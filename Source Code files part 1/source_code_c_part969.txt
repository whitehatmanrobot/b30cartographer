y,sizeof(void *) * m_nExtent);
//			register void** pTmp = (void **) CWin32DefaultArena::WbemMemReAlloc(m_pArray, sizeof(void *) * m_nExtent);
			if (pTmp == 0)
				return out_of_memory;
            m_pArray =  pTmp;
		}
        else
		m_pArray = (void **)g_pIMalloc->Alloc(sizeof(void *) * m_nExtent);
		//            m_pArray = (void **) CWin32DefaultArena::WbemMemAlloc(sizeof(void *) * m_nExtent);    
        if (!m_pArray)
            return out_of_memory;                
    }

    return no_error;
}
        
    
//***************************************************************************
//
//  CFlexArray::InsertAt
//
//  Inserts a new element at the specified location.  The pointer is copied.
//
//  Parameters:
//  <nIndex>        The 0-origin location at which to insert the new element.
//  <pSrc>          The pointer to copy. (contents are not copied).
//
//  Return value:
//  array_full
//  out_of_memory
//  no_error
//
//***************************************************************************
// ok

int CFlexArray::InsertAt(int nIndex, void *pSrc)
{
    // TEMP: fix for sparse functionality in stdprov
    // =============================================

    while(nIndex > m_nSize)
        Add(NULL);

    // If the array is full, we need to expand it.
    // ===========================================
    
    if (m_nSize == m_nExtent) {
        if (m_nGrowByPercent == 0)
            return array_full;
		register nTmpExtent = m_nExtent;
        m_nExtent += 1;
        m_nExtent *= (100 + m_nGrowByPercent);
        m_nExtent /= 100;

        if(m_pArray)
		{
			register void** pTmp = (void **)g_pIMalloc->Realloc(m_pArray,sizeof(void *) * m_nExtent);
//			register void** pTmp = (void **) CWin32DefaultArena::WbemMemReAlloc(m_pArray, sizeof(void *) * m_nExtent);
			if (pTmp == 0)
			{
				m_nExtent = nTmpExtent;	//Change it back, otherwise the extent could constantly grow even though  it keeps failing...
				return out_of_memory;
			}
            m_pArray =  pTmp;
		}
        else
			m_pArray = (void **)g_pIMalloc->Alloc(sizeof(void *) * m_nExtent);
//            m_pArray = (void **) CWin32DefaultArena::WbemMemAlloc(sizeof(void *) * m_nExtent);    
        if (!m_pArray)
            return out_of_memory;                
    }

    // Special case of appending.  This is so frequent
    // compared to true insertion that we want to optimize.
    // ====================================================
    
    if (nIndex == m_nSize) {
        m_pArray[m_nSize++] = pSrc;
        return no_error;
    }
    
    // If here, we are inserting at some random location.
    // We start at the end of the array and copy all the elements 
    // one position farther to the end to make a 'hole' for
    // the new element.
    // ==========================================================

    // Account for nIndex being 0 based and m_nSize being 1 based
	MoveMemory( &m_pArray[nIndex+1], &m_pArray[nIndex], ( m_nSize - nIndex ) * sizeof(void *) );

    m_pArray[nIndex] = pSrc;
    m_nSize++;
            
    return no_error;    
}

void CFlexArray::Sort()
{
    if(m_pArray)
        qsort((void*)m_pArray, m_nSize, sizeof(void*), CFlexArray::CompareEls);
}

int __cdecl CFlexArray::CompareEls(const void* pelem1, const void* pelem2)
{
    return *(int*)pelem1 - *(int*)pelem2;
}
//***************************************************************************
//
//  CFlexArray::DebugDump
//
//***************************************************************************
void CFlexArray::DebugDump()
{
    printf("----CFlexArray Debug Dump----\n");
    printf("m_pArray = 0x%P\n", m_pArray);
    printf("m_nSize = %d\n", m_nSize);
    printf("m_nExtent = %d\n", m_nExtent);
    printf("m_nGrowByPercent = %d\n", m_nGrowByPercent);

    for (int i = 0; i < m_nExtent; i++)
    {
        if (i < m_nSize)
            printf("![%P] = %X\n", i, m_pArray[i]);
        else
            printf("?[%P] = %X\n", i, m_pArray[i]);                    
    }        
}

//***************************************************************************
//
//  CFlexArray::Compress
//
//  Removes NULL elements by moving all non-NULL pointers to the beginning
//  of the array.  The array "Size" changes, but the extent is untouched.
//
//***************************************************************************
// ok

void CFlexArray::Compress()
{
    int nLeftCursor = 0, nRightCursor = 0;
    
    while (nLeftCursor < m_nSize - 1) {
        if (m_pArray[nLeftCursor]) {
            nLeftCursor++;
            continue;
        }
        else {
            nRightCursor = nLeftCursor + 1;
            while ( nRightCursor < m_nSize && m_pArray[nRightCursor] == 0 )
                nRightCursor++;
            if (nRightCursor == m_nSize)
                break;  // Short circuit, no more nonzero elements.
            m_pArray[nLeftCursor] = m_pArray[nRightCursor];
            m_pArray[nRightCursor] = 0;                                            
        }                    
    }
    
    Trim();
}    

void CFlexArray::Trim()
{
    while (m_nSize >  0 && m_pArray[m_nSize - 1] == NULL) m_nSize--;
}

//***************************************************************************
//
//  CFlexArray::Empty
//
//  Clears the array of all pointers (does not deallocate them) and sets
//  its apparent size to zero.
//
//***************************************************************************
// ok
void CFlexArray::Empty()
{
	g_pIMalloc->Free(m_pArray);
//    CWin32DefaultArena::WbemMemFree(m_pArray);
    m_pArray = NULL;
    m_nSize = 0;
    m_nExtent = 0;
}

//***************************************************************************
//
//  CFlexArray::UnbindPtr
//
//  Empties the array and returns the pointer to the data it contained
//
//***************************************************************************

void** CFlexArray::UnbindPtr()
{
    void** pp = m_pArray;
    m_pArray = NULL;
    Empty();
    return pp;
}

//***************************************************************************
//
//  CFlexArray::CopyData
//
//  Copies the data but not the settings of another flexarray
//
//***************************************************************************

int CFlexArray::CopyDataFrom(const CFlexArray& aOther)
{
    // Check if there is enough room
    // =============================

    if(aOther.m_nSize > m_nExtent)
    {
        // Extend the array to the requisite size
        // ======================================

        m_nExtent = aOther.m_nSize;
        if(m_pArray)
		{
			register void** pTmp = (void **)g_pIMalloc->Realloc(m_pArray,sizeof(void *) * m_nExtent);
//			register void** pTmp = (void **) CWin32DefaultArena::WbemMemReAlloc(m_pArray, sizeof(void *) * m_nExtent);
			if (pTmp == 0)
				return out_of_memory;
            m_pArray =  pTmp;
		}
        else
			m_pArray = (void **)g_pIMalloc->Alloc(sizeof(void *) * m_nExtent);
//            m_pArray = (void **) CWin32DefaultArena::WbemMemAlloc(sizeof(void *) * m_nExtent);    
        if (!m_pArray)
            return out_of_memory;                
    }

    // Copy the data
    // =============

    m_nSize = aOther.m_nSize;
    memcpy(m_pArray, aOther.m_pArray, sizeof(void*) * m_nSize);
    return no_error;
}

//***************************************************************************
//
//  CWStringArray::CWStringArray
//
//  Constructs a wide-string array.
//
//  Parameters:
//  <nSize>         The starting preallocated size of the array.
//  <nGrowBy>       The amount to grow by when the array fills up.
//
//  Size() returns the number of elements in use, not the 'true' size.
//
//***************************************************************************

CWStringArray::CWStringArray(
        int nSize, 
        int nGrowBy
        )
        : 
        m_Array(nSize, nGrowBy)
{
}        

//***************************************************************************
//
//  Copy constructor.
//
//***************************************************************************

CWStringArray::CWStringArray(CWStringArray &Src)
{
    
    *this = Src;    
}

//***************************************************************************
//
//  Destructor.  Cleans up all the strings.
//
//***************************************************************************

CWStringArray::~CWStringArray()
{
    Empty();
}

//***************************************************************************
//
//  CWStringArray::DeleteStr
//
//  Frees the string at the specified index and sets the element to NULL.  
//  Does not compress array.
// 
//  Does not currently do a range check.
//
//  Parameters:
//  <nIndex>    The 0-origin index of the string to remove.
//
//  Return values:
//  no_error
//  
//***************************************************************************

int CWStringArray::DeleteStr(int nIndex)
{
	g_pIMalloc->Free(m_Array[nIndex]);
    m_Array[nIndex] = 0;
    return no_error;
}   

//***************************************************************************
//
//  CWStringArray::FindStr
//
//  Finds the specified string and returns its location.
//
//  Parameters:
//  <pTarget>       The string to find.
//  <nFlags>        <no_case> or <with_case>
//  
//  Return value:
//  The 0-origin location of the string, or -1 if not found.
//
//***************************************************************************

int CWStringArray::FindStr(const wchar_t *pTarget, int nFlags)
{
    if (nFlags == no_case) {
        for (int i = 0; i < m_Array.Size(); i++)
            if (wbem_wcsicmp((wchar_t *) m_Array[i], pTarget) == 0)
                return i;
    }
    else {
        for (int i = 0; i < m_Array.Size(); i++)
            if (wcscmp((wchar_t *) m_Array[i], pTarget) == 0)
                return i;
    }
    return not_found;
}

//***************************************************************************
//
//  operator =
//  
//***************************************************************************

//  Heap handle & allocation functions are not copied. This allows
//  transfer of arrays between heaps.
         
CWStringArray& CWStringArray::operator =(CWStringArray &Src)
{
    Empty();
    
    for (int i = 0; i < Src.Size(); i++) 
    {
        wchar_t *pSrc = (wchar_t *) Src.m_Array[i];
        wchar_t *pCopy = (wchar_t *) g_pIMalloc->Alloc((wcslen(pSrc) + 1) * 2);
//        wchar_t *pCopy = (wchar_t *) CWin32DefaultArena::WbemMemAlloc((wcslen(pSrc) + 1) * 2);

		// Check for allocation failures
		if ( NULL == pCopy )
		{
			throw CX_MemoryException();
		}

        wcscpy(pCopy, pSrc);

        if ( m_Array.Add(pCopy) != CFlexArray::no_error )
		{
			throw CX_MemoryException();
		}
    }

    return *this;
}

//***************************************************************************
//
//  CWStringArray::Add
//
//  Appends a new string to the end of the array.
//
//  Parameters:
//  <pSrc>      The string to copy.
//
//  Return value:
//  The return values of CFlexArray::Add.
//  
//***************************************************************************
    
int CWStringArray::Add(const wchar_t *pSrc)
{
    wchar_t *pNewStr = (wchar_t *) g_pIMalloc->Alloc((wcslen(pSrc) + 1) * 2);
//    wchar_t *pNewStr = (wchar_t *) CWin32DefaultArena::WbemMemAlloc((wcslen(pSrc) + 1) * 2);

	// Check for allocation failures
	if ( NULL == pNewStr )
	{
		return out_of_memory;
	}

    wcscpy(pNewStr, pSrc);
    return m_Array.Add(pNewStr);
}
//***************************************************************************
//
//  CWStringArray::InsertAt
//
//  Inserts a copy of a string in the array.
//
//  Parameters:
//  <nIndex>    The 0-origin location at which to insert the string.
//  <pSrc>      The string to copy.
//
//  Return values:
//  The return values of CFlexArray::InsertAt
//
//***************************************************************************

int CWStringArray::InsertAt(int nIndex, const wchar_t *pSrc)
{
    wchar_t *pNewStr = (wchar_t *) g_pIMalloc->Alloc((wcslen(pSrc) + 1) * 2);
//    wchar_t *pNewStr = (wchar_t *) CWin32DefaultArena::WbemMemAlloc((wcslen(pSrc) + 1) * 2);

	// Check for allocation failures
	if ( NULL == pNewStr )
	{
		return out_of_memory;
	}

    wcscpy(pNewStr, pSrc);
    return m_Array.InsertAt(nIndex, pNewStr);
}


//***************************************************************************
//
//  CWStringArray::RemoveAt
//
//  Removes and deallocates the string at the specified location.
//  Shrinks the array.
//
//  Parameters:
//  <nIndex>    The 0-origin index of the 'doomed' string.
//  
//  Return value:
//  Same as CFlexArray::RemoveAt.
//
//***************************************************************************

int CWStringArray::RemoveAt(int nIndex)
{
    wchar_t *pDoomedString = (wchar_t *) m_Array[nIndex];
	g_pIMalloc->Free(pDoomedString);
//    CWin32DefaultArena::WbemMemFree(pDoomedString);
    return m_Array.RemoveAt(nIndex);
}

//***************************************************************************
//
//  CWStringArray::SetAt
//
//  Replaces the string at the targeted location with the new one.
//  The old string at the location is cleaned up.
//
//  No range checking or out-of-memory checks at present.
//
//  Parameters:
//  <nIndex>        The 0-origin location at which to replace the string.
//  <pSrc>          The string to copy.  
//
//  Return value:
//  no_error
//   
//***************************************************************************

int CWStringArray::SetAt(int nIndex, const wchar_t *pSrc)
{
    wchar_t *pNewStr = (wchar_t *) g_pIMalloc->Alloc((wcslen(pSrc) + 1) * 2);
//    wchar_t *pNewStr = (wchar_t *) CWin32DefaultArena::WbemMemAlloc((wcslen(pSrc) + 1) * 2);
	// Check for allocation failures
	if ( NULL == pNewStr )
	{
		return out_of_memory;
	}

    wchar_t *pDoomedString = (wchar_t *) m_Array[nIndex];
    if (pDoomedString)
		g_pIMalloc->Free(pDoomedString);
//        CWin32DefaultArena::WbemMemFree(pDoomedString);

    wcscpy(pNewStr, pSrc);
    m_Array[nIndex] = pNewStr;

    return no_error;
}

//***************************************************************************
//
//  CWStringArray::ReplaceAt
//
//  Directly replaces the pointer at the specified location with the
//  one in the parameter.   No copy or cleanup.
//
//  Parameters:
//  <nIndex>     The 0-origin location at which to replace.
//  <pSrc>       The new pointer to copy over the old one.
//
//  Return value:
//  no_error        (No checking done at present).
//  
//***************************************************************************

int CWStringArray::ReplaceAt(int nIndex, wchar_t *pSrc)
{
    m_Array[nIndex] = pSrc;
    return no_error;
}



//***************************************************************************
//
//  CWStringArray::Empty
//
//  Empties the array, deallocates all strings, and sets the apparent
//  array size to zero.
//
//***************************************************************************

void CWStringArray::Empty()
{
    for (int i = 0; i < m_Array.Size(); i++)
		g_pIMalloc->Free(m_Array[i]);
//        CWin32DefaultArena::WbemMemFree(m_Array[i]);
    m_Array.Empty();        
}

//***************************************************************************
//
//  CWStringArray::Sort
//
//  Sorts the array according to UNICODE order.  
//  (Shell sort).
//
//***************************************************************************
void CWStringArray::Sort()
{
    for (int nInterval = 1; nInterval < m_Array.Size() / 9; nInterval = nInterval * 3 + 1);    

    while (nInterval) 
    {
        for (int iCursor = nInterval; iCursor < m_Array.Size(); iCursor++) 
        {
            int iBackscan = iCursor;
            while (iBackscan - nInterval >= 0 &&
               wbem_wcsicmp((const wchar_t *) m_Array[iBackscan],
                    (const wchar_t *) m_Array[iBackscan-nInterval]) < 0) 
            {
                wchar_t *pTemp = (wchar_t *) m_Array[iBackscan - nInterval];
                m_Array[iBackscan - nInterval] = m_Array[iBackscan];
                m_Array[iBackscan] = pTemp;
                iBackscan -= nInterval;
            }
        }
        nInterval /= 3;
    }
}


//***************************************************************************
//
//  CWStringArray::Difference
//
//  Set-theoretic difference operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array which is 'subtracted' from first (not modified).    
//  <Diff>      Receives the difference.  Should be an empty array on entry.
//
//***************************************************************************
void CWStringArray::Difference(
    CWStringArray &Src1, 
    CWStringArray &Src2,
    CWStringArray &Diff
    )
{
    for (int i = 0; i < Src1.Size(); i++)
	{
        if (Src2.FindStr(Src1[i], no_case) == -1)
		{
            if ( Diff.Add(Src1[i]) != no_error )
			{
				throw CX_MemoryException();
			}
		}
	}
}

//***************************************************************************
//
//  CWStringArray::Intersection
//
//  Set-theoretic intersection operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array (not modified).    
//  <Diff>      Receives the intersection.  Should be an empty array on entry.

//***************************************************************************

void CWStringArray::Intersection(
    CWStringArray &Src1,
    CWStringArray &Src2,
    CWStringArray &Output
    )
{
    for (int i = 0; i < Src1.Size(); i++)
	{
        if (Src2.FindStr(Src1[i], no_case) != -1)
		{
            if ( Output.Add(Src1[i]) != no_error )
			{
				throw CX_MemoryException();
			}
		}

	}
}    

//***************************************************************************
//
//  CWStringArray::Union
//
//  Set-theoretic union operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array (not modified).    
//  <Diff>      Receives the union.  Should be an empty array on entry.
//
//***************************************************************************

void CWStringArray::Union(
    CWStringArray &Src1,
    CWStringArray &Src2,
    CWStringArray &Output
    )
{
    Output = Src1;
    for (int i = 0; i < Src2.Size(); i++)
	{
        if (Output.FindStr(Src2[i], no_case) == not_found)
		{
            if ( Output.Add(Src2[i]) != no_error )
			{
				throw CX_MemoryException();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\enumerat.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Enumeration Routines
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _ENUMERATOR_
#define _ENUMERATOR_

#include "critsec.h"

class CEnumeratorNameSpace;

/////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpISourcesRowset : public ISourcesRowset	
{
    public:
	
	    CImpISourcesRowset(CEnumeratorNameSpace *pCEnumeratorNameSpace)
        {
		    m_pCEnumeratorNameSpace = pCEnumeratorNameSpace;
            m_cRef = 0;
	    }
	    ~CImpISourcesRowset()
        {
        }

	    STDMETHODIMP_(ULONG) AddRef(void);
	    STDMETHODIMP_(ULONG) Release(void);
	    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);

	    STDMETHODIMP GetSourcesRowset( IUnknown	*pUnkOuter,	REFIID		riid, ULONG		cPropertySets, DBPROPSET	rgPropertySets[],	IUnknown	**ppvSourcesRowset	);

    private: 


	    CEnumeratorNameSpace	*m_pCEnumeratorNameSpace;
        ULONG m_cRef;

};

typedef CImpISourcesRowset * PIMPISOURCESROWSET;

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Create a moniker with the name passed to it.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpIParseDisplayName : public IParseDisplayName
{
    public:  
	
	    CImpIParseDisplayName(CEnumeratorNameSpace *pCEnumeratorNameSpace)
	    {
		    m_pCEnumeratorNameSpace = pCEnumeratorNameSpace;
            m_cRef = 0;

 	    }
	    ~CImpIParseDisplayName()
        {
        }

	    STDMETHODIMP_(ULONG) AddRef(void);
	    STDMETHODIMP_(ULONG) Release(void);
	    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
													    
	    STDMETHODIMP ParseDisplayName
	    (
		    IBindCtx	*pbc,				//Pointer to bind context
		    WCHAR		*pszDisplayName, 	//Pointer to string containing display name
		    ULONG		*pchEaten, 			//Length, in characters, of display name
		    IMoniker	**ppmkOut			//Pointer to moniker that results
	    );

    private: 

	    CEnumeratorNameSpace	*m_pCEnumeratorNameSpace;
        ULONG m_cRef;
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Contains a few interfaces and enumerates namespaces
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////
class CEnumeratorNameSpace : public CBaseObj
{
	
	friend  CImpISourcesRowset;
	friend  CImpIParseDisplayName;
	friend  CImpISupportErrorInfo;
	
public: //
	CEnumeratorNameSpace(LPUNKNOWN);
	~CEnumeratorNameSpace(void);

	STDMETHODIMP Initialize(void);

	inline CDataSource* GetDataSource()	{		return (CDataSource *)m_pCDataSource;		}
	inline CDBSession* GetSession()		{		return (CDBSession*)m_pCDBSession;		}

	STDMETHODIMP QueryInterface(REFIID, LPVOID *);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	
    protected: 

	    enum ENK{		ENK_DIDINIT = 0x0001,		};  // Values for m_dwStatus.
    	DWORD                   m_dwStatus;

	    LPUNKNOWN				m_pCDataSource;
	    LPUNKNOWN				m_pCDBSession;
	                                                    // Contained interfaces
    	CImpISourcesRowset		m_ISourcesRowset;	    // Contained ISourcesRowset
    	CImpIParseDisplayName	m_IParseDisplayName;    // Contained IParseDisplayName
	    CImpISupportErrorInfo*	m_pISupportErrorInfo;    // Contained ISupportErrorInfo

        HRESULT CreateDataSource();
		HRESULT AddInterfacesForISupportErrorInfo();


};	 //CEnumeratorNameSpace

typedef CEnumeratorNameSpace * PCENUMERATOR;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\errinf.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Error Routines
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef __ERROR_H__
#define __ERROR_H__

#include "headers.h"
#include "classfac.h"
///////////////////////////////////////////////////////////////////////////////////////////////////////
// Forward declarations ------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////////////
class CErrorLookup;
typedef CErrorLookup*			PCERRORLOOKUP;
class CImpIWMIErrorInfo;
typedef CImpIWMIErrorInfo*		PIMPIWMIERRORINFO;

///////////////////////////////////////////////////////////////////////////////////////////////////////
//----------------------------------------------------------------------------
// MACROS AND INLINE FUNCTIONS
//----------------------------------------------------------------------------
// The following macro takes the Data1 element of a guid and looks at the lower
// byte. Taking this value and a particular base value that would will yield a 
// number between 1 and 32, we can determine what bit in the DWORD to set on.
///////////////////////////////////////////////////////////////////////////////////////////////////////
#define PBIT(p1, base)  (DWORD)(1 << (((p1) & 0x000000FF) & ~(base)))


///////////////////////////////////////////////////////////////////////////////////////////////////////
const DWORD ERR_STATIC_STRING = 0x08000000; // NOTE: High Byte is reserved by IDENTIFIER_SDK_MASK
const DWORD INITIAL_SIZE_FOR_ERRORSTUFF = 32;
const DWORD INCREMENT_BY_FOR_ERRORSTUFF = 16;

typedef struct tagERRORSTUFF
{
	DWORD	dwDynamicId;		// Identification number for a set of errors
	UINT	uStringId;			// String id for standard error
	LONG	lNative;			// Native Error value
	HRESULT	hr;					// HRESULT
	WORD	wLineNumber;		// Batch/Procedue Line number
	WCHAR*	pwszServer;			// Server name
	WCHAR*	pwszProcedure;		// Procedure name
    WCHAR * pwszMessage;
} ERRORSTUFF, *PERRORSTUFF;


///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Class that maintains error data until we generate error records via IErrorRecords::AddErrorRecord
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
class CErrorData : public CFlexArray
{
    private: 
    	WORD			m_wStatus;

    public: 
    	CErrorData();
        ~CErrorData();

    	WORD WGetStatus(WORD w) const	{ return m_wStatus & w; }
	    void SetStatus(WORD w)			{ m_wStatus |= w; }
	    void ClearStatus(WORD w)		{ m_wStatus &= ~w; }

	    inline void GetLastError(PERRORSTUFF *ppErrorStuff)	{	assert(Size() > 0); *ppErrorStuff = (PERRORSTUFF)	GetAt(Size()-1);}

	    STDMETHODIMP InsertError(	ULONG	iInsert,			// IN | index to insert the error
		                            UINT	uStringId,			// IN | string ID for error
		                            LONG	lNative = 0	);		// IN | native error code

	    void PeekError( DWORD	*pdwStdError,		            // OUT | standard WMI error number (optional)
		                LONG	*plNativeError	);	            // OUT | native error number from WMI Server

	    STDMETHODIMP PostStandardError( UINT	uStringId,		// IN | string ID for error
		                                HRESULT	hrErr = S_OK,	// IN | hresult to associate
		                                LONG	lNative = 0	);	// IN | native eror code
    	STDMETHODIMP PostWMIError(	UINT	uStringId,			// IN | string ID for error
		                            LONG	lNative,			// IN | native error code
		                            WORD	wLineNumber,		// IN | batch/procedure line number
		                            LPCWSTR	pwszError,			// IN | error message
		                            LPCWSTR	pwszServer,			// IN | server name or NULL
		                            LPCWSTR pwszProcedure,		// IN | procedure name or NULL
		                            HRESULT	hrErr = S_OK		// IN | associated hresult
		                            );
	    inline STDMETHODIMP PostWinError(UINT uStringId){	return PostStandardError(uStringId, S_OK, (LONG)::GetLastError());	}
	    ULONG RemoveError(	LONG lNativeError );
	    void XferErrors(CErrorData* pCError);

	    enum EErrStatus	{
		    ERR_STATUS_OK 	    = 0x0000,
		    ERR_STATUS_OOM		= 0x0001,			//	Out-of-memory error occurred
		    ERR_STATUS_KEEP		= 0x0002,		};

	    ULONG SetPosError(HRESULT rc);

        void FreeErrors();
};

///////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpISupportErrorInfo : public ISupportErrorInfo	
{
    private:
        
	    ULONG           m_cRef;
    	IUnknown*		m_pUnkOuter;
		
    	GUID**	m_rgpErrInt;
    	ULONG			m_cpErrInt;
		ULONG			m_cAllocGuid;				// Number of allocate GUIDs

    public: 

		CImpISupportErrorInfo( IUnknown* pUnkOuter );
	    ~CImpISupportErrorInfo();

	    STDMETHODIMP_(ULONG) AddRef(void);
	    STDMETHODIMP_(ULONG) Release(void);
	    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);		

    	STDMETHODIMP InterfaceSupportsErrorInfo(REFIID riid);

		HRESULT AddInterfaceID(REFIID riid);

};

typedef CImpISupportErrorInfo* PIMPISUPPORTERRORINFO;
///////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpIErrorLookup : public IErrorLookup
{
    private: 
    	ULONG               m_cRef;
	    PCERRORLOOKUP		m_pCErrorLookup;

    public: 
    	CImpIErrorLookup(PCERRORLOOKUP pCErrorLookup){
		    DEBUGCODE(m_cRef = 0L);
		    m_pCErrorLookup = pCErrorLookup;
		    }
    	~CImpIErrorLookup() {}

	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);		
	STDMETHODIMP GetErrorDescription(HRESULT hrError, DWORD dwLookupId, DISPPARAMS*	pdispparams, LCID lcid,	 BSTR* ppwszSource,	BSTR* ppwszDescription);
	STDMETHODIMP GetHelpInfo(HRESULT hrError, DWORD dwMinor, LCID lcid, BSTR* ppwszHelpFile, DWORD* pdwHelpContext);
	STDMETHODIMP ReleaseErrors(const DWORD dwDynamicErrorId);
};

typedef CImpIErrorLookup*		PIMPIERRORLOOKUP;

///////////////////////////////////////////////////////////////////////////////////////////////////////
class CErrorLookup : public CBaseObj
{
	friend class CImpIErrorLookup;

    protected: 
	    CImpIErrorLookup	m_IErrorLookup;

    public: 
    	 CErrorLookup(LPUNKNOWN pUnkOuter);
	    ~CErrorLookup(void) {}

    	STDMETHODIMP			QueryInterface(REFIID, LPVOID *);
    	STDMETHODIMP_(ULONG)	AddRef(void);
    	STDMETHODIMP_(ULONG)	Release(void);
};

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Routines to maintain the internal posting, viewing and removal of error information.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
class CError
{
    private: 
	    ERRORINFO			m_ErrorInfo;
    	PERRORSTUFF*		m_prgErrorDex;
    	CCriticalSection*   m_pcsErrors;
    	ULONG				m_cErrors;
    	ULONG				m_cErrorsUsed;
    	ULONG				m_ulNext;
    	DWORD				m_dwId;
    	CFlexArray*		    m_pWMIErrorInfoCollection;


    private:
	    HRESULT	GetErrorInterfaces(IErrorInfo** ppIErrorInfo, IErrorRecords** ppIErrorRecords);

    public: 
    	CError();
    	~CError();
		
        HRESULT FInit();
        HRESULT	FindFreeDex(ULONG* pulDex);
    	inline static void ClearErrorInfo(void)	        { SetErrorInfo(0, NULL); 	}
        inline int Size()                               { return m_pWMIErrorInfoCollection->Size(); }
        inline void SetAt(int n, void *p)               { m_pWMIErrorInfoCollection->SetAt(n,p); }
    	inline HRESULT AddToCollection(CImpIWMIErrorInfo* pWMIErrorInfo);
    	inline void RemoveFromCollection(ULONG hObjCollection);
    	HRESULT GetErrorDescription(ULONG ulDex, BSTR* ppwszDescription);
        void RemoveErrors(DWORD dwDynamicId);
        void FreeErrors();

    	HRESULT PostError(HRESULT hrErr, const IID* piid, DWORD dwIds, DISPPARAMS* pdispparams);
    	HRESULT PostErrorMessage(HRESULT hrErr, const IID* piid, UINT uStringId, LPCWSTR pwszMessage);
    	HRESULT PostHResult(HRESULT hrErr, const IID* piid);
    	HRESULT PostWMIErrors(	HRESULT	hrErr, const IID*	piid, CErrorData*	pErrData);
};
////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpIWMIErrorInfo  
{
    private: 
	    ULONG		m_cRef;				
	    PERRORSTUFF	m_pErrStuff;		
	    ULONG 		m_hObjCollection;	

    public:
	    CImpIWMIErrorInfo(PERRORSTUFF pErrStuff);
	    ~CImpIWMIErrorInfo();
	    inline HRESULT FInit();
	    PERRORSTUFF GetErrorStuff(void) const { return m_pErrStuff; }
	    STDMETHODIMP			QueryInterface(REFIID, LPVOID *);
	    STDMETHODIMP_(ULONG)	AddRef(void);
	    STDMETHODIMP_(ULONG)	Release(void);
        STDMETHODIMP GetWMIInfo(BSTR* pbstrWMIInfo, LONG* plNativeError);
};

////////////////////////////////////////////////////////////////////////////////////////////////////////
inline HRESULT CError::AddToCollection(	CImpIWMIErrorInfo* pWMIErrorInfo	)
{ 
	CAutoBlock Crit(m_pcsErrors);
	HRESULT hr = m_pWMIErrorInfoCollection->Add(pWMIErrorInfo); 
	return hr;
};
////////////////////////////////////////////////////////////////////////////////////////////////////////
inline void CError::RemoveFromCollection(ULONG hObjCollection)
{ 
	CAutoBlock Crit(m_pcsErrors);
	m_pWMIErrorInfoCollection->RemoveAt(hObjCollection); 
}
    extern CError * g_pCError;

////////////////////////////////////////////////////////////////////////////////////////////////////////
inline HRESULT CImpIWMIErrorInfo::FInit()
{
	// For Abnormal Termination, add self to Collection
    if( g_pCError ){
	    return g_pCError->AddToCollection(this);
    }
    return -1;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\guids.h ===
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider 
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _GUIDS_H_
#define _GUIDS_H_


// {FD8D9C02-265E-11d2-98D9-00A0C9B7CBFE}
DEFINE_GUID(CLSID_WMIOLEDB,				0xfd8d9c02, 0x265e, 0x11d2, 0x98, 0xd9, 0x0, 0xa0, 0xc9, 0xb7, 0xcb, 0xfe);
DEFINE_GUID(CLSID_WMIOLEDB_ROOTBINDER,  0xcdcedb81, 0x5fec, 0x11d3, 0x9d, 0x1c, 0x0, 0xc0, 0x4f, 0x5f, 0x11, 0x64);
// {E14321B2-67C0-11d3-B3B4-00104BCC48C4}
DEFINE_GUID(CLSID_WMIOLEDB_ENUMERATOR,  0xe14321b2, 0x67c0, 0x11d3, 0xb3, 0xb4, 0x0, 0x10, 0x4b, 0xcc, 0x48, 0xc4);
//{80C4A61D-CB78-46fd-BD8F-8BF45BE46A4C}
DEFINE_GUID(CLSID_WMIOLEDB_ERRORLOOOKUP,  0x80C4A61D, 0xCB78, 0x46fd, 0xBD, 0x8F, 0x8B, 0xF4, 0x5B, 0xE4, 0x6A, 0x4C);

// {21B2028F-AD0A-11d3-B3CB-00104BCC48C4}
DEFINE_GUID(DBGUID_WQL, 0x21b2028f, 0xad0a, 0x11d3, 0xb3, 0xcb, 0x0, 0x10, 0x4b, 0xcc, 0x48, 0xc4);
// {18EC17EA-14D9-47fc-9722-2DCD8A1C3D70}
DEFINE_GUID(DBGUID_LDAP,0x18ec17ea, 0x14d9, 0x47fc, 0x97, 0x22, 0x2d, 0xcd, 0x8a, 0x1c, 0x3d, 0x70);
// {3718AA52-5F6E-4c2e-AAAE-383E69C0C928}
DEFINE_GUID(DBGUID_LDAPSQL,0x3718aa52, 0x5f6e, 0x4c2e, 0xaa, 0xae, 0x38, 0x3e, 0x69, 0xc0, 0xc9, 0x28);

// {D75984C0-8FFF-4d4c-835A-26BFAC6C01B7}
DEFINE_GUID(DBGUID_WMI_METHOD,0xd75984c0, 0x8fff, 0x4d4c, 0x83, 0x5a, 0x26, 0xbf, 0xac, 0x6c, 0x1, 0xb7);

// {CF60E9AB-F782-413c-B25D-DECE26E172D0}
DEFINE_GUID(DBOBJECT_WMIINSTANCE, 0xcf60e9ab, 0xf782, 0x413c, 0xb2, 0x5d, 0xde, 0xce, 0x26, 0xe1, 0x72, 0xd0);

 
DEFINE_GUID(DBPROPSET_WMIOLEDB_DBINIT, 0xdd497a71,0x9628,0x11d3,0x9d,0x5f,0x0,0xc0,0x4f,0x5f,0x11,0x64);
DEFINE_GUID(DBPROPSET_WMIOLEDB_ROWSET, 0x8d16c220,0x9bbb,0x11d3,0x9d,0x65,0x0,0xc0,0x4f,0x5f,0x11,0x64);
DEFINE_GUID(DBPROPSET_WMIOLEDB_COLUMN, 0x3ed51791,0x9c76,0x11d3,0x9d,0x66,0x0,0xc0,0x4f,0x5f,0x11,0x64);
DEFINE_GUID(DBPROPSET_WMIOLEDB_COMMAND,0xda0ff63c,0xad10,0x11d3,0xb3,0xcb,0x0,0x10,0x4b,0xcc,0x48,0xc4);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\headers.cpp ===
//--------------------------------------------------------------------
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// @doc
//
// @module HEADERS.CPP | precompiled headers module
//
//

// Includes ------------------------------------------------------------------

#include "headers.h"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\hashtbl.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Hashing routines for row manipulation.
//
/////////////////////////////////////////////////////////////////////////////////////
#include "headers.h"
#include "hashtbl.h"



/////////////////////////////////////////////////////////////////////////////////////////
// Constructor
/////////////////////////////////////////////////////////////////////////////////////////
_COLUMNDATA::_COLUMNDATA()
{
    dwLength = 0;
    dwStatus = 0;
    dwType = 0;
    pbData= NULL;
}
/////////////////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////////////////
_COLUMNDATA::~_COLUMNDATA()
{
    CDataMap Map;
    Map.FreeData(dwType,pbData);
}

/////////////////////////////////////////////////////////////////////////////////////////
// Function to set column information for the current column
// NTRaid:111827  111828
// 06/07/00
/////////////////////////////////////////////////////////////////////////////////////////
HRESULT _COLUMNDATA::SetData(CVARIANT & vVar , DWORD dwColType )
{
    HRESULT hr = S_OK;
    CDataMap Map;
	// NTRaid:111828
	// 06/13/00
	WORD wType = -1;
	// NTRaid:111827
	// 06/13/00
	DWORD dwFlags = 0;

    dwStatus = E_UNEXPECTED;

	//=================================================================
	// This will set the type of the column in _COLUMNDATA
	//=================================================================
	hr = Map.MapCIMTypeToOLEDBType(vVar.GetType(),wType,dwLength,dwFlags);
	dwType = wType;
	
	if( dwColType == CIM_DATETIME || dwColType == DBTYPE_DBTIMESTAMP)
	{
		dwType = CIM_DATETIME;
	}

	//=================================================================================
	// This is done so as  AllocateAndMapCIMTypeToOLEDBType should convert from
	// Variant DATE format to DBTIMESTAMP format
	//=================================================================================
	if( vVar.GetType() == VT_DATE)
	{
		dwType = VT_DATE;
	}

	if( dwColType == VT_VARIANT)
	{
		dwType = (DBTYPE)dwColType;
	}

	if(dwColType == CIM_IUNKNOWN)
	{
		dwType = CIM_IUNKNOWN;
	}

    hr = Map.AllocateAndMapCIMTypeToOLEDBType(vVar,pbData,dwType, dwLength,dwFlags);
    if(SUCCEEDED(hr)){
		//=============================================================================
		// SetData returns the status of the Data setting if it has not failed
		//=============================================================================
        dwStatus = hr;

		if((dwColType == (CIM_DATETIME | CIM_FLAG_ARRAY)) || (dwColType == (DBTYPE_DBTIMESTAMP | CIM_FLAG_ARRAY)) )
		{
			dwType = (DBTYPE)dwColType;
		}
		else
		if(dwType == CIM_IUNKNOWN)
		{
			dwType = DBTYPE_IUNKNOWN;
		}
		hr = S_OK;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
// Function to reset the column data. This frees column data
/////////////////////////////////////////////////////////////////////////////////////////
void _COLUMNDATA::ReleaseColumnData( )
{
	CDataMap Map;
	if(pbData != NULL)
	{
		Map.FreeData(dwType,pbData);
	}
}


/////////////////////////////////////////////////////////////////////////////////////////
// Get pointer to a particular columndata
/////////////////////////////////////////////////////////////////////////////////////////
PCOLUMNDATA tagRowBuff::GetColumnData(int iCol)
{
	return (pdData + iCol);
}

/////////////////////////////////////////////////////////////////////////////////////////
// Set the rowdata pointer
/////////////////////////////////////////////////////////////////////////////////////////
HRESULT tagRowBuff::SetRowData(PCOLUMNDATA pColData)
{
	pdData = pColData;
	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////////////
//
// Allocates a contiguous block of the required number of slots.
//
// Returns one of the following values:
//      S_OK           slot allocate succeeded
// 		E_OUTOFMEMORY  slot allocation failed because of memory allocation problem 
/////////////////////////////////////////////////////////////////////////////////////
HRESULT GetNextSlots  (    PLSTSLOT plstslot,  //IN  slot list
                            HSLOT cslot,       //IN  needed block size (in slots)
                            HSLOT* pislot      //IN  handle of the first slot in the returned block
    )
{
    HSLOT   islot, dslot;
    PSLOT   pslot, pslotTmp;
    LONG_PTR  cbCommit;
    HRESULT hr = S_OK;

    if (plstslot->islotRov)
	{
        plstslot->islotRov = ((PSLOT) & plstslot->rgslot[(plstslot->islotRov * plstslot->cbSlot)-sizeof(SLOT)])->islotNext;
	}
    else
	{
        plstslot->islotRov = plstslot->islotFirst;
	}

    islot = plstslot->islotRov;
    while (islot)
    {
        if (((PSLOT) & plstslot->rgslot[(islot *plstslot->cbSlot)-sizeof(SLOT)])->cslot >= cslot)
		{
            break;
		}
        islot = ((PSLOT) & plstslot->rgslot[(islot *plstslot->cbSlot)-sizeof(SLOT)])->islotNext;
    }
    if (islot == 0)
    {
        islot = plstslot->islotFirst;
        while (islot != plstslot->islotRov)
        {
            if (((PSLOT) & plstslot->rgslot[(islot *plstslot->cbSlot)-sizeof(SLOT)])->cslot >= cslot)
			{
                break;
			}
            islot = ((PSLOT) & plstslot->rgslot[(islot *plstslot->cbSlot)-sizeof(SLOT)])->islotNext;
        }
        if (islot == plstslot->islotRov)
            islot = 0;
    }

    if (islot == 0)
    {
        cbCommit = ((cslot *plstslot->cbSlot) / plstslot->cbPage + 1) *plstslot->cbPage;
        if ((plstslot->cbCommitCurrent + cbCommit) > plstslot->cbCommitMax
            || VirtualAlloc((VOID *) ((BYTE *) plstslot + plstslot->cbCommitCurrent),
                                    cbCommit,
                                    MEM_COMMIT,
                                    PAGE_READWRITE ) == NULL)
		{
            hr =  E_OUTOFMEMORY ;
		}
		else
		{
			islot = (HSLOT) ((plstslot->cbCommitCurrent + plstslot->cbExtra) / plstslot->cbSlot);
			dslot = ((cbCommit + plstslot->cbslotLeftOver) / plstslot->cbSlot);
			if ((plstslot->pbitsSlot)->IsSlotSet( islot - 1 ) != NOERROR)
			{
				if ((plstslot->pbitsSlot)->FindSet( islot - 1, plstslot->islotMin, &islot ) == NOERROR)
				{
					islot++;
				}
				else
				{
					islot = plstslot->islotMin;
				}
				pslot = (PSLOT) & plstslot->rgslot[(islot *plstslot->cbSlot)-sizeof(SLOT)];
				pslot->cslot += dslot;
				DecoupleSlot( plstslot, islot, pslot );
			}
			else
			{
//				pslot = (PSLOT) ((BYTE *) plstslot + plstslot->cbCommitCurrent - plstslot->cbslotLeftOver);
				pslot = (PSLOT) & plstslot->rgslot[(islot *plstslot->cbSlot)-sizeof(SLOT)];
				pslot->cslot = dslot;
			}

			pslot->islotNext = plstslot->islotFirst;
			pslot->islotPrev = 0;

			plstslot->islotMax += dslot;
			plstslot->islotFirst       = islot;
			plstslot->cbslotLeftOver   = (cbCommit + plstslot->cbslotLeftOver) % plstslot->cbSlot;
			plstslot->cbCommitCurrent += cbCommit;

			if (pslot->islotNext)
			{
				((PSLOT) & plstslot->rgslot[(pslot->islotNext *plstslot->cbSlot)-sizeof(SLOT)])->islotPrev = islot;
			}
			islot = plstslot->islotFirst;
		}
    }
	if(SUCCEEDED(hr))
	{
		pslot = (PSLOT) & plstslot->rgslot[(islot *plstslot->cbSlot)-sizeof(SLOT)];
		DecoupleSlot( plstslot, islot, pslot );
		if (pslot->cslot > cslot)
		{
			pslotTmp = (PSLOT) & plstslot->rgslot[ ((islot + cslot) *plstslot->cbSlot)-sizeof(SLOT)];
			pslotTmp->cslot = pslot->cslot - cslot;
			AddSlotToList( plstslot, islot + cslot, pslotTmp );
		}

		if (SUCCEEDED( hr = (plstslot->pbitsSlot)->SetSlots( islot, islot + cslot - 1 )))
		{
			if (pislot)
			{
				*pislot = islot;
			}
		}
	}
    return  hr;
}


/////////////////////////////////////////////////////////////////////////////////////
//
//  Decouples a slot from the list of free slots
//
//  NONE
//
/////////////////////////////////////////////////////////////////////////////////////

VOID DecoupleSlot    (   PLSTSLOT plstslot,  //IN  slot list
                         HSLOT islot,        //IN  slot handle to decouple
                         PSLOT pslot         //IN  pointer to the slot header
                    )
{
	PSLOT slotTemp = NULL;
    if (pslot->islotNext)
	{
		slotTemp = (PSLOT) & plstslot->rgslot[(pslot->islotNext *plstslot->cbSlot)-sizeof(SLOT)];
		slotTemp->islotNext = pslot->islotPrev;
        ((PSLOT) & plstslot->rgslot[(pslot->islotNext *plstslot->cbSlot)-sizeof(SLOT)])->islotPrev = pslot->islotPrev;
	}
    if (pslot->islotPrev)
	{
        ((PSLOT) & plstslot->rgslot[(pslot->islotPrev *plstslot->cbSlot)-sizeof(SLOT)])->islotNext = pslot->islotNext;
	}
    else
	{
        plstslot->islotFirst = pslot->islotNext;
	}
    if (islot == plstslot->islotRov)
	{
        plstslot->islotRov = pslot->islotNext;
	}
}


/////////////////////////////////////////////////////////////////////////////////////
//
//  Adds a slot to the list of free slots
//
//  NONE
//
/////////////////////////////////////////////////////////////////////////////////////
VOID AddSlotToList  (    PLSTSLOT plstslot,  //IN  slot list
                         HSLOT islot,        //IN  slot handle
                         PSLOT pslot         //IN  pointer to the slot header
    )
{
    pslot->islotPrev = 0;
    pslot->islotNext = plstslot->islotFirst;
    plstslot->islotFirst = islot;
    if (pslot->islotNext)
	{
        ((PSLOT) & plstslot->rgslot[(pslot->islotNext *plstslot->cbSlot)-sizeof(SLOT)])->islotPrev = islot;
	}
}


/////////////////////////////////////////////////////////////////////////////////////
// ReleaseSlots
//
//  Releases a contiguous block of slots.
//
//  Returns one of the following values:
//         S_OK | method succeeded
//
/////////////////////////////////////////////////////////////////////////////////////
HRESULT ReleaseSlots (   PLSTSLOT plstslot,  //IN  slot list
                         HSLOT    islot,     //IN  handle of first slot to release 
                         ULONG_PTR    cslot      //IN  count of slots to release
    )
{
    PSLOT pslot, pslotTmp;

    (plstslot->pbitsSlot)->ResetSlots( islot, islot + cslot - 1 );
    pslot = (PSLOT) & plstslot->rgslot[(islot * plstslot->cbSlot)-sizeof(SLOT)];
    pslot->cslot = cslot;

    if (islot > plstslot->islotMin && (plstslot->pbitsSlot)->IsSlotSet( islot - 1 ) != NOERROR)
    {
        if ((plstslot->pbitsSlot)->FindSet( islot - 1, plstslot->islotMin, &islot ) == NOERROR)
		{
            islot++;
		}
        else
		{
            islot = plstslot->islotMin;
		}
        pslot = (PSLOT) & plstslot->rgslot[(islot * plstslot->cbSlot)-sizeof(SLOT)];
        pslot->cslot += cslot;
        DecoupleSlot( plstslot, islot, pslot );
    }
	else	
    if ((islot + cslot) <= (ULONG_PTR)plstslot->islotMax && (plstslot->pbitsSlot)->IsSlotSet( islot + cslot ) != NOERROR)
    {
        pslotTmp = (PSLOT) & plstslot->rgslot[ ((islot + cslot) *plstslot->cbSlot)-sizeof(SLOT)];
        pslot->cslot += pslotTmp->cslot;
        DecoupleSlot( plstslot, (islot + cslot), pslotTmp );
    }

    AddSlotToList( plstslot, islot, pslot );
    return  S_OK ;
}

/////////////////////////////////////////////////////////////////////////////////////
//
//  Initializes the Slot List object
//
//  Did the initialization succeed
//       S_OK          | method succeeded
//       E_OUTOFMEMORY | failed, out of memory
//           
/////////////////////////////////////////////////////////////////////////////////////
HRESULT InitializeSlotList(    ULONG_PTR cslotMax,         //IN  max number of slots
                               ULONG_PTR cbSlot,           //IN  slot size (row buffer size)
                               ULONG_PTR cbPage,           //IN  page size
                               LPBITARRAY pbits,       //IN  
                               PLSTSLOT* pplstslot,    //OUT  pointer to slot list
                               BYTE** prgslot          //OUT  
    )
{
    LONG_PTR	cbReserve;
    BYTE     *	pbAlloc;
    ULONG_PTR   cbCommitFirst;
    PLSTSLOT	plstslot;
    ULONG_PTR   cslot, islotFirst;
    PSLOT		pslot;
	HRESULT		hr = S_OK;


    if (cbPage == 0)
    {
        SYSTEM_INFO sysinfo;

        GetSystemInfo( &sysinfo );
        cbPage = sysinfo.dwPageSize;
    }

    // Add in the LSTSLOT and SLOT
	cbSlot = cbSlot + (sizeof( LSTSLOT ) + sizeof( SLOT ));
	cbReserve = ((cslotMax *(cbSlot + (sizeof( LSTSLOT ) + sizeof( SLOT )))) / cbPage + 1) *cbPage;

    pbAlloc = (BYTE *) VirtualAlloc( NULL, cbReserve, MEM_RESERVE, PAGE_READWRITE );
    if (pbAlloc == NULL)
	{
        hr = E_OUTOFMEMORY ;
	}
	else
	{

		cbCommitFirst = ((sizeof( LSTSLOT ) + sizeof( SLOT )) / cbPage + 1) * cbPage;
		plstslot = (PLSTSLOT) VirtualAlloc( pbAlloc, cbCommitFirst, MEM_COMMIT, PAGE_READWRITE );
		if (plstslot == NULL)
		{
			VirtualFree((VOID *) pbAlloc, 0, MEM_RELEASE );
			hr = E_OUTOFMEMORY ;
		}
		else
		{

			plstslot->cbSlot          = cbSlot;
			plstslot->cbPage          = cbPage;
			plstslot->cbCommitCurrent = cbCommitFirst;
			plstslot->cbCommitMax     = cbReserve;
			plstslot->pbitsSlot       = pbits;


			if (cbSlot <= 2*(sizeof( LSTSLOT ) + sizeof( SLOT )))
			{
				islotFirst        = (sizeof( LSTSLOT ) + sizeof( SLOT )) / cbSlot + (((sizeof( LSTSLOT ) + sizeof( SLOT )) % cbSlot) ? 1 : 0);
				plstslot->cbExtra = 0;
				cslot = (ULONG_PTR) ((cbCommitFirst / cbSlot) - islotFirst);
				plstslot->cbslotLeftOver = cbCommitFirst - cbSlot * (cslot + islotFirst);
			}
			else
			{
				islotFirst        = 1;
				plstslot->cbExtra = cbSlot - (sizeof( LSTSLOT ) + sizeof( SLOT ));
				cslot = (cbCommitFirst - (sizeof( LSTSLOT ) + sizeof( SLOT ))) / cbSlot;
				plstslot->cbslotLeftOver = cbCommitFirst - (sizeof( LSTSLOT ) + sizeof( SLOT )) - cslot*cbSlot;
			}
			plstslot->rgslot = ((BYTE *) plstslot - plstslot->cbExtra);
			if (cslot)
			{
				plstslot->islotFirst = islotFirst;
				pslot = (PSLOT) & plstslot->rgslot[(islotFirst *plstslot->cbSlot)-sizeof(SLOT)];
				pslot->cslot     = cslot;
				pslot->islotNext = 0;
				pslot->islotPrev = 0;
			}
			else
			{
				plstslot->islotFirst = 0;
			}
			plstslot->islotMin   = islotFirst;
			plstslot->islotMax   = islotFirst + cslot - 1;
			plstslot->islotRov = plstslot->islotFirst;

			*pplstslot = plstslot;
			*prgslot   = plstslot->rgslot;
		}
	}
    
	return  hr ;
}


/////////////////////////////////////////////////////////////////////////////////////
//
//  Restore slot list to newly-initiated state
//
//  
//   S_OK  | method succeeded
//
/////////////////////////////////////////////////////////////////////////////////////
HRESULT ResetSlotList   (   PLSTSLOT plstslot    )
{
    ULONG_PTR   cslot;
    PSLOT   pslot;

    cslot = (plstslot->islotMax >= plstslot->islotMin) ? (plstslot->islotMax - plstslot->islotMin + 1) : 0;
    if (cslot)
    {
        plstslot->islotFirst = plstslot->islotMin;
        pslot = (PSLOT) & plstslot->rgslot[(plstslot->islotFirst *plstslot->cbSlot)-sizeof(SLOT)];
        pslot->cslot     = cslot;
        pslot->islotNext = 0;
        pslot->islotPrev = 0;
    }
    else
	{
        plstslot->islotFirst = 0;
	}

    plstslot->islotRov = plstslot->islotFirst;
    return  S_OK ;
}

/////////////////////////////////////////////////////////////////////////////////////
//
//  Free slot list's memory
//
//  
//   S_OK  | method succeeded
//
/////////////////////////////////////////////////////////////////////////////////////
HRESULT ReleaseSlotList  (  PLSTSLOT plstslot   )
{
    if (plstslot != NULL)
	{
		if (plstslot->cbCommitCurrent)
		{
			VirtualFree((VOID *) plstslot, plstslot->cbCommitCurrent, MEM_DECOMMIT );
		}

		VirtualFree((VOID *) plstslot, 0, MEM_RELEASE );
	}
    return  S_OK ;
}



/////////////////////////////////////////////////////////////////////////////////////
//	gets the buffer address for the slot
/////////////////////////////////////////////////////////////////////////////////////
ROWBUFF* GetRowBuffer(PLSTSLOT plstslot , HSLOT islot)
{
	BYTE *pTemp = & (plstslot->rgslot[(islot * plstslot->cbSlot)]);
	ROWBUFF * pBuff = (ROWBUFF *)&(plstslot->rgslot[(islot * plstslot->cbSlot)]);
	return pBuff;
}


/////////////////////////////////////////////////////////////////////////////////////////////
////////////		CHashTbl Implementation											/////////
/////////////////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------------
// CHashTbl::CHashTbl
//
// @mfunc CHashTbl constructor.
//
// @rdesc NONE
//-----------------------------------------------------------------------------------

CHashTbl::CHashTbl()
{
	m_rgwHash		= NULL;
	m_ulTableSize	= 0;
}


//-----------------------------------------------------------------------------------
// CHashTbl::~CHashTbl
//
// @mfunc CHashTbl destructor.
//
// @rdesc NONE
//-----------------------------------------------------------------------------------
CHashTbl::~CHashTbl()
	{
	if (m_rgwHash)
		g_pIMalloc->Free(m_rgwHash);
	}


//////////////////////////////////////////////////////////////////////////////////////
// CHashTbl::FInit
//
// Initialize the Hashtable object.
//
// Did the Initialization Succeed
//      TRUE   Initialization succeeded
//		FALSE  Initializtion failed
//////////////////////////////////////////////////////////////////////////////////////

BOOL  CHashTbl::FInit(PLSTSLOT	pLstSlot)
{

	BOOL bRet = TRUE;

	// Initialize the hashtable size
	m_ulTableSize = HASHTBLSIZE;

	// Allocate the table.
	m_rgwHash = (USHORT*)g_pIMalloc->Alloc(m_ulTableSize*sizeof(USHORT));
	if (m_rgwHash == NULL)
	{
		bRet = FALSE; 
	}
	else
	{
		memset(m_rgwHash, 0x00, m_ulTableSize*sizeof(USHORT)); // Initialize.
		m_pLstSlot = pLstSlot;
	}

	return bRet;
}

//////////////////////////////////////////////////////////////////////////////////////
// CHashTbl::InsertFindBmk
//
// Either only check if a given bookmark is already in the hashtable 
// (fFindOnly = TRUE), or check, and if it is not there, insert.
//
// Returns one of the following values:
// 		S_OK 			Bookmark found in the hashtable,
// 		S_FALSE			Bookmark not found, if fFindOnly = FALSE, the new row
//							  with this bookmark was inserted in the table.
//////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP  CHashTbl::InsertFindBmk
	(
	BOOL        fFindOnly,		//@parm IN  | FindOnly or Find/Insert
	HSLOT       iSlot,		//@parm IN  | handle of the rowbuffer to be inserted
	ULONG_PTR  	cbBmk,			//@parm IN  | bookmark length
	BYTE     	*pbBmk,			//@parm IN  | bookmark pointer
	ULONG_PTR	*pirowSlotFound	//@parm OUT | if bookmark found returns handle of the 
								//			  row that contains the bookmark
	)
{
	//NTRaid:111766
	// 06/07/00
	DBHASHVALUE BmkHash = 0;
	HROW		iSlotCurr = 0;
	PROWBUFF	prowbuffCur = NULL;
	HRESULT		hr			= S_FALSE;


	assert(cbBmk == BOOKMARKSIZE && pbBmk);
	assert(pirowSlotFound);

	// Hash the bookmark. The hash value indexes the hashtable element which, if
	// not empty, will contain the handle to the beginning of the list of rows whose
	// bookmarks hash to the same value. 
	HashBmk(cbBmk, pbBmk, &BmkHash);
	
	assert(BmkHash <= m_ulTableSize);

	iSlotCurr = m_rgwHash[BmkHash];
	// If the entry is non-zero, search the corresponding list for this bookmark.
	if (iSlotCurr)
	{
		prowbuffCur = GetRowBuffer(m_pLstSlot,iSlotCurr);
		iSlotCurr = 0;
		// Walk the overflow list looking for bookmark match.
		while (prowbuffCur)
		{
			assert(prowbuffCur->dwBmk && "Error attempting to compare bookmark on invalid row");
			
			// Compare the bookmarks
			if (cbBmk == prowbuffCur->cbBmk && cbBmk == BOOKMARKSIZE &&
				memcmp(&(prowbuffCur->dwBmk), pbBmk , BOOKMARKSIZE) == 0)
			{
				iSlotCurr = prowbuffCur->ulSlot;
				break;
			}
			prowbuffCur = prowbuffCur->prowbuffNext;
		}
	}

	// No insertion in the hashtable is needed or necessary.
	if (fFindOnly || iSlotCurr)
	{
		*pirowSlotFound = iSlotCurr;  // Return the index of the rowbuffer that has
										// this bookmark, or 0 if none.
		hr = iSlotCurr ? S_OK : S_FALSE;
	}
	else
	{

		// Get the pointer to the row to be inserted.
		prowbuffCur = GetRowBuffer(m_pLstSlot,iSlot);
		
		// Initialize the new node for the list.
		if (m_rgwHash[BmkHash])
		{
			prowbuffCur->prowbuffNext = GetRowBuffer(m_pLstSlot,(ULONG)MAKELONG(m_rgwHash[BmkHash], 0));
		}
		else
		{
			prowbuffCur->prowbuffNext = NULL;
		}

		prowbuffCur->wBmkHash     	  = (USHORT)BmkHash;
		prowbuffCur->ulSlot     	  = iSlot;

		// Always insert a new node at the beginning of the list.
		m_rgwHash[BmkHash] = LOWORD(iSlot);

		*pirowSlotFound = iSlot;
	}

	// S_FALSE signifies that originally there was no row with this bookmark
	// in the hashtable.
	return hr;
}



//////////////////////////////////////////////////////////////////////////////////////
// CRowset::HashBmk
//
// Hashes a fixed-size bookmark for a table of given size. 
//
// Returns one of the following values:
// 		S_OK 				Hashing  succeeded,
// 		E_INVALIDARG	 	Hashing failed because the bookmark was invalid 
//								  or the pointer to bookmark was NULL. 
//////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CHashTbl::HashBmk
	(
	DBBKMARK		cbBmk,
	const BYTE  *pbBmk,
	DBHASHVALUE	*pdwHashedValue)
{
	HRESULT hr = S_OK;
	if (cbBmk != BOOKMARKSIZE || pbBmk == NULL)
	{
		hr = E_INVALIDARG;
	}
	else
	{
		assert(pdwHashedValue);

		*pdwHashedValue = (*(UNALIGNED ULONG*)pbBmk) % m_ulTableSize;
	}
	return hr;
}


//////////////////////////////////////////////////////////////////////////////////////
// CHashTbl::DeleteBmk
//
//  Delete a bookmark corresponding to a given row from the hashtable.
//
// Returns one of the following values:
// 		S_OK 			Bookmark was found and deleted from the hashtable,
// 		S_FALSE			Bookmark was not found in the hashtable.
//////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP  CHashTbl::DeleteBmk
	(
	HSLOT  ulSlot //@parm IN | handle of the rowbuffer with bookmark to be deleted.
	)
{
	HSLOT		iSlotCur;
	USHORT		wBmkHash;
	HRESULT		hr = S_OK;
	PROWBUFF *	pprowbuffCur, prowbuffFirst;


	wBmkHash = GetRowBuffer(m_pLstSlot,ulSlot)->wBmkHash;
	
	iSlotCur = MAKELONG(m_rgwHash[wBmkHash], 0);
	//==============================================================
	// If there is a non-zero entry search the corresponding list.
	//==============================================================
	if (ulSlot)
	{
		pprowbuffCur  = &prowbuffFirst;
		prowbuffFirst = GetRowBuffer(m_pLstSlot,iSlotCur);
		while (*pprowbuffCur)
		{
			//===========================================================
			// To delete a row under a given index just compare indices,
			// no need to look at bookmarks.
			//===========================================================
			if (ulSlot == (*pprowbuffCur)->ulSlot)
			{
				break;
			}
			pprowbuffCur = &(*pprowbuffCur)->prowbuffNext;
		}
	
		if (*pprowbuffCur == NULL)
		{
			hr = S_FALSE;
		}
	}
	else
	{
		hr = S_FALSE;
	}

	if(hr == S_OK)
	{
		// Remove the row from the list.
		if (pprowbuffCur == &prowbuffFirst)
		{
			m_rgwHash[wBmkHash] = (USHORT)((prowbuffFirst->prowbuffNext) ?  (prowbuffFirst->prowbuffNext)->ulSlot : 0);
		}
		else
		{
			*pprowbuffCur = (*pprowbuffCur)->prowbuffNext;	
		}
	}
  	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\headers.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider 
//
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// A common header file included in all implementation files
////////////////////////////////////////////////////////////////////////////////////////////////////
#pragma message("Including precompiled header...")
#ifndef _HEADERS_H_
#define _HEADERS_H_
#include <assert.h>


#define DEBUGCODE(p) p
#define ASSERT(x) assert(x);
#define THISPROVIDER LOG_WMIOLEDB

//	Don't include everything from windows.h, but always bring in OLE 2 support
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif


#define INC_OLE2

// Basic Windows and OLE everything
#include <windows.h>
#include <accctrl.h>
#include <aclapi.h>
#include <limits.h>				
#include <stdio.h>				// vsnprintf, etc.
#include <stddef.h>				// offsetof, etc.
#include <wchar.h>				// swprintf
#include <Chstring.h>
#include <ProvExce.h>
#include <wbemcli.h>
#include <wbemutil.h>
#include <wbemtime.h>
#include <wmiutils.h>
#include "umi.h"
#include <flexarry.h>

//	OLE DB headers
#include "oledb.h"
#include "oledberr.h"

//	Data conversion library header
#include "msdadc.h"
#include "datamap.h"

// MSDASQL Guids (for conversion library guid)
#include "msdaguid.h"

#include "resource.h"
#include "urlparser.h"
#include "util.h"

//	General headers
#include "baseobj.h"
#include "wmiglobal.h"
#include "utilprop.h"

//#include "rc.h"

// GUIDs
#include "guids.h"

#include "critsec.h"
#include <autobloc.h>

//	CDataSource object and contained interface objects
#include "cwbemwrap.h"
/////////////////////////////////////////////////////////////////////////////////////////////
#include "oahelp.inl"
#include "wmioledbmap.h"
#include "datasrc.h"
#include "dataconvert.h"


#include "tranoptions.h"
// CDBSession object and contained interface objects
#include "dbsess.h"
//	CRowset object and contained interface objects
#include "Rowset.h"
#include "row.h"
#include "Binder.h"
#include "autobloc.h"
#include "schema.h"
#include "command.h"

#include "errinf.h"

#define WMIOLEDB L"WMIOLEDB"

class CGlobals
{
	static BOOL m_bInitialized;
public:
	CGlobals();
	~CGlobals();
	HRESULT Init();
};


#ifndef DECLARE_GLOBALS

    extern IMalloc *					g_pIMalloc;				// OLE2 task memory allocator
    extern HINSTANCE					g_hInstance;				// Instance Handle
    extern IDataConvert *				g_pIDataConvert;		// IDataConvert pointer

    extern CCriticalSection				m_CsGlobalError;
    extern CError *						g_pCError;
    extern IClassFactory*				g_pErrClassFact;
	extern BOOL							g_bIsAnsiOS;
	extern IClassFactory			*	g_pIWbemPathParser;
	extern CGlobals						g_cgGlobals;
	extern IClassFactory*				g_pIWbemCtxClassFac;


#else
    IMalloc *					g_pIMalloc				= NULL;		// OLE2 task memory allocator
    HINSTANCE					g_hInstance;						// Instance Handle
    IDataConvert *				g_pIDataConvert			= NULL;		// IDataConvert pointer

    CCriticalSection			m_CsGlobalError(FALSE);
    CError *					g_pCError				= NULL;

    IClassFactory*				g_pErrClassFact			= NULL;
	BOOL						g_bIsAnsiOS				= FALSE;
	IClassFactory			*	g_pIWbemPathParser		= FALSE;	// class factory pointer for Parser object
	IClassFactory*				g_pIWbemCtxClassFac		= NULL;

	CGlobals					g_cgGlobals;

#endif


#define ROWSET ((CRowset*)(m_pObj))
#define BASEROW ((CBaseRowObj*)(m_pObj))
#define DATASOURCE ((CDataSource*)(m_pObj))
#define BINDER ((CBinder*)(m_pObj))
#define COMMAND ((CCommand*)(m_pObj))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\ialtertable.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//	IAlterTable.cpp  - IAlterTable interface implementation
////////////////////////////////////////////////////////////////////////////////////////////////////
#include "headers.h"
#include "dbsess.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Modifies properties of columns 
//	In WMI terms modifies properties of a class
//
// Returns one of the following values:
//			S_OK						Altering the column succeeded
//			E_FAIL						AlterColumn failed due to a WMI error
//			DB_E_BADTABLEID				The TableID passed is invalid or bad
//			DB_E_NOCOLUMN				The ColumnID passed is invalid or bad
//			E_INVALIDARG				One of more arguments passed in not valid
//			DB_E_NOTSUPPORTED			The requested type of modification of column
//										not supported
////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImplIAlterTable::AlterColumn(DBID *              pTableID,
											DBID *              pColumnID,
											DBCOLUMNDESCFLAGS   ColumnDescFlags,
											DBCOLUMNDESC *      pColumnDesc)
{
	HRESULT hr = E_FAIL;
	WCHAR *pwcsTableName = NULL;

	//===================================================================
	//  Initialize incoming parameters
	//===================================================================

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(m_pObj->GetCriticalSection());

	// Clear ErrorInfo
	g_pCError->ClearErrorInfo();

	if(wcslen(pTableID->uName.pwszName) == 0 || pTableID->eKind != DBKIND_NAME)
	{
		hr = DB_E_BADTABLEID;
	}
	else
	if(wcslen(pColumnID->uName.pwszName) == 0 || pColumnID->eKind != DBKIND_NAME)
	{
		hr = DB_E_NOCOLUMN;
	}
	else
	if( pColumnDesc == NULL)
	{
		hr = E_INVALIDARG;
	}
	else
	if( pColumnDesc->dbcid.uName.pwszName == NULL)
	{
		hr = E_INVALIDARG;
	}
	else
	//===================================================================================
	//  Check the connection is valid & the alteration flags is supported or not
	//===================================================================================
	if(S_OK == (hr =CheckIfSupported(ColumnDescFlags)) &&
	 m_pObj->m_pCDataSource->m_pWbemWrap->ValidConnection() )
	{
	
		CWmiOleDBMap Map;
		if(SUCCEEDED(hr =Map.FInit(NO_QUALIFIERS,(LPWSTR)pTableID->uName.pwszName,m_pObj->m_pCDataSource->m_pWbemWrap)))
		{
			hr = Map.SetColumnProperties(pColumnDesc);
		}
		
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IAlterTable);

	CATCH_BLOCK_HRESULT(hr,L"IAlterTable::AlterColumn");
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Modifies some of the attributes of the class
//
// Returns one of the following values:
//			DB_E_NOTSUPPORTED			Altering the properties of table not supported
////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImplIAlterTable::AlterTable(DBID *      pTableID,
											DBID *      pNewTableID,
											ULONG       cPropertySets,
											DBPROPSET   rgPropertySet[])

{
	HRESULT hr = DB_E_NOTSUPPORTED;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Clear ErrorInfo
	g_pCError->ClearErrorInfo();

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IAlterTable);
	// return not supported as no TABLE Properties are supported

	CATCH_BLOCK_HRESULT(hr,L"IAlterTable::AlterTable");
	return hr;
}


HRESULT CImplIAlterTable::CheckIfSupported(DBCOLUMNDESCFLAGS   ColumnDescFlags)
{
	if(ColumnDescFlags == DBCOLUMNDESCFLAGS_PROPERTIES)
		return S_OK;
	else
		return DB_E_NOTSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\hashtbl.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider 
//
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Class Definitions for CHashTbl Class and miscellaneous bookmark functions
//
/////////////////////////////////////////////////////////////////////////////////////////
#ifndef _HASHTBL_H_
#define _HASHTBL_H_
#include "bitarray.h"
#include "dataconvert.h"

#define SIZE_64K			   65535			// Actually 64*1024-1
#define HASHTBLSIZE				500
#define BOOKMARKSIZE			sizeof(ULONG_PTR)

/////////////////////////////////////////////////////////////////////////////////////////
// This defines the data as stored within the row buffer. Each row has columns laid out 
// sequentially.  Use 'offsetof' when doing pointer addition. Note that it is important 
// to align these. Suggest ensuring quadword alignment for double and __int64.
/////////////////////////////////////////////////////////////////////////////////////////
typedef struct _COLUMNDATA{

    _COLUMNDATA();
    ~_COLUMNDATA();
    HRESULT SetData(CVARIANT & vVar, DWORD dwColType);
	void ReleaseColumnData();

	DBLENGTH	dwLength;	    // length of data 
	DBSTATUS	dwStatus;	    // status of column
    DBTYPE      dwType;
	BYTE *		pbData;	        // data here and beyond

} COLUMNDATA, *PCOLUMNDATA;


/////////////////////////////////////////////////////////////////////////////////////////
// This is the layout of a row.
//
// Note the unique arrangement of the hash chain pointers inside the row itself.
//
// Note also that the structure for columns is defined, and each row contains an array 
// of columns.
// Bookmarks are named separately from ColumnData, for clarity of usage.  The layout 
// directly matches COLUMNDATA, however. There are asserts which enforce this.
/////////////////////////////////////////////////////////////////////////////////////////
typedef struct tagRowBuff
{
	ULONG       ulRefCount;		// reference count of outstanding handles
	HSLOT		ulSlot;
	tagRowBuff *prowbuffNext;	// next row in bookmark hash chain
	USHORT      wBmkHash;		// hash value (redundant)
	VOID       *pbBmk;			// ptr  to bookmark
	ULONG       cbBmk;			// (dwLength) bookmark size, in bytes
	ULONG       dwBmkStatus;	// (dwStatus) bookmark status
	DBBKMARK    dwBmk;			// (bData)    bookmark value, , maybe row count
//	COLUMNDATA  cdData[1];		// Column data here and beyond (Bookmark should be here)
	COLUMNDATA  *pdData;		// Column data here and beyond (Bookmark should be here)

	PCOLUMNDATA GetColumnData(int iCol);	// Get PCOLUMNDATA pointer for a particlular column
	HRESULT SetRowData(PCOLUMNDATA pColData); // get the pointer to the COLUMNDATA member of the structure

} ROWBUFF, *PROWBUFF;

typedef struct tagSLOT
{
	HSLOT islotNext;
	HSLOT islotPrev;
	HSLOT cslot;
} SLOT, *PSLOT;

typedef struct tagLSTSLOT
{
	HSLOT       islotFirst;
	HSLOT       islotRov;
	HSLOT       islotMin;
	HSLOT       islotMax;
	BYTE        *rgslot;
	LPBITARRAY	pbitsSlot;	// bit array to mark active rows
	ULONG_PTR       cbExtra;
	ULONG_PTR       cbslotLeftOver;
	ULONG_PTR       cbSlot;
	ULONG_PTR       cbPage;
	ULONG_PTR       cbCommitCurrent;
	ULONG_PTR       cbCommitMax;
} LSTSLOT, *PLSTSLOT;


HRESULT		GetNextSlots(PLSTSLOT plstslot,	HSLOT cslot, HSLOT* pislot);
VOID		DecoupleSlot(PLSTSLOT plstslot, HSLOT islot, PSLOT pslot);
VOID		AddSlotToList(PLSTSLOT plstslot, HSLOT islot, PSLOT pslot);
HRESULT		ReleaseSlots(PLSTSLOT plstslot,	HSLOT islot, ULONG_PTR cslot);
HRESULT		InitializeSlotList(ULONG_PTR cslotMax, ULONG_PTR cbSlot, ULONG_PTR cbPage, LPBITARRAY pbits, PLSTSLOT* pplstslot, BYTE** prgslot);
HRESULT		ResetSlotList(PLSTSLOT plstslot);
HRESULT		ReleaseSlotList(PLSTSLOT plstslot);
ROWBUFF* 	GetRowBuffer(PLSTSLOT plstslot , HSLOT islot);


class IHashTbl
{

public:
	virtual STDMETHODIMP InsertFindBmk
		(
		BOOL       	fFindOnly,
		HSLOT      	irowbuff,
		ULONG_PTR	cbBmk,
		BYTE     	*pbBmk,
		ULONG_PTR 	*pirowbuffFound
		) = 0;

	//@cmember Delete a row with the given bookmark from 
	//the hashtable.
	virtual STDMETHODIMP DeleteBmk
		(
		HSLOT			irowbuff
		)  = 0;

 };


class CHashTbl:public IHashTbl
{
	USHORT    		*m_rgwHash;	   	//@cmember hash array
	ULONG	  		m_ulTableSize; 	//@cmember use this # of elements of the hash array
	PLSTSLOT		m_pLstSlot;		// Pointer to the slot list

public:
	 CHashTbl();
	~CHashTbl(void);
	//@cmember Initialize hashtable object.
	BOOL FInit(PLSTSLOT		pLstSlot);

	//@cmember Find or if not found insert a row with the 
	//given bookmark into the hashtable.
	STDMETHODIMP InsertFindBmk
			(
			BOOL        	fFindOnly,
			HSLOT      		irowbuff,
			ULONG_PTR  		cbBmk,
			BYTE     		*pbBmk,
			ULONG_PTR 			*pirowbuffFound
			);
	//@cmember Delete a row with the given bookmark from 
	//the hashtable.
	STDMETHODIMP DeleteBmk
		(
			HSLOT		iSlot
		);

	STDMETHODIMP CHashTbl::HashBmk
		(
		DBBKMARK		 cbBmk,
		const BYTE * pbBmk,
		DBHASHVALUE* pdwHashedValue
		);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\flexarry.h ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CFlexArray & CWStringArray class defination- This is taken from Winmgmt\common
// 
// Module Name : Flexarry.h
///////////////////////////////////////////////////////////////////////////////////


#ifndef _FLEXARRY_H_
#define _FLEXARRY_H_

#include "corepol.h"

//#include <arena.h>

//***************************************************************************
//
//  class CFlexArray
//
//  This class is a generic pointer array.
//
//***************************************************************************

class POLARITY CFlexArray
{
protected:
    int m_nSize;            // apparent size
    int m_nExtent;          // de facto size
    int m_nGrowByPercent;          
    void** m_pArray;
            
public:
    enum { no_error, failed, out_of_memory, array_full, range_error };

    // Constructs a flex array at an initial size and
    // specifies the initial size and growth-size chunk.
    // =================================================
    CFlexArray(
        IN int nInitialSize = 0, 
        IN int nGrowByPercent = 100
        );

   ~CFlexArray(); 
    CFlexArray(CFlexArray &);
    CFlexArray& operator=(CFlexArray &);

    int CopyDataFrom(const CFlexArray& aOther);
    int EnsureExtent(int nExtent);

    // Gets an element at a particular location.
    // =========================================
    inline void *  GetAt(int nIndex) const { return m_pArray[nIndex]; }

    // Returns a ptr in the array; allows use on left-hand side of assignment.
    // =======================================================================
    inline void * operator[](int nIndex) const { return m_pArray[nIndex]; }
    inline void *& operator[](int nIndex) { return m_pArray[nIndex]; }

    // Sets the element at the requested location.
    // ===========================================
    void inline SetAt(int nIndex, void *p) { m_pArray[nIndex] = p; }

    // Removes an element.
    // ====================
    int   RemoveAt(int nIndex);

    // Inserts an element.
    // ===================
    int   InsertAt(int nIndex, void *);

    // Removes all zero entries (null ptrs) and shrinks the array size.
    // ================================================================
    void  Compress();    

    // Removes all zero entries from the end of the array and shrinks it
    // =================================================================

    void Trim();

    // Adds a new element to the end of the array.
    // ===========================================
    int inline Add(void *pSrc) { return InsertAt(m_nSize, pSrc); }    

    // Gets the apparent size of the array (number of used elements)
    // =============================================================
    int inline Size() const { return m_nSize; }

    // Sets the apparent size of the array
    // ===================================
    void inline SetSize(int nNewSize) { m_nSize = nNewSize;}

    // Removes all entries and reduces array size to zero. The elements
    // are simply removed; not deallocated (this class doesn't know what
    // they are).
    // =================================================================
    void  Empty();

    // Gets a pointer to the internal array.
    // =====================================
    inline void**  GetArrayPtr() { return m_pArray; }
    inline void* const*  GetArrayPtr() const { return m_pArray; }
    
    // Gets a pointer to the internal array and Resets the contents to none
    // ====================================================================

    void** UnbindPtr();

    // For debugging.
    // ==============
    void  DebugDump();

    void Sort();

protected:
    static int __cdecl CompareEls(const void* pelem1, const void* pelem2);
};

//***************************************************************************
//
//  class CWStringArray
//
//  This class is a generic wide-string array.
//
//***************************************************************************


class POLARITY CWStringArray
{
    CFlexArray m_Array;
    
public:
    enum { no_error, failed, out_of_memory, array_full, range_error };
    enum { not_found = -1, no_case, with_case };
        
    CWStringArray(
        int nSize = 0, 
        int nGrowBy = 100
        );

    CWStringArray(CWStringArray &Src);
   ~CWStringArray();
            
    CWStringArray& operator =(CWStringArray &Src);

    // Gets the read-only ptr to the string at the requested index.
    // =============================================================    
    inline wchar_t *GetAt(int nIndex) const { return (wchar_t *) m_Array[nIndex]; }

    // Same as GetAt().
    // ================
    inline wchar_t *operator[](int nIndex) const{ return (wchar_t *) m_Array[nIndex]; }

    // Appends a new element to the end of the array. Copies the param.
    // ================================================================
    int  Add(const wchar_t *pStr);

    // Inserts a new element within the array.
    // =======================================
    int  InsertAt(int nIndex, const wchar_t *pStr);

    // Removes an element at the specified index.  Takes care of
    // cleanup.
    // =========================================================
    int  RemoveAt(int nIndex);

    // Inserts a copy of <pStr> at that location after removing
    // the prior string and deallocating it.
    // ========================================================
    int  SetAt(int nIndex, const wchar_t *pStr);

    // Directly replaces the pointer at the specified location
    // with the ptr value in <pStr>. No allocs or deallocs are done.
    // =============================================================
    int  ReplaceAt(int nIndex, wchar_t *pStr);
        // Unchecked replacement

    // Deletes the string at the location and sets the entry to zero
    // without compressing the array.
    // =============================================================
    int  DeleteStr(int nIndex);  

    // Returns the 'apparent' size of the array.
    // =========================================
    inline int  Size() const { return m_Array.Size(); }

    // Empties the array by cleaning up after all strings and
    // setting the size to zero.
    // ======================================================
    void Empty();

    // Locates a string or returns -1 if not found.
    // ============================================
    int  FindStr(const wchar_t *pTarget, int nFlags);  

    // Compresses the array by removing all zero elements.
    // ===================================================
    inline void Compress() { m_Array.Compress(); }

    // Sorts the array according to UNICODE order.
    // ===========================================
    void Sort();

    inline LPCWSTR*  GetArrayPtr() { return (LPCWSTR*) m_Array.GetArrayPtr(); }

    // Standard set-theoretic operations.
    // ==================================
    static void Difference(
        CWStringArray &Src1, 
        CWStringArray &Src2,
        CWStringArray &Diff
        );

    static void Intersection(
        CWStringArray &Src1,
        CWStringArray &Src2,
        CWStringArray &Output
        );

    static void Union(
        CWStringArray &Src1,
        CWStringArray &Src2,
        CWStringArray &Output
        );
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\ichaprowset.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
//
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//  ICHAPROWSET.CPP IChapteredRowset interface implementation
//
///////////////////////////////////////////////////////////////////////////

#include "headers.h"

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Adds a reference to a chapter
//
// Returns one of the following values:
//      S_OK                    Method Succeeded
//      DB_E_BADCHAPTER			The HCHAPTER given is invalid
//      E_FAIL			        General Error
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIChapteredRowset::AddRefChapter (HCHAPTER   hChapter, DBREFCOUNT *  pcRefCount)
{
	HRESULT hr = E_UNEXPECTED;
		
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock	cab(ROWSET->GetCriticalSection());

	// Clear ErrorInfo
	g_pCError->ClearErrorInfo();

	// Initialize the output variable
	if(pcRefCount != NULL)
	{
		*pcRefCount = -1;
	}

	if((m_pObj->m_bIsChildRs == TRUE && hChapter == DB_NULL_HCHAPTER) || (LONG_PTR)hChapter < 0  || 
		m_pObj->m_bIsChildRs == FALSE && hChapter != 0)
	{
		hr = DB_E_BADCHAPTER;
	}
	else
	{
		hr = m_pObj->AddRefChapter(hChapter,pcRefCount);
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IChapteredRowset);

	CATCH_BLOCK_HRESULT(hr,L"IChapteredRowset::AddRefChapter");
	return hr;

}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Releases a reference to the chapter
//
// Returns one of the following values:
//      S_OK                    Method Succeeded
//      DB_E_BADCHAPTER			The HCHAPTER given is invalid
//      E_FAIL			        General Error
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIChapteredRowset::ReleaseChapter (HCHAPTER   hChapter,DBREFCOUNT * pcRefCount)
{
	HRESULT hr = E_UNEXPECTED;
		
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock	cab(ROWSET->GetCriticalSection());

	// Clear ErrorInfo
	g_pCError->ClearErrorInfo();

	// Initialize the output variable
	if(pcRefCount != NULL)
	{
		*pcRefCount = -1;
	}
	if((m_pObj->m_bIsChildRs == TRUE && hChapter == DB_NULL_HCHAPTER) || (LONG_PTR)hChapter < 0  || 
		m_pObj->m_bIsChildRs == FALSE && hChapter != 0)
	{
		hr = DB_E_BADCHAPTER;
	}
	else
	{
		hr = m_pObj->ReleaseRefChapter(hChapter,pcRefCount);
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IChapteredRowset);
	
	CATCH_BLOCK_HRESULT(hr,L"IChapteredRowset::ReleaseChapter");

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\ibindresourcesess.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
//
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//  IBindResource.CPP CImplIBindRsrc interface implementation for 
//	Session object
//
///////////////////////////////////////////////////////////////////////////

#include "headers.h"

///////////////////////////////////////////////////////////////////////////
// Method of the IBindResource which binds the requested URL
//			S_OK						Bind succeeded
//			DB_S_ERRORSOCCURRED			Bind succeeded, but some bind flags 
//										or properties were not satisfied
//			DB_E_NOAGGREGATION			Aggregation not supported by the 
//										object requested
//			DB_E_NOTFOUND				Object requested as from URL not found
//			DB_E_OBJECTMISMATCH			The object requested and the URL passed
//										does not match
//			DB_SEC_E_PERMISSIONDENIED	User does not have permission for the
//										object requested
//			E_FAIL						Other error ( WMI specifice errors)
//			E_INVALIDARG				one or more arguments are not valid
//			E_NOINTERFACE				The interface requested is not supported
//			E_UNEXPECTED				unexpected error
///////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImplIBindRsrc::Bind( IUnknown *            pUnkOuter,
									   LPCOLESTR             pwszURL,
									   DBBINDURLFLAG         dwBindURLFlags,
									   REFGUID               rguid,
									   REFIID                riid,
									   IAuthenticate *       pAuthenticate,
									   DBIMPLICITSESSION *   pImplSession,
									   DBBINDURLSTATUS *     pdwBindStatus,
									   IUnknown **           ppUnk)
{ 
	HRESULT hr = S_OK;
	BSTR strUrl;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	//=========================================================================================
	// Serialize the object
	//=========================================================================================
	CAutoBlock	cab(m_pObj->GetCriticalSection());

	// Clear ErrorInfo
	g_pCError->ClearErrorInfo();

	//=========================================================================================
	// If URL is NULL return Invalid Argument
	//=========================================================================================
	if(pwszURL == NULL)
	{
		hr = E_INVALIDARG;
	}
	else
	{

		//=========================================================================================
		// Allocate the string
		//=========================================================================================
		strUrl = Wmioledb_SysAllocString(pwszURL);

		//=========================================================================================
		// Check if the flags passed are valid for the object requested
		//=========================================================================================
		if(!CheckBindURLFlags(dwBindURLFlags,rguid))
		{
			hr =  E_INVALIDARG;
		}
		else
		if(!CheckIfProperURL(strUrl,rguid,pdwBindStatus))
		{
			hr =  DB_E_OBJECTMISMATCH;
		}
		else
		if( pUnkOuter != NULL && riid != IID_IUnknown)
		{
			hr = DB_E_NOAGGREGATION;
		}
		if(SUCCEEDED(hr))
		{
			//=========================================================================================
			// Calling this to bind the URL to the appropriate object
			//=========================================================================================
			hr = BindURL(pUnkOuter,strUrl,dwBindURLFlags,rguid,riid,pImplSession,pdwBindStatus,ppUnk);
		}

		// Free the string
		SysFreeString(strUrl);
	}
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IBindResource);

	CATCH_BLOCK_HRESULT(hr,L"IBindResource::Bind on Session object");
	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////
// Function which checks if the URL flags matches the requested object
//  This is as per the OLEDB specs
///////////////////////////////////////////////////////////////////////////////////////////
BOOL CImplIBindRsrc::CheckBindURLFlags(DBBINDURLFLAG dwBindURLFlags , REFGUID rguid)
{
	BOOL bFlag = FALSE;
	LONG lTemp = 0;

	if( DBGUID_DSO == rguid)
	{
		lTemp = DBBINDURLFLAG_ASYNCHRONOUS | DBBINDURLFLAG_READ | DBBINDURLFLAG_WAITFORINIT;
		//=========================================================================================
		// Flags can have only these values
		//=========================================================================================
		if((dwBindURLFlags & ~lTemp) == 0)
			bFlag = TRUE;

	}

	if( DBGUID_SESSION == rguid)
	{
		if( dwBindURLFlags == DBBINDURLFLAG_READ) // Flags can have only these values
			bFlag = TRUE;
	}

	if( DBGUID_COMMAND == rguid)
	{
		lTemp = DBBINDURLFLAG_READ | DBBINDURLFLAG_WAITFORINIT;
		if((dwBindURLFlags & ~lTemp) == 0)
			bFlag = TRUE;
	}

	if( DBGUID_ROW == rguid)
	{
		bFlag = TRUE;
	}

	if( DBGUID_ROWSET == rguid)
	{
		if(!((dwBindURLFlags & DBBINDURLFLAG_DELAYFETCHCOLUMNS) ||			// Flags cannot have any of these two values
			(dwBindURLFlags & DBBINDURLFLAG_DELAYFETCHSTREAM)))
			bFlag = TRUE;

	}

	if( DBGUID_STREAM == rguid)
	{
	}


	return bFlag;
}


////////////////////////////////////////////////////////////////////////////////////////////
// Function which checks if the URL is valid for the requested object
///////////////////////////////////////////////////////////////////////////////////////////
BOOL CImplIBindRsrc::CheckIfProperURL(BSTR & strUrl,REFGUID rguid,DBBINDURLSTATUS * pdwBindStatus)
{
	BOOL bRet = TRUE;
	LONG lUrlType = -1;
	CURLParser urlParser;
	
	//=========================================================================================
	// Set the URL string of the URL parser utility class
	//=========================================================================================
	if(SUCCEEDED(urlParser.SetURL(strUrl)))
	{
		// If the url is a valid URL
		if((lUrlType = urlParser.GetURLType()) != -1)
		{
			switch(lUrlType)
			{
				case URL_ROW:
				case URL_EMBEDEDCLASS:
					bRet = TRUE;

					//=========================================================================================
					// if the url is of type row or rowset and if the requested object is
					// datasource or session or command , then set the status 
					//=========================================================================================
					if(rguid == DBGUID_DSO || rguid == DBGUID_SESSION || rguid == DBGUID_COMMAND)
						*pdwBindStatus = DBBINDURLSTATUS_S_REDIRECTED;					

					break;

				case URL_DATASOURCE:
					//=========================================================================================
					// check if the url is of type datasource and the requested object is
					// row or rowset or stream 
					//=========================================================================================
					if(!(rguid == DBGUID_ROW || rguid == DBGUID_ROWSET || rguid == DBGUID_STREAM))
						bRet = TRUE;

					break;

				case URL_ROWSET:

					//=========================================================================================
					// if the url is of type rowset and if the requested object is
					// datasource or session or command , then set the status 
					//=========================================================================================
					if(rguid == DBGUID_DSO || rguid == DBGUID_SESSION || rguid == DBGUID_COMMAND)
						*pdwBindStatus = DBBINDURLSTATUS_S_REDIRECTED;
	
					bRet = TRUE;
					
					if(rguid == DBGUID_ROW)
						bRet = FALSE;

					break;
			};
		}
	}

	return bRet;
	
}



///////////////////////////////////////////////////////////////////////////
// Function to bind the requested URL
// NTRaid:136545
// 07/05/00
///////////////////////////////////////////////////////////////////////////
HRESULT CImplIBindRsrc::BindURL(IUnknown *            pUnkOuter,
									LPCOLESTR             pwszURL,
									DBBINDURLFLAG         dwBindURLFlags,
									REFGUID               rguid,
									REFIID                riid,
									DBIMPLICITSESSION *   pImplSession,
									DBBINDURLSTATUS *     pdwBindStatus,
									IUnknown **           ppUnk)
{

	HRESULT hr		= E_FAIL;
	BSTR	strURL	= NULL;
	
	strURL	= Wmioledb_SysAllocString(pwszURL);

	
	//=========================================================================================
	// If the requested object is DSO then create the object aggregating with the outer object
	//=========================================================================================
	if( rguid == DBGUID_DSO)
	{

		hr = m_pObj->m_pCDataSource->QueryInterface(riid,(void **)ppUnk);

	}
	else
	//=========================================================================================
	// If the requested object is Session object then QI for the requiested object
	//=========================================================================================
	if( rguid == DBGUID_SESSION)
	{
		hr = m_pObj->QueryInterface(riid,(void **)ppUnk);
	}
	else
	//=========================================================================================
	// If requested object is command then call function to 
	// to create a command
	//=========================================================================================
	if(rguid == DBGUID_COMMAND)
	{
		hr = m_pObj->CreateCommand(pUnkOuter,riid,ppUnk);
	}
	//=========================================================================================
	// If requested object is row then call function to 
	// to create a row
	//=========================================================================================
	if( rguid == DBGUID_ROW)
	{
		hr = m_pObj->CreateRow(pUnkOuter,strURL,riid,ppUnk);
	}
	//=========================================================================================
	// If requested object is rowset then call function to 
	// to create a rowset
	//=========================================================================================
	if( rguid == DBGUID_ROWSET)
	{
		hr = m_pObj->CreateRowset(pUnkOuter,strURL,riid,ppUnk);
	}


	if(! SUCCEEDED(hr))
	{
		*ppUnk = NULL;
	}

	SysFreeString(strURL);

	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\icreaterow.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
//
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//  ICREATEROW.CPP ICreateRow interface implementation
//
///////////////////////////////////////////////////////////////////////////

#include "headers.h"

HRESULT CImplICreateRow::CreateRow(IUnknown *           pUnkOuter,
								   LPCOLESTR            pwszURL,
								   DBBINDURLFLAG        dwBindURLFlags,
								   REFGUID              rguid,
								   REFIID               riid,
								   IAuthenticate *       pAuthenticate,
								   DBIMPLICITSESSION *   pImplSession,
								   DBBINDURLSTATUS *     pdwBindStatus,
								   LPOLESTR *            ppwszNewURL,
								   IUnknown **           ppUnk)
{
	HRESULT hr = S_OK;
	BSTR strUrl;
	BOOL bCreateNew = TRUE;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock	cab(BINDER->GetCriticalSection());

	// Clear ErrorInfo
	g_pCError->ClearErrorInfo();

	// Allocate the string
	strUrl = Wmioledb_SysAllocString(pwszURL);

	if(!CheckBindURLFlags(dwBindURLFlags,rguid))
	{
		hr = E_INVALIDARG;
	}
	else
	if(!CheckIfProperURL(strUrl,rguid,pdwBindStatus))
	{
		hr = DB_E_OBJECTMISMATCH;
	}
	else
	if( pUnkOuter != NULL && riid != IID_IUnknown)
	{
		hr = DB_E_NOAGGREGATION;
	}
	else
	{
		m_pObj->m_pUrlParser->ClearParser();
		if(DBBINDURLFLAG_OPENIFEXISTS & dwBindURLFlags)
		{
			// Calling this to bind the URL to the appropriate object
			hr = BindURL(pUnkOuter,strUrl,dwBindURLFlags,rguid,riid,pImplSession,pdwBindStatus,ppUnk);
			if( SUCCEEDED(hr))
			{
				bCreateNew = FALSE;
			}
		}
		
		// If row does not exist or if a new row is to be created
		if( bCreateNew == TRUE)
		{
			hr = CreateNewRow(pUnkOuter,strUrl,dwBindURLFlags,rguid,riid,pImplSession,pdwBindStatus,ppUnk);
		}
	}
	SysFreeString(strUrl);

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_ICreateRow);

	CATCH_BLOCK_HRESULT(hr,L"ICreateRow::CreateRow");
	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////
// Function which checks if the URL flags matches the requested object
//  This is as per the OLEDB specs
///////////////////////////////////////////////////////////////////////////////////////////
BOOL CImplICreateRow::CheckBindURLFlags(DBBINDURLFLAG dwBindURLFlags , REFGUID rguid)
{
	BOOL bFlag = FALSE;
	LONG lTemp = 0;

	if( DBGUID_ROW == rguid)
	{
		if(!((dwBindURLFlags & DBBINDURLFLAG_OPENIFEXISTS ) &&			// Flags cannot have any of these two values
			(dwBindURLFlags & DBBINDURLFLAG_OVERWRITE )))
			bFlag = TRUE;
	}

	if( DBGUID_ROWSET == rguid)
	{
		if((dwBindURLFlags & DBBINDURLFLAG_COLLECTION  ) &&			
			!(dwBindURLFlags & DBBINDURLFLAG_DELAYFETCHCOLUMNS ) &&
			!(dwBindURLFlags & DBBINDURLFLAG_DELAYFETCHCOLUMNS ))
			bFlag = TRUE;

	}

	if( DBGUID_STREAM == rguid)
	{
	}


	return bFlag;
}


////////////////////////////////////////////////////////////////////////////////////////////
// Function which checks if the URL is valid for the requested object
///////////////////////////////////////////////////////////////////////////////////////////
BOOL CImplICreateRow::CheckIfProperURL(BSTR & strUrl,REFGUID rguid,DBBINDURLSTATUS * pdwBindStatus)
{
	BOOL bRet = FALSE;
	LONG lUrlType = -1;
	
	m_pObj->m_pUrlParser->ClearParser();
	// Set the URL string of the URL parser utility class
	if(SUCCEEDED(m_pObj->m_pUrlParser->SetURL(strUrl)))
	{
		bRet = TRUE;
		// If the url is a valid URL
		if((lUrlType = m_pObj->m_pUrlParser->GetURLType()) != -1)
		{
			switch(lUrlType)
			{
				case URL_ROW:

					if(rguid == DBGUID_ROW)
						bRet = TRUE;

					break;


				case URL_ROWSET:

					
					if(rguid == DBGUID_ROWSET)
						bRet = TRUE;

					break;
			};
		}
	}

	return bRet;
	
}

///////////////////////////////////////////////////////////////////////////
// Function to bind the requested URL
///////////////////////////////////////////////////////////////////////////
HRESULT CImplICreateRow::BindURL(	IUnknown *            pUnkOuter,
									LPCOLESTR             pwszURL,
									DBBINDURLFLAG         dwBindURLFlags,
									REFGUID               rguid,
									REFIID                riid,
									DBIMPLICITSESSION *   pImplSession,
									DBBINDURLSTATUS *     pdwBindStatus,
									IUnknown **           ppUnk)
{
	HRESULT hr = E_FAIL;
	IUnknown *pTempUnk = NULL;
	LONG lInitFlags  = 0;
	LONG lBindFlags	 = 0;
	REFGUID guidTemp = GUID_NULL;
	IUnknown* pReqestedPtr = NULL;


	GetInitAndBindFlagsFromBindFlags(dwBindURLFlags,lInitFlags,lBindFlags);

	
	if(S_OK == (hr = m_pObj->CreateDSO(NULL,lInitFlags,guidTemp,NULL)))
	{
		if(pImplSession != NULL)
		{
			pTempUnk = pImplSession->pUnkOuter;
			
			if(pTempUnk != NULL && *pImplSession->piid != IID_IUnknown)
				return DB_E_NOAGGREGATION;

			hr = m_pObj->CreateSession(pTempUnk,IID_IUnknown,&pReqestedPtr);
		}
		else
			hr = m_pObj->CreateSession(pTempUnk,guidTemp,&pReqestedPtr);

		if(S_OK == hr)
		{
			// If the implicit session is not null then get the requested
			// session pointer 
			if(pImplSession != NULL)
			{
				if( S_OK == pReqestedPtr->QueryInterface(*pImplSession->piid,(void **)&pImplSession->pSession))
					pReqestedPtr->Release();

			}

			// If requested object is row then call function to 
			// to create a row
			if( rguid == DBGUID_ROW)
			{
				pReqestedPtr = NULL;
				hr = m_pObj->CreateRow(pUnkOuter,riid,ppUnk);
			}

			// If requested object is rowset then call function to 
			// to create a rowset
			if( rguid == DBGUID_ROWSET)
			{
				pReqestedPtr = NULL;
				hr = m_pObj->CreateRowset(pUnkOuter,riid,ppUnk);
			}

		}
	}
	// If failed due to some reason then release all the
	// object created for binding
	if( hr != S_OK)
	{
		m_pObj->ReleaseAllObjects();
	}

	return hr ;
}

///////////////////////////////////////////////////////////////////////////
// Function to create a new row as given by the URL
///////////////////////////////////////////////////////////////////////////
HRESULT CImplICreateRow::CreateNewRow(	IUnknown *            pUnkOuter,
										LPCOLESTR             pwszURL,
										DBBINDURLFLAG         dwBindURLFlags,
										REFGUID               rguid,
										REFIID                riid,
										DBIMPLICITSESSION *   pImplSession,
										DBBINDURLSTATUS *     pdwBindStatus,
										IUnknown **           ppUnk)

{
	HRESULT hr = E_FAIL;
	IUnknown *pTempUnk = NULL;
	LONG lInitFlags  = 0;
	LONG lBindFlags	 = 0;
	REFGUID guidTemp = GUID_NULL;
	IUnknown* pReqestedPtr = NULL;
	ROWCREATEBINDFLAG rowCreateFlag = ROWCREATE;


	GetInitAndBindFlagsFromBindFlags(dwBindURLFlags,lInitFlags,lBindFlags);

	
	if(S_OK == (hr = m_pObj->CreateDSO(NULL,lInitFlags,guidTemp,NULL)))
	{
		if(pImplSession != NULL)
		{
			pTempUnk = pImplSession->pUnkOuter;
			if(pTempUnk != NULL && *pImplSession->piid != IID_IUnknown)
				return DB_E_NOAGGREGATION;

			hr = m_pObj->CreateSession(pTempUnk,IID_IUnknown,&pReqestedPtr);
		}
		else
			hr = m_pObj->CreateSession(pTempUnk,guidTemp,&pReqestedPtr);

		if(S_OK == hr)
		{
			// If the implicit session is not null then get the requested
			// session pointer 
			if(pImplSession != NULL)
			{
				if( S_OK == pReqestedPtr->QueryInterface(*pImplSession->piid,(void **)&pImplSession->pSession))
					pReqestedPtr->Release();

			}

			// If requested object is row then call function to 
			// to create a new row
			if( rguid == DBGUID_ROW)
			{
				if(DBBINDURLFLAG_OVERWRITE & dwBindURLFlags)
					rowCreateFlag = ROWOVERWRITE;

				pReqestedPtr = NULL;
				hr = m_pObj->CreateRow(pUnkOuter,riid,ppUnk,rowCreateFlag);
			}
			else
				hr = DB_E_NOTSUPPORTED;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\igetsess.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
//
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//  IGetSess.CPP IGetSession interface implementation
//
///////////////////////////////////////////////////////////////////////////

#include "headers.h"

STDMETHODIMP CImpIGetSession::GetSession(REFIID riid,IUnknown ** ppSession)
{
	HRESULT hr = E_FAIL;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(m_pObj->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();


	if( m_pObj->m_pCreator != NULL)
	{
		hr = m_pObj->m_pCreator->QueryInterface(riid,(void **)ppSession);
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IGetSession);

	CATCH_BLOCK_HRESULT(hr,L"IGetSession::GetSession");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\igetrow.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
//
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//  IChapteredRowset.CPP IChapteredRowset interface implementation
//
///////////////////////////////////////////////////////////////////////////

#include "headers.h"

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Adds a reference to a chapter
//
// Returns one of the following values:
//      S_OK                    Method Succeeded
//      E_FAIL			        General Error
//
/////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CImpIGetRow::GetRowFromHROW(IUnknown * pUnkOuter,HROW hRow,REFIID riid,IUnknown ** ppUnk)
{
	HRESULT hr = DB_E_BADROWHANDLE;
	CRow *pRow = NULL;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(ROWSET->GetCriticalSection());

	// Clear ErrorInfo
	g_pCError->ClearErrorInfo();

	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
	if( pUnkOuter != NULL && riid != IID_IUnknown)
	{
		hr = DB_E_NOAGGREGATION;
	}
	else
	if(ppUnk == NULL)
	{	
		hr = E_INVALIDARG;
	}
	else
	if( m_pObj->m_uRsType == PROPERTYQUALIFIER ||
		m_pObj->m_uRsType == CLASSQUALIFIER ||
		m_pObj->m_uRsType == METHOD_ROWSET ||
		m_pObj->m_uRsType == SCHEMA_ROWSET)
	{
		hr = E_FAIL;
		LogMessage("URL for Qualifier or Schema rows not supported",hr);
	}
	// else was missing
	// modified on 06/07/00
	else
	if(hRow > 0)
	{
		if(TRUE == m_pObj->IsRowExists(hRow))
		{
			DWORD dwStatus = m_pObj->GetRowStatus(hRow);
			if(dwStatus != DBSTATUS_S_OK)
			{
				LogMessage("Status of the row is not DBSTATUS_S_OK",hr);
				hr = dwStatus == DBROWSTATUS_E_DELETED ? DB_E_DELETEDROW : E_FAIL;
			}
			else
			{
				CBSTR strKey;
				if(SUCCEEDED(hr = ((CWbemClassInstanceWrapper *)m_pObj->GetInstancePtr(hRow))->GetKey(strKey)))
				{
					try
					{
						pRow = new CRow(pUnkOuter,m_pObj,m_pObj->m_pCreator,m_pObj->m_pCon);
					}
					catch(...)
					{
						SAFE_DELETE_PTR(pRow);
						throw;
					}
					if(pRow != NULL)
					{
						
						if(S_OK == (hr = pRow->InitRow(hRow,m_pObj->GetInstancePtr(hRow))))
						{
							hr = pRow->QueryInterface(riid,(void **)ppUnk);
						}
					}
					else
					{
						hr = E_OUTOFMEMORY;
					}
				}
				else
				{
					hr = E_FAIL;
					*ppUnk = NULL;
				}
			}
		}
	}

	if(FAILED(hr))
	{
		SAFE_DELETE_PTR(pRow);
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IGetRow);

	CATCH_BLOCK_HRESULT(hr,L"IGetRow::GetRowFromHROW");
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Adds a reference to a chapter
//
// Returns one of the following values:
//      S_OK                    Method Succeeded
//      E_FAIL			        General Error
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIGetRow::GetURLFromHROW(HROW hRow,LPOLESTR * ppwszURL)
{
	HRESULT hr = DB_E_BADROWHANDLE;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	//========================
	// Serialize the object
	//========================
	CAutoBlock cab(ROWSET->GetCriticalSection());

	//========================
	// Clear ErrorInfo
	//========================
	g_pCError->ClearErrorInfo();

	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
	if( m_pObj->m_uRsType == PROPERTYQUALIFIER ||
		m_pObj->m_uRsType == CLASSQUALIFIER ||
		m_pObj->m_uRsType == METHOD_ROWSET||
		m_pObj->m_uRsType == SCHEMA_ROWSET)
	{
		hr = E_FAIL;
		LogMessage("URL for Qualifier or Schema rows not supported",hr);
	}
	else
	if(hRow > 0)
	{
		//========================
		// If row exists
		//========================
		if(TRUE == m_pObj->IsRowExists(hRow))
		{
			DWORD dwStatus = m_pObj->GetRowStatus(hRow);
			if(dwStatus != DBSTATUS_S_OK)
			{
				LogMessage("Status of the row is not DBSTATUS_S_OK",hr);
				hr = dwStatus == DBROWSTATUS_E_DELETED ? DB_E_DELETEDROW : E_FAIL;
			}
			else
			{
				CBSTR strKey;
				if(SUCCEEDED(hr = ((CWbemClassInstanceWrapper *)m_pObj->GetInstancePtr(hRow))->GetKey(strKey)))
				{
					BSTR strPath = NULL;
					BSTR strURL  = NULL;
					hr = S_OK;
					CURLParser urlParser;

					urlParser.SetPath(strKey);

					urlParser.GetURL(strURL);

					try
					{
						*ppwszURL = (LPOLESTR)g_pIMalloc->Alloc((SysStringLen(strURL) + 1) *sizeof(WCHAR));
					}
					catch(...)
					{
						if(*ppwszURL)
						{
							g_pIMalloc->Free(*ppwszURL);
						}
						throw;
					}
					
					if(*ppwszURL == NULL)
					{
						hr = E_OUTOFMEMORY;
					}
					else
					{
						wcscpy(*ppwszURL,strURL);
					}

					SysFreeString(strURL);
					SysFreeString(strPath);
				}
				else
				{
					LogMessage("Getting a URL on command executed row is not supported except" \
						"except if query is not REFERENCES OF or ASSOCIATERS OF",hr);
					hr = E_FAIL;
				}
			}
		}
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IGetRow);

	CATCH_BLOCK_HRESULT(hr,L"IGetRow::GetURLFromHROW");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\ibindresource.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
//
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//  IBindResource.CPP CImplIBindResource interface implementation
//
///////////////////////////////////////////////////////////////////////////

#include "headers.h"

////////////////////////////////////////////////////////////////////////////////
// Method of the IBindResource which binds the requested URL
// Returns one of the following values:
//			S_OK						Bind succeeded
//			DB_S_ERRORSOCCURRED			Bind succeeded, but some bind flags 
//										or properties were not satisfied
//			DB_E_NOAGGREGATION			Aggregation not supported by the 
//										object requested
//			DB_E_NOTFOUND				Object requested as from URL not found
//			DB_E_OBJECTMISMATCH			The object requested and the URL passed
//										does not match
//			DB_SEC_E_PERMISSIONDENIED	User does not have permission for the
//										object requested
//			E_FAIL						Other error ( WMI specifice errors)
//			E_INVALIDARG				one or more arguments are not valid
//			E_NOINTERFACE				The interface requested is not supported
//			E_UNEXPECTED				unexpected error
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImplIBindResource::Bind( IUnknown *            pUnkOuter,
									   LPCOLESTR             pwszURL,
									   DBBINDURLFLAG         dwBindURLFlags,
									   REFGUID               rguid,
									   REFIID                riid,
									   IAuthenticate *       pAuthenticate,
									   DBIMPLICITSESSION *   pImplSession,
									   DBBINDURLSTATUS *     pdwBindStatus,
									   IUnknown **           ppUnk)
{ 
	HRESULT hr = E_FAIL;
	BSTR strUrl;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock	cab(BINDER->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	// If URL is NULL return Invalid Argument
	if(pwszURL == NULL)
	{
		hr = E_INVALIDARG;
	}
	else
	{
		// Allocate the string
		strUrl = Wmioledb_SysAllocString(pwszURL);

		// Check if the flags passed are valid for the object requested
		if(!CheckBindURLFlags(dwBindURLFlags,rguid))
		{
			hr = E_INVALIDARG;
		}
		else
		if(!CheckIfProperURL(strUrl,rguid,pdwBindStatus))
		{
			hr = DB_E_OBJECTMISMATCH;
		}
		else
		if( pUnkOuter != NULL && riid != IID_IUnknown)
		{
			hr = DB_E_NOAGGREGATION;
		}
		else
		{
			// Calling this to bind the URL to the appropriate object
			hr = BindURL(pUnkOuter,strUrl,dwBindURLFlags,rguid,riid,pImplSession,pdwBindStatus,ppUnk);
		}

		// Free the string
		SysFreeString(strUrl);
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IBindResource);

	CATCH_BLOCK_HRESULT(hr,L"IBindResource::Bind");
	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////
// Function which checks if the URL flags matches the requested object
//  This is as per the OLEDB specs
///////////////////////////////////////////////////////////////////////////////////////////
BOOL CImplIBindResource::CheckBindURLFlags(DBBINDURLFLAG dwBindURLFlags , REFGUID rguid)
{
	BOOL bFlag = FALSE;
	LONG lTemp = 0;

	if( DBGUID_DSO == rguid)
	{
		lTemp = DBBINDURLFLAG_ASYNCHRONOUS | DBBINDURLFLAG_READ | DBBINDURLFLAG_WAITFORINIT;
		// Flags can have only these values
		if((dwBindURLFlags & ~lTemp) == 0)
			bFlag = TRUE;

	}

	if( DBGUID_SESSION == rguid)
	{
		if( dwBindURLFlags == DBBINDURLFLAG_READ) // Flags can have only these values
			bFlag = TRUE;
	}

	if( DBGUID_COMMAND == rguid)
	{
		lTemp = DBBINDURLFLAG_READ | DBBINDURLFLAG_WAITFORINIT;
		if((dwBindURLFlags & ~lTemp) == 0)
			bFlag = TRUE;
	}

	if( DBGUID_ROW == rguid)
	{
		bFlag = TRUE;
	}

	if( DBGUID_ROWSET == rguid)
	{
		if(!((dwBindURLFlags & DBBINDURLFLAG_DELAYFETCHCOLUMNS) ||			// Flags cannot have any of these two values
			(dwBindURLFlags & DBBINDURLFLAG_DELAYFETCHSTREAM)))
			bFlag = TRUE;

	}

	if( DBGUID_STREAM == rguid)
	{
	}


	return bFlag;
}


////////////////////////////////////////////////////////////////////////////////////////////
// Function which checks if the URL is valid for the requested object
///////////////////////////////////////////////////////////////////////////////////////////
BOOL CImplIBindResource::CheckIfProperURL(BSTR & strUrl,REFGUID rguid,DBBINDURLSTATUS * pdwBindStatus)
{
	BOOL bRet = FALSE;
	LONG lUrlType = -1;
	
	m_pObj->m_pUrlParser->ClearParser();
	//==================================================================
	// Set the URL string of the URL parser utility class
	//==================================================================
	if(SUCCEEDED(m_pObj->m_pUrlParser->SetURL(strUrl)))
	{
		bRet = TRUE;
		//==================================================================
		// If the url is a valid URL
		//==================================================================
		if((lUrlType = m_pObj->m_pUrlParser->GetURLType()) != -1)
		{
			switch(lUrlType)
			{
				case URL_ROW:
				case URL_EMBEDEDCLASS:
					bRet = TRUE;

					//==================================================================
					// if the url is of type row or rowset and if the requested object is
					// datasource or session or command , then set the status 
					//==================================================================
					if(rguid == DBGUID_DSO || rguid == DBGUID_SESSION || rguid == DBGUID_COMMAND)
						*pdwBindStatus = DBBINDURLSTATUS_S_REDIRECTED;					

					break;

				case URL_DATASOURCE:
					//==================================================================
					// check if the url is of type datasource and the requested object is
					// row or rowset or stream 
					//==================================================================
					if(!(rguid == DBGUID_ROW || rguid == DBGUID_ROWSET || rguid == DBGUID_STREAM))
						bRet = TRUE;

					break;

				case URL_ROWSET:

					//==================================================================
					// if the url is of type rowset and if the requested object is
					// datasource or session or command , then set the status 
					//==================================================================
					if(rguid == DBGUID_DSO || rguid == DBGUID_SESSION || rguid == DBGUID_COMMAND)
						*pdwBindStatus = DBBINDURLSTATUS_S_REDIRECTED;
	
					bRet = TRUE;
					
					if(rguid == DBGUID_ROW)
						bRet = FALSE;

					break;
			};
		}
	}

	return bRet;
	
}



///////////////////////////////////////////////////////////////////////////
// Function to bind the requested URL
///////////////////////////////////////////////////////////////////////////
HRESULT CImplIBindResource::BindURL(IUnknown *            pUnkOuter,
									LPCOLESTR             pwszURL,
									DBBINDURLFLAG         dwBindURLFlags,
									REFGUID               rguid,
									REFIID                riid,
									DBIMPLICITSESSION *   pImplSession,
									DBBINDURLSTATUS *     pdwBindStatus,
									IUnknown **           ppUnk)
{

	HRESULT hr = E_FAIL;
	IUnknown *pTempUnk = NULL;
	LONG lInitFlags  = 0;
	LONG lBindFlags	 = 0;
	REFGUID guidTemp = GUID_NULL;
	IUnknown* pReqestedPtr = NULL;



	GetInitAndBindFlagsFromBindFlags(dwBindURLFlags,lInitFlags,lBindFlags);
	
	
	//=========================================================================================
	// If the requested object is DSO then create the object aggregating with the outer object
	//=========================================================================================
	if( rguid == DBGUID_DSO)
	{
		if(DBBINDURLFLAG_WAITFORINIT & dwBindURLFlags)
			lInitFlags |= DBBINDURLFLAG_WAITFORINIT;

		hr = m_pObj->CreateDSO(pUnkOuter,lInitFlags,riid,&pReqestedPtr);

	}
	else
	{
		hr = m_pObj->CreateDSO(NULL,lInitFlags,guidTemp,NULL);
	}

	if(SUCCEEDED(hr))
	{

		if(rguid != DBGUID_DSO)
		{
			//=========================================================================================
			// If the requested object is DSO then create the object aggregating with the outer object
			//=========================================================================================
			pReqestedPtr = NULL;
			pTempUnk	 = NULL;
			if( rguid == DBGUID_SESSION)
			{
				hr = m_pObj->CreateSession(pUnkOuter,riid,&pReqestedPtr);
			}
			else
			{
				if(pImplSession != NULL)
				{
					pTempUnk = pImplSession->pUnkOuter;
					
					// if the session is to be created with aggregation 
					// if the requested pointer is on IUnknown then throw error
					if( pTempUnk != NULL && *pImplSession->piid != IID_IUnknown)
					{
						hr = DB_E_NOAGGREGATION;
					}
				}
				if(SUCCEEDED(hr))
				{
					hr = m_pObj->CreateSession(pTempUnk,guidTemp,&pReqestedPtr);
				}
			}
		}


		if( SUCCEEDED(hr))
		{

			//=========================================================================================
			// If requested object is command then call function to 
			// to create a command
			//=========================================================================================
			if(rguid == DBGUID_COMMAND)
			{
				pReqestedPtr = NULL;
				hr = m_pObj->CreateCommand(pUnkOuter,riid,&pReqestedPtr);
			}

			//=========================================================================================
			// If requested object is row then call function to 
			// to create a row
			//=========================================================================================
			if( rguid == DBGUID_ROW)
			{
				pReqestedPtr = NULL;
				hr = m_pObj->CreateRow(pUnkOuter,riid,&pReqestedPtr);
			}

			//=========================================================================================
			// If requested object is rowset then call function to 
			// to create a rowset
			//=========================================================================================
			if( rguid == DBGUID_ROWSET)
			{
				pReqestedPtr = NULL;
				hr = m_pObj->CreateRowset(pUnkOuter,riid,&pReqestedPtr);
			}

		}
		
	}

	//=========================================================================================
	// If failed due to some reason then release all the
	// object created for binding
	//=========================================================================================
	if( hr != S_OK)
	{
		m_pObj->ReleaseAllObjects();
	}

	if( SUCCEEDED(hr))
	{
		*ppUnk = pReqestedPtr;
	}

	return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\idbdatasrcadmin.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//
//  IDBDataSrcAdmin.cpp - IDBDataSourceAdmin interface implementation
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CImpIDBDataSrcAdmin::CreateDataSource 
//
// Creates a new Datasouce : ie creates a namespace 
//
// Returns one of the following values:

//      S_OK                       Method Succeeded
//      DB_S_ERRORSOCCURRED        new datasource was created but one or more properties was not set
//      E_FAIL                     Provider-specific error
//      E_INVALIDARG               cPropertySets was not zero and rgPropertySets was null pointer
//      E_OUTOFMEMORY              Out of Memory
//      OTHER                      Other HRESULTs returned by called functions
///////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIDBDataSrcAdmin::CreateDataSource(	ULONG		cPropertySets,
													DBPROPSET	rgPropertySets[  ],
													IUnknown  *	pUnkOuter,
													REFIID		riid,
													IUnknown **	ppDBSession)
{
    HRESULT hr	= S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Do nothing if no property was specified
	if(cPropertySets != 0)
	{
		// Serialize the object
		CAutoBlock cab(DATASOURCE->GetCriticalSection());
		g_pCError->ClearErrorInfo();

		if (m_pObj->m_fDSOInitialized)
		{
			hr = DB_E_ALREADYINITIALIZED;
		}
		else
		if( cPropertySets != 0 && rgPropertySets == NULL)
		{
			hr = E_INVALIDARG;
		}
		else
		if ( ppDBSession && (pUnkOuter) && (riid != IID_IUnknown) )
		{
			hr = DB_E_NOAGGREGATION;
		}
		else
		{
			//===================================================================================
			// Check Arguments for use by properties
			//===================================================================================
			if(SUCCEEDED(hr = m_pObj->m_pUtilProp->SetPropertiesArgChk(cPropertySets, rgPropertySets,m_pObj->m_fDSOInitialized)))
			{
				//===================================================================================
				// just pass this call on to the utility object that manages our properties
				//===================================================================================
				if(SUCCEEDED(hr = m_pObj->m_pUtilProp->SetProperties(PROPSET_DSO,cPropertySets, rgPropertySets)) && 
					SUCCEEDED(hr = m_pObj->InitializeConnectionProperties()) )
				{
					if(SUCCEEDED(hr = m_pObj->m_pWbemWrap->CreateNameSpace()))
					{
						m_pObj->m_fDSOInitialized = TRUE;
					}
				}
			}
		}

		// if session is to be created then
		if(SUCCEEDED(hr) && ppDBSession)
		{
			hr = m_pObj->CreateSession(pUnkOuter,riid,ppDBSession);
		}
	}
	
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IDBDataSourceAdmin);

	CATCH_BLOCK_HRESULT(hr,L"IDBDataSourceAdmin::CreateDataSource");
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CImpIDBDataSrcAdmin::DestroyDataSource 
//
// Deletes a Datasouce : ie deletes a namespace 
//
// Returns one of the following values:

//      S_OK                       Method Succeeded
//      E_FAIL                     Provider-specific error
//      E_INVALIDARG               cPropertySets was not zero and rgPropertySets was null pointer
//      OTHER                      Other HRESULTs returned by called functions
///////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIDBDataSrcAdmin::DestroyDataSource( void)
{
    HRESULT hr	= S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	if (!m_pObj->m_fDSOInitialized || 
		(m_pObj->m_fDSOInitialized && m_pObj->m_fDBSessionCreated) )
	{
		hr = E_UNEXPECTED;
	}
	else
	{
		if(SUCCEEDED(hr = m_pObj->m_pWbemWrap->DeleteNameSpace()))
		{
			m_pObj->m_fDSOInitialized = FALSE;
		}
	}

	
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IDBDataSourceAdmin);

	CATCH_BLOCK_HRESULT(hr,L"IDBDataSourceAdmin::DestroyDataSource");
    return hr;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CImpIDBDataSrcAdmin::GetCreationProperties 
//
// Gets datasource creation properties
//
// Returns one of the following values:

//      S_OK                       Method Succeeded
//      E_FAIL                     Provider-specific error
//		DB_S_ERRORSOCCURRED		   One or more properties specified in were not supported
//      E_INVALIDARG               cPropertySets was not zero and rgPropertySets was null pointer
//		E_OUTOFMEMORY				out of memory
//		DB_E_ERRORSOCCURRED			values were not returned for any properties
//      OTHER                      Other HRESULTs returned by called functions
///////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIDBDataSrcAdmin::GetCreationProperties(	ULONG				cPropertyIDSets,
															const DBPROPIDSET	rgPropertyIDSets[],
															ULONG  *			pcPropertyInfoSets,
															DBPROPINFOSET  **	prgPropertyInfoSets,
															OLECHAR  **			ppDescBuffer)
{
    HRESULT hr	= S_OK;
    CSetStructuredExceptionHandler seh;
	DWORD dwBitMask = PROPSET_DSO;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	//=====================================================================================
    // just pass this call on to the utility object that manages our properties
	//=====================================================================================
    hr = m_pObj->m_pUtilProp->GetPropertyInfo(
									m_pObj->m_fDSOInitialized,
									cPropertyIDSets, 
									rgPropertyIDSets,
									pcPropertyInfoSets, 
									prgPropertyInfoSets,
									ppDescBuffer);

	
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IDBDataSourceAdmin);

	CATCH_BLOCK_HRESULT(hr,L"IDBDataSourceAdmin::GetCreationProperties");
    return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CImpIDBDataSrcAdmin::GetCreationProperties 
//
// Gets datasource creation properties
//
// Returns one of the following values:

//      S_OK                       Method Succeeded
//      E_FAIL                     Provider-specific error
//		E_UNEXPECTED			   Datasource object was not initialized
//		DB_S_ERRORSOCCURRED		   One or more properties specified in were not supported
//      E_INVALIDARG               cPropertySets was not zero and rgPropertySets was null pointer
//		E_OUTOFMEMORY				out of memory
//		DB_E_ERRORSOCCURRED			values were not returned for any properties
//      OTHER                      Other HRESULTs returned by called functions
///////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIDBDataSrcAdmin::ModifyDataSource( ULONG cPropertySets,DBPROPSET  rgPropertySets[])
{
    HRESULT hr	= S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	hr = DB_E_NOTSUPPORTED;

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IDBDataSourceAdmin);

	CATCH_BLOCK_HRESULT(hr,L"IDBDataSourceAdmin::ModifyDataSource");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\idbbinderprop.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// IDBProperties and IDBInfo interface implementations
//
//////////////////////////////////////////////////////////////////////////////////////////////////
#include "headers.h"


//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Returns information about the different properties that can be set on the provider
//
//  HRESULT
//       S_OK           The method succeeded
//       E_INVALIDARG   pcPropertyInfo or prgPropertyInfo was NULL
//       E_OUTOFMEMORY  Out of memory
//
//////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP    CImplIDBBinderProperties::GetPropertyInfo (
	    ULONG				cPropertySets,		// IN   Number of properties being asked about
	    const DBPROPIDSET	rgPropertySets[],	// IN   Array of cPropertySets properties about which to return information
	    ULONG*				pcPropertyInfoSets,	// OUT  Number of properties for which information is being returned
	    DBPROPINFOSET**		prgPropertyInfoSets,// OUT  Buffer containing default values returned
		WCHAR**				ppDescBuffer		// OUT  Buffer containing property descriptions
    )
{
    assert( m_pObj );
    assert( m_pObj->m_pUtilProp );
	HRESULT hr	= S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock	cab(BINDER->GetCriticalSection());

	// Clear ErrorInfo
	g_pCError->ClearErrorInfo();

	//=====================================================================================
    // just pass this call on to the utility object that manages our properties
	//=====================================================================================
    hr = m_pObj->m_pUtilProp->GetPropertyInfo(
									m_pObj->m_fDSOInitialized,
									cPropertySets, 
									rgPropertySets,
									pcPropertyInfoSets, 
									prgPropertyInfoSets,
									ppDescBuffer);

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IDBBinderProperties);

	CATCH_BLOCK_HRESULT(hr,L"IDBBinderProperties::GetPropertyInfo");
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Returns current settings of all properties of the required property set
//
//  HRESULT
//       S_OK           The method succeeded
//       E_INVALIDARG   pcProperties or prgPropertyInfo was NULL
//       E_OUTOFMEMORY  Out of memory
//
//////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImplIDBBinderProperties::GetProperties (
						ULONG				cPropertySets,		// IN   count of restiction guids
						const DBPROPIDSET	rgPropertySets[],	// IN   restriction guids
						ULONG*              pcProperties,		// OUT  count of properties returned
						DBPROPSET**			prgProperties		// OUT  property information returned
    )
{
	DWORD dwBitMask = GetBitMask(rgPropertySets[0].guidPropertySet);

    assert( m_pObj );
    assert( m_pObj->m_pUtilProp );
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock	cab(BINDER->GetCriticalSection());

	// Clear ErrorInfo
	g_pCError->ClearErrorInfo();

	//=================================================================================
	// Check Arguments
	//=================================================================================
	hr = m_pObj->m_pUtilProp->GetPropertiesArgChk(dwBitMask, cPropertySets, rgPropertySets, pcProperties, prgProperties,m_pObj->m_fDSOInitialized);
	if ( !FAILED(hr) ){

		//=============================================================================
		// Just pass this call on to the utility object that manages our properties
		//=============================================================================
		hr = m_pObj->m_pUtilProp->GetProperties(dwBitMask,cPropertySets, rgPropertySets,pcProperties, prgProperties );
	}
	
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IDBBinderProperties);

	CATCH_BLOCK_HRESULT(hr,L"IDBBinderProperties::GetProperties");
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Set properties on the provider
//
//  HRESULT
//       S_OK          | The method succeeded
//       E_INVALIDARG  | cProperties was not equal to 0 and rgProperties was NULL
//
//////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP    CImplIDBBinderProperties::SetProperties (  ULONG		cProperties,DBPROPSET	rgProperties[]	)
{
    HRESULT hr			= E_FAIL;
	DWORD dwBitMask = GetBitMask(rgProperties[0].guidPropertySet);
    CSetStructuredExceptionHandler seh;

	assert( m_pObj );
    assert( m_pObj->m_pUtilProp );

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock	cab(BINDER->GetCriticalSection());

	// Clear ErrorInfo
	g_pCError->ClearErrorInfo();

	//===================================================================================
	// Quick return if the Count of Properties is 0
	//===================================================================================
	if( cProperties == 0 ){
		hr = S_OK ;
	}

	//===================================================================================
	// Check Arguments for use by properties
	//===================================================================================
	hr = m_pObj->m_pUtilProp->SetPropertiesArgChk(cProperties, rgProperties,m_pObj->m_fDSOInitialized);
	if( !FAILED(hr) ){


		//===================================================================================
		// just pass this call on to the utility object that manages our properties
		//===================================================================================
		hr = m_pObj->m_pUtilProp->SetProperties(dwBitMask,cProperties, rgProperties);
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IDBBinderProperties);

	CATCH_BLOCK_HRESULT(hr,L"IDBBinderProperties::SetProperties");
	return hr;
}


HRESULT CImplIDBBinderProperties::Reset()
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock	cab(BINDER->GetCriticalSection());

		// Clear ErrorInfo
	g_pCError->ClearErrorInfo();

	hr = m_pObj->m_pUtilProp->ResetProperties();
	
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IDBBinderProperties);

	CATCH_BLOCK_HRESULT(hr,L"IDBBinderProperties::Reset");
	return hr;
}



DWORD CImplIDBBinderProperties::GetBitMask(REFGUID rguid) 
{
	DWORD dwRet = 0;
	
	if( rguid == DBPROPSET_COLUMN || rguid == DBPROPSET_WMIOLEDB_COLUMN)
		dwRet = PROPSET_ROWSET;
	else
	if( rguid == DBPROPSET_DATASOURCE)
		dwRet = PROPSET_DSO	;
	else
	if( rguid == DBPROPSET_DATASOURCEINFO)
		dwRet = PROPSET_DSO;
	else
	if( rguid == DBPROPSET_DBINIT || rguid == DBPROPSET_WMIOLEDB_DBINIT)
		dwRet = PROPSET_DSOINIT;
	else
	if( rguid == DBPROPSET_ROWSET || rguid == DBPROPSET_WMIOLEDB_ROWSET)
		dwRet = PROPSET_ROWSET;
	else
	if( rguid == DBPROPSET_SESSION)
		dwRet = PROPSET_SESSION;

	return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\iindexdef.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
//
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//  IIndexDef.CPP IIndexDefinition interface implementation
//
///////////////////////////////////////////////////////////////////////////

#include "headers.h"

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Creates a index on a property of a class
//
// Returns one of the following values:
//      S_OK						Method Succeeded
//		E_FAIL						Generic Provider specific failure
//      DB_S_ERRORSOCCURED			creating index was successful with some errors
//		DB_E_ERRORSOCCURRED			Could not create index
//      E_INVALIDARG				One or more arguments was invalid
//      OTHER						Other HRESULTs returned by called functions
//		DB_E_NOTABLE				The table specified is not present
//		DB_SEC_E_PERMISSIONDENIED	User does not have permission to create index
//
//		Note: pIndexID	- Should be pointing to the columnname for which the index need to be added
//			  ppIndexID - will be pointing to the Index qualifier. ie. <ColumnName>/"Index"
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImplIIndexDefinition::CreateIndex(DBID *                    pTableID,
												DBID *                    pIndexID,
												DBORDINAL                 cIndexColumnDescs,
												const DBINDEXCOLUMNDESC   rgIndexColumnDescs[],
												ULONG                     cPropertySets,
												DBPROPSET                 rgPropertySets[],
												DBID **                   ppIndexID)

{
	HRESULT hr = E_FAIL;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the obect
	CAutoBlock cab(m_pObj->GetCriticalSection());
	LONG lSize = -1;

	// Clear Error information
	g_pCError->ClearErrorInfo();
	
	//===================================================================================
	//  Check the connection is valid
	//===================================================================================
	if ( m_pObj->m_pCDataSource->m_pWbemWrap->ValidConnection()  ){

		if( pIndexID->eKind != DBKIND_NAME || 0 == wcslen(pIndexID->uName.pwszName) ||
			pTableID->eKind != DBKIND_NAME || 0 == wcslen(pTableID->uName.pwszName))
		{
			hr = E_INVALIDARG;
		}
		else
		{

    		CWmiOleDBMap Map;
    		if(SUCCEEDED(hr =Map.FInit(NO_QUALIFIERS,pTableID->uName.pwszName,m_pObj->m_pCDataSource->m_pWbemWrap)))
			{
	 			if(S_OK == (hr = Map.AddIndex(pIndexID))  && ppIndexID != NULL)
				{
					try
					{
						// Allocate memory for DBID
						(*ppIndexID) = (DBID *)g_pIMalloc->Alloc(sizeof(DBID));
					}
					catch(...)
					{
						if(*ppIndexID)
						{
							g_pIMalloc->Free(*ppIndexID);
							(*ppIndexID) = NULL;
						}
						throw;
					}

					if(*ppIndexID == NULL)
					{
						hr = E_OUTOFMEMORY;
					}
					else
					{
						(*ppIndexID)->eKind = DBKIND_NAME;
						// Allocate memory for then tablename
						lSize = sizeof(WCHAR) *(wcslen(pIndexID->uName.pwszName) + \
												wcslen(strIndex) + \
												wcslen(SEPARATOR) + 1);
												
						// Allocate memory for qualifer name which gives the indexID
						(*ppIndexID)->uName.pwszName = (WCHAR *)g_pIMalloc->Alloc(lSize);
						wcscpy((*ppIndexID)->uName.pwszName,pIndexID->uName.pwszName);
						wcscat((*ppIndexID)->uName.pwszName,SEPARATOR);
						wcscat((*ppIndexID)->uName.pwszName,strIndex);
					}
				}
			}
			
		}
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IIndexDefinition);

	CATCH_BLOCK_HRESULT(hr,L"IIndexDefinition::CreateIndex");
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Creates a index on a property of a class
//
// Returns one of the following values:
//      S_OK						Method Succeeded
//		E_FAIL						Generic Provider specific failure
//      DB_S_ERRORSOCCURED			creating index was successful with some errors
//		DB_E_ERRORSOCCURRED			Could not create index
//      E_INVALIDARG				One or more arguments was invalid
//      DB_E_NOINDEX				index not present
//		DB_E_NOTABLE				The table specified is not present
//		DB_SEC_E_PERMISSIONDENIED	User does not have permission to create index
//
//		pIndexID - will be pointing to the index qualifier ie.<columnName>/"Index"
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImplIIndexDefinition::DropIndex( DBID * pTableID, DBID * pIndexID)
{
	HRESULT hr = E_FAIL;
	LONG lSize = -1;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the obect
	CAutoBlock cab(m_pObj->GetCriticalSection());
	//===================================================================================
	//  Check the connection is valid
	//===================================================================================
	// Clear Error information
	g_pCError->ClearErrorInfo();

	if ( m_pObj->m_pCDataSource->m_pWbemWrap->ValidConnection()  ){

		if( pIndexID->eKind != DBKIND_NAME || 0 == wcslen(pIndexID->uName.pwszName) ||
			pTableID->eKind != DBKIND_NAME || 0 == wcslen(pTableID->uName.pwszName))
		{
			hr = E_INVALIDARG;
		}
		else
		{

    		CWmiOleDBMap Map;
    		if(SUCCEEDED(hr = Map.FInit(NO_QUALIFIERS,pTableID->uName.pwszName,m_pObj->m_pCDataSource->m_pWbemWrap)))
			{
	 			hr = Map.DropIndex(pIndexID);
			}
			
		}
	}
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IIndexDefinition);

	CATCH_BLOCK_HRESULT(hr,L"IIndexDefinition::CreateIndex");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\iobjaccesscontrol.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//
//  IObjAccessControl.cpp - IObjectAccessControl interface implementation
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CImpIObjectAccessControl::GetObjectAccessRights 
//
// Gets a list of all access rights 
//
// Returns one of the following values:

///////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIObjectAccessControl::GetObjectAccessRights( SEC_OBJECT  *pObject,
																ULONG  *pcAccessEntries,
																EXPLICIT_ACCESS_W **prgAccessEntries)
{
    HRESULT hr	= S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	if (!m_pObj->m_fDSOInitialized)
	{
		hr = E_UNEXPECTED;
	}
	else
	if(( *pcAccessEntries != 0 && *prgAccessEntries == NULL) ||
		!pcAccessEntries || !prgAccessEntries )
	{
		hr = E_INVALIDARG;
	}
	else
	if(SUCCEEDED(hr = IfValidSecObject(pObject)))
	{
		CBSTR strTemp(pObject->prgObjects->ObjectID.uName.pwszName);
		if(!m_pObj->m_pWbemWrap->IsValidObject(strTemp))
		{
			hr = SEC_E_INVALIDOBJECT;
		}
	}

	if(SUCCEEDED(hr))
	{
		ULONG ulExplicitAccess = 0;
		EXPLICIT_ACCESS_W *pAccessEntriesTemp  = NULL;

		CBSTR strTemp(pObject->prgObjects[0].ObjectID.uName.pwszName);
		
		hr = m_pObj->m_pWbemWrap->GetObjectAccessRights(strTemp,
														&ulExplicitAccess,
														&pAccessEntriesTemp,
														*pcAccessEntries,
														*prgAccessEntries);

	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IObjectAccessControl);

	CATCH_BLOCK_HRESULT(hr,L"IObjectAccessControl::GetObjectAccessRights");
    return hr;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CImpIObjectAccessControl::GetObjectOwner 
//
// Get the owner of the object
//
// Returns one of the following values:

///////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIObjectAccessControl::GetObjectOwner( SEC_OBJECT  *pObject,TRUSTEE_W  ** ppOwner)
{
    HRESULT hr	= S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	if (m_pObj->m_fDSOInitialized)
	{
		hr = E_UNEXPECTED;
	}
	else
	if( *ppOwner == NULL)
	{
		hr = E_INVALIDARG;
	}
	else
	if(SUCCEEDED(hr = IfValidSecObject(pObject)))
	{
		{
			CBSTR strTemp(pObject->prgObjects->ObjectID.uName.pwszName);
			if(!m_pObj->m_pWbemWrap->IsValidObject(strTemp))
			{
				hr = SEC_E_INVALIDOBJECT;
			}
		}
	}

	if(SUCCEEDED(hr))
	{
		CBSTR strObj(pObject->prgObjects->ObjectID.uName.pwszName);
		hr = m_pObj->m_pWbemWrap->GetObjectOwner(strObj,ppOwner);
	}



	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IObjectAccessControl);

	CATCH_BLOCK_HRESULT(hr,L"IObjectAccessControl::GetObjectOwner");
    return hr;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CImpIObjectAccessControl::IsObjectAccessAllowed 
//
// Checks if the a trustee has the given access on the object
//
// Returns one of the following values:

///////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIObjectAccessControl::IsObjectAccessAllowed(	SEC_OBJECT *pObject,
																EXPLICIT_ACCESS_W *pAccessEntry,
																BOOL  *pfResult)
{
    HRESULT hr	= S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	if (m_pObj->m_fDSOInitialized)
	{
		hr = E_UNEXPECTED;
	}
	else
	if(pAccessEntry == NULL  || !pfResult)
	{
		hr = E_INVALIDARG;
	}
	else
	if(SUCCEEDED(hr = IfValidSecObject(pObject)))
	{
		CBSTR strTemp(pObject->prgObjects->ObjectID.uName.pwszName);
		if(!m_pObj->m_pWbemWrap->IsValidObject(strTemp))
		{
			hr = SEC_E_INVALIDOBJECT;
		}
	}

	if(SUCCEEDED(hr))
	{
		CBSTR strObj(pObject->prgObjects->ObjectID.uName.pwszName);
		hr = m_pObj->m_pWbemWrap->IsObjectAccessAllowed(strObj,pAccessEntry,pfResult);
	}


	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IObjectAccessControl);
	CATCH_BLOCK_HRESULT(hr,L"IObjectAccessControl::IsObjectAccessAllowed");
    return hr;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CImpIObjectAccessControl::SetObjectAccessRights 
//
// Set the AccessRights for a particular object
//
// Returns one of the following values:

///////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIObjectAccessControl::SetObjectAccessRights(	SEC_OBJECT  *pObject,
																ULONG cAccessEntries,
																EXPLICIT_ACCESS_W *prgAccessEntries)
{
    HRESULT hr	= S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	if (m_pObj->m_fDSOInitialized)
	{
		hr = E_UNEXPECTED;
	}
	else
	if(( cAccessEntries != 0 && prgAccessEntries == NULL) ||
		 !pObject)
	{
		hr = E_INVALIDARG;
	}
	else
	if(SUCCEEDED(hr = IfValidSecObject(pObject)))
	{
		if(cAccessEntries != 0)
		{
			CBSTR strTemp(pObject->prgObjects->ObjectID.uName.pwszName);
			if(!m_pObj->m_pWbemWrap->IsValidObject(strTemp))
			{
				hr = SEC_E_INVALIDOBJECT;
			}
		
			if(SUCCEEDED(hr))
			{
				ULONG ulExplicitAccess = 0;
				EXPLICIT_ACCESS_W *pAccessEntriesTemp  = NULL;

				CBSTR strTemp(pObject->prgObjects[0].ObjectID.uName.pwszName);
				hr = m_pObj->m_pWbemWrap->SetObjectAccessRights(strTemp,
																cAccessEntries,
																prgAccessEntries);

			}
		}
	}
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IObjectAccessControl);

	CATCH_BLOCK_HRESULT(hr,L"IObjectAccessControl::SetObjectAccessRights");
    return hr;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CImpIObjectAccessControl::SetObjectOwner 
//
// Set Owner for a particular object
//
// Returns one of the following values:

///////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIObjectAccessControl::SetObjectOwner( SEC_OBJECT  *pObject,TRUSTEE_W  *pOwner)
{
    HRESULT hr	= S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	if (m_pObj->m_fDSOInitialized)
	{
		hr = E_UNEXPECTED;
	}
	else
	if(!pOwner)
	{
		hr = E_INVALIDARG;
	}
	else
	if(SUCCEEDED(hr = IfValidSecObject(pObject)))
	{
		CBSTR strTemp(pObject->prgObjects->ObjectID.uName.pwszName);
		if(!m_pObj->m_pWbemWrap->IsValidObject(strTemp))
		{
			hr = SEC_E_INVALIDOBJECT;
		}
	}

	if(SUCCEEDED(hr))
	{
		CBSTR strObj(pObject->prgObjects->ObjectID.uName.pwszName);
		hr = m_pObj->m_pWbemWrap->SetObjectOwner(strObj,pOwner);
	}


	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IObjectAccessControl);

	CATCH_BLOCK_HRESULT(hr,L"IObjectAccessControl::SetObjectOwner");
    return hr;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CImpIObjectAccessControl::IfValidSecObject 
//
// a function to validate SEC_OBJECT parameter
//
// Returns one of the following values:
//		E_INVALIDARG
//		SEC_E_INVALIDOBJECT

///////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIObjectAccessControl::IfValidSecObject(SEC_OBJECT  *pObject)
{
	HRESULT hr = S_OK;

	if(!pObject)
	{
		hr = E_INVALIDARG;
	}
	else
	if((pObject->cObjects != 0 && pObject->prgObjects == NULL) ||
		pObject->cObjects > 1)
	{
		hr = E_INVALIDARG;
	}
	else
	if(pObject->cObjects == 0 )
	{
		hr = SEC_E_INVALIDOBJECT;
	}
	else
	// WMIOLEDB allows setting/setting security for only one object
	if(pObject->cObjects != 1)
	{
		hr = E_INVALIDARG;
	}
	else if(pObject->prgObjects[0].guidObjectType != DBOBJECT_TABLE  &&
			pObject->prgObjects[0].guidObjectType != DBOBJECT_DATABASE  &&
			pObject->prgObjects[0].guidObjectType != DBOBJECT_WMIINSTANCE)
	{
		hr = SEC_E_INVALIDOBJECT;
	}
	else
	if(pObject->prgObjects->ObjectID.eKind != DBKIND_NAME)
	{
		hr = E_INVALIDARG;
	}

	
	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\irow.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
//
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//  IROW.CPP IRow interface implementation
//
///////////////////////////////////////////////////////////////////////////

#include "headers.h"


//////////////////////////////////////////////////////////////////////////////////////
// Get the column values  
//////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIRow::GetColumns(DBORDINAL cColumns,DBCOLUMNACCESS   rgColumns[ ])
{
	HRESULT hr = E_FAIL;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	if( cColumns > 0)
	{
		// if there are columns to be retrieved and 
		// if the the output DBCOLUMNACCESS pointer is NULL
		if( cColumns > 0 && rgColumns == NULL)
		{
			hr = E_INVALIDARG;
		}
		else
		{
			// Get the columns and data for the required columns
			hr = m_pObj->GetColumns(cColumns,rgColumns);
		}
	}
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRow);

	CATCH_BLOCK_HRESULT(hr,L"IRow::GetColumns");
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////
// Get the source rowset if any
//////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIRow::GetSourceRowset(REFIID riid,IUnknown ** ppRowset,HROW *phRow)
{
	HRESULT hr = E_FAIL;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	// If there is any source rowset then query for the required interface
	if(m_pObj->m_pSourcesRowset != NULL)
	{
		hr = m_pObj->m_pSourcesRowset->QueryInterface(riid , (void **)ppRowset);
		if(phRow != NULL && hr == S_OK)
		{
			*phRow = m_pObj->m_hRow;
		}
	}
	else
	{
		hr = DB_E_NOSOURCEOBJECT;
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRow);

	CATCH_BLOCK_HRESULT(hr,L"IRow::GetSourceRowset");
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////
// Open a row identified by the column
//////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIRow::Open(  IUnknown *    pUnkOuter,
			   DBID *        pColumnID,
			   REFGUID       rguidColumnType,
			   DWORD         dwFlags,
			   REFIID        riid,
			   IUnknown **   ppUnk)
{
	HRESULT		hr				= E_FAIL;
	DBORDINAL	iCol			= 0;
	BOOL		bIsChildRowset	= TRUE;
	VARIANT		varValue;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	VariantInit(&varValue);

	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	if( pUnkOuter != NULL && riid != IID_IUnknown)
	{
		hr = DB_E_NOAGGREGATION;
	}
	else
	if(!(pColumnID->eKind == DBKIND_NAME) || (pColumnID->eKind == DBKIND_NAME && pColumnID->uName.pwszName == NULL))
	{
		hr = DB_E_BADCOLUMNID;
	}
	
	// This function is implemented only to give the child rowset and if 
	// consumer asks for any other type of object then return error
	else
	// NTRaid:135384
	if(rguidColumnType != DBGUID_ROWSET && rguidColumnType != DBGUID_ROW && rguidColumnType != GUID_NULL)
	{
		hr = E_INVALIDARG;
	}
	else
	{

		iCol = m_pObj->m_pRowColumns->GetColOrdinal(pColumnID->uName.pwszName);
		LONG lColumnType = m_pObj->m_pRowColumns->ColumnType(iCol);
		LONG lColumnFlag = m_pObj->m_pRowColumns->ColumnFlags(iCol);

		if(lColumnType == DBTYPE_IUNKNOWN)
		{
			hr = m_pObj->GetIUnknownColumnValue(iCol,riid,ppUnk,pColumnID->uName.pwszName);
		}
		else
		// The column unavailable for the row as the class qualifier belongs to a parent rowset
		if(m_pObj->m_pSourcesRowset != NULL && S_OK == (hr =m_pObj->m_pCreator->GetDataSrcProperty(DBPROP_WMIOLEDB_QUALIFIERS,varValue)))
		if(	(varValue.lVal & CLASS_QUALIFIERS) && 
						m_pObj->m_bClassChanged && 
						iCol == 1 && 
						m_pObj->m_pRowColumns->ColumnType(iCol) == DBTYPE_HCHAPTER)
		{
			hr = DB_E_NOTFOUND;
		}
		else
		if((DB_LORDINAL)iCol < 0)
		{
			hr = DB_E_BADCOLUMNID;
		}
		else
		{

			hr = S_OK;
			switch(lColumnType)
			{
				// if the type is HCHAPTER then column can be only rowset
				case DBTYPE_HCHAPTER :
					if(lColumnFlag != DBCOLUMNFLAGS_ISCOLLECTION && m_pObj->m_pSourcesRowset == NULL)
					{
						hr = DB_E_BADCOLUMNID;
					}
					else
					if(rguidColumnType != DBGUID_ROWSET)
					{
						hr = DB_E_OBJECTMISMATCH;
					}
					break;

				// column is a BSTR with the flag DBCOLUMNFLAGS_ISROWURL then the requested object 
				// has to be ROW object
				case DBTYPE_BSTR :
					if(!(lColumnFlag & DBCOLUMNFLAGS_ISROWURL))
					{
						hr = DB_E_BADCOLUMNID;
					}
					else
					if(rguidColumnType  != DBGUID_ROW)
					{
						hr = DB_E_OBJECTMISMATCH;
					}
					else
					{
						bIsChildRowset = FALSE;
					}

					break;
			};

			// Open the column if everything is ok
			if(SUCCEEDED(hr))
			{

				assert(dwFlags == 0);

				hr = m_pObj->OpenChild(pUnkOuter,pColumnID->uName.pwszName ,riid,ppUnk,bIsChildRowset);
			}
		}
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRow);

	CATCH_BLOCK_HRESULT(hr,L"IRow::Open");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\instrowfetch.cpp ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CInstanceRowFetchObj object implementation
// 
//
///////////////////////////////////////////////////////////////////////////////////

#include "headers.h"
#include "WmiOleDBMap.h"

///////////////////////////////////////////////////////////////////////////////////////
// Function which fetches required number of rows
///////////////////////////////////////////////////////////////////////////////////////
HRESULT CInstanceRowFetchObj::FetchRows(CRowset *	 pRowset,
								HCHAPTER		hChapter,        // IN  The Chapter handle.
								DBROWOFFSET		lRowOffset,      // IN  Rows to skip before reading
								DBROWCOUNT		cRows,           // IN  Number of rows to fetch
								DBCOUNTITEM*	pcRowsObtained, // OUT Number of rows obtained
								HROW       **	prghRows)       // OUT Array of Hrows obtained)

{
    DBCOUNTITEM	cRowsTmp				= 0;
    HROW		irow(0), ih(0);
    PROWBUFF	prowbuff				= NULL;
    HRESULT		hr						= S_OK;
	HROW		*prghRowsTemp			= NULL;
	HROW		hRowCurrent				= 0;
	HSLOT		hSlot					= -1;
	BOOL		bAlreadyDataRetrieved	= FALSE;
	BOOL		bAlreadyFetched			= FALSE;
	CVARIANT	varKey;
	BOOL		bFetchBack				= FALSE;
	HROW		hRowTemp				= 0;
	CBSTR		strKey;
	LONG_PTR	lFetchPos				= 0;
	DBROWCOUNT	ulMax					= 0;
	BOOL		bMaxRowsExceed			= FALSE;
	DBSTATUS	dwStat					= DBSTATUS_S_OK;
	BOOL		bHRowsAllocated			= FALSE;
	CWbemClassWrapper *pInst = NULL;


	if(cRows != 0)
	{
		{
			VARIANT		varTemp;
			VariantInit(&varTemp);
			pRowset->GetRowsetProperty(DBPROP_MAXOPENROWS,varTemp);

			ulMax	= varTemp.lVal;
			VariantClear(&varTemp);
		}


		//=======================================================
		// If already maximum rows are opened then return
		//=======================================================
		if( pRowset->m_ulRowRefCount >= (DBROWCOUNT)ulMax)
		{
			hr =  DB_S_ROWLIMITEXCEEDED;
		}
		else
		{
			//========================
			// Fetch Data
			//========================
			 if (lRowOffset)
			{
				//===================================
				// Calculate the new position
				//===================================
				hr = pRowset->ResetRowsetToNewPosition(lRowOffset,pInst);
				if( FAILED(hr))
				{
					pRowset->SetStatus(hChapter , STAT_ENDOFCURSOR);
					hr =  DB_S_ENDOFROWSET ;
				}
			}
			// 07/11/00
			 //141938
			if(hr == S_OK)
			{
				if(0 >( lFetchPos = GetFirstFetchPos(pRowset,cRows,lRowOffset)))
				{
					hr = DB_E_BADSTARTPOSITION;
				}
				else
				{
					cRowsTmp	= cRows >= 0 ? cRows : cRows * (-1);
					ulMax	= ulMax - pRowset->m_ulRowRefCount;
					if(ulMax < (DBROWCOUNT)cRowsTmp)
					{
						bMaxRowsExceed = TRUE;
					}
					else
					{
						ulMax = cRowsTmp;
					}
					cRowsTmp = 0;

					//=======================================================================
					// If any rows is to be retrieved then allocate memory for the HROWS
					//=======================================================================
					if (ulMax )
					{
						try
						{
							prghRowsTemp = (HROW *) g_pIMalloc->Alloc( ulMax * sizeof( HROW ));
						}
						catch(...)
						{
							if(prghRowsTemp != NULL)
							{
								g_pIMalloc->Free(prghRowsTemp);
							}
							throw;
						}
					}
					if(prghRowsTemp == NULL)
					{
						hr = E_OUTOFMEMORY;
					}
					else
					{
						memset(prghRowsTemp,0,ulMax * sizeof(HROW));

						pRowset->m_FetchDir = (LONG_PTR)cRows < 0 ? FETCHDIRBACKWARD : FETCHDIRFORWARD;
						bFetchBack			= (LONG_PTR)cRows < 0 ? TRUE : FALSE;

						hRowTemp = pRowset->m_hRowLastFetched;
						for (irow =1; irow <= (ULONG)ulMax; irow++)
						{
							bAlreadyFetched			= FALSE;
							bAlreadyDataRetrieved	= FALSE;
							dwStat					= DBSTATUS_S_OK;

							//============================================================
							// Get the pointer to the next instance
							//============================================================
							if (S_OK != ( hr = pRowset->GetNextInstance(pInst,strKey,bFetchBack)))
							{
								pRowset->SetStatus(hChapter , STAT_ENDOFCURSOR);
								hr = DB_S_ENDOFROWSET;
								break;
							}
						
							//==========================================================================
							// If the instance is a deleted instance and deleted instance is to be
							// removed then continue to the next instance 
							// If the rowset is opened in dyanamic cursor mode then skipping of
							// deleted row doesn't depend on REMOVEDELETED
							//==========================================================================
							if(pRowset->IsInstanceDeleted(pInst) &&
								(pRowset->m_ulProps & OTHERINSERT)  || 
								 ( pRowset->m_ulProps & REMOVEDELETED) )
							{
								irow--;
								continue;
							}

							//=================================================================
							// Check if instance already exist 
							//=================================================================
							bAlreadyFetched  = pRowset->m_InstMgr->IsInstanceExist(strKey);
						
							//==========================================================================
							// If not able to find the instance by key ( key might change sometime
							// in some cases if all the properties are keys) So check if the instance
							// is already fetched by the instance pointers
							//==========================================================================
							if(bAlreadyFetched == FALSE)
							{
								bAlreadyFetched  = pRowset->m_InstMgr->IsInstanceExist(pInst );
								
								//==========================================================================
								// if found the instance has to be refreshed
								//==========================================================================
								if(bAlreadyFetched == TRUE)
								{
									pRowset->RefreshInstance(pInst);
								}
							}


							//==================================================================
							// if already exists get the HROW and slot number for the instance
							//==================================================================
							if(bAlreadyFetched == TRUE)
							{
								hRowCurrent = pRowset->m_InstMgr->GetHRow(strKey);
								
								if((pRowset->GetRowStatus(hRowCurrent) & DBROWSTATUS_E_DELETED) && ( pRowset->m_ulProps & REMOVEDELETED))
								{
									continue;
								}

								//=================================================================
								// if the slot number for the instance exist this means thet
								// data is already retrieved for the row
								//=================================================================
								if((hSlot = pRowset->m_InstMgr->GetSlot(hRowCurrent)) != -1)
								{
									bAlreadyDataRetrieved = TRUE;
								}

							}
							else
							{
								hRowCurrent = pRowset->GetNextHRow();
							}
							//=====================================================
							// Get the data if data is already not fetched
							//=====================================================
							if(bAlreadyDataRetrieved == FALSE)
							{
								

								hSlot		= -1;
								//============================================
								// Get the next slot for retrieving data and 
								// bind it to the column mem manager
								//============================================
								if (FAILED( hr = GetNextSlots( pRowset->m_pIBuffer, 1, &hSlot )))
								{
									break;
								}
								
								if (FAILED( pRowset->Rebind((BYTE *) pRowset->GetRowBuffFromSlot( hSlot, TRUE ))))
								{
									hr = E_FAIL;
									break;
								}

								hRowCurrent = hSlot;

								//=========================================================
								// fill the bookmark with keyvalue of the instance
								//=========================================================
								varKey.SetStr(strKey);
								//=================================================================================================
								// if the other updates visible property is set to false ,then get the data to the local buffer
								//=================================================================================================
								if(!( pRowset->m_ulProps & OTHERUPDATEDELETE))
								{

									if(FAILED(hr = pRowset->GetInstanceDataToLocalBuffer(pInst,hSlot)))
									{
										break;
									}
							
									//===========================================================================
									// if there is atleast one row retrieved and there are neseted columns
									// then allocate rows for the child recordsets
									//===========================================================================
									if(pRowset->m_cNestedCols > 0 )

									{
										if(pRowset->m_ppChildRowsets == NULL)
										{
											pRowset->AllocateAndInitializeChildRowsets();
										}

										//=====================================================================
										// Fill the HCHAPTERS for the column
										//=====================================================================
										if(FAILED(hr = pRowset->FillHChaptersForRow(pInst,strKey)))
										{
											break;
										}
									}

								}


								//=================================================
								// add instance pointer to instance manager
								//=================================================
								if(FAILED(hr = pRowset->m_InstMgr->AddInstanceToList(hRowCurrent,pInst,strKey,hSlot)))
								{
									break;
								}

								//=====================================================
								// if the row is deleted then set the row status
								//=====================================================
								if(pRowset->IsInstanceDeleted(pInst) && SUCCEEDED(hr))
								{
									pRowset->SetRowStatus(hRowCurrent,DBROWSTATUS_E_DELETED);
								}

								varKey.Clear();
							}
							
							prghRowsTemp[irow-1] = hSlot;

							strKey.Clear();
							strKey.Unbind();
						}
						
						if(SUCCEEDED(hr))
						{
							cRowsTmp = irow - 1; //Irow will be +1 because of For Loop


							//=====================================================================
							// Through fetching many rows of data
							//
							// Allocate row handles for client. Note that we need to use IMalloc 
							// for this. Should only malloc cRowsTmp, instead of cRows.
							// Should malloc cRows, since client will assume it's that big.
							//=====================================================================


							if ( *prghRows == NULL && cRowsTmp )
							{
								try
								{
									*prghRows = (HROW *) g_pIMalloc->Alloc( cRowsTmp * sizeof( HROW ));
								}
								catch(...)
								{
									if(*prghRows)
									{
										g_pIMalloc->Free(*prghRows);
									}
									throw;
								}
								bHRowsAllocated = TRUE;
							}

							if ( *prghRows == NULL  && cRowsTmp )
							{
								hr =  E_OUTOFMEMORY ;
								
							}
							else
							{
								memset(*prghRows,0,cRowsTmp * sizeof( HROW ));
								//=====================================================================
								// Fill in the status information: Length, IsNull. May be able to wait 
								// until first call to GetData, but have to do it sometime.
								//
								// Suggest keeping an array of structs of accessor info. One element is
								// whether accessor requires any status info or length info.
								//
								// Then we could skip this whole section.
								//
								// Added check for cRowsTmp to MarkRows call. Don't want to call if 
								// cRowsTmp==0.
								// (Range passed to MarkRows is inclusive, so can't specify marking 0 rows.)
								//
								// Note that SetSlots is a CBitArray member function -- not an IBuffer function.
								//
								// Bits are [0...n-1], row handles are [1...n].
								//
								// Cleanup. Row handles, bits, indices are the same [m....(m+n)], where 
								// m is some # >0,
								//
								// Added row-wise reference counts and cursor-wise reference counts.
								//
								// Set row handles, fix data length field and compute data status field.
								//=======================================================================
								pRowset->m_cRows   = cRowsTmp;
								

								for (ih =0; ih < (ULONG) pRowset->m_cRows; ih++) 
								{


									//=============================================================================
									// Increment the rows-read count,
									// then store it as the bookmark in the very first DWORD of the row.
									//=============================================================================
									prowbuff = pRowset->GetRowBuff( prghRowsTemp[ih], TRUE );

									//=======================================================================================
									// Insert the bookmark and its row number (from 1...n) into a hash table.
									// This allows us to quickly determine the presence of a row in mem, given the bookmark.
									// The bookmark is contained in the row buffer, at the very beginning.
									// Bookmark is the row number within the entire result set [1...num_rows_read].

									// This was a new Bookmark, not in memory,
									// so return to user (in *prghRows) the hRow we stored.
									//=======================================================================================
									prowbuff->ulRefCount++;
									pRowset->m_ulRowRefCount++;
									(*prghRows)[ih] = prghRowsTemp[ih]; // (HROW) ( irow );
									pRowset->m_hRowLastFetched	= prghRowsTemp[ih];

									if(pRowset->m_ulProps & BOOKMARKPROP)
									{
										if(ih != 0)
										{
											lFetchPos = (pRowset->m_FetchDir == FETCHDIRFORWARD ) ?  lFetchPos + 1  : lFetchPos -1;
										}
        
										prowbuff->dwBmk				= lFetchPos;
										prowbuff->cbBmk				= BOOKMARKSIZE;
										pRowset->m_lLastFetchPos	= lFetchPos;

										// Add bookmark to the hashtable
										pRowset->m_pHashTblBkmark->InsertFindBmk(FALSE,prghRowsTemp[ih],prowbuff->cbBmk,(BYTE *)&(prowbuff->dwBmk),(ULONG_PTR*)&hSlot);

										
									}
        
								}
							}		// If proper allocation of *prghRows if required
						}		// If succeeded(hr) after the loop
						
						if(SUCCEEDED(hr))
						{
							*pcRowsObtained = cRowsTmp;
						}

						//=====================================================
						// if the number of rows asked is more than
						// the max number of open rows and if there 
						// is no error then set the error number
						//=====================================================
						if( hr == S_OK && bMaxRowsExceed == TRUE)
						{
							hr = DB_S_ROWLIMITEXCEEDED;
						}
					}	// Else for check for proper allocation prghRowsTemp

				}	// Else for check for DB_E_BADSTARTPOSITION

			}

		}
	
	}		// if cRow > 0


	// IF failed clean up
	if( FAILED(hr))
	{
		for (ih =0; ih < (ULONG) cRowsTmp; ih++) 
		{
			if(prghRowsTemp[ih] != 0)
			{
				pRowset->m_InstMgr->DeleteInstanceFromList(prghRowsTemp[ih]);
			}
		}

		if(pcRowsObtained)
		{
			*pcRowsObtained = 0;
		}

		if(prghRows && bHRowsAllocated == TRUE)
		{
			g_pIMalloc->Free(prghRows);
			prghRows = NULL;
		}
		else
		if(prghRows)
		{
			*prghRows = NULL;
		}
		if(pcRowsObtained)
		{
			*pcRowsObtained = 0;
		}

	}

	//==============================================
	// free the temporary memory allocated
	//==============================================
	if(prghRowsTemp)
	{
		g_pIMalloc->Free(prghRowsTemp);
		prghRowsTemp = NULL;
	}

	// reset the starting position to the original position
	if(lRowOffset && (FAILED(hr) || (hr != S_OK && cRowsTmp == 0)))
	{
		pRowset->ResetRowsetToNewPosition(lRowOffset * (-1),pInst);
	}

	return hr;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\irowchng.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
//
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//  IROWChng.CPP IRowChange interface implementation
//
///////////////////////////////////////////////////////////////////////////

#include "headers.h"

STDMETHODIMP CImpIRowChange::SetColumns(DBORDINAL cColumns,DBCOLUMNACCESS rgColumns[ ])
{
	HRESULT hr = E_FAIL;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	hr = m_pObj->UpdateRow(cColumns,rgColumns);

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowChange);

	CATCH_BLOCK_HRESULT(hr,L"IRowChange::SetColumns");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\irowset.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
//
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//  IROWSET.CPP IRowsetLocate interface implementation
//
///////////////////////////////////////////////////////////////////////////

#include "headers.h"


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Retrieves data from the rowset's cache
//
// Returns one of the following values:
//      S_OK                    Method Succeeded
//      DB_S_ERRORSOCCURED      Could not coerce a column value
//      DB_E_BADACCESSORHANDLE  Invalid Accessor given
//      DB_E_BADROWHANDLE       Invalid row handle given
//      E_INVALIDARG            pData was NULL
//      OTHER                   Other HRESULTs returned by called functions
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIRowsetLocate::GetData(  HROW  hRow,             //IN  Row Handle
                                    HACCESSOR   hAccessor,  //IN  Accessor to use
                                    void       *pData  )    //OUT Pointer to buffer where data should go.
{
	HRESULT hr = DB_E_BADROWHANDLE;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());
	g_pCError->ClearErrorInfo();
	

	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
	if( hRow > 0)
	{
		//============================================================
		// Call this function of RowFetch Object to fetch data
		//============================================================
		hr =  m_pObj->m_pRowFetchObj->FetchData(m_pObj,hRow,hAccessor,pData);
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetLocate);

	CATCH_BLOCK_HRESULT(hr,L"IRowset::GetData");
	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CImpIRowset::GetNextRows 
//
// Fetches rows in a sequential style, remembering the previous position
//
// Returns one of the following values:

//      S_OK                       Method Succeeded
//      DB_S_ENDOFROWSET           Reached end of rowset
//      DB_E_CANTFETCHBACKWARDS    cRows was negative and we can't fetch backwards
//      DB_E_ROWSNOTRELEASED       Must release all HROWs before calling GetNextRows
//      E_FAIL                     Provider-specific error
//      E_INVALIDARG               pcRowsObtained or prghRows was NULL
//      E_OUTOFMEMORY              Out of Memory
//      OTHER                      Other HRESULTs returned by called functions
///////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIRowsetLocate::GetNextRows ( HCHAPTER   hChapter,        // IN  The Chapter handle.
                                        DBROWOFFSET       lRowOffset,      // IN  Rows to skip before reading
                                        DBROWCOUNT       cRows,           // IN  Number of rows to fetch
                                        DBCOUNTITEM      *pcRowsObtained, // OUT Number of rows obtained
                                        HROW       **prghRows       // OUT Array of Hrows obtained
                                        )
{
    HRESULT		hr;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());
	// clear error information
	g_pCError->ClearErrorInfo();

    //========================================================================
    //  Check the HChapter is of the current rowset is valid
    //========================================================================
	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
	if((m_pObj->m_bIsChildRs == TRUE && hChapter == DB_NULL_HCHAPTER) || (LONG_PTR)hChapter < 0  || 
		m_pObj->m_bIsChildRs == FALSE && hChapter != 0)
	{
		hr = DB_E_BADCHAPTER;
	}
	else
	{
		//========================================================================
		//  Check the rowset parameters to see if we support this request
		//========================================================================
		if(SUCCEEDED(hr = CheckParameters(pcRowsObtained, lRowOffset, cRows, prghRows)))
		{
			if(hChapter)
			{
				hr = m_pObj->CheckAndInitializeChapter(hChapter);
			}
			
			if(SUCCEEDED(hr))
			{
				// Create the data members to manage the data only the first time
				if(!m_pObj->m_bHelperFunctionCreated)
				{
					if( SUCCEEDED(hr = m_pObj->CreateHelperFunctions()))
					{
						m_pObj->m_bHelperFunctionCreated = TRUE;
					}
				}

				if(SUCCEEDED(hr))
				{
					//========================================================================
					// Are there any unreleased rows?
					//========================================================================
					if( ((m_pObj->m_pIAccessor->GetBitArrayPtr())->ArrayEmpty() != S_OK) && !(m_pObj->m_ulProps & CANHOLDROWS) )
					{
						hr = DB_E_ROWSNOTRELEASED;
					}
					else
					{
						//============================================================
						// Call this function of Rowfetch object to fetch rows
						//============================================================
						hr = m_pObj->m_pRowFetchObj->FetchRows(m_pObj,hChapter,lRowOffset,cRows,pcRowsObtained,prghRows);
					}	// else
				
				} // if succeeded(hr)
			
			} // if succeeded(hr)
		} // if succeeded(hr)
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowset);

	CATCH_BLOCK_HRESULT(hr,L"IRowset::GetNextRows");
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Releases row handles
//
// 	Returns one of the following values:
// 			 S_OK 						| success
// 			 DB_S_ERRORSOCCURRED		| some elements of rghRows were invalid
// 			 DB_E_ERRORSOCCURRED		| all elements of rghRows were invalid
// 			 E_INVALIDARG 				| rghRows was a NULL pointer and crow > 0
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIRowsetLocate::ReleaseRows ( DBCOUNTITEM		cRows,          // IN Number of rows to release
                                        const HROW		rghRows[],      // IN Array of handles of rows to be released
	                                    DBROWOPTIONS	rgRowOptions[],	// IN Additional Options
	                                    DBREFCOUNT		rgRefCounts[],	// OUT array of ref counts of released rows
	                                    DBROWSTATUS		rgRowStatus[]	// OUT status array of for input rows
                                        )
{
    HRESULT hr				= S_OK;
    ULONG   ihRow			= 0L;
    ULONG	cErrors			= 0L;
    ROWBUFF *pRowBuff		= NULL;
	BOOL	bBuffFlag		= FALSE;
	LONG	lRowRefCount	= 0;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());
	// clear error information
	g_pCError->ClearErrorInfo();

	if(cRows == 0)
	{
		hr = S_OK;
	}
	else
	//============================================================================
    // check params
    //============================================================================
    if ( cRows && !rghRows )
	{
		hr = E_INVALIDARG;
//		return g_pCError->PostHResult(E_INVALIDARG,&IID_IRowset);
	}
	else
	{
		ihRow = 0;

		// If any rows is fetched data slotlist would have been initialized otherwise
		// return invallid rows
		if(!m_pObj->m_bHelperFunctionCreated)
		{
			for (ihRow = 0; ihRow < cRows; ihRow++)
			{
				if(rgRefCounts)
				{
					rgRefCounts[ihRow] = 0;
				}
				if(rgRowStatus)
				{
					rgRowStatus[ihRow] = DBROWSTATUS_E_INVALID;
				}
			}
			hr = DB_E_ERRORSOCCURRED;
//			return g_pCError->PostHResult(DB_E_ERRORSOCCURRED,&IID_IRowset);
		}
		else
		{

			while ( ihRow < cRows )
			{

				bBuffFlag = FALSE;
				lRowRefCount = 0;
				
				//=============================================================
				// if HROW is invalid mark it and continue with the next row
				//=============================================================
				if(((LONG) rghRows[ihRow]) <= 0)
				{
					if( rgRowStatus != NULL)
						rgRowStatus[ihRow] = DBROWSTATUS_E_INVALID;

					ihRow++;
					cErrors++;
					continue;
				}
				hr = m_pObj->IsSlotSet(rghRows[ihRow]);
				if( hr == S_OK)
				{
					//=============================================================
					// Get the buffer address if it is allocated
					//=============================================================
					pRowBuff=m_pObj->GetRowBuff((ULONG) rghRows[ihRow], TRUE);
					if(pRowBuff != NULL)
					{
						bBuffFlag = TRUE;
					}
				}
				
				//=========================================================================
				// check the row handle
				//=========================================================================
				if(m_pObj->m_ulRowRefCount && (TRUE == m_pObj->IsRowExists(rghRows[ihRow])))
				{

					if(bBuffFlag == TRUE)
					{
						--pRowBuff->ulRefCount;
						lRowRefCount = pRowBuff->ulRefCount;
					}
				

					//=====================================================================
					// Found valid row, so decrement reference counts.
					// (Internal error for refcount to be 0 here, since slot set.)
					//=====================================================================
						--m_pObj->m_ulRowRefCount;

					//=====================================================================
					// stuff new refcount into caller's array
					//=====================================================================
					if ( rgRefCounts )
					{
						rgRefCounts[ihRow] = lRowRefCount;
					}

					if ( rgRowStatus )
					{
						rgRowStatus[ihRow] = DBROWSTATUS_S_OK;
					}

					if ( lRowRefCount == 0 )
					{
						if(bBuffFlag == TRUE)
						{
							// Bind the row data to the rowdata mem manager
							if (FAILED( m_pObj->Rebind((BYTE *) pRowBuff)))
							{
								if( rgRowStatus != NULL)
								{
									rgRowStatus[ihRow] = DBROWSTATUS_E_FAIL;
								}
								
								++cErrors;
								//return g_pCError->PostHResult(E_FAIL,&IID_IRowset);
							}
							else
							{
								//============================================================
								// release the memory allocated for the different columns
								//============================================================
								m_pObj->m_pRowData->ReleaseRowData();
							}

							if(m_pObj->m_ulProps & BOOKMARKPROP)
							{
								m_pObj->m_pHashTblBkmark->DeleteBmk((ULONG)rghRows[ihRow]);
							}
							if(m_pObj->m_ulLastFetchedRow == rghRows[ihRow])
							{
								m_pObj->m_ulLastFetchedRow = 0;
							}

							// release the slots
							ReleaseSlots( m_pObj->m_pIBuffer, m_pObj->GetSlotForRow(rghRows[ihRow]), 1 );
						}

						// release the rows from the instance manager and chapter manager
 						m_pObj->ReleaseInstancePointer(rghRows[ihRow]);

					}
				}
				else
				{
					//=====================================================================
					// It is an error for client to try to release a row
					// for which "IsSetSlot" is false.  Client gave us an invalid handle.
					// Ignore it (we can't release it...) and report error when done.
					//=====================================================================
					if ( rgRefCounts )
					{
						rgRefCounts[ihRow] = 0;
					}

					if ( rgRowStatus )
					{
						rgRowStatus[ihRow] = DBROWSTATUS_E_INVALID;
					}

					++cErrors;
				}

				ihRow++;
			} // while
		
			//=============================================================================
			// If everything went OK except errors in rows use DB_S_ERRORSOCCURRED.
			//=============================================================================
			hr = cErrors ? ( cErrors < cRows ) ? 
					( DB_S_ERRORSOCCURRED ) : 
		 			( DB_E_ERRORSOCCURRED ) : 
		 			( S_OK );

		}	//  else for 		if(!m_pObj->m_bHelperFunctionCreated)
	
	}	//   else for  if ( cRows && !rghRows )


	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowset);

	CATCH_BLOCK_HRESULT(hr,L"IRowset::ReleaseRows");
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Repositions the next fetch position to the start of the rowset
//
// - all rows must be released before calling this method
// - it is not expensive to Restart us, because we are from a single table
//
//
// 	Returns one of the following values:
//       S_OK					| Method Succeeded
//       DB_E_ROWSNOTRELEASED	| All HROWs must be released before calling
//		 DB_S_COMMANDREEXECUTED | The command was re-executed. This can happen when a method is 
//								  is executed or RestartPosition is called on Forwardonly rowset
//		 DB_E_BADCHAPTER		| HCHAPTER passed was invalid
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIRowsetLocate::RestartPosition( HCHAPTER    hChapter )     // IN  The Chapter handle.
{
	BOOL		fCanHoldRows		= FALSE;
	BOOL		fLiteralIdentity	= FALSE;
	HRESULT		hr					= S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());
	// clear error information
	g_pCError->ClearErrorInfo();

	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
	if((m_pObj->m_bIsChildRs == TRUE && hChapter == DB_NULL_HCHAPTER) || (LONG_PTR)hChapter < 0  || 
		m_pObj->m_bIsChildRs == FALSE && hChapter != 0)
	{
		hr = DB_E_BADCHAPTER;
		//return g_pCError->PostHResult(DB_E_BADCHAPTER,&IID_IRowset);
	}
	else
	{

		//=========================================================================
		// If no rows are fetched in this rowset after opening don't do anything
		// if bitarray is NULL no rows are fetched till now
		//=========================================================================
		if(!(m_pObj->m_hRow == 0 || 
			m_pObj->m_pIAccessor->GetBitArrayPtr() == NULL))
		{

		

		 /*   
			//========================================================================
			// Get the LiteralIdentity property
			//========================================================================
			if( ((m_pObj->m_pIAccessor->GetBitArrayPtr())->ArrayEmpty() != S_OK) && !(m_pObj->m_ulProps & LITERALIDENTITY) ){
				fLiteralIdentity = TRUE;
			}
		*/

			//========================================================================
			// Are there any unreleased rows?
			//========================================================================
			if( ((m_pObj->m_pIAccessor->GetBitArrayPtr())->ArrayEmpty() != S_OK) && !(m_pObj->m_ulProps & CANHOLDROWS) )
			{
				hr = DB_E_ROWSNOTRELEASED;
				//return g_pCError->PostHResult(DB_E_ROWSNOTRELEASED,&IID_IRowset);
			}
			else
			{

			/*    //============================================================================
				// If LiteralIdentity is on reset SlotList
				//============================================================================
				if ( fLiteralIdentity )
					ResetSlotList( m_pObj->m_pIBuffer );
			*/
				//============================================================================
				// set "next fetch" position to the start of the rowset
				//============================================================================
				if( m_pObj->m_uRsType == PROPERTYQUALIFIER || 
					m_pObj->m_uRsType == CLASSQUALIFIER ) 
				{
				    hr = m_pObj->ResetQualifers(hChapter);
				}
				else
				if(m_pObj->m_bIsChildRs == FALSE)
					hr = m_pObj->ResetInstances();

				if(hr == S_OK)
				{
					//============================================================================
					// clear "end of cursor" flag
					//============================================================================
					m_pObj->SetStatus(hChapter, ~STAT_ENDOFCURSOR);

					// if the rowset is as a result of command then set the return value to signify
					// that command has been executed
					// Rowset is also reopened if rowset is forward only rowset
					// If Command is reexecuted , then release all the rows as the rows will not be
					// valid if command is re-executed
					if(!((CANSCROLLBACKWARDS & m_pObj->m_ulProps) || 
						(CANFETCHBACKWARDS & m_pObj->m_ulProps)   || 
						(BOOKMARKPROP & m_pObj->m_ulProps))		  ||
						m_pObj->m_uRsType == METHOD_ROWSET)
					{	
						m_pObj->ReleaseAllRows();
						hr = DB_S_COMMANDREEXECUTED;
					}
				}
			}	// else for If ( rows are not released when CANHOLDROWS is false)
		
		}	// if ( no rows are fetched till now)
	
	} //  else if( check for validity of HCHAPTER)

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowset);

	CATCH_BLOCK_HRESULT(hr,L"IRowset::RestartPosition");
	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Adds a reference count to an existing row handle
//
// 	Returns one of the following values:
// 			 S_OK 						| success
// 			 DB_S_ERRORSOCCURRED		| some elements of rghRows were invalid
// 			 DB_E_ERRORSOCCURRED		| all elements of rghRows were invalid
// 			 E_INVALIDARG 				| rghRows was a NULL pointer and crow > 0
//
//	NTRaid:111815
//	06/06/00
///////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP  CImpIRowsetLocate::AddRefRows ( DBCOUNTITEM           cRows,          //  IN     Number of rows to refcount
                                        const HROW      rghRows[],      //  IN     Array of row handles to refcount
                                        DBREFCOUNT			rgRefCounts[],  //  OUT    Array of refcounts
                                        DBROWSTATUS     rgRowStatus[])  //  OUT    Array of row status
{
    HRESULT hr		  = S_OK;
    ULONG   ihRow	  = 0L;
    ULONG	cErrors	  = 0L;
    ROWBUFF *pRowBuff = NULL;


    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());
	// clear error information
	g_pCError->ClearErrorInfo();

	//============================================
	// If cRows is 0 do nothing and return S_OK
	//============================================
	if(cRows == 0)
		return S_OK;

    //============================================================================
    // check params
    //============================================================================
    if ( cRows && !rghRows )
	{
		hr = E_INVALIDARG;
		//return g_pCError->PostHResult(E_INVALIDARG,&IID_IRowset);
	}
	else
	{

		// If any rows is fetched data slotlist would have been initialized otherwise
		// return invallid rows
		if(!m_pObj->m_bHelperFunctionCreated)
		{
			for (ihRow = 0; ihRow < cRows; ihRow++)
			{
				if(rgRefCounts)
				{
					rgRefCounts[ihRow] = 0;
				}
				if(rgRowStatus)
				{
					rgRowStatus[ihRow] = DBROWSTATUS_E_INVALID;
				}
			}
			hr = DB_E_ERRORSOCCURRED;
			//return g_pCError->PostHResult(DB_E_ERRORSOCCURRED,&IID_IRowset);
		}
		else
		{
			//============================================================================
			// for each of the HROWs the caller provided...
			//============================================================================
			for (ihRow = 0; ihRow < cRows; ihRow++){

				if( rghRows[ihRow] <= 0)
				{
					if( rgRowStatus != NULL)
						rgRowStatus[ihRow] = DBROWSTATUS_E_INVALID;

					cErrors++;
					continue;
				}
				//========================================================================        
				// check the row handle
				//========================================================================        
				if(m_pObj->IsSlotSet((ULONG) rghRows[ihRow]) == S_OK)
				{
            
					if(( pRowBuff=m_pObj->GetRowBuff( rghRows[ihRow], TRUE )))
					{
						//=======================================================
						// if row is marked as deleted then set the status
						//=======================================================
						if(DBROWSTATUS_E_DELETED == m_pObj->GetRowStatus(rghRows[ihRow]))
						{
							if ( rgRowStatus )
							{
								rgRowStatus[ihRow] = DBROWSTATUS_E_DELETED;
							}
							++cErrors;
						}
						else
						{
							//====================================================================
							// bump refcount
							//====================================================================
							assert( pRowBuff->ulRefCount != 0 );
							assert( m_pObj->m_ulRowRefCount != 0 );
							++pRowBuff->ulRefCount;
							++m_pObj->m_ulRowRefCount;

							//====================================================================
							// stuff new refcount into caller's array
							//====================================================================
							if ( rgRefCounts )
							{
								rgRefCounts[ihRow] = pRowBuff->ulRefCount;
							}
							if ( rgRowStatus )
							{
								rgRowStatus[ihRow] = DBROWSTATUS_S_OK;
							}
						}
					}
					else
					{
						if( rgRowStatus != NULL)
						{
							rgRowStatus[ihRow] = DBROWSTATUS_E_INVALID;
						}
						cErrors++;
						continue;

					}
				}
				else
				{

    				if ( rgRefCounts )
					{
    					rgRefCounts[ihRow] = 0;
					}
    				if ( rgRowStatus )
					{
		    			rgRowStatus[ihRow] = DBROWSTATUS_E_INVALID;
					}
					++cErrors;
    			}

			}

			// If everything went OK except errors in rows use DB_S_ERRORSOCCURRED.
			hr =  cErrors ? ( cErrors < cRows ) ? 
					( DB_S_ERRORSOCCURRED ) : 
		 			( DB_E_ERRORSOCCURRED ) : 
		 			( S_OK );

		} // Else for If( any rows are fetched till now)
	
	}	// Else for If( Validate input arguments )
	
	CATCH_BLOCK_HRESULT(hr,L"IRowset::AddRefRows");
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowset);
	return hr;
}




//////////////////////////////////////////////////////////////////////////////////////
////	IRowsetLocate Methods									/////////////////////
//////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////
// CImpIRowsetScroll::Compare
//
// Compares two bookmarks.
//
// Returns one of the following values:
// 		S_OK 						compare bookmarks succeeded,
// 		E_INVALIDARG 				one of the bookmark had 0 length or 
//									     one of the bookmark pointer was null
//										  or pdwComparison was NULL,
// 		DB_E_BADBOOKMARK 			one or both of the bookmarks was a standard
//										  bookmark,
//		DBCOMPARE_NOTCOMPARABLE		The bookmarks passed are not comparable
// 		E_FAIL 					    Compare failed for some other reason, 
//		
//////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIRowsetLocate::Compare (HCHAPTER       hChapter,
										 DBBKMARK       cbBookmark1,
										 const BYTE *   pBookmark1,
										 DBBKMARK       cbBookmark2,
										 const BYTE *   pBookmark2,
										 DBCOMPARE *    pComparison)
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(ROWSET->GetCriticalSection() );
	// clear error information
	g_pCError->ClearErrorInfo();


	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
	// Are arguments valid?
	if (cbBookmark1 == 0 || cbBookmark2 == 0 || pBookmark1 == NULL 
		|| pBookmark2 == NULL || pComparison == NULL)  
	{
		hr = E_INVALIDARG;
//		return g_pCError->PostHResult(E_INVALIDARG,&IID_IRowsetLocate);
	}
	else
	{
		*pComparison = DBCOMPARE_NE;

		if ((cbBookmark1 != STD_BOOKMARKLENGTH 
				&& cbBookmark1 != BOOKMARKSIZE)
			|| (cbBookmark2 != STD_BOOKMARKLENGTH 
				&& cbBookmark2 != BOOKMARKSIZE)
			|| (cbBookmark1 == STD_BOOKMARKLENGTH 
				&& *pBookmark1 == DBBMK_INVALID)
			|| (cbBookmark2 == STD_BOOKMARKLENGTH 
				&& *pBookmark2 == DBBMK_INVALID) )
		{
			hr = DB_E_BADBOOKMARK;
		}
		else
		if (cbBookmark1 == STD_BOOKMARKLENGTH)
		{
			*pComparison =  (cbBookmark2 == STD_BOOKMARKLENGTH && *(BYTE*)pBookmark1 == *(BYTE*)pBookmark2) 
				? DBCOMPARE_EQ : DBCOMPARE_NE;
			
		}
		else
		if (cbBookmark1 == BOOKMARKSIZE)
		{
			*pComparison = (cbBookmark2 == BOOKMARKSIZE 
						&& *(ULONG *)pBookmark1 == *(ULONG *)pBookmark2) 
				? DBCOMPARE_EQ : DBCOMPARE_NE;
		}	
		else
		{
			hr = DBCOMPARE_NOTCOMPARABLE;
		}

	} // Else for validating arguments

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetLocate);
	
	CATCH_BLOCK_HRESULT(hr,L"IRowsetLocate::Compare");
	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// CImpIRowsetScroll::GetRowsAt
//
// Fetches rows starting with the row specified by an offset from a bookmark.
//
// Returns one of the following values:
// 		S_OK 						Row fetching suceeded
// 		DB_S_ENDOFROWSET			Start or End of rowset was reached during fetching
// 		E_INVALIDARG 				Arguments pcRowsObtained or prghRows was a NULL pointer,
// 		E_OUTOFMEMORY 				Fetching rows failed because of memory alloccation problem,
// 		E_FAIL 						fetching rows failed for some other reason, 

//  	DB_E_ROWSNOTRELEASED 		Previous rowhandles were not release as 
//									required by the rowset type, 
//  	DB_E_CANTFETCHBACKWARD 		cRows was negative and the rowset cannot fetch backward,
//  	DB_E_CANTSCROLLBACKWARD		cRowsToSkip was negative and the rowset 
//									cannot scroll backward,
// 		OTHER						| other result codes returned by called functions.
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIRowsetLocate::GetRowsAt (HWATCHREGION   hReserved1,
										   HCHAPTER       hChapter,
										   DBBKMARK       cbBookmark,
										   const BYTE *   pBookmark,
										   DBROWOFFSET    lRowsOffset,
										   DBROWCOUNT     cRows,
										   DBCOUNTITEM *  pcRowsObtained,
										   HROW **        prghRows)
{
	HRESULT  hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(ROWSET->GetCriticalSection() );
	// Clear previous Error Object for this thread
	g_pCError->ClearErrorInfo();

	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
	// Initialize pointer argument.
	if (pcRowsObtained)
	{
		*pcRowsObtained = 0;
	}
    //========================================================================
    //  Check the HChapter is of the current rowset is valid
    //========================================================================
	if((m_pObj->m_bIsChildRs == TRUE && hChapter == DB_NULL_HCHAPTER) || (LONG_PTR)hChapter < 0  || 
		m_pObj->m_bIsChildRs == FALSE && hChapter != 0)
	{
		hr = DB_E_BADCHAPTER;
		//return g_pCError->PostHResult(DB_E_BADCHAPTER,&IID_IRowsetLocate);
	}
	else
	if ( (pcRowsObtained == NULL || prghRows == NULL) ||		// Check validity of pointer arguments.
		(cbBookmark == 0 || pBookmark == NULL))					// Is bookmark valid?
	{
		hr = E_INVALIDARG;
		//return g_pCError->PostHResult(E_INVALIDARG, &IID_IRowsetLocate);
	}
	else
	{
		//========================================================================
		//  Check the rowset parameters to see if we support this request
		//========================================================================
		if( S_OK == (hr = CheckParameters(pcRowsObtained, lRowsOffset, cRows, prghRows)))
		{

			if(hChapter)
			{
				hr = m_pObj->CheckAndInitializeChapter(hChapter);
/*				if(FAILED(hr))
					return g_pCError->PostHResult(hr, &IID_IRowsetLocate);
*/			}

			if(SUCCEEDED(hr))
			{
				// Create the data members to manage the data only the first time
				if(!m_pObj->m_bHelperFunctionCreated)
				{
					if( SUCCEEDED(hr = m_pObj->CreateHelperFunctions()))
						m_pObj->m_bHelperFunctionCreated = TRUE;
				}

				if(SUCCEEDED(hr))
				{
					//========================================================================
					// Are there any unreleased rows?
					//========================================================================
					if( ((m_pObj->m_pIAccessor->GetBitArrayPtr())->ArrayEmpty() != S_OK) && !(m_pObj->m_ulProps & CANHOLDROWS) )
					{
						hr = DB_E_ROWSNOTRELEASED;
						//return g_pCError->PostHResult(DB_E_ROWSNOTRELEASED, &IID_IRowsetLocate);
					}
					else
					{

						// call the function to fetch rows by bookmark
						hr = m_pObj->m_pRowFetchObj->FetchNextRowsByBookMark( m_pObj,
																				hChapter,
																				cbBookmark,
																				pBookmark,
																				lRowsOffset,
																				cRows,
																				pcRowsObtained,
																				prghRows);
					} // Rows not released with CANHOLDROWS set to false

				} // If succeded(hr) if CreateHelperFunction called

			} // if Succeeded(hr) after initializing the chapter if any
		
		}	// If(CheckParameters())
	
	} // Else for if validating some arguments

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetLocate);

	CATCH_BLOCK_HRESULT(hr,L"IRowsetLocate::GetRowsAt");
	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// CImpIRowsetScroll::GetRowsByBookmark
//
// Fetches rows with specified bookmarks.
//
// Returns one of the following values:
// 		S_OK 					Getting rows succeeded,
// 		DB_S_ERRORSOCCURRED		Getting rows succeeded but there were errors 
//								          associated with some returned rows,
// 		E_INVALIDARG 			Getting rows failed because pcRowsObtained
//										  or prghRows was a NULL pointer, or
//										  cRows was not zero and either rgcbBookmarks
//										  or rgpBookmarks was a NULL pointer, or
//										  fReturnErrors was TRUE and either pcErrors or
//										  prgErrors was  a NULL pointer,
// 		E_OUTOFMEMORY 			Getting rows failed because memory for 
//										  holding row handles could not be allocated,
//									      or memory for error structures could not 
//										  be allocated, 
//  	DB_E_ROWSNOTRELEASED 	Getting rows failed because previous rowhandles  
//										  were not released as required by the rowset type, 
// 		OTHER					Other result codes returned by called functions.
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIRowsetLocate::GetRowsByBookmark (HCHAPTER       hChapter,
								   DBCOUNTITEM     cRows,
								   const DBBKMARK  rgcbBookmarks[],
								   const BYTE *   rgpBookmarks[],
								   HROW           rghRows[],
								   DBROWSTATUS    rgRowStatus[])
{
	HRESULT hr = S_OK;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(ROWSET->GetCriticalSection() );
	// Clear previous Error Object for this thread
	g_pCError->ClearErrorInfo();



	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
    //===========================================================================
    // No-op case always succeeds.
    //===========================================================================
    if ( cRows == 0 ){
        hr =  S_OK ;
    }
	else
    //========================================================================
    //  Check the HChapter is of the current rowset is valid
    //========================================================================
	if((m_pObj->m_bIsChildRs == TRUE && hChapter == DB_NULL_HCHAPTER) || (LONG_PTR)hChapter < 0  || 
		m_pObj->m_bIsChildRs == FALSE && hChapter != 0)
	{
		hr = DB_E_BADCHAPTER;
		//return g_pCError->PostHResult(DB_E_BADCHAPTER,&IID_IRowsetLocate);
	}
	else
    //===========================================================================
    // This implementation doesn't support scrolling backward. if the CANFETCHBACKWARDS is false
    //===========================================================================
    if((LONG_PTR)cRows < 0 && !(m_pObj->m_ulProps & CANFETCHBACKWARDS) )
	{
		hr = DB_E_CANTFETCHBACKWARDS;
        //return g_pCError->PostHResult(DB_E_CANTFETCHBACKWARDS,&IID_IRowsetLocate);
    }
	else
	if( (rghRows == NULL) ||							 // Check validity of pointer arguments.
		(rgcbBookmarks == NULL || rgpBookmarks == NULL)) // If more than zero rows required pointers to bookmarks must be real.
	{
		hr = E_INVALIDARG;
		//return g_pCError->PostHResult(E_INVALIDARG,&IID_IRowsetLocate);
	}
	else
	// Must detect unreleased rows in cases when holding them over is illegal.
	if (!(m_pObj->m_ulProps & CANHOLDROWS))
	{
		hr = DB_E_ROWSNOTRELEASED;
		//return g_pCError->PostHResult(DB_E_ROWSNOTRELEASED, &IID_IRowsetLocate);
	}
	else
	{
		// Initialize the Chapters if the rowset is chaptered rowset
		if(hChapter)
		{
			hr = m_pObj->CheckAndInitializeChapter(hChapter);
		}

		if(SUCCEEDED(hr))
		{
			// Create the data members to manage the data only the first time
			if(!m_pObj->m_bHelperFunctionCreated)
			{
				if(SUCCEEDED(hr = m_pObj->CreateHelperFunctions()))
					m_pObj->m_bHelperFunctionCreated = TRUE;
			}

			if(SUCCEEDED(hr))
			{
				//========================================================================
				// Are there any unreleased rows?
				//========================================================================
				if( ((m_pObj->m_pIAccessor->GetBitArrayPtr())->ArrayEmpty() != S_OK) && !(m_pObj->m_ulProps & CANHOLDROWS) )
				{
					hr = DB_E_ROWSNOTRELEASED;
					// return g_pCError->PostHResult(DB_E_ROWSNOTRELEASED, &IID_IRowsetLocate);
				}
				else
				{
					hr = m_pObj->m_pRowFetchObj->FetchRowsByBookMark(m_pObj,hChapter,cRows,rgcbBookmarks,rgpBookmarks,rghRows,rgRowStatus);
				}
			
			} // if(SUCCEEDED(hr)) after calling CreateHelperFunction()
		
		} // if(Succeeded(hr)) after initializing chapters if any
	
	} // Else for check of parameters

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetLocate);

	CATCH_BLOCK_HRESULT(hr,L"IRowsetLocate::GetRowsByBookMark");
	return hr;

	
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns hash values for the specified bookmarks.
//
// Returns one of the following values:
// 		S_OK 					Getting hash succeeded,
// 		DB_S_ERRORSOCCURED		At least one bookmark was successfully hashed 
//										  but an element of rgcbBookmarks was 0, or 
//										  an element of rgpBookmarks was null pointer, or 
//										  an element of rgpBookmarks pointed to a 
//										  standard bookmark,
// 		E_INVALIDARG 			cBookmarks was not 0 and rgcbBookmarks or 
//										  rgpBookmarks was a null pointer, or 
//										  prgHashedValues was a null pointer,
// 		DB_E_ERRORSOCCURED		No bookmarks were successfully hashed, 
// 		OTHER					other result codes returned by called functions.
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIRowsetLocate::Hash (HCHAPTER       hChapter,
					   DBBKMARK       cBookmarks,
					   const DBBKMARK rgcbBookmarks[],
					   const BYTE *   rgpBookmarks[],
					   DBHASHVALUE    rgHashedValues[],
					   DBROWSTATUS    rgBookmarkStatus[])
{
	ULONG iBmk, cErrors;
	HRESULT hr;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(ROWSET->GetCriticalSection() );

	// Clear previous Error Object for this thread
	g_pCError->ClearErrorInfo();

	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
    //========================================================================
    //  Check the HChapter is of the current rowset is valid
    //========================================================================
	if((m_pObj->m_bIsChildRs == TRUE && hChapter == DB_NULL_HCHAPTER) || (LONG_PTR)hChapter < 0  || 
		m_pObj->m_bIsChildRs == FALSE && hChapter != 0)
	{
		hr = DB_E_BADCHAPTER;
		//return g_pCError->PostHResult(DB_E_BADCHAPTER,&IID_IRowsetLocate);
	}
	else
	// Check arguments
	if (	(cBookmarks && (rgcbBookmarks == NULL || rgpBookmarks == NULL))
			|| (rgHashedValues == NULL))
	{
		hr = E_INVALIDARG;
		//return g_pCError->PostHResult(E_INVALIDARG, &IID_IRowsetLocate);
	}
	else
	{
		cErrors = 0;
		//=================================================================
		// Initialize the BookMarkStatus if valid pointer is passed
		//=================================================================
		if (rgBookmarkStatus)
		{
			for (iBmk =0; iBmk <cBookmarks; iBmk++)
					rgBookmarkStatus[iBmk] = DBROWSTATUS_S_OK;
		}

		// Loop through the array of bookmarks hashing 'em and recording 
		// their status.
		for (iBmk =0; iBmk <cBookmarks; iBmk++)
		{
			hr = m_pObj->m_pHashTblBkmark->HashBmk(rgcbBookmarks[iBmk],
													rgpBookmarks[iBmk],
													&(rgHashedValues[iBmk]));
			if (FAILED(hr))
			{
				cErrors++;
				if (rgBookmarkStatus)
				{
					rgBookmarkStatus[iBmk] = DBROWSTATUS_E_INVALID;
				}
			}
		}		

		hr = cErrors 
				? (cErrors <cBookmarks) 
					? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED
				: S_OK;
	
	} // Else for Validating arguments

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetLocate);

	CATCH_BLOCK_HRESULT(hr,L"IRowsetLocate::Hash");
	return hr;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////
// Check the input parameters
///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CImpIRowsetLocate::CheckParameters(DBCOUNTITEM * pcRowsObtained,  DBROWOFFSET lRowOffset,  DBROWCOUNT  cRows,HROW **prghRows )
{

    HRESULT hr = S_OK;

    //===========================================================================
    // init out-params
    //===========================================================================
    if ( pcRowsObtained ){
		*pcRowsObtained = 0;
    }

    //===========================================================================
    // Check validity of arguments.
    //===========================================================================
    if ( pcRowsObtained == NULL || prghRows == NULL )
	{
		hr = E_INVALIDARG;
        //return  E_INVALIDARG ;
    }
	else
    //===========================================================================
    // No-op case always succeeds.
    //===========================================================================
    if ( cRows == 0 )
	{
		hr = S_OK;
        //return  S_OK ;
    }
	else
    //===========================================================================
    // This implementation doesn't support scrolling backward. if the CANFETCHBACKWARDS is false
    //===========================================================================
    if((LONG_PTR)cRows < 0 && !(m_pObj->m_ulProps & CANFETCHBACKWARDS) )
	{
		hr = DB_E_CANTFETCHBACKWARDS;
        //return  DB_E_CANTFETCHBACKWARDS ;
    }
	else
    //===========================================================================
    // This implementation doesn't support scrolling backward.if the CANTSCROLLBACKWARDS is false
    //===========================================================================
    if ( lRowOffset < 0  && !(m_pObj->m_ulProps & CANSCROLLBACKWARDS) )
	{
		hr = DB_E_CANTSCROLLBACKWARDS;
        //return  DB_E_CANTSCROLLBACKWARDS ;
	}

    //===========================================================================
    // return success
    //===========================================================================
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\irowstrefresh.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// IRowsetIdentity interface implementation
//
///////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"


///////////////////////////////////////////////////////////////////////////////////////////
//
// Compares two row handles to see if they refer to the same row instance.
//
// HRESULT
//      S_FALSE                Method Succeeded but did not refer to the same row
//      S_OK				   Method Succeeded
//      DB_E_BADROWHANDLE      Invalid row handle given
//      OTHER                  Other HRESULTs returned by called functions
//
///////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImplIRowsetRefresh::GetLastVisibleData(HROW hRow,HACCESSOR hAccessor,void * pData)
{
	//============================================================
	// Call this function of RowFetch Object to fetch data
	//============================================================

	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;
		
	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
	{
		hr =  m_pObj->m_pRowFetchObj->FetchData(m_pObj,hRow,hAccessor,pData);
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetRefresh);

	CATCH_BLOCK_HRESULT(hr,L"IRowsetRefresh::GetLastVisibleData");
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////
//
// Compares two row handles to see if they refer to the same row instance.
//
// HRESULT
//      S_FALSE                Method Succeeded but did not refer to the same row
//      S_OK				   Method Succeeded
//      DB_E_BADROWHANDLE      Invalid row handle given
//		DB_E_BADCHAPTER		   Bad HCHAPTER
//		E_INVALIDARG		   One of the parameters is invalid
//      OTHER                  Other HRESULTs returned by called functions
//
// NTRaid 111830 (Raid about CRowset::GetData Found that this function is not returning
// the proper error while looking into this
// NTRaid 147095 
///////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImplIRowsetRefresh::RefreshVisibleData(HCHAPTER        hChapter,
													DBCOUNTITEM      cRows,
													const HROW       rghRows[],
													BOOL             fOverwrite,
													DBCOUNTITEM *    pcRowsRefreshed,
													HROW **          prghRowsRefreshed,
													DBROWSTATUS **   prgRowStatus)
{
    HRESULT			hr					= S_OK;
	DBCOUNTITEM		lRowsRefreshed		= 0;
	DBROWSTATUS *	rgRowStatus;
	HROW *			prghRows			= NULL;
	BOOL			bGetAllActiveRows	= FALSE;
	BSTR			strBookMark			= Wmioledb_SysAllocString(NULL);

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	*prgRowStatus =		NULL;

	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
    //========================================================================
    //  Check the HChapter is of the current rowset if it is non zero
    //========================================================================
	if((LONG_PTR) cRows < 0 || ( cRows > 0 && rghRows == NULL) || 
		(pcRowsRefreshed == NULL && prghRowsRefreshed != NULL) )
	{
		hr = E_INVALIDARG;
	}
	else
    //========================================================================
    //  Check the HChapter is of the current rowset is valid
    //========================================================================
	if((m_pObj->m_bIsChildRs == TRUE && hChapter == DB_NULL_HCHAPTER) || (LONG_PTR)hChapter < 0  || 
		m_pObj->m_bIsChildRs == FALSE && hChapter != 0)
	{
		hr = DB_E_BADCHAPTER;
	}
	else
	{
		try
		{
			if(prghRowsRefreshed)
			{
				*prghRowsRefreshed = NULL;
			}
			if(pcRowsRefreshed)
			{
				*pcRowsRefreshed = 0;
			}
			if(prgRowStatus)
			{
				*prgRowStatus = NULL;
			}

			// If cRows is zero get all the active rows
			if(cRows == 0)
			{
				bGetAllActiveRows = TRUE;
				//=================================================
				// if the rowset is child rowset get the list 
				// open rowset from the chapter manager
				//=================================================
				if(m_pObj->m_bIsChildRs)
				{
					hr = m_pObj->m_pChapterMgr->GetAllHROWs(prghRows,cRows);

				}
				//=========================================
				// else get it from the instance manager
				//=========================================
				else
				{
					hr = m_pObj->m_InstMgr->GetAllHROWs(prghRows,cRows);
				}
			}
			else
			{
				prghRows = (HROW *)&rghRows[0];
			}

			// allocate memory for the row status
			rgRowStatus = (DBROWSTATUS *)g_pIMalloc->Alloc(sizeof(DBROWSTATUS) * cRows);
			if(S_OK == CheckIfRowsExists(cRows,prghRows,rgRowStatus))
			{
				// Navigate thru each  row 
				for( ULONG nIndex = 0 ; nIndex < cRows ; nIndex++)
				{
					// If the status of the row is ok then refresh the instance
					if(rgRowStatus[nIndex] == DBROWSTATUS_S_OK)
					{
						// call this function to refresh the instance pointer
						m_pObj->RefreshInstance(m_pObj->GetInstancePtr(prghRows[nIndex]));

						if(m_pObj->m_uRsType == PROPERTYQUALIFIER || 
							m_pObj->m_uRsType == CLASSQUALIFIER ) 
						{
								m_pObj->GetQualiferName(prghRows[nIndex],strBookMark);
						}

						// Release the previous row data
						hr = m_pObj->ReleaseRowData(prghRows[nIndex],FALSE); // don't release the slots
						
						if (FAILED(hr))
						{		
							rgRowStatus[nIndex] = DBROWSTATUS_E_FAIL;
						}
						//===================================================================
						// if data otherupdatedelete property is false then get the data
						// for the row, 
						// Get the data even if rowset is pointing to a qualifer rowset
						//===================================================================
						// Get the data for the current row
						hr = m_pObj->GetData(prghRows[nIndex],strBookMark);
						
						if(FAILED(hr))
						{
							rgRowStatus[nIndex] = DBROWSTATUS_E_FAIL;
						}
						else
						{
							m_pObj->m_ulLastFetchedRow = prghRows[nIndex];
							lRowsRefreshed++;
							rgRowStatus[nIndex] = DBROWSTATUS_S_OK;
						}
					}
					if(strBookMark != NULL)
					{
						SysFreeString(strBookMark);
						strBookMark = NULL;
					}
					hr = S_OK;
				}
				
				// Allocate memory for output HROW and ROWSTATUS
				if(pcRowsRefreshed)
				{
					*prghRowsRefreshed = (HROW *)g_pIMalloc->Alloc(sizeof(HROW) * cRows);
					if(*prghRowsRefreshed)
					{
						memcpy( *prghRowsRefreshed,prghRows,sizeof(HROW) * cRows);
						*pcRowsRefreshed = lRowsRefreshed;
					}
					else
					{
						hr = E_OUTOFMEMORY;
					}

					if(SUCCEEDED(hr) && prgRowStatus)
					{
						*prgRowStatus = (DBROWSTATUS *)g_pIMalloc->Alloc(sizeof(DBROWSTATUS) * cRows);
						if(*prgRowStatus)
						{
							memcpy( *prgRowStatus,rgRowStatus,sizeof(DBROWSTATUS) * cRows);
						}
						else
						{
							if(*prghRowsRefreshed != NULL)
							{
								g_pIMalloc->Free(*prghRowsRefreshed);
							}

							*prghRowsRefreshed = NULL;
							*pcRowsRefreshed = 0;

							hr = E_OUTOFMEMORY;
						}
					}
				}
								
				// free the temporarily allocated memory
				g_pIMalloc->Free(rgRowStatus);

				// free the memory if allocated by GetAllHROWs
				// which is called when cRows is 0 
				if(prghRows != NULL && bGetAllActiveRows == TRUE)
				{
					SAFE_DELETE_ARRAY(prghRows);
				}

			}
			else
			{
				hr = E_FAIL;
			}
		}
		catch(...)
		{
			if(rgRowStatus != NULL)
				g_pIMalloc->Free(rgRowStatus);
			
			if(*prgRowStatus != NULL)
				g_pIMalloc->Free(*prgRowStatus);
			
			if(*prghRowsRefreshed != NULL)
			g_pIMalloc->Free(*prghRowsRefreshed);

			if(prghRows != NULL && rghRows == NULL)
			{
				SAFE_DELETE_ARRAY(prghRows);
			}

			throw;
		}
	}

	if(SUCCEEDED(hr))
	{
		if(lRowsRefreshed == 0 && cRows)
		{
			hr = DB_E_ERRORSOCCURRED;
		}
		else
		{
			hr = cRows>lRowsRefreshed ? DB_S_ERRORSOCCURRED : S_OK;
		}
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetRefresh);

	CATCH_BLOCK_HRESULT(hr,L"IRowsetRefresh::RefreshVisibleData");
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to check the row handles and set the status of the row handles
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CImplIRowsetRefresh::CheckIfRowsExists(DBCOUNTITEM cRows,const HROW rghRows[],DBROWSTATUS *   prgRowStatus)
{
	HRESULT hr = S_OK;
	DBSTATUS dwStatus = 0;

	if (!m_pObj->BitArrayInitialized()){

        //=================================================================================
		// This is the case when the method was called even before the rowset got fully
		// intialized, hence no rows could have been fetched yet, therefore there do not 
		// exist valid row handles, and all row handles provided must be invalid.
        //=================================================================================
		hr = DB_E_BADROWHANDLE;		
	}
	else
	{
		for ( ULONG nIndex = 0 ; nIndex < cRows ; nIndex++)
		{
        //=================================================================================
		// Check validity of input handles
        //=================================================================================
			if(TRUE == m_pObj->IsRowExists(rghRows[nIndex]) )
			{
				dwStatus = m_pObj->GetRowStatus(rghRows[nIndex]);
					if( dwStatus != DBROWSTATUS_S_OK )
					{
						if(dwStatus == DBROWSTATUS_E_DELETED || 
							dwStatus == DBROWSTATUS_E_DELETED)
								hr = DB_E_DELETEDROW;
							else
								prgRowStatus[nIndex] = DBROWSTATUS_E_FAIL;
					}
					else
						prgRowStatus[nIndex] = DBROWSTATUS_S_OK;

			}
			else
			{
				prgRowStatus[nIndex] = DBROWSTATUS_E_INVALID;
			}
		}
	}

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\irowiden.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// IRowsetIdentity interface implementation
//
///////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"


///////////////////////////////////////////////////////////////////////////////////////////
//
// Compares two row handles to see if they refer to the same row instance.
//
// HRESULT
//      S_FALSE                Method Succeeded but did not refer to the same row
//      S_OK				   Method Succeeded
//      DB_E_BADROWHANDLE      Invalid row handle given
//      OTHER                  Other HRESULTs returned by called functions
//
///////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CImpIRowsetIdentity::IsSameRow ( HROW	hThisRow,		//IN   The handle of an active row
	                                          HROW	hThatRow		//IN   The handle of an active row
    )
{
	HRESULT	 hr = S_OK;
	BSTR strKeyThisRow = NULL,strKeyThatRow = NULL;
	DWORD dwStatusThisRow = 0 , dwStatusThatRow = 0;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
	if (!m_pObj->BitArrayInitialized()){

        //=================================================================================
		// This is the case when the method was called even before the rowset got fully
		// intialized, hence no rows could have been fetched yet, therefore there do not 
		// exist valid row handles, and all row handles provided must be invalid.
        //=================================================================================
		hr = DB_E_BADROWHANDLE;		
	}
	else
	{
        //=================================================================================
		// Check validity of input handles
        //=================================================================================
		// NTBuild : 138810
		// 07/18/00
		if(TRUE == m_pObj->IsRowExists(hThisRow) && TRUE == m_pObj->IsRowExists(hThatRow))
		{
			
			//NTRaid:138810
			// 07/18/00
			/// Get the status of the row and check
			// if it is deleted
			dwStatusThisRow = m_pObj->GetRowStatus(hThisRow);
			dwStatusThatRow = m_pObj->GetRowStatus(hThatRow);
			
			if( DBROWSTATUS_S_OK != dwStatusThisRow || DBROWSTATUS_S_OK != dwStatusThatRow)
			{
				hr = DB_E_ERRORSOCCURRED;

				if( DBROWSTATUS_E_DELETED == dwStatusThisRow ||	 DBROWSTATUS_E_DELETED == dwStatusThatRow)
				{
					hr = DB_E_DELETEDROW;
				}
			}
			else
			if(hThisRow == hThatRow)
			{
				hr = S_OK;
			}
			else
			{
				m_pObj->GetInstanceKey(hThisRow,&strKeyThisRow);
				m_pObj->GetInstanceKey(hThatRow,&strKeyThatRow);
				
				// NTRaid:111813
				// 06/07/00
				if(!strKeyThisRow || !strKeyThatRow)
				{
					hr = S_FALSE;
				}
				else
				// If the key of both the instances are same then
				// both the rows are referring to the same row
				if( wbem_wcsicmp(strKeyThisRow,strKeyThisRow) == 0)
				{
					hr = S_OK;
				}
				else
				{
					hr = S_FALSE;
				}

				SysFreeString(strKeyThisRow);
				SysFreeString(strKeyThatRow);
			}
		}
		else
		{
			hr = DB_E_BADROWHANDLE;
		}

	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetIdentity);

	CATCH_BLOCK_HRESULT(hr,L"IRowsetIdentity::IsSameRow");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\iscopedoperation.cpp ===
///////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
//
// (C) Copyright 2000-1999 Microsoft Corporation. All Rights Reserved.
//
//  IBindResource.CPP CImplIBindResource interface implementation
//
///////////////////////////////////////////////////////////////////////////

#include "headers.h"

////////////////////////////////////////////////////////////////////////////////
// Method of the IBindResource which binds the requested URL
// Returns one of the following values:
//			S_OK						Bind succeeded
//			DB_S_ERRORSOCCURRED			Bind succeeded, but some bind flags 
//										or properties were not satisfied
//			DB_E_NOAGGREGATION			Aggregation not supported by the 
//										object requested
//			DB_E_NOTFOUND				Object requested as from URL not found
//			DB_E_OBJECTMISMATCH			The object requested and the URL passed
//										does not match
//			DB_SEC_E_PERMISSIONDENIED	User does not have permission for the
//										object requested
//			E_FAIL						Other error ( WMI specifice errors)
//			E_INVALIDARG				one or more arguments are not valid
//			E_NOINTERFACE				The interface requested is not supported
//			E_UNEXPECTED				unexpected error
//  NOTE:  This should be allowed for only Scopes as the path of the objects in
//	scope have the path of the scope in which they are and make sense only for 
// that. In case of objects in container, these objects can be in as many
// container as it wants and its path need not be dependent on the containee
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIScopedOperations::Bind(IUnknown *            pUnkOuter,
										   LPCOLESTR             pwszURL,
										   DBBINDURLFLAG         dwBindURLFlags,
										   REFGUID               rguid,
										   REFIID                riid,
										   IAuthenticate *       pAuthenticate,
										   DBIMPLICITSESSION *   pImplSession,
										   DBBINDURLSTATUS *     pdwBindStatus,
										   IUnknown **           ppUnk)
{
	HRESULT hr		= DB_E_NOTSUPPORTED;
	WCHAR * pstrUrl = NULL;

    CSetStructuredExceptionHandler seh;

	// Bind is allowed only for Scopes
	if(!m_pObj->IsContainer())
	{
		TRY_BLOCK;

		// Serialize the object
		CAutoBlock	cab(m_pObj->GetCriticalSection());
		g_pCError->ClearErrorInfo();

		// If URL is NULL return Invalid Argument
		if(pwszURL == NULL)
		{
			hr = E_INVALIDARG;
		}
		else
		{
			try
			{
				// Allocate the string
				pstrUrl = new WCHAR[wcslen(pwszURL) + 1];
				hr = S_OK;
			}
			catch(...)
			{
				SAFE_DELETE_PTR(pstrUrl);
			}
			wcscpy(pstrUrl,pwszURL);

			if(SUCCEEDED(hr = CheckIfProperURL(pstrUrl,rguid)))
			{
				if( pUnkOuter != NULL && riid != IID_IUnknown)
				{
					hr = DB_E_NOAGGREGATION;
				}
				else
				{
					//========================================================================
					// Calling this to bind the URL to the appropriate object
					//========================================================================
					hr = BindURL(pUnkOuter,pstrUrl,dwBindURLFlags,rguid,riid,pImplSession,pdwBindStatus,ppUnk);
				}
				
			}
			SAFE_DELETE_ARRAY(pstrUrl);
		}
		CATCH_BLOCK_HRESULT(hr,L"IScopedOperations::Bind");

	}
	
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IBindResource);

	return hr;
}





////////////////////////////////////////////////////////////////////////////////
// Copy link from one container to another container
// Returns one of the following values:
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIScopedOperations::Copy(DBCOUNTITEM cRows,
											LPCOLESTR __RPC_FAR rgpwszSourceURLs[  ],
											LPCOLESTR __RPC_FAR rgpwszDestURLs[  ],
											DWORD dwCopyFlags,
											IAuthenticate __RPC_FAR *pAuthenticate,
											DBSTATUS __RPC_FAR rgdwStatus[  ],
											LPOLESTR __RPC_FAR rgpwszNewURLs[  ],
											OLECHAR __RPC_FAR *__RPC_FAR *ppStringsBuffer)
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(m_pObj->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();
	
	if(!m_pObj->IsContainer() && !(dwCopyFlags & DBCOPY_NON_RECURSIVE))
	{
		hr = DB_E_NOTSUPPORTED;
		LogMessage("Copy of the entire sub tree is not supported for Scopes");
	}
	else
	if(cRows)
	{
		//======================================================================================================
		// The last parameter specifies ManipulateObjects to Copy objects from one scope/contianer to another
		//======================================================================================================
		ManipulateObjects(cRows,rgpwszSourceURLs,rgpwszDestURLs,rgdwStatus,rgpwszNewURLs,ppStringsBuffer,FALSE);
	}

	CATCH_BLOCK_HRESULT(hr,L"IScopedOperations::Copy");

	return hr;
}

////////////////////////////////////////////////////////////////////////////////
// Moving item from one container to another container
// Returns one of the following values:
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIScopedOperations::Move(DBCOUNTITEM cRows,
										LPCOLESTR __RPC_FAR rgpwszSourceURLs[  ],
										LPCOLESTR __RPC_FAR rgpwszDestURLs[  ],
										DWORD dwMoveFlags,
										IAuthenticate __RPC_FAR *pAuthenticate,
										DBSTATUS __RPC_FAR rgdwStatus[  ],
										LPOLESTR __RPC_FAR rgpwszNewURLs[  ],
										OLECHAR __RPC_FAR *__RPC_FAR *ppStringsBuffer)
{

	HRESULT	hr = S_OK;
    CSetStructuredExceptionHandler seh;

	// Seriliaze the object
	CAutoBlock cab(m_pObj->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	ppStringsBuffer  = NULL;
	
	TRY_BLOCK

	if(!m_pObj->IsContainer())
	{
		hr = DB_E_NOTSUPPORTED;
		LogMessage("Move not supported on a scope object");
	}	
	else
	if(cRows)
	{
		//======================================================================================================
		// The last parameter specifies ManipulateObjects to Move objects from one contianer to another
		//======================================================================================================
		hr = ManipulateObjects(cRows,rgpwszSourceURLs,rgpwszDestURLs,rgdwStatus,rgpwszNewURLs,ppStringsBuffer,TRUE);
	}

	CATCH_BLOCK_HRESULT(hr,L"IScopedOperations::Move");

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IBindResource);
	return hr;
}

////////////////////////////////////////////////////////////////////////////////
// Deleting objects from container. This can also be used to delete
// items from scope
// Returns one of the following values:
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIScopedOperations::Delete(DBCOUNTITEM cRows,
											LPCOLESTR __RPC_FAR rgpwszURLs[  ],
											DWORD dwDeleteFlags,
											DBSTATUS __RPC_FAR rgdwStatus[  ])
{
	HRESULT hr = S_OK;
	BOOL bContainer = FALSE;
	DBSTATUS	dbStatus;
	DBCOUNTITEM	cError = 0;
	WCHAR * pstrUrl = NULL;
    CSetStructuredExceptionHandler seh;

	// Seriliaze the object
	CAutoBlock cab(m_pObj->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	if(cRows > 0)
	{	
		TRY_BLOCK

		for ( DBCOUNTITEM item = 0 ; item < cRows ; item++)
		{

			dbStatus = DBSTATUS_S_OK;
			try
			{
				// Allocate the string
				pstrUrl = new WCHAR[wcslen(rgpwszURLs[item]) + 1];
			}
			catch(...)
			{
				SAFE_DELETE_PTR(pstrUrl);
			}

			if(pstrUrl)
			{
				memset(pstrUrl,0,(wcslen(rgpwszURLs[item]) + 1) * sizeof(WCHAR));
				hr = S_OK;
				wcscpy(pstrUrl,rgpwszURLs[item]);
			}
			else
			{
				hr = E_OUTOFMEMORY;
				break;
			}

			//=============================================
			// check if the URL passed is valid
			//=============================================
			if(SUCCEEDED(hr = CheckIfProperURL(pstrUrl,DBGUID_ROW)))
			{
				//======================================================
				// call this function to delete the object passed 
				// refered in the URL
				//======================================================
				if(FAILED(m_pObj->Delete(pstrUrl,dwDeleteFlags,dbStatus)))
				{
					cError++;
				}
				if(rgdwStatus)
				{
					rgdwStatus[item] = dbStatus;
				}			
			}
			else
			{
				if(rgdwStatus)
				{
					rgdwStatus[item] = DBSTATUS_E_INVALIDURL;
				}
				cError++;
				hr = S_OK;
			}
			SAFE_DELETE_PTR(pstrUrl);
		} // for loop

		if(SUCCEEDED(hr))
		{
			hr = cError > 0 ? DB_S_ERRORSOCCURRED: S_OK;
		}	hr = cError >= cRows ? DB_E_ERRORSOCCURRED: hr;
		
		hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IBindResource);

		CATCH_BLOCK_HRESULT(hr,L"IScopedOperations::Delete");
	}
	return hr;
}


////////////////////////////////////////////////////////////////////////////////
// Opening a rowset contiang objects in scope/container
// Returns one of the following values:
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIScopedOperations::OpenRowset(IUnknown __RPC_FAR *pUnkOuter,
												DBID __RPC_FAR *pTableID,
												DBID __RPC_FAR *pIndexID,
												REFIID riid,
												ULONG cPropertySets,
												DBPROPSET __RPC_FAR rgPropertySets[  ],
												IUnknown __RPC_FAR *__RPC_FAR *ppRowset)
{
	HRESULT		hr			= S_OK;
	WCHAR *		pTempStr	= NULL;
	WCHAR *		pStrURL		= NULL;

    CSetStructuredExceptionHandler seh;

    if( ppRowset )
	{
	    *ppRowset = NULL;
    }

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(m_pObj->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

    //=====================================================================
    // Check Arguments
    //=====================================================================
    if ( riid == IID_NULL)
	{
		hr = E_NOINTERFACE;
//        return g_pCError->PostHResult(E_NOINTERFACE,&IID_IOpenRowset) ;
    }
	else
	//==========================================================
	// We only accept NULL for pIndexID at this present time
	//==========================================================
    if( pIndexID )
	{                                         
		hr = DB_E_NOINDEX;	
//        return g_pCError->PostHResult(DB_E_NOINDEX,&IID_IOpenRowset) ;
    }
	else
	//===================================================================================
	// We do not allow the riid to be anything other than IID_IUnknown for aggregation
	//===================================================================================
    if ( (pUnkOuter) && (riid != IID_IUnknown) )
	{   
		hr = DB_E_NOAGGREGATION;
//        return g_pCError->PostHResult(DB_E_NOAGGREGATION,&IID_IOpenRowset) ;
    }

	if (pTableID == NULL ||
		(pTableID != NULL &&  pTableID->eKind == DBKIND_NAME &&  pTableID->uName.pwszName == NULL) ||
		(pTableID != NULL &&  pTableID->eKind == DBKIND_NAME &&  !wcscmp(pTableID->uName.pwszName,L"") ))
	{
		pTempStr = NULL;
    }
	else
	{
		pTempStr = pTableID->uName.pwszName;
	}


	if(SUCCEEDED(hr))
	{
		
		if(pTempStr)
		{
			pStrURL = new WCHAR [ wcslen(pTempStr) + 1];
			if(pStrURL)
			{
				wcscpy(pStrURL,pTempStr);
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}
		
		//====================================================
		// Check if the URL passed is in the require format
		//====================================================
		if(SUCCEEDED(hr) && SUCCEEDED(hr =CheckIfProperURL(pStrURL,DBGUID_ROWSET)))
		{
			//==============================
			// Open the rowset
			//==============================
			hr = m_pObj->OpenRowset(pStrURL,pUnkOuter,riid,TRUE,ppRowset,cPropertySets,rgPropertySets);
		}
		SAFE_DELETE_ARRAY(pStrURL);
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IScopedOperations);

	CATCH_BLOCK_HRESULT(hr,L"IScopedOperations::OpenRowset");
	return hr;
}




////////////////////////////////////////////////////////////////////////////////////////////
// Function which checks if the URL flags matches the requested object
//  This is as per the OLEDB specs
///////////////////////////////////////////////////////////////////////////////////////////
BOOL CImpIScopedOperations::CheckBindURLFlags(DBBINDURLFLAG dwBindURLFlags , REFGUID rguid)
{
	BOOL bFlag = FALSE;

	if( DBGUID_ROW == rguid)
	{
		bFlag = TRUE;
	}

	if( DBGUID_ROWSET == rguid)
	{
		if(!((dwBindURLFlags & DBBINDURLFLAG_DELAYFETCHCOLUMNS) ||			// Flags cannot have any of these two values
			(dwBindURLFlags & DBBINDURLFLAG_DELAYFETCHSTREAM)))
			bFlag = TRUE;

	}

	return bFlag;
}


////////////////////////////////////////////////////////////////////////////////////////////
// Function which checks if the URL is valid for the requested object
///////////////////////////////////////////////////////////////////////////////////////////
HRESULT CImpIScopedOperations::CheckIfProperURL(LPOLESTR & lpszURL,REFGUID rguid)
{
	HRESULT hr = S_OK;
	LONG lUrlType = -1;
	CURLParser	urlParser;
	BOOL		bEmptyURL = FALSE;
	

	// IScopedOperations::Bind supports binding of only
	// to rowset and row objects
	if(!(rguid == DBGUID_ROW || rguid == DBGUID_ROWSET))
	{
		hr = DB_E_NOTSUPPORTED;
	}
	else
	// Empty URL can be passed only for OpenRowset call
	if(!lpszURL && rguid != DBGUID_ROWSET)
	{
		hr = E_INVALIDARG;
	}
	else
	if(urlParser.IsValidURL(lpszURL) != RELATIVEURL)
	{

		bEmptyURL = (lpszURL == NULL || (lpszURL != NULL && wcslen(lpszURL) == 0));

		// if URL is null or empty string then the requested object has to be rowset or
		// if URL of the current row object and the object requested is same and if the row object is 
		// requested then there is no meaning as the current row is reffering to the object
		if( (bEmptyURL  && rguid != DBGUID_ROWSET) 
			||( wbem_wcsicmp(lpszURL,m_pObj->m_strURL) == 0 && rguid == DBGUID_ROW))
		{
			hr = E_INVALIDARG;
		}
		else
		{
			// If URL is passed then the URL should be in the scope of the current object 
			// otherwise there error should be returned
			if(!bEmptyURL && SUCCEEDED(hr = urlParser.SetURL(lpszURL)))
			{
				if(wbem_wcsincmp(m_pObj->m_strURL,lpszURL,wcslen(m_pObj->m_strURL)))
				{
					hr = DB_E_RESOURCEOUTOFSCOPE;
				}
			}

		}
	}

	return hr;
	
}



///////////////////////////////////////////////////////////////////////////
// Function to bind the requested URL
///////////////////////////////////////////////////////////////////////////
HRESULT CImpIScopedOperations::BindURL(IUnknown *            pUnkOuter,
									LPCOLESTR             pwszURL,
									DBBINDURLFLAG         dwBindURLFlags,
									REFGUID               rguid,
									REFIID                riid,
									DBIMPLICITSESSION *   pImplSession,
									DBBINDURLSTATUS *     pdwBindStatus,
									IUnknown **           ppUnk)
{

	HRESULT hr = E_FAIL;
	IUnknown *pTempUnk = NULL;
	LONG lInitFlags  = 0;
	LONG lBindFlags	 = 0;
	REFGUID guidTemp = GUID_NULL;
	IUnknown* pReqestedPtr = NULL;
	WCHAR *	pStrTemp = NULL;

	GetInitAndBindFlagsFromBindFlags(dwBindURLFlags,lInitFlags,lBindFlags);
	
	//=========================================================================================
	// If requested object is row then call function to 
	// to create a row
	//=========================================================================================
	if( rguid == DBGUID_ROW)
	{
		pReqestedPtr = NULL;
		hr = m_pObj->OpenRow(pwszURL,pUnkOuter,riid,&pReqestedPtr);
	}

	//=========================================================================================
	// If requested object is rowset then call function to 
	// to create a rowset
	//=========================================================================================
	if( rguid == DBGUID_ROWSET)
	{
		pReqestedPtr = NULL;
		// This has to be changed to path . URL should not be sent
		// if DBBINDURLFLAG_COLLECTION flag of bindflags is set then , it means that the rowset is to
		// be opened as container
		hr = m_pObj->OpenRowset(pStrTemp,pUnkOuter,riid,(dwBindURLFlags & DBBINDURLFLAG_COLLECTION),&pReqestedPtr);
	}
	
	if( SUCCEEDED(hr))
	{
		*ppUnk = pReqestedPtr;
	}

	return hr ;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Function to Move/Copy objects from one container to another
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CImpIScopedOperations::ManipulateObjects(DBCOUNTITEM cRows,
												LPCOLESTR __RPC_FAR rgpwszSourceURLs[  ],
												LPCOLESTR __RPC_FAR rgpwszDestURLs[  ],
												DBSTATUS __RPC_FAR rgdwStatus[  ],
												LPOLESTR __RPC_FAR rgpwszNewURLs[  ],
												OLECHAR __RPC_FAR *__RPC_FAR *ppStringsBuffer,
												BOOL	bMoveObjects)
{
	HRESULT		hr			= S_OK;
	WCHAR *		pstrSrcURL	= NULL;
	WCHAR *		pStrDstURL	= NULL;
	WCHAR *		pstrNewURL	= NULL;
	DBCOUNTITEM item		= 0;
	DBCOUNTITEM	cError		= 0;
	DBSTATUS	dbStatus	= DBSTATUS_S_OK;
	
	// NTRaid:111804
	// 06/07/00
	WCHAR **		prgURL = NULL;

	if(cRows)
	{
		prgURL = new WCHAR*[cRows];
		// NTRaid:111803
		// 06/07/00
		if(prgURL)
		{
			for(item = 0 ; item < cRows ; item++)
			{
				prgURL[item] = NULL;
			}

			try
			{
				for ( item = 0 ; item < cRows ; item++)
				{

					dbStatus = DBSTATUS_S_OK;
					// Allocate the string
					pstrSrcURL = new WCHAR[wcslen(rgpwszSourceURLs[item]) + 1];
					pStrDstURL = new WCHAR[wcslen(rgpwszDestURLs[item]) + 1];
					
					// NTRaid:111805 & 111806
					// 06/07/00
					if(!pstrSrcURL || !pStrDstURL)
					{
						SAFE_DELETE_ARRAY(pstrSrcURL);
						SAFE_DELETE_ARRAY(pStrDstURL);
						SAFE_DELETE_ARRAY(prgURL);
						hr = E_OUTOFMEMORY;
						break;
					}
					else
					{
						memset(pstrSrcURL,0,(wcslen(rgpwszSourceURLs[item]) + 1) * sizeof(WCHAR));				
						memset(pStrDstURL,0,(wcslen(rgpwszDestURLs[item]) + 1) * sizeof(WCHAR));
							
						hr = S_OK;

						wcscpy(pstrSrcURL,rgpwszSourceURLs[item]);
						wcscpy(pStrDstURL,rgpwszDestURLs[item]);

						if((SUCCEEDED(hr = CheckIfProperURL(pstrSrcURL,DBGUID_ROW))) &&
							(SUCCEEDED(hr = CheckIfProperURL(pStrDstURL,DBGUID_ROW))))
						{
							if(bMoveObjects)
							{
								hr = m_pObj->MoveObjects(pStrDstURL,pstrSrcURL,prgURL[item],dbStatus);
							}
							else
							{
								hr = m_pObj->CopyObjects(pStrDstURL,pstrSrcURL,prgURL[item],dbStatus);
							}

							if(FAILED(hr))
							{
								hr = S_OK;
								cError++;
							}
							else
							if(rgdwStatus)
							{
								rgdwStatus[item] = dbStatus;
							}			
						}
						else
					
						{
							if(rgdwStatus)
							{
								rgdwStatus[item] = DBSTATUS_E_INVALIDURL;
							}
							cError++;
							hr = S_OK;
						}
					}
					SAFE_DELETE_ARRAY(pstrSrcURL);
					SAFE_DELETE_ARRAY(pStrDstURL);
					SAFE_DELETE_ARRAY(prgURL);

					
				} // for loop

				if(SUCCEEDED(hr))
				{
					DBCOUNTITEM lNumberOfCharacters;
					for(item = 0 ; item < cRows ; item++)
					{
						if(rgpwszNewURLs)
						{
							rgpwszNewURLs[item] = prgURL[item];
						}
						lNumberOfCharacters += wcslen(prgURL[item]);
						lNumberOfCharacters++;
					}

					//==================================================================
					// if the pointer is not NULL then allocate buffer for the 
					// URL strings and fill the data
					//==================================================================
					if(ppStringsBuffer)
					{
						WCHAR *pTemp;
						*ppStringsBuffer = (OLECHAR *)g_pIMalloc->Alloc(lNumberOfCharacters * sizeof(WCHAR));
						pTemp = *ppStringsBuffer;
						DBLENGTH lBytesToCopy = 0;

						for(item = 0 ; item < cRows ; item++)
						{
							lBytesToCopy = (wcslen(prgURL[item]) + 1) * sizeof(WCHAR);
							memcpy(pTemp,prgURL[item],lBytesToCopy);
							pTemp = (WCHAR *)(((BYTE *)pTemp) + lBytesToCopy);
						}
					}
					//==================================================================
					// if the output parameter is NULL then delete all the memory 
					// allocated
					//==================================================================
					if(!rgpwszNewURLs)
					{
						for(item = 0 ; item < cRows ; item++)
						{
							SAFE_DELETE_ARRAY(prgURL[item]);
						}
					}
				}		
				
			}
			catch(...) 
			{ 
				//=====================================
				// Release the memory allocated
				//=====================================
				for(item = 0 ; item < cRows ; item++)
				{
					SAFE_DELETE_ARRAY(prgURL[item]);
				}
				SAFE_DELETE_ARRAY(pstrSrcURL);
				SAFE_DELETE_ARRAY(pStrDstURL);
				SAFE_DELETE_ARRAY(prgURL);
				if(*ppStringsBuffer)
				{
					g_pIMalloc->Free(*ppStringsBuffer);
				}
				throw;
			} 


			if(SUCCEEDED(hr))
			{
				hr = cError > 0 ? DB_S_ERRORSOCCURRED: S_OK;
				hr = (cError >= cRows) ? DB_E_ERRORSOCCURRED: hr;
			}
			else
			{
				if(ppStringsBuffer)
				{
					*ppStringsBuffer  = NULL;
				}
				for(item = 0 ; item < cRows ; item++)
				{
					SAFE_DELETE_ARRAY(prgURL[item]);
				}
				SAFE_DELETE_ARRAY(pstrSrcURL);
				SAFE_DELETE_ARRAY(pStrDstURL);
			}
			SAFE_DELETE_ARRAY(prgURL);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\isecurityinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//
//  IObjAccessControl.cpp - IObjectAccessControl interface implementation
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"

//GUID g_rgObjectID[3]= {DBOBJECT_TABLE,DBOBJECT_DATABASE,DBOBJECT_WMIINSTANCE};	
const GUID *g_prgObjectID[] = { &DBOBJECT_TABLE,&DBOBJECT_DATABASE,&DBOBJECT_WMIINSTANCE };

#define NUMBER_OF_SUPPORTEDOBJECTS 3

STDMETHODIMP CImpISecurityInfo::GetCurrentTrustee(TRUSTEE_W ** ppTrustee)
{
    HRESULT hr	= S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	hr = GetCurTrustee(ppTrustee);

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_ISecurityInfo);

	CATCH_BLOCK_HRESULT(hr,L"ISecurityInfo::GetCurrentTrustee");
    return hr;
}

STDMETHODIMP CImpISecurityInfo::GetObjectTypes(ULONG  *cObjectTypes,GUID  **gObjectTypes)
{
    HRESULT hr	= S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();
	
	if(!cObjectTypes || !gObjectTypes)
	{
		E_INVALIDARG;
	}
	else
	{
		try
		{
			*gObjectTypes = (GUID *)g_pIMalloc->Alloc(sizeof(GUID) * NUMBER_OF_SUPPORTEDOBJECTS);
		}
		catch(...)
		{
			if(*gObjectTypes)
			{
				g_pIMalloc->Free(*gObjectTypes);
			}
		}
		if(*gObjectTypes)
		{
			for(int lIndex = 0 ; lIndex < NUMBER_OF_SUPPORTEDOBJECTS ; lIndex++)
			{
				memcpy(gObjectTypes[lIndex] , g_prgObjectID[lIndex] , sizeof(GUID));
			}
			*cObjectTypes = NUMBER_OF_SUPPORTEDOBJECTS;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}

	}
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_ISecurityInfo);

	CATCH_BLOCK_HRESULT(hr,L"ISecurityInfo::GetObjectTypes");
    return hr;
}

STDMETHODIMP CImpISecurityInfo::GetPermissions(GUID ObjectType,ACCESS_MASK  *pPermissions)
{
    HRESULT hr	= S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(DATASOURCE->GetCriticalSection());
	g_pCError->ClearErrorInfo();

	if(ObjectType != DBOBJECT_TABLE &&
		ObjectType != DBOBJECT_DATABASE &&
		ObjectType != DBOBJECT_WMIINSTANCE) 
	{
		hr = SEC_E_INVALIDOBJECT;
	}
	if(pPermissions == NULL)
	{
		hr = E_INVALIDARG;
	}
	else
	{
		*pPermissions = DELETE | READ_CONTROL | WRITE_DAC | WRITE_OWNER;
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_ISecurityInfo);

	CATCH_BLOCK_HRESULT(hr,L"ISecurityInfo::GetPermissions");
    return hr;
}


STDMETHODIMP CImpISecurityInfo::GetCurTrustee(TRUSTEE_W ** ppTrustee)
{
	HRESULT hr = E_FAIL;
	HANDLE hToken;
	HANDLE hProcess;
	TOKEN_USER * pTokenUser = NULL;
	DWORD processID = GetCurrentProcessId();
	BOOL	bRet = FALSE;
	ULONG lSize = 0;

	hProcess = OpenProcess(PROCESS_QUERY_INFORMATION,FALSE,processID);

	if(hProcess != NULL)
	{
		if(OpenProcessToken(hProcess,TOKEN_QUERY,&hToken))
		{
			if(GetTokenInformation(hToken,TokenUser,NULL,0,&lSize))
			{
				try
				{
					pTokenUser = (TOKEN_USER *) g_pIMalloc->Alloc(lSize);
				}
				catch(...)
				{
					if(pTokenUser)
					{
						g_pIMalloc->Free(pTokenUser);
					}
					throw;
				}
				if(!pTokenUser)
				{
					hr = E_OUTOFMEMORY;
				}
				else
				{
					if(GetTokenInformation(hToken,TokenUser,pTokenUser,lSize,&lSize))
					{
						*ppTrustee = NULL; 
						try
						{
							*ppTrustee = (TRUSTEE_W *)g_pIMalloc->Alloc(sizeof(TRUSTEE_W));
						}
						catch(...)
						{
							if(*ppTrustee)
								g_pIMalloc->Free(*ppTrustee);
							throw;
						}
						if(!(*ppTrustee))
						{
							hr = E_OUTOFMEMORY;
						}
						else
						{
							BuildTrusteeWithSidW(*ppTrustee,pTokenUser->User.Sid);
						}
					}
				}

				if(pTokenUser)
				{
					g_pIMalloc->Free(pTokenUser);
				}
			}
		}
		CloseHandle(hProcess);
	}
	else
	{
		hr = E_FAIL;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\itabledef.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//
//  ITableDef.cpp - ITableDefination interface implementation
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Create a new table and return a pointer to an empty rowset
//
//  HRESULT
// S_OK					-		Success
// DB_S_ERRORSOCCURRED	-		General failure
// E_INVALIDARG			-		one of the arguments is invalid
// DB_E_NOTABLE			-		the table defined ( the parent class referred  is not present)
// DB_E_BADCOLUMNID		-		the column id is bad 
// DB_SEC_E_PERMISSIONDENIED -  does not have permission to create the table
// E_NOINTERFACE		-		does not implement that is asked for
// DB_E_BADTABLEID		-		The tableID is bad
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE CImpITableDefinition::CreateTable( IUnknown __RPC_FAR *pUnkOuter,
																DBID __RPC_FAR *pTableID,
																DBORDINAL cColumnDescs,
																const DBCOLUMNDESC __RPC_FAR rgColumnDescs[  ],
																REFIID riid, ULONG cPropertySets,
																DBPROPSET __RPC_FAR rgPropertySets[  ],
																DBID __RPC_FAR *__RPC_FAR *ppTableID,
																IUnknown __RPC_FAR *__RPC_FAR *ppRowset)	// OUT
{
	HRESULT hr = E_FAIL;
	CRowset* pRowset = NULL;
	WCHAR *pwcsTableName = NULL;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	//===================================================================
	//  Initialize incoming parameters
	//===================================================================
	if(ppRowset != NULL)
	{
		*ppRowset = NULL;
	}

	//==========================
	// Seriliaze the object
	//==========================
	CAutoBlock cab(m_pObj->GetCriticalSection());

	//==========================
	// Clear Error information
	//==========================
	g_pCError->ClearErrorInfo();

	if(pTableID->uName.pwszName == NULL)
	{
		hr = DB_E_BADTABLEID;
	}
	else
	if(wcslen(pTableID->uName.pwszName) == 0 || pTableID->eKind != DBKIND_NAME)
	{
		hr = DB_E_BADTABLEID;
	}
	else
	//===================================================================================
	//  Check the connection is valid
	//===================================================================================
	if ( m_pObj->m_pCDataSource->m_pWbemWrap->ValidConnection() ){

  		//===============================================================
        // construct a new CWmiOleDBMap class
  		//===============================================================
		CWmiOleDBMap Map;
		if(SUCCEEDED(hr = Map.FInit(NO_QUALIFIERS,(LPWSTR)pTableID->uName.pwszName,m_pObj->m_pCDataSource->m_pWbemWrap)))
		{
			hr = Map.CreateTable(cColumnDescs, rgColumnDescs, cPropertySets, rgPropertySets);
			if ( SUCCEEDED(hr) &&  ppRowset != NULL)
			{
				pwcsTableName = Map.GetClassName();

				try
				{
    				//===========================================================
					//  Now, return the rowset
					//===========================================================
					pRowset = new CRowset(pUnkOuter,m_pObj);
				}
				catch(...)
				{
					SAFE_DELETE_PTR(pRowset);
					throw;
				}
				if ( pRowset ){
		
					//=======================================================
					//Set session of this rowset
					//=======================================================
	//				m_pObj->m_fRowsetCreated = TRUE;
					if ( SUCCEEDED(hr) ){

						//=======================================================
						// Store the newly created table in pRowset & get ptr
						//=======================================================
						hr = pRowset->InitRowset(cPropertySets, rgPropertySets,(LPWSTR)pwcsTableName);
						if( SUCCEEDED(hr)){
							hr = pRowset->QueryInterface(IID_IRowset, (void**)ppRowset);
						}
					}
				}
			}
		}

		if ( !SUCCEEDED(hr)  && ppRowset != NULL) {
			SAFE_DELETE_PTR(pRowset);
			*ppRowset = NULL;
		}

		if(ppTableID != NULL && SUCCEEDED( hr))
		{
			//====================================
			// Allocate memory for DBID
			//====================================
			*ppTableID = (DBID *)g_pIMalloc->Alloc(sizeof(DBID));
			(*ppTableID)->eKind = DBKIND_NAME;
			//====================================
			// Allocate memory for then tablename
			//====================================
			(*ppTableID)->uName.pwszName = (WCHAR *)g_pIMalloc->Alloc(sizeof(WCHAR) *(wcslen(pwcsTableName) + 1));
			wcscpy((*ppTableID)->uName.pwszName,Map.GetClassName());
		}

	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_ITableDefinition);

	CATCH_BLOCK_HRESULT(hr,L"ITableDefinition::CreateTable");
	return hr;

}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
// DropTable
// S_OK					-		Success
// DB_S_ERRORSOCCURRED	-		General failure
// E_INVALIDARG			-		one of the arguments is invalid
// DB_E_NOTABLE			-		the table defined in invalid
// DB_SEC_E_PERMISSIONDENIED - does not have permission to drop the table
//////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE CImpITableDefinition::DropTable( DBID __RPC_FAR *pTableID) // IN
{
	HRESULT hr = E_FAIL;
	CBSTR strClassName;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	CAutoBlock cab(m_pObj->GetCriticalSection());

	//====================================
	// Clear Error information
	//====================================
	g_pCError->ClearErrorInfo();
	
	//===================================================================================
	//  Check the connection is valid
	//===================================================================================
	if ( m_pObj->m_pCDataSource->m_pWbemWrap->ValidConnection()  ){
		
	
		if(pTableID->uName.pwszName == NULL)
		{
			hr = DB_E_BADTABLEID;
		}
		else
		if ( wcslen(pTableID->uName.pwszName) == 0  || pTableID->eKind != DBKIND_NAME){
			hr = DB_E_BADTABLEID;
		}
		else{
			strClassName.SetStr(pTableID->uName.pwszName);
			//=========================================================================
			// Call this function of the connection wrapper class to delete the class
			//=========================================================================
			hr = m_pObj->m_pCDataSource->m_pWbemWrap->DeleteClass((BSTR)strClassName);
		}
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_ITableDefinition);

	CATCH_BLOCK_HRESULT(hr,L"ITableDefinition::DropTable");
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//A method of ITableDefinition interface to add a column to a table
// Return Values :
// S_OK					-		Success
// DB_S_ERRORSOCCURRED	-		General failure
// E_INVALIDARG			-		one of the arguments is invalid
// DB_E_NOTABLE			-		the table defined in invalid
// DB_E_BADCOLUMNID		-		the column id is bad 
// DB_SEC_E_PERMISSIONDENIED - does not have permission to add a column
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE CImpITableDefinition::AddColumn( DBID __RPC_FAR *pTableID, // IN
															DBCOLUMNDESC __RPC_FAR *pColumnDesc, //IN|OUT
															DBID __RPC_FAR *__RPC_FAR *ppColumnID)
{
	HRESULT hr = E_FAIL;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	CAutoBlock cab(m_pObj->GetCriticalSection());
	
	//===============================
	// Clear Error information
	//===============================
	g_pCError->ClearErrorInfo();

	//===================================================================================
	//  Check the connection is valid
	//===================================================================================
	if ( m_pObj->m_pCDataSource->m_pWbemWrap->ValidConnection()  ){

		if(pTableID->uName.pwszName == NULL)
		{
			hr = DB_E_BADTABLEID;
		}
		else
		if( NULL == pColumnDesc  ||
			pTableID->eKind != DBKIND_NAME || 0 == wcslen(pTableID->uName.pwszName))
		{
			hr = E_INVALIDARG;
		}
		else
		{

    		CWmiOleDBMap Map;
    		if(SUCCEEDED(hr =Map.FInit(NO_QUALIFIERS,pTableID->uName.pwszName,m_pObj->m_pCDataSource->m_pWbemWrap)))
			{
	 			if(S_OK == (hr = Map.AddColumn(pColumnDesc, ppColumnID)) && ppColumnID != NULL )
				{
					//=====================================
					// Allocate memory for DBID
					//=====================================
					*ppColumnID = (DBID *)g_pIMalloc->Alloc(sizeof(DBID));
					(*ppColumnID)->eKind = DBKIND_NAME;
					//=====================================
					// Allocate memory for then tablename
					//=====================================
					(*ppColumnID)->uName.pwszName = (WCHAR *)g_pIMalloc->Alloc(sizeof(WCHAR) *(wcslen(pColumnDesc->dbcid.uName.pwszName) + 1));
					wcscpy((*ppColumnID)->uName.pwszName,pColumnDesc->dbcid.uName.pwszName);
				}
			}
			
		}
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_ITableDefinition);

	CATCH_BLOCK_HRESULT(hr,L"ITableDefinition::AddColumn");
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//A method of ITableDefinition interface to drop a column
// Return Values :
// S_OK					-		Success
// DB_S_ERRORSOCCURRED	-		General failure
// E_INVALIDARG			-		one of the arguments is invalid
// DB_E_NOTABLE			-		the table defined in invalid
// DB_E_BADCOLUMNID		-		the column id is bad or not exists
// DB_SEC_E_PERMISSIONDENIED - does not have permission to drop the column
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE CImpITableDefinition::DropColumn( 
										DBID __RPC_FAR *pTableID,	// IN  Name of WBEM Class
										DBID __RPC_FAR *pColumnID)	// IN  Name of WBEM Property
{
	HRESULT hr = E_FAIL;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	CAutoBlock cab(m_pObj->GetCriticalSection());
	
	//=====================================
	// Clear Error information
	//=====================================
	g_pCError->ClearErrorInfo();

	//===================================================================================
	//  Check the connection is valid
	//===================================================================================
	if ( m_pObj->m_pCDataSource->m_pWbemWrap->ValidConnection()  ){
		
		if(pTableID->uName.pwszName == NULL)
		{
			hr = DB_E_BADTABLEID;
		}
		else
		if( pTableID->eKind != DBKIND_NAME || 0 == wcslen(pTableID->uName.pwszName) ||
			pColumnID->eKind != DBKIND_NAME || 0 == wcslen(pColumnID->uName.pwszName))
		{
			hr = E_INVALIDARG;
		}
		else
		{

    		CWmiOleDBMap Map;	
    		if(SUCCEEDED(hr = Map.FInit(NO_QUALIFIERS,(LPWSTR)pTableID->uName.pwszName,m_pObj->m_pCDataSource->m_pWbemWrap)))
			{
				hr = Map.DropColumn(pColumnID); 
			}
		}
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_ITableDefinition);

	CATCH_BLOCK_HRESULT(hr,L"ITableDefinition::DropColumn");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\itranslocal.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//	ITransLocal.cpp
// ITransactionLocal interface Implementation
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Commits a transaction
//
// Returns one of the following values:
//      S_OK                    Method Succeeded
//      E_FAIL					a provider specific error occured
//      XACT_E_ABORTED			Transaction was aborted before Commit
//      DB_E_UNEXPECTED			An unexpected error occured
//      XACT_E_COMMIT_FAILED    Transaction commit failed due to unknow reason. Txn Aborted
//      XACT_E_CONNECTION_DOWN  Connection to datasource down
//		XACT_E_NOTRANSACTION	transaction had already been implicitly or explicityly commited/aborted
//		XACT_E_NOTSUPPORTED		Invalid combination of commit flags was specified
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpITransactionLocal::Commit (BOOL fRetaining,
											DWORD grfTC,
											DWORD grfRM)
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(m_pCDBSession->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	//==============================================
	// check if transaction is already started
	//==============================================
	if(!m_pCDBSession->IsTransactionActive())
	{
		hr = XACT_E_NOTRANSACTION;
	}
	else
	{
		//===============================================================================================
		// call this functin to Commit transactions
		//===============================================================================================
		if(SUCCEEDED(hr = m_pCDBSession->m_pCDataSource->m_pWbemWrap->CompleteTransaction(FALSE,0)))	// put the commit function here
		{								 
			m_pCDBSession->SetTransactionActive(FALSE);
		}
	}

	if(SUCCEEDED(hr) && fRetaining)
	{
		m_pCDBSession->SetAllOpenRowsetToZoombieState();
	}
	
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_ITransactionLocal);

	CATCH_BLOCK_HRESULT(hr,L"ITransactionLocal::Commit");
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Aborts a transaction
//
// Returns one of the following values:
//      S_OK                    Method Succeeded
//      E_FAIL					a provider specific error occured
//      DB_E_UNEXPECTED			An unexpected error occured
//      XACT_E_CONNECTION_DOWN  Connection to datasource down
//		XACT_E_NOTRANSACTION	transaction had already been implicitly or explicityly commited/aborted
//		XACT_E_NOTSUPPORTED		fAsync was TRUE on input and async abort operation not supported
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpITransactionLocal::Abort (BOID *pboidReason,
											BOOL fRetaining,
											BOOL fAsync)
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(m_pCDBSession->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	if(fAsync)
	{
		hr = XACT_E_NOTSUPPORTED;
	}
	else
	if(fRetaining)
	{
		hr = XACT_E_CANTRETAIN;
	}
	//==============================================
	// check if transaction is already started
	//==============================================
	else
	if(!m_pCDBSession->IsTransactionActive())
	{
		hr = XACT_E_NOTRANSACTION;
	}
	else
	{
		//===============================================================================================
		// call this functin to Abort transactions
		//===============================================================================================
		if(SUCCEEDED(hr = m_pCDBSession->m_pCDataSource->m_pWbemWrap->CompleteTransaction(TRUE,0)))	// put the commit function here
		{
			m_pCDBSession->SetTransactionActive(FALSE);
		}
	}

	if(SUCCEEDED(hr))
	{
		m_pCDBSession->SetAllOpenRowsetToZoombieState();
	}
	
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_ITransactionLocal);

	CATCH_BLOCK_HRESULT(hr,L"ITransactionLocal::Abort");
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Get information regarding transaction
//
// Returns one of the following values:
//      S_OK                    Method Succeeded
//      E_FAIL					a provider specific error occured
//      DB_E_UNEXPECTED			An unexpected error occured
//      DB_E_INVALIDARG			pInfo was a null pointer
//		XACT_E_NOTRANSACTION	Unable to retrieve info because txn was already completed
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpITransactionLocal::GetTransactionInfo (XACTTRANSINFO *pinfo)
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(m_pCDBSession->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	if(pinfo == NULL)
	{
		hr = E_INVALIDARG;
	}
	else
	if(!m_pCDBSession->IsTransactionActive())
	{
		hr = XACT_E_NOTRANSACTION;
	}
	else
	{
//		XACTUOW uow;
//		GetCurrentUOW(uow);
		pinfo->uow						= m_pCDBSession->GetCurrentUOW();
		pinfo->isoLevel					= m_pCDBSession->GetIsolationLevel();		
		pinfo->isoFlags					= 0;
		pinfo->grfTCSupported			= XACTTC_SYNC;
		pinfo->grfRMSupported			= 0;
		pinfo->grfTCSupportedRetaining	= 0;
		pinfo->grfRMSupportedRetaining	= 0;
	}
	
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_ITransactionLocal);

	CATCH_BLOCK_HRESULT(hr,L"ITransactionLocal::GetTransactionInfo");
	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Get the options object for the transaction
// Returns an object which can be used to specify configuration options for subsequent
// call to ITransactionLocal::StartTransaction
//
// Returns one of the following values:
//      S_OK                    Method Succeeded
//      E_FAIL					a provider specific error occured
//      DB_E_UNEXPECTED			An unexpected error occured
//      DB_E_INVALIDARG			ppObtions was a null pointer
//		E_OUTOFMEMORY			unable to allocate memory
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpITransactionLocal::GetOptionsObject(ITransactionOptions  ** ppOptions)
{
	HRESULT hr = E_INVALIDARG;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(m_pCDBSession->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	if(ppOptions)
	{
		*ppOptions = NULL;
		CTranOptions *pNewOptions = NULL;
		hr  = E_OUTOFMEMORY;
		try
		{
			pNewOptions = new CTranOptions;
		}
		catch(...)
		{
			SAFE_DELETE_PTR(pNewOptions);
			throw;
		}

		if(pNewOptions)
		{
			hr = S_OK;
			if(SUCCEEDED(hr = pNewOptions->FInit()))
			{
				hr = pNewOptions->QueryInterface(IID_ITransactionOptions , (void **)ppOptions);
			}
			else
			{
				SAFE_DELETE_PTR(pNewOptions);
			}
		}
	}
	
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_ITransactionLocal);

	CATCH_BLOCK_HRESULT(hr,L"ITransactionLocal::GetOptionsObject");
	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Begins a new transaction
//
// Returns one of the following values:
//      S_OK                    Method Succeeded
//      E_FAIL					a provider specific error occured
//		DB_E_OBJECTOPEN			a rowset object was open and provider does not support starting a
//								new transaction with an existing open rowset/row object open
//      DB_E_UNEXPECTED			An unexpected error occured
//      XACT_E_CONNECTIONDENIED	session could not create a new transaction at the present time
//		XACT_E_CONNECTION_DOWN	Session is having communication difficulties
//		XACT_E_NOISORETAIN		Requested semantics of retention of isolation across retaining 
//								commit/abort boundaries cannot be supported or isoFlags was 
//								not equal to zero
//		XACT_E_XTIONEXISTS		Session can handle only one extant transaction ata time and 
//								there is presently such a transaction.
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpITransactionLocal::StartTransaction( ISOLEVEL isoLevel,
														ULONG isoFlags,
														ITransactionOptions  *pOtherOptions,
														ULONG *pulTransactionLevel)
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;
	LONG lFlags = 0;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(m_pCDBSession->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();


	//==============================================
	// check if transaction is already started
	//==============================================
	if(m_pCDBSession->IsTransactionActive())
	{
		hr = XACT_E_XTIONEXISTS;
	}
	else
	{
		XACTOPT xOpt;
		GUID	guidTrans;
		// NTBug:111816
		// 06/07/00
		hr = CoCreateGuid(&guidTrans);
		xOpt.ulTimeout = 0;
		memset(xOpt.szDescription,0,MAX_TRAN_DESC * sizeof(unsigned char));

		if(SUCCEEDED(hr) && pOtherOptions)
		{
			hr = pOtherOptions->GetOptions(&xOpt);
		}
		if(SUCCEEDED(hr))
		{
			if(SUCCEEDED(hr = GetFlagsForIsolation(isoLevel,lFlags)))
			{
				//===============================================================================================
				// call this functin to start a transaction
				//===============================================================================================
				if(SUCCEEDED(hr = m_pCDBSession->GenerateNewUOW(guidTrans)) && 
					SUCCEEDED(hr = m_pCDBSession->m_pCDataSource->m_pWbemWrap->BeginTransaction(xOpt.ulTimeout,lFlags,&guidTrans)))	// put the commit function here
				{
					m_pCDBSession->SetTransactionActive(TRUE);
					m_pCDBSession->SetIsolationLevel(isoLevel);
					if(pulTransactionLevel)
					{
						*pulTransactionLevel = 1;
					}
				}
			}
		}
	}
	
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_ITransactionLocal);

	CATCH_BLOCK_HRESULT(hr,L"ITransactionLocal::StartTransaction");
	return hr;
}

HRESULT CImpITransactionLocal::GetFlagsForIsolation(ISOLEVEL isoLevel,LONG &lFlag)
{
	HRESULT hr = S_OK;
	lFlag = 0;
	switch(isoLevel)
	{
		case ISOLATIONLEVEL_READCOMMITTED:
			lFlag = 0;
			break;
/*
		case ISOLATIONLEVEL_CURSORSTABILITY:
		case ISOLATIONLEVEL_REPEATABLEREAD:
			//lFlags = Read  
			break;

		case ISOLATIONLEVEL_SERIALIZABLE:
		case ISOLATIONLEVEL_ISOLATED:
			// lFlags = write
			break;
*/

		default:
		hr = XACT_E_ISOLATIONLEVEL;

	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\persist.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// IPersistFile interface implementation for Datasource object
//
///////////////////////////////////////////////////////////////////////////////////////////////


#include "headers.h"

// Key values of the different properties to be stored in the file
WCHAR wszDataSource[]		= L"DataSource";			// DBPROP_INIT_DATASOURCE
WCHAR wszUserId[]			= L"UserID";				// DBPROP_AUTH_USERID
WCHAR wszMode[]				= L"Mode";					// DBPROP_INIT_MODE
WCHAR wszProtection[]		= L"ProtectionLevel";		// DBPROP_INIT_PROTECTION_LEVEL
WCHAR wszImpersonation[]	= L"ImpersonationLevel";	// DBPROP_INIT_IMPERSONATION_LEVEL
WCHAR wszWmioledbQualif[]	= L"WmiOledbQualifiers";	// DBPROP_WMIOLEDB_QUALIFIERS
WCHAR wszWmioledbAuthority[]= L"Authority";				// DBPROP_WMIOLEDB_AUTHORITY
WCHAR wszSystemProperties[] = L"System Properties";		// DBPROP_WMIOLEDB_SYSTEMPROPERTIES

const ULONG DBCS_MAXWID				=sizeof(WCHAR);

///////////////////////////////////////////////////////////////////////////////////////////////
//
// Get the CLSID of the DSO.
//
//	Returns one of the following values
// HRESULT
//      S_OK                   The method succeeded.
//      E_FAIL                 Provider-specific error.
//
///////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIPersistFile::GetClassID( CLSID *pClassID )
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(m_pObj->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	// Check the pointer
	if ( pClassID ){
		memcpy( pClassID, &CLSID_WMIOLEDB, sizeof(CLSID) );
		hr = S_OK;
	}
	else
	{
		hr =  E_FAIL;
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetLocate);

	CATCH_BLOCK_HRESULT(hr,L"IPersistFile::GetClassID");
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////
//
// Checks an object for changes since it was last saved to its current file.
//
//	Returns one of the following values
// HRESULT
//      S_OK                   The object has changed since it was last saved
//      S_FALSE                The object has not changed since the last saved
//
///////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIPersistFile::IsDirty(void)
{
	HRESULT hr = S_FALSE;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(m_pObj->GetCriticalSection());
	// Clear previous Error Object for this thread
	g_pCError->ClearErrorInfo();

	hr = m_pObj->m_bIsPersitFileDirty ? S_OK : S_FALSE;

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetLocate);

	CATCH_BLOCK_HRESULT(hr,L"IPersistFile::IsDirty");
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////
//
// Retrieves either the absolute path to the object's current working file
// or, if there is no current working file, the object's default filename prompt.
//
//	Returns one of the following values
// HRESULT
//      S_OK					A valid absolute path was successfully returned
//      S_FALSE					The default save prompt was returned
//		E_OUTOFMEMORY			The operation failed due to insufficient memory
//		E_FAIL					The operation failed due to some reason other than 
//								insufficient memory
//
///////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIPersistFile::GetCurFile( LPOLESTR *ppszFileName)
{
	HRESULT hr = S_FALSE;
	int nFileNameLen = 0;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(m_pObj->GetCriticalSection());
	// Clear previous Error Object for this thread
	g_pCError->ClearErrorInfo();
	
	if (ppszFileName == NULL)
		hr = E_FAIL;
	else
	if(m_pObj->m_strPersistFileName != NULL)
	{
		nFileNameLen = (SysStringLen(m_pObj->m_strPersistFileName) + 1 )* sizeof(WCHAR);
		*ppszFileName = (LPOLESTR )g_pIMalloc->Alloc(nFileNameLen);
		if ( ! *ppszFileName )
			hr = E_OUTOFMEMORY;
		else
		{
			wcscpy(*ppszFileName,m_pObj->m_strPersistFileName);
			hr = S_OK;
		}
	}
	// Else if file name is null then return the defauld save prompt ie "*.dso"
	else
	if(m_pObj->m_strPersistFileName == NULL)
	{
		static const WCHAR wszDefaultSavePrompt[] = L"*.dso";
		nFileNameLen = (wcslen(wszDefaultSavePrompt) + 1) * sizeof(WCHAR);
		
		try
		{
			*ppszFileName = (OLECHAR*)(LPOLESTR )g_pIMalloc->Alloc(nFileNameLen);
		}
		catch(...)
		{
			if(*ppszFileName)
			{
				g_pIMalloc->Free(*ppszFileName);
				*ppszFileName = NULL;
			}
			throw;
		}

		if ( ! *ppszFileName )
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			// Copy the string
			wcscpy(*ppszFileName, wszDefaultSavePrompt);
			hr =  S_FALSE;
		}

	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetLocate);

	CATCH_BLOCK_HRESULT(hr,L"IPersistFile::GetCurFile");
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////
//
// Opens the specified file and initializes an object from the file contents.
//
//	Returns one of the following values
// HRESULT
//      S_OK					The object was successfully loaded
//      S_FALSE					The default save prompt was returned
//		E_OUTOFMEMORY			The object could not be loaded due to a lack of memory
//		DB_E_ALREADYINITIALIZED	The object is already initialized and so load failed
//		STG_E_INVALIDNAME		The name of the file passed is invalid or null
//		STG_E_FILENOTFOUND		The specified file not found
//		E_FAIL					The operation failed due to some reason other than 
//								insufficient memory
///////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIPersistFile::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	CAutoBlock cab(m_pObj->GetCriticalSection());

	// Clear previous Error Object for this thread
	g_pCError->ClearErrorInfo();

	// @devnote We ignore the 'dwMode' parameter.

	// Illegal to load if initialized.
	if (IsInitialized())
		hr = DB_E_ALREADYINITIALIZED;
	// Read all the properties from the file.
	// But we just store them; client has to call IDBInitialize.
	else
	if (!pszFileName)
	{
		hr = STG_E_INVALIDNAME;
	}
	else
	{
			// Read the file and initialize the object
			hr = ReadFromFile(pszFileName);

			// Clear the dirty flag, store name.
			if (SUCCEEDED(hr))
			{
				ClearDirtyFlag();

				// Save the filename, if given.
				if (pszFileName)
				{
					SysFreeString(m_pObj->m_strPersistFileName);
					m_pObj->m_strPersistFileName = Wmioledb_SysAllocString(pszFileName);
				}
			}

	}


	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetLocate);

	CATCH_BLOCK_HRESULT(hr,L"IPersistFile::Load");
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////
//
// Saves a copy of the object into the specified file.ie. saves initialization properties
//
//	Returns one of the following values
// HRESULT
//      S_OK					The object was successfully loaded
//      S_FALSE					The default save prompt was returned
//		E_OUTOFMEMORY			The object could not be loaded due to a lack of memory
//		STG_E_INVALIDNAME		The name of the file passed is invalid or null
//		E_FAIL					The operation failed due to some reason other than 
//								insufficient memory
///////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIPersistFile::Save(LPCOLESTR pszFileName,BOOL fRemember)
{
	HRESULT hr = S_OK;
	LPCOLESTR pFileNameTemp;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Serialize the object
	CAutoBlock cab(m_pObj->GetCriticalSection());
	// Clear previous Error Object for this thread
	g_pCError->ClearErrorInfo();

	if(m_pObj->m_fDSOInitialized == FALSE)
	{
		hr = E_UNEXPECTED;
	}
	else
	// if file name stored AND the filename passed is NULL
	if(( pszFileName == NULL && m_pObj->m_strPersistFileName == NULL) ||
		(pszFileName != NULL && wcslen(pszFileName) == 0))
		hr = STG_E_INVALIDNAME;
	else
	{
		pFileNameTemp = pszFileName == NULL ? m_pObj->m_strPersistFileName : pszFileName;
		// Call this function to save properties to the file
		if(S_OK == (hr = WriteToFile(pFileNameTemp)))
		{
			ClearDirtyFlag();
		}

		// if the name of file is not to be remembered then free the string
		if(pszFileName != NULL && fRemember == TRUE)
		{
			SysFreeString(m_pObj->m_strPersistFileName);
			m_pObj->m_strPersistFileName = Wmioledb_SysAllocString(pszFileName);

//			SysFreeString(m_pObj->m_strPersistFileName);
//			m_pObj->m_strPersistFileName = NULL;
//			m_pObj->m_bIsPersitFileDirty = TRUE;
		}
		if(fRemember == FALSE)
		{
			m_pObj->m_bIsPersitFileDirty = TRUE;
		}
	}

	CATCH_BLOCK_HRESULT(hr,L"IPersistFile::Save");
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetLocate);
	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////
//
// Notifies the object that it can write to its file
//
//	Returns one of the following values
// HRESULT
//      S_OK					Returned in all cases
///////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CImpIPersistFile::SaveCompleted(LPCOLESTR pszFileName)
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Clear previous Error Object for this thread
	g_pCError->ClearErrorInfo();

	CATCH_BLOCK_HRESULT(hr,L"IPersistFile::SaveCompleted");
	return hr;
}





///////////////////////////////////////////////////////////////////////////////////////////////
//
// Function to Write initialization properties to the file
//
//	Returns one of the following values
// HRESULT
//		S_OK		Writing into file is successful
//		E_FAIL		Writing to file failed
//      Return values of GetProperties
//
///////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CImpIPersistFile::WriteToFile(LPCOLESTR strFileName)
{
	DBPROPSET*	prgPropertySets;
	ULONG		ulPropSets		= 0;
	HRESULT		hr				= S_OK;
	ULONG		nPropSetIndex	= 0;
	ULONG		nPropIndex		= 0;
	WCHAR *		wszKey			= NULL;
	VARIANT		varTemp;
	BOOL		bWriteToFile	= TRUE;

	VariantInit(&varTemp);

	// Get data source object's properties
	if(S_OK == (hr = m_pObj->m_pUtilProp->GetProperties(PROPSET_DSO,0,NULL,&ulPropSets,&prgPropertySets)))
	{
		for(nPropSetIndex = 0 ; nPropSetIndex < ulPropSets ; nPropSetIndex++)
		{
			// Only Initialization properties are stored in the file
			if(prgPropertySets[nPropSetIndex].guidPropertySet == DBPROPSET_DBINIT ||
				prgPropertySets[nPropSetIndex].guidPropertySet == DBPROPSET_WMIOLEDB_DBINIT)
			{
				// For all properties in the property set returned
				for(nPropIndex = 0 ; nPropIndex < prgPropertySets[nPropSetIndex].cProperties ; nPropIndex++)
				{
					bWriteToFile = TRUE;
					// Switch on the property ID to get the appropriate key value
					switch(prgPropertySets[nPropSetIndex].rgProperties[nPropIndex].dwPropertyID)
					{
						case DBPROP_INIT_DATASOURCE:
							wszKey		= &wszDataSource[0];
							break;

						case DBPROP_AUTH_USERID:
							wszKey = &wszUserId[0];

						case DBPROP_INIT_MODE:
							wszKey		= &wszMode[0];
							break;

						case DBPROP_INIT_PROTECTION_LEVEL:
							wszKey		= &wszProtection[0];
							break;

						case DBPROP_INIT_IMPERSONATION_LEVEL:
							wszKey		= &wszImpersonation[0];
							break;

						case DBPROP_WMIOLEDB_QUALIFIERS:
							wszKey		= &wszWmioledbQualif[0];
							break;

						case DBPROP_WMIOLEDB_SYSTEMPROPERTIES:
							wszKey		= &wszSystemProperties[0];
							break;

						case DBPROP_WMIOLEDB_AUTHORITY:
							wszKey		= &wszWmioledbAuthority[0];
							break;
						
						default:
							bWriteToFile = FALSE;
					}

					// If everything is successful then write value to file
					if(bWriteToFile == TRUE)
					{
						// If property is not of type BSTR convert it into BSTR
						VariantClear(&varTemp);
						if(prgPropertySets[nPropSetIndex].rgProperties[nPropIndex].vValue.vt != VT_BSTR)
						{
							// Convert the value to string
							VariantChangeType(&varTemp,&prgPropertySets[nPropSetIndex].rgProperties[nPropIndex].vValue,
												VARIANT_NOVALUEPROP,VT_BSTR);
						}
						else
						{
							VariantCopy(&varTemp,&prgPropertySets[nPropSetIndex].rgProperties[nPropIndex].vValue);
						}
						// Call the member function to persist into a file
						if(!WritePrivateProfileString(WMIOLEDB,wszKey,varTemp.bstrVal,strFileName))
						{
							VariantClear(&varTemp);
							return E_FAIL;
						}
					}
				}
			}
		}
    	//==========================================================================
		//  Free memory we allocated to by GetProperties
    	//==========================================================================
		m_pObj->m_pUtilProp->m_PropMemMgr.FreeDBPROPSET(ulPropSets, prgPropertySets);

	}
	VariantClear(&varTemp);
	return hr;

}


///////////////////////////////////////////////////////////////////////////////////////////////
//
// Read properties from the file and initialize the datasource object by setting the 
//	initialization properties
//
//	Returns one of the following values
// HRESULT
//		S_OK					Reading from file and datasource initiallization was successful
//		STG_E_FILENOTFOUND		The specified file not found
//		E_FAIL					Reading from file faied , due to lack of memory
//      Return values of SetProperties
//
///////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CImpIPersistFile::ReadFromFile(LPCOLESTR pszFileName)
{
	HRESULT hr = E_FAIL;
	WCHAR	wszFileNameFull[MAX_PATH];			// fill in with full path name
	WCHAR	wszValue[MAX_PATH];
	VARIANT varProp;
	LONG	lValue = 0;
	
	VariantInit(&varProp);

	// Check if file exists and also get the full absolute path
	if(S_OK == (hr = GetCurrentFile(pszFileName,wszFileNameFull,GENERIC_READ)))
	{
		memset(wszValue,0,MAX_PATH * sizeof(WCHAR));
		// Get the DBPROP_INIT_DATASOURCE from the file  
		if(GetPrivateProfileStr(WMIOLEDB,wszDataSource,pszFileName,wszValue))
		{
			varProp.vt = VT_BSTR;
			varProp.bstrVal = Wmioledb_SysAllocString(wszValue);
			// Set DBPROP_INIT_DATASOURCE property
			hr = SetDBInitProp(DBPROP_INIT_DATASOURCE,DBPROPSET_DBINIT,varProp);
		}

		// Get the DBPROP_AUTH_USERID from the file  
		if(GetPrivateProfileStr(WMIOLEDB,wszUserId,pszFileName,wszValue))
		{
			varProp.vt = VT_BSTR;
			varProp.bstrVal = Wmioledb_SysAllocString(wszValue);
			// Set DBPROP_AUTH_USERID property
			hr = SetDBInitProp(DBPROP_AUTH_USERID,DBPROPSET_DBINIT,varProp);
		}

		// Get the DBPROP_INIT_MODE from the file  
		if( hr == S_OK && GetPrivateProfileLong(WMIOLEDB,wszMode,pszFileName,lValue))
		{
			VariantClear(&varProp);
			varProp.vt		= VT_I4;
			varProp.lVal	= lValue;
			// Set DBPROP_INIT_MODE property
			hr = SetDBInitProp(DBPROP_INIT_MODE,DBPROPSET_DBINIT,varProp);
		}

		// Get the DBPROP_INIT_PROTECTION_LEVEL from the file  
		if( hr == S_OK && GetPrivateProfileLong(WMIOLEDB,wszProtection,pszFileName,lValue))
		{
			VariantClear(&varProp);
			varProp.vt		= VT_I4;
			varProp.lVal	= lValue;
			// Set DBPROP_INIT_PROTECTION_LEVEL property
			hr = SetDBInitProp(DBPROP_INIT_PROTECTION_LEVEL,DBPROPSET_DBINIT,varProp);
		}

		// Get the DBPROP_INIT_IMPERSONATION_LEVEL from the file  
		if( hr == S_OK && GetPrivateProfileLong(WMIOLEDB,wszImpersonation,pszFileName,lValue))
		{
			VariantClear(&varProp);
			varProp.vt		= VT_I4;
			varProp.lVal	= lValue;
			// Set DBPROP_INIT_IMPERSONATION_LEVEL property
			hr = SetDBInitProp(DBPROP_INIT_IMPERSONATION_LEVEL,DBPROPSET_DBINIT,varProp);
		}

		// Get the DBPROP_WMIOLEDB_QUALIFIERS from the file  
		if( hr == S_OK && GetPrivateProfileLong(WMIOLEDB,wszWmioledbQualif,pszFileName,lValue))
		{
			VariantClear(&varProp);
			varProp.vt		= VT_I4;
			varProp.lVal	= lValue;
			// Set DBPROP_WMIOLEDB_QUALIFIERS property
			hr = SetDBInitProp(DBPROP_WMIOLEDB_QUALIFIERS,DBPROPSET_WMIOLEDB_DBINIT,varProp);
		}

		// Get the DBPROP_WMIOLEDB_SYSTEMPROPERTIES from the file  
		if( hr == S_OK && GetPrivateProfileLong(WMIOLEDB,wszSystemProperties,pszFileName,lValue))
		{
			VariantClear(&varProp);
			varProp.vt		= VT_BOOL;
			varProp.boolVal	= (BOOL)lValue;
			// Set DBPROP_WMIOLEDB_QUALIFIERS property
			hr = SetDBInitProp(DBPROP_WMIOLEDB_SYSTEMPROPERTIES,DBPROPSET_WMIOLEDB_DBINIT,varProp);
		}

		// Get the DBPROP_WMIOLEDB_AUTHORITY from the file  
		if( hr == S_OK && GetPrivateProfileStr(WMIOLEDB,wszWmioledbAuthority,pszFileName,wszValue))
		{
			VariantClear(&varProp);
			varProp.vt		= VT_BSTR;
			varProp.bstrVal	= SysAllocString(wszValue);
			// Set DBPROP_WMIOLEDB_AUTHORITY property
			hr = SetDBInitProp(DBPROP_WMIOLEDB_AUTHORITY,DBPROPSET_WMIOLEDB_DBINIT,varProp);
		}
	}
	
	VariantClear(&varProp);
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Clear the dirty flag
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CImpIPersistFile::ClearDirtyFlag()
{
	m_pObj->m_bIsPersitFileDirty = FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Check if Datasource is Initialized
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CImpIPersistFile::IsInitialized()
{
	return m_pObj->m_fDSOInitialized;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Write a key value to the File in INI file format
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CImpIPersistFile::WritePrivateProfileString(LPCOLESTR wszAppName,LPCOLESTR wszKeyName,LPCOLESTR wszValue,LPCOLESTR wszFileName)
{
	BOOL	fRet = FALSE;
	// If operation system supports UNICODE then call UNICODE version 
	if(g_bIsAnsiOS == FALSE)
	{
		fRet = ::WritePrivateProfileStringW(wszAppName,
										wszKeyName,
										wszValue,
 										wszFileName);
	}
	// Else convert the strings to ANSI format and call ANSI version of the function
	else
	{
		LPSTR	szAppName = NULL;
		LPSTR	szKeyName = NULL;
		LPSTR	szValue = NULL;
		LPSTR	szFileName = NULL;

		if( UnicodeToAnsi((WCHAR *)wszAppName,szAppName) &&
			 UnicodeToAnsi((WCHAR *)wszKeyName,szKeyName) &&
			  UnicodeToAnsi((WCHAR *)wszValue,szValue) &&
			   UnicodeToAnsi((WCHAR *)wszFileName,szFileName) )
		{

			fRet = ::WritePrivateProfileStringA(szAppName,
											szKeyName,
											szValue,
											szFileName);
		}
		// release the memory
		SAFE_DELETE_ARRAY(szAppName);
		SAFE_DELETE_ARRAY(szKeyName);
		SAFE_DELETE_ARRAY(szValue);
		SAFE_DELETE_ARRAY(szFileName);
	}

	return fRet;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get a String Key value from the file
// Assumption: that the the buffer size of wszValue is MAX_PATH
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CImpIPersistFile::GetPrivateProfileStr(LPCOLESTR wszAppName,LPCOLESTR wszKeyName,LPCOLESTR wszFileName,LPOLESTR wszValue)
{
	BOOL	fRet = FALSE;
	// If operation system supports UNICODE then call UNICODE version 
	if(g_bIsAnsiOS == FALSE)
	{
		fRet = ::GetPrivateProfileStringW(wszAppName,
										wszKeyName,
										NULL,
										wszValue,
										MAX_PATH,
 										wszFileName);
	}
	// Else convert the strings to ANSI format and call ANSI version of the function
	else
	{
		LPSTR	szAppName = NULL;
		LPSTR	szKeyName = NULL;
		LPSTR	szFileName = NULL;

		LPSTR pszValue = NULL;
		pszValue = new char[MAX_PATH * DBCS_MAXWID];

		if( UnicodeToAnsi((WCHAR *)wszAppName,szAppName) &&
			 UnicodeToAnsi((WCHAR *)wszKeyName,szKeyName) &&
			   UnicodeToAnsi((WCHAR *)wszFileName,szFileName) )
		{
			if(0 != (fRet = ::GetPrivateProfileStringA(szAppName,
										szKeyName,
										NULL,
										pszValue,
										MAX_PATH * DBCS_MAXWID,
										szFileName)))
			{
				// convert back to UNICODE
				AllocateAndConvertAnsiToUnicode(pszValue,wszValue);
			}
		}
		// release the memory
		SAFE_DELETE_ARRAY(szAppName);
		SAFE_DELETE_ARRAY(szKeyName);
		SAFE_DELETE_ARRAY(pszValue);
		SAFE_DELETE_ARRAY(szFileName);
	}

	return fRet;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get a Long Key value from the file
//	//NTRaid:111772
	// 06/07/00
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CImpIPersistFile::GetPrivateProfileLong(LPCOLESTR wszAppName,LPCOLESTR wszKeyName,LPCOLESTR wszFileName, LONG &lValue)
{
	BOOL	fRet		= FALSE;
	INT		nDefaultVal	= -1111;

	// If operation system supports UNICODE then call UNICODE version 
	if(g_bIsAnsiOS == FALSE)
	{
		if(nDefaultVal != (lValue = ::GetPrivateProfileIntW(wszAppName,
										wszKeyName,
										nDefaultVal,
										wszFileName)))
			fRet = TRUE;
	}
	// Else convert the strings to ANSI format and call ANSI version of the function
	else
	{
		LPSTR	szAppName = NULL;
		LPSTR	szKeyName = NULL;
		LPSTR	szFileName = NULL;

		if( UnicodeToAnsi((WCHAR *)wszAppName,szAppName) &&
			 UnicodeToAnsi((WCHAR *)wszKeyName,szKeyName) &&
			   UnicodeToAnsi((WCHAR *)wszFileName,szFileName) )
		{
			if( nDefaultVal != (lValue = ::GetPrivateProfileIntA(szAppName,
										szKeyName,
										nDefaultVal,
										szFileName)))
				fRet = TRUE;
		}
		// release the memory
		SAFE_DELETE_ARRAY(szAppName);
		SAFE_DELETE_ARRAY(szKeyName);
		SAFE_DELETE_ARRAY(szFileName);
	}

	return fRet;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function which gets the absolute path of the file, then checks whether the file exists for
// the given access on the file
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CImpIPersistFile::GetCurrentFile(LPCOLESTR pwszFileName,LPOLESTR wszFileNameFull,DWORD dwAccess)
{
	//NTRaid:111771
	// 06/07/00
	HANDLE hFile = INVALID_HANDLE_VALUE;
	DWORD dwShareMode;
	DWORD dwCreationDistribution;
	HRESULT hr = S_OK;

	// Call this function to get the absolute path of the file
	if(S_OK == ( hr = GetAbsolutePath(pwszFileName,wszFileNameFull)))
	{
		// Set the access, share mpde and file creation flags depending on the access
		// for which the file is required
		if(dwAccess != GENERIC_READ)
		{
			dwAccess =  GENERIC_READ | GENERIC_WRITE;
			dwShareMode = 0;							// disallow other user access, FILE_SHARE_READ, _WRITE
			dwCreationDistribution	= OPEN_ALWAYS;		// will create if it doesn't exist
		}
		else
		{
			dwShareMode				= FILE_SHARE_READ;
			dwCreationDistribution	= OPEN_EXISTING;
		}


	// If operation system supports UNICODE then call UNICODE version 
		if ( !g_bIsAnsiOS ) 
		{
			hFile = ::CreateFileW(wszFileNameFull, dwAccess, dwShareMode, NULL,
								dwCreationDistribution,	FILE_ATTRIBUTE_NORMAL, NULL );

		}
	// Else convert the strings to ANSI format and call ANSI version of the function
		else
		{
			LPSTR szFileName;
			if(UnicodeToAnsi((WCHAR *)pwszFileName,szFileName))
				hFile = ::CreateFileA(szFileName, dwAccess, dwShareMode, NULL,
									dwCreationDistribution,	FILE_ATTRIBUTE_NORMAL, NULL );
			else
				hr = E_FAIL;

			SAFE_DELETE_ARRAY(szFileName);
		}

		// If the handle is invalid then return error
		if (hFile == INVALID_HANDLE_VALUE)
		{
			hr = STG_E_FILENOTFOUND;
		}
		else
			CloseHandle(hFile);
	} // Get the full path
	
	return hr;

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the absolute path of the file
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CImpIPersistFile::GetAbsolutePath(LPCOLESTR pwszFileName,LPOLESTR wszFileNameFull)
{
	HRESULT hr = S_OK;
	
	// If operation system supports UNICODE then call UNICODE version 
	if ( !g_bIsAnsiOS ) 
	{
		if(NULL == _wfullpath( wszFileNameFull, pwszFileName, MAX_PATH ))
			hr = E_FAIL;
	}
	// Else convert the strings to ANSI format and call ANSI version of the function
	else
	{
		LPSTR pszAbs = NULL;
		LPSTR pszRel = NULL;
		pszAbs = new char[MAX_PATH * DBCS_MAXWID];

		if ( pszAbs )
		{

			if (!UnicodeToAnsi((WCHAR *)pwszFileName, pszRel )) 
				hr = E_FAIL;
			else
			if ( _fullpath(pszAbs, pszRel, MAX_PATH * DBCS_MAXWID) )
			{
				// Convert the output parameter back to UNICODE
				AllocateAndConvertAnsiToUnicode(pszAbs,wszFileNameFull);
			}
			else
				hr = E_FAIL;

			SAFE_DELETE_ARRAY(pszAbs);
			SAFE_DELETE_ARRAY(pszRel);
		}
		else
			hr = E_OUTOFMEMORY;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to set a specific Datasource Initialization property
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CImpIPersistFile::SetDBInitProp(DBPROPID propId ,GUID guidPropSet,VARIANT vPropValue)
{
	DBPROPSET	rgPropertySets[1];
	DBPROP		rgprop[1];
	HRESULT		hr				= S_OK;


	memset(&rgprop[0],0,sizeof(DBPROP));
	memset(&rgPropertySets[0],0,sizeof(DBPROPSET));

	rgprop[0].dwPropertyID = propId;
	VariantCopy(&rgprop[0].vValue,&vPropValue);

	rgPropertySets[0].rgProperties		= &rgprop[0];
	rgPropertySets[0].cProperties		= 1;
	rgPropertySets[0].guidPropertySet	= guidPropSet;


	hr = m_pObj->m_pUtilProp->SetProperties( PROPSET_INIT,1,rgPropertySets);

	VariantClear(&rgprop[0].vValue);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\precomp.h ===
#include <comdef.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\qualifrowfetch.cpp ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CQualifierRowFetchObj object implementation
// 
//
///////////////////////////////////////////////////////////////////////////////////

#include "headers.h"
#include "WmiOleDBMap.h"

///////////////////////////////////////////////////////////////////////////////////////
// Function which fetches required number of rows
///////////////////////////////////////////////////////////////////////////////////////
HRESULT CQualifierRowFetchObj::FetchRows(CRowset *	 pRowset,
								HCHAPTER		hChapter,        // IN  The Chapter handle.
								DBROWOFFSET		lRowOffset,      // IN  Rows to skip before reading
								DBROWCOUNT		cRows,           // IN  Number of rows to fetch
								DBCOUNTITEM*	pcRowsObtained, // OUT Number of rows obtained
								HROW       **	prghRows)       // OUT Array of Hrows obtained)

{
    DBCOUNTITEM	cRowsTmp				= 0;
    HROW		irow, ih;
    PROWBUFF	prowbuff				= NULL;
    HRESULT		hr						= S_OK;
	HROW	*	prghRowsTemp			= NULL;
	HROW		hRowCurrent				= 0;
	HSLOT		hSlot					= -1;
	BOOL		bAlreadyDataRetrieved	= FALSE; 
	BOOL		bAlreadyFetched			= FALSE;
	CVARIANT	varKey;
	BOOL		bFetchBack				= FALSE;
	HROW		hRowTemp;
	BSTR		strQualifier;
	CBSTR		strKey;
	LONG_PTR	lFetchPos				= 0;
	BOOL		bHRowsAllocated			= FALSE;
	DBROWCOUNT	ulMax					= 0;
	BOOL		bMaxRowsExceed			= FALSE;
	
	CWbemClassWrapper *pInst			= NULL;

	if(cRows != 0)
	{
		{
			VARIANT varTemp;
			VariantInit(&varTemp);
			pRowset->GetRowsetProperty(DBPROP_MAXOPENROWS,varTemp);

			ulMax	= varTemp.lVal;
			VariantClear(&varTemp);
		}


		//=======================================================
		// If already maximum rows are opened then return
		//=======================================================
		if( pRowset->m_ulRowRefCount >= (DBROWCOUNT)ulMax)
		{
			hr =  DB_S_ROWLIMITEXCEEDED;
		}
		else
		{

			if(pRowset->m_bIsChildRs == FALSE)
			{
				assert(pRowset->m_pInstance != NULL);
			}

			//========================
			// Fetch Data
			//========================
			if (lRowOffset)
			{
				if(hChapter > 0)
				{
					pInst = pRowset->m_pChapterMgr->GetInstance(hChapter);
				}
				else
				if(pRowset->m_bIsChildRs == FALSE)
				{
					pInst = pRowset->m_pInstance;
				}
				//===================================
				// Calculate the new position
				//===================================
				hr = pRowset->ResetRowsetToNewPosition(lRowOffset,pInst);
				if( hr != S_OK )
				{
					pRowset->SetStatus(hChapter , STAT_ENDOFCURSOR);
					hr = DB_S_ENDOFROWSET ;
				}
			}

			if(hr == S_OK)
			{

				if(0 >( lFetchPos = GetFirstFetchPos(pRowset,cRows,lRowOffset)))
				{
					hr = DB_E_BADSTARTPOSITION;
				}
				else
				{
					cRowsTmp	= cRows >= 0 ? cRows : cRows * (-1);
					ulMax	= ulMax - pRowset->m_ulRowRefCount;
					if(ulMax < (DBROWCOUNT)cRowsTmp)
					{
						bMaxRowsExceed = TRUE;
					}
					else
					{
						ulMax = cRowsTmp;
					}
					cRowsTmp = 0;

					pRowset->m_FetchDir = (LONG_PTR)cRows < 0 ? FETCHDIRBACKWARD : FETCHDIRFORWARD;
					bFetchBack			= (LONG_PTR)cRows < 0 ? TRUE : FALSE;
//					cRows = cRows >=0 ? cRows : cRows * (-1);
					//=======================================================================
					// If any rows is to be retrieved then allocate memory for the HROWS
					//=======================================================================
					if (ulMax )
					{
						try
						{
							prghRowsTemp = (HROW *) g_pIMalloc->Alloc( ulMax * sizeof( HROW ));
						}
						catch(...)
						{
							if(prghRowsTemp != NULL)
							{
								g_pIMalloc->Free(prghRowsTemp);
							}
							throw;
						}
					}
					
					if(prghRowsTemp == NULL)
					{
						hr = E_OUTOFMEMORY;
					}
				}
				if(SUCCEEDED(hr))
				{
					memset(prghRowsTemp,0,ulMax * sizeof( HROW ));

					hRowTemp = pRowset->m_hRowLastFetched;
					for (irow =1; irow <= (DBCOUNTITEM)ulMax; irow++)
					{
						bAlreadyFetched			= FALSE;
						bAlreadyDataRetrieved	= FALSE;

						if(pRowset->m_bIsChildRs == TRUE)
						{
							//==============================================================================
							// Find out whether qualifier is already obtained 
							//==============================================================================
							pInst = pRowset->m_pChapterMgr->GetInstance(hChapter);
							pRowset->m_pChapterMgr->GetInstanceKey(hChapter,(BSTR *)&strKey);
						}
						else
						if( pRowset->m_pInstance != NULL)
						{
							pInst = pRowset->m_pInstance;
						}

						switch(pRowset->m_uRsType)
						{
							case CLASSQUALIFIER:
								hr = pRowset->GetNextClassQualifier(pInst,strQualifier,bFetchBack);
								break;

							case PROPERTYQUALIFIER:
								hr = pRowset->GetNextPropertyQualifier(pInst,pRowset->m_strPropertyName,strQualifier,bFetchBack);
								break;
						}

						if(S_OK != hr)
						{
							pRowset->SetStatus(hChapter , STAT_ENDOFCURSOR);
							hr = DB_S_ENDOFROWSET;
							break;
						}

						if( hr == S_OK)
						{
							strKey.Clear();
							strKey.Unbind();
							strKey.SetStr(strQualifier);
							if(pRowset->m_bIsChildRs == TRUE)
							{
								hRowTemp = pRowset->m_pChapterMgr->GetHRow(hChapter,strQualifier);
							}
							else
							{
								hRowTemp = pRowset->m_InstMgr->GetHRow(strQualifier);
							}


							if( (LONG)hRowTemp > 0)
							{
								bAlreadyFetched = TRUE;
							}
						}

						if( bAlreadyFetched == TRUE)
						{
							hRowCurrent = hRowTemp;

							if(pRowset->m_bIsChildRs == TRUE)
							{
								hSlot = pRowset->m_pChapterMgr->GetSlot(hRowCurrent);
							}
							else
							{
								hSlot = pRowset->m_InstMgr->GetSlot(hRowCurrent);
							}
							if( hSlot != -1)
							{
								bAlreadyDataRetrieved = TRUE;
							}
						}


						//====================================================
						// Get the HROW if row is not already fetched
						//====================================================
						if( bAlreadyFetched == FALSE)
							hRowCurrent = pRowset->GetNextHRow();

						//=====================================================
						// Get the data if data is already not fetched
						//=====================================================
						if(bAlreadyDataRetrieved == FALSE)
						{

							hSlot		= -1;
							if (SUCCEEDED( hr = GetNextSlots( pRowset->m_pIBuffer, 1, &hSlot )))
							{
								if (FAILED( pRowset->Rebind((BYTE *) pRowset->GetRowBuffFromSlot( hSlot, TRUE ))))
								{
									hr = E_FAIL;
									break;
								}
							}
							else
							{
								break;
							}

							hRowCurrent = hSlot;

							//=================================================================================================
							// if the other updates visible property is set to false ,then get the data to the local buffer
							//=================================================================================================
							if(!( pRowset->m_ulProps & OTHERUPDATEDELETE))
							{

								if(FAILED(hr = pRowset->GetInstanceDataToLocalBuffer(pInst,hSlot,strQualifier)))
								{
									break;
								}

								//===========================================================================
								// if there is atleast one row retrieved and there are neseted columns
								// then allocate rows for the child recordsets
								//===========================================================================
								if(pRowset->m_cNestedCols > 0 )

								{
									if(pRowset->m_ppChildRowsets == NULL)
									{
										pRowset->AllocateAndInitializeChildRowsets();
									}

									//=====================================================================
									// Fill the HCHAPTERS for the column
									//=====================================================================
									if(S_OK != (hr = pRowset->FillHChaptersForRow(pInst,strKey)))
									{
										break;
									}
								}

							}

							
							if(SUCCEEDED(hr))
							{
								//===================================================
								// if the rowset is not a child rowset
								//===================================================
								if(pRowset->m_bIsChildRs == FALSE)
								{
									//=================================================
									// add instance pointer to instance manager
									//=================================================
									if(FAILED(hr = pRowset->m_InstMgr->AddInstanceToList(hRowCurrent,pInst,strQualifier,hSlot)))
									{
										break;
									}
								}
								//=================================================================================
								// if rowset is refering to qualifiers then add the row to the particular chapter
								//=================================================================================
								else 
								{
									// add instance pointer to instance manager
									if(FAILED(hr = pRowset->m_pChapterMgr->AddHRowForChapter(hChapter,hRowCurrent, NULL ,hSlot)))
									{
										break;
									}

									pRowset->m_pChapterMgr->SetInstance(hChapter,pInst, strQualifier ,hRowCurrent);
								}
							}						

						}	//if(bAlreadyDataRetrieved == FALSE)
				//		prghRowsTemp[irow-1] = hRowCurrent;
						prghRowsTemp[irow-1] = hSlot;

						SysFreeString(strQualifier);
						strKey.Clear();
						strKey.Unbind();
						strQualifier = Wmioledb_SysAllocString(NULL);
					}
					
					if(SUCCEEDED(hr))
					{
						cRowsTmp = irow - 1; //Irow will be +1 because of For Loop

						//=====================================================================
						// Through fetching many rows of data
						//
						// Allocate row handles for client. Note that we need to use IMalloc 
						// for this. Should only malloc cRowsTmp, instead of ulMax.
						// Should malloc ulMax, since client will assume it's that big.
						//=====================================================================

						if ( *prghRows == NULL && cRowsTmp )
						{
							try
							{
								*prghRows = (HROW *) g_pIMalloc->Alloc( cRowsTmp * sizeof( HROW ));
							}
							catch(...)
							{
								if(*prghRows)
								{
									g_pIMalloc->Free(prghRows);
								}
								throw;
							}
							bHRowsAllocated = TRUE;
							memset(*prghRows,0,cRowsTmp * sizeof( HROW ));
						}

						if ( *prghRows == NULL  && cRowsTmp )
						{
							hr =  E_OUTOFMEMORY ;
						}
						else
						{
							//=====================================================================
							// Fill in the status information: Length, IsNull. May be able to wait 
							// until first call to GetData, but have to do it sometime.
							//
							// Suggest keeping an array of structs of accessor info. One element is
							// whether accessor requires any status info or length info.
							//
							// Then we could skip this whole section.
							//
							// Added check for cRowsTmp to MarkRows call. Don't want to call if 
							// cRowsTmp==0.
							// (Range passed to MarkRows is inclusive, so can't specify marking 0 rows.)
							//
							// Note that SetSlots is a CBitArray member function -- not an IBuffer function.
							//
							// Added row-wise reference counts and cursor-wise reference counts.
							//
							// Set row handles, fix data length field and compute data status field.
							//=======================================================================
							pRowset->m_cRows   = cRowsTmp;

							// set the first position if it is zero
							if(lFetchPos == 0) 
							{
								lFetchPos = 1;
							}

							for (ih =0; ih < (ULONG) pRowset->m_cRows; ih++) 
							{


								//=============================================================================
								// Increment the rows-read count,
								// then store it as the bookmark in the very first DWORD of the row.
								//=============================================================================
								prowbuff = pRowset->GetRowBuff( prghRowsTemp[ih], TRUE );

								//=======================================================================================
								// Insert the bookmark and its row number (from 1...n) into a hash table.
								// This allows us to quickly determine the presence of a row in mem, given the bookmark.
								// The bookmark is contained in the row buffer, at the very beginning.
								// Bookmark is the row number within the entire result set [1...num_rows_read].

								// This was a new Bookmark, not in memory,
								// so return to user (in *prghRows) the hRow we stored.
								//=======================================================================================
								prowbuff->ulRefCount++;
								pRowset->m_ulRowRefCount++;

								(*prghRows)[ih] = prghRowsTemp[ih]; // (HROW) ( irow );
								pRowset->m_hRowLastFetched	= prghRowsTemp[ih];

								// if bookmark property is true then initialize the bookmark
								if(pRowset->m_ulProps & BOOKMARKPROP)
								{
									if(ih != 0)
									{
										lFetchPos = (pRowset->m_FetchDir == FETCHDIRFORWARD ) ?  lFetchPos + 1  : lFetchPos -1;
									}
        
									prowbuff->dwBmk				= lFetchPos;
									prowbuff->cbBmk				= BOOKMARKSIZE;
									pRowset->m_lLastFetchPos	= lFetchPos;

									// Add bookmark to the hashtable
									pRowset->m_pHashTblBkmark->InsertFindBmk(FALSE,prghRowsTemp[ih],prowbuff->cbBmk,(BYTE *)&(prowbuff->dwBmk),(HROW *)&hSlot);
								}
							
							}	// for loop
						
						}	// else for memory allocation for HROWS
					
					} // if(succeeded(hr))

					if(SUCCEEDED(hr))
					{
						*pcRowsObtained = cRowsTmp;
					}

					//===================================================
					// set return value if MAX_ROWS is exceeded
					//===================================================
					if( hr == S_OK && bMaxRowsExceed == TRUE)
					{
						hr = DB_S_ROWLIMITEXCEEDED;
					}

				} // else for some basic parameter checking
			} // if(Succeeded(hr)) after setting the resetting offset
		}	// else after checking for MAX rows limit
	} // if(cRows != 0)


	//==============================================
	// free the temporary memory allocated
	//==============================================

	if(FAILED(hr))
	{
	//	for(irow = irowFirst ; irow <= hRowTemp ; irow++)
		for (ih =0; ih < (ULONG) cRowsTmp; ih++) 
		{
			if(prghRowsTemp[ih] != 0)
			{
				if(pRowset->m_bIsChildRs == FALSE)
				{
					pRowset->m_InstMgr->DeleteInstanceFromList(prghRowsTemp[ih]);
				}
				else
				{
					pRowset->m_pChapterMgr->DeleteHRow(prghRowsTemp[ih]);
				}
			}
		}
		if(pcRowsObtained)
		{
			*pcRowsObtained = 0;
		}
		
		// if HROWS for output parameter is allcated by this method
		// then release them
		if(prghRows && bHRowsAllocated == TRUE)
		{
			g_pIMalloc->Free(prghRows);
			prghRows = NULL;
		}
		else
		if(prghRows)
		{
			*prghRows = NULL;
		}
		if(pcRowsObtained)
		{
			*pcRowsObtained = 0;
		}
		if(strQualifier != NULL)
		{
			SysFreeString(strQualifier);
		}
	}

	//==============================================
	// free the temporary memory allocated
	//==============================================
	if(prghRowsTemp)
	{
		g_pIMalloc->Free(prghRowsTemp);
		prghRowsTemp = NULL;
	}
	
	// reset the starting position to the original position
	if(lRowOffset && (FAILED(hr) || (hr != S_OK && cRowsTmp == 0)))
	{
		pRowset->ResetRowsetToNewPosition(lRowOffset * (-1),pInst);
	}


	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\opnrowst.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// interface implementation
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Opens and returns a rowset that includes all rows from a single base table
//
// HRESULT
//       S_OK                   The method succeeded
//       E_INVALIDARG           pTableID was NULL
//       E_FAIL                 Provider-specific error
//       DB_E_NOTABLE           Specified table does not exist in current Data Data Source object
//       E_OUTOFMEMORY          Out of memory
//       E_NOINTERFACE          The requested interface was not available
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIOpenRowset::OpenRowset(   IUnknown*    pUnkOuter,         // IN  Controlling unknown, if any
                                            DBID*        pTableID,          // IN  table to open
	                                        DBID*		pIndexID,		    // IN  DBID of the index
                                            REFIID      riid,               // IN  interface to return
                                            ULONG       cPropertySets,      // IN  count of properties
                                            DBPROPSET	rgPropertySets[],   // INOUT array of property values
                                            IUnknown**  ppRowset            // OUT   where to return interface
    )
{
    CRowset*    pRowset			= NULL;
    HRESULT     hr				= S_OK;
	HRESULT		hrProp			= S_OK ;
	BOOL		bRowRequested	= FALSE;
    CRow*		pRow			= NULL;
	ULONG		cErrors = 0;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;


    assert( m_pObj );
	assert( m_pObj->m_pUtilProp );


    //=====================================================================
    // NULL out-params in case of error
    //=====================================================================
    if( ppRowset )
	{
	    *ppRowset = NULL;
    }

	// Seriliaze the object
	CAutoBlock cab(m_pObj->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

    //=====================================================================
    // Check Arguments
    //=====================================================================
    if ( !pTableID && !pIndexID )
	{
		hr = E_INVALIDARG;
//        return g_pCError->PostHResult(E_INVALIDARG,&IID_IOpenRowset);
    }
	else
    if ( riid == IID_NULL)
	{
		hr = E_NOINTERFACE;
//        return g_pCError->PostHResult(E_NOINTERFACE,&IID_IOpenRowset) ;
    }
	else
	//==========================================================
	// We only accept NULL for pIndexID at this present time
	//==========================================================
    if( pIndexID )
	{                                         
		hr = DB_E_NOINDEX;
//        return g_pCError->PostHResult(DB_E_NOINDEX,&IID_IOpenRowset) ;
    }
	else
	//===================================================================================
	// We do not allow the riid to be anything other than IID_IUnknown for aggregation
	//===================================================================================
    if ( (pUnkOuter) && (riid != IID_IUnknown) )
	{   
		hr = DB_E_NOAGGREGATION;
//        return g_pCError->PostHResult(DB_E_NOAGGREGATION,&IID_IOpenRowset) ;
    }
	else
	//==============================================
	// validate the property sets to be set
	//==============================================
    if( SUCCEEDED(hr = m_pObj->m_pUtilProp->SetPropertiesArgChk(cPropertySets, rgPropertySets,TRUE)) )
	{

        //=================================================================
    	// If the eKind is not known to use, basically it means we have no 
        // table identifier
        //=================================================================
    	if ( (!pTableID ) || ( pTableID->eKind != DBKIND_NAME ) ||  ( (pTableID->eKind == DBKIND_NAME) && (!(pTableID->uName.pwszName)) ) ||
            ( wcslen(pTableID->uName.pwszName) == 0 ) ||  ( wcslen(pTableID->uName.pwszName) > _MAX_FNAME ) )
		{
            hr =  DB_E_NOTABLE ;
        }
        else
		{

			if( riid == IID_IRow || riid == IID_IRowChange  || 
				GetIRowProp(cPropertySets,rgPropertySets) == TRUE)
			{
				bRowRequested = TRUE;
			}
			// If rowset is to be created then create a new rowset
			if( bRowRequested == FALSE)
			{
				//===============================================================================
				// open and initialize a rowset\cursor object
			   //===============================================================================
	//            pRowset = new CRowset(pUnkOuter,NO_QUALIFIERS,(LPWSTR)(pTableID->uName.pwszName),m_pObj);
				try
				{
					pRowset = new CRowset(pUnkOuter,m_pObj);
				}
				catch(...)
				{
					SAFE_DELETE_PTR(pRowset);
					throw;;
				}

				if (!pRowset)
				{
					hr = E_OUTOFMEMORY ;
				}
				else
				{
					//===========================================================================
    				// if properties failed or ppRowset NULL
					//===========================================================================
					hr = pRowset->InitRowset(cPropertySets, rgPropertySets,(LPWSTR)(pTableID->uName.pwszName));
    				if( (SUCCEEDED(hr)) )
					{
						if(hr != S_OK)
						{
							cErrors++;
						}
						//=======================================================================
						// get requested interface pointer on rowset\cursor
						//=======================================================================
						if(ppRowset != NULL)
						{
							hr = pRowset->QueryInterface( riid, (void **) ppRowset );
							if (SUCCEEDED( hr ))
							{
								//===================================================================
            					//Assign creator pointer. Used for IRowsetInfo::GetSpecification
								//===================================================================
//								m_pObj->m_fRowsetCreated = TRUE;
							}
						}
						else
						{
							SAFE_DELETE_PTR(pRowset);
							hr = cErrors > 0 ? DB_S_ERRORSOCCURRED : S_OK;
						}	
					}
				} // else for failure of allocation of pRowset
			}
			// Create a row
			else
			{
				CURLParser  urlParser;
				VARIANT		varNameSpace;
				BSTR		strClassName,strObject;

				strObject = Wmioledb_SysAllocString(pTableID->uName.pwszName);
			
				VariantInit(&varNameSpace);

				// Get the namespace of the datasource
				m_pObj->GetDataSrcProperty(DBPROP_INIT_DATASOURCE,varNameSpace);

				hr = urlParser.SetURL(strObject);
				SAFE_FREE_SYSSTRING(strObject);
				if(SUCCEEDED(hr))
				{

	//				urlParser.SetNameSpace(varNameSpace.bstrVal);
					urlParser.GetClassName(strClassName);
					urlParser.GetPath(strObject);


					try
					{
						// Create a new row on the instance
						pRow = new CRow(pUnkOuter,m_pObj);
					}
					catch(...)
					{
						SAFE_DELETE_PTR(pRow);
						throw;
					}
					
					if(pRow == NULL)
					{
						hr = E_OUTOFMEMORY;
					}
					else
					{
						// call this function to initialize the row
						hr = pRow->InitRow(strObject,strClassName);
						if(hr == S_OK)
						{
							// QI for the required interface
							hr = pRow->QueryInterface(riid,(void **)ppRowset);
						}

					}
				}
				// Freeing the variables
				VariantClear(&varNameSpace);
				SysFreeString(strClassName);
				SysFreeString(strObject);
			
			} // end of creating row
        
		}  // if valid table name
    }

    if( FAILED(hr ) )
	{
        SAFE_DELETE_PTR( pRowset );
        SAFE_DELETE_PTR( pRow );
    }
	
	if(hr == S_OK && cErrors > 0)
	{
		hr = DB_S_ERRORSOCCURRED;
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IOpenRowset);

	CATCH_BLOCK_HRESULT(hr,L"IOpenRowset::OpenRowset");
	return hr;

}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get a DBPROP_IRow property 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CImpIOpenRowset::GetIRowProp(ULONG       cPropertySets,      // IN  count of properties
                                  DBPROPSET	rgPropertySets[])
{
	BOOL bRet = FALSE;


	for( ULONG lIndex = 0 ; lIndex < cPropertySets ; lIndex++)
	{
		if(rgPropertySets[lIndex].guidPropertySet == DBPROPSET_ROWSET)
		{
			for ( ULONG nPropIndex = 0 ; nPropIndex < rgPropertySets[lIndex].cProperties ; nPropIndex++ )
			{
				if(rgPropertySets[lIndex].rgProperties[nPropIndex].dwPropertyID == DBPROP_IRow &&
					rgPropertySets[lIndex].rgProperties[nPropIndex].vValue.boolVal == VARIANT_TRUE)
				{
						bRet = TRUE;
				} // if DBPROP_IRow is true;
			
			}// for loop
		
		} // if propertyset is DBPROPSET_ROWSET
	
	} // outer for loop
	
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\rowchng.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// IRowsetChange interface implementation
//
///////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"

///////////////////////////////////////////////////////////////////////////////////////////
//
// Sets new data values into fields of a row.
//
// HRESULT
//       S_OK                    The method succeeded
//       E_OUTOFMEMORY           Out of memory
//       DB_E_BADACCESSORHANDLE  Bad accessor handle
//       DB_E_READONLYACCESSOR   Tried to write through a read-only accessor
//       DB_E_BADROWHANDLE       Invalid row handle
//       E_INVALIDARG            pData was NULL
//       E_FAIL                  Provider-specific error
//       OTHER                   Other HRESULTs returned by called functions
//
///////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIRowsetChange::SetData ( HROW        hRow,       // IN  Handle of the row in which to set the data
                                          HACCESSOR   hAccessor,  // IN  Handle to the accessor to use
                                          void*		pData         // IN  Pointer to the data
    )
{
    BYTE*           pbProvRow;
    HRESULT         hr = S_OK;
    PACCESSOR       paccessor = NULL;
    DWORD           dwErrorCount = 0 , dwStatus = DBROWSTATUS_S_OK;
	VARIANT			varProp;
	BOOL			bNewRow		= FALSE;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	VariantInit(&varProp);

	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	hr = m_pObj->GetRowsetProperty(DBPROP_UPDATABILITY,varProp);
	
	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
	// If updation is allowed then
	if( !(hr == 0 && (DBPROPVAL_UP_CHANGE & varProp.lVal)))
	{
		hr = DB_E_NOTSUPPORTED;
	}
	else
	//===========================================================================
	// validate the arguments and get the accessor and row pointers
	//===========================================================================
	if( SUCCEEDED(hr = ValidateArguments(hRow,hAccessor,pData,(PROWBUFF *)&pbProvRow,&paccessor)))
	{
	
		//===========================================================================
		// If the number of bindings is zero then there is nothing to update
		//===========================================================================
		if( paccessor->cBindings == 0)
		{
			hr = S_OK;
		}
		else
		{
			//============================================================================
			// Is row handle deleted?
			//============================================================================

			dwStatus = m_pObj->GetRowStatus(hRow);
			if(dwStatus == DBROWSTATUS_E_NEWLYINSERTED)
			{
				bNewRow = TRUE;
			}
			else
			if( dwStatus != DBROWSTATUS_S_OK)
			{
				if(dwStatus == DBROWSTATUS_E_DELETED)
				{
					hr = DB_E_DELETEDROW;
				}
				else
				{
					hr = E_FAIL;
				}
			}
			
			if(SUCCEEDED(hr))
			{
				// Get data from accessor an put it into the row buffer
				hr = ApplyAccessorToData(paccessor->cBindings,paccessor->rgBindings,pbProvRow,pData,dwErrorCount);

				if( hr == NOCOLSCHANGED && dwErrorCount  > 0)
				{
					hr = DB_E_ERRORSOCCURRED;
					LogMessage("IRowsetChange::SetData:No columns has been modified");
				}
				else
				// If there is no change in any of the columns then 
				// there is no need to update
				if( !FAILED(hr))
				{
					//==================================================
					// update the data on the instance
					//==================================================
					if(SUCCEEDED(hr = m_pObj->UpdateRowData(hRow,paccessor,bNewRow)))
					{
						m_pObj->SetRowStatus(hRow,DBROWSTATUS_S_OK);
					}
				}
			}
		}
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetChange);

	CATCH_BLOCK_HRESULT(hr,L"IRowsetChange::SetData");
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//  Deletes rows from the provider.  If Errors on individual rows occur, the DBERRORINFO 
//  array is updated to reflect the error and S_FALSE is returned instead of S_OK.
//
//  HRESULT indicating the status of the method
//       S_OK                   All row handles deleted
//       DB_S_ERRORSOCCURRED    Some, but not all, row handles deleted
//       E_INVALIDARG           Arguments did not match spec.
//       E_OUTOFMEMORY          Could not allocated error array
//
///////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIRowsetChange::DeleteRows (HCHAPTER		hChapter,       // IN  The Chapter handle.
		                                    DBCOUNTITEM     cRows,			// IN  Number of rows to delete
		                                    const HROW      rghRows[],		// IN  Array of handles to delete
		                                    DBROWSTATUS		rgRowStatus[]	// OUT Error information
    )
{
    ULONG			ihRow			= 0L;
    ULONG			cErrors			= 0L;
    ULONG			cRowReleased	= 0L;
    BYTE*			pbProvRow		= NULL;
    HRESULT			hr				= S_OK;
	DBROWSTATUS *	pRowStatus		= NULL;
	VARIANT			varProp;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	VariantInit(&varProp);

	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	hr = m_pObj->GetRowsetProperty(DBPROP_UPDATABILITY,varProp);
	
	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
	// If updation is allowed then
	if( !(hr == 0 && (DBPROPVAL_UP_DELETE & varProp.lVal)))
	{
		hr = DB_E_NOTSUPPORTED;
	}
	else


    //=====================================================
    // If No Row handle, just return.
    //=====================================================
    if ( cRows > 0 )
	{

        //=================================================
        // Check for Invalid Arguments
        //=================================================
        if ( (cRows >= 1) && (NULL == rghRows) ){
			hr = E_INVALIDARG;
        }
		else
		{
			//=================================================
			// Process row handles
			//=================================================
			while (ihRow < cRows){

				pRowStatus = NULL;

				if ( rgRowStatus )
				{
					rgRowStatus[ihRow] = DBROWSTATUS_S_OK;
					pRowStatus		   = &rgRowStatus[ihRow];
				}

				//=============================================
				// Is row handle valid
				//=============================================
				if(FALSE == m_pObj->IsRowExists(rghRows[ihRow])){
					// Log Error
					if ( rgRowStatus ){
						rgRowStatus[ihRow]= DBROWSTATUS_E_INVALID;
					}
					cErrors++;
					ihRow++;
					continue;
				}
				

				//=======================================================
				// Delete the Row
				//=======================================================
				if( S_OK != (hr = m_pObj->DeleteRow(rghRows[ihRow],pRowStatus)))
					cErrors++;
			

				ihRow++;

			} //while
		}
        //=================================================
	    // If everything went OK except errors in rows use 
        // DB_S_ERRORSOCCURRED.
        //=================================================
	    hr = cErrors ? ( cErrors < cRows ) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED : S_OK ;
    }

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetChange);

	CATCH_BLOCK_HRESULT(hr,L"IRowsetChange::DeleteRows");
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//  Insert row into provider
//
//  Returns:   S_OK                    if data changed successfully
//             E_FAIL                  if Catch all (NULL pData, etc.)
//             E_INVALIDARG            if pcErrors!=NULL and paErrors==NULL
//             E_OUTOFMEMORY           if output error array couldn't be allocated
//             DB_E_BADACCESSORHANDLE  if invalid accessor
//
/////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP    CImpIRowsetChange::InsertRow  (HCHAPTER    hChapter,        // IN The Chapter handle.
		                                        HACCESSOR	hAccessor,
		                                        void*		pData,
		                                        HROW*		phRow )
{
   
    HRESULT         hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

    //====================================================
	// Initialize values
    //====================================================
    if ( phRow ){
		*phRow = NULL;
    }
    hr = E_FAIL;

    DBORDINAL		ibind			= 0;
    BYTE*           pbProvRow		= NULL;
    HROW			irow			= 0;
    DBCOUNTITEM     cBindings		= 0;
    DBBINDING*      pBinding		= NULL;
    DBCOUNTITEM     dwErrorCount	= 0;
    PACCESSOR       paccessor		= NULL;
	BOOL			fCanHoldRows	= FALSE;
	BSTR			strKey			= Wmioledb_SysAllocString(NULL);
	HROW			hRowNew			= 0;
	DBORDINAL		lQualifColIndex = -1;
	BOOL			bCleanUp		= FALSE;
	
	VARIANT			varProp;
	CVARIANT		cvarData;
	CDataMap		dataMap;
	VARIANT*		pvarData;

	CWbemClassWrapper *pNewInst = NULL;

	pvarData = &cvarData;

	VariantInit(&varProp);

	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	hr = m_pObj->GetRowsetProperty(DBPROP_UPDATABILITY,varProp);
	
	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
	// If updation is allowed then
	if( !(hr == 0 && (DBPROPVAL_UP_INSERT & varProp.lVal)))
	{
		hr = DB_E_NOTSUPPORTED;
	}
	else
    //====================================================
    // Check the Accessor Handle
    //====================================================
	if ( m_pObj->m_pIAccessor->GetAccessorPtr() == NULL ||  FAILED( m_pObj->m_pIAccessor->GetAccessorPtr()->GetItemOfExtBuffer( hAccessor, &paccessor)) ||
        paccessor == NULL )
	{
        hr = DB_E_BADACCESSORHANDLE;
    }        
    else
	{
        assert( paccessor );

        //====================================================
	    // Check to see if it is a row accessor
        //====================================================
        if ( !(paccessor->dwAccessorFlags & DBACCESSOR_ROWDATA) )
            hr = DB_E_BADACCESSORTYPE;

        // Ensure a source of data.
        if ( pData == NULL  && paccessor->cBindings )
		{
            hr =  E_INVALIDARG ;
		}
        else 
        {
			if (m_pObj->m_ulProps & CANHOLDROWS)
			{
				fCanHoldRows = TRUE;
			}

            // Are there any unreleased rows?
            if( ((m_pObj->m_pIAccessor->GetBitArrayPtr())->ArrayEmpty() != S_OK) && (!fCanHoldRows) )
			{
                hr = DB_E_ROWSNOTRELEASED;
			}
			else
			// Create the data members to manage the data only the first time
			if(!m_pObj->m_bHelperFunctionCreated)
			{
				if( SUCCEEDED(hr = m_pObj->CreateHelperFunctions()))
				{
					m_pObj->m_bHelperFunctionCreated = TRUE;
				}
			}

			if(SUCCEEDED(hr))
			{
				// Get new slots for the new row
				if (FAILED( hr = GetNextSlots( m_pObj->m_pIBuffer, 1, (HSLOT *)&irow )))
				{
					 ;
				}
				else
				// Bind the slot for the row
				if (FAILED( m_pObj->Rebind((BYTE *) m_pObj->GetRowBuffFromSlot( (HSLOT)irow, TRUE ))))
				{
					ReleaseSlots( m_pObj->m_pIBuffer, irow,1 );
				}
				else 
				{
					if(IsNullAccessor(paccessor,(BYTE *)pData))
					{
						if(SUCCEEDED(hr = InsertNewRow(irow,hChapter,pNewInst)))
						{
							m_pObj->SetRowStatus(irow,DBROWSTATUS_E_NEWLYINSERTED);
							if(phRow)
							{
								*phRow = irow;
							}
						}
						else
						{
							bCleanUp = TRUE;
						}
					}
					else
					{
						// Get the rowbuffer and set the new bookmark
						pbProvRow = (BYTE *) (m_pObj->GetRowBuffFromSlot((HSLOT)irow, TRUE ));

						cBindings = paccessor->cBindings;
						pBinding  = paccessor->rgBindings;

						// NULL Accessor (set Status to NULL)
						// Apply accessor to data.
						for (ibind = 0, dwErrorCount = 0; ibind < cBindings; ibind++)
						{

							// If the column is value then get the type of the col is given by the 
							// qualifier type column
							if(( m_pObj->m_uRsType == PROPERTYQUALIFIER || m_pObj->m_uRsType == CLASSQUALIFIER) &&
								pBinding[ibind].iOrdinal == QUALIFIERVALCOL  && ibind < cBindings-1)
							{
								lQualifColIndex = ibind;
								continue;
							}

							hr = UpdateDataToRowBuffer(ibind,pbProvRow,pBinding,(BYTE *)pData);
							if( hr == E_FAIL)
							{
								dwErrorCount++;
								continue;
							}
							
						}

						// if the recordset is of qualifer type then update the qualifier value
						if( m_pObj->m_uRsType == PROPERTYQUALIFIER || m_pObj->m_uRsType == CLASSQUALIFIER)
						{
							if((DB_LORDINAL)lQualifColIndex == -1)
							{
								dwErrorCount = cBindings;	// to escape the next if condition to throw error
								hr = E_FAIL;				// the value of the qualifer is not provided for adding 
															// a new qualifer
							}
							else
							{
								//update the qualifier value
								ibind = lQualifColIndex;
								hr = UpdateDataToRowBuffer(ibind,pbProvRow,pBinding,(BYTE *)pData);
								if( hr == E_FAIL)
								{
									dwErrorCount = cBindings;	// to escape the next if condition to throw error
								}
							}

						}
						// If all bindings are bad and not a NULL Accessor
						if ( ( !cBindings ) || ( dwErrorCount < cBindings ) )
						{
							if(SUCCEEDED(hr = InsertNewRow(irow,hChapter,pNewInst)))
							{
								m_pObj->SetRowStatus(irow,DBROWSTATUS_E_NEWLYINSERTED);

								//=======================================================
								// Update the row data  ie. put the property values
								// and save the instance
								//=======================================================
								hr = m_pObj->UpdateRowData(irow,paccessor, TRUE);

								if (SUCCEEDED(hr))
								{
									if(phRow)
									{
										*phRow = irow;
									}
									m_pObj->SetRowStatus(irow,DBSTATUS_S_OK);
									//=======================================================
									// If the rowset is bookmark enabled
									//=======================================================
									if(m_pObj->m_ulProps & BOOKMARKPROP)
									{
										//=======================================================
										// Add the bookmark to the bookmark hash table
										//=======================================================
										m_pObj->m_lLastFetchPos++;
										((PROWBUFF)pbProvRow)->dwBmk	= m_pObj->m_lLastFetchPos;
										((PROWBUFF)pbProvRow)->cbBmk	= BOOKMARKSIZE;
										m_pObj->m_pHashTblBkmark->InsertFindBmk(FALSE,irow,BOOKMARKSIZE,(BYTE *)&((PROWBUFF)pbProvRow)->dwBmk,&irow);
									}
								}
								else
								{
									bCleanUp = TRUE;
								}
							
							}  // if succeeded(hr) after inserting row and initializing chapters
							else
							{
								bCleanUp = TRUE;
							}

						}
					}	
				} // else if(FAILED(REbind())
			} // succeeded(hr) after CreateHelperFunctions
        }
            
    }
	if(!(FAILED(hr)))
	{
		//======================================================================
		// If everything went OK except errors in rows use DB_S_ERRORSOCCURRED.
		//======================================================================
		hr = dwErrorCount ? ( dwErrorCount < cBindings ) ? 
				DB_S_ERRORSOCCURRED  :  DB_E_ERRORSOCCURRED  : S_OK ;
	}

	//==============================================================
	// If any failure release the memory allocated for the row
	//==============================================================
	if( FAILED (hr) && bCleanUp)
	{
		//======================================================================
		// release the memory allocated for the different columns
		//======================================================================
		m_pObj->m_pRowData->ReleaseRowData();
		ReleaseSlots( m_pObj->m_pIBuffer, irow,1 );
		//======================================================================
		// release the rows from the instance manager and chapter manager
		//======================================================================
 		m_pObj->ReleaseInstancePointer(irow);
	}
	SysFreeString(strKey);

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetChange);

	CATCH_BLOCK_HRESULT(hr,L"IRowsetChange::InsertRow");
    return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////
HRESULT CImpIRowsetChange::ApplyAccessorToData( DBCOUNTITEM cBindings, DBBINDING* pBinding,BYTE* pbProvRow, void* pData,DWORD  & dwErrorCount )

{
    PCOLUMNDATA     pColumnData;
    DBORDINAL		icol, ibind;
    DBTYPE          dwSrcType;
    DBTYPE          dwDstType;
    DBLENGTH        dwSrcLength;
    DBLENGTH*       pdwDstLength;
    DBLENGTH        dwDstMaxLength;
    DBSTATUS        dwSrcStatus;
    DBSTATUS*       pdwDstStatus;
	DBSTATUS*		pdwSrcStatus;
    DWORD           dwPart;
    BYTE            b;
    void*           pDst;
    void*           pSrc;
	void*			pTemp;
	CDataMap		dataMap;
	CVARIANT		cvarData;
	VARIANT			*pvarData = &cvarData;
	CDataMap		map;
	ULONG			cColChanged = 0;
	BOOL			bUseDataConvert	= TRUE;
	LONG_PTR		lCIMType = 0;


    
    HRESULT hr = NOCOLSCHANGED;


    for (ibind = 0, dwErrorCount = 0; ibind < cBindings; ibind++)
	{
		bUseDataConvert	= TRUE;
        icol = pBinding[ibind].iOrdinal;
		
        pColumnData = (COLUMNDATA *) (pbProvRow + m_pObj->m_Columns.GetDataOffset(icol));

        dwSrcType      = pBinding[ibind].wType;
        dwDstType      = (DBTYPE)pColumnData->dwType; // m_pObj->m_Columns.ColumnType(icol);
		if(dwDstType == DBTYPE_EMPTY || dwDstType == DBTYPE_NULL)
		{
			dwDstType = m_pObj->m_Columns.ColumnType(icol);
		}
		
        dwSrcType      = pBinding[ibind].wType;
        pdwDstLength   = &(pColumnData->dwLength);
        pdwDstStatus   = &(pColumnData->dwStatus);
        dwDstMaxLength = pBinding[ibind].cbMaxLen;

        dwPart         = pBinding[ibind].dwPart;

        if ((dwPart & DBPART_VALUE) == 0){

            if (((dwPart & DBPART_STATUS)   && (*(ULONG *) ((BYTE*) pData + pBinding[ibind].obStatus) & DBSTATUS_S_ISNULL))
               || ((dwPart & DBPART_LENGTH) && *(ULONG *) ((BYTE*) pData + pBinding[ibind].obLength) == 0))	{

                pSrc = &b;
                b = 0x00;
			}
            else{
                hr = E_FAIL ;
                break;
            }
		}
        else{
            pSrc = (void *) ((BYTE*) pData + pBinding[ibind].obValue);
		}

        dwSrcLength = (dwPart & DBPART_LENGTH) ? *(ULONG *) ((BYTE*) pData + pBinding[ibind].obLength) : 0;
        dwSrcStatus = (dwPart & DBPART_STATUS) ? *(ULONG *) ((BYTE*) pData + pBinding[ibind].obStatus) : DBSTATUS_S_OK;
		pdwSrcStatus = (dwPart & DBPART_STATUS) ? (ULONG *) ((BYTE*) pData + pBinding[ibind].obStatus) : NULL;

		//==========================================================================
		// if the columnd is of type readonly then don't do anything
		//==========================================================================
		if((m_pObj->m_Columns.ColumnFlags(icol) & DBCOLUMNFLAGS_WRITE) == 0)
		{
			if(pdwSrcStatus != NULL)
				*pdwSrcStatus = DBSTATUS_E_READONLY;
			dwErrorCount++;
			continue;
		}

		hr = g_pIDataConvert->GetConversionSize(dwSrcType, dwDstType, &dwSrcLength, pdwDstLength, pSrc);

		try
		{
			pDst = new BYTE[*pdwDstLength];
		}
		catch(...)
		{
			SAFE_DELETE_ARRAY(pDst);
			throw;
		}

		// if both the source and destination type is array then don't
		// use IDataConvert::DataConvert for conversion
		if( (dwSrcType & DBTYPE_ARRAY) && (dwDstType & DBTYPE_ARRAY) )
		{
			bUseDataConvert = FALSE;
		}

		if( dwSrcType != VT_NULL && dwSrcType != VT_EMPTY && bUseDataConvert == TRUE && pSrc != NULL)
		{
			hr = g_pIDataConvert->DataConvert(  dwSrcType, dwDstType, dwSrcLength, pdwDstLength, pSrc,
												pDst, dwDstMaxLength,  dwSrcStatus,  pdwDstStatus,
												pBinding[ibind].bPrecision,	// bPrecision for conversion to DBNUMERIC
												pBinding[ibind].bScale,		// bScale for conversion to DBNUMERIC
												DBDATACONVERT_SETDATABEHAVIOR);

			if(hr == DB_E_UNSUPPORTEDCONVERSION && pdwDstStatus != NULL)
			{
				*pdwDstStatus = DBSTATUS_E_CANTCONVERTVALUE;
			}
		}
		else
		if(bUseDataConvert == FALSE && pSrc != NULL)
		{
			// Call this function to get the array in the destination address
			hr = map.ConvertAndCopyArray((SAFEARRAY *)pSrc,(SAFEARRAY **)pDst, dwSrcType,dwDstType,pdwDstStatus);
			
			if( *pdwDstStatus == DBSTATUS_E_CANTCONVERTVALUE)
			{
				*pdwDstLength = 0;
				dwErrorCount++;
			}

		}
		else
		{
			pDst = NULL;
			*pdwDstLength = 0;
			*pdwDstStatus = DBSTATUS_S_ISNULL;
		}

		if( SUCCEEDED(hr))
		{
			if(pDst != NULL && dwDstType == VT_BSTR)
			{
				pTemp = *(BSTR **)pDst;
			}
			else
			{
				pTemp = pDst;
			}
		}

		// If data is modified then
		if(hr == S_OK && (map.CompareData(dwDstType,pColumnData->pbData,pTemp) == FALSE)
			 && !( pColumnData->pbData == NULL && *pdwDstLength == 0))
		{
			// Release the previous data
			pColumnData->ReleaseColumnData();

			// If no data is there in the column ie. data i null then
			if(*pdwDstLength > 0)
			{
				// this variable gets value only if the CIMTYPE is array
				lCIMType = -1;
				// if the type is array , then get the original CIMTYPE as array type will
				// be given out as VT_ARRAY  | VT_VARIANT
				if(dwDstType & DBTYPE_ARRAY)
				{
					lCIMType = m_pObj->m_Columns.GetCIMType(icol);
				}

				if(dwDstType == VT_BSTR)
				{
					pTemp = *(BSTR **)pDst;
				}
				else
				{
					pTemp = pDst;
				}


				// Convert the new data to Variant , THis function returns the status if not
				// able to conver the data
				hr = dataMap.MapAndConvertOLEDBTypeToCIMType(dwDstType,pTemp,*pdwDstLength,*pvarData,lCIMType);
			}

			if( SUCCEEDED(hr))
			{
				// Set the data
				if( S_OK == (hr = pColumnData->SetData(cvarData,dwDstType)))
				{
					cColChanged++;
				}

				
				// Set the data to modified
				pColumnData->dwStatus |= COLUMNSTAT_MODIFIED;

				cvarData.Clear();

			}
			else
			{
				// Set the data to modified
				*pdwDstStatus |= hr;

			}

		}
		
		SAFE_DELETE_ARRAY(pDst);

        if (FAILED(hr)){
            dwErrorCount++; // rounding or truncation or can't coerce

        }
		hr = S_OK;
		
	}
	
	// If the number of errors is equal or greater than
	// the number of bindings and the error is only 
	// due to the readonly attribute of every column then
	// set the error
	if(cColChanged == 0)
	{
		hr = NOCOLSCHANGED;
	}
	else
	{
		hr = dwErrorCount ? DB_S_ERRORSOCCURRED : S_OK ;
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////
//	Function to validate the arguments
/////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIRowsetChange::ValidateArguments(	HROW        hRow,
													HACCESSOR   hAccessor,
													const void  *pData,
													PROWBUFF    *pprowbuff,
													PACCESSOR *ppkgaccessor)
{
	HRESULT hr = S_OK;
	// NTRaid:111831 - 111832
	// 06/07/00
	PROWBUFF pRowBuff = NULL ;
	PACCESSOR pAccessor = NULL;

	//========================================================
	// Check if the row exists
	//========================================================
	if(FALSE == m_pObj->IsRowExists(hRow))
	{
		hr = DB_E_BADROWHANDLE;
	}
	else
	{
		//============================================================================
		// Row is fetched  but data is not yet fetched??
		//============================================================================
		if ( m_pObj->IsSlotSet(hRow)  != S_OK )
		{
			hr = m_pObj->GetData(hRow);
			
			if(FAILED(hr))
			{
				hr = DB_E_BADROWHANDLE ;
			}
		}
		
		if (SUCCEEDED(hr) && m_pObj->m_pIAccessor->GetAccessorPtr() == NULL ||
			 FAILED( m_pObj->m_pIAccessor->GetAccessorPtr()->GetItemOfExtBuffer( hAccessor, &pAccessor)) ||
			 pAccessor == NULL ){

			//========================================================================
			// Check the Accessor Handle
			//========================================================================
			return DB_E_BADACCESSORHANDLE ;
		}

		if(SUCCEEDED(hr))
		{
			assert( pAccessor );

			//============================================================================
			// Check to see if it is a row accessor
			//============================================================================
			if ( !((pAccessor)->dwAccessorFlags & DBACCESSOR_ROWDATA) )
			{
				hr = DB_E_BADACCESSORTYPE;
			}
			else if ( pData == NULL){

				//============================================================================
				// Ensure a source of data.
				//============================================================================
				hr = E_INVALIDARG;
			}
			else
			{

				pRowBuff = m_pObj->GetRowBuff((ULONG) hRow, TRUE );
			}
		}

	}

	if(pprowbuff != NULL)
	{
		*pprowbuff = pRowBuff;
	}

	if(ppkgaccessor != NULL)
	{
		*ppkgaccessor = pAccessor;
	}

	return hr;
}




/////////////////////////////////////////////////////////////////////////////////////////////
//	Function with compares dat of a particular type and checks whether both are same or not
/////////////////////////////////////////////////////////////////////////////////////////////
BOOL CImpIRowsetChange::CompareData(DBTYPE dwType,void * pData1 , void *pData2)
{

	BOOL bRet = FALSE;
	long lType = VT_NULL;

	if(pData1 == NULL || pData2 == NULL)
	{
		if(pData1 == pData2)
		{
			bRet = TRUE;
		}
	}
	
	if(bRet == FALSE)
	{
		// If the type is of some array
		if (dwType & VT_ARRAY)
		{
			lType = VT_ARRAY;
		}
		else 
		{
			lType = dwType;
		}

		switch( lType ){

			case VT_NULL:
			case VT_EMPTY:
				bRet = TRUE;
				break;

			case CIM_FLAG_ARRAY:
				bRet = FALSE;
				break;

			case CIM_SINT8:
			case CIM_UINT8:
				if(!memcmp(pData1,pData2,1))
					bRet = TRUE;
				break; 

			case CIM_CHAR16:
			case CIM_SINT16:
			case CIM_UINT16:
			case CIM_BOOLEAN:
				if(!memcmp(pData1,pData2,2))
					bRet = TRUE;
				break; 

			case CIM_SINT32:
			case CIM_UINT32:
			case CIM_REAL32:
				if(!memcmp(pData1,pData2,4))
					bRet = TRUE;
				break; 

			case CIM_SINT64:
			case CIM_UINT64:
			case CIM_REAL64:
			case CIM_DATETIME:
				if(!memcmp(pData1,pData2,8))
					bRet = TRUE;
				
				break; 

			case CIM_STRING:
				

				if( pData1 != NULL && pData2 != NULL)
				{
					if(!_wcsicmp((WCHAR *)pData1,(WCHAR *)pData2))
						bRet = TRUE;
				}

				break;

			case CIM_REFERENCE:
				break;

			case CIM_OBJECT:
				break;

			
			case VT_VARIANT:
				break;

			default:
				assert( !"Unmatched OLEDB Data Type to CIMTYPE." );
		}
	}
    
	return bRet;
}


HRESULT CImpIRowsetChange::UpdateDataToRowBuffer(DBCOUNTITEM ibind,BYTE * pbProvRow,DBBINDING* pBinding,BYTE *pData)
{

    //====================================================
	// Initialize values
    //====================================================
    HRESULT         hr					= S_OK;
    DBORDINAL       icol				= 0;
    DBTYPE          dwSrcType			= 0;
    DBTYPE          dwDstType			= 0;
    void*           pSrc				= NULL;
    void*           pDst				= NULL;
	void*			pTemp				= NULL;
    DBLENGTH        dwSrcLength			= 0;
    DBLENGTH*       pdwDstLength		= 0;
    DBLENGTH        dwDstMaxLength		= 0;
    DWORD           dwSrcStatus			= 0;
    DWORD*          pdwDstStatus		= 0;
    DWORD           dwPart				= 0;
    PCOLUMNDATA     pColumnData			= NULL;
    BYTE            b					= 0;
	VARIANT*		pvarData			= NULL;
	BSTR			strPropName			= Wmioledb_SysAllocString(NULL);
	BOOL			bUseDataConvert		= TRUE;
	DWORD			dwCIMType			= 0;
	CVARIANT		cvarData;
	CDataMap		dataMap;

	pvarData = &cvarData;
    
	icol = pBinding[ibind].iOrdinal;
		
	pColumnData = (COLUMNDATA *) (pbProvRow + m_pObj->m_Columns.GetDataOffset(icol));

	dwSrcType      = pBinding[ibind].wType;
	pDst           = &(pColumnData->pbData);
	pdwDstLength   = &(pColumnData->dwLength);
	pdwDstStatus   = &(pColumnData->dwStatus);
	dwDstMaxLength = pBinding[ibind].cbMaxLen;

	dwPart         = pBinding[ibind].dwPart;

	// If the column is value then get the type of the col is given by the 
	// qualifier type column
	if(( m_pObj->m_uRsType == PROPERTYQUALIFIER || m_pObj->m_uRsType == CLASSQUALIFIER) &&
		pBinding[ibind].iOrdinal == QUALIFIERVALCOL )
	{
		dwDstType			= *(DBTYPE *)((COLUMNDATA *) (pbProvRow + m_pObj->m_Columns.GetDataOffset(QUALIFIERTYPECOL)))->pbData;
		pColumnData->dwType	= VT_VARIANT;
	}
	else
	{
		dwDstType				= m_pObj->m_Columns.ColumnType(icol);
		pColumnData->dwType		= dwDstType;
	}


	if ((dwPart & DBPART_VALUE) == 0)
	{
		if (((dwPart & DBPART_STATUS)
			&& (*(ULONG *) ((BYTE*) pData + pBinding[ibind].obStatus) & DBSTATUS_S_ISNULL))
		   || ((dwPart & DBPART_LENGTH) && *(ULONG *) ((BYTE*) pData + pBinding[ibind].obLength) == 0))
		{
			pSrc = &b;
			b = 0x00;
		}
		else
		{	
			if ( dwPart & DBPART_STATUS )
			{
				*(DBSTATUS *) ((BYTE*) pData + pBinding[ibind].obStatus) = DBSTATUS_E_UNAVAILABLE;
			}
				hr = E_FAIL;
		}
	}
	else
	{
		pSrc = (void *) ((BYTE*) pData + pBinding[ibind].obValue);
	}

	if(SUCCEEDED(hr))
	{
		dwSrcLength = (dwPart & DBPART_LENGTH) ? *(ULONG *) ((BYTE*) pData + pBinding[ibind].obLength) : 0;

		dwSrcStatus = (dwPart & DBPART_STATUS) ? *(ULONG *) ((BYTE*) pData + pBinding[ibind].obStatus) : DBSTATUS_S_OK;

		if(!( dwSrcType == DBTYPE_HCHAPTER || dwDstType == DBTYPE_HCHAPTER))
		{
			strPropName = Wmioledb_SysAllocString(m_pObj->m_Columns.ColumnName(icol));
			//==========================================================================
			// if the columnd is a system property then set it to readonly
			//==========================================================================
			if(TRUE == m_pObj->m_pMap->IsSystemProperty(strPropName))
			{
				SysFreeString(strPropName);
				pColumnData->dwStatus = DBSTATUS_E_READONLY;
				hr = E_FAIL;
			}
			else
			{
				SysFreeString(strPropName);

				// Get the conversion size for the column
				if(SUCCEEDED(hr = g_pIDataConvert->GetConversionSize(dwSrcType, dwDstType, &dwSrcLength, pdwDstLength, pSrc)))
				{
					hr = E_OUTOFMEMORY;
					try
					{
						pDst = new BYTE[*pdwDstLength];
					}
					catch(...)
					{
						SAFE_DELETE_ARRAY(pDst);
						throw;
					}
					
					if(pDst)
					{
						hr = S_OK;
						// if both the source and destination type is array then don't
						// use IDataConvert::DataConvert for conversion
						if( (dwSrcType & DBTYPE_ARRAY) && (dwDstType & DBTYPE_ARRAY) )
						{
							bUseDataConvert = FALSE;
						}

						if( dwSrcType != VT_NULL && dwSrcType != VT_EMPTY && bUseDataConvert == TRUE && pSrc != NULL)
						{
							// Convert the data to the type which can be update to WBEM
							hr = g_pIDataConvert->DataConvert(  dwSrcType, dwDstType, dwSrcLength, pdwDstLength, pSrc,
																pDst, dwDstMaxLength,  dwSrcStatus,  pdwDstStatus,
																pBinding[ibind].bPrecision,	// bPrecision for conversion to DBNUMERIC
																pBinding[ibind].bScale,		// bScale for conversion to DBNUMERIC
																DBDATACONVERT_SETDATABEHAVIOR);

							if(hr == DB_E_UNSUPPORTEDCONVERSION && pdwDstStatus != NULL)
							{
								*pdwDstStatus = DBSTATUS_E_CANTCONVERTVALUE;
							}
						}
						else
						if(bUseDataConvert == FALSE && pSrc != NULL)
						{
							// Call this function to get the array in the destination address
							hr = dataMap.ConvertAndCopyArray((SAFEARRAY *)pSrc,(SAFEARRAY **)pDst, dwSrcType,dwDstType,pdwDstStatus);				
							if( *pdwDstStatus == DBSTATUS_E_CANTCONVERTVALUE || FAILED(hr))
							{
								*pdwDstLength = 0;
								hr = E_FAIL;
							}
						}
						else
						{
							pDst = NULL;
							*pdwDstLength = 0;
							*pdwDstStatus  = DBSTATUS_S_ISNULL;
						}

						if (SUCCEEDED(hr))
						{
							if(pDst != NULL && pColumnData->dwType == VT_BSTR)
							{
								pTemp = *(BSTR **)pDst;
							}
							else
							{
								pTemp = pDst;
							}

							// If no data is there in the column ie. data i null then
							if(*pdwDstLength > 0)
							{

								// this variable gets value only if the CIMTYPE is array
								dwCIMType = -1;
								// if the type is array , then get the original CIMTYPE as array type will
								// be given out as VT_ARRAY  | VT_VARIANT
								if(pColumnData->dwType & DBTYPE_ARRAY)
								{
									dwCIMType = m_pObj->m_Columns.GetCIMType(icol);
								}

								if(pColumnData->dwType == VT_BSTR)
								{
									pTemp = *(BSTR **)pDst;
								}
								else
								{
									pTemp = pDst;
								}
								// Convert the new data to Variant, this function return DBSTATUS if 
								// not able to convert
								hr = dataMap.MapAndConvertOLEDBTypeToCIMType(dwDstType,pTemp,*pdwDstLength,*pvarData,dwCIMType);
							}

							if(SUCCEEDED(hr))
							{
								// Set the data
								hr = pColumnData->SetData(cvarData,pColumnData->dwType);
							}
							else
							{
								pColumnData->dwStatus |= hr;
							}

							if (SUCCEEDED(hr))
							{
								// Set the data to modified
								pColumnData->dwStatus |= COLUMNSTAT_MODIFIED;
							}

							cvarData.Clear();
						
						} 
					}  // if (pDst)
				}	// IF succeeded(getting conversion size)					
			}	// if valid property name
		}	// if the column in not a chapter
	}

	SAFE_DELETE_ARRAY(pDst);

	return hr;
}

BOOL CImpIRowsetChange::IsNullAccessor(PACCESSOR phAccessor,BYTE * pData )
{
	BOOL	bNullAccessor	= TRUE;
	DWORD	dwPart			= 0;
	DWORD	dwStatatus		= 0;

	if(phAccessor->cBindings)
	{
		for(DBORDINAL cBinding = 0 ; cBinding < phAccessor->cBindings ; cBinding++)
		{
			dwPart = phAccessor->rgBindings[cBinding].dwPart;
			dwStatatus = (dwPart & DBPART_STATUS) ? *(ULONG *) ((BYTE*) pData + phAccessor->rgBindings[cBinding].obStatus) : DBSTATUS_S_OK;
			if(dwStatatus != DBSTATUS_S_IGNORE)
			{
				bNullAccessor = FALSE;
				break;
			}
		}
	}
	return bNullAccessor;
}

HRESULT CImpIRowsetChange::InsertNewRow(HROW hRow,	HCHAPTER    hChapter,CWbemClassWrapper *& pNewInst)
{
	HRESULT hr = S_OK;
	BSTR strKey = NULL;

	//==========================
	// Carry out the insert.
	// Set the RowHandle
	//==========================
	if(SUCCEEDED(hr = m_pObj->InsertNewRow(&pNewInst)))
	{
		//===========================================================================
		// if there is atleast one row retrieved and there are neseted columns
		// then allocate rows for the child recordsets
		//===========================================================================
		if(m_pObj->m_cNestedCols > 0 )

		{
			if(m_pObj->m_ppChildRowsets == NULL)
				m_pObj->AllocateAndInitializeChildRowsets();

			//=====================================================================
			// Fill the HCHAPTERS for the column
			//=====================================================================
			hr = m_pObj->FillHChaptersForRow(pNewInst,strKey);
		}

		
		if(SUCCEEDED(hr))
		{
			//===================================================
			// if the class is not representing qualilfiers
			//===================================================
			if(m_pObj->m_bIsChildRs == FALSE)
			{
				//=================================================
				// add instance pointer to instance manager
				//=================================================
				hr = m_pObj->m_InstMgr->AddInstanceToList(hRow,pNewInst,strKey,hRow);
			}
			//=================================================================================
			// if rowset is refering to qualifiers then add the row to the particular chapter
			//=================================================================================
			else 
			{
				// add instance pointer to instance manager
				hr = m_pObj->m_pChapterMgr->AddHRowForChapter(hChapter,hRow, NULL ,hRow);
			}
		}
	
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\resource.h ===
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider 
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//	resource.h - File containing the string ID defination
/////////////////////////////////////////////////////////////////////////////////////////////////////////

#define IDS_DBKEYWORDS                  0xF100

#define IDS_DS_DEREFALIAS				0xF102
#define IDS_DS_SIZELIMIT				0xF103
#define IDS_DS_PAGEDTIMELIMIT			0xF104
#define IDS_DS_ASYNC					0xF105
#define IDS_DS_SEARCHSCOPE				0xF106
#define IDS_DS_TIMEOUT					0xF107
#define IDS_DS_PAGESIZE					0xF108
#define IDS_DS_TIMELIMIT				0xF109
#define IDS_DS_CHASEREF					0xF10A
#define IDS_DS_ATTRIBONLY				0xF10B
#define IDS_DS_CACHERESULTS				0xF10C
#define IDS_DS_TOMBSTONE				0xF10D
#define IDS_DS_FILTER					0xF10E
#define	IDS_DS_ATTRIBUTES				0xF10F		
#define IDS_WMIOLEDBDES                 0xF110 


#define IDS_STRFORMAT					0xF111
#define IDS_PROGID						0xF112 
#define IDS_DESCRIPTION                 0xF113 
#define IDS_PROGCLSID					0xF114
#define IDS_CLSID						0xF115 
#define IDS_CLSIDKEY					0xF116 
#define IDS_PROGIDKEY					0xF117 
#define IDS_VIPROGIDKEY                 0xF118 
#define IDS_OLEDBSER					0xF119 
#define IDS_INPROCSER					0xF11A 
#define IDS_OLEDBPROVKEY                0xF11B 
#define IDS_BOTHTHREADMODEL             0xF11C 
#define IDS_THREADMODEL                 0xF11D 
#define IDS_EXTERROR					0xF11E 

#define IDS_EXTERRORCLSIDKEY            0xF11F 

#define IDS_EXTERRDESC					0xF120 
#define IDS_ERRLOOKUPDESC               0xF121 


#define IDS_EL_PROGID					0xF122 
#define IDS_EL_PROGCLSID                0xF123 
#define IDS_EL_CLSID					0xF124 
#define IDS_EL_CLSIDKEY                 0xF125 
#define IDS_EL_CLSPROGID                0xF126 
#define IDS_EL_CLSVIPROGID              0xF127 
#define IDS_EL_INPROCSERKEY             0xF128 

#define IDS_RB_DESC						0xF129 
#define IDS_RB_PROGID					0xF12A 
#define IDS_RB_PROGCLSID                0xF12B 
#define IDS_RB_CLSID					0xF12C
#define IDS_RB_CLSIDKEY                 0xF12D 
#define IDS_RB_CLSPROGID                0xF12E 
#define IDS_RB_CLSVIPROGID              0xF12F 
#define IDS_RB_INPROCSERKEY             0xF130 
#define IDS_RB_ROOTBINDER               0xF131 

#define IDS_EN_DESC						0xF132 
#define IDS_EN_PROGID					0xF133 
#define IDS_EN_PROGCLSID                0xF134 
#define IDS_EN_CLSID					0xF135 
#define IDS_EN_CLSIDKEY	                0xF136 
#define IDS_EN_CLSPROGID                0xF137 
#define IDS_EN_CLSVIPROGID              0xF138 
#define IDS_EN_INPROCSERKEY             0xF139 
#define IDS_EN_ENUMERATOR	            0xF13A 

#define IDS_WMIOLEDBDLLNAME				0xF13B
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\row.h ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// @module ROW.H | CRow base object and contained interface
// 
//
///////////////////////////////////////////////////////////////////////////////////

#ifndef _ROW_H_
#define _ROW_H_



typedef enum tagROWCREATEBINDFLAG
{
	ROWOPEN =0,ROWCREATE =1 , ROWOVERWRITE = 1

}ROWCREATEBINDFLAG;

typedef enum tagROWTYPE
{
	ROW_SCOPE =0,ROW_INSTANCE =1

}ROWTYPE;


#include "baserowobj.h"
class CImpIRowChange;
class CImpIColumnsInfo;
class CImpIGetSession;
class CImpIRow;
class CImpIScopedOperations;

//class CRowFetchObj;


typedef CImpIRowChange*			PIMPIROWCHANGE;
typedef CImpIRow*				PIMPIROW;
typedef CImpIGetSession*		PIMPIGETSESSION;
typedef CImpIScopedOperations*	PIMPISCOPEDOPERATIONS;

typedef CRowFetchObj*		PROWFETCHOBJ;


class CRow : public CBaseRowObj
{
	friend class CImpIRowChange;
	friend class CImpIRow;
	friend class CImpIGetSession;
	friend class CImpIScopedOperations;

	friend class CRowFetchObj;
	friend class CDBSession;

	PIMPIROW						m_pIRow;						// Contained IRow
	PIMPIGETSESSION					m_pIGetSession;					// Contained IGetSession
	PIMPIROWCHANGE					m_pIRowChange;					// Contained IRowChange;
	PIMPISCOPEDOPERATIONS			m_pIScopedOperations;			// Contained IScopedOperations


	UDWORD          				m_dwStatus;                     // status word for the entire cursor
	cRowColumnInfoMemMgr *			m_pRowColumns;						// column information for all the columns other than
																	// than the source rowset

	WCHAR *							m_strURL;						// URL of the row
	WCHAR *							m_strKey;						// Key of the row
	CWbemClassInstanceWrapper *		m_pInstance;						// Pointer to the instance corresponding to the row


	BOOL							m_bHelperFunctionCreated;		// flag to indicate whethe helper function are created or not
	BOOL							m_bClassChanged;				// flag which stores if the instance being represented, is
																	// is of different type ( belong to different class) as
																	// compared to the rowset which created it. This will 
																	// have meaning only when row is created from rowset

	CRowset	*						m_pSourcesRowset;				// Pointer to the rowset , if it this row is created by the row
	ROWTYPE							m_rowType;						// type of the object which the row represents							
	
	void	InitVars();
	HRESULT GetColumns(DBORDINAL cColumns,DBCOLUMNACCESS   rgColumns[ ]);
	HRESULT GetColumnsFromRowset(DBORDINAL cColumns,DBCOLUMNACCESS   rgColumns[]);
	HRESULT UpdateRow(DBORDINAL cColumns,DBCOLUMNACCESS rgColumns[ ]);
	HRESULT UpdateColumnsFromRowset(DBORDINAL cColumns,DBCOLUMNACCESS rgColumns[ ]);

	HRESULT GetColumnInfo(DBORDINAL* pcColumns, DBCOLUMNINFO** prgInfo,WCHAR** ppStringsBuffer);
	HRESULT GetRowColumnInfo();
	HRESULT GatherColumnInfo();
	HRESULT GetColumnInfo();
	HRESULT GetColumnData(DBCOLUMNACCESS &col);
	HRESULT SetColumnData(DBCOLUMNACCESS &col , BOOL bNewRow = FALSE);


	HRESULT GetRowData(DBORDINAL cColumns,DBCOLUMNACCESS   rgColumns[]);
	HRESULT SetRowData(DBORDINAL cColumns,DBCOLUMNACCESS   rgColumns[]);

	HRESULT OpenChild(IUnknown *pUnkOuter,WCHAR *strColName ,REFIID riid, IUnknown **ppUnk,BOOL bIsChildRowset);
	WCHAR * GetPropertyNameFromColName(WCHAR *pColName);
	HRESULT GetEmbededInstancePtrAndSetMapClass(CURLParser *urlParser);

	HRESULT GetChildRowet(	IUnknown *pUnkOuter,
						WCHAR *strColName,
						DBPROPSET *rgPropertySets,
						ULONG cPropSets,
						REFIID riid, 
						IUnknown **ppUnk);
	
	HRESULT GetChildRow(IUnknown *pUnkOuter,
						WCHAR *strColName,
						DBPROPSET *rgPropertySets,
						ULONG cPropSets,
						REFIID riid, 
						IUnknown **ppUnk);

	HRESULT CreateNewRow(CWbemClassInstanceWrapper **pNewInst);
	HRESULT AllocateInterfacePointers();
	HRESULT InitializeWmiOledbMap(LPWSTR strPath, 
								LPWSTR strTableID , 
								DWORD dwFlags);
	HRESULT	AddInterfacesForISupportErrorInfo();
	
	HRESULT OpenRow(LPCOLESTR pwszURL,IUnknown * pUnkOuter,REFIID riid,IUnknown** ppOut);
	HRESULT OpenRowset(LPCOLESTR pwszURL,
						IUnknown * pUnkOuter,
						REFIID riid,
						BOOL bContainer , 
						IUnknown** ppOut,
						ULONG cPropertySets = 0,
						DBPROPSET __RPC_FAR rgPropertySets[] = NULL);

	
	HRESULT SetRowProperties(const ULONG cPropertySets, const DBPROPSET	rgPropertySets[] );
	HRESULT Delete(LPCOLESTR lpszURL,DWORD dwDeleteFlags,DBSTATUS &dbStatus);
	HRESULT MoveObjects(WCHAR * pStrDstURL,WCHAR * pstrSrcURL, WCHAR *& pstrUrl,DBSTATUS &dbStatus);
	HRESULT CopyObjects(WCHAR * pStrDstURL,WCHAR * pstrSrcURL, WCHAR *& pNewURL,DBSTATUS &dbStatus);
	BOOL	GetPathFromURL(BSTR &str);
	BOOL	IsContainer();
	HRESULT GetIUnknownColumnValue(DBORDINAL iCol,REFIID riid,IUnknown ** ppUnk,LPCWSTR pStrColName);


	public:

		CRow(LPUNKNOWN,CRowset *pRowset,PCDBSESSION pObj,CWbemConnectionWrapper *pCon = NULL);
		CRow(LPUNKNOWN pUnkOuter, PCDBSESSION pObj);
		~CRow();

		HRESULT InitRow(HROW hRow = 0, 
					  CWbemClassWrapper *pInst = NULL,
					  ROWCREATEBINDFLAG rowCreateFlag = ROWOPEN);

		HRESULT InitRow(LPWSTR strPath , 
					  LPWSTR strTableID , 
					  DWORD dwFlags = -1,
					  ROWCREATEBINDFLAG rowCreateFlag = ROWOPEN);

		HRESULT UpdateKeysForNewInstance();

		STDMETHODIMP			QueryInterface(REFIID, LPVOID *);
		STDMETHODIMP_(ULONG)	AddRef(void);
		STDMETHODIMP_(ULONG)	Release(void);

};



class CImpIGetSession:public IGetSession
{
private:
		CRow		*m_pObj;											
		DEBUGCODE(ULONG m_cRef);

	public: 
		CImpIGetSession( CRow *pObj )				
		{																
			DEBUGCODE(m_cRef = 0L);										
			m_pObj		= pObj;											
		}																
		~CImpIGetSession()													
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		STDMETHODIMP GetSession(REFIID riid,IUnknown ** ppSession);


};


class CImpIRow:public IRow
{
private:
		CRow		*m_pObj;											
		DEBUGCODE(ULONG m_cRef);


	public: 
		CImpIRow( CRow *pObj )				
		{																
			DEBUGCODE(m_cRef = 0L);										
			m_pObj		= pObj;											
		}																
		~CImpIRow()													
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		STDMETHODIMP GetColumns(DBORDINAL cColumns,DBCOLUMNACCESS   rgColumns[ ]);

		STDMETHODIMP GetSourceRowset(REFIID riid,IUnknown ** ppRowset,HROW *phRow);
		STDMETHODIMP Open(  IUnknown *    pUnkOuter,
					   DBID *        pColumnID,
					   REFGUID       rguidColumnType,
					   DWORD         dwFlags,
					   REFIID        riid,
					   IUnknown **   ppUnk);


};



class CImpIRowChange:public IRowChange
{
private:
		CRow		*m_pObj;											
		DEBUGCODE(ULONG m_cRef);

	public: 
		CImpIRowChange( CRow *pObj )				
		{																
			DEBUGCODE(m_cRef = 0L);										
			m_pObj		= pObj;											
		}																
		~CImpIRowChange()													
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		STDMETHODIMP SetColumns(DBORDINAL cColumns,DBCOLUMNACCESS rgColumns[ ]);




};

class CImpIScopedOperations:public IScopedOperations
{
private:
		CRow		*m_pObj;											
		DEBUGCODE(ULONG m_cRef);

		BOOL	CheckBindURLFlags(DBBINDURLFLAG dwBindURLFlags , REFGUID rguid);	// Function to check if proper flags are
																				// are set for the require object
		// To check if URL Matches the requested type of object
		HRESULT	CheckIfProperURL(LPOLESTR & lpszURL,REFGUID rguid);

		HRESULT BindURL(IUnknown *            pUnkOuter,
					 LPCOLESTR             pwszURL,
					 DBBINDURLFLAG         dwBindURLFlags,
					 REFGUID               rguid,
					 REFIID                riid,
					 DBIMPLICITSESSION *   pImplSession,
					 DBBINDURLSTATUS *     pdwBindStatus,
					 IUnknown **           ppUnk);

		// Copy or move objects from one scope/container to another
		HRESULT ManipulateObjects(DBCOUNTITEM cRows,
									LPCOLESTR __RPC_FAR rgpwszSourceURLs[  ],
									LPCOLESTR __RPC_FAR rgpwszDestURLs[  ],
									DBSTATUS __RPC_FAR rgdwStatus[  ],
									LPOLESTR __RPC_FAR rgpwszNewURLs[  ],
									OLECHAR __RPC_FAR *__RPC_FAR *ppStringsBuffer,
									BOOL bMoveObjects);


	public: 
		CImpIScopedOperations( CRow *pObj )				
		{																
			DEBUGCODE(m_cRef = 0L);										
			m_pObj		= pObj;											
		}																
		~CImpIScopedOperations()													
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}


		STDMETHODIMP Bind(IUnknown *			 pUnkOuter,
						   LPCOLESTR             pwszURL,
						   DBBINDURLFLAG         dwBindURLFlags,
						   REFGUID               rguid,
						   REFIID                riid,
						   IAuthenticate *       pAuthenticate,
						   DBIMPLICITSESSION *   pImplSession,
						   DBBINDURLSTATUS *     pdwBindStatus,
						   IUnknown **           ppUnk);





        STDMETHODIMP Copy(DBCOUNTITEM cRows,
							LPCOLESTR __RPC_FAR rgpwszSourceURLs[  ],
							LPCOLESTR __RPC_FAR rgpwszDestURLs[  ],
							DWORD dwCopyFlags,
							IAuthenticate __RPC_FAR *pAuthenticate,
							DBSTATUS __RPC_FAR rgdwStatus[  ],
							LPOLESTR __RPC_FAR rgpwszNewURLs[  ],
							OLECHAR __RPC_FAR *__RPC_FAR *ppStringsBuffer);
        
        STDMETHODIMP Move(DBCOUNTITEM cRows,
							LPCOLESTR __RPC_FAR rgpwszSourceURLs[  ],
							LPCOLESTR __RPC_FAR rgpwszDestURLs[  ],
							DWORD dwMoveFlags,
							IAuthenticate __RPC_FAR *pAuthenticate,
							DBSTATUS __RPC_FAR rgdwStatus[  ],
							LPOLESTR __RPC_FAR rgpwszNewURLs[  ],
							OLECHAR __RPC_FAR *__RPC_FAR *ppStringsBuffer);
        
        STDMETHODIMP Delete(DBCOUNTITEM cRows,
							LPCOLESTR __RPC_FAR rgpwszURLs[  ],
							DWORD dwDeleteFlags,
							DBSTATUS __RPC_FAR rgdwStatus[  ]);
        
        STDMETHODIMP OpenRowset(IUnknown __RPC_FAR *pUnkOuter,
								DBID __RPC_FAR *pTableID,
								DBID __RPC_FAR *pIndexID,
								REFIID riid,
								ULONG cPropertySets,
								DBPROPSET __RPC_FAR rgPropertySets[  ],
								IUnknown __RPC_FAR *__RPC_FAR *ppRowset);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\row.cpp ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CRow object implementation
//
//
///////////////////////////////////////////////////////////////////////////////////
#include "headers.h"
#include "WmiOleDBMap.h"

#define PATHSEPARATOR L"/"
/////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor for this class
/////////////////////////////////////////////////////////////////////////////////////////////////
CRow::CRow(LPUNKNOWN pUnkOuter,CRowset *pRowset,PCDBSESSION pObj,CWbemConnectionWrapper *pCon ) : CBaseRowObj(pUnkOuter)
{
	InitVars();

	m_pMap				= pRowset->GetWmiOleDBMap();
	m_pMap->AddRef();

	m_pUtilProp = pRowset->m_pUtilProp;

	m_pCreator			= pObj;
	m_pSourcesRowset	= pRowset;
	m_pSourcesRowset->AddRef();
	m_pCreator->GetOuterUnknown()->AddRef();

	//===============================================
	// Add this rowset ot list of open rowset
	//===============================================
	m_pCreator->AddRowset(this);

	pRowset->QueryInterface(IID_IConvertType, (void **)&m_pIConvertType);
	m_pCon	= pCon;

	InterlockedIncrement(&g_cObj);
	
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor for this class. This is called from the root binder object
/////////////////////////////////////////////////////////////////////////////////////////////////
CRow::CRow(LPUNKNOWN pUnkOuter, PCDBSESSION pObj ) : CBaseRowObj(pUnkOuter)
{
	InitVars();

	m_pCreator			= pObj;
	m_pSourcesRowset	= NULL;
	m_pCreator->GetOuterUnknown()->AddRef();
	//===============================================
	// Add this rowset ot list of open rowset
	//===============================================
	m_pCreator->AddRowset(this);

	InterlockedIncrement(&g_cObj);
}

void CRow::InitVars()
{
		m_pMap				= NULL;

		m_pUtilProp			= NULL;

		m_pCreator			= NULL;
		m_pSourcesRowset	= NULL;

		m_pRowData			= NULL;				
		m_pIBuffer			= NULL;

		m_strURL			= NULL;
		m_strKey			= NULL;

		m_rgbRowData		= NULL;
		m_pRowColumns		= NULL;

		m_pInstance			= NULL;

		m_pIColumnsInfo			= NULL;
		m_pIRow					= NULL;
		m_pIConvertType			= NULL;
		m_pIGetSession			= NULL;
		m_pIRowChange			= NULL;
		m_pIScopedOperations	= NULL;

		m_cTotalCols		= 0;
		m_cCols				= 0;
		m_cNestedCols		= 0;
		m_cRef				= 0;
		m_cbRowSize			= 0;

		m_ulProps			= 0;
		m_hRow				= 0;
		m_dwStatus			= 0;

		m_bHelperFunctionCreated	= FALSE;
		m_bClassChanged				= FALSE;

		m_rowType					= ROW_INSTANCE;


}


/////////////////////////////////////////////////////////////////////////////////////////////////
// Destructor for this class
/////////////////////////////////////////////////////////////////////////////////////////////////
CRow::~CRow()
{

    if (NULL != m_pIBuffer){
        ReleaseSlotList( m_pIBuffer );
	}

    //===============================================================
    //  NOTE:  m_pMap releases the class ptr in destructor and if
	//			the reference count goes to 0 then this will released
    //===============================================================
	m_pMap->Release();

	// If the row object is created from a rowset object then release all the interfaces
	if(m_pSourcesRowset != NULL)
	{
		m_pIConvertType->Release();
		m_pSourcesRowset->Release();
		SAFE_DELETE_PTR(m_pRowColumns);
	}
	else
	{
	    SAFE_DELETE_PTR( m_pIConvertType );
	    SAFE_DELETE_PTR( m_pUtilProp );
	}

	//===============================================================
    //  Free contained interfaces
	//===============================================================
    SAFE_DELETE_PTR( m_pIColumnsInfo );
    SAFE_DELETE_PTR( m_pIRow );
    SAFE_DELETE_PTR( m_pIGetSession );
    SAFE_DELETE_PTR( m_pIRowChange );
    SAFE_DELETE_PTR(m_pRowData);
	SAFE_DELETE_PTR(m_pIScopedOperations);
    SAFE_DELETE_PTR(m_pISupportErrorInfo);
	
/*
	if(m_pSourcesRowset == NULL)
	{
		SAFE_DELETE_PTR(m_pInstance);
	}
*/
	//===============================================================
	// Decrement the DBSession Count.  GetSpecification is not
    // possible anymore
	//===============================================================
    if( m_pCreator ){

    	//===========================================================
    	// Mark the session as not having an open rowset anymore
	    //===========================================================
		m_pCreator->GetOuterUnknown()->Release();
	}

	SAFE_DELETE_ARRAY(m_strKey);
	SAFE_DELETE_ARRAY(m_strURL);
	//===============================================================
    // Decrement global object count.
	//===============================================================
    InterlockedDecrement(&g_cObj);
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns a pointer to a specified interface. Callers use QueryInterface to determine which
// interfaces the called object supports.
//
// HRESULT indicating the status of the method
//      S_OK            Interface is supported and ppvObject is set.
//      E_NOINTERFACE   Interface is not supported by the object
//      E_INVALIDARG    One or more arguments are invalid.
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CRow::QueryInterface ( REFIID riid, LPVOID * ppv  )
{
    HRESULT hr = S_OK;


    //======================================================
    //  Check parameters, if not valid return
    //======================================================
    if (NULL == ppv)
	{
        hr = E_INVALIDARG ;
    }
	else
	{
		//======================================================
		//  Place NULL in *ppv in case of failure
		//======================================================
		*ppv = NULL;

		//======================================================
		//  This is the non-delegating IUnknown implementation
		//======================================================
		if (riid == IID_IUnknown)
		{
			*ppv = (LPVOID) this;
		}
		else if (riid == IID_IColumnsInfo)
		{
			*ppv = (LPVOID) m_pIColumnsInfo;
		}
		else if (riid == IID_IConvertType)
		{
			*ppv = (LPVOID) m_pIConvertType;
		}
		else if (riid == IID_IRow)
		{
			*ppv = (LPVOID) m_pIRow;
		}
		else if (riid == IID_IGetSession)
		{
			*ppv = (LPVOID) m_pIGetSession;
		}
		else if (riid == IID_IRowChange)
		{
			*ppv = (LPVOID) m_pIRowChange;
		}
		else if( riid == IID_ISupportErrorInfo)
		{
			*ppv = (LPVOID)m_pISupportErrorInfo;
		}
		else if(riid == IID_IScopedOperations || riid == IID_IBindResource)
		{
			*ppv = (LPVOID)m_pIScopedOperations;
		}

		//======================================================
		//  If we're going to return an interface, AddRef first
		//======================================================
		if (*ppv){
			((LPUNKNOWN) *ppv)->AddRef();
			hr = S_OK ;
		}
		else{
			hr =  E_NOINTERFACE;
		}
	}

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Increments a persistence count for the object
//
// Current reference count
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CRow::AddRef(  void   )
{
    return InterlockedIncrement((long*)&m_cRef);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Decrements a persistence count for the object and if persistence count is 0, the object
// destroys itself.
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CRow::Release( void   )
{
    if (!InterlockedDecrement((long*)&m_cRef)){
		//===========================================================
		// Mark the session as not having an open rowset anymore
		//===========================================================
		this->m_pCreator->RemoveRowset(this);
//		this->m_pCreator->DecRowsetCount();
        delete this;
        return 0;
    }

    return m_cRef;
}



/////////////////////////////////////////////////////////////////////////////////////////////////
// The first function called for the row for initialization of the class
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::InitRow(HROW hRow ,
					  CWbemClassWrapper *pInst ,
					  ROWCREATEBINDFLAG rowCreateFlag)
{
	HRESULT hr = S_OK;
	DBCOLUMNINFO * pCol = NULL;
	CURLParser   urlParser;

	m_hRow	= hRow;
	m_pInstance = (CWbemClassInstanceWrapper *)pInst;

	//=================================================
	// If the class is not created by the rowset then
	//=================================================
	if(m_pSourcesRowset == NULL)
	{
		BSTR strTemp;
		strTemp = Wmioledb_SysAllocString(m_strKey);
		urlParser.SetPath(strTemp);
		SysFreeString(strTemp);
		if(urlParser.GetURLType() == URL_EMBEDEDCLASS)
		{

			GetEmbededInstancePtrAndSetMapClass(&urlParser);
		}
		else
		{
			VARIANT varDataSrc;
			VariantInit(&varDataSrc);
			m_pInstance = NULL;
			strTemp = Wmioledb_SysAllocString(m_strKey);

			// If the object path is same as the data src then the object has
			// to be obtained by just QI on the IWbemServicesEx pointer
			if(SUCCEEDED(hr = m_pCreator->GetDataSrcProperty(DBPROP_INIT_DATASOURCE , varDataSrc)) && 
				varDataSrc.vt == VT_BSTR && varDataSrc.bstrVal != NULL)
			{
				if(_wcsicmp(m_strKey,varDataSrc.bstrVal) == 0)
				{
					SAFE_FREE_SYSSTRING(strTemp);
				}
			}
			m_pInstance = (CWbemClassInstanceWrapper *)m_pMap->GetInstance(strTemp);
			SysFreeString(strTemp);
		}
		urlParser.GetURL(strTemp);
		m_strURL = new WCHAR[SysStringLen(strTemp) + 1];
		// NTRaid:111801
		// 06/07/00
		if(m_strURL)
		{
			memset(m_strURL,0,(SysStringLen(strTemp) + 1) * sizeof(WCHAR));
			memcpy(m_strURL,strTemp,SysStringLen(strTemp)  * sizeof(WCHAR));

			if( rowCreateFlag == ROWCREATE && m_pInstance != NULL)
			{
				hr = DB_E_RESOURCEEXISTS;
			}
			else
			{
				//=================================================
				// If an existing instance is to be created
				//=================================================
				if( rowCreateFlag == ROWCREATE || rowCreateFlag == ROWOVERWRITE )
				{
					//======================================================
					// If instance already exists then delete the instance
					//======================================================
					if( m_pInstance != NULL)
					{
						m_pMap->DeleteInstance(m_pInstance);
						m_pInstance = NULL;
					}
					//===========================
					// Create instance
					//===========================
					hr = CreateNewRow(&m_pInstance);
				}
				
				//=================================================================
				// If instance is pointed by the path is not found return error
				//=================================================================
				if( m_pInstance == NULL)
				{
					hr = DB_E_NOTFOUND;
				}
				else
				{

	/*				//====================================================================
					/// Get property and Set Serach Preferences
					//====================================================================
					hr = SetSearchPreferences();

					//===================================================================================
					//  Get the column information
					//===================================================================================
					if(SUCCEEDED(hr = CBaseRowObj::GetColumnInfo()))
					{
						m_cTotalCols--;		// Decrementing so as not to take into account the bookmark column

						
						//===========================================================================
						// Initialize the columns representing the qualifiers and embeded classes
						//===========================================================================
						if(m_cNestedCols > 0)
						for ( int iCol = 1 ; iCol < (int)m_Columns.GetTotalNumberOfColumns(); iCol++)
						{
							pCol = m_Columns.GetColInfo(iCol);
							if( pCol->wType == DBTYPE_HCHAPTER)
							{
								pCol->wType			        = DBTYPE_UI4;
								pCol->ulColumnSize			= sizeof(ULONG);
								pCol->dwFlags				= DBCOLUMNFLAGS_ISCOLLECTION;
							}

						}
					
					}	// Succeeded(GetCOlumnInfo())
	*/			
					hr = S_OK;
				} // Else if instance pointed by path not found			

			} // else of if( rowCreateFlag == ROWCREATE && m_pInstance != NULL)
		} // if(m_strUrl)
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		CBSTR strTemp;
		if(SUCCEEDED(hr = ((CWbemClassInstanceWrapper *)pInst)->GetKey(strTemp)))
		{
			m_strKey = new WCHAR [ SysStringLen(strTemp) + 1];
			wcscpy(m_strKey,strTemp);

			urlParser.SetPath(strTemp);
			strTemp.Clear();
			strTemp.Unbind();
			urlParser.GetURL((BSTR &)strTemp);
			m_strURL = new WCHAR[ SysStringLen(strTemp) + 1];
			memset(m_strURL,0,(SysStringLen(strTemp) + 1) * sizeof(WCHAR));
			memcpy(m_strURL,strTemp,SysStringLen(strTemp) * sizeof(WCHAR));

		}
	}

	if(SUCCEEDED(hr))
	{
		//===========================================================================
		// Call this function to allocate memory for all the contained interfaces
		// and utility classes
		//===========================================================================
		if(SUCCEEDED(hr = AllocateInterfacePointers()))
		{
			if(m_pSourcesRowset != NULL)
			{
				m_cTotalCols = m_pSourcesRowset->m_Columns.GetTotalNumberOfColumns();
				hr = GetRowColumnInfo();
			}
			else
			{
				//====================================================================
				/// Get property and Set Serach Preferences
				//====================================================================
				hr = SetSearchPreferences();

				//===================================================================================
				//  Get the column information 
				//===================================================================================
				if(SUCCEEDED(hr = CBaseRowObj::GetColumnInfo()))
				{
					m_cTotalCols--;		// Decrementing so as not to take into account the bookmark column

					
					//===========================================================================
					// Initialize the columns representing the qualifiers and embeded classes
					//===========================================================================
					if(m_cNestedCols > 0)
					for ( int iCol = 1 ; iCol < (int)m_Columns.GetTotalNumberOfColumns(); iCol++)
					{
						pCol = m_Columns.GetColInfo(iCol);
						if( pCol->wType == DBTYPE_HCHAPTER)
						{
							pCol->wType			        = DBTYPE_UI4;
							pCol->ulColumnSize			= sizeof(ULONG);
							pCol->dwFlags				= DBCOLUMNFLAGS_ISCOLLECTION | DBCOLUMNFLAGS_ISCHAPTER;
						}

					}
				
				}	// Succeeded(GetCOlumnInfo())

				m_pRowColumns = &m_Columns;
			}
		
		} // if Succeeded(hr)
	
	} // If Succeeded(hr)

	if(SUCCEEDED(hr))
	{
		//==========================================================
		// Call this function to initialize the ISupportErrorInfo;
		//==========================================================
		hr = AddInterfacesForISupportErrorInfo();

	}
	
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// This first function called for the row for initialization of the class when a row is
// not created from rowset object
// An overloaded function
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::InitRow(LPWSTR strPath,
					  LPWSTR strTableID ,
					  DWORD dwFlags,
					  ROWCREATEBINDFLAG rowCreateFlag)
{

	HRESULT hr = S_OK;
	//=========================================================
	// Call this function to Initialize and allocate WMIOledb
	//=========================================================
	hr = InitializeWmiOledbMap(strPath,strTableID,dwFlags);

	if( SUCCEEDED(hr))
	{
		hr = InitRow(0,0,rowCreateFlag);
	}

	return hr;
}



////////////////////////////////////////////////////////////////////////////////////////////
// Function to allocate contained interface pointers and also some utility classes
////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::AllocateInterfacePointers()
{
	HRESULT hr = S_OK;
	if(m_pSourcesRowset == NULL)
	{
		m_pIConvertType	= new CImpIConvertType(this);
		m_pUtilProp		= new CUtilProp;
		// NTRaid: 136443
		// 07/05/00
		if(m_pUtilProp)
		{
			hr = m_pUtilProp->FInit(ROWSETPROP);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	//=========================================================================
	// if row is created from a rowset then create a columninfo manager
	// instance , passing the source rowset as a parameter to constructor
	//=========================================================================
	else
	{		
		m_pRowColumns	= new cRowColumnInfoMemMgr(&m_pSourcesRowset->m_Columns);
	}

	if(SUCCEEDED(hr))
	{
		m_pIColumnsInfo			= new CImpIColumnsInfo( this );
		m_pIRow					= new CImpIRow( this );
		m_pIGetSession			= new CImpIGetSession( this );
		m_pIRowChange			= new CImpIRowChange( this );
		m_pISupportErrorInfo	= new CImpISupportErrorInfo(this);
		m_pIScopedOperations	= new CImpIScopedOperations(this);


		if( ! (m_pIColumnsInfo &&  m_pUtilProp && m_pIRow && m_pIGetSession && m_pIRowChange && m_pIConvertType && m_pIScopedOperations))
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////
// Function to allocate CWmiOledbMap class if row is not created from rowset
////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::InitializeWmiOledbMap(LPWSTR strPath,
									LPWSTR strTableID ,
									DWORD dwFlags)
{
	HRESULT hr = S_OK;
	assert(m_pSourcesRowset == NULL);
	CURLParser urlParser;
	CBSTR strTemp;

	if(strPath == NULL )
	{
		hr = E_INVALIDARG;
	}
	else
	{
		LONG lObjectType = -1;
		strTemp.SetStr(strPath);
		urlParser.SetPath(strTemp);
		lObjectType = urlParser.GetURLType();
		if(lObjectType == URL_DATASOURCE && strTableID == NULL)
		{
			hr = E_INVALIDARG;
		}
		if(lObjectType == URL_DATASOURCE) // or scope
		{
			m_rowType = ROW_SCOPE;
		}
	}

	if(SUCCEEDED(hr))
	{
		dwFlags = dwFlags == -1 ? GetQualifierFlags(): dwFlags;
		if(m_rowType == ROW_SCOPE) // this happenes only the opened scope is a namespace
		{
/*//			m_pMap = new CWmiOleDBMap(	strPath,
//										m_pCon == NULL ?m_pCreator->m_pCDataSource->m_pWbemWrap: m_pCon);

			if(m_pMap)
			{
	//			hr = m_pMap->FInit(	strPath,m_pCon == NULL ?m_pCreator->m_pCDataSource->m_pWbemWrap: m_pCon);
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
*/		}
		else
		{
			m_pMap = new CWmiOleDBMap;
			
			if(m_pMap)
			{
				hr = m_pMap->FInit(dwFlags,strTableID,m_pCon == NULL ?m_pCreator->m_pCDataSource->m_pWbemWrap: m_pCon);
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}

		if(SUCCEEDED(hr))
		{
			VARIANT varValue;
			VariantInit(&varValue);
			// Bug which not able to get system properties from Row object
			// NTRaid: 145684
			// 05/06/00
			//===========================================================================================
			// Get the DataSource property to check if system Properties is to be fetched?
			//===========================================================================================
			if(SUCCEEDED(hr = m_pCreator->GetDataSrcProperty(DBPROP_WMIOLEDB_SYSTEMPROPERTIES,varValue)))
			{
				if( varValue.boolVal == VARIANT_TRUE)
				{
					m_pMap->SetSytemPropertiesFlag(TRUE);
				}

				m_strKey			= new WCHAR [wcslen(strPath) + 1];
				if(m_strKey == NULL)
				{
					hr = E_OUTOFMEMORY;
				}
				else
				{
					wcscpy(m_strKey,strPath);
					m_pMap->AddRef();
				}
			}
			VariantClear(&varValue);
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to add interfaces to ISupportErrorInfo interface
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::AddInterfacesForISupportErrorInfo()
{
	HRESULT hr = S_OK;

	if( SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IColumnsInfo)) &&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IConvertType)) &&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IGetSession)) &&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IRowChange)) &&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IScopedOperations)) &&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IBindResource)))
	{
		hr = m_pISupportErrorInfo->AddInterfaceID(IID_IRow);
	}

	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////
// Function to the get the value of the columns requested
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::GetColumns(DBORDINAL cColumns,DBCOLUMNACCESS   rgColumns[ ])
{
	HRESULT hr = E_FAIL;

	for( ULONG_PTR lIndex = 0 ; lIndex < cColumns ; lIndex++)
	{
		//=============================================
		// Initialize the output memeber variables
		//=============================================
		rgColumns[lIndex].cbDataLen  = 0;
		rgColumns[lIndex].dwStatus	 = DBSTATUS_S_OK;
	}

	//======================================================
	// if the row object is created by the rowset then
	// get the data maintained by the rowset object
	//======================================================
	if(m_pSourcesRowset != NULL)
	{
		hr = GetColumnsFromRowset(cColumns,rgColumns);
	}
	else
	{
		/// Get data for the requested columns
		hr = GetRowData(cColumns,rgColumns);
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// Function to the get the value of the columns when row object is created from rowset
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::GetColumnsFromRowset(DBORDINAL cColumns,DBCOLUMNACCESS   rgColumns[])
{
    DBORDINAL   icol;
    ROWBUFF     *pRowBuff;
    COLUMNDATA  *pColumnData;
    DBCOUNTITEM ulErrorCount	= 0;
    DBTYPE      dwSrcType;
    DBTYPE      dwDstType;
    void        *pSrc;
    void        *pDst;
	DBLENGTH    ulSrcLength;
    DBLENGTH    *pulDstLength;
    DBLENGTH    ulDstMaxLength;
    DBSTATUS    dwSrcStatus;
    DBSTATUS    *pdwDstStatus;
    HRESULT     hr				= S_OK;
	DBSTATUS	dwStatus		= DBSTATUS_S_OK;
	CDataMap	dataMap;
	BOOL		bUseDataConvert = TRUE;
	VARIANT		varValue;

	VariantInit(&varValue);

	//=========================================================
	// Check if the row is already deleted
	//=========================================================
	dwStatus = m_pSourcesRowset->GetRowStatus(m_hRow);
	if( dwStatus != DBROWSTATUS_S_OK)
	{
		if(dwStatus == DBROWSTATUS_E_DELETED)
		{
			hr = DB_E_DELETEDROW;
		}
		else
		{
			hr = E_FAIL;
		}
	}

	if( SUCCEEDED(hr))
	{
		//=========================================================
		// if data is not yet received then fetch the data
		//=========================================================
		if(S_OK != m_pSourcesRowset->IsSlotSet(m_hRow))
		{
			hr = m_pSourcesRowset->GetData(m_hRow);
		}
		
		if(SUCCEEDED(hr))
		{
			if( (m_pSourcesRowset->m_ulProps & OTHERUPDATEDELETE) &&(m_pSourcesRowset->m_ulLastFetchedRow != m_hRow))
			{
				if(SUCCEEDED(hr = m_pSourcesRowset->GetDataToLocalBuffer(m_hRow)))
				{
					m_pSourcesRowset->m_ulLastFetchedRow = m_hRow;
				}
			}

			if(SUCCEEDED(hr))
			{
				//=========================================================
				// Get the pointer to the rowbuffer
				//=========================================================
				pRowBuff = m_pSourcesRowset->GetRowBuff(m_hRow , TRUE);

				assert(pRowBuff != NULL);

				// Navigate for each requested column
				for( ULONG lIndex = 0 ; lIndex < cColumns ; lIndex++)
				{
					bUseDataConvert = TRUE;
					
					// if the column is a bookmark then continue without doing anything
					if(rgColumns[lIndex].columnid.eKind == DBKIND_GUID_PROPID &&
						rgColumns[lIndex].columnid.uGuid.guid == DBCOL_SPECIALCOL &&
						rgColumns[lIndex].columnid.uName.ulPropid >= 2)
					{
						if(m_pSourcesRowset->m_ulProps & BOOKMARKPROP)
						{
							dwSrcType	= DBTYPE_I4;
							pSrc		= &pRowBuff->dwBmk;
							ulSrcLength	= pRowBuff->cbBmk;
							dwSrcStatus	= DBSTATUS_S_OK;
							icol		= 0;
						}
						else
						{
							continue;
						}
					}
					else
					{
						//=================================================================
						// If the columnID is not of type name then set the status
						// to unavialable as only this is supported
						//=================================================================
						if(rgColumns[lIndex].columnid.eKind != DBKIND_NAME)
						{
							rgColumns[lIndex].dwStatus = DBSTATUS_E_UNAVAILABLE;
							continue;
						}

						icol = m_pSourcesRowset->GetOrdinalFromColName(rgColumns[lIndex].columnid.uName.pwszName);


						//=========================================================================================
						// The column unavailable for the row as the class qualifier belongs to a parent rowset
						//=========================================================================================
						if(S_OK == (hr =m_pCreator->GetDataSrcProperty(DBPROP_WMIOLEDB_QUALIFIERS,varValue)))
						if(	(varValue.lVal & CLASS_QUALIFIERS) &&
										m_bClassChanged &&
										icol == 1 &&
										m_pRowColumns->ColumnType(icol) == DBTYPE_HCHAPTER)
						{
							rgColumns[lIndex].dwStatus = DBSTATUS_E_UNAVAILABLE;
							continue;
						}
						//=================================================================
						// If the requested column is not part of the source rowset
						// get it directly from the instance
						//=================================================================
						if((DB_LORDINAL) icol == -1)
						{
							hr = GetColumnData(rgColumns[lIndex]);
							
							if ( hr != S_OK )
							{
								ulErrorCount++;
							}
							continue;
						}
					
						pColumnData = (COLUMNDATA *) ((BYTE *) pRowBuff + m_pSourcesRowset->m_Columns.GetDataOffset(icol));


						dwSrcType      = (SHORT)pColumnData->dwType;

						if( dwSrcType == DBTYPE_BSTR)
						{
							pSrc           = &(pColumnData->pbData);
						}
						else
						{
							pSrc           = (pColumnData->pbData);
						}

						ulSrcLength    = pColumnData->dwLength;
						dwSrcStatus    = pColumnData->dwStatus;
					}
					ulDstMaxLength = rgColumns[lIndex].cbMaxLen;
					dwDstType      = rgColumns[lIndex].wType;

					pDst           = rgColumns[lIndex].pData;
					pulDstLength   = &rgColumns[lIndex].cbDataLen;
					pdwDstStatus   = &rgColumns[lIndex].dwStatus;

					//==========================================================
					// if the column is of type chapter then consider that
					// as a of type long as HCHAPTER is a ULONG value
					//==========================================================
					if(dwSrcType == DBTYPE_HCHAPTER)
					{
						dwSrcType = DBTYPE_UI4;
					}

					if(dwDstType == DBTYPE_HCHAPTER)
					{
						dwDstType = DBTYPE_UI4;
					}

					//=================================================================
					// if both the source and destination type is array then don't
					// use IDataConvert::DataConvert for conversion
					//=================================================================
					if( (dwSrcType & DBTYPE_ARRAY) && (dwDstType & DBTYPE_ARRAY) )
					{
						bUseDataConvert = FALSE;
					}

					if( dwSrcType != VT_NULL && dwSrcType != VT_EMPTY && bUseDataConvert == TRUE && pSrc != NULL)
					{
						// NTRaid:138957
						// since for DBTYPE_UI4 the data returned from WMI
						// is of type DBTYPE_I4 changing the source type does not
						// have any effect except that the VARIANT type of the
						// output will be VT_I4 instead of VT_UI4
						DBTYPE dbSrcType = dwSrcType;
						if(dwDstType == DBTYPE_VARIANT)
						{
							dbSrcType = GetVBCompatibleAutomationType(dwSrcType);
						}
						hr = g_pIDataConvert->DataConvert(
								dbSrcType,
								dwDstType,
								ulSrcLength,
								pulDstLength,
								pSrc,
								pDst,
								ulDstMaxLength,
								dwSrcStatus,
								pdwDstStatus,
								rgColumns[lIndex].bPrecision,	// bPrecision for conversion to DBNUMERIC
								rgColumns[lIndex].bScale,		// bScale for conversion to DBNUMERIC
								DBDATACONVERT_DEFAULT);

						if(hr == DB_E_UNSUPPORTEDCONVERSION && pdwDstStatus != NULL)
						{
							*pdwDstStatus = DBSTATUS_E_CANTCONVERTVALUE;
						}
					}
					else
					if(bUseDataConvert == FALSE && pSrc != NULL)
					{
						//=================================================================
						// Call this function to get the array in the destination address
						//=================================================================
						hr = dataMap.ConvertAndCopyArray((SAFEARRAY *)pSrc,(SAFEARRAY **)pDst, dwSrcType,dwDstType,pdwDstStatus);
						
						if( *pdwDstStatus == DBSTATUS_E_CANTCONVERTVALUE)
						{
							*pulDstLength = 0;
						}

					}
					else
					{
						*pulDstLength = 0;
						*pdwDstStatus = DBSTATUS_S_ISNULL;
					}

					//===================================================================
					// Ignoring the array for the time being
					// to be removed later
					//===================================================================
					if(dwSrcType & VT_ARRAY)
					{
						hr = S_OK;
					}

					if (hr != S_OK )
					{
						ulErrorCount++; // can't coerce
						hr = S_OK;
					}
				
				} // for loop
			
			} // if succeeded(hr) after getting local buffer address
		
		} // if Succeeded(hr) after getting the slot number
	
	} // if Succeeded(hr) after initial checking

	//===================================================================
    // We report any lossy conversions with a special status.
    // Note that DB_S_ERRORSOCCURED is a success, rather than failure.
	//===================================================================
    if ( SUCCEEDED(hr) )
	{
        hr = ( ulErrorCount ? DB_S_ERRORSOCCURRED : S_OK );
	}

    return hr;
}






/////////////////////////////////////////////////////////////////////////////////////////////////
// Function to update a row
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::UpdateRow(DBORDINAL cColumns,DBCOLUMNACCESS rgColumns[ ])
{
	VARIANT varProp;
	HRESULT hr = E_FAIL;

	VariantInit(&varProp);

	if(m_pSourcesRowset != NULL)
	{
		//===================================================================
		// Check if updatibility is supported by the parent rowset
		//===================================================================
		if(SUCCEEDED(hr = m_pSourcesRowset->GetRowsetProperty(DBPROP_UPDATABILITY , varProp)))
		{
			//=========================================================
			// If the rowset is not updatable then return failure
			//=========================================================
			if(!( varProp.lVal & DBPROPVAL_UP_CHANGE))
			{
				hr = E_FAIL;
			}
			else
			{
				hr = UpdateColumnsFromRowset(cColumns,rgColumns);
			}
		}

	}
	else
	{
		hr = SetRowData(cColumns,rgColumns);
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// Function to update a row when it is created by a rowset
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::UpdateColumnsFromRowset(DBORDINAL cColumns,DBCOLUMNACCESS rgColumns[ ])
{
    DBORDINAL   icol;
    ROWBUFF     *pRowBuff;
    COLUMNDATA  *pColumnData;
    DBCOUNTITEM ulErrorCount	= 0;
    DBTYPE      dwSrcType;
    DBTYPE      dwDstType;
    void        *pSrc;
    void        *pDst;
	void		*pTemp;
    DBLENGTH    ulSrcLength;
    DBLENGTH    ulDstLength;
    DBLENGTH    ulDstMaxLength;
    DBSTATUS    dwSrcStatus;
    DBSTATUS    dwDstStatus;
    HRESULT     hr				= S_OK;
	DBSTATUS	dwStatus		= DBSTATUS_S_OK;
	CVARIANT	cvarData;
	VARIANT	 	*pvarData		= &cvarData;
	CDataMap	map;
	ULONG		lFlags			= 0;
	BOOL 		bUseDataConvert = TRUE;
	DWORD		dwCIMType		= 0;


	dwStatus = m_pSourcesRowset->GetRowStatus(m_hRow);
	if( dwStatus != DBROWSTATUS_S_OK)
	{
		if(dwStatus == DBROWSTATUS_E_DELETED)
		{
			hr = DB_E_DELETEDROW;
		}
		else
		{
			hr = E_FAIL;
		}
	}
	else
	{
		//========================================================
		// if data is not yet received then fetch the data
		//========================================================
		if(S_OK != m_pSourcesRowset->IsSlotSet(m_hRow))
		{
			hr = m_pSourcesRowset->GetData(m_hRow);
		}
		
		if(SUCCEEDED(hr))
		{
			//========================================
			// Get the pointer to the rowbuffer
			//========================================
			pRowBuff = m_pSourcesRowset->GetRowBuff(m_hRow , TRUE);

			assert(pRowBuff != NULL);

			for( ULONG lIndex = 0 ; lIndex < cColumns ; lIndex++)
			{
				bUseDataConvert = TRUE;
				if(rgColumns[lIndex].columnid.eKind != DBKIND_NAME)
				{
					rgColumns[lIndex].dwStatus = DBSTATUS_E_UNAVAILABLE;
					continue;
				}

				icol = m_pSourcesRowset->GetOrdinalFromColName(rgColumns[lIndex].columnid.uName.pwszName);

				//===================================================================================
				// If the requested column is not part of the source rowset
				// call SetColumnData function to set it directly from the instance
				//===================================================================================
				if((DB_LORDINAL)icol < 0)
				{
					hr = SetColumnData(rgColumns[lIndex]);
					if ( hr != S_OK )
					{
						ulErrorCount++;
					}
					continue;
				}

				pColumnData = (COLUMNDATA *) ((BYTE *) pRowBuff + m_pSourcesRowset->m_Columns.GetDataOffset(icol));

				//==================================================
				// check if the column is readonly or not
				//==================================================
				lFlags = m_pSourcesRowset->m_Columns.ColumnFlags(icol);
				if((m_pSourcesRowset->m_Columns.ColumnFlags(icol) & DBCOLUMNFLAGS_WRITE) == 0)
				{
					pColumnData->dwStatus = DBSTATUS_E_READONLY;
					ulErrorCount++;
					continue;
				}

				dwSrcType      = rgColumns[lIndex].wType;
				ulSrcLength    = rgColumns[lIndex].cbDataLen;
				dwSrcStatus    = rgColumns[lIndex].dwStatus;
				pSrc		   = rgColumns[lIndex].pData;
				
				ulDstMaxLength = -1;
				dwDstType      = (SHORT)pColumnData->dwType;
		//		pDst           = &varData;

				//==========================================================
				// if the column is of type chapter then consider that
				// as a of type long as HCHAPTER is a ULONG value
				//==========================================================
				if(dwSrcType == DBTYPE_HCHAPTER)
				{
					dwSrcType = DBTYPE_UI4;
				}

				if(dwDstType == DBTYPE_HCHAPTER)
				{
					dwDstType = DBTYPE_UI4;
				}

				hr = g_pIDataConvert->GetConversionSize(dwSrcType, dwDstType, &ulSrcLength, &ulDstLength, pSrc);
				try
				{
					pDst = new BYTE[ulDstLength];
				}
				catch(...)
				{
					SAFE_DELETE_ARRAY(pDst);
					throw;
				}

				//===================================================================================
				// if both the source and destination type is array then don't
				// use IDataConvert::DataConvert for conversion
				//===================================================================================
				if( (dwSrcType & DBTYPE_ARRAY) && (dwDstType & DBTYPE_ARRAY) )
				{
					bUseDataConvert = FALSE;
				}

				// this function is called to check for some non automation types
				dwSrcType = GetVBCompatibleAutomationType(dwSrcType);
				//===================================================================================
				// If the source type is not array or empty or null the use the conversion library
				// for converting the data
				//===================================================================================
				if( dwSrcType != VT_NULL && dwSrcType != VT_EMPTY && bUseDataConvert == TRUE && pSrc != NULL)
				{
					hr = g_pIDataConvert->DataConvert(
							dwSrcType,
							dwDstType,
							ulSrcLength,
							&ulDstLength,
							pSrc,
							pDst,
							ulDstMaxLength,
							dwSrcStatus,
							&dwDstStatus,
							0,	// bPrecision for conversion to DBNUMERIC
							0,		// bScale for conversion to DBNUMERIC
							DBDATACONVERT_DEFAULT);

					if(hr == DB_E_UNSUPPORTEDCONVERSION )
					{
						dwDstStatus = DBSTATUS_E_CANTCONVERTVALUE;
					}
				}
				else
				if(bUseDataConvert == FALSE && pSrc != NULL)
				{
					//==================================================================
					// Call this function to get the array in the destination address
					//==================================================================
					hr = map.ConvertAndCopyArray((SAFEARRAY *)pSrc,(SAFEARRAY **)pDst, dwSrcType,dwDstType,	&dwDstStatus);		
					if(dwDstStatus == DBSTATUS_E_CANTCONVERTVALUE)
					{
						ulDstLength = 0;
						ulErrorCount++;
					}
				}
				else
				{
					pDst = NULL;
					ulDstLength = 0;
					dwDstStatus = DBSTATUS_S_ISNULL;
				}


				if( hr == S_OK)
				{
					dwCIMType = -1;
					//============================================================================
					// if the type is array , then get the original CIMTYPE as array type will
					// be given out as VT_ARRAY  | VT_VARIANT
					//============================================================================
					if(pColumnData->dwType & DBTYPE_ARRAY)
					{
						dwCIMType = m_Columns.GetCIMType(icol);
					}

					if(pDst != NULL && pColumnData->dwType == VT_BSTR)
					{
						pTemp = *(BSTR **)pDst;
					}
					else
					{
						pTemp = pDst;
					}
					//====================================
					// If data is is modified then
					//====================================
					if((map.CompareData(dwDstType,pColumnData->pbData,pTemp) == FALSE)
						 && !( pColumnData->pbData == NULL && ulDstLength == 0))
					{
						//===============================
						// Release the Old data
						//===============================
						pColumnData->ReleaseColumnData();
						if(ulDstLength > 0)
						{
							//=====================================================================
							// Convert the new data to Variant. This function return the status
							// if not able to conver the data
							//=====================================================================
							hr = map.MapAndConvertOLEDBTypeToCIMType((USHORT)pColumnData->dwType,pTemp,ulDstLength,*pvarData,dwCIMType);
						}
						if( hr == S_OK)
						{
							hr = pColumnData->SetData(cvarData,dwDstType);

							//==============================
							// Set the data to modified
							//==============================
							pColumnData->dwStatus |= COLUMNSTAT_MODIFIED;
							
							cvarData.Clear();
						}
						else
						{
							//==============================
							// Set the data to modified
							//==============================
							pColumnData->dwStatus |= hr;
							ulErrorCount++;

						}
					}
						
				}
				else
				{
					ulErrorCount++;
					rgColumns[lIndex].dwStatus = dwDstStatus;
				}

				SAFE_DELETE_ARRAY(pDst);
			
			} // for loop

			//===============================================================
			// if the error count is less than the number of columns
			// then there is atleast one column to be updated
			//===============================================================
			if( ulErrorCount < cColumns)
			{
				//====================================================================
				// Update the the row
				//====================================================================
				hr =  m_pSourcesRowset->UpdateRowData(m_hRow,cColumns,rgColumns);
			}

			//===================================================================
			// We report any lossy conversions with a special status.
			// Note that DB_S_ERRORSOCCURED is a success, rather than failure.
			//===================================================================
			if ( SUCCEEDED(hr) )
			{
				hr = ( ulErrorCount ? DB_S_ERRORSOCCURRED : S_OK );
			}
		}
	
	} // else of check if deleted

	return hr;

}



/////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Virtual overridden function which is called from IColumnInfo to get the column information
/////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::GetColumnInfo(DBORDINAL* pcColumns, DBCOLUMNINFO** prgInfo,WCHAR** ppStringsBuffer)
{
    DBORDINAL       icol					= 0;
    DBCOLUMNINFO*   rgdbcolinfo				= NULL;
    WCHAR*          pstrBuffer				= NULL;
    WCHAR*          pstrBufferForColInfo	= NULL;
	HRESULT			hr						= S_OK;
	ptrdiff_t		dp;
	DBCOUNTITEM		cSourcesCol				= 0;


	if(SUCCEEDED(hr = m_pRowColumns->CopyColumnInfoList(rgdbcolinfo,(m_pSourcesRowset != NULL))))
	{
		//=========================================================================
		// Copy the heap for column names.
		//=========================================================================
		if (m_pSourcesRowset != NULL && m_pRowColumns->ColumnNameListStartingPointOfSrcRs() != NULL){

			hr = m_pRowColumns->CopyColumnNamesList(pstrBuffer);
			if( hr != S_OK || pstrBuffer == NULL)
			{
				hr = E_OUTOFMEMORY;
			}
			else
			{
				//==================================================================================
				// This will give the starting pointer difference to the columns names of the
				// source rowset
				//==================================================================================
				dp = (LONG_PTR) pstrBuffer - (LONG_PTR) (m_pRowColumns->ColumnNameListStartingPointOfSrcRs());
				dp >>= 1;

				//=========================================================================
				// Loop through columns and adjust pointers
				// to column names.
				//=========================================================================
				cSourcesCol = m_pRowColumns->GetNumberOfColumnsInSourceRowset();
				for ( icol =0; icol < cSourcesCol; icol++ )
				{
					if ( rgdbcolinfo[icol].pwszName )
					{
						rgdbcolinfo[icol].pwszName += dp;
					}
					if(rgdbcolinfo[icol].wType == DBTYPE_HCHAPTER)
					{
						rgdbcolinfo[icol].dwFlags = DBCOLUMNFLAGS_ISCOLLECTION | DBCOLUMNFLAGS_ISCHAPTER ;
					}
				}

				//==================================================================================================================
				// This will give the starting pointer difference to the columns names of the columns which is not present in the
				// sources rowset
				// Here the number of bytes copied for source rowset column names has to be taken care of
				//==================================================================================================================
				dp = (LONG_PTR) pstrBuffer + m_pRowColumns->GetCountOfBytesCopiedForSrcRs() - (LONG_PTR) (m_pRowColumns->ColumnNameListStartingPoint());
				dp >>= 1;
			}

		}
		else
		{
			if( SUCCEEDED(hr = m_pRowColumns->CopyColumnNamesList(pstrBuffer)))
			{
				//================================================================================
				// This will give the starting pointer difference to the columns names of the
				// source rowset
				//================================================================================
				dp = (LONG_PTR) pstrBuffer - (LONG_PTR) (m_pRowColumns->ColumnNameListStartingPoint());
				dp >>= 1;
				icol = 0;
			}
		}

		if(SUCCEEDED(hr))
		{
			//===========================================
			// Loop through columns and adjust pointers
			// to column names.
			//===========================================
			for ( ; icol < m_cTotalCols ; icol++ )
			{
				if ( rgdbcolinfo[icol].pwszName )
				{
					rgdbcolinfo[icol].pwszName += dp;
				}

			}

			//=======================================================
			// If the row's column is of type HCHAPTER change it
			// to empty and the flag to DBCOLUMNFLAGS_ISCOLLECTION
			//=======================================================
			if(m_cNestedCols > 0)
			for(icol  = 0; icol < m_cTotalCols ; icol++)
			{
				if(rgdbcolinfo[icol].wType == DBTYPE_HCHAPTER)
				{
					rgdbcolinfo[icol].wType			=	DBTYPE_HCHAPTER;
					rgdbcolinfo[icol].dwFlags		=	DBCOLUMNFLAGS_ISCHAPTER | DBCOLUMNFLAGS_ISCOLLECTION;
					rgdbcolinfo[icol].ulColumnSize	=	sizeof(DBLENGTH);
				}
			}

			//===================================================================================================
			// Setting the output parameters
			//===================================================================================================
			*prgInfo = &rgdbcolinfo[0];
			*ppStringsBuffer = pstrBuffer;
			*pcColumns = m_cTotalCols;
		
		} // if succeeded(hr)

	}		// if succeeded(CopyColumnInfoList())

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Function to get the column information of the row. THis function check if the class name of the
//  rowset which created the row belongs to the same class as that of the instance pointing the current row
//  If these two are different , this ffunction get the col info for this row
/////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::GetRowColumnInfo()
{
	WCHAR *pstrRsClassName = NULL, *pstrRowClassName = NULL;
	HRESULT hr = S_OK;

	//====================================================
	// Get the class name to which the instance belongs
	//====================================================
	pstrRowClassName = m_pInstance->GetClassName();
	if( pstrRowClassName != NULL)
	{
		//================================================
		// Get the class name of the source rowset
		//================================================
		pstrRsClassName = m_pSourcesRowset->m_pMap->GetClassName();
	}
	
	//============================================================
	// Set the bClassChanged flag to true if instance points to
	// different class than that of the source rowset
	//============================================================
	if( pstrRsClassName == NULL && pstrRowClassName == NULL)
	{
		m_bClassChanged = FALSE;
	}
	else
	if( pstrRsClassName == NULL || pstrRowClassName == NULL)
	{
		m_bClassChanged = TRUE;
	}
	else
	if(_wcsicmp(pstrRsClassName,pstrRowClassName) != 0)
	{
		m_bClassChanged = TRUE;
	}
	
	//=====================================================================
	// If the source rowset and the row points to different classes ,
	// then the columnd info of the remaining columns has to be obtained
	//=====================================================================
	if(m_bClassChanged == TRUE)
	{
		//===========================================
		// Get the flags of the source rowset
		//===========================================
		DWORD dwFlags = m_pInstance->GetFlags();
		SAFE_RELEASE_PTR(m_pMap);
		
		//===================================
		// Create a new map class
		//===================================
		m_pMap = new CWmiOleDBMap;
		
		if(m_pMap == NULL)
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			if(SUCCEEDED(hr = m_pMap->FInit(dwFlags,pstrRowClassName,
											m_pCon == NULL ?m_pCreator->m_pCDataSource->m_pWbemWrap: m_pCon)))
			{
				m_pMap->AddRef();

				//============================
				// Get the column info
				//============================
				hr = GetColumnInfo();
			}
		}
	}

	SAFE_DELETE_ARRAY(pstrRowClassName);

	return hr;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Get the number of columns in the row and allocate memory
/////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::GetColumnInfo()
{
    HRESULT hr = S_OK;
	VARIANT varValue;

	VariantInit(&varValue);

	// Bug which not able to get system properties from Row object
	// NTRaid: 140657
	// 05/06/00
	//===========================================================================================
	// Get the DataSource property to check if system Properties is to be fetched?
	//===========================================================================================
	if(SUCCEEDED(hr = m_pCreator->GetDataSrcProperty(DBPROP_WMIOLEDB_SYSTEMPROPERTIES,varValue)))
	{
		if( varValue.boolVal == VARIANT_TRUE)
		{
			m_pMap->SetSytemPropertiesFlag(TRUE);
		}

		//==================================================================================
		// switch on type of the qualifier. If it is 0 then the recordset is
		// representing the instances of the class
		//==================================================================================
		switch(	m_uRsType)
		{
			case 0 :

				//==================================================================================
				// Get the count of columns in the table
				//==================================================================================
				hr = m_pMap->GetColumnCount(m_cTotalCols,m_cCols,m_cNestedCols);

				// If source rowset is present and
				// If the property for showing system property is false and
				// if the source rowset is created by a query of mixed type
				// ( meaning rowset created executing a query, which results
				// in heterogenous objects ) then add another column to the row
				// which is part of the source rowset to show __PATH
				// NTRaid : 142133 & 141923
				// 07/12/00
				if(m_pSourcesRowset != NULL && m_cTotalCols)
				{
					if( varValue.boolVal == FALSE)
					{
						// all types of rowset has to have an extr column as __PATH property
						// which is a system property is shown in the row even if the 
						// DBPROP_WMIOLEDB_SYSTEMPROPERTIES is set to FALSE
						if(NORMAL != m_pSourcesRowset->GetObjListType())
						{
							m_cTotalCols++;
							m_cCols++;
						}
					}
					VariantClear(&varValue);
				}

				break;

			case PROPERTYQUALIFIER :
			case CLASSQUALIFIER:

				//==================================================================================
				// Get the number of columns for the property qualifier
				//==================================================================================
				m_cCols			= NUMBER_OF_COLUMNS_IN_QUALIFERROWSET + 1; // for bookmarkcolumn
				m_cTotalCols = m_cCols;
				break;

		};
	}

	if( SUCCEEDED(hr))
	{
		// The column unavailable for the row as the class qualifier belongs to a parent rowset
		if(m_pSourcesRowset != NULL && S_OK == (hr =m_pCreator->GetDataSrcProperty(DBPROP_WMIOLEDB_QUALIFIERS,varValue)))
		if(	(varValue.lVal & CLASS_QUALIFIERS) &&
						m_bClassChanged)
		{
			m_cTotalCols++;						// This is to accomodate another column which actually
												// holds the class/instance qualifiers
		}

        if( S_OK == (hr = m_pRowColumns->AllocColumnNameList(m_cTotalCols))){

            //===============================================================================
            //  Allocate the DBCOLUMNINFO structs to match the number of columns
            //===============================================================================
            if( S_OK == (hr = m_pRowColumns->AllocColumnInfoList(m_cTotalCols))){
                hr = GatherColumnInfo();
            }
        }
	}

    //==================================================================================
    // Free the columnlist if more is allocated
    //==================================================================================
    if( hr != S_OK ){
        m_pRowColumns->FreeColumnNameList();
        m_pRowColumns->FreeColumnInfoList();
    }

    return hr;

}


/////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Get the col info for row
/////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::GatherColumnInfo()
{
    HRESULT hr = S_OK;

	switch(	m_uRsType)
	{
		case 0 :

			//=============================================================
			// Get Column Names and Lengths
			//=============================================================
			hr = m_pMap->GetColumnInfoForParentColumns(m_pRowColumns);
			break;

		case PROPERTYQUALIFIER:

			//==================================================================================
			// Get the number of columns for the property qualifier
			//==================================================================================
			hr = CBaseRowObj::GatherColumnInfoForQualifierRowset();
			break;

		case CLASSQUALIFIER:
			break;

	};

    if(SUCCEEDED(hr))
	{
        m_cbRowSize = m_pRowColumns->SetRowSize();
        hr = m_pRowColumns->FreeUnusedMemory();
    }

  	
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////
// Get data for a particular column
//////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::GetColumnData(DBCOLUMNACCESS &col)
{
	DBORDINAL	icol			= 0;
    DBCOUNTITEM ulErrorCount	= 0;
	CIMTYPE		cimType			= 0;
    DBTYPE		dwSrcType;
    DBTYPE      dwDstType;
    void        *pSrc			= NULL;
    void        *pDst			= NULL;
	BYTE		*pTemp			= NULL;
    DBLENGTH    ulSrcLength;
    DBLENGTH    *pulDstLength	= NULL;
    DBLENGTH    ulDstMaxLength	= NULL;
    DBSTATUS    dwSrcStatus		= 0;
    DBSTATUS    *pdwDstStatus	= NULL;
    HRESULT     hr = S_OK;
	DBSTATUS	dwStatus		= DBSTATUS_S_OK;
	BSTR		strProp			= NULL;
	DWORD		dwFlags			= 0;
	CDataMap	map;
	BOOL		bUseDataConvert = TRUE;
	DBORDINAL	lCollectionColData = 0;

	icol = m_pRowColumns->GetColOrdinal(col.columnid.uName.pwszName);

	if( icol > 0)
	{
		// If the column is of type HCHAPTER or if it is a collection ( meaning
		// if the column represents any of the child rowsets) then set the
		// column to ordinal of the column
		if(m_pRowColumns->ColumnType(icol) == DBTYPE_HCHAPTER ||
			m_pRowColumns->ColumnFlags(icol) & DBCOLUMNFLAGS_ISCOLLECTION ||
			m_pRowColumns->ColumnFlags(icol) & DBCOLUMNFLAGS_ISCHAPTER)
		{
			col.bPrecision	= 0;
			col.bScale		= 0;
			lCollectionColData = icol;

			dwSrcType		= DBTYPE_UI4;
			ulDstMaxLength	= col.cbMaxLen;
			dwDstType		= (DBTYPE)col.wType;
			pulDstLength	= &col.cbDataLen;
			pdwDstStatus	= &col.dwStatus;
			ulSrcLength		= sizeof(lCollectionColData);
			dwSrcStatus		= DBSTATUS_S_OK;
			pSrc			= &lCollectionColData;

			hr = S_OK;
		}
		else
		{
			strProp = Wmioledb_SysAllocString(col.columnid.uName.pwszName);
			hr = m_pMap->GetProperty(m_pInstance,strProp, pTemp,dwSrcType ,ulSrcLength, dwFlags  );
			
			if(SUCCEEDED(hr))
			{
			
		//		dwSrcType = (DBTYPE)cimType;
				//==========================================
				// check if the column is readonly or not
				//==========================================
				if((dwFlags & DBCOLUMNFLAGS_WRITE) == 0)
				{
					col.dwStatus = DBSTATUS_E_READONLY;
				}
			
				//=========================================================
				// if the data is null set the status to null and return
				//=========================================================
				if(pTemp == NULL)
				{
					col.dwStatus = DBSTATUS_S_ISNULL;
					hr = S_OK;
				}
				else
				{
				
					if( dwSrcType == DBTYPE_BSTR)
					{
						pSrc = &pTemp;
					}
					else
					{
						pSrc = pTemp;
					}
					
					ulDstMaxLength = col.cbMaxLen;
					dwDstType      = (DBTYPE)col.wType;
					pulDstLength   = &col.cbDataLen;
					pdwDstStatus   = &col.dwStatus;

				}
			}
			SAFE_FREE_SYSSTRING(strProp);
		}

		if(SUCCEEDED(hr))
		{
			//==========================================================
			// if the column is of type chapter then consider that
			// as a of type long as HCHAPTER is a ULONG value
			//==========================================================
			if(dwSrcType == DBTYPE_HCHAPTER)
			{
				dwSrcType = DBTYPE_UI4;
			}
			if(dwDstType == DBTYPE_HCHAPTER)
			{
				dwDstType = DBTYPE_UI4;
			}
			pDst = (BYTE *)col.pData;

			// if both the source and destination type is array then don't
			// use IDataConvert::DataConvert for conversion
			// Arrays are requested as VARIANTS then also do conversion using our conversion routine
			// and fill the variant
			if( (dwSrcType & DBTYPE_ARRAY) && ( (dwDstType & DBTYPE_ARRAY) || dwDstType == VT_VARIANT) )
			{
				bUseDataConvert = FALSE;
			}

			// this function is called to check for some non automation types
			dwSrcType = GetVBCompatibleAutomationType(dwSrcType);
			// this function is called to check for some non automation types
			dwDstType = GetVBCompatibleAutomationType(dwDstType);
			// If the source type is not array or empty or null the use the conversion library
			// for converting the data
			if( dwSrcType != VT_NULL && dwSrcType != VT_EMPTY && bUseDataConvert == TRUE && pSrc != NULL)
			{
				hr = g_pIDataConvert->DataConvert(
						(USHORT)dwSrcType,
						dwDstType,
						ulSrcLength,
						pulDstLength,
						pSrc,
						pDst,
						ulDstMaxLength,
						dwSrcStatus,
						pdwDstStatus,
						0,	// bPrecision for conversion to DBNUMERIC
						0,		// bScale for conversion to DBNUMERIC
						DBDATACONVERT_DEFAULT);


				if(hr == DB_E_UNSUPPORTEDCONVERSION && pdwDstStatus != NULL)
				{
					*pdwDstStatus = DBSTATUS_E_CANTCONVERTVALUE;
				}

				if ( hr != S_OK)
				{
					ulErrorCount++;
				}
			}
			else
			if(bUseDataConvert == FALSE && pSrc != NULL)
			{
				SAFEARRAY *pArray = NULL;
				SAFEARRAY **pTemp = NULL;
				if(pDst != NULL)
				{
					pTemp = (SAFEARRAY **)pDst;
					if(dwDstType == VT_VARIANT)
					{
						pTemp = &pArray;
					}
				}

				// Call this function to get the array in the destination address
				hr = map.ConvertAndCopyArray((SAFEARRAY *)pSrc,pTemp, dwSrcType,dwDstType,pdwDstStatus);
				
				if( *pdwDstStatus == DBSTATUS_E_CANTCONVERTVALUE)
				{
					pulDstLength = 0;
				}
				if(SUCCEEDED(hr) && dwDstType == VT_VARIANT)
				{
					VariantInit((VARIANT *)pDst);
					if(pArray && pDst != NULL)
					{
						((VARIANT *)pDst)->vt = VT_ARRAY | VT_VARIANT;
						((VARIANT *)pDst)->parray = pArray;
					}
				}
			}
			else
			{
				if(pulDstLength)
				{
					*pulDstLength = 0;
				}
				if(pdwDstStatus)
				{
					*pdwDstStatus = DBSTATUS_S_ISNULL;
				}
			}
			//===============================	
			// Free the data allocated
			//===============================	
			map.FreeData(dwSrcType , pTemp);
		}
	}
	else
	{
		col.dwStatus = DBSTATUS_E_UNAVAILABLE;
		hr = E_FAIL;
	}

	return hr;
}



//////////////////////////////////////////////////////////////////////////////////////
// Set a value of a particular column
//////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::SetColumnData(DBCOLUMNACCESS &col,BOOL bNewRow)
{
    DBORDINAL   icol;
    DBCOUNTITEM ulErrorCount = 0;
    DBTYPE      dwSrcType;
    DBTYPE      dwDstType;
    void        *pSrc		= NULL;
    void        *pDst		= NULL;
	void		*pTemp		= NULL;
    DBLENGTH    lSrcLength;
    DBLENGTH    lDstLength;
    DBLENGTH    lDstMaxLength;
    DBSTATUS    dwSrcStatus;
    DBSTATUS    dwDstStatus;
    HRESULT     hr = S_OK;
	CVARIANT		cvarData;
	VARIANT			*pvarData = &cvarData;
	CDataMap	map;
	ULONG		lFlags = 0;
	BSTR		strProp;
	BOOL		bUseDataConvert = TRUE;
	DWORD		dwCIMType = 0;


	//===============================================================
	// Get the ordinal of the column from the column information
	//===============================================================
	icol = m_pRowColumns->GetColOrdinal(col.columnid.uName.pwszName);

	if( ((LONG)icol) >= 0)
	{

		strProp = Wmioledb_SysAllocString(col.columnid.uName.pwszName);
		//================================================
		// check if the column is readonly or not
		// If it is a new row continue updating
		//================================================
		lFlags = m_pRowColumns->ColumnFlags(icol);
		if(((bNewRow == FALSE)  && ((m_pRowColumns->ColumnFlags(icol) & DBCOLUMNFLAGS_WRITE) == 0)) ||
			((bNewRow == TRUE)  && m_pMap->IsSystemProperty(strProp)))
		{
			col.dwStatus = DBSTATUS_E_READONLY;
			ulErrorCount++;
			hr = DB_S_ERRORSOCCURRED;
		}
		else
		{

			dwSrcType      = col.wType;
			lSrcLength    = col.cbDataLen;
			dwSrcStatus    = col.dwStatus;

			if(dwSrcType == DBTYPE_BSTR)
			{
				pSrc = &col.pData;
			}
			else
			{
				pSrc		   = col.pData;
			}
			
			lDstMaxLength = -1;
			dwDstType      = (SHORT)m_pRowColumns->ColumnType(icol);

			//==========================================================
			// if the column is of type chapter then consider that
			// as a of type long as HCHAPTER is a ULONG value
			//==========================================================
			if(dwSrcType == DBTYPE_HCHAPTER)
			{
				dwSrcType = DBTYPE_UI4;
			}
			if(dwDstType == DBTYPE_HCHAPTER)
			{
				dwDstType = DBTYPE_UI4;
			}

			hr = g_pIDataConvert->GetConversionSize(dwSrcType, dwDstType, &lSrcLength, &lDstLength, pSrc);

			try
			{
				pDst = new BYTE[lDstLength];
			}
			catch(...)
			{
				SAFE_DELETE_ARRAY(pDst);
				throw;
			}

			// if both the source and destination type is array then don't
			// use IDataConvert::DataConvert for conversion
			if((dwSrcType & DBTYPE_ARRAY) && (dwDstType & DBTYPE_ARRAY))
			{
				bUseDataConvert = FALSE;
			}
			// this function is called to check for some non automation types
			dwSrcType = GetVBCompatibleAutomationType(dwSrcType);
			// If the source type is not array or empty or null the use the conversion library
			// for converting the data
			if( dwSrcType != VT_NULL && dwSrcType != VT_EMPTY && bUseDataConvert == TRUE && pSrc != NULL)
			{
				hr = g_pIDataConvert->DataConvert(
						dwSrcType,
						dwDstType,
						lSrcLength,
						&lDstLength,
						pSrc,
						pDst,
						lDstMaxLength,
						dwSrcStatus,
						&dwDstStatus,
						0,	// bPrecision for conversion to DBNUMERIC
						0,		// bScale for conversion to DBNUMERIC
						DBDATACONVERT_DEFAULT);

				if(hr == DB_E_UNSUPPORTEDCONVERSION )
				{
					dwDstStatus = DBSTATUS_E_CANTCONVERTVALUE;
				}
			}
			else
			if(bUseDataConvert == FALSE && pSrc != NULL)
			{
				// Call this function to get the array in the destination address
				hr = map.ConvertAndCopyArray((SAFEARRAY *)pSrc,(SAFEARRAY **)pDst, dwSrcType,dwDstType,&dwDstStatus);
				
				if( dwDstStatus == DBSTATUS_E_CANTCONVERTVALUE)
				{
					lDstLength = 0;
				}
			}
			else
			{
					lDstLength = 0;
					dwDstStatus = DBSTATUS_S_ISNULL;
			}

			if(SUCCEEDED(hr))
			{
				dwCIMType = -1;
				// if the type is array , then get the original CIMTYPE as array type will
				// be given out as VT_ARRAY  | VT_VARIANT
				if(dwDstType & DBTYPE_ARRAY)
				{
					dwCIMType = m_Columns.GetCIMType(icol);
				}

				if(pDst != NULL && dwDstType == VT_BSTR)
				{
					pTemp = *(BSTR **)pDst;
				}
				else
				{
					pTemp = pDst;
				}

				//=========================================
				// If data is is modified then
				//=========================================
				if( pTemp != NULL && lDstLength != 0)
				{
					if(lDstLength > 0)
					{
						//===========================================
						// Convert the new data to Variant
						//===========================================
						map.MapAndConvertOLEDBTypeToCIMType((USHORT)dwDstType,pTemp,lDstLength,*pvarData,dwCIMType);
						hr = m_pInstance->SetProperty(strProp,pvarData);
					}					
					cvarData.Clear();
				}
					
			}
			else
			{
				ulErrorCount++;
				col.dwStatus = dwDstStatus;
			}

			SAFE_DELETE_PTR(pDst);

		}
		SysFreeString(strProp);
	}

	//===================================================================
    // We report any lossy conversions with a special status.
    // Note that DB_S_ERRORSOCCURED is a success, rather than failure.
	//===================================================================
    if ( SUCCEEDED(hr) )
	{
        hr = ( ulErrorCount ? DB_S_ERRORSOCCURRED : S_OK );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Get the rowdata and put it into the buffer pointed by the second parameter
/////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::GetRowData(DBORDINAL cColumns,DBCOLUMNACCESS   rgColumns[])
{ 			
	ULONG ulErrorCount = 0;
	HRESULT hr = S_OK;

	//=========================================================
	// Navigate through every element in the array, get
	// the value of the columns
	//=========================================================
	for (ULONG_PTR lIndex = 0 ; lIndex < cColumns ; lIndex++)
	{
		hr = GetColumnData(rgColumns[lIndex]);
			
		if ( hr != S_OK )
		{
			ulErrorCount++;
			hr = S_OK;
		}
	}

    if ( SUCCEEDED(hr) )
	{
        hr = ( ulErrorCount ? DB_S_ERRORSOCCURRED : S_OK );
	}

	if( ulErrorCount >= cColumns)
	{
		hr = E_FAIL;
	}

	return hr;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Set the the values of the different columns. This is called when row is created directly
//	and not from rowset
/////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::SetRowData(DBORDINAL cColumns,DBCOLUMNACCESS   rgColumns[])
{ 			
	ULONG ulErrorCount = 0;
	HRESULT hr = S_OK;

	//=========================================================
	// Navigate through every element in the array, set
	// the value of the columns
	//=========================================================
	for (ULONG_PTR lIndex = 0 ; lIndex < cColumns ; lIndex++)
	{
		hr = SetColumnData(rgColumns[lIndex]);
			
		if ( hr != S_OK )
		{
			ulErrorCount++;
			hr = S_OK;
		}
	}

	if(SUCCEEDED(hr))
	{
		//==============================================
		// call this function to update the instance
		//==============================================
		hr = m_pMap->UpdateInstance(m_pInstance,FALSE);
	}

    if ( SUCCEEDED(hr) )
	{
        hr = ( ulErrorCount ? DB_S_ERRORSOCCURRED : S_OK );
	}

	if( ulErrorCount >= cColumns)
	{
		hr = E_FAIL;
	}

	return hr;

}



//////////////////////////////////////////////////////////////////////////////////////
// Open a rowset on a column which represents qualifiers or embeded classes
// NTRaid:111833
// 06/07/00
//////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::OpenChild(IUnknown *pUnkOuter,WCHAR *strColName ,REFIID riid, IUnknown **ppUnk,BOOL bIsChildRowset)
{
	HRESULT hr = S_OK;

	ULONG		cPropSets = 1;
	// NTRaid:111833
	// 06/13/00
	DBPROPSET*	prgPropertySets = NULL;
	DBPROPIDSET rgPropIDSet[1];
	VARIANT		varValue;
	VariantInit(&varValue);


	rgPropIDSet[0].cPropertyIDs		= 0;
	rgPropIDSet[0].guidPropertySet	= DBPROPSET_ROWSET;

	//==============================================================================
	// Get the properties set thru IDBBinderProperties
	//==============================================================================
	if(SUCCEEDED(hr = m_pUtilProp->GetProperties(PROPSET_ROWSET,0,rgPropIDSet, &cPropSets,&prgPropertySets)))
	{
		//==============================================================================
		// If the column refers to a rowset ( pointing to a qualifier) get the rowset
		//==============================================================================
		if(bIsChildRowset)
		{
			hr = GetChildRowet(pUnkOuter,strColName ,prgPropertySets,cPropSets,riid,ppUnk);
		}
		//======================
		// else get a row
		//======================
		else
		{
			hr = GetChildRow(pUnkOuter,strColName ,prgPropertySets,cPropSets,riid,ppUnk);
		}
	}
	//==========================================================================
	//  Free memory we allocated to by GetProperties
    //==========================================================================
	m_pUtilProp->m_PropMemMgr.FreeDBPROPSET( cPropSets, prgPropertySets);
	
	return hr;
}

///////////////////////////////////////////////////////////////
// Function to parse the column name to get the property name
// The returned pointer is to released by the caller
///////////////////////////////////////////////////////////////
WCHAR * CRow::GetPropertyNameFromColName(WCHAR *pColName)
{
	WCHAR *pQualiferSuffix = NULL;
	WCHAR *pPropName		  = NULL;

	try
	{
		pQualiferSuffix = new WCHAR[wcslen(SEPARATOR) + wcslen(QUALIFIER_) + 1];
	}
	catch(...)
	{
		SAFE_DELETE_ARRAY(pQualiferSuffix);
		throw;
	}
	
	if(pQualiferSuffix)
	{
		swprintf(pQualiferSuffix,L"%s%s",SEPARATOR,QUALIFIER_);
		if( wcsstr(pColName,pQualiferSuffix))
		{
			int nPropLen =  wcslen(pColName) - wcslen(pQualiferSuffix) +1;
			pPropName = new WCHAR [nPropLen];

			//NTRaid:111767 & NTRaid:111768
			// 06/07/00
			if(pPropName)
			{
				memset(pPropName,0,nPropLen * sizeof(WCHAR));
				memcpy(pPropName,pColName , (nPropLen-1) * sizeof(WCHAR));
			}
		}
		SAFE_DELETE_ARRAY(pQualiferSuffix);
	}
	
	return pPropName;
}


//////////////////////////////////////////////////////////////////////////////////////
// Function which get the embeded instance given the URL of the instance
//////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::GetEmbededInstancePtrAndSetMapClass(CURLParser *urlParser)
{
	BSTR strPath;
	BSTR strProperty;
	int  nIndex = 0;
	DWORD dwFlags = 0;
	WCHAR * strTableName;
	HRESULT hr = S_OK;

	urlParser->GetPath(strPath);
	urlParser->GetEmbededInstInfo(strProperty,nIndex);

	m_pInstance = (CWbemClassInstanceWrapper *)m_pMap->GetEmbededInstance(strPath,strProperty,nIndex);

	if( m_pInstance == NULL)
	{
		hr = E_FAIL;
	}
	else
	{
		//==================================================
		// Set the class name of the wmioledbmap function
		//==================================================
		strTableName = m_pInstance->GetClassName();
		hr = m_pMap->SetClass(strTableName);
		delete [] strTableName;

		SysFreeString(strPath);
		SysFreeString(strProperty);
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////////////
// Function to get a child row of the particular row which is pointed by a particular
// column
//////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::GetChildRow(	IUnknown *pUnkOuter,
							WCHAR *strColName,
							DBPROPSET *prgPropertySets,
							ULONG cPropSets,
							REFIID riid,
							IUnknown **ppUnk)
{
	HRESULT hr = S_OK;
	BSTR strPath,strTable , strURL;
	CURLParser urlParser;
	DBCOLUMNACCESS col;
	CRow *pChildRow = NULL;

	
	memset(&col,0,sizeof(DBCOLUMNACCESS));
	
	col.pData					= &strURL;
	col.columnid.eKind			= DBKIND_NAME;
	col.columnid.uName.pwszName = strColName;	  ;
	col.wType						= DBTYPE_BSTR;

	if(SUCCEEDED(hr = GetColumnData(col)))
	{
		urlParser.SetURL(strURL);
		urlParser.GetClassName(strTable);
		hr = urlParser.GetPathWithEmbededInstInfo(strPath);

		try
		{
			pChildRow = new CRow(pUnkOuter, m_pCreator);
		}
		catch(...)
		{
			SAFE_DELETE_PTR(pChildRow);
			throw;
		}

		if(SUCCEEDED(hr) && SUCCEEDED(hr = pChildRow->InitRow(strPath, strTable)))
		{
			hr = pChildRow->QueryInterface(riid, (void **)ppUnk);
		}
		SysFreeString(strTable);
		SysFreeString(strPath);
	}

	if(FAILED(hr))
	{
		SAFE_DELETE_PTR(pChildRow);
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////////////
// Function to get a child rowset of the particular row which is pointed by a particular
// column
//////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::GetChildRowet(IUnknown *pUnkOuter,
							WCHAR *strColName,
							DBPROPSET *prgPropertySets,
							ULONG cPropSets,
							REFIID riid,
							IUnknown **ppUnk)
{

	HRESULT hr = S_OK;
	CRowset *pChildRowset = NULL;
	int iOrdinal = 0;
	WCHAR *pPropName = NULL;
	ULONG lRsType = 0;

	lRsType = m_pMap->ParseQualifiedNameToGetColumnType(strColName);

	if(lRsType == WMI_PROPERTY_QUALIFIER)
	{
		//=============================================================
		// Get the name of the property for which the qualifiers are
		// to be retrieved as rowset
		//=============================================================
		pPropName = GetPropertyNameFromColName(strColName);
		lRsType = PROPERTYQUALIFIER;
	}
	else
	if(lRsType == WMI_CLASS_QUALIFIER)
	{
		lRsType = CLASSQUALIFIER;
	}

	
	if((pPropName != NULL && lRsType == PROPERTYQUALIFIER) ||
		lRsType == CLASSQUALIFIER)
	{
		try
		{
			//================================
			// Create a new rowset
			//================================
			pChildRowset = new CRowset(pUnkOuter,lRsType, pPropName,m_pCreator,m_pMap);
		}
		catch(...)
		{
			SAFE_DELETE_PTR(pChildRowset);
			throw;
		}
		
		// Initialize the rowset
		if( pChildRowset)
		if(S_OK == (hr = pChildRowset->InitRowsetForRow(pUnkOuter,cPropSets,prgPropertySets,m_pInstance)))
		{
			hr = pChildRowset->QueryInterface(riid , (void **)ppUnk);
		}

		SAFE_DELETE_ARRAY(pPropName);
	}
	else
	{
		hr = DB_E_BADCOLUMNID;
	}

	return hr;

}


////////////////////////////////////////////////////////////////////////////////////////
// Creates a new instance
// called from ICreateRow::CreateRow
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::CreateNewRow(CWbemClassInstanceWrapper **pNewInst)
{

	return m_pMap->AddNewInstance((CWbemClassWrapper **)pNewInst);

}

////////////////////////////////////////////////////////////////////////////////////////
// Function which gets all the key values from the URL and updates it to
// the new instance
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::UpdateKeysForNewInstance()
{
	HRESULT hr = S_OK;
	DBCOLUMNACCESS dbCol;
	SAFEARRAY *psaKeyPropNames;
	LONG lBound = 0 , uBound = 0;
	BSTR strProperty;
	LONG rgIndices[1];
	CURLParser urlParser;
	VARIANT		varKeyValue;
	CWbemClassWrapper * pTempInstance = NULL;

	VariantInit(&varKeyValue);

	urlParser.SetPath(m_strKey);

	memset(&dbCol,0,sizeof(DBCOLUMNACCESS));

	dbCol.columnid.eKind = DBKIND_NAME;
	dbCol.columnid.uName.pwszName = NULL;
	dbCol.cbDataLen = -1;
	dbCol.wType		= DBTYPE_VARIANT | DBTYPE_BYREF;

	// Get the propertynames of the key values
	hr = m_pMap->GetKeyPropertyNames(&psaKeyPropNames);

	// Get the bounds of the array returned
	hr = SafeArrayGetLBound(psaKeyPropNames,1,&lBound);
	hr = SafeArrayGetUBound(psaKeyPropNames,1,&uBound);

	// Navigate thru every element of the array
	for( int nIndex = lBound ; nIndex <= uBound  ; nIndex++)
	{
		rgIndices[0] = nIndex;
		hr = SafeArrayGetElement(psaKeyPropNames,&rgIndices[0],(void *)&strProperty);		

		// Get the value of the key from the URL
		if(SUCCEEDED(hr = urlParser.GetKeyValue(strProperty,varKeyValue)))
		{

			dbCol.columnid.uName.pwszName	= (WCHAR *)strProperty;
			dbCol.pData						= &varKeyValue;

			hr = SetColumnData(dbCol,TRUE);

			VariantClear(&varKeyValue);

			if(hr != S_OK)
			{
				break;
			}
	   	}
	}

	// Destroy the array created
	SafeArrayDestroy(psaKeyPropNames);

	if(SUCCEEDED(hr))
	{
		// call this function to save the new instance
		hr = m_pMap->UpdateInstance(m_pInstance,TRUE);
	}

	// The instance may be created, but we have to
	// check if the URL passed identifies the row , if no
	// then return error
	if( hr == S_OK)
	{
		// Convert it into upper case
		pTempInstance = m_pMap->GetInstance(m_strKey);
		if(pTempInstance == NULL)
		{
			hr = DB_E_NOTFOUND;
		}
		else
		{
			m_pInstance = (CWbemClassInstanceWrapper *)pTempInstance;
		}
	}

	// Delete the instance created if there
	// any failure in the process of creating new instance
	if(FAILED(hr))
	{
		m_pMap->DeleteInstance(m_pInstance);
		m_pInstance = NULL;
		hr = DB_E_NOTFOUND;
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
// Function to open a row pointed by the URL
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::OpenRow(LPCOLESTR pwszURL,IUnknown * pUnkOuter,REFIID riid,IUnknown** ppOut)
{
	HRESULT		hr				= S_OK;
	LONG		lObjType		= -1;
	CRow *		pRow			= NULL;
	CURLParser	urlParser;
	CBSTR		bstrTemp;
	CBSTR		bstrPath;
	CBSTR		bstrClassName;


	bstrTemp.SetStr((LPWSTR)pwszURL);
	urlParser.SetURL((BSTR)bstrTemp);
	lObjType = urlParser.GetURLType();

	switch(lObjType)
	{
		case URL_ROW:
			{
				urlParser.GetPath((BSTR &)bstrPath);
				urlParser.GetClassName((BSTR &)bstrClassName);
			}
			break;

		case -1 :
			{
				hr = DB_E_NOTFOUND;
				break;
			}

		default:
			{
				urlParser.GetPath((BSTR &)bstrPath);
				break;
			}

	}

	if(SUCCEEDED(hr))
	{
		try
		{
			pRow = new CRow(pUnkOuter,m_pCreator);
		}
		catch(...)
		{
			SAFE_DELETE_PTR(pRow);
		}


		if(SUCCEEDED(hr))
		{
			hr = pRow->InitRow(bstrPath,bstrClassName,GetQualifierFlags(),ROWOPEN);
		}

		if(SUCCEEDED(hr))
		{
			DBPROPSET*	prgPropertySets;
			DBPROPIDSET rgPropIDSet[1];
			ULONG		cPropSets		= 1;

			rgPropIDSet[0].cPropertyIDs		= 0;
			rgPropIDSet[0].guidPropertySet	= DBPROPSET_ROWSET;
			//==============================================================================
			// Get the properties set thru of the current row and set it on the rowset
			//==============================================================================
			if(SUCCEEDED(hr = m_pUtilProp->GetProperties(PROPSET_ROWSET,0,rgPropIDSet, &cPropSets,&prgPropertySets)))
			{
				hr = pRow->SetRowProperties(cPropSets,prgPropertySets);
			}
			
			//==========================================================================
			//  Free memory we allocated to by GetProperties
			//==========================================================================
			m_pUtilProp->m_PropMemMgr.FreeDBPROPSET( cPropSets, prgPropertySets);

			if(FAILED(hr = pRow->QueryInterface(riid,(void **)ppOut)))
			{
				SAFE_DELETE_PTR(pRow);
				*ppOut = NULL;
			}
		}
	}


	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
// Function to open a rowset which contains instance of container/scope
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::OpenRowset(LPCOLESTR pwszURL,
						 IUnknown * pUnkOuter,
						 REFIID riid,
						 BOOL bContainer,
						 IUnknown** ppOut,
						 ULONG cPropertySets,
						 DBPROPSET __RPC_FAR rgPropertySets[])
{
	HRESULT		hr				= S_OK;
	WCHAR *		pstrPath		= NULL;
	ULONG		cPropSets		= 1;
	CRowset *	pRowset			= NULL;
	DBPROPIDSET rgPropIDSet[1];
	VARIANT		varValue;
	VariantInit(&varValue);
	WCHAR *		pstrTemp		= NULL;
	WCHAR *		pStrRelPath		= NULL;
	LPWSTR		pStrObjectToOpen = NULL;

	rgPropIDSet[0].cPropertyIDs		= 0;
	rgPropIDSet[0].guidPropertySet	= DBPROPSET_ROWSET;


	pRowset = new CRowset(pUnkOuter,m_pCreator,m_pCon);
	if(!pRowset)
	{
		hr = E_OUTOFMEMORY;
	}

	if(SUCCEEDED(hr))
	{
		INSTANCELISTTYPE ObjInstListType = GetObjectTypeProp(cPropertySets, rgPropertySets);
		
		WCHAR	*	pStrPath = NULL;
		CURLParser  urlParser;
		CBSTR		bstrTemp;
		if(!bContainer)
		{
			// Get the relative path of the current object
			if(SUCCEEDED(hr = m_pMap->GetRelativePath(m_pInstance,pStrRelPath)))
			{
				//===========================================
				// If URL is passed open rowset on the URL
				//===========================================
				if(pwszURL == NULL)
				{	
					pstrTemp = pStrRelPath;	
				}
				//===========================================
				// else get URL of the current row
				//===========================================
				else
				{
					pstrTemp = new WCHAR[wcslen(pStrRelPath) + wcslen(pwszURL) + wcslen(PATHSEPARATOR) + 1];
					if(pstrTemp)
					{
						wcscpy(pstrTemp,pStrRelPath);
						wcscat(pstrTemp,PATHSEPARATOR);
						wcscat(pstrTemp,pwszURL);
						SAFE_DELETE_ARRAY(pStrRelPath);
						pStrRelPath = pstrTemp;
					}
					else
					{
						hr = E_OUTOFMEMORY;
					}
				}
			}
		}
		else
		{
			CBSTR strObjPath;
			VARIANT varDataSource;
			VariantInit(&varDataSource);

			if(m_pCon)
			{
				if(SUCCEEDED(hr = m_pCon->GetNodeName(varDataSource.bstrVal)))
				{
					varDataSource.vt = VT_BSTR;
				}
			}
			else
			{

				if(SUCCEEDED(hr 	= m_pCreator->GetDataSrcProperty(DBPROP_INIT_DATASOURCE,varDataSource)) && 
					varDataSource.vt == VT_BSTR && varDataSource.bstrVal != NULL )
				{
					hr = S_OK;
				}
				else
				{
					hr = E_UNEXPECTED;
				}
			}

			if(SUCCEEDED(hr))
			{
				m_pMap->GetInstanceKey(m_pInstance,strObjPath);
				if(strObjPath != NULL && _wcsicmp(strObjPath,varDataSource.bstrVal) != 0)
				{
					hr = m_pMap->GetRelativePath(m_pInstance,pStrObjectToOpen);
				}
				else
				{
					pStrObjectToOpen = NULL;
				}
			}
			VariantClear(&varDataSource);
			pstrTemp = (WCHAR *)pwszURL;
		}
		
/*		bstrTemp.SetStr(pstrTemp);
		urlParser.SetURL((BSTR)bstrTemp);
		bstrTemp.Clear();
		urlParser.GetPath((BSTR &)bstrTemp);
*/
		if(SUCCEEDED(hr))
		{
//			pStrPath = new WCHAR[SysStringLen(bstrTemp) + 1];

//			if(pStrPath)
			{
//				memset(pStrPath , 0 , (SysStringLen(bstrTemp) + 1) * sizeof(WCHAR));
//				memcpy(pStrPath,bstrTemp,SysStringLen(bstrTemp) * sizeof(WCHAR));
				//==========================================================================
				// Call this function to open the object pointed by the URL as scope or 
				// container
				//==========================================================================
				hr = pRowset->InitRowset(cPropertySets,rgPropertySets,pstrTemp,pStrObjectToOpen,ObjInstListType);

				SAFE_DELETE_ARRAY(pStrPath);
			}
/*			else
			{
				hr = E_OUTOFMEMORY;
			}
*/		}
	}

	if(SUCCEEDED(hr))
	{
		if(FAILED(hr = pRowset->QueryInterface(riid,(void **)ppOut)))
		{
			SAFE_DELETE_PTR(pRowset);
			*ppOut = NULL;
		}
	}
	else
	{
		SAFE_DELETE_PTR(pRowset);
		*ppOut = NULL;
	}

	SAFE_DELETE_ARRAY(pStrObjectToOpen);
	SAFE_DELETE_ARRAY(pStrRelPath);
	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
// Function to set properties of the row
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::SetRowProperties(const ULONG cPropertySets, const DBPROPSET	rgPropertySets[] )
{
    HRESULT hr = S_OK;
	VARIANT varPropVal;
	VariantInit(&varPropVal);
	LONG lFlag = 0;

 	// call the base class implementation for setting properties
	hr = SetProperties(cPropertySets,rgPropertySets);

    //============================================================================
	// call this function to set the DBPROP_UPDATIBILITY to readonly if the Datasource
	// open mode is readonly
    //============================================================================
	if( (hr == S_OK) ||   (hr == DB_S_ERRORSOCCURRED) )
	{
		SynchronizeDataSourceMode();
	}

	return hr;
	
}

////////////////////////////////////////////////////////////////////////////////////////
// Function to delete/unlink objects from scope/container
// Object will be deleted if the current object is opened as scope
// object will be unlinked from the current object is opened as container
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::Delete(LPCOLESTR lpszURL,DWORD dwDeleteFlags,DBSTATUS &dbStatus)
{
	HRESULT hr = S_OK;
	BOOL	bContainer = FALSE;
	CURLParser urlParser;
	CBSTR		strTemp;
	
	dbStatus = DBSTATUS_S_OK;

	strTemp.SetStr((LPWSTR)lpszURL);

	urlParser.SetURL(strTemp);

	strTemp.Unbind();
	strTemp.Clear();

	urlParser.GetPath((BSTR &)strTemp);
	
	bContainer = IsContainer();
	if(bContainer)
	{
		CBSTR strContainer;
		strContainer.SetStr(m_strKey);
		//==============================================================
		// call this function to unlink object pointed by strTemp
		// from object pointed by m_strPath acting as container
		//==============================================================
		if(FAILED(hr = m_pMap->UnlinkObjectFromContainer(strContainer,strTemp)))
		{
			dbStatus = DBSTATUS_E_UNAVAILABLE;
		}

	}
	else
	{
		//==============================================================
		// Get the instance pointed by the path and then
		// delete the object
		//==============================================================
		CWbemClassWrapper *pInstToDelete = NULL;
		pInstToDelete = m_pMap->GetInstance(strTemp);
		if(pInstToDelete)
		{
			hr = m_pMap->DeleteInstance(pInstToDelete);
		}
		else
		{
			dbStatus = DBSTATUS_E_UNAVAILABLE;
		}
	}	// else
	

	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////
// Function to move object from one container to another
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::MoveObjects(WCHAR * pStrDstURL,WCHAR * pstrSrcURL, WCHAR *& pNewURL,DBSTATUS &dbStatus)
{
	HRESULT hr = S_OK;
	BOOL	bContainer = FALSE;
	CBSTR		strSrcObj,strDstObj;

	dbStatus = DBSTATUS_S_OK;

	//============================================================
	// Get the Path string for source and destination objects
	//============================================================
	strSrcObj.SetStr(pstrSrcURL);
	if(GetPathFromURL((BSTR &)strSrcObj))
	{
		strDstObj.SetStr(pStrDstURL);
		if(GetPathFromURL((BSTR &)strDstObj))
		{
			hr = E_FAIL;
			dbStatus = DBSTATUS_E_INVALIDURL;
		}
	}
	else
	{
		hr = E_FAIL;
		dbStatus = DBSTATUS_E_INVALIDURL;
	}

	if(SUCCEEDED(hr))
	{
		
		CBSTR strContainer;
		strContainer.SetStr(m_strKey);

		//==============================================================
		// call this function to unlink object pointed by strSrcObj
		// from object pointed by m_strPath acting as container
		//==============================================================
		if(FAILED(hr = m_pMap->UnlinkObjectFromContainer(strContainer,strSrcObj)))
		{
			dbStatus = DBSTATUS_E_UNAVAILABLE;
		}
		else
		//==============================================================
		// call this function to link object pointed by strSrcObj
		// to object pointed by strDstObj acting as container
		//==============================================================
		if(FAILED(hr = m_pMap->LinkObjectFromContainer(strDstObj,strSrcObj)))
		{
			dbStatus = DBSTATUS_E_UNAVAILABLE;
		}
		
		try
		{
			pNewURL = new WCHAR[wcslen(pstrSrcURL) +1];
		}
		catch(...)
		{
			SAFE_DELETE_ARRAY(pNewURL);
			throw;
		}
		if(pNewURL)
		{
			//==============================================================
			// URL of the object does not change as this is just a move of
			// object from one container to another
			//==============================================================
			wcscpy(pNewURL,pstrSrcURL);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}		
	}	// If succeeded(hr)

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
// Function to get Path from URL string
////////////////////////////////////////////////////////////////////////////////////////
BOOL CRow::GetPathFromURL(BSTR &str)
{
	BOOL		bRet		= FALSE;
	CURLParser	urlParser;

	if(SUCCEEDED( urlParser.SetURL(str)))
	{
		SysFreeString(str);
		urlParser.GetPath(str);
		bRet = TRUE;
	}

	return bRet;
}

////////////////////////////////////////////////////////////////////////////////////////
// Function to check if the current object is to be considered as Scope/Container
////////////////////////////////////////////////////////////////////////////////////////
BOOL CRow::IsContainer()
{
	VARIANT vValue;
	BOOL	bRet	= FALSE;
	VariantInit(&vValue);

	if(SUCCEEDED(GetRowsetProperty(DBPROP_WMIOLEDB_OBJECTTYPE,vValue)))
	{
		bRet = (V_I4(&vValue) == DBPROPVAL_CONTAINEROBJ) ? TRUE : FALSE;
	}

	return bRet;
}



////////////////////////////////////////////////////////////////////////////////////////
// Function to move object from one container to another
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::CopyObjects(WCHAR * pStrDstURL,WCHAR * pstrSrcURL, WCHAR *& pNewURL,DBSTATUS &dbStatus)
{
	HRESULT hr = S_OK;
	BOOL	bContainer = FALSE;
	CBSTR		strSrcObj,strDstObj;

	dbStatus = DBSTATUS_S_OK;

	//============================================================
	// Get the Path string for source and destination objects
	//============================================================
	strSrcObj.SetStr(pstrSrcURL);
	if(GetPathFromURL((BSTR &)strSrcObj))
	{
		strDstObj.SetStr(pStrDstURL);
		if(GetPathFromURL((BSTR &)strDstObj))
		{
			hr = E_FAIL;
			dbStatus = DBSTATUS_E_INVALIDURL;
		}
	}
	else
	{
		hr = E_FAIL;
		dbStatus = DBSTATUS_E_INVALIDURL;
	}

	if(SUCCEEDED(hr))
	{
		WCHAR * pstrNewPath = NULL;
		if(IsContainer())
		{
			//==============================================================
			// call this function to link object pointed by strSrcObj
			// to object pointed by strDstObj acting as container
			//==============================================================
			hr = m_pMap->LinkObjectFromContainer(strDstObj,strSrcObj);
			pstrNewPath = pstrSrcURL;
		}
		else
		{
			// Memory for pstrNewPath will be allocated in this function
			hr = m_pMap->CloneAndAddNewObjectInScope(strSrcObj,strDstObj,pstrNewPath);
		}
			
			
		if(FAILED(hr))
		{
			dbStatus = DBSTATUS_E_UNAVAILABLE;
		}
		
		try
		{
			pNewURL = new WCHAR[wcslen(pstrSrcURL) +1];
		}
		catch(...)
		{
			SAFE_DELETE_ARRAY(pNewURL);
			if(!IsContainer())
			{
				SAFE_DELETE_ARRAY(pstrNewPath);
			}
			throw;
		}
		if(pNewURL)
		{
			//==============================================================
			// URL of the object does not change as this is just a move of
			// object from one container to another
			//==============================================================
			wcscpy(pNewURL,pstrSrcURL);

		}
		else
		{
			hr = E_OUTOFMEMORY;
		}		

		if(!IsContainer())
		{
			SAFE_DELETE_ARRAY(pstrNewPath);
		}

	}	// If succeeded(hr)

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to fetch IUnknown properties
// NTRaid:135384
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRow::GetIUnknownColumnValue(DBORDINAL iCol,REFIID riid,IUnknown ** ppUnk,LPCWSTR pStrColName)
{
    ROWBUFF     *	pRowBuff	= NULL;
    COLUMNDATA *	pColumnData = NULL;
	void *			pSrc		= NULL;
	BSTR			strProp		= NULL;
    DBTYPE			dwDataType	= 0;
	BYTE *			pTemp		= NULL;
    DBLENGTH		uDatLength	= 0;
	DWORD			dwFlags		= 0;
	HRESULT			hr			= S_OK;
	BOOL			bGetData	= TRUE;

	*ppUnk = NULL;
	if(m_pSourcesRowset)
	{
		// if the column is part of the parent rowset then get data from the parent rowset's buffer
		if(iCol == m_pSourcesRowset->GetOrdinalFromColName((WCHAR *)pStrColName))
		{
			// Set this flag that data to be retrieved is identified
			bGetData = FALSE;
			//=========================================================
			// if data is not yet received then fetch the data
			//=========================================================
			if(S_OK != m_pSourcesRowset->IsSlotSet(m_hRow))
			{
				hr = m_pSourcesRowset->GetData(m_hRow);
			}
			if( (m_pSourcesRowset->m_ulProps & OTHERUPDATEDELETE) &&(m_pSourcesRowset->m_ulLastFetchedRow != m_hRow))
			{
				if(SUCCEEDED(hr = m_pSourcesRowset->GetDataToLocalBuffer(m_hRow)))
				{
					m_pSourcesRowset->m_ulLastFetchedRow = m_hRow;
				}
			}

			pRowBuff = m_pSourcesRowset->GetRowBuff(m_hRow , TRUE);
			pColumnData = (COLUMNDATA *) ((BYTE *) pRowBuff + m_pSourcesRowset->m_Columns.GetDataOffset(iCol));


			pSrc           = (pColumnData->pbData);
			if(pSrc != NULL)
			{
				hr = (*(IUnknown **)pSrc)->QueryInterface(riid,(void **)ppUnk);
			}
		}
	}
	
	if(bGetData)
	{
		strProp = Wmioledb_SysAllocString(pStrColName);
		hr = m_pMap->GetProperty(m_pInstance,strProp, pTemp,dwDataType ,uDatLength, dwFlags );
		
		if(SUCCEEDED(hr) && dwDataType == DBTYPE_IUNKNOWN && pTemp != NULL)
		{
			hr = (*(IUnknown **)pTemp)->QueryInterface(riid,(void **)ppUnk);
		}
		SAFE_FREE_SYSSTRING(strProp);

	}

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\rowinfo.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// IRowsetInfo interface implementation
//
/////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"

/////////////////////////////////////////////////////////////////////////////////////////
//
// Returns an interface pointer to the rowset to which the bookmark applies
//
// HRESULT
//		E_INVALIDARG		        ppReferencedRowset was NULL
//		DB_E_BADORDINAL	            iOrdinal was greater than number of columns in rowset
//      DB_E_NOTAREFERENCECOLUMN    This rowset does not support bookmarks
//
/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIRowsetInfo::GetReferencedRowset ( DBORDINAL	iOrdinal,			//IN	Bookmark Column
													REFIID		riid,				// IN	 ID of the interface pointer to return
													IUnknown **	ppReferencedRowset	// OUT  IRowset Interface Pointer
    )
{
	HRESULT hr = DB_E_BADROWHANDLE;

    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;


 	if( ppReferencedRowset )
		*ppReferencedRowset = NULL;

	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
    //========================================================================
	// Check Arguments
    //========================================================================
    if( ppReferencedRowset == NULL ){
		hr = E_INVALIDARG;
    }
    else{

		if(iOrdinal == 0 && (m_pObj->m_ulProps & BOOKMARKPROP))
			hr = this->QueryInterface(riid,(void **)ppReferencedRowset);
		else
		{
			//========================================================================
			// The oridinal was greater than the number of columns that we have.
			//========================================================================
			if ( ( iOrdinal == 0 ) || ( iOrdinal > m_pObj->m_cTotalCols ) ){
				hr = DB_E_BADORDINAL;
			}
			else{

					hr = m_pObj->GetChildRowset(iOrdinal,riid,ppReferencedRowset);
   
				//====================================================================
    			// Since we don't support bookmarks, this will alway return an error
				//====================================================================
	//            hr = DB_E_NOTAREFERENCECOLUMN;
			}
		}
    }
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetInfo);
	
	CATCH_BLOCK_HRESULT(hr,L"IRowsetInfo::GetReferencedRowset");
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// Returns current settings of all properties supported by the rowset
//
// HRESULT
//      S_OK           The method succeeded
//      E_INVALIDARG   pcProperties or prgProperties was NULL
//      E_OUTOFMEMORY  Out of memory
//
/////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CImpIRowsetInfo::GetProperties  (   const ULONG         cPropertySets,		//IN  # of property sets
                        const DBPROPIDSET	rgPropertySets[],	//IN  Array of DBPROPIDSET
                        ULONG*              pcProperties,		//OUT count of properties returned
                        DBPROPSET**			prgProperties		//OUT property information returned
    )
{
	assert( m_pObj );
    assert( m_pObj->m_pUtilProp );
	HRESULT hr = S_OK;

    CSetStructuredExceptionHandler seh;


	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());

    // Clear Error information
	g_pCError->ClearErrorInfo();

	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
	{
		//===============================================================
		// Check Arguments
		//===============================================================
		hr = m_pObj->m_pUtilProp->GetPropertiesArgChk(PROPSET_ROWSET, cPropertySets, 
									rgPropertySets, pcProperties, prgProperties);
		if ( SUCCEEDED(hr) ){

			//===============================================================
			// just pass this call on to the utility object that manages our
			// properties
			//===============================================================
			hr = m_pObj->m_pUtilProp->GetProperties( PROPSET_ROWSET, cPropertySets, rgPropertySets, pcProperties, prgProperties );
		}
	}

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetInfo);

	CATCH_BLOCK_HRESULT(hr,L"IRowsetInfo::GetProperties");
    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
// Returns the interface pointer of the object that created the rowset
//
// HRESULT
//      S_OK           Method Succeeded
//      E_INVALIDARG   Invalid parameters were specified
//
/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIRowsetInfo::GetSpecification ( REFIID   riid,      IUnknown **ppSpecification  )
{
	HRESULT hr = S_OK;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(ROWSET->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();

	if(m_pObj->IsZoombie())
	{
		hr = E_UNEXPECTED;
	}
	else
    if ( ppSpecification == NULL ){
        hr = E_INVALIDARG ;
    }
    else{

        // we do not have an interface pointer on the object that created this rowset, yet.
        *ppSpecification = NULL;

		if(m_pObj->m_pParentCmd)
		{
		    hr = m_pObj->m_pParentCmd->GetOuterUnknown()->QueryInterface (riid,(void**)ppSpecification);
		}
		else
	    if ( m_pObj->m_pCreator ){
		    assert(m_pObj->m_pCreator->GetOuterUnknown());
		    hr = m_pObj->m_pCreator->GetOuterUnknown()->QueryInterface (riid,(void**)ppSpecification);
	    }
    }

	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_IRowsetInfo);

	CATCH_BLOCK_HRESULT(hr,L"IRowsetInfo::GetSpecification");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\rowdatamgr.cpp ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CRowDataMemMgr class implementation - Implements class to maintain rows
// 
//
///////////////////////////////////////////////////////////////////////////////////

#include "headers.h"



///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Constructor
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
CRowDataMemMgr::CRowDataMemMgr()
{
    m_prgpColumnData = NULL;
    m_nCurrentIndex =1;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Destructor
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
CRowDataMemMgr::~CRowDataMemMgr()
{
    SAFE_DELETE_PTR(m_prgpColumnData);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ReAllocate the rowdata 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowDataMemMgr::ReAllocRowData()
{
    HRESULT hr = S_OK;

    DBCOUNTITEM cNewCols = m_cbTotalCols + DEFAULT_COLUMNS_TO_ADD;
    DBCOUNTITEM cOldCols = m_cbTotalCols;

    //==================================================
	// save the old buffer ptrs
    //==================================================
    PCOLUMNDATA *pOldList = m_prgpColumnData;

    hr = AllocRowData((ULONG_PTR)cNewCols);
    if( S_OK == hr ){
        //==============================================
        // copy what we have so far
        //==============================================
		memcpy(m_prgpColumnData,pOldList,cOldCols * sizeof(PCOLUMNDATA));
        m_nCurrentIndex = cOldCols;
        SAFE_DELETE_ARRAY(pOldList);
	}
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Reset the index of the class
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowDataMemMgr::ResetColumns()
{
    m_nCurrentIndex = 1;
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Allocate memory for the given number of columns
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowDataMemMgr::AllocRowData(ULONG_PTR cCols)
{
    HRESULT hr = E_OUTOFMEMORY;

	m_cbTotalCols = cCols ;
	
	m_prgpColumnData = new PCOLUMNDATA[m_cbTotalCols];

	if(m_prgpColumnData)
	{
		for( int nIndex = 0 ; nIndex < (int)m_cbTotalCols ; nIndex++)
		{
			m_prgpColumnData[nIndex] = NULL;
		}
		if ( m_prgpColumnData == NULL ){
			hr = E_INVALIDARG;
		}
		else
		{
			//====================================================================
			//  Set all ptrs to the beginning
			//====================================================================
			ResetColumns();
			hr = S_OK;
		}
	} 
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set the the current column data
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowDataMemMgr::CommitColumnToRowData(CVARIANT & vVar,DBTYPE lType)
{
    HRESULT hr = S_OK;
    //==============================================================
    // Set the offset from the start of the row, for this column, 
    // then advance past.
    //==============================================================
    if( m_nCurrentIndex > m_cbTotalCols ){
        hr = ReAllocRowData();
    }
    
	if(SUCCEEDED(hr))
	{
		if(SUCCEEDED(hr = m_prgpColumnData[m_nCurrentIndex]->SetData(vVar,lType)))
		{
			m_nCurrentIndex++;
		}
	}
	
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Commit the column data for the column of given index
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowDataMemMgr::CommitColumnToRowData(CVARIANT & vVar, DBORDINAL nIndex,DBTYPE lType)
{
    HRESULT hr = S_OK;
    //==============================================================
    // Set the offset from the start of the row, for this column, 
    // then advance past.
    //==============================================================
    if( nIndex > m_cbTotalCols ){
        hr = ReAllocRowData();
    }

	// NTRaid:111829
	// 06/13/00
	if(SUCCEEDED(hr))
	{
		//=============================================
		// release the previously allocated data
		//=============================================
		m_prgpColumnData[nIndex]->ReleaseColumnData();
		hr = m_prgpColumnData[nIndex]->SetData(vVar,lType);
	}

    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// bind the memory pointers of the column data
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowDataMemMgr::SetColumnBind( DBORDINAL dwCol, PCOLUMNDATA pColumn )
{
    HRESULT hr = S_OK;
    //=====================================================================
    // If the column number is in range then return the pointer
    //=====================================================================
//    if ((0 == dwCol) || (m_cbTotalCols < (ULONG)dwCol)){
    if ( (m_cbTotalCols < (ULONG)dwCol)){
        hr = E_FAIL;
    }
    else{
			
	        assert( pColumn );
			m_prgpColumnData[dwCol] = pColumn;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Free the data allocated for the row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CRowDataMemMgr::ReleaseRowData()
{
	ResetColumns();
	ReleaseBookMarkColumn();
	while(m_nCurrentIndex < m_cbTotalCols)
	{
		m_prgpColumnData[m_nCurrentIndex++]->ReleaseColumnData();
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Free the data allocated for the row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CRowDataMemMgr::ReleaseBookMarkColumn()
{
	m_prgpColumnData[0]->ReleaseColumnData();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\rowset.cpp ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CRowset object implementation
// 
//
///////////////////////////////////////////////////////////////////////////////////

#include "headers.h"
#include "WmiOleDBMap.h"


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CRowset::CRowset(LPUNKNOWN pUnkOuter,PCDBSESSION pObj,CWbemConnectionWrapper *pCon )  : CBaseRowObj( pUnkOuter)
{
	//===============================================================
    //  Initialize simple member vars
	//===============================================================
    InitVars();
	m_pCreator = pObj;     
	m_pCreator->GetOuterUnknown()->AddRef();
	//===============================================
	// Add this rowset ot list of open rowset
	//===============================================
	m_pCreator->AddRowset(this);

	m_pCon = pCon;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor for this class , Initializing recordset for Qualifiers
//
/////////////////////////////////////////////////////////////////////////////////////////////////
CRowset::CRowset(LPUNKNOWN pUnkOuter,ULONG uQType, LPWSTR PropertyName,PCDBSESSION pObj , CWmiOleDBMap *pMap) : CBaseRowObj(NULL)
{

	//===============================================================
    //  Initialize simple member vars
	//===============================================================
    InitVars();

	m_pCreator = pObj;     
	m_pCreator->GetOuterUnknown()->AddRef();
	//===============================================
	// Add this rowset ot list of open rowset
	//===============================================
	m_pCreator->AddRowset(this);

	m_pMap = pMap;
	m_pMap->AddRef();

	//======================================================================
	// set the flag which indicates that this Rowset is a child recordsets;
	//======================================================================
	m_bIsChildRs = TRUE;

	// Initializing the Qualifier properties
	m_uRsType =  uQType;
	if ( m_uRsType == PROPERTYQUALIFIER)
	{
		m_strPropertyName = Wmioledb_SysAllocString(PropertyName);
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to Initialize all the member variables
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CRowset::InitVars()
{
    m_cCols = m_cCols = m_cNestedCols = 0L;

	//===============================================================
	// set the flag which indicates that this Rowset is not a child rowset
	//===============================================================
	m_bIsChildRs = FALSE;

	//===============================================================
	// Intialize buffered row count + pointers to allocated memory
	//===============================================================
	m_cRows					= 0;
	m_cbRowSize				= 0;
	m_irowMin				= 0;
	m_ulRowRefCount			= 0;
	m_dwStatus				= 0;

    m_bHelperFunctionCreated= FALSE;

	m_hLastChapterAllocated = 0;
	m_ulProps				= 0;
	m_ulLastFetchedRow		= 0;
	m_hRow					= 0;
    m_uRsType				= 0;
	m_cRef					= 0L;
	m_bIsChildRs			= FALSE;

	m_FetchDir				= FETCHDIRNONE;
	m_lLastFetchPos			= 0;
	m_lRowCount				= -1;

	m_hRowLastFetched		= 0;
	//===============================================================
	//  Initially, NULL all contained interfaces
	//===============================================================
	m_pIAccessor            = (PIMPIACCESSOR)NULL;
	m_pIColumnsInfo         = NULL;
	m_pIConvertType			= NULL;
	m_pIRowset              = NULL;
	m_pIRowsetChange        = NULL;
	m_pIRowsetIdentity      = NULL;
	m_pIRowsetInfo          = NULL;
	m_pIChapteredRowset		= NULL;
	m_pIGetRow				= NULL;
	m_pIRowsetRefresh		= NULL;
	m_pRowFetchObj			= NULL;
	m_ppChildRowsets		= NULL;
	m_pInstance				= NULL;
	m_pParentCmd			= NULL;
	m_pIBuffer				= NULL;
	m_pLastBindBase			= NULL;
	m_pRowData				= NULL;
	m_pUtilProp				= NULL;
	m_pChapterMgr			= NULL;
	m_pMap					= NULL;
	m_pCreator				= NULL;     
	m_pHashTblBkmark		= NULL;
	m_InstMgr				= NULL;
	m_pISupportErrorInfo	= NULL;

	//===============================================================
	// Increment global object count.
	//===============================================================
	InterlockedIncrement(&g_cObj);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Destructor for this class
/////////////////////////////////////////////////////////////////////////////////////////////////
CRowset::~CRowset( void )
{

	//==============================================================
	// Release all the open Rows
	//==============================================================
	ReleaseAllRows();

	//================================================
	// If Slot list is allocated, release them
	//================================================
    if (NULL != m_pIBuffer)
	{
        ReleaseSlotList( m_pIBuffer );
	}

	if ( m_uRsType == PROPERTYQUALIFIER)
	{
		 SysFreeString(m_strPropertyName);
	}

    
	//===============================================================
	// Free pointers.
	//===============================================================

    SAFE_DELETE_PTR( m_pUtilProp );
    //===============================================================
    //  NOTE:  m_pMap releases the class ptr in destructor
    //===============================================================
	m_pMap->Release();


	SAFE_DELETE_PTR(m_pHashTblBkmark);

	//===============================================================
    //  Free contained interfaces
	//===============================================================
    SAFE_DELETE_PTR( m_pIAccessor );
    SAFE_DELETE_PTR( m_pIColumnsInfo );
    SAFE_DELETE_PTR( m_pIConvertType );
    SAFE_DELETE_PTR( m_pIRowset );
    SAFE_DELETE_PTR( m_pIRowsetChange );
    SAFE_DELETE_PTR( m_pIRowsetIdentity );
    SAFE_DELETE_PTR( m_pIRowsetInfo );
    SAFE_DELETE_PTR( m_pIChapteredRowset);
	SAFE_DELETE_PTR( m_pIGetRow);
	SAFE_DELETE_PTR( m_pIRowsetRefresh);
	SAFE_DELETE_PTR(m_pISupportErrorInfo);

    SAFE_DELETE_PTR(m_pRowData);
    SAFE_DELETE_PTR(m_pRowFetchObj);
    SAFE_DELETE_PTR(m_InstMgr);


	//===============================================================
	// Decrement the DBSession Count.  GetSpecification is not 
    // possible anymore
	//===============================================================
    if( m_pCreator )
	{
                                
		m_pCreator->GetOuterUnknown()->Release();
	}


	//===============================================================
	// If rowset is created by command then, decrement the number of rowsets
	// opened by the rowset and release the command pointer
	//===============================================================
	if(m_pParentCmd != NULL)
	{
		m_pParentCmd->DecrementOpenRowsets();
		m_pParentCmd->GetOuterUnknown()->Release();
	}

	SAFE_DELETE_PTR(m_pChapterMgr);

	//================================================
	// Release child rowsets 
	//================================================
	if(m_ppChildRowsets != NULL)
	{
		for(UINT nIndex = 0 ; nIndex < m_cTotalCols ; nIndex++)
		{
			if(m_ppChildRowsets[nIndex] != NULL)
			{
				m_ppChildRowsets[nIndex]->Release();
			}
		}
		delete m_ppChildRowsets;
	}

	if(m_bNewConAllocated)
	{
		SAFE_DELETE_PTR(m_pCon);
	}
	
	//===============================================================
    // Decrement global object count.
	//===============================================================
    InterlockedDecrement(&g_cObj);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns a pointer to a specified interface. Callers use QueryInterface to determine which 
// interfaces the called object supports. 
//	Sucess of QI for some of the interfaces depend on some of the properties
//
// HRESULT indicating the status of the method
//      S_OK            Interface is supported and ppvObject is set.
//      E_NOINTERFACE   Interface is not supported by the object
//      E_INVALIDARG    One or more arguments are invalid.
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CRowset::QueryInterface ( REFIID riid, LPVOID * ppv  )
{
    HRESULT hr = S_OK;


    //======================================================
    //  Check parameters, if not valid return
    //======================================================
    if (NULL == ppv)
	{
        hr = E_INVALIDARG ;
    }
	else
	{

		//======================================================
		//  Place NULL in *ppv in case of failure
		//======================================================
		*ppv = NULL;

		//======================================================
		//  This is the non-delegating IUnknown implementation
		//======================================================
		if (riid == IID_IUnknown)
		{
			*ppv = (LPVOID) this;
		}
		else if (riid == IID_IAccessor)
		{
			*ppv = (LPVOID) m_pIAccessor;
		}
		else if (riid == IID_IColumnsInfo)
		{
			*ppv = (LPVOID) m_pIColumnsInfo;
		}
		else if (riid == IID_IConvertType)
		{
			*ppv = (LPVOID) m_pIConvertType;
		}
		else if (riid == IID_IRowset)
		{
			*ppv = (LPVOID) m_pIRowset;
		}
		else if (riid == IID_IRowsetLocate && (m_ulProps & IROWSETLOCATE))
		{
			*ppv = (LPVOID) m_pIRowset;
		}
		else if (riid == IID_ISourcesRowset)
		{
			*ppv = (LPVOID) m_pIRowset;
		}
		else if (riid == IID_IRowsetChange && (m_ulProps & IROWSETCHANGE))
		{
			*ppv = (LPVOID) m_pIRowsetChange;
		}
		else if (riid == IID_IRowsetIdentity)
		{
			*ppv = (LPVOID) m_pIRowsetIdentity;
		}
		else if (riid == IID_IRowsetInfo)
		{
			*ppv = (LPVOID) m_pIRowsetInfo;
		}
		else if (riid == IID_IChapteredRowset && (m_ulProps & ICHAPTEREDROWSET))
		{
			*ppv = (LPVOID) m_pIChapteredRowset;
		}
		else if (riid == IID_IGetRow && (m_ulProps & IGETROW))
		{
			*ppv = (LPVOID) m_pIGetRow;
		}
		else if(riid == IID_IRowsetRefresh && (m_ulProps & IROWSETREFRESH))
		{
			*ppv = 		(LPVOID)m_pIRowsetRefresh;
		}
		else if(riid == IID_ISupportErrorInfo)
		{
			*ppv =		(LPVOID)m_pISupportErrorInfo;
		}


		//======================================================
		//  If we're going to return an interface, AddRef first
		//======================================================
		if (*ppv)
		{
			((LPUNKNOWN) *ppv)->AddRef();
			hr = S_OK ;
		}
		else
		{
			hr =  E_NOINTERFACE;
		}
	}
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Increments a persistence count for the object
//
// Returns Current reference count
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CRowset::AddRef(  void   )
{
    return InterlockedIncrement((long*)&m_cRef);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Decrements a persistence count for the object and if persistence count is 0, the object
// destroys itself.
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CRowset::Release( void   )
{
    if (!InterlockedDecrement((long*)&m_cRef))
	{
    	//===========================================================
    	// Mark the session as not having an open rowset anymore
	    //===========================================================
		this->m_pCreator->RemoveRowset(this);
//        this->m_pCreator->DecRowsetCount();
        delete this;
        return 0;
    }

    return m_cRef;
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Initialize the rowset for representing a row. This rowset will not be opened as a child rowset
// This is used	when rowset is opened on a qualifier
//						
//
// Did the Initialization Succeed
//      S_OK			Initialization succeeded
//		E_INVALIDARG	Some input data are incorrect
//      E_OUTOFMEMORY	Out of memory when allocate memory for member data
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::InitRowsetForRow(LPUNKNOWN pUnkOuter ,
								  const ULONG cPropertySets, 
								  const DBPROPSET	rgPropertySets[] , 
								  CWbemClassWrapper *pInst) 
{
	HRESULT hr = S_OK;
	HROW hRowCurrent = 0;
	CBSTR strKey;


	//================================================
	// Initialize the member variables
	//================================================
	m_bIsChildRs = FALSE;


	
	//==========================
	// Inititialize the rowset
	//==========================
	if(S_OK == (hr =InitRowset(cPropertySets,rgPropertySets)))
	{
		m_pMap->GetInstanceKey(pInst,strKey);
		m_pInstance	 = pInst;

		//===========================================================================
		// if there is atleast one row retrieved and there are neseted columns
		// then allocate rows for the child recordsets
		//===========================================================================
		if(m_cNestedCols > 0 )

		{
			if(m_ppChildRowsets == NULL)
			{
				AllocateAndInitializeChildRowsets();
			}

			//=====================================================================
			// Fill the HCHAPTERS for the column
			//=====================================================================
			if(S_OK != (hr = FillHChaptersForRow(pInst,strKey)))
			{
				hr = E_FAIL;
			}
		}

		if( FAILED(hr = CreateHelperFunctions()))
		{
			return hr;
		}

		m_bHelperFunctionCreated = TRUE;
	}
	return hr;

}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Overloaded Rowset Initialization function to initialize rowset created from a command object
//
// Did the Initialization Succeed
//      S_OK			Initialization succeeded
//		E_INVALIDARG	Some input data are incorrect
//      E_OUTOFMEMORY	Out of memory when allocate memory for member data
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::InitRowset( const ULONG cPropertySets, const DBPROPSET	rgPropertySets[],DWORD dwFlags, CQuery* p,PCCOMMAND pCmd ) 
{
	HRESULT hr = S_OK;
	//============================================
	// Set the qualifier flags
	//============================================
	dwFlags = (long)dwFlags == -1 ? GetQualifierFlags() : dwFlags;

	//==================================================================
	// Create a CWmiOleDBMap class with the appropriate constructor
	//==================================================================
	m_pMap = new CWmiOleDBMap;
	
	if( m_pMap != NULL)
	{
		if(SUCCEEDED(hr = m_pMap->FInit(dwFlags,p,m_pCon == NULL ?m_pCreator->m_pCDataSource->m_pWbemWrap: m_pCon)))
		{
			m_pMap->AddRef();
			m_pParentCmd	= pCmd;
			m_uRsType = p->GetType();       // If it is a COMMAND_ROWSET or METHOD_ROWSET

			//============================================
			// To hold the parent command reference
			//============================================
			m_pParentCmd->GetOuterUnknown()->AddRef();

			//=====================================================
			// Call this function to do the rest of initialization
			//=====================================================
			hr = InitRowset(cPropertySets,rgPropertySets);
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}
	
	return hr;

}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Overloaded Rowset Initialization function 
// This function is called for  (1) Schema Rowsets via CSchema
//
// Did the Initialization Succeed
//      S_OK			Initialization succeeded
//		E_INVALIDARG	Some input data are incorrect
//      E_OUTOFMEMORY	Out of memory when allocate memory for member data
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::InitRowset( int nBaseType,const ULONG cPropertySets, const DBPROPSET	rgPropertySets[],LPWSTR TableID, DWORD dwFlags, LPWSTR SpecificTable ) 
{
	HRESULT hr = S_OK;
	//============================================
	// Set the qualifier flags
	//============================================
	dwFlags = (long)dwFlags == -1 ? GetQualifierFlags() : dwFlags;

	//==================================================================
	// Create a CWmiOleDBMap class with the appropriate constructor
	//==================================================================
	m_pMap = new CWmiOleDBMap;

	if( m_pMap != NULL)
	{
		if(SUCCEEDED(hr = m_pMap->FInit(nBaseType, dwFlags, TableID, SpecificTable,
							  m_pCon == NULL ?m_pCreator->m_pCDataSource->m_pWbemWrap: m_pCon)))
		{
			m_pMap->AddRef();
			m_uRsType = SCHEMA_ROWSET;

			//=====================================================
			// Call this function to do the rest of initialization
			//=====================================================
			hr = InitRowset(cPropertySets,rgPropertySets);
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}
	
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Overloaded Rowset Initialization function 
// This function is called for  (1) Schema Rowsets
//								(2) rowsets created from IOpenrowset:OpenRowset
//
// Did the Initialization Succeed
//      S_OK			Initialization succeeded
//		E_INVALIDARG	Some input data are incorrect
//      E_OUTOFMEMORY	Out of memory when allocate memory for member data
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::InitRowset( const ULONG cPropertySets, const DBPROPSET	rgPropertySets[],LPWSTR TableID,BOOL fSchema , DWORD dwFlags ) 
{
	HRESULT hr = S_OK;
	VARIANT vValue;
	VariantInit(&vValue);

	//============================================
	// Set the qualifier flags
	//============================================
	dwFlags = (long)dwFlags == -1 ? GetQualifierFlags() : dwFlags;

	//==================================================================
	// Create a CWmiOleDBMap class with the appropriate constructor
	//==================================================================
	m_pMap = new CWmiOleDBMap;

	if( m_pMap != NULL)
	{
		if(wcscmp(TableID,OPENCOLLECTION) == 0)
		{			
			INSTANCELISTTYPE instType = GetObjectTypeProp(cPropertySets,rgPropertySets);
			hr = m_pMap->FInit(dwFlags,TableID,m_pCon == NULL ?m_pCreator->m_pCDataSource->m_pWbemWrap: m_pCon,instType);
		}
		else
		{
			hr = m_pMap->FInit(dwFlags,TableID,m_pCon == NULL ?m_pCreator->m_pCDataSource->m_pWbemWrap: m_pCon);
		}
		if(SUCCEEDED(hr))
		{
			m_pMap->AddRef();
			m_uRsType = fSchema == TRUE ? SCHEMA_ROWSET : 0;

			//=====================================================
			// Call this function to do the rest of initialization
			//=====================================================
			hr = InitRowset(cPropertySets,rgPropertySets);
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}
	
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Overloaded Rowset Initialization function 
// This function is called for  (1) ROwsets created for Scope/Container
//
// Did the Initialization Succeed
//      S_OK			Initialization succeeded
//		E_INVALIDARG	Some input data are incorrect
//      E_OUTOFMEMORY	Out of memory when allocate memory for member data
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::InitRowset( const ULONG cPropertySets, 
							const DBPROPSET	rgPropertySets[],
							LPWSTR strObjectID,
							LPWSTR strObjectToOpen,
							INSTANCELISTTYPE objInstListType , 
							DWORD dwFlags) 
{
	HRESULT hr = S_OK;
	WCHAR *pstrTableID = NULL;
	CWbemConnectionWrapper *pCon = m_pCon;

	pstrTableID = strObjectID;
	//============================================
	// Set the qualifier flags
	//============================================
	dwFlags = (long)dwFlags == -1 ? GetQualifierFlags() : dwFlags;

	if(!pstrTableID)
	{
		pstrTableID = new WCHAR[wcslen(OPENCOLLECTION) + 1];
		if(pstrTableID)
		{
			wcscpy(pstrTableID,OPENCOLLECTION);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	if(SUCCEEDED(hr) && strObjectToOpen)
//		wbem_wcsincmp(m_pCreator->m_pCDataSource->m_pWbemWrap->GetNamespace(),strObjectID,wcslen(m_pCreator->m_pCDataSource->m_pWbemWrap->GetNamespace())))
	{
		m_pCon = new CWbemConnectionWrapper;
		if(m_pCon)
		{
			hr = m_pCon->FInit(pCon != NULL ? pCon : m_pCreator->m_pCDataSource->m_pWbemWrap,
								strObjectToOpen,objInstListType);
			m_bNewConAllocated = TRUE;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	if(SUCCEEDED(hr))
	{
		//==================================================================
		// Create a CWmiOleDBMap class with the appropriate constructor
		//==================================================================
		m_pMap = new CWmiOleDBMap;
							
		if( m_pMap != NULL)
		{
			if(SUCCEEDED(hr = m_pMap ->FInit(dwFlags, 
										pstrTableID, 
										m_pCon == NULL ?m_pCreator->m_pCDataSource->m_pWbemWrap: m_pCon,
										objInstListType)))
			{
				m_pMap->AddRef();
				//=====================================================
				// Call this function to do the rest of initialization
				//=====================================================
				hr = InitRowset(cPropertySets,rgPropertySets);
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	if(!strObjectID)
	{
		SAFE_DELETE_ARRAY(pstrTableID);
	}
	
	return hr;
}



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Initialize the rowset Object
//
// Did the Initialization Succeed
//      S_OK			Initialization succeeded
//		E_INVALIDARG	Some input data are incorrect
//      E_OUTOFMEMORY	Out of memory when allocate memory for member data
//
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::InitRowset( const ULONG cPropertySets, const DBPROPSET	rgPropertySets[] ) 
{
    HRESULT hr = S_OK;
	bool bRowChange = true;
	ULONG	cErrors = 0;


	//============================================================================
	// allocate utility object that manages our properties
	//============================================================================
	m_pUtilProp = new CUtilProp;
	if ( m_pUtilProp == NULL ) 
	{
		hr = E_OUTOFMEMORY;
	}
	else
	// NTRaid: 136443
	// 07/05/00
	if(SUCCEEDED(hr = m_pUtilProp->FInit(ROWSETPROP)))
	{
		//07/06/00
		// NTRaid : 134987
		if(m_uRsType == SCHEMA_ROWSET)
		{
			hr = InitializePropertiesForSchemaRowset();
		}
		else
		if(m_uRsType == COMMAND_ROWSET )
		{
			hr = InitializePropertiesForCommandRowset();
		}
		else
		if(m_uRsType == METHOD_ROWSET)
		{
			hr = InitializePropertiesForMethodRowset();
		}
		//============================================================================
		// Set rowset properties
		// May be setting of optional properties might have failed and so we can continue
		//============================================================================
//		hr = SetRowsetProperties(cPropertySets,rgPropertySets);
		if(SUCCEEDED(hr) && SUCCEEDED(hr = SetRowsetProperties(cPropertySets,rgPropertySets)))
		{

			if(hr != S_OK)
			{
				cErrors++;
			}

			//===================================================================================
			// Call this function to initialize some of the rowset properties, set some flags
			// and set flags on CWmiOledbMap object
			//===================================================================================
			InitializeRowsetProperties();		
			
			//====================================================================
			/// Get property and Set Serach Preferences
			//====================================================================
			hr = SetSearchPreferences();

			//===================================================================================
			//  Get column the information for the rowset
			//===================================================================================
			if( S_OK == (hr = CBaseRowObj::GetColumnInfo()))
			{
				//=============================================================
				//  Initialize the first instance to zero if the rowset is 
				//	not a child rowset
				//=============================================================
				if(m_bIsChildRs != TRUE && ( m_uRsType == 0 || m_uRsType == SCHEMA_ROWSET || m_uRsType == COMMAND_ROWSET || m_uRsType == METHOD_ROWSET))
				{
					hr = ResetInstances();
				}
				else
				//======================================================================================
				// Create the chaptermanager with CRowsetpointers only if the rowset is a child rowset
				//======================================================================================
				if(m_bIsChildRs == TRUE)
				{
					m_pChapterMgr = new CChapterMgr();
					if ( !m_pChapterMgr ) 
					{
						hr = E_OUTOFMEMORY;
					}
				}

				if(!FAILED(hr))
				{
					//=======================================================
					// Call this function to allocate memory for all
					// contained interfaces
					//=======================================================
					hr = AllocateInterfacePointers();
				
				} 
			
			}	// if( S_OK == (hr = CBaseRowObj::GetColumnInfo()))
		
		}	// 	if(!FAILED(hr)) after Setting the rowset properties

		//===========================================================================
		// Call this function to increment the number of rowsets opened by command
		// if rowset is opened by command
		//===========================================================================
		if( SUCCEEDED(hr))
		{
			//==========================================================
			// Call this function to initialize the ISupportErrorInfo;
			//==========================================================
			hr = AddInterfacesForISupportErrorInfo();

			if(m_pParentCmd != NULL)
			{
				m_pParentCmd->IncrementOpenRowsets();
			}

			if(cErrors > 0)
			{
				hr = DB_S_ERRORSOCCURRED;
			}

		}

	} // If Succeeded(hr) after allocating memory for utilprop

    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////
// Allocate memory for the different interfaces
///////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::AllocateInterfacePointers()
{
	HRESULT hr			= S_OK;
	BOOL	bRowChange	= TRUE;

	//===========================================================================================
	// Allocate contained interface objects
	// Note that our approach is simple - we always create *all* of the Rowset interfaces
	// If our properties were read\write (i.e., could be set), we would need to
	// consult properties to known which interfaces to create.
	// Also, none of our interfaces conflict. If any did conflict, then we could
	// not just blindly create them all.
	//===========================================================================================

	m_pIAccessor                = new CImpIAccessor( this );
	if( m_pIAccessor )
	{
		hr = m_pIAccessor->FInit() ;
	}
	else
		hr = E_OUTOFMEMORY;

	if(SUCCEEDED(hr))
	{

		m_pIColumnsInfo             = new CImpIColumnsInfo( this );
		m_pIConvertType				= new CImpIConvertType(this);
		m_pIRowset                  = new CImpIRowsetLocate( this );

		if(m_ulProps & IROWSETCHANGE )
		{
			m_pIRowsetChange         = new CImpIRowsetChange( this );
		}

		m_pIRowsetIdentity          = new CImpIRowsetIdentity( this );
		m_pIRowsetInfo              = new CImpIRowsetInfo( this );
		m_pIChapteredRowset			= new CImpIChapteredRowset(this);
		m_pIGetRow					= new CImpIGetRow(this);
		m_pIRowsetRefresh			= new CImplIRowsetRefresh(this);
		m_pISupportErrorInfo		= new CImpISupportErrorInfo(this);


		//===============================================================
		// If rowset is pointing to qualifier then instantiate the 
		// qualifier fetch object
		//===============================================================
		if(m_uRsType == PROPERTYQUALIFIER || m_uRsType == CLASSQUALIFIER)
		{
			m_pRowFetchObj				= (CRowFetchObj *)new CQualifierRowFetchObj;
		}
		else
		{
			m_pRowFetchObj				= (CRowFetchObj *)new CInstanceRowFetchObj;
		}
	}

	if(SUCCEEDED(hr))
	{
		if( (m_pIRowsetChange == NULL) && ((m_ulProps & IROWSETCHANGE) != 0))
		{
			bRowChange	= FALSE;
		}
		//===========================================================================================
		// if all interfaces were created, return success
		//===========================================================================================
		if( ! (m_pIAccessor &&  m_pIColumnsInfo &&  m_pIConvertType && m_pIRowset && bRowChange && m_pIRowsetIdentity && m_pIRowsetInfo && m_pIChapteredRowset && m_pIRowsetRefresh && m_pISupportErrorInfo))
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to initialize Rowset properties and also set some of the flags on CWMIOledbMap accordingly
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void CRowset::InitializeRowsetProperties()
{
	HRESULT hr = S_OK;
	VARIANT varProp;

	VariantInit(&varProp);

	//===========================================================================================
	// Initialize the common rowset properties ( boolean properties)
	// and put that in the member variable
	//===========================================================================================
	GetCommonRowsetProperties();

	//===========================================================================================
	// set the forwardonly flag of enumerator to null depending on
	// the properties
	//===========================================================================================
	// NTRaid 14199
	// 07/14/2000. The navigation flags of the parent rowset for qualifier rowset was getting changed
	if(!((CANSCROLLBACKWARDS & m_ulProps) || (CANFETCHBACKWARDS & m_ulProps)  || (BOOKMARKPROP & m_ulProps)) ||
		(m_uRsType == METHOD_ROWSET) && (m_uRsType != PROPERTYQUALIFIER || m_uRsType != CLASSQUALIFIER))
	{
		m_pMap->SetNavigationFlags(WBEM_FLAG_FORWARD_ONLY);
		m_ulProps = m_ulProps & ~CANSCROLLBACKWARDS;
		m_ulProps = m_ulProps & ~CANFETCHBACKWARDS;
		m_ulProps = m_ulProps & ~BOOKMARKPROP;
		m_ulProps = m_ulProps & ~IROWSETLOCATE;
	}

	//===========================================================================================
	// If the custom WMIOLEDB property FETCHDEEP is set , then set the other OLEDB props
	// which reflects the behaviour of the rowset
	//===========================================================================================
	if(FETCHDEEP & m_ulProps)
	{
		varProp.vt = VT_BOOL;
		varProp.boolVal = VARIANT_TRUE;

		m_pMap->SetQueryFlags(WBEM_FLAG_DEEP);

		//===========================================================================================
		// If enumeration is opened as FLAG_DEEP, it is bidirectional
		// So set the respective properties
		//===========================================================================================
		SetRowsetProperty(DBPROP_CANSCROLLBACKWARDS,varProp);
		SetRowsetProperty(DBPROP_CANFETCHBACKWARDS,varProp);
	}

	VariantClear(&varProp);

	//===========================================================================================
	// Get the DataSource property to check if system Properties is to be fetched?
	//===========================================================================================
	m_pCreator->GetDataSrcProperty(DBPROP_WMIOLEDB_SYSTEMPROPERTIES,varProp);
	if( varProp.boolVal == VARIANT_TRUE)
	{
		m_pMap->SetSytemPropertiesFlag(TRUE);
	}

	VariantClear(&varProp);

}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to add interfaces to ISupportErrorInfo interface
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::AddInterfacesForISupportErrorInfo()
{
	HRESULT hr = S_OK;

	if(SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IAccessor)) &&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IColumnsInfo)) &&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IConvertType)) &&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IRowset)) &&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_ISourcesRowset)) &&
		SUCCEEDED(hr = m_pISupportErrorInfo->AddInterfaceID(IID_IRowsetIdentity)))
	{
		hr = m_pISupportErrorInfo->AddInterfaceID(IID_IRowsetInfo);
	}

	if(SUCCEEDED(hr) && (m_ulProps & IROWSETLOCATE))
	{
		hr = m_pISupportErrorInfo->AddInterfaceID(IID_IRowsetLocate);
	}
	if(SUCCEEDED(hr) && (m_ulProps & IROWSETCHANGE))
	{
		hr = m_pISupportErrorInfo->AddInterfaceID(IID_IRowsetChange);
	}
	if(SUCCEEDED(hr) && (m_ulProps & ICHAPTEREDROWSET))
	{
		hr = m_pISupportErrorInfo->AddInterfaceID(IID_IChapteredRowset);
	}
	if(SUCCEEDED(hr) && (m_ulProps & IGETROW))
	{
		hr = m_pISupportErrorInfo->AddInterfaceID(IID_IGetRow);
	}
	if(SUCCEEDED(hr) && (m_ulProps & IROWSETREFRESH))
	{
		hr = m_pISupportErrorInfo->AddInterfaceID(IID_IRowsetRefresh);
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Creates DBCOLINFO structures for each column in the result set.
//
//  HRESULT
//       S_OK       Column Info Obtained
//       E_FAIL     Problems getting Column Info
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::GatherColumnInfo()
{
	//=======================================================
	// Call GatherColumnInfo() on the base object
	//=======================================================
	HRESULT hr = CBaseRowObj::GatherColumnInfo();
	
    //=============================================================
    //  Initialize the first instance to zero if the rowset is 
	//	not a child rowset
    //=============================================================
	if(hr == S_OK && m_bIsChildRs != TRUE)
	{
		ResetInstances();
	}

    return hr;


}
/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Creates Helper classes that are needed to manage the Rowset Object
//
//  HRESULT
//       S_OK       Helper classes created
//       E_FAIL     Helper classes were not created
//
//	NTRaid : 142133 & 141923
//	07/12/00
/////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::CreateHelperFunctions (  void   )
{
	HRESULT hr = E_OUTOFMEMORY;
	
	if(m_cTotalCols == 0)
	{
		hr = S_OK;
	}
	else
	//============================================================================
	// List of free slots.
	// This manages the allocation of sets of contiguous rows.
	//============================================================================
	if (SUCCEEDED(hr = InitializeSlotList( MAX_TOTAL_ROWBUFF_SIZE / m_cbRowSize,  m_cbRowSize, g_dwPageSize, 
                                    m_pIAccessor->GetBitArrayPtr(),&m_pIBuffer, &m_rgbRowData )))
	{
		//============================================================================
		// Locate some free slots. Should be at very beginning.
		// This tells us which row we will bind to: m_irowMin.
		// After getting the slot just release it as this was just a test
		//============================================================================
		if (SUCCEEDED( hr = GetNextSlots( m_pIBuffer, 1, (HSLOT *)&m_irowMin )))
		{

			hr = ReleaseSlots( m_pIBuffer, m_irowMin, 1 );
		}
	}
	if(SUCCEEDED(hr))
	{
		//=================================================
		// Allocate and initialize rowdata manager
		//=================================================
		m_pRowData = new CRowDataMemMgr;

		if( m_pRowData != NULL)
		{

			//=================================================
			// Set the number of columns in row
			//=================================================
			m_pRowData->AllocRowData(m_cTotalCols);
			
			hr = S_OK;
			//=================================================
			// Allocate memory for instance manager
			//=================================================
			m_InstMgr = new CWMIInstanceMgr;

			if( m_InstMgr != NULL)
			{
				//==============================================================
				// If bookmark is required then allocate an new hashtbl class
				//==============================================================
				if(m_ulProps & BOOKMARKPROP)
				{
					m_pHashTblBkmark = new CHashTbl;

					if(m_pHashTblBkmark != NULL)
					{

						//=================================================
						// Initialize the hashtable
						//=================================================
						m_pHashTblBkmark->FInit((PLSTSLOT)m_pIBuffer);

						//=================================================
						// Call this function to get the number of rows 
						//=================================================
						GetRowCount();
						hr = S_OK;
					
					} // if(m_HashTblBkmark != NULL)
				
				} // if( bookmark property is set)
			
			} // if ( instance manage is allocated correctly)
			else
			{
				hr = E_OUTOFMEMORY;
			}

		} // if( m_pRowData != NULL)
	
	}	// GetNextSlots succeeded
	

    return  hr ;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Establishes data offsets and type for the routines to place the data
//
//  HRESULT
//       S_OK       Bindings set fine
//       E_FAIL     Bindings could not be set
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::Rebind(  BYTE *pBase  )          // IN Base pointer for Data Area
{
    HRESULT hr= 0;
    UWORD       icol;
    COLUMNDATA  *pColumn;

    //==============================================================================
    // Bind result set columns.
    // Use established types and sizes and offsets.
    // Bind to internal row buffer, area beginning with 'pRowBuff'.
    //
    // For each column, bind it's data as well as length.
    // Offsets point to start of COLUMNDATA structure.
    //==============================================================================

    assert( pBase );

    //==============================================================================
    // Optimize by not doing it over again.
    //==============================================================================
    if (pBase != m_pLastBindBase)
	{
		
		hr = E_UNEXPECTED;
        m_pLastBindBase = 0;

        for (icol=0; icol < m_cTotalCols; icol++)
		{

            //======================================================================
            //  Parent columns... what about nested ?
            //======================================================================
            pColumn = (COLUMNDATA *) (pBase + m_Columns.GetDataOffset(icol));
            hr = m_pRowData->SetColumnBind( icol, pColumn );
            if( hr != S_OK )
			{
                break;
            }
        }
        if( hr == S_OK )
		{
			//=================================================
            // Remember in case we bind to same place again.
			//=================================================
            m_pLastBindBase = pBase;
        }
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//  Shorthand way to get the address of a row buffer. Later we may extend this so that it can span several
//  non-contiguous blocks of memory.
//
//  Pointer to the buffer.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
ROWBUFF* CRowset::GetRowBuff(  HROW iRow,                  // IN  Row to get address of.
                               BOOL  fDataLocation )        // IN  Get the Data offset.
{
	HSLOT hSlot	 = -1;
    //=====================================================================
    // This assumes iRow is valid...
    //=====================================================================
    assert( m_rgbRowData );
    assert( m_cbRowSize );
    assert( iRow > 0 );



    if(m_bIsChildRs == FALSE)
	{
		//=================================================
		// Get the slot number for the row
		//=================================================
		hSlot = m_InstMgr->GetSlot(iRow);
	}
	//=================================================================================
	// if rowset is refering to qualifiers then add the row to the particular chapter
	//=================================================================================
	else 
	{
		//=================================================
		// Get the slot number for the row
		//=================================================
		hSlot = m_pChapterMgr->GetSlot(iRow);
	}

	return (hSlot != -1) ? GetRowBuffer(m_pIBuffer,(ULONG)hSlot): NULL;

}

	


/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//  Shorthand way to get the address of a row buffer. 
//
//  Pointer to the buffer.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
ROWBUFF* CRowset::GetRowBuffFromSlot(  HSLOT hSlot,                  // IN  Row to get address of.
                               BOOL  fDataLocation )        // IN  Get the Data offset.
{
    //=====================================================================
    // This assumes iRow is valid...
    //=====================================================================
    assert( m_rgbRowData );
    assert( m_cbRowSize );
    assert( hSlot >= 0 );

	return GetRowBuffer(m_pIBuffer,hSlot);

}


////////////////////////////////////////////////////////////////////////////
// Reset the position of the instances in the enumerator to the begining
////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::ResetInstances()
{

    return m_pMap->ResetInstances();
}

////////////////////////////////////////////////////////////////////////////
// Reset the qualifer set of the property/class/instance
////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::ResetQualifers(HCHAPTER hChapter)
{
	HRESULT hr = S_OK;
	CWbemClassWrapper *pInst = NULL;

    //=====================================================================
	// Get the pointer to instance for which qualifier is to 
	// be reset
    //=====================================================================
	if( hChapter > 0 && m_bIsChildRs == TRUE)
	{
		pInst = m_pChapterMgr->GetInstance(hChapter);
	}
	else
	{
		pInst = m_pInstance;
	}
	
	//=================================================
	// If valid instance then reset the qualifier
	//=================================================
	if(pInst)
	{
		m_pMap->ReleaseQualifier(pInst,m_strPropertyName);
	}
	else
	{
		hr = DB_E_BADCHAPTER;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////
// Reset the position of the instances in the enumerator the required position
/////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::ResetRowsetToNewPosition(DBROWOFFSET uWhich,CWbemClassWrapper *pInst)
{
	HRESULT hr = S_OK;
	switch(m_uRsType)
	{
		case PROPERTYQUALIFIER:
			hr = m_pMap->ResetPropQualiferToNewPosition(pInst,uWhich,m_strPropertyName);
			break;

		case CLASSQUALIFIER:
			hr = m_pMap->ResetClassQualiferToNewPosition(pInst,uWhich);
			break;

		case SCHEMA_ROWSET:
			// NTRaid : 134987
			// 07/12/00
			hr = m_pMap->ResetInstancesToNewPosition(uWhich);
			break;

		case 0:
        case COMMAND_ROWSET:
        case METHOD_ROWSET:
			hr = m_pMap->ResetInstancesToNewPosition(uWhich);
			break;

		default:
			hr = E_FAIL;
			break;
	}

    return hr;

}

///////////////////////////////////////////////////////
// Get the pointer and key to the next instance
///////////////////////////////////////////////////////
HRESULT CRowset::GetNextInstance(CWbemClassWrapper *&ppInst,CBSTR &strKey, BOOL bFetchBack)
{
	//=================================================
	// Reset the column Index of the data manager
	//=================================================
	m_pRowData->ResetColumns();
    return m_pMap->GetNextInstance(ppInst,strKey,bFetchBack);

}


///////////////////////////////////////////////////////
// Get the next property qualifier
///////////////////////////////////////////////////////
HRESULT CRowset::GetNextPropertyQualifier(CWbemClassWrapper *pInst,BSTR strPropName,BSTR &strQualifier,BOOL bFetchBack)
{
	HRESULT hr = S_OK;
	//=================================================
	// Reset the column Index of the data manager
	//=================================================
	m_pRowData->ResetColumns();
    hr = m_pMap->GetNextPropertyQualifier(pInst,strPropName,strQualifier,bFetchBack);

	return hr;

}

///////////////////////////////////////////////////////
// Get the next Class qualifier 
///////////////////////////////////////////////////////
HRESULT CRowset::GetNextClassQualifier(CWbemClassWrapper *pInst,BSTR &strQualifier,BOOL bFetchBack)
{
	HRESULT hr = S_OK;
	//=================================================
	// Reset the column Index of the data manager
	//=================================================
	m_pRowData->ResetColumns();
    hr = m_pMap->GetNextClassQualifier(pInst,strQualifier,bFetchBack);

	return hr;

}


//////////////////////////////////////////////////////////////////////////
// Get the data from the instance and populate it into the local buffer
//////////////////////////////////////////////////////////////////////////
HRESULT CRowset::GetInstanceDataToLocalBuffer(CWbemClassWrapper *pInst,HSLOT hSlot,BSTR strQualifier)
{
	HRESULT		hr			= S_OK;
	PROWBUFF	pRowBuff	= NULL;

	pRowBuff	= GetRowBuffFromSlot( hSlot, TRUE );

    if (FAILED( Rebind((BYTE *)pRowBuff )))
	{
        hr =  E_FAIL ;
    }
	else
	
	//=====================================================
	// Reset the column to point to the first column and 
	// get the data and put it into the buffer
	//=====================================================
	if( S_OK == (hr = m_pRowData->ResetColumns()))
	{
		switch(m_uRsType)
		{
			case PROPERTYQUALIFIER:
				hr = m_pMap->GetDataForPropertyQualifier(m_pRowData,pInst,m_strPropertyName,strQualifier,&m_Columns);
				break;

			case CLASSQUALIFIER:
				hr = m_pMap->GetDataForClassQualifier(m_pRowData,pInst,strQualifier,&m_Columns);
				break;

			case SCHEMA_ROWSET:
    			hr = m_pMap->GetDataForSchemaInstance(m_pRowData,pInst,&m_Columns);
				break;

			case 0:
            case COMMAND_ROWSET:
            case METHOD_ROWSET:
				hr = m_pMap->GetDataForInstance(m_pRowData,pInst,&m_Columns);
				break;

			default:
				hr = E_FAIL;
				break;
		}
	}
	
	return hr;
}
																	



///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Set rowset properties. This is called during initialization of the rowset
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::SetRowsetProperties(const ULONG cPropertySets, const DBPROPSET	rgPropertySets[] )
{
    HRESULT hr = S_OK;
	VARIANT varPropVal;
	VariantInit(&varPropVal);
	LONG lFlag = 0;

	// call the base class implementation for setting properties
	hr = SetProperties(cPropertySets,rgPropertySets);

    //============================================================================
	// call this function to set the DBPROP_UPDATIBILITY to readonly if the Datasource
	// open mode is readonly
    //============================================================================
	if( (hr == S_OK) ||   (hr == DB_S_ERRORSOCCURRED) )
	{
		SynchronizeDataSourceMode();
	}

    //============================================================================
	// Get some properties to determine whether to support bookmarks or not
    //============================================================================
	if( S_OK == GetRowsetProperty(DBPROP_CANSCROLLBACKWARDS,varPropVal) &&
		varPropVal.vt == VT_BOOL && varPropVal.boolVal == VARIANT_TRUE)
	{
		lFlag = lFlag | CANSCROLLBACKWARDS;
	}
	if( S_OK == GetRowsetProperty(DBPROP_CANFETCHBACKWARDS,varPropVal) &&
		varPropVal.vt == VT_BOOL && varPropVal.boolVal == VARIANT_TRUE)
	{
		lFlag = lFlag | CANFETCHBACKWARDS;
	}
	if( S_OK == GetRowsetProperty(DBPROP_IRowsetLocate,varPropVal) &&
		varPropVal.vt == VT_BOOL && varPropVal.boolVal == VARIANT_TRUE)
	{
		lFlag = lFlag | IROWSETLOCATE;
	}
	if( S_OK == GetRowsetProperty(DBPROP_OTHERINSERT,varPropVal) &&
		varPropVal.vt == VT_BOOL && varPropVal.boolVal == VARIANT_TRUE)
	{
		lFlag = lFlag | OTHERINSERT;
	}
	

    //============================================================================
	// if bookmarks are asked then set the fetchback and scrollback properties to true
    //============================================================================
	varPropVal.vt		= VT_BOOL;
	if(IROWSETLOCATE & lFlag )
	{
		varPropVal.boolVal	= VARIANT_TRUE;
		SetRowsetProperty(DBPROP_CANFETCHBACKWARDS,varPropVal);
		SetRowsetProperty(DBPROP_CANSCROLLBACKWARDS,varPropVal);
		SetRowsetProperty(DBPROP_BOOKMARKS,varPropVal);
		lFlag = lFlag | CANSCROLLBACKWARDS;
		lFlag = lFlag | CANFETCHBACKWARDS;
		lFlag = lFlag | BOOKMARKPROP;
	}
    //============================================================================
	// Bookmarks are not supported for qualifier rowsets
    //============================================================================
	if(m_uRsType == PROPERTYQUALIFIER || m_uRsType == CLASSQUALIFIER)
	{
		varPropVal.boolVal	= VARIANT_FALSE;
		SetRowsetProperty(DBPROP_BOOKMARKS,varPropVal);
		SetRowsetProperty(DBPROP_IRowsetLocate,varPropVal);
		lFlag = lFlag & ~BOOKMARKPROP;
		lFlag = lFlag & ~IROWSETLOCATE;
	}

	VariantClear(&varPropVal);
	return hr;
}



///////////////////////////////////////////////////////////////////////////
//   Function to Allocate and Iniatialize rowsets for child recordsets	 //
///////////////////////////////////////////////////////////////////////////
HRESULT  CRowset::AllocateAndInitializeChildRowsets()
{
	HRESULT hr = E_FAIL;
	DBPROPSET *rgPropsets = NULL;
	ULONG cProperties = 0;
	ULONG nIndex = 0 , nIndex2 = 0;
	ULONG lColType = 0;

	//===========================================================================================
	// if there are nested columns in the rowset and if childrowsets are not already allocated
	//===========================================================================================
	if(m_cNestedCols > 0 && m_ppChildRowsets == NULL)
	{

		//=============================================================
		// Allocate pointers for the child rowsets
		//=============================================================
		m_ppChildRowsets = (CBaseRowObj **)new CRowset*[m_cTotalCols];

		if(m_ppChildRowsets == NULL)
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			//================================================================================
			// Get the rowset Properties
			//================================================================================
			if(S_OK == (hr = m_pIRowsetInfo->GetProperties(cProperties,NULL,&cProperties,&rgPropsets)))
			{
				for ( nIndex = 0 ; nIndex < m_cTotalCols ; nIndex++)
				{
					//========================================================================
					// if the columntype is of CHAPTER then allocate a rowset and initialize
					//========================================================================
					if(m_Columns.ColumnFlags(nIndex) & DBCOLUMNFLAGS_ISCHAPTER )
					{
						lColType = m_pMap->ParseQualifiedNameToGetColumnType(m_Columns.ColumnName(nIndex));
						if(lColType == WMI_CLASS_QUALIFIER)
						{
							m_ppChildRowsets[nIndex] = (CBaseRowObj*) new CRowset(m_pUnkOuter,CLASSQUALIFIER, NULL,m_pCreator, m_pMap);
						}
						else
						if(lColType == WMI_PROPERTY_QUALIFIER)
						{
							m_ppChildRowsets[nIndex] = (CBaseRowObj*) new CRowset(m_pUnkOuter,PROPERTYQUALIFIER, m_Columns.ColumnName(nIndex-1),m_pCreator, m_pMap);
						}
						
						if(m_ppChildRowsets[nIndex] == NULL)
						{
							hr = E_OUTOFMEMORY;
							break;
						}

						else
						{
							//===================================================================
							// Initialize the rowset properties
							//===================================================================
 							hr = ((CRowset *)m_ppChildRowsets[nIndex])->InitRowset( cProperties, rgPropsets );	
							m_ppChildRowsets[nIndex]->AddRef();
						}

						
					} // if for columntype
					else
						m_ppChildRowsets[nIndex] = NULL;
				} // for
				
			} // GetProperties

    		//==========================================================================
			//  Free memory we allocated to by m_pIRowsetInfo->GetProperties
    		//==========================================================================
			m_pUtilProp->m_PropMemMgr.FreeDBPROPSET( cProperties, rgPropsets);

		} // if memory for pointers allocated successfully
	}
	return hr;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the pointer to the child recordset for the given ordinal
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::GetChildRowset(DBORDINAL ulOrdinal,REFIID riid, IUnknown ** ppIRowset)
{
	HRESULT hr = S_OK;

	//===============================================================================================
	// If row the child rowset pointer is fetched before fetching any rows from the parent rowsets
	// then this will be called before allocating the child recordset. SO allocate the child rowsets
	//===============================================================================================
	if( m_ppChildRowsets == NULL)
	{
		hr = AllocateAndInitializeChildRowsets();

	}

	if(SUCCEEDED(hr))
	{
		hr = DB_E_NOTAREFERENCECOLUMN;
		if(m_cNestedCols > 0)
		{
			
			if( ulOrdinal > m_cTotalCols)
			{
				hr = DB_E_BADORDINAL;
			}
			else
			if(m_ppChildRowsets[ulOrdinal] != NULL)
			{
				hr = m_ppChildRowsets[ulOrdinal]->QueryInterface(riid,(void **)ppIRowset);	
			}
		}
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Check if the HCHAPTER passed is valid or not
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::CheckAndInitializeChapter(HCHAPTER hChapter)
{
	HRESULT hr = E_FAIL;
	if(m_bIsChildRs && m_pChapterMgr->IsExists(hChapter))
	{
		hr = S_OK;
	}
	return hr;
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to release the instance pointers when ReleaseRows is called
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::ReleaseInstancePointer(HROW hRow)
{
    //========================================================================
	// if the recordset is representing a class 
    //========================================================================
	if(m_bIsChildRs == FALSE )
	{
		m_InstMgr->DeleteInstanceFromList(hRow);
	}
    //===============================================================================
	// if the row is a child recordset then delete the row from the chapter manager
    //===============================================================================
	if(m_bIsChildRs == TRUE)
	{
		m_pChapterMgr->DeleteHRow(hRow);
	}

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to check if the row exist in the chapter or instance manager
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CRowset::IsRowExists(HROW hRow)
{
	BOOL bRet = FALSE;
	if( hRow > 0)
	{
		//========================================================================
		// if the recordset is representing a class 
		//========================================================================
		if(m_bIsChildRs == FALSE)
		{
 			bRet = m_InstMgr->IsRowExists(hRow);
		}
		//===============================================================================
		// if the row is a child recordset then delete the row from the chapter manager
		//===============================================================================
		if(m_bIsChildRs == TRUE)
		{
			bRet = m_pChapterMgr->IsRowExists(hRow);
		}
	}

	return bRet;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to release all the open rows
// This is called from the destructor
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::ReleaseAllRows()
{
	DBROWOPTIONS	rgRowOptions[1];
	DBREFCOUNT		rgRefCounts[1];
	DBROWSTATUS		rgRowStatus[1];

	HRESULT hr = S_OK;

	//==========================================================
	// if there are any rows fetched 
	//==========================================================
	if(!( ( m_bIsChildRs == TRUE	&& m_pChapterMgr == NULL) ||
		( m_bIsChildRs == FALSE && m_InstMgr == NULL)))
	{
		memset(rgRowOptions,0,sizeof(DBROWOPTIONS));
		memset(rgRowStatus,0,sizeof(DBROWSTATUS));
		rgRefCounts[0] = 0;

		DBCOUNTITEM cRows = 0 , nIndex = 0;
		HROW *prghRows = NULL;

		//=================================================
		// if the rowset is child rowset get the list 
		// open rowset from the chapter manager
		//=================================================
		if(m_bIsChildRs)
		{
			hr = m_pChapterMgr->GetAllHROWs(prghRows,cRows);

		}
		//=========================================
		// else get it from the instance manager
		//=========================================
		else
		{
			hr = m_InstMgr->GetAllHROWs(prghRows,cRows);
		}

		//===============================================
		// If there are open rows the release the rows
		//===============================================
		if(cRows > 0)
		{
			for(nIndex = 0 ; nIndex < cRows ; nIndex++)
			{
				//==============================================================
				// Release till the reference count on the row goes to zero
				// and thus all the resources allocated for the is released
				//==============================================================
				do
				{
 					hr = m_pIRowset->ReleaseRows(1, &(prghRows[nIndex]),rgRowOptions,rgRefCounts,NULL);
				
				}while(rgRefCounts[0] > 0 && hr == S_OK);

			}
			//====================================================================================
			// delete the memory allocated by the functions which gives the list of open rows
			//====================================================================================
			if(prghRows != NULL)
			{
				delete [] prghRows;
				prghRows = NULL;
			}
		}
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to find whether the slot for the particular row is set
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT	CRowset::IsSlotSet(HSLOT hRow)
{

	HSLOT hSlot = -1;
	HRESULT hr = E_FAIL;

	hSlot = GetSlotForRow(hRow);
	
	// If valid slot
	if( (hSlot) >= 0)
	{
		hr = m_pIAccessor->GetBitArrayPtr()->IsSlotSet(hSlot);
	}

	return hr;

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to return the slot number of the row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HSLOT CRowset::GetSlotForRow(HROW hRow )        // IN  Row handle for which slot number is required
{
	HSLOT hSlot = -1;

	//=================================================================
	// if the rowset is a parent rowset then
	// get slot number from the instance manager else get it
	// from the chapter manager
	//=================================================================
    if(m_bIsChildRs == FALSE)
	{
		//=================================================
		// Get the slot for the row
		//=================================================
		hSlot = m_InstMgr->GetSlot(hRow);
	}
	//=================================================================================
	// if rowset is refering to qualifiers then add the row to the particular chapter
	//=================================================================================
	else 
	{
		//=================================================
		// Get the slot for the row
		//=================================================
		hSlot = m_pChapterMgr->GetSlot(hRow);
	}

	return hSlot;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function which fetches data and puts it into the local buffer
// NTRaid: 145773
// 07/18/00
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::GetData(HROW hRow,BSTR strQualifier )
{

	CWbemClassWrapper * pInst		= NULL;
	BSTR				strKey;
	HSLOT				hSlot		= 0;
	HRESULT				hr			= S_OK;
	PROWBUFF			pRowBuff	= NULL;
	CVARIANT			varKey;
	HCHAPTER			hChapter	= 0;
	


	//===================================================================
	/// get the instance pointer corresponding to the HROW passed
	// if rowset is referiing to a class and not to qualifiers then
	//===================================================================
	if(m_bIsChildRs == FALSE)
	
	{
		pInst = m_InstMgr->GetInstance(hRow);
		m_InstMgr->GetInstanceKey(hRow,&strKey);
		hSlot = m_InstMgr->GetSlot(hRow);
	}
	//===================================================================
	// if the recordset is a child rs and representing a qualifier
	//===================================================================
	else 
	{
		hChapter = m_pChapterMgr->GetChapterForHRow(hRow);
		if( hChapter <= 0)
		{
			hr = DB_E_BADCHAPTER;
		}
		else
		{
			//===================================================================
			// get the instance pointer corresponding to the 
			//===================================================================
			pInst = m_pChapterMgr->GetInstance(hChapter);
			m_pChapterMgr->GetInstanceKey(hChapter,&strKey, hRow);
			hSlot = m_pChapterMgr->GetSlot(hRow);
		}

	}
	// NTRaid:111830
	if(hSlot == 0 || pInst == NULL)
	{
		hr = DB_E_BADROWHANDLE;
	}
	else
	if ( SUCCEEDED(hr))
	{
		if(!( m_uRsType == PROPERTYQUALIFIER || 
			m_uRsType == CLASSQUALIFIER))
		{
			assert(strQualifier == NULL);

			//===================================================================
			// Refresh the instance.
			// This is to get the latest instance if modified from another instance
			//===================================================================
			if(m_ulProps & OTHERUPDATEDELETE)
			{
				hr = RefreshInstance(pInst);
			}

			//===================================================================
			// Filling data for the bookmark column
			//===================================================================
			varKey.SetStr(strKey);
		}
		else 
		{
			// If the otherupdate is true then strQualifier will be NULL
			if(m_ulProps & OTHERUPDATEDELETE)
			{
				// Filling data for the bookmark column
				varKey.SetStr(strKey);
			}
			else
			{
				// Filling data for the bookmark column
				varKey.SetStr(strQualifier);
			}

		}

		if(SUCCEEDED(hr = GetInstanceDataToLocalBuffer(pInst,hSlot,varKey.GetStr())))
		{
			//===========================================================================
			// if there is atleast one row retrieved and there are neseted columns
			// then allocate rows for the child recordsets
			//===========================================================================
			if(m_cNestedCols > 0 )

			{
				if(m_ppChildRowsets == NULL)
				{
					hr = AllocateAndInitializeChildRowsets();
				}

				//=====================================================================
				// Fill the HCHAPTERS for the column
				//=====================================================================
				if( SUCCEEDED(hr))
				{
					hr = FillHChaptersForRow(pInst,strKey);
				}

			}

			if( SUCCEEDED(hr))
			{
				//===================================================
				// if the class is not representing qualilfiers
				//===================================================
				if(m_bIsChildRs == FALSE)
				{
					//=================================================
					// Set the slot for the row
					//=================================================
					hr = m_InstMgr->SetSlot(hRow,hSlot);
				}
				//=================================================================================
				// if rowset is refering to qualifiers then add the row to the particular chapter
				//=================================================================================
				else 
				{
					//==============================================
					// Set the slot for the Row
					//==============================================
					if(SUCCEEDED(hr = m_pChapterMgr->SetSlot(hRow,hSlot)))
					{
						m_pChapterMgr->SetInstance(hChapter,pInst, varKey.GetStr() ,hRow);
					}
				}
				
				if(SUCCEEDED(hr))
				{
					pRowBuff = GetRowBuff( (ULONG) hRow, TRUE );
					
					// NTRaid:111830
					// 06/07/00
					if(pRowBuff)
					{
						//========================================
						// Increment the reference count
						//========================================
						pRowBuff->ulRefCount++;
					}
					else
					{
						hr = E_FAIL;
					}
				}

				//==============================================
				//	Free the string
				//==============================================
				if(m_bIsChildRs == FALSE)
				{
					SysFreeString(strKey);			
				}
			
			} // Succeeded(hr)
		}
		varKey.Clear();
	} // Succeeded(hr)

	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to update a row to WMI
// NTRaid : 143868
//	07/15/00
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::UpdateRowData(HROW hRow,PACCESSOR pAccessor , BOOL bNewInst)
{
	HRESULT				hr			= S_OK;
	PROWBUFF			pRowBuff	= NULL;
	DBORDINAL			ibind		= 0;
	COLUMNDATA *		pColumnData = NULL;
	CWbemClassWrapper * pInst		= NULL;
	DBORDINAL			icol		= 0;
	BOOL				bRowModified = FALSE;

	BSTR				bstrColName;
	BSTR				strQualifierName =Wmioledb_SysAllocString(NULL);
	CDataMap			dataMap;
	VARIANT				varData;
	LONG				lFlavor = 0;
	VariantInit(&varData);
	DWORD			dwCIMType = 0;

	//=================================================================================
	// get the pointer to the instance
	//=================================================================================
	if(m_bIsChildRs == FALSE)
	{
		if(	m_uRsType == PROPERTYQUALIFIER ||
			m_uRsType == CLASSQUALIFIER )
		{
			pInst = m_pInstance;
		}
		else
		if( m_uRsType !=  COLUMNSROWSET &&  m_uRsType !=  SCHEMA_ROWSET &&  m_uRsType !=  METHOD_ROWSET)
		{
			pInst = m_InstMgr->GetInstance(hRow);
		}

	}
	else
	{
		pInst = m_pChapterMgr->GetInstance(m_pChapterMgr->GetChapterForHRow(hRow));
	}

	//=================================================================================
	// Get the pointer to the row data
	//=================================================================================
	pRowBuff = GetRowBuff((ULONG) hRow, TRUE );

	// NTRaid:111823-111825
	// 06/07/00
	// If the row is not an instance or qualifier
	if(pInst == NULL)
	{
		hr = DB_E_NOTSUPPORTED;
	}
	else
	//=================================================================================
	// IF the rowset is a qualifier type rowset 
	//=================================================================================
	if(	m_uRsType == PROPERTYQUALIFIER || m_uRsType == CLASSQUALIFIER )
	{
		//=================================================================================
		// get the qualifier name
		//=================================================================================
		pColumnData = (COLUMNDATA *) (((BYTE *)pRowBuff )+ m_Columns.GetDataOffset(QUALIFIERNAMECOL));
		if( pColumnData->pbData == NULL)
		{
			hr				= DB_E_INTEGRITYVIOLATION;		// This is because one of the column values expected
															// is NULL or EMPTY
			bRowModified	= TRUE;
		}
		else
		{
			strQualifierName = Wmioledb_SysAllocString((WCHAR *)pColumnData->pbData);

			//=================================================================================
			// Get the qualifier Value
			//=================================================================================
			pColumnData = (COLUMNDATA *) (((BYTE *)pRowBuff )+ m_Columns.GetDataOffset(QUALIFIERVALCOL));
			VariantCopy(&varData,(VARIANT *)pColumnData->pbData);

			//=================================================================================
			// Get the qualifier flavor
			//=================================================================================
			pColumnData = (COLUMNDATA *) (((BYTE *)pRowBuff )+ m_Columns.GetDataOffset(QUALIFIERFLAVOR));
			lFlavor = pColumnData->pbData !=NULL ? *(LONG *)pColumnData->pbData : 0 ;

			if( varData.vt != VT_EMPTY  || varData.vt != VT_NULL)
			{	
				//=================================================================================
				// Set the qualifier 
				//=================================================================================
				hr = m_pMap->SetQualifier(pInst,m_strPropertyName,strQualifierName,&varData,lFlavor);

				if( SUCCEEDED(hr))
				{
					//=================================================================================
					// This is becuase , we are just adding a qualifier not a new instance
					//=================================================================================
					bNewInst		= FALSE;
					bRowModified	= TRUE;
				}
			}
			else
			{
				//=================================================================================
				// This is because one of the column values expected is NULL or empty
				//=================================================================================
				hr				= DB_E_INTEGRITYVIOLATION;		
				bRowModified	= TRUE;
			}
			SysFreeString(strQualifierName);
			VariantClear(&varData);
		}

	}
	else
    for (ibind = 0; ibind < (int)pAccessor->cBindings; ibind++)
	{
		icol = pAccessor->rgBindings[ibind].iOrdinal;

	    pColumnData = (COLUMNDATA *) (((BYTE *)pRowBuff )+ m_Columns.GetDataOffset(icol));
		//=================================================================================
		// If the columndata is modified then 
		//=================================================================================
		if(pColumnData->dwStatus & COLUMNSTAT_MODIFIED)
		{
			bstrColName = Wmioledb_SysAllocString((OLECHAR *)m_Columns.ColumnName(icol));
			// this variable gets value only if the CIMTYPE is array
			dwCIMType = -1;
			// if the type is array , then get the original CIMTYPE as array type will
			// be given out as VT_ARRAY  | VT_VARIANT
			if(pColumnData->dwType & DBTYPE_ARRAY)
			{
				dwCIMType = m_Columns.GetCIMType(icol);
			}
			if( pColumnData->pbData == NULL)
			{
				varData.vt = VT_NULL;
			}
			else
			{
				//=================================================================================
				// Call this function to convert the data to the appropriate datatype in a variant
				//=================================================================================
				dataMap.MapAndConvertOLEDBTypeToCIMType((USHORT)pColumnData->dwType,pColumnData->pbData,pColumnData->dwLength,varData,dwCIMType);
			}

			if( m_uRsType == 0)
			{
				//=================================================================================
				// Update the property
				//=================================================================================
				hr = m_pMap->SetProperty(pInst,bstrColName,&varData);
			}

 			pColumnData->dwStatus &= ~COLUMNSTAT_MODIFIED;

			VariantClear(&varData);
			SysFreeString(bstrColName);
			bRowModified = TRUE;
		}

	}
	
	if(SUCCEEDED(hr) && (bRowModified == TRUE || bNewInst == TRUE))
	{
		hr = m_pMap->UpdateInstance(pInst , bNewInst);
	}

	return hr;

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to update a row to WMI
// this is called from Row Object
// NTRaid : 143868
//	07/15/00
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::UpdateRowData(HROW hRow,DBORDINAL cColumns,DBCOLUMNACCESS rgColumns[ ])
{
	HRESULT				hr			= S_OK;
	PROWBUFF			pRowBuff	= NULL;
	DBORDINAL			lIndex		= 0;
	COLUMNDATA *		pColumnData = NULL;
	CWbemClassWrapper * pInst		= NULL;
	DBORDINAL			icol		= 0;

	BSTR				bstrColName;
	CDataMap			dataMap;
	VARIANT				varData;
	VariantInit(&varData);
	LONG				lFlavor = 0;
	BSTR				strQualifierName =Wmioledb_SysAllocString(NULL);
	DWORD				dwCIMType = 0;

	// get the pointer to the instance
	if(m_bIsChildRs == FALSE)
	{
		if(	m_uRsType == PROPERTYQUALIFIER ||
			m_uRsType == CLASSQUALIFIER )
		{
			pInst = m_pInstance;
		}
		else
		if( m_uRsType !=  COLUMNSROWSET &&  m_uRsType !=  SCHEMA_ROWSET &&  m_uRsType !=  METHOD_ROWSET)
		{
			pInst = m_InstMgr->GetInstance(hRow);
		}
	}
	else
	{
		pInst = m_pChapterMgr->GetInstance(m_pChapterMgr->GetChapterForHRow(hRow));
	}

    //=========================================
	// Get the pointer to the row data
    //=========================================
	pRowBuff = GetRowBuff((ULONG) hRow, TRUE );


	// NTRaid:111823-111825
	// 06/07/00
	// If the row is not an instance or qualifier
	if(pInst == NULL)
	{
		hr = DB_E_NOTSUPPORTED;
	}
	else
	//================================================
	// IF the rowset is a qualifier type rowset 
    //================================================
	if(	m_uRsType == PROPERTYQUALIFIER || m_uRsType == CLASSQUALIFIER )
	{
		icol = GetOrdinalFromColName(rgColumns[lIndex].columnid.uName.pwszName);

	    //===============================================
		// Only qualifier value can be modified
	    //===============================================
		if(cColumns == 1 && icol == QUALIFIERVALCOL)
		{
		    //===============================================
			// get the qualifier name
		    //===============================================
			pColumnData = (COLUMNDATA *) (((BYTE *)pRowBuff )+ m_Columns.GetDataOffset(QUALIFIERNAMECOL));
			if( pColumnData->pbData == NULL)
			{
				hr	= DB_E_INTEGRITYVIOLATION;		// This is because one of the column values expected
													// is NULL or EMPTY
			}
			else
			{
				strQualifierName = Wmioledb_SysAllocString((WCHAR *)pColumnData->pbData);

			    //===============================================
				// Get the qualifier Value
			    //===============================================
				pColumnData = (COLUMNDATA *) (((BYTE *)pRowBuff )+ m_Columns.GetDataOffset(QUALIFIERVALCOL));
				VariantCopy(&varData,(VARIANT *)pColumnData->pbData);

			    //===============================================
				// Get the qualifier flavor
			    //===============================================
				pColumnData = (COLUMNDATA *) (((BYTE *)pRowBuff )+ m_Columns.GetDataOffset(QUALIFIERFLAVOR));
				lFlavor = pColumnData->pbData !=NULL ? *(LONG *)pColumnData->pbData : 0 ;

				if( varData.vt != VT_EMPTY  || varData.vt != VT_NULL)
				{
					//===============================================
					// Set the qualifier
					//===============================================
					hr = m_pMap->SetQualifier(pInst,m_strPropertyName,strQualifierName,&varData,lFlavor);

				}
				else
				{
					//========================================================
					// This is because one of the column values expected
					//is NULL or EMPTY
					//========================================================
					hr				= DB_E_INTEGRITYVIOLATION;		 
				}
				SysFreeString(strQualifierName);
				VariantClear(&varData);
			}
		}
		else
		{
			//====================================================
			// Only qualifier value can be modified
			//====================================================
			hr = E_FAIL;
		}

	}
	else
    for (lIndex = 0; lIndex < cColumns; lIndex++)
	{
		icol = GetOrdinalFromColName(rgColumns[lIndex].columnid.uName.pwszName);

		//=============================================================================
		// If the column is not present in the rowset it is already updated in the 
		// row. This will happen only when this method is called from the row object
		//=============================================================================
		if( (DB_LORDINAL)icol < 0)
		{
			continue;
		}

	    pColumnData = (COLUMNDATA *) (((BYTE *)pRowBuff )+ m_Columns.GetDataOffset(icol));

		//=============================================================================
		// If the columndata is modified then 
		//=============================================================================
		if(pColumnData->dwStatus & COLUMNSTAT_MODIFIED)
		{
			bstrColName = Wmioledb_SysAllocString((OLECHAR *)m_Columns.ColumnName(icol));
			dwCIMType = -1;
			//===================================================================================
			// if the type is array , then get the original CIMTYPE as array type will
			// be given out as VT_ARRAY  | VT_VARIANT
			//===================================================================================
			if(pColumnData->dwType & DBTYPE_ARRAY)
			{
				dwCIMType = m_Columns.GetCIMType(icol);
			}

			if( pColumnData->pbData == NULL)
			{
				varData.vt = VT_NULL;
			}
			else
			{
				//===================================================================================
				// Call this function to convert the data to the appropriate datatype in a variant
				//===================================================================================
				dataMap.MapAndConvertOLEDBTypeToCIMType((USHORT)pColumnData->dwType,pColumnData->pbData,pColumnData->dwLength,varData,dwCIMType);
			}
			//================================
			// Update the property
			//================================
			if( m_uRsType == 0)
			{
				//==================================
				// Update the property
				//==================================
				hr = m_pMap->SetProperty(pInst,bstrColName,&varData);
			}
			pColumnData->dwStatus &= ~COLUMNSTAT_MODIFIED;

			VariantClear(&varData);
			SysFreeString(bstrColName);
		}

	}

	//=============================================================================
	// If everything is fine then update the instance
	//=============================================================================
	if( hr == S_OK)
	{
		hr = m_pMap->UpdateInstance(pInst , FALSE);
	}

	return hr;

}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to delete a instance(Row) from WMI
// NTRaid : 143524
//	07/15/00
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::DeleteRow(HROW hRow,DBROWSTATUS * pRowStatus)
{
	HRESULT hr = S_OK;
	DBROWOPTIONS	rgRowOptions[1];
	ULONG 			rgRefCounts[1];
	DBROWSTATUS		rgRowStatus[1];
	CWbemClassWrapper *pInst = NULL;
	VARIANT			varProp;
	PROWBUFF			pRowBuff	= NULL;
	COLUMNDATA *		pColumnData = NULL;

	VariantInit(&varProp);

	memset(rgRowOptions,0,sizeof(DBROWOPTIONS));
	memset(rgRowStatus,0,sizeof(DBROWSTATUS));
	rgRefCounts[0] = 0;

	if(pRowStatus != NULL)
		*pRowStatus = DBROWSTATUS_S_OK;

	//===================================================================
	/// get the instance pointer corresponding to the HROW passed
	// if rowset is referiing to a class and not to qualifiers then
	//===================================================================
	if(m_bIsChildRs == FALSE)
	
	{
		if(	m_uRsType == PROPERTYQUALIFIER ||
			m_uRsType == CLASSQUALIFIER )
		{
			pInst = m_pInstance;
		}
		else
		if( m_uRsType !=  COLUMNSROWSET &&  m_uRsType !=  SCHEMA_ROWSET &&  m_uRsType !=  METHOD_ROWSET)
		{
			pInst = m_InstMgr->GetInstance(hRow);
		}

	}
	//===================================================================
	// if the recordset is a child rs and representing a qualifier
	//===================================================================
	else 
	{
		//===================================================================
		// get the instance pointer corresponding to the 
		//===================================================================
		pInst = m_pChapterMgr->GetInstance(m_pChapterMgr->GetChapterForHRow(hRow));
	}

	// NTRaid:111800
	// 06/07/00
	// If the row is not an instance or qualifier
	if(pInst == NULL)
	{
		hr = DB_E_NOTSUPPORTED;
	}
	else
	// NTRaid : 143425
	// 07/17/00
	if(	m_uRsType == PROPERTYQUALIFIER ||
		m_uRsType == CLASSQUALIFIER )
	{
		// Delete qualifier
		//=========================================
		// Get the pointer to the row data
		//=========================================
		pRowBuff = GetRowBuff(hRow, TRUE );

		//=============================================
		// Get the Data for the qualifier name
		//=============================================
	    pColumnData = (COLUMNDATA *) (((BYTE *)pRowBuff )+ m_Columns.GetDataOffset(QUALIFIERNAMECOL));

		//================================================================================
		// This will always of type VT_BSTR as this column represents the QUALIFER name
		//================================================================================
		if(pColumnData->dwType == VT_BSTR)
		{
			hr = m_pMap->DeleteQualifier(pInst,(BSTR)pColumnData->pbData,(m_uRsType == CLASSQUALIFIER),m_strPropertyName);
		}

	}
	else
	if( m_uRsType !=  COLUMNSROWSET &&  m_uRsType !=  SCHEMA_ROWSET &&  m_uRsType !=  METHOD_ROWSET)
	{
		//===================================
		// Delete the Instance
		//===================================
		hr  = m_pMap->DeleteInstance(pInst);
	}
	else
	{
		hr = WBEM_E_PROVIDER_NOT_CAPABLE;
	}
	//===================================================================
	// If delete is not allowed if it is not capable of deletion then
	// set the updatibility property of the rowset
	//===================================================================
	if( hr == WBEM_E_PROVIDER_NOT_CAPABLE)
	{
		GetRowsetProperty(DBPROP_UPDATABILITY,varProp);
		varProp.lVal ^= DBPROPVAL_UP_DELETE;

		SetRowsetProperty(DBPROP_UPDATABILITY,varProp);
		hr = DB_E_NOTSUPPORTED;
		if(pRowStatus)
		{
			*pRowStatus = DBROWSTATUS_E_INTEGRITYVIOLATION;
		}
	}
	else
	if(FAILED(hr) && (pRowStatus != NULL))
	{
		if(pRowStatus)
		{
			*pRowStatus = DBROWSTATUS_E_FAIL;
		}
	}
	if( hr == S_OK)
	{
		//====================================
		// Set the row status to DELETED
		//====================================
		SetRowStatus(hRow,DBROWSTATUS_E_DELETED);
		if(pRowStatus)
		{
			*pRowStatus = DBROWSTATUS_S_OK;
		}

	}

	return hr;
	
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set the status of a row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CRowset::SetRowStatus(HROW hRow , DBSTATUS dwStatus)
{
	if(m_bIsChildRs == FALSE)
	{
		m_InstMgr->SetRowStatus(hRow , dwStatus);
	}
	else
	{
		m_pChapterMgr->SetRowStatus(hRow , dwStatus);
	}


}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Gets the current status of the row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
DBSTATUS CRowset::GetRowStatus(HROW hRow )
{
	DBSTATUS dwStatus = DBROWSTATUS_E_FAIL;
	if(m_bIsChildRs == FALSE)
	{
		dwStatus = m_InstMgr->GetRowStatus(hRow);
	}
	else
	{
		dwStatus = m_pChapterMgr->GetRowStatus(hRow);
	}

	return  dwStatus;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Gets Key value of a instance
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CRowset::GetInstanceKey(HROW hRow , BSTR *strKey)
{
	CWbemClassWrapper *pInst = NULL;

	//====================================
	// get the pointer to the instance
	//====================================
	if(m_bIsChildRs == FALSE)
	{
		pInst = m_InstMgr->GetInstance(hRow);
		m_InstMgr->GetInstanceKey(hRow,strKey);
	}
	else
	{
		pInst = m_pChapterMgr->GetInstance(m_pChapterMgr->GetChapterForHRow(hRow));
		m_pChapterMgr->GetInstanceKey(hRow,strKey);
	}

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set the status of a rowset or a chapter
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CRowset::SetStatus(HCHAPTER hChapter , DWORD dwStatus)
{
	if(m_bIsChildRs == FALSE)
	{
		//================================
		// skip caused END_OF_ROWSET
		//================================
		m_dwStatus |= dwStatus;
	}
	else
	{
		//========================================================================
		// set the status of the chapter to end of rowset
		//========================================================================
		m_pChapterMgr->SetChapterStatus(hChapter , dwStatus);
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Gets the status of a rowset or a chapter
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
DBSTATUS CRowset::GetStatus(HCHAPTER hChapter)
{
	DBSTATUS dwStatus = 0;

	if(m_bIsChildRs == FALSE)
	{
		//================================
		// skip caused END_OF_ROWSET
		//================================
		dwStatus = m_dwStatus;
	}
	else
	{
		//========================================================================
		// set the status of the chapter to end of rowset
		//========================================================================
		dwStatus = m_pChapterMgr->GetChapterStatus(hChapter );
	}

	return dwStatus;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Adds a new instance to the class
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::InsertNewRow(CWbemClassWrapper **ppNewInst)
{
	HRESULT hr = S_OK;
	switch(m_uRsType)
	{
		case PROPERTYQUALIFIER:
			break;

		case CLASSQUALIFIER:
			break;

		case SCHEMA_ROWSET:
			hr = DB_E_NOTSUPPORTED;
			break;

		case 0:
			 hr = m_pMap->AddNewInstance(ppNewInst);
			break;

		default:
			hr = E_FAIL;
	}

	return hr;

}

///////////////////////////////////////////////////////////////////////////////////////
// Function which releases the rowdata ( does not release the row)
// release the memory allocated for the row and also the slot allocated for the row
///////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::ReleaseRowData(HROW hRow,BOOL bReleaseSlot)
{
	HSLOT	hSlot	= 0;
	HRESULT	hr		= S_OK;


	//===================================================================
	/// get the handle to slot
	//===================================================================
	if(m_bIsChildRs == FALSE)
	
	{
		//===================================================================
		// get the handle to slot for the instance
		//===================================================================
		hSlot = m_InstMgr->GetSlot(hRow);

		if(bReleaseSlot)
		{
			// Reset the HSLOT in the chapter Manager
			m_InstMgr->SetSlot(hRow , -1);
		}
	}
	//===================================================================
	// if the recordset is a child rs and representing a qualifier
	//===================================================================
	else 
	{
		//===================================================================
		// get the handle to slot for the instance
		//===================================================================
		hSlot = m_pChapterMgr->GetSlot(hRow);
		//================================================
		// Reset the HSLOT in the chapter Manager
		//================================================
		if(bReleaseSlot)
		{
			m_pChapterMgr->SetSlot(hRow ,-1);
		}

	}

	if( hSlot > 0)
	{
		if (FAILED( Rebind((BYTE *) GetRowBuffFromSlot( hSlot, TRUE ))))
		{
			hr =   E_FAIL ;
		}
		else
		{
			//===========================================================
			// release the memory allocated for the different columns
			//===========================================================
			m_pRowData->ReleaseRowData();
		
			//==============================
			// release the slots
			//==============================
			if(bReleaseSlot)
			{
				ReleaseSlots( m_pIBuffer, hSlot, 1 );
			}
		}
	}

	
	return hr;

}


/////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Virtual Overidden function which is called from IColumnInfo to get the column information
/////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::GetColumnInfo(DBORDINAL* pcColumns, DBCOLUMNINFO** prgInfo,WCHAR** ppStringsBuffer)
{
    ULONG           icol = 0;
    DBCOLUMNINFO*   rgdbcolinfo = NULL;
    WCHAR*          pstrBuffer = NULL;
    WCHAR*          pstrBufferForColInfo = NULL;
	HRESULT			hr = S_OK;
	DBCOUNTITEM		nTotalCols = m_cTotalCols;
	BOOL			bFlag = TRUE;

	if(!(m_ulProps & BOOKMARKPROP))
	{
		nTotalCols--;
		bFlag = FALSE;
	}

	//=======================================
	// Copy the columninformation
	//=======================================
	if(SUCCEEDED(hr = m_Columns.CopyColumnInfoList(rgdbcolinfo,bFlag)))
	{
		//===========================================
		// Copy the heap for column names.
		//===========================================
		if ( m_Columns.ColumnNameListStartingPoint() != NULL){

			ptrdiff_t dp;

			hr = m_Columns.CopyColumnNamesList(pstrBuffer);
			dp = (LONG_PTR) pstrBuffer - (LONG_PTR) (m_Columns.ColumnNameListStartingPoint());
			dp >>= 1;

			//===========================================
			// Loop through columns and adjust pointers 
			// to column names.
			//===========================================
			for ( icol =0; icol < nTotalCols; icol++ )
			{
				if ( rgdbcolinfo[icol].pwszName )
				{
					rgdbcolinfo[icol].pwszName += dp;
				}
			}
		}

		//==============================
		// Set the output parameters
		//==============================
		*prgInfo = &rgdbcolinfo[0];			
		*ppStringsBuffer = pstrBuffer;
		*pcColumns = nTotalCols; 
	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////////////////////////////////
//  get the instance pointer of a particular row
/////////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemClassWrapper *CRowset::GetInstancePtr(HROW hRow)
{
	CWbemClassWrapper *pInst = NULL;

	if(m_bIsChildRs == FALSE)
	{
		pInst = m_InstMgr->GetInstance(hRow);
	}
	else
	{
		pInst = m_pChapterMgr->GetInstance(m_pChapterMgr->GetChapterForHRow(hRow));
	}

	return pInst;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Get the qualifier name which will be present in the first column for 
//  qualifier rowset
/////////////////////////////////////////////////////////////////////////////////////////////////////////
void CRowset::GetQualiferName(HROW hRow,BSTR &strBookMark)
{
	PROWBUFF pRowBuff = NULL;
	PCOLUMNDATA pColumnData = NULL;

	pRowBuff = GetRowBuff( (ULONG) hRow, TRUE );
    pColumnData = (COLUMNDATA *) ((BYTE *) pRowBuff + m_Columns.GetDataOffset(0));

	//===================================================================
	// FIXXX More work is to be done on this
	//===================================================================
	if( pColumnData->dwType == DBTYPE_BSTR )
		strBookMark         = Wmioledb_SysAllocString((WCHAR *)(pColumnData->pbData));
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Generate a new HCHAPTER for the current row and add it to the CHAPTER manager
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::FillHChaptersForRow(CWbemClassWrapper *pInst, BSTR strKey)
{
	HRESULT			hr			= S_OK;
	ULONG			nIndex		= 0;
	PCOLUMNDATA *	pColumnData = NULL;
	CVARIANT		var;
	HCHAPTER		hChapter	= 0;

    //============================================================================
	// if there are nested columns in the rowset
    //============================================================================
	if(m_cNestedCols > 0)
	{
		for ( ULONG nIndex = 0 ; nIndex < m_cTotalCols ; nIndex++)
		{
		    //============================================================================
			// if the columntype is of CHAPTER then allocate a rowset and initialize
		    //============================================================================
			if(m_Columns.ColumnFlags(nIndex) & DBCOLUMNFLAGS_ISCHAPTER )
			{
				hChapter = GetNextHChapter();
		        var.SetLONG((LONG)hChapter);
				if(FAILED(hr = m_pRowData->CommitColumnToRowData(var,nIndex,VT_UI4)))
				{
					break;
				}
				
			    //============================================================================
				// Add the chapter to the corresponding child recordset
			    //============================================================================
				m_ppChildRowsets[nIndex]->m_pChapterMgr->AddChapter(hChapter);
				m_ppChildRowsets[nIndex]->m_pChapterMgr->SetInstance(hChapter,pInst,strKey);
			} // if for columntype
		} // for
	}

	return hr;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to add reference to a chapter
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::AddRefChapter(HCHAPTER hChapter,DBREFCOUNT * pcRefCount)
{
	HRESULT hr = E_UNEXPECTED;
	ULONG ulRet = -1;

    //===========================================
	// if the rowset is a child rowset
    //===========================================
	if(m_bIsChildRs == TRUE)
	{
	    //=======================================
		// If chapter belongs to the rowset
	    //=======================================
		if(m_pChapterMgr->IsExists(hChapter) == FALSE)
		{
			hr = DB_E_BADCHAPTER;
		}
		else
		{
			//===================================
			// Add reference to the chapter
			//===================================
			ulRet = m_pChapterMgr->AddRefChapter(hChapter);
			if( ulRet > 0)
			{		
				hr = S_OK;
			}
		}
	
	}
	if(pcRefCount != NULL)
	{
		*pcRefCount = ulRet;
	}

	return hr;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to release reference to a chapter
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::ReleaseRefChapter(HCHAPTER hChapter , ULONG * pcRefCount)
{
	HRESULT hr = E_UNEXPECTED;
	ULONG ulRet = -1;
	//=======================================
	// if the rowset is a child rowset
	//=======================================
	if(m_bIsChildRs == TRUE)
	{
		//===================================
		// If chapter belongs to the rowset
		//===================================
		if(m_pChapterMgr->IsExists(hChapter) == FALSE)
		{
			hr = DB_E_BADCHAPTER;
		}
		else
		{
			//======================================
			// Release reference to the chapter
			//======================================
			ulRet = m_pChapterMgr->ReleaseRefChapter(hChapter);
			if(((LONG)ulRet) >= 0)
			{
				hr = S_OK;
			}
		}
	
	}
	
	if(pcRefCount != NULL)
	{
		*pcRefCount = ulRet;
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the number of rows in the rowset
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::GetRowCount()
{
	HRESULT hr = S_OK;
	switch(m_uRsType)
	{
		case PROPERTYQUALIFIER:
			m_lRowCount = -1;
			break;

		case CLASSQUALIFIER:
			m_lRowCount	= -1;
			break;

		case SCHEMA_ROWSET:
			m_lRowCount	= -1;
			break;

		case 0:
		case COMMAND_ROWSET:
			 hr = m_pMap->GetInstanceCount(m_lRowCount);
			break;

		default:
			hr = E_FAIL;
	}
	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the Data to local buffer for a particular row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowset::GetDataToLocalBuffer(HROW hRow)
{
	HSLOT	hSlot	= 0;
	HRESULT hr		= S_OK;
	BSTR strBookMark = Wmioledb_SysAllocString(NULL);
	
	if(m_uRsType == PROPERTYQUALIFIER || 
		m_uRsType == CLASSQUALIFIER )
	{
		GetQualiferName(hRow,strBookMark);
	}

	hSlot = GetSlotForRow(hRow);

	if (FAILED( Rebind((BYTE *) GetRowBuffFromSlot( hSlot, TRUE ))))
	{
		hr = E_FAIL;
	}
	else
	{
		//======================================
		// Release the previous row data
		//======================================
		m_pRowData->ReleaseRowData();	
		//======================================
		// Get the data for the current row
		//======================================
		if(SUCCEEDED(hr = GetData(hRow,strBookMark)))
		{
			m_ulLastFetchedRow = hRow;
		}

		if( strBookMark != NULL)
		{
			SysFreeString(strBookMark);
		}
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Check if a particular instance is deleted.
// A particular instance is deleted , if it is deleted from WMI and appropriate properties are
// set for different cursor types
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CRowset::IsInstanceDeleted(CWbemClassWrapper *pInst)
{
	DWORD dwStatus = m_pMap->GetInstanceStatus(pInst);
	BOOL bRet = FALSE;

	//===================================
	// if the cursor is dynamic
	//===================================
	if((m_ulProps & OTHERINSERT) && dwStatus != DBSTATUS_S_OK)
	{
		bRet =  TRUE;
	}
	else
	if(((m_ulProps & OWNUPDATEDELETE) && dwStatus == DBROWSTATUS_E_DELETED) || 
		((m_ulProps & OTHERUPDATEDELETE)  && dwStatus == DBSTATUS_E_UNAVAILABLE))
	{
		bRet = TRUE;
	}
	
	return bRet;
}

void CRowset::SetCurFetchDirection(FETCHDIRECTION FetchDir) 
{ 
	m_FetchDir = FetchDir;
	m_pMap->SetCurFetchDirection(FetchDir); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\rowfetchobj.cpp ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CRowFetchObj class implementation
// 
//
///////////////////////////////////////////////////////////////////////////////////

#include "headers.h"
#include "WmiOleDBMap.h"

/////////////////////////////////////////////////////////////////////////////////////
////CRowFetchObj class Implementation
/////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////
// Function which fetches data and puts it into the given buffer
// NTRaid:111834
// 06/07/00
///////////////////////////////////////////////////////////////////////////////////////////
HRESULT	CRowFetchObj::FetchData(CRowset *	  pRowset,
					  HROW  hRow,             //IN  Row Handle
                      HACCESSOR   hAccessor,  //IN  Accessor to use
                      void       *pData  )
{


	// NTRaid:111834
	// 06/13/00
    PACCESSOR   pAccessor		= NULL;
    DBORDINAL   icol			= 0;
	DBORDINAL	ibind			= 0;
    ROWBUFF     *pRowBuff		= NULL;
    COLUMNDATA  *pColumnData	= NULL;
    DBBINDING   *pBinding		= NULL;
    DBROWCOUNT  cBindings		= NULL;
    ULONG       ulErrorCount	= 0;
    DBTYPE      dwSrcType		= 0;
    DBTYPE      dwDstType		= 0;
    void        *pSrc			= NULL;
    void        *pDst			= NULL;
    DBLENGTH    ulSrcLength		= 0;
    DBLENGTH    *pulDstLength	= NULL;
    DBLENGTH    ulDstMaxLength	= 0;
    DBSTATUS    dwSrcStatus		= 0;
    DBSTATUS    *pdwDstStatus	= NULL;
    DWORD       dwPart			= 0;
    HRESULT     hr				= S_OK;
	HSLOT		hSlot			= 0;
	BOOL		bUseDataConvert = TRUE;

	CWbemClassWrapper * pInst = NULL;
	CDataMap		dataMap;


    //========================================================================================
    // Coerce data for row 'hRow', according to hAccessor. Put in location 'pData'.  
    // Offsets and types are in hAccessor's bindings.
    //
    // Return S_OK if all lossless conversions,
    // return DB_S_ERRORSOCCURED if lossy conversion (truncation, rounding, etc.)
    // Return E_FAIL, etc., if horrible errors.

    // GetItemOfExtBuffer is basically operator[].
    // It takes an index (or handle) (referenced from 1...n),
    // and a ptr for where to write the data.
    //
    // It holds ptrs to a variable-length ACCESSOR struct.
    // So we get the ACCESSOR ptr for the client's accessor handle.
    //========================================================================================

    assert( pRowset->m_pIAccessor->GetAccessorPtr());
    hr = pRowset->m_pIAccessor->GetAccessorPtr()->GetItemOfExtBuffer( hAccessor, &pAccessor );
    if (FAILED( hr ) || pAccessor == NULL)
	{
        hr = DB_E_BADACCESSORHANDLE;
	}
	else
	{
		assert( pAccessor );
		cBindings = pAccessor->cBindings;
		pBinding  = pAccessor->rgBindings;

		//========================================================================================
		// Ensure a place to put data, unless the accessor is the null accessor then
		// a NULL pData is okay.
		//========================================================================================
		if ( pData == NULL && cBindings != 0 )
		{
			hr =  E_INVALIDARG ;
		}
		else
		//========================================================================================
		// IsSlotSet returns S_OK    if row is marked.
		//                   S_FALSE if row is not marked.
		// The "mark" means that there is data present in the row.
		// Rows are [1...n], slot marks are [0...n-1].
		//========================================================================================
		if (pRowset->IsSlotSet(hRow ) != S_OK)
		{
			hr = DB_E_BADROWHANDLE;
		}
		else
		//===================================================================
		// if data is not already fetched to the memory ( which is done
		// if other updatedelete is false)
		//===================================================================
		if( (pRowset->m_ulProps & OTHERUPDATEDELETE) && (pRowset->m_ulLastFetchedRow != hRow))
		{
			if(SUCCEEDED (hr = pRowset->GetDataToLocalBuffer(hRow)))
			{
				pRowset->m_ulLastFetchedRow = hRow;
			}

		}
    
		if(SUCCEEDED(hr))
		{
			//========================================================================================
			// Internal error for a 0 reference count on this row,
			// since we depend on the slot-set stuff.
			//========================================================================================
			pRowBuff = pRowset->GetRowBuff( (ULONG) hRow, TRUE );
			assert( pRowBuff->ulRefCount );

			//========================================================================================
			// Check for the Deleted Row
			//========================================================================================
			ulErrorCount = 0;
			for (ibind = 0; ibind < (DBORDINAL)cBindings; ibind++) {
				
				bUseDataConvert = TRUE;
				icol = pBinding[ibind].iOrdinal;
		//		pColumnData = pRowBuff->GetColumnData(icol);

				//========================================================================================
				// If bookmark is not requested by setting the DBPROP_BOOKMARK property
				// then skip getting the bookmark
				//========================================================================================
				if(!(pRowset->m_ulProps & BOOKMARKPROP) && icol == 0)
				{
					continue;
				}
				else
				//========================================================================================
				// if it is a bookmark column get the bookmark column from the ROWBUFF Structure
				//========================================================================================
				if(icol == 0)
				{
					dwSrcType	= DBTYPE_I4;
					pSrc		= &pRowBuff->dwBmk;
					ulSrcLength	= pRowBuff->cbBmk;
					dwSrcStatus	= DBSTATUS_S_OK;
				}
				else
				{
					pColumnData = (COLUMNDATA *) ((BYTE *) pRowBuff + pRowset->m_Columns.GetDataOffset(icol));

					dwSrcType      = (DBTYPE)pColumnData->dwType ; //pRowset->m_Columns.ColumnType(icol);

					//===================================================================
					// FIXXX More work is to be done on this
					//===================================================================
					if( dwSrcType == DBTYPE_BSTR )
					{
						pSrc           = &(pColumnData->pbData);
					}
					else
					{
						pSrc           = (pColumnData->pbData);
					}

					ulSrcLength    = pColumnData->dwLength;
					dwSrcStatus    = pColumnData->dwStatus;

					if(dwSrcType == DBTYPE_HCHAPTER)
					{
						dwSrcType = DBTYPE_UI4;
					}
				}

				ulDstMaxLength = pBinding[ibind].cbMaxLen;
				dwDstType      = pBinding[ibind].wType;
				dwPart         = pBinding[ibind].dwPart;

				pDst           = dwPart & DBPART_VALUE ? ((BYTE*) pData + pBinding[ibind].obValue) : NULL;
				pulDstLength   = dwPart & DBPART_LENGTH ? (DBLENGTH *) ((BYTE*) pData + pBinding[ibind].obLength) : NULL;
				pdwDstStatus   = dwPart & DBPART_STATUS ? (DBSTATUS *) ((BYTE*) pData + pBinding[ibind].obStatus) : NULL;

				//==========================================================
				// if the column is of type chapter then consider that
				// as a of type long as HCHAPTER is a ULONG value
				//==========================================================

				if(dwDstType == DBTYPE_HCHAPTER)
				{
					dwDstType = DBTYPE_UI4;
				}
				if((dwSrcType & DBTYPE_ARRAY) && (dwDstType & DBTYPE_ARRAY))
				{
					bUseDataConvert = FALSE;
				}
				
				if( dwSrcType != VT_NULL && dwSrcType != VT_EMPTY && bUseDataConvert == TRUE && pSrc != NULL)
				{
					BSTR strData;
					if( dwDstType == DBTYPE_BSTR && pDst == NULL)
					{
						void **pTemp = &pDst;
						*pTemp = (void *)&strData;
					}

					hr = g_pIDataConvert->DataConvert(
							dwSrcType,
							dwDstType,
							ulSrcLength,
							pulDstLength,
							pSrc,
							pDst,
							ulDstMaxLength,
							dwSrcStatus,
							pdwDstStatus,
							pBinding[ibind].bPrecision,	// bPrecision for conversion to DBNUMERIC
							pBinding[ibind].bScale,		// bScale for conversion to DBNUMERIC
							DBDATACONVERT_DEFAULT);

					if(!(dwPart & DBPART_VALUE) && pulDstLength != NULL)
					{
						hr =g_pIDataConvert->GetConversionSize(dwSrcType,dwDstType,&ulSrcLength,pulDstLength,pSrc);
					}

					if(!(dwPart & DBPART_VALUE) && dwDstType == DBTYPE_BSTR )
					{
						if(pulDstLength != NULL)
						{
							*pulDstLength = SysStringLen(strData);
						}
						SysFreeString(strData);
					}

					if(hr == DB_E_UNSUPPORTEDCONVERSION && pdwDstStatus != NULL)
					{
						*pdwDstStatus = DBSTATUS_E_CANTCONVERTVALUE;
					}
				}
				else
				if(bUseDataConvert == FALSE && pSrc != NULL )
				{
					

					if(pDst != NULL)
					{
						//========================================================================================
						// Call this function to get the array in the destination address
						//========================================================================================
						hr = dataMap.ConvertAndCopyArray((SAFEARRAY *)pSrc,(SAFEARRAY **)pDst, dwSrcType,dwDstType,pdwDstStatus);
					}
				
					if(pulDstLength != NULL)
					{
						*pulDstLength = sizeof(SAFEARRAY);
					}

					if( pdwDstStatus != NULL && *pdwDstStatus == DBSTATUS_E_CANTCONVERTVALUE && pulDstLength != NULL)
					{
						*pulDstLength = 0;
					}
				}
				else
				{
					if(pulDstLength)
					{
						*pulDstLength = 0;
					}
					if(pdwDstStatus)
					{
						*pdwDstStatus = DBSTATUS_S_ISNULL;
					}
				}
				if (hr != S_OK )
				{
					ulErrorCount++; // can't coerce
				}
			}	// for loop

		}	// if succeeded(hr)
	
	}		// else for check for bad accessor

	//===================================================================
    // We report any lossy conversions with a special status.
    // Note that DB_S_ERRORSOCCURED is a success, rather than failure.
	//===================================================================
    if ( SUCCEEDED(hr) )
	{
        hr = ( ulErrorCount ? DB_S_ERRORSOCCURRED : S_OK );
	}

	return hr;


}


///////////////////////////////////////////////////////////////////////////////////////////
// Function to clear all the allocated buffer if any error occurs while getting data
///////////////////////////////////////////////////////////////////////////////////////////
void CRowFetchObj::ClearRowBuffer(void       *pData,
									DBBINDING   *pBinding,
									int nCurCol)
{
    ULONG       *pulDstLength;
    DWORD       *pdwDstStatus;
	CDataMap	map;
	void		*pDst;
	DWORD		dwPart; 


    //========================================================================================
	// Check for the Deleted Row
    //========================================================================================
    for (int ibind = 0; ibind < nCurCol; ibind++) 
	{
		dwPart = pBinding[ibind].dwPart;

		pDst           = dwPart & DBPART_VALUE ? ((BYTE*) pData + pBinding[ibind].obValue) : NULL;
        pulDstLength   = dwPart & DBPART_LENGTH ? (ULONG *) ((BYTE*) pData + pBinding[ibind].obLength) : NULL;
        pdwDstStatus   = dwPart & DBPART_STATUS ? (ULONG *) ((BYTE*) pData + pBinding[ibind].obStatus) : NULL;

		if(pDst)
		{
			map.ClearData(pBinding[ibind].wType,(BYTE *)pDst);
		}
		if(pulDstLength)
		{
			*pulDstLength = 0;
		}
		if(pdwDstStatus)
		{
			*pdwDstStatus = 0;
		}
	}
}



///////////////////////////////////////////////////////////////////////////////////////////
// Function which get the position of the first row to be fetched
///////////////////////////////////////////////////////////////////////////////////////////
LONG_PTR CRowFetchObj::GetFirstFetchPos(CRowset *pRowset,DBCOUNTITEM cRows,DBROWOFFSET lOffset)
{
	FETCHDIRECTION lFetchDir;
	LONG_PTR lFirstPos = -1;

	lFetchDir = (LONG_PTR)cRows < 0 ? FETCHDIRBACKWARD : FETCHDIRFORWARD;

	if( cRows != 0)
	{
		lFirstPos = pRowset->m_lLastFetchPos + lOffset;

		if((pRowset->m_FetchDir != FETCHDIRNONE) && pRowset->m_FetchDir != lFetchDir)
		{
		}
		else
		{
			lFirstPos = (LONG_PTR)cRows < 0 ? lFirstPos - 1 : lFirstPos + 1;
		}
	}

	if(lFirstPos <= 0)
	{
		lFirstPos = -1;
	}

	return lFirstPos;
}


///////////////////////////////////////////////////////////////////////////////////////////
// Function which get the position of the first row to be fetched
//	NTRaid:111770
//	06/07/00
///////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowFetchObj::FetchRowsByBookMark(CRowset *	 pRowset,
													HCHAPTER		hChapter,        // IN  The Chapter handle.
													DBROWCOUNT		cRows,           // IN  Number of rows to fetch
													const DBBKMARK	rgcbBookmarks[],	//@parm IN  | an array of bookmark sizes
													const BYTE*		rgpBookmarks[],	//@parm IN  | an array of pointers to bookmarks
													HROW			rghRows[],			// OUT Array of Hrows obtained
													DBROWSTATUS		rgRowStatus[])       // OUT status of rows
{

	DBCOUNTITEM		ibmk, cErrors, cRowsObtained;
	PROWBUFF 		prowbuff;
	HROW	 		hrow, hrowFound;
	HRESULT  		hr;
	BYTE*			pbBmk;
	DBBKMARK   		cbBmk;
	DBROWSTATUS		dbrowstatus;
	ULONG_PTR		ulLastFetchPos;
	FETCHDIRECTION	lFetchDir;
	DBROWOFFSET		lOffset = 0;
	HROW	*		phRow;

	ulLastFetchPos	= pRowset->m_lLastFetchPos;
	lFetchDir		= pRowset->m_FetchDir;

	if(pRowset->m_FetchDir == FETCHDIRNONE)
	{
		pRowset->m_FetchDir = FETCHDIRFORWARD;
	}

    //========================================================================================
	// Now, loop thru all supplied bookmarks.
    //========================================================================================
	for (ibmk =0, cErrors =0; ibmk < (DBCOUNTITEM)cRows; ibmk++)
	{
		pbBmk = (BYTE*)&rgpBookmarks[ibmk];
		cbBmk = pbBmk? rgcbBookmarks[ibmk] : 0;

	    //========================================================================================
		// Must be a valid bookmark
	    //========================================================================================
		if (cbBmk != BOOKMARKSIZE)
		{
			dbrowstatus = DBROWSTATUS_E_INVALID;
			hrow = DB_NULL_HROW;
		}

	    //========================================================================================
		// We might already have this bookmark in our hashtable.
	    //========================================================================================
		else if (pRowset->m_pHashTblBkmark->InsertFindBmk(TRUE, 0,
					cbBmk, pbBmk, &hrow) == S_OK)	
		{
		    //========================================================================================
			// Row handle for this Bookmark was already in memory,
			// so return the row handle that was found.
		    //========================================================================================
			prowbuff = pRowset->GetRowBuffFromSlot(hrow);
			if (pRowset->GetRowStatus(hrow) & DBROWSTATUS_E_DELETED)
			{
				dbrowstatus = DBROWSTATUS_E_INVALID;
				hrow = DB_NULL_HROW;
			}
			else
			{
				dbrowstatus = DBROWSTATUS_S_OK;
				prowbuff->ulRefCount++;
			}
		}

		else
		//==========================================================================================
		//	if bookmark not alread present then fetch the row and put the bookmark in hash table
		//==========================================================================================
		{
			lOffset = *((ULONG *)pbBmk) - pRowset->m_lLastFetchPos;

			lOffset = (pRowset->m_FetchDir == FETCHDIRFORWARD) ? --lOffset : ++lOffset;

			cRowsObtained = 0;
			phRow	 = &hrow;

			//====================================================================================
			// Use a utility object method to fetch the row with the bookmark.
			//====================================================================================
			hr = FetchRows(pRowset,hChapter ,lOffset,ONE_ROW, &cRowsObtained, &phRow);

			//==========================================================================================
			// In case of any problem with fetching the row make an entry 
			// in the error array.
			//==========================================================================================
			if (FAILED(hr) || cRowsObtained < ONE_ROW)
			{
				dbrowstatus = (hr == E_OUTOFMEMORY)
								? DBROWSTATUS_E_OUTOFMEMORY
								: DBROWSTATUS_E_INVALID;
				hrow = DB_NULL_HROW;
			}
			else 
			{
				prowbuff = pRowset->GetRowBuffFromSlot(hrow);
				//==========================================================================
				// Now, enter this bookmark in our hashtable.
				//==========================================================================
				if (SUCCEEDED(hr))
				{
					prowbuff->cbBmk = BOOKMARKSIZE;
					prowbuff->dwBmk = rgcbBookmarks[ibmk];

					hr = (pRowset->m_pHashTblBkmark)->InsertFindBmk(FALSE,
						hrow, prowbuff->cbBmk, pbBmk, &hrowFound);
					if (FAILED(hr))	
					{
						ReleaseSlots(pRowset->m_pIBuffer,hrow, ONE_ROW);
						dbrowstatus = DBROWSTATUS_E_OUTOFMEMORY;
						hrow = DB_NULL_HROW;
					}
					else
					{
						assert(hr == S_FALSE);
						dbrowstatus = DBROWSTATUS_S_OK;
					}
				}
			}
		}

		// mark status.
		if (rgRowStatus)
			rgRowStatus[ibmk] = dbrowstatus;

		if (dbrowstatus != DBROWSTATUS_S_OK)
			cErrors++;

		// Put the rowhandle in the output array, and 
		rghRows[ibmk] = (HROW)hrow;
	}

	// Reverting back the state of the rowset
	pRowset->m_lLastFetchPos	= ulLastFetchPos;
	pRowset->m_FetchDir			= lFetchDir;

  	return 
		cErrors 
			? (cErrors < (ULONG)cRows) 
				? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED
			: S_OK;


}


///////////////////////////////////////////////////////////////////////////////////////////
// Function to fetch the next few rows as requested from the bookmark specified
///////////////////////////////////////////////////////////////////////////////////////////
HRESULT CRowFetchObj::FetchNextRowsByBookMark(CRowset *	 pRowset,
													HCHAPTER   hChapter,        // IN  The Chapter handle.
													DBBKMARK   cbBookmark,	// size of BOOKMARK
		 											const BYTE *   pBookmark,	// The bookmark from which fetch should start
													DBROWOFFSET    lRowsOffset,
													DBROWCOUNT     cRows,
													DBCOUNTITEM *  pcRowsObtained,
													HROW **        prghRows)	// array containing the row handles
{
	HRESULT hr = S_OK;

	//=====================================================================
	// Must be a valid bookmark
	//=====================================================================
	if (cbBookmark != BOOKMARKSIZE && cbBookmark != STD_BOOKMARKLENGTH)
	{
		hr = 	DB_E_BADBOOKMARK;

	}
	else
	//=============================================================================
	// If the bookmark is a standard bookmark
	//=============================================================================
	if( cbBookmark == STD_BOOKMARKLENGTH)
	{
		switch(*pBookmark)
		{
			case DBBMK_INVALID:
				return DB_E_BADBOOKMARK;

			case DBBMK_FIRST:
				lRowsOffset = lRowsOffset - pRowset->m_lLastFetchPos ;
				if(cRows < 0)
				{
					hr = DB_S_ENDOFROWSET;
				}
				break;

			case DBBMK_LAST:
				lRowsOffset = lRowsOffset + pRowset->m_lRowCount - pRowset->m_lLastFetchPos;
				if(cRows > 0)
				{
					hr = DB_S_ENDOFROWSET;
				}
				break;

		}

	}
	//=============================================================================
	// If not a standard bookmark
	//=============================================================================
	else
	{
		lRowsOffset = lRowsOffset + (*(ULONG_PTR *)pBookmark - pRowset->m_lLastFetchPos);

		// Adjust the offset , so that the first received row is correct
		lRowsOffset = cRows > 0 ? lRowsOffset -1 : lRowsOffset + 1;

	}

	if(hr == S_OK)
	{
		if( 0 > (LONG)(lRowsOffset + pRowset->m_lLastFetchPos) && 
			(lRowsOffset + pRowset->m_lLastFetchPos) > pRowset->m_lRowCount)
		{
			hr = DB_E_BADSTARTPOSITION;
		}
		else
		{
			// NTRaid : 134987
			// 07/12/00
			ULONG_PTR lPrevPos = pRowset->m_lLastFetchPos;
			FETCHDIRECTION lFetchDir = pRowset->GetCurFetchDirection();

			// set the direction flag on the enumerator so that the 
			// enumerator returns instance starting from the last instance 
			if(cbBookmark == STD_BOOKMARKLENGTH && *pBookmark == DBBMK_LAST)
			{
				pRowset->SetCurFetchDirection(FETCHDIRFORWARD);
			}

			//=============================================================================
			// call this function to fetch rows
			//=============================================================================
			if(SUCCEEDED(hr = FetchRows(pRowset,hChapter ,lRowsOffset,cRows, pcRowsObtained, prghRows)))
			{
				HRESULT hrLocal = S_OK;
				// Adjust the position of the enumerator after fetching
				ULONG_PTR lOffSetAdjust = lPrevPos -pRowset->m_lLastFetchPos;
				if(SUCCEEDED(hrLocal = pRowset->ResetRowsetToNewPosition(lOffSetAdjust,pRowset->m_pInstance)))
				{
					pRowset->m_lLastFetchPos = lPrevPos;
					pRowset->SetCurFetchDirection(lFetchDir);
				}

				if(FAILED(hrLocal))
				{
					hr = hrLocal;
				}
			}
		}
	}
	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\rowsetutil.cpp ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CChapter, CChapterMgr and CWMIInstanceMgr class implementation
//		- Implements utility classes to maintain rowset
// 
//
///////////////////////////////////////////////////////////////////////////////////

#include "headers.h"

////////////////////////////////////////////////////////////////////////////////////////
////   CChapter  class Implementation	
////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////
// Constructor
////////////////////////////////////////////////////////////////////////////////////////
CChapter::CChapter()
{
	m_pNext			= NULL;
	m_hChapter		= 0;
	m_pFirstRow		= NULL;
	m_pInstance		= NULL;
	m_cRefChapter	= 0;
	m_lCount		= 0;
	m_strKey		= NULL;
	m_dwStatus		= 0;

}

////////////////////////////////////////////////////////////////////////////////////////
// Destructor
////////////////////////////////////////////////////////////////////////////////////////
CChapter::~CChapter()
{
	CHRowsForChapter *pRowToDel = NULL;
	CHRowsForChapter *pRowTemp = NULL;

	pRowToDel = m_pFirstRow;
	
	while(pRowToDel)
	{
		pRowTemp = pRowToDel->m_pNext;
		delete pRowToDel;
		pRowToDel = pRowTemp; 
	}
	if(m_strKey)
	{
		SysFreeString(m_strKey);
	}
}

////////////////////////////////////////////////////////////////////////////////////////
// Add a HROW to the chapter
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CChapter::AddHRow(HROW hRow ,CWbemClassWrapper *pInstance, HSLOT hSlot)
{
	HRESULT hr = S_OK;
	CHRowsForChapter *pRowNew = NULL;
	CHRowsForChapter *pRowTemp = NULL;

	try
	{
		pRowNew					= new CHRowsForChapter;
	}
	catch(...)
	{
		SAFE_DELETE_PTR(pRowNew);
		throw;
	}
	if(pRowNew)
	{
		pRowNew->m_hRow			= hRow;
		pRowNew->m_hSlot		= hSlot;
		pRowNew->m_pInstance	= pInstance;
		
		if(pRowNew == NULL)
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			if(m_pFirstRow == NULL)
			{
				m_pFirstRow = pRowNew;
			}
			else
			{
				for(pRowTemp = m_pFirstRow ; pRowTemp->m_pNext != NULL ; pRowTemp = pRowTemp->m_pNext);

				pRowTemp->m_pNext = pRowNew;
			}
			m_lCount++;
		}
	
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
// Delete a HROW for the chapter
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CChapter::DeleteHRow(HROW hRow)
{
	HRESULT hr = E_FAIL;
	CHRowsForChapter *pRowToDel = NULL;
	CHRowsForChapter *pRowTemp = NULL;
	
	

	if(m_pFirstRow != NULL)
	{
		if(m_pFirstRow->m_hRow == hRow)
		{
			pRowToDel = m_pFirstRow;
			m_pFirstRow = m_pFirstRow->m_pNext;
			delete pRowToDel;
			hr = S_OK;
		}
		else
		{
			for(pRowTemp = m_pFirstRow ; pRowTemp->m_pNext != NULL ; pRowTemp = pRowTemp->m_pNext)
			{
				//==================================================
				// if the row searching is found then delete
				// the element from the list
				//==================================================
				if(pRowTemp->m_pNext->m_hRow == hRow)
				{
					pRowToDel = pRowTemp->m_pNext;
					pRowTemp->m_pNext = pRowToDel->m_pNext;
					delete pRowToDel;
					hr = S_OK;
					break;
				}
			}

		}
		m_lCount--;
	}
	
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
// Check if the HROW passed belongs to the chapter
////////////////////////////////////////////////////////////////////////////////////////
HRESULT CChapter::IsHRowOfThisChapter(HROW hRow)
{
	HRESULT hr = E_FAIL;
	CHRowsForChapter *pRowToDel = NULL;
	CHRowsForChapter *pRowTemp = NULL;
	
	

	if(m_pFirstRow != NULL)
	{
		for(pRowTemp = m_pFirstRow ; pRowTemp != NULL ; pRowTemp = pRowTemp->m_pNext)
		{
			//==================================================
			// if the row searching is found then delete
			// the element from the list
			//==================================================
			if(pRowTemp->m_hRow == hRow)
			{
				hr = S_OK;
				break;
			}
		}

	}
	
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get all the open rows in the list
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CChapter::GetAllHRowsInList(HROW *pHRows)
{
	HRESULT hr = S_OK;
	CHRowsForChapter *pRowTemp = NULL;
	int nIndex = 0;

	if(m_pFirstRow != NULL)
	{

		for(pRowTemp = m_pFirstRow ; pRowTemp != NULL ; pRowTemp = pRowTemp->m_pNext)
		{
			pHRows[nIndex++] = pRowTemp->m_hRow;
		}
	}

	return S_OK;

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to set the slot number for the row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CChapter::SetSlot(HROW hRow , HSLOT hSolt)
{
	HRESULT hr = E_FAIL;
	CHRowsForChapter *pRow = NULL;
	
	

	if(m_pFirstRow != NULL)
	{
		for(pRow = m_pFirstRow ; pRow != NULL ; pRow = pRow->m_pNext)
		{
			//==================================================
			// if the row searching is found then delete
			// the element from the list
			//==================================================
			if(pRow->m_hRow == hRow)
			{
				pRow->m_hSlot = hSolt;
				hr = S_OK;
				break;
			}
		}

	}
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get the slot number for a row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HSLOT CChapter::GetSlot(HROW hRow)
{
	HSLOT hSlot = -1;
	CHRowsForChapter *pRow = NULL;
	
	

	if(m_pFirstRow != NULL)
	{
		for(pRow = m_pFirstRow ; pRow != NULL ; pRow = pRow->m_pNext)
		{
			//==================================================
			// if the row searching is found then delete
			// the element from the list
			//==================================================
			if(pRow->m_hRow == hRow)
			{
				hSlot = pRow->m_hSlot;
				break;
			}
		}

	}
	return hSlot;
}

//////////////////////////////////////////////////////////////////////////////////
// This method is for chapter representing child rows of type Embeded classes
//////////////////////////////////////////////////////////////////////////////////
HRESULT CChapter::SetInstance(HROW hRow , BSTR strInstKey , CWbemClassWrapper *pInstance)
{
	CHRowsForChapter *pRow = NULL;
	HRESULT hr = E_FAIL;	
	

	if(m_pFirstRow != NULL)
	{
		for(pRow = m_pFirstRow ; pRow != NULL ; pRow = pRow->m_pNext)
		{
			//==================================================
			// if the row searching is found then delete
			// the element from the list
			//==================================================
			if(pRow->m_hRow == hRow)
			{
				pRow->m_pInstance	= pInstance;
				SAFE_FREE_SYSSTRING(pRow->m_strKey);
				pRow->m_strKey	= Wmioledb_SysAllocString(strInstKey);
				hr = S_OK;
				break;
			}
		}

	}
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////
// This method is for chapter representing child rows of type Embeded classes
//////////////////////////////////////////////////////////////////////////////////
CWbemClassWrapper * CChapter::GetInstance(HROW hRow)
{
	CHRowsForChapter *	pRow		= NULL;
	CWbemClassWrapper *	pRetInst	= NULL;
	

	if(m_pFirstRow != NULL)
	{
		for(pRow = m_pFirstRow ; pRow != NULL ; pRow = pRow->m_pNext)
		{
			//==================================================
			// if the row searching is found then delete
			// the element from the list
			//==================================================
			if(pRow->m_hRow == hRow)
			{
				pRetInst = pRow->m_pInstance;
				break;
			}
		}

	}
	return pRetInst;
}

//////////////////////////////////////////////////////////////////////////////////
// This method is for chapter representing child rows of type Embeded classes
//////////////////////////////////////////////////////////////////////////////////
HRESULT CChapter::GetInstanceKey(HROW hRow , BSTR *pstrKey)
{
	CHRowsForChapter *pRow = NULL;
	HRESULT hr = E_FAIL;

	if(m_pFirstRow != NULL)
	{
		for(pRow = m_pFirstRow ; pRow != NULL ; pRow = pRow->m_pNext)
		{
			//==================================================
			// if the row searching is found then delete
			// the element from the list
			//==================================================
			if(pRow->m_hRow == hRow)
			{
				*pstrKey = Wmioledb_SysAllocString(pRow->m_strKey);
				hr = S_OK;
				break;
			}
		}

	}
	return hr;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set the status of a particular row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CChapter::SetRowStatus(HROW hRow , DBSTATUS dwStatus)
{

	CHRowsForChapter *pRow = NULL;

	if(m_pFirstRow != NULL)
	{
		for(pRow = m_pFirstRow ; pRow != NULL ; pRow = pRow->m_pNext)
		{
			//==================================================
			// if the row searching is found then delete
			// the element from the list
			//==================================================
			if(pRow->m_hRow == hRow)
			{
				pRow->SetRowStatus(dwStatus);
				break;
			}
		}

	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the status of a particular row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
DBSTATUS CChapter::GetRowStatus(HROW hRow)
{
	DBSTATUS dwStatus = DBROWSTATUS_E_FAIL;

	CHRowsForChapter *pRow = NULL;
	

	if(m_pFirstRow != NULL)
	{
		for(pRow = m_pFirstRow ; pRow != NULL ; pRow = pRow->m_pNext)
		{
			//==================================================
			// if the row searching is found then delete
			// the element from the list
			//==================================================
			if(pRow->m_hRow == hRow)
			{
				dwStatus = pRow->GetRowStatus();
				break;
			}
		}

	}	
	return dwStatus;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get HROW of the row identified by the key
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HROW CChapter::GetHRow(BSTR strInstKey)
{
	CHRowsForChapter *	pRow = m_pFirstRow;
	HROW				hRow = 0;

	while(pRow != NULL)
	{
		//==================================================
		// if the row searching is found then 
		//==================================================
		if(pRow->m_strKey != NULL && strInstKey != NULL)
		if(0 == _wcsicmp((WCHAR *)strInstKey,pRow->m_strKey))
		{
			hRow = pRow->m_hRow;
			break;
		}
		pRow = pRow->m_pNext;
	}

	return hRow;

}


///////////////////////////////////////////////////////////////////////////////////////
//   CChapterMgr  class Implementation		
///////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////
// Constructor
///////////////////////////////////////////////////////////////////////////////////////
CChapterMgr::CChapterMgr()
{
	m_pHead				= NULL;
	m_lCount			= 0;
}

///////////////////////////////////////////////////////////////////////////////////////
// Destructor
///////////////////////////////////////////////////////////////////////////////////////
CChapterMgr::~CChapterMgr()
{
	CChapter *pTempChap, *pTempChapToDel = NULL;
	pTempChapToDel = m_pHead;

	// Navigate thru the list and delete all the elements
	while(pTempChapToDel)
	{
		pTempChap = pTempChapToDel->m_pNext;
		delete pTempChapToDel;
		pTempChapToDel = pTempChap;
	}
}

///////////////////////////////////////////////////////////////////////////////////////
// Add a Chapter to the list
///////////////////////////////////////////////////////////////////////////////////////
HRESULT CChapterMgr::AddChapter(HCHAPTER hChapter)
{
	CChapter *pNewChap = NULL;
	CChapter *pTempChap = NULL;
	HRESULT hr = S_OK;

	try
	{

		pNewChap = new CChapter;
	} // try
	catch(...)
	{
		SAFE_DELETE_PTR(pNewChap);
		throw;
	}
	if(pNewChap == NULL)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		pNewChap->m_cRefChapter = 1;   // The moment HCHAPPTER is retrieved is ref count is 1
		pNewChap->m_hChapter = hChapter;
		if(m_pHead == NULL)
		{
			m_pHead = pNewChap;
		}
		else
		{
			for(pTempChap = m_pHead; pTempChap->m_pNext != NULL ; pTempChap = pTempChap->m_pNext);
			pTempChap->m_pNext = pNewChap;
		}
	
		m_lCount++;
	}


	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////
// Delete a chapter from the list
///////////////////////////////////////////////////////////////////////////////////////
HRESULT CChapterMgr::DeleteChapter(HCHAPTER hChapter)
{
	CChapter *pTempChap = NULL;
	CChapter *pTempChapToDel = NULL;

	if( m_pHead)
	{
		if(m_pHead->m_hChapter == hChapter)
		{
			pTempChapToDel = m_pHead;
			m_pHead = m_pHead->m_pNext;
			delete pTempChapToDel;
		}
		else
		{
			//============================================================
			// Get to the previous node which is being searched
			//============================================================
			for( pTempChap = m_pHead ; pTempChap->m_pNext != NULL  ; pTempChap = pTempChap->m_pNext)
			{
				if(pTempChap->m_pNext->m_hChapter == hChapter)
				{
					pTempChapToDel = pTempChap->m_pNext;
					pTempChap->m_pNext = pTempChapToDel->m_pNext;
					delete pTempChapToDel;
					break;
				} // if
			} // for
		} // else
		m_lCount--;

	} // if the head pointer is valid

	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////////////
// Set the Instance pointer for the HCHAPTER
///////////////////////////////////////////////////////////////////////////////////////
void CChapterMgr::SetInstance(HCHAPTER hChapter , CWbemClassWrapper *pInstance,BSTR strKey,HROW hRow)
{
	CChapter *pTempChap = m_pHead;

	while(pTempChap != NULL)
	{
		if(pTempChap->m_hChapter == hChapter)
		{
			//============================================================
			// hRow will be zero if the chapter is representing qualifier
			//============================================================
			if( hRow == 0)
			{
				pTempChap->m_pInstance = pInstance;
				pTempChap->m_strKey	   = Wmioledb_SysAllocString(strKey);
			}
			//============================================================
			// else the chapter will be refering to a embeded class
			//============================================================
			else
			{
				pTempChap->SetInstance(hRow,strKey,pInstance);
			}
			break;

		}
		pTempChap = pTempChap->m_pNext;
	}

}


///////////////////////////////////////////////////////////////////////////////////////
// Get the Instance pointer for the chapter
///////////////////////////////////////////////////////////////////////////////////////
CWbemClassWrapper *CChapterMgr::GetInstance(HCHAPTER hChapter, HROW hRow)
{
	CChapter *			pTempChap = m_pHead;
	CWbemClassWrapper *	pRetInst  = NULL;

	while(pTempChap != NULL)
	{
		if(pTempChap->m_hChapter == hChapter)
		{
			//============================================================
			// hRow will be zero if the chapter is representing qualifier
			//============================================================
			if( hRow == 0)
			{
				pRetInst = pTempChap->m_pInstance;
			}
			//============================================================
			// else the chapter will be refering to a embeded class
			//============================================================
			else
			{
				pRetInst = pTempChap->GetInstance(hRow);
			}
		}
		pTempChap = pTempChap->m_pNext;
	}
	return pRetInst;
}

///////////////////////////////////////////////////////////////////////////////////////
// Add a HROW to the list of HROWS for the chapter
///////////////////////////////////////////////////////////////////////////////////////
HRESULT CChapterMgr::AddHRowForChapter(HCHAPTER hChapter , HROW hRow, CWbemClassWrapper *pInstance , HSLOT hSlot)
{
	HRESULT hr = E_FAIL;

	CChapter *pTempChap = m_pHead;

	while(pTempChap != NULL)
	{
		if(pTempChap->m_hChapter == hChapter)
		{
			hr = pTempChap->AddHRow(hRow,pInstance, hSlot);
			break;
		}
		pTempChap = pTempChap->m_pNext;
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// Delete a HROW from the list of HROWS for the chapter
///////////////////////////////////////////////////////////////////////////////////////
HRESULT CChapterMgr::DeleteHRow(HROW hRow)
{
	HRESULT hr = S_OK;
	CChapter *pTempChap = NULL;

	//======================================================
	// Get to the node which is being searched
	//======================================================
	for( pTempChap = m_pHead ; pTempChap != NULL ; pTempChap = pTempChap->m_pNext)
	{

		if(S_OK == pTempChap->IsHRowOfThisChapter(hRow))
		{
			hr = pTempChap->DeleteHRow(hRow);
			break;
		} // if row is of this chapter
	}// for

	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////
// Get the HCHAPTER for the given HROW
///////////////////////////////////////////////////////////////////////////////////////
HCHAPTER CChapterMgr::GetChapterForHRow(HROW hRow)
{
	HCHAPTER hChapter = -1;

	CChapter *pTempChap = NULL;
	
	//========================================================
	// Get to the previous node which is being searched
	//========================================================
	for( pTempChap = m_pHead ; pTempChap != NULL ; pTempChap = pTempChap->m_pNext)
	{
		if(S_OK == pTempChap->IsHRowOfThisChapter(hRow))
		{
			hChapter = pTempChap->m_hChapter;
			break;
		}
	}

	return hChapter;

}


///////////////////////////////////////////////////////////////////////////////////////
// Check if the given HCHAPTER exists in the list
///////////////////////////////////////////////////////////////////////////////////////
BOOL CChapterMgr::IsExists(HCHAPTER hChapter)
{
	BOOL bRet = FALSE;
	CChapter *pTempChap = m_pHead;

	while(pTempChap != NULL)
	{
		if(pTempChap->m_hChapter == hChapter)
		{
			bRet = TRUE;
			break;
		}
		pTempChap = pTempChap->m_pNext;
	}

	return bRet;

}

///////////////////////////////////////////////////////////////////////////////////////
// Add a reference to HCHAPTER
///////////////////////////////////////////////////////////////////////////////////////
ULONG CChapterMgr::AddRefChapter(HCHAPTER hChapter)
{
	ULONG ulRet = 0;
	CChapter *pTempChap = m_pHead;

	while(pTempChap != NULL)
	{
		if(pTempChap->m_hChapter == hChapter)
		{
			ulRet = ++(pTempChap->m_cRefChapter);
			break;
		}
		pTempChap = pTempChap->m_pNext;
	}

	return ulRet;

	
}

///////////////////////////////////////////////////////////////////////////////////////
// Release a reference to the chapter
///////////////////////////////////////////////////////////////////////////////////////
ULONG CChapterMgr::ReleaseRefChapter(HCHAPTER hChapter)
{
	ULONG ulRet = 0;
	CChapter *pTempChap = m_pHead;

	while(pTempChap != NULL)
	{
		if(pTempChap->m_hChapter == hChapter)
		{
			ulRet = --(pTempChap->m_cRefChapter);
			break;
		}
		pTempChap = pTempChap->m_pNext;
	}

	return ulRet;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get all the open rows 
// caller releases the memory allocated
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CChapterMgr::GetAllHROWs(HROW *&prghRows , DBCOUNTITEM &cRows)
{
	HRESULT	hr			= S_OK;
	DBCOUNTITEM	ulRowCount	= 0;

	CChapter *pTempChap = NULL;

	HROW *pHRowTemp = NULL;
	prghRows		 = NULL;
	
	//========================================================
	// Get to the previous node which is being searched
	//========================================================
	for( pTempChap = m_pHead ; pTempChap != NULL ; pTempChap = pTempChap->m_pNext)
	{
		ulRowCount += pTempChap->m_lCount;
	}

	if( ulRowCount > 0)
	{
		pHRowTemp = new HROW[ulRowCount];
		
		//NTRaid:111769
		// 06/07/00
		if(pHRowTemp)
		{
			prghRows = pHRowTemp;
			cRows    = ulRowCount;
			
			//========================================================
			// Get to the previous node which is being searched
			//========================================================
			for( pTempChap = m_pHead ; pTempChap != NULL ; pTempChap = pTempChap->m_pNext)
			{
				if(S_OK == (hr = pTempChap->GetAllHRowsInList(pHRowTemp)))
				{
					pHRowTemp += pTempChap->m_lCount;
				}
				else
				{
					SAFE_DELETE_ARRAY(pHRowTemp);
					prghRows = NULL;
					cRows    = 0;
					break;
				}
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	return hr;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to find if any rows are opened for the chapter
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CChapterMgr::IsRowExistsForChapter(HCHAPTER hChapter)
{
	HRESULT		hr			= E_FAIL;
	CChapter *	pTempChap	= NULL;
	
	//========================================================
	// Get to the previous node which is being searched
	//========================================================
	for( pTempChap = m_pHead ; pTempChap != NULL ; pTempChap = pTempChap->m_pNext)
	{
		if(pTempChap->m_hChapter == hChapter)
		{
			if(pTempChap->m_lCount >0)
			{
				hr = S_OK;
			}
			break;
		}
	}

	return hr;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to set the slot number for the row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CChapterMgr::SetSlot(HROW hRow , HSLOT hSlot)
{
	HRESULT		hr			= E_FAIL;
	CChapter *	pTempChap	= NULL;
	
	//========================================================
	// Get to the previous node which is being searched
	//========================================================
	for( pTempChap = m_pHead ; pTempChap != NULL ; pTempChap = pTempChap->m_pNext)
	{
		if(S_OK == pTempChap->IsHRowOfThisChapter(hRow))
		{
			pTempChap->SetSlot(hRow,hSlot);
			hr = S_OK;
			break;
		}
	}

	return hr;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get slot number for the row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HSLOT CChapterMgr::GetSlot(HROW hRow)
{
	HSLOT		hSlot		= -1;
	CChapter *	pTempChap	= NULL;
	
	//========================================================
	// Get to the previous node which is being searched
	//========================================================
	for( pTempChap = m_pHead ; pTempChap != NULL ; pTempChap = pTempChap->m_pNext)
	{
		if(S_OK == pTempChap->IsHRowOfThisChapter(hRow))
		{
			hSlot = pTempChap->GetSlot(hRow);
			break;
		}
	}

	return hSlot;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to check if the particular row is opened
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CChapterMgr::IsRowExists(HROW hRow)
{
	BOOL bRet = FALSE;
	
	if( hRow > 0)
	if(0 < GetChapterForHRow(hRow))
	{
		bRet = TRUE;
	}

	return bRet;
		
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get the key for the chapter
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CChapterMgr::GetInstanceKey(HCHAPTER hChapter, BSTR *pstrKey, HROW hRow)
{
	CChapter *pTempChap = m_pHead;
	HRESULT hr = E_FAIL;

	while(pTempChap != NULL)
	{
		if(pTempChap->m_hChapter == hChapter)
		{
			//==================================================================
			// hRow will be zero if the chapter is representing qualifier
			//==================================================================
			if( hRow == 0)
			{
				hr = S_OK;
				*pstrKey = Wmioledb_SysAllocString(pTempChap->m_strKey);
			}
			//==================================================================
			// else the chapter will be refering to a embeded class
			//==================================================================
			else
			{
				hr = pTempChap->GetInstanceKey(hRow,pstrKey);
			}
			break;
		}
		pTempChap = pTempChap->m_pNext;
	}
	return hr;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to check if the instance identified by the key exists
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CChapterMgr::IsInstanceExist(BSTR strKey)
{
	BOOL		bRet		= FALSE;
	CChapter *	pTempChap	= m_pHead;

	while(pTempChap != NULL)
	{
		
		if(pTempChap->m_strKey != NULL && strKey != NULL)
		if(0 == wbem_wcsicmp(strKey,pTempChap->m_strKey))
		{
			bRet = TRUE;
			break;
		}
		pTempChap = pTempChap->m_pNext;
	}
	return bRet;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to check if a instance exists
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CChapterMgr::IsInstanceExist(CWbemClassWrapper *pInstance)
{
	BOOL		bRet		= FALSE;
	CChapter *	pTempChap	= m_pHead;

	while(pTempChap != NULL)
	{
		
		if(pTempChap->m_pInstance == pInstance)
		{
			bRet = TRUE;
			break;
		}
		pTempChap = pTempChap->m_pNext;
	}
	return bRet;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set the status of a particular row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CChapterMgr::SetRowStatus(HROW hRow , DWORD dwStatus)
{
	CChapter *pTempChap = NULL;
	//======================================================
	// Get to the node which is being searched
	//======================================================
	for( pTempChap = m_pHead ; pTempChap != NULL ; pTempChap = pTempChap->m_pNext)
	{

		if(S_OK == pTempChap->IsHRowOfThisChapter(hRow))
		{
			pTempChap->SetRowStatus(hRow , dwStatus);
			break;
		} // if row is of this chapter
	}// for

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the status of a particular row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
DBSTATUS CChapterMgr::GetRowStatus(HROW hRow)
{
	DBSTATUS	dwStatus  = DBROWSTATUS_S_OK;
	CChapter *	pTempChap = NULL;

	//======================================================
	// Get to the node which is being searched
	//======================================================
	for( pTempChap = m_pHead ; pTempChap != NULL ; pTempChap = pTempChap->m_pNext)
	{

		if(S_OK == pTempChap->IsHRowOfThisChapter(hRow))
		{
			dwStatus = pTempChap->GetRowStatus(hRow);
			break;
		} // if row is of this chapter
	}// for

	return dwStatus;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set the status of a particular chapter
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CChapterMgr::SetChapterStatus(HCHAPTER hChapter , DBSTATUS dwStatus)
{
	CChapter *pTempChap = m_pHead;

	while(pTempChap != NULL)
	{
		if(pTempChap->m_hChapter == hChapter)
		{
			pTempChap->m_dwStatus &= dwStatus;
			break;
		}
		pTempChap = pTempChap->m_pNext;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the status of the chapter
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
DBSTATUS CChapterMgr::GetChapterStatus(HCHAPTER hChapter)
{
	DBSTATUS	dwStatus  = 0;
	CChapter *	pTempChap = m_pHead;

	while(pTempChap != NULL)
	{
		if(pTempChap->m_hChapter == hChapter)
		{
			dwStatus = pTempChap->m_dwStatus;
			break;
		}
		pTempChap = pTempChap->m_pNext;
	}

	return dwStatus;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get a HROW of the row identified by the key
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HROW CChapterMgr::GetHRow(HCHAPTER hChapter, BSTR strInstKey)
{
	HROW hRow = 0;

	CChapter *pTempChap = m_pHead;
	
	while(pTempChap != NULL)
	{
		if(pTempChap->m_hChapter == hChapter)
		{
			break;
		}
		pTempChap = pTempChap->m_pNext;
	}
	
	if(pTempChap != NULL )
	{
		if( pTempChap->m_lCount != 0)
		{
			if( strInstKey == NULL )
			{
				hRow = pTempChap->m_pFirstRow->m_hRow;

			}
			else
			{
				hRow = pTempChap->GetHRow(strInstKey);
			}
		}
	}
	return hRow;
}


///////////////////////////////////////////////////////////////////////////////
// CWMIInstanceMgr class Implementation
//////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Constructor
//////////////////////////////////////////////////////////////////////////////
CWMIInstanceMgr::CWMIInstanceMgr()
{
	m_pFirst = NULL;
	m_lCount = 0;
}

///////////////////////////////////////////////////////////////////////////////
// Destructor
//////////////////////////////////////////////////////////////////////////////
CWMIInstanceMgr::~CWMIInstanceMgr()
{
	CWMIInstance *pTempInst = NULL , *pTempInstToDel = NULL;
	pTempInstToDel = m_pFirst;

	while(pTempInstToDel != NULL)
	{
		pTempInst = pTempInstToDel->m_pNext;
		delete pTempInstToDel;
		pTempInstToDel = pTempInst;
	}

}


///////////////////////////////////////////////////////////////////////////////////////
// Add an instance to the list
///////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIInstanceMgr::AddInstanceToList(HROW hRow,CWbemClassWrapper *pInstance, BSTR strKey ,HSLOT hSlot)
{
	HRESULT			hr				= S_OK;
	CWMIInstance *	pNewInstance	= NULL;
	CWMIInstance *	pTempInstance	= NULL;

	try
	{

		pNewInstance = new CWMIInstance;
	}
	catch(...)
	{
		SAFE_DELETE_PTR(pNewInstance);
		throw;
	}

	if(pNewInstance == NULL)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		pNewInstance->m_pInstance = pInstance;
		pNewInstance->m_hRow = hRow;
		pNewInstance->m_hSlot = hSlot;
		pNewInstance->m_strKey = Wmioledb_SysAllocString(strKey);
		if(m_pFirst == NULL)
		{
			m_pFirst = pNewInstance;
		}
		else
		{
			//========================================================================
			// Navigate to the last instance in the list and link the new instance
			//========================================================================
			for(pTempInstance = m_pFirst ; pTempInstance->m_pNext != NULL ; pTempInstance = pTempInstance->m_pNext);

			pTempInstance->m_pNext = pNewInstance;

		}
		m_lCount++;
	}

	return hr;

}


///////////////////////////////////////////////////////////////////////////////////////
// Delete the instance identified from the given HROW from the list
///////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIInstanceMgr::DeleteInstanceFromList(HROW hRow)
{
	HRESULT		hr					= S_OK;
	CWMIInstance *	pTempInstance	= NULL;
	CWMIInstance *	pTempInstToDel  = NULL;

	
	if(m_pFirst != NULL)
	{
		pTempInstance = m_pFirst;

		//====================================================
		// if the first one in the list is to be deleted
		//====================================================
		if(pTempInstance->m_hRow == hRow)
		{
			m_pFirst = pTempInstance->m_pNext;
			delete pTempInstance;
		}
		else
		{
			while(pTempInstance->m_pNext != NULL)
			{
				if(pTempInstance->m_pNext->m_hRow == hRow)
				{
					pTempInstToDel = pTempInstance->m_pNext;
					pTempInstance->m_pNext = pTempInstToDel->m_pNext;
					delete pTempInstToDel;
					break;
				}
				pTempInstance = pTempInstance->m_pNext;
			} // while
		} // else
		m_lCount--;
	} // if m_pFirst)
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
// Get the pointer to the instance for the given HROW
///////////////////////////////////////////////////////////////////////////////////////
CWbemClassWrapper * CWMIInstanceMgr::GetInstance(HROW hRow)
{
	CWMIInstance *		pTempInstance	= NULL;
	CWbemClassWrapper*	pRetInst		= NULL;

	pTempInstance = m_pFirst;

	while(pTempInstance != NULL)
	{
		if(pTempInstance->m_hRow == hRow)
		{
			pRetInst = pTempInstance->m_pInstance;
			break;
		}
		pTempInstance = pTempInstance->m_pNext;
	} // while

	return pRetInst;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get instance key identified by HROW
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIInstanceMgr::GetInstanceKey(HROW hRow,BSTR *strKey)
{
	HRESULT hr = E_FAIL;
	CWMIInstance *	pTempInstance	= NULL;

	pTempInstance = m_pFirst;

	while(pTempInstance != NULL)
	{
		if(pTempInstance->m_hRow == hRow)
		{
			hr = S_OK;
			*strKey = Wmioledb_SysAllocString(pTempInstance->m_strKey);
			break;
		}
		pTempInstance = pTempInstance->m_pNext;
	} // while

	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get all the HROWS in the list
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIInstanceMgr::GetAllHROWs(HROW * &prghRows , DBCOUNTITEM &cRows)
{
	CWMIInstance *	pTempInstance	= NULL;
	int				nIndex			= 0;
	HRESULT			hr				= E_OUTOFMEMORY;

	pTempInstance = m_pFirst;

	//==============================
	// If there are any open rows
	//==============================
	if(m_lCount >0)
	{
		try
		{
			prghRows = new HROW[m_lCount];
		}
		catch(...)
		{
			SAFE_DELETE_PTR(prghRows);
			throw;
		}
		if(prghRows != NULL)
		{
			cRows = m_lCount;
			
			//=================================================
			// Navigate through the list and get all HROWS
			//=================================================
			while(pTempInstance != NULL)
			{
				prghRows[nIndex++] = pTempInstance->m_hRow;
				pTempInstance = pTempInstance->m_pNext; 
			} 
			hr = S_OK;

		}
	}
	
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Check if the row identified by HROW exists
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWMIInstanceMgr::IsRowExists(HROW hRow)
{
	BOOL bRet = FALSE;
	if( hRow > 0)
	if(NULL != GetInstance(hRow))
	{
		bRet = TRUE;
	}

	return bRet;
		
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set the slot number for the row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWMIInstanceMgr::SetSlot(HROW hRow,HSLOT hSlot)
{
	CWMIInstance *	pTempInstance	= NULL;
	HRESULT hr = E_FAIL;

	pTempInstance = m_pFirst;

	while(pTempInstance != NULL)
	{
		if(pTempInstance->m_hRow == hRow)
		{
			pTempInstance->m_hSlot = hSlot;
			hr = S_OK;
			break;
		}
		pTempInstance = pTempInstance->m_pNext;
	} // while

	return hr;
		
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the slot number for the row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HSLOT CWMIInstanceMgr::GetSlot(HROW hRow)
{
	HSLOT			hSlot			= -1;
	CWMIInstance *	pTempInstance	= NULL;

	pTempInstance = m_pFirst;

	while(pTempInstance != NULL)
	{
		if(pTempInstance->m_hRow == hRow)
		{
			hSlot = pTempInstance->m_hSlot;
			break;
		}
		pTempInstance = pTempInstance->m_pNext;
	} // while

	return hSlot;
		
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Check if the instance identified by the key exists in the list
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWMIInstanceMgr::IsInstanceExist(BSTR strKey)
{
	BOOL bRet = FALSE;
	CWMIInstance *	pTempInstance	= NULL;

	pTempInstance = m_pFirst;

	while(pTempInstance != NULL)
	{
		if(pTempInstance->m_strKey != NULL && strKey != NULL)
		if(wbem_wcsicmp(pTempInstance->m_strKey,strKey) == 0)
		{
			bRet = TRUE;
			break;
		}
		pTempInstance = pTempInstance->m_pNext;
	} // while

	return bRet;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// check if the instance identified from the pointer exists
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWMIInstanceMgr::IsInstanceExist(CWbemClassWrapper * pInstance)
{
	BOOL bRet = FALSE;
	CWMIInstance *	pTempInstance	= NULL;

	pTempInstance = m_pFirst;

	while(pTempInstance != NULL)
	{
		if(pTempInstance->m_pInstance == pInstance)
		{
			bRet = TRUE;
			break;
		}
		pTempInstance = pTempInstance->m_pNext;
	} // while

	return bRet;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the HROW identified by the key
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HROW CWMIInstanceMgr::GetHRow(BSTR strKey)
{
	HROW			hRow			= -1;
	CWMIInstance *	pTempInstance	= NULL;

	pTempInstance = m_pFirst;

	while(pTempInstance != NULL)
	{
		if(pTempInstance->m_strKey != NULL && strKey != NULL)
		if(wbem_wcsicmp(pTempInstance->m_strKey,strKey) == 0)
		{
			hRow = pTempInstance->m_hRow;
			break;
		}
		pTempInstance = pTempInstance->m_pNext;
	} // while

	return hRow;

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set the status of a particular row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CWMIInstanceMgr::SetRowStatus(HROW hRow , DBSTATUS dwStatus)
{
	CWMIInstance *	pTempInstance	= NULL;

	pTempInstance = m_pFirst;

	while(pTempInstance != NULL)
	{
		if(pTempInstance->m_hRow == hRow)
		{
			pTempInstance->SetRowStatus(dwStatus);
			break;
		}
		pTempInstance = pTempInstance->m_pNext;
	} // while

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the status of a particular row
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
DBSTATUS CWMIInstanceMgr::GetRowStatus(HROW hRow)
{
	DBSTATUS		dwStatus		= DBROWSTATUS_E_FAIL;
	CWMIInstance *	pTempInstance	= NULL;

	pTempInstance = m_pFirst;

	while(pTempInstance != NULL)
	{
		if(pTempInstance->m_hRow == hRow)
		{
			dwStatus = pTempInstance->GetRowStatus();
			break;
		}
		pTempInstance = pTempInstance->m_pNext;
	} // while

	return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\tranoptions.h ===
//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider 
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//	tranoptions.h
//	Class declaration for implementing CTranOptions & ITransactionOptions interface
//
//////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _TRANOPTIONS_H_
#define _TRANOPTIONS_H_

#include "baseobj.h"

class CImpITransactionOptions;
typedef CImpITransactionOptions *PIMPITRANSACTIONOPTIONS;

class CTranOptions : public CBaseObj
{
	friend class CImpITransactionOptions;
    public: 
    	CTranOptions(IUnknown *pUnkOuter = NULL);
	    ~CTranOptions();

	// IUnknown methods
	STDMETHODIMP			QueryInterface(REFIID, LPVOID *);
	STDMETHODIMP_(ULONG)	AddRef(void);
	STDMETHODIMP_(ULONG)	Release(void);

	void			SetOptions(XACTOPT *pOpt);
	XACTOPT *		GetOptions();
	STDMETHODIMP	FInit();

    private: 
		XACTOPT m_xactOptions;
		PIMPITRANSACTIONOPTIONS		m_pITransOptions;
		PIMPISUPPORTERRORINFO		m_pISupportErrorInfo;			// contained ISupportErrorInfo


		HRESULT AddInterfacesForISupportErrorInfo();
};

class CImpITransactionOptions : public ITransactionOptions
{
    public: 
    	CImpITransactionOptions(CTranOptions * pObj)
        {
		    m_pObj = pObj;
            DEBUGCODE(m_cRef = 0);
		}
	    ~CImpITransactionOptions() {}

	STDMETHODIMP_(ULONG) AddRef(void)
	{																
		DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
		return m_pObj->GetOuterUnknown()->AddRef();								
	}								
	
	STDMETHODIMP_(ULONG) Release(void)
	{
		DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
	   if( lRef < 0 ){
		   ASSERT("Reference count on Object went below 0!")
	   })
	
		return m_pObj->GetOuterUnknown()->Release();								
	}

	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
	{																	
		return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
	}

    STDMETHODIMP SetOptions(XACTOPT * pOptions);
    
    STDMETHODIMP GetOptions(XACTOPT * pOptions);

    private: 
		CTranOptions		*m_pObj;											
		DEBUGCODE(ULONG m_cRef);											
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\rowset.h ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// @module ROWSET.H | CRowset base object and contained interface
// 
//
///////////////////////////////////////////////////////////////////////////////////

#ifndef _ROWSET_H_
#define _ROWSET_H_

#include "baserowobj.h"
#include "bitarray.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////
#define COLUMNINFO_SIZE MAX_PATH*3
#define DEFAULT_COLUMNS_TO_ADD 100
/////////////////////////////////////////////////////////////////////////////////////////////////////

#define COLUMNSTAT_MODIFIED		0x1000
#define NOCOLSCHANGED			0x0010

class CImpIAccessor;
class CImpIGetRow;
class CImplIRowsetRefresh;
class CImplIParentRowset;
class CQuery;
class CCommand;

typedef CImpIGetRow			 *	PIMPIGETROW;
typedef CImplIRowsetRefresh  *	PIMPIROWSETREFRESH;
typedef CHashTbl			 *	PHASHTBL;
typedef	CCommand			 *	PCCOMMAND;



///////////////////////////////////////////////////////////////////////////////////////////////////////
class CRowset : public CBaseRowObj				
{
	//	Contained interfaces are friends
	friend class CImpIRowsetLocate;
	friend class CImpIRowsetChange;
	friend class CImpIRowsetIdentity;
	friend class CImpIRowsetInfo;
	friend class CImpIAccessor;
	friend class CImpIGetRow;
	friend class CImplIRowsetRefresh;
	friend class CImpIChapteredRowset;

	friend class CRowFetchObj;
	friend class CInstanceRowFetchObj;
	friend class CQualifierRowFetchObj;
	friend class CRow;

    private: 

		CWMIInstanceMgr	*				m_InstMgr;						// to manage pointer to instance to HROW

		                       
		PIMPIROWSET						m_pIRowset;                     // Contained IRowset
		PIMPIROWSETLOCATE				m_pIRowsetLocate;               // Contained IRowsetLocate
		PIMPIROWSETCHANGE				m_pIRowsetChange;				// Contained IRowsetChange
		PIMPIROWSETIDENTITY				m_pIRowsetIdentity;             // Contained IRowsetIdentity
        PIMPIACCESSOR					m_pIAccessor;                   // Contained IAccessor
		PICHAPTEREDROWSET				m_pIChapteredRowset;			// Contained IChapteredRowset
		PIMPIROWSETINFO					m_pIRowsetInfo;					// Contained IRowsetInfo;
		PIMPIGETROW						m_pIGetRow;						// contained IGetRow
		PIMPIROWSETREFRESH				m_pIRowsetRefresh;				// Contained IRowsetIdentity
		PROWFETCHOBJ					m_pRowFetchObj;					// Rowfetch Object to fetch rows
		PHASHTBL						m_pHashTblBkmark;				// HashTable pointer to store bookmarks

		PCCOMMAND						m_pParentCmd;					// Command object which created the rowset

		DBORDINAL          				m_irowMin;                      // index of the first available rowbuffer
		ULONG_PTR          				m_cRows;                        // current # of rows in the buffer

		DBSTATUS          				m_dwStatus;                     // status word for the entire cursor
		BYTE*							m_pLastBindBase;                // remember last binding location
		DBROWCOUNT         				m_ulRowRefCount;	            // RefCount of all outstanding row handles
//		HCHAPTER						m_hLastChapterAllocated;		// variable to store the last HCHAPTER given;
		HCHAPTER						m_hLastChapterAllocated;		// variable to store the last HCHAPTER given;


		
		BOOL							m_bHelperFunctionCreated;		// flag to indicate whethe helper function are created or not
		HROW							m_ulLastFetchedRow;				// Position of the last fetched Row

																		// retrieved from WMIOLEDBMAP class or not
		HROW							m_hRowLastFetched;				// last fetched HROW

		CBaseRowObj **					m_ppChildRowsets;				// Array of rowset pointers for child recordsets
		BSTR							m_strPropertyName;				// Name of the property for which Qualifier is
            															// is to be retrieved
		CWbemClassWrapper *				m_pInstance;					// Instance pointer of instance for which this qualifier
																	// rowset is pointing
		BOOL							m_bIsChildRs;					// flag indicating whether the rowset is a child rowset

		FETCHDIRECTION					m_FetchDir;						// The last fetch Direction;
		ULONG_PTR						m_lLastFetchPos;				// The last fetched position
		DBCOUNTITEM						m_lRowCount;					// The number of rows in rowset


		HRESULT		GatherColumnInfo(void);         	                	//Builds DBCOLINFO structures
		HRESULT		ReleaseAllRows();										// release all rows during desctuction	
		HRESULT		CreateHelperFunctions(void);       	                	//Creates Helper Classes 
		ROWBUFF*	GetRowBuff(HROW iRow, BOOL fDataLocation = FALSE);    //Returns the Buffer Pointer for the specified row identified from HROW
		ROWBUFF*	GetRowBuffFromSlot(HSLOT hSlot, BOOL fDataLocation = FALSE);    //Returns the Buffer Pointer for the specified row identified by slot
		HRESULT		Rebind(BYTE* pBase);                               		//Establishes the data area bindings
		HRESULT		ReleaseRowData(HROW hRow,BOOL bReleaseSlot = TRUE);

		HRESULT		ResetInstances();                                   // Set instance back to 0
		HRESULT		ResetQualifers(HCHAPTER hChapter);
        HRESULT		ResetRowsetToNewPosition(DBROWOFFSET lRowOffset,CWbemClassWrapper *pInst = NULL);      // Start getting at new position

		HRESULT		AllocateAndInitializeChildRowsets();				// ALlocate and initialize rowsets for child recordsets
		HRESULT		GetChildRowset(DBORDINAL ulOrdinal,REFIID riid ,IUnknown ** ppIRowset);		// get the pointer to the child recordsets



		HRESULT		CheckAndInitializeChapter(HCHAPTER hChapter);

        HRESULT		GetNextInstance(CWbemClassWrapper *&ppInst, CBSTR &strKey,BOOL bFetchBack);					// Get the next one in the list
		HRESULT		GetNextPropertyQualifier(CWbemClassWrapper *pInst,BSTR strPropName,BSTR &strQualifier,BOOL bFetchBack);
		HRESULT		GetInstanceDataToLocalBuffer(CWbemClassWrapper *pInst,HSLOT hSlot,BSTR strQualifer = Wmioledb_SysAllocString(NULL));			// Get the Instance Data and put it into the
																		// provider's own memory
		HRESULT		GetNextClassQualifier(CWbemClassWrapper *pInst,BSTR &strQualifier,BOOL bFetchBack);
		HRESULT		ReleaseInstancePointer(HROW hRow);						// function to relese HROW from the chapter manager
																		// and instance manager when row is released
		
		BOOL		IsRowExists(HROW hRow);
		HRESULT		IsSlotSet(HSLOT hRow);
		HSLOT		GetSlotForRow(HROW hRow);
        
        HRESULT		SetRowsetProperties(const ULONG cPropertySets, const DBPROPSET	rgPropertySets[] );
		HRESULT		GetData(HROW hRow ,BSTR strQualifer = Wmioledb_SysAllocString(NULL));
		HRESULT		UpdateRowData(HROW hRow,PACCESSOR pAccessor, BOOL bNewInst);
		HRESULT		DeleteRow(HROW hRow,DBROWSTATUS * pRowStatus);
		void		SetRowStatus(HROW hRow , DBSTATUS dwStatus);
		DBSTATUS	GetRowStatus(HROW hRow);
		void		GetInstanceKey(HROW hRow , BSTR *strKey);
		HRESULT		UpdateRowData(HROW hRow,DBORDINAL cColumns,DBCOLUMNACCESS rgColumns[ ]);
		void		SetStatus(HCHAPTER hChapter , DWORD dwStatus);
		DBSTATUS	GetStatus(HCHAPTER hChapter = 0);
		HRESULT		InsertNewRow(CWbemClassWrapper **ppNewInst);
		HRESULT		GetColumnInfo(DBORDINAL* pcColumns, DBCOLUMNINFO** prgInfo,WCHAR** ppStringsBuffer);
		void		GetBookMark(HROW hRow,BSTR &strBookMark);
		HRESULT		FillHChaptersForRow(CWbemClassWrapper *pInst, BSTR strKey);
//		HCHAPTER	GetNextHChapter() { return ++m_hLastChapterAllocated; }
		HCHAPTER	GetNextHChapter() { return ++m_hLastChapterAllocated; }
		HRESULT		AddRefChapter(HCHAPTER hChapter,DBREFCOUNT * pcRefCount);
		HRESULT		ReleaseRefChapter(HCHAPTER hChapter,DBREFCOUNT * pcRefCount);	// Release reference to chapter
		HRESULT		GetRowCount();
		HRESULT		GetDataToLocalBuffer(HROW hRow);
		BOOL		IsInstanceDeleted(CWbemClassWrapper *pInst);
		HRESULT		AllocateInterfacePointers();
		void		InitializeRowsetProperties();
		HRESULT		AddInterfacesForISupportErrorInfo();

		CWbemClassWrapper * GetInstancePtr(HROW hRow);
		INSTANCELISTTYPE	GetObjListType()	{ return m_pMap->GetObjListType(); }

		FETCHDIRECTION	 GetCurFetchDirection() { return m_pMap->GetCurFetchDirection(); }
		void	 SetCurFetchDirection(FETCHDIRECTION FetchDir);
	
	public:

		 // For Hierarchical recordset to represent Qualifiers
		CRowset(LPUNKNOWN pUnkOuter,ULONG uQType, LPWSTR PropertyName,PCDBSESSION pObj , CWmiOleDBMap *pMap);
		CRowset(LPUNKNOWN pUnkOuter,PCDBSESSION pObj ,CWbemConnectionWrapper *pCon = NULL);


		~CRowset(void);
        void InitVars();
		
        inline BOOL BitArrayInitialized();
        inline LPEXTBUFFER GetAccessorBuffer();

    	inline PCUTILPROP GetCUtilProp() { return m_pUtilProp; };       // Return the CUtilProp object
		CWmiOleDBMap *GetWmiOleDBMap() { return m_pMap; };

		// Initialization functions
		
		HRESULT InitRowset( const ULONG		    cPropertySets, 
			                const DBPROPSET		rgPropertySets[] );

		// overloaded function for rowsets resulted from executing
		// query from command object
		HRESULT InitRowset( const ULONG cPropertySets, 
							const DBPROPSET	rgPropertySets[],
							DWORD dwFlags, 
							CQuery* p,
							PCCOMMAND pCmd );

		// Overloaded function for normal rowset and schema rowsets
        HRESULT InitRowset( int nBaseType,const ULONG cPropertySets, const DBPROPSET	rgPropertySets[],LPWSTR TableID, DWORD dwFlags, LPWSTR SpecificTable );

        HRESULT InitRowset( const ULONG cPropertySets, 
							const DBPROPSET	rgPropertySets[],
							LPWSTR TableID,
							BOOL fSchema = FALSE, 
							DWORD dwFlags = -1 );

		HRESULT InitRowset( const ULONG cPropertySets, 
							const DBPROPSET	rgPropertySets[],
							LPWSTR strObjectID,
							LPWSTR strObjectToOpen,
							INSTANCELISTTYPE objInstListType , 
							DWORD dwFlags = -1);
		
		HRESULT InitRowsetForRow(	LPUNKNOWN pUnkOuter ,
									const ULONG cPropertySets, 
									const DBPROPSET	rgPropertySets[] , 
									CWbemClassWrapper *pInst);
		
        void GetQualiferName(HROW hRow,BSTR &strBookMark);

		// IUnknown methods
		STDMETHODIMP			QueryInterface(REFIID, LPVOID *);
		STDMETHODIMP_(ULONG)	AddRef(void);
		STDMETHODIMP_(ULONG)	Release(void);
	
		
};

typedef CRowset *PCROWSET;

////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpIRowsetLocate : public IRowsetLocate		
{
	private:
		DEBUGCODE(ULONG m_cRef);											
		CRowset	 *		m_pObj;	

	public: 
		CImpIRowsetLocate( CRowset *pObj )				
		{																
			DEBUGCODE(m_cRef = 0L);										
			m_pObj		= pObj;											
		}																
		~CImpIRowsetLocate()													
		{											
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		STDMETHODIMP	GetData(HROW, HACCESSOR, void*);
		STDMETHODIMP	GetNextRows(HCHAPTER, DBROWOFFSET, DBROWCOUNT, DBCOUNTITEM*, HROW**);
		STDMETHODIMP	ReleaseRows(DBCOUNTITEM, const HROW[], DBROWOPTIONS[], DBREFCOUNT[], DBROWSTATUS[]);
		STDMETHODIMP	RestartPosition(HCHAPTER);
        STDMETHODIMP	AddRefRows(DBCOUNTITEM, const HROW[], DBREFCOUNT[], DBROWSTATUS[]);

		// IRowsetLocate Methods
		STDMETHODIMP	Compare (HCHAPTER       hChapter,
								 DBBKMARK          cbBookmark1,
								 const BYTE *   pBookmark1,
								 DBBKMARK          cbBookmark2,
								 const BYTE *   pBookmark2,
								 DBCOMPARE *    pComparison);

		STDMETHODIMP	GetRowsAt (HWATCHREGION   hReserved1,
								   HCHAPTER       hChapter,
								   DBBKMARK       cbBookmark,
								   const BYTE *   pBookmark,
								   DBROWOFFSET    lRowsOffset,
								   DBROWCOUNT     cRows,
								   DBCOUNTITEM *  pcRowsObtained,
								   HROW **        prghRows);


		STDMETHODIMP	GetRowsByBookmark (HCHAPTER       hChapter,
										   DBCOUNTITEM    cRows,
										   const DBBKMARK rgcbBookmarks[],
										   const BYTE *   rgpBookmarks[],
										   HROW           rghRows[],
										   DBROWSTATUS    rgRowStatus[]);


		STDMETHODIMP	Hash (HCHAPTER       hChapter,
							   DBBKMARK      cBookmarks,
							   const DBBKMARK rgcbBookmarks[],
							   const BYTE *   rgpBookmarks[],
							   DBHASHVALUE    rgHashedValues[],
							   DBROWSTATUS    rgBookmarkStatus[]);



		// a utility function
        HRESULT CheckParameters(DBCOUNTITEM * pcRowsObtained,  DBROWOFFSET lRowOffset,  DBROWCOUNT  cRows,HROW **prghRows );

};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpIRowsetChange : public IRowsetChange	
{
	private: 
		DEBUGCODE(ULONG m_cRef);											
		CRowset		*m_pObj;											

	public: 
		
		CImpIRowsetChange( CRowset *pObj )			
		{																
			DEBUGCODE(m_cRef = 0L);										
			m_pObj		= pObj;											
		}																
		~CImpIRowsetChange()											
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

	    STDMETHODIMP	SetData(HROW, HACCESSOR, void*);
	    STDMETHODIMP	DeleteRows(HCHAPTER, DBCOUNTITEM, const HROW[], DBROWSTATUS[]);
		STDMETHODIMP    InsertRow(HCHAPTER hChapter,HACCESSOR hAccessor, void* pData, HROW* phRow);

    private:
        STDMETHODIMP	ApplyAccessorToData( DBCOUNTITEM cBindings, DBBINDING* pBinding,BYTE*  pbProvRow,void* pData,DWORD & dwErrorCount );
		STDMETHODIMP	ValidateArguments(	HROW        hRow,
											HACCESSOR   hAccessor,
											const void  *pData,
											PROWBUFF    *pprowbuff = NULL,
											PACCESSOR *ppkgaccessor = NULL);

		BOOL	CompareData(DBTYPE dwType,void * pData1 , void *pData2);
		HRESULT UpdateDataToRowBuffer(DBCOUNTITEM iBind ,BYTE * pbProvRow,DBBINDING* pBinding,BYTE *pData);
		BOOL	IsNullAccessor(PACCESSOR phAccessor,BYTE * pData );
		HRESULT InsertNewRow(HROW hRow,	HCHAPTER    hChapter,CWbemClassWrapper *& pNewInst);
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpIColumnsInfo : public IColumnsInfo 		
{
	private: 
		DEBUGCODE(ULONG m_cRef);											
		CBaseRowObj		*m_pObj;											

	public: 

    	CImpIColumnsInfo(CBaseRowObj *pObj)
		{
	    	DEBUGCODE(m_cRef = 0L);
		    m_pObj		= pObj;
		}

		~CImpIColumnsInfo()												
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));	
           	return m_pObj->GetOuterUnknown()->AddRef();
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
        	return m_pObj->GetOuterUnknown()->Release();

		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

	    STDMETHODIMP	GetColumnInfo(DBORDINAL* pcColumns, DBCOLUMNINFO** prgInfo, OLECHAR** ppStringsBuffer);
		STDMETHODIMP	MapColumnIDs(DBORDINAL, const DBID[], DBORDINAL[]);
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpIAccessor : public IAccessor 		
{
	private: 
		DEBUGCODE(ULONG m_cRef);											
        CBaseObj    *m_pObj;
		LPEXTBUFFER m_pextbufferAccessor;           // array of accessor ptrs
		LPBITARRAY	m_prowbitsIBuffer;	            // bit array to mark active rows/ or parameters
		BOOL		m_bRowset;

    public: 
        
        CImpIAccessor::CImpIAccessor( CBaseObj *pParentObj,BOOL bRowset = TRUE)
	    {
	        //	Initialize simple member vars
	        DEBUGCODE(m_cRef = 0L);
	        m_pObj			    = pParentObj;
            m_prowbitsIBuffer   = NULL;
        	m_pextbufferAccessor= NULL;
			m_bRowset			= bRowset;
		}

    	~CImpIAccessor()													
		{							
	        //===============================================================
            // Free accessors.
            // Each accessor is allocated via new/delete.
            // We store an array of ptrs to each accessor (m_pextbufferAccessor).
	        //===============================================================
            if (NULL != m_pextbufferAccessor){
                HACCESSOR   hAccessor, hAccessorLast;
                PACCESSOR   pAccessor;

                m_pextbufferAccessor->GetFirstLastItemH( hAccessor, hAccessorLast );
                for (; hAccessor <= hAccessorLast; hAccessor++){

                    m_pextbufferAccessor->GetItemOfExtBuffer( hAccessor, &pAccessor );
                    SAFE_DELETE_PTR( pAccessor );
                }
                DeleteAccessorBuffer();
            }

           	// Delete bit array that marks referenced parameters.
        	DeleteBitArray();
		}

        HRESULT CImpIAccessor::FInit();

        inline CBaseObj* GetBaseObjectPtr() { return m_pObj;}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));		
        	return m_pObj->GetOuterUnknown()->AddRef();
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		STDMETHODIMP	AddRefAccessor(HACCESSOR hAccessor, DBREFCOUNT* pcRefCounts);
	    STDMETHODIMP	CreateAccessor(DBACCESSORFLAGS, DBCOUNTITEM, const DBBINDING[], DBLENGTH, HACCESSOR*, DBBINDSTATUS[]);
		STDMETHODIMP	GetBindings(HACCESSOR, DBACCESSORFLAGS*, DBCOUNTITEM*, DBBINDING**);
		STDMETHODIMP	ReleaseAccessor(HACCESSOR, DBREFCOUNT*);

		// utility member functions
        LPBITARRAY  GetBitArrayPtr()    { return m_prowbitsIBuffer; }
        LPEXTBUFFER GetAccessorPtr()    { return m_pextbufferAccessor;}           // array of accessor ptrs
        BOOL CreateNewBitArray();
        BOOL CreateNewAccessorBuffer();
        void DeleteBitArray()           { SAFE_DELETE_PTR(m_prowbitsIBuffer);}
        void DeleteAccessorBuffer()     { SAFE_DELETE_PTR(m_pextbufferAccessor);}
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpIRowsetInfo : public IRowsetInfo 
{
	private: 
		DEBUGCODE(ULONG m_cRef);											
		CRowset		*m_pObj;											

	public: 
		CImpIRowsetInfo( CRowset *pObj )				
		{																	
			DEBUGCODE(m_cRef = 0L);											
			m_pObj		= pObj;												
		}																	
		~CImpIRowsetInfo()													
		{																	
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		STDMETHODIMP			GetReferencedRowset
			(
				DBORDINAL	iOrdinal, 
				REFIID		rrid,
				IUnknown**	ppReferencedRowset
			);

		STDMETHODIMP			GetProperties
		    (
			    const ULONG			cPropertySets,
			    const DBPROPIDSET	rgPropertySets[],
			    ULONG*              pcProperties,
			    DBPROPSET**			prgProperties
		    );

		STDMETHODIMP			GetSpecification(REFIID, IUnknown**);

};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpIRowsetIdentity : public IRowsetIdentity 	
{
	private: 
		DEBUGCODE(ULONG m_cRef);										
		CRowset		*m_pObj;											

	public: 
		CImpIRowsetIdentity( CRowset *pObj)		
		{																
			DEBUGCODE(m_cRef = 0L);										
			m_pObj		= pObj;											
		}																
		~CImpIRowsetIdentity()											
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		STDMETHODIMP	IsSameRow(	HROW hThisRow, 
									HROW hThatRow);
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CImpIConvertType : public IConvertType 	
{
	private: 
		DEBUGCODE(ULONG m_cRef);											
		CBaseObj		*m_pObj;											

	public: 
		CImpIConvertType( CBaseObj *pObj )					
		{																	
			DEBUGCODE(m_cRef = 0L);											
			m_pObj		= pObj;												
		}																	
		~CImpIConvertType()														
		{																	
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		STDMETHODIMP CImpIConvertType::CanConvert
			(
			DBTYPE			wFromType,		//@parm IN | src type
			DBTYPE			wToType,		//@parm IN | dst type
			DBCONVERTFLAGS	dwConvertFlags	//@parm IN | conversion flags
			);
};


class CImpIChapteredRowset : public IChapteredRowset	
{
	private: 
		DEBUGCODE(ULONG m_cRef);											
		CRowset		*m_pObj;											

	public: 
		
		CImpIChapteredRowset( CRowset *pObj )			
		{																
			DEBUGCODE(m_cRef = 0L);										
			m_pObj		= pObj;											
		}																
		~CImpIChapteredRowset()											
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}
		
		STDMETHODIMP AddRefChapter (HCHAPTER   hChapter, DBREFCOUNT *  pcRefCount);
		STDMETHODIMP ReleaseChapter (HCHAPTER   hChapter,DBREFCOUNT * pcRefCount);

};



class CImpIGetRow : public IGetRow
{
	private: 
		DEBUGCODE(ULONG m_cRef);											
		CRowset		*m_pObj;											

	public: 
		
		CImpIGetRow( CRowset *pObj )			
		{																
			DEBUGCODE(m_cRef = 0L);										
			m_pObj		= pObj;											
		}																
		~CImpIGetRow()											
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		STDMETHODIMP GetRowFromHROW(IUnknown * pUnkOuter,HROW hRow,REFIID riid,IUnknown ** ppUnk);
		STDMETHODIMP GetURLFromHROW(HROW hRow,LPOLESTR * ppwszURL);
};


class CImplIRowsetRefresh : public IRowsetRefresh
{
	private: 
		DEBUGCODE(ULONG m_cRef);											
		CRowset		*m_pObj;											

		HRESULT CheckIfRowsExists(DBCOUNTITEM cRows,const HROW rghRows[],DBROWSTATUS *   prgRowStatus);
	public: 
		
		CImplIRowsetRefresh( CRowset *pObj )			
		{																
			DEBUGCODE(m_cRef = 0L);
			m_pObj		= pObj;											
		}																
		~CImplIRowsetRefresh()											
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

		STDMETHODIMP GetLastVisibleData(HROW hRow,HACCESSOR hAccessor,void * pData);

		STDMETHODIMP RefreshVisibleData(HCHAPTER         hChapter,
										DBCOUNTITEM      cRows,
										const HROW       rghRows[],
										BOOL             fOverwrite,
										DBCOUNTITEM *    pcRowsRefreshed,
										HROW **          prghRowsRefreshed,
										DBROWSTATUS **   prgRowStatus);

};


class CImplIParentRowset:public IParentRowset
{
	private: 
		DEBUGCODE(ULONG m_cRef);											
		CRowset		*m_pObj;											

	public: 
		
		CImplIParentRowset( CRowset *pObj )			
		{																
			DEBUGCODE(m_cRef = 0L);
			m_pObj		= pObj;											
		}																
		~CImplIParentRowset()											
		{																
		}

		STDMETHODIMP_(ULONG) AddRef(void)									
		{																
			DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
			return m_pObj->GetOuterUnknown()->AddRef();								
		}																

		STDMETHODIMP_(ULONG) Release(void)									
		{																
		   DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
		   if( lRef < 0 ){
			   ASSERT("Reference count on Object went below 0!")
		   })
		
			return m_pObj->GetOuterUnknown()->Release();								
		}																

		STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)		
		{																	
			return m_pObj->GetOuterUnknown()->QueryInterface(riid, ppv);					
		}

        STDMETHODIMP GetChildRowset( IUnknown __RPC_FAR *pUnkOuter,
										DBORDINAL iOrdinal,
										REFIID riid,
										IUnknown __RPC_FAR *__RPC_FAR *ppRowset);
};

// class for storing instance information for each row in rowset
class CWMIInstance
{
public:
	CWbemClassWrapper *		m_pInstance;
	HROW			m_hRow;
	HSLOT			m_hSlot;
	CWMIInstance *	m_pNext;
	BSTR			m_strKey;
	DBSTATUS		m_dwStatus;

	CWMIInstance()
	{
		m_pInstance = NULL;
		m_hRow		= DBROWSTATUS_S_OK;
		m_pNext		= NULL;
		m_hSlot		= -1;
		m_strKey = Wmioledb_SysAllocString(NULL);
		m_dwStatus	= 0;
	}

	~CWMIInstance()
	{
		if(m_strKey)
		{
			SysFreeString(m_strKey);
		}
	}

	void		SetRowStatus(DBSTATUS dwStatus) { m_dwStatus = dwStatus ; };
	DBSTATUS	GetRowStatus() { return m_dwStatus; };
};

// class to maps HROWS to CWMIInstance
class CWMIInstanceMgr
{
private:
	ULONG m_lCount;					// count of instances in the list;
public:
	CWMIInstance *m_pFirst;

	CWMIInstanceMgr();
	~CWMIInstanceMgr();

	HRESULT				AddInstanceToList(HROW hRow ,CWbemClassWrapper *pInstance ,BSTR strKey, HSLOT hSlot = -1);
	HRESULT				DeleteInstanceFromList(HROW hRow);
	CWbemClassWrapper * GetInstance(HROW hRow);
	HRESULT			  	GetInstanceKey(HROW hRow, BSTR * strKey);

	HRESULT				GetAllHROWs(HROW *&prghRows , DBCOUNTITEM &cRows);
	HRESULT				SetSlot(HROW hRow , HSLOT hSlot);
	HSLOT				GetSlot(HROW hRow);
	BOOL				IsRowExists(HROW hrow);
	BOOL				IsInstanceExist(BSTR strKey);
	BOOL				IsInstanceExist(CWbemClassWrapper *pInstance);
	HROW				GetHRow(BSTR strKey);

	void				SetRowStatus(HROW hRow , DBSTATUS dwStatus);
	DBSTATUS			GetRowStatus(HROW hRow);

};



//=================================================================
//Abstract base class for fetching rows and data for rows
//=================================================================
class CRowFetchObj
{
	void	ClearRowBuffer(void *pData,DBBINDING   *pBinding,int nCurCol);

protected:
	LONG_PTR	GetFirstFetchPos(CRowset *pRowset,DBCOUNTITEM cRows,DBROWOFFSET lOffset);

public:
	virtual HRESULT FetchRows(	CRowset *	 pRowset,
						HCHAPTER		hChapter,        // IN  The Chapter handle.
						DBROWOFFSET		lRowOffset,      // IN  Rows to skip before reading
						DBROWCOUNT		cRows,           // IN  Number of rows to fetch
						DBCOUNTITEM*	pcRowsObtained, // OUT Number of rows obtained
						HROW     **		prghRows) = 0;       // OUT Array of Hrows obtained)

	virtual HRESULT	FetchData(CRowset *	  pRowset,
					  HROW  hRow,             //IN  Row Handle
                      HACCESSOR   hAccessor,  //IN  Accessor to use
                      void       *pData  ) ;

	HRESULT CRowFetchObj::FetchRowsByBookMark(CRowset *	 pRowset,
													HCHAPTER	hChapter,        // IN  The Chapter handle.
													DBROWCOUNT	cRows,           // IN  Number of rows to fetch
													const DBBKMARK rgcbBookmarks[],	//@parm IN  | an array of bookmark sizes
													const BYTE*	rgpBookmarks[],	//@parm IN  | an array of pointers to bookmarks
													HROW		rghRows[],			// OUT Array of Hrows obtained
													DBROWSTATUS rgRowStatus[]);       // OUT status of rows

	HRESULT CRowFetchObj::FetchNextRowsByBookMark(CRowset *	 pRowset,
													HCHAPTER   hChapter,        // IN  The Chapter handle.
													DBBKMARK   cbBookmark,	// size of BOOKMARK
		 											const BYTE *   pBookmark,	// The bookmark from which fetch should start
													DBROWOFFSET    lRowsOffset,
													DBROWCOUNT     cRows,
													DBCOUNTITEM *  pcRowsObtained,
													HROW **        prghRows);
};


//=====================================================================
// Row fetch object for fetching data for rowsets showing instance
//=====================================================================
class CInstanceRowFetchObj : public CRowFetchObj
{
public:
	virtual HRESULT FetchRows(	CRowset *	 pRowset,
						HCHAPTER	hChapter,        // IN  The Chapter handle.
						DBROWOFFSET	lRowOffset,      // IN  Rows to skip before reading
						DBROWCOUNT  cRows,           // IN  Number of rows to fetch
						DBCOUNTITEM*pcRowsObtained, // OUT Number of rows obtained
						HROW       **prghRows);       // OUT Array of Hrows obtained)

};

//=====================================================================
// Row fetch object for fetching data for rowsets qualifiers
//=====================================================================
class CQualifierRowFetchObj : public CRowFetchObj
{
public:
	virtual HRESULT FetchRows(	CRowset *	 pRowset,
						HCHAPTER	hChapter,        // IN  The Chapter handle.
						DBROWOFFSET	lRowOffset,      // IN  Rows to skip before reading
						DBROWCOUNT	cRows,           // IN  Number of rows to fetch
						DBCOUNTITEM*pcRowsObtained, // OUT Number of rows obtained
						HROW     **	prghRows);       // OUT Array of Hrows obtained)

};



inline BOOL CRowset::BitArrayInitialized()     
{ return ((LPBITARRAY)m_pIAccessor->GetBitArrayPtr()) == NULL ? FALSE : TRUE; }

inline LPEXTBUFFER CRowset::GetAccessorBuffer()
{ return (LPEXTBUFFER)m_pIAccessor->GetAccessorPtr(); }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\schema.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
//
// (C) Copyright 1999-2000 Microsoft Corporation. All Rights Reserved.
//
//	Schema.cpp	-	Schema related class implementation
////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "headers.h"
#include "schema.h"
#include "enumerat.h"

extern const WCHAR szWQL[] = L"WQL";
extern const WCHAR szWQL2[] = L"WQL2";


#define TABLENAMEMAX 255
//Bug No: NTRaid 126631
// 06/13/00
#define NUMBER_OF_SCHEMAS	8
enum guiddata
{
	data1_DBSCHEMA_CATALOGS             = 0xc8b52211,
	data1_DBSCHEMA_PROVIDER_TYPES       = 0xc8b5222c,
    data1_DBSCHEMA_COLUMNS              = 0xc8b52214,
    data1_DBSCHEMA_TABLES               = 0xc8b52229,
    data1_DBSCHEMA_PRIMARY_KEYS         = 0xc8b522c5,
	data1_DBSCHEMA_TABLES_INFO          = 0xc8b522e0,
    data1_DBSCHEMA_PROCEDURES           = 0xc8b52224,
    data1_DBSCHEMA_PROCEDURE_PARAMETERS = 0xc8b522b8,
};
////////////////////////////////////////////////////////////////////////////////////////////////////////////

CIMTypeInfo g_ProviderTypeDetails[] = {
    { L"CIM_EMPTY",     0,                  0,                  0},
    { L"CIM_SINT8",     DBTYPE_I1,          sizeof(BYTE),       0},
    { L"CIM_UINT8",     DBTYPE_UI1,         sizeof(BYTE),       1},
    { L"CIM_SINT16",    DBTYPE_I2,          sizeof(short),      0},
    { L"CIM_UINT16",    DBTYPE_UI2,         sizeof(short),      1},
    { L"CIM_SINT32",    DBTYPE_I4,          sizeof(long),       0},
    { L"CIM_UINT32",    DBTYPE_UI4,         sizeof(long),       1},
    { L"CIM_SINT64",    DBTYPE_I8,          sizeof(__int64),    0},
    { L"CIM_UINT64",    DBTYPE_UI8,         sizeof(__int64),    1},
    { L"CIM_REAL32",    DBTYPE_R4,          sizeof(long),       0},
    { L"CIM_REAL64",    DBTYPE_R8,          sizeof(__int64),    0},
    { L"CIM_BOOLEAN",   DBTYPE_BOOL,        sizeof(short),      0},
    { L"CIM_STRING",    DBTYPE_BSTR,        ~0,                 0},
    { L"CIM_DATETIME",  DBTYPE_DBTIMESTAMP, sizeof(DBTIMESTAMP),0},
//    { L"CIM_REFERENCE", 0,                  0,                  0},
    { L"CIM_CHAR16",    DBTYPE_UI2,         sizeof(short),      1}
//    { L"CIM_OBJECT",    DBTYPE_IUNKNOWN,    sizeof(BSTR),       0},
//    { L"CIM_FLAG_ARRAY",0,                  0,                  0}
};

SchemaRowsetDefinition g_SourcesRowsetColumns[] = { {L"SOURCES_NAME",       CIM_STRING}, 
                                                    {L"SOURCES_PARSENAME",  CIM_STRING}, 
                                                    {L"SOURCES_DESCRIPTION",CIM_STRING},
                                                    {L"SOURCES_TYPE",       CIM_UINT16},
                                                    {L"SOURCES_ISPARENT",   CIM_BOOLEAN}};


SchemaRowsetDefinition g_ProviderTypes[] = { {L"TYPE_NAME",         CIM_STRING}, 
                                             {L"DATA_TYPE",         CIM_UINT16}, 
                                             {L"COLUMN_SIZE",       CIM_UINT32}, 
                                             {L"LITERAL_PREFIX",    CIM_STRING},
                                             {L"LITERAL_SUFFIX",    CIM_STRING},
                                             {L"CREATE_PARAMS",     CIM_STRING},
                                             {L"IS_NULLABLE",       CIM_BOOLEAN},
                                             {L"CASE_SENSITIVE",    CIM_BOOLEAN},
                                             {L"SEARCHABLE"    ,    CIM_UINT32},
                                             {L"UNSIGNED_ATTRIBUTE",CIM_BOOLEAN},
                                             {L"FIXED_PREC_SCALE",  CIM_BOOLEAN},
                                             {L"AUTO_UNIQUE_VALUE", CIM_BOOLEAN},
                                             {L"LOCAL_TYPE_NAME",   CIM_STRING},
                                             {L"MINIMUM_SCALE",     CIM_SINT16},
                                             {L"MAXIMUM_SCALE",     CIM_SINT16},
                                             {L"GUID",              DBTYPE_GUID},
                                             {L"TYPELIB",           CIM_STRING},
                                             {L"VERSION",           CIM_STRING},
                                             {L"IS_LONG",           CIM_BOOLEAN},
                                             {L"BEST_MATCH",        CIM_BOOLEAN},
                                             {L"IS_FIXEDLENGTH",    CIM_BOOLEAN} };

SchemaRowsetDefinition g_CatalogRowsetColumns[] = {{L"CATALOG_NAME",       CIM_STRING},
                                                    {L"SOURCES_DESCRIPTION", CIM_STRING} };

SchemaRowsetDefinition g_Tables[] =  {  {L"TABLE_CATALOG",   CIM_STRING},
                                        {L"TABLE_SCHEMA",    CIM_STRING},
                                        {L"TABLE_NAME",      CIM_STRING},
                                        {L"TABLE_TYPE",      CIM_STRING},
                                        {L"TABLE_GUID",      DBTYPE_GUID},
                                        {L"DESCRIPTION",     CIM_STRING},
                                        {L"TABLE_PROPID",    CIM_UINT32},
                                        {L"DATE_CREATED",    DBTYPE_DATE},
                                        {L"DATE_MODIFIED",   DBTYPE_DATE}};


SchemaRowsetDefinition g_TablesInfo[] =  {  {L"TABLE_CATALOG",  CIM_STRING},
                                        {L"TABLE_SCHEMA",       CIM_STRING},
                                        {L"TABLE_NAME",         CIM_STRING},
                                        {L"TABLE_TYPE",         CIM_STRING},
                                        {L"TABLE_GUID",         DBTYPE_GUID},
                                        {L"BOOKMARKS",          CIM_BOOLEAN},
                                        {L"BOOKMARK_TYPE",      CIM_UINT32},
                                        {L"BOOKMARK_DATATYPE",      CIM_UINT16},
                                        {L"BOOKMARK_MAXIMUM_LENGTH",CIM_UINT32},
                                        {L"BOOKMARK_INFORMATION",   CIM_UINT32},
                                        {L"TABLE_VERSION",          CIM_SINT64},
                                        {L"CARDINALITY",            CIM_UINT64},
                                        {L"DESCRIPTION",            CIM_STRING},
                                        {L"TABLE_PROPID",           CIM_UINT32}};


SchemaRowsetDefinition g_ColumnsRowsetColumns[] = { {L"TABLE_CATALOG",              CIM_STRING},
                                                    {L"TABLE_SCHEMA",               CIM_STRING}, 
                                                    {L"TABLE_NAME",                 CIM_STRING}, 
                                                    {L"COLUMN_NAME",                CIM_STRING}, 
                                                    {L"COLUMN_GUID",                DBTYPE_GUID}, 
                                                    {L"COLUMN_PROPID",              CIM_UINT32}, 
                                                    {L"COLUMN_POSITION",            CIM_UINT32}, 
                                                    {L"COLUMN_HASDEFAULT",          CIM_BOOLEAN}, 
                                                    {L"COLUMN_DEFAULT",             CIM_STRING}, 
                                                    {L"COLUMN_FLAGS",               CIM_UINT32}, 
                                                    {L"IS_NULLABLE",                CIM_BOOLEAN}, 
                                                    {L"DATA_TYPE",                  CIM_UINT16}, 
                                                    {L"TYPE_GUID",                  DBTYPE_GUID}, 
                                                    {L"CHARACTER_MAXIMUM_LENGTH",   CIM_UINT32}, 
                                                    {L"CHARACTER_OCTET_LENGTH",     CIM_UINT32}, 
                                                    {L"NUMERIC_PRECISION",          CIM_UINT16}, 
                                                    {L"NUMERIC_SCALE",              CIM_SINT16}, 
                                                    {L"DATETIME_PRECISION",         CIM_UINT32}, 
                                                    {L"CHARACTER_SET_CATALOG",      CIM_STRING}, 
                                                    {L"CHARACTER_SET_SCHEMA",       CIM_STRING}, 
                                                    {L"CHARACTER_SET_NAME",         CIM_STRING}, 
                                                    {L"COLLATION_CATALOG",          CIM_STRING}, 
                                                    {L"COLLATION_SCHEMA",           CIM_STRING}, 
                                                    {L"COLLATION_NAME",             CIM_STRING}, 
                                                    {L"DOMAIN_CATALOG",             CIM_STRING}, 
                                                    {L"DOMAIN_SCHEMA",              CIM_STRING}, 
                                                    {L"DOMAIN_NAME",                CIM_STRING}, 
                                                    {L"DESCRIPTION",                CIM_STRING}};


SchemaRowsetDefinition g_PrimaryKeysColumns[] =  {  {L"TABLE_CATALOG",   CIM_STRING},
                                                    {L"TABLE_SCHEMA",    CIM_STRING},
                                                    {L"TABLE_NAME",      CIM_STRING},
                                                    {L"COLUMN_NAME",     CIM_STRING},
                                                    {L"COLUMN_GUID",     DBTYPE_GUID},
                                                    {L"COLUMN_PROPID",   CIM_UINT32},
                                                    {L"ORDINAL",         CIM_UINT32},
                                                    {L"PK_NAME",         CIM_STRING}};
        
SchemaRowsetDefinition g_Procedures[] = {{L"PROCEDURE_CATALOG",     CIM_STRING},
                                         {L"PROCEDURE_SCHEMA",      CIM_STRING},
                                         {L"PROCEDURE_NAME",        CIM_STRING}, 
                                         {L"PROCEDURE_TYPE",        CIM_SINT16}, 
                                         {L"PROCEDURE_DEFINITION",  CIM_STRING}, 
                                         {L"DESCRIPTION",           CIM_STRING}, 
                                         {L"DATE_CREATED",          DBTYPE_DATE}, 
                                         {L"DATE_MODIFIED",          DBTYPE_DATE}}; 


SchemaRowsetDefinition g_ProcedureParameters[] = {{L"PROCEDURE_CATALOG",     CIM_STRING},
                                                  {L"PROCEDURE_SCHEMA",      CIM_STRING},
                                                  {L"PROCEDURE_NAME",        CIM_STRING}, 
                                                  {L"PARAMETER_NAME",        CIM_STRING}, 
                                                  {L"ORDINAL_POSITION",      CIM_UINT16}, 
                                                  {L"PARAMETER_TYPE",        CIM_UINT16}, 
                                                  {L"PARAMETER_HASDEFAULT",  CIM_BOOLEAN}, 
                                                  {L"PARAMETER_DEFAULT",     CIM_STRING}, 
                                                  {L"IS_NULLABLE",           CIM_BOOLEAN}, 
                                                  {L"DATATYPE",              CIM_UINT16}, 
                                                  {L"CHARACTER_MAXIMUM_LENGTH",CIM_UINT32}, 
                                                  {L"CHARACTER_OCTECT_LENGTH", CIM_UINT32}, 
                                                  {L"NUMERIC_PRECISION",       CIM_UINT16}, 
                                                  {L"NUMERIC_SCALE",           CIM_SINT16}, 
                                                  {L"DESCRIPTION",             CIM_STRING}, 
                                                  {L"TYPE_NAME",               CIM_STRING}, 
                                                  {L"LOCAL_TYPE_NAME",         CIM_STRING}};

SchemaRowsetDefinition g_ProcedureColumns[] = {{L"PROCEDURE_CATALOG",     CIM_STRING},
                                               {L"PROCEDURE_SCHEMA",      CIM_STRING},
                                               {L"PROCEDURE_NAME",        CIM_STRING}, 
                                               {L"COLUMN_NAME",           CIM_STRING},
                                               {L"COLUMN_GUID",           DBTYPE_GUID},
                                               {L"COLUMN_PROPID",         CIM_UINT32},
                                               {L"ROWSET_NUMBER",         CIM_UINT32},
                                               {L"ORDINAL_POSITION",      CIM_UINT32},
                                               {L"IS_NULLABLE",           CIM_BOOLEAN},
                                               {L"DATA_TYPE",             CIM_UINT16},
                                               {L"TYPE_GUID",             DBTYPE_GUID},
                                               {L"CHARACTER_MAXIMUM_LENGTH", CIM_UINT32},
                                               {L"CHARACTER_OCTECT_LENGTH",  CIM_UINT32},
                                               {L"NUMERIC_PRECISION",        CIM_UINT16},
                                               {L"NUMERIC_SCALE",            CIM_SINT16},
                                               {L"DESCRIPTION",              CIM_STRING}};


////////////////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************************
//
//  CLASS:  CSCHEMA
//
//**********************************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////////////////////////
CSchema::CSchema(LPUNKNOWN pUnkOuter, int nTableId,PCDBSESSION pObj) : 
            CRowset(pUnkOuter,pObj)	
{
	m_nTableId = nTableId;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
CSchema::~CSchema()
{
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Sets the rowset property corresponding to the requested interface if the requested interface is available
// on a read-only rowset.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CSchema::SetReadOnlyProperty( CUtilProp*	pRowsetProps,REFIID riid )
{
	HRESULT hr = S_OK;
	
	if (riid == IID_IRowsetChange || riid == IID_IRowsetUpdate	|| riid == IID_IRowsetResynch)
		hr = (E_NOINTERFACE);

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Initialize a schema rowset
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSchema::FInit(    ULONG	    cPropertySets, 	    DBPROPSET rgPropertySets[],	
                                REFIID	    riid,		        IUnknown	*pUnkOuter,			
                                IUnknown		**ppIRowset,    WCHAR * wcsSpecificTable )
{
	HRESULT					hr = S_OK;
	HRESULT					hrProp = S_OK;
	DWORD					dwStatus = 0;
	PWSTR					pwszBuff = NULL;
	LONG					cCursorRows = 0;
	WCHAR					strTableName[TABLENAMEMAX];

	memset(strTableName,0,TABLENAMEMAX * sizeof(WCHAR));

	if( SUCCEEDED(hr =GetTableName(strTableName)))
	{
	   //==========================================================================
		// Set the Rowset Properties 
		//==========================================================================
		hr = InitRowset(m_nTableId, cPropertySets,rgPropertySets,strTableName,0,wcsSpecificTable);
		if(SUCCEEDED(hr))
		{

			//==========================================================================
			// If the consumer asks for IID_IUnknown, IID_IAccessor, 
			// IID_IColumnsInfo, or IID_IRowsetInfo, we do not need to 
			//==========================================================================
			if ( riid != IID_IRowset &&	riid != IID_IColumnsInfo && riid != IID_IAccessor && riid != IID_IRowsetInfo 
				&& riid !=  IID_IUnknown && riid != IID_IMultipleResults ){
				hr = SetReadOnlyProperty(m_pUtilProp,riid);
			}

			if(SUCCEEDED(hr))
			{
				//==========================================================================
				// Execute the schema command to produce the rowset.
				//==========================================================================

				if (SUCCEEDED(hr)){

					if (hr == DB_E_ERRORSOCCURRED && cPropertySets > 0){
						m_pUtilProp->SetPropertiesArgChk(cPropertySets, rgPropertySets);
					}
				}


				if (DB_S_ERRORSOCCURRED == hr){

					hrProp = DB_S_ERRORSOCCURRED;
					if (cPropertySets > 0)
					{
						m_pUtilProp->SetPropertiesArgChk(cPropertySets, rgPropertySets);
					}
				}

				//==========================================================================
				// Get the requested interfaceS
				//==========================================================================
				hr = QueryInterface(riid, (LPVOID*)ppIRowset);
				
			}	// if (Succeeded(hr))
		
		}	// If(succeeded(hr) after initializing the rowset
	
	}	// if a valid tablename


	hr =  (hr == S_OK) ? hrProp : hr;
	hr = hr != S_OK ? g_pCError->PostHResult(hr, &IID_IDBSchemaRowset) : hr;
	return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CSchema::GetTableName(WCHAR *pTableName)
{
	HRESULT hr = S_OK;

	if(pTableName != NULL)
	{
		switch(m_nTableId)
		{
            case PROCEDURES_ROWSET:
				wcscpy(pTableName,PROCEDURES);
                break;

            case PROCEDURE_PARAMETERS_ROWSET:
				wcscpy(pTableName,PROCEDURE_PARAMETERS);
                break;

			case SOURCES_ROWSET:
				wcscpy(pTableName,NAMESPACE);
				break;

			case PROVIDER_TYPES_ROWSET:
				wcscpy(pTableName,PROVIDER_TYPES);
				break;

			case CATALOGS_ROWSET:
				wcscpy(pTableName,CATALOGS);
				break;

			case COLUMNS_ROWSET:
				wcscpy(pTableName,COLUMNS);
				break;

			case TABLES_ROWSET:
				wcscpy(pTableName,TABLES);
				break;

			case PRIMARY_KEYS_ROWSET:
				wcscpy(pTableName,PRIMARY_KEYS);
				break;

			case TABLES_INFO_ROWSET:
				wcscpy(pTableName,TABLESINFO);
				break;

			default:
				hr = E_FAIL;

		};
	}
	else
	{
		hr = E_FAIL;
	}
	return hr;

}
/*
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Increments a reference count for the object.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpIDBSchemaRowset::AddRef(void)
{
    DEBUGCODE(InterlockedIncrement((long*)&m_cRef));
	return m_pCDBSession->AddRef();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Decrement the object's reference count and deletes the object when the new reference count is zero.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CImpIDBSchemaRowset::Release(void)
{
    DEBUGCODE(InterlockedDecrement((long*)&m_cRef));
	return m_pCDBSession->Release();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns a pointer to a specified interface. Callers use QueryInterface to determine which interfaces the 
// called object supports. 
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIDBSchemaRowset::QueryInterface( REFIID riid, LPVOID *	ppv	)	
{
	return m_pCDBSession->QueryInterface(riid, ppv);
}

*/
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//**********************************************************************************************************
//
//  CLASS CImpIDBSchemaRowset
//
//**********************************************************************************************************
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Instantiate a rowset with schema information.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIDBSchemaRowset::GetRowset( IUnknown *pUnkOuter, REFGUID rguidSchema, ULONG cRestrictions,
                                        	 const VARIANT rgRestrictions[], REFIID riid,ULONG cProperties,
                                             DBPROPSET rgProperties[], IUnknown **ppIRowset	)
{
	HRESULT hr;
	CSchema *pCSchema = NULL;
    WCHAR * wcsSpecificTable = NULL;

    //========================================================
	// Serialize access to this object.
    //========================================================

	CAutoBlock cab(m_pCDBSession->GetCriticalSection());


	CError::ClearErrorInfo();

    //========================================================
	// Assign in case of error.
    //========================================================
	if (ppIRowset)
    {
		*ppIRowset = NULL;
    }
    //========================================================
	// Check per spec.
    //========================================================
    if (ppIRowset == NULL	|| (cRestrictions && rgRestrictions == NULL)	|| (cProperties   && rgProperties   == NULL) )
    {
		g_pCError->PostHResult(E_INVALIDARG, &IID_IDBSchemaRowset);
    }
    else
    {
        //========================================================
	    // The outer object must explicitly ask for IUnknown
        //========================================================
	    if (pUnkOuter != NULL && riid != IID_IUnknown)
        {
		    g_pCError->PostHResult((DB_E_NOAGGREGATION), &IID_IDBSchemaRowset);
	    }
        else{
            //========================================================
	        // Assume that all the pre-defined OLEDB guids differ 
            // only by the first DWORD, Data1. We have to make a 
            // table of constants, since the compiler can't 
	        // have non-constants in case statements.
            //========================================================

	        switch ( rguidSchema.Data1 )
            {

                //===================================================
                //  methods - the list of methods for a table
                //===================================================
                case data1_DBSCHEMA_PROCEDURES:

                    if (cRestrictions > CRESTRICTIONS_DBSCHEMA_PROCEDURES)
                    {
				        g_pCError->PostHResult(E_INVALIDARG, &IID_IDBSchemaRowset);
                    }
                    else
                    {
                        //====================================================================
                        //  The specific table name is located in the 3rd restriction
                        //====================================================================
                        if( cRestrictions > 1  && rgRestrictions[1].vt != VT_EMPTY)
                        {
                            wcsSpecificTable = V_BSTR(&rgRestrictions[1]);
                        }
			            pCSchema = new CSchema_Procedures(pUnkOuter,m_pCDBSession);
                    }
                    break;

                //===================================================
                //  methods - the list of parameters for a method
                //===================================================
                case data1_DBSCHEMA_PROCEDURE_PARAMETERS:
                    if (cRestrictions > CRESTRICTIONS_DBSCHEMA_PROCEDURE_PARAMETERS)
                    {
				        g_pCError->PostHResult(E_INVALIDARG, &IID_IDBSchemaRowset);
                    }
                    else
                    {
                        //====================================================================
                        //  The specific table name is located in the 3rd restriction
                        //====================================================================
                        if( cRestrictions > 1 && rgRestrictions[1].vt != VT_EMPTY)
                        {
                            wcsSpecificTable = V_BSTR(&rgRestrictions[1]);
                        }
			            pCSchema = new CSchema_Procedure_Parameters(pUnkOuter,m_pCDBSession);
                    }
                    break;

                //===================================================
                //  catalogs
                //===================================================
                case data1_DBSCHEMA_CATALOGS:

                    if (cRestrictions > CRESTRICTIONS_DBSCHEMA_CATALOGS)
                    {
				        g_pCError->PostHResult(E_INVALIDARG, &IID_IDBSchemaRowset);
                    }
                    else
                        {
			            pCSchema = new CSchema_Catalogs(pUnkOuter,m_pCDBSession);
                    }
			        break;

                //===================================================
                //  provider types
                //===================================================
		        case data1_DBSCHEMA_PROVIDER_TYPES:
                    if (cRestrictions > CRESTRICTIONS_DBSCHEMA_PROVIDER_TYPES){
				        g_pCError->PostHResult(E_INVALIDARG, &IID_IDBSchemaRowset);
                    }
                    else{
			            pCSchema = new CSchema_Provider_Types(pUnkOuter,m_pCDBSession);
                    }
			        break;

                //===================================================
                //  columns
                //===================================================
                case data1_DBSCHEMA_COLUMNS:
                    if (cRestrictions > CRESTRICTIONS_DBSCHEMA_COLUMNS)
                    {
				        g_pCError->PostHResult(E_INVALIDARG, &IID_IDBSchemaRowset);
                    }
                    else
                    {
                        //====================================================================
                        //  The specific table name is located in the 3rd restriction
                        //====================================================================
                        if( cRestrictions > 2 && rgRestrictions[2].vt != VT_EMPTY)
                        {
                            wcsSpecificTable = V_BSTR(&rgRestrictions[2]);
                        }
			            pCSchema = new CSchema_Columns(pUnkOuter,m_pCDBSession);
                    }
			        break;


                //===================================================
                //  tables
                //===================================================
                case data1_DBSCHEMA_TABLES:
                    if (cRestrictions > CRESTRICTIONS_DBSCHEMA_TABLES)
                    {
				       g_pCError->PostHResult(E_INVALIDARG, &IID_IDBSchemaRowset);
                    }
                    else
                    {
                        //====================================================================
                        //  The specific table name is located in the 3rd restriction
                        //====================================================================
                        if( cRestrictions > 2 && rgRestrictions[2].vt != VT_EMPTY)
                        {
                            wcsSpecificTable = V_BSTR(&rgRestrictions[2]);
                        }
			            pCSchema = new CSchema_Tables(pUnkOuter,m_pCDBSession);
                    }
			        break;

                //===================================================
                //  primary keys
                //===================================================
                case data1_DBSCHEMA_PRIMARY_KEYS:
                    if (cRestrictions > CRESTRICTIONS_DBSCHEMA_TABLES_INFO)
                    {
				       g_pCError->PostHResult(E_INVALIDARG, &IID_IDBSchemaRowset);
                    }
                    else
                    {
                        //====================================================================
                        //  The specific table name is located in the 2nd restriction
                        //====================================================================
                        if( cRestrictions > 1 && rgRestrictions[1].vt != VT_EMPTY)
                        {
                            wcsSpecificTable = V_BSTR(&rgRestrictions[1]);
                        }
			            pCSchema = new CSchema_Primary_Keys(pUnkOuter,m_pCDBSession);
                    }
			        break;

                //===================================================
                //  tables info
                //===================================================
                case data1_DBSCHEMA_TABLES_INFO:
                    if (cRestrictions > CRESTRICTIONS_DBSCHEMA_TABLES_INFO)
                    {
				       g_pCError->PostHResult(E_INVALIDARG, &IID_IDBSchemaRowset);
                    }
                    else
                    {
                        //====================================================================
                        //  The specific table name is located in the 3rd restriction
                        //====================================================================
                        if( cRestrictions > 2 && rgRestrictions[2].vt != VT_EMPTY)
                        {
                            wcsSpecificTable = V_BSTR(&rgRestrictions[2]);
                        }
			            pCSchema = new CSchema_Tables_Info(pUnkOuter,m_pCDBSession);
                    }
			        break;


		        default:
                    //===================================================
			        // check for provider-specific schema rowsets
                    //===================================================
			        return g_pCError->PostHResult(E_INVALIDARG, &IID_IDBSchemaRowset);
			        break;
	        }
            //===================================================
	        // At this point, pCSchema contains the uninitialized 
            // object, derived from CSchema
            //===================================================
	        if (!pCSchema)
            {
		        g_pCError->PostHResult((E_OUTOFMEMORY), &IID_IDBSchemaRowset);
	        }
        }
    }
    //===================================================
	// Initialize.  Creates the rowset.
    //===================================================
    if( pCSchema )
    {
    	hr = pCSchema->FInit(cProperties, rgProperties, riid, pUnkOuter, ppIRowset,wcsSpecificTable);
        if( S_OK == hr )
        {
            (*ppIRowset)->AddRef();
        }

        //===================================================
    	// Release our reference.
        //===================================================
    	pCSchema->Release();
    }
	else
	{
		hr = E_OUTOFMEMORY;
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Return an array of guids for supported schemas.
//
//Bug No: NTRaid 126631
// 06/13/00
////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpIDBSchemaRowset::GetSchemas( ULONG *pcSchemas, GUID **ppSchemas, ULONG **prgRestrictionSupport	)
{
	GUID	*pSchemas;
	ULONG	*pRestrictionSupport;
	ULONG	cSchemas;

    //===================================================
	// Serialize access to this object.
    //===================================================
//	m_pCDBSession->GetCriticalSection();

	g_pCError->ClearErrorInfo();

	if (pcSchemas)
		*pcSchemas = 0;
	if (ppSchemas)
		*ppSchemas = NULL;
	if (prgRestrictionSupport)
		*prgRestrictionSupport = NULL;

    //===================================================
	// Check per spec.
    //===================================================
    if (pcSchemas == NULL || ppSchemas == NULL || prgRestrictionSupport == NULL)
    {
		return g_pCError->PostHResult((E_INVALIDARG), &IID_IDBSchemaRowset);
	}

	cSchemas = NUMBER_OF_SCHEMAS;
	pSchemas = (GUID*) g_pIMalloc->Alloc(sizeof(GUID) * cSchemas);
	if (NULL == pSchemas)
    {
		return g_pCError->PostHResult((E_OUTOFMEMORY),&IID_IDBSchemaRowset);
	}
	pRestrictionSupport = (ULONG*)g_pIMalloc->Alloc(sizeof(ULONG) * cSchemas);
	
	if (NULL == pRestrictionSupport)
    {
		g_pIMalloc->Free(pSchemas);
		return g_pCError->PostHResult((E_OUTOFMEMORY),&IID_IDBSchemaRowset);
	}

	*ppSchemas  = pSchemas;
	*pSchemas++ = DBSCHEMA_CATALOGS;
	*pSchemas++ = DBSCHEMA_PROVIDER_TYPES;
	*pSchemas++ = DBSCHEMA_COLUMNS;
	*pSchemas++ = DBSCHEMA_TABLES;
	*pSchemas++ = DBSCHEMA_PRIMARY_KEYS;
	*pSchemas++ = DBSCHEMA_TABLES_INFO;
	*pSchemas++ = DBSCHEMA_PROCEDURES;
	*pSchemas++ = DBSCHEMA_PROCEDURE_PARAMETERS;


	if( prgRestrictionSupport != NULL)
	{
		*prgRestrictionSupport = pRestrictionSupport;
		*pRestrictionSupport++ = eSup_CATALOGS;
		*pRestrictionSupport++ = eSup_PROVIDER_TYPES;
		*pRestrictionSupport++ = eSup_COLUMNS;
		*pRestrictionSupport++ = eSup_TABLES;
		*pRestrictionSupport++ = eSup_PRIMARY_KEYS;
		*pRestrictionSupport++ = eSup_TABLES_INFO;
		*pRestrictionSupport++ = eSup_PROCEDURES;
		*pRestrictionSupport++ = eSup_PROCEDURE_PARAMETERS;
	}

    //===================================================
	// Set the number of schemas we have recorded.
    //===================================================
	*pcSchemas = cSchemas;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//***********************************************************************************************************
//
//      Class Schema definition 
//
//***********************************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemSchemaClassDefinitionWrapper::CWbemSchemaClassDefinitionWrapper(CWbemClassParameters * p) : 
                    CWbemClassDefinitionWrapper(p)
{
    m_nSchemaClassIndex = 0;
    m_nMaxColumns		= 0;
	m_bSchema			= TRUE;

}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemSchemaClassDefinitionWrapper::~CWbemSchemaClassDefinitionWrapper()
{
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaClassDefinitionWrapper::ValidClass( )
{
    return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaClassDefinitionWrapper::TotalPropertiesInClass(ULONG & ulPropCount, ULONG & ulSysPropCount )
{
    ulPropCount = m_nMaxColumns;
    ulSysPropCount = 0;
    return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaClassDefinitionWrapper::BeginPropertyEnumeration()
{
    m_nSchemaClassIndex = 0;
    return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaClassDefinitionWrapper::EndPropertyEnumeration()
{
    m_nSchemaClassIndex = 0;
    return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
// return failed, because we don't support the property qualifier enumeration
HRESULT CWbemSchemaClassDefinitionWrapper::BeginPropertyQualifierEnumeration(BSTR strPropName)
{
    return WBEM_S_NO_MORE_DATA;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
//************************************************************************************************
//
//  Deal with a Schema class instance
//
//************************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////////
CWbemSchemaClassInstanceWrapper::CWbemSchemaClassInstanceWrapper( CWbemClassParameters * p ): CWbemClassInstanceWrapper(p)
{
    m_uCurrentIndex = 0;
    m_nMaxColumns = 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
CWbemSchemaClassInstanceWrapper::~CWbemSchemaClassInstanceWrapper( )
{
}


//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaClassInstanceWrapper::GetClassProperty(WCHAR * wcsProperty, VARIANT * v, CIMTYPE * pType , LONG * plFlavor )
{
    HRESULT hr;

    BSTR bProp;
	bProp = Wmioledb_SysAllocString(wcsProperty);
    hr = GetProperty(bProp,v,pType,plFlavor);
    SysFreeString(bProp);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
void CWbemSchemaClassInstanceWrapper::AddToKeyList(WCHAR *& pwcsKeyList, WCHAR * wcsKey )
{
    WCHAR * pTmp = NULL;

    if( !pwcsKeyList ){
        pwcsKeyList = new WCHAR[wcslen(wcsKey) + 1];
        wcscpy(pwcsKeyList,wcsKey);
    }
    else{
        pTmp = new WCHAR[wcslen(pwcsKeyList) + wcslen(wcsKey) + 10];
        swprintf(pTmp,L"%s,%s",pwcsKeyList,wcsKey);
        SAFE_DELETE_PTR(pwcsKeyList);
        pwcsKeyList = pTmp;
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//***********************************************************************************************************
//      Class Schema Instance List
//***********************************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemSchemaInstanceList::CWbemSchemaInstanceList(CWbemClassParameters * p) : CWbemInstanceList(p)
{
    m_ulMaxRow = 0;
    m_fGotThemAll = FALSE;
    m_pSpecificClass = NULL;
    m_pwcsSpecificClass = NULL;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemSchemaInstanceList::CWbemSchemaInstanceList(CWbemClassParameters * p,WCHAR * pSpecific) : CWbemInstanceList(p)
{
    m_pSpecificClass = NULL;
    m_ulMaxRow = 0;
    m_fGotThemAll = FALSE;
    m_pwcsSpecificClass = pSpecific;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemSchemaInstanceList::~CWbemSchemaInstanceList()
{
    ResetTheSpecificClass();
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaInstanceList::ResetTheSpecificClass()
{
    m_fGotThemAll = FALSE;
    SAFE_RELEASE_PTR(m_pSpecificClass);
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaInstanceList::GetTheSpecificClass()
{
    HRESULT hr = WBEM_S_NO_MORE_DATA;
    if( !m_fGotThemAll )
    {
        hr = (m_pParms->GetServicesPtr())->GetObject(m_pwcsSpecificClass, 0, NULL, &m_pSpecificClass, NULL);
        m_fGotThemAll = TRUE;
    }
    return hr;
}
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
//
//  Classes for the Sources schema rowset
//
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
CWbemSchemaSourcesClassDefinitionWrapper::CWbemSchemaSourcesClassDefinitionWrapper(CWbemClassParameters * p) : CWbemSchemaClassDefinitionWrapper(p)
{
    
    m_nMaxColumns = sizeof(g_SourcesRowsetColumns)/sizeof(SchemaRowsetDefinition);
}

//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaSourcesClassDefinitionWrapper::GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor )
{
    HRESULT hr = S_OK;

    //===============================================================================
    //  See if we got all of the column info
    //===============================================================================
    if( m_nSchemaClassIndex == m_nMaxColumns )
    {
        return WBEM_S_NO_MORE_DATA;
    }

    //===============================================================================
    //  Get the column name and data type
    //===============================================================================
    *pType = g_SourcesRowsetColumns[m_nSchemaClassIndex].Type;
    *pProperty = Wmioledb_SysAllocString(g_SourcesRowsetColumns[m_nSchemaClassIndex].wcsColumnName);

    m_nSchemaClassIndex++;

    return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaSourcesInstanceWrapper::GetSchemaProperty( WCHAR * pProperty, VARIANT * v,CIMTYPE * pType , LONG * plFlavor)
{

    HRESULT hr = S_OK;

   ((CVARIANT*)v)->Clear();
   *plFlavor = 0;
    int i = 0;

    //=============================================================
    // SOURCES_NAME
    //=============================================================
   
    if( _wcsicmp(pProperty,g_SourcesRowsetColumns[0].wcsColumnName) == 0 )
    {
        hr = GetClassProperty(L"Name",v,pType,plFlavor);
    }
    //=============================================================
    // SOURCES_PARSENAME
    //=============================================================
    else if( _wcsicmp(pProperty,g_SourcesRowsetColumns[1].wcsColumnName) == 0 )
    {
       hr = GetClassProperty(L"__PATH",v,pType,plFlavor);
    }
    else
    { 
       //=============================================================
       //  Initialize the common stuff for these last column types
       //=============================================================
       *plFlavor = 0;

       //=============================================================
       // SOURCES_DESCRIPTION
       //=============================================================
       if( _wcsicmp(pProperty,g_SourcesRowsetColumns[2].wcsColumnName) == 0 ){
            *pType = CIM_STRING;
            ((CVARIANT*)v)->SetStr(L"N/A");
       }            
       //=============================================================
       // SOURCES_TYPE
       //=============================================================
       else if( _wcsicmp(pProperty,g_SourcesRowsetColumns[3].wcsColumnName) == 0 ){
            *pType = CIM_UINT16;
            ((CVARIANT*)v)->SetShort(DBSOURCETYPE_DATASOURCE);
       }
       //=============================================================
       // SOURCES_ISPARENT
       //=============================================================
       else if( _wcsicmp(pProperty,g_SourcesRowsetColumns[4].wcsColumnName) == 0 ){
            *pType = CIM_BOOLEAN;
            ((CVARIANT*)v)->SetBool(VARIANT_FALSE);
       }
       else{
           hr = E_INVALIDARG;
       }
    }

    return MapWbemErrorToOLEDBError(hr);
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaSourcesInstanceList::Reset()
{
    HRESULT hr = E_UNEXPECTED;
    LONG lFlags = WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY;

    //============================================================
    //  Send off the query for "Select Name from __Namespace
    //============================================================
    if( m_ppEnum )
    {
        hr = m_ppEnum->Reset();
        ReleaseAllInstances();
    }
    else
    {
         hr = (m_pParms->GetServicesPtr())->ExecQuery(CBSTR((WCHAR *)szWQL),CBSTR(L"select * from __Namespace"), WBEM_FLAG_FORWARD_ONLY,m_pParms->m_pConnection->GetContext(),&m_ppEnum);
    }
	m_lCurrentPos = 0;

    return MapWbemErrorToOLEDBError(hr);
}

//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
//
//  Classes for the Provider Types schema rowset
//
//////////////////////////////////////////////////////////////////////////////////////////////
//********************************************************************************************
CWbemSchemaProviderTypesClassDefinitionWrapper::CWbemSchemaProviderTypesClassDefinitionWrapper(CWbemClassParameters * p) : CWbemSchemaClassDefinitionWrapper(p) 
{
    
    m_nMaxColumns = sizeof(g_ProviderTypes)/sizeof(SchemaRowsetDefinition);
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProviderTypesClassDefinitionWrapper::GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor )
{
    HRESULT hr = S_OK;

    //===============================================================================
    //  See if we got all of the column info
    //===============================================================================
    if( m_nSchemaClassIndex == m_nMaxColumns )
    {
        return WBEM_S_NO_MORE_DATA;
    }

    //===============================================================================
    //  Get the column name and data type
    //===============================================================================
    *pType = g_ProviderTypes[m_nSchemaClassIndex].Type;
    *pProperty = Wmioledb_SysAllocString(g_ProviderTypes[m_nSchemaClassIndex].wcsColumnName);
    m_nSchemaClassIndex++;

    return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProviderTypesInstanceWrapper::ResetInstanceFromKey(CBSTR Key)
{
    return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProviderTypesInstanceWrapper::RefreshInstance()
{
    return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////////////////////
WCHAR *  CWbemSchemaProviderTypesInstanceWrapper::GetClassName()
{
     return L"PROVIDER_TYPES";
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProviderTypesInstanceWrapper::GetSchemaProperty( WCHAR * pProperty, VARIANT * vVar,CIMTYPE * pType , LONG * plFlavor)
{
    HRESULT hr = S_OK;

   ((CVARIANT*)vVar)->Clear();
   *plFlavor = 0;

    ULONG_PTR i = GetPos();

    //=============================================================
    // TYPE_NAME 
    //=============================================================
    if( _wcsicmp(pProperty,g_ProviderTypes[0].wcsColumnName) == 0 ){
        *pType = CIM_STRING;
        ((CVARIANT*)vVar)->SetStr(g_ProviderTypeDetails[i].wcsTypeName);
    }
    //=============================================================
    // DATA_TYPE
    //=============================================================
    else if( _wcsicmp(pProperty,g_ProviderTypes[1].wcsColumnName) == 0 ){
        *pType = CIM_UINT16;
        ((CVARIANT*)vVar)->SetShort(g_ProviderTypeDetails[i].DataType);
    }
    //=============================================================
    // COLUMN_SIZE
    //=============================================================
    else if( _wcsicmp(pProperty,g_ProviderTypes[2].wcsColumnName) == 0 ){
        *pType = CIM_SINT32;
        ((CVARIANT*)vVar)->SetLONG(g_ProviderTypeDetails[i].ColumnSize);
    }
    //=============================================================
    // LITERAL_PREFIX, LITERAL_SUFFIX, CREATE_PARAMS
    //=============================================================
    else if(( _wcsicmp(pProperty,g_ProviderTypes[3].wcsColumnName) == 0 ) ||
            ( _wcsicmp(pProperty,g_ProviderTypes[4].wcsColumnName) == 0 ) ||
            ( _wcsicmp(pProperty,g_ProviderTypes[5].wcsColumnName) == 0 ) ){
        *pType = CIM_STRING;
        ((CVARIANT*)vVar)->SetStr(L"");
    }
    //=============================================================
    // IS_NULLABLE,CASE_SENSITIVE
    //=============================================================
    else if(( _wcsicmp(pProperty,g_ProviderTypes[6].wcsColumnName) == 0 ) ||
            ( _wcsicmp(pProperty,g_ProviderTypes[7].wcsColumnName) == 0 ) ){
        *pType = CIM_BOOLEAN;
        ((CVARIANT*)vVar)->SetBool(VARIANT_FALSE);
    }
    //=============================================================
    // SEARCHABLE
    //=============================================================
    else if( _wcsicmp(pProperty,g_ProviderTypes[8].wcsColumnName) == 0 ){
        *pType = CIM_UINT32;
        ((CVARIANT*)vVar)->SetLONG(0);
    }
    //=============================================================
    // UNSIGNED_ATTRIBUTE
    //=============================================================
    else if( _wcsicmp(pProperty,g_ProviderTypes[9].wcsColumnName) == 0 ){
        *pType = CIM_BOOLEAN;
        ((CVARIANT*)vVar)->SetShort((short)g_ProviderTypeDetails[i].UnsignedAttribute);
    }
    //=============================================================
    // FIXED_PREC_SCALE, AUTO_UNIQUE_VALUE
    //=============================================================
    else if(( _wcsicmp(pProperty,g_ProviderTypes[10].wcsColumnName) == 0 ) ||
            ( _wcsicmp(pProperty,g_ProviderTypes[11].wcsColumnName) == 0 ) ){
        *pType = CIM_BOOLEAN;
        ((CVARIANT*)vVar)->SetBool(VARIANT_FALSE);
    }
    //=============================================================
    // LOCAL_TYPE_NAME
    //=============================================================
    else if( _wcsicmp(pProperty,g_ProviderTypes[12].wcsColumnName) == 0 ){
        *pType = CIM_STRING;
        ((CVARIANT*)vVar)->SetStr(L"");
    }
    //=============================================================
    // MINIMUM_SCALE, MAXIMUM_SCALE
    //=============================================================
    else if(( _wcsicmp(pProperty,g_ProviderTypes[13].wcsColumnName) == 0 ) || 
            ( _wcsicmp(pProperty,g_ProviderTypes[14].wcsColumnName) == 0 )){
        *pType = CIM_SINT16;
        ((CVARIANT*)vVar)->SetShort(0);
    }
    //=============================================================
    // GUID
    //=============================================================
    else if( _wcsicmp(pProperty,g_ProviderTypes[15].wcsColumnName) == 0 ){
        *pType = DBTYPE_GUID;
		((CVARIANT*)vVar)->Clear();
    }
    //=============================================================
    // TYPELIB
    //=============================================================
    else if( _wcsicmp(pProperty,g_ProviderTypes[16].wcsColumnName) == 0 ){
        *pType = CIM_STRING;
        ((CVARIANT*)vVar)->SetStr(L"");
    }
    //=============================================================
    // VERSION
    //=============================================================
    else if( _wcsicmp(pProperty,g_ProviderTypes[17].wcsColumnName) == 0 ){
        *pType = CIM_STRING;
        ((CVARIANT*)vVar)->SetStr(L"");
    }
        //=============================================================
        // IS_LONG for CIM_STRING which will be BSTR
        //=============================================================
		else if( ( _wcsicmp(pProperty,g_ProviderTypes[18].wcsColumnName) == 0 ) &&
			g_ProviderTypeDetails[i].DataType == DBTYPE_BSTR)
		{
            *pType = CIM_BOOLEAN;
            ((CVARIANT*)vVar)->SetBool(TRUE);
		}
        //=============================================================
        // IS_FIXEDLENGTH for CIM_STRING be FALSE
        //=============================================================
		else if( ( _wcsicmp(pProperty,g_ProviderTypes[20].wcsColumnName) == 0 ) &&
			g_ProviderTypeDetails[i].DataType == DBTYPE_BSTR)
		{
            *pType = CIM_BOOLEAN;
            ((CVARIANT*)vVar)->SetBool(FALSE);
		}
        //=============================================================
        // IS_FIXEDLENGTH for all types apart from CIM_STRING TRUE
        //=============================================================
		else if( ( _wcsicmp(pProperty,g_ProviderTypes[20].wcsColumnName) == 0 ) &&
			g_ProviderTypeDetails[i].DataType != DBTYPE_BSTR )
		{
            *pType = CIM_BOOLEAN;
            ((CVARIANT*)vVar)->SetBool(TRUE);
		}
        //=============================================================
        // IS_LONG, BEST_MATCH
        //=============================================================
        else if(( _wcsicmp(pProperty,g_ProviderTypes[18].wcsColumnName) == 0 ) ||
                ( _wcsicmp(pProperty,g_ProviderTypes[19].wcsColumnName) == 0 ) ) {
            *pType = CIM_BOOLEAN;
            ((CVARIANT*)vVar)->SetBool(FALSE);
        }
/*		//=============================================================
    // IS_LONG, BEST_MATCH, IS_FIXEDLENGTH
    //=============================================================
    else if(( _wcsicmp(pProperty,g_ProviderTypes[18].wcsColumnName) == 0 ) ||
            ( _wcsicmp(pProperty,g_ProviderTypes[19].wcsColumnName) == 0 ) ||
            ( _wcsicmp(pProperty,g_ProviderTypes[20].wcsColumnName) == 0 )) {
        *pType = CIM_BOOLEAN;
        ((CVARIANT*)vVar)->SetBool(VARIANT_FALSE);
    }
	*/
    //=============================================================
    // INVALID_ARG
    //=============================================================
    else{
        hr = E_INVALIDARG;
    }
    return MapWbemErrorToOLEDBError(hr);
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProviderTypesInstanceWrapper::GetKey(CBSTR & Key)
{
    HRESULT hr = S_OK;

    Key.SetStr(g_ProviderTypeDetails[GetPos()].wcsTypeName);
    return hr;    
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProviderTypesInstanceList::Reset()
{
    HRESULT hr = E_UNEXPECTED;
    LONG lFlags = WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY;

    //============================================================
    //  Send off the query for "Select Name from __Namespace
    //============================================================
    if( m_ppEnum ){
        hr = m_ppEnum->Reset();
        ReleaseAllInstances();
    }
    else
    {
        m_ulMaxRow = sizeof(g_ProviderTypeDetails)/sizeof(CIMTypeInfo);
        hr = S_OK;  // hardcoded rowset
    }
	m_lCurrentPos = 0;

    return MapWbemErrorToOLEDBError(hr);
}

////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProviderTypesInstanceList::NextInstance( CBSTR & Key, CWbemClassInstanceWrapper ** pInst  )
{
    HRESULT hr = E_FAIL;

    if( m_lCurrentPos < m_ulMaxRow )
    { 
		*pInst = new CWbemSchemaProviderTypesInstanceWrapper(m_pParms);
		// NTRaid:136533
		// 07/05/00
		if(*pInst)
		{
			(*pInst)->SetPos(++m_lCurrentPos);
			AddInstance(*pInst);
			(*pInst)->GetKey(Key);
			hr = S_OK;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
    }
    else
    {
        hr = WBEM_S_NO_MORE_DATA;
    }

    return hr;
}

//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
//
//  Classes for the Catalogs schema rowset
//
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
CWbemSchemaCatalogsClassDefinitionWrapper::CWbemSchemaCatalogsClassDefinitionWrapper(CWbemClassParameters * p) : CWbemSchemaClassDefinitionWrapper(p) 
{
    m_nMaxColumns = sizeof(g_CatalogRowsetColumns)/sizeof(SchemaRowsetDefinition);
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaCatalogsClassDefinitionWrapper::GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor )
{
    HRESULT hr = S_OK;

    //===============================================================================
    //  See if we got all of the column info
    //===============================================================================
    if( m_nSchemaClassIndex == m_nMaxColumns )
    {
        return WBEM_S_NO_MORE_DATA;
    }

    *pType = g_CatalogRowsetColumns[m_nSchemaClassIndex].Type;
    *pProperty = Wmioledb_SysAllocString(g_CatalogRowsetColumns[m_nSchemaClassIndex].wcsColumnName);
    m_nSchemaClassIndex++;

    return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaCatalogsInstanceWrapper::GetSchemaProperty( WCHAR * pProperty, VARIANT * v,CIMTYPE * pType , LONG * plFlavor)
{
    HRESULT hr = S_OK;

   ((CVARIANT*)v)->Clear();
   *plFlavor = 0;

   //=============================================================
   // CATALOG_NAME
   //=============================================================
   if( _wcsicmp(pProperty,g_CatalogRowsetColumns[0].wcsColumnName) == 0 ){
        hr = m_pClass->Get(CBSTR(L"Name"),0,(VARIANT *)v,pType,plFlavor);
   }
   //=============================================================
    // SOURCES_DESCRIPTION
   //=============================================================
   else if( _wcsicmp(pProperty,g_CatalogRowsetColumns[1].wcsColumnName) == 0 ){

       *plFlavor = 0;
       *pType = CIM_STRING;
       ((CVARIANT*)v)->SetStr(L"N/A");
   }            
   return MapWbemErrorToOLEDBError(hr);
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaCatalogsInstanceList::Reset()
{
    HRESULT hr = E_UNEXPECTED;
    LONG lFlags = WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY;

    //============================================================
    //  Send off the query for "Select Name from __Namespace
    //============================================================
    if( m_ppEnum )
    {
        hr = m_ppEnum->Reset();
        ReleaseAllInstances();
    }
    else
    {
        hr = (m_pParms->GetServicesPtr())->ExecQuery(CBSTR((WCHAR *)szWQL),CBSTR(L"select * from __Namespace"),  WBEM_FLAG_FORWARD_ONLY,m_pParms->m_pConnection->GetContext(),&m_ppEnum);
    }
	m_lCurrentPos = 0;

    return MapWbemErrorToOLEDBError(hr);
}
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
//
//  Classes for the COlumns schema rowset
//
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
CWbemSchemaColumnsClassDefinitionWrapper::CWbemSchemaColumnsClassDefinitionWrapper(CWbemClassParameters * p) : CWbemSchemaClassDefinitionWrapper(p) 
{
    
    m_nMaxColumns = sizeof(g_ColumnsRowsetColumns)/sizeof(SchemaRowsetDefinition);
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaColumnsClassDefinitionWrapper::GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor )
{
    HRESULT hr = S_OK;

    //===============================================================================
    //  See if we got all of the column info
    //===============================================================================
    if( m_nSchemaClassIndex == m_nMaxColumns )
    {
        return WBEM_S_NO_MORE_DATA;
    }

    *pType = g_ColumnsRowsetColumns[m_nSchemaClassIndex].Type;
    *pProperty = Wmioledb_SysAllocString(g_ColumnsRowsetColumns[m_nSchemaClassIndex].wcsColumnName);

    m_nSchemaClassIndex++;

    return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaColumnsInstanceWrapper::GetSchemaProperty( WCHAR * pProperty, VARIANT * v,CIMTYPE * pType , LONG * plFlavor)
{
   HRESULT hr = S_OK;

   ((CVARIANT*)v)->Clear();
   *plFlavor = 0;

   //=============================================================
   // TABLE_CATALOG
   //=============================================================
   if( wcscmp(pProperty,g_ColumnsRowsetColumns[0].wcsColumnName) == 0 ){
       *pType = CIM_STRING;
       ((CVARIANT*)v)->SetStr(m_pParms->m_pConnection->GetNamespace());
   }
   //=============================================================
    // TABLE_SCHEMA
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[1].wcsColumnName) == 0 ){
       *pType = CIM_STRING;
   }            
   //=============================================================
    // TABLE_NAME
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[2].wcsColumnName) == 0 ){

       ((CVARIANT*)v)->SetStr(m_pParms->m_pwcsParentClassName);
   }            
   //=============================================================
    // COLUMN_NAME
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[3].wcsColumnName) == 0 ){
       *pType = CIM_STRING;

		DBCOLUMNINFO * pCol = m_pColumns->GetColInfo(m_uCurrentIndex);
        ((CVARIANT*)v)->SetStr(pCol->pwszName);
   }            
   //=============================================================
    // COLUMN_GUID
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[4].wcsColumnName) == 0 ){
        *pType = DBTYPE_GUID;
   }
   //=============================================================
    // COLUMN_PROPID
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[5].wcsColumnName) == 0 ){
        *pType = CIM_UINT32;
   }
   //=============================================================
    // ORDINAL_POSITION
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[6].wcsColumnName) == 0 ){
        *pType = CIM_UINT32;
		DBCOLUMNINFO * pCol = m_pColumns->GetColInfo(m_uCurrentIndex);
        ((CVARIANT*)v)->SetLONG((LONG)pCol->iOrdinal);
   }
   //=============================================================
    // COLUMN_HASDEFAULT
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[7].wcsColumnName) == 0 ){
        *pType = CIM_BOOLEAN;
		((CVARIANT*)v)->SetBool(VARIANT_FALSE);
   }
   //=============================================================
    // COLUMN_DEFAULT
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[8].wcsColumnName) == 0 ){
        *pType = CIM_STRING;
   }
   //=============================================================
    // COLUMN_FLAGS
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[9].wcsColumnName) == 0 ){
        *pType = CIM_UINT32;

		DBCOLUMNINFO * pCol = m_pColumns->GetColInfo(m_uCurrentIndex);
		((CVARIANT*)v)->SetLONG(pCol->dwFlags);
   }
   //=============================================================
    // IS_NULLABLE
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[10].wcsColumnName) == 0 ){
        *pType = CIM_BOOLEAN;
        ((CVARIANT*)v)->SetBool(VARIANT_TRUE);
   }
   //=============================================================
    // DATA_TYPE
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[11].wcsColumnName) == 0 ){
        *pType = CIM_UINT16;

		DBCOLUMNINFO * pCol = m_pColumns->GetColInfo(m_uCurrentIndex);
		((CVARIANT*)v)->SetLONG(pCol->wType);
   }
   //=============================================================
    // TYPE_GUID
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[12].wcsColumnName) == 0 ){
        *pType = DBTYPE_GUID;
   }
   //=============================================================
    // CHARACTER_MAXIMUM_LENGTH
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[13].wcsColumnName) == 0 )
   {
        *pType = CIM_UINT32;  
   }
   //=============================================================
    // CHARACTER_OCTET_LENGTH
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[14].wcsColumnName) == 0 ){
        *pType = CIM_UINT32;
   }
   //=============================================================
    // NUMERIC_PRECISION
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[15].wcsColumnName) == 0 ){
        *pType = CIM_UINT16;
		DBCOLUMNINFO * pCol = m_pColumns->GetColInfo(m_uCurrentIndex);
        ((CVARIANT*)v)->SetShort(pCol->bPrecision);
   }
   //=============================================================
    // NUMERIC_SCALE
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[16].wcsColumnName) == 0 ){
        *pType = CIM_SINT16;

		DBCOLUMNINFO * pCol = m_pColumns->GetColInfo(m_uCurrentIndex);
        ((CVARIANT*)v)->SetShort(pCol->bScale);
   }
   //=============================================================
   // DATETIME_PRECISION
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[17].wcsColumnName) == 0 ){
        *pType = CIM_UINT32;
   }
   //=============================================================
   // CHARACTER_SET_CATALOG
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[18].wcsColumnName) == 0 ){
        *pType = CIM_STRING;
   }
   //=============================================================
   // CHARACTER_SET_SCHEMA
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[19].wcsColumnName) == 0 ){
        *pType = CIM_STRING;
   }
   //=============================================================
   // CHARACTER_SET_NAME
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[20].wcsColumnName) == 0 ){
        *pType = CIM_STRING;
   }
   //=============================================================
   // COLLATION_CATALOG
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[21].wcsColumnName) == 0 ){
        *pType = CIM_STRING;
   }
   //=============================================================
   // COLLATION_SCHEMA
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[22].wcsColumnName) == 0 ){
        *pType = CIM_STRING;
   }
   //=============================================================
   // COLLATION_NAME
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[23].wcsColumnName) == 0 ){
        *pType = CIM_STRING;
   }
   //=============================================================
   // DOMAIN_CATALOG
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[24].wcsColumnName) == 0 ){
        *pType = CIM_STRING;
   }
   //=============================================================
   // DOMAIN_SCHEMA
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[25].wcsColumnName) == 0 ){
        *pType = CIM_STRING;
   }
   //=============================================================
   // DOMAIN_NAME
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[26].wcsColumnName) == 0 ){
        *pType = CIM_STRING;
   }
   //=============================================================
   // DESCRIPTION
   //=============================================================
   else if( _wcsicmp(pProperty,g_ColumnsRowsetColumns[27].wcsColumnName) == 0 ){
        *pType = CIM_STRING;
   }
   

    return MapWbemErrorToOLEDBError(hr);
}
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaColumnsInstanceWrapper::GetKey(CBSTR & Key)
{
    HRESULT hr = S_OK;


    if( m_pColumns )
    {
        //============================================================
        // the key is the combo of the table name and column name
        //============================================================
    	DBCOLUMNINFO * pCol = m_pColumns->GetColInfo(m_uCurrentIndex);
        if( pCol )
        {

            WCHAR * p = new WCHAR [wcslen(pCol->pwszName) + wcslen(m_pParms->m_pwcsParentClassName) + 4 ];
            if( p )
            {
                swprintf(p, L"%s:%s", m_pParms->m_pwcsParentClassName,pCol->pwszName);
                Key.SetStr(p);
                delete p;  
            }
        }
    }
    return hr;    
}

///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaColumnsInstanceList::Reset()
{
    HRESULT hr = E_UNEXPECTED;
    //============================================================
    //  If we are working with just one class, then get the one
    //  class, otherwise enumerate all
    //============================================================
    if( m_pwcsSpecificClass)
    {
        hr = ResetTheSpecificClass();
    }
    else
    {

        LONG lFlags = WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY;

        //============================================================
        //  Send off the query for "Select Name from __Namespace
        //============================================================
        if( m_ppEnum )
        {
            hr = m_ppEnum->Reset();
            ReleaseAllInstances();
        }
        else
        {
            hr = (m_pParms->GetServicesPtr())->CreateClassEnum(NULL,  WBEM_FLAG_FORWARD_ONLY,m_pParms->m_pConnection->GetContext(),&m_ppEnum);
        }
    }
	m_lCurrentPos = 0;

    return MapWbemErrorToOLEDBError(hr);
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaColumnsInstanceList::GetColumnInformation(CWbemClassInstanceWrapper * p )
{
    HRESULT hr = E_FAIL;
    DBCOUNTITEM cTotalCols, cCols, cNestedCols;

    FreeColumns();

    CWmiOleDBMap Map;
    if(SUCCEEDED(hr = Map.FInit(m_pParms->m_dwFlags,p->GetClassName(),m_pParms->m_pConnection)))
	{
		hr = Map.GetColumnCount(cTotalCols,cCols,cNestedCols);
		if( S_OK == hr ){
			if( S_OK == (hr = m_Columns.AllocColumnNameList(cTotalCols))){

				//===============================================================================
				//  Allocate the DBCOLUMNINFO structs to match the number of columns
				//===============================================================================
				if( S_OK == (hr = m_Columns.AllocColumnInfoList(cTotalCols))){

					hr = Map.GetColumnInfoForParentColumns(&m_Columns);
					if( hr == S_OK ){
						//==============================================================
						// Increment past the bookmark column
						//==============================================================
						m_lColumnIndex = 1;
						((CWbemSchemaColumnsInstanceWrapper*)p)->SetColumnsPtr(&m_Columns);
						((CWbemSchemaColumnsInstanceWrapper*)p)->SetIndex(m_lColumnIndex);
					}
				}
			}
		}
	}

    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaColumnsInstanceList::NextInstance( CBSTR & Key, CWbemClassInstanceWrapper ** pInst  )
{
    HRESULT hr = E_FAIL;
    long ulTotal;

    ulTotal = (LONG)m_Columns.GetTotalNumberOfColumns();
    m_lColumnIndex++;

    if( m_lColumnIndex  >= ulTotal )
    {
        //================================================================
        //  If we are working with a specific class, then use it, other
        //  wise, enumerate the next one
        //================================================================
        if( !m_pwcsSpecificClass)
        {
            hr = CWbemInstanceList::NextInstance(Key,pInst);
            if( S_OK == hr )
            {
                CVARIANT v;
                CIMTYPE Type;
                LONG lFlavor;
                if( S_OK == (hr = ((CWbemSchemaColumnsInstanceWrapper*)*pInst)->GetClassProperty(L"__CLASS",&v,&Type,&lFlavor)))
                {
                    //  Now, save it in Parameters for the generated ones
                    m_pParms->SetParentClassName(v.GetStr());

                    hr = GetColumnInformation(*pInst);
                    if( S_OK == hr )
                    {
                        //==========================================
                        // We don't want to display the bookmark
                        // column.
                        //==========================================
                        ulTotal = (LONG)m_Columns.GetTotalNumberOfColumns();

                        if( m_lColumnIndex == ulTotal )
                        {
                            hr = NextInstance(Key,pInst);
                        }
                   }
                   hr = ((CWbemSchemaColumnsInstanceWrapper*)*pInst)->GetKey(Key);
                }
            }        
        }
        else
        {
            hr = GetTheSpecificClass();
            if( S_OK == hr )
            {
                *pInst = (CWbemSchemaClassInstanceWrapper *) new CWbemSchemaColumnsInstanceWrapper(m_pParms);
                if( *pInst )
                {
                    ((CWbemSchemaColumnsInstanceWrapper*)*pInst)->SetClass(m_pSpecificClass);

                    CVARIANT v;
                    CIMTYPE Type;
                    LONG lFlavor;
 
                    if( S_OK == (hr = ((CWbemSchemaColumnsInstanceWrapper*)*pInst)->GetClassProperty(L"__CLASS",&v,&Type,&lFlavor)))
                    {

                        m_pParms->SetParentClassName(v.GetStr());
                        if( SUCCEEDED(hr))
                        {
                            hr = GetColumnInformation(*pInst);
                            ulTotal = (LONG)m_Columns.GetTotalNumberOfColumns();
                            //===================================================================
                            //  This class does't have any columns
                            //===================================================================
                            if( m_lColumnIndex == ulTotal )
                            {
                                hr = WBEM_S_NO_MORE_DATA;
                            }

                            if( S_OK == hr)
                            {
                                hr = ((CWbemSchemaColumnsInstanceWrapper*)*pInst)->GetKey(Key);
            			        (*pInst)->SetPos(++m_lCurrentPos);
                                ((CWbemSchemaColumnsInstanceWrapper*)*pInst)->SetColumnsPtr(&m_Columns);
                                ((CWbemSchemaColumnsInstanceWrapper*)*pInst)->SetIndex(m_lColumnIndex);
			                    AddInstance(*pInst);
                            }
                        }
                    }
                }
            }

        }
    }
    else
    {
        *pInst = (CWbemSchemaClassInstanceWrapper *) new CWbemSchemaColumnsInstanceWrapper(m_pParms);
        if( *pInst )
        {
			(*pInst)->SetPos(++m_lCurrentPos);
            ((CWbemSchemaColumnsInstanceWrapper*)*pInst)->SetColumnsPtr(&m_Columns);
            ((CWbemSchemaColumnsInstanceWrapper*)*pInst)->SetIndex(m_lColumnIndex);
			(*pInst)->GetKey(Key);
			AddInstance(*pInst);
            hr = S_OK;
        }
    }
    return hr;
}
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
//
//  Classes for the Tables schema rowset
//
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
CWbemSchemaTablesClassDefinitionWrapper::CWbemSchemaTablesClassDefinitionWrapper(CWbemClassParameters * p) : CWbemSchemaClassDefinitionWrapper(p) 
{
    
    m_nMaxColumns = sizeof(g_Tables)/sizeof(SchemaRowsetDefinition);
}

//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaTablesClassDefinitionWrapper::GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor )
{
    HRESULT hr = S_OK;

    //===============================================================================
    //  See if we got all of the column info
    //===============================================================================
    if( m_nSchemaClassIndex == m_nMaxColumns )
    {
        return WBEM_S_NO_MORE_DATA;
    }

    *pType = g_Tables[m_nSchemaClassIndex].Type;
    *pProperty = Wmioledb_SysAllocString(g_Tables[m_nSchemaClassIndex].wcsColumnName);
    m_nSchemaClassIndex++;

    return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaTablesInstanceWrapper::GetSchemaProperty( WCHAR * pProperty, VARIANT * v,CIMTYPE * pType , LONG * plFlavor)
{
   HRESULT hr = S_OK;

   ((CVARIANT*)v)->Clear();
   *plFlavor = 0;
  
   //=============================================================
   // TABLE_CATALOG
   //=============================================================
   if( _wcsicmp(pProperty,g_Tables[0].wcsColumnName) == 0 ){
       *pType = CIM_STRING;
       ((CVARIANT*)v)->SetStr(m_pParms->m_pConnection->GetNamespace());
   }
   //=============================================================
   // TABLE_SCHEMA
   //=============================================================
   else if( _wcsicmp(pProperty,g_Tables[1].wcsColumnName) == 0 ){
       *pType = CIM_STRING;
   }            
   //=============================================================
   // TABLE_NAME
   //=============================================================
   else if( _wcsicmp(pProperty,g_Tables[2].wcsColumnName) == 0 ){
       *pType = CIM_STRING;
       hr = GetClassProperty(L"__CLASS",v,pType,plFlavor);
   }            
   //=============================================================
   // TABLE_TYPE
   //   This is either "TABLE" or "SYSTEM TABLE"
   //=============================================================
   else if( _wcsicmp(pProperty,g_Tables[3].wcsColumnName) == 0 ){
       *pType = CIM_STRING;
       CVARIANT Var;
       hr = GetClassProperty(L"__CLASS",&Var,pType,plFlavor);
       if( S_OK == hr ){
            WCHAR * p = NULL;
			p = Var.GetStr();
			// NTRaid:136462 & 136466
			// 07/05/00
			if(p != NULL || VT_BSTR != Var.GetType())
			{
				if( wcsncmp( p, L"__",2) == 0 ){
					((CVARIANT*)v)->SetStr(L"SYSTEM TABLE");
				}
				else{
					((CVARIANT*)v)->SetStr(L"TABLE");
				}
			}
			else
			{
				hr = E_UNEXPECTED; 
			}
       }
   }            
   //=============================================================
   // TABLE_GUID
   //=============================================================
   else if( _wcsicmp(pProperty,g_Tables[4].wcsColumnName) == 0 ){
       *pType = DBTYPE_GUID;
   }            
   //=============================================================
   // TABLE_DESCRIPTION
   //=============================================================
   else if( _wcsicmp(pProperty,g_Tables[5].wcsColumnName) == 0 ){
       *pType = CIM_STRING;
       hr = GetClassQualifier(L"Description",v,pType,plFlavor);
   }            
   //=============================================================
   // TABLE_PROPID
   //=============================================================
   else if( _wcsicmp(pProperty,g_Tables[6].wcsColumnName) == 0 ){
       *pType = CIM_UINT32;
   }
   //=============================================================
   // DATE_CREATED, DATE_MODIFIED
   //=============================================================
   else if( _wcsicmp(pProperty,g_Tables[7].wcsColumnName) == 0 ){
       *pType = DBTYPE_DATE;
   }

    return MapWbemErrorToOLEDBError(hr);
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaTablesInstanceList::NextInstance( CBSTR & Key, CWbemClassInstanceWrapper ** pInst  )
{
    HRESULT hr = S_OK;

    if( !m_pwcsSpecificClass )
    {
        return CWbemInstanceList::NextInstance(Key,pInst);
    }
        
    hr = GetTheSpecificClass();
    if( S_OK == hr )
    {
        *pInst = (CWbemSchemaTablesInstanceWrapper *) new CWbemSchemaTablesInstanceWrapper(m_pParms);
		// NTRaid:136526 , 136530
		// 07/05/00
		if(*pInst)
		{
			(*pInst)->SetClass(m_pSpecificClass);
			(*pInst)->SetPos(++m_lCurrentPos);
			AddInstance(*pInst);
			(*pInst)->GetKey(Key);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaTablesInstanceList::Reset()
{
    HRESULT hr = E_UNEXPECTED;

    if( m_pwcsSpecificClass)
    {
        hr = ResetTheSpecificClass();
    }
    else
    {
        LONG lFlags = WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY;

        //============================================================
        //  Send off the query for "Select Name from __Namespace
        //============================================================
        if( m_ppEnum )
        {
            hr = m_ppEnum->Reset();
            ReleaseAllInstances();
        }
        else
        {
            hr = (m_pParms->GetServicesPtr())->CreateClassEnum(NULL,  WBEM_FLAG_FORWARD_ONLY,m_pParms->m_pConnection->GetContext(),&m_ppEnum);
        }
    }
	m_lCurrentPos = 0;

    return MapWbemErrorToOLEDBError(hr);
}

//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
//
//  Classes for the Primary Keys schema rowset
//
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
CWbemSchemaPrimaryKeysClassDefinitionWrapper::CWbemSchemaPrimaryKeysClassDefinitionWrapper(CWbemClassParameters * p) : CWbemSchemaClassDefinitionWrapper(p)
{
   
    m_nMaxColumns = sizeof(g_PrimaryKeysColumns)/sizeof(SchemaRowsetDefinition);
}
//////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CWbemSchemaPrimaryKeysClassDefinitionWrapper::GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor )
{
    HRESULT hr = S_OK;

    //===============================================================================
    //  See if we got all of the column info
    //===============================================================================
    if( m_nSchemaClassIndex == m_nMaxColumns )
    {
        return WBEM_S_NO_MORE_DATA;
    }

    *pType = g_PrimaryKeysColumns[m_nSchemaClassIndex].Type;
    *pProperty = Wmioledb_SysAllocString(g_PrimaryKeysColumns[m_nSchemaClassIndex].wcsColumnName);
    m_nSchemaClassIndex++;

    return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaPrimaryKeysInstanceWrapper::GetSchemaProperty( WCHAR * pProperty, VARIANT * v,CIMTYPE * pType , LONG * plFlavor)
{
   HRESULT hr = S_OK;

   ((CVARIANT*)v)->Clear();
   *plFlavor = 0;
 
   //=============================================================
   // TABLE_CATALOG
   //=============================================================
   if( _wcsicmp(pProperty,g_PrimaryKeysColumns[0].wcsColumnName) == 0 )
   {
       *pType = CIM_STRING;
       ((CVARIANT*)v)->SetStr(m_pParms->m_pConnection->GetNamespace());
   }
   //=============================================================
   // TABLE_SCHEMA
   //=============================================================
   else if( _wcsicmp(pProperty,g_PrimaryKeysColumns[1].wcsColumnName) == 0 )
   {
       *pType = CIM_STRING;
   }            
   //=============================================================
   // TABLE_NAME
   //=============================================================
   else if( _wcsicmp(pProperty,g_PrimaryKeysColumns[2].wcsColumnName) == 0 ){
       *pType = CIM_STRING;
       hr = GetClassProperty(L"__CLASS",v,pType,plFlavor);
   }            
   //=============================================================
   // COLUMN_NAME
   //=============================================================
   else if( _wcsicmp(pProperty,g_PrimaryKeysColumns[3].wcsColumnName) == 0 ){
        
        *pType = CIM_STRING;

    	LONG lFlavor = 0, lType = 0;
        CBSTR bstrPropQual(L"key");
        WCHAR * pList = NULL;

        if( S_OK == (hr = BeginPropertyEnumeration())){

            CBSTR bstrProperty;
            CVARIANT vValue;
  
            while( S_OK == (hr = GetNextProperty((BSTR*)&bstrProperty,(VARIANT *)&vValue, &lType, &lFlavor))){
                CVARIANT vKey;

                hr = CWbemClassWrapper::GetPropertyQualifier(bstrProperty,bstrPropQual,(VARIANT *)&vKey,&lType,&lFlavor);
                if( S_OK == hr ){
                    //===========================================================
                    //  Ok, we found a key, so start adding it.  There could be
                    //  multiple keys, so we still 
                    //===========================================================
                    AddToKeyList(pList,(WCHAR *)bstrProperty);
                }
            }
        }

        if ( WBEM_S_NO_MORE_DATA == hr ){
            hr = S_OK;
        }
        ((CVARIANT*)v)->SetStr(pList);
        SAFE_DELETE_PTR(pList);

	    EndPropertyEnumeration();
    }            
   //=============================================================
   // COLUMN_GUID
   //=============================================================
   else if( _wcsicmp(pProperty,g_PrimaryKeysColumns[4].wcsColumnName) == 0 ){
       *pType = DBTYPE_GUID;
   }            
   //=============================================================
   // COLUMN_PROPID
   //=============================================================
   else if( _wcsicmp(pProperty,g_PrimaryKeysColumns[5].wcsColumnName) == 0 ){
       *pType = CIM_UINT32;
   }            
   //=============================================================
   // ORDINAL
   //=============================================================
   else if( _wcsicmp(pProperty,g_PrimaryKeysColumns[6].wcsColumnName) == 0 ){
       *pType = CIM_UINT32;
   }
   //=============================================================
   // PK_NAME
   //=============================================================
   else if( _wcsicmp(pProperty,g_PrimaryKeysColumns[7].wcsColumnName) == 0 ){
       *pType = CIM_STRING;
   }

    return MapWbemErrorToOLEDBError(hr);
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaPrimaryKeysInstanceList::NextInstance( CBSTR & Key, CWbemClassInstanceWrapper ** pInst  )
{
    HRESULT hr = S_OK;

    if( !m_pwcsSpecificClass )
    {
        return CWbemInstanceList::NextInstance(Key,pInst);
    }
        
    hr = GetTheSpecificClass();
    if( S_OK == hr )
    {
        *pInst = (CWbemSchemaPrimaryKeysInstanceWrapper *) new CWbemSchemaPrimaryKeysInstanceWrapper(m_pParms);
		// NTRaid:136519 , 136522
		// 07/05/00
		if(*pInst)
		{
			(*pInst)->SetClass(m_pSpecificClass);
			(*pInst)->SetPos(++m_lCurrentPos);
			AddInstance(*pInst);
			(*pInst)->GetKey(Key);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaPrimaryKeysInstanceList::Reset()
{
    HRESULT hr = E_UNEXPECTED;

    if( m_pwcsSpecificClass)
    {
        hr = ResetTheSpecificClass();
    }
    else
    {
        LONG lFlags = WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY;

        //============================================================
        //  Send off the query for "Select Name from __Namespace
        //============================================================
        if( m_ppEnum )
        {
            hr = m_ppEnum->Reset();
            ReleaseAllInstances();
        }
        else
        {
            hr = (m_pParms->GetServicesPtr())->CreateClassEnum(NULL,  WBEM_FLAG_FORWARD_ONLY,m_pParms->m_pConnection->GetContext(),&m_ppEnum);
        }
    }
	m_lCurrentPos = 0;

    return MapWbemErrorToOLEDBError(hr);
}

//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
//
//  Classes for the Tables Info schema rowset
//
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
CWbemSchemaTablesInfoClassDefinitionWrapper::CWbemSchemaTablesInfoClassDefinitionWrapper(CWbemClassParameters * p) : CWbemSchemaClassDefinitionWrapper(p) 
{
    
    m_nMaxColumns = sizeof(g_TablesInfo)/sizeof(SchemaRowsetDefinition);
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaTablesInfoClassDefinitionWrapper::GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor )
{
    HRESULT hr = S_OK;

    //===============================================================================
    //  See if we got all of the column info
    //===============================================================================
    if( m_nSchemaClassIndex == m_nMaxColumns )
    {
        return WBEM_S_NO_MORE_DATA;
    }

    *pType = g_TablesInfo[m_nSchemaClassIndex].Type;
    *pProperty = Wmioledb_SysAllocString(g_TablesInfo[m_nSchemaClassIndex].wcsColumnName);
    m_nSchemaClassIndex++;

    return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaTablesInfoInstanceWrapper::GetSchemaProperty( WCHAR * pProperty, VARIANT * v,CIMTYPE * pType , LONG * plFlavor)
{
   HRESULT hr = S_OK;

   ((CVARIANT*)v)->Clear();
   *plFlavor = 0;

  
   //=============================================================
   // TABLE_CATALOG
   //=============================================================
   if( _wcsicmp(pProperty,g_TablesInfo[0].wcsColumnName) == 0 ){
       *pType = CIM_STRING;
       ((CVARIANT*)v)->SetStr(m_pParms->m_pConnection->GetNamespace());
   }
   //=============================================================
   // TABLE_SCHEMA
   //=============================================================
   else if( _wcsicmp(pProperty,g_TablesInfo[1].wcsColumnName) == 0 ){
       *pType = CIM_STRING;
   }            
   //=============================================================
   // TABLE_NAME
   //=============================================================
   else if( _wcsicmp(pProperty,g_TablesInfo[2].wcsColumnName) == 0 ){
       *pType = CIM_STRING;
       hr = GetClassProperty(L"__CLASS",v,pType,plFlavor);
   }            
   //=============================================================
   // TABLE_TYPE
   //   This is either "TABLE" or "SYSTEM TABLE"
   //=============================================================
   else if( _wcsicmp(pProperty,g_TablesInfo[3].wcsColumnName) == 0 ){
       *pType = CIM_STRING;
       CVARIANT Var;
       hr = GetClassProperty(L"__CLASS",&Var,pType,plFlavor);
	   // NT Raid 136462
	   // 07/12/00
       if( S_OK == hr ){
          WCHAR * p = Var.GetStr();
          if (p != NULL){
             if( wcsncmp( p, L"__",2) == 0 ){
                 ((CVARIANT*)v)->SetStr(L"SYSTEM TABLE");
			 }
             else{
                 ((CVARIANT*)v)->SetStr(L"TABLE");
			 }
          }
		  else{
			  hr = E_UNEXPECTED;
		  }
       }
   }            
   //=============================================================
   // TABLE_GUID
   //=============================================================
   else if( _wcsicmp(pProperty,g_TablesInfo[4].wcsColumnName) == 0 ){
       *pType = DBTYPE_GUID;
   }            
   //=============================================================
   // BOOKMARKS
   //=============================================================
   else if( _wcsicmp(pProperty,g_TablesInfo[5].wcsColumnName) == 0 ){
       *pType = CIM_BOOLEAN;
       ((CVARIANT*)v)->SetBool(TRUE);
   }            
   //=============================================================
   // BOOKMARK_TYPE
   //=============================================================
   else if( _wcsicmp(pProperty,g_TablesInfo[6].wcsColumnName) == 0 ){
       *pType = CIM_SINT32;
       ((CVARIANT*)v)->SetLONG(DBPROPVAL_BMK_NUMERIC);
   }            
   //=============================================================
   // BOOKMARK_DATATYPE
   //=============================================================
   else if( _wcsicmp(pProperty,g_TablesInfo[7].wcsColumnName) == 0 ){
       *pType = CIM_UINT16;
       ((CVARIANT*)v)->SetShort(DBTYPE_UI4);

   }            
   //=============================================================
   // BOOKMARK_MAXIMUM_LENGTH
   //=============================================================
   else if( _wcsicmp(pProperty,g_TablesInfo[8].wcsColumnName) == 0 )
   {
       *pType = CIM_UINT32;
       ((CVARIANT*)v)->SetLONG(sizeof(ULONG));
   }            
   //=============================================================
   // BOOKMARK_INFORMATION
   //=============================================================
   else if( _wcsicmp(pProperty,g_TablesInfo[9].wcsColumnName) == 0 ){
       *pType = CIM_UINT32;
   }            
   //=============================================================
   // BOOKMARK_TABLE_VERSION
   //=============================================================
   else if( _wcsicmp(pProperty,g_TablesInfo[10].wcsColumnName) == 0 ){
       *pType = CIM_STRING;
   }            
   //=============================================================
   // CARDINALITY
   //=============================================================
   else if( _wcsicmp(pProperty,g_TablesInfo[11].wcsColumnName) == 0 ){
       *pType = CIM_STRING;
   }            
   //=============================================================
   // DESCRIPTION
   //=============================================================
   else if( _wcsicmp(pProperty,g_TablesInfo[12].wcsColumnName) == 0 ){
       *pType = CIM_STRING;
       hr = GetClassQualifier(L"Description",v,pType,plFlavor);
   }            
   //=============================================================
   // TABLE_PROPID
   //=============================================================
   else if( _wcsicmp(pProperty,g_TablesInfo[13].wcsColumnName) == 0 ){
       *pType = CIM_UINT32;
   }
    return MapWbemErrorToOLEDBError(hr);
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaTablesInfoInstanceList::NextInstance( CBSTR & Key, CWbemClassInstanceWrapper ** pInst  )
{
    HRESULT hr = S_OK;

    if( !m_pwcsSpecificClass )
    {
        return CWbemInstanceList::NextInstance(Key,pInst);
    }
        
    hr = GetTheSpecificClass();
    if( S_OK == hr )
    {
        *pInst = (CWbemSchemaTablesInfoInstanceWrapper *) new CWbemSchemaTablesInfoInstanceWrapper(m_pParms);
		// NTRaid:136512 , 136514
		// 07/05/00
		if(*pInst)
		{
			(*pInst)->SetClass(m_pSpecificClass);
			(*pInst)->SetPos(++m_lCurrentPos);
			AddInstance(*pInst);
			(*pInst)->GetKey(Key);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaTablesInfoInstanceList::Reset()
{
    HRESULT hr = E_UNEXPECTED;
    if( m_pwcsSpecificClass)
    {
        hr = ResetTheSpecificClass();
    }
    else
    {
        LONG lFlags = WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY;

        //============================================================
        //  Send off the query for "Select Name from __Namespace
        //============================================================
        if( m_ppEnum )
        {
            hr = m_ppEnum->Reset();
            ReleaseAllInstances();
        }
        else
        {
            hr = (m_pParms->GetServicesPtr())->CreateClassEnum(NULL,  WBEM_FLAG_FORWARD_ONLY,m_pParms->m_pConnection->GetContext(),&m_ppEnum);
        }
    }
	m_lCurrentPos = 0;

    return MapWbemErrorToOLEDBError(hr);
}

//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
//
//  Classes for the Procedures schema rowset
//
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
CWbemSchemaProceduresClassDefinitionWrapper::CWbemSchemaProceduresClassDefinitionWrapper(CWbemClassParameters * p) : CWbemSchemaClassDefinitionWrapper(p) 
{
   
   m_nMaxColumns = sizeof(g_Procedures)/sizeof(SchemaRowsetDefinition);
}

//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProceduresClassDefinitionWrapper::GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor )
{
    HRESULT hr = S_OK;

    //===============================================================================
    //  See if we got all of the column info
    //===============================================================================
    if( m_nSchemaClassIndex == m_nMaxColumns )
    {
        return WBEM_S_NO_MORE_DATA;
    }

    *pType = g_Procedures[m_nSchemaClassIndex].Type;
    *pProperty = Wmioledb_SysAllocString(g_Procedures[m_nSchemaClassIndex].wcsColumnName);
    m_nSchemaClassIndex++;

    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProceduresInstanceWrapper::GetKey(CBSTR & Key)
{
    HRESULT hr = S_OK;

    //===========================================================
    //  The key is going to the be the class name.method name
    //===========================================================
    CVARIANT v;
    CIMTYPE Type;
    LONG lFlavor;

    hr = GetClassProperty(L"__CLASS",&v,&Type,&lFlavor);
    if( SUCCEEDED(hr))
    {
        WCHAR * p = new WCHAR [wcslen(v.GetStr()) + wcslen(m_bstrCurrentMethodName) + 4 ];
        if( p )
        {
            swprintf(p, L"%s:%s", v.GetStr(),m_bstrCurrentMethodName);
            Key.SetStr(p);
            delete p;  
        }
    }
    
    return hr;    
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProceduresInstanceWrapper::GetSchemaProperty( WCHAR * pProperty, VARIANT * v,CIMTYPE * pType , LONG * plFlavor)
{
    HRESULT hr = S_OK;

   ((CVARIANT*)v)->Clear();
   *plFlavor = 0;
   //=============================================================
   // PROCEDURE_CATALOG
   //=============================================================
   if( _wcsicmp(pProperty,g_Procedures[0].wcsColumnName) == 0 )
   {
       *pType = CIM_STRING;
       ((CVARIANT*)v)->SetStr(m_pParms->m_pConnection->GetNamespace());
   }
   //=============================================================
   // PROCEDURE_SCHEMA
   //=============================================================
   else if( _wcsicmp(pProperty,g_Procedures[1].wcsColumnName) == 0 )
   {
       *pType = CIM_STRING;
       hr = GetClassProperty(L"__CLASS",v,pType,plFlavor);
   }            
   //=============================================================
   // PROCEDURE_NAME
   //=============================================================
   else if( _wcsicmp(pProperty,g_Procedures[2].wcsColumnName) == 0 )
   {
       *pType = CIM_STRING;
       ((CVARIANT*)v)->SetStr(m_bstrCurrentMethodName);

   }            
   //=============================================================
   // PROCEDURE_TYPE
   //=============================================================
   else if( _wcsicmp(pProperty,g_Procedures[3].wcsColumnName) == 0 )
   {
       *pType = CIM_SINT16;
       //=========================================================
       //
       //  If there is an output class, then the type is
       //       DB_PT_FUNCTION
       //  If there is not an output class, then the type is
       //       DB_PT_PROCEDURE
       //=========================================================
       if( m_pOutClass )
       {
           ((CVARIANT*)v)->SetShort(DB_PT_FUNCTION);
       }
       else
       {
           ((CVARIANT*)v)->SetShort(DB_PT_PROCEDURE);
       }
   }            
   //=============================================================
   // PROCEDURE_DEFINITION
   //=============================================================
   else if( _wcsicmp(pProperty,g_Procedures[4].wcsColumnName) == 0 )
   {
       *pType = CIM_STRING;
   }            
   //=============================================================
   // PROCEDURE_DESCRIPTION
   //=============================================================
   else if( _wcsicmp(pProperty,g_Procedures[5].wcsColumnName) == 0 )
   {
       *pType = CIM_STRING;
   }            
   //=============================================================
   // DATE_CREATED
   //=============================================================
   else if( _wcsicmp(pProperty,g_Procedures[6].wcsColumnName) == 0 )
   {
       *pType = DBTYPE_DATE;

   }            
   //=============================================================
   // DATE_MODIFIED
   //=============================================================
   else if( _wcsicmp(pProperty,g_Procedures[7].wcsColumnName) == 0 )
   {
       *pType = DBTYPE_DATE;
   }            

    return MapWbemErrorToOLEDBError(hr);
}
///////////////////////////////////////////////////////////////////////////////////////////////////
void CWbemSchemaProceduresInstanceList::ResetMethodPtrs()
{
    m_bstrCurrentMethodName.Clear();
    SAFE_RELEASE_PTR(m_pCurrentMethodInClass);
    SAFE_RELEASE_PTR(m_pCurrentMethodOutClass);
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProceduresInstanceList::Reset()
{
    HRESULT hr = E_UNEXPECTED;
    if( m_pwcsSpecificClass)
    {
        hr = ResetTheSpecificClass();
    }
    else
    {
        LONG lFlags = WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY;

        //============================================================
        //  Send off the query for "Select Name from __Namespace
        //============================================================
        if( m_ppEnum )
        {
            hr = m_ppEnum->Reset();
            ReleaseAllInstances();
        }
        else
        {
            hr = (m_pParms->GetServicesPtr())->CreateClassEnum(NULL,  WBEM_FLAG_FORWARD_ONLY,m_pParms->m_pConnection->GetContext(),&m_ppEnum);
        }
    }
	m_lCurrentPos = 0;
    m_fContinueWithSameClass = FALSE;
    SAFE_RELEASE_PTR(m_pCurrentMethodClass);

    return MapWbemErrorToOLEDBError(hr);
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProceduresInstanceList::GetTheNextClassThatHasMethods()
{
    HRESULT hr = S_OK;

    //==================================================================
    //  Does the existing class have methods in it?
    //==================================================================
    while( S_OK == hr )
    {
        //==============================================================
        //  It does, then set all the current info and return so we
        //  can process the columns
        //==============================================================
		unsigned long u = 0L;

        if( !m_fContinueWithSameClass )
        {
            if( !m_pwcsSpecificClass )
            {
                SAFE_RELEASE_PTR(m_pCurrentMethodClass);
                hr = m_ppEnum->Next(0,1,&m_pCurrentMethodClass,&u);
                if( SUCCEEDED(hr))
                {
                    hr = m_pCurrentMethodClass->BeginMethodEnumeration(0);
                }
            }
        }

        if( SUCCEEDED(hr))
        {   
            ResetMethodPtrs();

            hr = m_pCurrentMethodClass->NextMethod(0,(BSTR*)&m_bstrCurrentMethodName,&m_pCurrentMethodInClass,&m_pCurrentMethodOutClass);
            if( hr == S_OK )
            {
                m_fContinueWithSameClass = TRUE;
                break;
            }
            else
            {   
                if( hr == WBEM_S_NO_MORE_DATA )
                {
                    if( !m_pwcsSpecificClass )
                    {
                        hr = S_OK;  // continue on to the next one
                    }
                    // otherwise,we know there isn't another one.
                }
                m_pCurrentMethodClass->EndEnumeration();
                m_fContinueWithSameClass = FALSE;
            }
            //==============================================================
            //  It doesn't, so, keep looping through the classes until we
            //  find another class that has methods, or we are done with all
            //  the classes
            //==============================================================
        }
        else
        {
            break;
        }
    }

    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProceduresInstanceList::GetSpecificNextInstance()
{
    HRESULT hr = GetTheSpecificClass();
    if( S_OK == hr )
    {
        m_pCurrentMethodClass = m_pSpecificClass;
        m_pSpecificClass = NULL; // will be released with the m_pCurrentMethodClass
        ResetMethodPtrs();
        m_fContinueWithSameClass = TRUE;
        hr = m_pCurrentMethodClass->BeginMethodEnumeration(0);
    }
    //==================================================================
    //  We know there are no more classes, but there might be more
    //  methods, so go on to process the rest of the methods
    //==================================================================
    if( hr == WBEM_S_NO_MORE_DATA )
    {
        hr = S_OK;
    }
    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProceduresInstanceList::NextInstance( CBSTR & Key, CWbemClassInstanceWrapper ** pInst  )
{
    HRESULT hr = S_OK;

    if( m_pwcsSpecificClass )
    {
        hr = GetSpecificNextInstance();
    }
    if( S_OK == hr )
    {
        hr = GetTheNextClassThatHasMethods();
        if( S_OK == hr)
        {
            *pInst = new CWbemSchemaProceduresInstanceWrapper(m_pParms);
			// NTRaid:136455
			// 07/05/00
			if(*pInst)
			{
 				(*pInst)->SetPos(++m_lCurrentPos);
   				((CWbemSchemaProceduresInstanceWrapper*)(*pInst))->SetMethodName((LPWSTR)m_bstrCurrentMethodName);
   				((CWbemSchemaProceduresInstanceWrapper*)(*pInst))->SetInputClass(m_pCurrentMethodInClass);
   				((CWbemSchemaProceduresInstanceWrapper*)(*pInst))->SetOutputClass(m_pCurrentMethodOutClass);
   				(*pInst)->SetClass(m_pCurrentMethodClass);
				AddInstance(*pInst);
				(*pInst)->GetKey(Key);
				hr = S_OK;
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
        }
    }
    return hr;
}
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
//
//  Classes for the Procedure Parameters schema rowset
//
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
CWbemSchemaProceduresParametersClassDefinitionWrapper::CWbemSchemaProceduresParametersClassDefinitionWrapper(CWbemClassParameters * p) : CWbemSchemaClassDefinitionWrapper(p) 
{
   
   m_nMaxColumns = sizeof(g_ProcedureParameters)/sizeof(SchemaRowsetDefinition);
}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProceduresParametersClassDefinitionWrapper::GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor )
{
    HRESULT hr = S_OK;

    //===============================================================================
    //  See if we got all of the column info
    //===============================================================================
    if( m_nSchemaClassIndex == m_nMaxColumns )
    {
        return WBEM_S_NO_MORE_DATA;
    }

    *pType = g_ProcedureParameters[m_nSchemaClassIndex].Type;
    *pProperty = Wmioledb_SysAllocString(g_ProcedureParameters[m_nSchemaClassIndex].wcsColumnName);
    m_nSchemaClassIndex++;

    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProceduresParametersInstanceWrapper::GetKey(CBSTR & Key)
{
    HRESULT hr = S_OK;

    //===========================================================
    //  The key is going to the be the class name.method name
    //===========================================================
    CVARIANT v;
    CIMTYPE Type;
    LONG lFlavor;

    hr = GetClassProperty(L"__CLASS",&v,&Type,&lFlavor);
    if( SUCCEEDED(hr))
    {
        WCHAR * p = new WCHAR [wcslen(v.GetStr()) + wcslen(m_bstrCurrentMethodName) + wcslen(m_bstrPropertyName)+ 4 ];
        if( p )
        {
            swprintf(p, L"%s:%s:%s", v.GetStr(),m_bstrCurrentMethodName,m_bstrPropertyName);
            Key.SetStr(p);
            delete p;  
        }
    }
    
    return hr;    
}

//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProceduresParametersInstanceWrapper::GetPropertyQualifier(WCHAR * wcsQualifier,VARIANT * v)
{
    LONG lType;
    long lFlavor;
    HRESULT hr = S_OK;

    IWbemClassObject * pTmp = m_pClass;

    if( m_pInClass )
    {
        m_pClass = m_pInClass;
    }
    else
    {
        m_pClass = m_pOutClass;
    }

    hr = CWbemClassWrapper::GetPropertyQualifier(m_bstrPropertyName,CBSTR(wcsQualifier),v,&lType,&lFlavor);

    m_pClass = pTmp;

    return hr;

}
//////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProceduresParametersInstanceWrapper::GetSchemaProperty( WCHAR * pProperty, VARIANT * v,CIMTYPE * pType , LONG * plFlavor)
{
    HRESULT hr = S_OK;

   ((CVARIANT*)v)->Clear();
   *plFlavor = 0;

   //=============================================================
   // PROCEDURE_CATALOG
   //=============================================================
   if( _wcsicmp(pProperty,g_ProcedureParameters[0].wcsColumnName) == 0 )
   {
       *pType = CIM_STRING;
       ((CVARIANT*)v)->SetStr(m_pParms->m_pConnection->GetNamespace());
   }
   //=============================================================
   // PROCEDURE_SCHEMA
   //=============================================================
   else if( _wcsicmp(pProperty,g_ProcedureParameters[1].wcsColumnName) == 0 )
   {
       *pType = CIM_STRING;
       hr = GetClassProperty(L"__CLASS",v,pType,plFlavor);
   }            
   //=============================================================
   // PROCEDURE_NAME
   //=============================================================
   else if( _wcsicmp(pProperty,g_ProcedureParameters[2].wcsColumnName) == 0 )
   {
       *pType = CIM_STRING;
       ((CVARIANT*)v)->SetStr(m_bstrCurrentMethodName);
   }          
   //=============================================================
   // PARAMETER_NAME
   //=============================================================
   else if( _wcsicmp(pProperty,g_ProcedureParameters[3].wcsColumnName) == 0 )
   {
       *pType = CIM_STRING;
       ((CVARIANT*)v)->SetStr(m_bstrPropertyName);
   }          
   //=============================================================
   // ORDINAL_POSITION
   //=============================================================
   else if( _wcsicmp(pProperty,g_ProcedureParameters[4].wcsColumnName) == 0 )
   {
       *pType = CIM_UINT16;
       ((CVARIANT*)v)->SetShort(m_nOrdinal);
   }          
   //=============================================================
   // PARAMETER_TYPE
   //=============================================================
   else if( _wcsicmp(pProperty,g_ProcedureParameters[5].wcsColumnName) == 0 )
   {
       *pType = CIM_UINT16;
       CVARIANT vIn, vOut;

       GetPropertyQualifier(L"IN",vIn);
       GetPropertyQualifier(L"OUT",vOut);

       if( vIn.GetType() != VT_EMPTY && vOut.GetType() != VT_EMPTY )
       {
           if( vIn.GetBool() == TRUE && vOut.GetBool() == TRUE )
           {
              ((CVARIANT*)v)->SetShort(DBPARAMTYPE_INPUTOUTPUT);
           }
       }
       else if( vOut.GetType() != VT_EMPTY && vOut.GetBool() == TRUE )
       {
          ((CVARIANT*)v)->SetShort(DBPARAMTYPE_OUTPUT);
       }
       else if( vIn.GetType() != VT_EMPTY && vIn.GetBool() == TRUE )
       {
          ((CVARIANT*)v)->SetShort(DBPARAMTYPE_INPUT);
       }
   }          
   //=============================================================
   // PARAMETER_HASDEFAULT
   //=============================================================
   else if( _wcsicmp(pProperty,g_ProcedureParameters[6].wcsColumnName) == 0 )
   {
       *pType = CIM_BOOLEAN;

       CVARIANT vVar;

       hr = GetPropertyQualifier(CBSTR(L"Optional"),(VARIANT *)&vVar);
       if( SUCCEEDED(hr))
       {
           ((CVARIANT*)v)->SetBool(vVar.GetBool());
       }
   }          
   //=============================================================
   // PARAMETER_DEFAULT
   //=============================================================
   else if( _wcsicmp(pProperty,g_ProcedureParameters[7].wcsColumnName) == 0 )
   {
       *pType = CIM_STRING;
   }          
   //=============================================================
   // IS_NULLABLE
   //=============================================================
   else if( _wcsicmp(pProperty,g_ProcedureParameters[8].wcsColumnName) == 0 )
   {
       *pType = CIM_BOOLEAN;
       ((CVARIANT*)v)->SetBool(VARIANT_TRUE);
   }          
   //=============================================================
   // DATA_TYPE
   //=============================================================
   else if( _wcsicmp(pProperty,g_ProcedureParameters[9].wcsColumnName) == 0 )
   {
       *pType = CIM_UINT16;  
       CDataMap Map;
       WORD wType;
       DBLENGTH dwLength;
       DWORD dwFlags;

       hr = Map.MapCIMTypeToOLEDBType(m_vProperty.GetType(),wType,dwLength,dwFlags);
       if( SUCCEEDED(hr))
       {
            ((CVARIANT*)v)->SetShort(wType);
       }
   }          
   //=============================================================
   // CHARACTER_MAXIMUM_LENGTH
   //=============================================================
   else if( _wcsicmp(pProperty,g_ProcedureParameters[10].wcsColumnName) == 0 )
   {
        *pType = CIM_UINT32;  
        if( m_vProperty.GetType() == CIM_STRING )
        {
            ((CVARIANT*)v)->SetLONG(~0);
        }
   }          
   //=============================================================
   // CHARACTER_OCTET_LENGTH
   //=============================================================
   else if( _wcsicmp(pProperty,g_ProcedureParameters[11].wcsColumnName) == 0 )
   {
       *pType = CIM_UINT32;  
        if( m_vProperty.GetType() == CIM_STRING )
        {
            ((CVARIANT*)v)->SetLONG(~0);
        }
   }          
   //=============================================================
   // NUMERIC_PRECISION
   //=============================================================
   else if( _wcsicmp(pProperty,g_ProcedureParameters[12].wcsColumnName) == 0 )
   {
       *pType = CIM_UINT16;
   }          
   //=============================================================
   // NUMERIC_SCALE
   //=============================================================
   else if( _wcsicmp(pProperty,g_ProcedureParameters[13].wcsColumnName) == 0 )
   {
       *pType = CIM_SINT16;
   }          
   //=============================================================
   // DESCRIPTION
   //=============================================================
   else if( _wcsicmp(pProperty,g_ProcedureParameters[14].wcsColumnName) == 0 )
   {
       *pType = CIM_STRING;
   }          
   //=============================================================
   // TYPE_NAME
   //=============================================================
   else if( _wcsicmp(pProperty,g_ProcedureParameters[15].wcsColumnName) == 0 )
   {
       *pType = CIM_STRING;
       CVARIANT vVar;

       hr = GetPropertyQualifier(CBSTR(L"CIMTYPE"),(VARIANT *)&vVar);
       if( SUCCEEDED(hr))
       {
           ((CVARIANT*)v)->SetStr(vVar.GetStr());
       }
   }          
   //=============================================================
   // LOCAL_TYPE_NAME
   //=============================================================
   else if( _wcsicmp(pProperty,g_ProcedureParameters[16].wcsColumnName) == 0 )
   {
       *pType = CIM_STRING;
   }          
   

    return MapWbemErrorToOLEDBError(hr);
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProceduresParametersInstanceList::GetTheNextParameter()
{
    HRESULT hr = WBEM_S_NO_MORE_DATA;
    //===================================================================
    // Get the properties of the class 
    //===================================================================
    CIMTYPE Type = 0;
    LONG Flavor = 0;

    m_bstrPropertyName.Clear();
    m_vProperty.Clear();

    if( m_pCurrentMethodInClass )
    {
        hr = m_pCurrentMethodInClass->Next(0,(BSTR*)&m_bstrPropertyName,&m_vProperty,&Type,&Flavor);
    }
    
    if( hr == WBEM_S_NO_MORE_DATA )
    {
        SAFE_RELEASE_PTR(m_pCurrentMethodInClass );
        if( m_pCurrentMethodOutClass )
        {
            hr = m_pCurrentMethodOutClass->Next(0,(BSTR*)&m_bstrPropertyName,&m_vProperty,&Type,&Flavor);
        }
    }
    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProceduresParametersInstanceList::GetTheNextClassThatHasParameters()
{
    HRESULT hr = S_OK;

    //===================================================================================
    //  If we aren't working on the same class, then get the next class that has a method
    //===================================================================================
    m_nOrdinal = 0;

    while(hr == S_OK)
    {
        hr = GetTheNextClassThatHasMethods();
        if( SUCCEEDED(hr))
        {
            //===========================================================================
            //  Process the input parameters first
            //===========================================================================
            if( m_pCurrentMethodInClass )
            {
                hr = m_pCurrentMethodInClass->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
            }
            else if( m_pCurrentMethodOutClass )
            {
                hr = m_pCurrentMethodOutClass->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
            }

            if( SUCCEEDED(hr))
            {
                hr = GetTheNextParameter();
                if( SUCCEEDED(hr))
                {
                    m_fStillWorkingOnTheSameClass = TRUE;
                    break;
                }
            }
        }            
    }

    return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWbemSchemaProceduresParametersInstanceList::NextInstance( CBSTR & Key, CWbemClassInstanceWrapper ** pInst  )
{
    HRESULT hr = S_OK;
    if( m_pwcsSpecificClass )
    {
        hr = GetSpecificNextInstance();
        m_fStillWorkingOnTheSameClass = TRUE; // We want to pick up the parameters 
    }
    if( S_OK == hr )
    {
        if( !m_fStillWorkingOnTheSameClass )
        {
            hr = GetTheNextClassThatHasParameters();
        }
        else
        {
            hr = GetTheNextParameter();
            if( S_OK != hr )
            {
                hr = GetTheNextClassThatHasParameters();
            }
        }
    }
    
    if( S_OK == hr)
    {
        *pInst = new CWbemSchemaProceduresParametersInstanceWrapper(m_pParms);
 		// NTRaid:136459
		// 07/05/00
		if(*pInst)
		{
 			(*pInst)->SetPos(++m_lCurrentPos);
   			((CWbemSchemaProceduresParametersInstanceWrapper*)(*pInst))->SetMethodName((LPWSTR)m_bstrCurrentMethodName);
   			((CWbemSchemaProceduresParametersInstanceWrapper*)(*pInst))->SetPropertyName((LPWSTR)m_bstrPropertyName);
   			((CWbemSchemaProceduresParametersInstanceWrapper*)(*pInst))->SetProperty(m_vProperty);
   			((CWbemSchemaProceduresParametersInstanceWrapper*)(*pInst))->SetOrdinal(++m_nOrdinal);
   			((CWbemSchemaProceduresInstanceWrapper*)(*pInst))->SetInputClass(m_pCurrentMethodInClass);
   			((CWbemSchemaProceduresInstanceWrapper*)(*pInst))->SetOutputClass(m_pCurrentMethodOutClass);

   			(*pInst)->SetClass(m_pCurrentMethodClass);
			AddInstance(*pInst);
    		((CWbemSchemaProceduresInstanceWrapper*)(*pInst))->GetKey(Key);
			hr = S_OK;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\tranoptions.cpp ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// CTranOptions object implementation & ITransactionOptions interface implementation
// 
//
///////////////////////////////////////////////////////////////////////////////////

#include "headers.h"


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CTranOptions::CTranOptions(IUnknown *pUnkOuter) : CBaseObj(BOT_TXNOPTIONS,pUnkOuter)
{
	m_pITransOptions = NULL;
	m_xactOptions.ulTimeout = 0;
	memset(m_xactOptions.szDescription,0,MAX_TRAN_DESC * sizeof(unsigned char));
    InterlockedIncrement(&g_cObj);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Destructor
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CTranOptions::~CTranOptions()
{
	SAFE_DELETE_PTR(m_pITransOptions);
	SAFE_DELETE_PTR(m_pISupportErrorInfo);
    InterlockedDecrement(&g_cObj);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IUnknown method AddRef
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CTranOptions::AddRef(void)
{
    return InterlockedIncrement((long*)&m_cRef);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// IUnknown method Release
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CTranOptions::Release(void)
{
    if (!InterlockedDecrement((long*)&m_cRef))
	{
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QueryInterface
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CTranOptions::QueryInterface(REFIID riid, LPVOID *ppv)
{
    HRESULT hr = S_OK;


    //======================================================
    //  Check parameters, if not valid return
    //======================================================
    if (NULL == ppv)
	{
        hr = E_INVALIDARG ;
    }
	else
	{

		//======================================================
		//  Place NULL in *ppv in case of failure
		//======================================================
		*ppv = NULL;
		if (riid == IID_IUnknown)
		{
			*ppv = (LPVOID) this;
		}
		else if (riid == IID_ITransactionOptions)
		{
			*ppv = (LPVOID)m_pITransOptions;
		}
		else if (riid == IID_ISupportErrorInfo)
		{
			*ppv = (LPVOID)m_pISupportErrorInfo;
		}

		//======================================================
		//  If we're going to return an interface, AddRef first
		//======================================================
		if (*ppv)
		{
			((LPUNKNOWN) *ppv)->AddRef();
			hr = S_OK ;
		}
		else
		{
			hr =  E_NOINTERFACE;
		}

	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Initilization function for the object
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CTranOptions::FInit()
{
	HRESULT hr = S_OK;
	m_pITransOptions		= new CImpITransactionOptions(this);
	m_pISupportErrorInfo	= new CImpISupportErrorInfo(this);

	if(!m_pITransOptions || !m_pISupportErrorInfo)
	{
		hr = E_OUTOFMEMORY;
	}

	if(SUCCEEDED(hr))
	{
		hr = AddInterfacesForISupportErrorInfo();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to add interfaces to ISupportErrorInfo interface
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CTranOptions::AddInterfacesForISupportErrorInfo()
{
	HRESULT hr = S_OK;
	hr = m_pISupportErrorInfo->AddInterfaceID(IID_ITransactionOptions);

	return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to set the transactions options
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTranOptions::SetOptions(XACTOPT *pOpt)
{
	m_xactOptions.ulTimeout = pOpt->ulTimeout;
	strcpy(m_xactOptions.szDescription,pOpt->szDescription);
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function which returns pointer to transaction options structure pointer
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
XACTOPT *CTranOptions::GetOptions()
{
	return &m_xactOptions;
}



////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
//	CImpITransactionOptions class implementaions - ie ITransactionOptions interface implementation
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Set transactions options
//
// Returns one of the following values:
//      S_OK                    Method Succeeded
//      E_FAIL					a provider specific error occured
//		E_INVALIDARG			pOptions is NULL
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpITransactionOptions::SetOptions(XACTOPT * pOptions)
{
	HRESULT hr = E_INVALIDARG;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(m_pObj->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();
	
	if(pOptions)
	{
		m_pObj->SetOptions(pOptions);
		hr = S_OK;
	}
	
	
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_ITransactionOptions);

	CATCH_BLOCK_HRESULT(hr,L"ITransactionOptions::SetOptions");
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Get the current transactions options
//
// Returns one of the following values:
//      S_OK                    Method Succeeded
//      E_FAIL					a provider specific error occured
//		E_INVALIDARG			pOptions is NULL
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImpITransactionOptions::GetOptions(XACTOPT * pOptions)
{
	HRESULT hr = E_INVALIDARG;
    CSetStructuredExceptionHandler seh;

	TRY_BLOCK;

	// Seriliaze the object
	CAutoBlock cab(m_pObj->GetCriticalSection());

	// Clear Error information
	g_pCError->ClearErrorInfo();
	
	if(pOptions)
	{
		XACTOPT *pOptTemp = m_pObj->GetOptions();
		pOptions->ulTimeout = pOptTemp->ulTimeout;
		strcpy(pOptions->szDescription,pOptTemp->szDescription);
		hr = S_OK;
	}
	
	hr = hr == S_OK ? hr :g_pCError->PostHResult(hr,&IID_ITransactionOptions);

	CATCH_BLOCK_HRESULT(hr,L"ITransactionOptions::SetOptions");
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\urlparser.h ===
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider 
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//	UrlParser.h		-	CURLParer class header file,
/////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _URLPARSER_H_
#define _URLPARSER_H_


#define URL_ROW				1
#define URL_DATASOURCE		2
#define URL_ROWSET			3
#define URL_EMBEDEDCLASS	4

#define WMIURL				1
#define UMIURL				2
#define RELATIVEURL			3

#define NAMESPACE_MAXLENGTH		1024
#define CLASSNAME_MAXLENGTH		255
#define PATH_MAXLENGTH			2048
#define KEYNAME_MAXLENGTH		255


class IPathParser
{
public:
	virtual HRESULT GetNameSpace(BSTR &strNameSpace) = 0;
	virtual HRESULT GetClassName(BSTR &strClassName) = 0;
	virtual HRESULT SetPath(WCHAR * strPath) = 0;
	virtual HRESULT GetPath(BSTR &strPath) = 0;
	virtual LONG	GetURLType() = 0;
	virtual HRESULT GetKeyValue(BSTR strKey, VARIANT &varValue) = 0;
	virtual HRESULT ParseNameSpace(BSTR & strParentNameSpace,BSTR &strNameSpace) = 0;
	virtual HRESULT Initialize() = 0;
};


class CURLParser
{
private:
	BSTR m_strURL;			// Path of the URL
	BSTR m_strNameSpace;		
	BSTR m_strClassName;
	BSTR m_strPath;
	BSTR m_strInitProps;
	BSTR m_strEmbededPropName;
	LONG m_nEmbededChildIndex;

	BOOL m_bAllPropsInSync;
	BOOL m_bURLInitialized;	// flag which tells whether all the other properties are intialized from URL o
							// URL is constructed from the other properties
	LONG m_lURLType;

	IPathParser	*m_pIPathParser;
	IWbemPath	*m_pIWbemPath;

	void	GetInitializationProps(WCHAR *pStr);
//	void	GetNameSpaceFromURL(WCHAR * & pStrIn);
//	void	GetClassNameFromURL(WCHAR *pStr);
	HRESULT	GetURLString(BSTR &strUrl);
	void	GetEmbededInstanceParameters(WCHAR  * & pStrIn);
	HRESULT SetPathofParser(WCHAR * strPath);
	HRESULT	Initialize(WCHAR * strPath);
	HRESULT InitializeParserForURL(BSTR strURL);
//	void	GetPathFromURLString(WCHAR  * & pStrIn);

public:
	CURLParser();
	~CURLParser();

	HRESULT SetPath(BSTR strPath);
	HRESULT GetPath(BSTR &strPath);

	HRESULT GetNameSpace(BSTR & strNameSpace);

//	void SetClassName(BSTR strClassName);
	HRESULT GetClassName(BSTR &strClassName);

	HRESULT SetURL(BSTR strURL);
	HRESULT GetURL(BSTR &strURL);

	void SetEmbededInstInfo(BSTR strProperty,int nIndex);
	void GetEmbededInstInfo(BSTR &strProperty,int &nIndex);
	
	HRESULT GetPathWithEmbededInstInfo(BSTR &strPath);

	LONG GetURLType();

	HRESULT GetKeyValue(BSTR strKey,VARIANT &varValue);
	void	ClearParser();
	
	HRESULT ParseNameSpace(BSTR & strParentNameSpace,BSTR &strNameSpace);

	LONG IsValidURL(WCHAR *pStrUrl);

};

class CWBEMPathParser : public IPathParser
{
	IWbemPath	*m_pIWbemPath;
public:
	CWBEMPathParser();
	~CWBEMPathParser();
	virtual HRESULT Initialize();

	virtual HRESULT GetNameSpace(BSTR &strNameSpace);
	virtual HRESULT GetClassName(BSTR &strClassName);
	virtual HRESULT SetPath(WCHAR * pwcsath);
	virtual HRESULT GetPath(BSTR &strPath);
	virtual LONG	GetURLType();
	virtual HRESULT GetKeyValue(BSTR strKey, VARIANT &varValue);
	virtual HRESULT ParseNameSpace(BSTR & strParentNameSpace,BSTR &strNameSpace);
};


class CUMIPathParser : public IPathParser
{
	IUmiURL	*m_pIUmiPath;
public:
	CUMIPathParser();
	~CUMIPathParser();

	virtual HRESULT Initialize() ;
	virtual HRESULT GetNameSpace(BSTR &strNameSpace);
	virtual HRESULT GetClassName(BSTR &strClassName);
	virtual HRESULT SetPath(WCHAR * strPath);
	virtual HRESULT GetPath(BSTR &strPath);
	virtual LONG	GetURLType();
	virtual HRESULT GetKeyValue(BSTR strKey, VARIANT &varValue);
	virtual HRESULT ParseNameSpace(BSTR & strParentNameSpace,BSTR &strNameSpace);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\schema.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Utility object versions for synthesized rowsets.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef __SCHEMA_INCL__
#define __SCHEMA_INCL__

#include "headers.h"

#define SOURCES_ROWSET              10
#define PROVIDER_TYPES_ROWSET       20
#define CATALOGS_ROWSET             30
#define COLUMNS_ROWSET              40
#define TABLES_ROWSET               60
#define PRIMARY_KEYS_ROWSET         70
#define TABLES_INFO_ROWSET          80
#define PROCEDURES_ROWSET           90
#define PROCEDURE_PARAMETERS_ROWSET 100


/////////////////////////////////////////////////////////////////////////////////////////////
//  The Schema rowset definitions
/////////////////////////////////////////////////////////////////////////////////////////////
// FOR THE PROVIDER_TYPES ROWSET
typedef struct _CIMTypeInfo
{
    WCHAR *         wcsTypeName;
    short           DataType;
    unsigned long   ColumnSize;
//    WCHAR *     LiteralPrefix;        Same values for all rows, so hardcoded in function
//    WCHAR *     LiteralSuffix;        Same values for all rows, so hardcoded in function
//    WCHAR *     CreateParams;         Same values for all rows, so hardcoded in function
//    CIM_BOOLEAN IsNullable;           Same values for all rows, so hardcoded in function
//    CIM_BOOLEAN CaseSensitive;        Same values for all rows, so hardcoded in function
//    CIM_UINT32  Searchable;           Same values for all rows, so hardcoded in function
    BOOL            UnsignedAttribute;
//    CIM_BOOLEAN FixedPrec;            Same values for all rows, so hardcoded in function
//    CIM_BOOLEAN AutoUnique;           Same values for all rows, so hardcoded in function
//    WCHAR *     LocalTypeName;        Same values for all rows, so hardcoded in function
//    CIM_SINT16  MinimumScale;         Same values for all rows, so hardcoded in function
//    CIM_SINT16  MaximumScale;         Same values for all rows, so hardcoded in function
//  DBTYPE_GUID Guid;
//    WCHAR *     TypeLib;              Same values for all rows, so hardcoded in function
//    WCHAR *     Version;              Same values for all rows, so hardcoded in function
//    CIM_BOOLEAN IsLong;               Same values for all rows, so hardcoded in function
//    CIM_BOOLEAN BestMatch;            Same values for all rows, so hardcoded in function
//  CIM_BOOLEAN IsFixedLength;          Same values for all rows, so hardcoded in function

}CIMTypeInfo;


typedef struct _SchemaRowsetDefinition
{
    LPWSTR wcsColumnName;
    CIMTYPE Type;

} SchemaRowsetDefinition;

////////////////////////////////////////////////////////////////////////////////////////////////////////
// SCHEMA BASE CLASS
//
// This class is used by one of the many CSchema__xxx classes to retrieve schema information.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
class CSchema : public CRowset
{
	int m_nTableId;

	HRESULT GetTableName(WCHAR *pTableName);

    public:		

		
        STDMETHODIMP	FInit(  ULONG			cPropertySets,		// IN  Count of properties			
		                        DBPROPSET		rgProperties[],		// IN  Properties array
		                        REFIID			riid,				// IN  riid for IRowset object
		                        IUnknown		*pUnkOuter,			// IN  Outer unknown
		                        IUnknown		**ppIRowset,		// OUT Newly-created IRowset interface		
                                WCHAR * wcsSpecificTable
	    );

    protected:	
        //=========================================================================
    	// These are functions a derived class needs to call (only on base).
        // Protected so only a derived class can use.
        //=========================================================================
	    CSchema	(LPUNKNOWN pUnkOuter, int nTableId,PCDBSESSION pObj );	

        //=========================================================================
	    // Sets the rowset property corresponding to the requested interface
    	// if the requested interface is available on a read-only rowset.
        //=========================================================================
    	HRESULT SetReadOnlyProperty(	CUtilProp*	pRowsetProps, 	REFIID riid);

    protected:	
	    
	    virtual ~CSchema();                                         //Clients must use Release().

};
////////////////////////////////////////////////////////////////////////////////////////////////
//
// Schema Command object for CATALOGS rowset.
//
////////////////////////////////////////////////////////////////////////////////////////////////

class CSchema_Catalogs: public CSchema
{
    public:	
        CSchema_Catalogs(LPUNKNOWN pUnkOuter,PCDBSESSION pObj ):CSchema(pUnkOuter,CATALOGS_ROWSET,pObj) {};	

};

////////////////////////////////////////////////////////////////////////////////////////////////
//
// Schema Command object for PROVIDER_TYPES rowset.
//
////////////////////////////////////////////////////////////////////////////////////////////////
class CSchema_Provider_Types: public CSchema
{
    public:	
        CSchema_Provider_Types(LPUNKNOWN pUnkOuter,PCDBSESSION pObj ):CSchema(pUnkOuter,PROVIDER_TYPES_ROWSET,pObj) {};	

};

////////////////////////////////////////////////////////////////////////////////////////////////
//
// Schema Command object for COLUMNS rowset.
//
////////////////////////////////////////////////////////////////////////////////////////////////
class CSchema_Columns: public CSchema
{
    public:	
        CSchema_Columns(LPUNKNOWN pUnkOuter,PCDBSESSION pObj ):CSchema(pUnkOuter,COLUMNS_ROWSET,pObj) {};	

};


////////////////////////////////////////////////////////////////////////////////////////////////
//
// Schema Command object for TABLES rowset.
//
////////////////////////////////////////////////////////////////////////////////////////////////
class CSchema_Tables: public CSchema
{
    public:	
        CSchema_Tables(LPUNKNOWN pUnkOuter,PCDBSESSION pObj ):CSchema(pUnkOuter,TABLES_ROWSET,pObj) {};	

};

////////////////////////////////////////////////////////////////////////////////////////////////
//
// Schema Command object for primary keys rowset.
//
////////////////////////////////////////////////////////////////////////////////////////////////
class CSchema_Primary_Keys: public CSchema
{
    public:	
        CSchema_Primary_Keys(LPUNKNOWN pUnkOuter,PCDBSESSION pObj ):CSchema(pUnkOuter,PRIMARY_KEYS_ROWSET,pObj) {};	

};

////////////////////////////////////////////////////////////////////////////////////////////////
//
// Schema Command object for TABLES_INFO rowset.
//
////////////////////////////////////////////////////////////////////////////////////////////////
class CSchema_Tables_Info: public CSchema
{
    public:	
        CSchema_Tables_Info(LPUNKNOWN pUnkOuter,PCDBSESSION pObj ):CSchema(pUnkOuter,TABLES_INFO_ROWSET,pObj) {};	

};
////////////////////////////////////////////////////////////////////////////////////////////////
//
// Schema Command object for Sources rowset.
//
////////////////////////////////////////////////////////////////////////////////////////////////
class CSchema_ISourcesRowset: public CSchema
{
    public:	
       
        CSchema_ISourcesRowset(LPUNKNOWN pUnkOuter,PCDBSESSION pObj ):CSchema(pUnkOuter,SOURCES_ROWSET,pObj) {}	

};
////////////////////////////////////////////////////////////////////////////////////////////////
//
// Schema object for Procedures rowset.
//
////////////////////////////////////////////////////////////////////////////////////////////////

class CSchema_Procedures: public CSchema
{
    public:	
        CSchema_Procedures(LPUNKNOWN pUnkOuter,PCDBSESSION pObj ):CSchema(pUnkOuter,PROCEDURES_ROWSET,pObj) {};	
};

////////////////////////////////////////////////////////////////////////////////////////////////
//
// Schema object for PROCEDURES_PARAMETERS rowset.
//
////////////////////////////////////////////////////////////////////////////////////////////////

class CSchema_Procedure_Parameters: public CSchema
{
    public:	
        CSchema_Procedure_Parameters(LPUNKNOWN pUnkOuter,PCDBSESSION pObj )
                                      :CSchema(pUnkOuter,PROCEDURE_PARAMETERS_ROWSET,pObj) {};	
};

////////////////////////////////////////////////////////////////////////////////////////////////
class CImpIDBSchemaRowset : public IDBSchemaRowset	//@base public | IDBSchemaRowset
{
    private: 
	
	enum eRestrictionSupport{
		eSup_CATALOGS				= 0x00,	// Allow nothing
		eSup_COLUMNS				= 0x07,	// Allow the first 3 columns as a restriction
		eSup_PRIMARY_KEYS			= 0x07,	// Allow the first 3 columns as a restriction
		eSup_PROCEDURE_PARAMETERS	= 0x03,	// Allow the first 2 columns as a restriction
		eSup_PROCEDURES				= 0x03,	// Allow the first 2 columns as a restriction
		eSup_PROVIDER_TYPES			= 0x00,	// Allow nothing
		eSup_TABLES					= 0x07,	// Allow the first 3 columns as a restriction
		eSup_TABLES_INFO			= 0x07,	// Allow the first 3 columns as a restriction
		eSup_LINKEDSERVERS			= 0x01, // 1 out of 1
		};

public: 
	CImpIDBSchemaRowset(PCDBSESSION pCDBSession){
		DEBUGCODE(m_cRef = 0L);
		m_pCDBSession = pCDBSession;
    }
	~CImpIDBSchemaRowset() {assert(m_cRef == 0);}

	STDMETHODIMP_(ULONG) AddRef(void)
	{																
		DEBUGCODE(InterlockedIncrement((long*)&m_cRef));						
		return m_pCDBSession->GetOuterUnknown()->AddRef();								
	}								
	
	STDMETHODIMP_(ULONG) Release(void)
	{
		DEBUGCODE(long lRef = InterlockedDecrement((long*)&m_cRef);
	   if( lRef < 0 ){
		   ASSERT("Reference count on Object went below 0!")
	   })
	
		return m_pCDBSession->GetOuterUnknown()->Release();								
	}

	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
	{																	
		return m_pCDBSession->GetOuterUnknown()->QueryInterface(riid, ppv);					
	}

	STDMETHODIMP GetRowset( IUnknown *pUnkOuter,  REFGUID rguidSchema,  ULONG cRestrictions, const VARIANT rgRestrictions[],
                            REFIID riid, ULONG cProperties,	DBPROPSET rgProperties[], IUnknown **ppRowset);
    STDMETHODIMP GetSchemas( ULONG *pcSchemas, GUID **ppSchemas, ULONG **prgRestrictionSupport );

private:
	DEBUGCODE(ULONG m_cRef);
	PCDBSESSION		m_pCDBSession;
};

typedef CImpIDBSchemaRowset *PIMPIDBSCHEMAROWSET;


//////////////////////////////////////////////////////////////////////////////////////////////
class CWbemSchemaClassInstanceWrapper : public CWbemClassInstanceWrapper
{
   protected:
        ULONG m_uCurrentIndex;
        int m_nMaxColumns;


    public:
        CWbemSchemaClassInstanceWrapper(CWbemClassParameters * p);
        ~CWbemSchemaClassInstanceWrapper();

        void SetIndex(ULONG u)                          { m_uCurrentIndex = u;}
        void AddToKeyList(WCHAR *& pwcsKeyList, WCHAR * wcsKey );

        virtual HRESULT ResetInstanceFromKey(CBSTR Key) { return CWbemClassInstanceWrapper::ResetInstanceFromKey(Key); }
        
        virtual HRESULT GetKey(CBSTR & Key)             { return CWbemClassInstanceWrapper::GetKey(Key);}
		virtual HRESULT RefreshInstance()               { return CWbemClassInstanceWrapper::RefreshInstance(); }
		virtual WCHAR * GetClassName()                  { return CWbemClassInstanceWrapper::GetClassName(); }

        HRESULT GetClassProperty(WCHAR * wcsProperty, VARIANT * v, CIMTYPE * pType , LONG * plFlavor );
        virtual HRESULT GetSchemaProperty(WCHAR * wcsProperty, VARIANT * v, CIMTYPE * pType , LONG * plFlavor )=0;
 
};
//////////////////////////////////////////////////////////////////////////////////////////////
// Works with just the schema classes
//////////////////////////////////////////////////////////////////////////////////////////////
class  CWbemSchemaClassDefinitionWrapper : public CWbemClassDefinitionWrapper
{
    protected:
        int                         m_nSchemaClassIndex;
        int                         m_nMaxColumns;

    public:
        CWbemSchemaClassDefinitionWrapper(CWbemClassParameters * p);
        ~CWbemSchemaClassDefinitionWrapper();

        HRESULT ValidClass();

        HRESULT TotalPropertiesInClass(ULONG & ulPropCount, ULONG &ulSysPropCount);
        HRESULT BeginPropertyEnumeration();
        HRESULT EndPropertyEnumeration();
        virtual HRESULT GetNextProperty(BSTR * pProperty, VARIANT * vValue, CIMTYPE * pType ,LONG * plFlavor ) { return CWbemClassDefinitionWrapper::GetNextProperty(pProperty,vValue,pType,plFlavor);}
        HRESULT BeginPropertyQualifierEnumeration(BSTR strPropName);

};
///////////////////////////////////////////////////////////////////////////////////////////////////
class CWbemSchemaInstanceList: public CWbemInstanceList 
{
    protected:
        ULONG m_ulMaxRow;
        WCHAR * m_pwcsSpecificClass;
        IWbemClassObject * m_pSpecificClass;
        BOOL m_fGotThemAll;
 
    public:
        CWbemSchemaInstanceList(CWbemClassParameters * p);
        CWbemSchemaInstanceList(CWbemClassParameters * p,WCHAR * pSpecific);
        ~CWbemSchemaInstanceList();

        virtual HRESULT Reset()=0;
        virtual HRESULT NextInstance(CBSTR & Key, CWbemClassInstanceWrapper ** p) { return CWbemInstanceList::NextInstance(Key,p);}
        virtual HRESULT PrevInstance( CBSTR & Key, CWbemClassInstanceWrapper *& p){ if( !m_pwcsSpecificClass ){ return CWbemInstanceList::PrevInstance(Key,p);} return S_OK;}
        HRESULT ResetTheSpecificClass();
        HRESULT GetTheSpecificClass();


};
//////////////////////////////////////////////////////////////////////////////////////////////
//********************************************************************************************
//
//  Classes for the Sources schema rowset
//
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////

class CWbemSchemaSourcesClassDefinitionWrapper: public CWbemSchemaClassDefinitionWrapper 
{
    private:

    public:
        CWbemSchemaSourcesClassDefinitionWrapper(CWbemClassParameters * p);
        ~CWbemSchemaSourcesClassDefinitionWrapper() {}
        HRESULT GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor );

};
class CWbemSchemaSourcesInstanceWrapper: public CWbemSchemaClassInstanceWrapper 
{
    private:

    public:
        CWbemSchemaSourcesInstanceWrapper(CWbemClassParameters * p) : CWbemSchemaClassInstanceWrapper(p)
        { }
        ~CWbemSchemaSourcesInstanceWrapper() {}
        HRESULT GetSchemaProperty(WCHAR * wcsProperty, VARIANT * v, CIMTYPE * pType , LONG * plFlavor );
};

class CWbemSchemaSourcesInstanceList: public CWbemSchemaInstanceList
{
    private:

    public:
        CWbemSchemaSourcesInstanceList(CWbemClassParameters * p) : CWbemSchemaInstanceList(p) {m_nBaseType = SOURCES_ROWSET;}
        ~CWbemSchemaSourcesInstanceList() {}
        HRESULT Reset();
};

//////////////////////////////////////////////////////////////////////////////////////////////
//********************************************************************************************
//
//  Classes for the Provider Types schema rowset
//
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
class CWbemSchemaProviderTypesClassDefinitionWrapper: public CWbemSchemaClassDefinitionWrapper 
{
    private:

    public:
       CWbemSchemaProviderTypesClassDefinitionWrapper(CWbemClassParameters * p);
       ~CWbemSchemaProviderTypesClassDefinitionWrapper() {}
       HRESULT GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor );
       HRESULT ResetInstanceFromKey(CBSTR Key);
 };
class CWbemSchemaProviderTypesInstanceWrapper: public CWbemSchemaClassInstanceWrapper 
{
    private:

    public:
        CWbemSchemaProviderTypesInstanceWrapper(CWbemClassParameters * p) : CWbemSchemaClassInstanceWrapper(p)
        { }
        ~CWbemSchemaProviderTypesInstanceWrapper() {}
         HRESULT GetSchemaProperty(WCHAR * wcsProperty, VARIANT * v, CIMTYPE * pType , LONG * plFlavor );
         HRESULT GetKey(CBSTR & Key);
         HRESULT ResetInstanceFromKey(CBSTR Key);
         HRESULT RefreshInstance();
         WCHAR * GetClassName();
};
class CWbemSchemaProviderTypesInstanceList: public CWbemSchemaInstanceList
{
    private:

    public:
        CWbemSchemaProviderTypesInstanceList(CWbemClassParameters * p) : CWbemSchemaInstanceList(p) {m_nBaseType = PROVIDER_TYPES_ROWSET;}
        ~CWbemSchemaProviderTypesInstanceList(){}
        HRESULT Reset();
        HRESULT NextInstance(CBSTR & Key, CWbemClassInstanceWrapper ** p);

};

//////////////////////////////////////////////////////////////////////////////////////////////
//********************************************************************************************
//
//  Classes for the Catalogs schema rowset
//
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
class CWbemSchemaCatalogsClassDefinitionWrapper: public CWbemSchemaClassDefinitionWrapper 
{
    private:

    public:
        CWbemSchemaCatalogsClassDefinitionWrapper(CWbemClassParameters * p);
        ~CWbemSchemaCatalogsClassDefinitionWrapper() {}
        HRESULT GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor );
};
class CWbemSchemaCatalogsInstanceWrapper: public CWbemSchemaClassInstanceWrapper 
{
    private:

    public:
        CWbemSchemaCatalogsInstanceWrapper(CWbemClassParameters * p) : CWbemSchemaClassInstanceWrapper(p)
        { }
        ~CWbemSchemaCatalogsInstanceWrapper() {}
        HRESULT GetSchemaProperty(WCHAR * wcsProperty, VARIANT * v, CIMTYPE * pType , LONG * plFlavor );
};
class CWbemSchemaCatalogsInstanceList: public CWbemSchemaInstanceList
{
    private:

    public:
        CWbemSchemaCatalogsInstanceList(CWbemClassParameters * p) : CWbemSchemaInstanceList(p) { m_nBaseType = CATALOGS_ROWSET; }
        ~CWbemSchemaCatalogsInstanceList() {}
        HRESULT Reset();
};


//////////////////////////////////////////////////////////////////////////////////////////////
//********************************************************************************************
//
//  Classes for the COlumns schema rowset
//
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
class CWbemSchemaColumnsClassDefinitionWrapper : public CWbemSchemaClassDefinitionWrapper 
{
    private:

    public:
        CWbemSchemaColumnsClassDefinitionWrapper(CWbemClassParameters * p);
        ~CWbemSchemaColumnsClassDefinitionWrapper() {}
        HRESULT GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor );
};

class CWbemSchemaColumnsInstanceWrapper: public CWbemSchemaClassInstanceWrapper 
{
    private:
        cRowColumnInfoMemMgr * m_pColumns;

    public:
        CWbemSchemaColumnsInstanceWrapper(CWbemClassParameters * p) : CWbemSchemaClassInstanceWrapper(p) { m_pColumns=NULL;}
        ~CWbemSchemaColumnsInstanceWrapper() {}

        void SetColumnsPtr(cRowColumnInfoMemMgr * p)    { m_pColumns = p; }
        HRESULT GetSchemaProperty(WCHAR * wcsProperty, VARIANT * v, CIMTYPE * pType , LONG * plFlavor );
        HRESULT GetKey(CBSTR & Key);

};
class CWbemSchemaColumnsInstanceList: public CWbemSchemaInstanceList
{
    private:
        LONG  m_lColumnIndex;
        cRowColumnInfoMemMgr m_Columns;
        
        HRESULT GetColumnInformation(CWbemClassInstanceWrapper  * p);
        void  FreeColumns()                     { m_Columns.FreeColumnNameList(); m_Columns.FreeColumnInfoList();}

    public:
        CWbemSchemaColumnsInstanceList(CWbemClassParameters * p,WCHAR * pSpecific) : CWbemSchemaInstanceList(p, pSpecific) 
        {    m_lColumnIndex = -1; m_nBaseType = COLUMNS_ROWSET;}
        ~CWbemSchemaColumnsInstanceList() {FreeColumns();}
        DBCOUNTITEM GetTotalColumns()  { return m_Columns.GetTotalNumberOfColumns(); }
        HRESULT Reset();
        HRESULT NextInstance( CBSTR & Key, CWbemClassInstanceWrapper ** pInst  );

};

//////////////////////////////////////////////////////////////////////////////////////////////
//********************************************************************************************
//
//  Classes for the Tables schema rowset
//
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
class CWbemSchemaTablesClassDefinitionWrapper: public CWbemSchemaClassDefinitionWrapper 
{
    private:

    public:
        CWbemSchemaTablesClassDefinitionWrapper(CWbemClassParameters * p);
        ~CWbemSchemaTablesClassDefinitionWrapper() {}
        HRESULT GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor );
};
class CWbemSchemaTablesInstanceWrapper: public CWbemSchemaClassInstanceWrapper 
{
    private:

    public:
        CWbemSchemaTablesInstanceWrapper(CWbemClassParameters * p) : CWbemSchemaClassInstanceWrapper(p)
        { }
        ~CWbemSchemaTablesInstanceWrapper() {}
        HRESULT GetSchemaProperty(WCHAR * wcsProperty, VARIANT * v, CIMTYPE * pType , LONG * plFlavor );
};
class CWbemSchemaTablesInstanceList: public CWbemSchemaInstanceList
{
    private:

    public:
        CWbemSchemaTablesInstanceList(CWbemClassParameters * p,WCHAR * pSpecific) : CWbemSchemaInstanceList(p, pSpecific) 
        {m_nBaseType = TABLES_ROWSET;}
        ~CWbemSchemaTablesInstanceList() {}
        HRESULT Reset();
        HRESULT NextInstance( CBSTR & Key, CWbemClassInstanceWrapper ** pInst  );

};
//////////////////////////////////////////////////////////////////////////////////////////////
//********************************************************************************************
//
//  Classes for the Primary Keys schema rowset
//
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
class CWbemSchemaPrimaryKeysClassDefinitionWrapper : public CWbemSchemaClassDefinitionWrapper 
{
    private:

    public:
        CWbemSchemaPrimaryKeysClassDefinitionWrapper(CWbemClassParameters * p);
         ~CWbemSchemaPrimaryKeysClassDefinitionWrapper() {}
        HRESULT GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor );
};
class CWbemSchemaPrimaryKeysInstanceWrapper: public CWbemSchemaClassInstanceWrapper 
{
    private:

    public:
        CWbemSchemaPrimaryKeysInstanceWrapper(CWbemClassParameters * p) : CWbemSchemaClassInstanceWrapper(p)
        { }
        ~CWbemSchemaPrimaryKeysInstanceWrapper() {}
        HRESULT GetSchemaProperty(WCHAR * wcsProperty, VARIANT * v, CIMTYPE * pType , LONG * plFlavor );
};
class CWbemSchemaPrimaryKeysInstanceList: public CWbemSchemaInstanceList
{
    private:

    public:

        CWbemSchemaPrimaryKeysInstanceList(CWbemClassParameters * p,WCHAR * pSpecific) : CWbemSchemaInstanceList(p, pSpecific) { m_nBaseType = PRIMARY_KEYS_ROWSET;}
        ~CWbemSchemaPrimaryKeysInstanceList() {}
        HRESULT Reset();
        HRESULT NextInstance( CBSTR & Key, CWbemClassInstanceWrapper ** pInst  );

};


//////////////////////////////////////////////////////////////////////////////////////////////
//********************************************************************************************
//
//  Classes for the Tables Info schema rowset
//
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
class CWbemSchemaTablesInfoClassDefinitionWrapper: public CWbemSchemaClassDefinitionWrapper 
{
    private:

    public:
        CWbemSchemaTablesInfoClassDefinitionWrapper(CWbemClassParameters * p);
        ~CWbemSchemaTablesInfoClassDefinitionWrapper() {}
        HRESULT GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor );
};
class CWbemSchemaTablesInfoInstanceWrapper: public CWbemSchemaClassInstanceWrapper 
{
    private:

    public:
        CWbemSchemaTablesInfoInstanceWrapper(CWbemClassParameters * p) : CWbemSchemaClassInstanceWrapper(p) {}
        ~CWbemSchemaTablesInfoInstanceWrapper() {}
        HRESULT GetSchemaProperty(WCHAR * wcsProperty, VARIANT * v, CIMTYPE * pType , LONG * plFlavor );
};
class CWbemSchemaTablesInfoInstanceList: public CWbemSchemaInstanceList
{
    private:

    public:
        CWbemSchemaTablesInfoInstanceList(CWbemClassParameters * p,WCHAR * pSpecific) : CWbemSchemaInstanceList(p,pSpecific) 
        {m_nBaseType = TABLES_INFO_ROWSET;}
        ~CWbemSchemaTablesInfoInstanceList() {}
        HRESULT Reset();
        HRESULT NextInstance( CBSTR & Key, CWbemClassInstanceWrapper ** pInst  );
};

//////////////////////////////////////////////////////////////////////////////////////////////
//********************************************************************************************
//
//  Classes for the Procedures schema rowset
//
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
class CWbemSchemaProceduresClassDefinitionWrapper: public CWbemSchemaClassDefinitionWrapper 
{
    private:

    public:
        CWbemSchemaProceduresClassDefinitionWrapper(CWbemClassParameters * p);
        ~CWbemSchemaProceduresClassDefinitionWrapper() {}
        HRESULT GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor );
};

class CWbemSchemaProceduresInstanceWrapper: public CWbemSchemaClassInstanceWrapper 
{
    protected:
        CBSTR m_bstrCurrentMethodName;
        IWbemClassObject * m_pInClass;
        IWbemClassObject * m_pOutClass;


    public:
        CWbemSchemaProceduresInstanceWrapper(CWbemClassParameters * p) : CWbemSchemaClassInstanceWrapper(p)
        {
            m_pInClass = NULL;
            m_pOutClass = NULL;
        }
        ~CWbemSchemaProceduresInstanceWrapper() 
        {
            m_bstrCurrentMethodName.Clear();
            SAFE_RELEASE_PTR(m_pInClass);
            SAFE_RELEASE_PTR(m_pOutClass);
        }
        HRESULT GetKey(CBSTR & Key);
        HRESULT GetSchemaProperty(WCHAR * wcsProperty, VARIANT * v, CIMTYPE * pType , LONG * plFlavor );
        void SetMethodName(WCHAR * Method)         {  m_bstrCurrentMethodName.Clear(); m_bstrCurrentMethodName.SetStr(Method);}
        void SetInputClass(IWbemClassObject * p)   {  SAFE_RELEASE_PTR(m_pInClass);  m_pInClass = p;  if( p ) m_pInClass->AddRef(); }
        void SetOutputClass(IWbemClassObject * p)  {  SAFE_RELEASE_PTR(m_pOutClass); m_pOutClass = p; if( p ) m_pOutClass->AddRef(); }
};

class CWbemSchemaProceduresInstanceList: public CWbemSchemaInstanceList
{
    protected:
        CBSTR m_bstrCurrentMethodName;
        IWbemClassObject * m_pCurrentMethodClass;
        IWbemClassObject * m_pCurrentMethodInClass;
        IWbemClassObject * m_pCurrentMethodOutClass;
        BOOL m_fContinueWithSameClass;
        HRESULT GetSpecificNextInstance();

    public:
        CWbemSchemaProceduresInstanceList(CWbemClassParameters * p,WCHAR * pSpecific) : CWbemSchemaInstanceList(p, pSpecific) 
        {
            m_nBaseType = PROCEDURES_ROWSET; 
            m_fContinueWithSameClass = FALSE;
            m_pCurrentMethodClass = NULL;
            m_pCurrentMethodInClass = NULL;
            m_pCurrentMethodOutClass = NULL;
         }
        ~CWbemSchemaProceduresInstanceList() 
        {
            SAFE_RELEASE_PTR(m_pCurrentMethodClass);
            SAFE_RELEASE_PTR(m_pCurrentMethodInClass);
            SAFE_RELEASE_PTR(m_pCurrentMethodOutClass);
            ResetMethodPtrs();
        }
        HRESULT GetTheNextClassThatHasMethods();
        HRESULT Reset();
        HRESULT NextInstance( CBSTR & Key, CWbemClassInstanceWrapper ** pInst  );
        void ResetMethodPtrs();
};

//////////////////////////////////////////////////////////////////////////////////////////////
//********************************************************************************************
//
//  Classes for the Procedure Parameters schema rowset
//
//********************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////
class CWbemSchemaProceduresParametersClassDefinitionWrapper : public CWbemSchemaClassDefinitionWrapper 
{
    private:

    public:
        CWbemSchemaProceduresParametersClassDefinitionWrapper(CWbemClassParameters * p);
        ~CWbemSchemaProceduresParametersClassDefinitionWrapper() {}
        HRESULT GetNextProperty(BSTR * pProperty, VARIANT * vValue,CIMTYPE * pType , LONG * plFlavor );
};

class CWbemSchemaProceduresParametersInstanceWrapper: public CWbemSchemaProceduresInstanceWrapper 
{
    protected:
        CVARIANT  m_vProperty;
        short     m_nOrdinal;
        CBSTR     m_bstrPropertyName;

    public:
        CWbemSchemaProceduresParametersInstanceWrapper(CWbemClassParameters * p) : CWbemSchemaProceduresInstanceWrapper(p)
        { 
            m_nOrdinal = 0;
        }
        ~CWbemSchemaProceduresParametersInstanceWrapper() 
        {
            m_bstrPropertyName.Clear();
        }
        HRESULT GetSchemaProperty(WCHAR * wcsProperty, VARIANT * v, CIMTYPE * pType , LONG * plFlavor );
        HRESULT GetPropertyQualifier(WCHAR * wcsQualifier,VARIANT * v);
        
        void SetPropertyName(WCHAR * Name)   {  m_bstrPropertyName.Clear();  m_bstrPropertyName.SetStr(Name);}
        void SetProperty(CVARIANT v)         {  m_vProperty = v;}
        void SetOrdinal(short n)             {  m_nOrdinal = n; }
        HRESULT GetKey(CBSTR & Key);
};

class CWbemSchemaProceduresParametersInstanceList : public CWbemSchemaProceduresInstanceList
{
    private:
        BOOL m_fStillWorkingOnTheSameClass;
        short m_nOrdinal;
        CBSTR m_bstrPropertyName;
        CVARIANT m_vProperty;

    public:
        CWbemSchemaProceduresParametersInstanceList(CWbemClassParameters * p,WCHAR * pSpecific) : CWbemSchemaProceduresInstanceList(p, pSpecific) 
        {  
            m_nBaseType = PROCEDURE_PARAMETERS_ROWSET;
            m_fStillWorkingOnTheSameClass = FALSE;
            m_nOrdinal = 0;
        }

        ~CWbemSchemaProceduresParametersInstanceList() 
        {
            m_bstrPropertyName.Clear();
        }
        HRESULT NextInstance( CBSTR & Key, CWbemClassInstanceWrapper ** pInst  );
        HRESULT GetTheNextParameter();
        HRESULT GetTheNextClassThatHasParameters();

};


#endif	// __SCHEMA_INCL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\urlparser.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// URLPARSER.cpp: implementation of the CURLParser class.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"

/////////////////////////////////////////////////////////////////////////////////
// Some markers used
/////////////////////////////////////////////////////////////////////////////////
WCHAR DBInitDelimBegin[]	= L"::[";
WCHAR DBInitDelimEnd[]		= L"]";
WCHAR StrKeyEnd[]			= L"\"";
WCHAR EmbededPropDelim[]	= L"#";
WCHAR EmbededInstNumDelim[]	= L":=";
WCHAR BACKSLASH[]			= L"\\";
WCHAR DOT[]					= L".";


#define MAXCHILDINDEX_SIZE		10

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CURLParser::CURLParser()
{

	m_strURL				= Wmioledb_SysAllocString(NULL);
	m_strNameSpace			= Wmioledb_SysAllocString(NULL);		
	m_strClassName			= Wmioledb_SysAllocString(NULL);
	m_strPath				= Wmioledb_SysAllocString(NULL);
	m_strEmbededPropName	= Wmioledb_SysAllocString(NULL);
	m_lURLType				= -1;
	m_nEmbededChildIndex	= -1;

	m_bAllPropsInSync	= FALSE;
	m_bURLInitialized	= FALSE;
	m_strInitProps		= Wmioledb_SysAllocString(NULL);
	m_pIPathParser		= NULL;

}


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CURLParser::~CURLParser()
{
	// Free all the strings
	SAFE_FREE_SYSSTRING(m_strURL);
	SAFE_FREE_SYSSTRING(m_strNameSpace);
	SAFE_FREE_SYSSTRING(m_strClassName);
	SAFE_FREE_SYSSTRING(m_strEmbededPropName);
	SAFE_FREE_SYSSTRING(m_strInitProps);

	SAFE_DELETE_PTR(m_pIPathParser);
}


//////////////////////////////////////////////////////////////////////
// Function to the get the Name space
//////////////////////////////////////////////////////////////////////
HRESULT CURLParser::GetNameSpace(BSTR & strNameSpace)
{
	HRESULT hr = E_FAIL;
	// if initialized
	if(m_bURLInitialized)
	{
		hr = m_pIPathParser->GetNameSpace(strNameSpace);
	}
	
	return hr;
}


//////////////////////////////////////////////////////////////////////
// Function to the Get the classname
// The string will be freed by the calling application
//////////////////////////////////////////////////////////////////////
HRESULT CURLParser::GetClassName(BSTR &strClassName)
{

	HRESULT hr = E_FAIL;
	// if parser initialized
	if(m_bURLInitialized)
	{
		// NTRaid : 134967
		// 07/12/00
		if(!(m_strURL != NULL && IsValidURL(m_strURL) == RELATIVEURL))
		{
			hr = m_pIPathParser->GetClassName(strClassName);
		}
	}
	return hr;
}


//////////////////////////////////////////////////////////////////////
// Function to the set the Path // corresponds to PATH
//////////////////////////////////////////////////////////////////////
HRESULT CURLParser::SetPath(BSTR strPath)
{
	HRESULT hr			= E_FAIL;
	WCHAR *	pstrPath	= NULL;
	int		nMemToAlloc = 0;
	
	// if parser initialized
	if(!m_bURLInitialized)
	{
		hr = S_OK;
		nMemToAlloc = SysStringLen(strPath);
		nMemToAlloc = (nMemToAlloc + 1) * sizeof(WCHAR);

		pstrPath = new WCHAR[ nMemToAlloc];

		if(pstrPath)
		{

			memset(pstrPath,0,nMemToAlloc);
			memcpy(pstrPath,strPath,SysStringLen(strPath) * sizeof(WCHAR));
			
			// Seperate the embededInstances parameters if any
			GetEmbededInstanceParameters(pstrPath);

			// if the underlying parser object is not instantiated
			// then instantiate the appropriate object
			if(!m_pIPathParser)
			{
				hr = Initialize(pstrPath);
			}

			if(SUCCEEDED(hr))
			{
				m_bAllPropsInSync	= TRUE;			
				hr = m_pIPathParser->SetPath(pstrPath);
				m_bURLInitialized = TRUE;
			}

		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	SAFE_DELETE_ARRAY(pstrPath);
	return hr;
}


//////////////////////////////////////////////////////////////////////
// Function to the get the Path // corresponds to PATH
//////////////////////////////////////////////////////////////////////
HRESULT CURLParser::GetPath(BSTR &strPath)
{

	HRESULT hr = E_FAIL;
	// NTRaid : 134967
	// 07/12/00
	if(m_strURL != NULL && IsValidURL(m_strURL) == RELATIVEURL)
	{
		strPath = Wmioledb_SysAllocString(m_strURL);
		hr = S_OK;
	}
	else
	// if initialized
	if(m_bURLInitialized)
	{
		hr = m_pIPathParser->GetPath(strPath);
	}
	return hr;
}


//////////////////////////////////////////////////////////////////////
// Function to the get the Path with the embeded inst info
//////////////////////////////////////////////////////////////////////
HRESULT CURLParser::GetPathWithEmbededInstInfo(BSTR &strPath)
{
	WCHAR *	pstrTemp = NULL;
	WCHAR	strIndex[MAXCHILDINDEX_SIZE];
	LONG	cLen = 0;
	BSTR	strTemp	 = NULL;
	HRESULT hr = E_FAIL;

	// if  parser initialized
	if(m_bURLInitialized)
	{
		hr = S_OK;
		memset(strIndex,0,sizeof(WCHAR) * MAXCHILDINDEX_SIZE);

		if(SUCCEEDED(hr = GetPath(strTemp)))
		{
			// Frame the the string
			// Initially get the length of the string to be allocated
			cLen = wcslen(strTemp);
			_itow(m_nEmbededChildIndex,strIndex,10);

			if( m_lURLType == URL_EMBEDEDCLASS)
			{
				cLen += wcslen(EmbededPropDelim) + wcslen(m_strEmbededPropName);

				if(m_nEmbededChildIndex >= 0)
				{
					cLen += wcslen(EmbededInstNumDelim) + wcslen(strIndex);
				}
			}
			cLen++;

			pstrTemp = new WCHAR[cLen];
			
			if(pstrTemp != NULL)
			{		
				memset(pstrTemp,0,sizeof(WCHAR) * cLen);

				// Copy the string
				wcscpy(pstrTemp,strTemp);

				if( m_lURLType == URL_EMBEDEDCLASS)
				{
					wcscat(pstrTemp,EmbededPropDelim);
					wcscat(pstrTemp,m_strEmbededPropName);

					// If the property is array of embeded instance
					if( m_nEmbededChildIndex >=0)
					{
						wcscat(pstrTemp,EmbededInstNumDelim);
						wcscat(pstrTemp,strIndex);
					}
				}

				strPath = Wmioledb_SysAllocString(pstrTemp);
				SAFE_DELETE_ARRAY(pstrTemp);
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
			SAFE_FREE_SYSSTRING(strTemp);
		}
	}
	return hr;

}

//////////////////////////////////////////////////////////////////////
// Function to the set the URL string
//////////////////////////////////////////////////////////////////////
HRESULT CURLParser::SetURL(BSTR strURL)
{
	HRESULT hr = S_OK;

	// if already not initialized
	if(!m_bURLInitialized)
	{

		hr = InitializeParserForURL(strURL);

		if(SUCCEEDED(hr))
		{
			m_bURLInitialized = TRUE;
		}
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Function to the get the URL string
//////////////////////////////////////////////////////////////////////
HRESULT CURLParser::GetURL(BSTR &strURL)
{
	HRESULT hr = E_FAIL;
	// NTRaid : 134967
	// 07/12/00
	if(m_strURL != NULL && IsValidURL(m_strURL) == RELATIVEURL)
	{
		strURL = Wmioledb_SysAllocString(m_strURL);
		hr = S_OK;
	}
	else
	// if already initialized
	if(m_bURLInitialized)
	{
		hr = GetURLString(strURL);
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Function to the set embeded instance information for the URL
//////////////////////////////////////////////////////////////////////
void CURLParser::SetEmbededInstInfo(BSTR strProperty,int nIndex)
{
	BOOL bRet = FALSE;
	WCHAR *pstrPropName = NULL;

	pstrPropName = new WCHAR [SysStringLen(strProperty) + 1];

	if(pstrPropName != NULL)
	{
		wcscpy(pstrPropName,strProperty);

		_wcsupr(pstrPropName);

		m_nEmbededChildIndex = nIndex;
		if(m_strEmbededPropName != NULL)
		{
			SysFreeString(m_strEmbededPropName);
		}

		m_strEmbededPropName = Wmioledb_SysAllocString(pstrPropName);

		SAFE_DELETE_ARRAY(pstrPropName);

		m_lURLType			= URL_EMBEDEDCLASS;	
	}
}

//////////////////////////////////////////////////////////////////////
// Function to the get embeded instance information from the URL
//////////////////////////////////////////////////////////////////////
void CURLParser::GetEmbededInstInfo(BSTR &strProperty,int &nIndex)
{
	nIndex = -1;
	strProperty = Wmioledb_SysAllocString(NULL);
	m_bAllPropsInSync = TRUE;
	if( m_lURLType == URL_EMBEDEDCLASS)
	{
		strProperty = Wmioledb_SysAllocString(m_strEmbededPropName);
		nIndex		= m_nEmbededChildIndex;
	}
}

//////////////////////////////////////////////////////////////////////
// Function which extracts the Initialiazation properties from URL
//////////////////////////////////////////////////////////////////////
void CURLParser::GetInitializationProps(WCHAR *pStrIn)
{
	WCHAR *		pStrTemp		= NULL;
	WCHAR *		pStrTemp1		= NULL;
	WCHAR *		pStrInitProps	= NULL;
	ULONG_PTR	cStrLenToCpy	= 0;

	_wcsrev(pStrIn);

	pStrTemp = wcsstr(pStrIn ,_wcsrev(DBInitDelimBegin));
	pStrTemp1 = wcsstr(pStrIn ,StrKeyEnd );

	if(!( pStrTemp == NULL || pStrTemp1 == NULL))
	{
		// reversing back again
		_wcsrev(DBInitDelimBegin);

		if(pStrTemp1 > pStrTemp && pStrTemp != NULL)
		{
			cStrLenToCpy = pStrTemp - pStrIn  + 1 - wcslen(DBInitDelimEnd);
			
			pStrInitProps = new WCHAR[ cStrLenToCpy];

			if(pStrInitProps != NULL)
			{

				memset(pStrInitProps , 0 , cStrLenToCpy * sizeof(WCHAR));
				memcpy( pStrInitProps , pStrIn + wcslen(DBInitDelimEnd) , (cStrLenToCpy -1) * sizeof(WCHAR));
				_wcsrev(pStrInitProps);

				m_strInitProps = Wmioledb_SysAllocString(pStrInitProps);

				pStrInitProps = NULL;

				pStrTemp += wcslen(DBInitDelimBegin);
				_wcsrev(pStrTemp);
				wcscpy(pStrIn,pStrTemp);
			}
		}
	}
	else
	{
		_wcsrev(pStrIn);
	}
	SAFE_DELETE_ARRAY(pStrInitProps);

}

//////////////////////////////////////////////////////////////////////
// Function which frames the URL string from the other properties
//////////////////////////////////////////////////////////////////////
HRESULT CURLParser::GetURLString(BSTR &strURL)
{
	WCHAR *	pStrURL			= NULL;
	WCHAR *	pStrTemp		= NULL;
	LONG	lSizeToAlloc	= 0;
	BOOL	bDefaultServer	= FALSE;
	WCHAR *	strIndex		= NULL;
	LONG	lUrlFormat		= 0;
	HRESULT hr				= S_OK;

	if(m_bURLInitialized)
	{
		if(m_strURL != NULL)
		{
			SysFreeString(m_strURL);
		}

		CBSTR strPath;
		HRESULT hr  = S_OK;
		
		if(SUCCEEDED(hr = GetPath((BSTR &)strPath)))
		{
			lUrlFormat = IsValidURL(strPath);
			lSizeToAlloc += (SysStringLen(strPath) * sizeof(WCHAR));

			if(lUrlFormat != UMIURL)
			{
				// Get the size of the URL 
				lSizeToAlloc += wcslen(WMIURLPREFIX) ;
			}

			if( m_lURLType == URL_EMBEDEDCLASS)
			{
				strIndex = new WCHAR[MAXCHILDINDEX_SIZE];

				if( strIndex == NULL)
				{
					hr = E_OUTOFMEMORY;
				}
				else
				{
					_itow(m_nEmbededChildIndex,strIndex,10);
					lSizeToAlloc += wcslen(EmbededPropDelim) + wcslen(m_strEmbededPropName);				
					// If the property is array of embeded instance
					if( m_nEmbededChildIndex >= 0)
					{
						lSizeToAlloc += wcslen(EmbededInstNumDelim) + wcslen(strIndex);
					}
				}
			}

			if(SUCCEEDED(hr))
			{

				// Adding for the NULL termination
				lSizeToAlloc += sizeof(WCHAR);

				pStrURL = new WCHAR [lSizeToAlloc];

				if( pStrURL != NULL)
				{
					if(lUrlFormat != UMIURL)
					{
						// frame the URL
						wcscpy(pStrURL,WMIURLPREFIX);
						wcscat(pStrURL,strPath);
					}
					else
					{
						wcscpy(pStrURL,strPath);
					}

					if( m_lURLType == URL_EMBEDEDCLASS)
					{
						wcscat(pStrURL,EmbededPropDelim);
						wcscat(pStrURL,m_strEmbededPropName);

						// If the property is array of embeded instance
						if( m_nEmbededChildIndex >=0)
						{
							wcscat(pStrURL,EmbededInstNumDelim);
							wcscat(pStrURL,strIndex);
						}

					}
					strURL = Wmioledb_SysAllocString(pStrURL);
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}

			}
		}
		// NTRaid: 136439
		// 07/05/00
		SAFE_DELETE_ARRAY(pStrURL)
		SAFE_DELETE_ARRAY(strIndex)
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////
// Get the type of object which is represented by URL
//////////////////////////////////////////////////////////////////////
LONG CURLParser::GetURLType()
{
	
	// NTRaid : 134967
	// 07/12/00
	if(!(m_strURL != NULL && IsValidURL(m_strURL) == RELATIVEURL)
	 && m_lURLType != URL_EMBEDEDCLASS)
	{
		m_lURLType = -1;
		// if already initialized
		if(m_bURLInitialized)
		{
			m_lURLType = m_pIPathParser->GetURLType();
		}
	}
	return m_lURLType;
}

/*
//////////////////////////////////////////////////////////////////////
// Get the path of the object from URL
//////////////////////////////////////////////////////////////////////
void CURLParser::GetPathFromURLString(WCHAR  * & pStrIn)
{
	WCHAR *pStrTemp = NULL;

	if( m_strPath != NULL)
	{
		SysFreeString(m_strPath);
		m_strPath = Wmioledb_SysAllocString(NULL);
	}

	// If there is default server then there will be no server name in the URL
	if(NULL != wcsstr(pStrIn , DefaultServer))
	{
		pStrTemp	= pStrIn + wcslen(DefaultServer);
		m_strPath	= Wmioledb_SysAllocString(pStrTemp);
		pStrIn		= pStrTemp;
	}
	else
	{
		// put the path in the member variable
		m_strPath = Wmioledb_SysAllocString(pStrIn);
	}

	HRESULT hr = m_pIPathParser->SetPath(m_strPath);
	
}

*/

//////////////////////////////////////////////////////////////////////
// Seperate the embededInstances parameters if any
//////////////////////////////////////////////////////////////////////
void CURLParser::GetEmbededInstanceParameters(WCHAR  * & pStrIn)
{
	WCHAR *pStrTemp		= NULL;
	WCHAR *pStrPropName = NULL;
	WCHAR *pStrIndex	= NULL;
	LONG   lPropNameLen = 0;

	pStrTemp = wcsstr(pStrIn,EmbededPropDelim);

	if(pStrTemp != NULL)
	{
		lPropNameLen = wcslen(pStrTemp) - wcslen(EmbededPropDelim);
		
		pStrIndex = wcsstr(pStrTemp,EmbededInstNumDelim);
		if(pStrIndex != NULL)
		{
			lPropNameLen -=  wcslen(pStrIndex);
			m_nEmbededChildIndex = _wtoi(pStrIndex + wcslen(EmbededInstNumDelim));
			// Terminate the string
			*pStrIndex = '\0';
		}
		lPropNameLen++;
		
		pStrPropName  = new WCHAR[lPropNameLen];

		if(pStrPropName != NULL)
		{
			wcscpy(pStrPropName,pStrTemp + wcslen(EmbededPropDelim));

			// Terminate the string
			*pStrTemp = '\0';
			m_lURLType		= URL_EMBEDEDCLASS;	
			
			if(m_strEmbededPropName)
			{
				SysFreeString(m_strEmbededPropName);
			}
			m_strEmbededPropName = Wmioledb_SysAllocString(pStrPropName);
		}
	}
	else
	{
		m_lURLType		= -1;
	}
	SAFE_DELETE_ARRAY(pStrPropName);
}

//////////////////////////////////////////////////////////////////////
// Initialize the URL of the parser
//////////////////////////////////////////////////////////////////////
HRESULT CURLParser::InitializeParserForURL(BSTR strURL)
{
	
	WCHAR *	pstrPath	= NULL;
	WCHAR *	pTempStr	= NULL;
	HRESULT hr			= E_FAIL;
	LONG	lUrlFormat	= 0;

	// check if the URL is valid and get the format ( umi or wmi url) of the url
	lUrlFormat = IsValidURL(strURL);
	
	// NTRaid : 134967
	// 07/12/00
	if(lUrlFormat == RELATIVEURL)
	{
		m_strURL = Wmioledb_SysAllocString(strURL);
		m_lURLType =  URL_ROW;
		hr = S_OK;
	}
	else
	if(lUrlFormat > 0)
	{
		hr = S_OK;
		// Get the length of the prefix of the URL
		// before the path
		pstrPath = new WCHAR[wcslen((WCHAR *)strURL) + 1];

		if(pstrPath != NULL)
		{
			pTempStr = (WCHAR *)strURL;
			// if URL is of WMI format then remove the prefix "Winmgmts:"
			if(lUrlFormat == WMIURL)
			{
				pTempStr += wcslen(WMIURLPREFIX);
			}

			wcscpy(pstrPath,pTempStr);

			pTempStr = pstrPath;

			// Seperate the initialization properties if any
			GetInitializationProps(pstrPath);

			// Seperate the embededInstances parameters if any
			GetEmbededInstanceParameters(pstrPath);

			// if the underlying parser object is not instantiated
			// then instantiate the appropriate object
			if(!m_pIPathParser)
			{
				hr = Initialize(pstrPath);
			}

			if(SUCCEEDED(hr))
			{
				// Separate the path string
//				GetPathFromURLString(pstrPath);	
				hr = m_pIPathParser->SetPath(pstrPath);
			}

			SAFE_DELETE_ARRAY(pTempStr);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Get key value for a particular key in the path
////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CURLParser::GetKeyValue(BSTR strKey,VARIANT &varValue)
{
	HRESULT hr = E_FAIL;
	// if already initialized
	if(m_bURLInitialized)
	{
		hr = m_pIPathParser->GetKeyValue(strKey,varValue);
	}

	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to instantiate a appropriate parser object
////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CURLParser::Initialize(WCHAR *pStrPath)
{
	HRESULT hr  = S_OK;

	if(wbem_wcsincmp(pStrPath,UMIURLPREFIX,wcslen(UMIURLPREFIX)))
	{
		m_pIPathParser = new CWBEMPathParser;
	}
	else
	{
		m_pIPathParser = new CUMIPathParser;
	}

	if(m_pIPathParser == NULL)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		hr = m_pIPathParser->Initialize();
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to clear all the member variables
////////////////////////////////////////////////////////////////////////////////////////////////////
void CURLParser::ClearParser()
{
	SAFE_FREE_SYSSTRING(m_strURL);
	SAFE_FREE_SYSSTRING(m_strNameSpace);
	SAFE_FREE_SYSSTRING(m_strClassName);
	SAFE_FREE_SYSSTRING(m_strEmbededPropName);
	SAFE_FREE_SYSSTRING(m_strInitProps);

	m_lURLType				= -1;
	m_nEmbededChildIndex	= -1;

	m_bAllPropsInSync	= FALSE;
	m_bURLInitialized	= FALSE;

	if(m_pIPathParser)
	{
		m_pIPathParser->SetPath(L"");
	}

}


////////////////////////////////////////////////////////////////////////////////////////////////////
// function which gets the parent namespace and the namespace
////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CURLParser::ParseNameSpace(BSTR & strParentNameSpace,BSTR &strNameSpace)
{
	return m_pIPathParser->ParseNameSpace(strParentNameSpace,strNameSpace);
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Function which checks if the URL is valid and also returns the format of the URL ( UMI or WMI)
////////////////////////////////////////////////////////////////////////////////////////////////////
LONG CURLParser::IsValidURL(WCHAR *pStrUrl)
{
	long lRet = RELATIVEURL;

	if(wbem_wcsincmp(pStrUrl,UMIURLPREFIX,wcslen(UMIURLPREFIX)) == 0)
	{
		lRet = UMIURL;
	}
	else
	if(wbem_wcsincmp(pStrUrl,WMIURLPREFIX,wcslen(WMIURLPREFIX)) == 0)
	{
		lRet = WMIURL;
	}

	return lRet;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//		CWBEMPathParser class implementation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWBEMPathParser::CWBEMPathParser()
{
	m_pIWbemPath = NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Destructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWBEMPathParser::~CWBEMPathParser()
{
	SAFE_RELEASE_PTR(m_pIWbemPath);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Initialization function
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWBEMPathParser::Initialize()
{
	HRESULT hr		= S_OK;

	if(!g_pIWbemPathParser)
	{
		hr = CoGetClassObject(CLSID_WbemDefPath,CLSCTX_INPROC_SERVER,NULL,IID_IClassFactory,(LPVOID *)&g_pIWbemPathParser);
	}

	if(SUCCEEDED(hr))
	{
		if(SUCCEEDED(hr = g_pIWbemPathParser->CreateInstance(NULL,IID_IWbemPath,(LPVOID *)&m_pIWbemPath)))
		{
			hr = g_pIWbemPathParser->LockServer(TRUE);
		}
	}
		
	return hr;

}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the namespace of from the parser
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWBEMPathParser::GetNameSpace(BSTR &strNameSpace)
{
	HRESULT hr = S_OK;
	WCHAR	wstrNameSpace[PATH_MAXLENGTH];
	ULONG	lBuffLen	= PATH_MAXLENGTH;

	memset(wstrNameSpace,0,PATH_MAXLENGTH *sizeof(WCHAR));

	if(SUCCEEDED(hr = m_pIWbemPath->GetText(WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY,&lBuffLen,wstrNameSpace)))
	{
		strNameSpace = Wmioledb_SysAllocString(wstrNameSpace);
	}
	return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the class name 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWBEMPathParser::GetClassName(BSTR &strClassName)
{
	WCHAR	wstrClassName[CLASSNAME_MAXLENGTH];
	HRESULT	hr			= S_OK;
	ULONG	lBuffLen	= CLASSNAME_MAXLENGTH;

	memset(wstrClassName,0,CLASSNAME_MAXLENGTH * sizeof(WCHAR));

	if(SUCCEEDED(hr = m_pIWbemPath->GetClassName(&lBuffLen,wstrClassName)))
	{
		strClassName = Wmioledb_SysAllocString(wstrClassName);
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set the path
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWBEMPathParser::SetPath(WCHAR * pwcsPath)
{
	return m_pIWbemPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,pwcsPath);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get the path
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWBEMPathParser::GetPath(BSTR &strPath)
{
	HRESULT hr = S_OK;
	WCHAR	wstrPath[PATH_MAXLENGTH];
	ULONG	lBuffLen	= PATH_MAXLENGTH;

	memset(wstrPath,0,PATH_MAXLENGTH *sizeof(WCHAR));

	if(SUCCEEDED(hr = m_pIWbemPath->GetText(WBEMPATH_GET_SERVER_TOO,&lBuffLen,wstrPath)))
	{
		strPath = Wmioledb_SysAllocString(wstrPath);
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the type of the URL
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
LONG	CWBEMPathParser::GetURLType()
{
	LONG		lRet	= -1;
	ULONGLONG	lType	= 0;

	if( lRet != URL_EMBEDEDCLASS)
	{
		HRESULT hr = m_pIWbemPath->GetInfo(0,&lType);

		if(lType & WBEMPATH_INFO_IS_CLASS_REF)
		{
			lRet = URL_ROWSET;
		}
		else
		if(lRet & WBEMPATH_INFO_IS_INST_REF)
		{
			lRet = URL_ROW;
		}
		else
		{
			lRet = URL_DATASOURCE;
		}
	}

	return lRet;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the key value of a particular key in the path
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWBEMPathParser::GetKeyValue(BSTR strKey, VARIANT &varValue)
{
	IWbemPathKeyList *	pKeyList		= NULL;
	BOOL				bFound			= FALSE;
	ULONG				lKeyCount		= 0;
	ULONG				lNameBufSize	= KEYNAME_MAXLENGTH * sizeof(WCHAR);
	ULONG				lValBuffSize	= 0;
	ULONG				lCimType		= 0;
	HRESULT				hr				= S_OK;

	if(SUCCEEDED(hr = m_pIWbemPath->GetKeyList(&pKeyList)))
	{
		if(SUCCEEDED(hr = pKeyList->GetCount(&lKeyCount)))
		{
			WCHAR strKeyName[KEYNAME_MAXLENGTH];
			memset(strKeyName,0,KEYNAME_MAXLENGTH * sizeof(WCHAR));
			for(ULONG lIndex=0 ; lIndex < lKeyCount ; lIndex++)
			{
				lValBuffSize = 0;
				if(FAILED(hr = pKeyList->GetKey(lIndex,
												 0,
												 &lNameBufSize,
												 strKeyName,
												 &lValBuffSize,
												 NULL,
												 NULL)))
				{
					break;
				}

				// if the required key is found then
				// get the value
				if(!wbem_wcsicmp(strKeyName,strKey))
				{
					lNameBufSize = 0;
					lValBuffSize = sizeof(VARIANT);
					if(SUCCEEDED(hr = pKeyList->GetKey2(lIndex,
											 0,
											 &lNameBufSize,
											 NULL,
											 &varValue,
											 &lCimType)))
					{

						bFound = TRUE;
						break;
					}
					
				}
				else
				{
					wcscpy(strKeyName,L"");
				}
			}
			if(SUCCEEDED(hr) && bFound == FALSE)
			{
				hr = E_FAIL;
			}
		}
	}


	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// function which gets the parent namespace and the namespace
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWBEMPathParser::ParseNameSpace(BSTR & strParentNameSpace,BSTR &strNameSpace)
{
	HRESULT hr = S_OK;
	WCHAR	wstrNameSpace[PATH_MAXLENGTH];
	ULONG	lTemp		= PATH_MAXLENGTH;
	ULONG	lLocal		= 0;
	WCHAR *	pTempStr	= &wstrNameSpace[0];
	ULONG	ulCount		= 0;

	memset(wstrNameSpace,0,PATH_MAXLENGTH *sizeof(WCHAR));

	if(SUCCEEDED(hr =m_pIWbemPath->GetNamespaceCount(&ulCount)))
	{
		if(ulCount >= 2)
		{
			if(SUCCEEDED(hr = m_pIWbemPath->GetServer(&lTemp,wstrNameSpace)))
			{
				if(wcscmp(wstrNameSpace , DOT) == 0)
				{
					wcscpy(wstrNameSpace , L"\\\\.");
				}
				pTempStr += wcslen(wstrNameSpace) ;
				pTempStr =	&wstrNameSpace[0] + wcslen(wstrNameSpace);

				for(ULONG lIndex = 0 ; lIndex < ulCount -1  ; lIndex++)
				{
					wcscat(pTempStr , BACKSLASH);
					lLocal		= PATH_MAXLENGTH - wcslen(wstrNameSpace);
					pTempStr	= &wstrNameSpace[0] + wcslen(wstrNameSpace);

					if(FAILED(hr = m_pIWbemPath->GetNamespaceAt(lIndex, &lLocal,pTempStr)))
					{
						break;
					}

				}
			}
		}
		else
		{
			hr = E_FAIL;
		}
	}

	if(SUCCEEDED(hr))
	{
		strParentNameSpace = Wmioledb_SysAllocString(wstrNameSpace);

		wcscpy(wstrNameSpace , L"");
		lLocal		= PATH_MAXLENGTH;
		pTempStr	= &wstrNameSpace[0];
		if(FAILED(hr = m_pIWbemPath->GetNamespaceAt(ulCount-1, &lLocal,pTempStr)))
		{
			SysFreeString(strParentNameSpace);
		}
		else
		{
			strNameSpace = Wmioledb_SysAllocString(wstrNameSpace);
		}
	}

	return hr;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//		CUMIPathParser class implementation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// COnsturctor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CUMIPathParser::CUMIPathParser()
{
	m_pIUmiPath = NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Destructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CUMIPathParser::~CUMIPathParser()
{
	SAFE_RELEASE_PTR(m_pIUmiPath);
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Initialization function
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CUMIPathParser::Initialize()
{
	HRESULT hr		= S_OK;

	if(!g_pIWbemPathParser)
	{
		hr = CoGetClassObject(CLSID_WbemDefPath,CLSCTX_INPROC_SERVER,NULL,IID_IClassFactory,(LPVOID *)&g_pIWbemPathParser);
	}

	if(SUCCEEDED(hr))
	{
		if(SUCCEEDED(hr = g_pIWbemPathParser->CreateInstance(NULL,IID_IUmiURL,(LPVOID *)&m_pIUmiPath)))
		{
			hr = g_pIWbemPathParser->LockServer(TRUE);
		}
	}
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the namespace to connect
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CUMIPathParser::GetNameSpace(BSTR &strNameSpace)
{
	WCHAR	wstrNamespace[PATH_MAXLENGTH];
	HRESULT	hr			= S_OK;
	ULONG	lBuffLen	= PATH_MAXLENGTH * sizeof(WCHAR);
	
	memset(wstrNamespace,0,lBuffLen);

	hr = m_pIUmiPath->Get(UMIPATH_CREATE_AS_EITHER,&lBuffLen,wstrNamespace);
	strNameSpace = Wmioledb_SysAllocString(wstrNamespace);

	/*
	WCHAR	wstrLocator[PATH_MAXLENGTH];
	WCHAR	wstrName[PATH_MAXLENGTH];
	WCHAR	wstrRoot[PATH_MAXLENGTH];
	ULONG	lBuffLen	= PATH_MAXLENGTH;
	IUmiURLKeyList *pKeyList = NULL;
	ULONG lCnt = 0;
	lBuffLen	= PATH_MAXLENGTH * sizeof(WCHAR);

	lBuffLen	= PATH_MAXLENGTH;
	
	memset(wstrLocator,0,PATH_MAXLENGTH *sizeof(WCHAR));
	memset(wstrName,0,PATH_MAXLENGTH *sizeof(WCHAR));
	memset(wstrRoot,0,PATH_MAXLENGTH *sizeof(WCHAR));
	hr = m_pIUmiPath->GetComponentCount(&lCnt);

	if(SUCCEEDED(hr = m_pIUmiPath->GetLocator(&lBuffLen,wstrLocator)))
	{
		lBuffLen = PATH_MAXLENGTH;
		if(SUCCEEDED(hr = m_pIUmiPath->GetRootNamespace(&lBuffLen,wstrRoot)))
		{
			// If there is no component then the the namespace can
			// be obtained from GetLeafName method
			lBuffLen = PATH_MAXLENGTH;
			if(lCnt >0)
			{
				hr = m_pIUmiPath->GetComponent(0,&lBuffLen,wstrName,&pKeyList);
			}
			else
			{
				hr = m_pIUmiPath->GetLeafName(&lBuffLen,wstrName);
			}
			if(SUCCEEDED(hr))
			{
				WCHAR *pTemp = NULL;
				lBuffLen = wcslen(UMIATORPREFIX) + 
							wcslen(wstrLocator) + wcslen(UMISEPARATOR) +
							wcslen(wstrRoot) + wcslen(UMISEPARATOR) +
							wcslen(wstrName) + + wcslen (UMIPREFIX) + 1;
				SAFE_RELEASE_PTR(pKeyList)
				try
				{
					pTemp = new WCHAR[lBuffLen];
				}
				catch(...)
				{
					SAFE_DELETE_ARRAY(pTemp);
					throw;
				}
				if(pTemp)
				{
					wcscpy(pTemp,UMIPREFIX);
					wcscat(pTemp,UMIATORPREFIX);
					wcscat(pTemp,wstrLocator);
					wcscat(pTemp,UMISEPARATOR);
					wcscat(pTemp,wstrRoot);
					if(wcslen(wstrName) != 0)
					{
						wcscat(pTemp,UMISEPARATOR);
						wcscat(pTemp,wstrName);
					}
					strNameSpace = Wmioledb_SysAllocString(pTemp);

					SAFE_DELETE_ARRAY(pTemp);
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
			}
		}
	}

*/
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the class name
// if the URL is pointing to a instance then this function fails as
// class name cannot be obtained from the URL
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CUMIPathParser::GetClassName(BSTR &strClassName)
{
	HRESULT	hr			= S_OK;

	if(GetURLType() == URL_ROWSET)
	{
		WCHAR	wstrClassName[CLASSNAME_MAXLENGTH];
		ULONG	lBuffLen	= CLASSNAME_MAXLENGTH;
		LONG	lUrlType	= -1;

		memset(wstrClassName,0,CLASSNAME_MAXLENGTH * sizeof(WCHAR));
		lUrlType = GetURLType();

		if(lUrlType == URL_ROW  || lUrlType == URL_ROWSET)
		if(SUCCEEDED(hr = m_pIUmiPath->GetLeafName(&lBuffLen,wstrClassName)))
		{
			strClassName = Wmioledb_SysAllocString(wstrClassName);
		}
	}
	else
	{
		hr = E_FAIL;
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to set the path
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CUMIPathParser::SetPath(WCHAR * pwcsPath)
{
	return m_pIUmiPath->Set(UMIPATH_CREATE_AS_EITHER,pwcsPath);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get the path
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CUMIPathParser::GetPath(BSTR &strPath)
{
	HRESULT hr = S_OK;
	WCHAR	wstrPath[PATH_MAXLENGTH];
	ULONG	lBuffLen	= PATH_MAXLENGTH;

	memset(wstrPath,0,PATH_MAXLENGTH *sizeof(WCHAR));

	if(SUCCEEDED(hr = m_pIUmiPath->Get(UMIPATH_CREATE_AS_EITHER,&lBuffLen,wstrPath)))
	{
		strPath = Wmioledb_SysAllocString(wstrPath);
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get type of the object the URL is representing
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
LONG	CUMIPathParser::GetURLType()
{
	LONG				lRet		= URL_DATASOURCE;
	ULONGLONG			lType		= 0;
	HRESULT				hr			= S_OK;

	if(SUCCEEDED(hr = m_pIUmiPath->GetPathInfo(0,&lType)))
	{
		if(UMIPATH_INFO_CLASS_PATH == lType)
		{
			lRet = URL_ROWSET;
		}
		else
		{
			lRet = URL_ROW;
		}
	}
	return lRet;

}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get a key value of a particular key in the path
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CUMIPathParser::GetKeyValue(BSTR strKey, VARIANT &varValue)
{
	HRESULT				hr				= S_OK;
	IUmiURLKeyList *	pKeyList		= NULL;
	BOOL				bFound			= FALSE;
	ULONG				lKeyCount		= 0;
	ULONG				lNameBufSize	= KEYNAME_MAXLENGTH * sizeof(WCHAR);
	ULONG				lValBuffSize	= 0;
	ULONG				lCimType		= 0;

	if(SUCCEEDED(hr = m_pIUmiPath->GetKeyList(&pKeyList)))
	{
		if(SUCCEEDED(hr = pKeyList->GetCount(&lKeyCount)) && lKeyCount > 0)
		{
			WCHAR strKeyName[KEYNAME_MAXLENGTH];
			WCHAR pChar[2048];
			memset(strKeyName,0,KEYNAME_MAXLENGTH * sizeof(WCHAR));
			for(ULONG lIndex=0 ; lIndex < lKeyCount ; lIndex++)
			{
				lValBuffSize = 0;
				if(FAILED(hr = pKeyList->GetKey(lIndex,
												 0,
												 &lNameBufSize,
												 strKeyName,
												 &lValBuffSize,
												 NULL)))
				{
					break;
				}

				// if the required key is found then
				// get the value
				if(!wbem_wcsicmp(strKeyName,strKey))
				{
					lNameBufSize = 0;
					lValBuffSize = sizeof(VARIANT);
					lValBuffSize = 2048;
					if(SUCCEEDED(hr = pKeyList->GetKey(lIndex,
											 0,
											 &lNameBufSize,
											 NULL,
											 &lValBuffSize,
											 pChar)))
					{
						bFound = TRUE;
						break;
					}
					
				}
				else
				{
					wcscpy(strKeyName,L"");
				}
			}
			if(SUCCEEDED(hr) && bFound == FALSE)
			{
				hr = E_FAIL;
			}
			
			if(SUCCEEDED(hr))
			{
				varValue.vt = VT_BSTR;
				varValue.bstrVal = SysAllocString(pChar);
			}

		}
		if(SUCCEEDED(hr) && lKeyCount == 0)
		{
			hr = E_FAIL;
		}
		SAFE_RELEASE_PTR(pKeyList);
	}


	return hr;
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// function which gets the parent namespace and the namespace
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CUMIPathParser::ParseNameSpace(BSTR & strParentNameSpace,BSTR &strNameSpace)
{
	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\util.h ===
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider 
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//  UTIL.h		- HEader file for utility functions
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _UTIL_HEADER
#define _UTIL_HEADER

class CWbemConnectionWrapper;

#define SAFE_DELETE_PTR(pv)  \
	{ if(pv) delete pv;  \
      pv = NULL; }

#define SAFE_RELEASE_PTR(pv)  \
    { if(pv){ pv->Release(); }  \
      pv = NULL; }

#define SAFE_DELETE_ARRAY(pv)  \
	{ if(pv) delete []pv;  \
      pv = NULL; }

#define SAFE_FREE_SYSSTRING(pv)  \
    { if(pv){ SysFreeString(pv);}  \
      pv = NULL; }

#define TRY_BLOCK	try	{

#define	CATCH_BLOCK_HRESULT(hr , str)	} \
    catch(CStructured_Exception e_SE) \
    { \
        hr = E_UNEXPECTED; \
		FormatAndLogMessage(L"%s: HEAP_EXCEPTION",str);	\
    } \
    catch(CHeap_Exception e_HE) \
    { \
		FormatAndLogMessage(L"%s: STRUCTURED_EXCEPTION",str);	\
        hr = E_OUTOFMEMORY; \
    } \
	catch(...) \
	{ \
		FormatAndLogMessage(L"%s: UNSPECIFIED_EXCEPTION",str);	\
        hr = E_UNEXPECTED; \
	} 

#define	CATCH_BLOCK_BOOL(bVal,str)	} \
    catch(CStructured_Exception e_SE) \
    { \
        bVal = FALSE; \
		FormatAndLogMessage(L"%s: HEAP_EXCEPTION",str);	\
    } \
    catch(CHeap_Exception e_HE) \
    { \
		FormatAndLogMessage(L"%s: STRUCTURED_EXCEPTION",str);	\
        bVal = FALSE; \
    } \
	catch(...) \
	{ \
		FormatAndLogMessage(L"%s: UNSPECIFIED_EXCEPTION",str);	\
        bVal = FALSE; \
	} 

BOOL UnicodeToAnsi(WCHAR * pszW, char *& pAnsi);
void AllocateAndConvertAnsiToUnicode(char * pstr, WCHAR *& pszW);

void TranslateAndLog( WCHAR * wcsMsg );
void LogMessage( char * szMsg );
void LogMessage( char * szMsg , HRESULT hr);
void LogMessage( WCHAR * szMsg );
void LogMessage( WCHAR * szMsg , HRESULT hr);
BOOL OnUnicodeSystem();
void FormatAndLogMessage( LPCWSTR pszFormatString,... );
BSTR Wmioledb_SysAllocString(const OLECHAR *  sz);
void GetInitAndBindFlagsFromBindFlags(DBBINDURLFLAG dwBindURLFlags,LONG & lInitMode ,LONG & lInitBindFlags);
int WMIOledb_LoadStringW(UINT nID, LPWSTR lpszBuf, UINT nMaxBuf);


int wbem_wcsicmp(const wchar_t* wsz1, const wchar_t* wsz2);
int wbem_wcsincmp(const wchar_t* wsz1, const wchar_t* wsz2,int nChars);

DWORD	GetImpLevel(DWORD dwImpPropVal);
DWORD	GetAuthnLevel(DWORD dwAuthnPropVal);
HRESULT InitializeConnectionProperties(CWbemConnectionWrapper *pConWrap,DBPROPSET*	prgPropertySets,BSTR strPath);
HRESULT GetClassName(CURLParser *pUrlParser,DBPROPSET*	prgPropertySets,BSTR &strClassName,CWbemConnectionWrapper *pConWrapper = NULL);
DBTYPE GetVBCompatibleAutomationType(DBTYPE dbInType);

class CTString
{
	TCHAR * m_pStr;
public:
	CTString();
	~CTString();
	HRESULT LoadStr(UINT lStrID);

	operator LPTSTR() { return m_pStr; }
//	operator LPCTSTR() { return (LPCTSTR)m_pStr; }

};


typedef enum FetchDir
{
	FETCHDIRNONE = -1,
	FETCHDIRFORWARD,
	FETCHDIRBACKWARD,
} FETCHDIRECTION;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\utilprop.h ===
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider 
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//	UtilProp.h	- Header file for classes for managing properties
/////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _UTILPROP_H_
#define _UTILPROP_H_

extern const GUID DBPROPSET_WMIOLEDB_DBINIT;
extern const GUID DBPROPSET_WMIOLEDB_ROWSET;
extern const GUID DBPROPSET_WMIOLEDB_COLUMN;
extern const GUID DBPROPSET_WMIOLEDB_COMMAND;



////////////////////////////////////////////////////////////////////////
// PRivileges property values
////////////////////////////////////////////////////////////////////////
#define DBPROPVAL_CREATE_TOKEN              0x01
#define DBPROPVAL_ASSIGNPRIMARYTOKEN        0x02
#define DBPROPVAL_LOCK_MEMORY               0x04
#define DBPROPVAL_INCREASE_QUOTA			0x08
#define DBPROPVAL_MACHINE_ACCOUNT           0x10
#define DBPROPVAL_TCB                       0x20
#define DBPROPVAL_SECURITY                  0x40
#define DBPROPVAL_TAKE_OWNERSHIP            0x80
#define DBPROPVAL_LOAD_DRIVER               0x100
#define DBPROPVAL_SYSTEM_PROFILE            0x200
#define DBPROPVAL_SYSTEMTIME                0x400
#define DBPROPVAL_PROF_SINGLE_PROCESS       0x800
#define DBPROPVAL_INC_BASE_PRIORITY			0x1000
#define DBPROPVAL_CREATE_PAGEFILE           0x2000
#define DBPROPVAL_CREATE_PERMANENT          0x4000
#define DBPROPVAL_BACKUP                    0x8000
#define DBPROPVAL_RESTORE                   0x10000
#define DBPROPVAL_SHUTDOWN                  0x20000
#define DBPROPVAL_DEBUG                     0x40000
#define DBPROPVAL_AUDIT                     0x80000
#define DBPROPVAL_SYSTEM_ENVIRONMENT        0x100000
#define DBPROPVAL_CHANGE_NOTIFY             0x200000
#define DBPROPVAL_REMOTE_SHUTDOWN           0x400000
#define DBPROPVAL_UNDOCK                    0x800000
#define DBPROPVAL_SYNC_AGENT                0x1000000
#define DBPROPVAL_ENABLE_DELEGATION         0x2000000

#define NUMBEROF_PRIVELAGES						 26
#define NUMBEROF_SEARCHPREF						 14

//DBPROP_WMIOLEDB_OBJECTTYPE property values
#define DBPROPVAL_NOOBJ							0
#define DBPROPVAL_SCOPEOBJ						1
#define DBPROPVAL_CONTAINEROBJ					2


/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// simple table used to store property information. Used in 
// our read-only implementation of IDBProperties::GetPropertyInfo and IRowsetInfo::GetProperties
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////
 struct _tagPROPSTRUCT
{
    DBPROPID	dwPropertyID;
	DBPROPFLAGS dwFlags;
    VARTYPE     vtType;
    BOOL        boolVal;
    SLONG       longVal;
    PWSTR       pwstrVal;
    PWSTR		pwstrDescBuffer;
	
	~_tagPROPSTRUCT()
	{
		// Only for Datasource , string will allocated by the utility
		if( vtType == VT_BSTR && pwstrVal != NULL && DBPROP_INIT_DATASOURCE == dwPropertyID )
		{
//			SysFreeString((BSTR)pwstrVal);
			SAFE_DELETE_ARRAY(pwstrVal);
			pwstrVal = NULL;
		}
	}

};
 typedef _tagPROPSTRUCT PROPSTRUCT;


/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Property ID of the WMIOLEDB custom properties
/////////////////////////////////////////////////////////////////////////////////////////////////////////
#define		DBPROP_WMIOLEDB_FETCHDEEP						0x1000
#define		DBPROP_WMIOLEDB_QUALIFIERS						0x1001
#define		DBPROP_WMIOLEDB_QUALIFIERFLAVOR					0x1002
#define		DBPROP_WMIOLEDB_SYSTEMPROPERTIES				0x1003
#define		DBPROP_WMIOLEDB_OBJECTTYPE						0x1005

#define		DBPROP_WMIOLEDB_PREV_CREATE_TOKEN 			0x1006
#define		DBPROP_WMIOLEDB_PREV_ASSIGNPRIMARYTOKEN 	0x1007
#define		DBPROP_WMIOLEDB_PREV_LOCK_MEMORY 			0x1008
#define		DBPROP_WMIOLEDB_PREV_INCREASE_QUOTA 		0x1009
#define		DBPROP_WMIOLEDB_PREV_MACHINE_ACCOUNT 		0x100a
#define		DBPROP_WMIOLEDB_PREV_TCB 					0x100b
#define		DBPROP_WMIOLEDB_PREV_SECURITY 				0x100c
#define		DBPROP_WMIOLEDB_PREV_TAKE_OWNERSHIP 		0x100d
#define		DBPROP_WMIOLEDB_PREV_LOAD_DRIVER 			0x100e
#define		DBPROP_WMIOLEDB_PREV_SYSTEM_PROFILE 		0x100f
#define		DBPROP_WMIOLEDB_PREV_SYSTEMTIME 			0x1010
#define		DBPROP_WMIOLEDB_PREV_PROF_SINGLE_PROCESS 	0x1011
#define		DBPROP_WMIOLEDB_PREV_INC_BASE_PRIORITY 		0x1012
#define		DBPROP_WMIOLEDB_PREV_CREATE_PAGEFILE  		0x1013
#define		DBPROP_WMIOLEDB_PREV_CREATE_PERMANENT  		0x1014
#define		DBPROP_WMIOLEDB_PREV_BACKUP 				0x1015
#define		DBPROP_WMIOLEDB_PREV_RESTORE 				0x1016
#define		DBPROP_WMIOLEDB_PREV_SHUTDOWN 				0x1017
#define		DBPROP_WMIOLEDB_PREV_DEBUG 					0x1018
#define		DBPROP_WMIOLEDB_PREV_AUDIT  				0x1019
#define		DBPROP_WMIOLEDB_PREV_SYSTEM_ENVIRONMENT  	0x101a
#define		DBPROP_WMIOLEDB_PREV_CHANGE_NOTIFY 			0x101b
#define		DBPROP_WMIOLEDB_PREV_REMOTE_SHUTDOWN 		0x101c
#define		DBPROP_WMIOLEDB_PREV_UNDOCK 				0x101d
#define		DBPROP_WMIOLEDB_PREV_SYNC_AGENT 			0x101e
#define		DBPROP_WMIOLEDB_PREV_ENABLE_DELEGATION 		0x101f


#define		DBPROP_WMIOLEDB_DS_DEREFALIAS				0x1020
#define		DBPROP_WMIOLEDB_DS_SIZELIMIT				0x1021
#define		DBPROP_WMIOLEDB_DS_PAGEDTIMELIMIT			0x1022
#define		DBPROP_WMIOLEDB_DS_TOMBSTONE				0x1023
#define		DBPROP_WMIOLEDB_DS_SEARCHSCOPE				0x1024
#define		DBPROP_WMIOLEDB_DS_TIMEOUT					0x1025
#define		DBPROP_WMIOLEDB_DS_PAGESIZE					0x1026
#define		DBPROP_WMIOLEDB_DS_TIMELIMIT				0x1027
#define		DBPROP_WMIOLEDB_DS_CHASEREF					0x1028
#define		DBPROP_WMIOLEDB_DS_ATTRIBUTES				0x1029
#define		DBPROP_WMIOLEDB_DS_CACHERESULTS				0x102a
#define		DBPROP_WMIOLEDB_DS_FILTER					0x102b
#define		DBPROP_WMIOLEDB_DS_ATTRIBONLY				0x102c
#define		DBPROP_WMIOLEDB_DS_ASYNCH					0x102d

#define		DBPROP_WMIOLEDB_ISMETHOD					0x102e
#define		DBPROP_WMIOLEDB_AUTHORITY					0x102f
#define		DBPROP_WMIOLEDB_QUERYLANGUAGE				0x1030

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// DBPROP_WMIOLEDB_QUALIFIERS property values
/////////////////////////////////////////////////////////////////////////////////////////////////////////
#define DBPROP_WM_CLASSQUALIFIERS		0x1
#define DBPROP_WM_PROPERTYQUALIFIERS	0x2


/////////////////////////////////////////////////////////////////////////////////////////////////////////
// DBPROP_WMIOLEDB_QUALIFIERFLAVOR property values
/////////////////////////////////////////////////////////////////////////////////////////////////////////
#define DBPROPVAL_FLAVOR_PROPOGAGTE_TO_INSTANCE				WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE
#define DBPROPVAL_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS	WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS
#define DBPROPVAL_FLAVOR_NOT_OVERRIDABLE					WBEM_FLAVOR_NOT_OVERRIDABLE
#define DBPROPVAL_FLAVOR_OVERRIDABLE						WBEM_FLAVOR_OVERRIDABLE
#define DBPROPVAL_FLAVOR_AMENDED							WBEM_FLAVOR_AMENDED


/////////////////////////////////////////////////////////////////////////////////////////////////////////
// flags for IDBProperties::GetPropertyInfo
/////////////////////////////////////////////////////////////////////////////////////////////////////////
#define FLAGS_ROWSETRO		(DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ)
#define FLAGS_ROWSETRW		(DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE)
#define FLAGS_DATASRCINF    (DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ)
#define FLAGS_DBINITRW		(DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE)
#define FLAGS_COLUMNSRW		(DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE)

enum PROPERTYTYPE
{
	DATASOURCEPROP,
	SESSIONPROP,
	ROWSETPROP,
	COMMANDPROP,
	BINDERPROP,
	COLUMNPROP,
};



/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Number of supported properties per property set
/////////////////////////////////////////////////////////////////////////////////////////////////////////
#define NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES				9
#define	NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES		10
#define	NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES				25
#define	NUMBER_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES		18
#define	NUMBER_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES		0
#define	NUMBER_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES		29
#define	NUMBER_OF_SUPPORTED_SESSION_PROPERTIES				0
#define	NUMBER_OF_SUPPORTED_COLUMN_PROPERTIES				3
#define	NUMBER_OF_SUPPORTED_WMIOLEDB_COLUMN_PROPERTIES		1

#define NUMBER_OF_PREVILAGE_PROPERTIES						26
#define START_OF_PREVILAGE_PROPERTIES						START_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES + 2 // 2 other 
																											 // WMIOLEDB_INIT properties	

#define	NUMBER_OF_SUPPORTED_PROPERTY_SETS					7

#define START_OF_SUPPORTED_DBINIT_PROPERTIES				0
#define START_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES		NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES
#define START_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES		(START_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES +NUMBER_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES)
#define START_OF_SUPPORTED_SESSION_PROPERTIES				(START_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES + NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES)
#define	START_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES		(START_OF_SUPPORTED_SESSION_PROPERTIES + NUMBER_OF_SUPPORTED_SESSION_PROPERTIES)
#define	START_OF_SUPPORTED_ROWSET_PROPERTIES				(START_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES + NUMBER_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES)
#define	START_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES		(START_OF_SUPPORTED_ROWSET_PROPERTIES + NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES)
#define	START_OF_SUPPORTED_COLUMN_PROPERTIES				(START_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES + NUMBER_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES)
#define	START_OF_SUPPORTED_WMIOLEDB_COLUMN_PROPERTIES		(START_OF_SUPPORTED_COLUMN_PROPERTIES + NUMBER_OF_SUPPORTED_COLUMN_PROPERTIES)


#define	NUMBER_OF_SUPPORTED_PROPERTIES							\
		(	NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES +				\
			NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES +		\
			NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES +				\
			NUMBER_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES +	\
			NUMBER_OF_SUPPORTED_SESSION_PROPERTIES +			\
			NUMBER_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES +	\
			NUMBER_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES +	\
			NUMBER_OF_SUPPORTED_COLUMN_PROPERTIES +				\
			NUMBER_OF_SUPPORTED_WMIOLEDB_COLUMN_PROPERTIES)



//////////////////////////////////////////////////////////////////////////
// Index of properties returned by function GetConnectionInitProperties
//////////////////////////////////////////////////////////////////////////

#define	IDX_DBPROP_INIT_DATASOURCE			0
#define	IDX_DBPROP_INIT_PROTECTION_LEVEL	1
#define	IDX_DBPROP_INIT_IMPERSONATION_LEVEL	2
#define	IDX_DBPROP_AUTH_USERID				3
#define	IDX_DBPROP_AUTH_PASSWORD			4
#define	IDX_DBPROP_INIT_LCID				5
#define	IDX_DBPROP_WMIOLEDB_AUTHORITY		6

#define	NUMBER_OF_CONNECTIONINIT_PROP		7

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Flags for different Rowset Properties
/////////////////////////////////////////////////////////////////////////////////////////////////////////

#define	CANHOLDROWS			0x1
#define	CANSCROLLBACKWARDS	0x2
#define	CANFETCHBACKWARDS	0x4
#define	OTHERUPDATEDELETE	0x8
#define	OWNINSERT			0x10
#define	REMOVEDELETED		0x20
#define	OTHERINSERT			0x40
#define	OWNUPDATEDELETE		0x80
#define LITERALIDENTITY		0x100
#define IROWSETCHANGE		0x200
#define BOOKMARKPROP		0x400
#define FETCHDEEP			0x800
#define IROWSETLOCATE		0x1000
#define	IGETROW				0x2000
#define	IROWSETREFRESH		0x4000
#define	ICHAPTEREDROWSET	0x8000

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// description size
/////////////////////////////////////////////////////////////////////////////////////////////////////////
#define CCH_GETPROPERTYINFO_DESCRIP_BUFFER_SIZE 50
#define MAXOPENROWS								2048

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// flags for Get and Set Properties
/////////////////////////////////////////////////////////////////////////////////////////////////////////
const DWORD		PROPSET_DSO		= 0x0001;
const DWORD		PROPSET_INIT	= 0x0002;
const DWORD		PROPSET_DSOINIT = PROPSET_DSO | PROPSET_INIT;
const DWORD		PROPSET_SESSION	= 0x0004;
const DWORD		PROPSET_ROWSET	= 0x0008;
const DWORD		PROPSET_COLUMN	= 0x0010;
const DWORD     PROPSET_COMMAND = 0x0020;
/////////////////////////////////////////////////////////////////////////////////////////////////////////
class CPropertyMemoryMgr
{
    public:

        //================================================================================        
        //
        //================================================================================        
        HRESULT AllocDESCRIPTBuffer(WCHAR *& pDescBuffer,  WCHAR** ppDescBuffer, ULONG cProperties);
        HRESULT AllocDBPROPINFOSET(DBPROPINFOSET *& pPropInfoSet, const ULONG cProps);
        HRESULT AllocDBPROPINFO(DBPROPINFO *& pPropInfo, DBPROPINFOSET * pPropInfoSet,ULONG ulPropSets);
        HRESULT AllocDBPROPSET(DBPROPSET*& ppPropSet, const ULONG cPropSets);
        HRESULT AllocateDBPROP(DBPROP*& ppProp, const ULONG cProperties);
        HRESULT AllocDBCOLUMNDESC(DBCOLUMNDESC*& ppCOLUMNDESC, const ULONG cColumnDescs);


		void FreeDBPROPINFOSET(DBPROPINFOSET *& pPropInfoSet, const ULONG cProps);
        void FreeDESCRIPTBuffer(WCHAR *& pDescBuffer,  WCHAR** ppDescBuffer);
		void FreeDBPROPINFO(DBPROPINFO *& pPropInfo, const ULONG cProps);
//        static void FreeDBPROPSET( ULONG  cPropertySets, DBPROPSET *& prgPropertySets);

        void FreeDBCOLUMNDESC(DBCOLUMNDESC rgColumnDescs[], LONG cColumns);

        HRESULT CopyDBPROPSET(DBPROPSET*& pDestination, DBPROPSET*& pSource);
        HRESULT CopyDBCOLUMNDESC(DBCOLUMNDESC*& pDestination, DBCOLUMNDESC*& pSource);
		HRESULT SetDefaultValueForStringProperties(PROPSTRUCT *	prgPropeties,ULONG cProperties);

		static void CPropertyMemoryMgr::FreeDBPROPSET( ULONG  cPropertySets, DBPROPSET *& prgPropertySets)
		{
			//==============================================================================
			// Free the memory
			//==============================================================================
			if (prgPropertySets){

				for( ULONG i = 0; i < cPropertySets; i++ ){

					for(ULONG ulIndex=0; ulIndex<prgPropertySets[i].cProperties; ulIndex++){
						VariantClear(&prgPropertySets[i].rgProperties[ulIndex].vValue);		
					}
					
					g_pIMalloc->Free(prgPropertySets[i].rgProperties);	
				}
				g_pIMalloc->Free(prgPropertySets);
			}
		}
};

/////////////////////////////////////////////////////////////////////////////////////////////////////////
class CUtilProp
{
	protected: 
		PROPSTRUCT	*	m_prgproperties;
		PROPERTYTYPE	m_propType ;
		ULONG			m_cProperties;
		ULONG			m_nPropStartIndex ;
        
        HRESULT CheckPropertyIDSets ( BOOL & fIsNotSpecialGUID, BOOL & fIsSpecialGUID, ULONG	cPropertyIDSets,	const DBPROPIDSET	rgPropertyIDSets[] ) ;
		
        BOOL GetPropIndex( DBPROPID dwPropertyID,ULONG* pulIndex);                       //Gets index of entry for a given property in property set
        BOOL GetPropIndexFromAllSupportedProps( DBPROPID dwPropertyID,ULONG* pulIndex);  //Gets index of entry for a given property in global property table
        BOOL LoadDBPROPINFO(PROPSTRUCT*		pPropStruct,DBPROPINFO*		pPropInfo );    //Loads fields of DBPROPINFO struct. Helper for GetPropertyInfo            
        BOOL LoadDBPROP(PROPSTRUCT*	pPropStruct,DBPROP*		pPropSupport);              //Loads fields of DBPROP struct. Helper for GetProperties

        HRESULT IsValidValue(DBPROP* pDBProp	);                                  //Checks to see if the value is valid. Helper for SetProperties
		BOOL IsPropertySetSupported(const GUID guidPropset);
		ULONG	GetNumberofPropInfoToBeReturned(	BOOL bDSOInitialized,
													ULONG	cPropertyIDSets,
													const	DBPROPIDSET	rgPropertyIDSets[]);

		void  FillPropertySets(BOOL fDSOInitialized,
								const DBPROPIDSET rgPropIDSets[],
								ULONG cPropIDSets,
								DBPROPINFOSET* pPropInfoSet,
								ULONG &cProperties);

	public: 
		 CUtilProp();
		 CUtilProp(PROPERTYTYPE propType);
		~CUtilProp(void);
        CPropertyMemoryMgr   m_PropMemMgr;

		HRESULT 	FInit(PROPERTYTYPE propType);

		HRESULT	SetPropertiesArgChk(const ULONG cProperties, const DBPROPSET rgProperties[]	,BOOL bDSOInitialized = TRUE);
		HRESULT	GetPropertiesArgChk( DWORD dwBitMask,	const ULONG	cPropertySets, const DBPROPIDSET rgPropertySets[],
			                                ULONG* pcProperties, DBPROPSET** prgProperties,BOOL bDSOInitialized = TRUE);

        STDMETHODIMP GetProperties ( DWORD	dwBitMask,  ULONG cPropertySets,  const DBPROPIDSET	rgPropertySets[],
			                         ULONG* pcProperties, DBPROPSET** prgProperties );
		STDMETHODIMP GetPropertyInfo (BOOL	fDSOInitialized,  ULONG	cPropertySets, const DBPROPIDSET	rgPropertySets[],	
				                      ULONG* pcPropertyInfoSets, DBPROPINFOSET**		prgPropertyInfoSets,WCHAR**	 ppDescBuffer);
		STDMETHODIMP SetProperties(	const DWORD dwBitMask,	const ULONG cProperties,DBPROPSET rgProperties[]);

//		DWORD	GetImpLevel(DWORD dwImpPropVal);
//		DWORD	GetAuthnLevel(DWORD dwAuthnPropVal);
		HRESULT ResetProperties();

		ULONG	GetNumberOfPropertySets(BOOL fDSOInitialized,const DBPROPIDSET	rgPropIDSets[],ULONG cPropIDSets);
		ULONG	GetNumberOfPropertySets(BOOL fDSOInitialized,DWORD dwBitMask);
		HRESULT IsValidPropertySet(BOOL fDSOInitialized,const GUID guidPropset);
		HRESULT FillPropStruct(BOOL fDSOInitialized,DWORD dwBitMask,DBPROPSET*	pPropSet);
		HRESULT GetConnectionInitProperties(DBPROPSET**	pprgPropertySets);
		HRESULT SetDefaultValueForStringProperties(PROPSTRUCT *	prgPropeties,ULONG cProperties);

};

typedef CUtilProp *PCUTILPROP;


class CPreviligeToken
{
	TOKEN_PRIVILEGES *m_pPrevTokenPrev;
	int				  m_nMemAllocated;
	void OpenToken(HANDLE &hToken);

public:
	CPreviligeToken();
	~CPreviligeToken();
	// NTRaid: 136443
	// 07/05/00
	HRESULT FInit();

	BOOL AdjustTokenPrivileges(ULONG cProps , DBPROP rgProp[]);
	void SetDBPROPForPrivileges(ULONG cProps , DBPROP *rgProp);
	void ConvertDBPropToPriveleges(ULONG cProps , DBPROP rgProp[]);

	BOOL AdjustTokenPrivileges(ULONG ulProperty);
	void SetDBPROPForPrivileges(ULONG &ulProperty);
	void ConvertDBPropToPriveleges(ULONG ulProperty);

	void GetCurrentPrivelegeToken();
	BOOL GetPropIndex (ULONG cProps ,DBPROP rgProp[],DBPROPID	dwPropertyID,LONG* pulIndex);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\utilprop.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Properties utility object implementation
//
//
// Notes - there are two main methods in this module:
//     - CUtilProps::GetPropertyInfo, a helper function for IDBInfo::GetPropertyInfo
//     - CUtilProps::GetProperties, a helper function for IRowsetInfo::GetProperties
//
// Our property implementation is simplified considerably by the fact that we
// only support reading\getting the properties, we do not support
// writing\setting them. This makes sense because we are a simple provider,
// and our rowset object always creates all the interfaces it exposes. In
// other words, there are really no properties the consumer could set.
//
// The implementation is very simple - we keep a global table of the
// properties we support in s_rgprop. We search this table sequentially.
//
// Note that a full-featured provider would probably need to use a more
// sophisticated implementation. We keep the entire GUID for each property in
// our struct, which would become a waste of space if we had a lot more
// properties. Similarly, with large numbers of properties some sort of
// hashing would be better than the sequential search used here.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "headers.h"
#include "wmiver.h"

#define __TXT(x)      L ## x
#define _TEXT_T(x)      __TXT(x)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Struct containing the properties we know about. The GUID and string fields are
// initialized in the constructor, because C++ makes it awkward to do so at declaration
// time. So, if you change this table, be sure to make parallel changes in CUtilProp::CUtilProp.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define PRIVILEGE_NAMESIZE					255

const GUID DBPROPSET_WMIOLEDB_DBINIT	= {0xdd497a71,0x9628,0x11d3,{0x9d,0x5f,0x0,0xc0,0x4f,0x5f,0x11,0x64}};
const GUID DBPROPSET_WMIOLEDB_ROWSET	= {0x8d16c220,0x9bbb,0x11d3,{0x9d,0x65,0x0,0xc0,0x4f,0x5f,0x11,0x64}};
const GUID DBPROPSET_WMIOLEDB_COLUMN	= {0x3ed51791,0x9c76,0x11d3,{0x9d,0x66,0x0,0xc0,0x4f,0x5f,0x11,0x64}};
const GUID DBPROPSET_WMIOLEDB_COMMAND   = {0xda0ff63c,0xad10,0x11d3,{0xb3,0xcb,0x0,0x10,0x4b,0xcc,0x48,0xc4}};

PROPSTRUCT s_rgprop[] =
   {
/* 0*/  {DBPROP_INIT_DATASOURCE,		FLAGS_DBINITRW,		VT_BSTR, FALSE,  0, NULL,	L"Data Source"},
/* 1*/  {DBPROP_INIT_HWND,				FLAGS_DBINITRW,		VT_I4,	 FALSE,  0, NULL,			L"Window Handle"},
/* 2*/  {DBPROP_INIT_PROMPT,			FLAGS_DBINITRW,		VT_I2,   FALSE,  4, NULL,			L"Prompt"},
/* 3*/  {DBPROP_INIT_PROTECTION_LEVEL,	FLAGS_DBINITRW, VT_I4,	 FALSE,	 DB_PROT_LEVEL_CONNECT,		NULL,	L"Protection Level"},
/* 4*/  {DBPROP_INIT_IMPERSONATION_LEVEL,	FLAGS_DBINITRW, VT_I4,	 FALSE,	 DB_IMP_LEVEL_IMPERSONATE,	NULL,	L"Impersonation Level"},
/* 5*/  {DBPROP_INIT_MODE,				FLAGS_DBINITRW,		VT_I4,	 TRUE,	 DB_MODE_READWRITE,	NULL,			L"Mode"},
/* 6*/  {DBPROP_AUTH_USERID,			FLAGS_DBINITRW,		VT_BSTR, FALSE,  0, NULL,			L"User ID"},
/* 7*/  {DBPROP_AUTH_PASSWORD,			FLAGS_DBINITRW,		VT_BSTR, FALSE,  0, NULL,			L"Password"},
/* 8*/  {DBPROP_INIT_LCID,				FLAGS_DBINITRW,		VT_I4,	 FALSE,  0, NULL,			L"Locale Identifier"},

/* 9*/	{DBPROP_WMIOLEDB_QUALIFIERS ,		FLAGS_DBINITRW , VT_I4,	  FALSE , 0,NULL, L"Qualifiers"},
/* 10*/	{DBPROP_WMIOLEDB_SYSTEMPROPERTIES ,	FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"System Properties"},
/* 11*/	{DBPROP_WMIOLEDB_AUTHORITY ,		FLAGS_DBINITRW , VT_BSTR,	  FALSE , 0,NULL, L"Authority"},

	
		// security priveleges
/* 12*/	{DBPROP_WMIOLEDB_PREV_CREATE_TOKEN,			FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Create Token Privilege"},
/* 13*/	{DBPROP_WMIOLEDB_PREV_ASSIGNPRIMARYTOKEN,	FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Assign Primary Token Privilege"},
/* 14*/	{DBPROP_WMIOLEDB_PREV_LOCK_MEMORY,			FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Lock Memory Privilege"},
/* 15*/ {DBPROP_WMIOLEDB_PREV_INCREASE_QUOTA,		FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Increase Quota Privilege"},
/* 16*/	{DBPROP_WMIOLEDB_PREV_MACHINE_ACCOUNT,		FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Machine Account Privilege"},
/* 17*/	{DBPROP_WMIOLEDB_PREV_TCB,					FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Tcb Privilege"},
/* 18*/	{DBPROP_WMIOLEDB_PREV_SECURITY,				FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Security Privilege"},
/* 19*/	{DBPROP_WMIOLEDB_PREV_TAKE_OWNERSHIP,		FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Take Ownership Privilege"},
/* 20*/	{DBPROP_WMIOLEDB_PREV_LOAD_DRIVER,			FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Load Driver Privilege"},
/* 21*/	{DBPROP_WMIOLEDB_PREV_SYSTEM_PROFILE,		FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"System Profile Privilege"},
/* 22*/	{DBPROP_WMIOLEDB_PREV_SYSTEMTIME,			FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Systemtime Privilege"},
/* 23*/	{DBPROP_WMIOLEDB_PREV_PROF_SINGLE_PROCESS,	FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Profile SingleProcess Privilege"},
/* 24*/	{DBPROP_WMIOLEDB_PREV_INC_BASE_PRIORITY,	FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Increase BasePriority Privilege"},
/* 25*/	{DBPROP_WMIOLEDB_PREV_CREATE_PAGEFILE ,		FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Create Pagefile Privilege"},
/* 26*/ {DBPROP_WMIOLEDB_PREV_CREATE_PERMANENT ,	FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Create Permanent Privilege"},
/* 27*/	{DBPROP_WMIOLEDB_PREV_BACKUP,				FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Backup Privilege"},
/* 28*/	{DBPROP_WMIOLEDB_PREV_RESTORE,				FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Restore Privilege"},
/* 29*/	{DBPROP_WMIOLEDB_PREV_SHUTDOWN,				FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Shutdown Privilege"},
/* 30*/	{DBPROP_WMIOLEDB_PREV_DEBUG,				FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Debug Privilege"},
/* 31*/	{DBPROP_WMIOLEDB_PREV_AUDIT ,				FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Audit Privilege"},
/* 32*/	{DBPROP_WMIOLEDB_PREV_SYSTEM_ENVIRONMENT ,	FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"System Environment Privilege"},
/* 33*/	{DBPROP_WMIOLEDB_PREV_CHANGE_NOTIFY,		FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Change Notify Privilege"},
/* 34*/	{DBPROP_WMIOLEDB_PREV_REMOTE_SHUTDOWN,		FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Remote Shutdown Privilege"},
/* 35*/	{DBPROP_WMIOLEDB_PREV_UNDOCK,				FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Undock Privilege"},
/* 36*/	{DBPROP_WMIOLEDB_PREV_SYNC_AGENT,			FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"SyncAgent Privilege"},
/* 37*/	{DBPROP_WMIOLEDB_PREV_ENABLE_DELEGATION,	FLAGS_DBINITRW , VT_BOOL, FALSE , 0,NULL, L"Enable Delegation Privilege"},

//  Session properties should come here

//  Data Source properties

/* 38*/  {DBPROP_ACTIVESESSIONS,		FLAGS_DATASRCINF,	VT_I4,	 FALSE,  1, NULL,			L"Active Sessions"},
/* 39*/ {DBPROP_PERSISTENTIDTYPE,		FLAGS_DATASRCINF,	VT_I4,	 FALSE,  DBPROPVAL_PT_GUID_PROPID, NULL,	L"Persistent ID Type"},
/* 40*/ {DBPROP_PROVIDERFILENAME,		FLAGS_DATASRCINF,	VT_BSTR, FALSE,  0, L"WMIOLEDB.DLL",L"Provider Name"},
/* 41*/ {DBPROP_PROVIDERFRIENDLYNAME,	FLAGS_DATASRCINF,	VT_BSTR, FALSE,  0, L"Microsoft WMIOLE DB Provider",L"Provider Friendly Name"},
/* 42*/ {DBPROP_PROVIDEROLEDBVER,		FLAGS_DATASRCINF,	VT_BSTR, FALSE,  0, L"02.00",		L"OLE DB Version"},
/* 43*/ {DBPROP_PROVIDERVER,			FLAGS_DATASRCINF,	VT_BSTR, FALSE,  0, _TEXT_T(VER_PRODUCTVERSION_STR), L"Provider Version"},
/* 44*/ {DBPROP_GENERATEURL,			FLAGS_DATASRCINF,	VT_I4,   FALSE,  DBPROPVAL_GU_NOTSUPPORTED, NULL, L"URL Generation"},
/* 45*/ {DBPROP_ALTERCOLUMN,			FLAGS_DATASRCINF,	VT_I4,   FALSE,  DBCOLUMNDESCFLAGS_PROPERTIES, NULL, L"Alter Column Support"},
/* 45*/ {DBPROP_MULTIPLERESULTS,		FLAGS_DATASRCINF,	VT_I4,   FALSE,  0, NULL, L"Multiple Results"},
/* 45*/ {DBPROP_OLEOBJECTS,				FLAGS_DATASRCINF,	VT_I4,   FALSE,  DBPROPVAL_OO_ROWOBJECT, NULL, L"OLE Object Support"},

	//  Command properties should come here
///* 75*/ {DBPROP_WMIOLEDB_ISMETHOD,		FLAGS_ROWSETRW,		VT_BOOL, FALSE, 0, NULL,			L"Method"},
///* 75*/ {DBPROP_WMIOLEDB_QUERYLANGUAGE,	FLAGS_ROWSETRW,		VT_BSTR, FALSE, 0, NULL,			L"Query Language"},


/* 46*/ {DBPROP_IAccessor,				FLAGS_ROWSETRO,     VT_BOOL, TRUE,   0, NULL,			L"IAccessor"},
/* 47*/ {DBPROP_IColumnsInfo,			FLAGS_ROWSETRO,     VT_BOOL, TRUE,   0, NULL,			L"IColumnsInfo"},
/* 48*/ {DBPROP_IConvertType,			FLAGS_ROWSETRO,     VT_BOOL, TRUE,   0, NULL,			L"IConvertType"},
/* 49*/ {DBPROP_IRowset,				FLAGS_ROWSETRO,     VT_BOOL, TRUE,   0, NULL,			L"IRowset"},
/* 50*/ {DBPROP_IRowsetChange,			FLAGS_ROWSETRW,     VT_BOOL, TRUE,   0, NULL,			L"IRowsetChange"},
/* 51*/ {DBPROP_IRowsetInfo,			FLAGS_ROWSETRO,     VT_BOOL, TRUE,   0, NULL,			L"IRowsetInfo"},
/* 52*/ {DBPROP_IRowsetIdentity,		FLAGS_ROWSETRO,     VT_BOOL, TRUE,   0, NULL,			L"IRowsetIdentity"},
/* 53*/ {DBPROP_IRowsetLocate,			FLAGS_ROWSETRW,     VT_BOOL, FALSE,   0, NULL,			L"IRowsetLocate"},
/* 54*/ {DBPROP_CANHOLDROWS,			FLAGS_ROWSETRW,     VT_BOOL, TRUE,   0, NULL,			L"Hold Rows"},
/* 55*/ {DBPROP_LITERALIDENTITY,		FLAGS_ROWSETRW,     VT_BOOL, TRUE,   0, NULL,			L"Literal Row Identity"},
/* 56*/ {DBPROP_UPDATABILITY,			FLAGS_ROWSETRW,     VT_I4,	 TRUE,   0, NULL,			L"Updatability"},
/* 57*/ {DBPROP_OWNUPDATEDELETE,		FLAGS_ROWSETRW,		VT_BOOL, FALSE,	 0,	NULL,			L"Own Changes Visible"},
///**/ {DBPROP_IRowsetUpdate,			FLAGS_ROWSETRO,		VT_BOOL, FALSE,	 0,	NULL,			L"IRowsetUpdate"},
/* 58*/ {DBPROP_ISequentialStream,		FLAGS_ROWSETRO,		VT_BOOL, FALSE,	 0,	NULL,			L"ISequentialStream"},
/* 59*/ {DBPROP_OTHERUPDATEDELETE,		FLAGS_ROWSETRW,		VT_BOOL, FALSE,	 0,	NULL,			L"Others' Changes Visible"},
/* 60*/ {DBPROP_CANFETCHBACKWARDS,		FLAGS_ROWSETRW,		VT_BOOL, FALSE,	 0,	NULL,			L"Fetch Backwards"},
/* 61*/ {DBPROP_CANSCROLLBACKWARDS,		FLAGS_ROWSETRW,		VT_BOOL, FALSE,	 0,	NULL,			L"Scroll Backwards"},
/* 62*/ {DBPROP_BOOKMARKS,				FLAGS_ROWSETRW,		VT_BOOL, TRUE,	 0,	NULL,			L"Use Bookmarks"},
/* 63*/ {DBPROP_BOOKMARKTYPE,			FLAGS_ROWSETRO,		VT_I4,	 TRUE,	 DBPROPVAL_BMK_NUMERIC,	NULL,			L"Bookmark Type"},
/* 64*/ {DBPROP_IRow,					FLAGS_ROWSETRW,		VT_BOOL, FALSE,  0, NULL,			L"IRow"},
/* 65*/ {DBPROP_IGetRow,				FLAGS_ROWSETRW,		VT_BOOL, TRUE,  0, NULL,			L"IGetRow"},
/* 66*/ {DBPROP_IRowsetRefresh,			FLAGS_ROWSETRW,		VT_BOOL, TRUE,  0, NULL,			L"IRowsetRefresh"},
/* 67*/ {DBPROP_IChapteredRowset,		FLAGS_ROWSETRW,		VT_BOOL, TRUE,  0, NULL,			L"IChapteredRowset"},
/* 68*/ {DBPROP_REMOVEDELETED,			FLAGS_ROWSETRO,		VT_BOOL, FALSE, 0, NULL,			L"Remove Deleted Rows"},
/* 69*/ {DBPROP_OTHERINSERT,			FLAGS_ROWSETRW,		VT_BOOL, FALSE, 0, NULL,			L"Others' Inserts Visible"},
/* 70*/ {DBPROP_MAXOPENROWS,			FLAGS_ROWSETRW,		VT_I4,   TRUE,  1024, NULL,			L"Maximum Open Rows"},

//   WMIOLEDB_ROWSET properties
/* 73*/ {DBPROP_WMIOLEDB_FETCHDEEP,		FLAGS_ROWSETRW,		VT_BOOL, FALSE,	 0,	NULL,			L"Get Child Instances"},
/* 74*/ {DBPROP_WMIOLEDB_OBJECTTYPE,	FLAGS_ROWSETRW,		VT_I4,   TRUE,  DBPROPVAL_SCOPEOBJ, NULL,			L"Type of Object"},
/* 75*/ {DBPROP_WMIOLEDB_ISMETHOD,		FLAGS_ROWSETRW,		VT_BOOL, FALSE, 0, NULL,			L"Method"},
/* 75*/ {DBPROP_WMIOLEDB_QUERYLANGUAGE,	FLAGS_ROWSETRW,		VT_BSTR, FALSE, 0, NULL,			L"Query Language"},

	// ADSI Search Preferences
/* 76*/ {DBPROP_WMIOLEDB_DS_DEREFALIAS,		FLAGS_ROWSETRW,	VT_I4,	FALSE, 0, NULL,	L"Deref Aliases"},
/* 77*/ {DBPROP_WMIOLEDB_DS_SIZELIMIT,		FLAGS_ROWSETRW,	VT_I4,	TRUE,  0, NULL,	L"Size Limit"},
/* 78*/ {DBPROP_WMIOLEDB_DS_SEARCHSCOPE,	FLAGS_ROWSETRW,	VT_I4,	FALSE, 0, NULL,	L"SearchScope"},
/* 79*/ {DBPROP_WMIOLEDB_DS_TIMEOUT,		FLAGS_ROWSETRW,	VT_I4,	TRUE,  0, NULL,	L"Timeout"},
/* 80*/ {DBPROP_WMIOLEDB_DS_PAGESIZE,		FLAGS_ROWSETRW,	VT_I4,	TRUE,  0, NULL,	L"Page Size"},
/* 81*/ {DBPROP_WMIOLEDB_DS_TIMELIMIT,		FLAGS_ROWSETRW,	VT_I4,	TRUE,  0, NULL,	L"Time Limit"},
/* 82*/ {DBPROP_WMIOLEDB_DS_CHASEREF,		FLAGS_ROWSETRW,	VT_I4,	TRUE,  0, NULL,	L"Chase Referals"},
/* 83*/ {DBPROP_WMIOLEDB_DS_CACHERESULTS,	FLAGS_ROWSETRW,	VT_BOOL,TRUE,  0, NULL,	L"Cache Results"},
/* 84*/ {DBPROP_WMIOLEDB_DS_ASYNCH,			FLAGS_ROWSETRW,	VT_BOOL,FALSE, 0, NULL,	L"Search Asynchronous"},
/* 85*/ {DBPROP_WMIOLEDB_DS_ATTRIBONLY,		FLAGS_ROWSETRW,	VT_BOOL,FALSE, 0, NULL,	L"Attributes Only"},
/* 86*/ {DBPROP_WMIOLEDB_DS_PAGEDTIMELIMIT,	FLAGS_ROWSETRW,	VT_I4,	FALSE, 0, NULL,	L"Page size limit"},
/* 87*/ {DBPROP_WMIOLEDB_DS_TOMBSTONE,		FLAGS_ROWSETRW,	VT_BOOL,FALSE, 0, NULL,	L"TombStone"},
/* 88*/ {DBPROP_WMIOLEDB_DS_FILTER,			FLAGS_ROWSETRW,	VT_BSTR,FALSE, 0, NULL,	L"Filter"},
/* 89*/ {DBPROP_WMIOLEDB_DS_ATTRIBUTES,		FLAGS_ROWSETRW,	VT_BSTR,FALSE, 0, NULL,	L"Attributes"},


//   Column Properties
/* 90*/ {DBPROP_COL_NULLABLE,			FLAGS_COLUMNSRW,	VT_BOOL, TRUE,	 0,	NULL,			L"Nullable"},
/* 91*/ {DBPROP_COL_UNIQUE,				FLAGS_COLUMNSRW,	VT_BOOL, TRUE,	 0,	NULL,			L"Unique"},
/* 92*/ {DBPROP_COL_PRIMARYKEY,			FLAGS_COLUMNSRW,	VT_BOOL, TRUE,	 0,	NULL,			L"Primary Key"},

// WMIOLEDB_COLUMN Properties
/* 93*/ {DBPROP_WMIOLEDB_QUALIFIERFLAVOR, FLAGS_COLUMNSRW,	VT_I4,	 TRUE,	 DBPROPVAL_FLAVOR_PROPOGAGTE_TO_INSTANCE,	NULL,	L"Qualifier Flavor"},

};





/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor for this class
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CUtilProp::CUtilProp (void)
{
/*	m_prgproperties = NULL;
	m_cProperties	= NUMBER_OF_SUPPORTED_PROPERTIES;
	m_prgproperties = (PROPSTRUCT *)g_pIMalloc->Alloc(sizeof(PROPSTRUCT) * m_cProperties);
	memcpy(m_prgproperties, &s_rgprop, sizeof(PROPSTRUCT) * m_cProperties );
	m_nPropStartIndex	= 0;
*/
	m_propType			= BINDERPROP;
	m_prgproperties		= NULL;
	m_cProperties		= 0;
	m_nPropStartIndex	= 0;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Constructor for this class
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CUtilProp::CUtilProp ( PROPERTYTYPE propType )
{
/*
	m_propType			= propType;
	m_prgproperties		= NULL;
	m_cProperties		= 0;
	m_nPropStartIndex	= 0;

	switch(propType)
	{
		case DATASOURCEPROP :
			m_cProperties	= NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES +			\
								NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES + \
								NUMBER_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES;
			m_nPropStartIndex	= 0;
			break;

		case SESSIONPROP :
			m_cProperties	= NUMBER_OF_SUPPORTED_SESSION_PROPERTIES;
			m_nPropStartIndex = START_OF_SUPPORTED_SESSION_PROPERTIES;
			break;

			// for command follow through to include even the rowset properties
		case COMMANDPROP :
			m_cProperties	= NUMBER_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES;
			m_nPropStartIndex = START_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES;

		case ROWSETPROP :
			m_cProperties	+= NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES + NUMBER_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES;
			// if start index is no set by COMMANDPROP
			if(m_nPropStartIndex == 0)
			{
				m_nPropStartIndex = START_OF_SUPPORTED_ROWSET_PROPERTIES;
			}
			break;

		case BINDERPROP:
			m_cProperties	= NUMBER_OF_SUPPORTED_PROPERTIES;
			m_nPropStartIndex = 0;
			break;

		case COLUMNPROP:
			m_cProperties	= NUMBER_OF_SUPPORTED_COLUMN_PROPERTIES + NUMBER_OF_SUPPORTED_WMIOLEDB_COLUMN_PROPERTIES;
			m_nPropStartIndex = START_OF_SUPPORTED_COLUMN_PROPERTIES;
			break;
	};
	
	if(m_cProperties > 0)
	{
//		m_prgproperties = (PROPSTRUCT *)g_pIMalloc->Alloc(sizeof(PROPSTRUCT) * m_cProperties);
		m_prgproperties = new PROPSTRUCT[m_cProperties];
		memcpy(m_prgproperties, &s_rgprop[m_nPropStartIndex], sizeof(PROPSTRUCT) * m_cProperties );
		SetDefaultValueForStringProperties(m_prgproperties,m_cProperties);
	}

	if( propType == DATASOURCEPROP || propType == BINDERPROP)
	{
		ULONG lIndex = 0;

		// Get the default LCID
		if(GetPropIndex(DBPROP_INIT_LCID,&lIndex))
		{
			m_prgproperties[lIndex].longVal = (SLONG)GetSystemDefaultLCID();
		}
	
		CPreviligeToken pvgToken;
		DBPROPIDSET	rgPropertyIDSets[1];
		ULONG		cPropertySets;
		DBPROPSET*	prgPropertySets;
		HRESULT		hr = S_OK;

		rgPropertyIDSets[0].guidPropertySet		= DBPROPSET_WMIOLEDB_DBINIT;
		rgPropertyIDSets[0].rgPropertyIDs		= NULL;
		rgPropertyIDSets[0].cPropertyIDs		= 0;

		// NTRaid: 136443
		// 07/05/00
		hr = pvgToken.FInit();
		
		if(SUCCEEDED(hr) && SUCCEEDED(hr = GetProperties(PROPSET_DSO,1,rgPropertyIDSets,&cPropertySets,&prgPropertySets)))
		{
			pvgToken.SetDBPROPForPrivileges(prgPropertySets->cProperties ,prgPropertySets[0].rgProperties);

			hr = SetProperties(PROPSET_DSO,1,prgPropertySets);
    		//==========================================================================
			//  Free memory we allocated to get the namespace property above
    		//==========================================================================
			m_PropMemMgr.FreeDBPROPSET( cPropertySets, prgPropertySets);
		}

	}
*/
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Destructor for this class
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CUtilProp:: ~CUtilProp (void )
{
	SAFE_DELETE_ARRAY(m_prgproperties);
}


HRESULT CUtilProp::	FInit(PROPERTYTYPE propType)
{
	HRESULT hr = S_OK;
	m_propType			= propType;

	switch(propType)
	{
		case DATASOURCEPROP :
			m_cProperties	= NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES +			\
								NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES + \
								NUMBER_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES;
			m_nPropStartIndex	= 0;
			break;

		case SESSIONPROP :
			m_cProperties	= NUMBER_OF_SUPPORTED_SESSION_PROPERTIES;
			m_nPropStartIndex = START_OF_SUPPORTED_SESSION_PROPERTIES;
			break;

			// for command follow through to include even the rowset properties
		case COMMANDPROP :
			m_cProperties	= NUMBER_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES;
			m_nPropStartIndex = START_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES;

		case ROWSETPROP :
			m_cProperties	+= NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES + NUMBER_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES;
			// if start index is no set by COMMANDPROP
			if(m_nPropStartIndex == 0)
			{
				m_nPropStartIndex = START_OF_SUPPORTED_ROWSET_PROPERTIES;
			}
			break;

		case BINDERPROP:
			m_cProperties	= NUMBER_OF_SUPPORTED_PROPERTIES;
			m_nPropStartIndex = 0;
			break;

		case COLUMNPROP:
			m_cProperties	= NUMBER_OF_SUPPORTED_COLUMN_PROPERTIES + NUMBER_OF_SUPPORTED_WMIOLEDB_COLUMN_PROPERTIES;
			m_nPropStartIndex = START_OF_SUPPORTED_COLUMN_PROPERTIES;
			break;
	};
	
	if(m_cProperties > 0)
	{
//		m_prgproperties = (PROPSTRUCT *)g_pIMalloc->Alloc(sizeof(PROPSTRUCT) * m_cProperties);
		m_prgproperties = new PROPSTRUCT[m_cProperties];
		if(m_prgproperties)
		{
			memcpy(m_prgproperties, &s_rgprop[m_nPropStartIndex], sizeof(PROPSTRUCT) * m_cProperties );
			SetDefaultValueForStringProperties(m_prgproperties,m_cProperties);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	if	(SUCCEEDED(hr) &&( propType == DATASOURCEPROP || propType == BINDERPROP))
	{
		ULONG lIndex = 0;

		// Get the default LCID
		if(GetPropIndex(DBPROP_INIT_LCID,&lIndex))
		{
			m_prgproperties[lIndex].longVal = (SLONG)GetSystemDefaultLCID();
		}
	
		CPreviligeToken pvgToken;
		DBPROPIDSET	rgPropertyIDSets[1];
		ULONG		cPropertySets;
		DBPROPSET*	prgPropertySets;
		HRESULT		hr = S_OK;

		rgPropertyIDSets[0].guidPropertySet		= DBPROPSET_WMIOLEDB_DBINIT;
		rgPropertyIDSets[0].rgPropertyIDs		= NULL;
		rgPropertyIDSets[0].cPropertyIDs		= 0;

		// NTRaid: 136443
		// 07/05/00
		hr = pvgToken.FInit();
		
		if(SUCCEEDED(hr) && SUCCEEDED(hr = GetProperties(PROPSET_DSO,1,rgPropertyIDSets,&cPropertySets,&prgPropertySets)))
		{
			pvgToken.SetDBPROPForPrivileges(prgPropertySets->cProperties ,prgPropertySets[0].rgProperties);

			hr = SetProperties(PROPSET_DSO,1,prgPropertySets);
    		//==========================================================================
			//  Free memory we allocated to get the namespace property above
    		//==========================================================================
			m_PropMemMgr.FreeDBPROPSET( cPropertySets, prgPropertySets);
		}

	}
	return hr;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns index of the given property in the property set 
//
// BOOL
//      TRUE       found match, copied it to pulIndex out-param
//      FALSE      no match. In this case, pulIndex has no meaning
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BOOL CUtilProp::GetPropIndex (	DBPROPID	dwPropertyID,   //IN   PROPID of desired property
	                            ULONG*		pulIndex)	    //OUT  index of desired property if return was TRUE
{
    ULONG cNumberOfProperties;
    BOOL fRc = FALSE;
    assert( pulIndex );

    for (	cNumberOfProperties = 0; cNumberOfProperties < m_cProperties; 	cNumberOfProperties++)  {
        if (dwPropertyID == m_prgproperties[cNumberOfProperties].dwPropertyID ) {

            //==============================================================
            // found a match
            //==============================================================
            *pulIndex = cNumberOfProperties;
            fRc = TRUE;
			break;
         }
    }
    return fRc;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns index of the given property in our global table of properties
//
// BOOL
//      TRUE       found match, copied it to pulIndex out-param
//      FALSE      no match. In this case, pulIndex has no meaning
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BOOL CUtilProp::GetPropIndexFromAllSupportedProps (	DBPROPID	dwPropertyID,   //IN   PROPID of desired property
	                            ULONG*		pulIndex)	    //OUT  index of desired property if return was TRUE
{
    ULONG cNumberOfProperties;
    BOOL fRc = FALSE;
    assert( pulIndex );

    for (	cNumberOfProperties = 0; cNumberOfProperties < NUMBER_OF_SUPPORTED_PROPERTIES; 	cNumberOfProperties++)  {
        if (dwPropertyID == s_rgprop[cNumberOfProperties].dwPropertyID ) {

            //==============================================================
            // found a match
            //==============================================================
            *pulIndex = cNumberOfProperties;
            fRc = TRUE;
			break;
         }
    }
    return fRc;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Helper for GetPropertyInfo. Loads field of DBPROPINFO structure.
//
// BOOL
//      TRUE           Method succeeded
//      FALSE          Method failed (couldn't allocate memory)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CUtilProp::LoadDBPROPINFO  (  PROPSTRUCT*		pPropStruct,  DBPROPINFO*		pPropInfo  )
{
    
    assert( pPropStruct );
    assert( pPropInfo );

    //=======================================================================
    // init the variant
    //=======================================================================
    VariantInit( &pPropInfo->vValues );

    //=======================================================================
    // set the easy fields..
    //=======================================================================
    pPropInfo->dwPropertyID	= pPropStruct->dwPropertyID;
    pPropInfo->dwFlags		= pPropStruct->dwFlags;
    pPropInfo->vtType		= pPropStruct->vtType;

    //=======================================================================
	// fill in the description
    //=======================================================================
    if ( pPropInfo->pwszDescription ){
		wcscpy(pPropInfo->pwszDescription, pPropStruct->pwstrDescBuffer);
    }

    //=======================================================================
    // all went well
    //=======================================================================
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Helper for GetProperties. Loads field of DBPROP structure.
//
// BOOL
//     TRUE           Method succeeded
//     FALSE          Method failed (couldn't allocate memory)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CUtilProp::LoadDBPROP  (  PROPSTRUCT*	pPropStruct,  DBPROP*		pPropSupport   )
{
    assert( pPropStruct );
    assert( pPropSupport );

    //========================================================================
    // init the variant
    //========================================================================
    VariantInit( &pPropSupport->vValue );

    //========================================================================
    // set the easy fields..
    //========================================================================
    pPropSupport->dwPropertyID  = pPropStruct->dwPropertyID;
    pPropSupport->colid			= DB_NULLID;
	pPropSupport->dwStatus		= DBPROPSTATUS_OK;

    //========================================================================
    // set pPropSupport->vValue based on Variant type
    //========================================================================
    switch (pPropStruct->vtType){

	    case VT_BOOL:
			V_VT( &pPropSupport->vValue ) = VT_BOOL;
			if( pPropStruct->boolVal ) 
				V_BOOL( &pPropSupport->vValue ) = VARIANT_TRUE;
			else
				V_BOOL( &pPropSupport->vValue ) = VARIANT_FALSE;

			break;
        
	    case VT_I2:
		    V_VT( &pPropSupport->vValue ) = VT_I2;
			V_I2( &pPropSupport->vValue ) = (SHORT)pPropStruct->longVal;
			break;

		case VT_I4:
		    V_VT( &pPropSupport->vValue ) = VT_I4;
			V_I4( &pPropSupport->vValue ) = pPropStruct->longVal;
			break;
        
	    case VT_BSTR:
            if( pPropStruct->pwstrVal  ){
				V_VT( &pPropSupport->vValue ) = VT_BSTR;
				V_BSTR( &pPropSupport->vValue ) = Wmioledb_SysAllocString( pPropStruct->pwstrVal );
			}
/*			else
				VariantClear( &pPropSupport->vValue );
*/			break;
        
		case VT_UI4:
		    V_VT( &pPropSupport->vValue ) = VT_I4;
			V_UI4( &pPropSupport->vValue ) = pPropStruct->longVal;
			break;

		default:
			assert( !"LoadDBPROP unknown variant type!\n\r" );
			break;
    }
    // all went well
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Initialize the buffers and check for E_INVALIDARG cases
//
// NOTE: This routine is used by RowsetInfo and IDBProperties
//
// HRESULT indicating the status of the method
//		S_OK            Properties gathered
//		E_INVALIDARG    Invalid parameter values
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CUtilProp::GetPropertiesArgChk(	DWORD				dwBitMask,			//IN  Mask for object
	                                    const ULONG			cPropertySets,		//IN  Number of property Sets
	                                    const DBPROPIDSET	rgPropertySets[],	//IN  Property Classes and Ids
	                                    ULONG*				pcProperties,		//OUT Count of structs returned
	                                    DBPROPSET**			prgProperties,	//OUT Array of Properties
	                                    BOOL bDSOInitialized )
{
    HRESULT hr = S_OK;
    //================================================================
	// Initialize values
    //================================================================
    if( pcProperties ){
		*pcProperties = 0;
    }
    if( prgProperties ){
		*prgProperties = NULL;	
    }

    //================================================================
	// Check Arguments
    //================================================================
    if (((cPropertySets > 0) && !rgPropertySets) || 
		!pcProperties || 
		!prgProperties )
	{
		hr = E_INVALIDARG ;
    }
    else{

        //=========================================================================
	    // New argument check for > 1 cPropertyIDs and NULL pointer 
        // for array of property ids.
        //=========================================================================
    	for(ULONG ul=0; ul<cPropertySets && hr == S_OK; ul++){

			if(( rgPropertySets[ul].guidPropertySet == DBPROPSET_PROPERTIESINERROR &&
				(rgPropertySets[ul].cPropertyIDs != 0 || rgPropertySets[0].rgPropertyIDs != NULL ||
				 cPropertySets > 1))   && (dwBitMask == DATASOURCEPROP || dwBitMask == COMMANDPROP))
			{
			    hr = E_INVALIDARG;
				break;
			}
			else
            if( rgPropertySets[ul].cPropertyIDs && !(rgPropertySets[ul].rgPropertyIDs) )
			{
			    hr = E_INVALIDARG;
			}
			else
			{
				// Check if all the propertysetID's are correct for this object
				hr = IsValidPropertySet(bDSOInitialized,rgPropertySets[ul].guidPropertySet);
            }
			if(FAILED(hr))
			{
				hr = E_INVALIDARG;
				break;
			}
			else
				hr = S_OK;
			
        }
	}
	
	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Validate that the variant contains legal values for it's particalur type and for the particular PROPID in this 
// propset.
//
// HRESULT indicating status
//        
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CUtilProp::IsValidValue(DBPROP*	pDBProp )
{
    HRESULT hr	= S_OK;
	ULONG lIndex = 0;

    //===========================================================================
	// Check BOOLEAN values
    //===========================================================================
	if( (pDBProp->vValue.vt == VT_BOOL) &&	!((V_BOOL(&(pDBProp->vValue)) == VARIANT_TRUE) ||
        (V_BOOL(&(pDBProp->vValue)) == VARIANT_FALSE)) ){
		hr = S_FALSE;
    }
    else if( pDBProp->vValue.vt != VT_EMPTY  && pDBProp->vValue.vt != VT_NULL){
			
		if(GetPropIndex(pDBProp->dwPropertyID,&lIndex) == FALSE)
			hr = FALSE;
		else
		if(pDBProp->vValue.vt != m_prgproperties[lIndex].vtType)
			hr = S_FALSE;
		else
		{

			switch( pDBProp->dwPropertyID )	{
				case DBPROP_INIT_DATASOURCE:
				case DBPROP_AUTH_USERID:
				case DBPROP_AUTH_PASSWORD:
				case DBPROP_WMIOLEDB_AUTHORITY:
				case DBPROP_WMIOLEDB_QUERYLANGUAGE:
					if( pDBProp->vValue.vt != VT_BSTR ){
						hr = S_FALSE;
					}
					break;				

				case DBPROP_INIT_HWND:
					if( pDBProp->vValue.vt != VT_I4 ){
						hr = S_FALSE;
					}
					break;				

				case DBPROP_INIT_PROMPT:
					//===============================================================
					// These are the only values we support (from spec).
					//===============================================================
					if ( (pDBProp->vValue.vt == VT_I2) &&
						 !(V_I2(&pDBProp->vValue) == DBPROMPT_PROMPT || 
						   V_I2(&pDBProp->vValue) == DBPROMPT_COMPLETE ||
						   V_I2(&pDBProp->vValue) == DBPROMPT_COMPLETEREQUIRED ||
						   V_I2(&pDBProp->vValue) == DBPROMPT_NOPROMPT)){
						hr = S_FALSE;
					}
					break;

				case DBPROP_INIT_PROTECTION_LEVEL:
					if (!(	V_I4(&pDBProp->vValue) == DB_PROT_LEVEL_NONE ||
							V_I4(&pDBProp->vValue) == DB_PROT_LEVEL_CONNECT ||
							V_I4(&pDBProp->vValue) == DB_PROT_LEVEL_CALL ||
							V_I4(&pDBProp->vValue) == DB_PROT_LEVEL_PKT ||
							V_I4(&pDBProp->vValue) == DB_PROT_LEVEL_PKT ||
							V_I4(&pDBProp->vValue) == DB_PROT_LEVEL_PKT_PRIVACY))
					{
						hr = S_FALSE;
					}
					break;

				case DBPROP_INIT_IMPERSONATION_LEVEL:
					if (!(	V_I4(&pDBProp->vValue) == DB_IMP_LEVEL_ANONYMOUS ||
							V_I4(&pDBProp->vValue) == DB_IMP_LEVEL_IDENTIFY ||
							V_I4(&pDBProp->vValue) == DB_IMP_LEVEL_IMPERSONATE ||
							V_I4(&pDBProp->vValue) == DB_IMP_LEVEL_DELEGATE ))					{
						hr = S_FALSE;
					}
					break;

				case DBPROP_INIT_MODE:
					switch(V_I4(&pDBProp->vValue))
					{
						case DB_MODE_READ:
						case DB_MODE_WRITE:
						case DB_MODE_READWRITE:
						case DB_MODE_SHARE_DENY_READ:
						case DB_MODE_SHARE_EXCLUSIVE:
						case DB_MODE_SHARE_DENY_NONE:
						case DB_MODE_SHARE_EXCLUSIVE|DB_MODE_SHARE_DENY_NONE:
						case DB_MODE_READ|DB_MODE_WRITE|DB_MODE_READWRITE|DB_MODE_SHARE_DENY_READ|DB_MODE_SHARE_DENY_WRITE|DB_MODE_SHARE_EXCLUSIVE|DB_MODE_SHARE_DENY_NONE:
							hr = S_OK;
							break;

						default:
							hr = S_FALSE;
					};
					break;

				case DBPROP_WMIOLEDB_QUALIFIERS:
					if (!(	V_I4(&pDBProp->vValue) == DBPROP_WM_CLASSQUALIFIERS ||
							V_I4(&pDBProp->vValue) == DBPROP_WM_PROPERTYQUALIFIERS ||
							V_I4(&pDBProp->vValue) == 0 ||
							V_I4(&pDBProp->vValue) == (DBPROP_WM_PROPERTYQUALIFIERS | DBPROP_WM_CLASSQUALIFIERS) ))
					{
						hr = S_FALSE;
					}
					break;

				case DBPROP_UPDATABILITY:
					if (!(	V_I4(&pDBProp->vValue) <= (DBPROPVAL_UP_CHANGE | DBPROPVAL_UP_DELETE | DBPROPVAL_UP_INSERT) &&
						V_I4(&pDBProp->vValue) >= 0))
					{
						hr = S_FALSE;
					}
					break;

				case DBPROP_MAXOPENROWS:
					if(V_I4(&pDBProp->vValue) > MAXOPENROWS && 
						V_I4(&pDBProp->vValue) <= 0)
					{
						hr = S_FALSE;
					}
					break;

				case DBPROP_WMIOLEDB_OBJECTTYPE:
					if(!( (V_I4(&pDBProp->vValue) == DBPROPVAL_SCOPEOBJ) ||
						(V_I4(&pDBProp->vValue) == DBPROPVAL_CONTAINEROBJ) ||
						(V_I4(&pDBProp->vValue) == DBPROPVAL_NOOBJ) ) )
					{
						hr = S_FALSE;
					}
					break;

			}
		}
	}
	return hr;	
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CUtilProp::CheckPropertyIDSets( BOOL & fIsNotSpecialGUID,  BOOL & fIsSpecialGUID,
                                        ULONG cPropIDSets, const DBPROPIDSET	rgPropIDSets[] )	//IN  Array of property sets 
{
    HRESULT hr = S_OK;
	fIsNotSpecialGUID = FALSE;
	fIsSpecialGUID	  = FALSE;

	for(ULONG ul=0; ul<cPropIDSets; ul++){

        if( rgPropIDSets[ul].cPropertyIDs && !(rgPropIDSets[ul].rgPropertyIDs) ){
			hr = E_INVALIDARG ;
            break;
        }
		
		if (DBPROPSET_ROWSETALL			== rgPropIDSets[ul].guidPropertySet	||
			DBPROPSET_DATASOURCEALL		== rgPropIDSets[ul].guidPropertySet	||
			DBPROPSET_DATASOURCEINFOALL == rgPropIDSets[ul].guidPropertySet	||
			DBPROPSET_SESSIONALL		== rgPropIDSets[ul].guidPropertySet	||
			DBPROPSET_COLUMNALL			== rgPropIDSets[ul].guidPropertySet	||
            DBPROPSET_DBINITALL			== rgPropIDSets[ul].guidPropertySet	||
			DBPROPSET_CONSTRAINTALL		== rgPropIDSets[ul].guidPropertySet	||
			DBPROPSET_INDEXALL			== rgPropIDSets[ul].guidPropertySet	||
			DBPROPSET_SESSIONALL		== rgPropIDSets[ul].guidPropertySet	||
			DBPROPSET_VIEWALL			== rgPropIDSets[ul].guidPropertySet	||
			DBPROPSET_TABLEALL			== rgPropIDSets[ul].guidPropertySet	||
			DBPROPSET_TRUSTEEALL		== rgPropIDSets[ul].guidPropertySet	)
		{
			fIsSpecialGUID = TRUE;
        }
        else{
			fIsNotSpecialGUID = TRUE;
        }

        if(fIsSpecialGUID && fIsNotSpecialGUID){
			hr = E_INVALIDARG ;
            break;
        }
	}
    
	if(fIsSpecialGUID && fIsNotSpecialGUID)
		hr = E_INVALIDARG ;

	return hr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns information about rowset and data source properties supported by the provider
//
// HRESULT
//      S_OK           The method succeeded
//      E_INVALIDARG   pcPropertyIDSets or prgPropertyInfo was NULL
//      E_OUTOFMEMORY  Out of memory
//
// NTRaid : 142133 - Testing this , found that getting data source property from ADO was resulting in a crash
// 07/12/00
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUtilProp::GetPropertyInfo(   BOOL	fDSOInitialized,	            //IN  if Initialized
                                            ULONG				cPropIDSets,	//IN  # properties
                                            const DBPROPIDSET	rgPropIDSets[],	//IN  Array of property sets
	                                        ULONG*				pcPropInfoSets,	//OUT # DBPROPSET structures
	                                        DBPROPINFOSET**		prgPropInfoSets,//OUT DBPROPSET structures property information returned
	                                        WCHAR**				ppDescBuffer		//OUT Property descriptions
    )
{
    BOOL fRet= TRUE;
	BOOL fPropsinError,	fPropsSucceed, fIsSpecialGUID, fIsNotSpecialGUID;
    ULONG cProps					= 0;
	ULONG cCount					= 0;
	ULONG ulPropSets				= 0;
	ULONG cTotalPropSets			= 0;
	ULONG ulPropSetIndex			= 0;
	ULONG cPropSetsInSpecialGUID	= 0;

	WCHAR*			pDescBuffer	= NULL;
	WCHAR*			pDescBufferTemp = NULL;
    DBPROPINFO*		pPropInfo;
    DBPROPINFOSET*	pPropInfoSet;
    HRESULT         hr = S_OK;
	ULONG			ulPropertyInfoCount = 0;

    //=======================================================================
    // init out params and local stuff
    //=======================================================================
	if (pcPropInfoSets)
		*pcPropInfoSets	 = 0;
	if (prgPropInfoSets)
		*prgPropInfoSets = NULL;
	if (ppDescBuffer)
		*ppDescBuffer = NULL;

	fPropsinError = fPropsSucceed = fIsSpecialGUID = fIsNotSpecialGUID = FALSE;
    cProps = cCount = ulPropSets = ulPropSetIndex = cTotalPropSets = cPropSetsInSpecialGUID = 0;

    //=======================================================================
	// Check Arguments, on failure post HRESULT to error queue
    //=======================================================================
    if( ((cPropIDSets > 0) && !rgPropIDSets) ||	!pcPropInfoSets || !prgPropInfoSets ){
        return E_INVALIDARG ;
    }
	
    //=======================================================================
	// If the consumer does not restrict the property sets by specify an 
    // array of property sets and a cPropertySets greater than 0, then we 
    // need to make sure we have some to return
    //=======================================================================

	if ( (cPropIDSets == 0) ){
		if( fDSOInitialized )
			cProps = NUMBER_OF_SUPPORTED_PROPERTY_SETS;
		else
			cProps = 2;

		cTotalPropSets = cProps;
	}	
	else
	{
		//=======================================================================
		// New argument check for > 1 cPropIDs and NULL pointer for 
		// array of property ids.
		//=======================================================================
		if( S_OK != ( hr = CheckPropertyIDSets(fIsNotSpecialGUID,fIsSpecialGUID,cPropIDSets,rgPropIDSets)) ){
			return hr;
		}

		if( fIsSpecialGUID == TRUE)
		{
			cTotalPropSets = GetNumberOfPropertySets(fDSOInitialized,rgPropIDSets,cPropIDSets);
			
			// NTRaid : 142133
			// 07/12/00
			cProps = cPropIDSets;
		}
		else
			//=======================================================================
			// save the count of PropertyIDSets
			//=======================================================================
			cTotalPropSets = cProps = cPropIDSets;
	}

	// con.properties
	// 07/06/00
	if(cTotalPropSets)
	{
		//=======================================================================
		// use task memory allocater to alloc a DBPROPINFOSET struct
		//=======================================================================
		if( S_OK != (hr = m_PropMemMgr.AllocDBPROPINFOSET(pPropInfoSet,cTotalPropSets))){
			return hr;
		}
		memset(pPropInfoSet,0,cTotalPropSets * sizeof(DBPROPINFOSET));

		// Fill the property sets info to be fetched and get the number of properties that will be returned
		if(fIsSpecialGUID == TRUE || cPropIDSets == 0)
		{
			FillPropertySets(fDSOInitialized,rgPropIDSets,cPropIDSets ,pPropInfoSet,ulPropertyInfoCount);
		}
		else
		{
			ulPropertyInfoCount = GetNumberofPropInfoToBeReturned(fDSOInitialized,cPropIDSets,rgPropIDSets);
		}

		//=======================================================================
		// Alloc memory for ppDescBuffer
		//=======================================================================
		if( S_OK != (hr = m_PropMemMgr.AllocDESCRIPTBuffer(pDescBuffer, ppDescBuffer,ulPropertyInfoCount))){
			m_PropMemMgr.FreeDBPROPINFOSET(pPropInfoSet,cTotalPropSets);
			return hr;
		}
		pDescBufferTemp = pDescBuffer;
		//=======================================================================
		// For each supported Property Set
		//=======================================================================
		for (ulPropSets=0,ulPropSetIndex = 0; ulPropSets < cTotalPropSets; ulPropSets++ )
		{
			BOOL fGetAllProps = FALSE;
			
			// if the propinfo is not filled manually then get it from the input parameters
			if(fIsSpecialGUID == FALSE && cPropIDSets != 0)
			{
				pPropInfoSet[ulPropSetIndex].guidPropertySet = rgPropIDSets[ulPropSets].guidPropertySet;
				pPropInfoSet[ulPropSetIndex].cPropertyInfos  = rgPropIDSets[ulPropSets].cPropertyIDs;
			}

			if (pPropInfoSet[ulPropSetIndex].guidPropertySet == DBPROPSET_DBINIT  &&
				 pPropInfoSet[ulPropSetIndex].cPropertyInfos == 0 )
			{
				fGetAllProps = TRUE;
				pPropInfoSet[ulPropSetIndex].cPropertyInfos  = NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES;
			}
			else
			if (pPropInfoSet[ulPropSetIndex].guidPropertySet == DBPROPSET_WMIOLEDB_DBINIT &&
				 pPropInfoSet[ulPropSetIndex].cPropertyInfos == 0 )
			{
				fGetAllProps = TRUE;
				pPropInfoSet[ulPropSetIndex].cPropertyInfos  = NUMBER_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES;
			}
			else 
			if( fDSOInitialized )
			{
				if (pPropInfoSet[ulPropSetIndex].guidPropertySet == DBPROPSET_DATASOURCEINFO  &&
					 pPropInfoSet[ulPropSetIndex].cPropertyInfos == 0 )
				{
					fGetAllProps = TRUE;
					pPropInfoSet[ulPropSetIndex].cPropertyInfos  = NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES;
				}
				else
				if (pPropInfoSet[ulPropSetIndex].guidPropertySet == DBPROPSET_ROWSET  &&
					 pPropInfoSet[ulPropSetIndex].cPropertyInfos == 0 )
				{
					fGetAllProps = TRUE;
					pPropInfoSet[ulPropSetIndex].cPropertyInfos  = NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;
				}
				else 
				if (pPropInfoSet[ulPropSetIndex].guidPropertySet == DBPROPSET_WMIOLEDB_ROWSET  &&
					 pPropInfoSet[ulPropSetIndex].cPropertyInfos == 0 )
				{
					fGetAllProps = TRUE;
					pPropInfoSet[ulPropSetIndex].cPropertyInfos  = NUMBER_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES;
				}
				else
				if (pPropInfoSet[ulPropSetIndex].guidPropertySet == DBPROPSET_COLUMN  &&
					 pPropInfoSet[ulPropSetIndex].cPropertyInfos == 0 )
				{
					fGetAllProps = TRUE;
					pPropInfoSet[ulPropSetIndex].cPropertyInfos  = NUMBER_OF_SUPPORTED_COLUMN_PROPERTIES;
				}
				else
				if (pPropInfoSet[ulPropSetIndex].guidPropertySet == DBPROPSET_WMIOLEDB_COLUMN  &&
					 pPropInfoSet[ulPropSetIndex].cPropertyInfos == 0 )
				{
					fGetAllProps = TRUE;
					pPropInfoSet[ulPropSetIndex].cPropertyInfos  = NUMBER_OF_SUPPORTED_WMIOLEDB_COLUMN_PROPERTIES;
				}
/*						if (pPropInfoSet[ulPropSetIndex].guidPropertySet == DBPROPSET_WMIOLEDB_COMMAND  &&
					 pPropInfoSet[ulPropSetIndex].cPropertyInfos == 0 )
				{
					fGetAllProps = TRUE;
					pPropInfoSet[ulPropSetIndex].cPropertyInfos  = NUMBER_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES;
				}
*/						
//						else if (rgPropIDSets[ulPropSets].cPropertyIDs == 0)
				else if (pPropInfoSet[ulPropSetIndex].cPropertyInfos == 0)
					fPropsinError = TRUE;
			}
//					else if (rgPropIDSets[ulPropSets].cPropertyIDs == 0)
			else if (pPropInfoSet[ulPropSetIndex].cPropertyInfos == 0)
			{
				
				//===============================================================
				// Since we do not support it should return a error with 0 & NULL
				//===============================================================
				fPropsinError = TRUE;
			}
			
			
			if (pPropInfoSet[ulPropSetIndex].cPropertyInfos){

				//===============================================================
				// use task memory allocater to alloc array of DBPROPINFO structs
				//===============================================================
				hr = m_PropMemMgr.AllocDBPROPINFO(pPropInfo,pPropInfoSet,ulPropSetIndex);
				if (!pPropInfo)	{
					m_PropMemMgr.FreeDBPROPINFOSET(pPropInfoSet,cTotalPropSets);
					pDescBuffer = pDescBufferTemp;
					m_PropMemMgr.FreeDESCRIPTBuffer(pDescBuffer,ppDescBuffer);
					return E_OUTOFMEMORY ;
				}
			
				pPropInfoSet[ulPropSetIndex].rgPropertyInfos = &pPropInfo[0];

				memset( pPropInfo, 0, 
					(pPropInfoSet[ulPropSetIndex].cPropertyInfos * sizeof( DBPROPINFO )));
			}

			if(!IsPropertySetSupported(pPropInfoSet[ulPropSetIndex].guidPropertySet))
			{
				for (cCount=0; cCount < pPropInfoSet[ulPropSetIndex].cPropertyInfos; cCount++)
				{
					pPropInfo[cCount].dwPropertyID	= rgPropIDSets[ulPropSets].rgPropertyIDs[cCount];
					pPropInfo[cCount].dwFlags		= DBPROPFLAGS_NOTSUPPORTED;
					fPropsinError = TRUE;
					pPropInfo[cCount].pwszDescription = NULL;
				}
			}
			else
			{
				//===============================================================
				// for each prop in our table..
				//===============================================================
				for (cCount=0; cCount < pPropInfoSet[ulPropSetIndex].cPropertyInfos; cCount++){

					//===========================================================
					// init the Variant right up front that way we can 
					// VariantClear with no worried (if we need to)
					//===========================================================
					VariantInit( &pPropInfo[cCount].vValues );

					//===========================================================
					// set the description pointer
					//===========================================================
					pPropInfo[cCount].pwszDescription = pDescBuffer;

					//===========================================================
					// Check supported property sets
					//===========================================================
					if ( (pPropInfoSet[ulPropSetIndex].guidPropertySet == DBPROPSET_DBINIT) && (fGetAllProps) ){

						//=======================================================
						// load up their DBPROPINFO from our table
						//=======================================================
						fPropsSucceed = TRUE;
						fRet = LoadDBPROPINFO( &s_rgprop[START_OF_SUPPORTED_DBINIT_PROPERTIES + cCount], &pPropInfo[cCount] );
					}
					else
					if ( (pPropInfoSet[ulPropSetIndex].guidPropertySet == DBPROPSET_WMIOLEDB_DBINIT) && (fGetAllProps) ){

						//=======================================================
						// load up their DBPROPINFO from our table
						//=======================================================
						fPropsSucceed = TRUE;
						fRet = LoadDBPROPINFO( &s_rgprop[START_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES + cCount], &pPropInfo[cCount] );
					}
					else if ( (pPropInfoSet[ulPropSetIndex].guidPropertySet == DBPROPSET_DATASOURCEINFO) && fGetAllProps && fDSOInitialized){

						//=======================================================
						// load up their DBPROPINFO from our table
						//=======================================================
						fPropsSucceed = TRUE;
						fRet = LoadDBPROPINFO( &s_rgprop[START_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES + cCount], &pPropInfo[cCount] );
					}

					else if ( (pPropInfoSet[ulPropSetIndex].guidPropertySet == DBPROPSET_ROWSET) && fGetAllProps && fDSOInitialized){

						//=======================================================
						// load up their DBPROPINFO from our table
						//=======================================================
						fPropsSucceed = TRUE;
						fRet = LoadDBPROPINFO( &s_rgprop[START_OF_SUPPORTED_ROWSET_PROPERTIES + cCount],&pPropInfo[cCount] );
					}
					else if ( (pPropInfoSet[ulPropSetIndex].guidPropertySet == DBPROPSET_WMIOLEDB_ROWSET) && fGetAllProps && fDSOInitialized){

						//=======================================================
						// load up their DBPROPINFO from our table
						//=======================================================
						fPropsSucceed = TRUE;
						fRet = LoadDBPROPINFO( &s_rgprop[START_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES + cCount],&pPropInfo[cCount] );
					}
					else if ( (pPropInfoSet[ulPropSetIndex].guidPropertySet == DBPROPSET_COLUMN) && fGetAllProps && fDSOInitialized){

						//=======================================================
						// load up their DBPROPINFO from our table
						//=======================================================
						fPropsSucceed = TRUE;
						fRet = LoadDBPROPINFO( &s_rgprop[START_OF_SUPPORTED_COLUMN_PROPERTIES + cCount],&pPropInfo[cCount] );
					}
					else if ( (pPropInfoSet[ulPropSetIndex].guidPropertySet == DBPROPSET_WMIOLEDB_COLUMN) && fGetAllProps && fDSOInitialized){

						//=======================================================
						// load up their DBPROPINFO from our table
						//=======================================================
						fPropsSucceed = TRUE;
						fRet = LoadDBPROPINFO( &s_rgprop[START_OF_SUPPORTED_WMIOLEDB_COLUMN_PROPERTIES + cCount],&pPropInfo[cCount] );
					}
/*						else if ( (pPropInfoSet[ulPropSetIndex].guidPropertySet == DBPROPSET_WMIOLEDB_COMMAND) && fGetAllProps && fDSOInitialized){

						//=======================================================
						// load up their DBPROPINFO from our table
						//=======================================================
						fPropsSucceed = TRUE;
						fRet = LoadDBPROPINFO( &s_rgprop[START_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES + cCount],&pPropInfo[cCount] );
					}
*/						else{
						ULONG ulIndex;

						pPropInfo[cCount].dwPropertyID	= rgPropIDSets[ulPropSets].rgPropertyIDs[cCount];
						pPropInfo[cCount].dwFlags		= DBPROPFLAGS_NOTSUPPORTED;

						if ( (GetPropIndexFromAllSupportedProps(rgPropIDSets[ulPropSets].rgPropertyIDs[cCount], &ulIndex)) &&
							 (fDSOInitialized || (pPropInfoSet[ulPropSetIndex].guidPropertySet == DBPROPSET_DBINIT)) ){
							fPropsSucceed = TRUE;
							fRet = LoadDBPROPINFO( &s_rgprop[ulIndex], &pPropInfo[cCount] );
						}
						else{
							fPropsinError = TRUE;
							pPropInfo[cCount].pwszDescription = NULL;
						}
					}

					if (!fRet){

						m_PropMemMgr.FreeDBPROPINFOSET(pPropInfoSet,cTotalPropSets);
						
						if ( ppDescBuffer ){
							*ppDescBuffer = NULL;
						}
						g_pIMalloc->Free( pDescBufferTemp );
						return E_FAIL ;
					}

					//===========================================================
					// move the description pointer to the next
					//===========================================================
					if ( pPropInfo[cCount].pwszDescription ){
						pDescBuffer += (wcslen(pPropInfo[cCount].pwszDescription) + sizeof(CHAR));
				}
				}
			}
			//===============================================================
			// Set local back to FALSE
			//===============================================================
			fGetAllProps = FALSE;

//			cPropSetsInSpecialGUID--;
			ulPropSetIndex++;
		}
	}
	else
	if(fIsSpecialGUID && ulPropSetIndex == 0)
	{
		hr = S_OK;
	}
	else
	{
		hr = DB_E_ERRORSOCCURRED;
	}


	if(ulPropSetIndex)
	{
		//===================================================================
		// set count of properties and property information
		//===================================================================
		*pcPropInfoSets	 = ulPropSetIndex;
		*prgPropInfoSets = pPropInfoSet;
	}

	if(SUCCEEDED(hr))
	{
		if ( !fPropsSucceed && fPropsinError ){
			if ( ppDescBuffer ){
				*ppDescBuffer = NULL;
			}
			g_pIMalloc->Free( pDescBufferTemp );
			hr = DB_E_ERRORSOCCURRED ;
		}
		else if ( fPropsSucceed && fPropsinError )
			hr = DB_S_ERRORSOCCURRED ;
		else
			hr =  S_OK ;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Returns current settings of all properties supported by the DSO/rowset
//
// HRESULT
//      S_OK           The method succeeded
//      E_INVALIDARG   pcProperties or prgPropertyInfo was NULL
//      E_OUTOFMEMORY  Out of memory
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUtilProp::GetProperties(	DWORD			    dwBitMask,			//IN   Mask if Initialized
		                                ULONG				cPropertyIDSets,	//IN   # of restiction property IDs
		                                const DBPROPIDSET	rgPropertyIDSets[],	//IN   restriction guids
		                                ULONG*              pcPropertySets,		//OUT  count of properties returned
		                                DBPROPSET**			prgPropertySets		//OUT  property information returned
    )
{
    BOOL			fRet		  = TRUE;
	BOOL			fPropsinError = FALSE;
	BOOL			fPropsSucceed = FALSE;
    ULONG			cProps		  = 0;
	ULONG			cCount		  = 0;
    ULONG			ulPropertySets= 0;
    DBPROP*			pProp;
    DBPROPSET*		pPropSet;
	BOOL			bDSOInitialized = FALSE;
	ULONG			ulIndex			= 0;
	HRESULT			hr				= S_OK;

    //======================================================================
	// save the count of PropertyIDSets
    //======================================================================
	cProps = cPropertyIDSets;

    //======================================================================
	// If the consumer does not restrict the property sets by specify an 
    // array of property sets and a cPropertySets greater than 0, then we 
    // need to make sure we have some to return
    //======================================================================

	if ( (dwBitMask & PROPSET_DSOINIT) == PROPSET_DSOINIT )
		bDSOInitialized = TRUE;

	if( cPropertyIDSets == 0 ){

        //=================================================================
		// only allow the DBINIT and DATASOURCE if Initialized
        //=================================================================
		cProps = GetNumberOfPropertySets(bDSOInitialized,dwBitMask);
	}

    //=====================================================================
    // use task memory allocater to alloc a DBPROPSET struct
    //=====================================================================
    pPropSet = (DBPROPSET*) g_pIMalloc->Alloc(cProps *  sizeof( DBPROPSET ));
    if ( !pPropSet )
        return  E_OUTOFMEMORY ;

    memset( pPropSet, 0, (cProps * sizeof( DBPROPSET )));

	if(cPropertyIDSets == 0)
	{
		FillPropStruct(bDSOInitialized,dwBitMask,pPropSet);
	}

	if(pcPropertySets)
	{
		*pcPropertySets = 0;
	}
	if(prgPropertySets)
	{
		*prgPropertySets = NULL;
	}
    //=====================================================================
	// For each supported Property Set
    //=====================================================================
	for (ulPropertySets=0; ulPropertySets < cProps; ulPropertySets++){
		BOOL fGetAllProps = FALSE;



        //=====================================================================
		// If no restrictions return all properties from the three supported 
        // property sets
        //=====================================================================
		if ( cPropertyIDSets == 0 ){
				fGetAllProps = TRUE;
				
/*                //=============================================================
				// only do this once
                //=============================================================
				if ( ulPropertySets == 0 ){

                    if( !(dwBitMask & PROPSET_SESSION) ){
                        
						if ( !(dwBitMask & PROPSET_ROWSET) ){
								pPropSet[0].guidPropertySet = DBPROPSET_DBINIT;
								pPropSet[0].cProperties  = NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES;

							if( dwBitMask & PROPSET_INIT ){
								pPropSet[1].guidPropertySet = DBPROPSET_DATASOURCEINFO;
								pPropSet[1].cProperties  = NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES;
							}
						}
						else{
							pPropSet[0].guidPropertySet = DBPROPSET_ROWSET;
							pPropSet[0].cProperties  = NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;
						}
					}
				}
*/		}
		else
		{
			pPropSet[ulPropertySets].guidPropertySet = rgPropertyIDSets[ulPropertySets].guidPropertySet;

			// if propertyset is supported by provider , but not available for the current OLEDB object ,
			// then throw error
			// if the requested number of propertysets is more than one then , the other properties should be 
			// fetched and DB_S_ERRORSOCCURRED should be thrown
			if((S_OK != (hr = IsValidPropertySet(bDSOInitialized,pPropSet[ulPropertySets].guidPropertySet))) &&
				IsPropertySetSupported(pPropSet[ulPropertySets].guidPropertySet) && 
				rgPropertyIDSets[ulPropertySets].cPropertyIDs == 0)
			{
				if(cProps > 1)
				{
					fPropsinError = TRUE;
					continue;
				}
				else
				{
					*pcPropertySets	= 1;
					*prgPropertySets = pPropSet;
					return DB_E_ERRORSOCCURRED;
				}
			}

			pPropSet[ulPropertySets].cProperties  = rgPropertyIDSets[ulPropertySets].cPropertyIDs;

			if( rgPropertyIDSets[ulPropertySets].cPropertyIDs == 0 && 
				rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_PROPERTIESINERROR )
			{
				fPropsSucceed = TRUE;
				continue;
			}

			if( rgPropertyIDSets[ulPropertySets].cPropertyIDs == 0 ){
				fGetAllProps = TRUE;

				if( rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT ){
					pPropSet[ulPropertySets].cProperties  = NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES;
				}
				else
				if( rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_WMIOLEDB_DBINIT ){
					pPropSet[ulPropertySets].cProperties  = NUMBER_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES;
				}
				else if( (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEINFO) &&
						 ((dwBitMask & PROPSET_DSOINIT) == PROPSET_DSOINIT) ){
					pPropSet[ulPropertySets].cProperties  = NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES;
				}
				else if( (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_ROWSET) &&
						 (dwBitMask & PROPSET_ROWSET)){
					pPropSet[ulPropertySets].cProperties  = NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;
				}
				else if( (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_WMIOLEDB_ROWSET) &&
						 (dwBitMask & PROPSET_ROWSET)){
					pPropSet[ulPropertySets].cProperties  = NUMBER_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES;
				}
				else if( (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_COLUMN) &&
						 (dwBitMask & PROPSET_COLUMN)){
					pPropSet[ulPropertySets].cProperties  = NUMBER_OF_SUPPORTED_COLUMN_PROPERTIES;
				}
				else if( (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_WMIOLEDB_COLUMN) &&
						 (dwBitMask & PROPSET_COLUMN)){
					pPropSet[ulPropertySets].cProperties  = NUMBER_OF_SUPPORTED_WMIOLEDB_COLUMN_PROPERTIES;
				}
/*				else if( (rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_WMIOLEDB_COMMAND) &&
						 (dwBitMask & PROPSET_COMMAND)){
					pPropSet[ulPropertySets].cProperties  = NUMBER_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES;
				}
*/				else{
					fGetAllProps = FALSE;
					fPropsinError = TRUE;
				}
			}
		}
		
		if( pPropSet[ulPropertySets].cProperties ){

            //=============================================================
		    // use task memory allocater to alloc array of DBPROP structs
            //=============================================================
			pProp = (DBPROP*) g_pIMalloc->Alloc(sizeof( DBPROP ) *	 pPropSet[ulPropertySets].cProperties);

			if (!pProp){

				for(ULONG ul=0; ul<ulPropertySets; ul++){

					for(ULONG ul2=0; ul2<pPropSet[ul].cProperties; ul2++)
						VariantClear( &pPropSet[ul].rgProperties[ul2].vValue );

					g_pIMalloc->Free( pPropSet[ul].rgProperties );
				}
				g_pIMalloc->Free( pPropSet );

				return E_OUTOFMEMORY ;
			}
		
			pPropSet[ulPropertySets].rgProperties = &pProp[0];

			memset( pProp, 0, (pPropSet[ulPropertySets].cProperties * sizeof( DBPROP )));
		}

        //=================================================================
	    // for each prop in our table..
        //=================================================================
		for (cCount=0; cCount < pPropSet[ulPropertySets].cProperties; cCount++){

            //=============================================================
			// init the Variant right up front
			// that way we can VariantClear with no worried (if we need to)
            //=============================================================
			VariantInit( &pProp[cCount].vValue );

          //=============================================================
			// Check supported property sets
            //=============================================================
			if ( pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT && fGetAllProps )	{
				fPropsSucceed = TRUE;

                //=========================================================
				// load up their DBPROP from our table
                //=========================================================
				pProp[cCount].dwPropertyID	= s_rgprop[START_OF_SUPPORTED_DBINIT_PROPERTIES + cCount].dwPropertyID;
//				fRet = LoadDBPROP( &s_rgprop[START_OF_SUPPORTED_DBINIT_PROPERTIES + cCount],&pProp[cCount] );
			}
			else
			if ( pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_WMIOLEDB_DBINIT && fGetAllProps )	{
				fPropsSucceed = TRUE;

                //=========================================================
				// load up their DBPROP from our table
                //=========================================================
				pProp[cCount].dwPropertyID	= s_rgprop[START_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES + cCount].dwPropertyID;
//				fRet = LoadDBPROP( &s_rgprop[START_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES + cCount],&pProp[cCount] );
			}
			else if ( pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEINFO && fGetAllProps ){
				fPropsSucceed = TRUE;
                //=========================================================
				// load up their DBPROPINFO from our table
                //=========================================================
				pProp[cCount].dwPropertyID	= s_rgprop[START_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES + cCount].dwPropertyID;
//				fRet = LoadDBPROP( &s_rgprop[START_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES + cCount],&pProp[cCount] );
			}
			else if ( pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_ROWSET && fGetAllProps ){
				fPropsSucceed = TRUE;

                //=========================================================
				// load up their DBPROPINFO from our table
                //=========================================================
				pProp[cCount].dwPropertyID	= s_rgprop[START_OF_SUPPORTED_ROWSET_PROPERTIES + cCount].dwPropertyID;
//				fRet = LoadDBPROP( &s_rgprop[START_OF_SUPPORTED_ROWSET_PROPERTIES + cCount], &pProp[cCount] );
			}
			else if ( pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_WMIOLEDB_ROWSET && fGetAllProps ){
				fPropsSucceed = TRUE;

                //=========================================================
				// load up their DBPROPINFO from our table
                //=========================================================
				pProp[cCount].dwPropertyID	= s_rgprop[START_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES + cCount].dwPropertyID;
//				fRet = LoadDBPROP( &s_rgprop[START_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES + cCount], &pProp[cCount] );
			}
			else if ( pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_COLUMN && fGetAllProps ){
				fPropsSucceed = TRUE;

                //=========================================================
				// load up their DBPROPINFO from our table
                //=========================================================
				pProp[cCount].dwPropertyID	= s_rgprop[START_OF_SUPPORTED_COLUMN_PROPERTIES + cCount].dwPropertyID;
//				fRet = LoadDBPROP( &s_rgprop[START_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES + cCount], &pProp[cCount] );
			}
			else if ( pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_WMIOLEDB_COLUMN && fGetAllProps ){
				fPropsSucceed = TRUE;

                //=========================================================
				// load up their DBPROPINFO from our table
                //=========================================================
				pProp[cCount].dwPropertyID	= s_rgprop[START_OF_SUPPORTED_WMIOLEDB_COLUMN_PROPERTIES + cCount].dwPropertyID;
//				fRet = LoadDBPROP( &s_rgprop[START_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES + cCount], &pProp[cCount] );
			}
/*			else if ( pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_WMIOLEDB_COMMAND && fGetAllProps ){
				fPropsSucceed = TRUE;

                //=========================================================
				// load up their DBPROPINFO from our table
                //=========================================================
				pProp[cCount].dwPropertyID	= s_rgprop[START_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES + cCount].dwPropertyID;
//				fRet = LoadDBPROP( &s_rgprop[START_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES + cCount], &pProp[cCount] );
			}
*/			else
			{

				pProp[cCount].dwPropertyID	= rgPropertyIDSets[ulPropertySets].rgPropertyIDs[cCount];
				pProp[cCount].dwStatus		= DBPROPSTATUS_NOTSUPPORTED;
			}
			if(GetPropIndex(pProp[cCount].dwPropertyID, &ulIndex))
			{
				fPropsSucceed = FALSE;

				switch(dwBitMask)
				{
					case PROPSET_DSO:	
					case PROPSET_DSOINIT:
						if(pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT ||
							 pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_WMIOLEDB_DBINIT ||
							 ((pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCE  ||
							   pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEINFO) &&
							   bDSOInitialized == TRUE)){
							fPropsSucceed = TRUE;
						}
						break;


					case PROPSET_INIT:	
						if(pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT ||
							 pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_WMIOLEDB_DBINIT)	{
							fPropsSucceed = TRUE;
						}
						break;

					case PROPSET_SESSION:	
						if(pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_SESSION){
							fPropsSucceed = TRUE;
						}
						break;


                    case PROPSET_COMMAND:
					    if(pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_ROWSET ||
                            pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_WMIOLEDB_ROWSET) {
//							 || pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_WMIOLEDB_COMMAND){
							fPropsSucceed = TRUE;
						}
						break;

					case PROPSET_ROWSET:	
						if(pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_ROWSET ||
							pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_WMIOLEDB_ROWSET){
							fPropsSucceed = TRUE;
						}
						break;

					case PROPSET_COLUMN:	
						if(pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_COLUMN ||
							pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_WMIOLEDB_COLUMN){
							fPropsSucceed = TRUE;
						}
						break;

					default:
						fPropsSucceed = FALSE;

				};

				if(fPropsSucceed == TRUE)
				{
					fRet = LoadDBPROP( &m_prgproperties[ulIndex], &pProp[cCount] );
				}
				else
					fPropsinError = TRUE;
			}
			else
			{
				pProp[cCount].dwPropertyID	= rgPropertyIDSets[ulPropertySets].rgPropertyIDs[cCount];
				pProp[cCount].dwStatus		= DBPROPSTATUS_NOTSUPPORTED;
				fPropsinError				= TRUE;
			}


/*			if(  (GetPropIndex(pProp[cCount].dwPropertyID, &ulIndex)) &&
				 ((((dwBitMask & PROPSET_DSO) || (dwBitMask & PROPSET_INIT)) && 
				   (pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT)) ||
				 (((dwBitMask & PROPSET_DSO) || (dwBitMask & PROPSET_INIT))&& 
				   (pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_WMIOLEDB_DBINIT)) ||
				  (((dwBitMask & PROPSET_DSOINIT) == PROPSET_DSOINIT) &&
				   ((pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCE) ||
					(pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEINFO))) ||
				  ((dwBitMask & PROPSET_SESSION) && 
				   (pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_SESSION)) ||
				  ((dwBitMask & PROPSET_ROWSET) && 
				   ((pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_ROWSET) ||
					(pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_WMIOLEDB_ROWSET))) ||
				  ((dwBitMask & PROPSET_COLUMN) && 
				   ((pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_COLUMN) ||
					(pPropSet[ulPropertySets].guidPropertySet == DBPROPSET_WMIOLEDB_COLUMN))) ) ){
				fPropsSucceed = TRUE;
				fRet = LoadDBPROP( &m_prgproperties[ulIndex], &pProp[cCount] );
			}
			else
				fPropsinError = TRUE;
			
*/
			if (!fRet){
				ULONG ulFor;

                //=========================================================
				// something went wrong
				// clear all variants used so far..
                //=========================================================
                for (ulFor = 0; ulFor < cCount; ulFor++){
                    VariantClear( &pProp[ulFor].vValue );
                }

                //=========================================================
				// .. delete the pPropInfo array, return failure
                //=========================================================
				g_pIMalloc->Free( pProp );
				g_pIMalloc->Free( pPropSet );
				return E_FAIL ;
			}
		}
        //=================================================================
		// Set local back to FALSE
        //=================================================================
		fGetAllProps = FALSE;
	}

    //=====================================================================
	// set count of properties and property information
    //=====================================================================
    if(cProps > 0)
	{
		*pcPropertySets	 = cProps;
		*prgPropertySets = pPropSet;
	}

	if ( (!fPropsSucceed && cPropertyIDSets) || (!fPropsSucceed && fPropsinError) )
	{
/*		g_pIMalloc->Free( pProp );
		g_pIMalloc->Free( pPropSet );
		*pcPropertySets	 = 0;
		*prgPropertySets = NULL;
*/		return  DB_E_ERRORSOCCURRED ;
	}
	else if ( fPropsSucceed && fPropsinError )
		return  DB_S_ERRORSOCCURRED ;
	else
		return  S_OK ;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Initialize the buffers and check for E_INVALIDARG cases
//
// HRESULT indicating the status of the method
//		S_OK            Properties gathered
//		E_INVALIDARG    Invalid parameter values
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CUtilProp::SetPropertiesArgChk(	const ULONG cPropertySets,	    //IN Count of structs returned
	                                    const DBPROPSET rgPropertySets[],//IN Array of Properties Sets
	                                    BOOL bDSOInitialized)
{
	HRESULT hr = S_OK;
    //================================================================
	// Argument Checking
    //================================================================
    if ((cPropertySets > 0) && !rgPropertySets)  
		return E_INVALIDARG ;

    //================================================================
	// New argument check for > 1 cPropertyIDs and NULL pointer for 
	// array of property ids.
    //================================================================
	for(ULONG ul=0; ul<cPropertySets && hr == S_OK; ul++){

		// Setting a error property set is not allowed
		if(rgPropertySets[ul].guidPropertySet == DBPROPSET_PROPERTIESINERROR )
		{
			hr = E_INVALIDARG;
		}
		else
		if( rgPropertySets[ul].cProperties && !(rgPropertySets[ul].rgProperties) )
		{
			hr = E_INVALIDARG ;
			break;
		}
		else
		{
			// Check if all the propertysetID is correct for this object
			hr = IsValidPropertySet(bDSOInitialized,rgPropertySets[ul].guidPropertySet);
		}
		if(FAILED(hr))
			break;
		else
			hr = S_OK;


	}
	
	return  hr ;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Set current settings of properties supported by the DSO/rowset
//
// HRESULT
//      S_OK           The method succeeded
//      E_INVALIDARG   pcProperties or prgPropertyInfo was NULL
//      E_OUTOFMEMORY  Out of memory
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUtilProp::SetProperties (	const DWORD	dwBitMask,			//IN		Type of PropSet
		                                const ULONG	cPropertyIDSets,	//IN		# of DBPROPSET
		                                DBPROPSET	rgPropertyIDSets[]	//IN	Array of property sets
	)
{
    ULONG ulPropertySets  = 0;
	ULONG cCount		  = 0;
	BOOL  fSetAllProps	  = TRUE;
	BOOL  fOnePropSet	  = FALSE;
	BOOL  fWarn			  = FALSE;
	ULONG cNoOfProps	  = 0;
	BOOL  fFail			  = FALSE;
	HRESULT hr			  = S_OK;

    //====================================================================
	// For each supported Property Set
    //====================================================================
	for (ulPropertySets=0; ulPropertySets < cPropertyIDSets; ulPropertySets++){
		ULONG ulIndex = 0;

        //================================================================
	    // for each prop in the propset
        //================================================================
		for (cCount=0; cCount < rgPropertyIDSets[ulPropertySets].cProperties; cCount++)	{

			cNoOfProps++;
			rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_OK;
			
            //============================================================
			// only allow the DBINIT and DATASOURCE
            //============================================================
			if ( (dwBitMask & PROPSET_DSO) && ((rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DBINIT) && 
				 (dwBitMask & PROPSET_INIT)) ){
				 rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_NOTSETTABLE;
				 fSetAllProps = FALSE;
			}
			else if ( ((dwBitMask & PROPSET_DSO) &&
					   (rgPropertyIDSets[ulPropertySets].guidPropertySet != DBPROPSET_DATASOURCE &&
					    rgPropertyIDSets[ulPropertySets].guidPropertySet != DBPROPSET_DATASOURCEINFO &&
					    rgPropertyIDSets[ulPropertySets].guidPropertySet != DBPROPSET_WMIOLEDB_DBINIT &&
					    rgPropertyIDSets[ulPropertySets].guidPropertySet != DBPROPSET_DBINIT))   ||
					  ((rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCE ||
					    rgPropertyIDSets[ulPropertySets].guidPropertySet == DBPROPSET_DATASOURCEINFO) && 
					   !(dwBitMask & PROPSET_INIT)) ){
				 rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
				 fSetAllProps = FALSE;

				 if(rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwOptions == DBPROPOPTIONS_OPTIONAL)
					 fWarn = TRUE;
			}
            //============================================================
			// only allow the SESSION
            //============================================================
			else if ( (dwBitMask & PROPSET_SESSION) &&  (rgPropertyIDSets[ulPropertySets].guidPropertySet != DBPROPSET_SESSION) ){
				 rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
				 fSetAllProps = FALSE;

				 if(rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwOptions == DBPROPOPTIONS_OPTIONAL)
					 fWarn = TRUE;
			}
            //============================================================
			// only allow the ROWSET
            //============================================================
			else if ( (dwBitMask & PROPSET_ROWSET) && (rgPropertyIDSets[ulPropertySets].guidPropertySet != DBPROPSET_ROWSET) &&
						(rgPropertyIDSets[ulPropertySets].guidPropertySet != DBPROPSET_WMIOLEDB_ROWSET) ){
				 rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
				 fSetAllProps = FALSE;

				 if(rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwOptions == DBPROPOPTIONS_OPTIONAL)
					 fWarn = TRUE;
			}
            //============================================================
			// only allow the COLUMN
            //============================================================
			else if ( (dwBitMask & PROPSET_COLUMN) && (rgPropertyIDSets[ulPropertySets].guidPropertySet != DBPROPSET_COLUMN) &&
						(rgPropertyIDSets[ulPropertySets].guidPropertySet != DBPROPSET_WMIOLEDB_COLUMN) ){
				 rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
				 fSetAllProps = FALSE;

				 if(rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwOptions == DBPROPOPTIONS_OPTIONAL)
					 fWarn = TRUE;
			}
			else if ( (dwBitMask & PROPSET_COMMAND) && (rgPropertyIDSets[ulPropertySets].guidPropertySet != DBPROPSET_ROWSET) &&
						(rgPropertyIDSets[ulPropertySets].guidPropertySet != DBPROPSET_WMIOLEDB_ROWSET) ) {
//						&& (rgPropertyIDSets[ulPropertySets].guidPropertySet != DBPROPSET_WMIOLEDB_COMMAND)){
				 rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
				 fSetAllProps = FALSE;

				 if(rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwOptions == DBPROPOPTIONS_OPTIONAL)
					 fWarn = TRUE;
			}
			else{

                //========================================================
				// get the index in the array
                //========================================================
				if ( GetPropIndex(rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwPropertyID, &ulIndex) ){

                    //====================================================
					// arg checking for the prop
                    //====================================================
					if ( (DBPROPOPTIONS_OPTIONAL != rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwOptions) &&
						 (DBPROPOPTIONS_REQUIRED != rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwOptions) ){
						rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_BADOPTION;
		 				fSetAllProps = FALSE;
					}
					else if ( !(m_prgproperties[ulIndex].dwFlags & DBPROPFLAGS_WRITE) &&
								rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.vt == m_prgproperties[ulIndex].vtType){
						
						// Check if it is been tried to set to default value
						if (((rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.vt == VT_BOOL) && 
							  ((rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.boolVal == VARIANT_TRUE) != m_prgproperties[ulIndex].boolVal)) ||
							 ((rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.vt == VT_I4) && 
							  (rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.lVal != m_prgproperties[ulIndex].longVal)) ||
							 ((rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.vt == VT_BSTR) && 
							  (wcscmp(rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.bstrVal,m_prgproperties[ulIndex].pwstrVal))) )
						{

		 					fSetAllProps = FALSE;
							rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_NOTSETTABLE;

							if(rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwOptions == DBPROPOPTIONS_OPTIONAL)
								fWarn = TRUE;
						}
						else
							fOnePropSet = TRUE;

					}
					else if ( ((m_prgproperties[ulIndex].vtType != rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.vt) &&
							   (VT_EMPTY != rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.vt)) ||
							  (IsValidValue(&rgPropertyIDSets[ulPropertySets].rgProperties[cCount]) == S_FALSE)) {
						rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_BADVALUE;
		 				fSetAllProps = FALSE;

						if(rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwOptions == DBPROPOPTIONS_OPTIONAL)
							fWarn = TRUE;
					}
					else
					{
						fOnePropSet = TRUE;
							
						if( rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.vt == VT_EMPTY )
						{
							memcpy( &m_prgproperties[ulIndex], &s_rgprop[m_nPropStartIndex + ulIndex], sizeof(PROPSTRUCT));
						}
						else
						{
							// switch on the propid
							switch( m_prgproperties[ulIndex].dwPropertyID )
							{
								case DBPROP_INIT_DATASOURCE:
								case DBPROP_AUTH_USERID:
								case DBPROP_AUTH_PASSWORD:
								case DBPROP_WMIOLEDB_DS_FILTER:
								case DBPROP_WMIOLEDB_DS_ATTRIBUTES:
								case DBPROP_WMIOLEDB_AUTHORITY:
								case DBPROP_WMIOLEDB_QUERYLANGUAGE:
									SAFE_DELETE_ARRAY(m_prgproperties[ulIndex].pwstrVal);
									m_prgproperties[ulIndex].pwstrVal = new WCHAR [ SysStringLen(rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.bstrVal) +1];
									if(m_prgproperties[ulIndex].pwstrVal)
									{
										wcscpy(m_prgproperties[ulIndex].pwstrVal , rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue.bstrVal);
									}
									else
									{
										hr = E_OUTOFMEMORY;
										fFail = TRUE;
									}
									break;

								case DBPROP_INIT_HWND:
								case DBPROP_INIT_MODE:
								case DBPROP_UPDATABILITY:
								case DBPROP_WMIOLEDB_QUALIFIERS:
								case DBPROP_WMIOLEDB_QUALIFIERFLAVOR:
								case DBPROP_INIT_PROTECTION_LEVEL:
								case DBPROP_INIT_IMPERSONATION_LEVEL:
								case DBPROP_WMIOLEDB_OBJECTTYPE:
								case DBPROP_INIT_LCID:
								case DBPROP_WMIOLEDB_DS_DEREFALIAS:
								case DBPROP_WMIOLEDB_DS_SIZELIMIT:
								case DBPROP_WMIOLEDB_DS_PAGEDTIMELIMIT:
								case DBPROP_WMIOLEDB_DS_SEARCHSCOPE:
								case DBPROP_WMIOLEDB_DS_TIMEOUT:
								case DBPROP_WMIOLEDB_DS_PAGESIZE:
								case DBPROP_WMIOLEDB_DS_TIMELIMIT:
								case DBPROP_WMIOLEDB_DS_CHASEREF:

									m_prgproperties[ulIndex].longVal = V_I4(&rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue);
									break;

								case DBPROP_IRowsetChange:
								case DBPROP_CANHOLDROWS:
								case DBPROP_LITERALIDENTITY:
								case DBPROP_OWNUPDATEDELETE:
								case DBPROP_OTHERUPDATEDELETE:
								case DBPROP_CANFETCHBACKWARDS:
								case DBPROP_CANSCROLLBACKWARDS:
								case DBPROP_BOOKMARKS:
								case DBPROP_WMIOLEDB_FETCHDEEP:
								case DBPROP_IRow:
								case DBPROP_COL_NULLABLE:
								case DBPROP_COL_UNIQUE:
								case DBPROP_COL_PRIMARYKEY:
								case DBPROP_IRowsetLocate:
								case DBPROP_WMIOLEDB_SYSTEMPROPERTIES:
								case DBPROP_IGetRow:
								case DBPROP_IRowsetRefresh:
								case DBPROP_IChapteredRowset:
//								case DBPROP_OTHERINSERT:
								case DBPROP_REMOVEDELETED:
								case DBPROP_WMIOLEDB_PREV_CREATE_TOKEN :
								case DBPROP_WMIOLEDB_PREV_ASSIGNPRIMARYTOKEN :
								case DBPROP_WMIOLEDB_PREV_LOCK_MEMORY :
								case DBPROP_WMIOLEDB_PREV_INCREASE_QUOTA :
								case DBPROP_WMIOLEDB_PREV_MACHINE_ACCOUNT :
								case DBPROP_WMIOLEDB_PREV_TCB  :
								case DBPROP_WMIOLEDB_PREV_SECURITY :
								case DBPROP_WMIOLEDB_PREV_TAKE_OWNERSHIP :
								case DBPROP_WMIOLEDB_PREV_LOAD_DRIVER  :
								case DBPROP_WMIOLEDB_PREV_SYSTEM_PROFILE :
								case DBPROP_WMIOLEDB_PREV_SYSTEMTIME :
								case DBPROP_WMIOLEDB_PREV_PROF_SINGLE_PROCESS :
								case DBPROP_WMIOLEDB_PREV_INC_BASE_PRIORITY :
								case DBPROP_WMIOLEDB_PREV_CREATE_PAGEFILE :
								case DBPROP_WMIOLEDB_PREV_CREATE_PERMANENT :
								case DBPROP_WMIOLEDB_PREV_BACKUP :
								case DBPROP_WMIOLEDB_PREV_RESTORE  :
								case DBPROP_WMIOLEDB_PREV_SHUTDOWN  :
								case DBPROP_WMIOLEDB_PREV_DEBUG :
								case DBPROP_WMIOLEDB_PREV_AUDIT :
								case DBPROP_WMIOLEDB_PREV_SYSTEM_ENVIRONMENT :
								case DBPROP_WMIOLEDB_PREV_CHANGE_NOTIFY :
								case DBPROP_WMIOLEDB_PREV_REMOTE_SHUTDOWN :
								case DBPROP_WMIOLEDB_PREV_UNDOCK :
								case DBPROP_WMIOLEDB_PREV_SYNC_AGENT :
								case DBPROP_WMIOLEDB_PREV_ENABLE_DELEGATION :
								case DBPROP_WMIOLEDB_DS_ASYNCH:
								case DBPROP_WMIOLEDB_DS_CACHERESULTS:
								case DBPROP_WMIOLEDB_DS_ATTRIBONLY:
								case DBPROP_WMIOLEDB_DS_TOMBSTONE:
								case DBPROP_WMIOLEDB_ISMETHOD:
									m_prgproperties[ulIndex].boolVal = V_BOOL(&rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue);
									break;


								case DBPROP_INIT_PROMPT:
									m_prgproperties[ulIndex].longVal = V_I2(&rgPropertyIDSets[ulPropertySets].rgProperties[cCount].vValue);


							}
						}
					}
				}
				else
				{
					rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
					fSetAllProps = FALSE;

					if(rgPropertyIDSets[ulPropertySets].rgProperties[cCount].dwOptions == DBPROPOPTIONS_OPTIONAL)
						fWarn = TRUE;
					else
					{
						fFail = TRUE;
					}
				}
			}
		}
	}
	

	if(fFail)
	{
		hr = hr == S_OK ? DB_E_ERRORSOCCURRED: hr;

		return hr;
	}
	// Figure out the retcode
	if ( fSetAllProps )
		return  S_OK ;
	else if (fOnePropSet && !fSetAllProps)
		return  DB_S_ERRORSOCCURRED ;
	else if((fSetAllProps == FALSE && fOnePropSet == FALSE &&
		fWarn == TRUE && cNoOfProps == 1) && 
		(m_propType == ROWSETPROP || m_propType == BINDERPROP))
			return  DB_S_ERRORSOCCURRED ;
	else 
		return  DB_E_ERRORSOCCURRED ;
}

/////////////////////////////////////////////////////////////////////////////////////////
// Gets the number of propertysets to be returned when a special GUID is passed
/////////////////////////////////////////////////////////////////////////////////////////
ULONG CUtilProp::GetNumberOfPropertySets(BOOL fDSOInitialized,const DBPROPIDSET	rgPropIDSets[],ULONG cPropIDSets)
{
	ULONG cPropSets = 0;


	for( ULONG ulIndex = 0 ; ulIndex < cPropIDSets ; ulIndex++)
	{

		if( DBPROPSET_DBINITALL == rgPropIDSets[ulIndex].guidPropertySet)
		{
			cPropSets += 2;
		}
		else
		if(fDSOInitialized)
		{
			if(DBPROPSET_ROWSETALL == rgPropIDSets[ulIndex].guidPropertySet )
			{
				cPropSets += 2;
			}
			else
			if( DBPROPSET_DATASOURCEALL == rgPropIDSets[ulIndex].guidPropertySet)
			{
				cPropSets += 0;  // as of now there are no datasource info properties
			}
			else
			if( DBPROPSET_DATASOURCEINFOALL == rgPropIDSets[ulIndex].guidPropertySet)
			{
				cPropSets += 1;
			}
			else
			if( DBPROPSET_SESSIONALL == rgPropIDSets[ulIndex].guidPropertySet )
			{
				cPropSets += 0;  // session properties is yet to be added
			}
			else
			if(DBPROPSET_COLUMNALL == rgPropIDSets[ulIndex].guidPropertySet)
			{
				cPropSets += 2; // Columns and WMioledb_columns propertysets
			}
		}
	}

	return cPropSets;

}


/////////////////////////////////////////////////////////////////////////////////////////
// Fills the propertysets informations to be returned when a special GUID is passed for GetPropertyInfo
/////////////////////////////////////////////////////////////////////////////////////////
void CUtilProp::FillPropertySets(BOOL fDSOInitialized,
								  const DBPROPIDSET	rgPropIDSets[],
								  ULONG cPropIDSets,
								  DBPROPINFOSET* pPropInfoSet,
								  ULONG &cProperties)
{
	cProperties = 0;
	ULONG ulIndex = 0;
	ULONG ulPropSetIndex = 0;

	if(cPropIDSets == 0)
	{
		pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_DBINIT;
		pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
		cProperties									   += NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES;

		pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_WMIOLEDB_DBINIT;
		pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
		cProperties									   += NUMBER_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES;

		if(fDSOInitialized)
		{

/*			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_WMIOLEDB_COMMAND;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += NUMBER_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES;
*/
			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_ROWSET;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;

			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_WMIOLEDB_ROWSET;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += NUMBER_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES;

			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_DATASOURCEINFO;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES;

			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_COLUMN;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += NUMBER_OF_SUPPORTED_COLUMN_PROPERTIES;

			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_WMIOLEDB_COLUMN;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += NUMBER_OF_SUPPORTED_WMIOLEDB_COLUMN_PROPERTIES;
		}
	}
	else
	for( ; ulIndex < cPropIDSets ;ulIndex++)
	{
		if( fDSOInitialized == FALSE && 
			DBPROPSET_DBINITALL != rgPropIDSets[ulIndex].guidPropertySet)
		{
			pPropInfoSet[ulPropSetIndex].guidPropertySet = rgPropIDSets[ulIndex].guidPropertySet;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += 0;

		}
		else
		if(DBPROPSET_ROWSETALL == rgPropIDSets[ulIndex].guidPropertySet )
		{
			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_ROWSET;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;

			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_WMIOLEDB_ROWSET;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += NUMBER_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES;
		}
		else
		if( DBPROPSET_DATASOURCEINFOALL == rgPropIDSets[ulIndex].guidPropertySet )
		{
			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_DATASOURCEINFO;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES;
		}
		else
		if( DBPROPSET_DBINITALL == rgPropIDSets[ulIndex].guidPropertySet)
		{
			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_DBINIT;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES;

			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_WMIOLEDB_DBINIT;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += NUMBER_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES;
		}
		else
		if(DBPROPSET_COLUMNALL == rgPropIDSets[ulIndex].guidPropertySet)
		{
			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_COLUMN;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += NUMBER_OF_SUPPORTED_COLUMN_PROPERTIES;

			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_WMIOLEDB_COLUMN;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += NUMBER_OF_SUPPORTED_WMIOLEDB_COLUMN_PROPERTIES;
		}
		// NTRaid : 142133
		// 07/12/00
		// since we don't support any of the property in the following Special GUIL
		// this is been commented
/*		else
		if(DBPROPSET_DATASOURCEALL == rgPropIDSets[ulIndex].guidPropertySet )
		{
			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_DATASOURCEALL;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += 0;

		}
		else
		if(DBPROPSET_CONSTRAINTALL == rgPropIDSets[ulIndex].guidPropertySet )
		{
			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_CONSTRAINTALL;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += 0;

		}
		else
		if(DBPROPSET_INDEXALL == rgPropIDSets[ulIndex].guidPropertySet)
		{
			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_INDEXALL;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += 0;

		}
		else
		if(DBPROPSET_SESSIONALL  == rgPropIDSets[ulIndex].guidPropertySet)
		{
			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_SESSIONALL;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += 0;

		}
		else
		if(DBPROPSET_TABLEALL == rgPropIDSets[ulIndex].guidPropertySet)
		{
			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_TABLEALL;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += 0;

		}
		else
		if(DBPROPSET_TRUSTEEALL == rgPropIDSets[ulIndex].guidPropertySet)
		{
			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_TRUSTEEALL;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += 0;

		}
		else
		if(DBPROPSET_VIEWALL == rgPropIDSets[ulIndex].guidPropertySet &&  fDSOInitialized == TRUE)
		{
			pPropInfoSet[ulPropSetIndex].guidPropertySet = DBPROPSET_VIEWALL;
			pPropInfoSet[ulPropSetIndex++].cPropertyInfos  = 0;
			cProperties									   += 0;

		}
*/	}

}

/////////////////////////////////////////////////////////////////////////////////////////
// Gets the number of propertysets to be returned for a particular type of property object
// if 0 is passed for the number of property set to be retrieved
/////////////////////////////////////////////////////////////////////////////////////////
ULONG CUtilProp::GetNumberOfPropertySets(BOOL fDSOInitialized,DWORD dwBitMask)
{
	ULONG cPropSets = 0;

	switch(m_propType)
	{
		case DATASOURCEPROP :
			if(fDSOInitialized == TRUE)
				cPropSets	= 3; // DBINIT & WMIOLEDB_DBINIT && DATASOURCEINFO
			else
				cPropSets	= 2; // DBINIT & WMIOLEDB_DBINIT
			break;

		case SESSIONPROP :
			cPropSets = 0;	// number of sesssion propertysets
			break;

		case COMMANDPROP :
			cPropSets = 3; // WMIOLEDB_COMMAND & ROWSET & WMIOLEDB_ROWSET
			break;

		case ROWSETPROP :
			cPropSets = 2; // ROWSET & WMIOLEDB_ROWSET
			break;

		case BINDERPROP:
			switch(dwBitMask)
			{
				case PROPSET_INIT:
						cPropSets = 2;
						break;

				case PROPSET_DSO:
				case PROPSET_DSOINIT:
					if(fDSOInitialized == TRUE)
						cPropSets = 3;
					else
						cPropSets = 2;

					break;

				case PROPSET_SESSION:
					cPropSets = 0;
					break;

				case PROPSET_COMMAND:
					cPropSets = 3;
					break;

				case PROPSET_ROWSET:
					cPropSets = 2;
					break;

				case PROPSET_COLUMN:
					cPropSets = 2;
					break;

				default:
					cPropSets = NUMBER_OF_SUPPORTED_PROPERTY_SETS;	// all propertysets supported

			}
			break;

		case COLUMNPROP:
			cPropSets	= 2;	// COLUMNS & WMIOLEDB_COLUMN
			break;
	};

	return cPropSets;

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Reset all the properties to default properties
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CUtilProp::ResetProperties()
{
	ULONG nPropStartIndex = 0;

	switch(m_propType)
	{
		case DATASOURCEPROP :
			nPropStartIndex	= 0;
			break;

		case SESSIONPROP :
			nPropStartIndex = START_OF_SUPPORTED_SESSION_PROPERTIES;
			break;

		case COMMANDPROP :
			nPropStartIndex = NUMBER_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES;
			break;

		case ROWSETPROP :
			nPropStartIndex = START_OF_SUPPORTED_ROWSET_PROPERTIES;
			break;

		case BINDERPROP:
			nPropStartIndex = 0;
			break;
	};
	
	if(m_cProperties > 0)
	{
		memcpy(m_prgproperties, &s_rgprop[nPropStartIndex], sizeof(PROPSTRUCT) * m_cProperties );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////////////
// Fills the different PropertIDsets when the number of propertysets 
// requested for GetProperties is 0
/////////////////////////////////////////////////////////////////////////////////////////
HRESULT CUtilProp::FillPropStruct(BOOL fDSOInitialized,DWORD dwBitMask,DBPROPSET*		pPropSet)
{
	HRESULT hr = S_OK;
	ULONG lIndex = 0;

	if(pPropSet == NULL)
	{
		hr = E_FAIL;
	}
	else
	switch(m_propType)
	{
		case DATASOURCEPROP :

			pPropSet[lIndex].guidPropertySet = DBPROPSET_DBINIT;
			pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES;

			pPropSet[lIndex].guidPropertySet = DBPROPSET_WMIOLEDB_DBINIT;
			pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES;
			
			if(fDSOInitialized == TRUE)
			{
				pPropSet[lIndex].guidPropertySet = DBPROPSET_DATASOURCEINFO;
				pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES;
			}

			break;

		case SESSIONPROP :
			break;

		case COMMANDPROP :
/*			pPropSet[lIndex].guidPropertySet = DBPROPSET_WMIOLEDB_COMMAND;
			pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES;
*/			
			pPropSet[lIndex].guidPropertySet = DBPROPSET_ROWSET;
			pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;

			pPropSet[lIndex].guidPropertySet = DBPROPSET_WMIOLEDB_ROWSET;
			pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES;

			break;

		case ROWSETPROP :
			pPropSet[lIndex].guidPropertySet = DBPROPSET_ROWSET;
			pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;
			
			pPropSet[lIndex].guidPropertySet = DBPROPSET_WMIOLEDB_ROWSET;
			pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES;

			break;

		case BINDERPROP:

			switch(dwBitMask)
			{
				case PROPSET_INIT:
					pPropSet[lIndex].guidPropertySet = DBPROPSET_DBINIT;
					pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES;

					pPropSet[lIndex].guidPropertySet = DBPROPSET_WMIOLEDB_DBINIT;
					pPropSet[lIndex].cProperties		= NUMBER_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES;
					break;

				case PROPSET_DSO:
				case PROPSET_DSOINIT:
					pPropSet[lIndex].guidPropertySet = DBPROPSET_DBINIT;
					pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES;

					pPropSet[lIndex].guidPropertySet = DBPROPSET_WMIOLEDB_DBINIT;
					pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES;

					if(fDSOInitialized == TRUE)
					{
						pPropSet[lIndex].guidPropertySet = DBPROPSET_DATASOURCEINFO;
						pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES;
					}

					break;

				case PROPSET_SESSION:
					break;

				case PROPSET_COMMAND:
/*					pPropSet[lIndex].guidPropertySet = DBPROPSET_WMIOLEDB_COMMAND;
					pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES;
*/					
					pPropSet[lIndex].guidPropertySet = DBPROPSET_ROWSET;
					pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;

					pPropSet[lIndex].guidPropertySet = DBPROPSET_WMIOLEDB_ROWSET;
					pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES;

					break;

				case PROPSET_ROWSET:
					pPropSet[lIndex].guidPropertySet = DBPROPSET_ROWSET;
					pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;
					
					pPropSet[lIndex].guidPropertySet = DBPROPSET_WMIOLEDB_ROWSET;
					pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES;
					break;

				case PROPSET_COLUMN:
					pPropSet[lIndex].guidPropertySet = DBPROPSET_COLUMN;
					pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_COLUMN_PROPERTIES;

					pPropSet[lIndex].guidPropertySet = DBPROPSET_WMIOLEDB_COLUMN;
					pPropSet[lIndex++].cProperties		= START_OF_SUPPORTED_WMIOLEDB_COLUMN_PROPERTIES;
					break;

				default:
					pPropSet[lIndex].guidPropertySet = DBPROPSET_DBINIT;
					pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES;

					pPropSet[lIndex].guidPropertySet = DBPROPSET_WMIOLEDB_DBINIT;
					pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES;
					
					pPropSet[lIndex].guidPropertySet = DBPROPSET_DATASOURCEINFO;
					pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES;

/*					pPropSet[lIndex].guidPropertySet = DBPROPSET_WMIOLEDB_COMMAND;
					pPropSet[lIndex++].cProperties		= START_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES;
*/
					pPropSet[lIndex].guidPropertySet = DBPROPSET_ROWSET;
					pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;
					
					pPropSet[lIndex].guidPropertySet = DBPROPSET_WMIOLEDB_ROWSET;
					pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES;

					pPropSet[lIndex].guidPropertySet = DBPROPSET_COLUMN;
					pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_COLUMN_PROPERTIES;

					pPropSet[lIndex].guidPropertySet = DBPROPSET_WMIOLEDB_COLUMN;
					pPropSet[lIndex++].cProperties		= START_OF_SUPPORTED_WMIOLEDB_COLUMN_PROPERTIES;
			};


			break;

		case COLUMNPROP:
			pPropSet[lIndex].guidPropertySet = DBPROPSET_COLUMN;
			pPropSet[lIndex++].cProperties		= NUMBER_OF_SUPPORTED_COLUMN_PROPERTIES;

			pPropSet[lIndex].guidPropertySet = DBPROPSET_WMIOLEDB_COLUMN;
			pPropSet[lIndex++].cProperties		= START_OF_SUPPORTED_WMIOLEDB_COLUMN_PROPERTIES;
	};

	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Checks if the PropertysetIDs are proper
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CUtilProp::IsValidPropertySet(BOOL fDSOInitialized,const GUID guidPropset)
{
	HRESULT hr = S_OK;
/*
	if(guidPropset == DBPROPSET_PROPERTIESINERROR && 
		(m_propType == DATASOURCEPROP || m_propType == COMMANDPROP))
		return hr;
	else
		return DB_S_ERRORSOCCURRED;
*/
	switch(m_propType)
	{
		case DATASOURCEPROP :

			if(!( guidPropset == DBPROPSET_DBINIT ||
				(guidPropset == DBPROPSET_DATASOURCEINFO && fDSOInitialized == TRUE) ||
				guidPropset == DBPROPSET_WMIOLEDB_DBINIT ||
				guidPropset == DBPROPSET_PROPERTIESINERROR)) 
			{
				hr = DB_S_ERRORSOCCURRED;
			}
			break;

		case SESSIONPROP :
			if(!( guidPropset == DBPROPSET_SESSION))
			{
				hr = DB_S_ERRORSOCCURRED;
			}
			break;

		case COMMANDPROP :
			if(!( guidPropset == DBPROPSET_ROWSET ||
				  guidPropset == DBPROPSET_WMIOLEDB_ROWSET || 
//				  guidPropset == DBPROPSET_WMIOLEDB_COMMAND ||
				  guidPropset == DBPROPSET_PROPERTIESINERROR))
			{
				hr = DB_S_ERRORSOCCURRED;
			}

		case ROWSETPROP :
			if(!( guidPropset == DBPROPSET_ROWSET ||
				  guidPropset == DBPROPSET_WMIOLEDB_ROWSET))
			{
				hr = DB_S_ERRORSOCCURRED;
			}
			break;

		case BINDERPROP :
			hr = S_OK;
			break;

		case COLUMNPROP :
			if(!( guidPropset == DBPROPSET_COLUMN ||
				  guidPropset == DBPROPSET_WMIOLEDB_COLUMN))
			{
				hr = DB_S_ERRORSOCCURRED;
			}
			break;
	};
	
	return hr;
}

BOOL CUtilProp::IsPropertySetSupported(const GUID guidPropset)
{
	BOOL bRet = FALSE;


	if(guidPropset == DBPROPSET_PROPERTIESINERROR ||
		guidPropset == DBPROPSET_DBINIT ||
		guidPropset == DBPROPSET_DATASOURCEINFO ||
		guidPropset == DBPROPSET_WMIOLEDB_DBINIT ||
		guidPropset == DBPROPSET_SESSION ||
		guidPropset == DBPROPSET_ROWSET ||
		guidPropset == DBPROPSET_WMIOLEDB_ROWSET ||
		guidPropset == DBPROPSET_COLUMN ||
		guidPropset == DBPROPSET_WMIOLEDB_COLUMN ) 
//		|| guidPropset == DBPROPSET_WMIOLEDB_COMMAND )
		{
			bRet = TRUE;
		};
	
	return bRet;
}


ULONG CUtilProp::GetNumberofPropInfoToBeReturned(BOOL bDSOInitialized,
												 ULONG				cPropertyIDSets,
												 const DBPROPIDSET	rgPropertyIDSets[])
{
	int nProps = 0;
	if(cPropertyIDSets == 0)
	{
		nProps = NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES +
				NUMBER_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES;

		if(bDSOInitialized)
		{
			nProps = nProps + NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES +
					NUMBER_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES +
					NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES +
					NUMBER_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES +
					NUMBER_OF_SUPPORTED_COLUMN_PROPERTIES +
					NUMBER_OF_SUPPORTED_WMIOLEDB_COLUMN_PROPERTIES;
					
		}

	}
	else
	for( ULONG ulPropSets = 0; ulPropSets < cPropertyIDSets;ulPropSets++)
	{

		if (rgPropertyIDSets[ulPropSets].guidPropertySet == DBPROPSET_DBINIT) 
		{
			if(rgPropertyIDSets[ulPropSets].cPropertyIDs == 0 )
			{
				nProps += NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES  ;
			}
			else
			{
				nProps += rgPropertyIDSets[ulPropSets].cPropertyIDs;
			}
		}
		else
		if (rgPropertyIDSets[ulPropSets].guidPropertySet == DBPROPSET_WMIOLEDB_DBINIT) 
		{
			if(rgPropertyIDSets[ulPropSets].cPropertyIDs == 0 )
			{
				nProps += NUMBER_OF_SUPPORTED_WMIOLEDB_DBINIT_PROPERTIES ;
			}
			else
			{
				nProps += rgPropertyIDSets[ulPropSets].cPropertyIDs;
			}
		}
		else 
		if( bDSOInitialized )
		{
			if(rgPropertyIDSets[ulPropSets].guidPropertySet == DBPROPSET_DATASOURCEINFO)
			{
				if(rgPropertyIDSets[ulPropSets].cPropertyIDs == 0 )
				{
					nProps += NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES;
				}
				else
				{
					nProps += rgPropertyIDSets[ulPropSets].cPropertyIDs;
				}
			}
			else 
			if(rgPropertyIDSets[ulPropSets].guidPropertySet == DBPROPSET_WMIOLEDB_COMMAND)
			{
				if(rgPropertyIDSets[ulPropSets].cPropertyIDs == 0 )
				{
					nProps += NUMBER_OF_SUPPORTED_WMIOLEDB_COMMAND_PROPERTIES;
				}
				else
				{
					nProps += rgPropertyIDSets[ulPropSets].cPropertyIDs;
				}
			}
			else 
			if(rgPropertyIDSets[ulPropSets].guidPropertySet == DBPROPSET_ROWSET)
			{
				if(rgPropertyIDSets[ulPropSets].cPropertyIDs == 0 )
				{
					nProps += NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES;
				}
				else
				{
					nProps += rgPropertyIDSets[ulPropSets].cPropertyIDs;
				}
			}
			else 
			if(rgPropertyIDSets[ulPropSets].guidPropertySet == DBPROPSET_WMIOLEDB_ROWSET)
			{
				if(rgPropertyIDSets[ulPropSets].cPropertyIDs == 0 )
				{
					nProps += NUMBER_OF_SUPPORTED_WMIOLEDB_ROWSET_PROPERTIES;
				}
				else
				{
					nProps += rgPropertyIDSets[ulPropSets].cPropertyIDs;
				}
			}
			else 
			if(rgPropertyIDSets[ulPropSets].guidPropertySet == DBPROPSET_COLUMN)
			{
				if(rgPropertyIDSets[ulPropSets].cPropertyIDs == 0 )
				{
					nProps += NUMBER_OF_SUPPORTED_COLUMN_PROPERTIES;
				}
				else
				{
					nProps += rgPropertyIDSets[ulPropSets].cPropertyIDs;
				}
			}
			else 
			if(rgPropertyIDSets[ulPropSets].guidPropertySet == DBPROPSET_WMIOLEDB_COLUMN)
			{
				if(rgPropertyIDSets[ulPropSets].cPropertyIDs == 0 )
				{
					nProps += NUMBER_OF_SUPPORTED_WMIOLEDB_COLUMN_PROPERTIES;
				}
				else
				{
					nProps += rgPropertyIDSets[ulPropSets].cPropertyIDs;
				}
			}
		}
	}
		return nProps;
}

HRESULT CUtilProp::GetConnectionInitProperties(DBPROPSET**	pprgPropertySets)
{
	DBPROPIDSET	rgPropertyIDSets[1];
	ULONG		cPropertySets;
	DBPROPID	rgPropId[NUMBER_OF_CONNECTIONINIT_PROP];

	rgPropId[0]								= DBPROP_INIT_DATASOURCE;
	rgPropId[1]								= DBPROP_INIT_PROTECTION_LEVEL;
	rgPropId[2]								= DBPROP_INIT_IMPERSONATION_LEVEL;
	rgPropId[3]								= DBPROP_AUTH_USERID;
	rgPropId[4]								= DBPROP_AUTH_PASSWORD;
	rgPropId[5]								= DBPROP_INIT_LCID;
	rgPropId[6]								= DBPROP_WMIOLEDB_AUTHORITY;

	rgPropertyIDSets[0].guidPropertySet		= DBPROPSET_DBINIT;
	rgPropertyIDSets[0].rgPropertyIDs		= rgPropId;
	rgPropertyIDSets[0].cPropertyIDs		= 7;

	return GetProperties( PROPSET_DSO,1, rgPropertyIDSets,&cPropertySets,pprgPropertySets );


}
HRESULT CUtilProp::SetDefaultValueForStringProperties(PROPSTRUCT *	prgPropeties,ULONG cProperties)
{
	HRESULT hr = S_OK;
	for(ULONG lProperties = 0; lProperties < cProperties ; lProperties++)
	{
		switch(prgPropeties[lProperties].dwPropertyID)
		{
			case DBPROP_INIT_DATASOURCE:
			case DBPROP_AUTH_USERID:
			case DBPROP_AUTH_PASSWORD:
			case DBPROP_WMIOLEDB_DS_FILTER:
			case DBPROP_WMIOLEDB_DS_ATTRIBUTES:
			case DBPROP_WMIOLEDB_AUTHORITY:
					prgPropeties[lProperties].pwstrVal = NULL;
					break;

			case DBPROP_WMIOLEDB_QUERYLANGUAGE:
					prgPropeties[lProperties].pwstrVal = new WCHAR[wcslen(DEFAULTQUERYLANG) + 1];
					if(prgPropeties[lProperties].pwstrVal)
					{
						wcscpy(prgPropeties[lProperties].pwstrVal,DEFAULTQUERYLANG);
					}
					else
					{
						hr = E_OUTOFMEMORY;
					}
					break;

		}
	}
	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//
//   This class manages the memory allocations of all the property structs
//
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPropertyMemoryMgr::AllocDBPROPINFOSET(DBPROPINFOSET *& pPropInfoSet, const ULONG cProps)
{
    HRESULT hr = S_OK;
    pPropInfoSet = (DBPROPINFOSET*) g_pIMalloc->Alloc(cProps *  sizeof( DBPROPINFOSET ));

    if ( !pPropInfoSet ){
        hr = E_OUTOFMEMORY ;
    }
    else{
        memset( pPropInfoSet, 0, (cProps * sizeof( DBPROPINFOSET )));
    }
    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPropertyMemoryMgr::AllocDESCRIPTBuffer(WCHAR *& pDescBuffer,  WCHAR** ppDescBuffer, ULONG cProperties)
{
    HRESULT hr = S_OK;

	if ( ppDescBuffer ){
		pDescBuffer = (WCHAR*)g_pIMalloc->Alloc(cProperties * CCH_GETPROPERTYINFO_DESCRIP_BUFFER_SIZE * sizeof(WCHAR) );
		
		if( pDescBuffer ){
			memset(pDescBuffer, 0, (cProperties * CCH_GETPROPERTYINFO_DESCRIP_BUFFER_SIZE * sizeof(WCHAR)));
			*ppDescBuffer = pDescBuffer;
		}
		else{
			hr = E_OUTOFMEMORY ;
		}
	}
    return hr;
}
//=====================================================================================================
HRESULT CPropertyMemoryMgr::AllocDBPROPINFO(DBPROPINFO *& pPropInfo, DBPROPINFOSET * pPropInfoSet, ULONG ulPropSets)
{
	HRESULT	hr = S_OK;

	pPropInfo = (DBPROPINFO*) g_pIMalloc->Alloc(sizeof( DBPROPINFO ) * pPropInfoSet[ulPropSets].cPropertyInfos);
    if( pPropInfo ){

    }
    else{
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
//=====================================================================================================
HRESULT CPropertyMemoryMgr::AllocateDBPROP(DBPROP*& ppProp, const ULONG cProperties)
{
	HRESULT	hr = E_INVALIDARG;

	if ( NULL != ppProp && NULL == ppProp && cProperties > 0 ) {

		ppProp = (DBPROP*)g_pIMalloc->Alloc(cProperties * sizeof DBPROP);
//			*ppProp = new DBPROP[cProperties];
        if ( NULL == ppProp ){
			hr = E_OUTOFMEMORY;
        }
		else {
			memset(ppProp, 0, sizeof DBPROP);
			hr = S_OK;
		}
	}

	return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPropertyMemoryMgr::AllocDBPROPSET(DBPROPSET*& ppPropSet, const ULONG cPropSets)
{
	HRESULT	hr = E_INVALIDARG;

	if ( NULL != ppPropSet && NULL == ppPropSet && cPropSets > 0 ) {

		ppPropSet = (DBPROPSET*)g_pIMalloc->Alloc(cPropSets * sizeof DBPROPSET);
        if ( NULL == ppPropSet ){
			hr = E_OUTOFMEMORY;
        }
		else {
			memset(ppPropSet, 0, cPropSets * sizeof DBPROPSET);
			hr = S_OK;
		}
	}
	return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPropertyMemoryMgr::AllocDBCOLUMNDESC(DBCOLUMNDESC*& ppCOLUMNDESC, const ULONG cColumnDescs)
{
	HRESULT	hr = E_INVALIDARG;

	if ( NULL != ppCOLUMNDESC && NULL == ppCOLUMNDESC && cColumnDescs > 0 ) {

		ppCOLUMNDESC = (DBCOLUMNDESC*)g_pIMalloc->Alloc(cColumnDescs * sizeof DBCOLUMNDESC);
        if ( NULL == ppCOLUMNDESC ){
			hr = E_OUTOFMEMORY;
        }
		else {
			memset(ppCOLUMNDESC, 0, cColumnDescs * sizeof DBCOLUMNDESC);
			hr = S_OK;
		}
	}
	return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPropertyMemoryMgr::FreeDBPROPINFOSET(DBPROPINFOSET *& pPropInfoSet, const ULONG cProps)
{
	if (pPropInfoSet){
		for(ULONG i = 0 ; i < cProps ; i++)
		{
			if(pPropInfoSet[i].rgPropertyInfos)
			{
				FreeDBPROPINFO(pPropInfoSet[i].rgPropertyInfos , pPropInfoSet[i].cPropertyInfos);
			}
		}

	    g_pIMalloc->Free(pPropInfoSet);
        pPropInfoSet = NULL;
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPropertyMemoryMgr::FreeDBPROPINFO(DBPROPINFO *& pPropInfo, const ULONG cProps)
{
	if(pPropInfo)
	{
		for(ULONG i = 0 ; i < cProps; i++)
		{
			VariantClear(&pPropInfo[i].vValues);
		}
		g_pIMalloc->Free(pPropInfo);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPropertyMemoryMgr::FreeDESCRIPTBuffer(WCHAR *& pDescBuffer,  WCHAR** ppDescBuffer)
{
    if ( ppDescBuffer ) {
		*ppDescBuffer = NULL;
    }
    if( pDescBuffer ){
        g_pIMalloc->Free(pDescBuffer);
        pDescBuffer = NULL;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPropertyMemoryMgr::FreeDBCOLUMNDESC(DBCOLUMNDESC rgColumnDescs[], LONG cColumns)
{ 
    if ( rgColumnDescs ){
	    for ( LONG i = 0; i < cColumns; i++ ) {
            //free pointers
		    SysFreeString((BSTR)(rgColumnDescs[i].pwszTypeName));
		    if ( rgColumnDescs[i].pTypeInfo ) {
			    rgColumnDescs[i].pTypeInfo->Release();
			    rgColumnDescs[i].pTypeInfo = NULL;
		    }
		    //free sub structs
		    FreeDBPROPSET(rgColumnDescs[i].cPropertySets,rgColumnDescs[i].rgPropertySets);
		    rgColumnDescs[i].rgPropertySets = NULL;
	    }
	    g_pIMalloc->Free(rgColumnDescs);
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CPropertyMemoryMgr::CopyDBPROPSET(DBPROPSET*& pDestination, DBPROPSET*& pSource)
{
	if ( NULL == pSource		|| 
		 NULL == pDestination	|| 
		 NULL != pDestination->rgProperties )
		return E_INVALIDARG;

	memcpy(pDestination, pSource, sizeof DBPROPSET);
	memset(pSource->rgProperties, 0, sizeof DBPROPSET);
	return S_OK;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CPropertyMemoryMgr::CopyDBCOLUMNDESC(DBCOLUMNDESC*& pDestination, DBCOLUMNDESC*& pSource)
{
	if ( NULL == pSource		|| 
		 NULL == pDestination	|| 
		 NULL != pDestination->rgPropertySets )  //must not contain data
		return E_INVALIDARG;
	memcpy(pDestination, pSource, sizeof DBCOLUMNDESC);
	memset(pSource->rgPropertySets, 0, sizeof DBCOLUMNDESC);
	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//		CPriveligeToken class implementation	
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor
//////////////////////////////////////////////////////////////////////////////////////////////////////////
CPreviligeToken::CPreviligeToken()
{
	m_nMemAllocated = 0;
	m_pPrevTokenPrev = NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// Destructor
//////////////////////////////////////////////////////////////////////////////////////////////////////////
CPreviligeToken::~CPreviligeToken()
{
	SAFE_DELETE_ARRAY(m_pPrevTokenPrev);
}


// NTRaid: 136443
// 07/05/00
HRESULT CPreviligeToken::FInit()
{
	HRESULT hr = S_OK;

	m_nMemAllocated = sizeof(TOKEN_PRIVILEGES) + NUMBEROF_PRIVELAGES * sizeof(LUID_AND_ATTRIBUTES);
	m_pPrevTokenPrev = (TOKEN_PRIVILEGES *)new BYTE [m_nMemAllocated];
	if(m_pPrevTokenPrev)
	{
		memset(m_pPrevTokenPrev,0,m_nMemAllocated);
		GetCurrentPrivelegeToken();
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to adjust the privileges
//////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CPreviligeToken::AdjustTokenPrivileges(ULONG cProps , DBPROP rgProp[])
{
	BOOL bRet = FALSE;
	HANDLE hToken	= NULL;
/*	DWORD dwError;

	ConvertDBPropToPriveleges(cProps,rgProp);
	
	dwError	= GetLastError();
//	if(bRet = OpenThreadToken(GetCurrentThread(),TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES,FALSE,&hToken))
	if(OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES,&hToken))
*/
	OpenToken(hToken);
	if(hToken != NULL)
	{
		bRet = ::AdjustTokenPrivileges(hToken,
										FALSE,
										m_pPrevTokenPrev,
										0,
										NULL,
										NULL);
		CloseHandle(hToken);
	}

	return bRet;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to Set the DBPROP structure accoriding to the current privileges
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPreviligeToken::SetDBPROPForPrivileges(ULONG cProps , DBPROP * rgProp)
{
	ULONG_PTR	lPropValTemp	= 1;
	ULONG		lSize			= PRIVILEGE_NAMESIZE;
	LONG		lIndex			= -1;

	TCHAR strName[PRIVILEGE_NAMESIZE];
	memset(strName,0,PRIVILEGE_NAMESIZE * sizeof(TCHAR));
	
	for(ULONG_PTR i = 0 ; i < m_pPrevTokenPrev->PrivilegeCount ; i++)
	{
		lIndex			= -1;
		LookupPrivilegeName(NULL,&((m_pPrevTokenPrev->Privileges[i]).Luid) ,&strName[0],&lSize);

		if(!_tcscmp(strName,SE_CREATE_TOKEN_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_CREATE_TOKEN,&lIndex);
		}
		else if(!_tcscmp(strName,SE_ASSIGNPRIMARYTOKEN_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_ASSIGNPRIMARYTOKEN,&lIndex);
		}
		else if(!_tcscmp(strName,SE_LOCK_MEMORY_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_LOCK_MEMORY,&lIndex);
		}
		else if(!_tcscmp(strName,SE_INCREASE_QUOTA_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_INCREASE_QUOTA,&lIndex); 
		}
		else if(!_tcscmp(strName,SE_MACHINE_ACCOUNT_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_MACHINE_ACCOUNT,&lIndex);
		}
		else if(!_tcscmp(strName,SE_TCB_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_TCB,&lIndex);
		}
		else if(!_tcscmp(strName,SE_SECURITY_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_SECURITY,&lIndex);
		}
		else if(!_tcscmp(strName,SE_TAKE_OWNERSHIP_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_TAKE_OWNERSHIP,&lIndex);
		}
		else if(!_tcscmp(strName,SE_LOAD_DRIVER_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_LOAD_DRIVER,&lIndex);
		}
		else if(!_tcscmp(strName,SE_SYSTEM_PROFILE_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_SYSTEM_PROFILE,&lIndex);
		}
		else if(!_tcscmp(strName,SE_SYSTEMTIME_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_SYSTEMTIME,&lIndex);
		}
		else if(!_tcscmp(strName,SE_PROF_SINGLE_PROCESS_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_PROF_SINGLE_PROCESS,&lIndex);
		}
		else if(!_tcscmp(strName,SE_INC_BASE_PRIORITY_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_INC_BASE_PRIORITY,&lIndex);
		}
		else if(!_tcscmp(strName,SE_CREATE_PAGEFILE_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_CREATE_PAGEFILE,&lIndex);
		}
		else if(!_tcscmp(strName,SE_CREATE_PERMANENT_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_CREATE_PERMANENT,&lIndex);
		}
		else if(!_tcscmp(strName,SE_BACKUP_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_BACKUP,&lIndex);
		}
		else if(!_tcscmp(strName,SE_RESTORE_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_RESTORE,&lIndex);
		}
		else if(!_tcscmp(strName,SE_SHUTDOWN_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_SHUTDOWN,&lIndex);
		}
		else if(!_tcscmp(strName,SE_DEBUG_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_DEBUG,&lIndex);
		}
		else if(!_tcscmp(strName,SE_AUDIT_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_AUDIT,&lIndex);
		}
		else if(!_tcscmp(strName,SE_SYSTEM_ENVIRONMENT_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_SYSTEM_ENVIRONMENT,&lIndex);
		}
		else if(!_tcscmp(strName,SE_CHANGE_NOTIFY_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_CHANGE_NOTIFY,&lIndex);
		}
		else if(!_tcscmp(strName,SE_REMOTE_SHUTDOWN_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_REMOTE_SHUTDOWN,&lIndex);
		}
		else if(!_tcscmp(strName,SE_UNDOCK_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_UNDOCK,&lIndex);
		}
		else if(!_tcscmp(strName,SE_SYNC_AGENT_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_SYNC_AGENT,&lIndex);
		}
		else if(!_tcscmp(strName,SE_ENABLE_DELEGATION_NAME))
		{
			GetPropIndex(cProps,rgProp,DBPROP_WMIOLEDB_PREV_ENABLE_DELEGATION,&lIndex);
		}

		if(lIndex >= 0)
		{
			if(m_pPrevTokenPrev->Privileges[i].Attributes == SE_PRIVILEGE_ENABLED)
			{
				rgProp[lIndex].vValue.boolVal = VARIANT_TRUE;
			}
			else
			{
				rgProp[lIndex].vValue.boolVal = VARIANT_FALSE;
			}
		}
		memset(strName,0,PRIVILEGE_NAMESIZE * sizeof(TCHAR));
	}	// for loop
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get priveleges from the DBPROP structure
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPreviligeToken::ConvertDBPropToPriveleges(ULONG cProps , DBPROP rgProp[])
{
	LUID		luid;
	ULONG_PTR	lPropValTemp	= 1;
	TCHAR	*	pName			= NULL;
	BOOL		bPrivelege		= TRUE;

	m_pPrevTokenPrev->PrivilegeCount = 0;
	
	for(ULONG i = 0 ; i < cProps && lPropValTemp != 0  ; i++)
	{
		bPrivelege = TRUE;
		switch(rgProp[i].dwPropertyID)
		{
			case  DBPROP_WMIOLEDB_PREV_CREATE_TOKEN :
				pName = SE_CREATE_TOKEN_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_ASSIGNPRIMARYTOKEN:
				pName = SE_ASSIGNPRIMARYTOKEN_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_LOCK_MEMORY :
				pName = SE_LOCK_MEMORY_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_INCREASE_QUOTA:
				pName = SE_INCREASE_QUOTA_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_MACHINE_ACCOUNT :
				pName = SE_MACHINE_ACCOUNT_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_TCB :
				pName = SE_TCB_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_SECURITY :
				pName = SE_SECURITY_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_TAKE_OWNERSHIP:
				pName = SE_TAKE_OWNERSHIP_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_LOAD_DRIVER:
				pName = SE_LOAD_DRIVER_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_SYSTEM_PROFILE :
				pName = SE_SYSTEM_PROFILE_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_SYSTEMTIME:
				pName = SE_SYSTEMTIME_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_PROF_SINGLE_PROCESS:
				pName = SE_PROF_SINGLE_PROCESS_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_INC_BASE_PRIORITY:
				pName = SE_INC_BASE_PRIORITY_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_CREATE_PAGEFILE :
				pName = SE_CREATE_PAGEFILE_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_CREATE_PERMANENT:
				pName = SE_CREATE_PERMANENT_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_BACKUP:
				pName = SE_BACKUP_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_RESTORE:
				pName = SE_RESTORE_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_SHUTDOWN:
				pName = SE_SHUTDOWN_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_DEBUG:
				pName = SE_DEBUG_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_AUDIT:
				pName = SE_AUDIT_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_SYSTEM_ENVIRONMENT:
				pName = SE_SYSTEM_ENVIRONMENT_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_CHANGE_NOTIFY :
				pName = SE_CHANGE_NOTIFY_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_REMOTE_SHUTDOWN :
				pName = SE_REMOTE_SHUTDOWN_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_UNDOCK:
				pName = SE_UNDOCK_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_SYNC_AGENT:
				pName = SE_SYNC_AGENT_NAME;
				break;

			case  DBPROP_WMIOLEDB_PREV_ENABLE_DELEGATION:
				pName = SE_ENABLE_DELEGATION_NAME;
				break;

			default:
				bPrivelege = FALSE;


		}
		
		if(bPrivelege)
		{
			LookupPrivilegeValue(NULL,pName,&luid);
			m_pPrevTokenPrev->Privileges[m_pPrevTokenPrev->PrivilegeCount].Luid = luid;
			//=============================================================================================
			//	Any setting other than SE_PRIVILEGE_ENABLED is interpreted by AdjustTokenPrivileges 
			//	as a DISABLE request for the privelege
			//=============================================================================================
			m_pPrevTokenPrev->Privileges[m_pPrevTokenPrev->PrivilegeCount].Attributes = (rgProp[i].vValue.boolVal == VARIANT_TRUE)
												? SE_PRIVILEGE_ENABLED : SE_PRIVILEGE_ENABLED_BY_DEFAULT;
			m_pPrevTokenPrev->PrivilegeCount++;
			pName		 = NULL;
		}
	}
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////
// Funciton to get the current privelege token
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPreviligeToken::GetCurrentPrivelegeToken()
{
	HANDLE hToken	= NULL;
	HANDLE hThread	= NULL;
	BOOL bRet = FALSE;
/*	
	hThread = GetCurrentProcess();
	dwError	= GetLastError();
	hThread = GetCurrentThread();

	if(OpenThreadToken(hThread,TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES,TRUE,&hToken))
//	if(OpenProcessToken(hThread,TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,&hToken))
*/
	OpenToken(hToken);
	if(hToken != NULL)
	{
			DWORD dwLen = m_nMemAllocated;
		bRet = GetTokenInformation(hToken, 
								  TokenPrivileges, 
								  m_pPrevTokenPrev, 
								  dwLen,
								  &dwLen);

		CloseHandle(hToken);
	}	
//	CloseHandle(hThread);
//	dwError	= GetLastError();

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to adjust the privileges
//////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CPreviligeToken::AdjustTokenPrivileges(ULONG ulProperty)
{
	BOOL bRet = FALSE;
	HANDLE hToken	= NULL;
	DWORD dwError = 0;

	ConvertDBPropToPriveleges(ulProperty);
/*	
	dwError	= GetLastError();
//	if(bRet = OpenThreadToken(GetCurrentThread(),TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES,FALSE,&hToken))
	if(OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES,&hToken))
*/
	OpenToken(hToken);
	if(hToken != NULL)
	{
		bRet = ::AdjustTokenPrivileges(hToken,
										FALSE,
										m_pPrevTokenPrev,
										0,
										NULL,
										NULL);
		CloseHandle(hToken);
	}
	dwError	= GetLastError();

	return bRet;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to Set the DBPROP structure accoriding to the current privileges
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPreviligeToken::SetDBPROPForPrivileges(ULONG &ulProperty)
{
	ULONG_PTR	lPropValTemp	= 1;
	ULONG		lSize			= PRIVILEGE_NAMESIZE;
	LONG		lIndex			= -1;
	ULONG		ulCurPrivilege  = 0;

	TCHAR		strName[PRIVILEGE_NAMESIZE];
	memset(strName,0,PRIVILEGE_NAMESIZE * sizeof(TCHAR));

	ulProperty = 0;

	for(ULONG_PTR i = 0 ; i < NUMBER_OF_PREVILAGE_PROPERTIES ; i++)
	{
		ulCurPrivilege	= 0;
		LookupPrivilegeName(NULL,&((m_pPrevTokenPrev->Privileges[i]).Luid) ,&strName[0],&lSize);

		if(!_tcscmp(strName,SE_CREATE_TOKEN_NAME))
		{
			ulCurPrivilege = DBPROPVAL_CREATE_TOKEN;
		}
		else if(!_tcscmp(strName,SE_ASSIGNPRIMARYTOKEN_NAME))
		{
			ulCurPrivilege = DBPROPVAL_ASSIGNPRIMARYTOKEN;
		}
		else if(!_tcscmp(strName,SE_LOCK_MEMORY_NAME))
		{
			ulCurPrivilege = DBPROPVAL_LOCK_MEMORY;
		}
		else if(!_tcscmp(strName,SE_INCREASE_QUOTA_NAME))
		{
			ulCurPrivilege = DBPROPVAL_INCREASE_QUOTA;
		}
		else if(!_tcscmp(strName,SE_MACHINE_ACCOUNT_NAME))
		{
			ulCurPrivilege = DBPROPVAL_MACHINE_ACCOUNT;
		}
		else if(!_tcscmp(strName,SE_TCB_NAME))
		{
			ulCurPrivilege = DBPROPVAL_TCB;
		}
		else if(!_tcscmp(strName,SE_SECURITY_NAME))
		{
			ulCurPrivilege = DBPROPVAL_SECURITY;
		}
		else if(!_tcscmp(strName,SE_TAKE_OWNERSHIP_NAME))
		{
			ulCurPrivilege = DBPROPVAL_TAKE_OWNERSHIP;
		}
		else if(!_tcscmp(strName,SE_LOAD_DRIVER_NAME))
		{
			ulCurPrivilege = DBPROPVAL_LOAD_DRIVER;
		}
		else if(!_tcscmp(strName,SE_SYSTEM_PROFILE_NAME))
		{
			ulCurPrivilege = DBPROPVAL_SYSTEM_PROFILE;
		}
		else if(!_tcscmp(strName,SE_SYSTEMTIME_NAME))
		{
			ulCurPrivilege = DBPROPVAL_SYSTEMTIME;
		}
		else if(!_tcscmp(strName,SE_PROF_SINGLE_PROCESS_NAME))
		{
			ulCurPrivilege = DBPROPVAL_PROF_SINGLE_PROCESS;
		}
		else if(!_tcscmp(strName,SE_INC_BASE_PRIORITY_NAME))
		{
			ulCurPrivilege = DBPROPVAL_INC_BASE_PRIORITY;
		}
		else if(!_tcscmp(strName,SE_CREATE_PAGEFILE_NAME))
		{
			ulCurPrivilege = DBPROPVAL_CREATE_PAGEFILE;
		}
		else if(!_tcscmp(strName,SE_CREATE_PERMANENT_NAME))
		{
			ulCurPrivilege = DBPROPVAL_CREATE_PERMANENT;
		}
		else if(!_tcscmp(strName,SE_BACKUP_NAME))
		{
			ulCurPrivilege = DBPROPVAL_BACKUP;
		}
		else if(!_tcscmp(strName,SE_RESTORE_NAME))
		{
			ulCurPrivilege = DBPROPVAL_RESTORE;
		}
		else if(!_tcscmp(strName,SE_SHUTDOWN_NAME))
		{
			ulCurPrivilege = DBPROPVAL_SHUTDOWN;
		}
		else if(!_tcscmp(strName,SE_DEBUG_NAME))
		{
			ulCurPrivilege = DBPROPVAL_DEBUG;
		}
		else if(!_tcscmp(strName,SE_AUDIT_NAME))
		{
			ulCurPrivilege = DBPROPVAL_AUDIT;
		}
		else if(!_tcscmp(strName,SE_SYSTEM_ENVIRONMENT_NAME))
		{
			ulCurPrivilege = DBPROPVAL_SYSTEM_ENVIRONMENT;
		}
		else if(!_tcscmp(strName,SE_CHANGE_NOTIFY_NAME))
		{
			ulCurPrivilege = DBPROPVAL_CHANGE_NOTIFY;
		}
		else if(!_tcscmp(strName,SE_REMOTE_SHUTDOWN_NAME))
		{
			ulCurPrivilege = DBPROPVAL_REMOTE_SHUTDOWN;
		}
		else if(!_tcscmp(strName,SE_UNDOCK_NAME))
		{
			ulCurPrivilege = DBPROPVAL_UNDOCK;
		}
		else if(!_tcscmp(strName,SE_SYNC_AGENT_NAME))
		{
			ulCurPrivilege = DBPROPVAL_SYNC_AGENT;
		}
		else if(!_tcscmp(strName,SE_ENABLE_DELEGATION_NAME))
		{
			ulCurPrivilege = DBPROPVAL_ENABLE_DELEGATION;
		}

		if(ulCurPrivilege != 0)
		{
			if(m_pPrevTokenPrev->Privileges[i].Attributes == SE_PRIVILEGE_ENABLED)
			{
				ulProperty = ulProperty | ulCurPrivilege;
			}
			else
			{
				ulProperty = ulProperty | !(ulCurPrivilege);
			}
		}
		memset(strName,0,PRIVILEGE_NAMESIZE * sizeof(TCHAR));
	}	// for loop
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get priveleges from the DBPROP structure
//////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPreviligeToken::ConvertDBPropToPriveleges(ULONG ulProperty)
{
	LUID		luid;
	ULONG		lPropValTemp	= 1;
	ULONG		lProp			= 0;
	TCHAR	*	pName			= NULL;
	BOOL		bPrivelege		= TRUE;

	m_pPrevTokenPrev->PrivilegeCount = 0;
	
	for(ULONG i = 0 ; i < NUMBER_OF_PREVILAGE_PROPERTIES  ; i++)
	{

		bPrivelege	= TRUE;
		
		switch(lPropValTemp)
		{
			case  DBPROPVAL_CREATE_TOKEN :
				pName = SE_CREATE_TOKEN_NAME;
				break;

			case  DBPROPVAL_ASSIGNPRIMARYTOKEN:
				pName = SE_ASSIGNPRIMARYTOKEN_NAME;
				break;

			case  DBPROPVAL_LOCK_MEMORY :
				pName = SE_LOCK_MEMORY_NAME;
				break;

			case  DBPROPVAL_INCREASE_QUOTA:
				pName = SE_INCREASE_QUOTA_NAME;
				break;

			case  DBPROPVAL_MACHINE_ACCOUNT :
				pName = SE_MACHINE_ACCOUNT_NAME;
				break;

			case  DBPROPVAL_TCB :
				pName = SE_TCB_NAME;
				break;

			case  DBPROPVAL_SECURITY :
				pName = SE_SECURITY_NAME;
				break;

			case  DBPROPVAL_TAKE_OWNERSHIP:
				pName = SE_TAKE_OWNERSHIP_NAME;
				break;

			case  DBPROPVAL_LOAD_DRIVER:
				pName = SE_LOAD_DRIVER_NAME;
				break;

			case  DBPROPVAL_SYSTEM_PROFILE :
				pName = SE_SYSTEM_PROFILE_NAME;
				break;

			case  DBPROPVAL_SYSTEMTIME:
				pName = SE_SYSTEMTIME_NAME;
				break;

			case  DBPROPVAL_PROF_SINGLE_PROCESS:
				pName = SE_PROF_SINGLE_PROCESS_NAME;
				break;

			case  DBPROPVAL_INC_BASE_PRIORITY:
				pName = SE_INC_BASE_PRIORITY_NAME;
				break;

			case  DBPROPVAL_CREATE_PAGEFILE :
				pName = SE_CREATE_PAGEFILE_NAME;
				break;

			case  DBPROPVAL_CREATE_PERMANENT:
				pName = SE_CREATE_PERMANENT_NAME;
				break;

			case  DBPROPVAL_BACKUP:
				pName = SE_BACKUP_NAME;
				break;

			case  DBPROPVAL_RESTORE:
				pName = SE_RESTORE_NAME;
				break;

			case  DBPROPVAL_SHUTDOWN:
				pName = SE_SHUTDOWN_NAME;
				break;

			case  DBPROPVAL_DEBUG:
				pName = SE_DEBUG_NAME;
				break;

			case  DBPROPVAL_AUDIT:
				pName = SE_AUDIT_NAME;
				break;

			case  DBPROPVAL_SYSTEM_ENVIRONMENT:
				pName = SE_SYSTEM_ENVIRONMENT_NAME;
				break;

			case  DBPROPVAL_CHANGE_NOTIFY :
				pName = SE_CHANGE_NOTIFY_NAME;
				break;

			case  DBPROPVAL_REMOTE_SHUTDOWN :
				pName = SE_REMOTE_SHUTDOWN_NAME;
				break;

			case  DBPROPVAL_UNDOCK:
				pName = SE_UNDOCK_NAME;
				break;

			case  DBPROPVAL_SYNC_AGENT:
				pName = SE_SYNC_AGENT_NAME;
				break;

			case  DBPROPVAL_ENABLE_DELEGATION:
				pName = SE_ENABLE_DELEGATION_NAME;
				break;

			default:
				bPrivelege = FALSE;

		}
		
		if(bPrivelege)
		{
			LookupPrivilegeValue(NULL,pName,&luid);
			m_pPrevTokenPrev->Privileges[m_pPrevTokenPrev->PrivilegeCount].Luid = luid;
			//=============================================================================================
			//	Any setting other than SE_PRIVILEGE_ENABLED is interpreted by AdjustTokenPrivileges 
			//	as a DISABLE request for the privelege
			//=============================================================================================
			m_pPrevTokenPrev->Privileges[m_pPrevTokenPrev->PrivilegeCount].Attributes = (ulProperty & lPropValTemp)
												? SE_PRIVILEGE_ENABLED : SE_PRIVILEGE_ENABLED_BY_DEFAULT;
			m_pPrevTokenPrev->PrivilegeCount++;
			pName		 = NULL;
			lPropValTemp <<= 1;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get the index of a particular property in the array of properties
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CPreviligeToken::GetPropIndex (ULONG cProps , 
									DBPROP rgProp[],
									DBPROPID	dwPropertyID,   
									LONG*		pulIndex)	    
{
    ULONG cNumberOfProperties;
    BOOL fRc = FALSE;
    assert( pulIndex );
	*pulIndex = -1;

    for (	cNumberOfProperties = 0; cNumberOfProperties < cProps; 	cNumberOfProperties++)  {
        if (dwPropertyID == rgProp[cNumberOfProperties].dwPropertyID ) {

            //==============================================================
            // found a match
            //==============================================================
            *pulIndex = cNumberOfProperties;
            fRc = TRUE;
			break;
         }
    }
    return fRc;
}

void CPreviligeToken::OpenToken(HANDLE &hToken)
{
	HANDLE hObject	= NULL;
	DWORD	dwError	= 0;
	BOOL bRet = FALSE;
	
	hObject = GetCurrentThread();
	if(!OpenThreadToken(hObject,TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES,TRUE,&hToken))
	{
		dwError = GetLastError();
	}
	
	if(dwError == ERROR_NO_TOKEN)
	{
		dwError = 0;
		CloseHandle(hObject);
		hObject = GetCurrentProcess();
		if(!OpenProcessToken(hObject,TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,&hToken))
		{
			dwError = GetLastError();
		}
	}

	CloseHandle(hObject);

	if(!dwError)
	{
		DWORD dwLen = m_nMemAllocated;
		bRet = GetTokenInformation(hToken, 
								  TokenPrivileges, 
								  m_pPrevTokenPrev, 
								  dwLen,
								  &dwLen);

		dwError	= GetLastError();
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\utlparam.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Parameter handling Routines
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _UTLPARAM_H_
#define _UTLPARAM_H_

#define PARAM_MARKER	L'?'

class CCommand;
const BYTE PARAMINFO_CONVERT_IUNKNOWN	= 0x01;
const DWORD CUTLPARAM_DEFAULT_PARAMS	= 0x00000001;
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Parameter information struct.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
struct PARAMINFO
{
	LPWSTR		    pwszParamName;	//parameter name
	DBPARAMFLAGS    dwFlags;		//parameter flags
	DBLENGTH	    cbColLength;	//max length of param as represented
	DBLENGTH	    cbValueMax; 	//max length of the param as represented by the OLE DB type
	DBLENGTH	    ulParamSize;	//max length of the param as defined for ICommandWithParameters::GetParameterInfo
	DBSTATUS	    dwStatus;		//status flags
	DBTYPE		    wOLEDBType;		//corresponding OLE DB type
    LONG            CIMType;
	BYTE *			pbData;
    LONG            Flavor;
	DBORDINAL		iOrdinal;

    PARAMINFO()     { 	this->Init(); 	}
	~PARAMINFO()	{	delete pwszParamName;	}
	void Init()		{	pwszParamName = NULL;	dwFlags = 0;	cbColLength = 0;cbValueMax = 0;	dwStatus = 0;wOLEDBType = 0; pbData = NULL; 	}
};
typedef PARAMINFO *PPARAMINFO;

struct WMIBINDINFO 
	{
	DBBINDING*		pBinding;		// Original binding data 
	PARAMINFO*		pParamInfo;		// Parameter information
	WMIBINDINFO*	pNextBindInfo;	// Next binding for the output parameter
	WORD			wFlags;			// Flags
	WORD			iBatchedRPC;	// Index to which batched RPC this param was used
	};
typedef WMIBINDINFO *PWMIBINDINFO;

// Get binding
inline DBBINDING* GetBinding(PWMIBINDINFO pBindInfo)
{
	if (pBindInfo->wFlags & DBPARAMIO_INPUT){

		for (;	pBindInfo; pBindInfo = pBindInfo->pNextBindInfo){

            if (pBindInfo->pBinding->eParamIO & DBPARAMIO_INPUT){
				break;
			}
		    assert(pBindInfo);
		}
    }
    return pBindInfo->pBinding;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Utility class for parameter and binding information
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CUtlParam
{
    private: 

	    ULONG			m_cRef;			// reference count
        DBPARAMS		m_dbparams;		// parameters
	    ULONG_PTR		m_cbRowSize;	// # of bytes allocated for a single set of params
	    CImpIAccessor*	m_pIAccessor;	// accessor interface
	    ULONG			m_cParams;		// # of parameters in the command
	    WMIBINDINFO*	m_prgBindInfo;	//@cmember binding information
	    PPARAMINFO*		m_rgpParamInfo; // parm info derived from bind info
	    ULONG			m_cParamInfo;	// # of param info structs derived
									    // from the bind info
	    DWORD			m_dwStatus;		// status information


    public: 
	
        CUtlParam();
    	~CUtlParam();

	// Increments the Reference count
	STDMETHODIMP_(ULONG)	AddRef(void);

	// Decrements the Reference count
	STDMETHODIMP_(ULONG)	Release(void);

	// Get the number parameters in the command
	ULONG CParams() const		{ return m_cParams; }

	// Get the number parameter sets
	ULONG CParamSets() const	{ return (ULONG)m_dbparams.cParamSets; }

	// Are there any default parameters?
	BOOL FHaveDefaultParams() const
		{
		return (m_dwStatus & CUTLPARAM_DEFAULT_PARAMS) != 0;
		}
		
    //==================================================================================
	// Builds the binding information needed to execute a command with parameters
    //==================================================================================
	STDMETHODIMP BuildBindInfo( CCommand *pcmd, DBPARAMS *pParams, const IID* piid );

    //==================================================================================
	// Builds the parameter information for the command from the binding information.
    //==================================================================================
	STDMETHODIMP BuildParamInfo( CCommand *pcmd,			// IN | Command Structure
		const IID*	piid			// IN | Interface that invoked this method
		);


	// Get the parameter information for a parameter
	inline PARAMINFO* GetParamInfo(ULONG iParam) const
		{
			return NULL;
		}
	
	// Set the status data for a parameter  
	inline void SetStatus(DBBINDING *pBind, DBSTATUS dbstatus)
		{
		if (pBind->dwPart & DBPART_STATUS)
			{
			BYTE *pbData;
			ULONG iParamSet;
			for (	pbData = (BYTE*)m_dbparams.pData, iParamSet = 0;
					iParamSet < m_dbparams.cParamSets;
					pbData += m_cbRowSize, iParamSet++ )
				{
				*(DBSTATUS *)(pbData + pBind->obStatus) = dbstatus;
				}
			}
		}
	// Bind a parameter to its data
    void BindParamData(	ULONG iParamSet, ULONG iParam,	DBBINDING*	pBinding,BYTE**	ppbValue, DWORD** ppdwLength,
	                	DWORD* pdwLength,DBSTATUS**	ppdwStatus,	DBSTATUS*	pdwStatus,	DBTYPE*	pdbtype	 );
	
	// Bind the pointers to parameter data
	inline void BindParamPtrs
		(
		ULONG		iParamSet,		// IN | parameter set ordinal
		ULONG		iParam,			// IN | parameter ordinal
		DBBINDING*	pBinding,		// IN | Binding information
		BYTE**		ppbValue,		// OUT | pointer to the param value
		DWORD**		ppdwLength,		// OUT | pointer to the length of param value
		DBSTATUS**	ppdwStatus		// OUT | pointer to the status for the param
		)
		{
		assert(iParamSet && iParamSet <= m_dbparams.cParamSets);
		assert(iParam && iParam <= m_cParams);
		assert(pBinding);
		assert(pBinding->iOrdinal == iParam);
		assert(ppbValue);
		assert(ppdwLength);
		assert(ppdwStatus);
		BYTE* pbData = (BYTE*)m_dbparams.pData + (iParamSet-1)*m_cbRowSize;
		
		*ppbValue = (pBinding->dwPart & DBPART_VALUE)
			? pbData + pBinding->obValue : NULL;
		*ppdwStatus = (pBinding->dwPart & DBPART_STATUS)
			? (DBSTATUS*)(pbData + pBinding->obStatus) : NULL;
		*ppdwLength = (pBinding->dwPart & DBPART_LENGTH)
			? (DWORD*)(pbData + pBinding->obLength) : NULL;
		}
	// Bind a parameter to its data
	inline BOOL FIsDefaultParam
		(
		ULONG		iParamSet,		// IN | parameter set ordinal
		ULONG		iParam,			// IN | parameter ordinal
		DBBINDING*	pBinding		// IN | Binding information
		)
		{
		assert(iParamSet && iParamSet <= m_dbparams.cParamSets);
		assert(iParam && iParam <= m_cParams);
		assert(pBinding);
		assert(pBinding->iOrdinal == iParam);

		if (pBinding->dwPart & DBPART_STATUS)
			{
			BYTE* pbData = (BYTE*)m_dbparams.pData + (iParamSet-1)*m_cbRowSize;
			assert(!IsBadReadPtr(pbData+pBinding->obStatus,sizeof(DBSTATUS)));
			if (DBSTATUS_S_DEFAULT == *((DBSTATUS*)(pbData + pBinding->obStatus)))
				return TRUE;
			}
		return FALSE;
		}
	// Get the length of the bound data
	ULONG GetBindLength
		(
		DBBINDING	*pBinding,		// IN | Binding information
		DWORD*		pdwLength,		// IN | bound length
		BYTE		*pbData			// IN | Pointer to param data
		);
	// Set bind status for parameters to DBSTATUS_E_UNAVAILABLE
	void SetParamsUnavailable(ULONG iParamSetFailed, ULONG iParamFailed,BOOL fBackOut);
};
typedef CUtlParam	*PCUTLPARAM;

#endif // UTLPARAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\util.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider 
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//  UTIL.CPP		- implementation of some utility functions
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////
#define _WIN32_DCOM

#include "headers.h"


#define wbem_towlower(C) \
    (((C) >= 0 && (C) <= 127)?          \
        (((C) >= 'A' && (C) <= 'Z')?          \
            ((C) + ('a' - 'A')):          \
            (C)          \
        ):          \
        towlower(C)          \
    )          


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AllocateAndConvertAnsiToUnicode(char * pstr, WCHAR *& pszW)
{
    pszW = NULL;

    int nSize = strlen(pstr);
    if (nSize != 0 ){

        // Determine number of wide characters to be allocated for the
        // Unicode string.
        nSize++;
		try{
			pszW = new WCHAR[nSize * 2];
			if (NULL != pszW){
            // Covert to Unicode.
				MultiByteToWideChar(CP_ACP, 0, pstr, nSize,pszW,nSize);
	        }	
		}
		catch(...)
		{
			SAFE_DELETE_ARRAY(pszW);
			throw;
		}
    }
}
////////////////////////////////////////////////////////////////////
BOOL UnicodeToAnsi(WCHAR * pszW, char *& pAnsi)
{
    ULONG cbAnsi, cCharacters;
    BOOL fRc = FALSE;

    pAnsi = NULL;
    if (pszW != NULL){

        cCharacters = wcslen(pszW)+1;
        // Determine number of bytes to be allocated for ANSI string. An
        // ANSI string can have at most 2 bytes per character (for Double
        // Byte Character Strings.)
        cbAnsi = cCharacters*2;
		try{
			pAnsi = new char[cbAnsi];
			if (NULL != pAnsi){

				// Convert to ANSI.
				if (0 != WideCharToMultiByte(CP_ACP, 0, pszW, cCharacters, pAnsi, cbAnsi, NULL, NULL)){
					fRc = TRUE;
	            }
		    }
		}
		catch(...)
		{
			SAFE_DELETE_ARRAY(pAnsi);
			throw;
		}
    }
    return fRc;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void TranslateAndLog( WCHAR * wcsMsg )
{
    char * pStr = NULL;

	UnicodeToAnsi(wcsMsg,pStr);                
	if( pStr ){
		ERRORTRACE((THISPROVIDER,"**************************************************************************\n"));
		ERRORTRACE((THISPROVIDER,pStr));
   		ERRORTRACE((THISPROVIDER,"\n"));
        SAFE_DELETE_ARRAY(pStr);
	}
}

void FormatAndLogMessage( LPCWSTR pszFormatString,... )
{
    char * pStr = NULL;

	va_list argList;
	va_start(argList,pszFormatString);
	CHString	sMsg;
	sMsg.FormatV(pszFormatString,argList);
	va_end(argList);

	UnicodeToAnsi(sMsg.GetBuffer(sMsg.GetLength()),pStr);                
	if( pStr ){
		ERRORTRACE((THISPROVIDER,"**************************************************************************\n"));
		ERRORTRACE((THISPROVIDER,pStr));
   		ERRORTRACE((THISPROVIDER,"\n"));
        SAFE_DELETE_ARRAY(pStr);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void LogMessage( char * szMsg )
{
	if( szMsg ){

		ERRORTRACE((THISPROVIDER,"**************************************************************************\n"));
		ERRORTRACE((THISPROVIDER,szMsg));
   		ERRORTRACE((THISPROVIDER,"\n"));
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void LogMessage( char * szMsg , HRESULT hr)
{
	if( szMsg ){

		ERRORTRACE((THISPROVIDER,"**************************************************************************\n"));
		ERRORTRACE((THISPROVIDER,szMsg));
   		ERRORTRACE((THISPROVIDER,"\n"));
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void LogMessage( WCHAR * szMsg )
{
	char *pstrMsg = NULL;
	UnicodeToAnsi(szMsg,pstrMsg);
	if( szMsg ){

		ERRORTRACE((THISPROVIDER,"**************************************************************************\n"));
		ERRORTRACE((THISPROVIDER,pstrMsg));
   		ERRORTRACE((THISPROVIDER,"\n"));
	}
	SAFE_DELETE_ARRAY(pstrMsg);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void LogMessage( WCHAR * szMsg , HRESULT hr)
{
	char *pstrMsg = NULL;
	UnicodeToAnsi(szMsg,pstrMsg);
	if( szMsg ){

		ERRORTRACE((THISPROVIDER,"**************************************************************************\n"));
		ERRORTRACE((THISPROVIDER,pstrMsg));
   		ERRORTRACE((THISPROVIDER,"\n"));
	}
	SAFE_DELETE_ARRAY(pstrMsg);
}

//-----------------------------------------------------------------------------
// OnUnicodeSystem
//
// @func Determine if the OS that we are on, actually supports the unicode verion
// of the win32 API.  If YES, then g_bIsAnsiOS == FALSE.
//
// @rdesc True of False
//-----------------------------------------------------------------------------------
BOOL OnUnicodeSystem()
{
	BOOL	fUnicode = TRUE;
	HKEY	hkJunk = HKEY_CURRENT_USER;

	// Check to see if we have win95's broken registry, thus
	// do not have Unicode support in the OS
	if ((RegOpenKeyExW(HKEY_LOCAL_MACHINE,
					 L"SOFTWARE",
					 0,
					 KEY_READ,
					 &hkJunk) == ERROR_SUCCESS) 
		 &&	hkJunk == HKEY_CURRENT_USER)
		{
	   // Try the ANSI version
		if ((RegOpenKeyExA(HKEY_LOCAL_MACHINE,
							 "SOFTWARE",
							 0,
							KEY_READ,
							&hkJunk) == ERROR_SUCCESS) 
			&&	(hkJunk != HKEY_CURRENT_USER))
			{
			fUnicode = FALSE;
			}
		}

	if (hkJunk != HKEY_CURRENT_USER)
		RegCloseKey(hkJunk);

	return fUnicode;
}

inline int wbem_towupper(wint_t c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'a' && c <= 'z')
            return c + ('A' - 'a');
        else
            return c;
    }
    else return towupper(c);
}


inline int wbem_tolower(int c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'A' && c <= 'Z')
            return c + ('a' - 'A');
        else
            return c;
    }
    else return tolower(c);
}

inline int wbem_toupper(int c)
{
    if(c >= 0 && c <= 127)
    {
        if(c >= 'a' && c <= 'z')
            return c + ('A' - 'a');
        else
            return c;
    }
    else return toupper(c);
}

int wbem_wcsicmp(const wchar_t* wsz1, const wchar_t* wsz2)
{
	int nRet = 0;

	if(wsz1 == NULL || wsz2 == NULL)
	{
		nRet = 1;
	}
	else
	if(!(wsz1 == NULL && wsz2 == NULL))
	{
		while(*wsz1 || *wsz2)
		{
			int diff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
			if(diff) return diff;
			wsz1++; wsz2++;
		}
	}

    return nRet;
}

int  wbem_wcsincmp(const wchar_t* wsz1, const wchar_t* wsz2,int nChars)
{
	int nIndex	= 0;
	int nDiff	= 0;


	if(wsz1 == NULL || wsz2 == NULL)
	{
		nDiff = 1;
	}
	else
	if(!(wsz1 == NULL && wsz2 == NULL))
	{

		while((*wsz1 || *wsz2) && nIndex < nChars )
		{
			nDiff = wbem_towlower(*wsz1) - wbem_towlower(*wsz2);
			if(nDiff) 
			{
				break;
			}
			wsz1++; wsz2++;
			nIndex++;
		}
	}

    return nDiff;
}

BSTR Wmioledb_SysAllocString(const OLECHAR *  sz)
{
	BSTR strRet = SysAllocString(sz);

	if(strRet == NULL && sz != NULL)
	{
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

	return strRet;
}


///////////////////////////////////////////////////////////////////////////////////////////////////
// Get Binding flags and put it in a variable as INIT_MODE flags
///////////////////////////////////////////////////////////////////////////////////////////////////
void GetInitAndBindFlagsFromBindFlags(DBBINDURLFLAG dwBindURLFlags,LONG & lInitMode ,LONG & lInitBindFlags)
{

	lInitMode = 0;
	lInitBindFlags = 0;

	// DBPROP_INIT_MODE
	if(DBBINDURLFLAG_READ & dwBindURLFlags)
	{
		lInitMode = lInitMode | DB_MODE_READ;
	}

	if(DBBINDURLFLAG_WRITE & dwBindURLFlags)
	{
		lInitMode = lInitMode | DB_MODE_WRITE;
	}

	if(DBBINDURLFLAG_SHARE_DENY_READ & dwBindURLFlags)
	{
		lInitMode = lInitMode | DB_MODE_SHARE_DENY_READ;
	}

	if(DBBINDURLFLAG_SHARE_DENY_WRITE & dwBindURLFlags)
	{
		lInitMode = lInitMode | DB_MODE_SHARE_DENY_WRITE;
	}

	if(DBBINDURLFLAG_SHARE_EXCLUSIVE & dwBindURLFlags)
	{
		lInitMode = lInitMode | DB_MODE_SHARE_EXCLUSIVE;
	}

	if(DBBINDURLFLAG_SHARE_DENY_NONE & dwBindURLFlags)
	{
		lInitMode = lInitMode | DB_MODE_SHARE_DENY_NONE;
	}

	// DBPROP_INIT_BINDFLAGS
	if(DBBINDURLFLAG_RECURSIVE & dwBindURLFlags)
	{
		lInitBindFlags = lInitBindFlags | DB_BINDFLAGS_RECURSIVE;
	}

	if(DBBINDURLFLAG_OUTPUT & dwBindURLFlags)
	{
		lInitBindFlags = lInitBindFlags | DB_BINDFLAGS_OUTPUT;
	}

	if(DBBINDURLFLAG_DELAYFETCHCOLUMNS & dwBindURLFlags)
	{
		lInitBindFlags = lInitBindFlags | DB_BINDFLAGS_DELAYFETCHCOLUMNS;
	}

	if(DBBINDURLFLAG_DELAYFETCHSTREAM & dwBindURLFlags)
	{
		lInitBindFlags = lInitBindFlags | DB_BINDFLAGS_DELAYFETCHSTREAM;
	}



}


int WMIOledb_LoadStringW(UINT nID, LPWSTR lpszBuf, UINT nMaxBuf)
{
    int nLen;

    if (!g_bIsAnsiOS )
    {
        nLen = ::LoadStringW(g_hInstance, nID, lpszBuf, nMaxBuf);
        if (nLen == 0)
        {
            lpszBuf[0] = '\0';
        }
    }
    else
    {
        char *pszBuf = new char[nMaxBuf];
        if ( pszBuf )
        {
            nLen = ::LoadStringA(g_hInstance, nID, pszBuf, nMaxBuf);
            if (nLen == 0)
            {
                lpszBuf[0] = '\0';
            }
            else
            {
                nLen = ::MultiByteToWideChar(CP_ACP, 0, pszBuf, nLen + 1, 
                            lpszBuf, nMaxBuf); 
                
                // Truncate to requested size  
                if (nLen > 0)
                {
                    // nLen doesn't include the '\0'.
                    nLen = min(nMaxBuf - 1, (UINT) nLen - 1); 
                }
                
                lpszBuf[nLen] = '\0'; 
            }
            
            delete [] pszBuf;
        }
        else
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }

    return nLen; // excluding terminator
}


CTString::CTString()
{
	m_pStr = NULL;
}

CTString::~CTString()
{
	SAFE_DELETE_ARRAY(m_pStr);
}


// NTRaid: 136432 , 136436
// 07/05/00
HRESULT CTString::LoadStr(UINT lStrID)
{
	HRESULT hr = S_OK;
	// try fixed buffer first (to avoid wasting space in the heap)

	SAFE_DELETE_ARRAY(m_pStr);
	int nTcharLen = 256;
	m_pStr = new TCHAR[256];

	if(m_pStr)
	{
		memset(m_pStr,0,nTcharLen * sizeof(TCHAR));

		int nLen = LoadString(g_hInstance,lStrID, m_pStr,nTcharLen );
		if (nTcharLen - nLen > sizeof(TCHAR))
		{
			return S_OK;
		}

		// try buffer size of 512, then larger size until entire string is retrieved
		int nSize = 256;
		do
		{
			nTcharLen += nSize;
			SAFE_DELETE_PTR(m_pStr);
			m_pStr = new TCHAR[nTcharLen];
			if(m_pStr)
			{
				memset(m_pStr,0,nTcharLen * sizeof(TCHAR));
				nLen = LoadString(g_hInstance,lStrID, m_pStr,nTcharLen);
			}
			else
			{
				hr = E_OUTOFMEMORY;
				break;
			}
		} while (nTcharLen - nLen <= sizeof(TCHAR));
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	return hr;

}



// Function which tries to get class name from urlparser and if not possible
// get it from connection to the object
// NTRaid : 134967
// 07/12/00
HRESULT GetClassName(CURLParser *pUrlParser,DBPROPSET*	prgPropertySets,BSTR &strClassName,CWbemConnectionWrapper *pConWrapper)
{
	HRESULT hr = S_OK;
	hr = pUrlParser->GetClassName(strClassName);
	if(FAILED(hr) && hr != E_OUTOFMEMORY)
	{
		BSTR strPath= NULL;
		if(SUCCEEDED(hr = pUrlParser->GetPath(strPath)) && 
			(FAILED(hr = pConWrapper->GetClassName(strPath,strClassName)) && hr != E_OUTOFMEMORY))
		{
			BSTR strTemp = NULL;
			if (SUCCEEDED(hr = pUrlParser->GetPath(strTemp)))
			{
				CWbemConnectionWrapper *pConnection = new CWbemConnectionWrapper;
				if(pConnection)
				{
					if(SUCCEEDED(hr = InitializeConnectionProperties(pConnection,prgPropertySets,strTemp)))
					{
						hr = pConnection->GetParameters(strTemp,strClassName);
					}
					SAFE_DELETE_PTR(pConnection);
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
				SAFE_FREE_SYSSTRING(strTemp);
			}
		}
		SAFE_FREE_SYSSTRING(strPath);
	}

	return hr;
}

HRESULT InitializeConnectionProperties(CWbemConnectionWrapper *pConWrap,DBPROPSET*	prgPropertySets,BSTR strPath)
{
	HRESULT		hr				= S_OK;
	DWORD		dwAuthnLevel	= 0;
	DWORD		dwImpLevel		= 0;
	CVARIANT	var;

	var.SetStr(strPath);


    //==========================================================================
    //  now, set the namespace, if this isn't a valid namespace, then it reverts
    //  to the default
    //==========================================================================
    pConWrap->SetValidNamespace(&var);

	pConWrap->SetUserInfo(prgPropertySets->rgProperties[IDX_DBPROP_AUTH_USERID].vValue.bstrVal,
										prgPropertySets->rgProperties[IDX_DBPROP_AUTH_PASSWORD].vValue.bstrVal,
									prgPropertySets->rgProperties[IDX_DBPROP_WMIOLEDB_AUTHORITY].vValue.bstrVal);

	// convert the OLEDB prop value to the actual value
	dwAuthnLevel = GetAuthnLevel(prgPropertySets->rgProperties[IDX_DBPROP_INIT_PROTECTION_LEVEL].vValue.lVal);
	dwImpLevel	 = GetImpLevel(prgPropertySets->rgProperties[IDX_DBPROP_INIT_PROTECTION_LEVEL].vValue.lVal);
	pConWrap->SetLocale(prgPropertySets->rgProperties[IDX_DBPROP_INIT_LCID].vValue.lVal);

	pConWrap->SetConnAttributes(dwAuthnLevel,dwImpLevel);

	return hr;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the authentication level for the corresponding OLEDB property
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DWORD GetAuthnLevel(DWORD dwAuthnPropVal)
{
	DWORD dwAuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT;
	
	switch(dwAuthnPropVal)
	{
		case DB_PROT_LEVEL_NONE :
			dwAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;
			break;

		case DB_PROT_LEVEL_CONNECT :
			dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;
			break;

		case DB_PROT_LEVEL_CALL :
			dwAuthnLevel = RPC_C_AUTHN_LEVEL_CALL;
			break;
		
		case DB_PROT_LEVEL_PKT :
			dwAuthnLevel = RPC_C_AUTHN_LEVEL_PKT;
			break;
		
		case DB_PROT_LEVEL_PKT_INTEGRITY :
			dwAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
			break;
		
		case DB_PROT_LEVEL_PKT_PRIVACY :
			dwAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
			break;
	}

	return dwAuthnLevel;

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the impersonation level for the corresponding OLEDB property
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DWORD GetImpLevel(DWORD dwImpPropVal)
{
	DWORD dwImpLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
	
	switch(dwImpPropVal)
	{
		case DB_IMP_LEVEL_ANONYMOUS :
			dwImpLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
			break;


		case DB_IMP_LEVEL_IDENTIFY :
			dwImpLevel = RPC_C_IMP_LEVEL_IDENTIFY;
			break;

		case DB_IMP_LEVEL_IMPERSONATE :
			dwImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
			break;
		
		case DB_IMP_LEVEL_DELEGATE :
			dwImpLevel = RPC_C_IMP_LEVEL_DELEGATE;
			break;
		
	}

	return dwImpLevel;
}

// NTRaid:138957
DBTYPE GetVBCompatibleAutomationType(DBTYPE dbInType)
{
	DBTYPE dbTypeOut = dbInType;
	switch(dbInType)
	{
		case DBTYPE_UI4:
			dbTypeOut = DBTYPE_I4;
			break;
	}
	return dbTypeOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\wmioledb.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//  WMIOLEDB.H	- a header file with all GUID & constants defination
//
/////////////////////////////////////////////////////////////////////


#ifndef _WMIOLEDB_HEADER
#define _WMIOLEDB_HEADER


// Provider-specific Class Ids
#ifdef DBINITCONSTANTS

DEFINE_GUID(CLSID_WMIOLEDB,				0xfd8d9c02, 0x265e, 0x11d2, 0x98, 0xd9, 0x0, 0xa0, 0xc9, 0xb7, 0xcb, 0xfe);
DEFINE_GUID(CLSID_WMIOLEDB_ROOTBINDER,  0xcdcedb81, 0x5fec, 0x11d3, 0x9d, 0x1c, 0x0, 0xc0, 0x4f, 0x5f, 0x11, 0x64);
// {E14321B2-67C0-11d3-B3B4-00104BCC48C4}
DEFINE_GUID(CLSID_WMIOLEDB_ENUMERATOR,  0xe14321b2, 0x67c0, 0x11d3, 0xb3, 0xb4, 0x0, 0x10, 0x4b, 0xcc, 0x48, 0xc4);
//{80C4A61D-CB78-46fd-BD8F-8BF45BE46A4C}
DEFINE_GUID(CLSID_WMIOLEDB_ERRORLOOOKUP,  0x80C4A61D, 0xCB78, 0x46fd, 0xBD, 0x8F, 0x8B, 0xF4, 0x5B, 0xE4, 0x6A, 0x4C);

// {21B2028F-AD0A-11d3-B3CB-00104BCC48C4}
DEFINE_GUID(DBGUID_WQL, 0x21b2028f, 0xad0a, 0x11d3, 0xb3, 0xcb, 0x0, 0x10, 0x4b, 0xcc, 0x48, 0xc4);
// {18EC17EA-14D9-47fc-9722-2DCD8A1C3D70}
DEFINE_GUID(DBGUID_LDAP,0x18ec17ea, 0x14d9, 0x47fc, 0x97, 0x22, 0x2d, 0xcd, 0x8a, 0x1c, 0x3d, 0x70);
// {3718AA52-5F6E-4c2e-AAAE-383E69C0C928}
DEFINE_GUID(DBGUID_LDAPSQL,0x3718aa52, 0x5f6e, 0x4c2e, 0xaa, 0xae, 0x38, 0x3e, 0x69, 0xc0, 0xc9, 0x28);
 
DEFINE_GUID(DBPROPSET_WMIOLEDB_DBINIT, 0xdd497a71,0x9628,0x11d3,0x9d,0x5f,0x0,0xc0,0x4f,0x5f,0x11,0x64);
DEFINE_GUID(DBPROPSET_WMIOLEDB_ROWSET, 0x8d16c220,0x9bbb,0x11d3,0x9d,0x65,0x0,0xc0,0x4f,0x5f,0x11,0x64);
DEFINE_GUID(DBPROPSET_WMIOLEDB_COLUMN, 0x3ed51791,0x9c76,0x11d3,0x9d,0x66,0x0,0xc0,0x4f,0x5f,0x11,0x64);
DEFINE_GUID(DBPROPSET_WMIOLEDB_COMMAND,0xda0ff63c,0xad10,0x11d3,0xb3,0xcb,0x0,0x10,0x4b,0xcc,0x48,0xc4);

// WMIOLEDB Custom properties
#define		DBPROP_WMIOLEDB_FETCHDEEP					0x1000
#define		DBPROP_WMIOLEDB_QUALIFIERS					0x1001
#define		DBPROP_WMIOLEDB_QUALIFIERFLAVOR				0x1002
#define		DBPROP_WMIOLEDB_SYSTEMPROPERTIES			0x1003
#define		DBPROP_WMIOLEDB_OBJECTTYPE					0x1005

#define		DBPROP_WMIOLEDB_PREV_CREATE_TOKEN 			0x1006
#define		DBPROP_WMIOLEDB_PREV_ASSIGNPRIMARYTOKEN 	0x1007
#define		DBPROP_WMIOLEDB_PREV_LOCK_MEMORY 			0x1008
#define		DBPROP_WMIOLEDB_PREV_INCREASE_QUOTA 		0x1009
#define		DBPROP_WMIOLEDB_PREV_MACHINE_ACCOUNT 		0x100a
#define		DBPROP_WMIOLEDB_PREV_TCB 					0x100b
#define		DBPROP_WMIOLEDB_PREV_SECURITY 				0x100c
#define		DBPROP_WMIOLEDB_PREV_TAKE_OWNERSHIP 		0x100d
#define		DBPROP_WMIOLEDB_PREV_LOAD_DRIVER 			0x100e
#define		DBPROP_WMIOLEDB_PREV_SYSTEM_PROFILE 		0x100f
#define		DBPROP_WMIOLEDB_PREV_SYSTEMTIME 			0x1010
#define		DBPROP_WMIOLEDB_PREV_PROF_SINGLE_PROCESS 	0x1011
#define		DBPROP_WMIOLEDB_PREV_INC_BASE_PRIORITY 		0x1012
#define		DBPROP_WMIOLEDB_PREV_CREATE_PAGEFILE  		0x1013
#define		DBPROP_WMIOLEDB_PREV_CREATE_PERMANENT  		0x1014
#define		DBPROP_WMIOLEDB_PREV_BACKUP 				0x1015
#define		DBPROP_WMIOLEDB_PREV_RESTORE 				0x1016
#define		DBPROP_WMIOLEDB_PREV_SHUTDOWN 				0x1017
#define		DBPROP_WMIOLEDB_PREV_DEBUG 					0x1018
#define		DBPROP_WMIOLEDB_PREV_AUDIT  				0x1019
#define		DBPROP_WMIOLEDB_PREV_SYSTEM_ENVIRONMENT  	0x101a
#define		DBPROP_WMIOLEDB_PREV_CHANGE_NOTIFY 			0x101b
#define		DBPROP_WMIOLEDB_PREV_REMOTE_SHUTDOWN 		0x101c
#define		DBPROP_WMIOLEDB_PREV_UNDOCK 				0x101d
#define		DBPROP_WMIOLEDB_PREV_SYNC_AGENT 			0x101e
#define		DBPROP_WMIOLEDB_PREV_ENABLE_DELEGATION 		0x101f


#define		DBPROP_WMIOLEDB_DS_DEREFALIAS				0x1020
#define		DBPROP_WMIOLEDB_DS_SIZELIMIT				0x1021
#define		DBPROP_WMIOLEDB_DS_PAGEDTIMELIMIT			0x1022
#define		DBPROP_WMIOLEDB_DS_TOMBSTONE				0x1023
#define		DBPROP_WMIOLEDB_DS_SEARCHSCOPE				0x1024
#define		DBPROP_WMIOLEDB_DS_TIMEOUT					0x1025
#define		DBPROP_WMIOLEDB_DS_PAGESIZE					0x1026
#define		DBPROP_WMIOLEDB_DS_TIMELIMIT				0x1027
#define		DBPROP_WMIOLEDB_DS_CHASEREF					0x1028
#define		DBPROP_WMIOLEDB_DS_ATTRIBUTES				0x1029
#define		DBPROP_WMIOLEDB_DS_CACHERESULTS				0x102a
#define		DBPROP_WMIOLEDB_DS_FILTER					0x102b
#define		DBPROP_WMIOLEDB_DS_ATTRIBONLY				0x102c
#define		DBPROP_WMIOLEDB_DS_ASYNCH					0x102d
#define		DBPROP_WMIOLEDB_ISMETHOD					0x102e
#define		DBPROP_WMIOLEDB_AUTHORITY					0x102f
#define		DBPROP_WMIOLEDB_QUERYLANGUAGE				0x1030


// Property values for DBPROP_WMIOLEDB_QUALIFIERS
#define PROPERTYQUALIFIER						1
#define CLASSQUALIFIER							2

//Property values for DBPROP_WMIOLEDB_OBJECTTYPE 
#define DBPROPVAL_NOOBJ							0
#define DBPROPVAL_SCOPEOBJ						1
#define DBPROPVAL_CONTAINEROBJ					2

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\wmiglobal.h ===
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// WMIGLOBAL.H global definations header file
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _WMIOLEDBGLOBAL_H
#define _WMIOLEDBGLOBAL_H

#define WMIOLEDB_CLASS_PROPERTY					0x200L
#define WMIOLEDB_PROPERTY_QUALIFIER				0x201L
#define WMIOLEDB_CLASS_QUALIFIER				0x202L

#define DBTYPE_WMI_QUALIFIERSET					DBTYPE_IUNKNOWN

#ifndef  MAX
# define MIN(a,b)  ( (a) < (b) ? (a) : (b) )
# define MAX(a,b)  ( (a) > (b) ? (a) : (b) )
#endif


#ifndef NUMELEM
# define NUMELEM(x) (sizeof(x)/sizeof(*x))
#endif

#define MAX_HEAP_SIZE          	128000
//#define MAX_TOTAL_ROWBUFF_SIZE 	(10*1024*1024)				// Max for all row buffers.
#define MAX_TOTAL_ROWBUFF_SIZE 	(10*64*1024)				// Max for all row buffers.
#define MAX_IBUFFER_SIZE       	2000000
#define MAX_BIND_LEN      		(MAX_IBUFFER_SIZE/10)


#define STAT_ENDOFCURSOR            0x00000100	// for forward-only means fully materialized



#define PROPERTYQUALIFIER						1
#define CLASSQUALIFIER							2
#define INSTANCEQUALIFIER						3
#define	COLUMNSROWSET							4	
#define SCHEMA_ROWSET                           5	
#define COMMAND_ROWSET                          6
#define METHOD_ROWSET                           7

#define NAMESPACE            L"NAMESPACE"
#define PROVIDER_TYPES       L"PROVIDER_TYPES"
#define CATALOGS             L"CATALOGS"
#define COLUMNS              L"COLUMNS"
#define FOREIGN_KEYS         L"FOREIGN_KEYS"
#define TABLES               L"TABLES"
#define PRIMARY_KEYS         L"PRIMARY_KEYS"
#define TABLESINFO           L"TABLES_INFO"
#define PROCEDURES           L"PROCEDURES"
#define PROCEDURE_PARAMETERS L"PROCEDURE_PARAMETERS"


#define OPENCOLLECTION		L"*"

#define UMIURLPREFIX		L"UMI:"
#define WMIURLPREFIX		L"WINMGMTS:"

#define DEFAULTQUERYLANG	L"WQL"
//-----------------------------------------------------------------------------
// Memory alignment
//-----------------------------------------------------------------------------

//++
// Useful rounding macros.
// Rounding amount is always a power of two.
//--
#define ROUND_DOWN( Size, Amount )  ((ULONG_PTR)(Size) & ~((Amount) - 1))
#define ROUND_UP(   Size, Amount ) (((ULONG_PTR)(Size) +  ((Amount) - 1)) & ~((Amount) - 1))

//++
// These macros are for aligment of ColumnData within the internal row buffer.
// COLUMN_ALIGN takes a ptr where you think data ought to go,
// and rounds up to the next appropriate address boundary.
//
// Rule of thumb is "natural" boundary, i.e. 4-byte member should be
// aligned on address that is multiple of 4.
//
// Most everything should be aligned to 32-bit boundary.
// But doubles should be aligned to 64-bit boundary, so let's play it safe.
// Also have __int64.
//--

#if defined(_M_MRX000)
# define COLUMN_ALIGNVAL 8
#elif  defined(_M_ALPHA)
# define COLUMN_ALIGNVAL 8
#else
# define COLUMN_ALIGNVAL 8		// venerable 80x86
#endif

#define SEPARATOR L"/"

extern LONG g_cObj;						// # of outstanding objects
extern LONG g_cLock;						// # of explicit locks set
extern DWORD g_cAttachedProcesses;			// # of attached processes
extern DWORD g_dwPageSize;					// System page size
extern IMalloc * g_pIMalloc;				// OLE2 task memory allocator
extern HINSTANCE g_hInstance;				// Instance Handle
extern IDataConvert * g_pIDataConvert;		// IDataConvert pointer


// Accessor Structure
typedef struct tagACCESSOR
{
    DBACCESSORFLAGS dwAccessorFlags;
	LONG			cRef;
	DBCOUNTITEM		cBindings;
	DBBINDING		rgBindings[1];
} ACCESSOR, *PACCESSOR;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\wmioledbmap.cpp ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// WmiOleDBMap.cpp: implementation of the CWmiOleDBMap class.
// 
//
///////////////////////////////////////////////////////////////////////////////////
#include "headers.h"
#include "dataconvert.h"

//////////////////////////////////////////////////////////////////////
// Construction of class for Schema Rowsets
//////////////////////////////////////////////////////////////////////
CWmiOleDBMap::CWmiOleDBMap()
{
    m_pWbemClassParms			= NULL;
    m_pWbemClassDefinition		= NULL;
    m_paWbemClassInstances		= NULL;
    m_pWbemCommandManager		= NULL;
	m_pWbemCollectionManager	= NULL;
	m_pWbemCurInst				= NULL;

	m_cRef						= 0;
	m_bMethodRowset				= FALSE;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWmiOleDBMap::~CWmiOleDBMap()
{
    SAFE_DELETE_PTR(m_pWbemClassParms);
    SAFE_DELETE_PTR(m_pWbemClassDefinition);
    SAFE_DELETE_PTR(m_paWbemClassInstances);
    SAFE_DELETE_PTR(m_pWbemCommandManager);
	SAFE_DELETE_PTR(m_pWbemCollectionManager);
}


STDMETHODIMP_( ULONG ) CWmiOleDBMap::AddRef(  void   )
{
    return InterlockedIncrement((long*)&m_cRef);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Decrements a persistence count for the object and if persistence count is 0, the object
// destroys itself.
//
/////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CWmiOleDBMap::Release( void   )
{
    if (!InterlockedDecrement((long*)&m_cRef)){
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// Initialization function for Schema Rowsets
//////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::FInit(int nSchemaType, DWORD dwFlags, WCHAR * pClassName, WCHAR * pSpecificTable, CWbemConnectionWrapper * Connect)
{
	// NTRaid:111784 - 111787
	// 06/07/00
	HRESULT hr = S_OK;
	m_pWbemClassParms       = new CWbemClassParameters(dwFlags,pClassName,Connect);
	if(m_pWbemClassParms)
	{
		m_pWbemClassParms->SetClassName(pClassName);

		switch( nSchemaType )
		{
			case SOURCES_ROWSET:
				m_pWbemClassDefinition  = (CWbemSchemaClassDefinitionWrapper*)new CWbemSchemaSourcesClassDefinitionWrapper(m_pWbemClassParms);
				m_paWbemClassInstances  = (CWbemSchemaInstanceList*)new CWbemSchemaSourcesInstanceList(m_pWbemClassParms);
				break;

			case PROVIDER_TYPES_ROWSET:
				m_pWbemClassDefinition  = (CWbemSchemaClassDefinitionWrapper*)new CWbemSchemaProviderTypesClassDefinitionWrapper(m_pWbemClassParms);
				m_paWbemClassInstances  = (CWbemSchemaInstanceList*)new CWbemSchemaProviderTypesInstanceList(m_pWbemClassParms);
				break;

			case CATALOGS_ROWSET:
				m_pWbemClassDefinition  = (CWbemSchemaClassDefinitionWrapper*)new CWbemSchemaCatalogsClassDefinitionWrapper(m_pWbemClassParms);
				m_paWbemClassInstances  = (CWbemSchemaInstanceList*)new CWbemSchemaCatalogsInstanceList(m_pWbemClassParms);
				break;

			case COLUMNS_ROWSET:
				m_pWbemClassDefinition  = (CWbemSchemaClassDefinitionWrapper*)new CWbemSchemaColumnsClassDefinitionWrapper(m_pWbemClassParms);
				m_paWbemClassInstances  = (CWbemSchemaInstanceList*)new CWbemSchemaColumnsInstanceList(m_pWbemClassParms,pSpecificTable);
				break;

			case TABLES_ROWSET:
				m_pWbemClassDefinition  = (CWbemSchemaClassDefinitionWrapper*)new CWbemSchemaTablesClassDefinitionWrapper(m_pWbemClassParms);
				m_paWbemClassInstances  = (CWbemSchemaInstanceList*)new CWbemSchemaTablesInstanceList(m_pWbemClassParms,pSpecificTable);
				break;

			case PRIMARY_KEYS_ROWSET:
				m_pWbemClassDefinition  = (CWbemSchemaClassDefinitionWrapper*)new CWbemSchemaPrimaryKeysClassDefinitionWrapper(m_pWbemClassParms);
				m_paWbemClassInstances  = (CWbemSchemaInstanceList*)new CWbemSchemaPrimaryKeysInstanceList(m_pWbemClassParms,pSpecificTable);
				break;

			case TABLES_INFO_ROWSET:
				m_pWbemClassDefinition  = (CWbemSchemaClassDefinitionWrapper*)new CWbemSchemaTablesInfoClassDefinitionWrapper(m_pWbemClassParms);
				m_paWbemClassInstances  = (CWbemSchemaInstanceList*)new CWbemSchemaTablesInfoInstanceList(m_pWbemClassParms,pSpecificTable);
				break;

			case PROCEDURES_ROWSET:
				m_pWbemClassDefinition  = (CWbemSchemaClassDefinitionWrapper*)new CWbemSchemaProceduresClassDefinitionWrapper(m_pWbemClassParms);
				m_paWbemClassInstances  = (CWbemSchemaInstanceList*)new CWbemSchemaProceduresInstanceList(m_pWbemClassParms,pSpecificTable);
				break;

			case PROCEDURE_PARAMETERS_ROWSET:
				m_pWbemClassDefinition  = (CWbemSchemaClassDefinitionWrapper*)new CWbemSchemaProceduresParametersClassDefinitionWrapper(m_pWbemClassParms);
				m_paWbemClassInstances  = (CWbemSchemaInstanceList*)new CWbemSchemaProceduresParametersInstanceList(m_pWbemClassParms,pSpecificTable);
				break;

		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	if(!m_pWbemClassDefinition || !m_pWbemClassDefinition)
	{
		hr = E_OUTOFMEMORY;
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Initialization function for opening a class
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::FInit(DWORD dwFlags, WCHAR * pClassName, CWbemConnectionWrapper * Connect)
{
	HRESULT hr = S_OK;
	m_pWbemClassParms       = new CWbemClassParameters(dwFlags,pClassName,Connect);
	// NTRaid:111784 - 111787
	// 06/07/00
	if(m_pWbemClassParms)
	{
		m_pWbemClassParms->SetClassName(pClassName);
		m_pWbemCurInst			= NULL;
		m_cRef					= 0;
		m_pWbemCommandManager   = NULL;
		m_bMethodRowset			= FALSE;
		m_pWbemCollectionManager = NULL;

		m_pWbemClassDefinition  = new CWbemClassDefinitionWrapper(m_pWbemClassParms);
		m_paWbemClassInstances  = new CWbemInstanceList(m_pWbemClassParms);
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}
	
	if(!m_pWbemClassDefinition || !m_paWbemClassInstances)
	{
		hr = E_OUTOFMEMORY;
	}
	return hr;

}
//////////////////////////////////////////////////////////////////////
// Initialization function for Commands or methods
// NTRaid:111788,111890 - 111792
// 06/07/00
//////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::FInit(DWORD dwFlags, CQuery * p, CWbemConnectionWrapper * Connect)
{

	HRESULT hr = E_OUTOFMEMORY;
	//=========================================================
	// If it is a COMMAND_ROWSET or METHOD_ROWSET
	//=========================================================
	switch( p->GetType() ){

		case COMMAND_ROWSET:

			m_pWbemCommandManager   = new CWbemCommandManager(p);

			if(m_pWbemCommandManager)
			{
				m_pWbemClassParms       = new CWbemCommandParameters(dwFlags,Connect,m_pWbemCommandManager);
				if(m_pWbemClassParms)
				{
//					m_pWbemClassParms->SetEnumeratorFlags(WBEM_FLAG_FORWARD_ONLY);
					m_pWbemClassParms->SetQueryFlags(WBEM_FLAG_DEEP);
					m_paWbemClassInstances  = new CWbemCommandInstanceList(m_pWbemClassParms,m_pWbemCommandManager);
					m_pWbemClassDefinition  = new CWbemCommandClassDefinitionWrapper(m_pWbemClassParms,m_pWbemCommandManager);

					if(m_paWbemClassInstances && m_pWbemClassDefinition)
					{
						m_pWbemCommandManager->Init((CWbemCommandInstanceList*)m_paWbemClassInstances,
													(CWbemCommandParameters*)m_pWbemClassParms,
													(CWbemCommandClassDefinitionWrapper*)m_pWbemClassDefinition);
						hr = S_OK;
					}
				}
			}
			break;

		case METHOD_ROWSET:
			m_pWbemClassParms       = new CWbemMethodParameters(p,dwFlags,Connect);
			if(m_pWbemClassParms)
			{
				m_pWbemClassParms->SetEnumeratorFlags(WBEM_FLAG_FORWARD_ONLY);
				m_pWbemClassParms->SetQueryFlags(WBEM_FLAG_SHALLOW);
				m_pWbemClassDefinition  = new CWbemMethodClassDefinitionWrapper((CWbemMethodParameters*)m_pWbemClassParms);
				if(m_pWbemClassDefinition)
				{
					m_paWbemClassInstances  = new CWbemMethodInstanceList((CWbemMethodParameters*)m_pWbemClassParms,
																		  (CWbemMethodClassDefinitionWrapper *) m_pWbemClassDefinition );

					if(m_paWbemClassInstances)
					{
						hr = ((CWbemMethodClassDefinitionWrapper*)m_pWbemClassDefinition)->Init();
						m_bMethodRowset			= TRUE;
					}
				}
			}
			break;
	}

	return hr;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Initialization function  for representing objects in Scope/Container
// if the namespace of the object is different from the current object then , a new Connect will be instantiated
// whic aggregates the existing connection pointer and store IwbemServices pointer opened on the given path and
// sets bConnectChanged to TRUE
// NTRaid:111793
// 06/07/00
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::FInit(DWORD dwFlags, WCHAR * pObjectPath, CWbemConnectionWrapper * Connect,INSTANCELISTTYPE instListType)
{

	HRESULT hr = E_OUTOFMEMORY;


	m_pWbemClassParms			= new CWbemCollectionParameters(dwFlags,Connect,pObjectPath);

	if(m_pWbemClassParms)
	{
		if(SUCCEEDED(hr = ((CWbemCollectionParameters *)m_pWbemClassParms)->Init(pObjectPath,Connect)))
		{
			m_pWbemCollectionManager	= new CWbemCollectionManager;
			if(m_pWbemCollectionManager)
			{
				m_pWbemClassDefinition		= new CWbemCollectionClassDefinitionWrapper(m_pWbemClassParms,pObjectPath,instListType);
				m_paWbemClassInstances		= new CWbemCollectionInstanceList(m_pWbemClassParms,m_pWbemCollectionManager);

				if(m_pWbemClassDefinition && m_paWbemClassInstances)
				{
					if(SUCCEEDED(hr = ((CWbemCollectionClassDefinitionWrapper *)m_pWbemClassDefinition)->Initialize(pObjectPath)))
					{
						m_pWbemCollectionManager->Init((CWbemCollectionInstanceList *)m_paWbemClassInstances, 
														(CWbemCollectionParameters *)m_pWbemClassParms,
														(CWbemCollectionClassDefinitionWrapper*) m_pWbemClassDefinition);
						hr = S_OK;
					}
				}
			}
		}
	}

	return hr;
}


HRESULT	CWmiOleDBMap::SetSearchPreferences(ULONG cProps , DBPROP rgProp[]) 
{ 
	return m_pWbemClassParms->SetSearchPreferences(cProps,rgProp);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Find the type of column given the column
// ie. find if a property is PROPERTY or PROPERTY_QUALIFIER or CLASS_QUALLIFIER
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CWmiOleDBMap::ParseQualifiedNameToGetColumnType(WCHAR * wcsName )
{
    int nRc = WMI_PROPERTY;
	WCHAR *  p = NULL;

    //========================================================================
    //  If there is not a separator in the name, then we know it is simply
    //  a WMI property.
    //  If there is a separator and the parsed value is equal to the name of
    //  the class, then we know we are dealing with a class qualifier,
    //  otherwise, it is a property qualifier.
    //========================================================================
	p = wcsstr(wcsName, SEPARATOR);
    if( p ){
        nRc = WMI_PROPERTY_QUALIFIER;
        //====================================================================
		p = NULL;
        p= wcsstr(wcsName,m_pWbemClassParms->GetClassName());
		if( p != NULL && p == wcsName)
		{
            nRc = WMI_CLASS_QUALIFIER;
        }
    }

    return nRc;
}
// 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWmiOleDBMap::ParseQualifiedName(WCHAR * Root, WCHAR *& Parent, WCHAR *& Child)
{
    BOOL fRc = FALSE;
    //========================================================================
    //  If there is not a separator in the name, then we know it is simply
    //  a WMI property.
    //  If there is a separator and the parsed value is equal to the name of
    //  the class, then we know we are dealing with a class qualifier,
    //  otherwise, it is a property qualifier.
    //========================================================================
	WCHAR *szTemp = NULL;
	try
	{
		szTemp = new WCHAR[wcslen(Root) +1];
	}
	catch(...)
	{
		SAFE_DELETE_ARRAY(szTemp);
	}
	wcscpy(szTemp,Root);
	WCHAR *  p = wcstok(szTemp, SEPARATOR);
    if( p ){
        AllocateAndCopy(Parent,p);
        p = wcstok( NULL, SEPARATOR );
        if( p ){
            if( AllocateAndCopy(Child,p)){
                fRc = TRUE;
            }
            else{
                SAFE_DELETE_PTR(Parent);
            }
        }
    }
	SAFE_DELETE_ARRAY(szTemp);
    return fRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Check if the property is a vallid
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::ValidProperty(const DBCOLUMNDESC * prgColDesc)
{
    HRESULT hr = S_OK;
    

	if( !(prgColDesc->dbcid.eKind == DBKIND_NAME && prgColDesc->dbcid.uName.pwszName != NULL))
	{
        hr = E_INVALIDARG;
	}
		
    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Map the DBPROP to the appropriate qualifier
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::MapDBPROPToStdPropertyQualifier( DBPROP pProp, CVARIANT & Qualifier, CVARIANT & Value, LONG & lFlavor )
{
    HRESULT hr = E_INVALIDARG;

    //========================================================================
    // we do not need to handle qualifier flavors for these standard qualifers
    // because, if a user is going to add a qualifier flavor on a qualifier 
    // that just 'happens' to match to a DBPROP, they will be adding it as
    // a wmi qualifier, this function is to just catch the DBPROPS that are
    // matched without the consumers knowledge, so in this case there will
    // be no qualifier flavor
    //========================================================================
	switch(pProp.dwPropertyID){

	    //=================================================================
        // WMI "Not_Null" standard qualifier only take true value.
        //=================================================================
		case DBPROP_COL_NULLABLE:

			if ( VT_BOOL == V_VT(&pProp.vValue) ) {
                if ( VARIANT_TRUE == V_BOOL(&pProp.vValue) ){
                    Qualifier.SetStr(L"Not_Null");  
	    		    Value.SetBool(TRUE);
                    hr = S_OK;
                }
            }
			break;

	    //=================================================================
        // WMI "Key" standard qualifier
	    //=================================================================
		case DBPROP_COL_UNIQUE:
		case DBPROP_COL_PRIMARYKEY:
			if ( VT_BOOL == V_VT(&pProp.vValue) ) {
                    Qualifier.SetStr(L"Key");  
	    		    Value.SetBool(TRUE);
                    hr = S_OK;
            }
			break;
	    //=================================================================
        // WMI Flavor
        //=================================================================
		case DBPROP_WMIOLEDB_QUALIFIERFLAVOR:
    		if ( VT_I4 == V_VT(&pProp.vValue) ) {
                lFlavor = V_I4(&pProp.vValue) ;
				hr = S_OK;
            }
			break;


		default: 
			hr = WBEM_E_NOT_SUPPORTED;
			break;
	}
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::MapDBPROPToStdClassQualifier( DBPROP pProp, CVARIANT & Qualifier, CVARIANT & Value, LONG & uFlavor )
{
    HRESULT hr = E_INVALIDARG;

    //========================================================================
    //  Now, the qualifier flavor will be passed through here, so, we need
    //  to pick it up as we are doing the double checking.  Regarding other
    //  maps, see comments in MapDBPROPTStdPropertyQualifier as to why we 
    //  don't care about flavors on DBPROP matches to standard qualifiers.
    //========================================================================

	switch(pProp.dwPropertyID){

	    //=================================================================
        // WMI Flavor
        // DON'T set the return code to S_OK, because we want to save the
        // flavor for later....
        //=================================================================
		case DBPROP_WMIOLEDB_QUALIFIERFLAVOR:
    		if ( VT_I4 == V_VT(&pProp.vValue) ) {
                uFlavor = V_I4(&pProp.vValue) ;
            }
			break;

		default: 
			hr = WBEM_E_NOT_SUPPORTED;
			break;
	}
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// save the  property
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::SetWMIProperty(const DBCOLUMNDESC * prgColDesc)
{
	HRESULT hr = S_OK;
	CBSTR bstrProperty(prgColDesc->dbcid.uName.pwszName);
	VARIANT varDefault , *pDefaultValue = NULL;
	VariantInit(&varDefault);
	CDataMap map;
	LONG lType = 0;

    //==================================================================================
    //  Ok, we already know we have a valid class here so just check if we have a valid
    //  property
    //==================================================================================
    if( S_OK == (hr = ValidProperty(prgColDesc))){

		// Get the default value for the property if any specified
		 GetDefaultValue(prgColDesc , varDefault);

		map.MapOLEDBTypeToCIMType(prgColDesc->wType,lType);

		if(V_VT(&varDefault) == VT_EMPTY || V_VT(&varDefault) == VT_NULL)
		{
			pDefaultValue = NULL;
		}
		else
		{
			pDefaultValue = &varDefault;
		}
        //==============================================================================
        //  Now, set it property and its value
        //==============================================================================
        hr = m_pWbemClassDefinition->SetProperty((BSTR)bstrProperty,pDefaultValue,lType);	
        if ( SUCCEEDED(hr) ){
	        
            //==========================================================================
            //  Now, go through the DBPROPSETS and the DBPROPS in them to see if they 
            //  happen to match some of the standard qualifiers we have mapped to them
            //==========================================================================
       
            for( ULONG i = 0; i <  prgColDesc->cPropertySets; i++ ){

		        for ( ULONG j = 0; j < prgColDesc->rgPropertySets[i].cProperties; j++ ) {

					if(prgColDesc->rgPropertySets[i].rgProperties[j].dwPropertyID != DBPROP_COL_DEFAULT &&
					prgColDesc->rgPropertySets[i].rgProperties[j].dwPropertyID != DBPROP_COL_NULLABLE )
					{
						CVARIANT Value,Qualifier;
						LONG lFlavor;

						//==================================================================
						//  See if we have a match, if we do, save it to WMI
						//==================================================================
						hr = MapDBPROPToStdPropertyQualifier(prgColDesc->rgPropertySets[i].rgProperties[j],Qualifier,Value, lFlavor);
						if( hr == S_OK){

							hr = m_pWbemClassDefinition->SetPropertyQualifier((BSTR)bstrProperty,Qualifier,Value,0);
							if( hr != S_OK){
								break;
							}
						}
					}
                }
            }
        }
    }
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function set value for a qualifier
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::SetWMIClassQualifier(const DBCOLUMNDESC * prgColDesc,BOOL bDefault)
{
	HRESULT hr = S_OK;

    WCHAR * pwcsQualifierName = NULL;
    WCHAR * pwcsClass = NULL;
	VARIANT varDefaultValue;
	VariantInit(&varDefaultValue);
    //==================================================================================
    //  Ok, we already know we have a valid class here so just check if we have a valid
    //  property
    //==================================================================================
    if( S_OK == (hr = ValidProperty(prgColDesc))){
		
        if( ParseQualifiedName(prgColDesc->dbcid.uName.pwszName,pwcsClass,pwcsQualifierName) ){
	        
            //==========================================================================
            //  Now, go through the DBPROPSETS and the DBPROPS in them to see if they 
            //  have a flavor for this qualifier or happen to map to other class 
            //  qualifiers
            //==========================================================================
            LONG lQualifierFlavor = 0L;
            for( ULONG i = 0; i <  prgColDesc->cPropertySets; i++ ){

		        for ( ULONG j = 0; j < prgColDesc->rgPropertySets[i].cProperties; j++ ) {

                    CVARIANT Value,Qualifier;
                    //==================================================================
                    // Get the qualifier flavor property if any
                    //==================================================================
					if( prgColDesc->rgPropertySets[i].rgProperties[j].dwPropertyID == DBPROP_WMIOLEDB_QUALIFIERFLAVOR &&
						V_VT(&prgColDesc->rgPropertySets[i].rgProperties[j].vValue) == VT_I4)
					{
						lQualifierFlavor = V_I4(&prgColDesc->rgPropertySets[i].rgProperties[j].vValue);
					}

                }
            }
            if( hr == S_OK )
			{
				CBSTR strQualifier(pwcsQualifierName);
				// If a new qualifer is to be added the get the default value
				if(bDefault == TRUE)
				{
					GetDefaultValue(prgColDesc,varDefaultValue);
				}
				else
				{
					hr = m_pWbemClassDefinition->GetClassQualifier((BSTR)strQualifier, &varDefaultValue, NULL,NULL);
				}

				hr = m_pWbemClassDefinition->SetClassQualifier(pwcsQualifierName, &varDefaultValue, lQualifierFlavor);
            }
        }
    }


    SAFE_DELETE_PTR(pwcsQualifierName);
    SAFE_DELETE_PTR(pwcsClass);

	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function set value for a particular property
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::SetWMIPropertyQualifier(const DBCOLUMNDESC * prgColDesc,BOOL bDefault)
{
	HRESULT hr = S_OK;
    WCHAR * pwcsQualifierName = NULL;
    WCHAR * pwcsProperty = NULL;
	VARIANT varDefaultValue;
	VariantInit(&varDefaultValue);

    //==================================================================================
    //  Ok, we already know we have a valid class here so just check if we have a valid
    //  property
    //==================================================================================
    if( S_OK == (hr = ValidProperty(prgColDesc))){



        if( ParseQualifiedName(prgColDesc->dbcid.uName.pwszName,pwcsProperty,pwcsQualifierName) ){
            LONG lQualifierFlavor = 0L;

	            
            //==========================================================================
            //  Now, go through the DBPROPSETS and the DBPROPS in them to see if they 
            //  have a flavor for this qualifier or happen to map to other class 
            //  qualifiers
            //==========================================================================
            for( ULONG i = 0; i <  prgColDesc->cPropertySets; i++ ){

		        for ( ULONG j = 0; j < prgColDesc->rgPropertySets[i].cProperties; j++ ) {

                    CVARIANT Value,Qualifier;
                    //==================================================================
                    // Get the qualifier flavor property if any
                    //==================================================================
					if( prgColDesc->rgPropertySets[i].rgProperties[j].dwPropertyID == DBPROP_WMIOLEDB_QUALIFIERFLAVOR &&
						V_VT(&prgColDesc->rgPropertySets[i].rgProperties[j].vValue) == VT_I4)
					{
						lQualifierFlavor = V_I4(&prgColDesc->rgPropertySets[i].rgProperties[j].vValue);
					}

                }

            }
            if( hr == S_OK ){
				CBSTR strQualifier(pwcsQualifierName),strProperty(pwcsProperty);

				if(bDefault == TRUE)
				{
					GetDefaultValue(prgColDesc,varDefaultValue);
				}
				else
				{
					GetPropertyQualifier((BSTR)strProperty,(BSTR)strQualifier,varDefaultValue);
				}

		        hr = m_pWbemClassDefinition->SetPropertyQualifier(pwcsProperty,pwcsQualifierName, &varDefaultValue, lQualifierFlavor);
            }
        }
    }

    SAFE_DELETE_PTR(pwcsQualifierName);
    SAFE_DELETE_PTR(pwcsProperty);

	return MapWbemErrorToOLEDBError(hr);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to initialize the DBCOLUMNINFO structure
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::SetCommonDBCOLUMNINFO(DBCOLUMNINFO ** pCol, DBORDINAL uCurrentIndex)
{
    (*pCol)->columnid.eKind          = DBKIND_GUID_PROPID;
    (*pCol)->columnid.uGuid.guid     = GUID_NULL;
    (*pCol)->columnid.uName.ulPropid = (ULONG)uCurrentIndex;
    (*pCol)->iOrdinal		          = uCurrentIndex;
    (*pCol)->pTypeInfo               = NULL;
    (*pCol)->bPrecision	          = (BYTE) ~0;
    (*pCol)->bScale		          = (BYTE) ~0;
    (*pCol)->dwFlags                 = 0;
    //==================================================================
    // We do support nulls
    //==================================================================
    (*pCol)->dwFlags |= DBCOLUMNFLAGS_ISNULLABLE;
    (*pCol)->dwFlags |= DBCOLUMNFLAGS_MAYBENULL;

    //==================================================================
    //We should always be able to write to the column
    //==================================================================
    (*pCol)->dwFlags |= DBCOLUMNFLAGS_WRITE;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function which gets column info for qualifier 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::GetQualifiedNameColumnInfo( cRowColumnInfoMemMgr * pParentCol,DBCOLUMNINFO ** pCol, WCHAR * pName)
{

    HRESULT hr = E_UNEXPECTED;
    WCHAR * pColumnName = new WCHAR[ wcslen(pName) + wcslen(QUALIFIER_) + wcslen(SEPARATOR) +2];
    
    if( pColumnName ){
        swprintf(pColumnName,L"%s%s%s",pName,SEPARATOR,QUALIFIER_);

		// if the column is already present in the col info info return 
		// This will happen when for row objects obtained from rowsets
		if(((DB_LORDINAL)pParentCol->GetColOrdinal(pColumnName)) >=0)
		{
			hr = S_OK;
		}
		else
		{
			hr = pParentCol->AddColumnNameToList(pColumnName, pCol);
			if( hr == S_OK ){

				//==================================================================
				// We use ordinal numbers for our columns
				//==================================================================
				SetCommonDBCOLUMNINFO(pCol, pParentCol->GetCurrentIndex());
				(*pCol)->wType			        = DBTYPE_HCHAPTER ;
				(*pCol)->ulColumnSize			= sizeof(HCHAPTER); 
				(*pCol)->dwFlags				= DBCOLUMNFLAGS_ISCHAPTER | DBCOLUMNFLAGS_ISFIXEDLENGTH ;

			// NTRaid:111762
			// 06/13/00
				hr = pParentCol->CommitColumnInfo();
			}
		}
    }
    SAFE_DELETE_PTR(pColumnName);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get column info for a property of a class
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::GetPropertyColumnInfo( cRowColumnInfoMemMgr * pColumn, DBCOLUMNINFO ** pCol,CBSTR & pProperty,LONG &lFlavor)
{
    HRESULT hr = E_FAIL;
    VARIANT vValue;
	CIMTYPE propertyType;
	CBSTR strWrite(L"write");
	DBORDINAL lOrdinal = -1;
	VariantInit(&vValue);
	BSTR bstrPath ;
	BSTR bstrProperty;

	if((BSTR)pProperty == NULL)
	{
		//===========================================================================
		// Get the next property
		//===========================================================================
		hr = m_pWbemClassDefinition->GetNextProperty((unsigned short **)&pProperty,(VARIANT *)&vValue, &propertyType,&lFlavor);
	}
	else
	{
		hr = m_pWbemClassDefinition->GetProperty(pProperty,(VARIANT *)&vValue, &propertyType, &lFlavor);
	}


	if( hr == S_OK)
	{
		bstrProperty = Wmioledb_SysAllocString((WCHAR *)(BSTR)pProperty);
		bstrPath = Wmioledb_SysAllocString(L"__PATH");
		// Ignore the __PATH column if the rowset type to be dealt is a rowset for executing
		// a method. This is because , __PATH property exists in __PARAMETERS object but the 
		// object obtained for output parameters does not contain this property
		if(wbem_wcsicmp(bstrProperty , bstrPath) == 0 && m_bMethodRowset == TRUE &&
			((CWbemMethodParameters *)m_pWbemClassParms)->m_pQuery != NULL && 
			((CWbemMethodParameters *)m_pWbemClassParms)->m_pQuery->GetType() == METHOD_ROWSET )
		{
			pProperty.Clear();
			VariantClear(&vValue);
			hr = m_pWbemClassDefinition->GetNextProperty((unsigned short **)&pProperty,(VARIANT *)&vValue, &propertyType,&lFlavor);
		}

		SysFreeString(bstrPath);
		SysFreeString(bstrProperty);

		lOrdinal = pColumn->GetColOrdinal((WCHAR *)(BSTR)pProperty);
		
		// if the column is already present in the col info info return 
		// This will happen when for row objects obtained from rowsets
	    if((DB_LORDINAL)lOrdinal < 0)
		{
		
			hr = pColumn->AddColumnNameToList(pProperty, pCol);
			if( hr == S_OK )
			{

				//==================================================================
				// We use ordinal numbers for our columns
				//==================================================================
				SetCommonDBCOLUMNINFO(pCol, pColumn->GetCurrentIndex());

				// if the property is system property then it cannot be updated
				if(lFlavor == WBEM_FLAVOR_ORIGIN_SYSTEM ||
					m_pWbemClassDefinition->IsClassSchema())
				{
					SetColumnReadOnly(*pCol,TRUE);
				}
				else
				{				
					hr = GetPropertyQualifier(pProperty,(BSTR)strWrite,vValue);

					//if((hr == S_OK) && (VARIANT_TRUE == V_BOOL(&vValue)))
					{
						SetColumnReadOnly(*pCol,FALSE);
					}
					//else
					{
					//	SetColumnReadOnly(*pCol,TRUE);
					}
				}

				pColumn->SetCIMType(propertyType);
				if((propertyType == CIM_OBJECT) || (propertyType == CIM_OBJECTARRAY)) 
				{
					if( propertyType == CIM_OBJECTARRAY)
					{
						propertyType = VT_ARRAY | VT_BSTR;
					}
					else
					{
						propertyType = CIM_STRING;
					}
					SetColumnTypeURL(*pCol);
				}
				
				hr = S_OK;
				CDataMap DataMap;
				DataMap.MapCIMTypeToOLEDBType(propertyType,(*pCol)->wType,(*pCol)->ulColumnSize,(*pCol)->dwFlags);

				// NTRaid:111762
				// 06/13/00
				hr = pColumn->CommitColumnInfo();
			}
        }
    }
    return hr;
}

//**********************************************************************************************************************
//
//      PUBLIC FUNCTIONS
//
//**********************************************************************************************************************

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to initialize the DBCOLUMNDESC structure for various types of column
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::SetColumns( const DBORDINAL cColumnDescs, const DBCOLUMNDESC  rgColumnDescs[])
{
	HRESULT hr = S_OK;

    if( S_OK == (hr = m_pWbemClassDefinition->ValidClass())){

		for( DBORDINAL i = 0; i < cColumnDescs && SUCCEEDED(hr); i++ ) { //for each column

//            switch(ParseQualifiedNameToGetColumnType(rgColumnDescs[i]->pwszTypeName)){
            switch(ParseQualifiedNameToGetColumnType(rgColumnDescs[i].dbcid.uName.pwszName)){

                case WMI_CLASS_QUALIFIER:
                    hr = SetWMIClassQualifier(&rgColumnDescs[i]);
                    break;

                case WMI_PROPERTY_QUALIFIER:
                    hr = SetWMIPropertyQualifier(&rgColumnDescs[i]);                     
                    break;

                case WMI_PROPERTY:
				    hr = SetWMIProperty(&rgColumnDescs[i]);
                    break;

                default:
                    hr = E_INVALIDARG;
                    break;
			}
		}
	}
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to create a new table ( which maps to a new class)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::CreateTable( DBORDINAL cColumnDescs,  const DBCOLUMNDESC rgColumnDescs[], 
		                           ULONG cPropertySets, DBPROPSET rgPropertySets[])
{
	HRESULT hr ;
	BSTR strSuperClass = Wmioledb_SysAllocString(NULL);
	
	// If the class already exists then return error
    if( S_OK == (hr = m_pWbemClassDefinition->ValidClass()))
	{
		hr = DB_E_DUPLICATETABLEID;
	}
	else
	{
		
        hr = m_pWbemClassDefinition->CreateClass();
        if( S_OK == hr ){
	        hr = SetColumns(cColumnDescs, rgColumnDescs); 

			if( hr == S_OK)
			{
				hr = m_pWbemClassDefinition->SaveClass();
			}
        }
    }
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Funtion to add a table ( which maps to a class)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::DropTable() 
{
	HRESULT hr = S_OK;

    if( S_OK == (hr = m_pWbemClassDefinition->ValidClass())){
        hr = m_pWbemClassDefinition->DeleteClass();
		if( hr == S_OK)
		{
			hr = m_pWbemClassDefinition->SaveClass(FALSE);
		}
    }

    return hr;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Funtion to add a column( which maps to property/qualifier)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::AddColumn(const DBCOLUMNDESC* prgColDesc, DBID** pColumnID) //Add a column to current ClassObject definition or instance
{
	HRESULT hr ;
	
    if( S_OK == (hr = m_pWbemClassDefinition->ValidClass())){
        hr = SetColumns(1, prgColDesc);
		if( hr == S_OK)
		{
			hr = m_pWbemClassDefinition->SaveClass(FALSE);
		}
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Funtion to drop a column( which maps to property/qualifier)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::DropColumn(const DBID* pColumnID) //Drop a column from current ClassObject definition or instance
{
	HRESULT hr ;
    WCHAR * pwcsClass = NULL;
    WCHAR * pwcsQualifier = NULL;
    WCHAR * pwcsProperty = NULL;
	CBSTR strColumnName(pColumnID->uName.pwszName);
	
    if( S_OK == (hr = m_pWbemClassDefinition->ValidClass())){

        switch(ParseQualifiedNameToGetColumnType((WCHAR*)pColumnID->uName.pwszName)){

            case WMI_CLASS_QUALIFIER:
                if( ParseQualifiedName((WCHAR*)pColumnID->uName.pwszName,pwcsClass,pwcsQualifier) ){
                    hr = m_pWbemClassDefinition->DeleteClassQualifier(pwcsQualifier);
                }
                break;

            case WMI_PROPERTY_QUALIFIER:
                if( ParseQualifiedName((WCHAR*)pColumnID->uName.pwszName,pwcsProperty,pwcsQualifier) ){
                    hr = m_pWbemClassDefinition->DeletePropertyQualifier(pwcsProperty,pwcsQualifier);
                }
                break;

            case WMI_PROPERTY:
                hr = m_pWbemClassDefinition->DeleteProperty((BSTR)strColumnName);  	
                break;

            default:
                hr = E_INVALIDARG;
                break;
        }
    }

	// If everthing is fine then save the changes to WMI
	if( hr == S_OK)
	{
		hr = m_pWbemClassDefinition->SaveClass(FALSE);
	}

    SAFE_DELETE_PTR(pwcsClass);
    SAFE_DELETE_PTR(pwcsQualifier);
    SAFE_DELETE_PTR(pwcsProperty);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the count of the number of columns
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::GetColumnCount( DBCOUNTITEM &  cTotalColumns,DBCOUNTITEM & cParentColumns,DBCOUNTITEM &cNestedCols)
{
    HRESULT hr;

    cTotalColumns	= 0L;
	cParentColumns	= 0L;
	cNestedCols		= 0L;

    if( S_OK == (hr = m_pWbemClassDefinition->ValidClass())){

        int nCnt = 1;

        //========================================================================
        //  If we are dealing with class qualifiers, then add one column which
        //  will contain the rowset of class qualifiers.
        //========================================================================
        if( m_pWbemClassDefinition->GetFlags() & CLASS_QUALIFIERS ){
            cTotalColumns++;
			cNestedCols++;
        }
        //========================================================================
        //  if we are dealing with property qualifiers, then we will need to add
        //  on a property qualifier for each property column
        //========================================================================
        if( m_pWbemClassDefinition->GetFlags() & PROPERTY_QUALIFIERS ){
            nCnt = 2;
        }
        //========================================================================
        //  Now, get the number of properties for this class
        //========================================================================
        ULONG ulProperties = 0, ulSysPropCount = 0;
        hr= m_pWbemClassDefinition->TotalPropertiesInClass(ulProperties,ulSysPropCount);
		//	NTRaid : 142133 & 141923
		//	07/12/00
		if(hr == S_FALSE)
		{
			cTotalColumns	= 0;
			cParentColumns	= 0;
			cNestedCols		= 0;
			hr = S_OK;
		}
		else
		if(SUCCEEDED(hr))
		{
	
			// Ignore the __PATH column if the rowset type to be dealt is a rowset for executing
			// a method. This is because , __PATH property exists in __PARAMETERS object but the 
			// object obtained for output parameters does not contain this property
			// So if the rowset to be constructed is to represent output parameters of a method
			// execution , decrement the number of system properties
			if(m_bMethodRowset == TRUE && ((CWbemMethodParameters *)m_pWbemClassParms)->m_pQuery != NULL && 
				((CWbemMethodParameters *)m_pWbemClassParms)->m_pQuery->GetType() == METHOD_ROWSET  && ulSysPropCount> 0)
			{
				ulSysPropCount--;
			}

			if( hr == S_OK ){

				cParentColumns	= cTotalColumns + ulSysPropCount + ulProperties;
				cTotalColumns += ulSysPropCount + ulProperties * nCnt;

				cTotalColumns++;	// Adding for the first bookmark column

				// If property is included in the rowset
				if( nCnt>1){
					cNestedCols += ulProperties;
				}

			}
		}
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Gets column information for the class
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::GetColumnInfoForParentColumns(cRowColumnInfoMemMgr * pParentCol)
{
    HRESULT				hr			= S_OK;
	LONG				lFlavour	= 0;
	INSTANCELISTTYPE	objListType = NORMAL;

    if( S_OK == (hr = m_pWbemClassDefinition->ValidClass())){

		if(m_pWbemCommandManager)
		{
			objListType = m_pWbemCommandManager->GetObjListType();
		}
		else
		if(m_pWbemCollectionManager)
		{
			objListType = m_pWbemCollectionManager->GetObjListType();
		}
		switch(objListType)
		{
			case NORMAL:
				{

					if( S_OK == (hr = m_pWbemClassDefinition->BeginPropertyEnumeration()))
					{

						pParentCol->ResetColumns();
						//====================================================================
						// get the column info for class qualifiers 
						//====================================================================
						if( m_pWbemClassDefinition->GetFlags() & CLASS_QUALIFIERS ){
							hr = GetQualifiedNameColumnInfo(pParentCol,pParentCol->CurrentColInfo(),m_pWbemClassParms->GetClassName());
						}
						if( hr == S_OK ){
            
							  CBSTR pProperty;
							//=================================================================
							//  Go through all of the columns we have allocated
							//=================================================================
							while(TRUE){

			//                    CBSTR pProperty;
								hr = GetPropertyColumnInfo(pParentCol,pParentCol->CurrentColInfo(),pProperty,lFlavour);
								if( hr!= S_OK ){
									break;
								}

								//=============================================================
								//  if we are supposed to support property qualifiers
								//=============================================================
								if( m_pWbemClassDefinition->GetFlags() & PROPERTY_QUALIFIERS && (lFlavour != WBEM_FLAVOR_ORIGIN_SYSTEM )){
									hr = GetQualifiedNameColumnInfo(pParentCol,pParentCol->CurrentColInfo(),pProperty);
								}
								pProperty.Clear();
								pProperty.Unbind();
							}

							if( hr == WBEM_S_NO_MORE_DATA ){
								hr = S_OK;
							}
						}
						m_pWbemClassDefinition->EndPropertyEnumeration();
					}
				}
				break;


			case MIXED:
			case SCOPE:
			case CONTAINER:
				{
					if( m_pWbemClassDefinition->GetFlags() & CLASS_QUALIFIERS ){
						hr = GetQualifiedNameColumnInfo(pParentCol,pParentCol->CurrentColInfo(),m_pWbemClassParms->GetClassName());
					}
/*					CBSTR pProperty(L"__PATH");
					hr = GetPropertyColumnInfo(pParentCol,pParentCol->CurrentColInfo(),pProperty,lFlavour);
*/					hr = GetPropertyColumnInfoForMixedRowsets(pParentCol,pParentCol->CurrentColInfo());
				}
				break;
		}	
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::ResetInstances()
{
    return m_paWbemClassInstances->Reset();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::ResetInstancesToNewPosition(DBROWOFFSET lRowOffset)   // Start getting at new position
{     
	return m_paWbemClassInstances->ResetRelPosition(lRowOffset);
   // return m_paWbemClassInstances->ResetInstancesToNewPosition(lRowOffset);
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::ResetPropQualiferToNewPosition(CWbemClassWrapper *pInst,DBROWOFFSET lRowOffset,BSTR strPropertyName)
{
	return pInst->SetQualifierRelPos(lRowOffset,strPropertyName);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::ResetClassQualiferToNewPosition(CWbemClassWrapper *pInst,DBROWOFFSET lRowOffset)
{
	return pInst->SetQualifierRelPos(lRowOffset);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
// Method to get the properties values and put it into the local buffer
//  In the code the code 	if(WBEM_FLAG_DEEP  != lFlags) check if 
//  all instances of child class is obtained or not. This will enable us to check if enumerator is to be 
//  used or not. If this is true , then the col info need not be in the same order as that of the 
//  enumerator, So properties has to be obtained in the order of the column information
///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::GetProperties(CRowDataMemMgr * pRow,CWbemClassWrapper * pClass,cRowColumnInfoMemMgr *pColInfoMgr)
{
    HRESULT hr				= S_OK;
	LONG	lFlags			= 0;
	
	// Get the flags of the class
	lFlags = pClass->GetQueryFlags();

	// Property Enumerator is not used if Deep flag is set or
	// if the query executed results in heterogenous object , in which case 
	// only __PATH is fetched


    CVARIANT vValue ,vChapter;
    LONG lFlavor = 0;
    CBSTR pProperty;
	BSTR bstProperty = NULL;
    BYTE * pData = NULL;
	CIMTYPE lType = 0;
	CDataMap map;
	DBORDINAL lIndex = 1;
	DBCOUNTITEM cCols = 0;

	// IF class Qualifiers are requested updated the qualifier
	if(pClass->GetFlags() & CLASS_QUALIFIERS) {

			vChapter.SetLONG(/*m_pWbemClassDefinition->GetNewHChapter()*/ 0);

		
		if( S_OK != (hr = pRow->CommitColumnToRowData(vChapter,VT_UI4))){
		}
		lIndex++;
	}

	cCols = pColInfoMgr->GetTotalNumberOfColumns();
	bstProperty = Wmioledb_SysAllocString(pColInfoMgr->ColumnName(lIndex));

	while (lIndex < (ULONG_PTR)cCols)
	{
		// Get the specified property
		if(pColInfoMgr->ColumnType(lIndex) != DBTYPE_HCHAPTER)
		{
			if (SysReAllocString(&bstProperty, pColInfoMgr->ColumnName(lIndex)))
			{
				hr = pClass->GetProperty(bstProperty,(VARIANT *)&vValue, &lType, &lFlavor);
			}
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
				break;
			}
		}

        if( FAILED(hr) ){
            break;
        }

		if(( lType != vValue.GetType() && VT_NULL != vValue.GetType() && VT_EMPTY != vValue.GetType()) &&
			lType != (CIM_FLAG_ARRAY | CIM_DATETIME ))
		{
			map.ConvertVariantType((VARIANT &)vValue ,(VARIANT &)vValue,lType);
		}
		else
		if((vValue.GetType() == VT_UNKNOWN) || (vValue.GetType() == CIM_OBJECTARRAY) || (vValue.GetType() == CIM_OBJECT) )
		{
			GetEmbededObjects((CWbemClassInstanceWrapper *)pClass,bstProperty ,vValue);
		}
        //=======================================================================
        //  Set the data into the row            
        //=======================================================================
        if( S_OK != (hr = pRow->CommitColumnToRowData(vValue,(DBTYPE)lType))){
            break;
        }
		lIndex++;

        //======================================================================================
        //  This is where we Get Property Qualifiers if the property is not a system property
        //=======================================================================================
		if( pClass->GetFlags() & PROPERTY_QUALIFIERS && lFlavor != WBEM_FLAVOR_ORIGIN_SYSTEM) {

				vChapter.SetLONG(/*m_pWbemClassDefinition->GetNewHChapter()*/ 0);

			if( S_OK != (hr = pRow->CommitColumnToRowData(vChapter,VT_UI4))){
				break;
			}
			lIndex++;
		}

		vValue.Clear();
	}
	SysFreeString(bstProperty);

	hr = hr == WBEM_S_NO_MORE_DATA ? S_OK : hr;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the next instance 
///////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::GetNextInstance(CWbemClassWrapper *&pInst,CBSTR &strKey , BOOL bFetchBack)
{
    HRESULT hr = WBEM_S_NO_MORE_DATA;
	CWbemClassInstanceWrapper *pInstTemp = NULL;


	if( bFetchBack == FALSE)
	{
		hr = m_paWbemClassInstances->NextInstance(strKey, &pInstTemp);
	}
	else
	{
		hr = m_paWbemClassInstances->PrevInstance(strKey, pInstTemp);
	}

	if(hr == S_OK)
	{
		pInst = (CWbemClassWrapper *)pInstTemp;
	}


    return hr;
}


//==========================================================================================================================
// Functin to get data for a particular instance
//==========================================================================================================================
HRESULT CWmiOleDBMap::GetDataForInstance(CRowDataMemMgr * pRow,CWbemClassWrapper *pInst,cRowColumnInfoMemMgr *pColInfoMgr)
{
    HRESULT hr = S_OK;

	if( pInst != NULL ){

		//========================================================
		//  Now, get the properties 
		//========================================================
		hr = GetProperties(pRow,(CWbemClassWrapper*)pInst,pColInfoMgr);
	}
    return hr;
}

//==========================================================================================================================
// Functin to get data for a particular Schema instance
//==========================================================================================================================
HRESULT CWmiOleDBMap::GetDataForSchemaInstance(CRowDataMemMgr * pRow,CWbemClassWrapper *pPtr,cRowColumnInfoMemMgr *pColInfoMgr)
{
    HRESULT hr = E_INVALIDARG;
    CWbemSchemaClassInstanceWrapper * pClass = (CWbemSchemaClassInstanceWrapper * ) pPtr;

	if( pClass != NULL ){

        CVARIANT vValue;
        LONG lFlavor;
        CBSTR pProperty;
        BYTE * pData = NULL;
		CIMTYPE lType = 0;
		CDataMap map;
		DBORDINAL lIndex = 1;
		DBLENGTH cCols = 0;

        hr = S_OK;
		cCols = pColInfoMgr->GetTotalNumberOfColumns();

		while ( ( S_OK == hr) && (lIndex < cCols)){
 
			hr = pClass->GetSchemaProperty((WCHAR *)pColInfoMgr->ColumnName(lIndex),(VARIANT*)vValue, &lType, &lFlavor);
            if( hr == WBEM_S_NO_MORE_DATA ){
                hr = S_OK;
                break;
            }
            if( lType != vValue.GetType() && VT_NULL != vValue.GetType() && VT_EMPTY != vValue.GetType()){
				map.ConvertVariantType((VARIANT &)vValue ,(VARIANT &)vValue,lType);
			}

            //=======================================================================
            //  Set the data into the row            
            //=======================================================================
            if( S_OK != (hr = pRow->CommitColumnToRowData(vValue,(DBTYPE)lType))){
                break;
            }
			lIndex++;

            VariantClear(&vValue);

        }
    }

	if( hr == WBEM_S_NO_MORE_DATA)
	{
		hr = S_OK;
	}

    return hr;
}


//==========================================================================================================================
// Function to get next property qualifer
//==========================================================================================================================
HRESULT CWmiOleDBMap::GetNextPropertyQualifier(CWbemClassWrapper *pInst,BSTR strPropName,BSTR &strQualifier,BOOL bFetchBack)
{
    HRESULT hr = E_INVALIDARG;
	CVARIANT vValue;
	LONG lType = 0;
	LONG lFlavor = 0;
	CVARIANT var;

	
    if( S_OK == (hr = pInst->ValidClass()))
	{
		if(bFetchBack == FALSE)
		{
			hr = pInst->GetNextPropertyQualifier(strPropName,&strQualifier,(VARIANT *)&vValue, &lType,&lFlavor);
		}
		else
		{
			hr = pInst->GetPrevPropertyQualifier(strPropName,&strQualifier,(VARIANT *)&vValue, &lType,&lFlavor);
		}
	}

	return hr;
}




//==========================================================================================================================
// Function to get data for property qualifer
//==========================================================================================================================
HRESULT CWmiOleDBMap::GetDataForPropertyQualifier(CRowDataMemMgr * pRow,CWbemClassWrapper *pInst,BSTR strPropName, BSTR strQualifier, cRowColumnInfoMemMgr *pColInfoMgr)
{
    HRESULT hr = E_INVALIDARG;
	CVARIANT vValue;
	LONG lType = 0;
	LONG lFlavor = 0;
	CVARIANT var;

	
    if(SUCCEEDED(hr = pInst->ValidClass()))
	{

		hr = pInst->GetPropertyQualifier(strPropName,strQualifier,(VARIANT *)&vValue, &lType,&lFlavor);
		if( SUCCEEDED(hr) )
		{
			hr = CommitRowDataForQualifier(pRow,strQualifier,vValue,lType,lFlavor);	
		}

     }
    
    return hr;
}


//==========================================================================================================================
// Function to get next class qualifer
//==========================================================================================================================
HRESULT CWmiOleDBMap::GetNextClassQualifier(CWbemClassWrapper *pInst,BSTR &strQualifier,BOOL bFetchBack)
{
    HRESULT hr = E_INVALIDARG;
	CVARIANT vValue;
	LONG lType = 0;
	LONG lFlavor = 0;
	CVARIANT var;

	
    if( SUCCEEDED (hr = pInst->ValidClass()))
	{
		if( bFetchBack == FALSE)
		{
			hr = pInst->GetNextClassQualifier(&strQualifier,(VARIANT *)&vValue, &lType,&lFlavor);
		}
		else
		{
			hr = pInst->GetPrevClassQualifier(&strQualifier,(VARIANT *)&vValue, &lType,&lFlavor);
		}
	}

	return hr;
}




//==========================================================================================================================
// Function to get data for class qualifer
//==========================================================================================================================
HRESULT CWmiOleDBMap::GetDataForClassQualifier(CRowDataMemMgr * pRow,CWbemClassWrapper *pInst, BSTR strQualifier, cRowColumnInfoMemMgr *pColInfoMgr)
{
    HRESULT hr = E_INVALIDARG;
	CVARIANT vValue;
	LONG lType = 0;
	LONG lFlavor = 0;
	CVARIANT var;

	
    if(SUCCEEDED(hr = pInst->ValidClass()))
	{

		hr = pInst->GetClassQualifier(strQualifier,(VARIANT *)&vValue, &lType,&lFlavor);
		if( hr == S_OK )
		{
			hr = CommitRowDataForQualifier(pRow,strQualifier,vValue,lType,lFlavor);	
		}

     }
    

    return hr;
}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWmiOleDBMap::IsPropQualiferIncluded()
{
	BOOL bRet = FALSE;

    if( m_pWbemClassDefinition->GetFlags() & PROPERTY_QUALIFIERS )
	{
		bRet = TRUE;
	}

	return bRet;
}


/*
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the column info for the Property Qualifiers
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::GetNextPropertyQualifier( CWbemClassWrapper *pInst,BSTR &strPropName,CVARIANT &vValue,LONG &lType)
{
    HRESULT hr = S_OK;
	/*
    LONG lFlavor;

    //===========================================================================
    //  Get the next property qualifier
    //===========================================================================
    hr = pInst->GetNextPropertyQualifier((unsigned short **)&strPropName,(VARIANT *)&vValue, &lType,&lFlavor);

    return hr;
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the property qualifer
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::GetPropertyQualifier(BSTR strPropName, BSTR strQualifierName ,VARIANT &vValue)
{
    HRESULT hr = S_OK;

    LONG lFlavor;
	CIMTYPE QualifierDataType;

    if( SUCCEEDED(hr = m_pWbemClassDefinition->ValidClass())){

        if(SUCCEEDED (hr = m_pWbemClassDefinition->BeginPropertyQualifierEnumeration(strPropName)))
		{
			// call this function to get a specific property
			hr = m_pWbemClassDefinition->GetPropertyQualifier(strQualifierName,(VARIANT *)&vValue, &QualifierDataType,&lFlavor);
			m_pWbemClassDefinition->EndPropertyQualifierEnumeration();
        }
    }

    return hr;
}



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// set a particular column's as readonly property
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CWmiOleDBMap::SetColumnReadOnly(DBCOLUMNINFO * pCol, BOOL bReadOnly)
{
	if(bReadOnly == FALSE)
	{
		pCol->dwFlags |= DBCOLUMNFLAGS_WRITE;
	}
	else
	{
		pCol->dwFlags &= ~(DBCOLUMNFLAGS_WRITE);
	}
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Delete a particular instance
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::DeleteInstance(CWbemClassWrapper * pClass )
{
	HRESULT hr = S_OK;
	CWbemClassInstanceWrapper *pTemp = (CWbemClassInstanceWrapper *) pClass;
	hr = m_paWbemClassInstances->DeleteInstance(pTemp);

	return hr;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// update a instance 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::UpdateInstance(CWbemClassWrapper *pInst,BOOL bNewInst)
{
	CWbemClassInstanceWrapper *pTemp = (CWbemClassInstanceWrapper *) pInst;
	return m_paWbemClassInstances->UpdateInstance(pTemp,bNewInst);
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Add new instance
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::AddNewInstance(CWbemClassWrapper ** ppClass )
{
	HRESULT hr = S_OK;
	// NTRaid:111794
	// 06/07/00
	CWbemClassInstanceWrapper *pNewInst = NULL ;
	hr = m_paWbemClassInstances->AddNewInstance((CWbemClassWrapper *)m_pWbemClassDefinition ,&pNewInst);
	if(SUCCEEDED(hr))
	{
		*ppClass = pNewInst;
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set navigation flags for enumerator
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CWmiOleDBMap::SetNavigationFlags(DWORD dwFlags)
{
	m_pWbemClassParms->SetEnumeratorFlags(dwFlags);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set navigation flags for enumerator
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CWmiOleDBMap::SetQueryFlags(DWORD dwFlags)
{
	m_pWbemClassParms->SetQueryFlags(dwFlags);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Refresh a particular instance
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::RefreshInstance(CWbemClassWrapper * pInstance )
{
	return ((CWbemClassInstanceWrapper *)pInstance)->RefreshInstance();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get a particular property of the instance
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::GetProperty(CWbemClassWrapper *pInst,BSTR pProperty, BYTE *& pData,DBTYPE &dwType ,DBLENGTH & dwSize, DWORD &dwFlags  )
{
	CVARIANT varValue;
	CIMTYPE cType = 0;
	LONG lFlavor = 0;
	CDataMap map;
	HRESULT hr = 0;
	DBTYPE dbType = 0;


	hr = pInst->GetProperty(pProperty, &varValue, (LONG *)&cType ,&lFlavor );
	if( hr == S_OK)
	{
		dbType = (DBTYPE)varValue.GetType();
		// NTRaid 135384
		if(cType == CIM_DATETIME || cType == CIM_IUNKNOWN)
		{
			dbType = (DBTYPE)cType;
		}
		else
		// If the property is an embeded instance
		if( dbType == VT_UNKNOWN || dbType == CIM_OBJECTARRAY || dbType == CIM_OBJECT)
		{
			hr = GetEmbededObjects((CWbemClassInstanceWrapper *)pInst,pProperty,varValue);
			dbType = varValue.GetType();
		}

		// return value of this function will be the status
		if(SUCCEEDED(hr = map.AllocateAndMapCIMTypeToOLEDBType(varValue,pData,dbType,dwSize, dwFlags)))
		{
			dwType = dbType;
			if((cType == (CIM_DATETIME | CIM_FLAG_ARRAY)) || (cType == (DBTYPE_DBTIMESTAMP | CIM_FLAG_ARRAY)) )
			{
				dwType = (DBTYPE)cType;
			}
			else
			if(cType == CIM_IUNKNOWN)
			{
				dwType = DBTYPE_IUNKNOWN;
			}
			hr = S_OK;
		}
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get the instance pointerd by the path
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemClassWrapper * CWmiOleDBMap::GetInstance(BSTR strPath)
{ 
	CWbemClassWrapper *pInst = NULL;
	pInst = m_pWbemClassDefinition->GetInstance(strPath); 
	
	// Add the instance to the list so that this get released when class is destructed
	if(pInst != NULL)
	{
		m_paWbemClassInstances->AddInstance((CWbemClassInstanceWrapper *)pInst);
	}

	return pInst;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get Embeded objects and generate URLS for every embeded instance and put it into SAFEARRATS of URLS
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::GetEmbededObjects(CWbemClassInstanceWrapper * pClass,BSTR strProperty,CVARIANT &vValue)
{
	CVARIANT					vTemp;
	HRESULT						hr				= S_OK;
	CWbemClassInstanceWrapper *	pNewInst		= NULL;
	IWbemClassObject *			pClassObject	= NULL;
	CBSTR						strKey;
	SAFEARRAY *					pArray;
	SAFEARRAY *					pArrayOut;
	LONG						rgIndices[1];
	IUnknown *					pUnk			= NULL;
	void *						p				= NULL;
    SAFEARRAYBOUND				rgsabound[1];    
	LONG						lBound = 0 , uBound = 0;

	VariantCopy(&vTemp, vValue);
	vValue.Clear();

	try
	{
		pNewInst = new CWbemClassInstanceWrapper(m_pWbemClassParms);
	}
	catch(...)
	{
		SAFE_DELETE_PTR(pNewInst);
		throw;
	}
	if(pNewInst == NULL)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		if(vTemp.GetType() & VT_ARRAY)
		{
			pArray = (SAFEARRAY *)vTemp;

			hr = SafeArrayGetLBound(pArray,1,&lBound);
			hr = SafeArrayGetUBound(pArray,1,&uBound);
			
			rgsabound[0].lLbound = lBound;
			rgsabound[0].cElements = uBound - lBound + 1;		// This is because the bounds includes both the bounds
			pArrayOut = SafeArrayCreate(VT_BSTR, 1, rgsabound);

			for( int nIndex = lBound ; nIndex <= uBound ; nIndex++)
			{
				strKey.Clear();
				rgIndices[0] = nIndex;
				hr = SafeArrayGetElement(pArray,&rgIndices[0],(void *)&pUnk);

				hr = pUnk->QueryInterface(IID_IWbemClassObject , (void **)&pClassObject);
				
				if(SUCCEEDED(hr))
				{
					pNewInst->SetClass(pClassObject);
					hr = pNewInst->GetKey(strKey);

					pUnk->Release();
					pClassObject->Release();

					GenerateURL(pClass,strProperty,nIndex, strKey);

					hr = SafeArrayPutElement(pArrayOut,&rgIndices[0],(void *)strKey);
				}
			}
			// If the elements in the array is not equal to zero
			if(SUCCEEDED(hr) && (uBound - lBound + 1 != 0))
			{
				vValue.SetArray(pArrayOut,VT_ARRAY|VT_BSTR);
			}
		}
		else
		{
			hr = vTemp.GetUnknown()->QueryInterface(IID_IWbemClassObject , (void **)&pClassObject);
			if(SUCCEEDED(hr))
			{
				pNewInst->SetClass(pClassObject);
				hr = pNewInst->GetKey(strKey);
				pClassObject->Release();
				GenerateURL(pClass,strProperty,-1, strKey);
				vValue.SetStr(strKey);
			}
		}
		SAFE_DELETE_PTR(pNewInst);
	}

	return hr;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Generate URL for an instance , Used for embeded instance
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CWmiOleDBMap::GenerateURL(CWbemClassInstanceWrapper * pClass,BSTR strProperty,ULONG nIndex,CBSTR &strIn)
{
	// NTRaid: 136446
	// 07/05/00
	CURLParser urlParser;
	BSTR bstrURL = NULL;

	if((strIn == NULL) || (SysStringLen(strIn) == 0))
	{
		pClass->GetKey(strIn);
	}
	
	urlParser.SetPath(strIn);
	urlParser.SetEmbededInstInfo(strProperty,nIndex);
	urlParser.GetURL(bstrURL);
	
	strIn.Clear();
	strIn.SetStr((LPWSTR)bstrURL);

	SysFreeString(bstrURL);
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get embeded instance 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CWbemClassWrapper *CWmiOleDBMap::GetEmbededInstance(BSTR strPath,BSTR strProperty,int nIndex)
{
	CWbemClassInstanceWrapper * pParentInst = NULL;
	CWbemClassInstanceWrapper * pInstance   = NULL;
	IWbemClassObject *pObject = NULL;
	IUnknown *pUnk = NULL;
	CVARIANT vValue;
	LONG lType;
	LONG lFlavor;
	HRESULT hr = S_OK;

	pParentInst = (CWbemClassInstanceWrapper *)m_pWbemClassDefinition->GetInstance(strPath); 
	
	if(pParentInst)
	{
		hr = pParentInst->GetProperty(strProperty,(VARIANT *)&vValue, &lType, &lFlavor);

		if(hr == S_OK && (vValue.GetType() == VT_UNKNOWN || vValue.GetType() == CIM_OBJECTARRAY ))
		{
			if( nIndex < 0 && vValue.GetType() == VT_UNKNOWN)
			{
				hr = vValue.GetUnknown()->QueryInterface(IID_IWbemClassObject,(void **)&pObject);
			}
			else
			if( nIndex >= 0 && vValue.GetType() == CIM_OBJECTARRAY)
			{
				hr = SafeArrayGetElement(vValue,(long *)&nIndex,(void *)&pUnk);
				if( hr == S_OK)
				{
					hr = pUnk->QueryInterface(IID_IWbemClassObject,(void **)&pObject);
					pUnk->Release();
				}
			}
			if(hr == S_OK)
			{
				try
				{
					pInstance = new CWbemClassInstanceWrapper(m_pWbemClassParms);
				}
				catch(...)
				{
					SAFE_DELETE_PTR(pInstance);
					throw;
				}
				if(pInstance == NULL)
				{
					hr = E_OUTOFMEMORY;
				}
				else
				{
					pInstance->SetClass(pObject);

					// Add the instance to the list so that this get released when class is destructed
					m_paWbemClassInstances->AddInstance((CWbemClassInstanceWrapper *)pInstance);
				}
			}
		}
		SAFE_RELEASE_PTR(pObject);
		SAFE_DELETE_PTR(pParentInst);
	}

	return pInstance;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Check if a particular property is a system property
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CWmiOleDBMap::IsSystemProperty(BSTR strProperty)
{
	LONG lFlavour = 0;
	BOOL bRet = FALSE;
	if( S_OK == m_pWbemClassDefinition->GetProperty(strProperty,NULL,NULL,&lFlavour) &&
		(lFlavour == WBEM_FLAVOR_ORIGIN_SYSTEM))
	{
		bRet = TRUE;
	}
	return bRet;

}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get default value from the DBCOLUMNDESC for a particular property
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CWmiOleDBMap::GetDefaultValue(const DBCOLUMNDESC * prgColDesc, VARIANT & varDefault)
{
	ULONG lIndex = 0,lColPropIndex = 0 , lPropType = 0;
	BOOL bDefault = FALSE;
	DBTYPE lType ;
	BSTR strDate;
	BOOL bDateTime = FALSE;
	VARIANT *pDefaultData;
	CDataMap map;
	

	memset(&varDefault,0,sizeof(VARIANT));

	// search for the DBPROP_COL_DEFAULT property in DBPROPSET_COLUMN in the property sets
	if(prgColDesc->cPropertySets > 0)
	{
		for ( lIndex = 0 ; lIndex < prgColDesc->cPropertySets;lIndex++)
		{
			if(prgColDesc->rgPropertySets[lIndex].guidPropertySet == DBPROPSET_COLUMN)
			for( lColPropIndex = 0; lColPropIndex < prgColDesc->rgPropertySets[lIndex].cProperties ; lColPropIndex++)
			{
				if(prgColDesc->rgPropertySets[lIndex].rgProperties[lColPropIndex].dwPropertyID  == DBPROP_COL_DEFAULT)
				{
					pDefaultData = &prgColDesc->rgPropertySets[lIndex].rgProperties[lColPropIndex].vValue;
					lType = prgColDesc->wType;

					switch(lType)
					{
						case DBTYPE_DBTIMESTAMP :
							map.ConvertOledbDateToCIMType(pDefaultData,strDate);
							bDateTime = TRUE;
							break;

						case DBTYPE_DBDATE :
							map.ConvertVariantDateToCIMType(pDefaultData->pdate,strDate);
							bDateTime = TRUE;
							break;

						case DBTYPE_DBTIME :
							bDateTime = TRUE;
							break;

						default:
							VariantCopy(&varDefault,pDefaultData);

					}
					if(bDateTime == TRUE)
					{
						varDefault.vt = VT_BSTR;
						varDefault.bstrVal = strDate;
					}

				}
			}
		}
	}
	
	lPropType = ParseQualifiedNameToGetColumnType(prgColDesc->dbcid.uName.pwszName);
	lType = prgColDesc->wType;

	// If there is no default and if it is a qualilfier then 
	if( bDefault == FALSE &&  (lPropType == WMI_CLASS_QUALIFIER || lPropType == WMI_PROPERTY_QUALIFIER))
	{
		memset(&varDefault,0,sizeof(VARIANT));
		switch(lType)
		{
			case DBTYPE_I1:
			case DBTYPE_UI1:
			case DBTYPE_I2:
			case DBTYPE_UI2:
			case DBTYPE_I4:
			case DBTYPE_UI4:
			case DBTYPE_I8:
			case DBTYPE_UI8:
			case DBTYPE_R4:
			case DBTYPE_R8:
			case DBTYPE_WSTR:
			case DBTYPE_STR:
			case DBTYPE_IDISPATCH :
				varDefault.vt = (SHORT)lType;
				break;

			case DBTYPE_BSTR:
				varDefault.vt = VT_BSTR;
				varDefault.bstrVal = SysAllocString(L"");
				break;

			case DBTYPE_BOOL:
				varDefault.vt = VT_BOOL;
				varDefault.boolVal = VARIANT_TRUE;
				break;

			case DBTYPE_DBTIMESTAMP:
				varDefault.vt = VT_DATE;
				break;


		}
	}


}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Commit the row data for qualifier rowset
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::CommitRowDataForQualifier(CRowDataMemMgr * pRow,BSTR strQualifier,CVARIANT &vValue, ULONG lType, ULONG lFlavor)
{
	HRESULT hr = S_OK;
	CVARIANT var;

	var.SetStr(strQualifier);
	hr = pRow->CommitColumnToRowData(var,DBTYPE_BSTR);
	
	if( hr == S_OK)
	{
		var.Clear();
		var.SetLONG(vValue.GetType());
		hr = pRow->CommitColumnToRowData(var,DBTYPE_UI4);
	}

	if( hr == S_OK)
	{
		hr = pRow->CommitColumnToRowData(vValue,DBTYPE_VARIANT);
	}
	
	if( hr == S_OK)
	{
		var.Clear();
		var.SetLONG(lFlavor);
		hr = pRow->CommitColumnToRowData(var,DBTYPE_BSTR);
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Function to release a qualifer
//////////////////////////////////////////////////////////////////////////////////////////
void CWmiOleDBMap::ReleaseQualifier(CWbemClassWrapper *pInst,BSTR strProperty)
{
	if( strProperty == NULL)
	{
		pInst->ReleaseClassQualifier(); 
	}
	else		
	{
		pInst->ReleasePropertyQualifier(strProperty); 
	}
}



HRESULT CWmiOleDBMap::SetQualifier(CWbemClassWrapper *pInst,BSTR bstrColName,BSTR bstrQualifier ,VARIANT *pvarData,LONG lFlavor) 
{ 
	HRESULT hr = E_FAIL;

	if(bstrColName == NULL)
	{
		hr = pInst->SetClassQualifier(bstrQualifier,pvarData,lFlavor);
	}
	else
	{
		hr = pInst->SetPropertyQualifier(bstrColName,bstrQualifier,pvarData,lFlavor);
	}
	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Funtion to add a index qualifier for a property
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::AddIndex(const DBID* pColumnID)
{
	HRESULT hr ;
	CBSTR strColumnName(pColumnID->uName.pwszName);
	CBSTR strIndexQualifier((WCHAR *)strIndex);
	VARIANT varIndexValue;
	VariantInit(&varIndexValue);
	
	varIndexValue.vt			= VT_BOOL;
	varIndexValue.boolVal	= VARIANT_TRUE;

	
    if( S_OK == (hr = m_pWbemClassDefinition->ValidClass())){

		//===================================================================================
		// If the passed columnID is a property then add a index qualifier to the property
		//===================================================================================
       if(WMI_PROPERTY == ParseQualifiedNameToGetColumnType((WCHAR*)pColumnID->uName.pwszName))
		{
			hr = SetQualifier(m_pWbemClassDefinition,strColumnName,strIndexQualifier ,&varIndexValue,0);
		}
		else
		{
			hr = DB_E_BADCOLUMNID;
        }
    }

	//=================================================================
	// If everthing is fine then save the changes to WMI
	//=================================================================
	if( hr == S_OK)
	{
		hr = m_pWbemClassDefinition->SaveClass(FALSE);
	}
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Funtion to delete a index qualifier as mentioned in pIndexID
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::DropIndex(const DBID* pIndexID)
{
	HRESULT hr ;
	CBSTR strColumnName(pIndexID->uName.pwszName);
	WCHAR *pStrIndex = NULL;
    WCHAR * pwcsQualifier = NULL;
    WCHAR * pwcsProperty = NULL;

	try
	{
		pStrIndex =  new WCHAR [wcslen(strIndex) + 1];
	}
	catch(...)
	{
		SAFE_DELETE_ARRAY(pStrIndex);
		throw;
	}

	if(pStrIndex == NULL)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		wcscpy(pStrIndex,(WCHAR *)strIndex);

		_wcsupr(pStrIndex);

		
		if( S_OK == (hr = m_pWbemClassDefinition->ValidClass())){

			if(WMI_PROPERTY_QUALIFIER == ParseQualifiedNameToGetColumnType((WCHAR*)pIndexID->uName.pwszName))
			{
					if( ParseQualifiedName((WCHAR*)pIndexID->uName.pwszName,pwcsProperty,pwcsQualifier))
					{
						_wcsupr(pwcsQualifier);
						//=================================================================
						// If the qualifer name is "Index" then delete the index 
						//=================================================================
						if(wbem_wcsicmp(pStrIndex,pwcsQualifier) == 0)
							hr = m_pWbemClassDefinition->DeletePropertyQualifier(pwcsProperty,pwcsQualifier);
						else
							hr = E_INVALIDARG;		// the index ID passed is invalid
					}
			}
			else
			{
				hr = E_INVALIDARG; // passed index is not a valid index 
			}
		}
		// free the memory
		SAFE_DELETE_ARRAY(pStrIndex);
		SAFE_DELETE_ARRAY(pwcsProperty);
		SAFE_DELETE_ARRAY(pwcsQualifier);

		//=================================================================
		// If everthing is fine then save the changes to WMI
		//=================================================================
		if(SUCCEEDED( hr))
		{
			hr = m_pWbemClassDefinition->SaveClass(FALSE);
		}
	}

    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Converts the OLEDB COLUMN properties to appropriate WMI properties/flavors
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::SetColumnProperties(const DBCOLUMNDESC * prgColDesc)
{
	HRESULT hr = E_FAIL;
	CBSTR bstrProperty(prgColDesc->dbcid.uName.pwszName);
	CDataMap map;
	LONG lType = 0;
	BOOL bIsColProperty = FALSE;

    //==================================================================================
    //  Ok, we already know we have a valid class here so just check if we have a valid
    //  property
    //==================================================================================
    if( SUCCEEDED(hr = ValidProperty(prgColDesc)))
	{
		switch(ParseQualifiedNameToGetColumnType(prgColDesc->dbcid.uName.pwszName))
		{

			case WMI_CLASS_QUALIFIER:
				hr = SetWMIClassQualifier(prgColDesc,FALSE);
				break;

			case WMI_PROPERTY_QUALIFIER:
				hr = SetWMIPropertyQualifier(prgColDesc,FALSE);                     
				break;

			case WMI_PROPERTY:
				bIsColProperty = TRUE;
				break;

			default:
				hr = E_INVALIDARG;
				break;
		}
	        
		// If the column passed is a property , then add qualifiers for the different
		// column properties
		if( bIsColProperty == TRUE)
		{
			//==========================================================================
			//  Go through the DBPROPSETS and the DBPROPS in them to see if they 
			//  happen to match some of the standard qualifiers we have mapped to them
			//==========================================================================
   
			for( ULONG i = 0; i <  prgColDesc->cPropertySets; i++ )
			{

				for ( ULONG j = 0; j < prgColDesc->rgPropertySets[i].cProperties; j++ ) 
				{

					CVARIANT Value,Qualifier;
					LONG lFlavor;

					//==================================================================
					//  See if we have a match, if we do, save it to WMI
					//==================================================================
					hr = MapDBPROPToStdPropertyQualifier(prgColDesc->rgPropertySets[i].rgProperties[j],Qualifier,Value, lFlavor);
					if( hr == S_OK)
					{

						hr = m_pWbemClassDefinition->SetPropertyQualifier((BSTR)bstrProperty,Qualifier,Value,0);
						if( FAILED(hr))
						{
							hr = E_FAIL;
							break;
						}
						else
						{
							hr = m_pWbemClassDefinition->SaveClass(FALSE);
						}
					}
				}
			}
		}
    }
	return hr;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to get class name of an instance
//////////////////////////////////////////////////////////////////////////////////////////////////////
WCHAR * CWmiOleDBMap::GetClassName() 
{ 
	WCHAR *pRet = NULL;
	//================================================================
	// if this class is opened on command by executing query then
	// return NULL as the class name
	//================================================================
	if(!(m_pWbemCommandManager || m_pWbemCollectionManager))
	{
		pRet = m_pWbemClassParms->GetClassName(); 
	}

	return pRet;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to delete a quallifier
//////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT	CWmiOleDBMap::DeleteQualifier(CWbemClassWrapper *pInst,
					BSTR strQualifierName,
					BOOL bClassQualifier ,
					BSTR strPropertyName )

{
	HRESULT hr = S_OK;

	if(bClassQualifier)
	{
		hr = pInst->DeletePropertyQualifier(strPropertyName,strQualifierName);
	}
	else
	{
		hr = ((CWbemClassDefinitionWrapper *)pInst)->DeleteClassQualifier(strPropertyName);
	}

	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to remove an object from a container
//////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::UnlinkObjectFromContainer(BSTR strContainerObj,BSTR strObject)
{
	return m_pWbemClassParms->RemoveObjectFromContainer(strContainerObj,strObject);
}


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to add an object to a container
//////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::LinkObjectFromContainer(BSTR strContainerObj,BSTR strObject)
{
	return m_pWbemClassParms->AddObjectFromContainer(strContainerObj,strObject);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
// Function to copy an existing instance to another scope
//////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CWmiOleDBMap::CloneAndAddNewObjectInScope(BSTR strObj, BSTR strScope,WCHAR *& pstrNewPath)
{
	HRESULT hr = DB_E_NOTFOUND;
	CWbemClassWrapper *pInstance = GetInstance(strScope);

	if(pInstance)
	{
		hr = m_pWbemClassParms->CloneAndAddNewObjectInScope(pInstance,strObj,pstrNewPath);
	}

	return hr;
}


HRESULT CWmiOleDBMap::GetPropertyColumnInfoForMixedRowsets( cRowColumnInfoMemMgr * pColumn, DBCOLUMNINFO ** pCol)
{
    HRESULT hr = S_OK;
	DBORDINAL lOrdinal = -1;
	

	BSTR bstrProperty = Wmioledb_SysAllocString(L"__PATH");
	lOrdinal = pColumn->GetColOrdinal((WCHAR *)L"__PATH");
	
	// if the column is already present in the col info info return 
	// This will happen when for row objects obtained from rowsets
	if((DB_LORDINAL)lOrdinal < 0)
	{
	
		hr = pColumn->AddColumnNameToList(bstrProperty, pCol);
		SysFreeString(bstrProperty);
		if( hr == S_OK )
		{
			//==================================================================
			// We use ordinal numbers for our columns
			//==================================================================
			SetCommonDBCOLUMNINFO(pCol, pColumn->GetCurrentIndex());
			SetColumnReadOnly(*pCol,TRUE);

			pColumn->SetCIMType(VT_BSTR);
			

			(*pCol)->wType			= VT_BSTR;
			(*pCol)->ulColumnSize	= ~0;
			(*pCol)->dwFlags		= 0;

			hr = S_OK;
			// NTRaid:111762
			// 06/13/00
			hr = pColumn->CommitColumnInfo();
		}
	}
    return hr;

}

INSTANCELISTTYPE CWmiOleDBMap::GetObjListType()
{
	INSTANCELISTTYPE qType = NORMAL;
	if(m_pWbemCommandManager)
	{
		qType = m_pWbemCommandManager->GetObjListType();
	}
	else
	if(m_pWbemCollectionManager)
	{
		qType = m_pWbemCollectionManager->GetObjListType();
	}
	return qType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\wmiver.h ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
// Wmiver.h - File having declarations for version information
// 
//
///////////////////////////////////////////////////////////////////////////////////

// Constants -----------------------------------------------------------------
#ifndef _AXVER_H_
#define _AXVER_H_

#define VER_FILEVERSION  02,00,2905,0
#define VER_FILEVERSION_STR  "02.00.2905.0\0"
#define VER_PRODUCTVERSION  02,00,2905,0
#define VER_PRODUCTVERSION_STR  "02.00.2905.0\0"

#define VER_FILEFLAGSMASK		(VS_FF_DEBUG | VS_FF_PRERELEASE)
#ifdef DEBUG
#define VER_FILEFLAGS			(VS_FF_DEBUG)
#else
#define VER_FILEFLAGS			(0)
#endif

#define VER_FILEOS				VOS_NT_WINDOWS32

#define VER_COMPANYNAME_STR		"Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR		"Microsoft OLE DB\0"
#define VER_LEGALCOPYRIGHT_STR	"Copyright \251 Microsoft Corporation 1995-1998\0"

// Resource DLL Version Resource ID
#define IDS_RESDLL_VER			1

#endif
//--------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\wmioledbmap.h ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMIOLE DB Provider
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//  Purpose: WmiOleDBMap.h: interface for the CWmiOleDBMap class.
// 
//
///////////////////////////////////////////////////////////////////////////////////
#ifndef _WMIOLEDBMAP_HEADER
#define _WMIOLEDBMAP_HEADER

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#include "headers.h"

const WCHAR strIndex[] = L"Index";

class CQuery;

#define ALL_QUALIFIERS      0x00000003
#define NO_QUALIFIERS       0x00000000
#define CLASS_QUALIFIERS    0x00000001
#define PROPERTY_QUALIFIERS 0x00000002

#define QUALIFIER_ L"Qualifier_"
#define DEFAULT_QUALIFIER_COUNT   10

#define WMI_CLASS_QUALIFIER         1
#define WMI_PROPERTY_QUALIFIER      2   
#define WMI_PROPERTY                3

const CIM_OBJECTARRAY= CIM_FLAG_ARRAY | CIM_OBJECT ;

class  cRowColumnInfoMemMgr;
class  CRowDataMemMgr;
///////////////////////////////////////////////////////////////////////////////////////////////////////////
class CWmiOleDBMap  
{

    private:

        CWbemClassParameters        *   m_pWbemClassParms;          // Common class information, such as name, context
        CWbemClassDefinitionWrapper *   m_pWbemClassDefinition;     // Just class definitions
        CWbemInstanceList           *   m_paWbemClassInstances;     // Just instance info
        CWbemCommandManager         *   m_pWbemCommandManager;      // To manage commands
		CWbemCollectionManager		*	m_pWbemCollectionManager;

		CWbemClassWrapper			*	m_pWbemCurInst;
		ULONG							m_cRef;
		BOOL							m_bMethodRowset;
        
        CPropertyMemoryMgr m_PropMemMgr;

        BOOL	ParseQualifiedName(WCHAR * Root, WCHAR *& Parent, WCHAR *& Child );
        HRESULT ValidProperty(const DBCOLUMNDESC * prgColDesc);
        HRESULT MapDBPROPToStdPropertyQualifier( DBPROP pProp, CVARIANT & Qualifier, CVARIANT & Value, LONG & lFlavor );
        HRESULT MapDBPROPToStdClassQualifier( DBPROP pProp, CVARIANT & Qualifier, CVARIANT & Value, LONG & uFlavor );

        HRESULT SetWMIProperty(const DBCOLUMNDESC* prgColDesc);
        HRESULT SetWMIClassQualifier(const DBCOLUMNDESC * prgColDesc,BOOL bDefault = TRUE);
        HRESULT SetWMIPropertyQualifier(const DBCOLUMNDESC * prgColDesc,BOOL bDefault = TRUE);

        HRESULT GetPropertyColumnInfo( cRowColumnInfoMemMgr * pColumn, DBCOLUMNINFO ** pCol,CBSTR & pProperty,LONG &lFlavor);
//		HRESULT GetNextPropertyQualifier( CWbemClassWrapper *pInst,BSTR &strPropName,CVARIANT &vValue, LONG &lType);
        
		HRESULT GetProperties(CRowDataMemMgr * pRow,CWbemClassWrapper * pClass,cRowColumnInfoMemMgr *pColInfoMgr);

		HRESULT GetEmbededObjects(CWbemClassInstanceWrapper * pClass,BSTR strProperty,CVARIANT &vValue);
		HRESULT CommitRowDataForQualifier(CRowDataMemMgr * pRow,BSTR strQualifier,CVARIANT &vValue, ULONG lType, ULONG lFlavor);
		void	GenerateURL(CWbemClassInstanceWrapper * pClass,BSTR strProperty,ULONG nIndex,CBSTR &strIn);
		void	GetDefaultValue(const DBCOLUMNDESC * prgColDesc, VARIANT & varDefault);
        HRESULT SetColumns( const DBORDINAL cColumnDescs, const DBCOLUMNDESC  rgColumnDescs[]);
		HRESULT GetPropertyColumnInfoForMixedRowsets( cRowColumnInfoMemMgr * pColumn, DBCOLUMNINFO ** pCol);

		void SetColumnTypeURL(DBCOLUMNINFO * pCol)
		{
			pCol->dwFlags |= DBCOLUMNFLAGS_ISROWURL;
		}


    public:

//		CWmiOleDBMap(DWORD dwFlags, IDispatch *pDisp,CWbemConnectionWrapper * pWrap);
/*        CWmiOleDBMap(int nSchemaType, DWORD dwFlags, WCHAR * pClassName, WCHAR * pSpecificTable, CWbemConnectionWrapper * Connect);
        CWmiOleDBMap(DWORD dwFlags, WCHAR * pClassName, CWbemConnectionWrapper * Connect,BOOL fSchema = FALSE);
        CWmiOleDBMap(DWORD dwFlags, CQuery* p, CWbemConnectionWrapper * Connect);
		CWmiOleDBMap(DWORD dwFlags, WCHAR * pObjectPath, CWbemConnectionWrapper * Connect,INSTANCELISTTYPE instListType);
*/		CWmiOleDBMap();

        HRESULT FInit(int nSchemaType, DWORD dwFlags, WCHAR * pClassName, WCHAR * pSpecificTable, CWbemConnectionWrapper * Connect);
        HRESULT FInit(DWORD dwFlags, WCHAR * pClassName, CWbemConnectionWrapper * Connect);
        HRESULT FInit(DWORD dwFlags, CQuery* p, CWbemConnectionWrapper * Connect);
		HRESULT FInit(DWORD dwFlags, WCHAR * pObjectPath, CWbemConnectionWrapper * Connect,INSTANCELISTTYPE instListType);

		~CWmiOleDBMap();

        //===================================================================================
        //  
        //===================================================================================
        HRESULT CreateTable( DBORDINAL cColumnDescs, const DBCOLUMNDESC rgColumnDescs[], 
		                     ULONG cPropertySets, DBPROPSET rgPropertySets[]);
        HRESULT AddColumn(const DBCOLUMNDESC* prgColDesc, DBID** ppColumnID);
        HRESULT DropColumn(const DBID* pColumnID);

        HRESULT SetCommonDBCOLUMNINFO(DBCOLUMNINFO ** pCol,DBORDINAL uCurrentIndex);
        void	SetColumnReadOnly(DBCOLUMNINFO * pCol, BOOL bReadOnly);
        HRESULT GetQualifiedNameColumnInfo( cRowColumnInfoMemMgr * pParentCol,DBCOLUMNINFO ** pCol, WCHAR * pName);

        HRESULT DropTable();


        HRESULT GetColumnCount( DBCOUNTITEM &  cTotalColumns,DBCOUNTITEM & cParentColumns,DBCOUNTITEM &cNestedCols);
        HRESULT GetColumnInfoForParentColumns(cRowColumnInfoMemMgr * pParentCol);

        HRESULT ResetInstances();
        HRESULT ResetInstancesToNewPosition(DBROWOFFSET);
        HRESULT GetNextInstance(CWbemClassWrapper *&ppInst, CBSTR &strKey ,BOOL bFetchBack);
		HRESULT GetDataForInstance(CRowDataMemMgr * pRow,CWbemClassWrapper *pInst,cRowColumnInfoMemMgr *pColInfoMgr);
		HRESULT GetDataForSchemaInstance(CRowDataMemMgr * pRow,CWbemClassWrapper *pInst,cRowColumnInfoMemMgr *pColInfoMgr);

		HRESULT GetPropertyQualifier(BSTR strPropName, BSTR strQualifierName ,VARIANT &vValue);
        BOOL	IsPropQualiferIncluded();
		HRESULT GetDataForPropertyQualifier(CRowDataMemMgr * pRow,CWbemClassWrapper *pInst,BSTR strPropName, BSTR strQualifier, cRowColumnInfoMemMgr *pColInfoMgr);
		BOOL	IsSystemProperty(BSTR strProperty);
		HRESULT GetNextPropertyQualifier(CWbemClassWrapper *pInst,BSTR strPropName,BSTR &strQualifier,BOOL bFetchBack = FALSE);
		HRESULT ResetPropQualiferToNewPosition(CWbemClassWrapper *pInst,DBROWOFFSET lRowOffset,BSTR strPropertyName);

		HRESULT GetNextClassQualifier(CWbemClassWrapper *pInst,BSTR &strQualifier,BOOL bFetchBack = FALSE);
		HRESULT GetDataForClassQualifier(CRowDataMemMgr * pRow,CWbemClassWrapper *pInst, BSTR strQualifier, cRowColumnInfoMemMgr *pColInfoMgr);
		HRESULT ResetClassQualiferToNewPosition(CWbemClassWrapper *pInst,DBROWOFFSET lRowOffset);

		HRESULT DeleteInstance(CWbemClassWrapper * pClass );
		HRESULT UpdateInstance(CWbemClassWrapper *pInst , BOOL bNewInst);
		HRESULT AddNewInstance(CWbemClassWrapper ** ppClass );
		HRESULT RefreshInstance(CWbemClassWrapper * pInstance );
		void	ReleaseAllQualifiers(CWbemClassWrapper *pInst) {pInst->ReleaseAllPropertyQualifiers(); }
		void	ReleaseQualifier(CWbemClassWrapper *pInst,BSTR strQualifier);
		WCHAR * GetClassName();
		void	SetNavigationFlags(DWORD dwFlags);
		void	SetQueryFlags(DWORD dwFlags);
		HRESULT	DeleteQualifier(CWbemClassWrapper *pInst,
								BSTR strQualifierName,
								BOOL bClassQualifier = TRUE ,
								BSTR strPropertyName = NULL);


		
		HRESULT SetProperty(CWbemClassWrapper *pInst,BSTR bstrColName,VARIANT *pvarData) 
		{
			return pInst->SetProperty(bstrColName,pvarData);
		}
		HRESULT SetQualifier(CWbemClassWrapper *pInst,BSTR bstrColName,BSTR bstrQualifier ,VARIANT *pvarData,LONG lFlavor);
		
		
		DWORD GetFlags() { return m_pWbemClassParms->GetFlags(); }

		HRESULT GetProperty(CWbemClassWrapper *pInst,BSTR pProperty, BYTE *& pData,DBTYPE &dwType ,DBLENGTH & dwSize, DWORD &dwFlags  );

		// This method is to be called before fetching any instance
		HRESULT SetClass(WCHAR *pClassName) {return m_pWbemClassDefinition->SetClass(pClassName); }

		CWbemClassWrapper *GetInstance(BSTR strPath);
		void GetInstanceKey(CWbemClassWrapper *pInst, CBSTR &strPath){ ((CWbemClassInstanceWrapper *)pInst)->GetKey(strPath);}
		CWbemClassWrapper *GetEmbededInstance(BSTR strPath,BSTR strProperty,int nIndex);

		HRESULT GetKeyPropertyNames( SAFEARRAY **ppsaNames) { return m_pWbemClassDefinition->GetKeyPropertyNames(ppsaNames); }
        int ParseQualifiedNameToGetColumnType(WCHAR * wcsName );
		HRESULT CWmiOleDBMap::GetInstanceCount(ULONG_PTR &lInstanceCount)
		{
			return m_paWbemClassInstances->GetNumberOfInstanceInEnumerator(&lInstanceCount);
//			return m_pWbemClassDefinition->GetInstanceCount(lInstanceCount);
		}

		HRESULT AddPropertyQualifier(CWbemClassWrapper *pInst,BSTR pProperty, BSTR Qualifier, VARIANT * vValue, LONG Flavor)
		{
			return pInst->SetPropertyQualifier(pProperty,Qualifier, vValue, Flavor);
		}
		HRESULT SetColumnProperties(const DBCOLUMNDESC * prgColDesc);

		HRESULT AddIndex(const DBID* pColumnID);
		HRESULT DropIndex(const DBID* pColumnID);
		HRESULT UnlinkObjectFromContainer(BSTR strContainerObj,BSTR pstrObject);
		HRESULT LinkObjectFromContainer(BSTR strContainerObj,BSTR pstrObject);
		HRESULT CloneAndAddNewObjectInScope(BSTR strObj, BSTR strScope,WCHAR *& pstrNewPath);

		void SetSytemPropertiesFlag(BOOL bSystemProperties) { m_pWbemClassParms->SetSytemPropertiesFlag(bSystemProperties);}

		DWORD GetInstanceStatus(CWbemClassWrapper *pInst) 
		{ 
			return ((CWbemClassInstanceWrapper *)pInst)->GetStatus(); 
		}
		void  SetInstanceStatus(CWbemClassWrapper *pInst, DWORD dwStatus) 
		{ 
			((CWbemClassInstanceWrapper *)pInst)->SetStatus(dwStatus); 
		}
		INSTANCELISTTYPE GetObjListType();
		
		STDMETHODIMP_(ULONG)	AddRef(void);
		STDMETHODIMP_(ULONG)	Release(void);

		HRESULT	SetSearchPreferences(ULONG cProps , DBPROP rgProp[]);


		HRESULT GetRelativePath(CWbemClassInstanceWrapper *pInst,WCHAR *& strRelPath) 
		{
			return pInst->GetRelativePath(strRelPath);
		}	

		FETCHDIRECTION	 GetCurFetchDirection() { return m_paWbemClassInstances->GetCurFetchDirection(); }
		void	 SetCurFetchDirection(FETCHDIRECTION FetchDir) { m_paWbemClassInstances->SetCurFetchDirection(FetchDir); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\cache\session.cpp ===
// Session.cpp: implementation of the CSession class.
//
//////////////////////////////////////////////////////////////////////

#include "Session.h"
#include "Repository.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

extern CRepository g_DataCache;

CSession::CSession()
{
	m_Ref = 1;
	m_pISessionCache		= NULL;	
	g_DataCache.GetDBSession(IID_IOpenRowset, (void**)&m_pISessionCache);
}

CSession::CSession(CSession& Session)
{
	m_Ref = 1;

	m_pISessionCache = Session.m_pISessionCache;
	if ( NULL != m_pISessionCache ){
		m_pISessionCache->AddRef();
	}
}

CSession::~CSession()
{
	if ( NULL != m_pISessionCache )
		m_pISessionCache->Release();
}

CSession& CSession::operator=(CSession& Session)
{
	//release previous allocated memory
	if ( NULL != m_pISessionCache )
		m_pISessionCache->Release();
	
	//copy Session
	m_pISessionCache = Session.m_pISessionCache;
	if ( NULL != m_pISessionCache ){
		m_pISessionCache->AddRef();
	}

	return *this;
}

STDMETHODIMP_(ULONG)
CSession::AddRef(void)
{
	return InterlockedIncrement(&m_Ref);
}

STDMETHODIMP_(ULONG)
CSession::Release(void)
{
	if ( 0 >= InterlockedDecrement(&m_Ref) )
		delete this;
	return m_Ref;
}

STDMETHODIMP
CSession::QueryInterface(REFIID riid, void __RPC_FAR *__RPC_FAR *ppv)
{
	if ( riid == IID_IUnknown || riid == IID_IOpenRowset )
		*ppv = static_cast<IOpenRowset*>(this);
	/******
	else if ( riid == IID_IRowsetInfo )
		*ppv = static_cast<IRowsetInfo*>(this);
	else if ( riid == IID_IRowsetUpdate )
		*ppv = static_cast<IRowsetUpdate*>(this);
	else if ( riid == IID_IRowsetChange )
		*ppv = static_cast<IRowsetChange*>(this);
	else if ( riid == IID_IRowsetIdentity )
		*ppv = static_cast<IRowsetIdentity*>(this);
	else if ( riid == IID_IRowsetLocate )
		*ppv = static_cast<IRowsetLocate*>(this);
	else if ( riid == IID_IRowsetResynch )
		*ppv = static_cast<IRowsetResynch*>(this);
	else if ( riid == IID_IRowsetScroll )
		*ppv = static_cast<IRowsetScroll*>(this);
	else if ( riid == IID_IAccessor )
		*ppv = static_cast<IAccessor*>(this);
	else if ( riid == IID_IColumnsInfo )
		*ppv = static_cast<IColumnsInfo*>(this);
	else if ( riid == IID_IColumnsRowset )
		*ppv = static_cast<IColumnsRowset*>(this);
	else if ( riid == IID_IConvertType )
		*ppv = static_cast<IConvertType*>(this);
//	else if ( riid == IID_IConnecttionPointContainer )
//		*ppv = static_cast<IConnecttionPointContainer*>(this);
	else if ( riid == IID_ISupportErrorInfo )
		*ppv = static_cast<ISupportErrorInfo*>(this);
	//add all exposed interfaces here
	else {
		*ppv = NULL;
		return E_NOINTERFACE;
	}
*******/
	return S_OK;
}

STDMETHODIMP 
CSession::GetCacheSession(REFIID riid, void __RPC_FAR *__RPC_FAR *pISession)
{
	if ( NULL != m_pISessionCache )
		return E_UNEXPECTED;
	return m_pISessionCache->QueryInterface(riid, pISession);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\cache\session.h ===
// Session.h: interface for the CSession class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SESSION_H__8C59A183_E91F_11D2_A56A_00C04F5F4400__INCLUDED_)
#define AFX_SESSION_H__8C59A183_E91F_11D2_A56A_00C04F5F4400__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "comoledb.h"
#include "oledb.h"

class CSession  :	public IGetDataSource,
					public IOpenRowset,
					public ISessionProperties,
					public IDBCreateCommand,
					public IDBSchemaRowset,
					public IIndexDefinition,
					public ISupportErrorInfo,
					public ITableDefinition,
//					public ITransaction,
					public ITransactionJoin,
					public ITransactionLocal,
					public ITransactionObject

{
public:
	CSession();
	CSession(CSession& session); //copy constructor
	virtual ~CSession();
	
	//data
protected:
	LONG	m_Ref;
	IUnknown* m_pISessionCache;
public:

	//IUnknown
	virtual STDMETHODIMP_(ULONG) AddRef(void);
	virtual STDMETHODIMP_(ULONG) Release(void);
	virtual STDMETHODIMP	QueryInterface(REFIID riid, void __RPC_FAR *__RPC_FAR *ppv);

	//initialization

	//operator
	virtual CSession& operator=(CSession& session);
	STDMETHODIMP GetCacheSession(REFIID riid, void __RPC_FAR *__RPC_FAR *pISession);

};

#endif // !defined(AFX_SESSION_H__8C59A183_E91F_11D2_A56A_00C04F5F4400__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\client\dump.cpp ===
#include "wmiclnt.h"




void DumpErrorMsg
	(
    const char* format,
    ...
	)
{
	va_list argptr;						    

	assert(format != NULL);

	// log this message to stderr and to our log file
	va_start( argptr, format );
	tvfprintf( stderr, format, argptr);
    tvfprintf( g_fpLogFile, format, argptr);
	va_end( argptr );
}    



void DumpStatusMsg
	(
    const char* format,
    ...
	)
{
	va_list argptr;

	assert(format != NULL);

	// log this message to stdout and to our log file
	va_start( argptr, format );
	tvfprintf( stdout, format, argptr );
    tvfprintf( g_fpLogFile, format, argptr );
	va_end( argptr );
}    




HRESULT DumpErrorHResult
	(
	HRESULT      hr_return,
	const char  *format,			// can be NULL
	... 
	)
{
	char     buff[100];
	int      cBytesWritten;
	va_list  argptr;

	//
	// Dump an error message.
	// Print the text of the HRESULT,
	// Return the HRESULT we were passed.

    // these result codes were generated from the oledberr.h 
	static Note ResultCodes[] = {
		// oledberr.h error codes
		NOTE(DB_E_BADACCESSORHANDLE),
		NOTE(DB_E_BADACCESSORHANDLE),
		NOTE(DB_E_ROWLIMITEXCEEDED),
		NOTE(DB_E_READONLYACCESSOR),
		NOTE(DB_E_SCHEMAVIOLATION),
		NOTE(DB_E_BADROWHANDLE),
		NOTE(DB_E_OBJECTOPEN),
		NOTE(DB_E_BADBINDINFO),
		NOTE(DB_SEC_E_PERMISSIONDENIED),
		NOTE(DB_E_NOTAREFERENCECOLUMN),
		NOTE(DB_E_NOCOMMAND),
		NOTE(DB_E_BADBOOKMARK),
		NOTE(DB_E_BADLOCKMODE),
		NOTE(DB_E_PARAMNOTOPTIONAL),
		NOTE(DB_E_BADRATIO),
		NOTE(DB_E_ERRORSINCOMMAND),
		NOTE(DB_E_BADSTARTPOSITION),
		NOTE(DB_E_NOTREENTRANT),
		NOTE(DB_E_NOAGGREGATION),
		NOTE(DB_E_DELETEDROW),
		NOTE(DB_E_CANTFETCHBACKWARDS),
		NOTE(DB_E_ROWSNOTRELEASED),
		NOTE(DB_E_BADSTORAGEFLAG),
		NOTE(DB_E_BADSTATUSVALUE),
		NOTE(DB_E_CANTSCROLLBACKWARDS),
		NOTE(DB_E_INTEGRITYVIOLATION),
		NOTE(DB_E_ABORTLIMITREACHED),
		NOTE(DB_E_DUPLICATEINDEXID),
		NOTE(DB_E_NOINDEX),
		NOTE(DB_E_INDEXINUSE),
		NOTE(DB_E_NOTABLE),
		NOTE(DB_E_CONCURRENCYVIOLATION),
		NOTE(DB_E_BADCOPY),
		NOTE(DB_E_BADPRECISION),
		NOTE(DB_E_BADSCALE),
		NOTE(DB_E_BADID),
		NOTE(DB_E_BADTYPE),
		NOTE(DB_E_DUPLICATECOLUMNID),
		NOTE(DB_E_DUPLICATETABLEID),
		NOTE(DB_E_TABLEINUSE),
		NOTE(DB_E_NOLOCALE),
		NOTE(DB_E_BADRECORDNUM),
		NOTE(DB_E_BOOKMARKSKIPPED),
		NOTE(DB_E_BADPROPERTYVALUE),
		NOTE(DB_E_INVALID),
		NOTE(DB_E_BADACCESSORFLAGS),
		NOTE(DB_E_BADSTORAGEFLAGS),
		NOTE(DB_E_BYREFACCESSORNOTSUPPORTED),
		NOTE(DB_E_NULLACCESSORNOTSUPPORTED),
		NOTE(DB_E_NOTPREPARED),
		NOTE(DB_E_BADACCESSORTYPE),
		NOTE(DB_E_WRITEONLYACCESSOR),
		NOTE(DB_SEC_E_AUTH_FAILED),
		NOTE(DB_E_CANCELED),
		NOTE(DB_E_BADSOURCEHANDLE),
		NOTE(DB_S_ROWLIMITEXCEEDED),
		NOTE(DB_S_COLUMNTYPEMISMATCH),
		NOTE(DB_S_TYPEINFOOVERRIDDEN),
		NOTE(DB_S_BOOKMARKSKIPPED),
		NOTE(DB_S_ENDOFROWSET),
		NOTE(DB_S_BUFFERFULL),
		NOTE(DB_S_CANTRELEASE),
		NOTE(DB_S_DIALECTIGNORED),
		NOTE(DB_S_UNWANTEDPHASE),
		NOTE(DB_S_COLUMNSCHANGED),
		NOTE(DB_S_ERRORSRETURNED),
		NOTE(DB_S_BADROWHANDLE),
		NOTE(DB_S_DELETEDROW),
		NOTE(DB_S_STOPLIMITREACHED),
		NOTE(DB_S_LOCKUPGRADED),
		NOTE(DB_S_PROPERTIESCHANGED),
		NOTE(DB_S_ERRORSOCCURRED),
		NOTE(DB_S_PARAMUNAVAILABLE),
		NOTE(DB_S_MULTIPLECHANGES),

		// winerr.h
		NOTE(E_UNEXPECTED),
		NOTE(E_NOTIMPL),
		NOTE(E_OUTOFMEMORY),
		NOTE(E_INVALIDARG),
		NOTE(E_NOINTERFACE),
		NOTE(E_POINTER),
		NOTE(E_HANDLE),
		NOTE(E_ABORT),
		NOTE(E_FAIL),
		NOTE(E_ACCESSDENIED),
		NOTE(S_OK),
		NOTE(S_FALSE),
		NOTE(E_UNEXPECTED),
		NOTE(E_NOTIMPL),
		NOTE(E_OUTOFMEMORY),
		NOTE(E_INVALIDARG),
		NOTE(E_NOINTERFACE),
		NOTE(E_POINTER),
		NOTE(E_HANDLE),
		NOTE(E_ABORT),
		NOTE(E_FAIL),
		NOTE(E_ACCESSDENIED),
		// BindMoniker Errors
		NOTE(MK_E_NOOBJECT),
		NOTE(MK_E_EXCEEDEDDEADLINE),
		NOTE(MK_E_CONNECTMANUALLY),
		NOTE(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED),
		NOTE(STG_E_ACCESSDENIED),
		NOTE(MK_E_SYNTAX),
		NOTE(MK_E_CANTOPENFILE),
	};


	// Format the message.
	// Print name of hresult code.

	if (format)
		{
		va_start( argptr, format );
		cBytesWritten = _vsnprintf( buff, sizeof(buff), format, argptr );
		va_end( argptr );
		}
	else
		strcpy( buff, "" );

	// log to stderr and also to our log file
	tfprintf( stderr, "%.*s: Returned %.30s\n", 
		sizeof(buff), buff, 
		GetNoteString( ResultCodes, NUMELEM(ResultCodes), GetScode(hr_return)) );
        
   	tfprintf( g_fpLogFile, "%.*s: Returned %.30s\n", 
		sizeof(buff), buff, 
		GetNoteString( ResultCodes, NUMELEM(ResultCodes), GetScode(hr_return)) );

	return ResultFromScode( hr_return );
}




void DumpColumnsInfo
	(
    DBCOLUMNINFO* pColInfo,
    ULONG	      cCol
    )
{
	ULONG j;

	assert(pColInfo != NULL);
	 
	tfprintf( g_fpLogFile, "\nColumn Information:\n\n"); 
	    
	for (j=0; j < cCol; j++)
		{
		WriteColumnInfo( g_fpLogFile, &pColInfo[j] );
		}
}



void WriteColumnInfo
	(
	FILE*			fp,
	DBCOLUMNINFO*	p 
	)
{
	DBID 	    *pCol;
    DBKIND      eKind;
	wchar_t 	wszGuidBuff[MAX_GUID_STRING];
    wchar_t     wszNameBuff[MAX_GUID_STRING];    
    
	static char *szDbcolkind[] = { "Guid+Name", "Guid+PropID", "Name", 
	    "Guid+Name", "Guid+PropID", "PropID", "Guid" };

	assert(p != NULL);

	// For DBTYPEENUM.  Doesn't need to be in order.
	// Below we mask off the high bits.
	static Note typenotes[] = 
	    {
		NOTE(DBTYPE_EMPTY),
		NOTE(DBTYPE_NULL),
		NOTE(DBTYPE_I2),
		NOTE(DBTYPE_I4),
		NOTE(DBTYPE_R4),
		NOTE(DBTYPE_R8),
		NOTE(DBTYPE_CY),
		NOTE(DBTYPE_DATE),
		NOTE(DBTYPE_BSTR),
		NOTE(DBTYPE_IDISPATCH),
		NOTE(DBTYPE_ERROR),
		NOTE(DBTYPE_BOOL),
		NOTE(DBTYPE_VARIANT),
		NOTE(DBTYPE_IUNKNOWN),
		NOTE(DBTYPE_DECIMAL),
		NOTE(DBTYPE_UI1),
		NOTE(DBTYPE_ARRAY),
		NOTE(DBTYPE_BYREF),
		NOTE(DBTYPE_I1),
		NOTE(DBTYPE_UI2),
		NOTE(DBTYPE_UI4),
		NOTE(DBTYPE_I8),
		NOTE(DBTYPE_UI8),
		NOTE(DBTYPE_GUID),
		NOTE(DBTYPE_VECTOR),
		NOTE(DBTYPE_RESERVED),
		NOTE(DBTYPE_BYTES),
		NOTE(DBTYPE_STR),
		NOTE(DBTYPE_WSTR),
		NOTE(DBTYPE_NUMERIC),
		NOTE(DBTYPE_UDT),
		NOTE(DBTYPE_DBDATE),
		NOTE(DBTYPE_DBTIME),
		NOTE(DBTYPE_DBTIMESTAMP),
	    };

	static Note flagnotes[] = 
	    {
		NOTE(DBCOLUMNFLAGS_ISBOOKMARK),
		NOTE(DBCOLUMNFLAGS_MAYDEFER),
		NOTE(DBCOLUMNFLAGS_WRITE),
		NOTE(DBCOLUMNFLAGS_WRITEUNKNOWN),
		NOTE(DBCOLUMNFLAGS_ISFIXEDLENGTH),
		NOTE(DBCOLUMNFLAGS_ISNULLABLE),
		NOTE(DBCOLUMNFLAGS_MAYBENULL),
		NOTE(DBCOLUMNFLAGS_ISLONG),
		NOTE(DBCOLUMNFLAGS_ISROWID),
		NOTE(DBCOLUMNFLAGS_ISROWVER),
		NOTE(DBCOLUMNFLAGS_CACHEDEFERRED),
		};

	pCol = & p->columnid;
    eKind = pCol->eKind;

    // stringize GUID for pretty printing
    switch (eKind)
        {
        case DBKIND_GUID_NAME:
        case DBKIND_GUID_PROPID:
        case DBKIND_GUID:
	        StringFromGUID2( pCol->uGuid.guid, wszGuidBuff, sizeof(wszGuidBuff) );
            break;
        case DBKIND_PGUID_NAME:
        case DBKIND_PGUID_PROPID:          
	        StringFromGUID2( *(pCol->uGuid.pguid), wszGuidBuff, sizeof(wszGuidBuff) );
            break;
        default:
            wcscpy( wszGuidBuff, L"<none>" );
            break;    
        }
        
    // stringize name or propID for pretty printing   
    switch (eKind)
        {
        case DBKIND_GUID_NAME:
        case DBKIND_NAME:
        case DBKIND_PGUID_NAME:
            swprintf( wszNameBuff, L"[name=%.50S]", pCol->uName.pwszName ? pCol->uName.pwszName : L"(unknown)" );
            break;
        case DBKIND_GUID_PROPID:
        case DBKIND_PGUID_PROPID:
        case DBKIND_PROPID:
            swprintf( wszNameBuff, L"[propid=%lu]", pCol->uName.ulPropid );
            break;
        default:
            wcscpy( wszNameBuff, L"" );
            break;    
        }   

    // pretty print column info
    tfprintf( fp, "ColumnId [kind=%.40s] [guid=%.40S] %.60S\n", 
        szDbcolkind[eKind], wszGuidBuff, wszNameBuff );
        

	// Now move on to other stuff...
	// Name in DBCOLUMNINFO different than name in DBCOLUMNID (maybe).
	tfprintf(fp, "  Name          = '%.50S'\n", p->pwszName );
	tfprintf(fp, "  iOrdinal      = %d\n", p->iOrdinal);
	tfprintf(fp, "  wType         = %.100s\n", 
		GetNoteString( typenotes, NUMELEM(typenotes),
		    p->wType & (~DBTYPE_BYREF) & (~DBTYPE_ARRAY) & (~DBTYPE_VECTOR) ) );
	if (p->wType & DBTYPE_BYREF)
		tfprintf(fp, "      (BYREF)\n");
	if (p->wType & DBTYPE_ARRAY)
		tfprintf(fp, "      (ARRAY)\n");
	if (p->wType & DBTYPE_VECTOR)
		tfprintf(fp, "      (VECTOR)\n");
	tfprintf(fp, "  ulColumnSize  = %ld\n", p->ulColumnSize );
	tfprintf(fp, "  bPrecision    = %d\n",  p->bPrecision );
	tfprintf(fp, "  bScale        = %d\n",  p->bScale );
	tfprintf(fp, "  dwFlags       = %s\n\n",
		GetNoteStringBitvals( flagnotes, NUMELEM(flagnotes), p->dwFlags ) );
	

}


char* GetNoteString
    ( 
	Note * rgNote, 
	int    cNote,
	DWORD  dwValue 
	)
{
	int j;

	assert(rgNote != NULL);

	// Scan a table of value/string,
	// return ptr to string found.

	for (j=0; j < cNote; j++) {
		if (rgNote[j].dwFlag == dwValue)
			return rgNote[j].szText;
	}
	return "<unknown>";
}







char*	GetNoteStringBitvals
	(
	Note* 	rgNote,
	int     cNote,
	DWORD   dwValue 
	)
{
	static char buff[400];
	int j;

	assert(rgNote != NULL);

	// Make a string that combines all the bits ORed together.

	strcpy(buff, "");
	for (j=0; j < cNote; j++) {
		if (rgNote[j].dwFlag & dwValue) {
			if (buff[0])
				strcat( buff, " | " );
			strcat( buff, rgNote[j].szText );
		}
	}
	assert(strlen(buff) < sizeof(buff));
	return buff;
}




ULONG CalcPrettyPrintMaxColWidth
    (
    DBBINDING*	rgBind,
    ULONG       cBind
    )
{
	ULONG	cMaxWidth;
    ULONG   cTotalWidth;
    ULONG	iBind;

	assert(rgBind != NULL);
	
	cMaxWidth = DEFAULT_CBMAXLENGTH;
	while (1)
		{
		cTotalWidth = 0;
		
		for (iBind=0; iBind < cBind; iBind++)
			cTotalWidth += min( cMaxWidth, rgBind[iBind].cbMaxLen ) + 1;
		
		if (cTotalWidth < PRETTYPRINT_MAXTOTALWIDTH || cMaxWidth < PRETTYPRINT_MINCOLWIDTH)
			break;
		
		cMaxWidth--;
		}

	return cMaxWidth;
}



void DumpColumnHeadings
	(
	DBBINDING*		rgBind, 
	ULONG			cBind, 
	DBCOLUMNINFO* 	pColInfo, 
	ULONG			cCol,
    ULONG			cMaxColWidth
	)
{
	ULONG iBind;

	assert(rgBind != NULL);
    assert(pColInfo != NULL);
 
	for (iBind=0; iBind < cBind; iBind++)
		tfprintf( g_fpLogFile, "%-*.*S ",
			min( cMaxColWidth, rgBind[iBind].cbMaxLen ),
			min( cMaxColWidth, rgBind[iBind].cbMaxLen ),
			LookupColumnName( pColInfo, cCol, rgBind[iBind].iOrdinal ) );
	tfprintf( g_fpLogFile, "\n" );
	for (iBind=0; iBind < cBind; iBind++)
		tfprintf( g_fpLogFile, "%-*.*s ",
			min( cMaxColWidth, rgBind[iBind].cbMaxLen ),
			min( cMaxColWidth, rgBind[iBind].cbMaxLen ),
			"------------------------------" );
	tfprintf( g_fpLogFile, "\n" );
}



WCHAR* LookupColumnName
	(
	DBCOLUMNINFO*	rgColInfo,
	ULONG 			cCol,
	ULONG 			iCol 
	)
{
	ULONG j;

	assert(rgColInfo != NULL);

	// A really slow way to get the column name, given the ordinal.
	// The problem is that result-set ordinals do not necessarily match
	// the index into the ColumnInfo array.
	// (May have bookmark, which is always column 0.)

	for (j=0; j < cCol; j++)
		if (rgColInfo[j].iOrdinal == iCol)
			return rgColInfo[j].pwszName;
            
	return L"Error";
}




void DumpRow
	(
    DBBINDING* 	rgBind,
    ULONG		cBind,
    ULONG		cMaxColWidth,
    BYTE* 		pData
    )
{
	ULONG 		iBind;
    TMPCOLUMNDATA*	pColumn;
    
	assert(rgBind);
	assert( offsetof(TMPCOLUMNDATA, dwLength) == 0);	
    
	// Print each column we're bound to.
	for (iBind=0; iBind < cBind; iBind++)
		{
		// Columns are bound differently; not so easy.
		// Print out to at least DEFAULT_CBMAXLENGTH width (pretty),
		// Limit to first dwLength characters.

		pColumn = (TMPCOLUMNDATA *) (pData + rgBind[iBind].obLength);
		PrintColumn( pColumn, rgBind, iBind, cMaxColWidth );
		}
	tfprintf( g_fpLogFile, "\n" );
}    





void PrintColumn
	(
	TMPCOLUMNDATA    *pColumn,
	DBBINDING     *rgBind,
	ULONG          iBind,
	ULONG          cMaxColWidth 
	)
{
	void*	p;
	ULONG   ulPrintWidth;
	ULONG   ulPrintPrecision;
	DWORD   dwStatus;
	DWORD   dwLength;
	BOOL    fDidVariant;
	BOOL    fIsUnicode;
	char*	sFormat;
	HRESULT hr;
	
    assert(pColumn != NULL);
    assert(rgBind != NULL);
    
	// Pretty print a column.
	// May have different type of binding.

	fDidVariant = FALSE;
	fIsUnicode  = FALSE;
	dwStatus = pColumn->dwStatus;
	dwLength = pColumn->dwLength;

	if (dwStatus == DBSTATUS_S_ISNULL)
		{
		p = "<null>";
		dwLength = strlen( (char *) p);
		}
    else if (dwStatus == DBBINDSTATUS_UNSUPPORTEDCONVERSION)
        {
        p = "<unsupportedconversion>";
		dwLength = strlen( (char *) p);
        }    
	else
		{
		switch (rgBind[iBind].wType) 
			{
		case DBTYPE_STR:
			// We have a string in our buffer, so use it.
			p = (void *) &pColumn->bData;
			break;
		case DBTYPE_VARIANT:
			// We have a variant in our buffer, so convert to string.
			p = (void *) &pColumn->bData;
			hr = VariantChangeTypeEx(
					(VARIANT *) p,			// Destination (convert in place)
					(VARIANT *) p,			// Source
					LOCALE_SYSTEM_DEFAULT,	// LCID
					0,						// dwFlags
					VT_BSTR );
			if (FAILED(hr))
            	{
				DumpErrorHResult( hr, "VariantChangeTypeEx, field %d", iBind );
                return;
                }
			p = (wchar_t *) (((VARIANT *)p)->bstrVal) ;
			dwLength = ((DWORD *)p)[-1] / sizeof(wchar_t);
			fDidVariant = TRUE;
			fIsUnicode  = TRUE;
			break;
		default:
			p = "??? unknown type ???";
			break;
			}
		}

	// Print the column.
	// If it has been truncated or rounded, print a '#' in
	// the far right-hand column.
	ulPrintWidth     = min( cMaxColWidth, rgBind[iBind].cbMaxLen );
	ulPrintPrecision = min( cMaxColWidth, dwLength );
	if (dwStatus == DBSTATUS_S_TRUNCATED ||  cMaxColWidth < dwLength)
	{
		ulPrintWidth--;
		ulPrintPrecision--;
	}

	sFormat = fIsUnicode ? "%-*.*S" : "%-*.*s";

	tfprintf( g_fpLogFile, sFormat, ulPrintWidth, ulPrintPrecision, p );

	if (dwStatus == DBSTATUS_S_TRUNCATED ||  cMaxColWidth < dwLength)
		tfprintf( g_fpLogFile, "#" );
	tfprintf( g_fpLogFile, " " );

	// Free memory used by the variant.
	if (fDidVariant)
		VariantClear( (VARIANT *) &pColumn->bData );
        
	return;
}




void tfprintf
	(
	FILE*		fp,
	const char* format,
	... 
	)
{
	int 	cBytesWritten;
	char 	buff[400];
	va_list argptr;

	assert(format != NULL);
	
	// Dump a formatted string.
    // _vsnprintf prevents overflowing our buffer.
	va_start( argptr, format );
	cBytesWritten = _vsnprintf( buff, sizeof(buff), format, argptr );
	va_end( argptr );
	buff[sizeof(buff)-1] = '\0';

	// Can't use fprintf, because string could contain '%'.
	if (fp)
		fputs( buff, fp );
}



void tvfprintf
	(
	FILE*		fp,
	const char* format,
	va_list		argptr 
	)
{
	int 	cBytesWritten;
	char 	buff[400];


	assert(format != NULL);

	// Dump a formatted string.
    // _vsnprintf prevents overflowing our buffer.
	cBytesWritten = _vsnprintf( buff, sizeof(buff), format, argptr );
	buff[sizeof(buff)-1] = '\0';

	// Can't use fprintf, because string could contain '%'.
	if (fp)
		fputs( buff, fp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\client\wmiclnt.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Microsoft WMI OLE DB Client test app
// (C) Copyright 1999 Microsoft Corporation. All Rights Reserved.
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////
#define INITGUID
#define DBINITCONSTANTS
#include "wmiclnt.h"
#include <headers.h>

IMalloc* g_pIMalloc = NULL;
FILE*    g_fpLogFile = NULL;    // our log file
WCHAR *  g_pwcsTable = NULL;
WCHAR *  g_pwcsNamespace = NULL;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void AllocateAndConvertAnsiToUnicode(char * pstr, WCHAR *& pszW)
{
    pszW = NULL;

    int nSize = strlen(pstr);
    if (nSize != 0 ){

        // Determine number of wide characters to be allocated for the
        // Unicode string.
        nSize++;
		try{
			pszW = new WCHAR[nSize * 2];
			if (NULL != pszW){
            // Covert to Unicode.
				MultiByteToWideChar(CP_ACP, 0, pstr, nSize,pszW,nSize);
	        }	
		}
		catch(...){
			throw;
		}
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
BOOL GetDataFromCommandLine(int argc,int & i, WCHAR *& p, char * argv[])
{
    i++;
    if( i > argc ){
        return FALSE;
    }

    AllocateAndConvertAnsiToUnicode(argv[i],p);


    return TRUE;
}
///////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ParseCommandLine(int argc, char * argv[])
{
    
    BOOL	fFlag = FALSE;

	if ( argc > 1 ){
        g_pwcsTable = NULL;
        g_pwcsNamespace = NULL;

        //======================================================================
        //  Now, go thru and get the ones we support
        //======================================================================
        for( int i = 0; i < argc; i++){

            //==================================================================
            //  NAMESPACE
            //==================================================================
            if(_stricmp(argv[i],"-Namespace")== 0){
                GetDataFromCommandLine(argc,i,g_pwcsNamespace,argv);
            }
            //==================================================================
            //  TABLE
            //==================================================================
            if(_stricmp(argv[i],"-Table")== 0){
                GetDataFromCommandLine(argc,i,g_pwcsTable,argv);
            }
        }
        if( g_pwcsTable && g_pwcsNamespace ) {
            fFlag = TRUE;
        }
    }

    if( !fFlag ){
		printf( "-Namespace name\n" );
		printf( "-Table tablename\n" );
	} 


    return fFlag;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
void InitializeLogFile()
{
	time_t	ttime;
 
  	g_fpLogFile = fopen( "wmiclnt.out", "at");
    if (!g_fpLogFile){
    	DumpErrorMsg( "Warning: cannot open log file wmiclnt.out\n" );
    }
  
  	time(&ttime);
    
    DumpStatusMsg( "\n-------------------------\n\n");
    DumpStatusMsg( "running wmiclnt.exe\n%s\n\n", ctime(&ttime) );
}




//**********************************************************************
//  
// GetWMIOLEDBDataSource
// 
// Purpose:
//
//     Calls OLE to find and load the WMIOLEDB data provider. 
//     Returns an IDBInitialize interface pointer on WMIOLEDB's 
//     Data Source object.
//
// Parameters:
// 	
//   IDBInitialize** ppIDBInitialize_out  - out pointer through which to return
// 									        IDBInitialize pointer on data 
//								            provider's Data Source object 	
// 
// Return Value:
// 
// 	S_OK		- Success
//  E_*	    	- Failure
//     
//
// Comments:      
// 
//     The call to CoCreateInstance is hard-coded with WMIOLEDB's CLSID.
//     The pointer returned through ppIDBInitialize_out has been AddRef'ed,
//     it must be Release'd later by the caller.
//  
//**********************************************************************

HRESULT GetWMIOLEDBDataSource(IDBInitialize**	ppIDBInitialize_out	)
{
	IDBInitialize*	pIDBInit = NULL;
	IDBProperties*	pIDBProperties = NULL;
	DBPROPSET		dbPropSet[1];
	DBPROP			dbProp[1];

	HRESULT	hr;


	DumpStatusMsg( "Connecting to the WMIOLEDB data provider...\n" );

	assert(ppIDBInitialize_out != NULL);

	VariantInit(&(dbProp[0].vValue));

    //===========================================================================
	// Create an instance of the WMIOLEDB  data provider
    //===========================================================================
	hr = CoCreateInstance( CLSID_WMIOLEDB, NULL, CLSCTX_INPROC_SERVER, 	IID_IDBInitialize, (void **)&pIDBInit ); 
	if (FAILED(hr)){
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr, "CoCreateInstance" );
        goto error;
    }

    //===========================================================================
	// Initialize this provider with the namespace
    //===========================================================================
	dbPropSet[0].rgProperties		= &dbProp[0];
	dbPropSet[0].cProperties		= 1;
	dbPropSet[0].guidPropertySet	= DBPROPSET_DBINIT;
	
	dbProp[0].dwPropertyID			= DBPROP_INIT_DATASOURCE;
	dbProp[0].dwOptions				= DBPROPOPTIONS_REQUIRED;
	dbProp[0].colid					= DB_NULLID;
	V_VT(&(dbProp[0].vValue))		= VT_BSTR;
	V_BSTR(&(dbProp[0].vValue))		= SysAllocString( g_pwcsNamespace );
    if ( NULL == V_BSTR(&(dbProp[0].vValue)) ){
        DUMP_ERROR_LINENUMBER();
        DumpErrorMsg( "SysAllocString failed\n" );
        goto error;
    }

    hr = pIDBInit->QueryInterface( IID_IDBProperties, (void**)&pIDBProperties);
    if (FAILED(hr)){
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr, "IDBInitialize::QI for IDBProperties");
        goto error;
        }

	hr = pIDBProperties->SetProperties( 1, &dbPropSet[0]);
	if (FAILED(hr)){
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr, "IDBProperties::SetProperties" );
        goto error;
    }
		
	hr = pIDBInit->Initialize();
	if (FAILED(hr)){
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr, "IDBInitialize::Initialize" );
        goto error;
    }

	*ppIDBInitialize_out = pIDBInit;

	hr = ResultFromScode( S_OK );

error:    
    VariantClear( &(dbProp[0].vValue) );

	if( pIDBProperties )
		pIDBProperties->Release();

	if( FAILED(hr) )
	{
        if (pIDBInit){
    		pIDBInit->Release();
        }
		*ppIDBInitialize_out = NULL;
	}

	return hr;    
}




//  **********************************************************************
//
// GetDBSessionFromDataSource
//
// Purpose:
//      Calls the provider's Data Source object to get an IOpenRowset interface
//      pointer on a DBSession object.  
//      
// Parameters:
//      pIDBInitialize      - pointer to Data Source object
//      ppIOpenRowset_out   - out pointer through which to return 
//                            IOpenRowset pointer on DBSession object
//
// Return Value: 
//
// 	S_OK		- Success
//  E_*	    	- Failure
//
//
// Comments:
//
//      The interface pointer returned through ppIOpenRowset_out has been 
//      AddRef'ed, the caller must Release it later.
//
//**********************************************************************

HRESULT GetDBSessionFromDataSource
    (
    IDBInitialize*      pIDBInitialize,      // [in]
    IOpenRowset**       ppIOpenRowset_out    // [out]
    )
{
    IDBCreateSession*   pIDBCreateSession;
    IOpenRowset*        pIOpenRowset;
    HRESULT             hr;


    DumpStatusMsg( "Getting a DBSession object from the data source object...\n" );
    
    assert(pIDBInitialize != NULL);
    assert(ppIOpenRowset_out  != NULL );

    hr = pIDBInitialize->QueryInterface( IID_IDBCreateSession, (void**)&pIDBCreateSession);
    if (FAILED(hr))
    	{
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr, "IDBInitialize::QI for IDBCreateSession");
        goto error;
        }
        
    hr = pIDBCreateSession->CreateSession( NULL, IID_IOpenRowset, (IUnknown**)&pIOpenRowset );    
    if (FAILED(hr))
    	{
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr, "IDBCreateSession::CreateSession");
        goto error;
        }
     pIDBCreateSession->Release();
     pIDBCreateSession = NULL;
     
     // all went well
     *ppIOpenRowset_out = pIOpenRowset;
     return ResultFromScode( S_OK );
     
error:
    if (pIDBCreateSession)
        pIDBCreateSession->Release();
        
    *ppIOpenRowset_out = NULL;    
    return ResultFromScode( hr );
}



//**********************************************************************
//
// GetRowsetFromDBSession
//
// Purpose:
//      Calls the provider's DBSession object to get an IRowset interface
//      pointer on a Rowset object.  
//      
// Parameters:
//      pIOpenRowset        - interface pointer on DBSession object
//      pwszTableName       - name of "table" (in this case text file)
//      ppIRowset_out       - out pointer through which to return 
//                            IRowset pointer on Rowset object
//
// Return Value: 
//
// 	S_OK		- Success
//  E_*	    	- Failure
//
// Comments:
//
//      The interface pointer returned through ppIRowset_out has been 
//      AddRef'ed, the caller must Release it later.
//
///**********************************************************************

HRESULT GetRowsetFromDBSession
    (
    IOpenRowset*   pIOpenRowset,    // [in]
    LPWSTR         pwszTableName,   // [in] 
    IRowset**      ppIRowset_out    // [out]
    )
{
    DBID            dbcolid;
    IRowset*        pIRowset = NULL;
    HRESULT         hr;

    DumpStatusMsg( "Getting a rowset object from the DBSession object...\n" );
    
    assert(pIOpenRowset != NULL);
    assert(ppIRowset_out  != NULL );
    
    // tell the provider which table to open
    dbcolid.eKind           = DBKIND_NAME;
    dbcolid.uName.pwszName  = pwszTableName;
    
    hr = pIOpenRowset->OpenRowset
                        (
                        NULL,                   // pUnkOuter - we are not aggregating
                        &dbcolid,               // pTableID -  the table we want
						NULL,					// pIndexID - the index we want
                        IID_IRowset,            // riid - interface we want on the rowset object
                        0,                      // cProperties - we are niave about props for now
                        NULL,                   // prgProperties[]
                        (IUnknown**)&pIRowset   // ppRowset
                        );
    if (FAILED(hr))
    	{
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr, "IOpenRowset::OpenRowset" );
        goto error;
        }
    
    // all went well
    *ppIRowset_out = pIRowset;
    return ResultFromScode( S_OK );

error:
    if (pIRowset)
        pIRowset->Release();
    *ppIRowset_out = NULL;            
    
    return ResultFromScode( hr );
}    





//**********************************************************************
// 
// GetColumnsInfo
//
// Purpose:
// 
//     Obtains information (metadata) about the columns in the rowset - the types
//     of the data and so on.
//
// 
// Parameters:
// 	IRowset*		pIRowset            - interface pointer on data provider's
//                                        Rowset object  
// 	ULONG*			pcCol_out           - out pointer through which to return
//                                        number of columns in the rowset
// 	DBCOLUMNINFO**	ppColumnInfo_out    - out pointer through which to return
//                                        pointer to structure containing
//                                        metadata for the columns in the rowset
// 	WCHAR**			ppStringsBuffer_out - out pointer through which to return
//                                        pointer to table of strings. see comments. 
// 
// Return Value:
//     S_OK        - Success
//     E_*         - Failure
//     
//     
// Comments:      
// 
//     ppColumnInfo_out and ppStringsBuffer_out are used to return pointers
//     to two buffers. These buffers are allocated by the data provider
//     (when GetColumnsInfo calls IColumnsInfo::GetColumnInfo). The data
//     provider uses IMalloc to allocate the buffers; therefore, the caller
//     of this routine must at a later point use IMalloc::Free to free
//     both of these buffers. The StringsBuffer contains strings pointed
//     to by pointers in the ColumnInfo buffer, therefore the StringsBuffer
//     should be freed *after* the ColumnInfo pointer.    
//
//     GetColumnsInfo calls DumpColumnsInfo to dump the column metadata to
//     the log file.
// 
//**********************************************************************

HRESULT GetColumnsInfo
	(
	IRowset*		pIRowset,
	ULONG*			pcCol_out,
	DBCOLUMNINFO**	ppColumnInfo_out,
	WCHAR**			ppStringsBuffer_out
	)
{
	IColumnsInfo* 	pIColumnsInfo = NULL;
    ULONG			cCol;
    DBCOLUMNINFO*	pColumnInfo;
    WCHAR*			pStringsBuffer;
	HRESULT 		hr;
    

	assert(pIRowset != NULL);
    assert(pcCol_out != NULL);
    assert(ppColumnInfo_out != NULL);
    assert(ppStringsBuffer_out != NULL);

	// get column information from the command object via IColumnsInfo 
	hr = pIRowset->QueryInterface( IID_IColumnsInfo, (void **) &pIColumnsInfo );
    if (FAILED(hr))
    	{
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr, "IRowset::QI for IID_IColumnsInfo" );
        goto error;
        }
	hr = pIColumnsInfo->GetColumnInfo( 
			&cCol, 
			&pColumnInfo,
			&pStringsBuffer );
    if (FAILED(hr))
    	{
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr, "pIColumnsInfo->GetColumnInfo" );
        goto error;
        }
	pIColumnsInfo->Release();
	pIColumnsInfo = NULL;

	DumpColumnsInfo( pColumnInfo, cCol );
    
    // fill out-params
    *pcCol_out = cCol;
    *ppColumnInfo_out = pColumnInfo;
    *ppStringsBuffer_out = pStringsBuffer;
    
	return ResultFromScode( S_OK );

error:
	if (pIColumnsInfo)
    	pIColumnsInfo->Release();
        
	*pcCol_out = 0;
    *ppColumnInfo_out = NULL;
    *ppStringsBuffer_out = NULL;
	
	return ResultFromScode( hr );
}


//**********************************************************************
// 
// SetupBindings
// 
// Purpose:
// 
//     Creates bindings that map the data in the rowset's columns to 
//     slots in the consumer's data buffer.
//     
// Parameters:
//
// 	ULONG 			cCol                - number of columns in rowset to bind
// 	DBCOLUMNINFO*	pColumnInfo         - pointer to column metadata
// 	DBBINDING*		rgBind_out          - out pointer through which to return
//                                        an array of binding structures, one
//                                        structure per column bound
// 	ULONG*			pcBind_out          - out pointer through which to return   
//                                        the number of columns bound (number
//                                        of valid elements in rgBind_out)              
// 	ULONG*			pcMaxRowSize_out    - out pointer through which to return
//                                        the buffer size necessary to hold
//                                        the largest row data
// 
// Return Value:
//     S_OK         - Success
//     E_*          - Failure
// 
//     
// Comments:      
// 
// 
//**********************************************************************

HRESULT SetupBindings
	(
	ULONG 			cCol,
	DBCOLUMNINFO*	pColumnInfo,
	DBBINDING*		rgBind_out,
	ULONG*			pcBind_out,
	ULONG*			pcMaxRowSize_out
	)
{
	ULONG dwOffset;
	ULONG iCol;
	ULONG iBind;
	
    
    assert(pColumnInfo != NULL);
    assert(rgBind_out != NULL);
    assert(pcBind_out != NULL);
    assert(pcMaxRowSize_out != NULL);
    
	// Create bindings.
	// Bind everything as a string just to keep things simple.
	dwOffset = 0;
	iBind=0;
	for (iCol=0; iCol < cCol; iCol++)
	{
		// Skip columns of type _VECTOR. Probably binary data.
		if (pColumnInfo[iCol].wType & DBTYPE_VECTOR)
			continue;

		rgBind_out[iBind].dwPart	= DBPART_VALUE | DBPART_LENGTH |
									  DBPART_STATUS;
        rgBind_out[iBind].eParamIO  = DBPARAMIO_NOTPARAM;                              
		rgBind_out[iBind].iOrdinal  = pColumnInfo[iCol].iOrdinal;
		rgBind_out[iBind].wType		= DBTYPE_STR;
		rgBind_out[iBind].pTypeInfo = NULL;
		rgBind_out[iBind].obValue   = dwOffset + offsetof(TMPCOLUMNDATA,bData);
 		rgBind_out[iBind].obLength  = dwOffset + offsetof(TMPCOLUMNDATA,dwLength);
        rgBind_out[iBind].obStatus  = dwOffset + offsetof(TMPCOLUMNDATA,dwStatus);
		rgBind_out[iBind].cbMaxLen  = pColumnInfo[iCol].wType == DBTYPE_STR ? 
										pColumnInfo[iCol].ulColumnSize + sizeof(char) : DEFAULT_CBMAXLENGTH;
		rgBind_out[iBind].pObject	= NULL;
		dwOffset += rgBind_out[iBind].cbMaxLen + offsetof( TMPCOLUMNDATA, bData );
		dwOffset = ROUND_UP( dwOffset, COLUMN_ALIGNVAL );
		iBind++;
	}  
    
	*pcBind_out 	  = iBind;
	*pcMaxRowSize_out = dwOffset;

	return ResultFromScode( S_OK );
}



//**********************************************************************
// 
// CreateAccessor
// 
// Purpose:
//
//     Passes a set of bindings to the data provider and recieves in return
//     an accessor handle that represents those bindings. 
//      
// Parameters:
// 	IRowset*	pIRowset        - interface pointer on data provider's Rowset
//                                object
// 	DBBINDING*	rgBind          - array of binding structures
// 	ULONG		cBind           - number of binding structures in rgBind
// 	HACCESSOR*	phAccessor_out  - out pointer through which to return an 
//                                accessor handle that represents all the bindings
//                                in rgBind
// 
// Return Value:
//     S_OK        - Success
//     E_*         - Failure
// 
//     
// Comments:      
// 
// 
//**********************************************************************

HRESULT CreateAccessor
	(
	IRowset*	pIRowset,
	DBBINDING*	rgBind,
	ULONG		cBind,
	HACCESSOR*	phAccessor_out 
	)
{
	IAccessor*	pIAccessor = NULL;
	HACCESSOR   hAccessor;
	HRESULT 	hr;


	assert(pIRowset != NULL);
    assert(rgBind != NULL);
    assert(phAccessor_out != NULL);

  	// Get an accessor for our bindings from the rowset, via IAccessor 
	hr = pIRowset->QueryInterface( IID_IAccessor, (void**)&pIAccessor );
	if (FAILED(hr))   	
    	{
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr, "pIRowset->QI for IID_IAccessor" );	
        goto error;
        }
	hr = pIAccessor->CreateAccessor( DBACCESSOR_ROWDATA, cBind, rgBind, 0, 
	                                 &hAccessor, NULL );
	if (FAILED(hr))   	
    	{
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr, "pIAccessor->CreateAccessor" );	
        goto error;
        }
	pIAccessor->Release();
	pIAccessor = NULL;

	*phAccessor_out = hAccessor;

	return ResultFromScode( S_OK );	

error:
	if (pIAccessor)
    	pIAccessor->Release();
	*phAccessor_out = NULL;
	
	return ResultFromScode( hr );
}


//**********************************************************************
// 
// GetData
// 
// Purpose:
// 
//     Reads the data from a rowset.
// 
// Parameters:
//
// 	   IRowset*	 pIRowset           - interface pointer on data provider's
//                                    Rowset object
// 	   ULONG   	 cMaxRowSize        - size of buffer needed to hold the data
//                                    for the largest row
//     HACCESSOR hAccessor          - accessor handle representing the set
//                                    of desired bindings
//     DBBINDING*		rgBind	  	- needed only for pretty printing	
//     ULONG			cBind	  	- for pretty printing  
//     DBCOLUMNINFO*	pColumnInfo - for pretty printing  
//     ULONG			cCol		- for pretty printing  
// 
// 
// Return Value:
//     S_OK        - Success
//     E_*         - Failure
// 
// 
//     
// Comments:      
//
//     GetData reads all the rows in the rowset, sequentially.
//     
//     GetData calls CalcPrettyPrintMaxColWidth, DumpColumnHeadings, and
//     DumpRow to dump the row data to a log file.
//  
// 
//**********************************************************************

HRESULT GetData( IRowset*	pIRowset,ULONG   	cMaxRowSize,   HACCESSOR   hAccessor,   DBBINDING*		rgBind,	  	  
                 ULONG			cBind,	  	    DBCOLUMNINFO*	pColumnInfo,    ULONG			cCol		  
	)
{
	ULONG 	cRowsObtained;
	ULONG	iRow;
	BYTE*	pRowData = NULL;
	HROW 	rghRows[NUMROWS_CHUNK];
	HROW*	pRows = &rghRows[0];
	ULONG	cMaxColWidth;	  	// needed for pretty printing
	HRESULT hr;
    

	assert(pIRowset != NULL);
    assert(rgBind != NULL);
    assert(pColumnInfo != NULL);

	// create a buffer for row data, big enough to hold the biggest row
	pRowData = (BYTE *) malloc( cMaxRowSize );
	if (!pRowData)
		{
        DUMP_ERROR_LINENUMBER();
        DumpErrorMsg("GetData: malloc failed\n");
        goto error;
		}	

	// pretty print
    cMaxColWidth = CalcPrettyPrintMaxColWidth( rgBind, cBind );
    
    // pretty print
	DumpColumnHeadings( rgBind, cBind, pColumnInfo, cCol, cMaxColWidth );
		
    // process all the rows, NUMROWS_CHUNK rows at a time
	while (1)
		{
		hr = pIRowset->GetNextRows(
			NULL,						// hChapter
			0,							// cRowsToSkip
			NUMROWS_CHUNK,				// cRowsDesired
			&cRowsObtained,             // pcRowsObtained
			&pRows );					// filled in w/ row handles
		if (FAILED(hr))
			{
            DUMP_ERROR_LINENUMBER();
            DumpErrorHResult( hr, "pIRowset->GetNextRows" );
            goto error;
			}		

		if ( cRowsObtained == 0 )			// all done, no more rows left to get
			break;

		// loop over rows obtained, getting data for each
		for ( iRow=0; iRow < cRowsObtained; iRow++ )
			{
			hr = pIRowset->GetData(
				rghRows[iRow],
				hAccessor,
				pRowData );
             if (FAILED(hr))
             	{
                DUMP_ERROR_LINENUMBER();
                DumpErrorHResult( hr, "pIRowset->GetData" );
                goto error;
             	}   
			
			// pretty print
            DumpRow( rgBind, cBind, cMaxColWidth, pRowData );
			}
		// release row handles
		hr = pIRowset->ReleaseRows( cRowsObtained, rghRows, NULL, NULL, NULL );
        if (FAILED(hr))
             	{
                DUMP_ERROR_LINENUMBER();
                DumpErrorHResult( hr, "pIRowset->ReleaseRows" );
                goto error;
             	} 
		}	// end while

	// free row data buffer
	free( pRowData );
	return ResultFromScode( S_OK );
    
error:
	if (pRowData)
		free( pRowData );
		    
    return ResultFromScode( hr );
}



//**********************************************************************
// 
// CleanupRowset
// 
// Purpose:
//
//     Allows the rowset to perform any necessary cleanup.
//  
// Parameters:
//
// 	IRowset*	pIRowset    - interface pointer on data provider's Rowset
//                            object
// 	HACCESSOR 	hAccessor   - accessor handle to release
// 
// Return Value:
//
//     S_OK        - Success
//     E_*         - Failure
//     
//     
// Comments:      
//
//     In this , the only cleanup that the rowset needs to do is
//     release the accessor handle. 
// 
//**********************************************************************

HRESULT CleanupRowset
	(
	IRowset*	pIRowset,
	HACCESSOR 	hAccessor
	)
{
	IAccessor*	pIAccessor = NULL;
	HRESULT		hr;
    
    assert(pIRowset != NULL);
    
	// tell the rowset object it can release the accessor, via IAccessor
	hr = pIRowset->QueryInterface( IID_IAccessor, (void**)&pIAccessor );
	if (FAILED(hr))
		{
        DUMP_ERROR_LINENUMBER();
		DumpErrorHResult( hr, "pIRowset->QI for IID_IAccessor" );
		goto error;
		} 
	hr = pIAccessor->ReleaseAccessor( hAccessor, NULL );
	if (FAILED(hr))
		{
        DUMP_ERROR_LINENUMBER();
		DumpErrorHResult( hr, "pIAccessor->ReleaseAccessor" );
		goto error;
		}    
	pIAccessor->Release();
	pIAccessor = NULL;

	return ResultFromScode( S_OK );
    
error:    
	if (pIAccessor)
    	pIAccessor->Release();

    return ResultFromScode( hr );    
}


//**********************************************************************
// 
// GetDataFromRowset
// 
// Purpose:
// 
//     Pulls the data from a Rowset object.
//     
// Parameters:
// 
// 	IRowset*	pIRowset    -  interface pointer on data provider's
//                             Rowset object
// 
// Return Value:
// 
//     S_OK        - Success
//     E_*         - Failure
// 
// Comments:      
// 
//     At a high level, a consumer pulls the data from a Rowset object by:
//     
//     1. getting metadata for the Rowset's columns
//     2. using that metadata, along with the consumer's own knowledge of
//        how it wants to recieve the data, to create bindings. Bindings
//        represent how the actual data in the Rowset's columns is
//        actually transferred to the consumer's buffer.
//     3. pass the bindings to the Rowset, and get in return an accessor
//        handle that represents that particulr set of bindings   
//     4. get the actual data
//     5. clean up the rowset (at a minumum, release the accessor) 
//     
//     GetDataFromRowset performs these steps by calling GetColumnsInfo,
//     SetupBindings, CreateAccessor, GetData, and CleanupRowset
//       
//**********************************************************************

HRESULT GetDataFromRowset
	(
	IRowset*	pIRowset
	)
{
	ULONG 			cCol;
	ULONG 			cbMaxRowSize;		// buffer size for 1 row's data
	ULONG 			cBind;
	DBBINDING		rgBind[MAX_BINDINGS];
	HACCESSOR		hAccessor		= NULL;
	DBCOLUMNINFO*	pColumnInfo 	= NULL;
	WCHAR*			pStringsBuffer  = NULL;
	HRESULT 		hr;
    


	DumpStatusMsg( "Reading all the data in the rowset...\n" );

	assert(pIRowset != NULL);
	assert(g_pIMalloc != NULL);
	
	hr = GetColumnsInfo( pIRowset, &cCol, &pColumnInfo, &pStringsBuffer );
	if (FAILED(hr))
    	{
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr,  "GetColumnsInfo");
        goto error;
        }
	
	hr = SetupBindings( cCol, pColumnInfo, rgBind, &cBind, &cbMaxRowSize );
	if (FAILED(hr))
    	{
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr,  "SetupBindings");
        goto error;
        }
	
	hr = CreateAccessor( pIRowset, rgBind, cBind, &hAccessor );
	if (FAILED(hr))
    	{
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr,  "CreateAccessor" );
        goto error;
        }

	hr = GetData( pIRowset, cbMaxRowSize, hAccessor, rgBind, cBind, pColumnInfo, cCol );
	if (FAILED(hr))
    	{
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr,  "GetData" );
        goto error;
        }

	g_pIMalloc->Free( pColumnInfo );
    pColumnInfo = NULL;
	g_pIMalloc->Free( pStringsBuffer );
    pStringsBuffer = NULL;
	
	hr = CleanupRowset( pIRowset, hAccessor );
	if (FAILED(hr))
    	{
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr,  "CleanupRowset" );
        goto error;
        }
	
	return ResultFromScode( S_OK );		
    
error:    
	if (pColumnInfo)
		g_pIMalloc->Free( pColumnInfo );
	if (pStringsBuffer)
		g_pIMalloc->Free( pStringsBuffer );	    	
	    
    return ResultFromScode( hr );    
}





//**********************************************************************
//  
//  DoTests
//  
//  Purpose:
//
//     Hooks up to the  WMIOLEDB provider application,

//  Parameters:
//  
//  	none
//      
//  Return Value:
//  
//  	S_OK		- Success
//      E_*			- Failure
//  	
//      
//  Comments:      
//  
//     At a high level, an OLE DB data consumer obtains data by 
//     
//     1. Getting hooked up to a data provider's Data Source object,
//        and initializing that object
//     2. Getting a DBSession object from the Data Source object
//     3. Getting the data from the Rowset object.
//     
//     DoTests follows these steps by making calls to GetWMIOLEDBDataSource,
//     GetDBSessionDataSource, and GetDataFromRowset    
//  
//**********************************************************************


HRESULT DoTests
	(
	)
{
	IDBInitialize*	    pIDBInitialize 	= NULL;
    IOpenRowset*        pIOpenRowset    = NULL;
    IRowset*		    pIRowset		= NULL;
	HRESULT			    hr;


	hr = GetWMIOLEDBDataSource( &pIDBInitialize );
	if (FAILED(hr))
    	{
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr, "GetWMIOLEDBDataSource" );
        goto error;
        }

    hr = GetDBSessionFromDataSource( pIDBInitialize, &pIOpenRowset );
    if (FAILED(hr))
        {
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr, "GetDBSessionFromDataSource" );
        goto error;
        }

    pIDBInitialize->Release();
    pIDBInitialize = NULL;    

    hr = GetRowsetFromDBSession( pIOpenRowset, g_pwcsTable, &pIRowset );
    if (FAILED(hr))
        {
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr, "GetRowsetFromDBCreateSession" );
        goto error;
        }
        
    pIOpenRowset->Release();
    pIOpenRowset = NULL;    

	hr = GetDataFromRowset( pIRowset );
	if (FAILED(hr))
    	{
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr, "GetDataFromRowset" );
        goto error;
        }
    pIRowset->Release(); 
    pIRowset = NULL;
	CoFreeUnusedLibraries();

	DumpStatusMsg( "\nDone! ");
	printf("\n\nFor more data from this run, see the log file wmiclnt.out\n" );	
	return ResultFromScode( S_OK );
    
error:    
	if (pIRowset) 
		pIRowset->Release();
    if (pIOpenRowset)
        pIOpenRowset->Release();    
    if (pIDBInitialize)
    	pIDBInitialize->Release();	    
	
	return ResultFromScode( hr );
}						    















///////////////////////////////////////////////////////////////////////////////////////////////////////////
//extern "C" int wmain( int argc, WCHAR * argv[] )
int main( int argc, char * argv[] )
{
	DWORD   dwVersion;
	HRESULT hr;
    BOOL 	fOleInitialized = FALSE;
	char	ch;

    //=====================================================================================
    //  Parse the command line
    //=====================================================================================
    if( !ParseCommandLine(argc,argv) ){
        return 1;
    }

    InitializeLogFile();

	dwVersion = OleBuildVersion();
    if (HIWORD(dwVersion) != rmm){
		DumpErrorMsg( "Error: OLE version mismatch. Build version %ld, current version %ld\n",
			rmm, HIWORD(dwVersion) );
        goto error;    
	}

	hr = OleInitialize( NULL );
	if (FAILED(hr)){
        DUMP_ERROR_LINENUMBER();
        DumpErrorMsg("Error: OleInitialize failed\n");
        goto error;
	}
	fOleInitialized = TRUE;
     
    hr = CoGetMalloc( MEMCTX_TASK, &g_pIMalloc );
 	if (FAILED(hr))	{
        DUMP_ERROR_LINENUMBER();
        DumpErrorMsg("Error: CoGetMalloc failed\n");
        goto error;
    }
   
    hr = DoTests();
	if (FAILED(hr)){
        DUMP_ERROR_LINENUMBER();
        DumpErrorHResult( hr, "DoTests");
        goto error;
    }
    
    g_pIMalloc->Release();
	OleUninitialize();

	if (g_fpLogFile)
    	fclose(g_fpLogFile);

	/* Pause before we quit, in case user ran from an icon, so they can see our messages. */
	printf("\n\n>>> Output has gone into 'wmiclnt.out'.");
	printf("\n>>> You may wish to use a wide-column editor to view this file.\n\n");
	printf("<press any key to continue>");
	ch = _getch();
	return -1;
    
error:
    if (g_pIMalloc)
    	g_pIMalloc->Release();    
	if (fOleInitialized)
    	OleUninitialize();
	if (g_fpLogFile)
    	fclose(g_fpLogFile);
	
	/* Pause before we quit, in case user ran from an icon, so they can see our messages. */
	printf("\n\n>>> Output has gone into 'wmiclnt.out'.");
	printf("\n>>> You may wish to use a wide-column editor to view this file.\n\n");
	printf("<press any key to continue>");
	ch = _getch();

	return 2;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\client\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft OLE DB Sample Consumer
// (C) Copyright 1995 - 1998 Microsoft Corporation. All Rights Reserved.
//
// Microsoft Visual C++ generated include file.
// Used by SAMPCLNT.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40006
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\client\wmiver.h ===
//-----------------------------------------------------------------------------
// Microsoft OLE DB Sample Consumer
// (C) Copyright 1995 - 1998 Microsoft Corporation. All Rights Reserved.
//
// @doc
//
// @module OLEDBVER.H | version include file
//
// @rev 1 | 05-09-95 | Peterbu | Created
// @rev 2 | 08-15-95 | Briants | changed from kageravr.h
//

// Constants -----------------------------------------------------------------

#define VER_FILEVERSION  02,00,2905,0
#define VER_FILEVERSION_STR  "02.00.2905.0\0"
#define VER_PRODUCTVERSION  02,00,2905,0
#define VER_PRODUCTVERSION_STR  "02.00.2905.0\0"

#define VER_FILEFLAGSMASK		(VS_FF_DEBUG | VS_FF_PRERELEASE)
#ifdef DEBUG
#define VER_FILEFLAGS			(VS_FF_DEBUG)
#else
#define VER_FILEFLAGS			(0)
#endif

#define VER_FILEOS				VOS_NT_WINDOWS32

#define VER_COMPANYNAME_STR		"Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR		"Microsoft OLE DB\0"
#define VER_LEGALCOPYRIGHT_STR	"Copyright \251 Microsoft Corporation 1995-1998\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\client\wmiclnt.h ===
//--------------------------------------------------------------------
// Microsoft OLE DB Sample Consumer
// (C) Copyright 1995 - 1998 Microsoft Corporation. All Rights Reserved.
//
// File name: SAMPCLNT.H
//
//      Declaration file for a simple OLE DB consumer.
//
//      See OLE DB SDK Guide for information on building and running 
//		this sample, as well as notes concerning the implementation of 
//		a simple OLE DB consumer.
//


#define WIN32_LEAN_AND_MEAN		// avoid the world
#define INC_OLE2				// tell windows.h to always include ole2.h

#include <windows.h>			// 
#include <ole2ver.h>			// OLE2.0 build version
#include <cguid.h>				// GUID_NULL
#include <stdio.h>				// vsnprintf, etc.
#include <stddef.h>				// offsetof
#include <stdarg.h>				// va_arg
#include <time.h>				// time
#include <assert.h>				// assert
#include <conio.h>				// _getch()

//	OLE DB headers
#include <oledb.h>
#include <oledberr.h>


//-----------------------------------
//	constants 
//------------------------------------

// Alignment for placement of each column within memory.
// Rule of thumb is "natural" boundary, i.e. 4-byte member should be
// aligned on address that is multiple of 4.
// Worst case is double or __int64 (8 bytes).
#define COLUMN_ALIGNVAL 8

#define MAX_GUID_STRING     42	// size of a GUID, in characters
#define MAX_NAME_STRING     60  // size of DBCOLOD name or propid string
#define MAX_BINDINGS       100	// size of binding array
#define NUMROWS_CHUNK       20	// number of rows to grab at a time
#define DEFAULT_CBMAXLENGTH 40	// cbMaxLength for binding


// for pretty printing
#define PRETTYPRINT_MAXTOTALWIDTH	200     // max entire width of printed row 
#define PRETTYPRINT_MINCOLWIDTH     6        // min width of printed column



//-----------------------------------
//	macros 
//------------------------------------


// Rounding amount is always a power of two.
#define ROUND_UP(   Size, Amount ) (((DWORD)(Size) +  ((Amount) - 1)) & ~((Amount) - 1))

#ifndef  NUMELEM
# define NUMELEM(p) (sizeof(p)/sizeof(*p))
#endif

// usage: DUMPLINE();
#define DUMP_ERROR_LINENUMBER() DumpErrorMsg("Error at file: %s  line: %u  \n", __FILE__, __LINE__)

    struct TMPCOLUMNDATA 
	{
	DWORD		dwLength;	// length of data (not space allocated)
	DWORD		dwStatus;	// status of column
	BYTE		bData[1];	// data here and beyond
	};



// Lists of value/string pairs.
typedef struct {
	DWORD dwFlag;
	char *szText;
} Note;

#define NOTE(s) { (DWORD) s, #s }




//-----------------------------------
//	global variables and functions that are private to the file 
//------------------------------------


extern IMalloc*	g_pIMalloc;
extern FILE*    g_fpLogFile;



    
    
// function prototypes, dump.cpp

void DumpErrorMsg
	(
    const char* format,
    ...
	);


void DumpStatusMsg
	(
    const char* format,
    ...
	);


HRESULT DumpErrorHResult
	(
	HRESULT      hr_return,
	const char  *format,
	... 
	);


void DumpColumnsInfo
	(
    DBCOLUMNINFO* pColInfo,
    ULONG	      cCol
    );



void WriteColumnInfo
	(
	FILE*			fp,
	DBCOLUMNINFO*	p 
	);
    

char* GetNoteString
    ( 
	Note * rgNote, 
	int    cNote,
	DWORD  dwValue 
	);


    
char* GetNoteStringBitvals
	(
	Note* 	rgNote,
	int     cNote,
	DWORD   dwValue 
	);


ULONG CalcPrettyPrintMaxColWidth
    (
    DBBINDING*	rgBind,
    ULONG       cBind
    );
 
    
void DumpColumnHeadings
	(
	DBBINDING*		rgBind, 
	ULONG			cBind, 
	DBCOLUMNINFO* 	pColInfo, 
	ULONG			cCol,
    ULONG			cMaxColWidth
	);


WCHAR* LookupColumnName
	(
	DBCOLUMNINFO*	rgColInfo,
	ULONG 			cCol,
	ULONG 			iCol 
	);

void DumpRow
	(
    DBBINDING* 	rgBind,
    ULONG		cBind,
    ULONG		cMaxColWidth,
    BYTE* 		pData
    );


void PrintColumn
	(
	TMPCOLUMNDATA    *pColumn,
	DBBINDING     *rgBind,
	ULONG          iBind,
	ULONG          cMaxColWidth 
	);

    
void tfprintf
	(
	FILE*		fp,
	const char* format,
	... 
	);


void tvfprintf
	(
	FILE*		fp,
	const char* format,
	va_list		argptr 
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\precomp.h ===
#ifndef	__PRECOMP_H__
#define	__PRECOMP_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#define STRICT

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif	_WIN32_WINNT

#ifndef	WIN32_LEAN_AND_MEAN
#define	WIN32_LEAN_AND_MEAN
#endif	WIN32_LEAN_AND_MEAN

#define _ATL_FREE_THREADED
//#define _ATL_APARTMENT_THREADED

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

// need atl wrappers
#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

///////////////////////////////////////////////////////////////////////////////
// macros
///////////////////////////////////////////////////////////////////////////////
#include <__macro_pragma.h>
#include <__macro_nocopy.h>
#include <__macro_loadstring.h>
#include <__macro_assert.h>
#include <__macro_err.h>

#include "__Common_Convert.h"
#include "__Common_SmartPTR.h"

///////////////////////////////////////////////////////////////////////////////
// wbem stuff
///////////////////////////////////////////////////////////////////////////////
#ifndef	__WBEMIDL_H_
#include <wbemidl.h>
#endif	__WBEMIDL_H_

///////////////////////////////////////////////////////////////////////////////
// defines
///////////////////////////////////////////////////////////////////////////////
#define	__SUPPORT_WAIT

//#define	__SUPPORT_ICECAP_ONCE
//#define	__SUPPORT_EVENTVWR
//#define	__SUPPORT_MSGBOX

//#define	__SUPPORT_LOGGING

#endif	__PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMIAdapter.cpp
//
//	Abstract:
//
//					implements functionality ( decides what to do :)) )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

// resorces

#include "PreComp.h"

// guids
#include <initguid.h>

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// messages ( event log )
#include "WmiAdapterMessages.h"

#include ".\WMIAdapter\resource.h"

// declarations
#include "WMIAdapter_Service.h"
#include "WMIAdapter_App.h"

// registration
#include "Wmi_Adapter_Registry_Service.h"

// enum
#include <refreshergenerate.h>

/////////////////////////////////////////////////////////////////////////////
// VARIABLES
/////////////////////////////////////////////////////////////////////////////

// app
WmiAdapterApp		_App;

// service module
WmiAdapterService	_Service;

////////////////////////////////////////////////////////////////////////////
// ATL stuff
////////////////////////////////////////////////////////////////////////////

// need atl wrappers
#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

// need registry
#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

/////////////////////////////////////////////////////////////////////////////
//
//	Helpers
//
/////////////////////////////////////////////////////////////////////////////

CRITICAL_SECTION	g_cs;						//	synch object used to protect above globals
LONG				g_lRef			= 0;		//	count of threads attached into Run Function
__SmartHANDLE		g_hDoneWorkEvt	= NULL;		//	event to set when init/uninit is finished done		( nonsignaled )
BOOL				g_bWorking		= FALSE;	//	boolean used to tell if init/unit in progress

//Performs Initialization if necessary, waits until initialization is done if necessary.
HRESULT DoInit()
{
	HRESULT hRes = E_FAIL;

	BOOL bWait = TRUE;
	BOOL bDoWork = FALSE;

	while (bWait)
	{
		try
		{
			::EnterCriticalSection ( &g_cs );
		}
		catch ( ... )
		{
			return E_OUTOFMEMORY;
		}

		if ( g_lRef == 0 )
		{
			bDoWork = TRUE;
			g_lRef++;
			g_bWorking = TRUE;
			::ResetEvent(g_hDoneWorkEvt);
			bWait = FALSE;
		}
		else
		{
			if ( g_bWorking )
			{
				::LeaveCriticalSection ( &g_cs );
				
				if ( WAIT_OBJECT_0 != ::WaitForSingleObject( g_hDoneWorkEvt, INFINITE ) )
				{
					return hRes;
				}
			}
			else
			{
				bWait = FALSE;
				g_lRef++;
				hRes = S_OK;
			}
		}
	}

	::LeaveCriticalSection( &g_cs );

	if (bDoWork)
	{
		if SUCCEEDED ( hRes = _App.InitKill ( ) )
		{
			try
			{
				////////////////////////////////////////////////////////////////////////
				// This provides a NULL DACL which will allow access to everyone.
				////////////////////////////////////////////////////////////////////////

				if SUCCEEDED ( hRes = ::CoInitializeSecurity(	NULL,
																-1,
																NULL,
																NULL,
																RPC_C_AUTHN_LEVEL_PKT,
																RPC_C_IMP_LEVEL_IMPERSONATE,
																NULL,
																EOAC_DYNAMIC_CLOAKING,
																NULL
															)
							 )
				{
					try
					{
						////////////////////////////////////////////////////////////////////////
						// LOCATOR ( neccessary )
						////////////////////////////////////////////////////////////////////////

						if ( ! ( (WmiAdapterStuff*) _App )->m_Stuff.m_spLocator )
						{
							hRes =	::CoCreateInstance
									(
											__uuidof ( WbemLocator ),
											NULL,
											CLSCTX_INPROC_SERVER,
											__uuidof ( IWbemLocator ),
											(void**) & ( ( (WmiAdapterStuff*) _App )->m_Stuff.m_spLocator )
									);
						}
					}
					catch ( ... )
					{
						hRes = E_UNEXPECTED;
					}
				}
			}
			catch ( ... )
			{
				hRes = E_UNEXPECTED;
			}
		}
		
		try
		{
			::EnterCriticalSection ( &g_cs );
		}
		catch (...)
		{
			// no choice have to give others a chance!
			::InterlockedDecrement ( &g_lRef );

			g_bWorking = FALSE;
			::SetEvent(g_hDoneWorkEvt);

			return E_OUTOFMEMORY;
		}

		if (FAILED(hRes))
		{
			g_lRef--;
		}

		g_bWorking = FALSE;
		::SetEvent(g_hDoneWorkEvt);
		::LeaveCriticalSection ( &g_cs );
	}

	return hRes;
}
		
//Performs unitialization ONLY if necessary. While unitializing sets global g_bWorking to TRUE.
void DoUninit()
{
	BOOL bDoWork = FALSE;

	try
	{
		::EnterCriticalSection ( &g_cs );
	}
	catch ( ... )
	{
		return;
	}

	if ( g_lRef == 1 )
	{
		bDoWork = TRUE;
		g_bWorking = TRUE;
		::ResetEvent(g_hDoneWorkEvt);
	}
	else
	{
		g_lRef--;
	}

	::LeaveCriticalSection( &g_cs );

	if (bDoWork)
	{
		try
		{
			if ( _App.m_hKill.GetHANDLE() )
			{
				::SetEvent ( _App.m_hKill );
			}

			// is refresh of registry already done ?
			if ( ((WmiAdapterStuff*)_App)->RequestGet() )
			{
				((WmiAdapterStuff*)_App)->Generate ( FALSE );
			}

			////////////////////////////////////////////////////////////////////////
			// LOCATOR
			////////////////////////////////////////////////////////////////////////
			try
			{
				( ( WmiAdapterStuff* ) _App )->m_Stuff.m_spLocator.Release();
			}
			catch ( ... )
			{
			}
		}
		catch (...)
		{
		}

		try
		{
			::EnterCriticalSection ( &g_cs );
		}
		catch ( ... )
		{
			//gotta give others a chance to work, risk it!
			::InterlockedDecrement ( &g_lRef );

			g_bWorking = FALSE;
			::SetEvent( g_hDoneWorkEvt );
			return;
		}

		g_lRef--;
		g_bWorking = FALSE;
		::SetEvent( g_hDoneWorkEvt );
		::LeaveCriticalSection ( &g_cs );
	}
}

/////////////////////////////////////////////////////////////////////////////
//
// WIN MAIN
//
/////////////////////////////////////////////////////////////////////////////

extern "C" int WINAPI   WinRun		( );

extern "C" int WINAPI _tWinMain		( HINSTANCE hInstance, HINSTANCE, LPTSTR, int )
{
	return WinMain ( hInstance, NULL, GetCommandLineA(), SW_SHOW );
}

extern "C" int WINAPI   WinMain		( HINSTANCE, HINSTANCE, LPSTR, int )
{
	////////////////////////////////////////////////////////////////////////
	// initialization
	////////////////////////////////////////////////////////////////////////
	_App.InitAttributes ( );

	////////////////////////////////////////////////////////////////////////
	// variables
	////////////////////////////////////////////////////////////////////////

    WCHAR	szTokens[]	= L"-/";
    HRESULT	nRet		= S_FALSE;

	////////////////////////////////////////////////////////////
	// initialization
	////////////////////////////////////////////////////////////
	if SUCCEEDED ( nRet = _App.Init ( ) )
	{
		////////////////////////////////////////////////////////////////////////
		// command line
		////////////////////////////////////////////////////////////////////////
		LPWSTR lpCmdLine = GetCommandLineW();

		////////////////////////////////////////////////////////////////////////
		// find behaviour
		////////////////////////////////////////////////////////////////////////

		LPCWSTR lpszToken	= WmiAdapterApp::FindOneOf(lpCmdLine, szTokens);
		BOOL	bContinue	= TRUE;
		try
		{
			while (lpszToken != NULL && bContinue)
			{
				if (lstrcmpiW(lpszToken, L"kill")==0)
				{
					if SUCCEEDED ( nRet = _App.InitKill ( ) )
					{
						::SetEvent	( _App.m_hKill.GetHANDLE() );
					}

					bContinue = FALSE;
				}
				else
				{
					if (lstrcmpiW(lpszToken, L"UnregServer")==0)
					{
						////////////////////////////////////////////////////////////////
						// unregister service
						////////////////////////////////////////////////////////////////
						if SUCCEEDED ( nRet = _Service.UnregisterService ( ) )
						{
							((WmiAdapterStuff*)_App)->Generate( FALSE, UnRegistration );

							////////////////////////////////////////////////////////////
							// unregister registry
							////////////////////////////////////////////////////////////
							WmiAdapterRegistryService::__UpdateRegistrySZ( false );
						}

						bContinue = FALSE;
					}
					else
					{
						if (lstrcmpiW(lpszToken, L"RegServer")==0)
						{
							////////////////////////////////////////////////////////////
							// register service
							////////////////////////////////////////////////////////////
							if SUCCEEDED ( nRet = _Service.RegisterService ( ) )
							{
								////////////////////////////////////////////////////////
								// create registry again
								////////////////////////////////////////////////////////
								WmiAdapterRegistryService::__UpdateRegistrySZ( true );

								((WmiAdapterStuff*)_App)->Generate( FALSE, Registration );
							}

							bContinue = FALSE;
						}
					}
				}

				lpszToken = WmiAdapterApp::FindOneOf(lpszToken, szTokens);
			}

			if ( bContinue )
			{
				////////////////////////////////////////////////////////////////
				// previous instance
				////////////////////////////////////////////////////////////////
				if ( ! _App.Exists() )
				{
					////////////////////////////////////////////////////////
					// initialization
					////////////////////////////////////////////////////////
					_Service.Init	( );

					__SmartServiceHANDLE	pSCM;
					if ( ( pSCM = OpenSCManager	(
													NULL,                   // machine (NULL == local)
													NULL,                   // database (NULL == default)
													SC_MANAGER_ALL_ACCESS   // access required
												) ) != NULL )
					{
						__SmartServiceHANDLE	pService;
						if ( ( pService = OpenServiceW ( pSCM, g_szAppName, SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG ) )
							   != NULL )
						{
							LPQUERY_SERVICE_CONFIG	lpQSC = NULL;
							DWORD					dwQSC = 0L;

							try
							{
								if ( ! QueryServiceConfig ( pService, lpQSC, 0, &dwQSC ) )
								{
									if ( ERROR_INSUFFICIENT_BUFFER == ::GetLastError () )
									{
										if ( ( lpQSC = (LPQUERY_SERVICE_CONFIG) LocalAlloc( LPTR, dwQSC ) ) != NULL )
										{
											if ( QueryServiceConfig ( pService, lpQSC, dwQSC, &dwQSC ) != 0 )
											{
												_App.m_bManual = ( lpQSC->dwStartType == SERVICE_DEMAND_START );
											}
										}
									}
								}
							}
							catch ( ... )
							{
							}

							LocalFree ( lpQSC ); 

							SERVICE_STATUS s;
							QueryServiceStatus ( pService, &s );

							// we are service, not running ???
							if( s.dwCurrentState != SERVICE_RUNNING )
							{
								if ( ! _Service.StartService () )
								{
									DWORD dwError = ERROR_SUCCESS;
									dwError = ::GetLastError();

									if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
									{
										nRet = HRESULT_FROM_WIN32 ( dwError );
									}
									else
									{
										nRet = HRESULT_FROM_WIN32 ( ERROR_NOT_READY );
									}
								}
							}
							else
							{
								DWORD dwError = ERROR_SUCCESS;
								dwError = ::GetLastError();

								if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
								{
									nRet = HRESULT_FROM_WIN32 ( dwError );
								}
								else
								{
									nRet = HRESULT_FROM_WIN32 ( ERROR_ALREADY_EXISTS );
								}
							}
						}
						else
						{
							DWORD dwError = ERROR_SUCCESS;
							dwError = ::GetLastError();

							if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
							{
								nRet = HRESULT_FROM_WIN32 ( dwError );
							}
							else
							{
								nRet = E_FAIL;
							}
						}
					}
					else
					{
						DWORD dwError = ERROR_SUCCESS;
						dwError = ::GetLastError();

						if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
						{
							nRet = HRESULT_FROM_WIN32 ( dwError );
						}
						else
						{
							nRet = E_FAIL;
						}
					}
				}
				else
				{
					////////////////////////////////////////////////////////////
					// termination
					////////////////////////////////////////////////////////////
					nRet =  HRESULT_FROM_WIN32 ( ERROR_ALREADY_EXISTS );
				}
			}
		}
		catch ( ... )
		{
			// catastrophic failure
			nRet = E_FAIL;
		}

		// return
		if SUCCEEDED ( nRet )
		{
			nRet = _Service.GetServiceStatus()->dwWin32ExitCode;
		}

		_App.Term ();
	}

	return nRet;
}

///////////////////////////////////////////////////////////////////////////////
//
// RUN :))
//
///////////////////////////////////////////////////////////////////////////////
extern "C" int WINAPI WinRun( )
{
	///////////////////////////////////////////////////////////////////////////
	// INITIALIZATION
	///////////////////////////////////////////////////////////////////////////

	LONG	lRes = ERROR_SUCCESS;
	HRESULT hRes = E_FAIL;

	///////////////////////////////////////////////////////////////////////////
	// COM INITIALIZATION
	///////////////////////////////////////////////////////////////////////////
	if SUCCEEDED ( hRes = ::CoInitializeEx(NULL, COINIT_MULTITHREADED) )
	{
		// mark service is running IMMEDIATELY
		_Service.SetServiceStatus ( SERVICE_RUNNING );

		if SUCCEEDED ( hRes = DoInit() )
		{
			try
			{
				if ( ( lRes = _Service.Work () ) != S_OK )
				{
					if ( _App.m_hKill.GetHANDLE() )
					{
						::SetEvent ( _App.m_hKill );
					}
				}

				::WaitForSingleObject ( _App.m_hKill, INFINITE );
			}
			catch ( ... )
			{
				lRes = E_UNEXPECTED;
			}

			///////////////////////////////////////////////////////////////////
			// do real finishing stuff ( synchronize etc )
			///////////////////////////////////////////////////////////////////
			DoUninit();
		}

		///////////////////////////////////////////////////////////////////////
		// COM UNINITIALIZATION
		///////////////////////////////////////////////////////////////////////
		::CoUninitialize();
	}

	if FAILED ( hRes )
	{
		// something was wrong in helpers
		return hRes;
	}
	else
	{
		// result from real work
		return ( lRes == S_FALSE ) ? S_OK : lRes;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_service.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMIAdapter_Service.cpp
//
//	Abstract:
//
//					module for service
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// messaging
#include "WMIAdapterMessages.h"

// application
#include "WMIAdapter_App.h"
extern WmiAdapterApp		_App;

// service module
#include "WMIAdapter_Service.h"
extern WmiAdapterService	_Service;

extern	LONG				g_lRefLib;	// refcount of libarries attached into process
extern	CRITICAL_SECTION	g_csInit;	// synch object used to protect above globals

/////////////////////////////////////////////////////////////////////////////////////////
// destruction
/////////////////////////////////////////////////////////////////////////////////////////

WmiAdapterService::~WmiAdapterService()
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterService destruction\n"
				L"*************************************************************\n" );

	if ( m_hServiceStatus )
	{
//		service status handle doesn't have to be closed
//		::CloseHandle ( m_hServiceStatus );

		m_hServiceStatus = NULL;
	}

	::DeleteCriticalSection ( &m_cs );
}

///////////////////////////////////////////////////////////////////////////////////////////////
// service status
///////////////////////////////////////////////////////////////////////////////////////////////
BOOL WmiAdapterService::SetServiceStatus ( DWORD dwState )
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterService set status\n"
				L"*************************************************************\n" );

	////////////////////////////////////////////////////////////////////////
	// smart locking/unlocking
	////////////////////////////////////////////////////////////////////////
	__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs ) );

	m_ServiceStatus.dwCurrentState = dwState;

	try
	{
		return ::SetServiceStatus ( m_hServiceStatus, &m_ServiceStatus );
	}
	catch ( ... )
	{
	}

	return FALSE;
}

SERVICE_STATUS* WmiAdapterService::GetServiceStatus ( void ) const
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterService get status\n"
				L"*************************************************************\n" );

	////////////////////////////////////////////////////////////////////////
	// smart locking/unlocking
	////////////////////////////////////////////////////////////////////////
	__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs ) );

	return const_cast < SERVICE_STATUS* > ( &m_ServiceStatus );
}

/////////////////////////////////////////////////////////////////////////////////////////
// run body :))
/////////////////////////////////////////////////////////////////////////////////////////

extern "C" int WINAPI WinRun	( );

/////////////////////////////////////////////////////////////////////////////////////////
// functions
/////////////////////////////////////////////////////////////////////////////////////////

void WINAPI WmiAdapterService::_ServiceMain(DWORD dwArgc, LPWSTR* lpszArgv)
{
    _Service.ServiceMain(dwArgc, lpszArgv);
}
void WINAPI WmiAdapterService::_ServiceHandler(DWORD dwOpcode)
{
    _Service.ServiceHandler(dwOpcode); 
}

/////////////////////////////////////////////////////////////////////////////////////////
// routine
/////////////////////////////////////////////////////////////////////////////////////////

inline void WmiAdapterService::ServiceMain( DWORD, LPWSTR* )
{
	// Register the control request handler
	m_ServiceStatus.dwCurrentState = SERVICE_START_PENDING;

	if ( ( m_hServiceStatus = RegisterServiceCtrlHandlerW(g_szAppName, _ServiceHandler) ) == NULL )
	{
		#ifdef	__SUPPORT_EVENTVWR
		try
		{
			((CPerformanceEventLogBase*)_App)->ReportEvent ( EVENTLOG_ERROR_TYPE, 0, WMI_ADAPTER_OPEN_SCM_FAIL, 0, 0, 0, 0 );
		}
		catch ( ... )
		{
		}
		#endif	__SUPPORT_EVENTVWR

		return;
	}

	SetServiceStatus(SERVICE_START_PENDING);

	m_ServiceStatus.dwWin32ExitCode	= S_OK;
	m_ServiceStatus.dwCheckPoint	= 0;
	m_ServiceStatus.dwWaitHint		= 0;

	try
	{
		m_ServiceStatus.dwWin32ExitCode	= WinRun ( );
	}
	catch ( ... )
	{
		m_ServiceStatus.dwWin32ExitCode	= static_cast < ULONG > ( E_UNEXPECTED );
	}

	SetServiceStatus ( SERVICE_STOPPED );
}

/////////////////////////////////////////////////////////////////////////////////////////
// handler
/////////////////////////////////////////////////////////////////////////////////////////

inline void WmiAdapterService::ServiceHandler(DWORD dwOpcode)
{
	// auto lock/unlock
	__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs ) );

    switch (dwOpcode)
    {
		case SERVICE_CONTROL_STOP:
		{
			BOOL bStop = FALSE;

			if ( ::TryEnterCriticalSection ( &g_csInit ) )
			{
				if ( ( ::InterlockedCompareExchange ( &g_lRefLib, 0, 0 ) == 0 ) && ! _App.InUseGet() )
				{
					bStop = TRUE;
				}

				::LeaveCriticalSection ( &g_csInit );
			}

			if ( bStop )
			{
				if ( SetServiceStatus ( SERVICE_STOP_PENDING ) )
				{
					if ( _App.m_hKill.GetHANDLE() )
					{
						// kill application
						::SetEvent	( _App.m_hKill );
					}
				}
			}
		}
		break;
		case SERVICE_CONTROL_CONTINUE:
		{
			m_ServiceStatus.dwCurrentState = SERVICE_RUNNING;
		}
		break;
		case SERVICE_CONTROL_PAUSE:
		break;
		case SERVICE_CONTROL_INTERROGATE:
		break;
		case SERVICE_CONTROL_SHUTDOWN:
		break;

		default:
		{
			// bad service status :))
		}
    }
}

BOOL WmiAdapterService::StartService ( void )
{
	SERVICE_TABLE_ENTRY st[] =
	{
		{ const_cast < LPWSTR > ( g_szAppName ), _ServiceMain },
		{ NULL, NULL }
	};

	if ( ! ::StartServiceCtrlDispatcher ( st ) )
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////
// initialization
/////////////////////////////////////////////////////////////////////////////////////////

HRESULT WmiAdapterService::Init ( void )
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterService initialization\n"
				L"*************************************************************\n" );

	////////////////////////////////////////////////////////////////////////
	// smart locking/unlocking
	////////////////////////////////////////////////////////////////////////
	__Smart_CRITICAL_SECTION scs ( const_cast<LPCRITICAL_SECTION> ( &m_cs ) );

    m_hServiceStatus = NULL;

    m_ServiceStatus.dwServiceType				= SERVICE_WIN32_OWN_PROCESS;
    m_ServiceStatus.dwCurrentState				= SERVICE_STOPPED;
    m_ServiceStatus.dwControlsAccepted			= SERVICE_ACCEPT_STOP;
    m_ServiceStatus.dwWin32ExitCode				= 0;
    m_ServiceStatus.dwServiceSpecificExitCode	= 0;
    m_ServiceStatus.dwCheckPoint				= 0;
    m_ServiceStatus.dwWaitHint					= 0;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
// helper if installed
/////////////////////////////////////////////////////////////////////////////////////////

int WmiAdapterService::IsInstalled ( SC_HANDLE hSC )
{
	int iResult = -1;

	if ( hSC )
	{
		__SmartServiceHANDLE hService;


		if ( ( hService = ::OpenServiceW ( hSC, g_szAppName, SERVICE_QUERY_CONFIG ) ) != NULL )
		{
			iResult = 1;
		}
		else
		{
			iResult = 0;
		}
	}

	return iResult;
}

/////////////////////////////////////////////////////////////////////////////////////////
// register service
/////////////////////////////////////////////////////////////////////////////////////////

HRESULT WmiAdapterService::RegisterService ( void )
{
	HRESULT hr = S_FALSE;

	// Unregister service ( could have bad variables )
	hr = UnregisterService ( false );

	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterService registration\n"
				L"*************************************************************\n" );

	if SUCCEEDED ( hr )
	{
		// SCM has suggested wait a while if we were deleting
		if ( hr == S_OK )
		{
			// I do not like it either, but there is no way
			// to waitforsingleobject on some kernel object ...
			::Sleep ( 3000 );
		}

		__SmartServiceHANDLE hSC;
		if ( ( hSC = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS) ) != NULL )
		{
			// Get the executable file path
			WCHAR wszFilePath[_MAX_PATH] = { L'\0' };
			::GetModuleFileNameW(NULL, wszFilePath, _MAX_PATH);

			__SmartServiceHANDLE hService;

			// create service description
			LPWSTR wszServiceName = NULL;

			try
			{
				wszServiceName = LoadStringSystem ( ::GetModuleHandle( NULL ), IDS_NAME );
			}
			catch ( ... )
			{
				if ( wszServiceName )
				{
					delete [] wszServiceName;
					wszServiceName = NULL;
				}
			}

			if ( ( hService = ::CreateServiceW	(	hSC,
													g_szAppName,

													( wszServiceName != NULL ) ?
														wszServiceName : 
														L"WMI Performance Adapter",

													SERVICE_ALL_ACCESS,
													SERVICE_WIN32_OWN_PROCESS,
													SERVICE_DEMAND_START,
													SERVICE_ERROR_NORMAL,
													wszFilePath,
													0,
													0,
													L"RPCSS\0",
													0,
													0
												) )
				 != NULL )
			{
				hr = E_OUTOFMEMORY;

				// create service description
				LPWSTR wszDescription = NULL;

				try
				{
					if ( ( wszDescription = LoadStringSystem ( ::GetModuleHandle( NULL ), IDS_DESCRIPTION ) ) != NULL )
					{
						hr = S_OK;

						SERVICE_DESCRIPTION sd;
						sd.lpDescription = wszDescription;

						if ( ! ChangeServiceConfig2 ( hService, SERVICE_CONFIG_DESCRIPTION, reinterpret_cast < LPVOID > ( &sd ) ) )
						{
							hr = FAILED ( HRESULT_FROM_WIN32 ( ::GetLastError () ) ) ? HRESULT_FROM_WIN32 ( ::GetLastError () ) : E_FAIL;
						}
					}
				}
				catch ( ... )
				{
					hr = E_FAIL;
				}

				if ( wszDescription )
				{
					delete [] wszDescription;
					wszDescription = NULL;
				}
			}
			else
			{
				#ifdef	__SUPPORT_EVENTVWR
				LPWSTR wszError = NULL;

				wszError = GetErrorMessageModule ( WMI_ADAPTER_CREATE_SC_FAIL, _App.m_hResources );
				::MessageBoxW ( ::GetActiveWindow(), ( wszError ) ? wszError : L"error", g_szAppName, MB_OK | MB_ICONERROR );

				delete wszError;

				try
				{
					((CPerformanceEventLogBase*)_App)->ReportEvent ( EVENTLOG_ERROR_TYPE, 0, WMI_ADAPTER_CREATE_SC_FAIL, 0, 0, 0, 0 );
				}
				catch ( ... )
				{
				}
				#endif	__SUPPORT_EVENTVWR

				if ( wszServiceName )
				{
					delete [] wszServiceName;
					wszServiceName = NULL;
				}

				// unable to create service
				hr = FAILED ( HRESULT_FROM_WIN32 ( ::GetLastError () ) ) ? HRESULT_FROM_WIN32 ( ::GetLastError () ) : E_FAIL;
			}

			if ( wszServiceName )
			{
				delete [] wszServiceName;
				wszServiceName = NULL;
			}
		}
		else
		{
			#ifdef	__SUPPORT_EVENTVWR
			LPWSTR wszError = NULL;

			wszError = GetErrorMessageModule ( WMI_ADAPTER_OPEN_SCM_FAIL, _App.m_hResources );
			::MessageBoxW ( ::GetActiveWindow(), ( wszError ) ? wszError : L"error", g_szAppName, MB_OK | MB_ICONERROR );

			delete wszError;

			try
			{
				((CPerformanceEventLogBase*)_App)->ReportEvent ( EVENTLOG_ERROR_TYPE, 0, WMI_ADAPTER_OPEN_SCM_FAIL, 0, 0, 0, 0 );
			}
			catch ( ... )
			{
			}
			#endif	__SUPPORT_EVENTVWR

			// unable to open service manager
			hr = FAILED ( HRESULT_FROM_WIN32 ( ::GetLastError () ) ) ? HRESULT_FROM_WIN32 ( ::GetLastError () ) : E_FAIL;
		}
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////
// unregister service
/////////////////////////////////////////////////////////////////////////////////////////

HRESULT WmiAdapterService::UnregisterService ( bool bStatus )
{
	HRESULT hr = S_FALSE;

	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterService unregistartion\n"
				L"*************************************************************\n" );

	__SmartServiceHANDLE hSCM;
	if ( ( hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS) ) != NULL )
	{
		if ( IsInstalled ( hSCM ) != 0 )
		{
			BOOL bContinue = TRUE;
			BOOL bSucceeded= FALSE;

			DWORD	dwTry = 5;
			while ( bContinue && dwTry-- )
			{
				__SmartServiceHANDLE hService;
				if ( ( hService = ::OpenServiceW( hSCM, g_szAppName, SERVICE_QUERY_STATUS | SERVICE_STOP ) ) != NULL)
				{
					SERVICE_STATUS s;
					QueryServiceStatus ( hService, &s );

					// we are service what's our status
					if( s.dwCurrentState != SERVICE_STOPPED )
					{
						if ( ! ::ControlService( hService, SERVICE_CONTROL_STOP, &s ) )
						{
							DWORD dwError = ERROR_SUCCESS;
							dwError = ::GetLastError ();

							switch ( dwError )
							{
								case ERROR_SERVICE_NOT_ACTIVE:
								{
									bContinue = FALSE;
									bSucceeded= TRUE;
								}
								break;

								case ERROR_SERVICE_CANNOT_ACCEPT_CTRL:
								{
									if ( s.dwCurrentState == SERVICE_STOPPED )
									{
										bContinue = FALSE;
										bSucceeded= TRUE;
									}
								}
								break;

								default:
								{
									bContinue = FALSE;
									hr = HRESULT_FROM_WIN32 ( dwError );
								}
								break;
							}
						}
						else
						{
							bSucceeded = TRUE;
						}
					}
					else
					{
						bContinue = FALSE;
						bSucceeded= TRUE;
					}
				}
				else
				{
					#ifdef	__SUPPORT_EVENTVWR
					LPWSTR wszError = NULL;

					wszError = GetErrorMessageModule ( WMI_ADAPTER_OPEN_SC_FAIL, _App.m_hResources );
					::MessageBoxW ( ::GetActiveWindow(), ( wszError ) ? wszError : L"error", g_szAppName, MB_OK | MB_ICONERROR );

					delete wszError;

					try
					{
						((CPerformanceEventLogBase*)_App)->ReportEvent ( EVENTLOG_ERROR_TYPE, 0, WMI_ADAPTER_OPEN_SC_FAIL, 0, 0, 0, 0 );
					}
					catch ( ... )
					{
					}
					#endif	__SUPPORT_EVENTVWR

					// unable to open service
					hr = FAILED ( HRESULT_FROM_WIN32 ( ::GetLastError () ) ) ? HRESULT_FROM_WIN32 ( ::GetLastError () ) : E_FAIL;
					bContinue = FALSE;
				}
			}

			if ( bSucceeded )
			{
				__SmartServiceHANDLE hService;
				if ( ( hService = ::OpenServiceW( hSCM, g_szAppName, DELETE ) ) != NULL)
				{
					BOOL bDelete = FALSE;
					if ( ( bDelete = ::DeleteService( hService ) ) == FALSE )
					{
						hr = S_FALSE;
					}
					else
					{
						hr = S_OK;
					}

					if ( bStatus )
					{
						#ifdef	__SUPPORT_EVENTVWR
						LPWSTR wszError = NULL;

						wszError = GetErrorMessageModule ( WMI_ADAPTER_DELETE_SC_FAIL, _App.m_hResources );
						::MessageBoxW ( ::GetActiveWindow(), ( wszError ) ? wszError : L"error", g_szAppName, MB_OK | MB_ICONERROR );

						delete wszError;

						try
						{
							((CPerformanceEventLogBase*)_App)->ReportEvent ( EVENTLOG_ERROR_TYPE, 0, WMI_ADAPTER_DELETE_SC_FAIL, 0, 0, 0, 0 );
						}
						catch ( ... )
						{
						}
						#endif	__SUPPORT_EVENTVWR
					}
				}
				else
				{
					#ifdef	__SUPPORT_EVENTVWR
					LPWSTR wszError = NULL;

					wszError = GetErrorMessageModule ( WMI_ADAPTER_OPEN_SC_FAIL, _App.m_hResources );
					::MessageBoxW ( ::GetActiveWindow(), ( wszError ) ? wszError : L"error", g_szAppName, MB_OK | MB_ICONERROR );

					delete wszError;

					try
					{
						((CPerformanceEventLogBase*)_App)->ReportEvent ( EVENTLOG_ERROR_TYPE, 0, WMI_ADAPTER_OPEN_SC_FAIL, 0, 0, 0, 0 );
					}
					catch ( ... )
					{
					}
					#endif	__SUPPORT_EVENTVWR

					// unable to open service
					hr = FAILED ( HRESULT_FROM_WIN32 ( ::GetLastError () ) ) ? HRESULT_FROM_WIN32 ( ::GetLastError () ) : E_FAIL;
					bContinue = FALSE;
				}
			}
		}
	}
	else
	{
		#ifdef	__SUPPORT_EVENTVWR
		LPWSTR wszError = NULL;

		wszError = GetErrorMessageModule ( WMI_ADAPTER_OPEN_SCM_FAIL, _App.m_hResources );
		::MessageBoxW ( ::GetActiveWindow(), ( wszError ) ? wszError : L"error", g_szAppName, MB_OK | MB_ICONERROR );

		delete wszError;

		try
		{
			((CPerformanceEventLogBase*)_App)->ReportEvent ( EVENTLOG_ERROR_TYPE, 0, WMI_ADAPTER_OPEN_SCM_FAIL, 0, 0, 0, 0 );
		}
		catch ( ... )
		{
		}
		#endif	__SUPPORT_EVENTVWR

		// unable to open service manager
		hr = FAILED ( HRESULT_FROM_WIN32 ( ::GetLastError () ) ) ? HRESULT_FROM_WIN32 ( ::GetLastError () ) : E_FAIL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_app.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMIAdapter_App.cpp
//
//	Abstract:
//
//					module for application
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// application
#include "WMIAdapter_App.h"
extern WmiAdapterApp		_App;

///////////////////////////////////////////////////////////////////////////
// GLOBAL STUFF
///////////////////////////////////////////////////////////////////////////

extern	LPCWSTR				g_szRefreshMutex;	// name of mutex for refresh
extern	__SmartHANDLE		g_hRefreshMutex;	// mutex to find out refersh request

extern	LPCWSTR				g_szRefreshMutexLib;// name of mutex for refresh
extern	__SmartHANDLE		g_hRefreshMutexLib;	// mutex to find out refersh request

extern	LPCWSTR				g_szRefreshFlag;
extern	__SmartHANDLE		g_hRefreshFlag;

extern __SmartHANDLE		g_hDoneWorkEvt;		//	event for COM init/uninit	( nonsignaled )
extern __SmartHANDLE		g_hDoneWorkEvtCIM;	//	event for CIM connect/release	( nonsignaled )
extern __SmartHANDLE		g_hDoneWorkEvtWMI;	//	event for WMI connect/release	( nonsignaled )
extern __SmartHANDLE		g_hDoneLibEvt;		//	event for lib connect/disconnect	( nonsignaled )
extern __SmartHANDLE		g_hDoneInitEvt;		//	event for init is finished	( nonsignaled )

extern CRITICAL_SECTION	g_cs;			// crit sec for guarding COM init/uninit
extern CRITICAL_SECTION	g_csWMI;		// crit sec for guarding CIM/WMI connect/release
extern CRITICAL_SECTION	g_csInit;		// crit sec for guarding libs init/uninit

extern LPCWSTR g_szAppName;
extern LPCWSTR g_szAppNameGlobal;

///////////////////////////////////////////////////////////////////////////
// construction & destruction
///////////////////////////////////////////////////////////////////////////

WmiAdapterApp::WmiAdapterApp( ):

	m_hResources ( NULL ),
	m_bInUse ( FALSE ),
	m_bManual ( FALSE )
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterApp construction\n"
				L"*************************************************************\n" );

	::InitializeCriticalSection ( &m_cs );
}

WmiAdapterApp::~WmiAdapterApp()
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterApp destruction\n"
				L"*************************************************************\n" );

	////////////////////////////////////////////////////////////////////////
	// release mutex ( previous instance checker :)) )
	////////////////////////////////////////////////////////////////////////
	if ( m_hInstance.GetHANDLE() )
	{
		::ReleaseMutex ( m_hInstance );
		m_hInstance.CloseHandle();
	}

	////////////////////////////////////////////////////////////////////////
	// release security attributtes
	////////////////////////////////////////////////////////////////////////
	try
	{
		if ( ! pStuff.IsEmpty() )
		{
			delete pStuff.Detach();
		}
	}
	catch ( ... )
	{
		pStuff.Detach();
	}

	////////////////////////////////////////////////////////////////////////
	// release event log
	////////////////////////////////////////////////////////////////////////
	try
	{
		if ( ! pEventLog.IsEmpty() )
		{
			delete pEventLog.Detach();
		}
	}
	catch ( ... )
	{
		pEventLog.Detach();
	}

	////////////////////////////////////////////////////////////////////////
	// release security attributtes
	////////////////////////////////////////////////////////////////////////
	try
	{
		if ( ! pSA.IsEmpty() )
		{
			delete pSA.Detach();
		}
	}
	catch ( ... )
	{
		pSA.Detach();
	}

	////////////////////////////////////////////////////////////////////////
	// close resources
	////////////////////////////////////////////////////////////////////////
	if ( m_hResources )
	{
		::FreeLibrary ( m_hResources );
		m_hResources = NULL;
	}

	::DeleteCriticalSection ( &g_cs );
	::DeleteCriticalSection ( &g_csWMI );
	::DeleteCriticalSection ( &g_csInit );

	::DeleteCriticalSection ( &m_cs );

	#ifdef	_DEBUG
	_CrtDumpMemoryLeaks();
	#endif	_DEBUG
}

///////////////////////////////////////////////////////////////////////////
// exists instance ?
///////////////////////////////////////////////////////////////////////////

BOOL WmiAdapterApp::Exists ( void )
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterApp exists application\n"
				L"*************************************************************\n" );

	////////////////////////////////////////////////////////////////////////
	// smart locking/unlocking
	////////////////////////////////////////////////////////////////////////
	__Smart_CRITICAL_SECTION scs ( const_cast < LPCRITICAL_SECTION> ( &m_cs ) );


	// check instance

	if ( m_hInstance.GetHANDLE() == NULL )
	{
		if ( !pSA.IsEmpty() )
		{
			if ( m_hInstance.SetHANDLE ( ::CreateMutexW ( pSA->GetSecurityAttributtes(), FALSE, g_szAppNameGlobal ) ), m_hInstance.GetHANDLE() != NULL )
			{
				if ( ::GetLastError () == ERROR_ALREADY_EXISTS )
				{
					return TRUE;
				}
			}
			else
			{
				// m_hInstance.GetHANDLE() == NULL
				// something's is very bad return we already exists :))
				return TRUE;
			}
		}
		else
		{
			if ( m_hInstance.SetHANDLE ( ::CreateMutexW ( NULL, FALSE, g_szAppNameGlobal ) ), m_hInstance.GetHANDLE() != NULL )
			{
				if ( ::GetLastError () == ERROR_ALREADY_EXISTS )
				{
					return TRUE;
				}
			}
			else
			{
				// m_hInstance.GetHANDLE() == NULL
				// something's is very bad return we already exists :))
				return TRUE;
			}
		}
	}

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
// INITIALIZATION
///////////////////////////////////////////////////////////////////////////

HRESULT	WmiAdapterApp::InitKill ( void )
{
	HRESULT hRes = S_FALSE;

	try
	{
		if (_App.m_hKill.GetHANDLE() == NULL)
		{
			if ( (	_App.m_hKill =
				::CreateEvent ( ( ((WmiSecurityAttributes*)_App) == NULL ) ?
								NULL :
								((WmiSecurityAttributes*)_App)->GetSecurityAttributtes(),
								TRUE,
								FALSE,
								L"Global\\WmiAdapterKillHandle" ) 
				 ) == NULL )
			{
				// get error
				HRESULT hr = HRESULT_FROM_WIN32 ( ::GetLastError() );

				if FAILED ( hr )
				{
					hRes = hr;
				}
				else
				{
					hRes = E_OUTOFMEMORY;
				}
			}
			else
			{
				hRes = S_OK;
			}
		}
	}
	catch ( ... )
	{
		hRes = HRESULT_FROM_WIN32 ( ERROR_NOT_READY );
	}

	return hRes;
}

HRESULT WmiAdapterApp::InitAttributes ( void )
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterApp initialization of neccessary attributes\n"
				L"*************************************************************\n" );

	////////////////////////////////////////////////////////////////////////
	// smart locking/unlocking
	////////////////////////////////////////////////////////////////////////
	__Smart_CRITICAL_SECTION scs ( &m_cs );

	////////////////////////////////////////////////////////////////////////
	// load resource library
	////////////////////////////////////////////////////////////////////////
	if ( ! m_hResources )
	{
		m_hResources = ::LoadLibraryW ( L"WMIApRes.dll" );
	}

	try
	{
		////////////////////////////////////////////////////////////////////////
		// create Security descriptor
		////////////////////////////////////////////////////////////////////////
		if ( pSA.IsEmpty() && ( pSA.SetData ( new WmiSecurityAttributes() ), pSA.IsEmpty() ) )
		{
			return E_OUTOFMEMORY;
		}

		#ifdef	__SUPPORT_EVENTVWR
		////////////////////////////////////////////////////////////////////////
		// create event log
		////////////////////////////////////////////////////////////////////////
		if ( pEventLog.IsEmpty() && ( pEventLog.SetData( new CPerformanceEventLogBase( L"WMIAdapter" ) ), pEventLog.IsEmpty() ) )
		{
			return E_OUTOFMEMORY;
		}
		#endif	__SUPPORT_EVENTVWR
	}
	catch ( ... )
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT WmiAdapterApp::Init ( void )
{
	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterApp initialization\n"
				L"*************************************************************\n" );

	////////////////////////////////////////////////////////////////////////
	// smart locking/unlocking
	////////////////////////////////////////////////////////////////////////
	__Smart_CRITICAL_SECTION scs ( &m_cs );

	////////////////////////////////////////////////////////////////////////
	// load resource library
	////////////////////////////////////////////////////////////////////////
	if ( ! m_hResources )
	{
		m_hResources = ::LoadLibraryW ( L"WMIApRes.dll" );
	}

	try
	{
		////////////////////////////////////////////////////////////////////////
		// create Security descriptor
		////////////////////////////////////////////////////////////////////////
		if ( pSA.IsEmpty() &&  ( pSA.SetData ( new WmiSecurityAttributes() ), pSA.IsEmpty() ) )
		{
			return E_OUTOFMEMORY;
		}

		////////////////////////////////////////////////////////////////////////
		// create event log
		////////////////////////////////////////////////////////////////////////
		if ( pEventLog.IsEmpty() && ( pEventLog.SetData( new CPerformanceEventLogBase( L"WMIAdapter" ) ), pEventLog.IsEmpty() ) )
		{
			return E_OUTOFMEMORY;
		}

		////////////////////////////////////////////////////////////////////////
		// create stuff
		////////////////////////////////////////////////////////////////////////
		if ( pStuff.IsEmpty() && ( pStuff.SetData( new WmiAdapterStuff( ) ), pStuff.IsEmpty() ) )
		{
			return E_OUTOFMEMORY;
		}
	}
	catch ( ... )
	{
		return E_FAIL;
	}

	#ifdef	__SUPPORT_WAIT
	m_hData = ::CreateEventW(	pSA->GetSecurityAttributtes(),
								TRUE,
								FALSE, 
								L"Global\\WmiAdapterDataReady"
						    );
	#endif	__SUPPORT_WAIT

	if ( ( m_hInit = ::CreateSemaphoreW(	pSA->GetSecurityAttributtes(),
											0L,
											100L,
											L"Global\\WmiAdapterInit"
										)
		 ) == NULL )
	{
		// this is really important to have
		return E_OUTOFMEMORY;
	}

	if ( ( m_hUninit= ::CreateSemaphoreW(	pSA->GetSecurityAttributtes(),
											0L,
											100L,
											L"Global\\WmiAdapterUninit"
										)
		 ) == NULL )
	{
		// this is really important to have
		return E_OUTOFMEMORY;
	}

	///////////////////////////////////////////////////////////////////////////
	// GLOBAL STUFF
	///////////////////////////////////////////////////////////////////////////

	if ( ! g_hRefreshMutex )
	{
		if ( ( g_hRefreshMutex = ::CreateMutex	(
													pSA->GetSecurityAttributtes(),
													FALSE,
													g_szRefreshMutex
												)
			 ) == NULL )
		{
			// this is really important to have
			return E_OUTOFMEMORY;
		}
	}

	if ( ! g_hRefreshMutexLib )
	{
		if ( ( g_hRefreshMutexLib = ::CreateMutex	(
														pSA->GetSecurityAttributtes(),
														FALSE,
														g_szRefreshMutexLib
													)
			 ) == NULL )
		{
			// this is really important to have
			return E_OUTOFMEMORY;
		}
	}

	if ( ! g_hRefreshFlag )
	{
		if ( ( g_hRefreshFlag = ::CreateMutex	(
													pSA->GetSecurityAttributtes(),
													FALSE,
													g_szRefreshFlag
												)
			 ) == NULL )
		{
			// this is really important to have
			return E_OUTOFMEMORY;
		}
	}

	if ( ! g_hDoneWorkEvt )
	{
		if ( ( g_hDoneWorkEvt = ::CreateEvent ( NULL, TRUE, FALSE, NULL ) ) == NULL )
		{
			// this is really important to have
			return E_OUTOFMEMORY;
		}
	}

	if ( ! g_hDoneWorkEvtCIM )
	{
		if ( ( g_hDoneWorkEvtCIM = ::CreateEvent ( NULL, TRUE, FALSE, NULL ) ) == NULL )
		{
			// this is really important to have
			return E_OUTOFMEMORY;
		}
	}

	if ( ! g_hDoneWorkEvtWMI )
	{
		if ( ( g_hDoneWorkEvtWMI = ::CreateEvent ( NULL, TRUE, FALSE, NULL ) ) == NULL )
		{
			// this is really important to have
			return E_OUTOFMEMORY;
		}
	}

	if ( ! g_hDoneInitEvt )
	{
		if ( ( g_hDoneInitEvt = ::CreateEvent ( NULL, TRUE, FALSE, NULL ) ) == NULL )
		{
			// this is really important to have
			return E_OUTOFMEMORY;
		}
	}

	if ( ! g_hDoneLibEvt )
	{
		if ( ( g_hDoneLibEvt = ::CreateEvent ( NULL, TRUE, FALSE, NULL ) ) == NULL )
		{
			// this is really important to have
			return E_OUTOFMEMORY;
		}
	}

	InitializeCriticalSection (&g_cs);
	InitializeCriticalSection (&g_csWMI);
	InitializeCriticalSection (&g_csInit);

	return S_OK;
}

void WmiAdapterApp::Term ( void )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\oledb\test\main.cpp ===
#define _WIN32_DCOM
#include <stdio.h>


#include <wbemcli.h>


void main(int argc, char **argv)
{

	HRESULT hRes;
	IWbemLocator *pLoc = 0;
	IWbemServices *pIWbemServices  = NULL;
	IWbemClassObject *pSamp = NULL;

	// Initialize OLE libraries    
   	CoInitializeEx(0, COINIT_MULTITHREADED);     

    CoInitializeSecurity(NULL, -1, NULL, NULL,
        RPC_C_AUTHN_LEVEL_CONNECT, 
        RPC_C_IMP_LEVEL_IDENTIFY, 
        NULL, EOAC_NONE, 0
        );

    DWORD dwRes = CoCreateInstance(CLSID_WbemLocator, 0, 
        CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pLoc);
 
    if (dwRes != S_OK)
    {
        printf("Failed to create IWbemLocator object.\n");
        CoUninitialize();
        return;
    }

	BSTR NameSpace = SysAllocString(L"ROOT\\WMI");

    // Connect to the Root\Default namespace with current user
    hRes = pLoc->ConnectServer(
			NameSpace,
            NULL,
            NULL,
            0,                                  
            NULL,
            0,                                  
            0,                                  
            &pIWbemServices
            );
	
    if (hRes)
    {
        printf("Could not connect. Error code = 0x%X\n", hRes);
        CoUninitialize();
		SysFreeString( NameSpace);
        return;
    }

	hRes = CoSetProxyBlanket( pIWbemServices,
							  RPC_C_AUTHN_WINNT,
							  RPC_C_AUTHN_NONE,
							  NULL,
							  RPC_C_AUTHN_LEVEL_CONNECT,
							  RPC_C_IMP_LEVEL_IMPERSONATE,
							  NULL,
							  EOAC_NONE );
	if ( hRes)
	{
		printf("\nCould not initialize authenciation level:  %x", hRes);
		CoUninitialize();
		return;
	}
    printf("Success: Connected to Namespace = %S\n",NameSpace);
	BSTR ObjectPath = SysAllocString(
			L"WmiSampleClass1.InstanceName=\"WMISamp\"");
			//L"MSPower_DeviceEnable.InstanceName=\"[0000]Intel 8255x-based PCI Ethernet Adapter (10/100)\"");
			//L"MSPower_DeviceEnable.InstanceName=\"Root\\\\MS_NDISWANIP\\\\0000_0\"");

	hRes = pIWbemServices->GetObject( ObjectPath, 0, NULL,&pSamp, NULL );
	if ( hRes == WBEM_NO_ERROR ){

		for( int Count = 0; Count < 15000; Count++ ){

			hRes = pIWbemServices->PutInstance( pSamp, 0,NULL,NULL );
			if( hRes != WBEM_NO_ERROR )	{
				printf("\nUnable to save instance: %x", hRes);
				break;
			}
			printf(".");

		}
		pSamp->Release();
		pSamp = NULL;
		Sleep(1000);
	}
	SysFreeString( ObjectPath );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_adapter.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_adapter.cpp
//
//	Abstract:
//
//					Defines the entry point for the DLL application.
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "WMI_adapter.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

////////////////////////////////////////////////////////////////////////////////////
// variables
////////////////////////////////////////////////////////////////////////////////////

#include "wmi_adapter_wrapper.h"
__WrapperPtr<WmiAdapterWrapper>		pWrapper;

#include "wmi_eventlog.h"
__WrapperPtr<CPerformanceEventLog>	pEventLog;

#include "wmi_security.h"
#include "wmi_security_attributes.h"
__WrapperPtr<WmiSecurityAttributes>	pSA;

#include "WMI_adapter_registry.h"

// save instance
HMODULE g_hModule		= NULL;

#ifdef	__SUPPORT_ICECAP
#include <icecap.h>
#endif	__SUPPORT_ICECAP

#include <wmiaplog.h>

#include ".\\WMIAdapter_Refresh\\RefresherGenerate.H"

////////////////////////////////////////////////////////////////////////////////////
// dll main
////////////////////////////////////////////////////////////////////////////////////

BOOL APIENTRY DllMain( HANDLE hModule, DWORD  dwReason, LPVOID )
{
    switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
		{
			AdapterLogMessage0 ( L"DllMain -> DLL_PROCESS_ATTACH" );

//			if ( !lpReserved )
//			{
//				// loaded dynamic
//			}
//			else
//			{
//				// loaded static
//			}

			// disable attach/detach of threads
			::DisableThreadLibraryCalls ( (HMODULE) hModule );

			BOOL bResult = FALSE;

			try
			{
				// event log initialization
				pEventLog.SetData( new CPerformanceEventLog( L"WmiAdapter" ) );

				pSA.SetData ( new WmiSecurityAttributes() );
				if ( ! pSA.IsEmpty() )
				{
					if ( pSA->GetSecurityAttributtes () )
					{
						pWrapper.SetData( new WmiAdapterWrapper() );
						if ( ! pWrapper.IsEmpty() )
						{
							bResult = TRUE;
						}
					}
				}
			}
			catch ( ... )
			{
			}

			if ( bResult )
			{
				g_hModule		= ( HMODULE ) hModule;
			}

			return bResult;
		}
		break;

		case DLL_PROCESS_DETACH:
		{
			AdapterLogMessage0 ( L"DllMain -> DLL_PROCESS_DETACH" );

//			if ( !lpReserved )
//			{
//				// unloaded by FreeLibrary
//			}
//			else
//			{
//				// unloaded by end of proccess
//			}

			// delete event log
			if ( !pEventLog.IsEmpty() )
			{
				delete  pEventLog.Detach();
			}

			// delete perflib wrapper
			delete pWrapper.Detach ();

			// delete security attributes
			delete pSA.Detach();

			#ifdef	_DEBUG
			_CrtDumpMemoryLeaks();
			#endif	_DEBUG
		}
		break;

		// thread attaching is not used !!!
		case DLL_THREAD_ATTACH: break;
		case DLL_THREAD_DETACH: break;
    }

	AdapterLogMessage1 ( L"DllMain", 1 );
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
// registration of perflib dll
////////////////////////////////////////////////////////////////////////////////////
EXTERN_C HRESULT __stdcall DllRegisterServer ( )
{
	if ( ::GetModuleFileNameW ( g_hModule, g_szPath, sizeof ( WCHAR ) * ( _MAX_PATH ) ) )
	{
		HRESULT hr = S_OK;

		if SUCCEEDED ( hr = WmiAdapterRegistry::__UpdateRegistrySZ( true ) )
		{
			hr = DoReverseAdapterMaintenanceInternal ( FALSE, Registration );
		}

		return hr;
	}

	return HRESULT_FROM_WIN32 ( ::GetLastError() );
}

////////////////////////////////////////////////////////////////////////////////////
// unregistration of perflib dll
////////////////////////////////////////////////////////////////////////////////////
EXTERN_C HRESULT __stdcall DllUnregisterServer ( void )
{
	HRESULT hr = S_OK;

	if SUCCEEDED ( hr = DoReverseAdapterMaintenanceInternal ( FALSE, UnRegistration ) )
	{
		hr = WmiAdapterRegistry::__UpdateRegistrySZ( false );
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
// exported functions ( PERFORMANCE )
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

DWORD __stdcall WmiOpenPerfData	(	LPWSTR lpwszDeviceNames )
{
	#ifdef	__SUPPORT_ICECAP
	StartProfile ( PROFILE_GLOBALLEVEL, PROFILE_CURRENTID );
	#endif	__SUPPORT_ICECAP

	AdapterLogMessage0 ( L"WmiOpenPerfData" );
	return pWrapper->Open ( lpwszDeviceNames );
}

DWORD __stdcall WmiClosePerfData	()
{
	#ifdef	__SUPPORT_ICECAP
	StopProfile ( PROFILE_GLOBALLEVEL, PROFILE_CURRENTID );
	#endif	__SUPPORT_ICECAP

	AdapterLogMessage0 ( L"WmiClosePerfData" );
	return pWrapper->Close ( );
}

DWORD __stdcall WmiCollectPerfData	(	LPWSTR lpwszValue, 
										LPVOID *lppData, 
										LPDWORD lpcbBytes, 
										LPDWORD lpcbObjectTypes
									)
{
	return pWrapper->Collect ( lpwszValue, lppData, lpcbBytes, lpcbObjectTypes );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_adapter_wrapper.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_adapter_wrapper.cpp
//
//	Abstract:
//
//					Defines wrapper for performance lib
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

// event messages
#include "wmiadaptermessages.h"
// event log helpers
#include "wmi_eventlog.h"

//security helper
#include "wmi_security.h"
#include "wmi_security_attributes.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// definitions
#include "WMI_adapter_wrapper.h"
#include "WMI_adapter_ObjectList.h"

// registry helpers
#include "wmi_perf_reg.h"

// shared memory
#include "wmi_reverse_memory.h"
#include "wmi_reverse_memory_ext.h"

extern LPCWSTR	g_szKey;
extern LPCWSTR	g_szKeyValue;

#ifndef	__WMI_PERF_REGSTRUCT__
#include "wmi_perf_regstruct.h"
#endif	__WMI_PERF_REGSTRUCT__

#include "RefresherUtils.h"

DWORD	GetCount ( LPCWSTR wszKey, LPCWSTR wszKeyValue )
{
	DWORD				dwResult	= 0L;
	PWMI_PERFORMANCE	p			= NULL;

	if SUCCEEDED ( GetRegistry ( wszKey, wszKeyValue, (BYTE**) &p ) )
	{
		try
		{
			if ( p )
			{
				PWMI_PERF_NAMESPACE n		= NULL;
				DWORD				dwCount	= 0L;

				// get namespace
				n = __Namespace::First ( p );

				// count num of supported objects ( first dword )
				for ( DWORD  dw = 0; dw < p->dwChildCount; dw++ )
				{
					dwCount += n->dwChildCount;
					n = __Namespace::Next ( n );
				}

				delete [] p;
				p = NULL;

				dwResult = dwCount;
			}
		}
		catch ( ... )
		{
			if ( p )
			{
				delete [] p;
				p = NULL;
			}

			dwResult = 0L;
		}
	}

	return dwResult;
}

////////////////////////////////////////////////////////////////////////////////////
// variables & macros
////////////////////////////////////////////////////////////////////////////////////

extern __WrapperPtr<CPerformanceEventLog>	pEventLog;
extern __WrapperPtr<WmiSecurityAttributes>	pSA;

#ifdef	_DEBUG
#define	_EVENT_MSG
#endif	_DEBUG

extern	LPCWSTR	g_szRefreshMutexLib;

////////////////////////////////////////////////////////////////////////////////////
// construction
////////////////////////////////////////////////////////////////////////////////////

WmiAdapterWrapper::WmiAdapterWrapper ( ):
m_lUseCount ( 0 ),

m_pData ( NULL ),
m_dwData ( 0 ),
m_dwDataOffsetCounter ( 0 ),
m_dwDataOffsetValidity ( 0 ),

m_dwPseudoCounter ( 0 ),
m_dwPseudoHelp ( 0 ),

m_bRefresh ( FALSE )

{
	::InitializeCriticalSection ( &m_pCS );

	////////////////////////////////////////////////////////////////////////////
	// connection to service manager
	////////////////////////////////////////////////////////////////////////////
	if ( ( hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS) ) == NULL )
	{
		if ( ::GetLastError () != ERROR_ACCESS_DENIED )
		{
			ReportEvent ( EVENTLOG_ERROR_TYPE, WMI_ADAPTER_OPEN_SCM_FAIL );
		}
	}

	m_hRefresh= ::CreateMutex	(
									pSA->GetSecurityAttributtes(),
									FALSE,
									g_szRefreshMutexLib
								);
}

////////////////////////////////////////////////////////////////////////////////////
// destruction
////////////////////////////////////////////////////////////////////////////////////

WmiAdapterWrapper::~WmiAdapterWrapper ( )
{
	::DeleteCriticalSection ( &m_pCS );
}

////////////////////////////////////////////////////////////////////////////////////
// exported functions
////////////////////////////////////////////////////////////////////////////////////

// open ( synchronized by perf app )
DWORD	WmiAdapterWrapper::Open	( LPWSTR )
{
	// returned error
	DWORD			dwResult = ERROR_ACCESS_DENIED;
	__SmartHANDLE	hInitEvent;

	if (! m_lUseCount)
	{
		try
		{
			////////////////////////////////////////////////////////////////////////////
			// connection to worker service
			////////////////////////////////////////////////////////////////////////////
			if ( hSCM.GetHANDLE() != NULL )
			{
				__SmartServiceHANDLE hService;
				if ( ( hService = ::OpenServiceW ( hSCM.GetHANDLE(), L"WMIApSrv", SERVICE_QUERY_STATUS | SERVICE_START ) ) != NULL)
				{
					SERVICE_STATUS s;
					if ( ::QueryServiceStatus ( hService, &s ) )
					{
						if ( s.dwCurrentState == SERVICE_STOPPED ||
							 s.dwCurrentState == SERVICE_PAUSED )
						{
							// start service
							if ( ! ::StartService ( hService, NULL, NULL ) )
							{
								// unable to open service
								DWORD dwError = ERROR_SUCCESS;
								dwError = ::GetLastError();

								if ( ERROR_SERVICE_ALREADY_RUNNING != dwError )
								{
									if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
									{
										if ( dwError != ERROR_ACCESS_DENIED )
										{
											ReportEvent ( EVENTLOG_ERROR_TYPE, WMI_ADAPTER_OPEN_SC_FAIL );
										}

										dwResult = dwError;
									}
									else
									{
										dwResult = static_cast < DWORD > ( E_FAIL );
									}
								}
								else
								{
									dwResult = ERROR_SUCCESS;
								}
							}
							else
							{
								dwResult = ERROR_SUCCESS;
							}
						}
						else
						{
							dwResult = ERROR_SUCCESS;
						}
					}
					else
					{
						// unable to open service
						DWORD dwError = ERROR_SUCCESS;
						dwError = ::GetLastError();

						if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
						{
							if ( dwError != ERROR_ACCESS_DENIED )
							{
								ReportEvent ( EVENTLOG_ERROR_TYPE, WMI_ADAPTER_OPEN_SC_FAIL );
							}

							dwResult = dwError;
						}
						else
						{
							dwResult = static_cast < DWORD > ( E_FAIL );
						}
					}
				}
				else
				{
					// unable to open service
					DWORD dwError = ERROR_SUCCESS;
					dwError = ::GetLastError();

					if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
					{
						if ( dwError != ERROR_ACCESS_DENIED )
						{
							ReportEvent ( EVENTLOG_ERROR_TYPE, WMI_ADAPTER_OPEN_SC_FAIL );
						}

						dwResult = dwError;
					}
					else
					{
						dwResult = static_cast < DWORD > ( E_FAIL );
					}
				}
			}
			else
			{
				// unable to operate with service
				dwResult =  static_cast < DWORD > ( ERROR_NOT_READY );
			}

			if SUCCEEDED ( HRESULT_FROM_WIN32 ( dwResult ) )
			{
				if ( ( hInitEvent = ::CreateSemaphore	(	pSA->GetSecurityAttributtes(),
															0L,
															100L, 
															L"Global\\WmiAdapterInit"
														)
					 ) != NULL
				   )
				{
					if ( hInitEvent.GetHANDLE() != INVALID_HANDLE_VALUE )
					{
						if ( ! ::ReleaseSemaphore( hInitEvent, 1, NULL ) )
						{
							DWORD dwError = ERROR_SUCCESS;
							dwError = ::GetLastError ();

							if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
							{
								dwResult = dwError;
							}
							else
							{
								dwResult = static_cast < DWORD > ( E_FAIL );
							}
						}
					}
				}
				else
				{
					DWORD dwError = ERROR_SUCCESS;
					dwError = ::GetLastError ();

					if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
					{
						dwResult = dwError;
					}
					else
					{
						dwResult = static_cast < DWORD > ( E_FAIL );
					}
				}

				if SUCCEEDED ( HRESULT_FROM_WIN32 ( dwResult ) )
				{
					DWORD dwStart	= 0;
					DWORD dwEnd		= 0;

					DWORD	dwWait	= 0L;
					DWORD	dwTime	= 0L;

					SYSTEMTIME st;
					::GetSystemTime ( &st );

					dwStart	= ( DWORD ) st.wMilliseconds;

					////////////////////////////////////////////////////////////////////////
					// connect to shared memory
					////////////////////////////////////////////////////////////////////////
					m_pMem.MemCreate	(
											L"Global\\WmiReverseAdapterMemory",
											pSA->GetSecurityAttributtes()
										);

					if ( m_pMem.MemCreate ( 4096 ), ( m_pMem.IsValid () && m_pMem.GetMemory ( 0 ) ) )
					{
						ATLTRACE (	L"*************************************************************\n"
									L"PERFLIB connected to shared memory\n"
									L"*************************************************************\n" );

						// get count of all memories
						DWORD cbCount		= 0L;
						cbCount = MemoryCountGet ();
						MemoryCountSet ( 1 + cbCount );

						DWORD	dwCount = 0L;
						dwCount = GetCount	(
												g_szKey,
												g_szKeyValue
											);

						::GetSystemTime ( &st );

						dwEnd	= ( DWORD ) st.wMilliseconds;
						dwTime	= ( dwEnd - dwStart ) + 5;

						dwWait = 150 *  ( ( dwCount ) ? dwCount : 1 );

						#ifdef	__SUPPORT_WAIT
						// wait if we are ready now
						if ( ( m_hReady = ::CreateEvent	(	pSA->GetSecurityAttributtes(),
															TRUE,
															FALSE, 
															L"Global\\WmiAdapterDataReady"
														)
							 ) != NULL
						   )
						{
							if ( !cbCount && ( dwTime < dwWait ) )
							{
								::WaitForSingleObject (
														m_hReady,
														( ( dwWait < 5000 ) ? dwWait : 5000 ) - dwTime
													  );
							}
						}
						else
						{
						#else	__SUPPORT_WAIT
						if ( !cbCount && ( dwTime < dwWait ) )
						{
							::Sleep ( ( ( dwWait < 5000 ) ? dwWait : 5000 ) - dwTime );
						}
						#endif	__SUPPORT_WAIT
						#ifdef	__SUPPORT_WAIT
						}
						#endif	__SUPPORT_WAIT

						////////////////////////////////////////////////////////////////////
						// create pseudo counter memory
						////////////////////////////////////////////////////////////////////
						PseudoCreate();

						////////////////////////////////////////////////////////////////////
						// SUCCESS
						////////////////////////////////////////////////////////////////////
						#ifdef	_EVENT_MSG
						ReportEvent	( EVENTLOG_INFORMATION_TYPE, WMI_PERFLIB_OPEN_SUCCESS );
						#endif	_EVENT_MSG

						InterlockedIncrement(&m_lUseCount);
					}
					else
					{
						DWORD dwError = ERROR_SUCCESS;
						dwError = ::GetLastError();

						if ( dwError != ERROR_ACCESS_DENIED )
						{
							////////////////////////////////////////////////////////////////
							// unable to connect into shared meory
							////////////////////////////////////////////////////////////////

							ReportEvent (
											EVENTLOG_ERROR_TYPE,
											WMI_ADAPTER_SHARED_FAIL
										) ;
							ReportEvent (
											(DWORD)E_OUTOFMEMORY,
											EVENTLOG_ERROR_TYPE,
											WMI_ADAPTER_SHARED_FAIL_STRING
										) ;
						}

						if FAILED ( HRESULT_FROM_WIN32 ( dwError ) )
						{
							dwResult = dwError;
						}
						else
						{
							dwResult = static_cast < DWORD > ( HRESULT_TO_WIN32 ( E_OUTOFMEMORY ) ) ;
						}
					}
				}
			}
		}
		catch ( ... )
		{
			////////////////////////////////////////////////////////////////////////
			// FAILURE
			////////////////////////////////////////////////////////////////////////
			dwResult =  static_cast < DWORD > ( ERROR_NOT_READY );
		}

		if FAILED ( HRESULT_FROM_WIN32 ( dwResult ) )
		{
			CloseLib ( ( hInitEvent.GetHANDLE() != NULL ) );
		}
	}

	return dwResult;
}

// close ( synchronized by perf app )
DWORD	WmiAdapterWrapper::Close ( void )
{
	if (m_lUseCount && ! (InterlockedDecrement (&m_lUseCount)))
	{
		CloseLib ();

		////////////////////////////////////////////////////////////////////////////
		// SUCCESS
		////////////////////////////////////////////////////////////////////////////
		#ifdef	_EVENT_MSG
		ReportEvent	( EVENTLOG_INFORMATION_TYPE, WMI_PERFLIB_CLOSE_SUCCESS );
		#endif	_EVENT_MSG
	}

	return static_cast < DWORD > ( ERROR_SUCCESS );
}

void	WmiAdapterWrapper::CloseLib ( BOOL bInit )
{
	if ( hSCM.GetHANDLE() != NULL )
	{
		////////////////////////////////////////////////////////////////////////
		// pseudo counter
		////////////////////////////////////////////////////////////////////////
		PseudoDelete ();

		////////////////////////////////////////////////////////////////////////////
		// destroy shared memory
		////////////////////////////////////////////////////////////////////////////
		try
		{
			if ( m_pMem.IsValid() && m_pMem.GetMemory ( 0 ) )
			{
				// get count of all memories
				DWORD cbCount  = 0L;
				if ( ( cbCount = MemoryCountGet () ) != 0 )
				{
					MemoryCountSet ( cbCount - 1 );
				}
			}
		}
		catch ( ... )
		{
		}

		if ( m_pMem.IsValid() )
		{
			m_pMem.MemDelete();
		}

		if ( bInit )
		{
			// server stop of refreshing
			__SmartHANDLE hUninitEvent;
			if ( ( hUninitEvent = ::CreateSemaphore	(	pSA->GetSecurityAttributtes(),
														0L,
														100L, 
														L"Global\\WmiAdapterUninit"
													)
				 ) != NULL
			   )
			{
				if ( hUninitEvent.GetHANDLE() != INVALID_HANDLE_VALUE )
				{
					::ReleaseSemaphore( hUninitEvent, 1, NULL );
				}
			}
		}
	}

	return;
}

// collect ( synchronized )
DWORD	WmiAdapterWrapper::Collect	(	LPWSTR lpwszValues,
										LPVOID*	lppData,
										LPDWORD	lpcbBytes,
										LPDWORD	lpcbObjectTypes
									)
{
	DWORD dwResult = ERROR_SUCCESS;

	if ( ::TryEnterCriticalSection ( &m_pCS ) )
	{
		if ( lpwszValues && ( m_pMem.IsValid () && m_pMem.GetMemory ( 0 ) ) )
		{
			LPVOID pStart = *lppData;

			try
			{
				DWORD dwWaitResult = 0L;
				dwWaitResult = ::WaitForSingleObject ( m_hRefresh, 0 );

				BOOL	bOwnMutex	= FALSE;
				BOOL	bRefresh	= FALSE;
				BOOL	bCollect	= FALSE;

				switch ( dwWaitResult )
				{
					case WAIT_OBJECT_0:
					{
						bOwnMutex	= TRUE;
						bCollect	= TRUE;
						break;
					}

					case WAIT_TIMEOUT:
					{
						// we are refreshing
						m_bRefresh	= TRUE;

						bRefresh	= TRUE;
						bCollect	= TRUE;
						break;
					}
					default:
					{
						(*lpcbBytes)		= 0;
						(*lpcbObjectTypes)	= 0;
						break;
					}
				}

				if ( bCollect )
				{
					#ifdef	__SUPPORT_WAIT
					if ( !m_bRefresh )
					{
						dwWaitResult = ::WaitForSingleObject ( m_hReady, 0 );
						if ( dwWaitResult == WAIT_TIMEOUT )
						{
							m_bRefresh = TRUE;
						}
					}
					#endif	__SUPPORT_WAIT

					////////////////////////////////////////////////////////////////////
					// main collect
					////////////////////////////////////////////////////////////////////
					dwResult = CollectObjects	(
												lpwszValues,
												lppData,
												lpcbBytes,
												lpcbObjectTypes
												);

					if ( bOwnMutex )
					{
						::ReleaseMutex ( m_hRefresh );
					}

					if ( bRefresh && dwResult == ERROR_SUCCESS )
					{
						m_bRefresh = bRefresh;
					}
				}
			}
			catch ( ... )
			{
				(*lppData)			= pStart;
				(*lpcbBytes)		= 0;
				(*lpcbObjectTypes)	= 0;
			}
		}
		else
		{
			(*lpcbBytes)		= 0;
			(*lpcbObjectTypes)	= 0;
		}

		::LeaveCriticalSection ( &m_pCS );
	}
	else
	{
		(*lpcbBytes)		= 0;
		(*lpcbObjectTypes)	= 0;
	}

	return dwResult;
}

DWORD	WmiAdapterWrapper::CollectObjects	(	LPWSTR lpwszValues,
												LPVOID*	lppData,
												LPDWORD	lpcbBytes,
												LPDWORD	lpcbObjectTypes
											)
{ 
	if ( m_bRefresh )
	{
		////////////////////////////////////////////////////////////////////////////////
		// is it big enough
		////////////////////////////////////////////////////////////////////////////////
		if ( ( *lpcbBytes ) < m_dwData )
		{
			// too small
			( * lpcbBytes )			= 0;
			( * lpcbObjectTypes )	= 0;

			return static_cast < DWORD > ( ERROR_MORE_DATA );
		}

		( * lpcbBytes )			= 0;
		( * lpcbObjectTypes )	= 0;

		// fill pseudo counter with valid data if exists
		if ( m_pData )
		{
			// recreate pseudo buffer
			if ( ( PseudoCreateRefresh () ) == S_OK )
			{
				memcpy ( ( * lppData ), m_pData, m_dwData );

				( * lpcbBytes )			= m_dwData;
				( * lpcbObjectTypes )	= 1;

				( * lppData )	= reinterpret_cast<PBYTE>
								( reinterpret_cast<PBYTE> ( * lppData ) + m_dwData );
			}
		}

		m_bRefresh = FALSE;
	}
	else
	{
		// get size of table
		DWORD dwOffsetBegin	= TableOffsetGet();
		// get size of all memory
		DWORD cbBytes		= RealSizeGet();

		////////////////////////////////////////////////////////////////////////////////
		// is it big enough
		////////////////////////////////////////////////////////////////////////////////
		if ( ( *lpcbBytes ) < cbBytes + m_dwData )
		{
			// too small
			( * lpcbBytes )			= 0;
			( * lpcbObjectTypes )	= 0;

			return static_cast < DWORD > ( ERROR_MORE_DATA );
		}

		////////////////////////////////////////////////////////////////////////////////
		// are data ready
		////////////////////////////////////////////////////////////////////////////////
		if ( ( dwOffsetBegin == (DWORD) -1 ) || ! cbBytes )
		{
			// fill pseudo counter with valid data if exists
			if ( m_pData )
			{
				PseudoRefresh ( 0 );
				PseudoRefresh ( FALSE );

				memcpy ( ( * lppData ), m_pData, m_dwData );

				( * lpcbBytes )			= m_dwData;
				( * lpcbObjectTypes )	= 1;

				( * lppData )	= reinterpret_cast<PBYTE>
								( reinterpret_cast<PBYTE> ( * lppData ) + m_dwData );
			}
			else
			{
				( * lpcbBytes )			= 0;
				( * lpcbObjectTypes )	= 0;
			}

			return static_cast < DWORD > ( ERROR_SUCCESS );
		}

		////////////////////////////////////////////////////////////////////////////////
		// do they want all countres
		////////////////////////////////////////////////////////////////////////////////
		if ( lstrcmpiW ( L"GLOBAL", lpwszValues ) == 0 )
		{
			//first and default values
			( * lpcbBytes )			= 0;
			( * lpcbObjectTypes )	= 0;

			BYTE* pData = NULL;
			pData = reinterpret_cast < PBYTE > ( * lppData );

			DWORD	dwCount		= 0L;
			dwCount = CountGet();

			// fill pseudo counter with valid data if exists
			if ( m_pData )
			{
				PseudoRefresh ( dwCount );
				PseudoRefresh ( );

				memcpy ( ( * lppData ), m_pData, m_dwData );

				( * lpcbBytes )			= m_dwData;
				( * lpcbObjectTypes )	= 1;

				( * lppData )	= reinterpret_cast<PBYTE>
								( reinterpret_cast<PBYTE> ( * lppData ) + m_dwData );
			}

			// fill rest of counters if possible
			if ( ! m_pMem.Read( (BYTE*) ( *lppData ),	// buffer
								cbBytes,				// size I want to read
								dwOffsetBegin			// offset from to read
							  )
			   )
			{
				HRESULT hrTemp = E_FAIL;
				hrTemp = MemoryGetLastError( dwOffsetBegin );

				if FAILED ( hrTemp ) 
				{
					ReportEvent (	( DWORD ) hrTemp,
									EVENTLOG_ERROR_TYPE,
									WMI_ADAPTER_SHARED_FAIL_READ_SZ ) ;
				}
				else
				{
					ReportEvent (	( DWORD ) E_FAIL,
									EVENTLOG_ERROR_TYPE,
									WMI_ADAPTER_SHARED_FAIL_READ_SZ ) ;
				}

				if ( m_pData )
				{
					PseudoRefresh ( FALSE );
					memcpy ( pData, m_pData, m_dwData );
				}
			}
			else
			{
				( * lpcbBytes )			= ( * lpcbBytes ) + cbBytes;
				( * lpcbObjectTypes )	= ( * lpcbObjectTypes ) + dwCount;

				( * lppData )	= reinterpret_cast<PBYTE>
								( reinterpret_cast<PBYTE> ( * lppData ) + cbBytes );
			}
		}

		////////////////////////////////////////////////////////////////////////////////
		// do they want just some of them
		////////////////////////////////////////////////////////////////////////////////
		else
		{
			//first and default values
			( * lpcbBytes )			= 0;
			( * lpcbObjectTypes )	= 0;

			// they are asking for objects :))
			WmiAdapterObjectList list ( lpwszValues );

			BYTE* pData = NULL;
			pData = reinterpret_cast < PBYTE > ( * lppData );

			BOOL bFailure = FALSE;

			DWORD	dwCount		= 0L;
			dwCount = CountGet();

			if ( list.IsInList ( m_dwPseudoCounter ) )
			{
				if ( m_pData )
				{
					PseudoRefresh ( dwCount );
					PseudoRefresh ( );

					memcpy ( ( * lppData ), m_pData, m_dwData );

					( * lpcbBytes )			= m_dwData;
					( * lpcbObjectTypes )	= 1;

					( * lppData )	= reinterpret_cast<PBYTE>
									( reinterpret_cast<PBYTE> ( * lppData ) + m_dwData );
				}
			}

			for ( DWORD dw = 0; dw < dwCount; dw++ )
			{
				if ( list.IsInList ( GetCounter ( dw ) ) )
				{
					if ( GetValidity ( dw ) != (DWORD) -1 )
					{
						DWORD dwSize	= 0;
						DWORD dwOffset	= 0;

						dwOffset = GetOffset ( dw );

						// don't forget we have a table :))
						dwOffset += dwOffsetBegin;

						// get size we want
						if ( m_pMem.Read ( ( BYTE* ) &dwSize, sizeof ( DWORD ), dwOffset ) )
						{
							// set memory
							if ( m_pMem.Read ( ( BYTE* ) ( *lppData ), dwSize, dwOffset ) )

							{
								( *lpcbBytes ) += dwSize;
								( *lpcbObjectTypes ) ++;

								( * lppData )	= reinterpret_cast<PBYTE>
												( reinterpret_cast<PBYTE> ( * lppData ) + dwSize );
							}
							else
							{
								bFailure = TRUE;
							}
						}
						else
						{
							bFailure = TRUE;
						}

						if ( bFailure )
						{
							ReportEvent (	( DWORD ) E_FAIL,
											EVENTLOG_ERROR_TYPE,
											WMI_ADAPTER_SHARED_FAIL_READ_SZ ) ;

							if ( m_pData )
							{
								PseudoRefresh ( FALSE );
								memcpy ( pData, m_pData, m_dwData );

								( * lppData )	= reinterpret_cast<PBYTE>
												( pData + m_dwData );
							}
							else
							{
								( * lpcbBytes )			= 0;
								( * lpcbObjectTypes )	= 0;

								( * lppData )			= pData;
							}

							break;
						}
					}
				}
			}
		}
	}

	return static_cast < DWORD > ( ERROR_SUCCESS );
}

////////////////////////////////////////////////////////////////////////////////////
// helper functions
////////////////////////////////////////////////////////////////////////////////////

// report event
BOOL WmiAdapterWrapper::ReportEvent (	WORD	wType,
										DWORD	dwEventID,
										WORD	wStrings,
										LPWSTR*	lpStrings
									)
{
	BOOL bResult = FALSE;

	try
	{
		if ( pEventLog )
		{
			bResult = pEventLog->ReportEvent ( wType, 0, dwEventID, wStrings, 0, (LPCWSTR*) lpStrings, 0 );
		}
	}
	catch ( ... )
	{
		bResult = FALSE;
	}

	return bResult;
}

// report event
BOOL WmiAdapterWrapper::ReportEvent ( DWORD dwError, WORD wType, DWORD dwEventSZ )
{
	LPWSTR wszError = NULL ;
	wszError = GetErrorMessageSystem ( dwError ) ;

	WCHAR wsz[_MAX_PATH]  = { L'\0' };
	LPWSTR ppwsz[1] = { NULL };

	if ( wszError && ( lstrlenW ( wszError ) + 1 ) < _MAX_PATH - 50 )
	{
		try
		{
			wsprintfW	( wsz,	L"\n Error code :\t0x%x"
								L"\n Error description :\t%s\n", dwError, wszError
						) ;

			delete ( wszError );
		}
		catch ( ... )
		{
			delete ( wszError );
			return FALSE;
		}
	}
	else
	{
		try
		{
			wsprintfW	( wsz,	L"\n Error code :\t0x%x"
								L"\n Error description :\t unspecified error \n", dwError
						) ;
		} 
		catch ( ... )
		{
			return FALSE;
		}
	}

	ppwsz[0] = wsz;
	return ReportEvent ( wType, dwEventSZ, 1, ppwsz ) ;
}

///////////////////////////////////////////////////////////////////////////
// get object properties from ord
///////////////////////////////////////////////////////////////////////////

DWORD	WmiAdapterWrapper::GetCounter ( DWORD dwOrd )
{
	DWORD dwResult = 0L;
	dwResult = static_cast < DWORD > ( -1 );

	if ( IsValidOrd ( dwOrd ) )
	{
		DWORD dwOffset	= 0L;
		DWORD dwIndex	= 0L;

		dwOffset = offsetObject1 + ( dwOrd * ( ObjectSize1 ) + offCounter1 );

		m_pMem.Read ( &dwResult, sizeof ( DWORD ), dwOffset );
	}

	return dwResult;
}

DWORD	WmiAdapterWrapper::GetOffset ( DWORD dwOrd )
{
	DWORD dwResult = 0L;
	dwResult = static_cast < DWORD > ( -1 );

	if ( IsValidOrd ( dwOrd ) )
	{
		DWORD dwOffset	= 0L;
		DWORD dwIndex	= 0L;

		dwOffset = offsetObject1 + ( dwOrd * ( ObjectSize1 ) + offOffset1 );

		m_pMem.Read ( &dwResult, sizeof ( DWORD ), dwOffset );
	}

	return dwResult;
}

DWORD	WmiAdapterWrapper::GetValidity ( DWORD dwOrd )
{
	DWORD dwResult = 0L;
	dwResult = static_cast < DWORD > ( -1 );

	if ( IsValidOrd ( dwOrd ) )
	{
		DWORD dwOffset	= 0L;
		DWORD dwIndex	= 0L;

		dwOffset = offsetObject1 + ( dwOrd * ( ObjectSize1 ) + offValidity1 );

		m_pMem.Read ( &dwResult, sizeof ( DWORD ), dwOffset );
	}

	return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_stuff_refresh.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMIAdapter_Stuff_Refresh.cpp
//
//	Abstract:
//
//					module for refersh stuff ( WMI refresh HELPER )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////


#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "WMIAdapter_Stuff.h"

extern LPCWSTR g_szNamespace1;
extern LPCWSTR g_szNamespace2;

enum NamespaceIn
{
	CIMV2,
	WMI,
	UNKNOWN
};

///////////////////////////////////////////////////////////////////////////////
// performance refreshing CLASS
///////////////////////////////////////////////////////////////////////////////
template < class WmiRefreshParent >
class WmiRefresh
{
	DECLARE_NO_COPY ( WmiRefresh );

	WmiRefreshParent*	parent;

	// variables
	IWbemRefresher*				m_pRefresher;		// A pointer to the refresher
	IWbemConfigureRefresher*	m_pConfig;			// A pointer to the refresher's manager

	__WrapperARRAY< WmiRefresherMember < IWbemHiPerfEnum >* >	m_Enums;	// enumerators
	__WrapperARRAY< WmiRefreshObject* >							m_Provs;	// providers ( handles )

	DWORD m_dwCount;

	public:

	WmiRefresh  ( WmiRefreshParent* pParent );
	~WmiRefresh ();

	HRESULT DataInit();
	HRESULT	DataUninit();

	///////////////////////////////////////////////////////////////////////////
	// accessors
	///////////////////////////////////////////////////////////////////////////
	__WrapperARRAY< WmiRefresherMember < IWbemHiPerfEnum >* >&	GetEnums ()
	{
		return m_Enums;
	}

	__WrapperARRAY< WmiRefreshObject* >	&						GetProvs ()
	{
		return m_Provs;
	}

	///////////////////////////////////////////////////////////////////////////
	// real refreshing stuff
	///////////////////////////////////////////////////////////////////////////
	HRESULT	Refresh ( void )
	{
		try
		{
			if  ( m_pRefresher )
			{
				return m_pRefresher->Refresh ( 0L );
			}
			else
			{
				return E_FAIL;
			}
		}
		catch ( ... )
		{
			return E_UNEXPECTED;
		}
	}

	///////////////////////////////////////////////////////////////////////////
	// enums
	///////////////////////////////////////////////////////////////////////////
	HRESULT	AddEnum		( PWMI_PERFORMANCE perf );
	HRESULT	RemoveEnum	( void);

	///////////////////////////////////////////////////////////////////////////
	// handles
	///////////////////////////////////////////////////////////////////////////
	HRESULT	AddHandles		( PWMI_PERFORMANCE perf );
	HRESULT	RemoveHandles	( void);

	private:

	HRESULT	CreateHandles ( IWbemServices* pServices, PWMI_PERF_OBJECT obj, WmiRefreshObject** ppObj );

	// count of enums
	DWORD	GetEnumCount ( PWMI_PERFORMANCE perf );
	DWORD	GetEnumCount ( void );
};

///////////////////////////////////////////////////////////////////////////////
// construction & destruction
///////////////////////////////////////////////////////////////////////////////
template < class WmiRefreshParent >
WmiRefresh < WmiRefreshParent >::WmiRefresh( WmiRefreshParent* pParent ) :

m_dwCount ( 0 ),

parent ( pParent ),

m_pRefresher	( NULL ),
m_pConfig		( NULL )

{
//	// Create the refresher and refresher manager
//	// ==========================================
//	DataInit();
}

template < class WmiRefreshParent >
WmiRefresh < WmiRefreshParent >::~WmiRefresh()
{
	// to be sure
	RemoveEnum();
	DataUninit();

	parent = NULL;
}

///////////////////////////////////////////////////////////////////////////////
// init stuff
///////////////////////////////////////////////////////////////////////////////
template < class WmiRefreshParent >
HRESULT WmiRefresh < WmiRefreshParent >::DataInit()
{
	HRESULT hRes = S_OK;

	// create refresher
	if SUCCEEDED( hRes = ::CoCreateInstance(	__uuidof ( WbemRefresher ), 
												NULL, 
												CLSCTX_INPROC_SERVER, 
												__uuidof ( IWbemRefresher ), 
												(void**) &m_pRefresher
										   )
				)
	{
		// crete refresher manager
		hRes = m_pRefresher->QueryInterface	(	__uuidof ( IWbemConfigureRefresher ),
												(void**) &m_pConfig
											);
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// uninit stuff
///////////////////////////////////////////////////////////////////////////////
template < class WmiRefreshParent >
HRESULT WmiRefresh < WmiRefreshParent >::DataUninit()
{
	HRESULT hRes = S_FALSE;
	if ( m_pRefresher && m_pConfig )
	{
		hRes = S_OK;
	}

	try
	{
		// destroy refresher
		if ( m_pRefresher )
		{
			m_pRefresher->Release();
			m_pRefresher = NULL;
		}
	}
	catch ( ... )
	{
		m_pRefresher = NULL;
	}

	try
	{
		// destroy refresher manager
		if ( m_pConfig )
		{
			m_pConfig->Release();
			m_pConfig = NULL;
		}
	}
	catch ( ... )
	{
		m_pConfig = NULL;
	}

	// we're successfull allready
	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// ENUM HELPERS
///////////////////////////////////////////////////////////////////////////////

template < class WmiRefreshParent >
DWORD WmiRefresh < WmiRefreshParent >::GetEnumCount ( PWMI_PERFORMANCE perf )
{
	DWORD dwCount = 0;

	if ( perf != NULL )
	{
		PWMI_PERF_NAMESPACE n = __Namespace::First ( perf );
		for ( DWORD dw = 0; dw < perf->dwChildCount; dw ++ )
		{
			dwCount += n->dwChildCount;
			n = __Namespace::Next ( n );
		}
	}

	return dwCount;
}

template < class WmiRefreshParent >
DWORD WmiRefresh < WmiRefreshParent >::GetEnumCount ( void )
{
	if ( m_Enums.IsEmpty() )
	{
		return 0L;
	}

	return ((DWORD)m_Enums);
}

///////////////////////////////////////////////////////////////////////////////
// handles stuff
///////////////////////////////////////////////////////////////////////////////
template < class WmiRefreshParent >
HRESULT WmiRefresh < WmiRefreshParent >::RemoveHandles ( void )
{
	try
	{
		// reset all handlers
		if ( ! m_Provs.IsEmpty() )
		{
			for ( DWORD dw = m_Provs; dw > 0 ; dw-- )
			{
				if ( m_Provs[dw-1] )
				m_Provs.DataDelete(dw-1);
			}

			delete [] m_Provs.Detach();
			m_Provs.SetData ( NULL, NULL );
		}
	}
	catch ( ... )
	{
	}

	return S_OK;
}

template < class WmiRefreshParent >
HRESULT	WmiRefresh < WmiRefreshParent >::AddHandles ( PWMI_PERFORMANCE perf )
{
	if ( perf == NULL )
	{
		RemoveHandles ();
		return S_FALSE;
	}

	DWORD dwIndex = 0L;
	m_dwCount = GetEnumCount ( perf );

	typedef WmiRefreshObject*						PWmiRefreshObject;

	// result
	HRESULT hRes = E_OUTOFMEMORY;

	try
	{
		m_Provs.SetData ( new PWmiRefreshObject[m_dwCount], m_dwCount );

		if ( !m_Provs.IsEmpty() )
		{
//			for ( DWORD dw = 0; dw < m_dwCount; dw++ )
//			{
//				m_Provs.SetAt ( dw );
//			}

			///////////////////////////////////////////////////////////////////////////
			// go accross all namespaces and add them into refresher
			///////////////////////////////////////////////////////////////////////////

			PWMI_PERF_NAMESPACE n = __Namespace::First ( perf );
			for ( DWORD dw = 0; dw < perf->dwChildCount; dw ++ )
			{
				DWORD dwItem = UNKNOWN;

				if ( ( lstrcmpW ( __Namespace::GetName ( n ), g_szNamespace1 ) ) == 0 )
				{
					dwItem = CIMV2;
				}
				else
//				if ( ( lstrcmpW ( __Namespace::GetName ( n ), g_szNamespace2 ) ) == 0 )
				{
					dwItem = WMI;
				}

				PWMI_PERF_OBJECT o = __Object::First ( n );
				for ( DWORD dwo = 0; dwo < n->dwChildCount; dwo++ )
				{
					WmiRefreshObject* pobj = NULL;

					switch ( dwItem )
					{
						case CIMV2:
						{
							if ( parent->m_Stuff.m_pServices_CIM )
							hRes = CreateHandles ( parent->m_Stuff.m_pServices_CIM, o, &pobj );
						}
						break;

						case WMI:
						{
							if ( parent->m_Stuff.m_pServices_WMI )
							hRes = CreateHandles ( parent->m_Stuff.m_pServices_WMI, o, &pobj );
						}
						break;
					}

					if ( hRes == WBEM_E_NOT_FOUND )
					{
						// let adapter know it is supposed to refresh at the end
						parent->RequestSet ();
					}

//					if SUCCEEDED ( hRes )
//					{
						try
						{
							m_Provs.SetAt ( dwIndex++, pobj );
						}
						catch ( ... )
						{
							hRes = E_FAIL;
						}
//					}

					// get next object
					o = __Object::Next ( o );
				}

				// get next namespace
				n = __Namespace::Next ( n );
			}

		}
	}
	catch ( ... )
	{
		m_Provs.SetData ( NULL, NULL );
		hRes = E_FAIL;
	}

	return hRes;
}

template < class WmiRefreshParent >
HRESULT WmiRefresh < WmiRefreshParent >::CreateHandles ( IWbemServices* pServices, PWMI_PERF_OBJECT obj, WmiRefreshObject** pObj )
{
	if ( ! pServices || ! obj )
	{
		return E_INVALIDARG;
	}

	// main body :))

	HRESULT hRes = S_OK;

	try
	{
		if ( ( ( *pObj ) = new WmiRefreshObject() ) == NULL )
		{
			return E_OUTOFMEMORY;
		}

		CComPtr < IWbemClassObject >	pClass;
		CComPtr < IWbemObjectAccess >	pAccess;

		if SUCCEEDED ( hRes = pServices -> GetObject ( CComBSTR ( __Object::GetName( obj ) ), 0, 0, &pClass, 0 ) )
		{
			if SUCCEEDED ( hRes = pClass -> QueryInterface ( __uuidof ( IWbemObjectAccess ) , (void**) &pAccess ) )
			{
				if ( ( (*pObj)->m_pHandles = new LONG[obj->dwChildCount + 2] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				long lHandle = 0;

				pAccess->GetPropertyHandle( L"Timestamp_PerfTime", NULL, &lHandle );
				(*pObj)->m_pHandles[0] = lHandle;

				lHandle = 0;

				hRes = pAccess->GetPropertyHandle( L"Frequency_PerfTime", NULL, &lHandle );
				(*pObj)->m_pHandles[1] = lHandle;

				// obtain all handles and store them into array
				PWMI_PERF_PROPERTY p = NULL;

				if ( obj->dwSingleton )
				{
					// jump across instance
					PWMI_PERF_INSTANCE i = (PWMI_PERF_INSTANCE) ( reinterpret_cast<PBYTE>( obj ) + obj->dwLength );
					p = (PWMI_PERF_PROPERTY) ( reinterpret_cast<PBYTE>( i ) + i->dwLength );
				}
				else
				{
					p = __Property::First ( obj );
				}

				for ( DWORD dw = 0; dw < obj->dwChildCount; dw++ )
				{
					lHandle = 0;

					if SUCCEEDED ( hRes = pAccess->GetPropertyHandle( CComBSTR ( __Property::GetName ( p ) ), NULL, &lHandle ) )
					{
						(*pObj)->m_pHandles[dw+2] = lHandle;
						p = __Property::Next ( p );
					}
					else
					{
						// clear we were failed
						delete ( *pObj );
						( *pObj ) = NULL;

						return hRes;
					}
				}
			}
		}
	}
	catch ( ... )
	{
		if ( ( *pObj ) )
		{
			// clear we were failed
			delete ( *pObj );
			( *pObj ) = NULL;
		}

		return E_FAIL;
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// enum stuff
///////////////////////////////////////////////////////////////////////////////
template < class WmiRefreshParent >
HRESULT WmiRefresh < WmiRefreshParent >::RemoveEnum ( void )
{
	try
	{
		// reset all enumerators :))
		if ( ! m_Enums.IsEmpty() )
		{
			for ( DWORD dw = m_Enums; dw > 0 ; dw-- )
			{
				if ( m_Enums[dw-1] )
				{
					// remove enum from refresher
					if ( m_pConfig )
					{
						try
						{
							m_pConfig->Remove ( m_Enums[dw-1]->GetID(), WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT );
						}
						catch ( ... )
						{
							m_pConfig = NULL;
						}
					}

					try
					{
						// remove all objects from enum
						if ( m_Enums[dw-1]->IsValid() )
						{
							IWbemHiPerfEnum * pEnum = NULL;
							if ( ( pEnum = m_Enums[dw-1]->GetMember() ) != NULL )
							{
								pEnum->RemoveAll ( 0 );
							}
						}
					}
					catch ( ... )
					{
					}

					m_Enums[dw-1]->Reset();
					m_Enums.DataDelete(dw-1);
				}
			}

			delete [] m_Enums.Detach();
			m_Enums.SetData ( NULL, NULL );
		}
	}
	catch ( ... )
	{
	}

	return S_OK;
}

template < class WmiRefreshParent >
HRESULT	WmiRefresh < WmiRefreshParent >::AddEnum ( PWMI_PERFORMANCE perf )
{
	if ( ! m_pConfig )
	{
		return E_UNEXPECTED;
	}

	DWORD dwIndex = 0L;

	typedef WmiRefresherMember<IWbemHiPerfEnum>*	PWmiRefresherMemberEnum;

	// result
	HRESULT hRes = E_OUTOFMEMORY;

	try
	{
		m_Enums.SetData ( new PWmiRefresherMemberEnum[ m_dwCount ], m_dwCount );

		if ( !m_Enums.IsEmpty() )
		{
//			for ( DWORD dw = 0; dw < m_dwCount; dw++ )
//			{
//				m_Enums.SetAt ( dw );
//			}

			///////////////////////////////////////////////////////////////////////////
			// go accross all namespaces and add them into refresher
			///////////////////////////////////////////////////////////////////////////

			PWMI_PERF_NAMESPACE n = __Namespace::First ( perf );
			for ( DWORD dw = 0; dw < perf->dwChildCount; dw ++ )
			{
				DWORD dwItem = UNKNOWN;

				if ( ( lstrcmpW ( __Namespace::GetName ( n ), g_szNamespace1 ) ) == 0 )
				{
					dwItem = CIMV2;
				}
				else
//				if ( ( lstrcmpW ( __Namespace::GetName ( n ), g_szNamespace2 ) ) == 0 )
				{
					dwItem = WMI;
				}

				PWMI_PERF_OBJECT o = __Object::First ( n );
				for ( DWORD dwo = 0; dwo < n->dwChildCount; dwo++ )
				{
					CComPtr < IWbemHiPerfEnum > pEnum;
					long						lEnum = 0L;

					switch ( dwItem )
					{
						case CIMV2:
						{
							if ( parent->m_Stuff.m_pServices_CIM )
							hRes = m_pConfig->AddEnum (	parent->m_Stuff.m_pServices_CIM,
														__Object::GetName ( o ),
														0,
														NULL,
														&pEnum,
														&lEnum
													 );
						}
						break;

						case WMI:
						{
							if ( parent->m_Stuff.m_pServices_WMI )
							hRes = m_pConfig->AddEnum (	parent->m_Stuff.m_pServices_WMI,
														__Object::GetName ( o ),
														0,
														NULL,
														&pEnum,
														&lEnum
													 );
						}
						break;
					}

					if SUCCEEDED ( hRes )
					{
						WmiRefresherMember < IWbemHiPerfEnum > * mem = NULL;

						try
						{
							if ( ( mem = new WmiRefresherMember < IWbemHiPerfEnum > () ) != NULL )
							{
								if ( ! ( pEnum == NULL ) )
								{
									mem->Set ( pEnum, lEnum );
								}

								m_Enums.SetAt ( dwIndex++, mem );
							}
							else
							{
								m_Enums.SetAt ( dwIndex++ );
							}
						}
						catch ( ... )
						{
							if ( mem )
							{
								delete mem;
								mem = NULL;
							}

							m_Enums.SetAt ( dwIndex++ );
							hRes = E_FAIL;
						}
					}
					else
					{
						// if enum exist remove from refresher
						if ( ( pEnum == NULL ) && ( m_pConfig == NULL ) )
						{
							try
							{
								m_pConfig->Remove ( lEnum, WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT );
							}
							catch ( ... )
							{
								m_pConfig = NULL;
							}
						}

						m_Enums.SetAt ( dwIndex++ );
					}

					// get next object
					o = __Object::Next ( o );
				}

				// get next namespace
				n = __Namespace::Next ( n );
			}
		}
	}
	catch ( ... )
	{
		m_Enums.SetData ( NULL, NULL );
		hRes = E_FAIL;
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_stuff.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMIAdapter_Stuff.cpp
//
//	Abstract:
//
//					module for application stuff ( security, event logging ... )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// application
#include "WMIAdapter_App.h"
extern WmiAdapterApp		_App;

#include "WMIAdapter_Stuff.h"
#include "WMIAdapter_Stuff_Refresh.cpp"

#include "RefresherUtils.h"

///////////////////////////////////////////////////////////////////////////////
// IsValid
///////////////////////////////////////////////////////////////////////////////
BOOL	WmiAdapterStuff::IsValidBasePerfRegistry ( )
{
	return	( m_data.IsValidGenerate () );
}

BOOL	WmiAdapterStuff::IsValidInternalRegistry ( )
{
	return	( m_data.GetPerformanceData() != NULL );
}

///////////////////////////////////////////////////////////////////////////////
// init
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiAdapterStuff::Init ( )
{
	return m_Stuff.Init();
}

///////////////////////////////////////////////////////////////////////////////
// uninit
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiAdapterStuff::Uninit ( )
{
	return m_Stuff.Uninit();
}

///////////////////////////////////////////////////////////////////////////////
// construction
///////////////////////////////////////////////////////////////////////////////
WmiAdapterStuff::WmiAdapterStuff() :

m_pWMIRefresh ( NULL )

{
	try
	{
		if ( ( m_pWMIRefresh = new WmiRefresh < WmiAdapterStuff > ( this ) ) == NULL )
		{
			return;
		}
	}
	catch ( ... )
	{
		return;
	}
}

///////////////////////////////////////////////////////////////////////////////
// destruction
///////////////////////////////////////////////////////////////////////////////
WmiAdapterStuff::~WmiAdapterStuff()
{
	try
	{
		if ( m_pWMIRefresh )
		{
			delete m_pWMIRefresh;
			m_pWMIRefresh = NULL;
		}
	}
	catch ( ... )
	{
	}
}

///////////////////////////////////////////////////////////////////////////////
// generate requested ?
///////////////////////////////////////////////////////////////////////////////
extern LPCWSTR	g_szKey;
extern LPCWSTR	g_szKeyRefresh;

BOOL	WmiAdapterStuff::RequestGet ()
{
	DWORD dwValue = 0;
	GetRegistry ( g_szKey, g_szKeyRefresh, &dwValue );

	return ( ( dwValue ) ? TRUE : FALSE ); 
}

BOOL	WmiAdapterStuff::RequestSet ()
{
	BOOL bResult = FALSE;

	if ( ! ( bResult = RequestGet () ) )
	{
		bResult = SUCCEEDED ( SetRegistry ( g_szKey, g_szKeyRefresh, 1 ) );
	}

	return bResult; 
}

///////////////////////////////////////////////////////////////////////////////
// generate
///////////////////////////////////////////////////////////////////////////////
extern __SmartHANDLE		g_hRefreshMutex;
extern __SmartHANDLE		g_hRefreshMutexLib;
extern __SmartHANDLE		g_hRefreshFlag;

HRESULT WmiAdapterStuff::Generate ( BOOL bInitialize, GenerateEnum type )
{
	HRESULT hRes = E_FAIL;

	BOOL	bInit			= FALSE;
	BOOL	bOwnFlag		= FALSE;
	BOOL	bOwnMutex		= FALSE;
	BOOL	bLocked			= FALSE;
	DWORD	dwWaitResult	= 0L;

	DWORD	dwHandles	= 2;
	HANDLE	hHandles[]	=
	{
		g_hRefreshMutex,
		g_hRefreshMutexLib
	};

	dwWaitResult = ::WaitForMultipleObjects ( dwHandles, hHandles, TRUE, 0 );
	if ( dwWaitResult == WAIT_TIMEOUT )
	{
		bLocked = TRUE;
	}
	else
	{
		if ( dwWaitResult == WAIT_OBJECT_0 )
		{
			bOwnMutex	= TRUE;
			hRes		= S_OK;
		}
	}

	if ( bLocked )
	{
		DWORD	dwHandles = 3;
		HANDLE	hHandles[] =

		{
			_App.m_hKill,
			g_hRefreshMutex,
			g_hRefreshMutexLib
		};

		dwWaitResult = ::WaitForMultipleObjects	(
													dwHandles,
													hHandles,
													FALSE,
													INFINITE
												);

		switch	( dwWaitResult )
		{
			case WAIT_OBJECT_0 + 2:
			{
				dwWaitResult = ::WaitForMultipleObjects	(
															dwHandles - 1,
															hHandles,
															FALSE,
															INFINITE
														);

				if ( dwWaitResult != WAIT_OBJECT_0 + 1 )
				{
					hRes = E_UNEXPECTED;

					::ReleaseMutex ( g_hRefreshMutexLib );
					break;
				}
			}

			case WAIT_OBJECT_0 + 1:
			{
				// we got a mutex so must reinit because registry might changed
				bOwnMutex	= TRUE;
				bInit		= TRUE;

				hRes		= S_OK;
			}
			break;

			case WAIT_OBJECT_0:
			{
				hRes = S_FALSE;
			}
			break;

			default:
			{
				hRes = E_UNEXPECTED;
			}
			break;
		}
	}

	if ( hRes == S_OK )
	{
		dwWaitResult = ::WaitForSingleObject ( g_hRefreshFlag, INFINITE );
		if ( dwWaitResult == WAIT_OBJECT_0 )
		{
			// mutex guarding registry has to be cleared
			bOwnFlag	= TRUE;

			// call refresh procedure
			hRes = m_Stuff.Generate ( FALSE, type );

			if SUCCEEDED ( hRes )
			{
				// reinit because registry might changed
				bInit = TRUE;
			}
		}
		else
		{
			hRes = E_UNEXPECTED;
		}
	}

	// if we got a mutex and are supposed to refresh our selves
	if ( bInitialize && bInit )
	{
		///////////////////////////////////////////////////////////////////////
		// clear first
		///////////////////////////////////////////////////////////////////////
		try
		{
			// clear internal structure ( obtained from registry )
			m_data.ClearPerformanceData();
		}
		catch ( ... )
		{
		}

		try
		{
			if ( m_pWMIRefresh )
			{
				// remove enums :))
				m_pWMIRefresh->RemoveHandles();
			}
		}
		catch ( ... )
		{
		}

		///////////////////////////////////////////////////////////////////////
		// obtain registry structure and make arrays
		///////////////////////////////////////////////////////////////////////
		if ( ( hRes = m_data.InitializePerformance () ) == S_OK )
		{
			m_data.Generate ();

			if ( m_data.IsValidGenerate () )
			{
				if ( m_pWMIRefresh )
				{
					// add handles :))
					m_pWMIRefresh->AddHandles ( m_data.GetPerformanceData() );
				}
			}
			else
			{
				hRes = E_FAIL;
			}
		}
	}

	if ( bOwnFlag )
	{
		::ReleaseMutex ( g_hRefreshFlag );
	}

	if ( bOwnMutex )
	{
		::ReleaseMutex ( g_hRefreshMutexLib );
		::ReleaseMutex ( g_hRefreshMutex );
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_stuff_performance.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMIAdapter_Stuff_Performance.cpp
//
//	Abstract:
//
//					performance stuff ( init, uninit, real refresh ... )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "WMIAdapter_Stuff.h"
#include "WMIAdapter_Stuff_Refresh.cpp"

// messaging
#include "WMIAdapterMessages.h"

// application
#include "WMIAdapter_App.h"
extern WmiAdapterApp		_App;

#define HRESULT_ERROR_MASK (0x0000FFFF)
#define HRESULT_ERROR_FUNC(X) (X&HRESULT_ERROR_MASK)

////////////////////////////////////////////////////////////////////////////////
// GLOBAL STUFF
////////////////////////////////////////////////////////////////////////////////

extern __SmartHANDLE	g_hRefreshFlag;		// already defined in static library

extern __SmartHANDLE	g_hRefreshMutex;	// already defined in static library
BOOL					g_bRefreshMutex;	// do we own a mutex

__SmartHANDLE		g_hDoneInitEvt	= NULL;		//	event to set when init/uninit is finished ( nonsignaled )
BOOL				g_bWorkingInit	= FALSE;	//	boolean used to tell if init/unit is finished
BOOL				g_bInit			= FALSE;	//	current state - initialized or not.
CRITICAL_SECTION	g_csInit;					//	synch object used to protect above globals

LONG				g_lRefLib		= 0;		//	count of perf libs attached into work
__SmartHANDLE		g_hDoneLibEvt	= NULL;		//	event to set when perf init/uninit is finished ( nonsignaled )
BOOL				g_bWorkingLib	= FALSE;	//	boolean used to tell if perf init/unit in progress

extern LPCWSTR	g_szKey;
extern LPCWSTR	g_szKeyRefreshed;

////////////////////////////////////////////////////////////////////////////////
// INITIALIZE DATA
////////////////////////////////////////////////////////////////////////////////
HRESULT WmiAdapterStuff::Initialize ( )
{
	HRESULT hRes = E_FAIL;
	BOOL bWait = TRUE;
	BOOL bDoWork = FALSE;

	BOOL bLocked		= FALSE;
	BOOL bRefreshMutex	= FALSE;

	while (bWait)
	{
		try
		{
			::EnterCriticalSection ( &g_csInit );
		}
		catch ( ... )
		{
			return E_OUTOFMEMORY;
		}

		if ( ! g_bWorkingInit )
		{
			if ( ! g_lRefLib && ! g_bInit )
			{
				DWORD dwWaitResult = 0L;
				dwWaitResult = ::WaitForSingleObject ( g_hRefreshMutex, 0 );

				if ( dwWaitResult == WAIT_TIMEOUT )
				{
					bLocked = TRUE;
					hRes = S_FALSE;
				}
				else
				{
					if ( dwWaitResult == WAIT_OBJECT_0 )
					{
						bRefreshMutex = TRUE;
						hRes = S_FALSE;
					}
				}

				if SUCCEEDED ( hRes )
				{
					bDoWork = TRUE;
					g_bWorkingInit = TRUE;
					::ResetEvent ( g_hDoneInitEvt );
				}
			}

			bWait = FALSE;
		}
		else
		{
			::LeaveCriticalSection ( &g_csInit );
			
			if ( WAIT_OBJECT_0 != ::WaitForSingleObject( g_hDoneInitEvt, INFINITE ) )
			{
				return hRes;
			}
		}
	}

	::LeaveCriticalSection( &g_csInit );

	if ( bDoWork )
	{
		if ( ! _App.m_bManual )
		{
			///////////////////////////////////////////////////////////////////////////
			// init stuff for adapter ( never FAILS !!! )
			///////////////////////////////////////////////////////////////////////////
			try
			{
				Init();
			}
			catch ( ... )
			{
			}
		}

		if ( bLocked )
		{
			DWORD dwWaitResult = 0L;

			DWORD	dwHandles = 2;
			HANDLE	hHandles[] =

			{
				_App.m_hKill,
				g_hRefreshMutex
			};

			dwWaitResult = ::WaitForMultipleObjects	(
														dwHandles,
														hHandles,
														FALSE,
														INFINITE
													);

			switch	( dwWaitResult )
			{
				case WAIT_OBJECT_0 + 1:
				{
					hRes = S_OK;
				}
				break;

				default:
				{
					hRes = E_FAIL;
				}
				break;
			}
		}

		if SUCCEEDED ( hRes )
		{
			try
			{
				///////////////////////////////////////////////////////////////////////
				// obtain registry structure
				///////////////////////////////////////////////////////////////////////
				if ( ( hRes = m_data.InitializePerformance () ) == S_OK )
				{
					if ( m_pWMIRefresh )
					{
						// add handles :))

						BOOL	bReconnect	= TRUE;
						DWORD	dwReconnect	= 3;

						do
						{
							if ( HRESULT_ERROR_FUNC ( m_pWMIRefresh->AddHandles ( m_data.GetPerformanceData() ) ) == RPC_S_SERVER_UNAVAILABLE )
							{
								m_pWMIRefresh->RemoveHandles ();

								try
								{
									// close handle to winmgmt ( only if exists )
									m_Stuff.WMIHandleClose ();

									Uninit ();
									Init ();

									// open handle to winmgmt
									m_Stuff.WMIHandleOpen ();
								}
								catch ( ... )
								{
									bReconnect = FALSE;
								}
							}
							else
							{
								bReconnect = FALSE;
							}
						}
						while ( bReconnect && dwReconnect-- );
					}

					// change flag to let them now we are done
					if ( ( ::WaitForSingleObject ( g_hRefreshFlag, INFINITE ) ) == WAIT_OBJECT_0 )
					{
						SetRegistry ( g_szKey, g_szKeyRefreshed, 0 );
						::ReleaseMutex ( g_hRefreshFlag );
					}
				}
			}
			catch ( ... )
			{
				hRes = E_FAIL;
			}

			if ( hRes != S_OK )
			{
				// TOTAL CLEANUP ( FAILURE )
				try
				{
					// clear internal structure ( obtained from registry )
					m_data.ClearPerformanceData();
				}
				catch ( ... )
				{
				}

				try
				{
					if ( m_pWMIRefresh )
					{
						// remove enums :))
						m_pWMIRefresh->RemoveHandles();
					}
				}
				catch ( ... )
				{
				}
			}
		}

		if ( ! _App.m_bManual )
		{
			///////////////////////////////////////////////////////////////////////////
			// uninit stuff for adapter ( never FAILS !!! )
			///////////////////////////////////////////////////////////////////////////
			try
			{
				Uninit();
			}
			catch ( ... )
			{
			}
		}

		try
		{
			::EnterCriticalSection ( &g_csInit );
		}
		catch (...)
		{
			//no choice have to give others a chance!
			g_bWorkingInit = FALSE;
			::SetEvent ( g_hDoneInitEvt );

			if ( bRefreshMutex )
			{
				::ReleaseMutex ( g_hRefreshMutex );
				bRefreshMutex = FALSE;
			}

			return E_OUTOFMEMORY;
		}

		if SUCCEEDED ( hRes )
		{
			g_bInit = TRUE;
		}

		g_bWorkingInit = FALSE;
		::SetEvent ( g_hDoneInitEvt );

		// change flag to let them now we are done
		if ( ( ::WaitForSingleObject ( g_hRefreshFlag, INFINITE ) ) == WAIT_OBJECT_0 )
		{
			hRes = SetRegistry ( g_szKey, g_szKeyRefreshed, 0 );
			::ReleaseMutex ( g_hRefreshFlag );
		}

		if ( bRefreshMutex )
		{
			::ReleaseMutex ( g_hRefreshMutex );
			bRefreshMutex = FALSE;
		}

		::LeaveCriticalSection ( &g_csInit );
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// perf initialize
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiAdapterStuff::InitializePerformance ( void )
{
	HRESULT hRes = E_FAIL;
	BOOL bWait = TRUE;
	BOOL bDoWork = FALSE;

	BOOL bLocked	= FALSE;
	BOOL bInitPerf	= FALSE;

	while (bWait)
	{
		try
		{
			::EnterCriticalSection ( &g_csInit );
		}
		catch ( ... )
		{
			return E_OUTOFMEMORY;
		}

		if ( ! _App.m_bManual && ! g_bInit )
		{
			bWait = FALSE;
		}
		else
		{
			if ( g_lRefLib == 0 )
			{
				DWORD dwWaitResult = 0L;
				dwWaitResult = ::WaitForSingleObject ( g_hRefreshMutex, 0 );

				if ( dwWaitResult == WAIT_TIMEOUT )
				{
					bLocked = TRUE;
					hRes = S_FALSE;
				}
				else
				{
					if ( dwWaitResult == WAIT_OBJECT_0 )
					{
						g_bRefreshMutex = TRUE;
						hRes = S_FALSE;
					}
				}

				if SUCCEEDED ( hRes )
				{
					bDoWork = TRUE;
					g_lRefLib++;
					g_bWorkingLib = TRUE;
					::ResetEvent ( g_hDoneLibEvt );
				}

				bWait = FALSE;
			}
			else
			{
				if ( g_bWorkingLib )
				{
					::LeaveCriticalSection ( &g_csInit );
					
					if ( WAIT_OBJECT_0 != ::WaitForSingleObject( g_hDoneLibEvt, INFINITE ) )
					{
						return hRes;
					}
				}
				else
				{
					bWait = FALSE;
					g_lRefLib++;
					hRes = S_OK;
				}
			}
		}
	}

	::LeaveCriticalSection( &g_csInit );

	if (bDoWork)
	{
		if ( ! _App.m_bManual )
		{
			///////////////////////////////////////////////////////////////////////////
			// init stuff for adapter ( NEVER FAILS !!! )
			///////////////////////////////////////////////////////////////////////////
			try
			{
				DWORD	dwStatus	= 0L;

				if ( ( GetExitCodeProcess ( m_Stuff.GetWMI (), &dwStatus ) ) != 0 )
				{
					if ( dwStatus != STILL_ACTIVE )
					{
						bInitPerf = TRUE;
					}
				}

				Init();

				if ( bInitPerf )
				{
					// close handle to winmgmt ( only if exists )
					m_Stuff.WMIHandleClose ();

					// open handle to winmgmt
					m_Stuff.WMIHandleOpen ();
				}
			}
			catch ( ... )
			{
			}
		}
		else
		{
			bInitPerf = TRUE;
		}

		if ( bLocked )
		{
			DWORD dwWaitResult = 0L;

			DWORD	dwHandles = 2;
			HANDLE	hHandles[] =

			{
				_App.m_hKill,
				g_hRefreshMutex
			};

			dwWaitResult = ::WaitForMultipleObjects	(
														dwHandles,
														hHandles,
														FALSE,
														INFINITE
													);

			switch	( dwWaitResult )
			{
				case WAIT_OBJECT_0 + 1:
				{
					// we got a mutex so must reinit because registry might changed
					g_bRefreshMutex = TRUE;

					if ( ! _App.m_bManual )
					{
						DWORD	dwValue = 0L;

						if SUCCEEDED ( GetRegistry ( g_szKey, g_szKeyRefreshed, &dwValue ) )
						{
							if ( dwValue )
							{
								///////////////////////////////////////////////////////////////////////
								// clear first
								///////////////////////////////////////////////////////////////////////
								try
								{
									// clear internal structure ( obtained from registry )
									m_data.ClearPerformanceData();
								}
								catch ( ... )
								{
								}

								try
								{
									if ( m_pWMIRefresh )
									{
										// remove enums :))
										m_pWMIRefresh->RemoveHandles();
									}
								}
								catch ( ... )
								{
								}

								bInitPerf = TRUE;
							}
						}
					}
				}
				break;

				default:
				{
					hRes = E_FAIL;
				}
				break;
			}
		}
		else
		{
			if ( ! _App.m_bManual )
			{
				DWORD	dwValue = 0L;

				if SUCCEEDED ( GetRegistry ( g_szKey, g_szKeyRefreshed, &dwValue ) )
				{
					if ( dwValue )
					{
						///////////////////////////////////////////////////////////////////////
						// clear first
						///////////////////////////////////////////////////////////////////////
						try
						{
							// clear internal structure ( obtained from registry )
							m_data.ClearPerformanceData();
						}
						catch ( ... )
						{
						}

						try
						{
							if ( m_pWMIRefresh )
							{
								// remove enums :))
								m_pWMIRefresh->RemoveHandles();
							}
						}
						catch ( ... )
						{
						}

						bInitPerf = TRUE;
					}
				}
			}
		}

		if ( SUCCEEDED ( hRes ) && bInitPerf )
		{
			///////////////////////////////////////////////////////////////////////
			// obtain registry structure and make arrays
			///////////////////////////////////////////////////////////////////////
			if ( ( hRes = m_data.InitializePerformance () ) == S_OK )
			{
				if ( m_pWMIRefresh )
				{
					// add handles :))

					BOOL	bReconnect	= TRUE;
					DWORD	dwReconnect	= 3;

					do
					{
						if ( HRESULT_ERROR_FUNC ( m_pWMIRefresh->AddHandles ( m_data.GetPerformanceData() ) ) == RPC_S_SERVER_UNAVAILABLE )
						{
							m_pWMIRefresh->RemoveHandles ();

							try
							{
								// close handle to winmgmt ( only if exists )
								m_Stuff.WMIHandleClose ();

								Uninit ();
								Init ();

								// open handle to winmgmt
								m_Stuff.WMIHandleOpen ();
							}
							catch ( ... )
							{
								bReconnect = FALSE;
							}
						}
						else
						{
							bReconnect = FALSE;
						}
					}
					while ( bReconnect && dwReconnect-- );
				}

				// change flag to let them now we are done
				if ( ( ::WaitForSingleObject ( g_hRefreshFlag, INFINITE ) ) == WAIT_OBJECT_0 )
				{
					SetRegistry ( g_szKey, g_szKeyRefreshed, 0 );
					::ReleaseMutex ( g_hRefreshFlag );
				}
			}
		}
		else
		{
			if ( SUCCEEDED ( hRes ) && ! bInitPerf )
			{
				// I was not re-refreshing so everything is OK
				hRes = S_OK;
			}
		}

		if ( hRes == S_OK )
		{
			try
			{
				////////////////////////////////////////////////////////////////////////
				// initialize memory structure
				////////////////////////////////////////////////////////////////////////
				if SUCCEEDED( hRes = m_data.InitializeData () )
				{
					if SUCCEEDED( hRes = m_data.InitializeTable () )
					{

						////////////////////////////////////////////////////////////////
						// create shared memory :))
						////////////////////////////////////////////////////////////////
						if SUCCEEDED( hRes = 
									m_pMem.MemCreate(	L"Global\\WmiReverseAdapterMemory",
														((WmiSecurityAttributes*)_App)->GetSecurityAttributtes()
													)
									)
						{
							if ( m_pMem.MemCreate (	m_data.GetDataSize() + 
													m_data.GetDataTableSize() + 
													m_data.GetDataTableOffset()
												  ),

								 m_pMem.IsValid () )
							{
								try
								{
									if ( m_pWMIRefresh )
									{
										// init data
										m_pWMIRefresh->DataInit();

										// add enums :))

										BOOL	bReconnect	= TRUE;
										DWORD	dwReconnect	= 3;

										do
										{
											if ( HRESULT_ERROR_FUNC ( m_pWMIRefresh->AddEnum ( m_data.GetPerformanceData() ) ) == RPC_S_SERVER_UNAVAILABLE )
											{
												m_pWMIRefresh->RemoveEnum ();
												m_pWMIRefresh->RemoveHandles ();

												try
												{
													// close handle to winmgmt ( only if exists )
													m_Stuff.WMIHandleClose ();

													Uninit ();
													Init ();

													// open handle to winmgmt
													m_Stuff.WMIHandleOpen ();
												}
												catch ( ... )
												{
													bReconnect = FALSE;
												}

												if ( bReconnect )
												{
													BOOL	bReconnectHandles	= TRUE;
													DWORD	dwReconnectHandles	= 3;

													do
													{
														if ( HRESULT_ERROR_FUNC ( m_pWMIRefresh->AddHandles ( m_data.GetPerformanceData() ) ) == RPC_S_SERVER_UNAVAILABLE )
														{
															m_pWMIRefresh->RemoveHandles ();

															try
															{
																// close handle to winmgmt ( only if exists )
																m_Stuff.WMIHandleClose ();

																Uninit ();
																Init ();

																// open handle to winmgmt
																m_Stuff.WMIHandleOpen ();
															}
															catch ( ... )
															{
																bReconnectHandles = FALSE;
															}
														}
														else
														{
															bReconnectHandles = FALSE;
														}
													}
													while ( bReconnectHandles && dwReconnectHandles-- );
												}
											}
											else
											{
												bReconnect = FALSE;
											}
										}
										while ( bReconnect && dwReconnect-- );
									}
								}
								catch ( ... )
								{
									hRes =  E_FAIL;
								}
							}
							else
							{
								hRes = E_OUTOFMEMORY;
							}
						}
					}
				}
			}
			catch ( ... )
			{
				hRes = E_FAIL;
			}

			// TOTAL CLEANUP DUE TO FAILURE
			if FAILED ( hRes )
			{
				try
				{
					m_data.DataClear();
					m_data.DataTableClear();
				}
				catch ( ... )
				{
				}

				try
				{
					// clear shared memory :))
					if ( m_pMem.IsValid() )
					{
						m_pMem.MemDelete();
					}
				}
				catch ( ... )
				{
				}

				try
				{
					if ( m_pWMIRefresh )
					{
						// remove enums :))
						m_pWMIRefresh->RemoveEnum();

						// uninit data
						m_pWMIRefresh->DataUninit();
					}
				}
				catch ( ... )
				{
				}
			}
		}

		if ( ! _App.m_bManual )
		{
			///////////////////////////////////////////////////////////////////////////
			// uninit stuff for adapter ( NEVER FAILS !!! )
			///////////////////////////////////////////////////////////////////////////
			try
			{
				Uninit();
			}
			catch ( ... )
			{
			}
		}

		try
		{
			::EnterCriticalSection ( &g_csInit );
		}
		catch (...)
		{
			//no choice have to give others a chance!
			if ( hRes != S_OK )
			{
				g_lRefLib--;
			}

			g_bWorkingLib = FALSE;
			::SetEvent(g_hDoneLibEvt);

			return E_OUTOFMEMORY;
		}

		if ( hRes != S_OK )
		{
			g_lRefLib--;
		}

		g_bWorkingLib = FALSE;
		::SetEvent(g_hDoneLibEvt);

		if ( hRes == S_OK )
		{
			// let service now we are in use
			_App.InUseSet ( TRUE );
		}

		::LeaveCriticalSection ( &g_csInit );
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// perf refresh
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiAdapterStuff::Refresh()
{
	HRESULT hRes = S_FALSE;

	try
	{
		if ( ::TryEnterCriticalSection ( &g_csInit ) )
		{
			if SUCCEEDED ( hRes = m_pWMIRefresh->Refresh() )
			{
				try
				{
					//////////////////////////////////////////////////////////////////////
					// create proper data and refres table
					//////////////////////////////////////////////////////////////////////
					if SUCCEEDED ( hRes = m_data.CreateData	( m_pWMIRefresh->GetEnums (), m_pWMIRefresh->GetProvs ()) )
					{
						m_data.RefreshTable	( );

						//////////////////////////////////////////////////////////////////
						// fill memory :))
						//////////////////////////////////////////////////////////////////

						if ( m_pMem.Write (	m_data.GetDataTable(),
											m_data.GetDataTableSize(),
											NULL,
											m_data.GetDataTableOffset()
										  )
						   )
						{
							// write everything into memory :))

							DWORD dwBytesRead	= 0L;
							DWORD dwOffset		= m_data.GetDataTableSize() + m_data.GetDataTableOffset();

							DWORD dwRealSize = m_data.__GetValue ( m_data.GetDataTable(), offsetRealSize );

							DWORD dwIndexWritten = 0L;
							DWORD dwBytesWritten = 0L;

							while ( ( dwBytesWritten < dwRealSize ) && SUCCEEDED ( hRes ) )
							{
								DWORD dwBytesWrote	= 0L;
								BYTE* ptr			= NULL;

								ptr = m_data.GetData ( dwIndexWritten++, &dwBytesRead );

								if ( m_pMem.Write ( ptr, dwBytesRead, &dwBytesWrote, dwOffset ) && dwBytesWrote )
								{
									dwOffset		+= dwBytesWrote;
									dwBytesWritten	+= dwBytesWrote;
								}
								else
								{
									hRes = E_FAIL;
								}
							}
						}
						else
						{
							hRes = E_FAIL;
						}
					}
				}
				catch ( ... )
				{
				}
			}

			::LeaveCriticalSection ( &g_csInit );
		}
	}
	catch ( ... )
	{
		hRes = E_UNEXPECTED;
	};

	#ifdef	_DEBUG
	if FAILED ( hRes )
	{
		ATLTRACE ( L"\n\n\n ******* REFRESH FAILED ******* \n\n\n" );
	}
	#endif	_DEBUG

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// perf uninitialize
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiAdapterStuff::UninitializePerformance ( void )
{
	HRESULT	hRes	= S_FALSE;
	BOOL	bDoWork = FALSE;

	try
	{
		::EnterCriticalSection ( &g_csInit );
	}
	catch ( ... )
	{
		return E_OUTOFMEMORY;
	}

	if ( g_lRefLib == 1 )
	{
		bDoWork = TRUE;
		g_bWorkingLib = TRUE;
		::ResetEvent(g_hDoneLibEvt);
	}
	else
	{
		if ( g_lRefLib )
		{
			g_lRefLib--;
		}
	}

	::LeaveCriticalSection( &g_csInit );

	if (bDoWork)
	{
		// clear internal structure ( obtained from registry )
		try
		{
			m_data.DataClear();
			m_data.DataTableClear();
		}
		catch ( ... )
		{
		}

		try
		{
			// clear shared memory :))
			if ( m_pMem.IsValid() )
			{
				m_pMem.MemDelete();
			}
		}
		catch ( ... )
		{
		}

		try
		{
			if ( m_pWMIRefresh )
			{
				// remove enums :))
				m_pWMIRefresh->RemoveEnum();

				// uninit data
				m_pWMIRefresh->DataUninit();
			}
		}
		catch ( ... )
		{
		}

		if ( g_bRefreshMutex )
		{
			::ReleaseMutex ( g_hRefreshMutex );
			g_bRefreshMutex = FALSE;
		}

		::CoFreeUnusedLibraries ( );

		try
		{
			::EnterCriticalSection ( &g_csInit );
		}
		catch ( ... )
		{
			//gotta give others a chance to work, risk it!
			g_lRefLib--;
			g_bWorkingLib = FALSE;
			::SetEvent( g_hDoneLibEvt );

			// let service now we are not in use anymore
			_App.InUseSet ( FALSE );

			return E_OUTOFMEMORY;
		}

		g_bWorkingLib = FALSE;
		g_lRefLib--;
		::SetEvent( g_hDoneLibEvt );

		// let service now we are not in use anymore
		_App.InUseSet ( FALSE );

		hRes = S_OK;

		if ( _App.m_bManual )
		{
			::SetEvent ( _App.m_hKill );
		}

		::LeaveCriticalSection ( &g_csInit );
	}

	return hRes;
}

////////////////////////////////////////////////////////////////////////////////
// UNINITIALIZE FINAL
////////////////////////////////////////////////////////////////////////////////
void	WmiAdapterStuff::Uninitialize ( void )
{
	if ( ! _App.m_bManual )
	{
		// close handle to winmgmt
		m_Stuff.WMIHandleClose ();
	}

	try
	{
		// clear internal structure ( obtained from registry )
		m_data.ClearPerformanceData();
	}
	catch ( ... )
	{
	}

	try
	{
		if ( m_pWMIRefresh )
		{
			// remove enums :))
			m_pWMIRefresh->RemoveHandles();
		}
	}
	catch ( ... )
	{
	}
}

/////////////////////////////////////////////////////////////////////////
// check usage of shared memory ( protect against perfmon has killed )
// undocumented kernel stuff for having number of object here
/////////////////////////////////////////////////////////////////////////

void	WmiAdapterStuff::CheckUsage ( void )
{
	// variables
	WmiReverseMemoryExt<WmiReverseGuard>* pMem = NULL;

	if ( m_pMem.IsValid() )
	{
		if ( ( pMem = m_pMem.GetMemory ( 0 ) ) != NULL )
		{
			LONG lRefCount = 0L;
			if ( ( lRefCount = pMem->References () ) > 0 )
			{
				if	(	lRefCount == 1 &&
						::InterlockedCompareExchange ( &g_lRefLib, g_lRefLib, 1 )
					)
				{
					HANDLE hUninit = NULL;
					if ( ( hUninit = _App.GetUninit() ) != NULL )
					{
						::ReleaseSemaphore( hUninit, 1, NULL );
					}
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_service_work.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMIAdapter_Service_Work.cpp
//
//	Abstract:
//
//					module for service real working
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "WMIAdapterMessages.h"

// application
#include "WMIAdapter_App.h"
extern WmiAdapterApp		_App;

// service module
#include "WMIAdapter_Service.h"
extern WmiAdapterService	_Service;

extern	LONG				g_lRefLib;		// reference count of perf libraries
extern	CRITICAL_SECTION	g_csInit;		// synch object used to protect above globals

/////////////////////////////////////////////////////////////////////////////
//
// WORK
//
/////////////////////////////////////////////////////////////////////////////

LONG WmiAdapterService::Work ( void )
{
	LONG		lReturn = 0L;

	if ( _App.m_bManual )
	{
		((WmiAdapterStuff*)_App)->Init();
	}
	else
	{
		try
		{
			////////////////////////////////////////////////////////////////////////////////
			// INITIALIZE
			////////////////////////////////////////////////////////////////////////////////

			if FAILED ( lReturn = ((WmiAdapterStuff*)_App)->Initialize() )
			{
				ATLTRACE (	L"*************************************************************\n"
							L"worker initialization failed ... %d ... 0x%x\n"
							L"*************************************************************\n",
							::GetCurrentThreadId(),
							lReturn
						 );
			}
		}
		catch ( ... )
		{
		}
	}

	DWORD	dwHandles = 3;
	HANDLE	hHandles[] =

	{
		_App.m_hKill,
		_App.GetInit(),
		_App.GetUninit()
	};

	ATLTRACE (	L"*************************************************************\n"
				L"WmiAdapterService WAIT for INITIALIZATION event\n"
				L"*************************************************************\n" );

	DWORD	dwWaitResult	= 0L;
	BOOL	bContinue		= TRUE;

	try
	{
		while ( bContinue &&

				( ( dwWaitResult = ::WaitForMultipleObjects	(
																dwHandles - 1,
																hHandles,
																FALSE,
																INFINITE
															)
				) != WAIT_OBJECT_0 )
			  )
		{
			if ( dwWaitResult == WAIT_OBJECT_0 + 1 )
			{
				BOOL bContinueRefresh = TRUE;

				try
				{
					////////////////////////////////////////////////////////////////
					// INITIALIZE PERFORMANCE 
					////////////////////////////////////////////////////////////////
					if ( ( lReturn = ((WmiAdapterStuff*)_App)->InitializePerformance() ) != S_OK )
					{
						ATLTRACE (	L"*************************************************************\n"
									L"worker initialization failed ... %d ... 0x%x\n"
									L"*************************************************************\n",
									::GetCurrentThreadId(),
									lReturn
								 );

						// go to main loop
						bContinueRefresh = FALSE;

						if ( _App.m_bManual )
						{
							// go away
							bContinue = FALSE;
						}
					}
				}
				catch ( ... )
				{
				}

				if ( ! bContinueRefresh &&
					   ((WmiAdapterStuff*)_App)->IsValidInternalRegistry() &&
					 ! ((WmiAdapterStuff*)_App)->IsValidBasePerfRegistry()
					   
				   )
				{
					// make termination refersh
					((WmiAdapterStuff*)_App)->RequestSet();
				}

				if ( bContinueRefresh )
				{
					ATLTRACE (	L"*************************************************************\n"
								L"WmiAdapterService WAIT for WORK\n"
								L"*************************************************************\n" );

					dwWaitResult = WAIT_TIMEOUT;

					#ifdef	__SUPPORT_WAIT
					BOOL bFirstRefresh    = TRUE;
					#endif	__SUPPORT_WAIT

					do
					{
						switch ( dwWaitResult )
						{
							case WAIT_TIMEOUT:
							{
								// show trace timeout gone
								ATLTRACE ( L"WAIT_TIMEOUT ... Performance ... id %x\n", ::GetCurrentThreadId() );

								try
								{
									// refresh everything ( internal ) :))
									((WmiAdapterStuff*)_App)->Refresh();
								}
								catch ( ... )
								{
								}

								// send library event we are ready
								#ifdef	__SUPPORT_WAIT
								if ( bFirstRefresh )
								{
									_App.SignalData ();
									bFirstRefresh = FALSE;
								}
								#endif	__SUPPORT_WAIT
							}
							break;

							case WAIT_OBJECT_0 + 1:
							{
								// dwWaitResult == WAIT_OBJECT_0 + 1
								::InterlockedIncrement ( &g_lRefLib );
							}
							break;

							case WAIT_OBJECT_0 + 2:
							{
								try
								{
									////////////////////////////////////////////////////////////
									// UNINITIALIZE PERFORMANCE 
									////////////////////////////////////////////////////////////
									if ( ((WmiAdapterStuff*)_App)->UninitializePerformance() == S_OK )
									{
										// got to the main loop only when it is last one
										bContinueRefresh = FALSE;
									}
								}
								catch ( ... )
								{
									// something goes wrong
									// got to the main loop
									bContinueRefresh = FALSE;
								}
							}
							break;

							default:
							{
								try
								{
									////////////////////////////////////////////////////////////
									// UNINITIALIZE PERFORMANCE 
									////////////////////////////////////////////////////////////
									((WmiAdapterStuff*)_App)->UninitializePerformance();
								}
								catch ( ... )
								{
								}

								// something goes wrong
								// got to the main loop
								bContinueRefresh = FALSE;
							}
							break;
						}

						#ifdef	__SUPPORT_ICECAP_ONCE
						{
							// got to the main loop
							bContinueRefresh	= FALSE;
							bContinue			= FALSE;
						}
						#endif	__SUPPORT_ICECAP_ONCE

						/////////////////////////////////////////////////////////////////////////
						// check usage of shared memory ( protect against perfmon has killed )
						/////////////////////////////////////////////////////////////////////////
						((WmiAdapterStuff*)_App)->CheckUsage();
					}
					while (	bContinueRefresh &&
							( ( dwWaitResult = ::WaitForMultipleObjects	(
																			dwHandles,
																			hHandles,
																			FALSE,
																			1000
																		)
							) != WAIT_OBJECT_0 )
						  );

					// reset library event we are starting again
					#ifdef	__SUPPORT_WAIT
					_App.SignalData ( FALSE );
					#endif	__SUPPORT_WAIT

					if ( ! _App.m_bManual )
					{
						// is refresh of registry already done ?
						if ( ((WmiAdapterStuff*)_App)->RequestGet() )
						{
							if ( ::TryEnterCriticalSection ( &g_csInit ) )
							{
								// lock & leave CS
								_App.InUseSet ( TRUE );
								::LeaveCriticalSection ( &g_csInit );

								try
								{
									( ( WmiAdapterStuff*) _App )->Generate ( ) ;
								}
								catch ( ... )
								{
								}

								if ( ::TryEnterCriticalSection ( &g_csInit ) )
								{
									// unlock & leave CS
									_App.InUseSet ( FALSE );

									::LeaveCriticalSection ( &g_csInit );
								}
							}
						}
					}
				}
			}
			else
			{
				bContinue = FALSE;
			}
		}
	}
	catch ( ... )
	{
	}

	try
	{
		#ifdef	__SUPPORT_ICECAP_ONCE
		if ( dwWaitResult == WAIT_TIMEOUT )
		#else	__SUPPORT_ICECAP_ONCE
		if ( dwWaitResult == WAIT_OBJECT_0 )
		#endif	__SUPPORT_ICECAP_ONCE
		{
			if ( ::InterlockedCompareExchange ( &g_lRefLib, g_lRefLib, g_lRefLib ) > 0 )
			{
				try
				{
					////////////////////////////////////////////////////////////////
					// UNINITIALIZE PERFORMANCE 
					////////////////////////////////////////////////////////////////
					((WmiAdapterStuff*)_App)->UninitializePerformance();
				}
				catch ( ... )
				{
				}
			}
		}
	}
	catch ( ... )
	{
	}

	try
	{
		////////////////////////////////////////////////////////////////////////
		// UNINITIALIZE
		////////////////////////////////////////////////////////////////////////
		((WmiAdapterStuff*)_App)->Uninitialize();
	}
	catch ( ... )
	{
	}

	if ( _App.m_bManual )
	{
		((WmiAdapterStuff*)_App)->Uninit();
	}

	return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_eventlog_base.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_eventlog_base.cpp
//
//	Abstract:
//
//					defines behaviour of evet logging
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// definitions
#include "wmi_EventLog_base.h"
#include <lmcons.h>

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// behaviour
#define	__AUTOMATIC_REFCOUNT__
#define	__AUTOMATIC_SID__

/////////////////////////////////////////////////////////////////////////////////////////
// construction & destruction
/////////////////////////////////////////////////////////////////////////////////////////

CPerformanceEventLogBase::CPerformanceEventLogBase( LPTSTR szApp ) :
m_lLogCount(0),
m_hEventLog(0),
m_pSid(0)
{
	#ifdef	__AUTOMATIC_SID__
	InitializeFromToken();
	#endif	__AUTOMATIC_SID__

	#ifdef	__AUTOMATIC_REFCOUNT__
	Open ( szApp );
	#endif	__AUTOMATIC_REFCOUNT__
}

CPerformanceEventLogBase::~CPerformanceEventLogBase()
{
	#ifdef	__AUTOMATIC_REFCOUNT__
	Close ();
	#endif	__AUTOMATIC_REFCOUNT__

	// rescue me :))
	while ( m_lLogCount > 0 )
	{
		Close ();
	}

	m_lLogCount	= 0;
	m_hEventLog		= NULL;

	delete[] m_pSid;
	m_pSid	= NULL;
}

void CPerformanceEventLogBase::Initialize ( LPTSTR szAppName, LPTSTR szResourceName )
{
	HKEY	hKey		= NULL;

	if ( szAppName )
	{
		LPTSTR	szKey		= _T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\");
		LPTSTR	szKeyFile	= _T("EventMessageFile");
		LPTSTR	szKeyType	= _T("TypesSupported");

		DWORD	dwData =	EVENTLOG_ERROR_TYPE |
							EVENTLOG_WARNING_TYPE | 
							EVENTLOG_INFORMATION_TYPE;

		LPTSTR szBuf = NULL;

		if ( ( szBuf = reinterpret_cast<LPTSTR>(new TCHAR [ 1 + lstrlen ( szKey ) + lstrlen ( szAppName ) ] ) ) != NULL )
		{
			lstrcpy ( szBuf, szKey );
			lstrcat ( szBuf, szAppName );

			if ( ! ::RegCreateKey (	HKEY_LOCAL_MACHINE, szBuf, &hKey ) )
			{
				if ( szResourceName )
				{
					// Add the name to the EventMessageFile subkey.
					::RegSetValueEx(hKey, szKeyFile, 0, REG_EXPAND_SZ, (LPBYTE) szResourceName, sizeof ( TCHAR ) * ( lstrlen( szResourceName ) + 1 ) );
				}

				// Set the supported event types in the TypesSupported subkey.
				::RegSetValueEx(hKey, szKeyType, 0, REG_DWORD, (LPBYTE) &dwData, sizeof( DWORD ) );

				::RegCloseKey(hKey);
			}

			delete ( szBuf );
			return;
		}
	}

	___ASSERT(L"Unable to initialize event logging !");
	return;
}

void CPerformanceEventLogBase::UnInitialize ( LPTSTR szAppName )
{
	if ( szAppName )
	{
		LPTSTR	szKey		= _T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\");

		LPTSTR szBuf = NULL;

		if ( ( szBuf = reinterpret_cast<LPTSTR>(new TCHAR [ 1 + lstrlen ( szKey ) + lstrlen ( szAppName ) ] ) ) != NULL )
		{
			lstrcpy ( szBuf, szKey );
			lstrcat ( szBuf, szAppName );

			::RegDeleteKey ( HKEY_LOCAL_MACHINE, szBuf );
			return;
		}
	}

	___ASSERT(L"Unable to uninitialize event logging !");
	return;
}

/////////////////////////////////////////////////////////////////////////////////////////
// methods
/////////////////////////////////////////////////////////////////////////////////////////

void CPerformanceEventLogBase::InitializeFromToken ( void )
{
	if ( ! m_pSid )
	{
		HANDLE	hAccessToken= NULL;

		PTOKEN_OWNER	ptOwner		= NULL;
		DWORD			dwOwnerSize	= 0;

		if ( ::OpenProcessToken ( ::GetCurrentProcess (), TOKEN_READ, &hAccessToken ) )
		{
			::GetTokenInformation( hAccessToken, TokenOwner, reinterpret_cast<LPVOID>( ptOwner ), dwOwnerSize, &dwOwnerSize );

			if ( ( ptOwner = reinterpret_cast<PTOKEN_OWNER>( new BYTE[ dwOwnerSize ] ) ) != NULL )
			if ( ::GetTokenInformation( hAccessToken, TokenOwner, reinterpret_cast<LPVOID>( ptOwner ), dwOwnerSize, &dwOwnerSize ) )
			{
				if ( ::IsValidSid ( ptOwner -> Owner ) )
				{
					DWORD	dwSid	= ::GetLengthSid ( ptOwner -> Owner );

					if ( ( m_pSid = reinterpret_cast<PSID>( new BYTE[dwSid] ) ) != NULL )
					{
						::CopySid ( dwSid, m_pSid, ptOwner -> Owner );
					}
				}
			}

			delete ( ptOwner );

			if ( hAccessToken )
			{
				::CloseHandle ( hAccessToken );
			}

			return;
		}
	}

	___ASSERT(L"Unable to set SID of user !");
	return;
}

void CPerformanceEventLogBase::InitializeFromAccount ( void )
{
	if ( ! m_pSid )
	{
		DWORD	dwSid		= 0;

		SID_NAME_USE	eUse;

		TCHAR	strName	[ UNLEN + 1 ]	= { _T('\0') };
		DWORD	dwName					= UNLEN + 1;

		if ( ::GetUserName ( strName, &dwName ) != 0 )
		{
			:: LookupAccountName( 0, strName, m_pSid, &dwSid, 0, 0, &eUse );
			if ( ( m_pSid = reinterpret_cast<PSID>( new BYTE[dwSid] ) ) != NULL )
			{
				::LookupAccountName( 0, strName, m_pSid, &dwSid, 0, 0, &eUse );
			}
		}

		return;
	}

	___ASSERT(L"Unable to set SID of user !");
	return;
}

HRESULT	CPerformanceEventLogBase::Open ( LPTSTR szName )
{
	if ( ! m_lLogCount && szName )
	{
		if ( ( m_hEventLog = ::RegisterEventSource ( NULL, szName ) ) == NULL )
		{
			return HRESULT_FROM_WIN32( ::GetLastError () );
		}
	}

	if ( m_hEventLog )
	{
		InterlockedIncrement( &m_lLogCount );
		return S_OK;
	}

	return S_FALSE;
}

void	CPerformanceEventLogBase::Close ( void )
{
	if (! ( InterlockedDecrement ( &m_lLogCount ) ) && m_hEventLog )
	{
		::DeregisterEventSource ( m_hEventLog );
	}

	return;
}

BOOL	CPerformanceEventLogBase::ReportEvent (	WORD		wType,
											WORD		wCategory,
											DWORD		dwEventID,
											WORD		wStrings,
											DWORD		dwData,
											LPCWSTR*	lpStrings,
											LPVOID		lpData
										  )
{
	if ( m_hEventLog )
	{
		if ( !::ReportEventW ( m_hEventLog, wType, wCategory, dwEventID, m_pSid, wStrings, dwData, (LPCWSTR*) lpStrings, lpData ) )
		{
			ERRORMESSAGE_DEFINITION;
			ERRORMESSAGE ( HRESULT_FROM_WIN32 ( ::GetLastError() ) ) ;

			return FALSE;
		}

		return TRUE;
	}

	___ASSERT(L"Unable to report event !");
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_eventlog.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_EventLog.cpp
//
//	Abstract:
//
//					defines event log specific ( see wmi_eventlog_base )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////


#include "PreComp.h"

// definitions
#include "wmi_EventLog.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// need macros
#ifndef	__ASSERT_VERIFY__
#include "__macro_assert.h"
#endif	__ASSERT_VERIFY__

/////////////////////////////////////////////////////////////////////////////////////////
// construction & destruction
/////////////////////////////////////////////////////////////////////////////////////////

CPerformanceEventLog::CPerformanceEventLog( LPTSTR szApp ) :
CPerformanceEventLogBase ( szApp ),
m_dwMessageLevel(0)
{
	if ( ! m_dwMessageLevel )
	{
		InitializeMessageLevel();
	}
}

CPerformanceEventLog::CPerformanceEventLog(DWORD dwMessageLevel, LPTSTR szApp ) :
CPerformanceEventLogBase ( szApp ),
m_dwMessageLevel(dwMessageLevel)
{
	if ( ! m_dwMessageLevel )
	{
		InitializeMessageLevel();
	}
}

CPerformanceEventLog::~CPerformanceEventLog()
{
	m_dwMessageLevel= 0;
}

/////////////////////////////////////////////////////////////////////////////////////////
// helpers
/////////////////////////////////////////////////////////////////////////////////////////

void CPerformanceEventLog::InitializeMessageLevel ( void )
{
	DWORD	dwResult	= 0;
	DWORD	dwLogLevel	= 0;

	HKEY	hKey		= NULL;

	dwResult = ::RegOpenKeyEx (	HKEY_LOCAL_MACHINE,
								_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\PerfLib"),
								NULL,
								KEY_READ,
								&hKey );

	if ( ERROR_SUCCESS == dwResult )
	{
		dwResult = ::RegQueryValueEx (	hKey,
										_T("EventLogLevel"),
										NULL,
										NULL,
										reinterpret_cast<LPBYTE>(&dwLogLevel),
										NULL);

		if ( ERROR_SUCCESS == dwResult )
		{
			m_dwMessageLevel = dwLogLevel;
		}

		::RegCloseKey ( hKey );
	}

	___ASSERT(L"Unable to set message log level !");
	m_dwMessageLevel = 1;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_perf.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_perf.cpp
//
//	Abstract:
//
//					Defines common helpers for conversion
//					Works with table structure for objects ( init, refresh )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "WMI_perf_data.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "wmi_perf_struct.h"

#include <pshpack8.h>
#pragma pack ( push, 8 )

////////////////////////////////////////////////////////////////////////////////////
// Initialize WINDOWS PERFORMANCE table struct from internal structure
////////////////////////////////////////////////////////////////////////////////////

HRESULT	WmiPerformanceData::InitializeTable ( void )
{
	try
	{
		m_dwDataTable =	( m_dwCount * ObjectSize ) +
						SizeSize +
						CountSize +
						RealSize;

		if ( ( m_pDataTable = (BYTE*) malloc ( m_dwDataTable ) ) != NULL )
		{
			__SetValue ( m_pDataTable, m_dwDataTable, offsetSize );
			__SetValue ( m_pDataTable, m_dwCount, offsetCount );
			__SetValue ( m_pDataTable, 0, offsetRealSize );

			for ( DWORD dw = 0; dw < m_dwCount; dw++ )
			{
				__SetValue ( m_pDataTable, dw,				offsetObject + ( dw * ( ObjectSize ) + offIndex ) );
				__SetValue ( m_pDataTable, m_Ord2Ind[dw],	offsetObject + ( dw * ( ObjectSize ) + offCounter ) );
				__SetValue ( m_pDataTable, 0,				offsetObject + ( dw * ( ObjectSize ) + offOffset ) );
				__SetValue ( m_pDataTable, 0,				offsetObject + ( dw * ( ObjectSize ) + offValidity ) );
			}
		}
	}
	catch ( ... )
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}

HRESULT	WmiPerformanceData::RefreshTable ( void )
{
	DWORD offset	= 0;

	DWORD realsize	= 0;
	DWORD realcount	= 0;

	for ( DWORD dw = 0; dw < m_dwCount; dw++ )
	{
		if ( __GetValue (	m_pDataTable, 
							offsetObject + ( dw * ( ObjectSize ) + offValidity )
						)

						== ( DWORD ) -1 
		   )
		{
			__SetValue	(	m_pDataTable,
							( DWORD ) -1,
							offsetObject + ( dw * ( ObjectSize ) + offOffset )
						);
		}
		else
		{
			__SetValue	(	m_pDataTable,
							realsize,
							offsetObject + ( dw * ( ObjectSize ) + offOffset )
						);

			if ( data.Read ( &offset, sizeof ( DWORD ), NULL, realsize ) == TRUE )
			{
				realsize	+= offset;
				realcount++;
			}
		}
	}

	// set num of objects
	__SetValue	(	m_pDataTable,
					m_dwCount,
					offsetCount
				);

	// set real size
	__SetValue	(	m_pDataTable,
					realsize,
					offsetRealSize
				);

	return S_OK;
}

#pragma pack ( pop )
#include <poppack.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_common.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_common.cpp
//
//	Abstract:
//
//					declarations of common constants
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

LPCWSTR	g_szAppName			= L"WmiApSrv";
LPCWSTR	g_szAppNameGlobal	= L"Global\\WmiApSrv";

////////////////////////////////////////////////////////////////////////////////////
// this constants are part of static library already
////////////////////////////////////////////////////////////////////////////////////

/*

LPCWSTR	g_szRefreshMutex	= L"Global\\RefreshRA";

// namespaces
LPCWSTR	g_szNamespace1	= L"\\\\.\\root\\cimv2";
LPCWSTR	g_szNamespace2	= L"\\\\.\\root\\wmi";

// registry
LPCWSTR	g_szKey			= L"SOFTWARE\\Microsoft\\WBEM\\PROVIDERS\\Performance";
LPCWSTR	g_szKeyValue	= L"Performance Data";

LPCWSTR	g_szKeyCounter	= L"SYSTEM\\CurrentControlSet\\Services\\WmiApRpl\\Performance";

*/

///////////////////////////////////////////////////////////////////////////////
// convertion
///////////////////////////////////////////////////////////////////////////////

WCHAR	g_szPath[_MAX_PATH] = { L'\0' };

LPCWSTR	g_szOpen	= L"WmiOpenPerfData";
LPCWSTR	g_szCollect	= L"WmiCollectPerfData";
LPCWSTR	g_szClose	= L"WmiClosePerfData";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_perf_data.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_perf_data.cpp
//
//	Abstract:
//
//					implements common work with internal data structure
//					( using registry structure )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "WMI_perf_data.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "wmi_perf_reg.h"

// application
#include "WMIAdapter_App.h"
extern WmiAdapterApp		_App;

// global crit sec
extern	CRITICAL_SECTION	g_csInit;

#ifdef	__SUPPORT_REGISTRY_DATA
#include <pshpack8.h>

////////////////////////////////////////////////////////////////////////////////////
// Initialize WINDOWS PERFORMANCE struct from internal structure ( WMI_PERFORMANCE )
////////////////////////////////////////////////////////////////////////////////////

HRESULT	WmiPerformanceData::InitializeData ( void )
{
	// have a wmi performance structure ?
	if ( ! m_perf )
	{
		return E_FAIL;
	}

	HRESULT hRes	= S_OK;

	try
	{
		// refresh internal information
		Generate ();

		if ( IsValidGenerate () )
		{
			DWORD dwCounter	= 0;
			DWORD dwHelp	= 0;

			// count num of supported objects ( first dword )
			m_dwCount = 0;

			PWMI_PERF_NAMESPACE n = NULL;
			PWMI_PERF_OBJECT	o = NULL;

			// get global size
			DWORD dwSize		= 0;
			DWORD dwSizeOrders	= 0;

			// get global index
			DWORD dwIndex	= 0;

			// size we are going to count for each object
			DWORD dwTotalByteLength = 0;
			dwTotalByteLength		=	// PERF_COUNTER_BLOCK
										sizeof ( PERF_OBJECT_TYPE ) +

										// assuming I have PERF_INSTANCE_DEFINITION TOO
										sizeof ( PERF_INSTANCE_DEFINITION ) +
										// so I need pseudo name too
										sizeof ( LPWSTR ) +

										// PERF_COUNTER_BLOCK and its alignment
										sizeof ( PERF_COUNTER_BLOCK ) + 
										sizeof ( DWORD );

			dwCounter	= m_dwFirstCounter + PSEUDO_COUNTER;	// take care of pseudo
			dwHelp		= m_dwFirstHelp + PSEUDO_COUNTER;		// take care of pseudo

			// get namespace
			n = __Namespace::First ( m_perf );
			// goes accross all namespaces
			for ( DWORD dw1 = 0; dw1 < m_perf->dwChildCount; dw1++ )
			{
				// increment count of objects
				m_dwCount += n->dwChildCount;

				// get object
				o = __Object::First ( n );
				// goes accross all objects
				for ( DWORD dw2 = 0; dw2 < n->dwChildCount; dw2++ )
				{
					dwSize =	dwSize + 
								dwTotalByteLength +

								// PERF_COUNTER_DEFINITON child times
								sizeof ( PERF_COUNTER_DEFINITION ) * (int) o->dwChildCount +

								// real data size
								o->dwChildCount * sizeof ( __int64 ) ;

					dwSizeOrders = dwSizeOrders + o->dwChildCount;

					// go accross all of objects
					o = __Object::Next ( o );
				}

				// go accross all namespaces
				n = __Namespace::Next ( n );
			}

			// create real data :))
			data.MemCreate ( dwSize );

			if ( data.IsValid () )
			{
				if SUCCEEDED ( hRes = OrdersAlloc ( m_dwCount ) )
				{
					// get namespace
					n = __Namespace::First ( m_perf );
					// goes accross all namespaces
					for ( DWORD dw1 = 0; dw1 < m_perf->dwChildCount; dw1++ )
					{
						// get object
						o = __Object::First ( n );
						// goes accross all objects
						for ( DWORD dw2 = 0; dw2 < n->dwChildCount; dw2++ )
						{
							// order <---> index
							m_Ord2Ind[ dwIndex++ ] = dwCounter;

							// move counter
							dwCounter	+= 2;
							dwHelp		+= 2;

							// count by number of childs
							dwCounter	+= o->dwChildCount * 2;
							dwHelp		+= o->dwChildCount * 2;

							// go accross all of objects
							o = __Object::Next ( o );
						}

						// go accross all namespaces
						n = __Namespace::Next ( n );
					}
				}
			}
			else
			{
				hRes = E_OUTOFMEMORY;
			}
		}
		else
		{
			hRes = E_FAIL;
		}
	}
	catch ( ... )
	{
		hRes = E_UNEXPECTED;
	}

	return hRes;
}

extern CRITICAL_SECTION g_csInit;

////////////////////////////////////////////////////////////////////////////////////
// Initialize internal WMI_PERFORMANCE struct from registry
////////////////////////////////////////////////////////////////////////////////////

HRESULT	WmiPerformanceData::InitializePerformance ( void )
{
	HRESULT hRes = S_FALSE;

	if ( m_perf.IsEmpty() )
	{
		hRes		= E_FAIL;
		HRESULT hr	= S_OK;
		LONG lTry	= 3;

		// get bit of registry ( WMI internal )
		while ( SUCCEEDED ( hr ) && FAILED ( hRes ) && lTry-- )
		{
			BYTE* pData = NULL;

			if FAILED ( hRes = GetRegistry ( g_szKey, g_szKeyValue, &pData ) )
			{
				// simulate failure to finish loop
				hr = E_FAIL;

				if ( hRes == HRESULT_FROM_WIN32 ( ERROR_FILE_NOT_FOUND ) )
				{
					if ( ::TryEnterCriticalSection ( &g_csInit ) )
					{
						// lock & leave CS
						_App.InUseSet ( TRUE );
						::LeaveCriticalSection ( &g_csInit );

						try
						{
							// refresh everything ( internal )
							hr = ( ( WmiAdapterStuff*) _App )->Generate ( FALSE ) ;
						}
						catch ( ... )
						{
						}

						if ( ::TryEnterCriticalSection ( &g_csInit ) )
						{
							// unlock & leave CS
							_App.InUseSet ( FALSE );

							::LeaveCriticalSection ( &g_csInit );
						}
					}
				}
			}
			else
			{
				if ( pData )
				{
					// success so store data to m_perf structure
					m_perf.Attach ( reinterpret_cast < WMI_PERFORMANCE * > ( pData ) );
					pData = NULL;
				}
				else
				{
					hRes = S_FALSE;
				}
			}
		}
	}

	return hRes;
}

#include <poppack.h>
#endif	__SUPPORT_REGISTRY_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_helper_regtable.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					regtable.cpp
//
//	Abstract:
//
//					registry updater :-))
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////
//
//	This file contains the implementation of a routine that adds/removes
//	the table's registry entries and optionally registers a type library.
//
//	RegistryTableUpdateRegistry - adds/removes registry entries for table
//     
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

// definitions & macros
#include "wmi_helper_regtable.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

LONG MyRegDeleteKey(HKEY hkeyRoot, const WCHAR *pszKeyName)
{
    LONG err = ERROR_BADKEY;
    if (pszKeyName && lstrlenW(pszKeyName))
    {
        HKEY    hkey;
        err = RegOpenKeyExW(hkeyRoot, pszKeyName, 0, 
                           KEY_ENUMERATE_SUB_KEYS | KEY_SET_VALUE | DELETE, &hkey );
        if(err == ERROR_SUCCESS)
        {
            while (err == ERROR_SUCCESS )
            {
                enum { MAX_KEY_LEN = 1024 };
                WCHAR szSubKey[MAX_KEY_LEN] = { L'\0' }; 
                DWORD   dwSubKeyLength = MAX_KEY_LEN;
                err = RegEnumKeyExW(hkey, 0, szSubKey,
                                    &dwSubKeyLength, 0, 0, 0, 0);
                
                if(err == ERROR_NO_MORE_ITEMS)
                {
                    err = RegDeleteKeyW(hkeyRoot, pszKeyName);
                    break;
                }
                else if (err == ERROR_SUCCESS)
                    err = MyRegDeleteKey(hkey, szSubKey);
            }
            RegCloseKey(hkey);
            // Do not save return code because error has already occurred
        }
    }
    return err;
}

LONG RegDeleteKeyValue(HKEY hkeyRoot, const WCHAR *pszKeyName, const WCHAR *pszValueName)
{
    LONG err = ERROR_BADKEY;
    if (pszKeyName && lstrlenW(pszKeyName))
    {
        HKEY    hkey = NULL;
        err = RegOpenKeyExW(hkeyRoot, pszKeyName, 0, KEY_SET_VALUE | DELETE, &hkey );
        if(err == ERROR_SUCCESS)
            err = RegDeleteValueW(hkey, pszValueName);

        RegCloseKey(hkey);
    }
    return err;
}

////////////////////////////////////////////////////////////////////////////////////
// the routine that inserts/deletes Registry keys based on the table
////////////////////////////////////////////////////////////////////////////////////

EXTERN_C HRESULT STDAPICALLTYPE 
RegistryTableUpdateRegistry(REGISTRY_ENTRY *pEntries, BOOL bInstalling)
{
    HRESULT hr = S_OK;
    if (bInstalling)
    {
        if (pEntries)
        {
            REGISTRY_ENTRY *pHead = pEntries;
            WCHAR szKey[4096] = { L'\0' };
            HKEY hkeyRoot = 0;
        
            while (pEntries->fFlags != -1)
            {
                WCHAR szFullKey[4096] = { L'\0' };
                DWORD dwValue = pEntries->dwValue;
                if (pEntries->hkeyRoot)
                {
                    hkeyRoot = pEntries->hkeyRoot;
                    lstrcpyW(szKey, pEntries->pszKey);
                    lstrcpyW(szFullKey, pEntries->pszKey);
                }
                else
                {
                    lstrcpyW(szFullKey, szKey);
                    lstrcatW(szFullKey, L"\\");
                    lstrcatW(szFullKey, pEntries->pszKey);
                }
                if (hkeyRoot == 0)
                {
                    RegistryTableUpdateRegistry(pHead, FALSE);
                    return SELFREG_E_CLASS;

                }
                HKEY hkey; DWORD dw;
                if (pEntries->fFlags & (REGFLAG_DELETE_BEFORE_REGISTERING|REGFLAG_DELETE_WHEN_REGISTERING))
                {
                    LONG err = MyRegDeleteKey(hkeyRoot, szFullKey);
                    if (err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND) 
                    {
                        RegistryTableUpdateRegistry(pHead, FALSE);
                        return SELFREG_E_CLASS;
                    }
                }
                if (pEntries->fFlags & (REGFLAG_DELETE_ONLY_VALUE))
                {
					LONG err = RegDeleteKeyValue(hkeyRoot, szFullKey, pEntries->pszValueName);
					if (err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND)
						hr = SELFREG_E_CLASS;
				}
				else
                {
                    LONG err = RegCreateKeyExW(hkeyRoot, szFullKey,
                                               0, 0, REG_OPTION_NON_VOLATILE,
                                               KEY_WRITE, pEntries->pSA, &hkey, &dw);
                    if (err == ERROR_SUCCESS)
                    {
                        err = RegSetValueExW(hkey, pEntries->pszValueName, 0, REG_DWORD, (const BYTE *)(&dwValue), sizeof(DWORD));
                        RegCloseKey(hkey);
                        if (hkeyRoot == 0)
                        {
                            RegistryTableUpdateRegistry(pHead, FALSE);
                            return SELFREG_E_CLASS;
                        }
                    }
                    else
                    {
                        RegistryTableUpdateRegistry(pHead, FALSE);
                        return SELFREG_E_CLASS;
                    }
                }
                pEntries++;
            }
        }
    }
    else
    {
        if (pEntries)
        {
            WCHAR szKey[4096] = { L'\0' };
            HKEY hkeyRoot = 0;
        
            while (pEntries->fFlags != -1)
            {
                WCHAR szFullKey[4096] = { L'\0' };
                if (pEntries->hkeyRoot)
                {
                    hkeyRoot = pEntries->hkeyRoot;
                    lstrcpyW(szKey, pEntries->pszKey);
                    lstrcpyW(szFullKey, pEntries->pszKey);
                }
                else
                {
                    lstrcpyW(szFullKey, szKey);
                    lstrcatW(szFullKey, L"\\");
                    lstrcatW(szFullKey, pEntries->pszKey);
                }
                if (hkeyRoot)
				{
					if (!(pEntries->fFlags & REGFLAG_NEVER_DELETE) && 
						!(pEntries->fFlags & REGFLAG_DELETE_WHEN_REGISTERING) &&
						!(pEntries->fFlags & REGFLAG_DELETE_ONLY_VALUE))
					{
						LONG err = MyRegDeleteKey(hkeyRoot, szFullKey);
						if (err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND)
							hr = SELFREG_E_CLASS;
					}
					else
					if(pEntries->fFlags & REGFLAG_DELETE_ONLY_VALUE)
					{
						LONG err = RegDeleteKeyValue(hkeyRoot, szFullKey, pEntries->pszValueName);
						if (err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND)
							hr = SELFREG_E_CLASS;
					}
				}

                pEntries++;
            }
        }
    }
    return hr;
}

////////////////////////////////////////////////////////////////////////////////////
// the routine that inserts/deletes Registry keys based on the table
////////////////////////////////////////////////////////////////////////////////////

EXTERN_C HRESULT STDAPICALLTYPE 
RegistryTableUpdateRegistrySZ(REGISTRY_ENTRY_SZ *pEntries, BOOL bInstalling)
{
    HRESULT hr = S_OK;
    if (bInstalling)
    {
        if (pEntries)
        {
            REGISTRY_ENTRY_SZ *pHead = pEntries;
            WCHAR szKey[4096] = { L'\0' };
            HKEY hkeyRoot = 0;
        
            while (pEntries->fFlags != -1)
            {
                WCHAR szFullKey[4096] = { L'\0' };
                if (pEntries->hkeyRoot)
                {
                    hkeyRoot = pEntries->hkeyRoot;
                    lstrcpyW(szKey, pEntries->pszKey);
                    lstrcpyW(szFullKey, pEntries->pszKey);
                }
                else
                {
                    lstrcpyW(szFullKey, szKey);
                    lstrcatW(szFullKey, L"\\");
                    lstrcatW(szFullKey, pEntries->pszKey);
                }
                if (hkeyRoot == 0)
                {
                    RegistryTableUpdateRegistrySZ(pHead, FALSE);
                    return SELFREG_E_CLASS;

                }
                HKEY hkey; DWORD dw;
                if (pEntries->fFlags & (REGFLAG_DELETE_BEFORE_REGISTERING|REGFLAG_DELETE_WHEN_REGISTERING))
                {
                    LONG err = MyRegDeleteKey(hkeyRoot, szFullKey);
                    if (err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND) 
                    {
                        RegistryTableUpdateRegistrySZ(pHead, FALSE);
                        return SELFREG_E_CLASS;
                    }
                }
                if (pEntries->fFlags & (REGFLAG_DELETE_ONLY_VALUE))
                {
					LONG err = RegDeleteKeyValue(hkeyRoot, szFullKey, pEntries->pszValueName);
					if (err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND)
						hr = SELFREG_E_CLASS;
				}
				else
                {
                    LONG err = RegCreateKeyExW(hkeyRoot, szFullKey,
                                               0, 0, REG_OPTION_NON_VOLATILE,
                                               KEY_WRITE, pEntries->pSA, &hkey, &dw);
                    if (err == ERROR_SUCCESS)
                    {
						if (pEntries->pszValue)
                        err = RegSetValueExW(hkey, pEntries->pszValueName, 0, REG_SZ, (const BYTE *)(pEntries->pszValue), ( lstrlenW(pEntries->pszValue) + 1 ) * sizeof ( WCHAR ) );

                        RegCloseKey(hkey);
                        if (hkeyRoot == 0)
                        {
                            RegistryTableUpdateRegistrySZ(pHead, FALSE);
                            return SELFREG_E_CLASS;

                        }
                    }
                    else
                    {
                        RegistryTableUpdateRegistrySZ(pHead, FALSE);
                        return SELFREG_E_CLASS;

                    }
                }
                pEntries++;
            }
        }
    }
    else
    {
        if (pEntries)
        {
            WCHAR szKey[4096] = { L'\0' };
            HKEY hkeyRoot = 0;
        
            while (pEntries->fFlags != -1)
            {
                WCHAR szFullKey[4096] = { L'\0' };
                if (pEntries->hkeyRoot)
                {
                    hkeyRoot = pEntries->hkeyRoot;
                    lstrcpyW(szKey, pEntries->pszKey);
                    lstrcpyW(szFullKey, pEntries->pszKey);
                }
                else
                {
                    lstrcpyW(szFullKey, szKey);
                    lstrcatW(szFullKey, L"\\");
                    lstrcatW(szFullKey, pEntries->pszKey);
                }
                if (hkeyRoot)
				{
					if (!(pEntries->fFlags & REGFLAG_NEVER_DELETE) && 
						!(pEntries->fFlags & REGFLAG_DELETE_WHEN_REGISTERING) &&
						!(pEntries->fFlags & REGFLAG_DELETE_ONLY_VALUE))
					{
						LONG err = MyRegDeleteKey(hkeyRoot, szFullKey);
						if (err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND)
							hr = SELFREG_E_CLASS;
					}
					else
					if(pEntries->fFlags & REGFLAG_DELETE_ONLY_VALUE)
					{
						LONG err = RegDeleteKeyValue(hkeyRoot, szFullKey, pEntries->pszValueName);
						if (err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND)
							hr = SELFREG_E_CLASS;
					}
				}

                pEntries++;
            }
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_adapter_wrapper_pseudo.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_adapter_wrapper_pseudo.cpp
//
//	Abstract:
//
//					Defines pseudo counter implementation
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// definitions
#include "WMI_adapter_wrapper.h"
#include "RefresherUtils.h"

#define	cCountInstances	1
#define	cCountCounter	2

void WmiAdapterWrapper::AppendMemory ( BYTE* pStr, DWORD dwStr, DWORD& dwOffset )
{
	// append structure
	if ( dwOffset <= m_dwData )
	{
		DWORD dwCount = min ( dwStr, m_dwData - dwOffset );
		::CopyMemory ( m_pData + dwOffset, pStr, dwCount );
	}

	dwOffset += dwStr;

	return;
}

void WmiAdapterWrapper::AppendMemory ( DWORD dwValue, DWORD& dwOffset )
{
	* reinterpret_cast < PDWORD > ( m_pData + dwOffset ) = dwValue;
	dwOffset += sizeof ( DWORD );

	return;
}

extern LPCWSTR	g_szKeyCounter;

HRESULT	WmiAdapterWrapper::PseudoCreateRefresh ( )
{
	HRESULT hr = E_FAIL;

	DWORD	dwOffset	= 0L;
	DWORD	dwCount		= 0L;
	DWORD	dwHelp		= 0L;

	// get data from registry
	GetRegistrySame ( g_szKeyCounter, L"First Counter",	&dwCount );
	GetRegistrySame ( g_szKeyCounter, L"First Help",	&dwHelp );

	if ( dwCount && dwHelp && dwCount+1 == dwHelp )
	{
		m_dwPseudoCounter	= dwCount;
		m_dwPseudoHelp		= dwHelp;

		try
		{
			////////////////////////////////////////////////////////////////////
			// PERF_OBJECT_TYPE
			////////////////////////////////////////////////////////////////////

			#ifndef	_WIN64
			LPWSTR	Name = NULL;
			LPWSTR	Help = NULL;
			#endif	_WIN64

			// time
			unsigned __int64 _PerfTime = 0; 
			unsigned __int64 _PerfFreq = 0;

			AppendMemory (	m_dwData, dwOffset );
			AppendMemory (	sizeof ( PERF_OBJECT_TYPE ) + 
							sizeof ( PERF_COUNTER_DEFINITION ) * cCountCounter, dwOffset );
			AppendMemory (	sizeof ( PERF_OBJECT_TYPE ), dwOffset );

			AppendMemory (	dwCount, dwOffset );

			#ifndef	_WIN64
			AppendMemory (	(BYTE*)&Name, sizeof ( LPWSTR ), dwOffset );
			#else	_WIN64
			AppendMemory (	0, dwOffset );
			#endif	_WIN64

			AppendMemory (	dwHelp, dwOffset );

			#ifndef	_WIN64
			AppendMemory (	(BYTE*)&Help, sizeof ( LPWSTR ), dwOffset );
			#else	_WIN64
			AppendMemory (	0, dwOffset );
			#endif	_WIN64

			AppendMemory (	PERF_DETAIL_NOVICE, dwOffset );
			AppendMemory (	cCountCounter, dwOffset );
			AppendMemory (	( DWORD ) -1, dwOffset );
			AppendMemory (	( DWORD ) PERF_NO_INSTANCES, dwOffset );
			AppendMemory (	0, dwOffset );

			AppendMemory ( (BYTE*) &_PerfTime,	sizeof ( unsigned __int64 ), dwOffset );
			AppendMemory ( (BYTE*) &_PerfFreq,	sizeof ( unsigned __int64 ), dwOffset );

			// increment index :)))
			dwCount	+= 2;
			dwHelp	+= 2;

			for ( DWORD dw = 0; dw < cCountCounter; dw++ )
			{
				////////////////////////////////////////////////////////////////////
				// PERF_COUNTER_DEFINITION
				////////////////////////////////////////////////////////////////////

				AppendMemory ( sizeof ( PERF_COUNTER_DEFINITION), dwOffset );
				AppendMemory ( dwCount, dwOffset );

				#ifndef	_WIN64
				AppendMemory (	(BYTE*)&Name, sizeof ( LPWSTR ), dwOffset );
				#else	_WIN64
				AppendMemory (	0, dwOffset );
				#endif	_WIN64

				AppendMemory ( dwHelp, dwOffset );

				#ifndef	_WIN64
				AppendMemory (	(BYTE*)&Help, sizeof ( LPWSTR ), dwOffset );
				#else	_WIN64
				AppendMemory (	0, dwOffset );
				#endif	_WIN64

				AppendMemory ( (
									( dw == 0 ) ?
									(
										0
									)
									:
									(
										1
									)
								),
								dwOffset
							 );

				AppendMemory ( PERF_DETAIL_NOVICE, dwOffset );

				AppendMemory ( (
									( dw == 0 ) ?
									(
										PERF_SIZE_LARGE | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL
									)
									:
									(
										PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL
									)
								),
								dwOffset
							 );
				
				AppendMemory ( sizeof ( __int64 ), dwOffset );

				AppendMemory (	sizeof ( PERF_COUNTER_BLOCK ) + sizeof ( DWORD ) + 
								sizeof ( __int64 ) * (int) dw, dwOffset );

				// increment index :)))
				dwCount	+= 2;
				dwHelp	+= 2;
			}

			////////////////////////////////////////////////////////////////////
			// PERF_COUNTER_BLOCK
			////////////////////////////////////////////////////////////////////

			// append counter block
			AppendMemory	(	sizeof ( PERF_COUNTER_BLOCK ) +
								sizeof ( DWORD ) + 
								cCountCounter * sizeof ( __int64 ), dwOffset );

			// fill hole ( to be 8 aligned )
			// dwOffset +=  sizeof ( DWORD );
			AppendMemory (	0, dwOffset );

			/////////////////////////////////////////////////////////
			// resolve counter data
			/////////////////////////////////////////////////////////

			m_dwDataOffsetCounter = dwOffset;
			AppendMemory (	0, dwOffset );
			// fill hole ( to be 8 aligned )
			// dwOffset += sizeof ( __int64 ) - sizeof ( DWORD );
			AppendMemory (	0, dwOffset );

			m_dwDataOffsetValidity = dwOffset;
			AppendMemory (	0, dwOffset );
			// fill hole ( to be 8 aligned )
			// dwOffset += sizeof ( __int64 ) - sizeof ( DWORD );
			AppendMemory (	0, dwOffset );

			hr = S_OK;
		}
		catch ( ... )
		{
			PseudoDelete ();
		}
	}

	return hr;
}

HRESULT	WmiAdapterWrapper::PseudoCreate ()
{
	HRESULT hRes		= S_FALSE;

	if ( ! m_pData )
	{
		m_dwData	=	sizeof	( PERF_OBJECT_TYPE ) +
						sizeof	( PERF_COUNTER_DEFINITION ) * cCountCounter 
								+
								(
									cCountInstances * (
														 sizeof ( PERF_COUNTER_BLOCK ) + 
														 sizeof ( DWORD ) + 

														 (
															cCountCounter * sizeof ( __int64 )
														 )
													)
								);

		try
		{
			if ( ( m_pData = new BYTE [ m_dwData ] ) == NULL )
			{
				hRes = E_OUTOFMEMORY;
			}
		}
		catch ( ... )
		{
			PseudoDelete ();
			hRes = E_FAIL;
		}

		if SUCCEEDED ( hRes )
		{
			PseudoCreateRefresh ();
		}
	}
	else
	{
		hRes = E_UNEXPECTED;
	}

	return hRes;
}

void	WmiAdapterWrapper::PseudoDelete ()
{
	if ( m_pData )
	{
		delete [] m_pData;
		m_pData = NULL;
	}

	m_dwData		= 0L;

	m_dwDataOffsetCounter	= 0L;
	m_dwDataOffsetValidity	= 0L;
}

void	WmiAdapterWrapper::PseudoRefresh ( DWORD dwCount )
{
	DWORD dwOffset	= 0L;

	dwOffset = m_dwDataOffsetCounter;
	AppendMemory ( dwCount, dwOffset );
}

void	WmiAdapterWrapper::PseudoRefresh ( BOOL bValid )
{
	DWORD dwOffset	= 0L;
	DWORD dwValue	= 0L;
	
	dwOffset	= m_dwDataOffsetValidity;
	dwValue		= ( bValid ) ? 1 : 0 ;

	AppendMemory ( dwValue, dwOffset );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_memory.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_memory.cpp
//
//	Abstract:
//
//					defines simple memory ( byte * ) and its behaviour
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

// create memory
template < class CRITGUARD >
HRESULT WmiMemory < CRITGUARD > ::MemCreate ( LPWSTR wszName, DWORD dwSize, LPSECURITY_ATTRIBUTES )
{
	if ( wszName )
	{
		try
		{
			if ( ( m_wszName = new WCHAR [ ::lstrlenW ( wszName ) + 1 ] ) != NULL )
			{
				lstrcpyW ( m_wszName, wszName );
			}
			else
			{
				m_LastError = E_OUTOFMEMORY;
				return m_LastError;
			}
		}
		catch ( ... )
		{
			m_LastError = E_UNEXPECTED;
			return m_LastError;
		}
	}

	___ASSERT ( m_pData == NULL );

	if ( dwSize )
	{
		try
		{
			if ( ( m_pData = new BYTE [ dwSize ] ) != NULL )
			{
				// clear them
				::memset ( m_pData, 0, dwSize );

				m_pData[0] = NULL;
				m_dwDataSize = dwSize;
			}
			else
			{
				m_LastError = E_OUTOFMEMORY;
				return m_LastError;
			}
		}
		catch ( ... )
		{
			m_LastError = E_UNEXPECTED;
			return m_LastError;
		}
	}

	return S_OK;
}

// delete memory
template < class CRITGUARD >
HRESULT WmiMemory < CRITGUARD > ::MemDelete ()
{
	if ( m_wszName )
	{
		delete m_wszName;
		m_wszName = NULL;
	}

	if ( m_pData )
	{
		delete [] m_pData;
		m_pData = NULL;
	}

	m_dwDataSize = 0;

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// write into memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class CRITGUARD >
BOOL WmiMemory < CRITGUARD > ::Write (LPCVOID pBuffer, DWORD dwBytesToWrite, DWORD* pdwBytesWritten, DWORD dwOffset )
{
	// auto lock/unlock writing
	WmiReverseGUARD_Auto_Write < CRITGUARD > cs ( m_pGuard );

	___ASSERT(m_pData != NULL);

	if ( dwOffset > m_dwDataSize )
	{
		if ( pdwBytesWritten )
		{
			*pdwBytesWritten = 0;
		}

		m_LastError = E_INVALIDARG;
		return FALSE;
	}

	DWORD dwCount = min ( dwBytesToWrite, m_dwDataSize - dwOffset );
	::CopyMemory ((LPBYTE) m_pData + dwOffset, pBuffer, dwCount);

	if (pdwBytesWritten != NULL)
	{
		*pdwBytesWritten = dwCount;
	}

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// read from memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class CRITGUARD >
BOOL WmiMemory < CRITGUARD > ::Read (LPVOID pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead, DWORD dwOffset )
{
	___ASSERT (m_pData != NULL);

	// auto lock/unlock reading
	WmiReverseGUARD_Auto_Read < CRITGUARD > cs ( m_pGuard );

	if (dwOffset > m_dwDataSize)
	{
		if ( pdwBytesRead )
		{
			*pdwBytesRead = 0;
		}

		m_LastError = E_INVALIDARG;
		return FALSE;
	}

	DWORD dwCount = min (dwBytesToRead, m_dwDataSize - dwOffset);
	::CopyMemory (pBuffer, (LPBYTE) m_pData + dwOffset, dwCount);

	if (pdwBytesRead != NULL)
	{
		*pdwBytesRead = dwCount;
	}

	return TRUE;
}

template < class CRITGUARD >
PBYTE WmiMemory < CRITGUARD > ::Read ( DWORD* pdwBytesRead, DWORD dwOffset )
{
	___ASSERT (m_pData != NULL);

	// auto lock/unlock reading
	WmiReverseGUARD_Auto_Read < CRITGUARD > cs ( m_pGuard );

	if (dwOffset > m_dwDataSize)
	{
		*pdwBytesRead = 0;
		m_LastError = E_INVALIDARG;
		return NULL;
	}

	if (pdwBytesRead != NULL)
	{
		*pdwBytesRead = m_dwDataSize - dwOffset;
	}

	return (LPBYTE) m_pData + dwOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmiadapter_messages.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmiadapter_messages.h
//
//	Abstract:
//
//					export from resource dll
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMIADAPTERMESSAGES_H__
#define	__WMIADAPTERMESSAGES_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// export/import
#ifdef	WMIADAPTERMESSAGES_EXPORTS
#define	WMIADAPTERMESSAGES_API	__declspec(dllexport)
#else	! WMIADAPTERMESSAGES_EXPORTS
#define	WMIADAPTERMESSAGES_API	__declspec(dllimport)
#endif	WMIADAPTERMESSAGES_EXPORTS

// registration exports
WMIADAPTERMESSAGES_API HRESULT __stdcall Register_Messages		( void );
WMIADAPTERMESSAGES_API HRESULT __stdcall Unregister_Messages	( void );

#endif	__WMIADAPTERMESSAGES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_perf_data_ext.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_data_ext.cpp
//
//	Abstract:
//
//					extension to internal data struture
//					access registry ...
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "WMI_perf_data_ext.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

void WmiPerformanceDataExt::Generate ( void )
{
	// get data from registry ( COUNTER )
	GetRegistrySame ( g_szKeyCounter, L"First Counter",	&m_dwFirstCounter );
	GetRegistrySame ( g_szKeyCounter, L"First Help",	&m_dwFirstHelp );
	GetRegistrySame ( g_szKeyCounter, L"Last Counter",	&m_dwLastCounter );
	GetRegistrySame ( g_szKeyCounter, L"Last Help",		&m_dwLastHelp );
}

///////////////////////////////////////////////////////////////////////////////
// IsValid
///////////////////////////////////////////////////////////////////////////////
BOOL	WmiPerformanceDataExt::IsValidGenerate ( )
{
	return	(
				m_dwFirstCounter &&
				m_dwFirstHelp && 
				m_dwLastCounter &&
				m_dwLastHelp &&

				( m_dwFirstCounter < m_dwLastCounter ) &&
				( m_dwFirstHelp < m_dwLastHelp ) &&


				( m_dwFirstCounter + 1 == m_dwFirstHelp ) &&
				( m_dwLastCounter + 1 == m_dwLastHelp )
			);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_perf_reg.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_reg.cpp
//
//	Abstract:
//
//					definitions of registry helpers
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// definitions
#include "wmi_perf_reg.h"
#include <pshpack8.h>

//////////////////////////////////////////////////////////////////////////////////////////////
// construction & destruction
//////////////////////////////////////////////////////////////////////////////////////////////

CPerformanceRegistry::CPerformanceRegistry( PWMI_PERFORMANCE pPerf ):
m_pPerf ( NULL )
{
	m_pPerf = pPerf;
}

CPerformanceRegistry::~CPerformanceRegistry()
{
	m_pPerf = NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// methods
//////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CPerformanceRegistry::GetObject ( DWORD dwIndex, PWMI_PERF_OBJECT* ppObject )
{
	// test out pointer
	if ( ! ppObject )
		return E_POINTER;

	// default value
	( *ppObject ) = NULL;

	// look out
	if ( m_pPerf )
	{
		if ( m_pPerf->dwChildCount )
		{
			DWORD				dwHelper	= 0;
			PWMI_PERF_NAMESPACE	pNamespace	= __Namespace::First ( m_pPerf );

			while ( ( ++dwHelper < m_pPerf->dwChildCount ) && ( pNamespace->dwLastID < dwIndex ) )
			{
				pNamespace = __Namespace::Next ( pNamespace );
			}

			( *ppObject ) = __Object::Get ( pNamespace, dwIndex );

			if ( ( *ppObject ) )
			{
				return S_OK;
			}
		}

		return E_FAIL;
	}

	return E_UNEXPECTED;
}

HRESULT CPerformanceRegistry::GetObjectName ( DWORD dwIndex, LPWSTR* ppwsz )
{
	// test out pointer
	if ( ! ppwsz )
	{
		return E_POINTER;
	}

	// default value
	( *ppwsz ) = NULL;

	// local variables
	PWMI_PERF_OBJECT pObject = NULL;

	// look out
	if SUCCEEDED ( GetObject ( dwIndex, &pObject ) )
	{
		( *ppwsz ) = __Object::GetName ( pObject );

		if ( ( *ppwsz ) )
		{
			return S_OK;
		}

		return E_FAIL;
	}

	return E_UNEXPECTED;
}

#include <poppack.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmiadapter_service.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmiadapter_service.h
//
//	Abstract:
//
//					declaration of service module
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__SERVICE_H__
#define	__SERVICE_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

class WmiAdapterService
{
	DECLARE_NO_COPY ( WmiAdapterService );

    SERVICE_STATUS_HANDLE	m_hServiceStatus;
    SERVICE_STATUS			m_ServiceStatus;

	CRITICAL_SECTION m_cs;

	BOOL	m_bUsed;

	public:

	///////////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	///////////////////////////////////////////////////////////////////////////////////////////////

	WmiAdapterService() :
		m_hServiceStatus ( NULL ),
		m_bUsed ( FALSE )
	{
		::InitializeCriticalSection ( &m_cs );
	}

	~WmiAdapterService();

	///////////////////////////////////////////////////////////////////////////////////////////////
	// start
	///////////////////////////////////////////////////////////////////////////////////////////////

	BOOL StartService ( void );

	///////////////////////////////////////////////////////////////////////////////////////////////
	// service status
	///////////////////////////////////////////////////////////////////////////////////////////////
	BOOL			SetServiceStatus ( DWORD dwState );
	SERVICE_STATUS* GetServiceStatus ( void ) const;

	void WINAPI ServiceMain		( DWORD dwArgc, LPWSTR* lpszArgv );
    void WINAPI ServiceHandler	( DWORD dwOpcode);

	///////////////////////////////////////////////////////////////////////////////////////////////
	// initialization
	///////////////////////////////////////////////////////////////////////////////////////////////
	HRESULT Init ( void );

	///////////////////////////////////////////////////////////////////////////////////////////////
	// registration
	///////////////////////////////////////////////////////////////////////////////////////////////
	HRESULT	RegisterService ( void );

	///////////////////////////////////////////////////////////////////////////////////////////////
	// unregistration
	///////////////////////////////////////////////////////////////////////////////////////////////
	HRESULT	UnregisterService ( bool bStatus = true );

	///////////////////////////////////////////////////////////////////////////////////////////////
	// MAIN WORK ROUTINE
	///////////////////////////////////////////////////////////////////////////////////////////////
	LONG Work();

	private:

	///////////////////////////////////////////////////////////////////////////////////////////////
	// service initializators
	///////////////////////////////////////////////////////////////////////////////////////////////

	static void WINAPI _ServiceMain		( DWORD dwArgc, LPWSTR* lpszArgv );
	static void WINAPI _ServiceHandler	( DWORD dwOpcode );

	///////////////////////////////////////////////////////////////////////////////////////////////
	// is service installed
	//
	// -1	... internal error
	// 0	... not installed
	// 1	... installed
	//
	///////////////////////////////////////////////////////////////////////////////////////////////

	int IsInstalled ( SC_HANDLE hSC );
};

extern WmiAdapterService _Service;

#endif	__SERVICE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_perf_data_create.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_perf_data_create.cpp
//
//	Abstract:
//
//					implements creation of internal data structure
//					( using registry structure )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "WMI_perf_data.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "wmi_perf_reg.h"

#include "WMIAdapter_Stuff.h"

#ifdef	__SUPPORT_REGISTRY_DATA

inline void WmiPerformanceData::AppendMemory ( BYTE* pStr, DWORD dwStr, DWORD& dwOffset )
{
	// append structure
	data.Write ( pStr, dwStr, NULL, dwOffset );
	dwOffset += dwStr;

	return;
}
inline void WmiPerformanceData::AppendMemory ( DWORD dwValue, DWORD& dwOffset )
{
	// append structure
	data.Write ( dwValue, dwOffset );
	dwOffset += sizeof ( DWORD );

	return;
}

#include <pshpack8.h>

////////////////////////////////////////////////////////////////////////////////////
//
//	-------------------------
//	-------------------------
//	WHAT TO RESOLVE IN FINAL:
//	-------------------------
//	-------------------------
//
//	PERF_OBJECT_TYPE:
//
//		... default counter ( doesn't supported )
//
//	PERF_COUNTER_DEFINITION:
//
//		... DONE
//
//	PERF_INSTANCE_DEFINITION:
//
//		... DONE
//
//	PERF_COUNTER_BLOCK:
//
//		... DONE
//
////////////////////////////////////////////////////////////////////////////////////

HRESULT	WmiPerformanceData::CreateData	(
											__WrapperARRAY< WmiRefresherMember < IWbemHiPerfEnum >* > & enums,
											__WrapperARRAY< WmiRefreshObject* >	& handles
										)
{
	if ( ! m_perf )
	{
		return E_FAIL;
	}

	if ( enums.IsEmpty() || handles.IsEmpty() )
	{
		return E_INVALIDARG;
	}

	HRESULT hRes = S_OK;

	DWORD dwCount = m_dwFirstCounter + PSEUDO_COUNTER;	// take care of pseudo
	DWORD dwHelp  = m_dwFirstHelp + PSEUDO_COUNTER;		// take care of pseudo

	// index of current object
	DWORD		dwIndex	= 0L;
	DWORD		offset	= 0;

	// get namespace
	PWMI_PERF_NAMESPACE n = __Namespace::First ( m_perf );
	for ( DWORD dw = 0; dw < m_perf->dwChildCount; dw++ )
	{
		// get object
		PWMI_PERF_OBJECT	o = __Object::First ( n );
		for ( DWORD dwo = 0; dwo < n->dwChildCount; dwo++ )
		{
			// enum contains all instances of object
			IWbemHiPerfEnum*			pEnum	= NULL;

			// refresher helper object
			WmiRefreshObject*			pObj	= NULL;

			if ( o )
			{
				try
				{
					pObj = handles.GetAt ( dwIndex );
				}
				catch ( ... )
				{
					pObj = NULL;
				}

				try
				{
					// create IWbemHiPerfEnum
					if ( enums.GetAt ( dwIndex ) && ( enums.GetAt ( dwIndex ) )->IsValid() )
					{
						pEnum = ( enums.GetAt ( dwIndex ) )->GetMember();
					}
				}
				catch ( ... )
				{
					pEnum = NULL;
				}

				if ( pEnum && pObj )
				{
					hRes = CreateDataInternal (	o,
												pEnum,
												pObj,
												dwCount,
												dwHelp,
												&offset
											  );
				}
				else
				{
					// object is not properly created
					__SetValue ( m_pDataTable, (DWORD) -1,	offsetObject + ( dwIndex * ( ObjectSize ) + offValidity ) );

					// increment object
					dwCount += 2;
					dwHelp	+= 2;

					// increment its counters
					dwCount += o->dwChildCount * 2;
					dwHelp	+= o->dwChildCount * 2;
				}

				dwIndex++;
			}
			else
			{
				hRes = E_UNEXPECTED;
			}

			if FAILED ( hRes )
			{
				//stop loops immediately;
				dwo = n->dwChildCount;
				dw  = m_perf->dwChildCount;
			}

			if ( dwo < n->dwChildCount - 1 )
			{
				// go accross all of objects
				o = __Object::Next ( o );
			}
		}

		if ( dw < m_perf->dwChildCount - 1 )
		{
			// go accross all namespaces
			n = __Namespace::Next ( n );
		}
	}

	return hRes;
}

////////////////////////////////////////////////////////////////////////////////////
// Create object from internal structure
////////////////////////////////////////////////////////////////////////////////////

HRESULT	WmiPerformanceData::CreateDataInternal ( PWMI_PERF_OBJECT pObject,
												 IWbemHiPerfEnum* enm,
												 WmiRefreshObject* obj,
												 DWORD& dwCounter,
												 DWORD& dwHelp,
												 DWORD* dwOffset
											   )
{
	// S_FALSE is going to be checked in the future if object is supposed to be shown in perfmon
	// this signals it is not having required properties 
	HRESULT hRes = S_FALSE;

	// find out how many objects :))
	IWbemObjectAccess**	ppAccess = NULL;
	DWORD				dwAccess = 0;

	// count size we really need
	DWORD dwTotalByteLength			= 0;
	DWORD dwTotalByteLengthOffset	= ( *dwOffset );

	if ( pObject->dwChildCount )
	{
		// Try to get the instances from the enumerator
		// ============================================

		hRes = enm->GetObjects( 0L, dwAccess, ppAccess, &dwAccess );

		// Is the buffer too small? ( HAS TO BE, OTHERWISE WMI IS SCREWED )
		// ========================

		if ( WBEM_E_BUFFER_TOO_SMALL == hRes )
		{
			// Increase the buffer size
			// ========================

			try
			{
				if ( ( ppAccess = new IWbemObjectAccess*[dwAccess] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}
			}
			catch ( ... )
			{
				return E_FAIL;
			}

			// get all objects
			hRes = enm->GetObjects( 0L, dwAccess, ppAccess, &dwAccess );
		}
		else
		{
			// it has to be small for the first time
			return hRes;
		}
	}

	if ( pObject->dwSingleton )
	{
		dwTotalByteLength		=	sizeof ( PERF_OBJECT_TYPE ) +
									sizeof ( PERF_COUNTER_DEFINITION ) * (int) pObject->dwChildCount +

									(
										( pObject->dwChildCount != 0 ) ?
										(
											dwAccess * sizeof ( PERF_INSTANCE_DEFINITION ) +

											dwAccess * (
														 sizeof ( PERF_COUNTER_BLOCK ) + 
														 sizeof ( DWORD ) + 

														 (
														 pObject->dwChildCount * sizeof ( __int64 )
														 )
													   )
										)
										:
										0
									);
	}
	else
	{
		dwTotalByteLength		=	sizeof ( PERF_OBJECT_TYPE ) +
									sizeof ( PERF_COUNTER_DEFINITION ) * (int) pObject->dwChildCount +

									(
										( pObject->dwChildCount != 0 ) ?
										(
											dwAccess * (
														 sizeof ( PERF_COUNTER_BLOCK ) + 
														 sizeof ( DWORD ) + 

														 (
														 pObject->dwChildCount * sizeof ( __int64 )
														 )
													   )
										)
										:
										0
									);
	}

	try
	{
		// get object
		PWMI_PERF_OBJECT o = pObject;

		/////////////////////////////////////////////////////////////////
		// resolve object
		/////////////////////////////////////////////////////////////////

		try
		{
			#ifndef	_WIN64
			LPWSTR	objectName = NULL;
			LPWSTR	objectHelp = NULL;
			#endif	_WIN64

			// time
			unsigned __int64 _PerfTime = 0; 
			unsigned __int64 _PerfFreq = 0;

			if ( ppAccess && obj->m_pHandles[0] )
			{
				ppAccess[0]->ReadQWORD( obj->m_pHandles[0], &_PerfTime );
			}

			if ( ppAccess && obj->m_pHandles[1] )
			{
				ppAccess[0]->ReadQWORD( obj->m_pHandles[1], &_PerfFreq );
			}

			AppendMemory (	dwTotalByteLength, ( *dwOffset ) );
			AppendMemory (	sizeof ( PERF_OBJECT_TYPE ) + 
							sizeof ( PERF_COUNTER_DEFINITION ) * (int) o->dwChildCount, ( *dwOffset ) );
			AppendMemory (	sizeof ( PERF_OBJECT_TYPE ), ( *dwOffset ) );
			AppendMemory (	dwCounter, ( *dwOffset ) );

			#ifndef	_WIN64
			AppendMemory (	(BYTE*)&objectName, sizeof ( LPWSTR ), ( *dwOffset ) );
			#else	_WIN64
			AppendMemory (	0, ( *dwOffset ) );
			#endif	_WIN64

			AppendMemory (	dwHelp, ( *dwOffset ) );

			#ifndef	_WIN64
			AppendMemory (	(BYTE*)&objectHelp, sizeof ( LPWSTR ), ( *dwOffset ) );
			#else	_WIN64
			AppendMemory (	0, ( *dwOffset ) );
			#endif	_WIN64

			AppendMemory (	o->dwDetailLevel, ( *dwOffset ) );
			AppendMemory (	o->dwChildCount, ( *dwOffset ) );
			AppendMemory (	(DWORD)-1, ( *dwOffset ) );
			AppendMemory (	( ( o->dwSingleton == 0 ) ? PERF_NO_INSTANCES : dwAccess ), ( *dwOffset ) );
			AppendMemory (	0, ( *dwOffset ) );
			AppendMemory ( (BYTE*) &_PerfTime,				sizeof ( unsigned __int64 ), ( *dwOffset ) );
			AppendMemory ( (BYTE*) &_PerfFreq,				sizeof ( unsigned __int64 ), ( *dwOffset ) );

			// increment index :)))
			dwCounter	+= 2;
			dwHelp		+= 2;

			/////////////////////////////////////////////////////////////////
			// resolve property
			/////////////////////////////////////////////////////////////////

			// get property
			PWMI_PERF_PROPERTY p = NULL;

			if ( o->dwSingleton )
			{
				// jump across instance
				PWMI_PERF_INSTANCE i = (PWMI_PERF_INSTANCE) ( reinterpret_cast<PBYTE>( o ) + o->dwLength );
				p = (PWMI_PERF_PROPERTY) ( reinterpret_cast<PBYTE>( i ) + i->dwLength );
			}
			else
			{
				p = __Property::First ( o );
			}

			// goes accross all properties
			for ( DWORD dw = 0; dw < o->dwChildCount; dw++ )
			{
				if ( p )
				{
					try
					{
						#ifndef	_WIN64
						LPWSTR	_CounterNameTitle      =	NULL; 
						LPWSTR	_CounterHelpTitle      =	NULL;
						#endif	_WIN64

						AppendMemory ( sizeof ( PERF_COUNTER_DEFINITION), ( *dwOffset ) );
						AppendMemory ( dwCounter, ( *dwOffset ) );

						#ifndef	_WIN64
						AppendMemory ( (BYTE*) &_CounterNameTitle,		sizeof ( LPWSTR ), ( *dwOffset ) );
						#else	_WIN64
						AppendMemory ( 0, ( *dwOffset ) );
						#endif	_WIN64

						AppendMemory ( dwHelp, ( *dwOffset ) );

						#ifndef	_WIN64
						AppendMemory ( (BYTE*) &_CounterHelpTitle,		sizeof ( LPWSTR ), ( *dwOffset ) );
						#else	_WIN64
						AppendMemory ( 0, ( *dwOffset ) );
						#endif	_WIN64

						AppendMemory ( p->dwDefaultScale, ( *dwOffset ) );
						AppendMemory ( p->dwDetailLevel, ( *dwOffset ) );
						AppendMemory ( p->dwCounterType, ( *dwOffset ) );
						AppendMemory ( sizeof ( __int64 ), ( *dwOffset ) );
						AppendMemory ( sizeof ( PERF_COUNTER_BLOCK ) + 
									   sizeof ( DWORD ) + 
									   sizeof ( __int64 ) * (int) dw, ( *dwOffset ) );

						// increment index :)))
						dwCounter	+= 2;
						dwHelp		+= 2;
					}
					catch ( ... )
					{
						// unexpected error
						___TRACE ( L"unexpected error" );
						hRes = E_UNEXPECTED;
						goto myCleanup;
					}

					// get next property
					p = __Property::Next ( p );
				}
				else
				{
					// out of resources
					___TRACE ( L"out of resources" );
					hRes = E_OUTOFMEMORY;
					goto myCleanup;
				}
			}

			/////////////////////////////////////////////////////////////////
			// resolve instances and perf_counter_block
			/////////////////////////////////////////////////////////////////

			if ( o->dwChildCount )
			{
				if ( ppAccess && o->dwSingleton )
				{
					// instances ( resolve instances -> counter block )
					PWMI_PERF_INSTANCE i = (PWMI_PERF_INSTANCE) ( reinterpret_cast<PBYTE>( o ) + o->dwLength );

					for ( DWORD dwi = 0; dwi < dwAccess; dwi++ )
					{
						WCHAR wszNameSimulated [ _MAX_PATH ] = { L'\0' };

						LPWSTR	wszName = NULL;
						DWORD	dwName	= 0L;

						// real length of string
						DWORD	dwHelpLength = 0L;

						CComVariant v;
						CComVariant vsz;

						CComPtr < IWbemClassObject > pClass;
						if SUCCEEDED ( hRes = ppAccess[dwi]->QueryInterface ( __uuidof ( IWbemClassObject ), ( void ** ) &pClass ) )
						{
							if SUCCEEDED ( hRes = pClass->Get	(	reinterpret_cast<LPWSTR> (&(i->dwName)),
																	0,
																	&v,
																	NULL,
																	NULL
																)
									  )
							{
								if ( V_VT ( &v ) != VT_BSTR )
								{
									if SUCCEEDED ( hRes = ::VariantChangeType ( &vsz, &v, VARIANT_NOVALUEPROP, VT_BSTR ) )
									{
										// cached name :))
										wszName = V_BSTR ( & vsz );
										dwHelpLength = ::SysStringLen ( V_BSTR ( &vsz ) ) + 1;
									}
								}
								else
								{
									// cached name :))
									wszName = V_BSTR ( & v );
									dwHelpLength = ::SysStringLen ( V_BSTR ( &v ) ) + 1;
								}
							}
						}

						// have to simulate instance name
						if FAILED ( hRes )
						{
							wsprintfW ( wszNameSimulated, L"_simulated_%d", dwi );

							wszName = wszNameSimulated;
							dwHelpLength = ::lstrlenW( wszName ) + 1;

							hRes = S_FALSE;
						}

						// cached size :))
						if ( ( dwHelpLength ) % 8 )
						{
							DWORD dwRem = 8 - ( ( dwHelpLength ) % 8 );
							dwName = sizeof ( WCHAR ) * ( ( dwHelpLength ) + dwRem );
						}
						else
						{
							dwName = sizeof ( WCHAR ) * ( dwHelpLength );
						}

						// change size to be real one
						dwTotalByteLength += dwName;

						p = (PWMI_PERF_PROPERTY) ( reinterpret_cast<PBYTE>( i ) + i->dwLength );
						/////////////////////////////////////////////////////////
						// resolve instance
						/////////////////////////////////////////////////////////

						try
						{
							AppendMemory ( sizeof ( PERF_INSTANCE_DEFINITION ) + dwName, ( *dwOffset ) );
							AppendMemory ( 0, ( *dwOffset ) );
							AppendMemory ( 0, ( *dwOffset ) );
							AppendMemory ( (DWORD)PERF_NO_UNIQUE_ID, ( *dwOffset ) );
							AppendMemory (	sizeof ( PERF_INSTANCE_DEFINITION ) +
											dwName -
											dwHelpLength * sizeof ( WCHAR ), ( *dwOffset ) );

							AppendMemory ( dwHelpLength * sizeof ( WCHAR ), ( *dwOffset ) );

							( *dwOffset ) += ( dwName - ( dwHelpLength * sizeof ( WCHAR ) ) );

							// copy string into structure
							AppendMemory (	(BYTE*) wszName,
											dwHelpLength * sizeof ( WCHAR ),
											( *dwOffset )
										 );
						}
						catch ( ... )
						{
							// unexpected error
							___TRACE ( L"unexpected error" );
							hRes = E_UNEXPECTED;
						}

						// append counter block
						AppendMemory	(	sizeof ( PERF_COUNTER_BLOCK ) +
											sizeof ( DWORD ) + 
											o->dwChildCount * sizeof ( __int64 ), ( *dwOffset ) );

						// fill hole ( to be 8 aligned )
						( *dwOffset ) +=  sizeof ( DWORD );

						/////////////////////////////////////////////////////////
						// resolve counter data
						/////////////////////////////////////////////////////////

						IWbemObjectAccess* pAccess = NULL;
						if ( ppAccess )
						{
							pAccess = ppAccess[dwi];
						}

						for ( dw = 0; dw < o->dwChildCount; dw++ )
						{
							if ( pAccess )
							{
								if ( p->dwTYPE == CIM_SINT32 || p->dwTYPE == CIM_UINT32 )
								{
									DWORD dwVal = 0;

									// Read the counter property value using the high performance IWbemObjectAccess->ReadDWORD().
									// NOTE: Remember to never to this while a refresh is in process!
									// ==========================================================================================

									if FAILED ( hRes = pAccess->ReadDWORD( obj->m_pHandles[dw+2], &dwVal) )
									{
										___TRACE ( L"... UNABLE TO READ DWORD DATA :))) " );
										goto myCleanup;
									}

									/////////////////////////////////////////////////////////
									// append DATA
									/////////////////////////////////////////////////////////
									AppendMemory (	dwVal, ( *dwOffset ) );
									( *dwOffset ) += sizeof ( __int64 ) - sizeof ( DWORD );
								}
								else
								if ( p->dwTYPE == CIM_SINT64 || p->dwTYPE == CIM_UINT64 )
								{
									unsigned __int64 qwVal = 0;

									// Read the counter property value using the high performance IWbemObjectAccess->ReadDWORD().
									// NOTE: Remember to never to this while a refresh is in process!
									// ==========================================================================================

									if FAILED ( hRes = pAccess->ReadQWORD( obj->m_pHandles[dw+2], &qwVal) )
									{
										___TRACE ( L"... UNABLE TO READ QWORD DATA :))) " );
										goto myCleanup;
									}

									/////////////////////////////////////////////////////////
									// append DATA
									/////////////////////////////////////////////////////////
									AppendMemory (	(BYTE*)&qwVal, sizeof ( __int64 ), ( *dwOffset ) );
								}
								else
								{
									DWORD dwVal = (DWORD) -1;

									/////////////////////////////////////////////////////////
									// append DATA
									/////////////////////////////////////////////////////////
									AppendMemory (	dwVal, ( *dwOffset ) );
									( *dwOffset ) += sizeof ( __int64 ) - sizeof ( DWORD );
								}
							}
							else
							{
								DWORD dwVal = (DWORD) -1;

								/////////////////////////////////////////////////////////
								// append DATA
								/////////////////////////////////////////////////////////
								AppendMemory (	dwVal, ( *dwOffset ) );
								( *dwOffset ) += sizeof ( __int64 ) - sizeof ( DWORD );
							}

							// next property
							p = __Property::Next ( p );
						}
					}

					AppendMemory (	dwTotalByteLength, dwTotalByteLengthOffset );
				}
				else
				{
					// append counter block
					AppendMemory	(	sizeof ( PERF_COUNTER_BLOCK ) +
										sizeof ( DWORD ) + 
										o->dwChildCount * sizeof ( __int64 ), ( *dwOffset ) );

					// fill hole ( to be 8 aligned )
					( *dwOffset ) +=  sizeof ( DWORD );

					/////////////////////////////////////////////////////////
					// resolve counter data
					/////////////////////////////////////////////////////////

					IWbemObjectAccess* pAccess = NULL;
					if ( ppAccess )
					{
						pAccess = ppAccess[0];
					}

					// property
					p = __Property::First ( o );

					for ( dw = 0; dw < o->dwChildCount; dw++ )
					{
						if ( pAccess )
						{
							if ( p->dwTYPE == CIM_SINT32 || p->dwTYPE == CIM_UINT32 )
							{
								DWORD dwVal = 0;

								// Read the counter property value using the high performance IWbemObjectAccess->ReadDWORD().
								// NOTE: Remember to never to this while a refresh is in process!
								// ==========================================================================================

								if FAILED ( hRes = pAccess->ReadDWORD( obj->m_pHandles[dw+2], &dwVal) )
								{
									___TRACE ( L"... UNABLE TO READ DWORD DATA :))) " );
									goto myCleanup;
								}

								/////////////////////////////////////////////////////////
								// append DATA
								/////////////////////////////////////////////////////////
								AppendMemory (	dwVal, ( *dwOffset ) );
								( *dwOffset ) += sizeof ( __int64 ) - sizeof ( DWORD );
							}
							else
							if ( p->dwTYPE == CIM_SINT64 || p->dwTYPE == CIM_UINT64 )
							{
								unsigned __int64 qwVal = 0;

								// Read the counter property value using the high performance IWbemObjectAccess->ReadDWORD().
								// NOTE: Remember to never to this while a refresh is in process!
								// ==========================================================================================

								if FAILED ( hRes = pAccess->ReadQWORD( obj->m_pHandles[dw+2], &qwVal) )
								{
									___TRACE ( L"... UNABLE TO READ QWORD DATA :))) " );
									goto myCleanup;
								}

								/////////////////////////////////////////////////////////
								// append DATA
								/////////////////////////////////////////////////////////
								AppendMemory (	(BYTE*)&qwVal, sizeof ( __int64 ), ( *dwOffset ) );
							}
							else
							{
								DWORD dwVal = (DWORD) -1;

								/////////////////////////////////////////////////////////
								// append DATA
								/////////////////////////////////////////////////////////
								AppendMemory (	dwVal, ( *dwOffset ) );
								( *dwOffset ) += sizeof ( __int64 ) - sizeof ( DWORD );
							}
						}
						else
						{
							DWORD dwVal = (DWORD) -1;

							/////////////////////////////////////////////////////////
							// append DATA
							/////////////////////////////////////////////////////////
							AppendMemory (	dwVal, ( *dwOffset ) );
							( *dwOffset ) += sizeof ( __int64 ) - sizeof ( DWORD );
						}

						// next property
						p = __Property::Next ( p );
					}
				}
			}
		}
		catch ( ... )
		{
			// unexpected error
			___TRACE ( L"unexpected error" );
			hRes = E_UNEXPECTED;
		}
	}
	catch ( ... )
	{
		// unexpected error
		___TRACE ( L"unexpected error" );
		hRes = E_UNEXPECTED;
	}

	myCleanup:

	// Release the objects from the enumerator's object array
	// ======================================================
	
	if ( ppAccess )
	{
		for ( DWORD nCtr = 0; nCtr < dwAccess; nCtr++ )
		{
			if (NULL != ppAccess[nCtr])
			{
				ppAccess[nCtr]->Release();
				ppAccess[nCtr] = NULL;
			}
		}
	}

	if ( NULL != ppAccess )
		delete [] ppAccess;

	// return
	return hRes;
}

#include <poppack.h>

#endif	__SUPPORT_REGISTRY_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmiadapter_app.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmiadapter_app.h
//
//	Abstract:
//
//					declaration of application module
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__APP_H__
#define	__APP_H__

#include "..\WmiAdapter\resource.h"

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// event log
#include "wmi_eventlog_base.h"

// security
#include "wmi_security.h"
#include "wmi_security_attributes.h"

// stuff
#include "WMIAdapter_Stuff.h"

extern LPCWSTR	g_szAppName;

///////////////////////////////////////////////////////////////////////////////
//
// APPLICATION WRAPPER
//
///////////////////////////////////////////////////////////////////////////////

class WmiAdapterApp
{
	DECLARE_NO_COPY ( WmiAdapterApp );

	// critical section ( MAIN GUARD OF APP )
	CRITICAL_SECTION m_cs;

	// variables

	__SmartHANDLE	m_hInstance;	// test for previous instance

	// event log
	__WrapperPtr<CPerformanceEventLogBase> pEventLog;

	// security
	__WrapperPtr<WmiSecurityAttributes> pSA;

	// stuff
	__WrapperPtr<WmiAdapterStuff> pStuff;

	BOOL			m_bInUse;			// in use

	#ifdef	__SUPPORT_WAIT
	__SmartHANDLE	m_hData;			// data ready
	#endif	__SUPPORT_WAIT

	__SmartHANDLE	m_hInit;
	__SmartHANDLE	m_hUninit;

	public:

	BOOL			m_bManual;			// type of start up

	HMODULE			m_hResources;		// resources ( messages etc )
	__SmartHANDLE	m_hKill;			// kill ( service / com )

	HANDLE	GetInit() const
	{	
		ATLTRACE (	L"*************************************************************\n"
					L"WmiAdapterApp init handle value\n"
					L"*************************************************************\n" );

		return m_hInit;
	}

	HANDLE	GetUninit() const
	{	
		ATLTRACE (	L"*************************************************************\n"
					L"WmiAdapterApp uninit handle value\n"
					L"*************************************************************\n" );

		return m_hUninit;
	}

	///////////////////////////////////////////////////////////////////////////
	// in use
	///////////////////////////////////////////////////////////////////////////

	BOOL	InUseGet() const
	{
		ATLTRACE (	L"*************************************************************\n"
					L"WmiAdapterApp inuse GET\n"
					L"*************************************************************\n" );

		return m_bInUse;
	}

	void	InUseSet( const BOOL bInUse )
	{
		ATLTRACE (	L"*************************************************************\n"
					L"WmiAdapterApp inuse SET\n"
					L"*************************************************************\n" );

		m_bInUse = bInUse;
	}

	#ifdef	__SUPPORT_WAIT
	BOOL	SignalData ( BOOL bSignal = TRUE )
	{
		BOOL bResult = FALSE;

		if ( m_hData.GetHANDLE() != NULL )
		{
			if ( ! bSignal )
			{
				::ResetEvent ( m_hData );

				ATLTRACE ( L"\n SignalData TRUE ( non signaled )\n" );
				bResult = TRUE;
			}
			else
			if ( ::WaitForSingleObject ( m_hData, 0 ) != WAIT_OBJECT_0 )
			{
				::SetEvent ( m_hData );

				ATLTRACE ( L"\n SignalData TRUE ( signaled )\n" );
				bResult = TRUE;
			}
		}
		#ifdef	_DEBUG
		if ( !bResult )
		{
			ATLTRACE ( L"\n SignalData FALSE \n" );
		}
		#endif	_DEBUG

		return bResult;
	}
	#endif	__SUPPORT_WAIT

	///////////////////////////////////////////////////////////////////////////
	// cast operators
	///////////////////////////////////////////////////////////////////////////

	operator WmiAdapterStuff*() const
	{
		return pStuff;
	}

	operator WmiSecurityAttributes*() const
	{
		return pSA;
	}

	operator CPerformanceEventLogBase*() const
	{
		return pEventLog;
	}

	///////////////////////////////////////////////////////////////////////////
	// construction & destruction
	///////////////////////////////////////////////////////////////////////////

	WmiAdapterApp( );
	~WmiAdapterApp();

	///////////////////////////////////////////////////////////////////////////
	// INITIALIZATION
	///////////////////////////////////////////////////////////////////////////
	HRESULT InitKill		( void );
	HRESULT InitAttributes	( void );
	HRESULT Init			( void );

	void	Term			( void );

	///////////////////////////////////////////////////////////////////////////
	// exists instance ?
	///////////////////////////////////////////////////////////////////////////

	BOOL Exists ( void );

	///////////////////////////////////////////////////////////////////////////
	// helper functions
	///////////////////////////////////////////////////////////////////////////
	static LPCWSTR FindOneOf(LPCWSTR p1, LPCWSTR p2)
	{
		while (p1 != NULL && *p1 != NULL)
		{
			LPCWSTR p = p2;
			while (p != NULL && *p != NULL)
			{
				if (*p1 == *p)
					return CharNextW(p1);
				p = CharNextW(p);
			}
			p1 = CharNextW(p1);
		}
		return NULL;
	}

   	static WCHAR* _cstrchr(const WCHAR* p, WCHAR ch)
	{
		//strchr for '\0' should succeed
		while (*p != 0)
		{
			if (*p == ch)
				break;
			p = CharNextW(p);
		}
		return (WCHAR*)((*p == ch) ? p : NULL);
	}

	static WCHAR* _cstrstr(const WCHAR* pStr, const WCHAR* pCharSet)
	{
		int nLen = lstrlenW(pCharSet);
		if (nLen == 0)
			return (WCHAR*)pStr;

		const WCHAR* pRet = NULL;
		const WCHAR* pCur = pStr;
		while((pStr = _cstrchr(pCur, *pCharSet)) != NULL)
		{
			if(memcmp(pCur, pCharSet, nLen * sizeof(WCHAR)) == 0)
			{
				pRet = pCur;
				break;
			}
			pCur = CharNextW(pCur);
		}
		return (WCHAR*) pRet;
	}
};

#endif	__APP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmi_reverse_guard.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_reverse_guard.cpp
//
//	Abstract:
//
//					implementations of 1-writer/many-reader
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "wmi_reverse_guard.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT	WmiReverseGuard:: EnterRead ( const LONG &a_Timeout )
{
	if ( bInit ) 
	{
		LONG	t_Reason = 0;

		t_Reason = WaitForSingleObject ( m_WriterSemaphore , a_Timeout ) ;
		if ( t_Reason != WAIT_OBJECT_0 )
		{
			return E_FAIL ;
		}

		t_Reason = WaitForSingleObject ( m_ReaderSemaphore , a_Timeout ) ;
		if ( t_Reason != WAIT_OBJECT_0 )
		{
			return E_FAIL ;
		}

		LONG t_SemaphoreCount = 0 ;
		if ( ! ReleaseSemaphore ( m_WriterSemaphore , 1 , & t_SemaphoreCount ) )
		{
			return E_FAIL ;
		}

		return S_OK ;
	}

	return E_UNEXPECTED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT	WmiReverseGuard:: EnterWrite ( const LONG &a_Timeout )
{
	if ( bInit ) 
	{
		LONG t_Reason = 0;

		t_Reason = WaitForSingleObject ( m_WriterSemaphore , a_Timeout ) ;
		if ( t_Reason != WAIT_OBJECT_0 )
		{
			return E_FAIL ;
		}

		bool t_Waiting = true ;

		while ( t_Waiting )
		{
			t_Reason = WaitForSingleObject ( m_ReaderSemaphore , a_Timeout ) ;
			if ( t_Reason != WAIT_OBJECT_0 )
			{
				LONG t_SemaphoreCount = 0 ;
				ReleaseSemaphore ( m_WriterSemaphore , 1 , & t_SemaphoreCount ) ;

				return E_FAIL ;
			}

			LONG t_SemaphoreCount = 0 ;
			if ( ReleaseSemaphore ( m_ReaderSemaphore , 1 , & t_SemaphoreCount ) )
			{
				if ( t_SemaphoreCount == m_ReaderSize - 1 )
				{
					t_Waiting = false ;
				}
				else
				{
					SwitchToThread () ;
				}
			}
			else
			{
				LONG t_SemaphoreCount = 0 ;
				ReleaseSemaphore ( m_WriterSemaphore , 1 , & t_SemaphoreCount ) ;

				return E_FAIL ;
			}
		}

		return S_OK ;
	}

	return E_UNEXPECTED ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT	WmiReverseGuard:: LeaveRead ()
{
	if ( bInit )
	{
		LONG t_SemaphoreCount = 0 ;
		if ( ReleaseSemaphore ( m_ReaderSemaphore , 1 , & t_SemaphoreCount ) )
		{
			return S_OK ;
		}

		return E_FAIL ;
	}
	else
	{
		return E_UNEXPECTED;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT	WmiReverseGuard:: LeaveWrite ()
{
	if ( bInit )
	{
		LONG t_SemaphoreCount = 0 ;
		if ( ReleaseSemaphore ( m_WriterSemaphore , 1 , & t_SemaphoreCount ) )
		{
			return S_OK ;
		}

		return E_FAIL ;
	}
	else
	{
		return E_UNEXPECTED;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmiadapter_stuff.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmiadapter_stuff.h
//
//	Abstract:
//
//					declaration of stuff for performance refresh
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__ADAPTER_STUFF_H__
#define	__ADAPTER_STUFF_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// include
#include "wmi_reverse_memory_ext.h"
#include "wmi_perf_data.h"

#include "RefresherStuff.h"
#include "WMIAdapter_Stuff_Refresh.h"

//enum
#include <refreshergenerate.h>

///////////////////////////////////////////////////////////////////////////////
//  storing handles of counters of object
///////////////////////////////////////////////////////////////////////////////
class WmiRefreshObject
{
	DECLARE_NO_COPY ( WmiRefreshObject );

	public:

	LONG*	m_pHandles;

	WmiRefreshObject():
		m_pHandles ( NULL )
	{
	};

	~WmiRefreshObject()
	{
		delete [] m_pHandles;
		m_pHandles = NULL;
	};
};

///////////////////////////////////////////////////////////////////////////////
// performance refreshing
///////////////////////////////////////////////////////////////////////////////
template < class WmiRefreshParent >
class WmiRefresh;

///////////////////////////////////////////////////////////////////////////////
// adapter stuff
///////////////////////////////////////////////////////////////////////////////
class WmiAdapterStuff
{
	DECLARE_NO_COPY ( WmiAdapterStuff );

	// wmi :))
	WmiPerformanceData										m_data;		// data helper
	WmiMemoryExt < WmiReverseMemoryExt<WmiReverseGuard> >	m_pMem;		// shared memory

	WmiRefresh < WmiAdapterStuff > * m_pWMIRefresh;

	public:

	WmiRefresherStuff	m_Stuff;

	// construction & destruction
	WmiAdapterStuff();
	~WmiAdapterStuff();

	///////////////////////////////////////////////////////
	// construction & destruction helpers
	///////////////////////////////////////////////////////
	public:

	BOOL	IsValidBasePerfRegistry	( void );
	BOOL	IsValidInternalRegistry	( void );

	HRESULT Init ( void );
	HRESULT	Uninit ( void );

	///////////////////////////////////////////////////////
	// generate files & registry
	///////////////////////////////////////////////////////
	HRESULT Generate ( BOOL bInitialize = TRUE, GenerateEnum type = Normal );

	/////////////////////////////////////////////////////////////////////////
	// check usage of shared memory ( protect against perfmon has killed )
	/////////////////////////////////////////////////////////////////////////
	void CheckUsage (void );

	///////////////////////////////////////////////////////
	// performance refreshing
	///////////////////////////////////////////////////////
	HRESULT	Initialize		( void );
	void	Uninitialize	( void );

	HRESULT	InitializePerformance	( void );
	HRESULT	UninitializePerformance	( void );

	HRESULT Refresh ( void );

	///////////////////////////////////////////////////////////////////////////
	// registry refresh
	///////////////////////////////////////////////////////////////////////////
	BOOL	RequestGet();
	BOOL	RequestSet();
};

#endif	__ADAPTER_STUFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmiadapter_stuff_refresh.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmiadapter_stuff_refresher.h
//
//	Abstract:
//
//					declaration of wrapper for refresher object
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__ADAPTER_STUFF_REFRESH_H__
#define	__ADAPTER_STUFF_REFRESH_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

///////////////////////////////////////////////////////////////////
//
//	WmiRefresherMember
//
//	This class facilitates the management of objects or enumerators 
//	that have been added to the refresher and the unique ID assigned
//	to them.
//
///////////////////////////////////////////////////////////////////

template<class T>
class WmiRefresherMember
{
	T*		m_pMember;
	long	m_lID;

public:
	WmiRefresherMember() : m_pMember( NULL ), m_lID( 0 ) {}
	~WmiRefresherMember() { if ( NULL != m_pMember) m_pMember->Release(); }

	void Set(T* pMember, long lID);
	void Reset();

	T* GetMember();
	long GetID(){ return m_lID; }

	BOOL IsValid();
};

template <class T> inline void WmiRefresherMember<T>::Set(T* pMember, long lID) 
{ 
	if ( NULL != pMember )
		pMember->AddRef();
	m_pMember = pMember;  
	m_lID = lID;
}

template <class T> inline void WmiRefresherMember<T>::Reset()
{
	if (NULL != m_pMember)
		m_pMember->Release();

	m_pMember = NULL;
	m_lID = 0;
}

template <class T> inline T* WmiRefresherMember<T>::GetMember()
{
	return m_pMember;
}

template <class T> inline BOOL WmiRefresherMember<T>::IsValid()
{
	return ( m_pMember != NULL );
}

#endif	__ADAPTER_STUFF_REFRESH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmiaplog.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					_log.h
//
//	Abstract:
//
//					declaration of log module and class
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__MY_LOG_H__
#define	__MY_LOG_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#ifdef	__SUPPORT_LOGGING

////////////////////////////////////////////////////////////////////////////////////
// abstract base
////////////////////////////////////////////////////////////////////////////////////
template < class __DUMMY >
class ATL_NO_VTABLE MyLog
{
	DECLARE_NO_COPY ( MyLog );

	public:

	MyLog ( )
	{
	}

	~MyLog ( )
	{
	}

	HRESULT Log		( LPCWSTR wszName, DWORD dwResult );
	HRESULT Log		( LPCWSTR wszName );
};

template < class __DUMMY >
HRESULT MyLog < __DUMMY > :: Log ( LPCWSTR wszName, DWORD dwResult )
{
	HRESULT	hr	= E_OUTOFMEMORY;
	WCHAR*	psz	= NULL;

	if ( !wszName )
	{
		hr = E_INVALIDARG;
	}
	else
	{
		try
		{
			if  ( ( psz = new WCHAR [ lstrlenW ( wszName ) + 1 + 2 + 8 + 1 + 1 ] ) != NULL )
			{
				wsprintf ( psz, L"%s %08x", wszName, dwResult );
				hr = Log ( psz );
			}
		}
		catch ( ... )
		{
			hr = E_UNEXPECTED;
		}

		if ( psz )
		{
			delete [] psz;
			psz = NULL;
		}
	}

	return hr;
}

template < class __DUMMY >
HRESULT MyLog < __DUMMY > :: Log ( LPCWSTR wszName )
{
	HRESULT	hr	= E_OUTOFMEMORY;

	if ( !wszName )
	{
		hr = E_INVALIDARG;
	}
	else
	{
		DWORD		dwThreadId = 0L;
		SYSTEMTIME	systime;

		dwThreadId = ::GetCurrentThreadId ();
		::GetSystemTime ( &systime );

		WCHAR* psz = NULL;

		try
		{
			if ( ( psz = new WCHAR [ lstrlenW ( wszName ) + 1 + 2 + 8 + 1 + 2 + 3 + 2 + 3 + 2 + 3 + 2 + 3 + 1 + 1 ] ) != NULL )
			{
				wsprintf ( psz, L"%s %08x %02d:%02d:%02d:%02d\n", wszName, dwThreadId, systime.wHour, systime.wMinute, systime.wSecond, systime.wMilliseconds );

				OutputDebugString ( psz );
				hr = S_OK;
			}
		}
		catch ( ... )
		{
			hr = E_UNEXPECTED;
		}

		if ( psz )
		{
			delete [] psz;
			psz = NULL;
		}
	}

	return hr;
}

__declspec ( selectany ) MyLog< void > log;

// macros
#define AdapterLogMessage0(lpszMessage)				log.Log ( lpszMessage )
#define	AdapterLogMessage1(lpszMessage, dwResult)	log.Log ( lpszMessage, dwResult )

#else	__SUPPORT_LOGGING

// macros
#define AdapterLogMessage0(lpszMessage)
#define	AdapterLogMessage1(lpszMessage, dwResult)

#endif	__SUPPORT_LOGGING

#endif	__MY_LOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_adapter.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_adapter.h
//
//	Abstract:
//
//					export of functions from perf libary
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMIREVERSESADAPTER_H__
#define	__WMIREVERSESADAPTER_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// export/import
#ifdef	WMIREVERSEADAPTER_EXPORTS
#define	WMIREVERSEADAPTER_API	__declspec(dllexport)
#else	WMIREVERSEADAPTER_EXPORTS
#define	WMIREVERSEADAPTER_API	__declspec(dllimport)
#endif	WMIREVERSEADAPTER_EXPORTS

// performance exports

WMIREVERSEADAPTER_API
DWORD __stdcall WmiOpenPerfData		(	LPWSTR lpwszDeviceNames );

WMIREVERSEADAPTER_API
DWORD __stdcall WmiClosePerfData	();

WMIREVERSEADAPTER_API
DWORD __stdcall WmiCollectPerfData	(	LPWSTR lpwszValue, 
										LPVOID *lppData, 
										LPDWORD lpcbBytes, 
										LPDWORD lpcObjectTypes
									);

// registration exports
EXTERN_C HRESULT __stdcall	DllRegisterServer	( void );
EXTERN_C HRESULT __stdcall	DllUnregisterServer	( void );

#endif	__WMIREVERSESADAPTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_adapter_objectlist.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_adapter_objectlist.h
//
//	Abstract:
//
//					object list helper class ( declaration )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__ADAPTER_OBJECTLIST_H__
#define	__ADAPTER_OBJECTLIST_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

class WmiAdapterObjectList
{
	DECLARE_NO_COPY ( WmiAdapterObjectList );

	// variables
	LPWSTR	m_pwszList;
	bool	m_bValid;

	public:

	WmiAdapterObjectList ( LPCWSTR wszList = NULL ) :
	m_pwszList ( NULL ),
	m_bValid ( false )
	{
		if ( lstrcmpiW ( L"COSTLY", wszList ) != 0 )
		{
			if ( wszList && ( lstrcmpiW ( L"GLOBAL", wszList ) != 0 ) )
			{
				try
				{
					if ( ( m_pwszList = new WCHAR [ lstrlenW(wszList) + 3 ] ) != NULL )
					{
						wsprintfW ( m_pwszList, L" %s ", wszList );
						m_bValid = true;
					}
				}
				catch ( ... )
				{
				}
			}
		}

	}

	~WmiAdapterObjectList()
	{
		if ( m_pwszList )
		{
			delete m_pwszList;
			m_pwszList = NULL;
		}
	}

	// function to find out if asking for supported object
	bool IsInList ( DWORD dwObject )
	{
		if ( m_bValid )
		{
			bool bResult = true;

			if ( m_pwszList )
			{
				WCHAR wszObject[32] = { L'\0' };
				wsprintfW( wszObject, L" %d ", dwObject );
				bResult = ( wcsstr( m_pwszList, wszObject ) != NULL );
			}

			return bResult;
		}

		return m_bValid;
	}
};

#endif	__ADAPTER_OBJECTLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_adapter_registry.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_adapter_registry.h
//
//	Abstract:
//
//					Declaration of the Registry for wmi reverse adapter
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef __WMI_ADAPTER_REGISTRY_H_
#define __WMI_ADAPTER_REGISTRY_H_

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#ifndef	_REGTABLE_H
#include "wmi_helper_regtable.h"
#endif	_REGTABLE_H

// constants are declared extern
extern WCHAR g_szPath[];
extern LPCWSTR g_szOpen;
extern LPCWSTR g_szCollect;
extern LPCWSTR g_szClose;

extern __WrapperPtr<WmiSecurityAttributes>	pSA;

extern LPCWSTR	g_szKeyCounter;

extern LPCWSTR	g_szKey;
extern LPCWSTR	g_szKeyValue;

class WmiAdapterRegistry
{
	DECLARE_NO_COPY ( WmiAdapterRegistry );


	public:

	// construction & destruction
	WmiAdapterRegistry( )
	{
	}

	~WmiAdapterRegistry( )
	{
	}

	// registry map

	BEGIN_CLASS_REGISTRY_TABLE_SZ(WmiAdapterRegistry)

	REGISTRY_KEY_SZ(HKEY_LOCAL_MACHINE,
					g_szKeyCounter,
					L"Library",
					g_szPath,
					pSA->GetSecurityAttributtes(),
					REGFLAG_NORMAL)

	REGISTRY_KEY_SZ(HKEY_LOCAL_MACHINE,
					g_szKeyCounter,
					L"Open",
					g_szOpen,
					pSA->GetSecurityAttributtes(),
					REGFLAG_NORMAL)

	REGISTRY_KEY_SZ(HKEY_LOCAL_MACHINE,
					g_szKeyCounter,
					L"Collect",
					g_szCollect,
					pSA->GetSecurityAttributtes(),
					REGFLAG_NORMAL)

	REGISTRY_KEY_SZ(HKEY_LOCAL_MACHINE,
					g_szKeyCounter,
					L"Close",
					g_szClose,
					pSA->GetSecurityAttributtes(),
					REGFLAG_NORMAL)

	REGISTRY_KEY_SZ(HKEY_LOCAL_MACHINE,
					g_szKey,
					g_szKeyValue,
					NULL,
					pSA->GetSecurityAttributtes(),
					REGFLAG_DELETE_ONLY_VALUE)

	END_CLASS_REGISTRY_TABLE_SZ()

};

#endif	__WMI_ADAPTER_REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_eventlog.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_EventLog
//
//	Abstract:
//
//					event log adapter specific declarations
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__PERF_EVENT_LOG_H__
#define	__PERF_EVENT_LOG_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// enable tstring
#ifndef	_INC_TCHAR
#include <tchar.h>
#endif	_INC_TCHAR

#include "wmi_eventlog_base.h"

class CPerformanceEventLog : public CPerformanceEventLogBase
{
	// disallow assigment & copy construction
	DECLARE_NO_COPY ( CPerformanceEventLog )

	// variables
 	DWORD	m_dwMessageLevel;

 	public:

	// construction & destruction
	CPerformanceEventLog ( LPTSTR szName = NULL );
	CPerformanceEventLog ( DWORD dwMessageLevel, LPTSTR szName = NULL );
 	virtual ~CPerformanceEventLog ( void );

	private:

	// helpers
	void	InitializeMessageLevel ( void );
};

#endif	__PERF_EVENT_LOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_adapter_registry_service.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_adapter_registry_service.h
//
//	Abstract:
//
//					Declaration of the Registry for wmi reverse adapter
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef __WMI_ADAPTER_REGISTRY_SERVICE_H_
#define __WMI_ADAPTER_REGISTRY_SERVICE_H_

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#ifndef	_REGTABLE_H
#include "wmi_helper_regtable.h"
#endif	_REGTABLE_H

// application
#include "WMIAdapter_App.h"
extern WmiAdapterApp		_App;

extern LPCWSTR g_szKey;

class WmiAdapterRegistryService
{
	DECLARE_NO_COPY ( WmiAdapterRegistryService );

	public:

	// construction & destruction
	WmiAdapterRegistryService( )
	{
	}

	~WmiAdapterRegistryService( )
	{
	}

	// registry map

	BEGIN_CLASS_REGISTRY_TABLE_SZ(WmiAdapterRegistry)

	REGISTRY_KEY_SZ(HKEY_CLASSES_ROOT,
					L"AppID\\{63A53A38-004F-489B-BD61-96B5EEFADC04}",
					L"LocalService",
					L"WMIApSrv",
//					( ((WmiSecurityAttributes*) _App) != NULL ) ? ((WmiSecurityAttributes*) _App)->GetSecurityAttributtes() : NULL,
					NULL,
					REGFLAG_NORMAL)

	REGISTRY_KEY_SZ	(HKEY_LOCAL_MACHINE,
					g_szKey,
					NULL,
					NULL,
//					( ((WmiSecurityAttributes*) _App) != NULL ) ? ((WmiSecurityAttributes*) _App)->GetSecurityAttributtes() : NULL,
					NULL,
					REGFLAG_NORMAL | REGFLAG_DELETE_BEFORE_REGISTERING)

	END_CLASS_REGISTRY_TABLE_SZ()
};

#endif	__WMI_ADAPTER_REGISTRY_SERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_eventlog_base.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_eventlog_base.h
//
//	Abstract:
//
//					declaration for event log wrapper
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__PERF_EVENT_LOG_BASE_H__
#define	__PERF_EVENT_LOG_BASE_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// enable tstring
#ifndef	_INC_TCHAR
#include <tchar.h>
#endif	_INC_TCHAR

class CPerformanceEventLogBase
{
	// disallow assigment & copy construction
	DECLARE_NO_COPY ( CPerformanceEventLogBase )

	// variables
 	LONG	m_lLogCount;
	HANDLE	m_hEventLog;

	// report variables
	PSID	m_pSid;

 	public:

	// construction & destruction
	CPerformanceEventLogBase ( LPTSTR szName = NULL );
 	virtual ~CPerformanceEventLogBase ( void );

	// methods
 	HRESULT	Open ( LPTSTR pszName = NULL);
 	void	Close ( void );

	// report event
	BOOL	ReportEvent (	WORD		wType,
							WORD		wCategory,
							DWORD		dwEventID,
							WORD		wStrings,
							DWORD		dwData,
							LPCWSTR*	lpStrings,
							LPVOID		lpRawData
						);

 	static	void	Initialize		( LPTSTR szAppName, LPTSTR szResourceName );
 	static	void	UnInitialize	( LPTSTR szAppName );

	// helpers
	void InitializeFromToken ( void );
	void InitializeFromAccount ( void );
};

#endif	__PERF_EVENT_LOG_BASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_adapter_wrapper.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					WMI_adapter_wrapper.h
//
//	Abstract:
//
//					declaration of adapter real working stuff
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_ADAPTER_WRAPPER_H__
#define	__WMI_ADAPTER_WRAPPER_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// shared memory 
#ifndef	__REVERSE_MEMORY_H__
#include "wmi_reverse_memory.h"
#endif	__REVERSE_MEMORY_H__

#ifndef	__REVERSE_MEMORY_EXT_H__
#include "wmi_reverse_memory_ext.h"
#endif	__REVERSE_MEMORY_EXT_H__

#include "wmi_memory_ext.h"

class WmiAdapterWrapper
{
	DECLARE_NO_COPY ( WmiAdapterWrapper );

	// variables

	LONG													m_lUseCount;	// reference count

	WmiMemoryExt < WmiReverseMemoryExt<WmiReverseGuard> >	m_pMem;			// shared memory
	CRITICAL_SECTION										m_pCS;			// critical section for collect

	__SmartServiceHANDLE hSCM;	// service manager ( helper )

	BYTE*	m_pData;
	DWORD	m_dwData;
	DWORD	m_dwDataOffsetCounter;
	DWORD	m_dwDataOffsetValidity;

	DWORD	m_dwPseudoCounter;
	DWORD	m_dwPseudoHelp;

	__SmartHANDLE	m_hRefresh;
	BOOL			m_bRefresh;

	#ifdef	__SUPPORT_WAIT
	__SmartHANDLE	m_hReady;
	#endif	__SUPPORT_WAIT

	public:

	// construction
	WmiAdapterWrapper();

	// destruction
	~WmiAdapterWrapper();

	// real functions

	DWORD	Open	( LPWSTR wszDeviceNames );
	DWORD	Close	( void );
	DWORD	Collect	( LPWSTR	wszValue,
					  LPVOID*	lppData,
					  LPDWORD	lpcbBytes,
					  LPDWORD	lpcbObjectTypes
					);

	private:

	DWORD	CollectObjects	( LPWSTR	wszValue,
							  LPVOID*	lppData,
							  LPDWORD	lpcbBytes,
							  LPDWORD	lpcbObjectTypes
							);

	void	CloseLib ( BOOL bInit = TRUE );

	// report event to event log
	BOOL ReportEvent (	WORD	wType,
						DWORD	dwEventID,
						WORD	wStrings	= 0,
						LPWSTR*	lpStrings	= NULL
					 );

	BOOL ReportEvent (	DWORD dwError, WORD wType, DWORD dwEventSZ  );

	// creation of pseudo
	HRESULT	PseudoCreateRefresh	( void );
	HRESULT	PseudoCreate		( void );
	void	PseudoDelete		( void );

	void	PseudoRefresh	( DWORD	dwCount );
	void	PseudoRefresh	( BOOL bValid = TRUE );

	// helpers
	void	AppendMemory ( BYTE* pStr, DWORD dwStr, DWORD& dwOffset );
	void	AppendMemory ( DWORD dwValue, DWORD& dwOffset );

	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////
	// count of memories
	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////

	DWORD	MemoryCountGet ( void )
	{
		return m_pMem.GetMemory ( 0 ) ->GetValue ( offsetCountMMF );
	}

	void	MemoryCountSet ( DWORD dwCount )
	{
		m_pMem.GetMemory ( 0 ) ->SetValue ( dwCount, offsetCountMMF );
	}

	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////
	// size of table
	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////

	DWORD	TableSizeGet ( void )
	{
		return m_pMem.GetMemory ( 0 ) ->GetValue ( offsetSize1 );
	}

	void	TableSizeSet ( DWORD dwSize )
	{
		m_pMem.GetMemory ( 0 ) ->SetValue ( dwSize, offsetSize1 );
	}

	DWORD	TableOffsetGet ( void )
	{
		return TableSizeGet() + offsetSize1;
	}

	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////
	// count of objects
	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////

	DWORD	CountGet ( void )
	{
		return m_pMem.GetMemory ( 0 ) ->GetValue ( offsetCount1 );
	}

	void	CountSet ( DWORD dwCount )
	{
		m_pMem.GetMemory ( 0 ) ->SetValue ( dwCount, offsetCount1 );
	}

	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////
	// real size
	///////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////

	DWORD	RealSizeGet ( void )
	{
		return m_pMem.GetMemory ( 0 ) ->GetValue ( offsetRealSize1 );
	}

	void	RealSizeSet ( DWORD dwSize )
	{
		m_pMem.GetMemory ( 0 ) ->SetValue ( dwSize, offsetRealSize1 );
	}

	///////////////////////////////////////////////////////////////////////////
	// get object properties from ord
	///////////////////////////////////////////////////////////////////////////

	DWORD	GetCounter ( DWORD dwOrd );
	DWORD	GetOffset ( DWORD dwOrd );
	DWORD	GetValidity ( DWORD dwOrd );

	///////////////////////////////////////////////////////////////////////////
	// is valid ordinary
	///////////////////////////////////////////////////////////////////////////

	BOOL	IsValidOrd ( DWORD dwOrd )
	{
		return ( dwOrd <= CountGet() );
	}

	// return error from memory
	HRESULT MemoryGetLastError ( DWORD dwOffsetBegin )
	{
		DWORD dwSize = 0L;
		dwSize = m_pMem.GetSize ( );

		DWORD dwCount = 0L;
		dwCount = m_pMem.GetCount ( );

		DWORD dwIndex = 0L;

		if ( dwCount )
		{
			dwSize	= dwSize / dwCount;
			dwIndex	= dwOffsetBegin / dwSize;
		}

		return m_pMem.GetMemory ( dwIndex ) -> GetLastError ();
	}
};

#endif	__WMI_ADAPTER_WRAPPER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_helper_regtable.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_helper_regtable.h
//
//	Abstract:
//
//					registry updater declaration
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef _REGTABLE_H
#define _REGTABLE_H

// basic table layout
typedef struct _REGISTRY_ENTRY {
    HKEY        hkeyRoot;
    const WCHAR *pszKey;
    const WCHAR *pszValueName;
    DWORD		dwValue;

	LPSECURITY_ATTRIBUTES	pSA;

    int         fFlags;
} REGISTRY_ENTRY;

typedef struct _REGISTRY_ENTRY_SZ {
    HKEY        hkeyRoot;
    const WCHAR *pszKey;
    const WCHAR *pszValueName;
    const WCHAR *pszValue;

	LPSECURITY_ATTRIBUTES	pSA;

    int         fFlags;
} REGISTRY_ENTRY_SZ;

// the routine that inserts/deletes Registry keys based on the table
EXTERN_C HRESULT STDAPICALLTYPE RegistryTableUpdateRegistry(REGISTRY_ENTRY *pEntries, BOOL bInstalling);
EXTERN_C HRESULT STDAPICALLTYPE RegistryTableUpdateRegistrySZ(REGISTRY_ENTRY_SZ *pEntries, BOOL bInstalling);

// flags for 
enum REGFLAGS {
    REGFLAG_NORMAL = 0x0,
    REGFLAG_NEVER_DELETE = 0x1,
    REGFLAG_DELETE_WHEN_REGISTERING = 0x2,
    REGFLAG_DELETE_BEFORE_REGISTERING = 0x4,
	REGFLAG_DELETE_ONLY_VALUE = 0x8
};

#define BEGIN_REGISTRY_TABLE(TableName) \
static REGISTRY_ENTRY TableName [] = {        

#define REGISTRY_KEY(hkr, pszKey, pszValueName, dwValue, pSA, fFlags) \
    { hkr, pszKey, pszValueName, dwValue, pSA, fFlags },

#define END_REGISTRY_TABLE() \
    { 0, 0, 0, 0, 0, -1 } \
};

#define BEGIN_CLASS_REGISTRY_TABLE(ClassName) \
    static HRESULT STDAPICALLTYPE __UpdateRegistry(BOOL bInstalling) \
    {\
        BEGIN_REGISTRY_TABLE(entries)

#define END_CLASS_REGISTRY_TABLE() \
        END_REGISTRY_TABLE()\
        return RegistryTableUpdateRegistry(entries, bInstalling);\
    }   

#define BEGIN_REGISTRY_TABLE_SZ(TableName) \
static REGISTRY_ENTRY_SZ TableName [] = {        

#define REGISTRY_KEY_SZ(hk, pszKey, pszValueName, pszValue, pSA, fFlags) \
    { hk, pszKey, pszValueName, pszValue, pSA, fFlags },

#define END_REGISTRY_TABLE_SZ() \
    { 0, 0, 0, 0, 0, -1 } \
};

#define BEGIN_CLASS_REGISTRY_TABLE_SZ(ClassName) \
    static HRESULT STDAPICALLTYPE __UpdateRegistrySZ(BOOL bInstalling) \
    {\
        BEGIN_REGISTRY_TABLE_SZ(entries)

#define END_CLASS_REGISTRY_TABLE_SZ() \
        END_REGISTRY_TABLE_SZ()\
        return RegistryTableUpdateRegistrySZ(entries, bInstalling);\
    }   

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_memory.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_memory.h
//
//	Abstract:
//
//					declaration of memory wrapper
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_MEMORY_H__
#define	__WMI_MEMORY_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// guard
#include "wmi_reverse_guard.h"

template < class CRITGUARD >
class WmiMemory
{
	DECLARE_NO_COPY ( WmiMemory );

	__WrapperPtr < CRITGUARD > m_pGuard;

	protected:

	DWORD	m_dwDataSize;
	BYTE*	m_pData;

	HRESULT m_LastError;

	public:

	/////////////////////////////////////////////////////////////////////////////////////
	//	LAST ERROR HELPER
	/////////////////////////////////////////////////////////////////////////////////////

	HRESULT GetLastError ( void )
	{
		HRESULT hr = S_OK;

		hr			= m_LastError;
		m_LastError = S_OK;

		return hr;
	}

	// construction

	WmiMemory ( LPCWSTR, DWORD dwSize = 4096, LPSECURITY_ATTRIBUTES psa = NULL  ):
		m_dwDataSize ( 0 ),
		m_pData ( NULL ),

		m_LastError ( S_OK )
	{
		try
		{
			m_pGuard.SetData ( new CRITGUARD( FALSE, 100, 1, psa ) );
		}
		catch ( ... )
		{
			___ASSERT_DESC ( m_pGuard != NULL, L"Constructor FAILED !" );
		}

		MemCreate ( NULL, dwSize, psa );
	}

	virtual ~WmiMemory ()
	{
		try
		{
			MemDelete ();
		}
		catch ( ... )
		{
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////
	//	VALIDITY
	/////////////////////////////////////////////////////////////////////////////////////

	BOOL IsValid ( void )
	{
		return ( m_pData != NULL );
	}

	/////////////////////////////////////////////////////////////////////////////////////
	//	ACCESSORS
	/////////////////////////////////////////////////////////////////////////////////////

	// get data
	PVOID	GetData () const
	{
		return m_pData;
	}

	// get data size
	DWORD	GetDataSize () const
	{
		return m_dwDataSize;
	}

	void	SetDataSize ( DWORD size )
	{
		m_dwDataSize = size;
	}

	// functions
	BOOL Write	(LPCVOID pBuffer, DWORD dwBytesToWrite, DWORD* pdwBytesWritten, DWORD dwOffset);
	BOOL Read	(LPVOID pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead, DWORD dwOffset);

	void	Write	( DWORD dwValue, DWORD dwOffset );
	PBYTE	Read	( DWORD* pdwBytesRead, DWORD dwOffset );

	// helpers
	HRESULT MemCreate ( LPCWSTR, DWORD dwSize, LPSECURITY_ATTRIBUTES psa = NULL  );
	HRESULT MemDelete ();
};

template < class CRITGUARD >
HRESULT WmiMemory < CRITGUARD > ::MemCreate ( LPCWSTR, DWORD dwSize, LPSECURITY_ATTRIBUTES )
{
	___ASSERT ( m_pData == NULL );

	if ( dwSize )
	{
		try
		{
			if ( ( m_pData = new BYTE [ dwSize ] ) != NULL )
			{
				m_pData[0] = NULL;
				m_dwDataSize = dwSize;
			}
			else
			{
				m_LastError = E_OUTOFMEMORY;
				return m_LastError;
			}
		}
		catch ( ... )
		{
			m_LastError = E_UNEXPECTED;
			return m_LastError;
		}

		m_LastError = S_OK;
		return S_OK;
	}

	m_LastError = S_FALSE;
	return S_FALSE;
}

// delete memory
template < class CRITGUARD >
HRESULT WmiMemory < CRITGUARD > ::MemDelete ()
{
	if ( m_pData )
	{
		delete [] m_pData;
		m_pData = NULL;
	}

	m_dwDataSize = 0;

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// write into memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class CRITGUARD >
BOOL WmiMemory < CRITGUARD > ::Write (LPCVOID pBuffer, DWORD dwBytesToWrite, DWORD* pdwBytesWritten, DWORD dwOffset )
{
	___ASSERT(m_pData != NULL);
	BOOL bResult = FALSE;

	if ( m_pGuard )
	{
		m_pGuard->EnterWrite ();

		if ( dwOffset > m_dwDataSize )
		{
			if ( pdwBytesWritten )
			{
				*pdwBytesWritten = 0;
			}

			m_LastError = E_INVALIDARG;
			return FALSE;
		}
		else
		{
			DWORD dwCount = min ( dwBytesToWrite, m_dwDataSize - dwOffset );
			::CopyMemory ((LPBYTE) m_pData + dwOffset, pBuffer, dwCount);

			if (pdwBytesWritten != NULL)
			{
				*pdwBytesWritten = dwCount;
			}

			m_pGuard->LeaveWrite ();

			bResult = TRUE;
		}
	}

	return bResult;
}

template < class CRITGUARD >
void WmiMemory < CRITGUARD > ::Write (DWORD dwValue, DWORD dwOffset )
{
	___ASSERT(m_pData != NULL);

	if ( m_pGuard )
	{
		m_pGuard->EnterWrite ();
		if ( dwOffset > m_dwDataSize )
		{
			m_LastError = E_INVALIDARG;
			return;
		}

		* reinterpret_cast < PDWORD > ( (LPBYTE) m_pData + dwOffset ) = dwValue;
		m_pGuard->LeaveWrite ();
	}

	return;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// read from memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class CRITGUARD >
BOOL WmiMemory < CRITGUARD > ::Read (LPVOID pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead, DWORD dwOffset )
{
	___ASSERT (m_pData != NULL);
	BOOL bResult = FALSE;

	if ( m_pGuard )
	{
		m_pGuard->EnterRead ();

		if (dwOffset > m_dwDataSize)
		{
			if ( pdwBytesRead )
			{
				*pdwBytesRead = 0;
			}

			m_LastError = E_INVALIDARG;
		}
		else
		{
			DWORD dwCount = min (dwBytesToRead, m_dwDataSize - dwOffset);
			::CopyMemory (pBuffer, (LPBYTE) m_pData + dwOffset, dwCount);

			if (pdwBytesRead != NULL)
			{
				*pdwBytesRead = dwCount;
			}

			m_pGuard->LeaveRead ();

			bResult = TRUE;
		}
	}

	return bResult;
}

template < class CRITGUARD >
PBYTE WmiMemory < CRITGUARD > ::Read ( DWORD* pdwBytesRead, DWORD dwOffset )
{
	___ASSERT (m_pData != NULL);
	PBYTE pByte = NULL;

	if ( m_pGuard )
	{
		m_pGuard->EnterRead ();

		if (dwOffset > m_dwDataSize)
		{
			if ( pdwBytesRead )
			{
				*pdwBytesRead = 0;
			}

			m_LastError = E_INVALIDARG;
		}
		else
		{
			pByte = (LPBYTE) m_pData + dwOffset;

			if (pdwBytesRead != NULL)
			{
				if ( pByte )
				{
					*pdwBytesRead = m_dwDataSize - dwOffset;
				}
				else
				{
					*pdwBytesRead = 0L;
				}
			}

			m_pGuard->LeaveRead ();
		}
	}

	return pByte;
}

#endif	__WMI_MEMORY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_memory_ext.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_memory.ext.h
//
//	Abstract:
//
//					declaration of single linked list of memories
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__MEMORY_EXT_H__
#define	__MEMORY_EXT_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

template < class MEMORY >
class WmiMemoryExt
{
	DECLARE_NO_COPY ( WmiMemoryExt );

	protected:

	DWORD						m_dwSize;		// size
	DWORD						m_dwGlobalSize;	// global size ( count of all )
	DWORD						m_dwCount;		// count of memories

	__WrapperARRAY < MEMORY* >	pMemory;	// array of memories

	LPCWSTR					m_wszName;
	LPSECURITY_ATTRIBUTES	m_psa;

	public:

	// construction

	WmiMemoryExt ( ) :

		m_dwGlobalSize ( 0 ),
		m_dwSize ( 0 ),
		m_dwCount ( 0 ),

		m_psa ( NULL ),

		m_wszName ( NULL )
	{
	}

	virtual ~WmiMemoryExt ()
	{
		try
		{
			MemDelete ();
		}
		catch ( ... )
		{
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////
	//	VALIDITY
	/////////////////////////////////////////////////////////////////////////////////////

	BOOL IsValid ( void )
	{
		return ( !pMemory.IsEmpty() );
	}

	/////////////////////////////////////////////////////////////////////////////////////
	//	ACCESSORS
	/////////////////////////////////////////////////////////////////////////////////////

	MEMORY*	GetMemory ( DWORD dwIndex ) const
	{
		if ( dwIndex < m_dwCount )
		{
			return pMemory [ dwIndex ];
		}

		return NULL;
	}

	// get name
	LPWSTR	GetName () const
	{
		return m_wszName;
	}

	// get size
	DWORD	GetSize () const
	{
		return m_dwGlobalSize;
	}

	// get count
	DWORD	GetCount () const
	{
		return m_dwCount;
	}

	// functions
	BOOL Write			(LPCVOID pBuffer, DWORD dwBytesToWrite, DWORD* pdwBytesWritten, DWORD dwOffset);
	void Write			(DWORD dwValue, DWORD dwOffset);
	BOOL Read			(LPVOID pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead, DWORD dwOffset, BOOL bReadAnyWay = FALSE);
	BOOL Read			(LPVOID pBuffer, DWORD dwBytesToRead, DWORD dwOffset);
	PBYTE ReadBytePtr	(DWORD dwIndex, DWORD* pdwBytesRead);

	// helpers
	HRESULT MemCreate ( LPCWSTR wszName = NULL, LPSECURITY_ATTRIBUTES psa = NULL  );
	HRESULT MemCreate ( DWORD dwSize );

	HRESULT MemDelete ();
};

// create memory
template < class MEMORY >
HRESULT WmiMemoryExt < MEMORY > ::MemCreate ( LPCWSTR wszName, LPSECURITY_ATTRIBUTES psa )
{
	// store security attributets on the first time
	if ( !m_psa && psa )
	{
		m_psa = psa;
	}

	// store name on the first time
	if ( !m_wszName && wszName )
	{
		m_wszName = wszName;
	}

	return S_OK;
}

// create memory
template < class MEMORY >
HRESULT WmiMemoryExt < MEMORY > ::MemCreate ( DWORD dwSize )
{
	HRESULT hRes = E_OUTOFMEMORY;

	try
	{
		MEMORY* mem = NULL;

		if ( m_wszName )
		{
			try
			{
				WCHAR name [_MAX_PATH] = { L'\0' };
				wsprintfW ( name, L"%s_%d", m_wszName, m_dwCount );

				if ( ( mem = new MEMORY ( name, dwSize, m_psa ) ) != NULL )
				{
					hRes = S_OK;
				}
			}
			catch ( ... )
			{
				hRes = E_UNEXPECTED;
			}
		}
		else
		{
			try
			{
				if ( ( mem = new MEMORY ( NULL, dwSize, m_psa ) ) != NULL )
				{
					hRes = S_OK;
				}
			}
			catch ( ... )
			{
				hRes = E_UNEXPECTED;
			}
		}

		if ( ! m_dwCount )
		{
			m_dwSize = mem->GetDataSize();
		}
		else
		{
			mem->SetDataSize ( dwSize );
		}

		pMemory.DataAdd ( mem );

		m_dwGlobalSize += m_dwSize;
		m_dwCount++;
	}
	catch ( ... )
	{
		hRes = E_UNEXPECTED;
	}

	return hRes;
}

// delete memory
template < class MEMORY >
HRESULT WmiMemoryExt < MEMORY > ::MemDelete ()
{
	if ( ! pMemory.IsEmpty() )
	{
		for ( DWORD dw = pMemory; dw > 0; dw-- )
		{
			if ( pMemory[dw-1] )
			{
				pMemory[dw-1]->MemDelete();
				pMemory.DataDelete(dw-1);
			}
		}

		delete [] pMemory.Detach();
	}

	m_dwSize  = 0;
	m_dwGlobalSize  = 0;
	m_dwCount = 0;

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// write into memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class MEMORY >
BOOL WmiMemoryExt < MEMORY >::Write (LPCVOID pBuffer, DWORD dwBytesToWrite, DWORD* pdwBytesWritten, DWORD dwOffset )
{
	// we have a memory :))
	___ASSERT ( IsValid () && ( m_dwSize != 0 ) );

	if ( !IsValid() || !m_dwSize )
	{
		return FALSE;
	}

	DWORD dwMainIndex = 0L;
	DWORD dwMainCount = 0L;

	dwMainIndex = dwOffset/m_dwSize;
	dwMainCount = dwBytesToWrite/m_dwSize + ( ( dwBytesToWrite%m_dwSize ) ? 1 : 0 );

	if ( dwOffset > m_dwGlobalSize )
	{
		// they want new memory to be created :))
		for ( DWORD dw = 0; dw < dwMainIndex; dw ++ )
		{
			if FAILED ( MemCreate ( m_dwSize ) )
			{
				if ( pdwBytesWritten )
				{
					( *pdwBytesWritten ) = 0;
				}

				return FALSE;
			}
		}
	}

	if ( dwBytesToWrite > ( m_dwGlobalSize - dwOffset ) )
	{
		// they want new memory to be created :))
		for ( DWORD dw = 0; dw < dwMainCount; dw ++ )
		{
			if FAILED ( MemCreate ( m_dwSize ) )
			{
				if ( pdwBytesWritten )
				{
					( *pdwBytesWritten ) = 0;
				}

				return FALSE;
			}
		}
	}

	// memory
	MEMORY* pmem = NULL;

	DWORD dwWritten = 0;

	pmem = const_cast< MEMORY* > ( pMemory [ dwMainIndex ] );
	if ( ! pmem -> Write (	pBuffer,
							(	( ( dwBytesToWrite >= ( m_dwSize - dwOffset%m_dwSize ) ) ?
									m_dwSize - dwOffset%m_dwSize :
									dwBytesToWrite%m_dwSize
								)
							),
							&dwWritten,
							dwOffset%m_dwSize
						 )
	   )
	{
		if ( pdwBytesWritten )
		{
			( *pdwBytesWritten ) = 0;
		}

		return FALSE;
	}

	// write rest of buffer
	DWORD dwIndex = dwMainIndex;
	while ( ( dwBytesToWrite > dwWritten ) && ( dwIndex < m_dwCount ) )
	{
		DWORD dwWrite = 0;

		pmem = const_cast< MEMORY* > ( pMemory [ ++dwIndex ] );
		if ( ! pmem->Write (	(PBYTE)pBuffer + dwWritten,
								(	( ( dwBytesToWrite - dwWritten ) >= m_dwSize ) ?

									m_dwSize :
									( dwBytesToWrite - dwWritten ) % m_dwSize
								),

								&dwWrite,
								0
						   )
		   )
		{
			if ( pdwBytesWritten )
			{
				( *pdwBytesWritten ) = 0;
			}

			return FALSE;
		}

		dwWritten += dwWrite;
	}

	// how many bytes :))
	if ( pdwBytesWritten )
	{
		( * pdwBytesWritten ) = dwWritten;
	}

	return TRUE;
}

template < class MEMORY >
void WmiMemoryExt < MEMORY >::Write( DWORD dwValue, DWORD dwOffset )
{
	// we have a memory :))
	___ASSERT ( IsValid () && ( m_dwSize != 0 ) );

	if ( IsValid() && ( m_dwSize != 0 ) )
	{
		DWORD dwMainIndex = 0L;
		DWORD dwMainCount = 0L;

		dwMainIndex = dwOffset/m_dwSize;
		dwMainCount = (sizeof ( DWORD ))/m_dwSize + ( ( (sizeof ( DWORD ))%m_dwSize ) ? 1 : 0 );

		if ( dwOffset > m_dwGlobalSize )
		{
			// they want new memory to be created :))
			for ( DWORD dw = 0; dw < dwMainIndex; dw ++ )
			{
				if FAILED ( MemCreate ( m_dwSize ) )
				{
					return;
				}
			}
		}

		if ( (sizeof ( DWORD )) > ( m_dwGlobalSize - dwOffset ) )
		{
			// they want new memory to be created :))
			for ( DWORD dw = 0; dw < dwMainCount; dw ++ )
			{
				if FAILED ( MemCreate ( m_dwSize ) )
				{
					return;
				}
			}
		}

		MEMORY* pmem = const_cast< MEMORY* > ( pMemory [ dwMainIndex ] );
		pmem->Write( dwValue, dwOffset%m_dwSize );
	}

	return;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// read from memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class MEMORY >
BOOL WmiMemoryExt < MEMORY >::Read (LPVOID pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead, DWORD dwOffset, BOOL bReadAnyWay )
{
	// we have a memory :))
	___ASSERT ( IsValid () && ( m_dwSize != 0 ) );

	if ( !IsValid() || !m_dwSize )
	{
		return FALSE;
	}

	DWORD dwMainIndex = 0L;
	DWORD dwMainCount = 0L;

	dwMainIndex = dwOffset/m_dwSize;
	dwMainCount = dwBytesToRead/m_dwSize + ( ( dwBytesToRead%m_dwSize ) ? 1 : 0 );

	if ( dwOffset > m_dwGlobalSize )
	{
		// they want new memory to be created :))
		for ( DWORD dw = 0; dw < dwMainIndex; dw ++ )
		{
			if FAILED ( MemCreate ( m_dwSize ) )
			{
				if ( pdwBytesRead )
				{
					( *pdwBytesRead ) = 0;
				}

				return FALSE;
			}
		}

		if ( !bReadAnyWay )
		{
			if ( pdwBytesRead )
			{
				( *pdwBytesRead ) = 0;
			}

			return FALSE;
		}
	}

	if ( dwBytesToRead > ( m_dwGlobalSize - dwOffset ) )
	{
		// they want new memory to be created :))
		for ( DWORD dw = 0; dw < dwMainCount; dw ++ )
		{
			if FAILED ( MemCreate ( m_dwSize ) )
			{
				if ( pdwBytesRead )
				{
					( *pdwBytesRead ) = 0;
				}

				return FALSE;
			}
		}

		if ( !bReadAnyWay )
		{
			if ( pdwBytesRead )
			{
				( *pdwBytesRead ) = 0;
			}

			return FALSE;
		}
	}

	// memory
	MEMORY* pmem = NULL;

	DWORD dwRead = 0;

	pmem = const_cast< MEMORY* > ( pMemory [ dwMainIndex ] );
	if ( ! pmem -> Read (	pBuffer,
							( ( dwBytesToRead >= m_dwSize - dwOffset%m_dwSize ) ?
								m_dwSize - dwOffset%m_dwSize :
								dwBytesToRead%m_dwSize
							),
							&dwRead,
							dwOffset%m_dwSize
						 )
	   )
	{
		if ( pdwBytesRead )
		{
			( *pdwBytesRead ) = 0;
		}

		return FALSE;
	}

	// read rest of buffer
	DWORD dwIndex    = dwMainIndex;
	while ( ( dwBytesToRead > dwRead ) && ( dwIndex < m_dwCount ) )
	{
		DWORD dwReadHelp = 0;

		pmem = const_cast< MEMORY* > ( pMemory [ ++dwIndex ] );
		if ( ! pmem->Read (	(PBYTE) ( (PBYTE)pBuffer + dwRead ),
								( ( ( dwBytesToRead - dwRead ) >= m_dwSize ) ?
										m_dwSize :
										( dwBytesToRead - dwRead ) % m_dwSize
								),
								&dwReadHelp,
								0
						   )
		   )
		{
			if ( pdwBytesRead )
			{
				( *pdwBytesRead ) = 0;
			}

			return FALSE;
		}

		dwRead += dwReadHelp;
	}

	// how many bytes :))
	if ( pdwBytesRead )
	{
		( * pdwBytesRead ) = dwRead;
	}

	return TRUE;
}

template < class MEMORY >
BOOL WmiMemoryExt < MEMORY >::Read ( LPVOID pBuffer, DWORD dwBytesToRead, DWORD dwOffset )
{
	// we have a memory :))
	___ASSERT ( IsValid () && ( m_dwSize != 0 ) );

	if ( !IsValid() || !m_dwSize )
	{
		return FALSE;
	}

	DWORD dwMainIndex = 0L;
	DWORD dwMainCount = 0L;

	dwMainIndex = dwOffset/m_dwSize;
	dwMainCount = dwBytesToRead/m_dwSize + ( ( dwBytesToRead%m_dwSize ) ? 1 : 0 );

	if ( dwOffset > m_dwGlobalSize )
	{
		// they want new memory to be created :))
		for ( DWORD dw = 0; dw < dwMainIndex; dw ++ )
		{
			if FAILED ( MemCreate ( m_dwSize ) )
			{
				return FALSE;
			}
		}
	}

	if ( dwBytesToRead > ( m_dwGlobalSize - dwOffset ) )
	{
		// they want new memory to be created :))
		for ( DWORD dw = 0; dw < dwMainCount; dw ++ )
		{
			if FAILED ( MemCreate ( m_dwSize ) )
			{
				return FALSE;
			}
		}
	}

	DWORD dwIndex	= 0L;
	DWORD dwRead	= 0;

	dwIndex = dwMainIndex;

	if ( m_dwCount && ( MEMORY** ) pMemory != NULL )
	{

		DWORD dwReadHelp = 0;

		do
		{
			MEMORY* pmem = const_cast< MEMORY* > ( pMemory [ dwIndex ] );

			if ( ! pmem -> Read (	(LPBYTE) pBuffer + dwRead,
									( ( dwBytesToRead - dwRead >= m_dwSize - dwOffset%m_dwSize ) ?
										m_dwSize - dwOffset%m_dwSize :
										( dwBytesToRead - dwRead ) % m_dwSize
									),
									&dwReadHelp,
									dwOffset%m_dwSize
								 )
			   )
			{
					return FALSE;
			}

			dwRead += dwReadHelp;
			dwOffset = 0;

			dwIndex++;

			if ( dwRead < dwBytesToRead && m_dwCount < dwIndex + 1 )
			{
				if FAILED ( MemCreate ( m_dwSize ) )
				{
					return FALSE;
				}
			}
		}
		while ( ( dwRead < dwBytesToRead ) && ( dwIndex < m_dwCount ) );
	}

	return TRUE;
}

template < class MEMORY >
PBYTE WmiMemoryExt < MEMORY >::ReadBytePtr ( DWORD dwIndex, DWORD* pdwBytesRead )
{
	if ( dwIndex < m_dwCount )
	{
		MEMORY* pmem = const_cast< MEMORY* > ( pMemory [ dwIndex ] );
		return pmem->Read ( pdwBytesRead, 0L );
	}

	if ( pdwBytesRead )
	{
		( *pdwBytesRead ) = 0L;
	}

	return NULL;
}

#endif	__MEMORY_EXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_perf_data_ext.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_data_ext.h
//
//	Abstract:
//
//					extension data declaration
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_DATA_EXT__
#define	__WMI_PERF_DATA_EXT__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

//////////////////////////////////////////////////////////////////////////////////////////////
// includes
//////////////////////////////////////////////////////////////////////////////////////////////
#include "refresherUtils.h"

//////////////////////////////////////////////////////////////////////////////////////////////
// variables
//////////////////////////////////////////////////////////////////////////////////////////////

extern LPCWSTR g_szKeyCounter;

#ifndef	__COMMON__
#include "__common.h"
#endif	__COMMON__

//////////////////////////////////////////////////////////////////////////////////////////////
// classes
//////////////////////////////////////////////////////////////////////////////////////////////
class WmiPerformanceDataExt
{
	DECLARE_NO_COPY ( WmiPerformanceDataExt );

	public:

	DWORD	m_dwFirstCounter;
	DWORD	m_dwFirstHelp;
	DWORD	m_dwLastCounter;
	DWORD	m_dwLastHelp;

	DWORD*	m_Ord2Ind;

	DWORD	m_dwCount;

	// construction
	WmiPerformanceDataExt () :
		m_dwFirstCounter ( 0 ),
		m_dwFirstHelp ( 0 ),
		m_dwLastCounter ( 0 ),
		m_dwLastHelp ( 0 ),

		m_Ord2Ind ( NULL ),

		m_dwCount ( 0 )

	{
	}

	// destruction
	virtual ~WmiPerformanceDataExt ()
	{
		OrdersClear();
	}

	HRESULT	OrdersAlloc ( DWORD dwSize )
	{
		HRESULT hr = S_FALSE;

		if ( dwSize )
		{
			// clear before use
			OrdersClear();

			if ( ( m_Ord2Ind = new DWORD [ dwSize ] ) != NULL )
			{
				hr = S_OK;
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}

		return hr;
	}

	void	OrdersClear ( void )
	{
		if ( m_Ord2Ind )
		{
			delete [] m_Ord2Ind;
			m_Ord2Ind = NULL;
		}
	}

	///////////////////////////////////////////////////////////////////////////
	// refresher ( GENERATED NEW STUFF )
	///////////////////////////////////////////////////////////////////////////

	void Generate ( void );
	BOOL IsValidGenerate ( void );
};

#endif	__WMI_PERF_DATA_EXT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_perf_reg.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_reg.h
//
//	Abstract:
//
//					declarations of registry helpers structure accessors etc
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_REG__
#define	__WMI_PERF_REG__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// need atl wrappers :)))
#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

#include "wmi_perf_regstruct.h"

//////////////////////////////////////////////////////////////////////////////////////////////
// class for creation of reg structures
//////////////////////////////////////////////////////////////////////////////////////////////

#include <pshpack8.h>

template < class REQUEST, class PARENT, class CHILD >
class CPerformanceStructureManipulator
{
	DECLARE_NO_COPY ( CPerformanceStructureManipulator );

	// variables
	REQUEST*							m_pRequest;

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	CPerformanceStructureManipulator( LPWSTR lpwsz, DWORD dwID ):
	m_pRequest(0)
	{
		m_pRequest = CreateStructure ( lpwsz, dwID );
	}

	CPerformanceStructureManipulator( DWORD dwLastID ):
	m_pRequest(0)
	{
		m_pRequest = CreateStructure ( dwLastID );
	}

	~CPerformanceStructureManipulator()
	{
		free ( m_pRequest );
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// append child object functions
	//////////////////////////////////////////////////////////////////////////////////////////

	HRESULT Append ( CHILD* pObject )
	{
		if ( ! pObject )
		{
			return E_INVALIDARG;
		}

		try
		{
			if ( m_pRequest )
			{
				::CopyMemory ( GetOffset ( m_pRequest->dwTotalLength ) , pObject, pObject->dwTotalLength );
				m_pRequest->dwTotalLength += pObject->dwTotalLength;
				m_pRequest->dwChildCount++;
				return S_OK;
			}
		}
		catch ( ... )
		{
		}

		return E_UNEXPECTED;
	}

	HRESULT AppendAlloc ( CHILD* pObject )
	{
		if ( ! pObject )
			return E_INVALIDARG;

		try
		{
			if ( ( m_pRequest ) && ( ( m_pRequest = (REQUEST*) realloc ( m_pRequest, m_pRequest->dwTotalLength + pObject->dwTotalLength ) ) != NULL ) )
			{
				::CopyMemory ( GetOffset ( m_pRequest->dwTotalLength ) , pObject, pObject->dwTotalLength );
				m_pRequest->dwTotalLength += pObject->dwTotalLength;
				m_pRequest->dwChildCount++;
				return S_OK;
			}
		}
		catch ( ... )
		{
			return E_FAIL;
		}

		return E_UNEXPECTED;
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// operators
	//////////////////////////////////////////////////////////////////////////////////////////

	operator REQUEST*() const
	{
		return m_pRequest;
	}

	REQUEST* operator= ( REQUEST* p )
	{
		m_pRequest = p;
		return m_pRequest;
	}

	BOOL IsEmpty ()
	{
		return (m_pRequest) ? FALSE : TRUE;
	}

	// operators BOOL
	BOOL operator! () const
	{
		return ( m_pRequest == NULL );
	}

	BOOL operator== (REQUEST* p) const
	{
		return ( m_p == p );
	}

	private:

	//////////////////////////////////////////////////////////////////////////////////////////
	// private helpers
	//////////////////////////////////////////////////////////////////////////////////////////

	// create structure & fill data
	static REQUEST* CreateStructure ( LPWSTR lpwsz, DWORD dwID )
	{
		REQUEST* pRequest = NULL;

		try
		{
			DWORD dwNameLength	= ( ::lstrlenW( lpwsz ) + 1 ) * sizeof ( WCHAR );

			DWORD dwAlignName	= 0L;
			if ( dwNameLength % 8 )
			{
				dwAlignName = 8 - ( dwNameLength % 8 );
			}

			DWORD dwAlignStruct	= 0L;
			if ( sizeof ( REQUEST ) % 8 )
			{
				dwAlignStruct = 8 - ( sizeof ( REQUEST ) % 8 );
			}

			DWORD dwLength		=	dwAlignName + dwNameLength + 
									dwAlignStruct + sizeof ( REQUEST );

			if ( ( pRequest = (REQUEST*) malloc ( dwLength ) ) != NULL )
			{
				// fill memory with zeros
				::ZeroMemory ( pRequest, dwLength );

				// copy string into structure
				::CopyMemory ( &(pRequest->dwName), lpwsz, dwNameLength );

				pRequest->dwNameLength	= dwNameLength;
				pRequest->dwLength		= dwLength;
				pRequest->dwTotalLength	= dwLength;

				pRequest->dwID = dwID;
			}
		}
		catch ( ... )
		{
		}

		return pRequest;
	}

	static REQUEST* CreateStructure ( DWORD dwLastID )
	{
		REQUEST* pRequest = NULL;

		try
		{
			DWORD dwAlignStruct	= 0L;
			if ( sizeof ( REQUEST ) % 8 )
			{
				dwAlignStruct = 8 - ( sizeof ( REQUEST ) % 8 );
			}

			DWORD dwLength		= dwAlignStruct + sizeof ( REQUEST );

			if ( ( pRequest = (REQUEST*) malloc ( dwLength ) ) != NULL )
			{
				// fill memory with zeros
				::ZeroMemory ( pRequest, dwLength );

				pRequest->dwLength		= dwLength;
				pRequest->dwTotalLength	= dwLength;

				pRequest->dwLastID = dwLastID;
			}
		}
		catch ( ... )
		{
		}

		return pRequest;
	}

	// return pointer from offset
	LPVOID GetOffset ( DWORD dwOffset )
	{
		if ( m_pRequest )
		{
			return ( ( LPVOID ) ( reinterpret_cast<PBYTE>( m_pRequest ) + dwOffset ) );
		}
		
		return NULL;
	}

};

//////////////////////////////////////////////////////////////////////////////////////////////
// typedefs
//////////////////////////////////////////////////////////////////////////////////////////////

typedef	CPerformanceStructureManipulator<WMI_PERF_PROPERTY, WMI_PERF_OBJECT, WMI_PERF_PROPERTY>		__PROPERTY;
typedef	CPerformanceStructureManipulator<WMI_PERF_OBJECT, WMI_PERF_NAMESPACE, WMI_PERF_PROPERTY>	__OBJECT;
typedef	CPerformanceStructureManipulator<WMI_PERF_NAMESPACE, WMI_PERFORMANCE, WMI_PERF_OBJECT>		__NAMESPACE;
typedef	CPerformanceStructureManipulator<WMI_PERFORMANCE, WMI_PERFORMANCE, WMI_PERF_NAMESPACE>		__PERFORMANCE;

//////////////////////////////////////////////////////////////////////////////////////////////
// class for registry
//////////////////////////////////////////////////////////////////////////////////////////////

class CPerformanceRegistry
{
	DECLARE_NO_COPY ( CPerformanceRegistry );

	// variables
	PWMI_PERFORMANCE	m_pPerf;

	public:

	// construction & detruction
	CPerformanceRegistry( PWMI_PERFORMANCE pPerf );
	~CPerformanceRegistry();

	// methods

	HRESULT	GetObject		( DWORD dwIndex, PWMI_PERF_OBJECT* ppObject );
	HRESULT	GetObjectName	( DWORD dwIndex, LPWSTR* ppwsz );
};

#include <poppack.h>

#endif	__WMI_PERF_REG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_perf_data.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_data.h
//
//	Abstract:
//
//					declaration of data performance service is dealing with
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_DATA__
#define	__WMI_PERF_DATA__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

//behaviour
#define	__SUPPORT_REGISTRY_DATA
#define	__SUPPORT_PSEUDO_COUNTER

#ifdef	__SUPPORT_PSEUDO_COUNTER
#define	PSEUDO_COUNTER	6
#else	__SUPPORT_PSEUDO_COUNTER
#define	PSEUDO_COUNTER	0
#endif	__SUPPORT_PSEUDO_COUNTER

//////////////////////////////////////////////////////////////////////////////////////////////
// includes
//////////////////////////////////////////////////////////////////////////////////////////////
#ifndef	_WINPERF_
#include "winperf.h"
#endif	_WINPERF_

#ifndef	__WMI_PERF_DATA_EXT__
#include "wmi_perf_data_ext.h"
#endif	__WMI_PERF_DATA_EXT__

#ifndef	__WMI_PERF_REGSTRUCT__
#include "wmi_perf_regstruct.h"
#endif	__WMI_PERF_REGSTRUCT__

// creator neccessary :))
#include "WMIAdapter_Stuff_Refresh.h"
class WmiRefreshObject;

///////////////////////////////////////////////////////////////////////////////
//
//	structure of memory
//
//	dwCount of MMF			... not yet
//	dwSize of MMF
//
//	dwSizeOfTable			... jumps to raw data
//	dwCountOfObjects
//	dwRealSize
//
//	---------------------------------------------
//
//	dwIndex
//	dwCounter				... object 1
//	dwOffset
//	dwValidity
//
//	---------------------------------------------
//	---------------------------------------------
//
//	dwIndex
//	dwCounter				... object 2
//	dwOffset
//	dwValidity
//
//	---------------------------------------------
//
//	raw data ( perf_object_types )
//
///////////////////////////////////////////////////////////////////////////////

#define	offsetCountMMF		0
#define	offsetSizeMMF		offsetCountMMF + sizeof ( DWORD )

#define	offsetSize1		offsetSizeMMF + sizeof ( DWORD )

#define	offsetSize		0
#define	offsetCount		offsetSize + sizeof ( DWORD )
#define	offsetRealSize	offsetCount + sizeof ( DWORD )
#define	offsetObject	offsetRealSize + sizeof ( DWORD )

#define	COUNTMMF		sizeof ( DWORD )
#define SIZEMMF			sizeof ( DWORD )

#define	SizeSize		sizeof ( DWORD )
#define	CountSize		sizeof ( DWORD )
#define	RealSize		sizeof ( DWORD )

#define	offIndex		0
#define	offCounter		offIndex + sizeof ( DWORD )
#define	offOffset		offCounter + sizeof ( DWORD )
#define	offValidity		offOffset + sizeof ( DWORD )

#define	ObjectSize		4 * sizeof ( DWORD )

//////////////////////////////////////////////////////////////////////////////////////////////
// variables
//////////////////////////////////////////////////////////////////////////////////////////////

// extrern constant

extern LPCWSTR g_szKey;
extern LPCWSTR g_szKeyValue;

//////////////////////////////////////////////////////////////////////////////////////////////
// classes
//////////////////////////////////////////////////////////////////////////////////////////////

#include <pshpack8.h>

// memory

#include "wmi_memory.h"
#include "wmi_memory_ext.h"

class WmiPerformanceData : public WmiPerformanceDataExt
{
	DECLARE_NO_COPY ( WmiPerformanceData );

	#ifdef	__SUPPORT_REGISTRY_DATA
	__WrapperPtr < WMI_PERFORMANCE >		m_perf;
	#endif	__SUPPORT_REGISTRY_DATA

	// data
	WmiMemoryExt < WmiMemory<WmiReverseGuard> > data;

	BYTE* m_pDataTable;
	DWORD m_dwDataTable;

	public:

	// construction
	WmiPerformanceData ():

		m_pDataTable ( NULL ),
		m_dwDataTable ( 0 )

	{
	}

	// destruction
	~WmiPerformanceData ()
	{
		DataClear();
		DataTableClear();

		#ifdef	__SUPPORT_REGISTRY_DATA
		ClearPerformanceData();
		#endif	__SUPPORT_REGISTRY_DATA
	}

	///////////////////////////////////////////////////////////////////////////
	// data structures ACCESSORS
	///////////////////////////////////////////////////////////////////////////

	void DataClear ( void )
	{
		data.MemDelete();
	}

	PBYTE GetData ( DWORD dwIndex, DWORD * dwBytesRead )
	{
		return data.ReadBytePtr ( dwIndex, dwBytesRead );
	}

	DWORD GetDataSize () const
	{
		return data.GetSize();
	}

	DWORD GetDataCount () const
	{
		return data.GetCount();
	}

	void DataTableClear ( void )
	{
		if ( m_pDataTable )
		{
			free ( m_pDataTable );

			m_pDataTable = NULL;
			m_dwDataTable = 0;
		}
	}

	PBYTE GetDataTable () const
	{
		return m_pDataTable;
	}

	DWORD GetDataTableSize () const
	{
		return m_dwDataTable;
	}

	DWORD GetDataTableOffset ()
	{
		return offsetSize1;
	}

	void SetDataTable ( BYTE* p )
	{
		___ASSERT ( m_pDataTable == NULL );
		m_pDataTable = p;
	}

	void SetDataTableSize ( DWORD dw )
	{
		___ASSERT ( m_dwDataTable == NULL );
		m_dwDataTable = dw;
	}

	///////////////////////////////////////////////////////////////////////////
	// performance internal structure ACCESSORS
	///////////////////////////////////////////////////////////////////////////

	#ifdef	__SUPPORT_REGISTRY_DATA

	void ClearPerformanceData ( void )
	{
		if ( ! m_perf.IsEmpty() )
		{
			delete m_perf.Detach();
		}
	}

	PWMI_PERFORMANCE GetPerformanceData () const
	{
		return m_perf;
	}

	void SetPerformanceData ( PWMI_PERFORMANCE perf )
	{
		// I'm empty one, don't I ? :)))
		___ASSERT ( m_perf == NULL );

		try
		{
			m_perf.SetData( perf );
		}
		catch ( ... )
		{
		}
	}

	void SetPerformanceDataCopy ( PWMI_PERFORMANCE perf )
	{
		// I'm empty one, don't I ? :)))
		___ASSERT ( m_perf == NULL );

		try
		{
			PWMI_PERFORMANCE p = NULL;

			if ( ( p = (PWMI_PERFORMANCE) new BYTE [ perf->dwTotalLength ] ) != NULL )
			{
				::CopyMemory ( p, perf, perf->dwTotalLength );
				m_perf.SetData ( p );
			}
		}
		catch ( ... )
		{
		}
	}

	#endif	__SUPPORT_REGISTRY_DATA

	HRESULT InitializeTable ( void );
	HRESULT	RefreshTable	( void );

	#ifdef	__SUPPORT_REGISTRY_DATA

	///////////////////////////////////////////////////////////////////////////
	// WINDOWS PERF structures
	///////////////////////////////////////////////////////////////////////////

	HRESULT InitializeData ( void );

	HRESULT	CreateData ( __WrapperARRAY< WmiRefresherMember < IWbemHiPerfEnum >* >	& enums,
						 __WrapperARRAY< WmiRefreshObject* >						& handles
					   );

	///////////////////////////////////////////////////////////////////////////
	// performance internal structure
	///////////////////////////////////////////////////////////////////////////
	HRESULT	InitializePerformance ( void );

	private:

	///////////////////////////////////////////////////////////////////////////
	// create objects
	///////////////////////////////////////////////////////////////////////////

	HRESULT	CreateDataInternal ( PWMI_PERF_OBJECT pObject,
								 IWbemHiPerfEnum* enm,
								 WmiRefreshObject* obj,
								 DWORD& dwCounter,
								 DWORD& dwHelp,
								 DWORD* pdwRes );

	#endif	__SUPPORT_REGISTRY_DATA


	private:

	///////////////////////////////////////////////////////////////////////////
	// append byte* :))
	///////////////////////////////////////////////////////////////////////////

	#ifdef	__SUPPORT_REGISTRY_DATA
	inline void AppendMemory ( BYTE* pStr, DWORD dwStr, DWORD& dwOffset );
	inline void AppendMemory ( DWORD dwValue, DWORD& dwOffset );
	#endif	__SUPPORT_REGISTRY_DATA

	public:

	///////////////////////////////////////////////////////////////////////////
	// work w/ specified offset ( UNSAFE )
	///////////////////////////////////////////////////////////////////////////

	DWORD	__GetValue ( BYTE * p, DWORD dwOffset )
	{
		___ASSERT ( p != NULL );
		return ( * reinterpret_cast<PDWORD> ( p + dwOffset ) );
	}

	void	__SetValue ( BYTE * p, DWORD dwValue, DWORD dwOffset )
	{
		___ASSERT ( p != NULL );
		* reinterpret_cast<PDWORD> ( p + dwOffset ) = dwValue;
	}
};

#include <poppack.h>
#endif	__WMI_PERF_DATA__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_perf_regstruct.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_regstruct.h
//
//	Abstract:
//
//					decalration of usefull registry structures and accessors
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_REGSTRUCT__
#define	__WMI_PERF_REGSTRUCT__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

//////////////////////////////////////////////////////////////////////////////////////////////
// structures
//////////////////////////////////////////////////////////////////////////////////////////////

#include <pshpack8.h>

typedef struct _WMI_PERFORMANCE {
	DWORD	dwTotalLength;		// total length
	DWORD	dwChildCount;		// count of namespaces for performance
	DWORD	dwLastID;			// index of last namespace in performance
	DWORD	dwLength;			// length of structure
} WMI_PERFORMANCE;

typedef struct _WMI_PERF_NAMESPACE {
	DWORD	dwTotalLength;	// total length
	DWORD	dwChildCount;	// count of objects for namespace
	DWORD	dwLastID;		// index of last object in namespace
	DWORD	dwParentID;		// parent's structure index
	DWORD	dwID;			// unique index
	DWORD	dwLength;		// length of structure
	DWORD	dwNameLength;	// length, in bytes, of the namespace name
	DWORD	dwName;			// offset of name from beginning to LPWSTR
} WMI_PERF_NAMESPACE;

typedef struct _WMI_PERF_OBJECT {
	DWORD	dwTotalLength;	// total length
	DWORD	dwChildCount;	// count of properties for object
	DWORD	dwLastID;		// index of last property in object
	DWORD	dwParentID;		// parent's structure index
	DWORD	dwID;			// unique index
	DWORD	dwSingleton;	// bool singleton

	// performance specific

	DWORD	dwDetailLevel;

	DWORD	dwLength;		// length of structure
	DWORD	dwNameLength;	// length, in bytes, of the object name
	DWORD	dwName;			// offset of name from beginning to LPWSTR
} WMI_PERF_OBJECT;

typedef struct _WMI_PERF_INSTANCE {
	DWORD	dwLength;		// length of the structure
	DWORD	dwNameLength;	// length, in bytes, of the instance name
	DWORD	dwName;			// offset of name from beginning to LPWSTR
} WMI_PERF_INSTANCE;

typedef struct _WMI_PERF_PROPERTY {
	DWORD	dwTotalLength;	// total length
	DWORD	dwParentID;		// parent's structure index
	DWORD	dwID;			// unique index
	DWORD	dwTYPE;			// type of property

	// perf specific data

	DWORD	dwDefaultScale;
	DWORD	dwDetailLevel;
	DWORD	dwCounterType;

	DWORD	dwLength;		// length of structure
	DWORD	dwNameLength;	// length, in bytes, of the instance name
	DWORD	dwName;			// offset of name from beginning to LPWSTR
} WMI_PERF_PROPERTY;


//////////////////////////////////////////////////////////////////////////////////////////////
// typedefs
//////////////////////////////////////////////////////////////////////////////////////////////

typedef	WMI_PERFORMANCE*	PWMI_PERFORMANCE;
typedef	WMI_PERF_NAMESPACE*	PWMI_PERF_NAMESPACE;
typedef	WMI_PERF_OBJECT*	PWMI_PERF_OBJECT;
typedef	WMI_PERF_INSTANCE*	PWMI_PERF_INSTANCE;
typedef	WMI_PERF_PROPERTY*	PWMI_PERF_PROPERTY;

//////////////////////////////////////////////////////////////////////////////////////////////
// class for manipulation with structures
//////////////////////////////////////////////////////////////////////////////////////////////

template < class REQUEST, class PARENT, class CHILD >
class __Manipulator
{
	__Manipulator(__Manipulator&)					{}
	__Manipulator& operator=(const __Manipulator&)	{}

	public:

	// construction & detruction
	__Manipulator()		{}
	~__Manipulator()	{}

	// methods

	//////////////////////////////////////////////////////////////////////////////////////////
	// accessors
	//////////////////////////////////////////////////////////////////////////////////////////

	inline static REQUEST First ( PARENT pParent )
	{
		if ( pParent->dwChildCount )
		{
			return ( (REQUEST) ( reinterpret_cast<PBYTE>( pParent ) + pParent->dwLength ) );
		}
		else
		{
			return NULL;
		}
	}

	inline static REQUEST Next ( REQUEST pRequest )
	{
		return ( (REQUEST) ( reinterpret_cast<PBYTE>( pRequest ) + pRequest->dwTotalLength ) );
	}

	// looking function
	inline static REQUEST Get ( PARENT pParent, DWORD dwIndex )
	{
		if ( ! pParent || ( pParent->dwLastID < dwIndex ) )
		{
			return NULL;
		}

		// obtain correct namespace
		REQUEST pRequest = First ( pParent );

		if ( pRequest )
		{
			while ( pRequest->dwID < dwIndex )
			{
				pRequest = Next ( pRequest );
			}

			if ( pRequest->dwID == dwIndex )
			{
				return pRequest;
			}
		}

		// not found
		return NULL;
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// names
	//////////////////////////////////////////////////////////////////////////////////////////

	// name functions
	inline static LPWSTR GetName ( REQUEST pRequest )
	{
		return reinterpret_cast<LPWSTR> (&(pRequest->dwName));
	}
};

typedef __Manipulator< PWMI_PERF_PROPERTY, PWMI_PERF_OBJECT, PWMI_PERF_PROPERTY >	__Property;
typedef __Manipulator< PWMI_PERF_OBJECT, PWMI_PERF_NAMESPACE, PWMI_PERF_PROPERTY >	__Object;
typedef __Manipulator< PWMI_PERF_NAMESPACE, PWMI_PERFORMANCE, PWMI_PERF_OBJECT >	__Namespace;

inline DWORD __TotalLength ( PWMI_PERF_PROPERTY pProperty )
{
	if (pProperty)
	return pProperty->dwLength;
	else
	return NULL;
}

inline DWORD __TotalLength ( PWMI_PERF_INSTANCE pInst )
{
	if (pInst)
	return pInst->dwLength;
	else
	return NULL;
}

inline DWORD __TotalLength ( PWMI_PERF_OBJECT pObject )
{
	if (pObject)
	{
		if ( pObject->dwChildCount )
		{
			PWMI_PERF_PROPERTY	pProperty	= __Property::First ( pObject );

			if ( pProperty )
			{
				DWORD			length		= pProperty->dwTotalLength;

				for ( DWORD i = 1; i < pObject->dwChildCount; i++ )
				{
					pProperty = __Property::Next ( pProperty );
					length	 += pProperty->dwTotalLength;
				}

				return length + pObject->dwLength;
			}
			else
			{
				return pObject->dwLength;
			}
		}
		else
		{
			return pObject->dwLength;
		}
	}
	else
	return NULL;
}

inline DWORD __TotalLength ( PWMI_PERF_NAMESPACE pNamespace )
{
	if (pNamespace)
	{
		if ( pNamespace->dwChildCount )
		{
			PWMI_PERF_OBJECT	pObject	= __Object::First ( pNamespace );

			if ( pObject )
			{
				DWORD			length		= pObject->dwTotalLength;

				for ( DWORD i = 1; i < pNamespace->dwChildCount; i++ )
				{
					pObject  = __Object::Next ( pObject );
					length	+= pObject->dwTotalLength;
				}

				return length + pNamespace->dwLength;
			}
			else
			{
				return pNamespace->dwLength;
			}
		}
		else
		{
			return pNamespace->dwLength;
		}
	}
	else
	{
		return NULL;
	}
}

inline DWORD __TotalLength ( PWMI_PERFORMANCE pPerf )
{
	if (pPerf)
	{
		if ( pPerf->dwChildCount )
		{
			PWMI_PERF_NAMESPACE	pNamespace	= __Namespace::First ( pPerf );

			if ( pNamespace )
			{
				DWORD			length		= pNamespace->dwTotalLength;

				for ( DWORD i = 1; i < pPerf->dwChildCount; i++ )
				{
					pNamespace = __Namespace::Next ( pNamespace );
					length	 += pNamespace->dwTotalLength;
				}

				return length + pPerf->dwLength;
			}
			else
			{
				return pPerf->dwLength;
			}
		}
		else
		{
			return pPerf->dwLength;
		}
	}
	else
	{
		return NULL;
	}
}

#include <poppack.h>

#endif	__WMI_PERF_REGSTRUCT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_reverse_guard_auto.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_reverse_guard_auto.h
//
//	Abstract:
//
//					automatic guard section
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__REVERSE_GUARD_AUTO_H__
#define	__REVERSE_GUARD_AUTO_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

///////////////////////////////////////////////////////////////////////////////
//
//	automatic critical section
//
//	note:
//
//	problem arrives if I own critical section and creation failed
//	I actually don't lock/unlock then
//
///////////////////////////////////////////////////////////////////////////////

template < class CRITSEC >
class WmiReverseGUARD_Auto_Read
{
	DECLARE_NO_COPY ( WmiReverseGUARD_Auto_Read );

	// variables
	CRITSEC*		pCS;

	public:

	// construction & destruction
	WmiReverseGUARD_Auto_Read ( CRITSEC* p ) :
		pCS ( NULL )
	{
		try
		{
			// enter read
			( pCS = p )->EnterRead();
		}
		catch ( ... )
		{
			pCS = NULL;
		}
	}

	virtual ~WmiReverseGUARD_Auto_Read()
	{
		try
		{
			// leave read
			pCS->LeaveRead();
		}
		catch ( ... )
		{
		}
	}
};

template < class CRITSEC >
class WmiReverseGUARD_Auto_Write
{
	DECLARE_NO_COPY ( WmiReverseGUARD_Auto_Write );

	// variables
	CRITSEC*		pCS;

	public:

	// construction & destruction
	WmiReverseGUARD_Auto_Write ( CRITSEC* p ) :
		pCS ( NULL )
	{
		try
		{
			// enter write
			( pCS = p )->EnterWrite();
		}
		catch ( ... )
		{
			pCS = NULL;
		}
	}

	virtual ~WmiReverseGUARD_Auto_Write()
	{
		try
		{
			// leave write
			pCS->LeaveWrite();
		}
		catch ( ... )
		{
		}
	}
};

#endif	__REVERSE_GUARD_AUTO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_reverse_guard.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_reverse_guard.h
//
//	Abstract:
//
//					guard critical section ( named ... uses named semaphores )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__REVERSE_GUARD_H__
#define	__REVERSE_GUARD_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// security attributes
#ifndef	__WMI_SECURITY_ATTRIBUTES_H__
#include "WMI_security_attributes.h"
#endif	__WMI_SECURITY_ATTRIBUTES_H__

class WmiReverseGuard
{
	DECLARE_NO_COPY ( WmiReverseGuard );

	HANDLE	m_ReaderSemaphore ;
	LONG			m_ReaderSize ;

	HANDLE	m_WriterSemaphore ;
	LONG			m_WriterSize ;

	bool bInit;

	public:

	// construction & destruction
	WmiReverseGuard (	BOOL bNamed,
						const LONG &a_ReaderSize,
						const LONG &a_WriterSize = 1,
						LPSECURITY_ATTRIBUTES psa = NULL ) :

	m_ReaderSize ( a_ReaderSize ),
	m_WriterSize ( a_WriterSize ),

	m_ReaderSemaphore ( NULL ),
	m_WriterSemaphore ( NULL ),

	bInit ( false )
	{
		try
		{
			m_ReaderSemaphore = CreateSemaphore ( m_ReaderSize, bNamed, TRUE, psa );
			m_WriterSemaphore = CreateSemaphore ( m_WriterSize, bNamed, FALSE, psa );
		}
		catch ( ... )
		{
			m_ReaderSemaphore = NULL;
			m_WriterSemaphore = NULL;
		}

		if ( m_ReaderSemaphore && m_WriterSemaphore )
		{
			bInit = true;
		}
	}

	virtual ~WmiReverseGuard ()
	{
		if ( m_ReaderSemaphore ) 
		{
			::CloseHandle ( m_ReaderSemaphore );
			m_ReaderSemaphore = NULL ;
		}
		if ( m_WriterSemaphore ) 
		{
			::CloseHandle ( m_WriterSemaphore );
			m_WriterSemaphore = NULL ;
		}
	}

	// functions

	virtual HRESULT	EnterRead ( const LONG &a_Timeout = INFINITE ) ;
	virtual HRESULT	EnterWrite ( const LONG &a_Timeout = INFINITE ) ;

	virtual HRESULT	LeaveRead () ;
	virtual HRESULT	LeaveWrite () ;

	private:

	HANDLE	CreateSemaphore (	LONG lSize,
								BOOL bNamed,
								BOOL bReader,
								LPSECURITY_ATTRIBUTES psa = NULL	)
	{
		HANDLE hResult = NULL;

		if ( !bNamed )
		{
			hResult = ::CreateSemaphoreW ( psa , lSize, lSize, NULL );
		}
		else
		{
			if ( bReader )
			{
				hResult =::CreateSemaphoreW	( psa, lSize, lSize, L"Global\\MEMORYGuard_Reader" );
			}
			else
			{
				hResult =::CreateSemaphoreW	( psa, lSize, lSize, L"Global\\MEMORYGuard_Writter" );
			}
		}

		return hResult;
	}
};

#endif	__REVERSE_GUARD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_perf_struct.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_struct.h
//
//	Abstract:
//
//					definitions of usefull accessors of perf structures
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_STRUCT__
#define	__WMI_PERF_STRUCT__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

//////////////////////////////////////////////////////////////////////////////////////////////
// structures
//////////////////////////////////////////////////////////////////////////////////////////////

#include <WinPerf.h>
#include <pshpack8.h>

//////////////////////////////////////////////////////////////////////////////////////////////
// ACCESSORS
//////////////////////////////////////////////////////////////////////////////////////////////

inline PPERF_OBJECT_TYPE FirstObject( PPERF_DATA_BLOCK PerfData )
{
	return( (PPERF_OBJECT_TYPE)((PBYTE)PerfData + PerfData->HeaderLength) );
}

inline PPERF_OBJECT_TYPE NextObject( PPERF_OBJECT_TYPE PerfObj )
{
	return( (PPERF_OBJECT_TYPE)((PBYTE)PerfObj + PerfObj->TotalByteLength) );
}

inline PPERF_INSTANCE_DEFINITION FirstInstance( PPERF_OBJECT_TYPE PerfObj )
{
	return( (PPERF_INSTANCE_DEFINITION)((PBYTE)PerfObj + PerfObj->DefinitionLength) );
}

inline PPERF_INSTANCE_DEFINITION NextInstance( PPERF_INSTANCE_DEFINITION PerfInst )
{
	PPERF_COUNTER_BLOCK PerfCntrBlk;
	PerfCntrBlk = (PPERF_COUNTER_BLOCK)((PBYTE)PerfInst + PerfInst->ByteLength);

	return( (PPERF_INSTANCE_DEFINITION)((PBYTE)PerfCntrBlk + PerfCntrBlk->ByteLength) );
}

inline PPERF_COUNTER_DEFINITION FirstCounter( PPERF_OBJECT_TYPE PerfObj )
{
	return( (PPERF_COUNTER_DEFINITION) ((PBYTE)PerfObj + PerfObj->HeaderLength) );
}

inline PPERF_COUNTER_DEFINITION NextCounter( PPERF_COUNTER_DEFINITION PerfCntr )
{
	return( (PPERF_COUNTER_DEFINITION)((PBYTE)PerfCntr + PerfCntr->ByteLength) );
}

#include <poppack.h>

#endif	__WMI_PERF_STRUCT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_reverse_memory.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_reverse_memory.h
//
//	Abstract:
//
//					shared memory wrapper
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__REVERSE_MEMORY_H__
#define	__REVERSE_MEMORY_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// security attributes
#ifndef	__WMI_SECURITY_ATTRIBUTES_H__
#include "WMI_security_attributes.h"
#endif	__WMI_SECURITY_ATTRIBUTES_H__

///////////////////////////////////////////////////////////////////////////////
//
//	structure of memory
//
//	dwCount of MMF			... not yet
//	dwSize of MMF
//
//	dwSizeOfTable			... jumps to raw data
//	dwCountOfObjects
//	dwRealSize
//
//	---------------------------------------------
//
//	dwIndex
//	dwCounter				... object 1
//	dwOffset
//	dwValidity
//
//	---------------------------------------------
//	---------------------------------------------
//
//	dwIndex
//	dwCounter				... object 2
//	dwOffset
//	dwValidity
//
//	---------------------------------------------
//
//	raw data ( perf_object_types )
//
///////////////////////////////////////////////////////////////////////////////

#define	offsetCountMMF		0
#define	offsetSizeMMF		offsetCountMMF + sizeof ( DWORD )

#define	offsetSize1		offsetSizeMMF + sizeof ( DWORD )
#define	offsetCount1	offsetSize1 + sizeof ( DWORD )
#define	offsetRealSize1	offsetCount1 + sizeof ( DWORD )
#define	offsetObject1	offsetRealSize1 + sizeof ( DWORD )

#define	offIndex1		0
#define	offCounter1		offIndex1 + sizeof ( DWORD )
#define	offOffset1		offCounter1 + sizeof ( DWORD )
#define	offValidity1	offOffset1 + sizeof ( DWORD )

#define	ObjectSize1		4 * sizeof ( DWORD )

template < class _DUMMY >
class WmiReverseMemory
{
	DECLARE_NO_COPY ( WmiReverseMemory );

	protected:

	LONG	m_lCount;

	DWORD	m_dwSize;

	HANDLE	m_hMap;
	void*	m_pMem;

	HRESULT m_LastError;

	public:

	/////////////////////////////////////////////////////////////////////////////////////
	//	LAST ERROR HELPER
	/////////////////////////////////////////////////////////////////////////////////////

	HRESULT GetLastError ( void )
	{
		HRESULT hr = S_OK;

		hr			= m_LastError;
		m_LastError = S_OK;

		return hr;
	}

	// construction

	WmiReverseMemory ( LPCWSTR wszName, DWORD dwSize = 4096, LPSECURITY_ATTRIBUTES psa = NULL ):
		m_hMap ( NULL ),
		m_pMem ( NULL ),
		m_dwSize ( 0 ),
		m_lCount ( 0 ),

		m_LastError ( S_OK )
	{
		try
		{
			MemCreate ( wszName, dwSize, psa );
		}
		catch ( ... )
		{
		}
	}

	virtual ~WmiReverseMemory ()
	{
		if ( m_pMem )
		{
			// flush memory at the end
			::FlushViewOfFile ( m_pMem, m_dwSize );
		}

		try
		{
			MemDelete ();
		}
		catch ( ... )
		{
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////
	//	VALIDITY
	/////////////////////////////////////////////////////////////////////////////////////

	BOOL IsValid ( void )
	{
		return ( m_pMem != NULL );
	}

	/////////////////////////////////////////////////////////////////////////////////////
	//	ACCESSORS
	/////////////////////////////////////////////////////////////////////////////////////

	// get data
	PVOID	GetData () const
	{
		return m_pMem;
	}

	// get data size
	DWORD	GetDataSize () const
	{
		return m_dwSize;
	}

	void	SetDataSize ( DWORD size )
	{
		m_dwSize = size;
	}

	// functions
	virtual BOOL Write (LPCVOID pBuffer, DWORD dwBytesToWrite, DWORD* pdwBytesWritten, DWORD dwOffset);
	virtual BOOL Read (LPVOID pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead, DWORD dwOffset);

	virtual PBYTE Find ( PBYTE pbSearchBytes, DWORD dwSearchBytes )
	{
		___ASSERT(m_hMap != NULL);
		___ASSERT(m_pMem != NULL);

		if ( dwSearchBytes > m_dwSize )
		{
			// what are you looking for looser :))
			return NULL;
		}
		else
		{
			for ( DWORD n = 0; n < ( m_dwSize - dwSearchBytes ); n++ )
			{
				if ( static_cast<PBYTE>( m_pMem )[n] == pbSearchBytes[0] )
				{
					for (DWORD x = 1; x < dwSearchBytes; x++)
					{
						if ( static_cast<PBYTE>( m_pMem )[n + x] != pbSearchBytes[x] ) 
						{
							break; // Not a match
						}
					}

					if (x == dwSearchBytes)
					{
						return static_cast <PBYTE> ( &( static_cast<PBYTE>( m_pMem )[n] ) );
					}
				}
			}
		}

		return(NULL);
	}

	// helpers
	HRESULT MemCreate ( LPCWSTR wszName, DWORD dwSize, LPSECURITY_ATTRIBUTES psa );
	HRESULT MemDelete ();

	LONG	References ( void );
};

// create shared memory
template < class _DUMMY >
HRESULT WmiReverseMemory < _DUMMY > ::MemCreate ( LPCWSTR wszName, DWORD dwSize, LPSECURITY_ATTRIBUTES psa )
{
	if ( ( m_hMap = ::CreateFileMappingW (	INVALID_HANDLE_VALUE,
											psa,
											PAGE_READWRITE,
											0,
											dwSize,
											wszName
										 ) )

										!= NULL )
	{
		bool bInit = false;
		bInit = ( ::GetLastError() == ERROR_ALREADY_EXISTS );

		if ( ( m_pMem = ::MapViewOfFile ( m_hMap, FILE_MAP_ALL_ACCESS, 0, 0, 0 ) ) != NULL )
		{
			if ( !bInit )
			{
				::memset ( m_pMem, 0, dwSize );
				// store real size :))
				* reinterpret_cast<PDWORD> ( (LPBYTE) m_pMem + offsetSizeMMF ) = dwSize;

				// cache size :))
				m_dwSize = dwSize;
			}
			else
			{
				// get real size from MMF
				m_dwSize = * reinterpret_cast<PDWORD> ( (LPBYTE) m_pMem + offsetSizeMMF );
			}

			::InterlockedIncrement ( &m_lCount );
		}
		else
		{
			::CloseHandle ( m_hMap );
			m_hMap = NULL;

			m_LastError = HRESULT_FROM_WIN32 ( ::GetLastError () );
		}
	}
	else
	{
		m_LastError = HRESULT_FROM_WIN32 ( ::GetLastError () );
		return m_LastError;
	}

	return S_OK;
}

// delete shared memory
template < class _DUMMY >
HRESULT WmiReverseMemory < _DUMMY > ::MemDelete ()
{
	if ( m_lCount && ::InterlockedDecrement ( &m_lCount ) == 0 )
	{
		if ( m_pMem )
		{
			::UnmapViewOfFile ( m_pMem );
			m_pMem = NULL;
		}

		if ( m_hMap )
		{
			::CloseHandle ( m_hMap );
			m_hMap = NULL;
		}

		return S_OK;
	}

	m_LastError = S_FALSE;
	return m_LastError;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// write into memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class _DUMMY >
BOOL WmiReverseMemory < _DUMMY > ::Write (LPCVOID pBuffer, DWORD dwBytesToWrite, DWORD* pdwBytesWritten, DWORD dwOffset )
{
	___ASSERT(m_hMap != NULL);
	___ASSERT(m_pMem != NULL);

	if ( dwOffset > m_dwSize )
	{
		if ( pdwBytesWritten )
		{
			*pdwBytesWritten = 0;
		}

		m_LastError = E_INVALIDARG;
		return FALSE;
	}

	DWORD dwCount = min ( dwBytesToWrite, m_dwSize - dwOffset );
	::CopyMemory ((LPBYTE) m_pMem + dwOffset, pBuffer, dwCount);

	if (pdwBytesWritten != NULL)
	{
		*pdwBytesWritten = dwCount;
	}

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// read from memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class _DUMMY >
BOOL WmiReverseMemory < _DUMMY > ::Read (LPVOID pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead, DWORD dwOffset )
{
	___ASSERT (m_hMap != NULL);
	___ASSERT (m_pMem != NULL);

	if (dwOffset > m_dwSize)
	{
		if ( pdwBytesRead )
		{
			*pdwBytesRead = 0;
		}

		m_LastError = E_INVALIDARG;
		return FALSE;
	}

	DWORD dwCount = min (dwBytesToRead, m_dwSize - dwOffset);
	::CopyMemory (pBuffer, (LPBYTE) m_pMem + dwOffset, dwCount);

	if (pdwBytesRead != NULL)
	{
		*pdwBytesRead = dwCount;
	}

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// undocumented kernel stuff for having number of object here
//
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class CRITSEC >
LONG WmiReverseMemory < CRITSEC > :: References ( void )
{
	LONG				lResult = -1;
	
	if ( m_hMap )
	{
		NTSTATUS Status = 0;
		OBJECT_BASIC_INFORMATION	BasicInfo;

		Status = NtQueryObject	(	m_hMap,
									ObjectBasicInformation,
									(PVOID)&BasicInfo,
									sizeof(BasicInfo),
									NULL
								);

		if ( NT_SUCCESS ( Status ) )
		{
			lResult = static_cast < LONG > ( BasicInfo.HandleCount );
		}
	}

	return lResult;
}

#endif	__REVERSE_MEMORY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_security_attributes.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_security_attributes.h
//
//	Abstract:
//
//					security attributtes wrapper
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_SECURITY_ATTRIBUTES_H__
#define	__WMI_SECURITY_ATTRIBUTES_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#ifndef	__WMI_SECURITY_H__
#include "WMI_security.h"
#endif	__WMI_SECURITY_H__

class WmiSecurityAttributes
{
	DECLARE_NO_COPY ( WmiSecurityAttributes );

	// variables
	__WrapperPtr < SECURITY_ATTRIBUTES >	m_psa;
	__WrapperPtr < WmiSecurity >			m_psd;

	public:

	// construction
	WmiSecurityAttributes ( BOOL bInherit = FALSE )
	{
		BOOL bInit  = FALSE;
		BOOL bAlloc	= FALSE;

		try
		{
			m_psa.SetData ( new SECURITY_ATTRIBUTES() );
			if ( ! m_psa.IsEmpty() )
			{
				bAlloc = TRUE;

				m_psd.SetData ( new WmiSecurity() );
				if ( ! m_psd.IsEmpty() )
				{
					if ( m_psd->Get () )
					{
						// init security attributes
						m_psa->nLength				= sizeof ( SECURITY_ATTRIBUTES );
						m_psa->lpSecurityDescriptor = m_psd->Get ();
						m_psa->bInheritHandle		= bInherit;

						bInit = TRUE;
					}
				}
			}
		}
		catch ( ... )
		{
		}

		if ( bAlloc && !bInit )
		{
			SECURITY_ATTRIBUTES* atr = NULL;
			atr = m_psa.Detach ();

			if ( atr )
			{
				delete atr;
				atr = NULL;
			}
		}
	}

	// destruction
	~WmiSecurityAttributes ()
	{
		// direct delete ( not neccessary )
		delete m_psd.Detach();
		delete m_psa.Detach();
	}

	// operator
	operator PSECURITY_ATTRIBUTES()
	{
		return GetSecurityAttributtes();
	}

	PSECURITY_ATTRIBUTES GetSecurityAttributtes()
	{
		return ( m_psa.IsEmpty() ) ? NULL : (PSECURITY_ATTRIBUTES) m_psa;
	}

	operator PSECURITY_DESCRIPTOR()
	{
		return GetSecurityDescriptor();
	}

	PSECURITY_DESCRIPTOR GetSecurityDescriptor()
	{
		return ( m_psd.IsEmpty() ) ? NULL : (PSECURITY_DESCRIPTOR) m_psd->Get();
	}
};

#endif	__WMI_SECURITY_ATTRIBUTES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_reverse_memory_ext.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_reverse_memory_ext.h
//
//	Abstract:
//
//					shared memory extension
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__REVERSE_MEMORY_EXT_H__
#define	__REVERSE_MEMORY_EXT_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// guard
#include "wmi_reverse_guard.h"

// performance
#ifndef	__WMI_PERF_STRUCT__
#include "wmi_perf_struct.h"
#endif	__WMI_PERF_STRUCT__

#ifndef	_WINPERF_
#include "winperf.h"
#endif	_WINPERF_

// shared memory
#include "wmi_reverse_memory.h"

///////////////////////////////////////////////////////////////////////////////
//	CRITGUARD 
//
//	requirements
//
//	constructor for object by name
//	enter ( read , write ) /leave ( read , write ) functions
//
///////////////////////////////////////////////////////////////////////////////

#include <pshpack8.h>

template < class CRITGUARD >
class WmiReverseMemoryExt : public WmiReverseMemory < void >
{
	DECLARE_NO_COPY ( WmiReverseMemoryExt );

	__WrapperPtr < CRITGUARD > m_pGUARD;

	public:

	// construction
	WmiReverseMemoryExt ( LPCWSTR wszName, DWORD dwSize = 4096, LPSECURITY_ATTRIBUTES psa = NULL ) : 
	WmiReverseMemory < void > ( wszName, dwSize, psa )
	{
		// create cross process guard
		try
		{
			m_pGUARD.SetData ( new CRITGUARD( TRUE, 100, 1, psa ) );
		}
		catch ( ... )
		{
			___ASSERT_DESC ( m_pGUARD != NULL, L"Constructor FAILED !" );
		}
	}

	virtual ~WmiReverseMemoryExt ()
	{
	}

	virtual BOOL Write (LPCVOID pBuffer, DWORD dwBytesToWrite, DWORD* pdwBytesWritten, DWORD dwOffset);
	virtual BOOL Read (LPVOID pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead, DWORD dwOffset);

	///////////////////////////////////////////////////////////////////////////
	// work w/ specified offset
	///////////////////////////////////////////////////////////////////////////

	DWORD	GetValue ( DWORD dwOffset )
	{
		DWORD dw = (DWORD) -1;
		Read ( &dw, sizeof ( DWORD ), 0, dwOffset );

		return dw;
	}

	void	SetValue ( DWORD dwValue, DWORD dwOffset )
	{
		Write ( &dwValue, sizeof ( DWORD ), 0, dwOffset );
	}
};

///////////////////////////////////////////////////////////////////////////////////////////////////
// write into memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class CRITGUARD >
BOOL WmiReverseMemoryExt < CRITGUARD > ::Write (LPCVOID pBuffer, DWORD dwBytesToWrite, DWORD* pdwBytesWritten, DWORD dwOffset)
{
	___ASSERT(m_hMap != NULL);
	___ASSERT(m_pMem != NULL);

	BOOL bResult = FALSE;

	if ( !m_pGUARD )
	{
		try
		{
			bResult = WmiReverseMemory < void > :: Write ( pBuffer, dwBytesToWrite, pdwBytesWritten, dwOffset );
		}
		catch ( ... )
		{
		}
	}
	else
	{
		m_pGUARD->EnterWrite ();
		try
		{
			bResult = WmiReverseMemory < void > :: Write ( pBuffer, dwBytesToWrite, pdwBytesWritten, dwOffset );
		}
		catch ( ... )
		{
		}
		m_pGUARD->LeaveWrite ();
	}

	return bResult;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// read from memory
///////////////////////////////////////////////////////////////////////////////////////////////////

template < class CRITGUARD >
BOOL WmiReverseMemoryExt < CRITGUARD > ::Read (LPVOID pBuffer, DWORD dwBytesToRead, DWORD* pdwBytesRead, DWORD dwOffset)
{
	___ASSERT (m_hMap != NULL);
	___ASSERT (m_pMem != NULL);

	BOOL bResult = FALSE;

	if ( !m_pGUARD )
	{
		try
		{
			bResult = WmiReverseMemory < void > :: Read ( pBuffer, dwBytesToRead, pdwBytesRead, dwOffset);
		}
		catch ( ... )
		{
		}
	}
	else
	{
		m_pGUARD->EnterRead ();
		try
		{
			bResult = WmiReverseMemory < void > :: Read ( pBuffer, dwBytesToRead, pdwBytesRead, dwOffset);
		}
		catch ( ... )
		{
		}
		m_pGUARD->LeaveRead ();
	}

	return bResult;
}

#include <poppack.h>

#endif	__REVERSE_MEMORY_EXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_security_descriptor.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_security_descriptor.h
//
//	Abstract:
//
//					security descriptor wrapper
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_SECURITY_DESCRIPTOR_H__
#define	__WMI_SECURITY_DESCRIPTOR_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#ifndef	__ATLCOM_H__

//////////////////////////////////////////////////////////////////////////////
// CSecurityDescriptor
class CSecurityDescriptor
{
public:
	CSecurityDescriptor();
	~CSecurityDescriptor();

public:
	HRESULT Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD);
	HRESULT AttachObject(HANDLE hObject);
	HRESULT Initialize();
	HRESULT InitializeFromProcessToken(BOOL bDefaulted = FALSE);
	HRESULT InitializeFromThreadToken(BOOL bDefaulted = FALSE, BOOL bRevertToProcessToken = TRUE);
	HRESULT SetOwner(PSID pOwnerSid, BOOL bDefaulted = FALSE);
	HRESULT SetGroup(PSID pGroupSid, BOOL bDefaulted = FALSE);
	HRESULT Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask);
	HRESULT Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask);
	HRESULT Revoke(LPCTSTR pszPrincipal);

	// utility functions
	// Any PSID you get from these functions should be free()ed
	static HRESULT SetPrivilege(LPCTSTR Privilege, BOOL bEnable = TRUE, HANDLE hToken = NULL);
	static HRESULT GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid);
	static HRESULT GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid = NULL);
	static HRESULT GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid = NULL, BOOL bOpenAsSelf = FALSE);
	static HRESULT CopyACL(PACL pDest, PACL pSrc);
	static HRESULT GetCurrentUserSID(PSID *ppSid);
	static HRESULT GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid);
	static HRESULT AddAccessAllowedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
	static HRESULT AddAccessDeniedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
	static HRESULT RemovePrincipalFromACL(PACL Acl, LPCTSTR pszPrincipal);

	operator PSECURITY_DESCRIPTOR()
	{
		return m_pSD;
	}

public:
	PSECURITY_DESCRIPTOR m_pSD;
	PSID m_pOwner;
	PSID m_pGroup;
	PACL m_pDACL;
	PACL m_pSACL;
};

inline CSecurityDescriptor::CSecurityDescriptor()
{
	m_pSD = NULL;
	m_pOwner = NULL;
	m_pGroup = NULL;
	m_pDACL = NULL;
	m_pSACL= NULL;
}

inline CSecurityDescriptor::~CSecurityDescriptor()
{
	if (m_pSD)
		delete m_pSD;
	if (m_pOwner)
		free(m_pOwner);
	if (m_pGroup)
		free(m_pGroup);
	if (m_pDACL)
		free(m_pDACL);
	if (m_pSACL)
		free(m_pSACL);
}

inline HRESULT CSecurityDescriptor::Initialize()
{
	if (m_pSD)
	{
		delete m_pSD;
		m_pSD = NULL;
	}
	if (m_pOwner)
	{
		free(m_pOwner);
		m_pOwner = NULL;
	}
	if (m_pGroup)
	{
		free(m_pGroup);
		m_pGroup = NULL;
	}
	if (m_pDACL)
	{
		free(m_pDACL);
		m_pDACL = NULL;
	}
	if (m_pSACL)
	{
		free(m_pSACL);
		m_pSACL = NULL;
	}

	ATLTRY(m_pSD = new SECURITY_DESCRIPTOR);
	if (m_pSD == NULL)
		return E_OUTOFMEMORY;

	if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		delete m_pSD;
		m_pSD = NULL;
		ATLASSERT(FALSE);
		return hr;
	}
	// Set the DACL to allow EVERYONE
	SetSecurityDescriptorDacl(m_pSD, TRUE, NULL, FALSE);
	return S_OK;
}

inline HRESULT CSecurityDescriptor::InitializeFromProcessToken(BOOL bDefaulted)
{
	PSID pUserSid = NULL;
	PSID pGroupSid = NULL;
	HRESULT hr;

	Initialize();
	hr = GetProcessSids(&pUserSid, &pGroupSid);
	if (SUCCEEDED(hr))
	{
		hr = SetOwner(pUserSid, bDefaulted);
		if (SUCCEEDED(hr))
			hr = SetGroup(pGroupSid, bDefaulted);
	}
	if (pUserSid != NULL)
		free(pUserSid);
	if (pGroupSid != NULL)
		free(pGroupSid);
	return hr;
}

inline HRESULT CSecurityDescriptor::InitializeFromThreadToken(BOOL bDefaulted, BOOL bRevertToProcessToken)
{
	PSID pUserSid = NULL;
	PSID pGroupSid = NULL;
	HRESULT hr;

	Initialize();
	hr = GetThreadSids(&pUserSid, &pGroupSid);
	if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
		hr = GetProcessSids(&pUserSid, &pGroupSid);
	if (SUCCEEDED(hr))
	{
		hr = SetOwner(pUserSid, bDefaulted);
		if (SUCCEEDED(hr))
			hr = SetGroup(pGroupSid, bDefaulted);
	}
	if (pUserSid != NULL)
		free(pUserSid);
	if (pGroupSid != NULL)
		free(pGroupSid);
	return hr;
}

inline HRESULT CSecurityDescriptor::SetOwner(PSID pOwnerSid, BOOL bDefaulted)
{
	ATLASSERT(m_pSD);

	// Mark the SD as having no owner
	if (!SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		return hr;
	}

	if (m_pOwner)
	{
		free(m_pOwner);
		m_pOwner = NULL;
	}

	// If they asked for no owner don't do the copy
	if (pOwnerSid == NULL)
		return S_OK;

	// Make a copy of the Sid for the return value
	DWORD dwSize = GetLengthSid(pOwnerSid);

	m_pOwner = (PSID) malloc(dwSize);
	if (m_pOwner == NULL)
		return E_OUTOFMEMORY;
	if (!CopySid(dwSize, m_pOwner, pOwnerSid))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		free(m_pOwner);
		m_pOwner = NULL;
		return hr;
	}

	ATLASSERT(IsValidSid(m_pOwner));

	if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		free(m_pOwner);
		m_pOwner = NULL;
		return hr;
	}

	return S_OK;
}

inline HRESULT CSecurityDescriptor::SetGroup(PSID pGroupSid, BOOL bDefaulted)
{
	ATLASSERT(m_pSD);

	// Mark the SD as having no Group
	if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		return hr;
	}

	if (m_pGroup)
	{
		free(m_pGroup);
		m_pGroup = NULL;
	}

	// If they asked for no Group don't do the copy
	if (pGroupSid == NULL)
		return S_OK;

	// Make a copy of the Sid for the return value
	DWORD dwSize = GetLengthSid(pGroupSid);

	m_pGroup = (PSID) malloc(dwSize);
	if (m_pGroup == NULL)
		return E_OUTOFMEMORY;
	if (!CopySid(dwSize, m_pGroup, pGroupSid))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		free(m_pGroup);
		m_pGroup = NULL;
		return hr;
	}

	ATLASSERT(IsValidSid(m_pGroup));

	if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
	{
		HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		free(m_pGroup);
		m_pGroup = NULL;
		return hr;
	}

	return S_OK;
}

inline HRESULT CSecurityDescriptor::Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

inline HRESULT CSecurityDescriptor::Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

inline HRESULT CSecurityDescriptor::Revoke(LPCTSTR pszPrincipal)
{
	HRESULT hr = RemovePrincipalFromACL(m_pDACL, pszPrincipal);
	if (SUCCEEDED(hr))
		SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE);
	return hr;
}

inline HRESULT CSecurityDescriptor::GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid)
{
	BOOL bRes;
	HRESULT hr;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
	if (!bRes)
	{
		// Couldn't open process token
		hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		return hr;
	}
	hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
	CloseHandle(hToken);
	return hr;
}

inline HRESULT CSecurityDescriptor::GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid, BOOL bOpenAsSelf)
{
	BOOL bRes;
	HRESULT hr;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken);
	if (!bRes)
	{
		// Couldn't open thread token
		hr = HRESULT_FROM_WIN32(GetLastError());
		return hr;
	}
	hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
	CloseHandle(hToken);
	return hr;
}

inline HRESULT CSecurityDescriptor::GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid)
{
	DWORD dwSize;
	HRESULT hr;
	PTOKEN_USER ptkUser = NULL;
	PTOKEN_PRIMARY_GROUP ptkGroup = NULL;

	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;

	if (ppUserSid)
	{
		// Get length required for TokenUser by specifying buffer length of 0
		GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
		hr = GetLastError();
		if (hr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			ATLASSERT(FALSE);
			hr = HRESULT_FROM_WIN32(hr);
			goto failed;
		}

		ptkUser = (TOKEN_USER*) malloc(dwSize);
		if (ptkUser == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			ATLASSERT(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkUser->User.Sid);

		PSID pSid;
		pSid = (PSID) malloc(dwSize);
		if (pSid == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			ATLASSERT(FALSE);
			goto failed;
		}

		ATLASSERT(IsValidSid(pSid));
		*ppUserSid = pSid;
		free(ptkUser);
	}
	if (ppGroupSid)
	{
		// Get length required for TokenPrimaryGroup by specifying buffer length of 0
		GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
		hr = GetLastError();
		if (hr != ERROR_INSUFFICIENT_BUFFER)
		{
			// Expected ERROR_INSUFFICIENT_BUFFER
			ATLASSERT(FALSE);
			hr = HRESULT_FROM_WIN32(hr);
			goto failed;
		}

		ptkGroup = (TOKEN_PRIMARY_GROUP*) malloc(dwSize);
		if (ptkGroup == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		// Get Sid of process token.
		if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
		{
			// Couldn't get user info
			hr = HRESULT_FROM_WIN32(GetLastError());
			ATLASSERT(FALSE);
			goto failed;
		}

		// Make a copy of the Sid for the return value
		dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

		PSID pSid;
		pSid = (PSID) malloc(dwSize);
		if (pSid == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto failed;
		}
		if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			ATLASSERT(FALSE);
			goto failed;
		}

		ATLASSERT(IsValidSid(pSid));

		*ppGroupSid = pSid;
		free(ptkGroup);
	}

	return S_OK;

failed:
	if (ptkUser)
		free(ptkUser);
	if (ptkGroup)
		free (ptkGroup);
	return hr;
}


inline HRESULT CSecurityDescriptor::GetCurrentUserSID(PSID *ppSid)
{
	HANDLE tkHandle;

	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tkHandle))
	{
		TOKEN_USER *tkUser;
		DWORD tkSize;
		DWORD sidLength;

		// Call to get size information for alloc
		GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize);
		tkUser = (TOKEN_USER *) malloc(tkSize);
		if (tkUser == NULL)
			return E_OUTOFMEMORY;

		// Now make the real call
		if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
		{
			sidLength = GetLengthSid(tkUser->User.Sid);
			*ppSid = (PSID) malloc(sidLength);
			if (*ppSid == NULL)
				return E_OUTOFMEMORY;

			memcpy(*ppSid, tkUser->User.Sid, sidLength);
			CloseHandle(tkHandle);

			free(tkUser);
			return S_OK;
		}
		else
		{
			free(tkUser);
			return HRESULT_FROM_WIN32(GetLastError());
		}
	}
	return HRESULT_FROM_WIN32(GetLastError());
}


inline HRESULT CSecurityDescriptor::GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid)
{
	HRESULT hr;
	LPTSTR pszRefDomain = NULL;
	DWORD dwDomainSize = 0;
	DWORD dwSidSize = 0;
	SID_NAME_USE snu;

	// Call to get size info for alloc
	LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu);

	hr = GetLastError();
	if (hr != ERROR_INSUFFICIENT_BUFFER)
		return HRESULT_FROM_WIN32(hr);

	ATLTRY(pszRefDomain = new TCHAR[dwDomainSize]);
	if (pszRefDomain == NULL)
		return E_OUTOFMEMORY;

	*ppSid = (PSID) malloc(dwSidSize);
	if (*ppSid != NULL)
	{
		if (!LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu))
		{
			free(*ppSid);
			*ppSid = NULL;
			delete[] pszRefDomain;
			return HRESULT_FROM_WIN32(GetLastError());
		}
		delete[] pszRefDomain;
		return S_OK;
	}
	delete[] pszRefDomain;
	return E_OUTOFMEMORY;
}


inline HRESULT CSecurityDescriptor::Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD)
{
	PACL    pDACL = NULL;
	PACL    pSACL = NULL;
	BOOL    bDACLPresent, bSACLPresent;
	BOOL    bDefaulted;
	PACL    m_pDACL = NULL;
	ACCESS_ALLOWED_ACE* pACE;
	HRESULT hr;
	PSID    pUserSid;
	PSID    pGroupSid;

	hr = Initialize();
	if(FAILED(hr))
		return hr;

	// get the existing DACL.
	if (!GetSecurityDescriptorDacl(pSelfRelativeSD, &bDACLPresent, &pDACL, &bDefaulted))
		goto failed;

	if (bDACLPresent)
	{
		if (pDACL)
		{
			// allocate new DACL.
			m_pDACL = (PACL) malloc(pDACL->AclSize);
			if (m_pDACL == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto failedMemory;
			}

			// initialize the DACL
			if (!InitializeAcl(m_pDACL, pDACL->AclSize, ACL_REVISION))
				goto failed;

			// copy the ACES
			for (int i = 0; i < pDACL->AceCount; i++)
			{
				if (!GetAce(pDACL, i, (void **)&pACE))
					goto failed;

				if (!AddAccessAllowedAce(m_pDACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
					goto failed;
			}

			if (!IsValidAcl(m_pDACL))
				goto failed;
		}

		// set the DACL
		if (!SetSecurityDescriptorDacl(m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, bDefaulted))
			goto failed;
	}

	// get the existing SACL.
	if (!GetSecurityDescriptorSacl(pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted))
		goto failed;

	if (bSACLPresent)
	{
		if (pSACL)
		{
			// allocate new SACL.
			m_pSACL = (PACL) malloc(pSACL->AclSize);
			if (m_pSACL == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto failedMemory;
			}

			// initialize the SACL
			if (!InitializeAcl(m_pSACL, pSACL->AclSize, ACL_REVISION))
				goto failed;

			// copy the ACES
			for (int i = 0; i < pSACL->AceCount; i++)
			{
				if (!GetAce(pSACL, i, (void **)&pACE))
					goto failed;

				if (!AddAccessAllowedAce(m_pSACL, ACL_REVISION, pACE->Mask, (PSID)&(pACE->SidStart)))
					goto failed;
			}

			if (!IsValidAcl(m_pSACL))
				goto failed;
		}

		// set the SACL
		if (!SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, bDefaulted))
			goto failed;
	}

	if (!GetSecurityDescriptorOwner(m_pSD, &pUserSid, &bDefaulted))
		goto failed;

	if (FAILED(SetOwner(pUserSid, bDefaulted)))
		goto failed;

	if (!GetSecurityDescriptorGroup(m_pSD, &pGroupSid, &bDefaulted))
		goto failed;

	if (FAILED(SetGroup(pGroupSid, bDefaulted)))
		goto failed;

	if (!IsValidSecurityDescriptor(m_pSD))
		goto failed;

	return hr;

failed:
	hr = HRESULT_FROM_WIN32(hr);

failedMemory:
	if (m_pDACL)
	{
		free(m_pDACL);
		m_pDACL = NULL;
	}
	if (m_pSD)
	{
		free(m_pSD);
		m_pSD = NULL;
	}
	return hr;
}

inline HRESULT CSecurityDescriptor::AttachObject(HANDLE hObject)
{
	HRESULT hr;
	DWORD dwSize = 0;
	PSECURITY_DESCRIPTOR pSD = NULL;

	GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION, pSD, 0, &dwSize);

	hr = GetLastError();
	if (hr != ERROR_INSUFFICIENT_BUFFER)
		return HRESULT_FROM_WIN32(hr);

	pSD = (PSECURITY_DESCRIPTOR) malloc(dwSize);
	if (pSD == NULL)
		return E_OUTOFMEMORY;

	if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
		DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		free(pSD);
		return hr;
	}

	hr = Attach(pSD);
	free(pSD);
	return hr;
}


inline HRESULT CSecurityDescriptor::CopyACL(PACL pDest, PACL pSrc)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	LPVOID pAce;
	ACE_HEADER *aceHeader;

	if (pSrc == NULL)
		return S_OK;

	if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
		return HRESULT_FROM_WIN32(GetLastError());

	// Copy all of the ACEs to the new ACL
	for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
	{
		if (!GetAce(pSrc, i, &pAce))
			return HRESULT_FROM_WIN32(GetLastError());

		aceHeader = (ACE_HEADER *) pAce;

		if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
			return HRESULT_FROM_WIN32(GetLastError());
	}

	return S_OK;
}

inline HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	DWORD returnValue;
	PSID principalSID;
	PACL oldACL, newACL = NULL;

	oldACL = *ppAcl;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL)
		GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

	ATLTRY(newACL = (PACL) new BYTE[aclSize]);
	if (newACL == NULL)
		return E_OUTOFMEMORY;

	if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	returnValue = CopyACL(newACL, oldACL);
	if (FAILED(returnValue))
	{
		free(principalSID);
		return returnValue;
	}

	*ppAcl = newACL;

	if (oldACL != NULL)
		free(oldACL);
	free(principalSID);
	return S_OK;
}


inline HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	DWORD returnValue;
	PSID principalSID;
	PACL oldACL, newACL = NULL;

	oldACL = *ppAcl;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL)
		GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(principalSID) - sizeof(DWORD);

	ATLTRY(newACL = (PACL) new BYTE[aclSize]);
	if (newACL == NULL)
		return E_OUTOFMEMORY;

	if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	returnValue = CopyACL(newACL, oldACL);
	if (FAILED(returnValue))
	{
		free(principalSID);
		return returnValue;
	}

	if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
	{
		free(principalSID);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	*ppAcl = newACL;

	if (oldACL != NULL)
		free(oldACL);
	free(principalSID);
	return S_OK;
}


inline HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, LPCTSTR pszPrincipal)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	ULONG i;
	LPVOID ace;
	ACCESS_ALLOWED_ACE *accessAllowedAce;
	ACCESS_DENIED_ACE *accessDeniedAce;
	SYSTEM_AUDIT_ACE *systemAuditAce;
	PSID principalSID;
	DWORD returnValue;
	ACE_HEADER *aceHeader;

	returnValue = GetPrincipalSID(pszPrincipal, &principalSID);
	if (FAILED(returnValue))
		return returnValue;

	GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);

	for (i = 0; i < aclSizeInfo.AceCount; i++)
	{
		if (!GetAce(pAcl, i, &ace))
		{
			free(principalSID);
			return HRESULT_FROM_WIN32(GetLastError());
		}

		aceHeader = (ACE_HEADER *) ace;

		if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
		{
			accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &accessAllowedAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		} else

		if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
		{
			accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &accessDeniedAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		} else

		if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
		{
			systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

			if (EqualSid(principalSID, (PSID) &systemAuditAce->SidStart))
			{
				DeleteAce(pAcl, i);
				free(principalSID);
				return S_OK;
			}
		}
	}
	free(principalSID);
	return S_OK;
}


inline HRESULT CSecurityDescriptor::SetPrivilege(LPCTSTR privilege, BOOL bEnable, HANDLE hToken)
{
	HRESULT hr;
	TOKEN_PRIVILEGES tpPrevious;
	TOKEN_PRIVILEGES tp;
	DWORD  cbPrevious = sizeof(TOKEN_PRIVILEGES);
	LUID   luid;
	HANDLE hTokenUsed;

	// if no token specified open process token
	if (hToken == 0)
	{
		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hTokenUsed))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			ATLASSERT(FALSE);
			return hr;
		}
	}
	else
		hTokenUsed = hToken;

	if (!LookupPrivilegeValue(NULL, privilege, &luid ))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		if (hToken == 0)
			CloseHandle(hTokenUsed);
		return hr;
	}

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = 0;

	if (!AdjustTokenPrivileges(hTokenUsed, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		if (hToken == 0)
			CloseHandle(hTokenUsed);
		return hr;
	}

	tpPrevious.PrivilegeCount = 1;
	tpPrevious.Privileges[0].Luid = luid;

	if (bEnable)
		tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
	else
		tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);

	if (!AdjustTokenPrivileges(hTokenUsed, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		ATLASSERT(FALSE);
		if (hToken == 0)
			CloseHandle(hTokenUsed);
		return hr;
	}
	return S_OK;
}

#endif	__ATLCOM_H__
#endif	__WMI_SECURITY_DESCRIPTOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\wmi_security.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_security.h
//
//	Abstract:
//
//					security wrapper
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_SECURITY_H__
#define	__WMI_SECURITY_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// security descriptor
#ifndef	__WMI_SECURITY_DESCRIPTOR_H__
#include "WMI_security_descriptor.h"
#endif	__WMI_SECURITY_DESCRIPTOR_H__

#include <Aclapi.h>
#include <Accctrl.h>

class WmiSecurity
{
	DECLARE_NO_COPY ( WmiSecurity );

	public:

	// variables
	CSecurityDescriptor m_sd;

	PSID	m_psidAdmin;
	PACL	m_pAcl;

	// construction
	WmiSecurity ():
		m_psidAdmin ( NULL ),
		m_pAcl ( NULL )
	{
		BOOL bInit = FALSE;

		try
		{
			if SUCCEEDED ( Initialize () )
			{
				// obtain sid's
				if SUCCEEDED ( InitializeAdmin() )
				{
					// DACL :))
					EXPLICIT_ACCESS ea;

					// Initialize an EXPLICIT_ACCESS structure for an ACE.
					// The ACE will allow the Administrators group full access to the key.

					ea.grfAccessPermissions	= 0x1F01FF;
					ea.grfAccessMode		= SET_ACCESS;
					ea.grfInheritance		= NO_INHERITANCE;

					ea.Trustee.pMultipleTrustee			= NULL;
					ea.Trustee.MultipleTrusteeOperation	= NO_MULTIPLE_TRUSTEE;

					ea.Trustee.TrusteeForm	= TRUSTEE_IS_SID;
					ea.Trustee.TrusteeType	= TRUSTEE_IS_GROUP;
					ea.Trustee.ptstrName	= (LPTSTR) m_psidAdmin;

					if ( ERROR_SUCCESS == ::SetEntriesInAcl(1, &ea, NULL, &m_pAcl) )
					{
						if ( ::SetSecurityDescriptorDacl(m_sd, TRUE, m_pAcl, FALSE) )
						{
							bInit = TRUE;
						}
					}

				}
			}
		}
		catch ( ... )
		{
		}

		if ( !bInit )
		{
			if ( m_sd.m_pSD )
			{
				delete m_sd.m_pSD;
				m_sd.m_pSD = NULL;
			}

			if ( m_pAcl )
			{
				::LocalFree ( m_pAcl );
				m_pAcl = NULL;
			}
		}
	}

	// destruction
	~WmiSecurity ()
	{
		if ( m_psidAdmin )
		{
			::FreeSid ( m_psidAdmin );
		}

		if ( m_pAcl )
		{
			::LocalFree ( m_pAcl );
		}
	}

	// operator
	operator PSECURITY_DESCRIPTOR() const
	{
		return m_sd.m_pSD;
	}

	PSECURITY_DESCRIPTOR Get() const
	{
		return m_sd.m_pSD;
	}

	PSID	GetAdminSID()
	{
		return m_psidAdmin;
	}

	private:

	HRESULT	InitializeAdmin( )
	{
		SID_IDENTIFIER_AUTHORITY	sia	= SECURITY_NT_AUTHORITY;
		HRESULT						hr	= S_OK;

		if ( ! ::AllocateAndInitializeSid (	&sia, 2, 
											SECURITY_BUILTIN_DOMAIN_RID,
											DOMAIN_ALIAS_RID_ADMINS,
											0,
											0, 0, 0, 0, 0, &m_psidAdmin )
		   )
		{
			hr = HRESULT_FROM_WIN32 ( ::GetLastError () );

			if ( m_psidAdmin )
			{
				::FreeSid ( m_psidAdmin );
				m_psidAdmin = NULL;
			}
		}

		return hr;
	}


	// initialize for everyone
	HRESULT Initialize ( )
	{
		return m_sd.Initialize();
	}
};

#endif	__WMI_SECURITY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__common_log.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__Common_Log.h
//
//	Abstract:
//
//					logging of events into file
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// smart pointers ///////////////////////////////////

#ifndef	__LOG__
#define	__LOG__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// need smart
#ifndef	__SMART_POINTERS__
#include "__Common_SmartPTR.h"
#endif	__SMART_POINTERS__

class __Log
{
	__Log ( __Log& )					{};
	__Log& operator= ( const __Log& )	{};

	__SmartHANDLE	m_hFile;

	public:

	__Log ( LPWSTR lpwszName )
	{
		if ( lpwszName )
		{
			m_hFile = ::CreateFileW	(	lpwszName,
										GENERIC_WRITE,
										FILE_SHARE_READ,
										NULL,
										CREATE_ALWAYS,
										FILE_ATTRIBUTE_NORMAL | SECURITY_ANONYMOUS,
										NULL
									);
		}
	}

	virtual ~__Log ()
	{
	}

	DWORD	ReportEvent ( LPWSTR wszEvent )
	{
		// auto lock/unlock
		CRITICAL_SECTION cs;
		::InitializeCriticalSection ( &cs );

		try
		{
			::EnterCriticalSection ( &cs );

			if ( wszEvent && m_hFile.GetHANDLE() && m_hFile.GetHANDLE() != INVALID_HANDLE_VALUE )
			{
				USES_CONVERSION;

				DWORD written = 0;

				try
				{
					::WriteFile (	m_hFile,
									W2A ( wszEvent ),
									( lstrlenW ( wszEvent ) + 1 ) * sizeof ( char ),
									&written,
									NULL
								);
				}
				catch ( ... )
				{
				}

				::LeaveCriticalSection ( &cs );
				::DeleteCriticalSection ( &cs );

				return static_cast< DWORD > ( HRESULT_TO_WIN32 ( S_OK ) );
			}
		}
		catch ( ... )
		{
		}

		::DeleteCriticalSection ( &cs );
		return static_cast< DWORD > ( HRESULT_TO_WIN32 ( E_UNEXPECTED ) );
	}
};

#endif	__LOG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__common_convert.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__Common_Convert.h
//
//	Abstract:
//
//					convertion routines used anywhere
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// CommonConvert ///////////////////////////////////

#ifndef	__COMMON_CONVERT__
#define	__COMMON_CONVERT__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

//////////////////////////////////////////////////////////////////////////////////////////////
// class for string operations
//////////////////////////////////////////////////////////////////////////////////////////////

class __String
{
	__String ( __String& )					{}
	__String& operator= ( const __String& )	{}

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	__String ()
	{
	}

	~__String ()
	{
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// functions
	//////////////////////////////////////////////////////////////////////////////////////////

	static void SetStringCopy ( LPWSTR& wszDest, LPCWSTR& wsz )
	{
		___ASSERT( wszDest == NULL );

		if ( wsz )
		{
			try
			{
				if ( ( wszDest = new WCHAR[ (lstrlenW ( wsz ) + 1) ] ) != NULL )
				{
					lstrcpyW ( wszDest, wsz );
				}
			}
			catch ( ... )
			{
				if ( wszDest )
				{
					delete wszDest;
					wszDest = NULL;
				}
			}
		}
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for string release
//////////////////////////////////////////////////////////////////////////////////////////////

class __Release
{
	__Release ( __Release& )					{}
	__Release& operator= ( const __Release& )	{}

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	__Release ()
	{
	}

	~__Release ()
	{
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// functions
	//////////////////////////////////////////////////////////////////////////////////////////

	static HRESULT Release ( void** ppsz )
	{
		if ( ppsz && (*ppsz) )
		{
			delete [] (*ppsz);
			(*ppsz) = NULL;

			return S_OK;
		}

		return S_FALSE;
	}

	static HRESULT Release ( void*** ppsz, DWORD* dwsz )
	{
		if ( ppsz && (*ppsz) )
		{
			if ( dwsz )
			{
				for ( DWORD dwIndex = 0; dwIndex < (*dwsz); dwIndex++ )
				{
					delete (*ppsz)[dwIndex];
					(*ppsz)[dwIndex] = NULL;
				}

				(*dwsz) = NULL;
			}

			delete [] (*ppsz);
			(*ppsz) = NULL;

			return S_OK;
		}

		return S_FALSE;
	}

	static HRESULT Release ( SAFEARRAY* psa )
	{
		if ( psa )
		{
			::SafeArrayDestroy ( psa );
			psa = NULL;

			return S_OK;
		}

		return S_FALSE;
	}

};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for string converion handling
//////////////////////////////////////////////////////////////////////////////////////////////

class __StringConvert
{
	__StringConvert ( __StringConvert& )					{}
	__StringConvert& operator= ( const __StringConvert& )	{}

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	__StringConvert ()
	{
	}

	~__StringConvert ()
	{
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// functions
	//////////////////////////////////////////////////////////////////////////////////////////

	// SAFEARRAY (BSTR) -> LPWSTR*
	inline static HRESULT ConvertSafeArrayToLPWSTRArray ( SAFEARRAY * psa, LPWSTR** pppsz, DWORD* pdwsz )
	{
		HRESULT hr = S_OK;

		if ( ! psa )
		return E_INVALIDARG;

		if ( ! pppsz || ! pdwsz )
		return E_POINTER;

		(*pppsz)	= NULL;
		(*pdwsz)	= NULL;

		// allocate enough memory
		try
		{
			long u = 0;
			long l = 0;

			hr = ::SafeArrayGetUBound( psa, 1, &u );
			hr = ::SafeArrayGetLBound( psa, 1, &l );

			(*pdwsz) = u-l + 1;

			if ( (*pdwsz) )
			{
				if ( ( (*pppsz) = (LPWSTR*) new LPWSTR[ (*pdwsz) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				// clear everything
				for ( LONG lIndex = 0; lIndex < (LONG) (*pdwsz); lIndex++ )
				{
					(*pppsz)[lIndex] = NULL;
				}

				BSTR * pbstr;

				if SUCCEEDED( hr = ::SafeArrayAccessData ( psa, (void**) &pbstr ) )
				{
					for ( LONG lIndex = 0; lIndex < (LONG) (*pdwsz); lIndex++ )
					{
						if ( ( (*pppsz)[lIndex] = (LPWSTR) new WCHAR[ (::SysStringLen(pbstr[lIndex]) + 1) ] ) == NULL )
						{
							return E_OUTOFMEMORY;
						}

						lstrcpyW ( (*pppsz)[lIndex], pbstr[lIndex] );
					}
				}
				else
				return hr;

				::SafeArrayUnaccessData ( psa );
			}
			else
			return E_FAIL;
		}
		catch ( ... )
		{
			__Release::Release ( (void***)pppsz, pdwsz );
			return E_UNEXPECTED;
		}

		return S_OK;
	}

	// LPWSTR* -> SAFEARRAY ( BSTR )
	inline static HRESULT ConvertLPWSTRArrayToSafeArray (  LPWSTR* ppsz, DWORD dwsz ,SAFEARRAY ** ppsa )
	{
		if ( ! ppsz )
		return E_INVALIDARG;

		if ( ! ppsa )
		return E_POINTER;

		(*ppsa)	= NULL;

		try
		{
			SAFEARRAYBOUND rgsabound[1];
			rgsabound[0].lLbound	= 0;
			rgsabound[0].cElements	= dwsz;

			if ( ( (*ppsa) = ::SafeArrayCreate ( VT_BSTR, 1, rgsabound ) ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			for ( DWORD dwIndex = 0; dwIndex < dwsz; dwIndex++ )
			{
				BSTR bstr = NULL;
				bstr = ::SysAllocString( ppsz[ dwIndex ] );

				if ( bstr )
				{
					::SafeArrayPutElement ( (*ppsa), (LONG*) &dwIndex, &bstr );
					::SysFreeString ( bstr );
				}
			}
		}
		catch ( ... )
		{
			__Release::Release ( (*ppsa) );
			return E_UNEXPECTED;
		}

		return S_OK;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// macros
//////////////////////////////////////////////////////////////////////////////////////////////

#define	RELEASE_ARRAY( ppwsz )\
__Release::Release( ( void** ) &ppwsz )

#define	RELEASE_DOUBLEARRAY( ppwsz, dwsz )\
__Release::Release( ( void*** ) &ppwsz, &dwsz )

#define	RELEASE_SAFEARRAY( psa )\
__Release::Release( psa )

#define	SAFEARRAY_TO_LPWSTRARRAY( psa, pppsz, pdwsz )\
__StringConvert::ConvertSafeArrayToLPWSTRArray( psa, pppsz, pdwsz )

#define	LPWSTRARRAY_TO_SAFEARRAY( ppsz, dwsz, ppsa )\
__StringConvert::ConvertLPWSTRArrayToSafeArray( ppsz, dwsz, ppsa )


// HRESULT -> WIN32
#define HRESULT_TO_WIN32(hres) ((HRESULT_FACILITY(hres) == FACILITY_WIN32) ? HRESULT_CODE(hres) : (hres))

#endif	__COMMON_CONVERT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__common_smartptr.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__Common_SmartPTR.h
//
//	Abstract:
//
//					smart pointers, handles, cs, ...
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// smart pointers ///////////////////////////////////

#ifndef	__SMART_POINTERS__
#define	__SMART_POINTERS__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// need common
#ifndef	__COMMON_CONVERT__
#include "__Common_Convert.h"
#endif	__COMMON_CONVERT__

// need assert macro
#ifndef	__ASSERT_VERIFY__
#include "__macro_assert.h"
#endif	__ASSERT_VERIFY__

//////////////////////////////////////////////////////////////////////////////////////////////
// class for smart CRITICAL SECTION
//////////////////////////////////////////////////////////////////////////////////////////////

class __Smart_CRITICAL_SECTION
{
	__Smart_CRITICAL_SECTION  ( __Smart_CRITICAL_SECTION& )					{};
	__Smart_CRITICAL_SECTION& operator= ( const __Smart_CRITICAL_SECTION& )	{};

	CRITICAL_SECTION*	m_cs;

	public:

	// construction
	__Smart_CRITICAL_SECTION( const LPCRITICAL_SECTION cs ) :
	m_cs ( NULL )
	{
		try
		{
			if ( ( m_cs = cs ) != NULL )
			{
				::EnterCriticalSection ( m_cs );

				ATLTRACE (	L"\n=============================================================\n"
							L" smart CS entered %x \n"
							L"=============================================================\n",
							::GetCurrentThreadId()
						 );
			}
		}
		catch ( ... )
		{
			m_cs = NULL;
		}
	}

	// destruction
	~__Smart_CRITICAL_SECTION ( )
	{
		if ( m_cs )
		{
			::LeaveCriticalSection ( m_cs );

			ATLTRACE (	L"\n=============================================================\n"
						L" smart CS leaved  %x \n"
						L"=============================================================\n",
						::GetCurrentThreadId()
					 );
		}

		m_cs = NULL;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for smart HANDLE
//////////////////////////////////////////////////////////////////////////////////////////////

class __SmartHANDLE;
class __SmartServiceHANDLE;

template < class CLASS >
class __HANDLE
{
	__HANDLE	( __HANDLE& )					{}
	__HANDLE&	operator= ( const __HANDLE& h )
	{
		___ASSERT ( m_handle == NULL );
		m_handle = h.GetHANDLE();

		return (*this);
	}

	friend class __SmartHANDLE;
	friend class __SmartServiceHANDLE;

	CLASS m_handle;

	public:

	__HANDLE() : m_handle ( NULL )
	{
	}

	virtual ~__HANDLE()
	{
		m_handle = NULL;
	}

	// operators

	operator CLASS() const
	{
		return m_handle;
	}

	CLASS& operator = ( const CLASS& handle )
	{
		___ASSERT ( m_handle == NULL );
		m_handle = handle;
	}

	// accessors

	void SetHANDLE ( CLASS handle )
	{
		___ASSERT ( m_handle == NULL );
		m_handle = handle;
	}

	CLASS GetHANDLE ( ) const
	{
		return m_handle;
	}

	// functions
	void CloseHandle ()
	{
		if ( m_handle )
		{
			::CloseHandle ( m_handle );
			m_handle = NULL;
		}
	}

	void Attach ( CLASS handle )
	{
		m_handle = handle;
	}

	CLASS Detach()
	{
		CLASS handle = NULL;

		handle = m_handle;
		m_handle = NULL;

		return handle;
	}
};

class __SmartHANDLE : public __HANDLE < HANDLE >
{
	__SmartHANDLE	( __SmartHANDLE& )					{}
	__SmartHANDLE&	operator= ( const __SmartHANDLE& )	{}

	public:

	__SmartHANDLE ( ) : __HANDLE < HANDLE > ( )
	{
	}

	__SmartHANDLE ( HANDLE handle ) : __HANDLE < HANDLE > ( )
	{
		m_handle = handle;
	}

	virtual ~__SmartHANDLE ()
	{
		if ( m_handle )
		{
			::CloseHandle ( m_handle );
		}
	}

	__SmartHANDLE& operator = ( const HANDLE& handle )
	{
		___ASSERT ( m_handle == NULL );
		m_handle = handle;

		return (*this);
	}
};

class __SmartServiceHANDLE : public __HANDLE < SC_HANDLE >
{
	__SmartServiceHANDLE	( __SmartServiceHANDLE& )					{}
	__SmartServiceHANDLE&	operator= ( const __SmartServiceHANDLE& )	{}

	public:

	__SmartServiceHANDLE ( ) : __HANDLE < SC_HANDLE > ( )
	{
	}

	__SmartServiceHANDLE ( SC_HANDLE handle ) : __HANDLE < SC_HANDLE > ( )
	{
		m_handle = handle;
	}

	virtual ~__SmartServiceHANDLE ()
	{
		if ( m_handle )
		{
			::CloseServiceHandle ( m_handle );
		}
	}

	__SmartServiceHANDLE& operator = ( const SC_HANDLE& handle )
	{
		___ASSERT ( m_handle == NULL );
		m_handle = handle;

		return (*this);
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for smart pointers
//////////////////////////////////////////////////////////////////////////////////////////////

template< class TYPE > class __WrapperPtr;
template< class TYPE > class __WrapperExt;
template< class TYPE > class __WrapperARRAY;

template < class BASE >
class __Wrapper
{
	__Wrapper	( __Wrapper& )					{}
	__Wrapper&	operator= ( const __Wrapper& )	{}

	// variables

	BASE* m_p;

	friend class __WrapperPtr < BASE >;
	friend class __WrapperExt < BASE >;
	friend class __WrapperARRAY < BASE >;

	public:

	// construction & destruction

	__Wrapper ( BASE* p = NULL ) :	m_p ( NULL )
	{
		m_p = p;
	}

	virtual ~ __Wrapper()
	{
		if ( m_p )
		{
			delete m_p;
			m_p = NULL;
		}
	}

	virtual void SetData ( BASE* p)
	{
		___ASSERT ( m_p == NULL );
		m_p = p;
	}

	BOOL IsEmpty ()
	{
		return (m_p == NULL ) ? TRUE : FALSE;
	}

	// operators BOOL
	BOOL operator! () const
	{
		return ( m_p == NULL );
	}

	BOOL operator== (BASE* p) const
	{
		return ( m_p == p );
	}

	// operators CASTING

	operator BASE*() const
	{
		return (BASE*)m_p;
	}
	BASE& operator*() const
	{
		return *m_p;
	}

	BASE** operator&()
	{
		___ASSERT ( m_p == NULL );
		return &m_p;
	}

	// pointer operations
	BASE* Detach()
	{
		BASE* p = m_p;
		m_p = NULL;

		return p;
	}

	void Attach ( BASE* p )
	{
		___ASSERT ( m_p == NULL );
		m_p = p;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for exposing -> operator
//////////////////////////////////////////////////////////////////////////////////////////////

template < class BASE >
class __WrapperPtr : public __Wrapper< BASE > 
{
	__WrapperPtr	( __WrapperPtr& )					{}
	__WrapperPtr&	operator= ( const __WrapperPtr& )	{}

	public:

	// construction & destruction

	__WrapperPtr ( BASE* p = NULL ) :	__Wrapper< BASE > ( p )
	{
	}

	BASE* operator->() const
	{
		return m_p;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class changig inner variable
//////////////////////////////////////////////////////////////////////////////////////////////

template < class BASE >
class __WrapperExt : public __Wrapper< BASE > 
{
	__WrapperExt	( __WrapperExt& )					{}
	__WrapperExt&	operator= ( const __WrapperExt& )	{}

	public:

	// construction & destruction

	__WrapperExt ( BASE* p = NULL ) :	__Wrapper< BASE > ( p )
	{
	}

	BASE** operator&()
	{
		return &m_p;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for wraping ARRAY
//////////////////////////////////////////////////////////////////////////////////////////////

template < class BASE >
class __WrapperARRAY : public __Wrapper<BASE>
{
	DWORD	m_dw;

	__WrapperARRAY  ( __WrapperARRAY & )
	{
	}

	__WrapperARRAY & operator= ( const __WrapperARRAY & )
	{
	}

	public:

	// construction & destruction
	__WrapperARRAY () : m_dw ( NULL )
	{
	}

	__WrapperARRAY ( BASE* p, DWORD dw ) : __Wrapper<BASE>( p ) ,
	m_dw ( NULL )
	{
		m_dw= dw;
	}

	virtual ~__WrapperARRAY ()
	{
		if ( m_p )
		{
			for ( DWORD dwIndex = 0; dwIndex < m_dw; dwIndex++ )
			{
				delete m_p[dwIndex];
				m_p[dwIndex] = NULL;
			}

			delete [] m_p;
		}

		m_p = NULL;
		m_dw = NULL;
	}

	// accessors
	void SetAt ( DWORD dwIndex, BASE data = NULL )
	{
		___ASSERT ( m_p );
		m_p[dwIndex] = data;
	}

	BASE&	GetAt ( DWORD dwIndex ) const
	{
		___ASSERT ( m_p );
		return m_p[dwIndex];
	}

	// adding data
	HRESULT DataAdd ( BASE item )
	{
		BASE* p = NULL;

		try
		{
			if ( ( p = new BASE[m_dw + 1] ) == NULL )
			{
				return E_OUTOFMEMORY;
			}

			if ( p )
			{
				if ( m_p )
				{
					for ( DWORD dw = 0; dw < m_dw; dw++ )
					{
						p[dw] = m_p[dw];
					}

					p[dw] = item;

					delete [] m_p;
					m_p = NULL;
				}
				else
				{
					p[m_dw] = item;
				}

				m_p = p;
				m_dw++;
			}
		}
		catch ( ... )
		{
			if ( p )
			{
				delete [] p;
				p = NULL;
			}

			return E_FAIL;
		}

		return S_OK;
	}

	// delete by index
	HRESULT DataDelete ( DWORD dwIndex )
	{
		if ( dwIndex < m_dw )
		{
			try
			{
				delete m_p[dwIndex];
			}
			catch ( ... )
			{
			}

			for ( DWORD dw = dwIndex; dw < m_dw - 1; dw++ )
			{
				m_p[dw] = m_p[dw+1];
			}

			m_dw--;
			return S_OK;
		}

		return E_INVALIDARG;
	}

	// delete by value
	HRESULT DataDelete ( BASE data )
	{
		if ( date )
		{
			for ( DWORD dw = 0; dw < m_dw; dw++ )
			{
				if ( m_p[dw] == data )
				{
					return DataDelete ( dw );
				}
			}

			return S_OK;
		}

		return S_FALSE;
	}

	// helpers
	void SetData ( BASE* p, DWORD dw )
	{
		if ( p )
		{
			__Wrapper<BASE>::SetData ( p );
		}

		m_dw = dw;
	}

	// aditional operators

	operator DWORD() const	// for return size of array
	{
		return m_dw;
	}

	operator DWORD*()		// for set size of array
	{
		return &m_dw;
	}

	const BASE& operator[] (DWORD dwIndex) const
	{
		return m_p[dwIndex];
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// class for wraping SAFEARRAY
//////////////////////////////////////////////////////////////////////////////////////////////

class __WrapperSAFEARRAY
{
	__WrapperSAFEARRAY ( __WrapperSAFEARRAY& )
	{
	}

	__WrapperSAFEARRAY& operator= ( const __WrapperSAFEARRAY& )
	{
	}

	SAFEARRAY * m_p;

	public:

	// constructor & destructor
	__WrapperSAFEARRAY( ) : m_p ( NULL )
	{
	}

	__WrapperSAFEARRAY( tagSAFEARRAY* psa ) : m_p ( NULL )
	{
		m_p = psa;
	}

	~__WrapperSAFEARRAY()
	{
		RELEASE_SAFEARRAY ( m_p );
		m_p = NULL;
	}

	// operators CASTING

	operator SAFEARRAY*() const
	{
		return (SAFEARRAY*)m_p;
	}

	SAFEARRAY** operator&()
	{
		___ASSERT ( m_p == NULL );
		return &m_p;
	}
};

#endif	__SMART_POINTERS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__macro_error.h ===
//////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__MACRO_ERROR.H
//
//	Abstract:
//
//					error helpers
//
//	History:
//
//					initial		a-marius
//
//////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// common error Macros ///////////////////////////////////

#ifndef	__ERROR__
#define	__ERROR__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

///////////////////////////////////////////////////////////////////////////////////////////
// macros
///////////////////////////////////////////////////////////////////////////////////////////

#endif	__ERROR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__macro_assert.h ===
///////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_assert.h
//
//	Abstract:
//
//					assertion and verify macros and helpers
//
//	History:
//
//					initial		a-marius
//
///////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// Assert/Verify Macros ///////////////////////////////////

#ifndef	__ASSERT_VERIFY__
#define	__ASSERT_VERIFY__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// set behaviour of macros
#ifdef	_DEBUG
//#define	__SHOW_MSGBOX
//#define	__DEBUG_BREAK
#endif	_DEBUG

///////////////////////////////////////////////////////////////////////////////////////////
// macros
///////////////////////////////////////////////////////////////////////////////////////////

// call DebugBreak if in debug mode
#ifdef	_DEBUG
inline void ForceDebugBreak ( void )
{
	#ifdef	__DEBUG_BREAK
	__try
	{ 
		DebugBreak(); 
	}
	__except(UnhandledExceptionFilter(GetExceptionInformation()))
	{
	}
	#endif	__DEBUG_BREAK
}
#else	_DEBUG
#define ForceDebugBreak()
#endif	_DEBUG

// show error and throw break

#ifdef	__SHOW_MSGBOX
#define ___FAIL(szMSG, szTitle)\
(\
	MessageBoxW(GetActiveWindow(), (szMSG) ? szMSG : L"", (szTitle) ? szTitle : L"", MB_OK | MB_ICONERROR),\
	ForceDebugBreak()\
)
#else	__SHOW_MSGBOX
#define ___FAIL(szMSG, szTitle)\
(\
	ForceDebugBreak()\
)
#endif	__SHOW_MSGBOX

// Put up an assertion failure
#define ___ASSERTFAIL(file,line,expr,title)\
{\
	WCHAR sz[256] = { L'\0' };\
	wsprintfW(sz, L"File %hs, line %d : %hs", file, line, expr);\
	___FAIL(sz, title);\
}

// Assert in debug builds, but don't remove the code in retail builds.

#ifdef	_DEBUG
#define ___ASSERT(x) if (!(x)) ___ASSERTFAIL(__FILE__, __LINE__, #x, L"Assert Failed")
#else	_DEBUG
#define ___ASSERT(x)
#endif	_DEBUG

#ifdef	_DEBUG
#define ___ASSERT_DESC(x, desc) if (!(x)) ___ASSERTFAIL(__FILE__, __LINE__, #desc, L"Assert Failed")
#else	_DEBUG
#define ___ASSERT_DESC(x, desc)
#endif	_DEBUG

#ifdef	_DEBUG
#define	___VERIFY(x) ___ASSERT(x)
#else	_DEBUG
#define	___VERIFY(x) (x)
#endif	_DEBUG

#endif	__ASSERT_VERIFY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__macro_behaviour.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_behaviour.h
//
//	Abstract:
//
//					behaviour of application
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////// Behaviour /////////////////////////////////////

#ifndef	__BEHAVIOUR__
#define	__BEHAVIOUR__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#endif	__BEHAVIOUR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__macro_nocopy.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_nocopy.h
//
//	Abstract:
//
//					dissallow creation of copy of instantied object
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////


#ifndef	__NO_COPY_H__
#define	__NO_COPY_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#define DECLARE_NO_COPY( T ) \
private:\
	T(const T&);\
	T& operator=(const T&);

#endif	__NO_COPY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__macro_loadstring.h ===
///////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_loadstring.h
//
//	Abstract:
//
//					load string from resources helper
//
//	History:
//
//					initial		a-marius
//
///////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// Resource Strings ///////////////////////////////////

#ifndef	__RESOURCE_STR__
#define	__RESOURCE_STR__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// inline helper
inline LPWSTR LoadStringHelper ( LPWSTR sz, LPWSTR szSource )
{
	if ( sz )
	{
		lstrcpyW ( sz, szSource );
	}

	delete ( szSource );
	return sz;
}

inline LPWSTR LoadStringSystem ( HINSTANCE hInst, UINT nID )
{
	WCHAR sz[_MAX_PATH] = { L'\0' };
	DWORD lenght = 0;

	if ( ( lenght = ::LoadStringW ( hInst, nID, sz, _MAX_PATH ) ) != 0 )
	{
		LPWSTR psz = NULL;

		if ( ( psz = reinterpret_cast<LPWSTR>( new WCHAR [ lenght + 1 ] ) ) != NULL )
		{
			lstrcpyW ( psz, sz );
		}

		return psz;
	}

	return NULL;
}

// macro
#ifndef	___LOADSTRING

#define	___LOADSTRINGDATA LPWSTR psz = NULL; DWORD dwSize = NULL;
#define	___LOADSTRING( hInst, nID ) \
( \
	( \
		( ! hInst ) ? NULL : \
		( \
			psz  = LoadStringSystem ( hInst, nID ), \
			size = ( \
						( ( ! psz ) ? NULL : ( ( lstrlenW ( psz ) + 1 ) ) * sizeof ( WCHAR ) ) \
				   ), \
\
			LoadStringHelper ( ( LPWSTR ) alloca ( size ), psz ) \
		) \
	) \
)

#endif	___LOADSTRING

#endif	__RESOURCE_STR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__macro_eventlog.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_eventlog.h
//
//	Abstract:
//
//					event log helpers and behaviours
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// EventLog ////////////////////////////////////////

#ifndef	__EVENT_LOG__
#define	__EVENT_LOG__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000


#endif	__EVENT_LOG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__macro_err.h ===
//////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_err.h
//
//	Abstract:
//
//					error handling helpers and macros
//
//	History:
//
//					initial		a-marius
//
///////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////// error & trace Macros ///////////////////////////////////

#ifndef	__WMI_PERF_ERR__
#define	__WMI_PERF_ERR__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// need atl wrappers
#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

// need macros :)))
#ifndef	__ASSERT_VERIFY__
#include <__macro_assert.h>
#endif	__ASSERT_VERIFY__

// trace description
#ifdef	_DEBUG
#define	___TRACE( x )\
(\
	AtlTrace( _TEXT( "\n error ... %hs(%d)" ), __FILE__, __LINE__ ),\
	AtlTrace( _TEXT( "\n DESCRIPTION : %s" ), x ),\
	AtlTrace( _TEXT( "\n" ) )\
)
#else	_DEBUG
#define	___TRACE( x )
#endif	_DEBUG

#ifdef	_DEBUG
#define	___TRACE_ERROR( x,err )\
(\
	AtlTrace( _TEXT( "\n error ... %hs(%d)" ), __FILE__, __LINE__ ),\
	AtlTrace( _TEXT( "\n DESCRIPTION  : %s" ), x ),\
	AtlTrace( _TEXT( "\n ERROR NUMBER : 0x%x" ), err ),\
	AtlTrace( _TEXT( "\n" ) )\
)
#else	_DEBUG
#define	___TRACE_ERROR( x, err )
#endif	_DEBUG

inline LPWSTR	GetErrorMessageSystem ( void );
inline LPWSTR	GetErrorMessageSystem ( DWORD dwError );

inline LPWSTR	GetErrorMessageModule ( DWORD dwError, HMODULE handle = NULL );

// stack allocation
inline LPWSTR	GetErrorMessage ( LPWSTR sz, LPWSTR szSource )
{
	if ( sz && szSource )
	{
		lstrcpyW ( sz, szSource );

		delete ( szSource );
		szSource = NULL;

		return sz;
	}

	return NULL;
}

inline LPWSTR	GetErrorMessage ( LPWSTR sz, DWORD err )
{
	wsprintfW ( sz, L"unspecified error : 0x%x", err );
	return sz;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// macros
//////////////////////////////////////////////////////////////////////////////////////////////
#pragma warning( disable : 4003 )

#ifdef	_DEBUG
#define	ERRORMESSAGE_DEFINITION	LPWSTR szErrorMessage = NULL;
#else	! _DEBUG
#define	ERRORMESSAGE_DEFINITION
#endif	_DEBUG

#ifdef	_DEBUG

// system
#define ERRORMESSAGE(dwError)\
szErrorMessage = GetErrorMessageSystem(dwError),\
(\
	( !szErrorMessage ) ? \
	(\
		___TRACE_ERROR ( L"unresolved error was occured !", dwError ),\
		___FAIL (	GetErrorMessage	(\
										(LPWSTR) alloca ( 32 * sizeof ( WCHAR ) ),\
										dwError\
									),\
					L"Error occured"\
				)\
	)\
	:\
	(\
		___TRACE ( szErrorMessage ),\
		___FAIL (	GetErrorMessage	(\
										(LPWSTR) alloca ( ( lstrlenW ( szErrorMessage ) + 1 ) * sizeof ( WCHAR ) ),\
										szErrorMessage\
									),\
					L"Error occured"\
				)\
	)\
),\
delete [] szErrorMessage,\
szErrorMessage = NULL

// module
#define ERRORMESSAGE1(dwError, handle)\
szErrorMessage = GetErrorMessageModule(dwError, handle),\
(\
	( !szErrorMessage ) ? \
	(\
		___TRACE_ERROR ( L"unresolved error was occured !", dwError ),\
		___FAIL (	GetErrorMessage	(\
										(LPWSTR) alloca ( 32 * sizeof ( WCHAR ) ),\
										dwError\
									),\
					L"Error occured"\
				)\
	)\
	:\
	(\
		___TRACE ( szErrorMessage ),\
		___FAIL (	GetErrorMessage	(\
										(LPWSTR) alloca ( ( lstrlenW ( szErrorMessage ) + 1 ) * sizeof ( WCHAR ) ),\
										szErrorMessage\
									),\
					L"Error occured"\
				)\
	)\
),\
delete [] szErrorMessage,\
szErrorMessage = NULL


#else	!_DEBUG
#define	ERRORMESSAGE(dwError)
#define	ERRORMESSAGE1(dwError, handle)
#endif	_DEBUG

#define	ERRORMESSAGE_RETURN(dwError)\
{\
	ERRORMESSAGE( dwError );\
	return dwError;\
}

#define	ERRORMESSAGE_EXIT(dwError)\
{\
	ERRORMESSAGE( dwError );\
	return;\
}

#define	ERRORMESSAGE1_RETURN(dwError, handle)\
{\
	ERRORMESSAGE1( dwError, handle );\
	return dwError;\
}

#define	ERRORMESSAGE1_EXIT(dwError, handle)\
{\
	ERRORMESSAGE1( dwError, handle );\
	return;\
}

//////////////////////////////////////////////////////////////////////////////////////////////
// class for wrapping error handling
//////////////////////////////////////////////////////////////////////////////////////////////

class __Error
{
	__Error ( __Error& )					{}
	__Error& operator= ( const __Error& )	{}

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	__Error ()
	{
	}

	virtual ~__Error ()
	{
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// functions
	//////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////
	// Function name	: GetMessageFromError
	// Description		: returns resolved error message or NULL
	// Return type		: LPWSTR 
	// Argument			: DWORD
	// Note				: user has to free returned string

	inline static LPWSTR GetMessageFromError( DWORD dwError )
	{
		LPVOID		lpMsgBuf = NULL;
		LPWSTR		szResult = NULL;

		try
		{
			FormatMessageW(	FORMAT_MESSAGE_ALLOCATE_BUFFER | 
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_IGNORE_INSERTS,
							NULL,
							dwError,
							MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
							(LPWSTR) &lpMsgBuf,
							0,
							NULL );

			if( lpMsgBuf )
			{
				if ( ( szResult = (LPWSTR) new WCHAR[ lstrlenW ( (LPWSTR)lpMsgBuf ) + 1 ] ) != NULL )
				{
					lstrcpyW( szResult, (LPWSTR)lpMsgBuf );
				}

				LocalFree( lpMsgBuf );
			}
		}
		catch ( ... )
		{
			if ( lpMsgBuf )
			{
				LocalFree( lpMsgBuf );
			}
		}

		return szResult;
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// Function name	: GetMessageFromModule
	// Description		: returns resolved error message or NULL
	// Return type		: LPWSTR 
	// Argument			: DWORD
	// Note				: user has to free returned string

	inline static LPWSTR GetMessageFromModule( DWORD dwError, HMODULE handle = NULL )
	{
		LPVOID		lpMsgBuf = NULL;
		LPWSTR		szResult = NULL;

		try
		{
			FormatMessageW(	FORMAT_MESSAGE_ALLOCATE_BUFFER | 
							FORMAT_MESSAGE_FROM_HMODULE |
							FORMAT_MESSAGE_IGNORE_INSERTS,
							(LPCVOID)handle,
							dwError,
							MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
							(LPWSTR) &lpMsgBuf,
							0,
							NULL );

			if( lpMsgBuf )
			{
				if ( ( szResult = (LPWSTR) new WCHAR[ lstrlenW ( (LPWSTR)lpMsgBuf ) + 1 ] ) != NULL )
				{
					lstrcpyW( szResult, (LPWSTR)lpMsgBuf );
				}

				LocalFree( lpMsgBuf );
			}
		}
		catch ( ... )
		{
			if ( lpMsgBuf )
			{
				LocalFree( lpMsgBuf );
			}
		}

		return szResult;
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// Function name	: GetMessageFromErrorInfo
	// Description		: returns resolved error message or NULL
	// Return type		: LPWSTR 
	// Argument			: void
	// Note				: user has to free returned string

	inline static LPWSTR GetMessageFromErrorInfo( void )
	{
		CComPtr< IErrorInfo >	pError;
		LPWSTR					szResult = NULL;

		if ( ( ::GetErrorInfo ( NULL, &pError ) == S_OK ) && pError )
		{
			CComBSTR	bstrSource;
			CComBSTR	bstrDescription;

			pError->GetSource ( &bstrSource );
			pError->GetDescription ( &bstrDescription );

			CComBSTR	bstrResult;

			if ( bstrSource.Length() )
			{
				bstrResult	+= L" ProgID : ";
				bstrResult	+= bstrSource;
			}
			if ( bstrDescription.Length() )
			{
				bstrResult	+= L" Description : ";
				bstrResult	+= bstrDescription;
			}

			if ( bstrResult.Length() )
			{
				if ( ( szResult = (LPWSTR) new WCHAR[ bstrResult.Length() + 1 ] ) != NULL )
				{
					lstrcpyW ( szResult, bstrResult );
				}
			}
		}

		return szResult;
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////
// helpers
//////////////////////////////////////////////////////////////////////////////////////////////

inline LPWSTR	GetErrorMessageModule ( DWORD dwError, HMODULE handle )
{
	return __Error::GetMessageFromModule ( dwError, handle );
}

inline LPWSTR	GetErrorMessageSystem ( DWORD dwError )
{
	return __Error::GetMessageFromError ( dwError );
}

inline LPWSTR	GetErrorMessageSystem ( void )
{
	return __Error::GetMessageFromErrorInfo();
}

#endif	__WMI_PERF_ERR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__macro_pragma.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_pragma.h
//
//	Abstract:
//
//					pragma message helper
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////// Pragma //////////////////////////////////////

#ifndef	__PRAGMA__
#define	__PRAGMA__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// When the compiler sees a line like this:
// #pragma ___PRAGMA_MSG(Fix this later)
//
// it outputs a line like this:
// C:\Document\AdvWin\Code\Sysinfo.06\..\CmnHdr.H(296):Fix this later
//
// You can easily jump directly to this line and examine the surrounding code.

#define ___STR(x)			#x
#define ___STRING(x)		___STR(x)
#define ___PRAGMA_MSG(desc)	message(__FILE__ "(" ___STRING(__LINE__) ") : " #desc)

#endif	__PRAGMA__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter\common.inc ===
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

WMI_PERFORMANCE_INC = $(ADAPTERS)\WmiReversePerformanceMonitor\Include

WMI_PERFORMANCE_REFRESH_INC = $(ADAPTERS)\WmiReversePerformanceMonitor\WMIAdapter_Refresh
WMI_PERFORMANCE_REFRESH_LIB = $(ADAPTERS)\WmiReversePerformanceMonitor\System\$(O)\WmiApRef.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\include\__macro_unicode.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__macro_unicode.h
//
//	Abstract:
//
//					unicode definitions
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////// Unicode //////////////////////////////////////

#ifndef	__UNICODE__
#define	__UNICODE__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// If we are not compiling for an x86 CPU, we always compile using Unicode.
#ifndef	_X86_
#define UNICODE
#endif	_X86_

// To compile using Unicode on the x86 CPU
#define UNICODE

// When using Unicode Win32 functions, use Unicode C-Runtime functions too.
#ifdef	UNICODE
#define _UNICODE
#endif	UNICODE

#endif	__UNICODE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pokus.rc
//
#define IDS_PROJNAME			100

#define IDS_NAME				110
#define IDS_DESCRIPTION			111

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_messages\common.inc ===
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

WMI_PERFORMANCE_INC = ..\Include
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_messages\resource.h ===
#define IDS_cWMIOBJECTS_NAME			204
#define IDS_cWMIOBJECTS_COUNT_NAME		205
#define IDS_cWMIOBJECTS_VALIDITY_NAME	206

#define IDS_cWMIOBJECTS_HELP			207
#define IDS_cWMIOBJECTS_COUNT_HELP		208
#define IDS_cWMIOBJECTS_VALIDITY_HELP	209
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\common.inc ===
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

WMI_PERFORMANCE_INC = $(ADAPTERS)\WmiReversePerformanceMonitor\Include
WMI_PERFORMANCE_MESSAGES_INC = $(ADAPTERS)\WmiReversePerformanceMonitor\WMIAdapter_Messages
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_messages\wmiadapter_messages.cpp ===
// WMIAdapterMessages.cpp

#include "precomp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

////////////////////////////////////////////////////////////////////////////////////
// includes
////////////////////////////////////////////////////////////////////////////////////
#include "WMIAdapter_Messages.h"
#include "WMI_EventLog_Base.h"

// save instance
HMODULE g_hModule = NULL;

////////////////////////////////////////////////////////////////////////////////////
// dll main
////////////////////////////////////////////////////////////////////////////////////

BOOL APIENTRY DllMain( HANDLE hModule, DWORD  dwReason, LPVOID lpReserved )
{
    switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
		{
			if ( !lpReserved )
			{
				// loaded dynamic
			}
			else
			{
				// loaded static
			}

			// disable attach/detach of threads
			::DisableThreadLibraryCalls ( (HMODULE) hModule );

			g_hModule = ( HMODULE ) hModule;
		}
		break;

		case DLL_PROCESS_DETACH:
		{
			#ifdef	_DEBUG
			_CrtDumpMemoryLeaks();
			#endif	_DEBUG
		}
		break;

		// thread attaching is not used !!!
		case DLL_THREAD_ATTACH: break;
		case DLL_THREAD_DETACH: break;
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
// registration of message dll
////////////////////////////////////////////////////////////////////////////////////
HRESULT __stdcall  Register_Messages ( void )
{
	TCHAR szPath [ _MAX_PATH ];

	if ( ::GetModuleFileName ( g_hModule, szPath, sizeof ( TCHAR ) * ( _MAX_PATH ) ) )
	{
		CPerformanceEventLogBase::Initialize ( _T("WmiAdapter"), szPath );
		return S_OK;
	}

	return HRESULT_FROM_WIN32 ( ::GetLastError () );
}

////////////////////////////////////////////////////////////////////////////////////
// unregistration of message dll
////////////////////////////////////////////////////////////////////////////////////
HRESULT __stdcall  Unregister_Messages ( void )
{
	CPerformanceEventLogBase::UnInitialize ( _T("WmiAdapter") );
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\precomp.h ===
#ifndef	__PRECOMP_H__
#define	__PRECOMP_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#define STRICT

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif	_WIN32_WINNT

#ifndef	WIN32_LEAN_AND_MEAN
#define	WIN32_LEAN_AND_MEAN
#endif	WIN32_LEAN_AND_MEAN

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <polarity.h>

// need atl wrappers
#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

///////////////////////////////////////////////////////////////////////////////
// macros
///////////////////////////////////////////////////////////////////////////////
#include <__macro_pragma.h>
#include <__macro_nocopy.h>
#include <__macro_loadstring.h>
#include <__macro_assert.h>
#include <__macro_err.h>

#include "__Common_Convert.h"
#include "__Common_SmartPTR.h"

///////////////////////////////////////////////////////////////////////////////
// wbem stuff
///////////////////////////////////////////////////////////////////////////////
#ifndef	__WBEMIDL_H_
#include <wbemidl.h>
#endif	__WBEMIDL_H_

#define UNICODE_SIGNATURE "\xff\xfe"

#endif	__PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\refresher.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					refresher.h
//
//	Abstract:
//
//					declaration of registry refresh exported functions
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__REFRESHER_H__
#define	__REFRESHER_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// it is not thread safe
HRESULT	__stdcall DoReverseAdapterMaintenance ( BOOL bThrottle );

#endif	__REFRESHER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\refresher.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					Refresher.cpp
//
//	Abstract:
//
//					module for application stuff ( security, event logging ... )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "Refresher.h"
#include "RefresherStuff.h"

// security
#include "wmi_security.h"
#include "wmi_security_attributes.h"

/////////////////////////////////////////////////////////////////////////////
//
//	Helpers
//
/////////////////////////////////////////////////////////////////////////////

extern LONG				g_lRefCIM;			//	count of threads attached into CIMV2 namespace
extern LONG				g_lRefWMI;			//	count of threads attached into WMI namespace

extern __SmartHANDLE	g_hDoneWorkEvtCIM;	//	event to set when init/uninit is finished done		( nonsignaled )
extern BOOL				g_bWorkingCIM;		//	boolean used to tell if init/unit in progress

extern __SmartHANDLE	g_hDoneWorkEvtWMI;	//	event to set when init/uninit is finished done		( nonsignaled )
extern BOOL				g_bWorkingWMI;		//	boolean used to tell if init/unit in progress

extern CRITICAL_SECTION	g_csWMI;			//	synch object used to protect above globals

/////////////////////////////////////////////////////////////////////////////
// MUTEX
/////////////////////////////////////////////////////////////////////////////

extern	LPCWSTR	g_szRefreshMutex;
__SmartHANDLE	g_hRefreshMutex		= NULL;

extern	LPCWSTR	g_szRefreshMutexLib;
__SmartHANDLE	g_hRefreshMutexLib	= NULL;

extern	LPCWSTR	g_szRefreshFlag;
__SmartHANDLE	g_hRefreshFlag		= NULL;

HRESULT	__stdcall WbemMaintenanceInitialize ( void )
{
	WmiSecurityAttributes RefresherSA;

	if ( RefresherSA.GetSecurityAttributtes() )
	{
		if ( ! g_hRefreshMutex )
		{
			if ( ( g_hRefreshMutex = ::CreateMutex	(
														RefresherSA.GetSecurityAttributtes(),
														FALSE,
														g_szRefreshMutex
													)
				 ) == NULL )
			{
				// this is really important to have

				DWORD dwError = 0L;
				dwError = ::GetLastError ();

				if ( dwError != ERROR_ALREADY_EXISTS )
				{
					return HRESULT_FROM_WIN32 ( dwError );
				}

				return E_OUTOFMEMORY;
			}
		}

		if ( ! g_hRefreshMutexLib )
		{
			if ( ( g_hRefreshMutexLib = ::CreateMutex	(
														RefresherSA.GetSecurityAttributtes(),
														FALSE,
														g_szRefreshMutexLib
													)
				 ) == NULL )
			{
				// this is really important to have

				DWORD dwError = 0L;
				dwError = ::GetLastError ();

				if ( dwError != ERROR_ALREADY_EXISTS )
				{
					return HRESULT_FROM_WIN32 ( dwError );
				}

				return E_OUTOFMEMORY;
			}
		}

		if ( ! g_hRefreshFlag )
		{
			if ( ( g_hRefreshFlag = ::CreateMutex	(
														RefresherSA.GetSecurityAttributtes(),
														FALSE,
														g_szRefreshFlag
													)
				 ) == NULL )
			{
				// this is really important to have

				DWORD dwError = 0L;
				dwError = ::GetLastError ();

				if ( dwError != ERROR_ALREADY_EXISTS )
				{
					return HRESULT_FROM_WIN32 ( dwError );
				}

				return E_OUTOFMEMORY;
			}
		}

		if ( ! g_hDoneWorkEvtCIM )
		{
			if ( ( g_hDoneWorkEvtCIM = ::CreateEvent ( NULL, TRUE, FALSE, NULL ) ) == NULL )
			{
				// this is really important to have

				DWORD dwError = 0L;
				dwError = ::GetLastError ();

				if ( dwError != ERROR_ALREADY_EXISTS )
				{
					return HRESULT_FROM_WIN32 ( dwError );
				}

				return E_OUTOFMEMORY;
			}
		}

		if ( ! g_hDoneWorkEvtWMI )
		{
			if ( ( g_hDoneWorkEvtWMI = ::CreateEvent ( NULL, TRUE, FALSE, NULL ) ) == NULL )
			{
				// this is really important to have

				DWORD dwError = 0L;
				dwError = ::GetLastError ();

				if ( dwError != ERROR_ALREADY_EXISTS )
				{
					return HRESULT_FROM_WIN32 ( dwError );
				}

				return E_OUTOFMEMORY;
			}
		}

		InitializeCriticalSection (&g_csWMI);
		return S_OK;
	}

	return E_FAIL;
}

HRESULT	__stdcall WbemMaintenanceUninitialize ( void )
{
	::DeleteCriticalSection ( &g_csWMI );
	return S_OK;
}

HRESULT	__stdcall DoReverseAdapterMaintenance ( BOOL bThrottle )
{
	return DoReverseAdapterMaintenanceInternal ( bThrottle );
}

HRESULT	__stdcall DoReverseAdapterMaintenanceInternal ( BOOL bThrottle, GenerateEnum generate )
{
	HRESULT				hRes = S_OK;
	WmiRefresherStuff*	stuff= NULL;

	try
	{
		if ( ( stuff = new WmiRefresherStuff () ) == NULL )
		{
			hRes = E_OUTOFMEMORY;
		}
	}
	catch ( ... )
	{
		if ( stuff )
		{
			delete stuff;
			stuff = NULL;
		}

		hRes = E_UNEXPECTED;
	}

	if ( stuff )
	{
		if SUCCEEDED ( hRes = WbemMaintenanceInitialize () )
		{
			if ( generate == Normal )
			{
				hRes = stuff->Connect ();
			}

			if SUCCEEDED ( hRes )
			{
				try
				{
					hRes = stuff->Generate ( bThrottle, generate );
				}
				catch ( ... )
				{
					hRes = E_UNEXPECTED;
				}
			}

			if ( generate == Normal )
			{
				stuff->Disconnect ();
			}

			delete stuff;
			stuff = NULL;

			WbemMaintenanceUninitialize();
		}
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// GetWbem directory
///////////////////////////////////////////////////////////////////////////////

extern LPCWSTR	g_szWbem;
extern LPCWSTR	g_szDir;
extern LPCWSTR	g_szFolder;

LPWSTR __stdcall GetWbemDirectory()
{
	CRegKey		rKey;
	LPWSTR		wszResult = NULL;

	// wbem directory
	if ( rKey.Open ( HKEY_LOCAL_MACHINE, g_szWbem, KEY_READ ) == ERROR_SUCCESS )
	{
		LPWSTR	tsz		= NULL;
		LPWSTR	tszFull	= NULL;

		DWORD	dwtsz	= 0;

		if ( rKey.QueryValue ( tsz, g_szDir, &dwtsz ) == ERROR_SUCCESS )
		{
			try
			{
				if ( ( tsz = new WCHAR[ dwtsz * sizeof ( WCHAR ) ] ) != NULL )
				{
					if ( rKey.QueryValue ( tsz, g_szDir, &dwtsz ) == ERROR_SUCCESS )
					{
						DWORD dw = 0L;
							
						if ( ( dw = ExpandEnvironmentStrings ( tsz, tszFull, 0 ) ) != 0 )
						{
							if ( ( tszFull = new WCHAR[ dw * sizeof ( WCHAR ) ] ) != NULL )
							{
								if ( ( dw = ExpandEnvironmentStrings ( tsz, tszFull, dw ) ) != 0 )
								{
									if ( ( wszResult = new WCHAR [ lstrlenW ( g_szFolder ) + lstrlenW ( tszFull ) + 1 ] ) != NULL )
									{
										lstrcpyW ( wszResult, tszFull );
										lstrcatW ( wszResult, g_szFolder );
									}
								}

								delete [] tszFull;
								tszFull = NULL;
							}
						}
					}

					delete [] tsz;
					tsz = NULL;
				}
			}
			catch ( ... )
			{
				if ( tsz )
				{
					delete [] tsz;
					tsz = NULL;
				}

				if ( tszFull )
				{
					delete [] tszFull;
					tszFull = NULL;
				}

				if ( wszResult )
				{
					delete [] wszResult;
					wszResult = NULL;
				}
			}
		}
	}

	return wszResult;
}

/////////////////////////////////////////////////////////////////////////////
// registry helper functions
/////////////////////////////////////////////////////////////////////////////

HRESULT	__stdcall	SetRegistry		(	LPCWSTR wszKey,
										LPSECURITY_ATTRIBUTES pSA,
										CRegKey &reg
									)
{
	DWORD	regErr = HRESULT_TO_WIN32 ( E_FAIL );

	// create parent
	LPWSTR wszKeyParent = NULL;
	LPWSTR wszResult	= NULL;

	wszResult = wcsrchr ( wszKey, L'\\' );

	if ( wszResult )
	{
		size_t dwKeyParent = 0L;
		dwKeyParent = wszResult - wszKey;

		BOOL bContinue = FALSE;

		try
		{
			if ( ( wszKeyParent = new WCHAR [ dwKeyParent + 1 ] ) != NULL )
			{
				memcpy ( wszKeyParent, wszKey, sizeof ( WCHAR ) * dwKeyParent );
				wszKeyParent [ dwKeyParent ] = L'\0';

				bContinue = TRUE;
			}
		}
		catch ( ... )
		{
		}

		if ( bContinue )
		{
			regErr = reg.Create	(	HKEY_LOCAL_MACHINE,
									wszKeyParent,
									NULL,
									REG_OPTION_NON_VOLATILE,
									KEY_ALL_ACCESS,
									NULL
								);
		}
	}

	if ( wszKeyParent )
	{
		delete [] wszKeyParent;
		wszKeyParent = NULL;
	}

	if ( regErr == ERROR_SUCCESS )
	{
		// create ( open ) requested
		regErr = reg.Create	(	HKEY_LOCAL_MACHINE,
								wszKey,
								REG_NONE,
								REG_OPTION_NON_VOLATILE,
								KEY_ALL_ACCESS,
								pSA
							);
	}

	return HRESULT_FROM_WIN32 ( regErr );
}

HRESULT	__stdcall	SetRegistry		(	LPCWSTR wszKey,
										LPCWSTR wszKeyValue,
										BYTE* pData,
										DWORD dwDataSize,
										LPSECURITY_ATTRIBUTES pSA
									)
{
	CRegKey reg;
	DWORD	regErr = ERROR_ACCESS_DENIED;

	regErr = reg.Open ( HKEY_LOCAL_MACHINE, wszKey, KEY_WRITE );
	if ( regErr != ERROR_SUCCESS && regErr != ERROR_ACCESS_DENIED )
	{
		if SUCCEEDED ( SetRegistry ( wszKey, pSA, reg ) )
		{
			regErr = ERROR_SUCCESS;
		}
	}

	if ( regErr == ERROR_SUCCESS )
	{
		regErr = RegSetValueEx	(	reg,
									wszKeyValue,
									NULL,
									REG_BINARY,
									pData,
									dwDataSize
								);
	}

	return HRESULT_FROM_WIN32 ( regErr );
}

HRESULT	__stdcall	SetRegistry		(	LPCWSTR wszKey,
										LPCWSTR wszKeyValue,
										DWORD dwValue,
										LPSECURITY_ATTRIBUTES pSA
									)
{
	CRegKey reg;
	DWORD	regErr = ERROR_ACCESS_DENIED;

	regErr = reg.Open ( HKEY_LOCAL_MACHINE, wszKey, KEY_WRITE );
	if ( regErr != ERROR_SUCCESS && regErr != ERROR_ACCESS_DENIED )
	{
		if SUCCEEDED ( SetRegistry ( wszKey, pSA, reg ) )
		{
			regErr = ERROR_SUCCESS;
		}
	}

	{
		regErr = RegSetValueEx	(	reg,
									wszKeyValue,
									NULL,
									REG_DWORD,
									reinterpret_cast < BYTE* > ( &dwValue ),
									sizeof ( DWORD )
								);
	}

	return HRESULT_FROM_WIN32 ( regErr );
}

// get internal registry bit
HRESULT	__stdcall GetRegistry ( LPCWSTR wszKey, LPCWSTR wszKeyValue, BYTE** pData )
{
	( * pData ) = NULL;

	// registry
	HKEY	reg = NULL;
	DWORD	regErr = ERROR_SUCCESS;

	if ( ( regErr = RegOpenKeyW ( HKEY_LOCAL_MACHINE, wszKey, &reg ) ) == ERROR_SUCCESS )
	{
		DWORD dwData = 0;

		if ( ( regErr = RegQueryValueExW ( reg, wszKeyValue, NULL, NULL, (*pData), &dwData ) ) == ERROR_SUCCESS )
		{
			if ( dwData )
			{
				try
				{
					if ( ( (*pData) = (BYTE*) new BYTE [ dwData ] ) != NULL )
					{
						if ((regErr = RegQueryValueExW ( reg, wszKeyValue, NULL, NULL, (*pData), &dwData )) != ERROR_SUCCESS)
						{
							delete [] ( *pData );
							(*pData) = NULL;
						}
					}
					else
					{
						regErr = static_cast < DWORD > ( HRESULT_TO_WIN32 ( E_OUTOFMEMORY ) );
					}
				}
				catch ( ... )
				{
					if (*pData)
					{
						delete [] ( *pData );
						(*pData) = NULL;
					}

					regErr = static_cast < DWORD > ( HRESULT_TO_WIN32 ( E_UNEXPECTED ) );
				}
			}
		}

		RegCloseKey ( reg );
	}

	return HRESULT_FROM_WIN32 ( regErr );
}

// get internal registry value
HRESULT	__stdcall GetRegistry ( LPCWSTR wszKey, LPCWSTR wszKeyValue, DWORD* pdwValue )
{
	// registry
	CRegKey reg;
	LONG	regErr = HRESULT_TO_WIN32 ( E_INVALIDARG );

	if ( wszKey && wszKeyValue )
	{
		if ( pdwValue )
		{
			(*pdwValue) = 0L;

			regErr = reg.Open ( HKEY_LOCAL_MACHINE, wszKey );
			if ( regErr == ERROR_SUCCESS )
			{
				regErr = reg.QueryValue ( (*pdwValue), wszKeyValue );
			}
		}
		else
		{
			regErr = HRESULT_TO_WIN32 ( E_POINTER );
		}
	}

	return HRESULT_FROM_WIN32 ( regErr );
}

// get internal registry value
HRESULT	__stdcall GetRegistrySame ( LPCWSTR wszKey, LPCWSTR wszKeyValue, DWORD* pdwValue )
{
	// registry
	static	CRegKey reg;
	LONG	regErr		= ERROR_SUCCESS;

	if ( pdwValue )
	{
		(*pdwValue) = 0L;

		if ( ! (HKEY)reg )
		{
			regErr = reg.Open ( HKEY_LOCAL_MACHINE, wszKey );
		}

		if ( regErr == ERROR_SUCCESS )
		{
			regErr = reg.QueryValue ( (*pdwValue), wszKeyValue );
		}
	}
	else
	{
		regErr = HRESULT_TO_WIN32 ( E_POINTER );
	}

	return HRESULT_FROM_WIN32 ( regErr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\refreshergenerate.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					refreshergenerate.h
//
//	Abstract:
//
//					declaration of helper enum
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__REFRESHER_GENERATE_H__
#define	__REFRESHER_GENERATE_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

enum GenerateEnum
{
	Registration = -1,
	Normal,
	UnRegistration

};

HRESULT	__stdcall DoReverseAdapterMaintenanceInternal ( BOOL bThrottle, GenerateEnum generate = Normal );

#endif	__REFRESHER_GENERATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\refresherstuff.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					refresherstuff.h
//
//	Abstract:
//
//					declaration of stuff for refresh
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__REFRESHER_STUFF_H__
#define	__REFRESHER_STUFF_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#include "refreshergenerate.h"
#include <psapi.h>

///////////////////////////////////////////////////////////////////////////////
// I would need to have this function
///////////////////////////////////////////////////////////////////////////////

typedef BOOL  (WINAPI *PSAPI_ENUM_PROCESSES) (DWORD    *pdwPIDList,        // Pointer to DWORD array
                                              DWORD     dwListSize,        // Size of array
                                              DWORD    *pdwByteCount) ;    // Bytes needed/returned

typedef BOOL  (WINAPI *PSAPI_ENUM_MODULES)   (HANDLE    hProcess,          // Process to query
                                              HMODULE  *pModuleList,       // Array of HMODULEs
                                              DWORD     dwListSize,        // Size of array
                                              DWORD    *pdwByteCount) ;    // Bytes needed/returned

typedef DWORD (WINAPI *PSAPI_GET_MODULE_NAME)(HANDLE    hProcess,          // Process to query
                                              HMODULE   hModule,           // Module to query
                                              LPWSTR     pszName,          // Pointer to name buffer
                                              DWORD     dwNameSize) ;      // Size of buffer

///////////////////////////////////////////////////////////////////////////////
// refresher stuff
///////////////////////////////////////////////////////////////////////////////
class WmiRefresherStuff
{
	DECLARE_NO_COPY ( WmiRefresherStuff );

	BOOL						m_bConnected;

	public:

	CComPtr < IWbemLocator >	m_spLocator;
	IWbemServices*				m_pServices_CIM;
	IWbemServices*				m_pServices_WMI;

	// construction & destruction
	WmiRefresherStuff();
	~WmiRefresherStuff();

	///////////////////////////////////////////////////////
	// construction & destruction helpers
	///////////////////////////////////////////////////////
	public:
	HRESULT Init ( void );
	HRESULT	Uninit ( void );

	HRESULT	Connect ( void );
	HRESULT Disconnect ( void );

	HRESULT Generate ( BOOL bThrottle, GenerateEnum type = Normal );

	private:

	HRESULT Init_CIM ( void );
	HRESULT Init_WMI ( void );

	void Uninit_CIM ( void );
	void Uninit_WMI ( void );

	///////////////////////////////////////////////////////
	// generate files & registry
	///////////////////////////////////////////////////////
	HRESULT GenerateInternal	( BOOL bThrottle, GenerateEnum type = Normal );
	LONG	LodCtrUnlodCtr		( LPCWSTR wszName, BOOL bLodctr );

	///////////////////////////////////////////////////////
	// process handle
	///////////////////////////////////////////////////////

	HINSTANCE				m_hLibHandle ;
	PSAPI_ENUM_PROCESSES    m_pEnumProcesses ;
	PSAPI_ENUM_MODULES	    m_pEnumModules ;
	PSAPI_GET_MODULE_NAME	m_pGetModuleName;

	// functions
	HRESULT	WMIHandleInit ();
	void	WMIHandleUninit ();

	HANDLE	m_WMIHandle;

	public:

	HRESULT	WMIHandleOpen ();
	void	WMIHandleClose ();

	HANDLE	GetWMI () const
	{
		return m_WMIHandle;
	}
};

#endif	__REFRESHER_STUFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\stllock.cpp ===
//***************************************************************************
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  STLLOCK.CPP
//
//  This implements the STL lockit class to avoid linking to msvcprt.dll
//
//***************************************************************************

#include "precomp.h"

class CCritSec : public CRITICAL_SECTION
{
public:
    CCritSec() 
    {
        InitializeCriticalSection(this);
    }
    ~CCritSec()
    {
        DeleteCriticalSection(this);
    }
    void Enter()
    {
        EnterCriticalSection(this);
    }
    void Leave()
    {
        LeaveCriticalSection(this);
    }
};

static CCritSec g_cs;

#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#undef _CRTIMP

std::_Lockit::_Lockit()
{
    g_cs.Enter();
}

std::_Lockit::~_Lockit()
{
    g_cs.Leave();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\refresherstuff.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					RefresherStuff.cpp
//
//	Abstract:
//
//					module for refresher stuff
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "PreComp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "RefresherUtils.h"
#include "RefresherStuff.h"

#include "wmi_perf_generate.h"

// wmi

#ifdef	_ASSERT
#undef	_ASSERT
#endif	__ASSERT

#include <wmicom.h>
#include <wmimof.h>

///////////////////////////////////////////////////////////////////////////////
// this call back is needed by the wdmlib function
///////////////////////////////////////////////////////////////////////////////
void WINAPI EventCallbackRoutine(PWNODE_HEADER WnodeHeader, ULONG_PTR Context)
{
	return;
}

/////////////////////////////////////////////////////////////////////////////
//
//	Helpers
//
/////////////////////////////////////////////////////////////////////////////

extern LPCWSTR	g_szKey;
extern LPCWSTR	g_szKeyValue;
extern LPCWSTR	g_szKeyRefresh;
extern LPCWSTR	g_szKeyRefreshed;

LONG				g_lRefCIM		= 0;			//	count of threads attached into CIMV2 namespace
LONG				g_lRefWMI		= 0;			//	count of threads attached into WMI namespace

__SmartHANDLE		g_hDoneWorkEvtCIM	= NULL;		//	event to set when init/uninit is finished done		( nonsignaled )
BOOL				g_bWorkingCIM		= FALSE;	//	boolean used to tell if init/unit in progress

__SmartHANDLE		g_hDoneWorkEvtWMI	= NULL;		//	event to set when init/uninit is finished done		( nonsignaled )
BOOL				g_bWorkingWMI		= FALSE;	//	boolean used to tell if init/unit in progress

CRITICAL_SECTION	g_csWMI;						//	synch object used to protect above globals

extern	__SmartHANDLE	g_hRefreshMutex;
extern	__SmartHANDLE	g_hRefreshMutexLib;
extern	__SmartHANDLE	g_hRefreshFlag;

extern	LPCWSTR	g_szLibraryName;
extern	LPCWSTR	g_szQuery;

LONG			g_lGenerateCount = 0;

///////////////////////////////////////////////////////////////////////////////
// variables
///////////////////////////////////////////////////////////////////////////////
extern LPCWSTR	g_szNamespace1;
extern LPCWSTR	g_szNamespace2;

extern LPCWSTR	g_szWmiReverseAdapSetLodCtr		;
extern LPCWSTR	g_szWmiReverseAdapLodCtrDone	;

///////////////////////////////////////////////////////////////////////////////
// construction
///////////////////////////////////////////////////////////////////////////////
WmiRefresherStuff::WmiRefresherStuff() :

m_pServices_CIM ( NULL ),
m_pServices_WMI	( NULL ),

m_hLibHandle ( NULL ),
m_WMIHandle ( NULL ),

m_bConnected ( FALSE )

{
	WMIHandleInit ();
}

///////////////////////////////////////////////////////////////////////////////
// destruction
///////////////////////////////////////////////////////////////////////////////
WmiRefresherStuff::~WmiRefresherStuff()
{
	WMIHandleUninit ();
	Uninit ();
}

HRESULT	WmiRefresherStuff::Connect ()
{
	HRESULT hRes = S_FALSE;

	if SUCCEEDED ( hRes = ::CoInitializeEx ( NULL, COINIT_MULTITHREADED ) )
	{
		m_bConnected = TRUE;

		// locator stuff
		hRes =	::CoCreateInstance
		(
				__uuidof ( WbemLocator ),
				NULL,
				CLSCTX_INPROC_SERVER,
				__uuidof ( IWbemLocator ),
				(void**) & ( m_spLocator )
		);

		if SUCCEEDED ( hRes )
		{
			if SUCCEEDED (::CoSetProxyBlanket	(	m_spLocator, 
													RPC_C_AUTHN_WINNT,
													RPC_C_AUTHZ_NONE,
													NULL,
													RPC_C_AUTHN_LEVEL_CONNECT,
													RPC_C_IMP_LEVEL_IMPERSONATE,
													NULL,
													EOAC_NONE
												)
						 )
			{
				// IUnknown has to be secured too
				CComPtr < IUnknown >	pUnk;

				if ( SUCCEEDED( m_spLocator->QueryInterface( IID_IUnknown, (void**) &pUnk ) ) )
				{
					::CoSetProxyBlanket	(	pUnk,
											RPC_C_AUTHN_WINNT,
											RPC_C_AUTHZ_NONE,
											NULL,
											RPC_C_AUTHN_LEVEL_CONNECT,
											RPC_C_IMP_LEVEL_IMPERSONATE,
											NULL,
											EOAC_NONE
										);
				}	
			}
		}
	}

	return hRes;
}

HRESULT	WmiRefresherStuff::Disconnect ()
{
	HRESULT hRes = S_FALSE;

	if ( m_bConnected )
	{
		if ( m_spLocator.p != NULL )
		{
			m_spLocator.Release();
		}

		::CoUninitialize ( );
		hRes = S_OK;
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// init
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiRefresherStuff::Init ( )
{
	HRESULT hRes = E_UNEXPECTED;

	if ( ! m_spLocator == FALSE )
	{
		Init_CIM ();
		Init_WMI ();

		hRes = S_OK;
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// uninit
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiRefresherStuff::Uninit ( )
{
	Uninit_CIM();
	Uninit_WMI();

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// init namespace CIMV2
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiRefresherStuff::Init_CIM ( )
{
	///////////////////////////////////////////////////////////////////////////
	// variables
	///////////////////////////////////////////////////////////////////////////
	HRESULT	hRes = E_FAIL;
	BOOL bWait = TRUE;
	BOOL bDoWork = FALSE;


	while (bWait)
	{
		try
		{
			::EnterCriticalSection ( &g_csWMI );
		}
		catch ( ... )
		{
			return E_OUTOFMEMORY;
		}

		if ( g_lRefCIM == 0 )
		{
			bDoWork = TRUE;
			g_lRefCIM++;
			g_bWorkingCIM = TRUE;
			::ResetEvent(g_hDoneWorkEvtCIM);
			bWait = FALSE;
		}
		else
		{
			if ( g_bWorkingCIM )
			{
				::LeaveCriticalSection ( &g_csWMI );
				
				if ( WAIT_OBJECT_0 != ::WaitForSingleObject( g_hDoneWorkEvtCIM, INFINITE ) )
				{
					return  hRes;
				}
			}
			else
			{
				bWait = FALSE;
				g_lRefCIM++;
				hRes = S_OK;
			}
		}
	}

	::LeaveCriticalSection( &g_csWMI );

	if (bDoWork)
	{
		if ( m_spLocator.p != NULL && ! m_pServices_CIM )
		{
			///////////////////////////////////////////////////////////////////////
			// namespace for cimv2
			///////////////////////////////////////////////////////////////////////
			if SUCCEEDED ( hRes = m_spLocator ->ConnectServer(	CComBSTR ( g_szNamespace1 ) ,	// NameSpace Name
																NULL,							// UserName
																NULL,							// Password
																NULL,							// Locale
																0L,								// Security Flags
																NULL,							// Authority
																NULL,							// Wbem Context
																&m_pServices_CIM				// Namespace
															  )
					  )
			{
				// Before refreshing, we need to ensure that security is correctly set on the
				// namespace as the refresher will use those settings when it communicates with
				// WMI.  This is especially important in remoting scenarios.

				if SUCCEEDED (hRes = ::CoSetProxyBlanket	(	m_pServices_CIM, 
																RPC_C_AUTHN_WINNT,
																RPC_C_AUTHZ_NONE,
																NULL,
																RPC_C_AUTHN_LEVEL_CONNECT,
																RPC_C_IMP_LEVEL_IMPERSONATE,
																NULL,
																EOAC_NONE
															)
							 )
				{
					// IUnknown has to be secured too
					CComPtr < IUnknown >	pUnk;

					if ( SUCCEEDED(hRes = m_pServices_CIM->QueryInterface( IID_IUnknown, (void**) &pUnk ) ) )
					{
						hRes = ::CoSetProxyBlanket	(	pUnk,
														RPC_C_AUTHN_WINNT,
														RPC_C_AUTHZ_NONE,
														NULL,
														RPC_C_AUTHN_LEVEL_CONNECT,
														RPC_C_IMP_LEVEL_IMPERSONATE,
														NULL,
														EOAC_NONE
													);
					}	
				}

				if (FAILED(hRes))
				{
					m_pServices_CIM->Release();
					m_pServices_CIM = NULL;
				}
			}
		}
		else
		{
			IWbemServices* p = NULL;
			p = m_pServices_CIM;

			try
			{
				if ( p )
				{
					p->AddRef();
				}
			}
			catch ( ... )
			{
				hRes = E_UNEXPECTED;
			}
		}

		try
		{
			::EnterCriticalSection ( &g_csWMI );
		}
		catch (...)
		{
			//no choice have to give others a chance!
			if FAILED ( hRes )
			{
				g_lRefCIM--;
			}

			g_bWorkingCIM = FALSE;
			::SetEvent( g_hDoneWorkEvtCIM );

			return E_OUTOFMEMORY;
		}

		if FAILED ( hRes )
		{
			g_lRefCIM--;
		}

		g_bWorkingCIM = FALSE;
		::SetEvent ( g_hDoneWorkEvtCIM );
		::LeaveCriticalSection ( &g_csWMI );
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// uninit namespace CIMV2
///////////////////////////////////////////////////////////////////////////////
void	WmiRefresherStuff::Uninit_CIM ( )
{
	try
	{
		::EnterCriticalSection ( &g_csWMI );
	}
	catch ( ... )
	{
		return;
	}

	if ( g_lRefCIM == 1 )
	{
		IWbemServices * p = NULL;

		if ( m_pServices_CIM )
		{
			p = m_pServices_CIM;
			m_pServices_CIM = NULL;
		}

		try
		{
			if ( p )
			{
				p -> Release ();
				p = NULL;
			}
		}
		catch ( ... )
		{
		}
	}

	if ( g_lRefCIM )
	{
		g_lRefCIM--;
	}

	::LeaveCriticalSection( &g_csWMI );
}

///////////////////////////////////////////////////////////////////////////////
// init namespace WMI
///////////////////////////////////////////////////////////////////////////////
HRESULT	WmiRefresherStuff::Init_WMI ( )
{
	///////////////////////////////////////////////////////////////////////////
	// variables
	///////////////////////////////////////////////////////////////////////////
	HRESULT	hRes = E_FAIL;
	BOOL bWait = TRUE;
	BOOL bDoWork = FALSE;


	while (bWait)
	{
		try
		{
			::EnterCriticalSection ( &g_csWMI );
		}
		catch ( ... )
		{
			return E_OUTOFMEMORY;
		}

		if (g_lRefWMI  == 0 )
		{
			bDoWork = TRUE;
			g_lRefWMI++;
			g_bWorkingWMI = TRUE;
			::ResetEvent(g_hDoneWorkEvtWMI);
			bWait = FALSE;
		}
		else
		{
			if ( g_bWorkingWMI )
			{
				::LeaveCriticalSection ( &g_csWMI );
				
				if ( WAIT_OBJECT_0 != ::WaitForSingleObject( g_hDoneWorkEvtWMI, INFINITE ) )
				{
					return  hRes;
				}
			}
			else
			{
				bWait = FALSE;
				g_lRefWMI++;
				hRes = S_OK;
			}
		}
	}

	::LeaveCriticalSection( &g_csWMI );

	if (bDoWork)
	{
		if ( m_spLocator.p != NULL && ! m_pServices_WMI )
		{
			///////////////////////////////////////////////////////////////////////
			// namespace for cimv2
			///////////////////////////////////////////////////////////////////////
			if SUCCEEDED ( hRes = m_spLocator ->ConnectServer(	CComBSTR ( g_szNamespace2 ) ,	// NameSpace Name
																NULL,							// UserName
																NULL,							// Password
																NULL,							// Locale
																0L,								// Security Flags
																NULL,							// Authority
																NULL,							// Wbem Context
																&m_pServices_WMI				// Namespace
															  )
					  )
			{
				// Before refreshing, we need to ensure that security is correctly set on the
				// namespace as the refresher will use those settings when it communicates with
				// WMI.  This is especially important in remoting scenarios.

				if SUCCEEDED (hRes = ::CoSetProxyBlanket	(	m_pServices_WMI, 
																RPC_C_AUTHN_WINNT,
																RPC_C_AUTHZ_NONE,
																NULL,
																RPC_C_AUTHN_LEVEL_CONNECT,
																RPC_C_IMP_LEVEL_IMPERSONATE,
																NULL,
																EOAC_NONE
															)
							 )
				{
					// IUnknown has to be secured too
					CComPtr < IUnknown >	pUnk;

					if ( SUCCEEDED(hRes = m_pServices_WMI->QueryInterface( IID_IUnknown, (void**) &pUnk ) ) )
					{
						hRes = ::CoSetProxyBlanket	(	pUnk,
														RPC_C_AUTHN_WINNT,
														RPC_C_AUTHZ_NONE,
														NULL,
														RPC_C_AUTHN_LEVEL_CONNECT,
														RPC_C_IMP_LEVEL_IMPERSONATE,
														NULL,
														EOAC_NONE
													);
					}	
				}

				if (FAILED(hRes))
				{
					m_pServices_WMI->Release();
					m_pServices_WMI = NULL;
				}
			}
		}
		else
		{
			IWbemServices* p = NULL;
			p = m_pServices_WMI;

			try
			{
				if ( p )
				{
					p->AddRef();
				}
			}
			catch ( ... )
			{
				hRes = E_UNEXPECTED;
			}
		}

		try
		{
			::EnterCriticalSection ( &g_csWMI );
		}
		catch (...)
		{
			//no choice have to give others a chance!
			if FAILED ( hRes )
			{
				g_lRefWMI--;
			}

			g_bWorkingWMI = FALSE;
			::SetEvent( g_hDoneWorkEvtWMI );

			return E_OUTOFMEMORY;
		}

		if FAILED ( hRes )
		{
			g_lRefWMI--;
		}

		g_bWorkingWMI = FALSE;
		::SetEvent ( g_hDoneWorkEvtWMI );
		::LeaveCriticalSection ( &g_csWMI );
	}

	return hRes;
}

///////////////////////////////////////////////////////////////////////////////
// uninit namespace WMI
///////////////////////////////////////////////////////////////////////////////
void	WmiRefresherStuff::Uninit_WMI ( )
{
	try
	{
		::EnterCriticalSection ( &g_csWMI );
	}
	catch ( ... )
	{
		return;
	}

	if ( g_lRefWMI == 1 )
	{
		IWbemServices * p = NULL;

		if ( m_pServices_WMI )
		{
			p = m_pServices_WMI;
			m_pServices_WMI = NULL;
		}

		try
		{
			if ( p )
			{
				p -> Release ();
				p = NULL;
			}
		}
		catch ( ... )
		{
		}
	}

	if ( g_lRefWMI )
	{
		g_lRefWMI--;
	}

	::LeaveCriticalSection( &g_csWMI );

}

#include <loadperf.h>
extern LPCWSTR	g_szKeyCounter;

///////////////////////////////////////////////////////////////////////////////
// load/unload counter helper
///////////////////////////////////////////////////////////////////////////////
LONG WmiRefresherStuff::LodCtrUnlodCtr ( LPCWSTR wszName, BOOL bLodctr )
{
	LONG		lErr	= E_OUTOFMEMORY;

	if ( ! wszName )
	{
		lErr = E_INVALIDARG;
	}
	else
	{
		// synchronization
		BOOL	bContinue		= FALSE;
		BOOL	bSynchronize	= FALSE;

		DWORD	dwWaitResult	= 0L;

		__SmartHANDLE	hWmiReverseAdapSetLodCtr		;
		__SmartHANDLE	hWmiReverseAdapLodCtrDone		;

		hWmiReverseAdapSetLodCtr	= ::OpenEvent ( EVENT_MODIFY_STATE, FALSE, g_szWmiReverseAdapSetLodCtr );
		hWmiReverseAdapLodCtrDone	= ::OpenEvent ( SYNCHRONIZE, FALSE, g_szWmiReverseAdapLodCtrDone );

		if ( hWmiReverseAdapSetLodCtr.GetHANDLE () && hWmiReverseAdapLodCtrDone.GetHANDLE () )
		{
			bSynchronize = TRUE;
		}
		else
		{
			bContinue = TRUE;
		}

		if ( bSynchronize )
		{
			if ( ::SetEvent ( hWmiReverseAdapSetLodCtr ) == TRUE )
			{
				bContinue = TRUE;
			}
		}

		if ( bContinue )
		{
			if ( bLodctr )
			{
				CRegKey		rKey;

				// delete registry first
				if ( rKey.Open (	HKEY_LOCAL_MACHINE,
									g_szKeyCounter,
									KEY_SET_VALUE | DELETE
							   )

					 == ERROR_SUCCESS )
				{
					rKey.DeleteValue ( L"First Counter" );
					rKey.DeleteValue ( L"First Help" );
					rKey.DeleteValue ( L"Last Counter" );
					rKey.DeleteValue ( L"Last Help" );
				}

				rKey.Close();

				///////////////////////////////////////////////////////////////////////////
				// create path
				///////////////////////////////////////////////////////////////////////////
				LPWSTR	tsz		= NULL;

				if ( ( tsz = GetWbemDirectory ( ) ) != NULL )
				{
					WCHAR* szName = NULL;
					try
					{
						if ( ( szName = new WCHAR [ 3 + lstrlenW ( tsz ) + lstrlenW ( wszName ) + 4 + 1 ] ) != NULL )
						{
							wsprintfW ( szName, L"xx %s%s.ini", tsz, wszName );

							if ( ( lErr = LoadPerfCounterTextStringsW ( szName, TRUE ) ) != ERROR_SUCCESS )
							{
								::SetLastError ( lErr );
							}
						}
					}
					catch ( ... )
					{
						lErr = E_UNEXPECTED;
					}

					if ( szName )
					{
						delete [] szName;
						szName = NULL;
					}

					delete [] tsz;
					tsz = NULL;
				}
			}
			else
			{
				WCHAR* szName = NULL;
				try
				{
					if ( ( szName = new WCHAR [ 3 + lstrlenW ( wszName ) + 1 ] ) != NULL )
					{
						wsprintfW ( szName, L"xx %s", wszName );

						if ( ( lErr = UnloadPerfCounterTextStringsW ( szName, TRUE ) ) != ERROR_SUCCESS )
						{
							::SetLastError ( lErr );
						}
					}
				}
				catch ( ... )
				{
					lErr = E_UNEXPECTED;
				}

				if ( szName )
				{
					delete [] szName;
					szName = NULL;
				}
			}

			if ( bSynchronize )
			{
				// wait for ADAP to be done
				dwWaitResult = ::WaitForSingleObject ( hWmiReverseAdapLodCtrDone, 3000 );
				if ( dwWaitResult != WAIT_OBJECT_0 )
				{
					// something went wrong ?
					lErr = E_FAIL;
				}
			}
		}
		else
		{
			// we failed to synchronize so no action has taken
			lErr = E_FAIL;
		}
	}

	return lErr;
}

HRESULT WmiRefresherStuff::Generate ( BOOL bThrottle, GenerateEnum type )
{
	HRESULT	hRes			= E_FAIL;

	BOOL	bOwnMutex		= FALSE;
	BOOL	bLocked			= FALSE;
	DWORD	dwWaitResult	= 0L;

	DWORD	dwHandles	= 2;
	HANDLE	hHandles[]	=
	{
		g_hRefreshMutex,
		g_hRefreshMutexLib
	};

	dwWaitResult = ::WaitForMultipleObjects ( dwHandles, hHandles, TRUE, 0 );
	if ( dwWaitResult == WAIT_TIMEOUT )
	{
		bLocked = TRUE;
	}
	else
	{
		if ( dwWaitResult == WAIT_OBJECT_0 )
		{
			bOwnMutex	= TRUE;
			hRes		= S_FALSE;
		}
	}

	if ( bLocked )
	{
		dwWaitResult = ::WaitForSingleObject ( g_hRefreshFlag, 0 );
		if ( dwWaitResult == WAIT_OBJECT_0 )
		{
			hRes = SetRegistry ( g_szKey, g_szKeyRefresh, 1 );
			::ReleaseMutex ( g_hRefreshFlag );
		}
	}
	else
	{
		if SUCCEEDED ( hRes )
		{
			if ( type == Normal )
			{
				try
				{
					// connect to management
					Init();
				}
				catch ( ... )
				{
				}
			}

			try
			{
				hRes = GenerateInternal ( bThrottle, type );

				if SUCCEEDED ( hRes )
				{
					if ( type != UnRegistration )
					{
						// change flag to let them now we are done
						dwWaitResult = ::WaitForSingleObject ( g_hRefreshFlag, INFINITE );
						if ( dwWaitResult == WAIT_OBJECT_0 )
						{
							if ( type == Registration )
							{
								hRes = SetRegistry ( g_szKey, g_szKeyRefresh, 1 );
								hRes = SetRegistry ( g_szKey, g_szKeyRefreshed, 0 );
							}
							else
							{
								hRes = SetRegistry ( g_szKey, g_szKeyRefresh, 0 );
								hRes = SetRegistry ( g_szKey, g_szKeyRefreshed, 1 );
							}

							::ReleaseMutex ( g_hRefreshFlag );
						}
					}
				}
			}
			catch ( ... )
			{
				hRes = E_UNEXPECTED;
			}

			if ( type == Normal )
			{
				try
				{
					// disconnect from management
					Uninit();
				}
				catch ( ... )
				{
				}
			}
		}
	}

	if ( bOwnMutex )
	{
		::ReleaseMutex ( g_hRefreshMutex );
		::ReleaseMutex ( g_hRefreshMutexLib );
	}

	return hRes;
}

HRESULT WmiRefresherStuff::GenerateInternal ( BOOL bThrottle, GenerateEnum type )
{
	HRESULT	hRes = S_OK;

	if ( ::InterlockedCompareExchange ( &g_lGenerateCount, 1, 0 ) == 0 )
	{
		if ( type == UnRegistration )
		{
			// lodctr / unlodctr functionality
			LodCtrUnlodCtr ( g_szLibraryName, FALSE );
		}
		else
		{
			// generate wrapper
			CGenerate	generate;

			if ( type == Normal )
			{
				// generate for cimv2
				if ( m_pServices_CIM )
				{
					generate.Generate ( m_pServices_CIM, g_szQuery, g_szNamespace1, TRUE );

					if ( generate.m_dwlcid == 2 )
					{
						generate.Generate ( m_pServices_CIM, g_szQuery, g_szNamespace1, FALSE );
					}
				}

				// generate for wmi
				if ( m_pServices_WMI )
				{
					generate.Generate ( m_pServices_WMI, g_szQuery, g_szNamespace2, TRUE );

					if ( generate.m_dwlcid == 2 )
					{
						generate.Generate ( m_pServices_WMI, g_szQuery, g_szNamespace2, FALSE );
					}
				}
			}

			// generate appropriate h file
			if SUCCEEDED ( hRes = generate.GenerateFile_h		( g_szLibraryName, bThrottle, type ) )
			{
				// generate appropriate ini file
				if SUCCEEDED ( hRes = generate.GenerateFile_ini	( g_szLibraryName, bThrottle, type ) )
				{
					// lodctr / unlodctr functionality
					LodCtrUnlodCtr ( g_szLibraryName, FALSE );
					// lodctr / unlodctr functionality
					LodCtrUnlodCtr ( g_szLibraryName, TRUE );

					if ( type == Normal )
					{
						// generate appropriate registry
						if FAILED( hRes = generate.GenerateRegistry	( g_szKey, g_szKeyValue, bThrottle ) )
						{
							#ifdef	__SUPPORT_MSGBOX
							ERRORMESSAGE_DEFINITION;
							ERRORMESSAGE ( hRes );
							#else	__SUPPORT_MSGBOX
							___TRACE_ERROR( L"generate registry failed",hRes );
							#endif	__SUPPORT_MSGBOX
						}

						// call wdm lib function to take care of 
						CWMIBinMof wmi;
						if SUCCEEDED ( wmi.Initialize ( NULL,FALSE ) )
						{
							wmi.CopyWDMKeyToDredgeKey ();
						}
					}
				}
				else
				{
					#ifdef	__SUPPORT_MSGBOX
					ERRORMESSAGE_DEFINITION;
					ERRORMESSAGE ( hRes );
					#else	__SUPPORT_MSGBOX
					___TRACE_ERROR( L"generate ini failed",hRes );
					#endif	__SUPPORT_MSGBOX
				}
			}
			else
			{
				#ifdef	__SUPPORT_MSGBOX
				ERRORMESSAGE_DEFINITION;
				ERRORMESSAGE ( hRes );
				#else	__SUPPORT_MSGBOX
				___TRACE_ERROR( L"generate header failed",hRes );
				#endif	__SUPPORT_MSGBOX
			}

			// unitialize global resources used by generate
			generate.Uninitialize ();
		}

		::InterlockedDecrement ( &g_lGenerateCount );
	}

	return hRes;
}

#define	MAX_MODULES	1024

HRESULT	WmiRefresherStuff::WMIHandleInit ( void )
{
	HRESULT hRes = S_FALSE;

    if ( m_hLibHandle == NULL)
	{
        if ( ( m_hLibHandle = LoadLibraryW ( L"PSAPI.DLL") ) == NULL )
		{
            hRes = HRESULT_FROM_WIN32 ( ERROR_DLL_NOT_FOUND );
        }
        else
		{
            m_pEnumProcesses	= (PSAPI_ENUM_PROCESSES)	GetProcAddress ( m_hLibHandle, "EnumProcesses" ) ;
            m_pEnumModules		= (PSAPI_ENUM_MODULES)		GetProcAddress ( m_hLibHandle, "EnumProcessModules" ) ;
            m_pGetModuleName	= (PSAPI_GET_MODULE_NAME)	GetProcAddress ( m_hLibHandle, "GetModuleBaseNameW" ) ;

			if	(	m_pEnumProcesses == NULL	||
					m_pEnumModules == NULL		||
					m_pGetModuleName == NULL
				)
			{
				hRes = HRESULT_FROM_WIN32 ( ERROR_PROC_NOT_FOUND );
			}
			else
			{
				hRes = S_OK;
			}
		}
	}

	return hRes;
}

void	WmiRefresherStuff::WMIHandleUninit ( void )
{
	if ( m_hLibHandle )
	{
		::FreeLibrary ( m_hLibHandle );
		m_hLibHandle = NULL;
	}
}

HRESULT	WmiRefresherStuff::WMIHandleOpen ( void )
{
	if (	! m_hLibHandle		||
			! m_pEnumProcesses	||
			! m_pEnumModules	||
			! m_pGetModuleName
	   )
	{
		return E_UNEXPECTED;
	}

	HRESULT hRes = E_OUTOFMEMORY;

	DWORD dw = 1;
	DWORD dwSize = dw * MAX_MODULES;
	DWORD dwNeed = 0;
	DWORD * pProcId = NULL;

	BOOL bContinue = TRUE;

	try
	{
		pProcId = new DWORD [ dwSize ];
	}
	catch ( ... )
	{
		if ( pProcId )
		{
			delete [] pProcId;
			pProcId = NULL;
		}

		hRes = E_UNEXPECTED;
	}

	if ( pProcId )
	{
		do
		{
			if ( m_pEnumProcesses ( pProcId, dwSize * sizeof ( DWORD ), &dwNeed ) == FALSE )
			{
				dw++;

				delete [] pProcId;
				pProcId = NULL;

				dwSize = dw * MAX_MODULES;

				if ( dw <= 4 )
				{
					try
					{
						pProcId = new DWORD [ dwSize ];
					}
					catch ( ... )
					{
						if ( pProcId )
						{
							delete [] pProcId;
							pProcId = NULL;
						}

						hRes = E_UNEXPECTED;
					}
				}
			}
			else
			{
				bContinue = FALSE;
			}
		}
		while ( pProcId && bContinue && dw <= 4 );

		if ( pProcId && bContinue == FALSE )
		{
			bContinue = TRUE;

			DWORD	dwSizeModules = MAX_MODULES;
			HMODULE * pModules = NULL;

			try
			{
				pModules = new HMODULE [ dwSizeModules ];
			}
			catch ( ... )
			{
				if ( pModules )
				{
					delete [] pModules;
					pModules = NULL;
				}

				hRes = E_UNEXPECTED;
			}

			if ( pModules )
			{
				hRes = E_FAIL;

				DWORD dwRetModules = 0L;
				dwNeed = dwNeed / sizeof ( DWORD );

				for ( DWORD i = 0; i < dwNeed && bContinue; i++ )
				{
					HANDLE hProcess = NULL;
					if ( ( hProcess = ::OpenProcess (	PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
														FALSE,
														pProcId [ i ]
													)
						 ) != NULL
					   )
					{
						if ( m_pEnumModules ( hProcess, pModules, dwSizeModules * sizeof ( DWORD ), &dwRetModules ) )
						{
							WCHAR ModuleName [ MAX_PATH ] = { L'\0' };

							if ( m_pGetModuleName (	hProcess,
													pModules[0], // first module is executable
													ModuleName,
													sizeof ( ModuleName ) / sizeof ( WCHAR )
												  )
							   )
							{					    
								if ( 0 == _wcsicmp ( L"Winmgmt.exe", ModuleName ) )
								{
									hRes = S_OK;
									bContinue = FALSE;
								}
							}
						}

						if ( bContinue )
						{
							CloseHandle ( hProcess );
							hProcess = NULL;
						}
					}

					if ( hRes == S_OK )
					{
						m_WMIHandle = hProcess;
					}
				}

				delete [] pModules;
				pModules = NULL;
			}
		}

		delete [] pProcId;
		pProcId = NULL;
	}

	return hRes;
}

void	WmiRefresherStuff::WMIHandleClose ( void )
{
	if ( m_WMIHandle )
	{
		::CloseHandle ( m_WMIHandle );
		m_WMIHandle = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\refresherutils.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					refresherUtils.h
//
//	Abstract:
//
//					declaration of registry refresh exported functions and utils
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__REFRESHERUTILS_H__
#define	__REFRESHERUTILS_H__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#include <polarity.h>

// helpers
LPWSTR	__stdcall GetWbemDirectory();

// registry helpers
HRESULT	__stdcall	SetRegistry		(	LPCWSTR wszKey,
									LPCWSTR wszKeyValue,
									BYTE* pData,
									DWORD dwDataSize,
									LPSECURITY_ATTRIBUTES pSA = NULL
							);

HRESULT	__stdcall	SetRegistry		(	LPCWSTR wszKey,
									LPCWSTR wszKeyValue,
									DWORD dwValue,
									LPSECURITY_ATTRIBUTES pSA = NULL
							);

HRESULT	__stdcall	GetRegistry		( LPCWSTR wszKey, LPCWSTR wszKeyValue, BYTE** pData );
HRESULT	__stdcall	GetRegistry		( LPCWSTR wszKey, LPCWSTR wszKeyValue, DWORD * pdwValue );
HRESULT	__stdcall	GetRegistrySame ( LPCWSTR wszKey, LPCWSTR wszKeyValue, DWORD * pdwValue );

#endif	__REFRESHERUTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_generate.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_generate.cpp
//
//	Abstract:
//
//					implements generate functionality ( generate registry and files )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "refresherUtils.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// definitions
#include "wmi_perf_generate.h"

HRESULT CGenerate::Generate ( IWbemServices* pServices, LPCWSTR szQuery, LPCWSTR szNamespace, BOOL bLocale )
{
	HRESULT hRes = S_OK;

	try
	{
		if ( bLocale )
		{
			__String::SetStringCopy ( m_pNamespaces[m_dwNamespaces].m_wszNamespace, szNamespace );
			__String::SetStringCopy ( m_pNamespaces[m_dwNamespaces].m_wszQuery, szQuery );

			if FAILED ( hRes = m_pNamespaces[m_dwNamespaces].GenerateObjects( pServices, szQuery, bLocale ) )
			{
				#ifdef	__SUPPORT_MSGBOX
				ERRORMESSAGE_DEFINITION;
				ERRORMESSAGE ( hRes );
				#else	__SUPPORT_MSGBOX
				___TRACE_ERROR( L"generate namespace failed",hRes );
				#endif	__SUPPORT_MSGBOX
			}

			m_dwNamespaces++;
		}
		else
		{
			if FAILED ( hRes = m_pNamespaces[m_dwNamespaces-1].GenerateObjects( pServices, szQuery, bLocale ) )
			{
				#ifdef	__SUPPORT_MSGBOX
				ERRORMESSAGE_DEFINITION;
				ERRORMESSAGE( hRes );
				#else	__SUPPORT_MSGBOX
				___TRACE_ERROR( L"generate namespace failed",hRes );
				#endif	__SUPPORT_MSGBOX
			}
		}
	}
	catch ( ... )
	{
		hRes = E_FAIL;
	}

	return hRes;
}

LPWSTR	CGenerate::GenerateNameInd ( LPCWSTR wszName, DWORD dwObjIndex )
{
	LPWSTR			wsz		= NULL;

	try
	{
		if ( ( wsz = new WCHAR [ lstrlenW ( wszName ) + 1 + 5 + 1 ] ) != NULL )
		{
			wsprintfW ( wsz, L"%s_%05x", wszName, dwObjIndex );
		}
	}
	catch ( ... )
	{
		if ( wsz )
		{
			delete [] wsz;
			wsz = NULL;
		}
	}

	return wsz;
}

static	LPWSTR	wszContent	= NULL;
static	DWORD	dwSize		= 4096;
static	DWORD	dwSizeLeft	= dwSize;

void	CGenerate::Uninitialize ( void )
{
	if ( wszContent )
	{
		delete [] wszContent;
		wszContent = NULL;
	}
}

void	CGenerate::ContentDelete ( void )
{
	if ( wszContent )
	{
		wszContent [ 0 ] = L'\0';
		dwSizeLeft = dwSize;
	}
}

HRESULT	CGenerate::ContentWrite ( BOOL bUnicode )
{
	HRESULT hRes = S_FALSE;

	if ( wszContent )
	{
		if ( dwSizeLeft != dwSize )
		{
			wszContent [ dwSize - dwSizeLeft ] = L'\0';

			//write to file now
			if ( bUnicode )
			{
				hRes = WriteToFileUnicode ( wszContent );
			}
			else
			{
				hRes = WriteToFile ( wszContent );
			}
		}

		ContentDelete ();
	}
	else
	{
		hRes = E_UNEXPECTED;
	}

	return hRes;
}

void CGenerate::AppendString ( LPCWSTR src, DWORD dwSrcSize, DWORD& dwSrcSizeLeft )
{
	if ( ( dwSizeLeft - 1 ) <= dwSrcSize )
	{
		memcpy ( ( wszContent + ( dwSize - dwSizeLeft ) ), src, ( dwSizeLeft - 1 ) * sizeof ( WCHAR ) );
		dwSrcSizeLeft	= dwSrcSize - ( dwSizeLeft - 1 );
		dwSizeLeft		= 0;

		wszContent [ dwSize - 1 ] = L'\0';
	}
	else
	{
		memcpy ( ( wszContent + ( dwSize - dwSizeLeft ) ), src, dwSrcSize * sizeof ( WCHAR ) );
		dwSrcSizeLeft	= 0;
		dwSizeLeft		= dwSizeLeft - dwSrcSize;

		wszContent [ dwSize - dwSizeLeft ] = L'\0';
	}
}

HRESULT CGenerate::AppendString ( LPCWSTR src, BOOL bUnicode )
{
	HRESULT hRes			= S_FALSE;

	DWORD	dwSrcSize		= 0L;
	DWORD	dwSrcSizeLeft	= 0L;
	LPCWSTR	wsz				= NULL;

	if ( ! wszContent )
	{
		hRes = E_OUTOFMEMORY;

		try
		{
			if ( ( wszContent = new WCHAR [ dwSize ] ) != NULL )
			{
				hRes = S_OK;
			}
		}
		catch ( ... )
		{
			if ( wszContent )
			{
				delete [] wszContent;
				wszContent = NULL;
			}

			hRes = E_FAIL;
		}
	}

	if SUCCEEDED ( hRes )
	{
		// append string
		if ( ( wsz = src ) != NULL )
		{
			do
			{
				dwSrcSize = lstrlenW ( wsz );

				AppendString ( wsz, dwSrcSize, dwSrcSizeLeft );
				if ( ! dwSizeLeft )
				{
					//write to file now
					if ( bUnicode )
					{
						hRes = WriteToFileUnicode ( wszContent );
					}
					else
					{
						hRes = WriteToFile ( wszContent );
					}

					if SUCCEEDED ( hRes )
					{
						dwSizeLeft = dwSize;
					}
				}
				else
				{
					hRes = S_OK;
				}

				if ( dwSrcSizeLeft )
				{
					DWORD dwOffset	= 0L;
					dwOffset = dwSrcSize - dwSrcSizeLeft;

					wsz = wsz + dwOffset;
				}
			}
			while ( dwSrcSizeLeft && SUCCEEDED ( hRes ) );
		}
		else
		{
			hRes = E_INVALIDARG;
		}
	}

	return hRes;
}

// need atl conversions
#ifndef	__ATLCONV_H__
#include <atlconv.h>
#endif	__ATLCONV_H__

HRESULT	CGenerate::WriteToFile ( LPCWSTR wszContent )
{
	HRESULT hRes = S_OK;

	if ( m_hFile && ( m_hFile != INVALID_HANDLE_VALUE ) && wszContent )
	{
		DWORD dwWritten = 0L;
		USES_CONVERSION;

		try
		{
			if ( ! ::WriteFile	(	m_hFile,
									W2A ( wszContent ),
									lstrlenW ( wszContent ) * sizeof ( char ),
									&dwWritten,
									NULL
								)
			   )
			{
				hRes = HRESULT_FROM_WIN32 ( ::GetLastError () );
			}
		}
		catch ( ... )
		{
			hRes = E_UNEXPECTED;
		}
	}
	else
	{
		hRes = E_INVALIDARG;
	}

	return hRes;
}

HRESULT	CGenerate::WriteToFileUnicode ( LPCWSTR wszContent )
{
	HRESULT hRes = S_OK;

	if ( m_hFile && ( m_hFile != INVALID_HANDLE_VALUE ) && wszContent )
	{
		DWORD dwWritten = 0L;

		try
		{
			if ( ! ::WriteFile	(	m_hFile,
									wszContent,
									lstrlenW ( wszContent ) * sizeof ( WCHAR ),
									&dwWritten,
									NULL
								)
			   )
			{
				hRes = HRESULT_FROM_WIN32 ( ::GetLastError () );
			}
		}
		catch ( ... )
		{
			hRes = E_UNEXPECTED;
		}
	}
	else
	{
		hRes = E_INVALIDARG;
	}

	return hRes;
}

HRESULT CGenerate::FileCreate ( LPCWSTR lpwszFileName )
{
	HRESULT		hRes	= E_OUTOFMEMORY;
	LPWSTR		path	= NULL;
	LPWSTR		tpath	= NULL;

	if ( lpwszFileName )
	{
		// get wbem directory
		if ( ( tpath = GetWbemDirectory() ) != NULL )
		{
			try
			{
				if ( ( path = new WCHAR [ lstrlenW ( tpath ) + lstrlenW ( lpwszFileName ) + 1 ] ) != NULL )
				{
					lstrcpyW ( path, tpath );
					lstrcatW ( path, lpwszFileName );

					hRes = S_FALSE;
				}
			}
			catch ( ... )
			{
				hRes = E_FAIL;
			}

			if SUCCEEDED ( hRes )
			{
				if ( ! ( ::CreateDirectoryW ( tpath, NULL ) ) )
				{
					if ( ERROR_ALREADY_EXISTS != ::GetLastError() )
					{
						hRes = HRESULT_FROM_WIN32( ::GetLastError() );
					}
					else
					{
						hRes = S_FALSE;
					}
				}

				if SUCCEEDED ( hRes )
				{
					if ( ( m_hFile = ::CreateFileW	(	path,
														GENERIC_WRITE,
														FILE_SHARE_READ,
														NULL,
														CREATE_ALWAYS,
														FILE_ATTRIBUTE_NORMAL | SECURITY_ANONYMOUS,
														NULL
													)
						 ) == INVALID_HANDLE_VALUE )
					{
						hRes = HRESULT_FROM_WIN32 ( ::GetLastError () );
					}
					else
					{
						hRes = S_OK;
					}
				}
			}

			if ( path )
			{
				delete [] path;
				path = NULL;
			}

			delete [] tpath;
			tpath = NULL;
		}
	}
	else
	{
		hRes = E_INVALIDARG;
	}

	return hRes;
}

HRESULT CGenerate::FileDelete ( LPCWSTR lpwszFileName )
{
	HRESULT		hRes	= E_OUTOFMEMORY;
	LPWSTR		path	= NULL;
	LPWSTR		tpath	= NULL;

	m_hFile.CloseHandle();

	if ( lpwszFileName )
	{
		// get wbem directory
		if ( ( tpath = GetWbemDirectory() ) != NULL )
		{
			try
			{
				if ( ( path = new WCHAR [ lstrlenW ( tpath ) + lstrlenW ( lpwszFileName ) + 1 ] ) != NULL )
				{
					lstrcpyW ( path, tpath );
					lstrcatW ( path, lpwszFileName );

					hRes = S_FALSE;
				}
			}
			catch ( ... )
			{
				hRes = E_FAIL;
			}

			if SUCCEEDED ( hRes )
			{
				if ( ! DeleteFile ( path ) )
				{
					hRes = HRESULT_FROM_WIN32 ( ::GetLastError () );
				}
				else
				{
					hRes = S_OK;
				}
			}

			if ( path )
			{
				delete [] path;
				path = NULL;
			}

			delete [] tpath;
			tpath = NULL;
		}
	}
	else
	{
		hRes = E_INVALIDARG;
	}

	return hRes;
}

HRESULT CGenerate::FileMove ( LPCWSTR lpwszFileName, LPCWSTR lpwszFileNameNew )
{
	HRESULT		hRes	= E_OUTOFMEMORY;
	LPWSTR		path1	= NULL;
	LPWSTR		path2	= NULL;
	LPWSTR		tpath	= NULL;

	if ( m_hFile )
	{
		::CloseHandle ( m_hFile );
		m_hFile = NULL;
	}

	if ( lpwszFileName && lpwszFileNameNew )
	{
		// get wbem directory
		if ( ( tpath = GetWbemDirectory() ) != NULL )
		{
			try
			{
				if ( ( path1 = new WCHAR [ lstrlenW ( tpath ) + lstrlenW ( lpwszFileName ) + 1 ] ) != NULL )
				{
					lstrcpyW ( path1, tpath );
					lstrcatW ( path1, lpwszFileName );

					hRes = S_FALSE;
				}
				else
				{
					hRes = E_OUTOFMEMORY;
				}
			}
			catch ( ... )
			{
				hRes = E_FAIL;
			}

			if SUCCEEDED ( hRes )
			{
				try
				{
					if ( ( path2 = new WCHAR [ lstrlenW ( tpath ) + lstrlenW ( lpwszFileNameNew ) + 1 ] ) != NULL )
					{
						lstrcpyW ( path2, tpath );
						lstrcatW ( path2, lpwszFileNameNew );

						hRes = S_FALSE;
					}
					else
					{
						hRes = E_OUTOFMEMORY;
					}
				}
				catch ( ... )
				{
					hRes = E_FAIL;
				}

				if SUCCEEDED ( hRes )
				{
					// try to delete old one
					DeleteFile ( path2 );

					if ( ! MoveFileEx ( path1, path2, MOVEFILE_REPLACE_EXISTING ) )
					{
						hRes = HRESULT_FROM_WIN32 ( ::GetLastError () );
					}
					else
					{
						hRes = S_OK;
					}
				}
			}

			if ( path2 )
			{
				delete [] path2;
				path2 = NULL;
			}

			if ( path1 )
			{
				delete [] path1;
				path1 = NULL;
			}

			delete [] tpath;
			tpath = NULL;
		}
	}
	else
	{
		hRes = E_INVALIDARG;
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_common.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_common.cpp
//
//	Abstract:
//
//					declarations of common constants
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

LPCWSTR	g_szLibraryName		= L"WmiApRpl";

LPCWSTR	g_szRefreshMutex	= L"Global\\RefreshRA_Mutex";
LPCWSTR	g_szRefreshMutexLib	= L"Global\\RefreshRA_Mutex_Lib";
LPCWSTR	g_szRefreshFlag		= L"Global\\RefreshRA_Mutex_Flag";

LPCWSTR	g_szWmiReverseAdapSetLodCtr		= L"Global\\WMI_RevAdap_Set";
LPCWSTR	g_szWmiReverseAdapLodCtrDone	= L"Global\\WMI_RevAdap_ACK";

// namespaces
LPCWSTR	g_szNamespace1	= L"\\\\.\\root\\cimv2";
LPCWSTR	g_szNamespace2	= L"\\\\.\\root\\wmi";

// query language & queries
LPCWSTR	g_szQueryLang	= L"WQL";
LPCWSTR	g_szQuery		= L"select * from meta_class where __this isa \"Win32_PerfRawData\"";

LONG g_lFlag = WBEM_FLAG_FORWARD_ONLY;

// required qualifiers
LPCWSTR g_szFulFil[] = 
{
	L"provider",
	L"HiPerf"
};

// don't required qualifier
LPCWSTR g_szFulFilNot[] =
{
	L"abstract",
	L"generic",
	L"genericperfctr",
	L"cooked"
};

DWORD g_dwFulFil	= sizeof ( g_szFulFil ) / sizeof ( g_szFulFil[0] );
DWORD g_dwFulFilNot	= sizeof ( g_szFulFilNot ) / sizeof ( g_szFulFilNot[0] );

LONG g_lFlagProperties = WBEM_FLAG_LOCAL_ONLY | WBEM_FLAG_NONSYSTEM_ONLY;

// required qualifiers of property
LPCWSTR g_szPropNeed[] = 
{
	L"defaultscale",
	L"perfdetail"
};

// don't required qualifiers of property
LPCWSTR g_szPropNeedNot[];

DWORD	g_dwPropNeed	= sizeof ( g_szPropNeed ) / sizeof ( g_szPropNeed[0] );
DWORD	g_dwPropNeedNot	= 0;

// main filter for properties
LPCWSTR g_szPropFilter = L"countertype";

///////////////////////////////////////////////////////////////////////////////
// generate :))
///////////////////////////////////////////////////////////////////////////////

LPCWSTR	g_szWbem	= L"SOFTWARE\\Microsoft\\Wbem";
LPCWSTR	g_szDir		= L"Installation Directory";
LPCWSTR	g_szFolder	= L"\\Performance\\";

LPCWSTR	g_szKey				= L"SOFTWARE\\Microsoft\\WBEM\\PROVIDERS\\Performance";
LPCWSTR	g_szKeyValue		= L"Performance Data";
LPCWSTR	g_szKeyRefresh		= L"Performance Refresh";
LPCWSTR	g_szKeyRefreshed	= L"Performance Refreshed";

LPCWSTR	g_szKeyCounter	= L"SYSTEM\\CurrentControlSet\\Services\\WmiApRpl\\Performance";

// constants
LPCWSTR	cNEW		= L"\r\n";
LPCWSTR	cTAB		= L"\t";
LPCWSTR	cDEFINE		= L"#define	";

LPCWSTR	cDriverName	= L"drivername=";
LPCWSTR	cSymbolFile	= L"symbolfile=";

LPCWSTR	cSIGN		= L"=";

LPCWSTR	cinfo		= L"[info]\r\n";
LPCWSTR	cobjects	= L"[objects]\r\n";
LPCWSTR	clanguages	= L"[languages]\r\n";
LPCWSTR	ctext		= L"[text]\r\n";

LPCWSTR	cNAME		= L"NAME";
LPCWSTR	cHELP		= L"HELP";

LPCWSTR	cWMIOBJECTS				= L"WMI_Objects";
LPCWSTR	cWMIOBJECTS_COUNT		= L"HiPerf_Classes";
LPCWSTR	cWMIOBJECTS_VALIDITY	= L"HiPerf_Validity";

LPCWSTR	cWMIOBJECTS_NAME			= L"NAME=WMI Objects";
LPCWSTR	cWMIOBJECTS_COUNT_NAME		= L"NAME=HiPerf Classes";
LPCWSTR	cWMIOBJECTS_VALIDITY_NAME	= L"NAME=HiPerf Validity";

LPCWSTR	cWMIOBJECTS_HELP			= L"HELP=Number of WMI High Performance provider returned by WMI Adapter";
LPCWSTR	cWMIOBJECTS_COUNT_HELP		= L"HELP=Shows High Performance Classes";
LPCWSTR	cWMIOBJECTS_VALIDITY_HELP	= L"HELP=Shows if High Performance Classes are valid";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_generate_comment.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_generate_comment.cpp
//
//	Abstract:
//
//					declarations of comment helpers
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

#include "wmi_perf_generate_comment.h"

HRESULT CGenerateComment::AddHeader ()
{
	HRESULT hr = S_OK;

	comment += L"//////////////////////////////////////////////////////////////////////////////////////////////\r\n";
	if ( ! comment )
	{
		hr = E_OUTOFMEMORY;
	}

	return hr;
}

HRESULT	CGenerateComment::AddFooter ()
{
	HRESULT hr = S_OK;

	if SUCCEEDED ( hr = AddHeader () )
	{
		if ( ! ( comment += L"\r\n" ) ) 
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}

HRESULT CGenerateComment::AddLine ( LPCWSTR szLine )
{
	HRESULT hr = S_OK;

	if ( ! szLine )
	{
		if ( ! ( comment += L"//\r\n" ) )
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		// test if line doesn't contain \n

		LPWSTR p = NULL;
		p = CharNextW ( szLine );

		while( p && p[0] != 0 )
		{
			p = CharNextW ( p );
			if ( p[0] == L'\n' )
			{
				hr = E_INVALIDARG;
			}
		}

		if SUCCEEDED ( hr )
		{
			if ( ! ( comment += L"// " ) )
			{
				hr = E_OUTOFMEMORY;
			}
			else
			if ( ! ( comment += szLine ) )
			{
				hr = E_OUTOFMEMORY;
			}
			else
			if ( ! ( comment += L"\r\n" ) )
			{
				hr = E_OUTOFMEMORY;
			}
		}
	}

	return hr;
}

HRESULT CGenerateComment::Add ( LPCWSTR szLine )
{
	HRESULT hr = S_OK;

	if ( ! szLine )
	{
		if ( ! ( comment += L"\r\n" ) )
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		if ( ! ( comment += szLine ) )
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_generate.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_generate.h
//
//	Abstract:
//
//					decalaration of generate everything wrapper
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_GENERATE__
#define	__WMI_PERF_GENERATE__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#include "refreshergenerate.h"

#ifndef	__WMI_PERF_OBJECT_LOCALE__
#include "wmi_perf_object_global.h"
#endif	__WMI_PERF_OBJECT_LOCALE__

class CGenerate
{
	DECLARE_NO_COPY ( CGenerate );

	// generate object global arrays
	// contains generated hi-perfs for all namspaces

	CObjectGlobal	m_pNamespaces[2];
	DWORD			m_dwNamespaces;

	LCID			m_lcid[2];

	public:

	DWORD			m_dwlcid;

	// construction & destruction

	CGenerate() :
	m_hFile ( NULL ),
	m_dwNamespaces ( 0 )
	{
		m_lcid[0] = ::GetSystemDefaultLCID();
		m_lcid[1] = MAKELCID( MAKELANGID ( LANG_ENGLISH, SUBLANG_ENGLISH_US ), SORT_DEFAULT );

		if ( m_lcid[0] != m_lcid[1] )
		{
			m_dwlcid = 2;
		}
		else
		{
			m_dwlcid = 1;
		}
	}

	~CGenerate()
	{
	}

	HRESULT Generate ( IWbemServices* pServices, LPCWSTR szQuery, LPCWSTR szNamespace, BOOL bLocale = FALSE );

	// generate files
	HRESULT	GenerateFile_ini	( LPCWSTR wszModuleName, BOOL bThrottle, int type = Normal );
	HRESULT	GenerateFile_h		( LPCWSTR wszModuleName, BOOL bThrottle, int type = Normal );

	// generate registry
	HRESULT GenerateRegistry ( LPCWSTR wszKey, LPCWSTR wszValue, BOOL bThrottle );

	void	Uninitialize ( void );

	private:

	// helpers
	DWORD	GenerateIndexRegistry	( BOOL bInit = FALSE );
	LPWSTR	GenerateIndex			( void );
	LPWSTR	GenerateLanguage		( LCID lcid );
	LPWSTR	GenerateName			( LPCWSTR wszName, LCID lcid );
	LPWSTR	GenerateNameInd			( LPCWSTR wszName, DWORD dwObjIndex );

	HRESULT CreateObjectList ( BOOL bThrottle = FALSE );

	// string
	void	AppendString ( LPCWSTR src, DWORD dwSrcSize, DWORD& dwSrcSizeLeft );
	HRESULT	AppendString ( LPCWSTR src, BOOL bUnicode = TRUE );

	// handle to one of files
	__SmartHANDLE	m_hFile;

	// create files
	HRESULT FileCreate	( LPCWSTR lpwszFileName );
	HRESULT FileDelete	( LPCWSTR lpwszFileName );
	HRESULT FileMove	( LPCWSTR lpwszFileName, LPCWSTR lpwszFileNameNew );

	HRESULT	ContentWrite	( BOOL bUnicode = TRUE );
	void	ContentDelete	( );

	// write to file
	HRESULT	WriteToFile			( LPCWSTR wszContent );
	HRESULT	WriteToFileUnicode	( LPCWSTR wszContent );
};

#endif	__WMI_PERF_GENERATE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_generate_comment.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_generate_comment.h
//
//	Abstract:
//
//					declaration of helpers for generate comment
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_GENERATE_COMMENT__
#define	__WMI_PERF_GENERATE_COMMENT__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// need atlbase

#ifndef	__ATLBASE_H__
#include <atlbase.h>
#endif	__ATLBASE_H__

class CGenerateComment
{
	CComBSTR comment;

	CGenerateComment ( const CGenerateComment& )				{}
	CGenerateComment& operator= ( const CGenerateComment& )	{}

	public:

	// construction & destruction

	CGenerateComment()
	{
	}

	virtual ~CGenerateComment()
	{
	}

	// funtions

	HRESULT Add			( LPCWSTR szLine = NULL );
	HRESULT AddLine		( LPCWSTR szLine = NULL );

	HRESULT AddHeader	();
	HRESULT	AddFooter	();

	LPWSTR GetCommentCopy ( void )
	{
		LPWSTR res = NULL;
		try
		{
			if ( ( res = (LPWSTR) new WCHAR[ comment.Length() + 1 ] ) != NULL )
			{
				lstrcpyW ( res, (LPWSTR)comment );
			}
		}
		catch ( ... )
		{
			if ( res )
			{
				delete res;
				res = NULL;
			}
		}

		return res;
	}

	LPWSTR GetComment( void ) const
	{
		return (LPWSTR)comment;
	}
};

#endif	__WMI_PERF_GENERATE_COMMENT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_generate_header.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_generate_header.cpp
//
//	Abstract:
//
//					implements generate functionality ( header file )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <throttle.h>

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// definitions
#include "wmi_perf_generate.h"
// generate comments
#include "wmi_perf_generate_comment.h"
// registry helpers
#include "wmi_perf_reg.h"

static DWORD	dwIndex = 0;

// constants
extern LPCWSTR	cNEW;
extern LPCWSTR	cTAB;
extern LPCWSTR	cDEFINE;

extern LPCWSTR	cWMIOBJECTS;
extern LPCWSTR	cWMIOBJECTS_COUNT;
extern LPCWSTR	cWMIOBJECTS_VALIDITY;

// generate index and its string represetation
LPWSTR	CGenerate::GenerateIndex ( )
{
	LPWSTR			wsz		= NULL;

	try
	{
		if ( ( wsz = new WCHAR [ 10 + 1 ] ) != NULL )
		{
			wsprintfW ( wsz, L"%d", ((dwIndex++)*2) );
		}
	}
	catch ( ... )
	{
		if ( wsz )
		{
			delete [] wsz;
			wsz = NULL;
		}
	}

	return wsz;
}

HRESULT CGenerate::GenerateFile_h( LPCWSTR wszModuleName, BOOL bThrottle, int type )
{
	HRESULT hRes		= S_FALSE;

	if ( ( wszModuleName == 0 || *wszModuleName == 0 ) || ( type == Normal && m_dwNamespaces == 0 ) )
	{
		hRes = E_UNEXPECTED;
	}
	else
	{
		LPWSTR	wszModule = NULL;

		try
		{
			if ( ( wszModule = new WCHAR [ lstrlenW ( wszModuleName ) + 6 + 1 ] ) == NULL )
			{
				hRes = E_OUTOFMEMORY;
			}
			else
			{
				lstrcpyW ( wszModule, wszModuleName );
				lstrcatW ( wszModule, L"_new.h" );

				if SUCCEEDED ( hRes = FileCreate ( wszModule ) )
				{
					// do comment stuff
					CGenerateComment comment;

					comment.AddHeader();
					comment.AddLine();
					comment.AddLine( L"Copyright (C) 2000 Microsoft Corporation" );
					comment.AddLine();
					comment.AddLine( L"Module Name:" );
					comment.AddLine( wszModuleName );
					comment.AddLine();
					comment.AddLine( L"Abstract:" );
					comment.AddLine();
					comment.AddLine( L"Include file for object and counters definitions." );
					comment.AddLine();
					comment.AddFooter();

					hRes = WriteToFile ( comment.GetComment() );
				}
			}
		}
		catch ( ... )
		{
			hRes = E_FAIL;
		}

		if SUCCEEDED ( hRes )
		{
			// generate pseudo counter data
			static LPCWSTR	sz0 = L"\t0";
			static LPCWSTR	sz2 = L"\t2";
			static LPCWSTR	sz4 = L"\t4";

			// generate pseudo counter name
			if SUCCEEDED ( hRes = AppendString ( cNEW, FALSE ) )
			{
				if SUCCEEDED ( hRes = AppendString ( cDEFINE, FALSE ) )
				{
					if SUCCEEDED ( hRes = AppendString ( cWMIOBJECTS, FALSE ) )
					{
						hRes = AppendString ( sz0, FALSE );
					}
				}
			}

			// generate first property of pseudo counter
			if ( SUCCEEDED ( hRes ) && SUCCEEDED ( hRes = AppendString ( cNEW, FALSE ) ) )
			{
				if SUCCEEDED ( hRes = AppendString ( cDEFINE, FALSE ) )
				{
					if SUCCEEDED ( hRes = AppendString ( cWMIOBJECTS_COUNT, FALSE ) )
					{
						hRes = AppendString ( sz2, FALSE );
					}
				}
			}

			// generate second property of pseudo counter
			if ( SUCCEEDED ( hRes ) && SUCCEEDED ( hRes = AppendString ( cNEW, FALSE ) ) )
			{
				if SUCCEEDED ( hRes = AppendString ( cDEFINE, FALSE ) )
				{
					if SUCCEEDED ( hRes = AppendString ( cWMIOBJECTS_VALIDITY, FALSE ) )
					{
						hRes = AppendString ( sz4, FALSE );
					}
				}
			}

			if SUCCEEDED ( hRes )
			{
				hRes = AppendString ( cNEW, FALSE );
			}

			if ( SUCCEEDED ( hRes ) && ( type != Registration ) )
			{

				// init helper variable
						dwIndex		= 3;
				DWORD	dwObjIndex	= 0;

				for (	DWORD dw = 0;
						dw < m_dwNamespaces && SUCCEEDED ( hRes );
						dw++
					)
				{
					if ( ! m_pNamespaces[dw].m_ppObjects.empty() )
					{
						DWORD dwIndexProp	= 0;
						try
						{
							// need to go accros object names
							for (	mapOBJECTit it = m_pNamespaces[dw].m_ppObjects.begin();
									it != m_pNamespaces[dw].m_ppObjects.end() && SUCCEEDED ( hRes );
									it++, dwObjIndex++
								)
							{
								if SUCCEEDED ( hRes = AppendString ( cNEW, FALSE ) )
								{
									if SUCCEEDED ( hRes = AppendString ( cDEFINE, FALSE ) )
									{
										LPWSTR	wszName = NULL;
										wszName = GenerateNameInd ( (*it).second->GetName(), dwObjIndex );

										if ( wszName )
										{
											hRes = AppendString ( wszName, FALSE );

											delete [] wszName;
											wszName = NULL;

											if SUCCEEDED ( hRes )
											{
												if SUCCEEDED ( hRes = AppendString ( cTAB, FALSE ) )
												{
													LPWSTR	szIndex = NULL;
													szIndex = GenerateIndex();

													if ( szIndex )
													{
														hRes = AppendString ( szIndex, FALSE );

														delete [] szIndex;
														szIndex = NULL;

														if SUCCEEDED( hRes )
														{
															if SUCCEEDED ( hRes = AppendString ( cNEW, FALSE ) )
															{
																// need to go accros properties names
																for (	dwIndexProp = 0;
																		dwIndexProp < (*it).second->GetArrayProperties() && SUCCEEDED ( hRes );
																		dwIndexProp++
																	)
																{
																	// do I have a locales for property ???
																	if ( !((*it).second->GetArrayProperties())[dwIndexProp]->GetArrayLocale().IsEmpty() )
																	{
																		// I have so this is not not hidden counter !!!
																		if SUCCEEDED ( hRes = AppendString ( cNEW, FALSE ) )
																		{
																			if SUCCEEDED ( hRes = AppendString ( cDEFINE, FALSE ) )
																			{
																				LPWSTR wszNameInd = NULL;
																				wszNameInd = GenerateNameInd ( ((*it).second->GetArrayProperties())[dwIndexProp]->GetName(), dwObjIndex );

																				if ( wszNameInd )
																				{
																					hRes = AppendString ( wszNameInd, FALSE );

																					if SUCCEEDED ( hRes )
																					{
																						if SUCCEEDED ( hRes = AppendString ( cTAB, FALSE) )
																						{
																							LPWSTR	szIndex = NULL;
																							szIndex = GenerateIndex();

																							if ( szIndex )
																							{
																								hRes = AppendString ( szIndex, FALSE );

																								delete [] szIndex;
																								szIndex = NULL;
																							}
																							else
																							{
																								hRes = E_OUTOFMEMORY;
																							}
																						}
																					}
																				}
																				else
																				{
																					hRes = E_OUTOFMEMORY;
																				}
																			}
																		}
																	}
																}

																if SUCCEEDED ( hRes )
																{
																	hRes = AppendString ( cNEW, FALSE );
																}
															}
														}
													}
													else
													{
														hRes = E_OUTOFMEMORY;
													}
												}
											}
										}
										else
										{
											hRes = E_OUTOFMEMORY;
										}
									}
								}

								if ( bThrottle && SUCCEEDED ( hRes ) )
								{
									Throttle	(
													THROTTLE_ALLOWED_FLAGS,
													1000,
													100,
													10,
													3000
												);
								}
							}
						}
						catch ( ... )
						{
							hRes =  E_UNEXPECTED;
						}
					}
				}
			}
		}

		if SUCCEEDED ( hRes )
		{
			// write changes if not done already
			if SUCCEEDED ( hRes = ContentWrite ( FALSE ) )
			{
				LPWSTR	wszModuleNew = NULL;

				try
				{
					if ( ( wszModuleNew = new WCHAR [ lstrlenW ( wszModuleName ) + 2 + 1 ] ) == NULL )
					{
						hRes = E_OUTOFMEMORY;
					}
					else
					{
						lstrcpyW ( wszModuleNew, wszModuleName );
						lstrcatW ( wszModuleNew, L".h" );

						// make changes
						hRes = FileMove ( wszModule, wszModuleNew );
					}
				}
				catch ( ... )
				{
					hRes = E_FAIL;
				}

				if ( wszModuleNew )
				{
					delete [] wszModuleNew;
					wszModuleNew = NULL;
				}
			}

			if FAILED ( hRes )
			{
				// revert changes
				ContentDelete ();
				FileDelete ( wszModule );
			}
		}
		else
		{
			// revert changes
			ContentDelete ();
			FileDelete ( wszModule );
		}

		if ( wszModule )
		{
			delete [] wszModule;
			wszModule = NULL;
		}
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_generate_registry.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_generate_registry.cpp
//
//	Abstract:
//
//					implements generate functionality ( generate registry )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "refresherUtils.h"
#include <throttle.h>

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// definitions
#include "wmi_perf_generate.h"

// registry helpers
#include "wmi_perf_reg.h"

// I need admin attributes to create registry
#include "..\\Include\\wmi_security_attributes.h"

////////////////////////////////////////////////////////////////////////////////////
// implementation
////////////////////////////////////////////////////////////////////////////////////

// registry helper
DWORD CGenerate::GenerateIndexRegistry( BOOL bInit )
{
	static	DWORD	dwIndex = 0;
	return ( ( bInit ) ? ( dwIndex = 0 ), 0 : ( ( dwIndex++ ) *2 ) );
}

// registry helper
HRESULT CGenerate::GenerateRegistry ( LPCWSTR wszKey, LPCWSTR wszKeyValue, BOOL bThrottle )
{
	HRESULT hRes = S_FALSE;

	try
	{
		__PERFORMANCE p ( 0 );
		if ( ! p.IsEmpty() )
		{
			// init helper static variable
			GenerateIndexRegistry ( TRUE );

			for (	DWORD dw = 0;
					dw < m_dwNamespaces && SUCCEEDED ( hRes );
					dw++
				)
			{
				if ( ! m_pNamespaces[dw].m_ppObjects.empty() )
				{
					hRes = S_OK;

					// create namespace
					try
					{
						__NAMESPACE n ( m_pNamespaces[dw].m_wszNamespace, dw );
						if ( ! n.IsEmpty() )
						{
							DWORD dwIndex = 0;
							for (	mapOBJECTit it = m_pNamespaces[dw].m_ppObjects.begin();
									it != m_pNamespaces[dw].m_ppObjects.end() && SUCCEEDED ( hRes );
									it++
								)
							{
								// create object
								try
								{
									dwIndex = GenerateIndexRegistry();

									__OBJECT o ( (*it).second->GetName(), dwIndex );
									if ( ! o.IsEmpty() )
									{
										if ( ! ( (*it).second->GetArrayKeys().IsEmpty() ) )
										{
											for (	DWORD dwInst = 0;
													dwInst < (*it).second->GetArrayKeys() && SUCCEEDED ( hRes );
													dwInst++
												)
											{
												// have an instance
												PWMI_PERF_INSTANCE pInst = NULL;

												try
												{
													DWORD dwNameLength	= ( ::lstrlenW( (*it).second->GetArrayKeys()[dwInst] ) + 1 ) * sizeof ( WCHAR );

													DWORD dwAlignName	= 0L;
													if ( dwNameLength % 8 )
													{
														dwAlignName = 8 - ( dwNameLength % 8 );
													}

													DWORD dwAlignStruct	= 0L;
													if ( sizeof ( WMI_PERF_INSTANCE ) % 8 )
													{
														dwAlignStruct = 8 - ( sizeof ( WMI_PERF_INSTANCE ) % 8 );
													}

													DWORD dwLength		=	dwAlignName + dwNameLength + 
																			dwAlignStruct + sizeof ( WMI_PERF_INSTANCE );

													if ( ( pInst = (PWMI_PERF_INSTANCE) malloc ( dwLength ) ) != NULL )
													{
														// copy string into structure
														::CopyMemory ( &(pInst->dwName), (*it).second->GetArrayKeys()[dwInst], dwNameLength );

														pInst->dwNameLength	= dwNameLength;
														pInst->dwLength		= dwLength;

														// copy instance into object
														try
														{
															if ( (PWMI_PERF_OBJECT)o && 
															   ( o = (PWMI_PERF_OBJECT) realloc ( (PWMI_PERF_OBJECT)o, ((PWMI_PERF_OBJECT)o)->dwTotalLength + pInst->dwLength ) ) != NULL )
															{
																::CopyMemory (
																				( LPVOID ) ( reinterpret_cast<PBYTE>( (PWMI_PERF_OBJECT)o ) + ((PWMI_PERF_OBJECT)o)->dwTotalLength ),
																				pInst,
																				pInst->dwLength );

																((PWMI_PERF_OBJECT)o)->dwTotalLength += pInst->dwLength;
															}
															else
															{
																hRes = E_OUTOFMEMORY;
															}
														}
														catch ( ... )
														{
															hRes = E_FAIL;
														}

														free ( pInst );
													}
													else
													{
														hRes = E_OUTOFMEMORY;
													}
												}
												catch ( ... )
												{
													hRes = E_FAIL;
												}

												// helper for property index
												DWORD dwIndex = 0;

												// make all properties
												for (	DWORD dwProp = 0;
														dwProp < (*it).second->GetArrayProperties() && SUCCEEDED ( hRes );
														dwProp++
													)
												{
													if (!((*it).second->GetArrayProperties())[dwProp]->GetArrayLocale().IsEmpty())
													{
														dwIndex = GenerateIndexRegistry();
														__PROPERTY p ( (*it).second->GetArrayProperties()[dwProp]->GetName(), dwIndex );

														if ( ! p.IsEmpty() )
														{
															// fill structure
															((PWMI_PERF_PROPERTY)p)->dwDefaultScale	= (*it).second->GetArrayProperties()[dwProp]->dwDefaultScale;
															((PWMI_PERF_PROPERTY)p)->dwDetailLevel	= (*it).second->GetArrayProperties()[dwProp]->dwDetailLevel;
															((PWMI_PERF_PROPERTY)p)->dwCounterType	= (*it).second->GetArrayProperties()[dwProp]->dwCounterType;

															((PWMI_PERF_PROPERTY)p)->dwTYPE		= (*it).second->GetArrayProperties()[dwProp]->GetType();
															((PWMI_PERF_PROPERTY)p)->dwParentID	= ((PWMI_PERF_OBJECT)o)->dwID;

															// append into parent one
															hRes = o.AppendAlloc( p );
														}
														else
														{
															hRes = E_OUTOFMEMORY;
														}
													}
													else
													{
														__PROPERTY p ( (*it).second->GetArrayProperties()[dwProp]->GetName(), 0 );

														if ( ! p.IsEmpty() )
														{
															// fill structure
															((PWMI_PERF_PROPERTY)p)->dwDefaultScale	= (*it).second->GetArrayProperties()[dwProp]->dwDefaultScale;
															((PWMI_PERF_PROPERTY)p)->dwDetailLevel	= (*it).second->GetArrayProperties()[dwProp]->dwDetailLevel;
															((PWMI_PERF_PROPERTY)p)->dwCounterType	= (*it).second->GetArrayProperties()[dwProp]->dwCounterType;

															((PWMI_PERF_PROPERTY)p)->dwTYPE		= (*it).second->GetArrayProperties()[dwProp]->GetType();
															((PWMI_PERF_PROPERTY)p)->dwParentID = ((PWMI_PERF_OBJECT)o)->dwID;

															// append into parent one
															hRes = o.AppendAlloc( p );
														}
														else
														{
															hRes = E_OUTOFMEMORY;
														}
													}
												}

												// fill parent structure
												if ( SUCCEEDED ( hRes ) && dwIndex )
												{
													((PWMI_PERF_OBJECT)o)->dwLastID = dwIndex;
												}
											}

											if SUCCEEDED ( hRes )
											{
												// I'm not singleton ( have dwInst instances )
												((PWMI_PERF_OBJECT)o)->dwSingleton	= dwInst;
											}
										}
										else
										{
											// helper for property index
											DWORD dwIndex = 0;

											// make all properties
											for (	DWORD dwProp = 0;
													dwProp < (*it).second->GetArrayProperties() && SUCCEEDED ( hRes );
													dwProp++
												)
											{
												if (!((*it).second->GetArrayProperties())[dwProp]->GetArrayLocale().IsEmpty())
												{
													dwIndex = GenerateIndexRegistry();

													__PROPERTY p ( (*it).second->GetArrayProperties()[dwProp]->GetName(), dwIndex );
													if ( ! p.IsEmpty() )
													{
														// fill structure
														((PWMI_PERF_PROPERTY)p)->dwDefaultScale	= (*it).second->GetArrayProperties()[dwProp]->dwDefaultScale;
														((PWMI_PERF_PROPERTY)p)->dwDetailLevel	= (*it).second->GetArrayProperties()[dwProp]->dwDetailLevel;
														((PWMI_PERF_PROPERTY)p)->dwCounterType	= (*it).second->GetArrayProperties()[dwProp]->dwCounterType;

														((PWMI_PERF_PROPERTY)p)->dwTYPE		= (*it).second->GetArrayProperties()[dwProp]->GetType();
														((PWMI_PERF_PROPERTY)p)->dwParentID = ((PWMI_PERF_OBJECT)o)->dwID;

														// append into parent one
														hRes = o.AppendAlloc( p );
													}
													else
													{
														hRes = E_OUTOFMEMORY;
													}
												}
												else
												{
													__PROPERTY p ( (*it).second->GetArrayProperties()[dwProp]->GetName(), 0 );
													if ( ! p.IsEmpty() )
													{
														// fill structure
														((PWMI_PERF_PROPERTY)p)->dwDefaultScale	= (*it).second->GetArrayProperties()[dwProp]->dwDefaultScale;
														((PWMI_PERF_PROPERTY)p)->dwDetailLevel	= (*it).second->GetArrayProperties()[dwProp]->dwDetailLevel;
														((PWMI_PERF_PROPERTY)p)->dwCounterType	= (*it).second->GetArrayProperties()[dwProp]->dwCounterType;

														((PWMI_PERF_PROPERTY)p)->dwTYPE		= (*it).second->GetArrayProperties()[dwProp]->GetType();
														((PWMI_PERF_PROPERTY)p)->dwParentID = ((PWMI_PERF_OBJECT)o)->dwID;

														// append into parent one
														hRes = o.AppendAlloc( p );
													}
													else
													{
														hRes = E_OUTOFMEMORY;
													}
												}
											}

											// fill parent structure
											if ( SUCCEEDED ( hRes ) && dwIndex )
											{
												((PWMI_PERF_OBJECT)o)->dwLastID = dwIndex;
											}
										}

										if SUCCEEDED ( hRes )
										{
											// fill structure
											((PWMI_PERF_OBJECT)o)->dwDetailLevel = (*it).second->dwDetailLevel;
											((PWMI_PERF_OBJECT)o)->dwParentID = ((PWMI_PERF_NAMESPACE)n)->dwID;

											// append into parent one
											hRes = n.AppendAlloc ( o );
										}
									}
									else
									{
										hRes = E_OUTOFMEMORY;
									}
								}
								catch ( ... )
								{
									hRes = E_FAIL;
								}

								if ( bThrottle && SUCCEEDED ( hRes ) )
								{
									Throttle	(
													THROTTLE_ALLOWED_FLAGS,
													1000,
													100,
													10,
													3000
												);
								}
							}

							if SUCCEEDED ( hRes )
							{
								// fill structure
								((PWMI_PERF_NAMESPACE)n)->dwLastID		= dwIndex;
								((PWMI_PERF_NAMESPACE)n)->dwParentID	= dw;

								// append into parent one
								hRes = p.AppendAlloc ( n );
							}
						}
						else
						{
							hRes = E_OUTOFMEMORY;
						}
					}
					catch ( ... )
					{
						hRes = E_FAIL;
					}
				}
			}

			WmiSecurityAttributes sa;
			if ( sa.GetSecurityAttributtes () )
			{
				if ( hRes == S_OK )
				{
					hRes = SetRegistry( wszKey, wszKeyValue, (BYTE*) (PWMI_PERFORMANCE)p, ((PWMI_PERFORMANCE)p)->dwTotalLength, sa.GetSecurityAttributtes() );
				}
				else
				{
					if ( hRes == S_FALSE )
					{
						hRes = SetRegistry( wszKey, wszKeyValue, (BYTE*) NULL, 0, sa.GetSecurityAttributtes() );
					}
				}
			}
			else
			{
				hRes =  E_FAIL;
			}
		}
		else
		{
			hRes = E_OUTOFMEMORY;
		}
	}
	catch ( ... )
	{
		hRes =  E_FAIL;
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_object.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_object.h
//
//	Abstract:
//
//					declaration of object structure
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_OBJECT__
#define	__WMI_PERF_OBJECT__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// wbem
#ifndef	__WBEMIDL_H_
#include <wbemidl.h>
#endif	__WBEMIDL_H_

class CPerformanceObject
{
	DECLARE_NO_COPY ( CPerformanceObject );

	IWbemClassObject*	m_pObject;
	BOOL				m_bCopy;

	IWbemQualifierSet*	m_pObjectQualifierSet;

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	CPerformanceObject ( IWbemClassObject * pObject, BOOL bCopy = FALSE ) :
	m_bCopy ( bCopy ),
	m_pObject ( NULL ),
	m_pObjectQualifierSet ( NULL )
	{
		if (pObject )
		{
			if ( m_bCopy )
			{
				( m_pObject = pObject ) -> AddRef ();
			}
			else
			{
				( m_pObject = pObject );
			}
		}
	}

	virtual ~CPerformanceObject ()
	{
		if ( m_bCopy && m_pObject )
		{
			m_pObject -> Release ();
		}

		m_pObject = NULL;

		if ( m_pObjectQualifierSet )
		{
			m_pObjectQualifierSet -> Release ();
		}

		m_pObjectQualifierSet = NULL;
	}

	// helpers for IWbemClassObject instances :))
	IWbemClassObject* GetObjectClass() const
	{
		return m_pObject;
	}

	IWbemClassObject* GetObjectClassCopy()
	{
		if ( m_pObject )
		{
			m_pObject->AddRef();
		}

		return m_pObject;
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// methods
	//////////////////////////////////////////////////////////////////////////////////////////

	// resolve if object has all required qualifiers and don't have exactly specified not reqired set
	HRESULT IsCorrectObject ( LPCWSTR* lptszFulFil, DWORD dwFulFil, LPCWSTR* lptszFulFilNot, DWORD dwFulFilNot );

	HRESULT	GetNames	(	DWORD*		pdwPropNames,
							LPWSTR**	ppPropNames,
							CIMTYPE**	ppTypes,
							DWORD**		ppScales,
							DWORD**		ppLevels,
							DWORD**		ppCounters,
							LONG		lFlags,
							LPCWSTR*	lptszPropNeed,
							DWORD		dwPropNeed,
							LPCWSTR*	lptszPropNeedNot,
							DWORD		dwPropNeedNot,
							LPCWSTR		lpwszQualifier = NULL
						);

	HRESULT	GetPropertyValue	( LPCWSTR wszPropName, LPWSTR* pwsz );

	HRESULT	GetQualifierValue	( LPCWSTR wszPropName, LPCWSTR wszQualifierName, LPWSTR* psz );
	HRESULT	GetQualifierValue	( LPCWSTR wszQualifierName, LPWSTR* psz );

	private:

	//////////////////////////////////////////////////////////////////////////////////////////
	// helpers
	//////////////////////////////////////////////////////////////////////////////////////////

	HRESULT	GetQualifierValue	( IWbemQualifierSet* pSet, LPCWSTR wszQualifierName, LPWSTR* psz );

	HRESULT	GetQualifierType	( LPCWSTR wszPropName, CIMTYPE* type );

	HRESULT	IsCorrect ( IWbemQualifierSet* pSet,
						LPCWSTR* lptszPropNeed,
						DWORD	dwPropNeed,
						LPCWSTR*	lptszPropNeedNot,
						DWORD	dwPropNeedNot
					  );
};

#endif	__WMI_PERF_OBJECT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_object.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_object.cpp
//
//	Abstract:
//
//					implements object helper functionality
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

// definitions
#include "wmi_perf_object.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

//////////////////////////////////////////////////////////////////////////////////////////////
// methods
//////////////////////////////////////////////////////////////////////////////////////////////

// return S_OK when correct
// return S_FALSE when not correct

HRESULT CPerformanceObject::IsCorrect ( IWbemQualifierSet* pSet,
										LPCWSTR* lptszNeed,
										DWORD	dwNeed,
										LPCWSTR*	lptszNeedNot,
										DWORD	dwNeedNot
									  )
{
	HRESULT	hRes	= S_OK;
	DWORD	dwIndex	= 0;

	// resolve all requested to be fulfiled with
	if ( lptszNeed && dwNeed )
	{
		for ( dwIndex = 0; dwIndex < dwNeed; dwIndex++ )
		{
			hRes = pSet->Get( lptszNeed[dwIndex], NULL, NULL, NULL );

			// there is no requested qualifier
			if ( hRes == WBEM_E_NOT_FOUND )
			{
				return S_FALSE;
			}

			if FAILED( hRes )
			{
				#ifdef	__SUPPORT_MSGBOX
				ERRORMESSAGE_DEFINITION;
				ERRORMESSAGE_RETURN ( hRes );
				#else	__SUPPORT_MSGBOX
				___TRACE_ERROR( L"find out if object is correct failed",hRes );
				return hRes;
				#endif	__SUPPORT_MSGBOX
			}
		}
	}

	// resolve all don't requested qualifiers

	if ( lptszNeedNot && dwNeedNot )
	{
		for ( dwIndex = 0; dwIndex < dwNeedNot; dwIndex++)
		{
			hRes = pSet->Get( lptszNeedNot[dwIndex], NULL, NULL, NULL );

			// there is found not requested qualifier
			if ( hRes == WBEM_S_NO_ERROR )
			{
				return S_FALSE;
			}

			if ( hRes != WBEM_E_NOT_FOUND )
			{
				#ifdef	__SUPPORT_MSGBOX
				ERRORMESSAGE_DEFINITION;
				ERRORMESSAGE_RETURN ( hRes );
				#else	__SUPPORT_MSGBOX
				___TRACE_ERROR( L"find out if object is correct failed",hRes );
				return hRes;
				#endif	__SUPPORT_MSGBOX
			}

			hRes = WBEM_S_NO_ERROR;
		}
	}

	return hRes;
}

HRESULT CPerformanceObject::IsCorrectObject ( LPCWSTR* lptszFulFil, DWORD dwFulFil, LPCWSTR* lptszFulFilNot, DWORD dwFulFilNot )
{
	HRESULT	hRes	= S_OK;

	// have no object ???
	if ( ! m_pObject )
	{
		hRes = E_UNEXPECTED;
	}

	if SUCCEEDED ( hRes )
	{
		if ( ! m_pObjectQualifierSet )
		{
			if FAILED ( hRes = m_pObject->GetQualifierSet ( &m_pObjectQualifierSet ) )
			{
				#ifdef	__SUPPORT_MSGBOX
				ERRORMESSAGE_DEFINITION;
				ERRORMESSAGE ( hRes );
				#else	__SUPPORT_MSGBOX
				___TRACE_ERROR( L"get qualifiers of object failed",hRes );
				#endif	__SUPPORT_MSGBOX
			}
		}

		if SUCCEEDED ( hRes )
		{
			hRes = IsCorrect ( m_pObjectQualifierSet, lptszFulFil, dwFulFil, lptszFulFilNot, dwFulFilNot);
		}
	}

	return hRes;
}

HRESULT	CPerformanceObject::GetNames	(	DWORD*		pdwPropNames,
											LPWSTR**	ppPropNames,
											CIMTYPE**	ppTypes,
											DWORD**		ppScales,
											DWORD**		ppLevels,
											DWORD**		ppCounters,
											LONG		lFlags,
											LPCWSTR*	lptszPropNeed,
											DWORD		dwPropNeed,
											LPCWSTR*	lptszPropNeedNot,
											DWORD		dwPropNeedNot,
											LPCWSTR		lpwszQualifier
										)
{
	HRESULT	hRes	= S_OK;
	DWORD	dwIndex	= 0;

	if ( ! m_pObject )
	{
		return E_UNEXPECTED;
	}

	if ( !pdwPropNames )
	{
		return E_INVALIDARG;
	}

	// smart pointer for safearrays
	__WrapperSAFEARRAY saNames;

	if FAILED ( hRes = m_pObject->GetNames ( lpwszQualifier, lFlags, NULL, &saNames ) )
	{
		#ifdef	__SUPPORT_MSGBOX
		ERRORMESSAGE_DEFINITION;
		ERRORMESSAGE_RETURN ( hRes );
		#else	__SUPPORT_MSGBOX
		___TRACE_ERROR( L"find out names of object's properties failed",hRes );
		return hRes;
		#endif	__SUPPORT_MSGBOX
	}

	// init all variables
	if ( ppPropNames )
	{
		(*ppPropNames)	= NULL;
	}

	if ( ppTypes )
	{
		(*ppTypes)		= NULL;
	}

	if ( ppScales )
	{
		(*ppScales)		= NULL;
	}

	if ( ppLevels )
	{
		(*ppLevels)		= NULL;
	}

	if ( ppCounters )
	{
		(*ppCounters)		= NULL;
	}

	// let's do something
	if ( lptszPropNeed || lptszPropNeedNot )
	{
		if ( ppPropNames )
		{
			// I need find out required properties only ( use qualifier array )

			__WrapperARRAY < LPWSTR >	help;

			if SUCCEEDED( SAFEARRAY_TO_LPWSTRARRAY ( saNames, &help, help ) )
			{
				for ( dwIndex = 0; dwIndex < help; dwIndex++ )
				{
					CIMTYPE type = CIM_EMPTY;

					if FAILED ( hRes = GetQualifierType ( help[dwIndex], &type ) )
					{
						return hRes;
					}

					switch ( type )
					{
						case CIM_SINT32:
						case CIM_UINT32:
						case CIM_SINT64:
						case CIM_UINT64:
						{
							break;
						}
						default:
						{
							// bad property type :))

							try
							{
								delete help.GetAt ( dwIndex );
								help.SetAt ( dwIndex );
							}
							catch ( ... )
							{
							}

							continue;
						}
					}

					// test if it has proper qualifier set
					CComPtr<IWbemQualifierSet> pSet;

					if SUCCEEDED ( hRes = m_pObject->GetPropertyQualifierSet ( help[dwIndex], &pSet ) )
					{
						if SUCCEEDED( hRes = IsCorrect	(	pSet,
															lptszPropNeed,
															dwPropNeed,
															lptszPropNeedNot,
															dwPropNeedNot
														)
									)
						{
							// is not correct clear this name
							if ( hRes == S_FALSE )
							{
								try
								{
									delete help.GetAt ( dwIndex );
									help.SetAt ( dwIndex );
								}
								catch ( ... )
								{
								}
							}
						}
						else
						{
							#ifdef	__SUPPORT_MSGBOX
							ERRORMESSAGE_DEFINITION;
							ERRORMESSAGE_RETURN ( hRes );
							#else	__SUPPORT_MSGBOX
							___TRACE_ERROR( L"IsCorrect failed",hRes );
							return hRes;
							#endif	__SUPPORT_MSGBOX
						}
					}
					else
					{
						#ifdef	__SUPPORT_MSGBOX
						ERRORMESSAGE_DEFINITION;
						ERRORMESSAGE_RETURN ( hRes );
						#else	__SUPPORT_MSGBOX
						___TRACE_ERROR( L"GetPropertyQualifierSet failed",hRes );
						return hRes;
						#endif	__SUPPORT_MSGBOX
					}
				}

				for ( dwIndex = 0; dwIndex < help; dwIndex++ )
				{
					if ( help[dwIndex] )
					{
						(*pdwPropNames)++;
					}
				}

				try
				{

					if ( *pdwPropNames )
					{
						if ( ( (*ppPropNames) = (LPWSTR*) new LPWSTR[ (*pdwPropNames) ] ) == NULL )
						{
							hRes =  E_OUTOFMEMORY;
						}

						// clear them all
						for ( dwIndex = 0; dwIndex < (*pdwPropNames); dwIndex++ )
						{
							(*ppPropNames)[dwIndex] = NULL;
						}

						DWORD dw = 0;

						for ( dwIndex = 0; dwIndex < help; dwIndex++ )
						{
							if ( help[dwIndex] )
							{
								if ( ( (*ppPropNames)[dw] = (LPWSTR) new WCHAR[ lstrlenW(help[dwIndex]) + 1] ) == NULL )
								{
									RELEASE_DOUBLEARRAY ( (*ppPropNames), (*pdwPropNames) );
									hRes =  E_OUTOFMEMORY;
								}

								lstrcpyW ( (*ppPropNames)[dw], help[dwIndex] );

								// increment internal index
								dw++;
							}
						}
					}
				}
				catch ( ... )
				{
					RELEASE_DOUBLEARRAY ( (*ppPropNames), (*pdwPropNames) );
					hRes =  E_UNEXPECTED;
				}
			}
			else
			{
				hRes = S_FALSE;
			}
		}
	}
	else
	{
		if ( ppPropNames )
		{
			// I don't need find out anything so all properties are returned
			if FAILED ( hRes = SAFEARRAY_TO_LPWSTRARRAY ( saNames, ppPropNames, pdwPropNames ) )
			{
				#ifdef	__SUPPORT_MSGBOX
				ERRORMESSAGE_DEFINITION;
				ERRORMESSAGE_RETURN ( hRes );
				#else	__SUPPORT_MSGBOX
				___TRACE_ERROR( L"SAFEARRAY_TO_LPWSTRARRAY failed",hRes );
				return hRes;
				#endif	__SUPPORT_MSGBOX
			}
		}
	}

	if ( hRes == S_OK )
	{
		if ( ppTypes )
		{
			try
			{
				if ( ( ( *ppTypes ) = new CIMTYPE[(*pdwPropNames)] ) == NULL )
				{
					hRes =  E_OUTOFMEMORY;
					goto myCleanup;
				}

			}
			catch ( ... )
			{
				hRes =  E_FAIL;
				goto myCleanup;
			}
		}

		// allocate all scales :))
		if ( ppScales )
		{
			try
			{
				if ( ( ( *ppScales ) = new DWORD[(*pdwPropNames)] ) == NULL )
				{
					hRes =  E_OUTOFMEMORY;
					goto myCleanup;
				}

			}
			catch ( ... )
			{
				hRes =  E_FAIL;
				goto myCleanup;
			}
		}

		// allocate all levels
		if ( ppLevels )
		{
			try
			{
				if ( ( ( *ppLevels ) = new DWORD[(*pdwPropNames)] ) == NULL )
				{
					hRes =  E_OUTOFMEMORY;
					goto myCleanup;
				}

			}
			catch ( ... )
			{
				hRes =  E_FAIL;
				goto myCleanup;
			}
		}

		// allocate all counter types
		if ( ppCounters )
		{
			try
			{
				if ( ( ( *ppCounters ) = new DWORD[(*pdwPropNames)] ) == NULL )
				{
					hRes =  E_OUTOFMEMORY;
					goto myCleanup;
				}

			}
			catch ( ... )
			{
				hRes =  E_FAIL;
				goto myCleanup;
			}
		}

		for ( dwIndex = 0; dwIndex < (*pdwPropNames); dwIndex++ )
		{
			CIMTYPE type = CIM_EMPTY;

			if FAILED ( hRes = GetQualifierType ( (*ppPropNames)[dwIndex], &type ) )
			{
				goto myCleanup;
			}

			switch ( type )
			{
				case CIM_SINT32:
				case CIM_UINT32:
				case CIM_SINT64:
				case CIM_UINT64:
				{
					if ( ppTypes )
					{
						(*ppTypes)[dwIndex] = type;
					}

					break;
				}
				default:
				{
					if ( ppTypes )
					{
						(*ppTypes)[dwIndex] = CIM_EMPTY;
					}

					break;
				}
			}

			LPWSTR szScale   = NULL;
			LPWSTR szLevel   = NULL;
			LPWSTR szCounter = NULL;

			if ( ppScales )
			{
				GetQualifierValue ( (*ppPropNames)[dwIndex], L"defaultscale", &szScale );

				if ( szScale )
				{
					( *ppScales)[dwIndex] = _wtol ( szScale );
					delete szScale;
				}
				else
				{
					( *ppScales)[dwIndex] = 0L;
				}
			}

			if ( ppLevels )
			{
				GetQualifierValue ( (*ppPropNames)[dwIndex], L"perfdetail", &szLevel );

				if ( szLevel )
				{
					( *ppLevels)[dwIndex] = _wtol ( szLevel );
					delete szLevel;
				}
				else
				{
					( *ppLevels)[dwIndex] = 0L;
				}
			}

			if ( ppCounters )
			{
				GetQualifierValue ( (*ppPropNames)[dwIndex], L"countertype", &szCounter );

				if ( szCounter )
				{
					( *ppCounters)[dwIndex] = _wtol ( szCounter );
					delete szCounter;
				}
				else
				{
					( *ppCounters)[dwIndex] = 0L;
				}
			}
		}
	}

	return hRes;

	myCleanup:

	if ( ppTypes )
	{
		delete [] (*ppTypes);
		(*ppTypes) = NULL;
	}

	if ( ppScales )
	{
		delete [] (*ppScales);
		(*ppScales) = NULL;
	}

	if ( ppLevels )
	{
		delete [] (*ppLevels);
		(*ppLevels) = NULL;
	}

	if ( ppCounters )
	{
		delete [] (*ppCounters);
		(*ppCounters) = NULL;
	}

	return hRes;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// helpers
//////////////////////////////////////////////////////////////////////////////////////////////

// qualifier type for specified property
HRESULT CPerformanceObject::GetQualifierType ( LPCWSTR wszPropName, CIMTYPE* type )
{
	HRESULT	hRes	= S_OK;

	( *type ) = NULL;

	if ( ! m_pObject )
	{
		return E_UNEXPECTED;
	}

	if FAILED ( hRes = m_pObject->Get ( wszPropName, NULL, NULL, type, NULL ) )
	{
		#ifdef	__SUPPORT_MSGBOX
		ERRORMESSAGE_DEFINITION;
		ERRORMESSAGE_RETURN ( hRes );
		#else	__SUPPORT_MSGBOX
		___TRACE_ERROR( L"Get method on object failed",hRes );
		return hRes;
		#endif	__SUPPORT_MSGBOX
	}

	return hRes;
}

// qualifier value for main object
HRESULT CPerformanceObject::GetQualifierValue ( LPCWSTR wszQualifierName, LPWSTR* psz )
{
	HRESULT	hRes	= S_OK;

	( *psz ) = NULL;

	if ( ! m_pObject )
	{
		return E_UNEXPECTED;
	}

	if ( ! m_pObjectQualifierSet )
	{
		CComPtr<IWbemQualifierSet> pQualifiers;

		if FAILED ( hRes = m_pObject->GetQualifierSet ( &pQualifiers ) )
		{
			#ifdef	__SUPPORT_MSGBOX
			ERRORMESSAGE_DEFINITION;
			ERRORMESSAGE_RETURN ( hRes );
			#else	__SUPPORT_MSGBOX
			___TRACE_ERROR( L"GetQualifierSet on object failed",hRes );
			return hRes;
			#endif	__SUPPORT_MSGBOX
		}

		( m_pObjectQualifierSet = pQualifiers ) -> AddRef ();
	}

	return GetQualifierValue ( m_pObjectQualifierSet, wszQualifierName, psz );
}

// qualifier value for specified property
HRESULT CPerformanceObject::GetQualifierValue ( LPCWSTR wszPropName, LPCWSTR wszQualifierName, LPWSTR* psz )
{
	HRESULT	hRes	= S_OK;

	( *psz ) = NULL;

	if ( ! m_pObject )
	{
		return E_UNEXPECTED;
	}

	CComPtr<IWbemQualifierSet> pQualifiers;

	if FAILED ( hRes = m_pObject->GetPropertyQualifierSet ( wszPropName, &pQualifiers ) )
	{
		#ifdef	__SUPPORT_MSGBOX
		ERRORMESSAGE_DEFINITION;
		ERRORMESSAGE_RETURN ( hRes );
		#else	__SUPPORT_MSGBOX
		___TRACE_ERROR( L"GetPropertyQualifierSet on object failed",hRes );
		return hRes;
		#endif	__SUPPORT_MSGBOX
	}

	return GetQualifierValue ( pQualifiers, wszQualifierName, psz );
}

// return qualifier value in string representation ( helper )
HRESULT CPerformanceObject::GetQualifierValue ( IWbemQualifierSet * pSet, LPCWSTR wszQualifierName, LPWSTR * psz )
{
	(*psz) = NULL;

	CComVariant var;
	CComVariant varDest;

	HRESULT hRes = S_OK;

	CComBSTR bstrQualifierName = wszQualifierName;
	if FAILED ( hRes = pSet->Get ( bstrQualifierName, NULL, &var, NULL ) )
	{
		return hRes;
	}

	try
	{
		if SUCCEEDED ( ::VariantChangeType ( &varDest, &var, VARIANT_NOVALUEPROP , VT_BSTR) )
		{
			try
			{
				if ( ( (*psz) = (LPWSTR) new WCHAR[ ( ::SysStringLen( V_BSTR(&varDest) ) + 1 ) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				lstrcpyW ( (*psz), V_BSTR( &varDest ) );
			}
			catch ( ... )
			{
				delete (*psz);
				(*psz) = NULL;

				return E_UNEXPECTED;
			}
		}
	}
	catch ( ... )
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}

HRESULT CPerformanceObject::GetPropertyValue ( LPCWSTR wszPropertyName, LPWSTR * psz )
{
	if ( ! m_pObject )
	{
		return E_UNEXPECTED;
	}

	(*psz) = NULL;

	CComVariant var;
	CComVariant varDest;

	HRESULT hRes = S_OK;

	CComBSTR bstrPropertyName = wszPropertyName;
	if FAILED ( hRes = m_pObject->Get ( bstrPropertyName, NULL, &var, NULL, NULL ) )
	{
		#ifdef	__SUPPORT_MSGBOX
		ERRORMESSAGE_DEFINITION;
		ERRORMESSAGE_RETURN ( hRes );
		#else	__SUPPORT_MSGBOX
		___TRACE_ERROR( L"Get method on object failed",hRes );
		return hRes;
		#endif	__SUPPORT_MSGBOX
	}

	try
	{
		if SUCCEEDED ( ::VariantChangeType ( &varDest, &var, VARIANT_NOVALUEPROP , VT_BSTR) )
		{
			try
			{
				if ( ( (*psz) = (LPWSTR) new WCHAR[ ( ::SysStringLen( V_BSTR(&varDest) ) + 1 ) ] ) == NULL )
				{
					return E_OUTOFMEMORY;
				}

				lstrcpyW ( (*psz), V_BSTR( &varDest ) );
			}
			catch ( ... )
			{
				delete (*psz);
				(*psz) = NULL;

				return E_UNEXPECTED;
			}
		}
	}
	catch ( ... )
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_generate_ini.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_generate_ini.cpp
//
//	Abstract:
//
//					implements generate functionality ( generate ini file )
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <throttle.h>

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// definitions
#include "wmi_perf_generate.h"
// generate comments
#include "wmi_perf_generate_comment.h"
// registry helpers
#include "wmi_perf_reg.h"

// resources
#include "resource.h"
#include "__macro_Loadstring.h"

// constants
extern LPCWSTR	cDriverName;
extern LPCWSTR	cSymbolFile;

extern LPCWSTR	cSIGN;
extern LPCWSTR	cNEW;

extern LPCWSTR	cinfo;
extern LPCWSTR	clanguages;
extern LPCWSTR	cobjects;
extern LPCWSTR	ctext;

extern	LPCWSTR	cNAME;
extern	LPCWSTR	cHELP;

extern LPCWSTR	cWMIOBJECTS;
extern LPCWSTR	cWMIOBJECTS_COUNT;
extern LPCWSTR	cWMIOBJECTS_VALIDITY;

extern LPCWSTR	cWMIOBJECTS_NAME;
extern LPCWSTR	cWMIOBJECTS_COUNT_NAME;
extern LPCWSTR	cWMIOBJECTS_VALIDITY_NAME;

extern LPCWSTR	cWMIOBJECTS_HELP;
extern LPCWSTR	cWMIOBJECTS_COUNT_HELP;
extern LPCWSTR	cWMIOBJECTS_VALIDITY_HELP;

LPWSTR	CGenerate::GenerateLanguage ( LCID lcid )
{
	WCHAR szLanguage[256] = { L'\0' };
	GetLocaleInfoW ( lcid, LOCALE_SENGLANGUAGE, szLanguage, 256 );

	int		show	= PRIMARYLANGID(LANGIDFROMLCID(lcid));
	LPWSTR	sz		= NULL;

	try
	{
		if ( ( sz = new WCHAR [ lstrlenW ( szLanguage ) + 3 + 3 + 1 ] ) != NULL )
		{
			wsprintfW ( sz, L"%03x=%s\r\n", show, szLanguage );
		}
	}
	catch ( ... )
	{
		if ( sz )
		{
			delete [] sz;
			sz = NULL;
		}
	}

	return sz;
}

LPWSTR	CGenerate::GenerateName ( LPCWSTR wszName, LCID lcid )
{
	int		show	= PRIMARYLANGID(LANGIDFROMLCID(lcid));
	LPWSTR	sz		= NULL;

	try
	{
		if ( ( sz = new WCHAR [ lstrlenW ( wszName ) + 2 + 3 + 1 ] ) != NULL )
		{
			wsprintfW ( sz, L"%s_%03x_", wszName, show );
		}
	}
	catch ( ... )
	{
		if ( sz )
		{
			delete [] sz;
			sz = NULL;
		}
	}

	return sz;
}

HRESULT CGenerate::CreateObjectList ( BOOL bThrottle )
{
	HRESULT hRes = E_FAIL;

	// start with [objects]		... cobjects
	if SUCCEEDED ( hRes = AppendString ( cobjects ) )
	{
		// loop variable
		DWORD	dw			= 0L;
		DWORD	dwIndex		= 0L;
		DWORD	dwObjIndex	= 0L;

		LPWSTR wszName	= NULL;
		LPWSTR wsz		= NULL;

		try
		{
			// pseudo counter
			if ( m_dwlcid == 2 )
			{
				HMODULE hModule = NULL;
				hModule = ::LoadLibraryW ( L"WMIApRes.dll" );

				if ( hModule )
				{
					wszName = GenerateName ( cWMIOBJECTS, m_lcid[dw] );
					if ( wszName != NULL )
					{

						if SUCCEEDED ( hRes = AppendString ( wszName ) )
						{
							if SUCCEEDED ( hRes = AppendString ( cNAME ) )
							{
								if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
								{
									wsz = LoadStringSystem ( hModule, IDS_cWMIOBJECTS_NAME );
									if ( wsz != NULL )
									{
										if SUCCEEDED ( hRes = AppendString ( wsz ) )
										{
											hRes = AppendString ( cNEW );
										}

										delete [] wsz;
										wsz = NULL;
									}
									else
									{
										hRes = E_OUTOFMEMORY;
									}
								}
							}
						}

						delete [] wszName;
						wszName = NULL;
					}
					else
					{
						hRes = E_OUTOFMEMORY;
					}

					// free resources cause we are done
					::FreeLibrary ( hModule );
				}
				else
				{
					hRes = E_FAIL;
				}

				dw++;
			}

			if SUCCEEDED ( hRes )
			{
				wszName = GenerateName ( cWMIOBJECTS, m_lcid[dw] );
				if ( wszName != NULL )
				{
					if SUCCEEDED ( hRes = AppendString ( wszName ) )
					{
						if SUCCEEDED ( hRes = AppendString ( cWMIOBJECTS_NAME ) )
						{
							hRes = AppendString ( cNEW );
						}
					}

					delete [] wszName;
					wszName = NULL;
				}
				else
				{
					hRes = E_OUTOFMEMORY;
				}
			}

			// real WMI objects
			for (	dw = 0;
					dw < m_dwNamespaces && SUCCEEDED ( hRes );
					dw++
				)
			{
				if ( ! m_pNamespaces[dw].m_ppObjects.empty() )
				{
					try
					{
						for (	mapOBJECTit it = m_pNamespaces[dw].m_ppObjects.begin();
								it != m_pNamespaces[dw].m_ppObjects.end() && SUCCEEDED ( hRes );
								it++, dwObjIndex++
							)
						{
							// resolve objects
							for (	dwIndex = 0;
									dwIndex < m_dwlcid && SUCCEEDED ( hRes );
									dwIndex++
								)
							{
								LPWSTR wszNameInd = NULL;
								wszNameInd = GenerateNameInd ( (*it).second->GetName(), dwObjIndex );

								if ( wszNameInd )
								{
									LPWSTR	szObject = NULL;
									szObject = GenerateName( wszNameInd, m_lcid[dwIndex] );

									delete [] wszNameInd;
									wszNameInd = NULL;

									if ( szObject )
									{
										if SUCCEEDED ( hRes = AppendString ( szObject ) )
										{
											if SUCCEEDED ( hRes = AppendString ( cNAME ) )
											{
												if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
												{
													if SUCCEEDED ( hRes = AppendString ( ((*it).second->GetArrayLocale())[dwIndex]->GetDisplayName() ) )
													{
														hRes = AppendString ( cNEW );
													}
												}
											}
										}

										delete [] szObject;
										szObject = NULL;
									}
									else
									{
										hRes = E_OUTOFMEMORY;
									}
								}
								else
								{
									hRes = E_OUTOFMEMORY;
								}
							}

							if ( bThrottle && SUCCEEDED ( hRes ) )
							{
								Throttle	(
												THROTTLE_ALLOWED_FLAGS,
												1000,
												100,
												10,
												3000
											);
							}
						}
					}
					catch ( ... )
					{
						hRes = E_UNEXPECTED;
					}
				}
			}
		}
		catch ( ... )
		{
			if ( wsz )
			{
				delete [] wsz;
				wsz = NULL;
			}

			if ( wszName )
			{
				delete [] wszName;
				wszName = NULL;
			}

			hRes = E_UNEXPECTED;
		}
	}

	// finish with [text]		... ctext
	if SUCCEEDED ( hRes )
	{
		hRes = AppendString ( cNEW );

		if SUCCEEDED ( hRes )
		{
			hRes = AppendString ( ctext );
		}
	}

	return hRes;
}

HRESULT CGenerate::GenerateFile_ini( LPCWSTR wszModuleName, BOOL bThrottle, int type )
{
	HRESULT hRes = E_UNEXPECTED;

	if ( ( wszModuleName != 0 && *wszModuleName != 0 ) && ( type != Normal || m_dwNamespaces != 0 ) )
	{
		LPWSTR	wszModule = NULL;

		try
		{
			if ( ( wszModule = new WCHAR [ lstrlenW ( wszModuleName ) + 8 + 1 ] ) == NULL )
			{
				hRes = E_OUTOFMEMORY;
			}
			else
			{
				lstrcpyW ( wszModule, wszModuleName );
				lstrcatW ( wszModule, L"_new.ini" );

				if SUCCEEDED ( hRes = FileCreate ( wszModule ) )
				{
					hRes			= E_FAIL;
					DWORD dwWritten = 0L;

					if ( ::WriteFile	(	m_hFile,
											UNICODE_SIGNATURE,
											2,
											&dwWritten,
											NULL
										)
					   )
					{
						hRes = S_OK;

						// do comment stuff
						CGenerateComment comment;

						comment.AddHeader();
						comment.AddLine();
						comment.AddLine( L"Copyright (C) 2000 Microsoft Corporation" );
						comment.AddLine();
						comment.AddLine( L"Module Name:" );
						comment.AddLine( wszModuleName );
						comment.AddLine();
						comment.AddLine( L"Abstract:" );
						comment.AddLine();
						comment.AddLine( L"Describes all the counters supported via WMI Hi-Performance providers" );
						comment.AddLine();
						comment.AddFooter();

						try
						{
							comment.Add ( );
							comment.Add ( cinfo );
							comment.Add ( cDriverName );
							comment.Add ( wszModuleName );
							comment.Add ( );
							comment.Add ( cSymbolFile );
							comment.Add ( wszModuleName );
							comment.Add ( L".h" );
							comment.Add ( );

							comment.Add ( );
							comment.Add ( clanguages );

							DWORD dwIndex = 0;

							for ( dwIndex = 0; dwIndex < m_dwlcid; dwIndex++ )
							{
								LPWSTR	lang = NULL;
								lang = GenerateLanguage ( m_lcid[dwIndex] );

								if ( lang )
								{
									comment.Add ( lang );

									delete [] lang;
									lang = NULL;
								}
								else
								{
									hRes = E_OUTOFMEMORY;
								}
							}

							comment.Add ( );
						}
						catch ( ... )
						{
							hRes = E_FAIL;
						}

						if SUCCEEDED ( hRes )
						{
							hRes = WriteToFileUnicode ( comment.GetComment() );

							if SUCCEEDED ( hRes )
							{
								hRes = CreateObjectList ( bThrottle );
							}
						}
					}
				}
			}
		}
		catch ( ... )
		{
			hRes = E_FAIL;
		}

		if SUCCEEDED ( hRes )
		{
			// generate pseudo counter
			// which language am using
			DWORD dw = 0;

			if ( m_dwlcid == 2 )
			{
				HMODULE hModule = NULL;
				hModule = ::LoadLibraryW ( L"WMIApRes.dll" );

				if ( hModule )
				{
					LPWSTR wszName = NULL;

					wszName = GenerateName ( cWMIOBJECTS, m_lcid[dw] );
					if ( wszName != NULL )
					{
						LPWSTR wsz = NULL;

						if SUCCEEDED ( hRes = AppendString ( wszName ) )
						{
							if SUCCEEDED ( hRes = AppendString ( cNAME ) )
							{
								if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
								{
									wsz = LoadStringSystem ( hModule, IDS_cWMIOBJECTS_NAME );
									if ( wsz != NULL )
									{
										if SUCCEEDED ( hRes = AppendString ( wsz ) )
										{
											hRes = AppendString ( cNEW );
										}

										delete [] wsz;
										wsz = NULL;
									}
									else
									{
										hRes = E_OUTOFMEMORY;
									}
								}
							}
						}

						if SUCCEEDED ( hRes )
						{
						if SUCCEEDED ( hRes = AppendString ( wszName ) )
						{
							if SUCCEEDED ( hRes = AppendString ( cHELP ) )
							{
								if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
								{
									wsz = LoadStringSystem ( hModule, IDS_cWMIOBJECTS_HELP );
									if ( wsz != NULL )
									{
										if SUCCEEDED ( hRes = AppendString ( wsz ) )
										{
											hRes = AppendString ( cNEW );
										}

										delete [] wsz;
										wsz = NULL;
									}
									else
									{
										hRes = E_OUTOFMEMORY;
									}
								}
							}
						}
						}
					}
					else
					{
						hRes = E_OUTOFMEMORY;
					}

					// free resources cause we are done
					::FreeLibrary ( hModule );
				}
				else
				{
					hRes = E_FAIL;
				}

				dw++;
			}

			if SUCCEEDED ( hRes )
			{
				LPWSTR wszName = NULL;

				wszName = GenerateName ( cWMIOBJECTS, m_lcid[dw] );
				if ( wszName != NULL )
				{
					if SUCCEEDED ( hRes = AppendString ( wszName ) )
					{
						if SUCCEEDED ( hRes = AppendString ( cWMIOBJECTS_NAME ) )
						{
							hRes = AppendString ( cNEW );
						}
					}

					if SUCCEEDED ( hRes )
					{
					if SUCCEEDED ( hRes = AppendString ( wszName ) )
					{
						if SUCCEEDED ( hRes = AppendString ( cWMIOBJECTS_HELP ) )
						{
							hRes = AppendString ( cNEW );
						}
					}
					}

					delete [] wszName;
					wszName = NULL;
				}
				else
				{
					hRes = E_OUTOFMEMORY;
				}
			}

			if SUCCEEDED ( hRes )
			{
				hRes = AppendString ( cNEW );
			}
		}

		// init helper variable
		DWORD dwIndex		= 0;
		DWORD dwIndexProp	= 0;

		DWORD	dwObjIndex		= 0;
		DWORD	dwObjIndexOld	= 0;

		if ( SUCCEEDED ( hRes ) && ( type != Registration ) )
		{
			for (	DWORD dw = 0;
					dw < m_dwNamespaces && SUCCEEDED ( hRes );
					dw++
				)
			{
				if ( ! m_pNamespaces[dw].m_ppObjects.empty() )
				{
					try
					{
						for (	mapOBJECTit it = m_pNamespaces[dw].m_ppObjects.begin();
								it != m_pNamespaces[dw].m_ppObjects.end() && SUCCEEDED ( hRes );
								it++, dwObjIndex++
							)
						{
							// resolve objects
							for (	dwIndex = 0;
									dwIndex < m_dwlcid && SUCCEEDED ( hRes );
									dwIndex++
								)
							{
								LPWSTR wszNameInd = NULL;
								wszNameInd = GenerateNameInd ( (*it).second->GetName(), dwObjIndex );

								if ( wszNameInd )
								{
									LPWSTR	szObject = NULL;
									szObject = GenerateName( wszNameInd, m_lcid[dwIndex] );

									delete [] wszNameInd;
									wszNameInd = NULL;

									if ( szObject )
									{
										if SUCCEEDED ( hRes = AppendString ( szObject ) )
										{
											if SUCCEEDED ( hRes = AppendString ( cNAME ) )
											{
												if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
												{
													if SUCCEEDED ( hRes = AppendString ( ((*it).second->GetArrayLocale())[dwIndex]->GetDisplayName() ) )
													{
														if SUCCEEDED ( hRes = AppendString ( cNEW ) )
														{
															if SUCCEEDED ( hRes = AppendString ( szObject ) )
															{
																if SUCCEEDED ( hRes = AppendString ( cHELP ) )
																{
																	if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
																	{
																		if SUCCEEDED ( hRes = AppendString ( ((*it).second->GetArrayLocale())[dwIndex]->GetDescription() ) )
																		{
																			hRes = AppendString ( cNEW );
																		}
																	}
																}
															}
														}
													}
												}
											}
										}

										delete [] szObject;
										szObject = NULL;
									}
									else
									{
										hRes = E_OUTOFMEMORY;
									}
								}
								else
								{
									hRes = E_OUTOFMEMORY;
								}
							}

							if SUCCEEDED ( hRes )
							{
								hRes = AppendString ( cNEW );
							}

							if ( bThrottle && SUCCEEDED ( hRes ) )
							{
								Throttle	(
												THROTTLE_ALLOWED_FLAGS,
												1000,
												100,
												10,
												3000
											);
							}
						}
					}
					catch ( ... )
					{
						hRes = E_UNEXPECTED;
					}
				}
			}
		}

		// generate pseudo counter properties
		if SUCCEEDED ( hRes )
		{
			// which language am using
			DWORD dw = 0;

			if ( m_dwlcid == 2 )
			{
				HMODULE hModule = NULL;
				hModule = ::LoadLibraryW ( L"WMIApRes.dll" );

				if ( hModule )
				{
					LPWSTR wszName = NULL;

					wszName = GenerateName ( cWMIOBJECTS_COUNT, m_lcid[dw] );
					if ( wszName != NULL )
					{
						LPWSTR wsz = NULL;

						if SUCCEEDED ( hRes = AppendString ( wszName ) )
						{
							if SUCCEEDED ( hRes = AppendString ( cNAME ) )
							{
								if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
								{
									wsz = LoadStringSystem ( hModule, IDS_cWMIOBJECTS_COUNT_NAME );
									if ( wsz != NULL )
									{
										if SUCCEEDED ( hRes = AppendString ( wsz ) )
										{
											hRes = AppendString ( cNEW );
										}

										delete [] wsz;
										wsz = NULL;
									}
									else
									{
										hRes = E_OUTOFMEMORY;
									}
								}
							}
						}

						if SUCCEEDED ( hRes )
						{
						if SUCCEEDED ( hRes = AppendString ( wszName ) )
						{
							if SUCCEEDED ( hRes = AppendString ( cHELP ) )
							{
								if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
								{
									wsz = LoadStringSystem ( hModule, IDS_cWMIOBJECTS_COUNT_HELP );
									if ( wsz != NULL )
									{
										if SUCCEEDED ( hRes = AppendString ( wsz ) )
										{
											hRes = AppendString ( cNEW );
										}

										delete [] wsz;
										wsz = NULL;
									}
									else
									{
										hRes = E_OUTOFMEMORY;
									}
								}
							}
						}
						}
					}
					else
					{
						hRes = E_OUTOFMEMORY;
					}

					if SUCCEEDED ( hRes )
					{
						hRes = AppendString ( cNEW );
					}

					if SUCCEEDED ( hRes )
					{
						LPWSTR wszName = NULL;

						wszName = GenerateName ( cWMIOBJECTS_VALIDITY, m_lcid[dw] );
						if ( wszName != NULL )
						{
							LPWSTR wsz = NULL;

							if SUCCEEDED ( hRes = AppendString ( wszName ) )
							{
								if SUCCEEDED ( hRes = AppendString ( cNAME ) )
								{
									if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
									{
										wsz = LoadStringSystem ( hModule, IDS_cWMIOBJECTS_VALIDITY_NAME );
										if ( wsz != NULL )
										{
											if SUCCEEDED ( hRes = AppendString ( wsz ) )
											{
												hRes = AppendString ( cNEW );
											}

											delete [] wsz;
											wsz = NULL;
										}
										else
										{
											hRes = E_OUTOFMEMORY;
										}
									}
								}
							}

							if SUCCEEDED ( hRes )
							{
							if SUCCEEDED ( hRes = AppendString ( wszName ) )
							{
								if SUCCEEDED ( hRes = AppendString ( cHELP ) )
								{
									if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
									{
										wsz = LoadStringSystem ( hModule, IDS_cWMIOBJECTS_VALIDITY_HELP );
										if ( wsz != NULL )
										{
											if SUCCEEDED ( hRes = AppendString ( wsz ) )
											{
												hRes = AppendString ( cNEW );
											}

											delete [] wsz;
											wsz = NULL;
										}
										else
										{
											hRes = E_OUTOFMEMORY;
										}
									}
								}
							}
							}
						}
						else
						{
							hRes = E_OUTOFMEMORY;
						}
					}

					// free resources cause we are done
					::FreeLibrary ( hModule );
				}
				else
				{
					hRes = E_FAIL;
				}

				dw++;
			}

			if SUCCEEDED ( hRes )
			{
				LPWSTR wszName = NULL;

				wszName = GenerateName ( cWMIOBJECTS_COUNT, m_lcid[dw] );
				if ( wszName != NULL )
				{
					if SUCCEEDED ( hRes = AppendString ( wszName ) )
					{
						hRes = AppendString ( cWMIOBJECTS_COUNT_NAME );
					}

					if SUCCEEDED ( hRes )
					{
					if SUCCEEDED ( hRes = AppendString ( cNEW ) )
					{
						if SUCCEEDED ( hRes = AppendString ( wszName ) )
						{
							hRes = AppendString ( cWMIOBJECTS_COUNT_HELP );
						}
					}
					}

					delete [] wszName;
					wszName = NULL;
				}
				else
				{
					hRes = E_OUTOFMEMORY;
				}

				if SUCCEEDED ( hRes )
				{
					hRes = AppendString ( cNEW );
				}

				if SUCCEEDED ( hRes )
				{
					LPWSTR wszName = NULL;

					wszName = GenerateName ( cWMIOBJECTS_VALIDITY, m_lcid[dw] );
					if ( wszName != NULL )
					{
						if SUCCEEDED ( hRes = AppendString ( cNEW ) )
						{
							if SUCCEEDED ( hRes = AppendString ( wszName ) )
							{
								hRes = AppendString ( cWMIOBJECTS_VALIDITY_NAME );
							}
						}

						if SUCCEEDED ( hRes )
						{
						if SUCCEEDED ( hRes = AppendString ( cNEW ) )
						{
							if SUCCEEDED ( hRes = AppendString ( wszName ) )
							{
								hRes = AppendString ( cWMIOBJECTS_VALIDITY_HELP );
							}
						}
						}

						delete [] wszName;
						wszName = NULL;
					}
					else
					{
						hRes = E_OUTOFMEMORY;
					}
				}
			}
		}

		if ( SUCCEEDED ( hRes ) && ( type != Registration ) )
		{
			hRes		= AppendString ( cNEW );
			dwObjIndex	= dwObjIndexOld;

			for (	DWORD dw = 0;
					dw < m_dwNamespaces && SUCCEEDED ( hRes );
					dw++
				)
			{
				if ( ! m_pNamespaces[dw].m_ppObjects.empty() )
				{
					try
					{
						if SUCCEEDED ( hRes )
						{
							hRes = AppendString ( cNEW );
						}

						for (	mapOBJECTit it = m_pNamespaces[dw].m_ppObjects.begin();
								it != m_pNamespaces[dw].m_ppObjects.end() && SUCCEEDED ( hRes );
								it++, dwObjIndex++
							)
						{
							// resolve counters
							for (	dwIndexProp = 0;
									dwIndexProp < (*it).second->GetArrayProperties() && SUCCEEDED ( hRes );
									dwIndexProp++
								)
							{
								// do I have a locales for property ???
								if ( !((*it).second->GetArrayProperties())[dwIndexProp]->GetArrayLocale().IsEmpty() )
								{
									// I have so this is not hidden counter !!!
									for (	dwIndex = 0;
											dwIndex < m_dwlcid && SUCCEEDED ( hRes );
											dwIndex++
										)
									{
										LPWSTR wszNameInd = NULL;
										wszNameInd = GenerateNameInd ( (*it).second->GetArrayProperties()[dwIndexProp]->GetName(), dwObjIndex );

										if ( wszNameInd )
										{
											LPWSTR	szObject = NULL;
											szObject = GenerateName( wszNameInd, m_lcid[dwIndex] );

											delete [] wszNameInd;
											wszNameInd = NULL;

											if ( szObject )
											{
												if SUCCEEDED ( hRes = AppendString ( szObject ) )
												{
													if SUCCEEDED ( hRes = AppendString ( cNAME ) )
													{
														if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
														{
															if SUCCEEDED ( hRes = AppendString ( ((*it).second->GetArrayProperties())[dwIndexProp]->GetArrayLocale()[dwIndex]->GetDisplayName() ) )
															{
																if SUCCEEDED ( hRes = AppendString ( cNEW ) )
																{
																	if SUCCEEDED ( hRes = AppendString ( szObject ) )
																	{
																		if SUCCEEDED ( hRes = AppendString ( cHELP ) )
																		{
																			if SUCCEEDED ( hRes = AppendString ( cSIGN ) )
																			{
																				if SUCCEEDED ( hRes = AppendString ( ((*it).second->GetArrayProperties())[dwIndexProp]->GetArrayLocale()[dwIndex]->GetDescription() ) )
																				{
																					hRes = AppendString ( cNEW );
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}

												delete [] szObject;
												szObject = NULL;
											}
											else
											{
												hRes = E_OUTOFMEMORY;
											}
										}
										else
										{
											hRes = E_OUTOFMEMORY;
										}
									}

									if SUCCEEDED ( hRes )
									{
										hRes = AppendString ( cNEW );
									}
								}
							}

							if ( bThrottle && SUCCEEDED ( hRes ) )
							{
								Throttle	(
												THROTTLE_ALLOWED_FLAGS,
												1000,
												100,
												10,
												3000
											);
							}
						}
					}
					catch ( ... )
					{
						hRes = E_UNEXPECTED;
					}
				}
			}
		}

		if SUCCEEDED ( hRes )
		{
			if SUCCEEDED ( hRes = ContentWrite () )
			{
				LPWSTR	wszModuleNew = NULL;

				try
				{
					if ( ( wszModuleNew = new WCHAR [ lstrlenW ( wszModuleName ) + 4 + 1 ] ) == NULL )
					{
						hRes = E_OUTOFMEMORY;
					}
					else
					{
						lstrcpyW ( wszModuleNew, wszModuleName );
						lstrcatW ( wszModuleNew, L".ini" );

						// make changes
						hRes = FileMove ( wszModule, wszModuleNew );
					}
				}
				catch ( ... )
				{
					hRes = E_FAIL;
				}

				if ( wszModuleNew )
				{
					delete [] wszModuleNew;
					wszModuleNew = NULL;
				}
			}

			if FAILED ( hRes )
			{
				// revert changes
				ContentDelete ( );
				FileDelete ( wszModule );
			}
		}
		else
		{
			// revert changes
			ContentDelete ( );
			FileDelete ( wszModule );
		}

		if ( wszModule )
		{
			delete [] wszModule;
			wszModule = NULL;
		}
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmireverseadapter\common.inc ===
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

WMI_PERFORMANCE_INC = $(ADAPTERS)\WmiReversePerformanceMonitor\Include

WMI_PERFORMANCE_REFRESH_INC = $(ADAPTERS)\WmiReversePerformanceMonitor\WMIAdapter_Refresh
WMI_PERFORMANCE_REFRESH_LIB = $(ADAPTERS)\WmiReversePerformanceMonitor\System\$(O)\WmiApRef.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_object_global.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_object_global.cpp
//
//	Abstract:
//
//					definitions of global object structure
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

// definitions
#include "wmi_perf_object_global.h"
// enum hiperfs
#include "wmi_perf_object_enum.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

// extern constant
extern	LPCWSTR	g_szPropFilter;
extern	LPCWSTR	g_szPropNeed[];
extern	LPCWSTR	g_szPropNeedNot[];

extern	DWORD	g_dwPropNeed;
extern	DWORD	g_dwPropNeedNot;

extern	LONG	g_lFlagProperties;

extern	LPCWSTR	g_szQueryLang;

extern	LPCWSTR	g_szFulFil[];
extern	LPCWSTR	g_szFulFilNot[];

extern	DWORD	g_dwFulFil;
extern	DWORD	g_dwFulFilNot;

extern	LONG	g_lFlag;

HRESULT CObjectGlobal::GenerateObjects ( IWbemServices * pService, LPCWSTR szQuery, BOOL bAmended )
{
	HRESULT					hRes = S_OK;
	CPerformanceObjectEnum	myEnum(pService);

	LONG lFlag = g_lFlag;

	if ( bAmended )
	{
		lFlag |= WBEM_FLAG_USE_AMENDED_QUALIFIERS;
	}

	if FAILED ( hRes = myEnum.ExecQuery ( g_szQueryLang, szQuery, lFlag ) )
	{
		#ifdef	__SUPPORT_MSGBOX
		ERRORMESSAGE_DEFINITION;
		ERRORMESSAGE_RETURN ( hRes );
		#else	__SUPPORT_MSGBOX
		___TRACE_ERROR( L"Exec query for providers failed",hRes );
		return hRes;
		#endif	__SUPPORT_MSGBOX
	}

	while ( hRes == WBEM_S_NO_ERROR )
	{
		__WrapperPtr<CPerformanceObject> obj;

		if ( ( hRes = myEnum.NextObject (	g_szFulFil,
											g_dwFulFil,
											g_szFulFilNot,
											g_dwFulFilNot,
											&obj
										)
			 ) == S_OK
		   )
		{
			if ( bAmended )
			{
				// I have all clasess for main namespace with amended qualifiers

				// get class name of object !!!
				__Wrapper<WCHAR> wszObjName = NULL;

				if FAILED ( hRes = obj->GetPropertyValue( L"__CLASS", &wszObjName) )
				{
					return hRes;
				}

				// get all properties of object !!!
				LPWSTR*		pwszProperties	= NULL;
				CIMTYPE*	pTypes			= NULL;
				DWORD*		pScales			= NULL;
				DWORD*		pLevels			= NULL;
				DWORD*		pCounters		= NULL;

				DWORD	dwProperties	= 0;

				LPWSTR*	pwszKeys	= NULL;
				DWORD	dwKeys		= 0;

				hRes = obj->GetNames (	&dwProperties,
										&pwszProperties,
										&pTypes,
										&pScales,
										&pLevels,
										&pCounters,
										g_lFlagProperties | WBEM_FLAG_ONLY_IF_TRUE,
										g_szPropNeed,
										g_dwPropNeed,
										NULL,
										NULL,
										g_szPropFilter
									 );

				if ( hRes == S_OK )
				{
					hRes = obj->GetNames (	&dwKeys,
											&pwszKeys,
											NULL,
											NULL,
											NULL,
											NULL,
											g_lFlagProperties | WBEM_FLAG_KEYS_ONLY ,
											NULL,
											NULL,
											NULL,
											NULL
										 );

					if ( hRes == S_OK )
					{
						// create object wrapper
						CObject* pGenObject = NULL;

						try
						{
							if ( ( pGenObject = new CObject() ) != NULL )
							{
								// set name of object
								pGenObject->SetName ( wszObjName.Detach() );

								// set keys of object
								pGenObject->SetArrayKeys ( pwszKeys, dwKeys );

								// set detail level for objects
								LPWSTR szDetailLevel = NULL;
								obj->GetQualifierValue ( L"perfdetail", &szDetailLevel );

								if ( szDetailLevel )
								{
									pGenObject->dwDetailLevel = _wtol ( szDetailLevel );
									delete szDetailLevel;
								}
								else
								{
									pGenObject->dwDetailLevel = 0;
								}

								// set properties
								if FAILED ( hRes = pGenObject->SetProperties (	obj,
																				pwszProperties,
																				pTypes,
																				pScales,
																				pLevels,
																				pCounters,
																				dwProperties ) )
								{
									// just trace we have failure
									___TRACE_ERROR( L"set properties to object failed",hRes );

									// clear stuff
									delete pGenObject;
									pGenObject = NULL;
								}
							}
							else
							{
								hRes = E_OUTOFMEMORY;
							}
						}
						catch ( ... )
						{
							if ( pGenObject )
							{
								delete pGenObject;
								pGenObject = NULL;
							}

							hRes = E_UNEXPECTED;
						}

						delete [] pTypes;
						delete [] pScales;
						delete [] pLevels;
						delete [] pCounters;

						RELEASE_DOUBLEARRAY ( pwszProperties, dwProperties );

						if SUCCEEDED ( hRes )
						{
							// add object into array
							if SUCCEEDED ( hRes = AddObject ( pGenObject ) )
							{
								// I'm amended ( fill apropriate locale information )
								if FAILED ( hRes = ResolveLocale ( pGenObject, obj ) )
								{
									// just trace we have failure
									___TRACE_ERROR( L"resolve object locale failed",hRes );
								}
							}
							else
							{
								if ( pGenObject )
								{
									delete pGenObject;
									pGenObject = NULL;
								}

								// just trace we have failure
								___TRACE_ERROR( L"add object description to list failed",hRes );
							}
						}
						else
						{
							RELEASE_DOUBLEARRAY ( pwszKeys, dwKeys );
						}
					}
					else
					{
						delete [] pTypes;
						delete [] pScales;
						delete [] pLevels;
						delete [] pCounters;

						RELEASE_DOUBLEARRAY ( pwszProperties, dwProperties );
						RELEASE_DOUBLEARRAY ( pwszKeys, dwKeys );
					}
				}
				else
				{
					delete [] pTypes;
					delete [] pScales;
					delete [] pLevels;
					delete [] pCounters;

					RELEASE_DOUBLEARRAY ( pwszProperties, dwProperties );
					RELEASE_DOUBLEARRAY ( pwszKeys, dwKeys );
				}

				if ( hRes == S_FALSE )
				{
					hRes = WBEM_S_NO_ERROR;
				}
			}
			else
			{
				// I have all classes from another namespace :))

				// get class name of object !!!
				__Wrapper<WCHAR> wszObjName = NULL;

				if SUCCEEDED ( hRes = obj->GetPropertyValue( L"__CLASS", &wszObjName) )
				{
					// try to find
					try
					{
						mapOBJECTit it = m_ppObjects.find ( wszObjName );

						if ( it != m_ppObjects.end() )
						{
							// founded :)))
							if FAILED ( hRes = ResolveLocale ( (*it).second, obj ) )
							{
								// just trace we have failure
								___TRACE_ERROR( L"resolve object locale failed",hRes );
							}
						}
					}
					catch ( ... )
					{
						hRes = E_FAIL;
					}
				}
			}
		}
	}

	return hRes;
}

HRESULT	CObjectGlobal::ResolveLocale ( CObject* pGenObj, CPerformanceObject* obj )
{
	__WrapperPtr<CLocale> pLocale;

	try
	{
		if ( pLocale.SetData ( new CLocale() ),
			 pLocale == NULL )
		{
			return E_OUTOFMEMORY;
		}

		// resolve apropriate display name
		__Wrapper< WCHAR >	szDisplayName;
		obj->GetQualifierValue(L"displayname", &szDisplayName);

		if ( ! szDisplayName )
		{
			try
			{
				if ( szDisplayName.SetData( new WCHAR[ lstrlenW ( pGenObj->GetName() ) + 1 ] ), 
					 szDisplayName == NULL )
				{
					return E_OUTOFMEMORY;
				}

				lstrcpyW ( szDisplayName, pGenObj->GetName() );
			}
			catch ( ... )
			{
				return E_UNEXPECTED;
			}
		}

		// set display name
		pLocale->SetDisplayName( szDisplayName.Detach() );

		// resolve apropriate description
		__Wrapper< WCHAR >	szDescription;
		obj->GetQualifierValue(L"description", &szDescription);

		if ( ! szDescription )
		{
			try
			{
				if ( szDescription.SetData( new WCHAR[ lstrlenW ( pGenObj->GetName() ) + 1 ] ), 
					 szDescription == NULL )
				{
					return E_OUTOFMEMORY;
				}

				lstrcpyW ( szDescription, pGenObj->GetName() );
			}
			catch ( ... )
			{
				return E_UNEXPECTED;
			}
		}

		// set description name
		pLocale->SetDescription( szDescription.Detach() );
	}
	catch ( ... )
	{
		return E_FAIL;
	}

	// have a locale information about object
	pGenObj->GetArrayLocale().DataAdd ( pLocale.Detach() );

	// resolve display names & descriptions of properties

	for ( DWORD dw = 0; dw <pGenObj->GetArrayProperties() ; dw++)
	{
		__Wrapper<WCHAR> wszShow;

		// take property and resolve
		obj->GetQualifierValue( pGenObj->GetArrayProperties()[dw]->GetName(), L"show", &wszShow );
		if ( ! wszShow.IsEmpty() )
		{
			if ( ! lstrcmpiW ( wszShow, L"false" ) )
			{
				// don't show counter
				continue;
			}
		}

		__WrapperPtr<CLocale> pLocale;

		try
		{
			if ( pLocale.SetData ( new CLocale() ),
				 pLocale == NULL )
			{
				return E_OUTOFMEMORY;
			}

			// resolve apropriate display name
			__Wrapper< WCHAR >	szDisplayName;
			obj->GetQualifierValue(pGenObj->GetArrayProperties()[dw]->GetName(), L"displayname", &szDisplayName);

			if ( ! szDisplayName )
			{
				try
				{
					if ( szDisplayName.SetData( new WCHAR[ lstrlenW ( pGenObj->GetArrayProperties()[dw]->GetName() ) + 1 ] ), 
						 szDisplayName == NULL )
					{
						return E_OUTOFMEMORY;
					}

					lstrcpyW ( szDisplayName, pGenObj->GetArrayProperties()[dw]->GetName() );
				}
				catch ( ... )
				{
					return E_UNEXPECTED;
				}
			}

			// set display name
			pLocale->SetDisplayName( szDisplayName.Detach() );

			// resolve apropriate description
			__Wrapper< WCHAR >	szDescription;
			obj->GetQualifierValue(pGenObj->GetArrayProperties()[dw]->GetName(), L"description", &szDescription);

			if ( ! szDescription )
			{
				try
				{
					if ( szDescription.SetData( new WCHAR[ lstrlenW ( pGenObj->GetArrayProperties()[dw]->GetName() ) + 1 ] ), 
						 szDescription == NULL )
					{
						return E_OUTOFMEMORY;
					}

					lstrcpyW ( szDescription, pGenObj->GetArrayProperties()[dw]->GetName() );
				}
				catch ( ... )
				{
					return E_UNEXPECTED;
				}
			}

			// set description name
			pLocale->SetDescription( szDescription.Detach() );
		}
		catch ( ... )
		{
			return E_FAIL;
		}

		// have a locale information about property
		pGenObj->GetArrayProperties()[dw]->GetArrayLocale().DataAdd ( pLocale.Detach() );
	}

	return S_OK;
}

// object helpers

void CObjectGlobal::DeleteAll ( void )
{
	if ( !m_ppObjects.empty() )
	{
		for ( mapOBJECTit it = m_ppObjects.begin(); it != m_ppObjects.end(); it++ )
		{
			if ( (*it).second )
			{
				delete (*it).second;
				(*it).second = NULL;
			}
		}

		m_ppObjects.clear();
	}
}

HRESULT CObjectGlobal::AddObject ( CObject* pObject )
{
	if ( ! pObject )
	{
		return E_INVALIDARG;
	}

	try
	{
		m_ppObjects.insert ( mapOBJECT::value_type ( pObject->GetName(), pObject ) );
	}
	catch ( ... )
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_object_enum.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_object_enum.cpp
//
//	Abstract:
//
//					implements enumeration of objects from WMI
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <throttle.h>

// definitions
#include "wmi_perf_object_enum.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

//////////////////////////////////////////////////////////////////////////////////////////////
// methods
//////////////////////////////////////////////////////////////////////////////////////////////

HRESULT	CPerformanceObjectEnum::ExecQuery ( LPCWSTR szQueryLang, LPCWSTR szQuery, LONG lFlag )
{
	if ( ! m_pServices )
	{
		return E_UNEXPECTED;
	}

	if ( ( ! szQueryLang ) || ( ! szQuery ) )
	{
		return E_INVALIDARG;
	}

	CComBSTR	bstrQueryLang	= szQueryLang;
	CComBSTR	bstrQuery		= szQuery;

	if ( m_pEnum )
	{
		m_pEnum->Release();
		m_pEnum = NULL;
	}

	return m_pServices->ExecQuery	(	bstrQueryLang,
										bstrQuery,
										lFlag,
										NULL,
										&m_pEnum
									);
}

HRESULT	CPerformanceObjectEnum::NextObject	(	LPCWSTR* lpwszNeed,
												DWORD	dwNeed,
												LPCWSTR*	lpwszNeedNot,
												DWORD	dwNeedNot,
												CPerformanceObject** ppObject
											)
{
	HRESULT hRes = S_OK;

	if ( ! m_pEnum )
	{
		hRes = E_UNEXPECTED;
	}

	if ( ! ppObject )
	{
		hRes = E_POINTER;
	}
	(*ppObject) = NULL;

	CComPtr<IWbemClassObject>	pObj;
	ULONG						uReturn = 0;

	while ( SUCCEEDED ( hRes ) &&
		  ( hRes = m_pEnum->Next ( WBEM_INFINITE, 1, &pObj, &uReturn ) ) == S_OK )
	{
		CPerformanceObject* obj = NULL;

		try
		{
			if ( ( obj = new CPerformanceObject( pObj, TRUE ) ) != NULL )
			{
				if ( ( hRes = obj->IsCorrectObject ( lpwszNeed, dwNeed, lpwszNeedNot, dwNeedNot ) ) == S_OK )
				{
					// object is correct ( has all qualifiers )
					(*ppObject) = obj;
					break;
				}
				else
				{
					// avoid leaks :)))
					pObj.Release();

					// destroy old performance object
					if ( obj )
					{
						delete obj;
						obj = NULL;
					}
				}
			}
			else
			{
				hRes =  E_OUTOFMEMORY;
			}
		}
		catch ( ... )
		{
			// avoid leaks :)))
			pObj.Release();

			if ( obj )
			{
				delete obj;
				obj = NULL;
			}

			hRes = E_UNEXPECTED;
		}
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_object_enum.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_object_enum.h
//
//	Abstract:
//
//					declaration of enumerate providers helpers
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_ENUM_OBJECT__
#define	__WMI_PERF_ENUM_OBJECT__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// wbem
#ifndef	__WBEMIDL_H_
#include <wbemidl.h>
#endif	__WBEMIDL_H_

#include "wmi_perf_object.h"

class CPerformanceObjectEnum
{
	DECLARE_NO_COPY ( CPerformanceObjectEnum );

	IWbemServices*	m_pServices;
	BOOL			m_bCopy;

	IEnumWbemClassObject * m_pEnum;

	public:

	//////////////////////////////////////////////////////////////////////////////////////////
	// construction & destruction
	//////////////////////////////////////////////////////////////////////////////////////////

	CPerformanceObjectEnum ( IWbemServices* pServices, BOOL bCopy = FALSE ) :
		m_pEnum ( NULL ),
		m_pServices ( NULL ),
		m_bCopy ( bCopy )
	{
		if ( pServices )
		{
			if ( m_bCopy )
			{
				(m_pServices = pServices)->AddRef();
			}
			else
			{
				(m_pServices = pServices);
			}
		}
	}

	virtual ~CPerformanceObjectEnum ()
	{
		if ( m_pEnum )
		{
			m_pEnum->Release();
		}

		if ( m_bCopy && m_pServices )
		{
			m_pServices->Release();
		}

		m_pServices	= NULL;
		m_pEnum		= NULL;
	}

	//////////////////////////////////////////////////////////////////////////////////////////
	// functions
	//////////////////////////////////////////////////////////////////////////////////////////

	// execute query to get all objects
	HRESULT ExecQuery ( LPCWSTR szQueryLang, LPCWSTR szQuery, LONG lFlag );

	// get next object from enum ( S_FALSE if there is no more )
	HRESULT	NextObject	(	LPCWSTR* lpwszNeed,
							DWORD	dwNeed,
							LPCWSTR*	lpwszNeedNot,
							DWORD	dwNeedNot,
							CPerformanceObject** ppObject
						);
};

#endif	__WMI_PERF_ENUM_OBJECT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_object_locale.cpp ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_object_locale.cpp
//
//	Abstract:
//
//					definitions of locale ( not local ) object
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#include "wmi_perf_object_locale.h"

// debuging features
#ifndef	_INC_CRTDBG
#include <crtdbg.h>
#endif	_INC_CRTDBG

// new stores file/line info
#ifdef _DEBUG
#ifndef	NEW
#define NEW new( _NORMAL_BLOCK, __FILE__, __LINE__ )
#define new NEW
#endif	NEW
#endif	_DEBUG

HRESULT CObject::SetProperties (	LPWSTR wsz,
									CIMTYPE type,
									DWORD dwScale,
									DWORD dwLevel,
									DWORD dwCounter,
									DWORD dw )
{
	__WrapperPtr<CObjectProperty> pProperty;

	try
	{
		if ( pProperty.SetData ( new CObjectProperty() ),
			 pProperty == NULL )
		{
			return E_OUTOFMEMORY;
		}

		LPWSTR sz = NULL;
		__String::SetStringCopy ( sz, wsz );

		pProperty->SetName ( sz );
		pProperty->SetType ( type );

		pProperty->dwDefaultScale	= dwScale;
		pProperty->dwDetailLevel	= dwLevel;
		pProperty->dwCounterType	= dwCounter;
	}
	catch ( ... )
	{
		return E_FAIL;
	}

	m_properties.SetAt ( dw, pProperty.Detach() );
	return S_OK;
}

HRESULT CObject::SetProperties (	CPerformanceObject* obj,
									LPWSTR* pp,
									CIMTYPE* pTypes,
									DWORD*	pScales,	
									DWORD*	pLevels,	
									DWORD*	pCounters,	
									DWORD dwpp )
{
	HRESULT hRes = S_OK;

	DWORD dwBase = 0;
	DWORD dw	 = 0;

	for ( dw = 0, dwBase = 0; dw < dwpp; dw ++ )
	{
		__Wrapper<WCHAR> wszBase;

		// take property and resolve
		obj->GetQualifierValue( pp[dw], L"base", &wszBase );
		if ( ! wszBase.IsEmpty() )
		{
			dwBase++;
		}
	}

	___ASSERT ( m_properties.IsEmpty() );

	try
	{
		typedef CObjectProperty* pCObjectProperty;
		if ( m_properties.SetData ( (new pCObjectProperty[ dwpp + dwBase ]), dwpp + dwBase ),
			 m_properties.IsEmpty() )
		{
			return E_OUTOFMEMORY;
		}
	}
	catch ( ... )
	{
		return E_UNEXPECTED;
	}

	for ( dw = 0, dwBase = 0; dw < dwpp; dw ++ )
	{
		if FAILED ( hRes = SetProperties ( pp[dw],
					( (pTypes != NULL) ? pTypes[dw] : CIM_EMPTY ),
					( (pScales != NULL) ? pScales[dw] : 0 ),
					( (pLevels != NULL) ? pLevels[dw] : PERF_DETAIL_NOVICE ),
					( (pCounters != NULL) ? pCounters[dw] : PERF_SIZE_ZERO ),
					dw + dwBase ) )
		{
			return hRes;
		}

		__Wrapper<WCHAR> wszBase;

		// take property and resolve
		obj->GetQualifierValue( pp[dw], L"base", &wszBase );
		if ( ! wszBase.IsEmpty() )
		{
			dwBase++;

			if FAILED ( hRes = SetProperties ( pp[dw],
						( (pTypes != NULL) ? pTypes[dw] : CIM_EMPTY ),
						( (pScales != NULL) ? pScales[dw] : 0 ),
						( (pLevels != NULL ) ? pLevels[dw] : PERF_DETAIL_NOVICE ),
						( (pCounters != NULL ) ? pCounters[dw] : PERF_SIZE_ZERO ),
						dw + dwBase ) )
			{
				return hRes;
			}

		}
	}

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_object_global.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_object_global.h
//
//	Abstract:
//
//					structure global aspect of generated internal objects
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_OBJECT_GLOBAL__
#define	__WMI_PERF_OBJECT_GLOBAL__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#ifndef	__WMI_PERF_OBJECT_LOCALE__
#include "wmi_perf_object_locale.h"
#endif	__WMI_PERF_OBJECT_LOCALE__

#ifndef	__WMI_PERF_OBJECT__
#include "wmi_perf_object.h"
#endif	__WMI_PERF_OBJECT__

#ifndef	__COMMON__
#include "__common.h"
#endif	__COMMON__

typedef	map< LPWSTR, CObject*, __CompareLPWSTR < LPWSTR >, RA_allocator < CObject* > >	mapOBJECT;
typedef	mapOBJECT::iterator																mapOBJECTit;

class CObjectGlobal
{
	DECLARE_NO_COPY ( CObjectGlobal );

	LPWSTR				m_wszNamespace;
	LPWSTR				m_wszQuery;

	mapOBJECT			m_ppObjects;

	friend class CGenerate;

	public:

	// construction & destruction

	CObjectGlobal() :
	m_wszNamespace ( NULL ),
	m_wszQuery ( NULL )
	{
	}

	virtual ~CObjectGlobal()
	{
		if ( m_wszNamespace )
		{
			delete m_wszNamespace;
			m_wszNamespace = NULL;
		}

		if ( m_wszQuery )
		{
			delete m_wszQuery;
			m_wszQuery = NULL;
		}

		DeleteAll();
	}

	HRESULT GenerateObjects ( IWbemServices * pService, LPCWSTR szQuery, BOOL bAmended = TRUE );

	// accessors
	mapOBJECT* GetObjects ( )
	{
		return &m_ppObjects;
	}

	LPWSTR	GetNamespace ( ) const
	{
		return m_wszNamespace;
	}
	LPWSTR	GetQuery ( ) const
	{
		return m_wszQuery;
	}

	private:
	// delete all object
	void	DeleteAll ( void );

	// add generate object at the end
	HRESULT AddObject ( CObject* pObject );
	// resolve locale stuff for object
	HRESULT	ResolveLocale ( CObject* pGenObj, CPerformanceObject* obj );
};

#endif	__WMI_PERF_OBJECT_GLOBAL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\wmi_perf_object_locale.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					wmi_perf_object_locale.h
//
//	Abstract:
//
//					structure containing properties of object in locale
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__WMI_PERF_OBJECT_LOCALE__
#define	__WMI_PERF_OBJECT_LOCALE__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

// class contains locale strings !!!
class CLocale
{
	DECLARE_NO_COPY ( CLocale );

	LPWSTR	m_wszLocaleDisplayName;
	LPWSTR	m_wszLocaleDescription;

	public:

	CLocale ():
	m_wszLocaleDisplayName ( NULL ),
	m_wszLocaleDescription ( NULL )
	{
	}

	virtual ~CLocale ()
	{
		if ( m_wszLocaleDisplayName )
		{
			delete m_wszLocaleDisplayName;
			m_wszLocaleDisplayName = NULL;
		}

		if ( m_wszLocaleDescription )
		{
			delete m_wszLocaleDescription;
			m_wszLocaleDescription = NULL;
		}
	}

	// accessors

	void SetDisplayName ( LPWSTR wsz )
	{
		___ASSERT ( m_wszLocaleDisplayName == NULL );
		m_wszLocaleDisplayName = wsz;
	}

	void SetDescription ( LPWSTR wsz )
	{
		___ASSERT ( m_wszLocaleDescription == NULL );
		m_wszLocaleDescription = wsz;
	}

	LPWSTR GetDisplayName () const
	{
		return m_wszLocaleDisplayName;
	}

	LPWSTR GetDescription () const
	{
		return m_wszLocaleDescription;
	}
};

#include <winperf.h>

// class contains description of property
class CObjectProperty
{
	DECLARE_NO_COPY ( CObjectProperty );

	LPWSTR						m_wszName;	// system name of property
	CIMTYPE						m_type;

	__WrapperARRAY< CLocale* >	m_locale;	// locale information

	public:

	DWORD						dwDefaultScale;
	DWORD						dwDetailLevel;
	DWORD						dwCounterType;

	CObjectProperty () :
	m_wszName ( NULL ),
	m_type ( CIM_EMPTY )
	{
		dwDefaultScale	= 0;
		dwDetailLevel	= PERF_DETAIL_NOVICE;
		dwCounterType	= PERF_SIZE_ZERO;
	}

	virtual ~CObjectProperty ()
	{
		if ( m_wszName )
		{
			delete m_wszName;
			m_wszName = NULL;
		}
	}

	// accessors
	void	SetName ( LPWSTR wsz )
	{
		___ASSERT ( m_wszName == NULL );
		m_wszName = wsz;
	}

	LPWSTR	GetName ( ) const
	{
		return m_wszName;
	}

	void	SetType ( CIMTYPE type )
	{
		___ASSERT ( m_type == CIM_EMPTY );
		m_type = type;
	}

	CIMTYPE	GetType ( ) const
	{
		return m_type;
	}

	// locale :))

	void						SetArrayLocale ( CLocale** loc, DWORD dw )
	{
		___ASSERT ( m_locale.IsEmpty() );

		try
		{
			m_locale.SetData ( loc, dw );
		}
		catch ( ... )
		{
		}
	}

	__WrapperARRAY< CLocale* >&	GetArrayLocale ( )
	{
		return m_locale;
	}
};

#ifndef	__WMI_PERF_OBJECT__
#include "wmi_perf_object.h"
#endif	__WMI_PERF_OBJECT__

class CObject
{
	DECLARE_NO_COPY ( CObject );

	LPWSTR								m_wszName;		// system name of object

	__WrapperARRAY< CLocale* >			m_locale;		// locale information
	__WrapperARRAY< CObjectProperty* >	m_properties;	// properties and theirs locale

	__WrapperARRAY< LPWSTR >			m_keys;

	public:

	DWORD								dwDetailLevel;

	CObject () :
	m_wszName ( NULL )
	{
		dwDetailLevel = PERF_DETAIL_NOVICE;
	}

	virtual ~CObject ()
	{
		if ( m_wszName )
		{
			delete m_wszName;
			m_wszName = NULL;
		}
	}

	// accessors
	void	SetName ( LPWSTR wsz )
	{
		___ASSERT ( m_wszName == NULL );
		m_wszName = wsz;
	}

	LPWSTR	GetName ( ) const
	{
		return m_wszName;
	}

	// locale :))
	void						SetArrayLocale ( CLocale** loc, DWORD dw )
	{
		___ASSERT ( m_locale.IsEmpty() );

		try
		{
			m_locale.SetData ( loc, dw );
		}
		catch ( ... )
		{
		}
	}

	__WrapperARRAY< CLocale* >&	GetArrayLocale ( )
	{
		return m_locale;
	}

	// properties :))
	void						SetArrayProperties ( CObjectProperty** prop, DWORD dw )
	{
		___ASSERT ( m_properties.IsEmpty() );

		try
		{
			m_properties.SetData ( prop, dw );
		}
		catch ( ... )
		{
		}
	}

	__WrapperARRAY< CObjectProperty* >&	GetArrayProperties ( )
	{
		return m_properties;
	}

	// keys :))
	void						SetArrayKeys ( LPWSTR* keys, DWORD dw )
	{
		___ASSERT ( m_keys.IsEmpty() );

		try
		{
			m_keys.SetData ( keys, dw );
		}
		catch ( ... )
		{
		}
	}

	__WrapperARRAY< LPWSTR >&	GetArrayKeys ( )
	{
		return m_keys;
	}

	// helper
	HRESULT	SetProperties ( CPerformanceObject* obj,	// object
							LPWSTR*		props,			// its properties
							CIMTYPE*	pTypes,			// its properties types
							DWORD*		pScales,		// its properties scales
							DWORD*		pLevels,		// its properties levels
							DWORD*		pCounters,		// its properties counter types
							DWORD		dw );

	private:

	HRESULT SetProperties ( LPWSTR wsz,
							CIMTYPE type,
							DWORD dwScale,
							DWORD dwLevel,
							DWORD dwCounter,
							DWORD dw );
};

#endif	__WMI_PERF_OBJECT_LOCALE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\wmireverseperformancemonitor\wmiadapter_refresh\__common.h ===
////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000, Microsoft Corporation.
//
//  All rights reserved.
//
//	Module Name:
//
//					__common.h
//
//	Abstract:
//
//					stl compare common functions
//
//	History:
//
//					initial		a-marius
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef	__COMMON__
#define	__COMMON__

#if		_MSC_VER > 1000
#pragma once
#endif	_MSC_VER > 1000

#ifdef	NEW
#undef	NEW
#undef	new
#endif	NEW

#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#undef _CRTIMP

// stl headers
#include <map>

using namespace std;

//////////////////////////////////////////////////////////////////////////
// compare function
//////////////////////////////////////////////////////////////////////////

template<class _LPWSTR>
struct __CompareLPWSTR : public binary_function<_LPWSTR, _LPWSTR, bool>
{
	bool operator()(const _LPWSTR& x, const _LPWSTR& y) const
	{
		return ( lstrcmpW ( x, y ) < 0 ) ? true : false;
	}
};

//////////////////////////////////////////////////////////////////////////
// ALLOCATOR
//////////////////////////////////////////////////////////////////////////

#include <memory>

template<class _Ty>
class RA_allocator
{
	public:

	typedef _SIZT size_type;
	typedef _PDFT difference_type;
	typedef _Ty _FARQ *pointer;
	typedef const _Ty _FARQ *const_pointer;
	typedef _Ty _FARQ &reference;
	typedef const _Ty _FARQ &const_reference;
	typedef _Ty value_type;

	pointer address(reference _X) const
	{
		return (&_X);
	}
	const_pointer address(const_reference _X) const
	{
		return (&_X);
	}
	char _FARQ *_Charalloc(size_type _N)
	{
		char _FARQ * pRet = ((char _FARQ *)operator new((_SIZT)_N * sizeof (_Ty)));

		if ( NULL == pRet )
		{
			throw E_OUTOFMEMORY;
		}

		return pRet; 
	}
	pointer allocate(size_type _N, const void *)
	{
		_Ty _FARQ * pRet = ((_Ty _FARQ *)operator new((_SIZT)_N * sizeof (_Ty)));

		if ( NULL == pRet )
		{
			throw E_OUTOFMEMORY;
		}

		return pRet;
	}
	void deallocate(void *_P, size_type)
	{
		operator delete(_P);
	}
	void construct(pointer _P, const _Ty& _V)
	{
		std::_Construct(_P, _V);
	}
	void destroy(pointer _P)
	{
		std::_Destroy(_P);
	}
	_SIZT max_size() const
	{
		_SIZT _N = (_SIZT)(-1) / sizeof (_Ty);
		return (0 < _N ? _N : 1);
	}
};


#endif	__COMMON__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\xml\wmixmlt\classfac.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  CLASSFAC.CPP
//
//  alanbos  13-Feb-98   Created.
//
//  Contains the class factory.  This creates objects when
//  connections are requested.
//
//***************************************************************************

#include "precomp.h"

//***************************************************************************
//
// CXMLTFactory::CXMLTFactory
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CXMLTFactory::CXMLTFactory()
{
    m_cRef=0L;
	return;
}

//***************************************************************************
//
// CXMLTFactory::~CXMLTFactory
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CXMLTFactory::~CXMLTFactory(void)
{
	return;
}

//***************************************************************************
//
// CXMLTFactory::QueryInterface
// CXMLTFactory::AddRef
// CXMLTFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CXMLTFactory::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CXMLTFactory::AddRef(void)
{
    long l = InterlockedIncrement(&m_cRef);
    return l;
}

STDMETHODIMP_(ULONG) CXMLTFactory::Release(void)
{
    long l = InterlockedDecrement(&m_cRef);
    if (0L!=l)
        return l;

    delete this;
    return 0L;
}

//***************************************************************************
//
//  SCODE CXMLTFactory::CreateInstance
//
//  Description: 
//
//  Instantiates a Translator object returning an interface pointer.
//
//  Parameters:
//
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CXMLTFactory::CreateInstance (

	IN LPUNKNOWN pUnkOuter,
    IN REFIID riid, 
    OUT PPVOID ppvObj
)
{
    IUnknown *   pObj;
    HRESULT      hr;

    *ppvObj=NULL;
    
    // This object doesnt support aggregation.
    if (NULL!=pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    pObj = (IWmiXMLTranslator *) new CXMLTranslator;
	
    if (NULL == pObj)
        return ResultFromScode(E_OUTOFMEMORY);;

    hr = pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if ( FAILED(hr) )
        delete pObj;
    return hr;
}

//***************************************************************************
//
//  SCODE CXMLTFactory::LockServer
//
//  Description:
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
//  Parameters:
//
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
//  Return Value:
// 
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CXMLTFactory::LockServer(IN BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((long *)&g_cLock);
    else
        InterlockedDecrement((long *)&g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\xml\wmixmlt\classfac.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  classfac.h
//
//  alanbos  13-Feb-98   Created.
//
//  Class factory interface.
//
//***************************************************************************

#ifndef _CLASSFAC_H_
#define _CLASSFAC_H_

typedef LPVOID * PPVOID;

// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern ULONG       g_cLock;

//***************************************************************************
//
//  CLASS NAME:
//
//  CXMLTFactory
//
//  DESCRIPTION:
//
//  Class factory for the CLocator class.
//
//***************************************************************************

class CXMLTFactory : public IClassFactory
{
protected:
	long           m_cRef;

public:

    CXMLTFactory(void);
    ~CXMLTFactory(void);
    
    //IUnknown members
	STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
	STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
	STDMETHODIMP         LockServer(BOOL);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\xml\wmixmlt\concache.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  CONCACHE.CPP
//
//  alanbos  13-Feb-98   Created.
//
//  implementation of the CXMLConnectionCache class.
//
//***************************************************************************

#include "precomp.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CXMLConnectionCache::CXMLConnectionCache()
{
	m_pLocator = NULL;

	// Get OS info
	OSVERSIONINFO	osVersionInfo;
	osVersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

	GetVersionEx (&osVersionInfo);
	m_dwCapabilities = EOAC_NONE;

	if ((VER_PLATFORM_WIN32_NT == osVersionInfo.dwPlatformId) &&
			(4 < osVersionInfo.dwMajorVersion))
		m_dwCapabilities |= EOAC_STATIC_CLOAKING;

#if 0
	m_pConnection = NULL;
	InitializeCriticalSection (&m_cs);
#endif
}

CXMLConnectionCache::~CXMLConnectionCache()
{
	if (m_pLocator)
		m_pLocator->Release ();

#if 0
	EnterCriticalSection (&m_cs);

	// Clean up the connection cache
	for (CXMLConnection *pConnection = m_pConnection; pConnection != NULL;)
	{
		CXMLConnection *pTemp = pConnection;
		pConnection = pTemp->Next;
		delete pTemp;
	}

	LeaveCriticalSection (&m_cs);
	DeleteCriticalSection (&m_cs);
#endif
}

HRESULT CXMLConnectionCache::GetConnectionByPath (BSTR pszNamespace, IWbemServices **ppService)
{
	HRESULT hr = WBEM_E_FAILED;
	*ppService = NULL;

	// If we don't have a locator yet, create one
	if (NULL == m_pLocator)
	{
		if (S_OK != CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
				IID_IWbemLocator, (LPVOID *) &m_pLocator))
			return WBEM_E_FAILED;
	}

	// Leave out caching for now as DCOM may timeout idle IWbemServices pointers
	// for us (yuck)

#if 0
	// Is our connection already in the cache?

	EnterCriticalSection (&m_cs);
	for (CXMLConnection *pConnection = m_pConnection; pConnection != NULL; 
					pConnection = pConnection->Next)
	{
		if (pConnection->MatchesNamespace (pszNamespace))
		{
			// Found it - just AddRef and return
			*ppService = pConnection->GetService ();
			(*ppService)->AddRef ();
			LeaveCriticalSection (&m_cs);
			return WBEM_S_NO_ERROR;
		}
	}

	// If we get here we didn't find an existing service
	if (WBEM_S_NO_ERROR == (hr = m_pLocator->ConnectServer 
			(pszNamespace, NULL, NULL, NULL, 0, NULL, NULL, ppService)))
	{
		// Success - add it into our cache
		(*ppService)->AddRef ();
		 CXMLConnection *pConnection = new CXMLConnection (*ppService, pszNamespace);
		 
		// Chain in at the front of the connection list
		if (m_pConnection)
		{
			pConnection->Next = m_pConnection->Next;
			m_pConnection->Prev = pConnection;
		}
		else
			pConnection->Next = NULL;

		m_pConnection = pConnection;
	}

	LeaveCriticalSection (&m_cs);

#else
	if (SUCCEEDED (hr = m_pLocator->ConnectServer (pszNamespace, NULL, NULL, NULL, 0, NULL, NULL, ppService)))
		SecureWmiProxy (*ppService);
#endif

	return hr;
}

void CXMLConnectionCache::SecureWmiProxy (IUnknown *pProxy)
{
	if (pProxy)
	{
		// Ensure we have impersonation enabled
		DWORD dwAuthnLevel, dwImpLevel;
		GetAuthImp (pProxy, &dwAuthnLevel, &dwImpLevel);

		SetInterfaceSecurity (pProxy, NULL, NULL, NULL, dwAuthnLevel, RPC_C_IMP_LEVEL_IMPERSONATE, 
								m_dwCapabilities);
	}
}

#if 0
void NormalizeNamespacePath (BSTR pszNamespace)
{
	if (pszNamespace)
	{
		wchar_t *pStr = pszNamespace;
		int len = wcslen (pStr);

		for (int i = 0 ; i < len; i++)
		{
			if (iswupper (pStr [i]))
				pStr [i] = towlower (pStr [i]);
			else if (L'\\' == pStr [i])
				pStr [i] = L'/';
		}
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\xml\wmixmlt\concache.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  concache.h
//
//  alanbos  13-Feb-98   Created.
//
//  Connection cache interface.
//
//***************************************************************************

#ifndef _CONCACHE_H_
#define _CONCACHE_H_

void	NormalizeNamespacePath (BSTR pszNamespace);

class CXMLConnectionCache  
{
private:
#if 0
	class CXMLConnection
	{
		private:
			IWbemServices		*m_pService;
			BSTR				m_pszNamespace;
						
		public:
			CXMLConnection (IWbemServices *pService, BSTR pszNamespace) :
						m_pService (pService),
						Prev (NULL)
			{
				m_pszNamespace = SysAllocString (pszNamespace);
				NormalizeNamespacePath (m_pszNamespace);
				DWORD dwAuthnLevel, dwImpLevel;
				GetAuthImp (m_pService, &dwAuthnLevel, &dwImpLevel);

				if (RPC_C_IMP_LEVEL_IMPERSONATE != dwImpLevel)
					SetInterfaceSecurity(m_pService, NULL, NULL, 
                             NULL, dwAuthnLevel, RPC_C_IMP_LEVEL_IMPERSONATE, EOAC_STATIC_CLOAKING);

			}

			virtual ~CXMLConnection ()
			{
				m_pService->Release ();
				SysFreeString (m_pszNamespace);
			}

			CXMLConnection*		Next;
			CXMLConnection*		Prev;
			IWbemServices*		GetService () { return m_pService; }
			bool				MatchesNamespace (BSTR pszNamespace)
			{
				NormalizeNamespacePath (pszNamespace);

				return (pszNamespace && m_pszNamespace && 
					(0 == _wcsicmp (pszNamespace, m_pszNamespace)));
			}
	};

	CXMLConnection		*m_pConnection;
	CRITICAL_SECTION	m_cs;  // Synchronization for the CXMLConnection class

#endif

	IWbemLocator		*m_pLocator;
	DWORD				m_dwCapabilities;

public:
	CXMLConnectionCache();
	virtual ~CXMLConnectionCache();

	HRESULT	GetConnectionByPath (BSTR namespacePath, IWbemServices **ppService);
	void	SecureWmiProxy (IUnknown *pProxy);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\xml\wmixmlt\cwmixmlt.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  cwbmxmlt.h
//
//  alanbos  13-Feb-98   Created.
//
//  Genral purpose include file.
//
//***************************************************************************

#ifndef _CWBMXMLT_H_
#define _CWBMXMLT_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CXMLTranslator
//
//  DESCRIPTION:
//
//  Implements the IWmiXMLTranslator.
//
//***************************************************************************

class CXMLTranslator : public IWmiXMLTranslator,
					   public IObjectSafety,
					   public ISupportErrorInfo
{
private:
	CRITICAL_SECTION			m_cs;
	ITypeInfo*					m_pITINeutral; 
	BSTR						m_schemaURL;
	VARIANT_BOOL				m_bAllowWMIExtensions;
	VARIANT_BOOL				m_bHostFilter;
	WmiXMLFilterEnum			m_iQualifierFilter;
	WmiXMLDTDVersionEnum		m_iDTDVersion;
	BSTR						m_queryFormat;
	CXMLConnectionCache			m_connectionCache;
	WmiXMLClassOriginFilterEnum	m_iClassOriginFilter;
	VARIANT_BOOL				m_bNamespaceInDeclGroup;
	WmiXMLDeclGroupTypeEnum		m_iDeclGroupType;

	HRESULT				m_hResult;	// Last HRESULT returned from CIMOM call

	static HRESULT	SaveStreamAsBSTR (IStream *pStream, BSTR *pBstr);

protected:

	long            m_cRef;         //Object reference count

public:
    
    CXMLTranslator();
    ~CXMLTranslator(void);

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// IDispatch

	STDMETHODIMP		GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP		GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    STDMETHODIMP		GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, 
							UINT cNames, LCID lcid, DISPID* rgdispid);
    STDMETHODIMP		Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
							WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, 
									EXCEPINFO* pexcepinfo, UINT* puArgErr);

 
	// IWbemXMLTranslator methods

	HRESULT STDMETHODCALLTYPE  GetObject
		(
		/*[in]*/	BSTR pszNamespacePath,
		/*[in]*/	BSTR pszObjectPath,
        /*[out]*/   BSTR* pXML
        );

	HRESULT STDMETHODCALLTYPE  ExecQuery
		(
		/*[in]*/	BSTR pszNamespacePath,
		/*[in]*/	BSTR pszQueryString,
        /*[out]*/   BSTR* pXML
        );

	HRESULT STDMETHODCALLTYPE	get_SchemaURL
		(
		/*[out]*/	BSTR* pSchemaURL
		);

	HRESULT STDMETHODCALLTYPE	put_SchemaURL
		(
		/*[in]*/	BSTR schemaURL
		);

	HRESULT STDMETHODCALLTYPE	get_AllowWMIExtensions
		(
		/*[out]*/	VARIANT_BOOL* bAllowWMIExtensions
		)
	{
		*bAllowWMIExtensions = m_bAllowWMIExtensions;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE	put_AllowWMIExtensions
		(
		/*[in]*/	VARIANT_BOOL bAllowWMIExtensions
		)
	{
		m_bAllowWMIExtensions = bAllowWMIExtensions;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE	get_HostFilter
		(
		/*[out]*/	VARIANT_BOOL* bHostFilter
		)
	{
		*bHostFilter = m_bHostFilter;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE	put_HostFilter
		(
		/*[in]*/	VARIANT_BOOL bHostFilter
		)
	{
		m_bHostFilter = bHostFilter;
		return S_OK;
	}
	
	HRESULT STDMETHODCALLTYPE get_QualifierFilter
		(
			/*[out]*/ WmiXMLFilterEnum *iQualifierFilter
		)
	{
		*iQualifierFilter = m_iQualifierFilter;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE put_QualifierFilter
		(
			/*[in]*/ WmiXMLFilterEnum iQualifierFilter
		)
	{
		HRESULT hr = E_FAIL;

		switch (iQualifierFilter)
		{
			case wmiXMLFilterNone:
			case wmiXMLFilterLocal:
			case wmiXMLFilterPropagated:
			case wmiXMLFilterAll:
				m_iQualifierFilter = iQualifierFilter;
				hr = S_OK;
				break;
		}

		if (FAILED(hr))
			m_hResult = hr;

		return hr;
	}

	HRESULT STDMETHODCALLTYPE	get_DTDVersion
		(
		/*[out]*/	WmiXMLDTDVersionEnum *iDTDVersion
		)
	{
		*iDTDVersion = m_iDTDVersion;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE	put_DTDVersion
		(
		/*[in]*/	WmiXMLDTDVersionEnum iDTDVersion
		)
	{
		HRESULT hr = E_FAIL;

		// Currently only 2.0 is supported
		if (wmiXMLDTDVersion_2_0 == iDTDVersion)
		{
			m_iDTDVersion = iDTDVersion;
			hr = S_OK;
		}

		if (FAILED(hr))
			m_hResult = hr;

		return hr;
	}


	HRESULT STDMETHODCALLTYPE	get_ClassOriginFilter
		(
		/*[out]*/	WmiXMLClassOriginFilterEnum *iClassOriginFilter
		)
	{
		*iClassOriginFilter = m_iClassOriginFilter;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE	put_ClassOriginFilter
		(
		/*[in]*/	WmiXMLClassOriginFilterEnum iClassOriginFilter
		)
	{
		HRESULT hr = E_FAIL;

		switch (iClassOriginFilter)
		{
			case wmiXMLClassOriginFilterNone:
			case wmiXMLClassOriginFilterClass:
			case wmiXMLClassOriginFilterInstance:
			case wmiXMLClassOriginFilterAll:
				m_iClassOriginFilter = iClassOriginFilter;
				hr = S_OK;
				break;
		}

		if (FAILED(hr))
			m_hResult = hr;

		return hr;	
	}

	HRESULT STDMETHODCALLTYPE	get_IncludeNamespace
		(
		/*[out]*/	VARIANT_BOOL* bIncludeNamespace
		)
	{
		*bIncludeNamespace = m_bNamespaceInDeclGroup;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE	put_IncludeNamespace
		(
		/*[in]*/	VARIANT_BOOL bIncludeNamespace
		)
	{
		m_bNamespaceInDeclGroup = bIncludeNamespace;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE get_DeclGroupType
		(
			/*[out]*/ WmiXMLDeclGroupTypeEnum *iDeclGroupType
		)
	{
		*iDeclGroupType = m_iDeclGroupType;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE put_DeclGroupType
		(
			/*[in]*/ WmiXMLDeclGroupTypeEnum iDeclGroupType
		)
	{
		HRESULT hr = E_FAIL;

		switch (iDeclGroupType)
		{
			case wmiXMLDeclGroup:
			case wmiXMLDeclGroupWithName:
			case wmiXMLDeclGroupWithPath:
				m_iDeclGroupType = iDeclGroupType;
				hr = S_OK;
				break;
		}

		if (FAILED(hr))
			m_hResult = hr;

		return hr;
	}

	
	// IObjectSafety methods
	HRESULT STDMETHODCALLTYPE SetInterfaceSafetyOptions
	(     
		/* [in] */ REFIID riid,
		/* [in] */ DWORD dwOptionSetMask,    
		/* [in] */ DWORD dwEnabledOptions
	)
	{ 
		return (dwOptionSetMask & dwEnabledOptions) ? E_FAIL : S_OK;
	}

	HRESULT  STDMETHODCALLTYPE GetInterfaceSafetyOptions( 
		/* [in]  */ REFIID riid,
		/* [out] */ DWORD __RPC_FAR *pdwSupportedOptions,
		/* [out] */ DWORD __RPC_FAR *pdwEnabledOptions
	)
	{ 
		if (pdwSupportedOptions) *pdwSupportedOptions = 0;
		if (pdwEnabledOptions) *pdwEnabledOptions = 0;
		return S_OK;
	}

	// ISupportErrorInfo methods
	HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo 
	(
		/* [in] */ REFIID riid
	)
	{
		return (IID_IWmiXMLTranslator == riid) ? S_OK : S_FALSE;
	}
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\xml\wmixmlt\makefile.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\xml\wmixmlt\maindll.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  MAINDLL.CPP
//
//  alanbos  13-Feb-98   Created.
//
//  Contains DLL entry points.  
//
//***************************************************************************

#include "precomp.h"

#include <initguid.h>

// {3B418F72-A4D7-11d1-8AE9-00600806D9B6} CLSID for the WBEM XML Translator
DEFINE_GUID(CLSID_IWmiXMLTranslator, 
0x3b418f72, 0xa4d7, 0x11d1, 0x8a, 0xe9, 0x0, 0x60, 0x8, 0x6, 0xd9, 0xb6);

// Control-specific registry strings
#define WMI_XML_DESCRIPTION	"WMI XML Translator"
#define WMI_XML_TXOR_PROGID	"WMI.XMLTranslator"
#define WMI_XML_TXOR_PROGIDVER	"WMI.XMLTranslator.1"
#define WMI_XML_TXOR_VERSION	"1.0"

// Standard registry key/value names
#define WMI_XML_RK_THRDMODEL	"ThreadingModel"
#define WMI_XML_RV_BOTH			"Both"
#define WMI_XML_RK_CONTROL		"Control"
#define WMI_XML_RK_PROGID		"ProgID"
#define WMI_XML_RK_VERPROGID	"VersionIndependentProgID"
#define WMI_XML_RK_TYPELIB		"TypeLib"
#define WMI_XML_RK_VERSION		"Version"
#define	WMI_XML_RK_INPROC32		"InProcServer32"
#define WMI_XML_RK_CLSID		"CLSID"
#define WMI_XML_RK_CURVER		"CurVer"

#define GUIDSIZE	128

// Count number of objects and number of locks.

long g_cObj = 0 ;
ULONG g_cLock = 0 ;
HMODULE ghModule ;

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain (
                        
	IN HINSTANCE hInstance,
    IN ULONG ulReason,
    LPVOID pvReserved
)
{
	switch (ulReason)
	{
		case DLL_PROCESS_DETACH:
			return TRUE;

		case DLL_PROCESS_ATTACH:
			ghModule = hInstance;
	        return TRUE;
    }

    return TRUE;
}

//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//  
//***************************************************************************

STDAPI DllGetClassObject(

	IN REFCLSID rclsid,
    IN REFIID riid,
    OUT LPVOID *ppv
)
{
    HRESULT hr;
    CXMLTFactory *pObj = NULL;

    if (CLSID_IWmiXMLTranslator == rclsid)
	{
        if (NULL == (pObj = new CXMLTFactory()))
			return ResultFromScode(E_OUTOFMEMORY);
	}
	else
        return E_FAIL;

    hr=pObj->QueryInterface(riid, ppv);

    if ( FAILED ( hr ) )
	{
        delete pObj ;
	}

    return hr ;
}

//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//  
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	//It is OK to unload if there are no objects or locks on the
    // class factory.

    return (0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
}


//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{ 
    OLECHAR		wcID[GUIDSIZE];
	OLECHAR		tlID[GUIDSIZE];
	char		nwcID[GUIDSIZE];
	char		ntlID[GUIDSIZE];
    char		szCLSID[GUIDSIZE+128];
    char		szModule[MAX_PATH];
    HKEY hKey1 = NULL, hKey2 = NULL;

    // Create the path.

    if(0 ==StringFromGUID2(CLSID_IWmiXMLTranslator, wcID, GUIDSIZE))
		return ERROR;

	wcstombs(nwcID, wcID, GUIDSIZE);
    lstrcpy (szCLSID, WMI_XML_RK_CLSID);
	lstrcat (szCLSID, "\\");
	lstrcat (szCLSID, nwcID);
	
	if (0 == StringFromGUID2 (LIBID_WmiXML, tlID, GUIDSIZE))
		return ERROR;

	wcstombs(ntlID, tlID, GUIDSIZE);	
	
	if(0 == GetModuleFileName(ghModule, szModule,  MAX_PATH))
		return ERROR;

    // Create entries under CLSID

    if(ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, szCLSID, &hKey1))
	{
		// Description (on main key)
		RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)WMI_XML_DESCRIPTION, 
										(strlen(WMI_XML_DESCRIPTION)+1));

		// Register as inproc server
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WMI_XML_RK_INPROC32 ,&hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
										(strlen(szModule)+1));
			RegSetValueEx(hKey2, WMI_XML_RK_THRDMODEL, 0, REG_SZ, (BYTE *)WMI_XML_RV_BOTH, 
                                        (strlen(WMI_XML_RV_BOTH)+1));
			RegCloseKey(hKey2);
		}

		// Register as a control
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WMI_XML_RK_CONTROL, &hKey2))
			RegCloseKey(hKey2);

		// Register the ProgID
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WMI_XML_RK_PROGID ,&hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)WMI_XML_TXOR_PROGIDVER, 
										(strlen(WMI_XML_TXOR_PROGIDVER)+1));
			RegCloseKey(hKey2);
        }

		// Register the version-independent ProgID

		if (ERROR_SUCCESS == RegCreateKey(hKey1, WMI_XML_RK_VERPROGID, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)WMI_XML_TXOR_PROGID, 
										(strlen(WMI_XML_TXOR_PROGID)+1));
			RegCloseKey(hKey2);
        }

		// Register the type-library
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WMI_XML_RK_TYPELIB, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)ntlID, 
										(strlen(ntlID)+1));
			RegCloseKey(hKey2);
        }

		// Register the version
		if (ERROR_SUCCESS == RegCreateKey(hKey1, WMI_XML_RK_VERSION, &hKey2))
		{
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)WMI_XML_TXOR_VERSION, 
										(strlen(WMI_XML_TXOR_VERSION)+1));
			RegCloseKey(hKey2);
        }
	
		RegCloseKey(hKey1);
	}
	else
		return ERROR;

  
    // Add the ProgID (Version independent and current version)

	if(ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, WMI_XML_TXOR_PROGID, &hKey1))
    {
		RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)WMI_XML_DESCRIPTION, 
										(strlen(WMI_XML_DESCRIPTION)+1));

		if(ERROR_SUCCESS == RegCreateKey(hKey1,WMI_XML_RK_CLSID, &hKey2))
        {
            RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)nwcID, 
										(strlen(nwcID)+1));
            RegCloseKey(hKey2);
            hKey2 = NULL;
        }

        if(ERROR_SUCCESS == RegCreateKey(hKey1, WMI_XML_RK_CURVER, &hKey2))
        {
			RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)WMI_XML_TXOR_PROGIDVER, 
										(strlen(WMI_XML_TXOR_PROGIDVER)+1));
			RegCloseKey(hKey2);
            hKey2 = NULL;
        }
        RegCloseKey(hKey1);
    }

    if(ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, WMI_XML_TXOR_PROGIDVER, &hKey1))
    {
		RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)WMI_XML_DESCRIPTION, 
										(strlen(WMI_XML_DESCRIPTION)+1));

        if(ERROR_SUCCESS == RegCreateKey(hKey1, WMI_XML_RK_CLSID, &hKey2))
        {
            RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)nwcID, 
										(strlen(nwcID)+1));
            RegCloseKey(hKey2);
            hKey2 = NULL;
        }
        RegCloseKey(hKey1);
    }

	// AUTOMATION.  register type library
	char cPath[MAX_PATH];
	WCHAR wPath[MAX_PATH];
	if(GetModuleFileName(ghModule, cPath, MAX_PATH-1))
	{
		// Replace final 3 characters "DLL" by "TLB"
		size_t pathLen = strlen (cPath);

		if ((pathLen > 3) && (0 == _stricmp (cPath + pathLen - 3, "DLL")))
		{
			cPath [pathLen - 3] = NULL;
			strcat (cPath, "TLB");
			mbstowcs(wPath, cPath, MAX_PATH-1);
			ITypeLib FAR* ptlib = NULL; 
			SCODE sc = LoadTypeLib(wPath, &ptlib);
			if(sc == 0 && ptlib)
			{
				sc = RegisterTypeLib(ptlib,wPath,NULL);
				ptlib->Release();
			}
		}
	}

	return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
	OLECHAR		wcID[GUIDSIZE];
    char		szCLSID[GUIDSIZE];
	char		nwcID[GUIDSIZE];
    HKEY		hKey;

    // Create the path using the CLSID

    if(0 == StringFromGUID2(CLSID_IWmiXMLTranslator, wcID, GUIDSIZE))
		return ERROR;

	wcstombs(nwcID, wcID, GUIDSIZE);
    lstrcpy (szCLSID, WMI_XML_RK_CLSID);
	lstrcat (szCLSID, "\\");
	lstrcat (szCLSID, nwcID);
	
    // First delete the subkeys of the HKCR\CLSID entry
    if(NO_ERROR == RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hKey))
    {
        RegDeleteKey(hKey, WMI_XML_RK_INPROC32);
		RegDeleteKey(hKey, WMI_XML_RK_CONTROL);
		RegDeleteKey(hKey, WMI_XML_RK_PROGID);
		RegDeleteKey(hKey, WMI_XML_RK_VERPROGID);
		RegDeleteKey(hKey, WMI_XML_RK_TYPELIB);
		RegDeleteKey(hKey, WMI_XML_RK_VERSION);
        RegCloseKey(hKey);
    }

	// Delete the HKCR\CLSID key
    if(NO_ERROR == RegOpenKey(HKEY_CLASSES_ROOT, WMI_XML_RK_CLSID, &hKey))
    {
        RegDeleteKey(hKey, nwcID);
        RegCloseKey(hKey);
    }

	// Delete the subkeys of the versioned HKCR\ProgID entry
    if (NO_ERROR == RegOpenKey(HKEY_CLASSES_ROOT, WMI_XML_TXOR_PROGIDVER, &hKey))
    {
		RegDeleteKey(hKey, WMI_XML_RK_CLSID);
		RegCloseKey(hKey);
	}

	// Delete the versioned HKCR\ProgID entry
    RegDeleteKey (HKEY_CLASSES_ROOT,WMI_XML_TXOR_PROGIDVER);

	// Delete the subkeys of the HKCR\VersionIndependentProgID entry
	if (NO_ERROR == RegOpenKey(HKEY_CLASSES_ROOT, WMI_XML_TXOR_PROGID, &hKey))
    {
		RegDeleteKey(hKey, WMI_XML_RK_CLSID);
		DWORD dwRet = RegDeleteKey(hKey, WMI_XML_RK_CURVER);
		RegCloseKey(hKey);
	}

	// Delete the HKCR\VersionIndependentProgID entry
	RegDeleteKey (HKEY_CLASSES_ROOT,WMI_XML_TXOR_PROGID);
	
	//	Unregister the type library.  The UnRegTypeLib function is not available in
    //  in some of the older version of the ole dlls and so it must be loaded
    //  dynamically
    HRESULT (STDAPICALLTYPE *pfnUnReg)(REFGUID, WORD,
            WORD , LCID , SYSKIND);

    char path[ MAX_PATH+20 ];
    GetSystemDirectory(path, MAX_PATH);
    lstrcat(path, "\\oleaut32.dll");

    HMODULE g_hOle32 = LoadLibraryEx(path, NULL, 0);

    if(g_hOle32 != NULL) 
    {
        (FARPROC&)pfnUnReg = GetProcAddress(g_hOle32, "UnRegisterTypeLib");
        if(pfnUnReg) 
            pfnUnReg(LIBID_WmiXML,1,0,0,SYS_WIN32);
        FreeLibrary(g_hOle32);
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\xml\wmixmlt\precomp.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  precomp.h
//
//  alanbos  04-Mar-98   Created.
//
//  Master include file.
//
//***************************************************************************

// Note we assume DCOM platforms only.  This makes life easier
// cross-thread handling of IWbemXXX interfaces.
#define _WIN32_DCOM

#include <stdio.h>
#include <objbase.h>
#include <objsafe.h>
#include <wbemidl.h>

#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <cominit.h>

#include "wmixmlt.h"
#include "wmi2xml.h"
#include "concache.h"
#include "cwmixmlt.h"
#include "classfac.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\xml\wmixmlt\wmi2xml.h ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  WBEM2XML.h
//
//  alanbos  13-Feb-98   Created.
//
//  Genral purpose include file.
//
//***************************************************************************

#ifndef _WBEM2XML_H_
#define _WBEM2XML_H_

#define WRITEBSTR(X)	m_pStream->Write ((OLECHAR *)X, wcslen (X) * sizeof (OLECHAR), NULL);
#define WRITEWSTR(X)	m_pStream->Write (           X, wcslen (X) * sizeof (OLECHAR), NULL);
#define WRITEWSTRL(X,L) m_pStream->Write (           X, L * sizeof (OLECHAR), NULL);

#ifdef WMIXML_DONL	
#define WRITENL			m_pStream->Write (NEWLINE, 4, NULL);
#else
#define WRITENL
#endif

#define	WRITESIG		m_pStream->Write (UTF16SIG, 2, NULL);

#define WRITECDATASTART	WRITEBSTR(CDATASTART)
#define WRITECDATAEND	WRITEBSTR(CDATAEND)
#define WRITEAMP        WRITEBSTR(AMPERSAND)
#define WRITELT         WRITEBSTR(LEFTCHEVRON)
#define WRITEGT         WRITEBSTR(RIGHTCHEVRON)


//***************************************************************************
//
//  CLASS NAME:
//
//  CWmiToXml
//
//  DESCRIPTION:
//
//  Performs conversion .
//
//***************************************************************************

class CWmiToXml
{
private:
	IStream					*m_pStream;
	IWbemClassObject		*m_pObject;
	bool					m_bIsClass;
	IEnumWbemClassObject	*m_pEnum;

	BSTR					m_bsNamespacePath;
	
	VARIANT_BOOL				m_bAllowWMIExtensions;
	WmiXMLFilterEnum			m_iQualifierFilter;
	WmiXMLDTDVersionEnum		m_iDTDVersion;
	VARIANT_BOOL				m_bHostFilter;
	VARIANT_BOOL				m_bNamespaceInDeclGroup;
	WmiXMLClassOriginFilterEnum	m_iClassOriginFilter;
	WmiXMLDeclGroupTypeEnum		m_iDeclGroupType;

	bool				PropertyIsLocal (BSTR name, long flavor, IWbemQualifierSet *pQualSet);
	BSTR				GetNamespace(IWbemClassObject *pObject);

    STDMETHODIMP		MapCommonHeaders (BSTR schemaURL);				
    STDMETHODIMP		MapCommonTrailers ();
	STDMETHODIMP		MapDeclGroupHeaders ();
	STDMETHODIMP		MapDeclGroupTrailers ();
    STDMETHODIMP		MapObjectWithoutHeaders ();
	STDMETHODIMP		MapWithPathClass (IWbemQualifierSet *pQualSet);
	STDMETHODIMP		MapClass (IWbemQualifierSet *pQualSet);
	STDMETHODIMP		MapClassPath (ParsedObjectPath *pParsedPath);
	STDMETHODIMP		MapLocalClassPath (ParsedObjectPath *pParsedPath);
	STDMETHODIMP		MapClassName (BSTR bsClassName);
	STDMETHODIMP		MapNamedInstance (IWbemQualifierSet *pQualSet);
	STDMETHODIMP		MapWithPathInstance (IWbemQualifierSet *pQualSet);
	STDMETHODIMP		MapInstance (IWbemQualifierSet *pQualSet);
	STDMETHODIMP		MapInstancePath (ParsedObjectPath *pParsedPath);
	STDMETHODIMP		MapLocalInstancePath (ParsedObjectPath *pParsedPath);
	STDMETHODIMP		MapInstanceName (ParsedObjectPath *pParsedPath);
	STDMETHODIMP		MapNamespacePath (BSTR bsNamespacePath);
	STDMETHODIMP		MapNamespacePath (ParsedObjectPath *pObjectPath);
	STDMETHODIMP		MapLocalNamespacePath (ParsedObjectPath *pObjectPath);
	STDMETHODIMP		MapQualifiers (IWbemQualifierSet *pQualSet, IWbemQualifierSet *pQualSet2 = NULL);
	STDMETHODIMP		MapQualifier (BSTR name, long flavor, VARIANT &var);
	STDMETHODIMP		MapProperties ();
	STDMETHODIMP		MapProperty (BSTR name, VARIANT &var, CIMTYPE cimtype,
										bool isArray, long flavor);
	STDMETHODIMP		MapObjectProperty (BSTR name, VARIANT &var, bool isArray, long flavor);
	void				MapArraySize (IWbemQualifierSet *pQualSet);
	STDMETHODIMP		MapReference (BSTR name, VARIANT &var, long flavor);
	STDMETHODIMP		MapMethods ();
	void				MapMethod (BSTR name, IWbemClassObject *pInParams, IWbemClassObject *pOutParams);
	void				MapParameter (BSTR paramName, IWbemQualifierSet *pQualSet, 
								CIMTYPE cimtype, IWbemQualifierSet *pQualSet2 = NULL);
	void				MapReturnParameter(BSTR strParameterName, VARIANT &variant);

	STDMETHODIMP		MapType (CIMTYPE cimtype);
	STDMETHODIMP		MapValue (VARIANT &var);
	STDMETHODIMP		MapValue (CIMTYPE cimtype, bool isArray, VARIANT &var);
	STDMETHODIMP		MapEmbeddedObjectValue (bool isArray, VARIANT &var);
	STDMETHODIMP		MapKeyValue (VARIANT &var);
	void				MapStrongType (IWbemQualifierSet *pQualSet);
	void				GetClassName (IWbemQualifierSet *pQualSet);
	void				MapLocal (long flavor);
	void				MapClassOrigin (BSTR &classOrigin);

	// Primitive functions to map individual values
	void				MapLongValue (long val);
	void				MapShortValue (short val);
	void				MapDoubleValue (double val);
	void				MapFloatValue (float val);
	void				MapBoolValue (bool val);
	void				MapByteValue (unsigned char val);
	void				MapCharValue (long val);
	void				MapStringValue (BSTR &val);
	void				MapReferenceValue (VARIANT &var);
	void				MapReferenceValue (ParsedObjectPath *pObjectPath);

	ParsedObjectPath*	IsReference (VARIANT &var);
	LPWSTR GetHostName();


public:
    
    CWmiToXml(BSTR bsNamespacePath, IStream *pStream, IWbemClassObject *pObject, VARIANT_BOOL bAllowWMIExtensions,
					WmiXMLFilterEnum iQualifierFilter, 
					VARIANT_BOOL bHostFilter,
					WmiXMLDTDVersionEnum iDTDVersion,
					VARIANT_BOOL bNamespaceInDeclGroup,
					WmiXMLClassOriginFilterEnum	iClassOriginFilter,
					WmiXMLDeclGroupTypeEnum	iDeclGroupType);
	CWmiToXml(BSTR bsNamespacePath, IStream *pStream, IEnumWbemClassObject *pObject, VARIANT_BOOL bAllowWMIExtensions,
					WmiXMLFilterEnum m_iQualifierFilter,
					VARIANT_BOOL bHostFilter,
					WmiXMLDTDVersionEnum iDTDVersion,
					VARIANT_BOOL bNamespaceInDeclGroup,
					WmiXMLClassOriginFilterEnum	iClassOriginFilter,
					WmiXMLDeclGroupTypeEnum	iDeclGroupType);
    ~CWmiToXml(void);

	STDMETHODIMP		MapEnum (BSTR schemaURL);
	STDMETHODIMP		MapObject (BSTR schemaURL);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\action.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  File:	Action.CPP
//
//  Description:	Implementation of the CAction member fuctions.
//
// (c) 1999 Microsoft Corporation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "precomp.h"		
#include "Action.h"			


//  Basic constructor
CAction::CAction(IWbemServices *pWbem):
	m_pWbem(pWbem),
	m_hStatus(0)	
{	
	if(m_pWbem)
	{
		m_pWbem->AddRef();
	}
}

//  Basic Destructor
CAction::~CAction()
{
	if(m_pWbem)
	{
		m_pWbem->Release();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\xml\wmixmlt\wmixmlt.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  WBEMXMLT.CPP
//
//  alanbos  15-Aug-96   Created.
//
//  Defines the implementation of IWbemXMLTranslator
//
//***************************************************************************


#include "precomp.h"

static BSTR MapHresultToWmiDescription (HRESULT hr);

//***************************************************************************
//
//  CXMLTranslator::CXMLTranslator
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CXMLTranslator::CXMLTranslator()
{
	InitializeCriticalSection (&m_cs);
	m_queryFormat = SysAllocString (OLESTR("WQL"));
	m_bAllowWMIExtensions = VARIANT_FALSE;
	m_pITINeutral = NULL;
	m_schemaURL = NULL;
	m_iQualifierFilter = wmiXMLFilterLocal;
	m_iDTDVersion = wmiXMLDTDVersion_2_0;
	m_bHostFilter = VARIANT_TRUE;	// Don't filter out the host
	m_bNamespaceInDeclGroup = VARIANT_FALSE;
	m_iClassOriginFilter = wmiXMLClassOriginFilterNone; // No class origin info 
	m_iDeclGroupType = wmiXMLDeclGroup;
	m_cRef=0;
	m_hResult = S_OK;
    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CXMLTranslator::~CXMLTranslator
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CXMLTranslator::~CXMLTranslator(void)
{
    InterlockedDecrement(&g_cObj);
	SysFreeString (m_queryFormat);
	
	if (m_pITINeutral)
		m_pITINeutral->Release ();

	EnterCriticalSection (&m_cs);
	if (m_schemaURL)
			SysFreeString (m_schemaURL);
	LeaveCriticalSection (&m_cs);

	DeleteCriticalSection (&m_cs);
}

//***************************************************************************
// HRESULT CXMLTranslator::QueryInterface
// long CXMLTranslator::AddRef
// long CXMLTranslator::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CXMLTranslator::QueryInterface (

	IN REFIID riid,
    OUT LPVOID *ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid)
		*ppv = reinterpret_cast<IUnknown*>(this);
	else if (IID_IWmiXMLTranslator==riid)
		*ppv = (IWmiXMLTranslator *)this;
	else if (IID_IDispatch==riid)
		*ppv = (IDispatch *)this;
	else if (IID_IObjectSafety==riid)
        *ppv = (IObjectSafety *)this;
	else if (IID_ISupportErrorInfo==riid)
		*ppv = (ISupportErrorInfo *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CXMLTranslator::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CXMLTranslator::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
// HRESULT CXMLTranslator::GetTypeInfoCount
// HRESULT CXMLTranslator::GetTypeInfo
// HRESULT CXMLTranslator::GetIDsOfNames
// HRESULT CXMLTranslator::Invoke
//
//
// DESCRIPTION:
//
// Standard Com IDispatch functions.
//
//***************************************************************************

STDMETHODIMP CXMLTranslator::GetTypeInfoCount(UINT *pctInfo)
{
	*pctInfo = 1;
	return S_OK;
}

STDMETHODIMP CXMLTranslator:: GetTypeInfo(UINT itInfo, LCID lcid,
											ITypeInfo **ppITypeInfo)
{
	ITypeLib	*pITypeLib = NULL;
	ITypeInfo	**ppITI = NULL;

	if (0 != itInfo)
		return TYPE_E_ELEMENTNOTFOUND;

	if (NULL == ppITypeInfo)
		return E_POINTER;

	*ppITypeInfo = NULL;

	switch (PRIMARYLANGID(lcid))
	{
		case LANG_NEUTRAL:
		case LANG_ENGLISH:
			ppITI = &m_pITINeutral;
			break;

		default:
			return DISP_E_UNKNOWNLCID;
	}

	if (ppITI)
	{
		HRESULT		hr;
	
		if (FAILED(hr = LoadRegTypeLib(LIBID_WmiXML, 1, 0,
					PRIMARYLANGID(lcid), &pITypeLib)))
			hr = LoadTypeLib(OLESTR("WMIXMLT.TLB"), &pITypeLib);

		if (FAILED(hr))
			return hr;

		hr = pITypeLib->GetTypeInfoOfGuid (IID_IWmiXMLTranslator, ppITI);
		pITypeLib->Release ();

		if (FAILED(hr))
			return hr;
	}

	// Getting here means we have a real ITypeInfo to assign
	(*ppITI)->AddRef ();
	*ppITypeInfo = *ppITI;
	return S_OK;
}

STDMETHODIMP CXMLTranslator::GetIDsOfNames (REFIID riid,
				OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
	ITypeInfo	*pTI = NULL;

	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	HRESULT	hr = GetTypeInfo (0, lcid, &pTI);

	if (SUCCEEDED(hr))
	{
		pTI->GetIDsOfNames (rgszNames, cNames, rgDispID);
		pTI->Release ();
	}

	return hr;
}

STDMETHODIMP CXMLTranslator::Invoke (DISPID dispID, REFIID riid,
				LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams,
				VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
	ITypeInfo	*pTI = NULL;
	m_hResult = S_OK;

	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	HRESULT hr = GetTypeInfo (0, lcid, &pTI);
	if (FAILED(hr))
		return hr;

	hr = pTI->Invoke (this, dispID, wFlags, pDispParams, pVarResult,
						pExcepInfo, puArgErr);

	pTI->Release ();

	if (FAILED(m_hResult))
	{
		if (NULL != pExcepInfo)
		{
			if (pExcepInfo->bstrDescription)
				SysFreeString (pExcepInfo->bstrDescription);

			pExcepInfo->bstrDescription = MapHresultToWmiDescription (m_hResult);

			if (pExcepInfo->bstrSource)
				SysFreeString (pExcepInfo->bstrSource);

			pExcepInfo->bstrSource = SysAllocString (L"XMLTranslator");
			pExcepInfo->scode = m_hResult;
			
			hr = DISP_E_EXCEPTION;
		}
	}

	return hr;
}

BSTR MapHresultToWmiDescription (HRESULT hr)
{
	BSTR bsMessageText = NULL;

	// Used as our error code translator 
	IWbemStatusCodeText *pErrorCodeTranslator = NULL;

	HRESULT result = CoCreateInstance (CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
				IID_IWbemStatusCodeText, (LPVOID *) &pErrorCodeTranslator);
	
	if (SUCCEEDED (result))
	{
		HRESULT sc = pErrorCodeTranslator->GetErrorCodeText(
							hr, (LCID) 0, 0, &bsMessageText);	

		pErrorCodeTranslator->Release ();		
	}

	return bsMessageText;
}

//***************************************************************************
// HRESULT CXMLTranslator::get_SchemaURL
// HRESULT CXMLTranslator::put_SchemaURL
//
// DESCRIPTION:
//
// IWbemXMLTranslator methods for handling properties.
//
// Property Name			Function
//		SchemaURL				URL to locate DTD, if required
//
//***************************************************************************

HRESULT CXMLTranslator::get_SchemaURL (BSTR *pSchemaURL)
{
	if (pSchemaURL)
	{
		*pSchemaURL = NULL;

		EnterCriticalSection (&m_cs);
		if (m_schemaURL)
			*pSchemaURL = SysAllocString (m_schemaURL);
		LeaveCriticalSection (&m_cs);
	}

	return S_OK;
}

HRESULT CXMLTranslator::put_SchemaURL (BSTR schemaURL)
{
	if (!schemaURL)
		return WBEM_E_FAILED;

	EnterCriticalSection (&m_cs);
	if (m_schemaURL)
		SysFreeString (m_schemaURL);

	m_schemaURL = SysAllocString (schemaURL);
	LeaveCriticalSection (&m_cs);
	
	return S_OK;
}

//***************************************************************************
//
//  SCODE CXMLTranslator::GetObject
//
//  DESCRIPTION:
//
//  Transforms a single WBEM object into its equivalent XML representation
//
//  PARAMETERS:
//
//		pszNamespacePath		The namespace path in which the object resides
//		pszObjectPath			The relative (model) path of the object within
//								that namespace
//		pXML					On successful return addresses the XML document.
//								The caller is responsible for freeing this BSTR
//								using SysFreeString.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::GetObject (
	BSTR pszNamespacePath,
	BSTR pszObjectPath,
	BSTR *pXML
)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pXML) || (NULL == pszObjectPath))
		return WBEM_E_INVALID_PARAMETER;

	// We need to make sure that only relative object paths are supplied in the second argument
	CObjectPathParser pathParser (e_ParserAcceptRelativeNamespace);
	ParsedObjectPath  *pParsedPath;
	pathParser.Parse (pszObjectPath, &pParsedPath) ;
	if (pParsedPath)
	{
		if (pParsedPath->m_dwNumNamespaces != 0)
		{
			pathParser.Free(pParsedPath);
			return WBEM_E_INVALID_PARAMETER;
		}
		pathParser.Free(pParsedPath);
	}


	// Connect to the requested namespace
	IWbemServices	*pService = NULL;

	if (WBEM_S_NO_ERROR == (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
	{
		// Get the requested object
		IWbemClassObject *pObject = NULL;

		// Check to see if this version of WMI supports the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag
		// Otherwise, make a best effort call with no flags.
		// We need this to get the properties that have the "amended" qualifier on them
		// TODO - Remove this double call to GetObject() if not required anymore
		if(WBEM_E_INVALID_PARAMETER  == (hr = pService->GetObject (pszObjectPath, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, &pObject, NULL)))
			hr = pService->GetObject (pszObjectPath, 0, NULL, &pObject, NULL);
		if (WBEM_S_NO_ERROR == hr)
		{
			// Create a stream
			IStream *pStream = NULL;

			if (SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
			{
				// Now do the translation
				BSTR schemaURL = NULL;
				EnterCriticalSection (&m_cs);

				CWmiToXml	w2xml (pszNamespacePath, pStream, pObject, m_bAllowWMIExtensions, 
									m_iQualifierFilter,	m_bHostFilter, m_iDTDVersion,
									m_bNamespaceInDeclGroup, m_iClassOriginFilter, m_iDeclGroupType);

				if (m_schemaURL)
					schemaURL = SysAllocString (m_schemaURL);

				LeaveCriticalSection (&m_cs);
				
				if (SUCCEEDED(hr = w2xml.MapObject (schemaURL)))
					hr = SaveStreamAsBSTR (pStream, pXML);

				SysFreeString (schemaURL);
				pStream->Release ();
			}
			else
				hr = WBEM_E_FAILED;

			pObject->Release ();
		}
		pService->Release();
	}

	if (FAILED(hr))
		m_hResult = hr;

	return hr;
}

//***************************************************************************
//
//  SCODE CXMLTranslator::ExecQuery
//
//  DESCRIPTION:
//
//  Transforms the query result set nto its equivalent XML representation
//
//  PARAMETERS:
//
//		pszNamespacePath		The namespace path in which the object resides.
//		pszQueryString			The query to execute within	that namespace.
//		pXML					On successful return addresses the XML document.
//								The caller is responsible for freeing this BSTR
//								using SysFreeString.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, XML document is addressed by pXML
//	WBEM_E_INVALID_PARAMETER	bad input parameters
//  WBEM_E_FAILED				otherwise
//
//	Other WBEM error codes may be returned by ConnectServer etc., in which
//	case these are passed on to the caller.
//
//***************************************************************************

HRESULT CXMLTranslator::ExecQuery (
	BSTR pszNamespacePath,
	BSTR pszQueryString,
	BSTR *pXML
)
{
	HRESULT hr = WBEM_E_FAILED;

	if ((NULL == pXML) || (NULL == pszNamespacePath) || (NULL == pszQueryString))
		return WBEM_E_INVALID_PARAMETER;

	// Connect to the requested namespace
	IWbemServices	*pService = NULL;

	if (WBEM_S_NO_ERROR == (hr = m_connectionCache.GetConnectionByPath (pszNamespacePath, &pService)))
	{
		// Perform the query
		IEnumWbemClassObject *pEnum = NULL;
		BSTR pszQueryLanguage = SysAllocString (L"WQL");
		bool bMustFreeQueryString = false;

		// If we are doing a select, make sure we add in __CLASS, __PATH,  __GENUS and __SUPERCLASS
		// as we need these for our own internal use
		int i = 0;
		int len = wcslen (pszQueryString);

		while ((i < len) && iswspace (pszQueryString [i]))
			i++;
		
		if ((i < len) && (0 == _wcsnicmp (L"select", &pszQueryString [i], wcslen(L"select"))))
		{
			i += wcslen (L"select");

			// Is the next non-space character a *
			while ((i < len) && iswspace (pszQueryString [i]))
				i++;

			if ((i < len) && (L'*' != pszQueryString [i]))
			{
				// Need to add in the system properties
				BSTR sysProps = SysAllocString (L" __CLASS, __PATH, __GENUS, __SUPERCLASS, ");
				WCHAR *pNewQuery = new WCHAR [wcslen (pszQueryString) + wcslen (sysProps) + 1];
				wcscpy (pNewQuery, L"select");
				wcscat (pNewQuery, sysProps);
				wcscat (pNewQuery, &pszQueryString [i]);
				pszQueryString = SysAllocString (pNewQuery);
				bMustFreeQueryString = true;
				delete [] pNewQuery;
				SysFreeString (sysProps);
			}
		}

		
		// Check to see if this version of WMI supports the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag
		// Otherwise, make a best effort call with no flags.
		// We need this to get the properties that have the "amended" qualifier on them
		// TODO - Remove this double call to GetObject() if not required anymore
		if(WBEM_E_INVALID_PARAMETER  == (hr = pService->ExecQuery (pszQueryLanguage, pszQueryString,  WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, &pEnum)))
			hr = pService->ExecQuery (pszQueryLanguage, pszQueryString, 0, NULL, &pEnum);
		if (WBEM_S_NO_ERROR == hr)
		{
			// Create a stream
			IStream *pStream = NULL;

			if (SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
			{
				// Ensure we have impersonation enabled
				DWORD dwAuthnLevel, dwImpLevel;
				GetAuthImp (pEnum, &dwAuthnLevel, &dwImpLevel);

				if (RPC_C_IMP_LEVEL_IMPERSONATE != dwImpLevel)
					SetInterfaceSecurity (pEnum, NULL, NULL, NULL, dwAuthnLevel, RPC_C_IMP_LEVEL_IMPERSONATE, EOAC_STATIC_CLOAKING);

				// Now do the translation
				BSTR schemaURL = NULL;
				EnterCriticalSection (&m_cs);

				CWmiToXml	w2xml (pszNamespacePath, pStream, pEnum, m_bAllowWMIExtensions, 
									m_iQualifierFilter,	m_bHostFilter, m_iDTDVersion,
									m_bNamespaceInDeclGroup, m_iClassOriginFilter, m_iDeclGroupType);

				if (m_schemaURL)
					schemaURL = SysAllocString (m_schemaURL);

				LeaveCriticalSection (&m_cs);
				
				if (SUCCEEDED (hr = w2xml.MapEnum (schemaURL)))
					hr = SaveStreamAsBSTR (pStream, pXML);
				
				SysFreeString (schemaURL);
				pStream->Release ();
			}
			else
				hr = WBEM_E_FAILED;

			pEnum->Release ();
		}

		if (bMustFreeQueryString)
			SysFreeString (pszQueryString);

		SysFreeString (pszQueryLanguage);
		pService->Release();
	}

	if (FAILED(hr))
		m_hResult = hr;

	return hr;
}

//***************************************************************************
//
//  HRESULT CXMLTranslator::SaveStreamAsBSTR
//
//  DESCRIPTION:
//
//  Returns the stream contents as a single BSTR
//
//  PARAMETERS:
//
//		pStream			The stream from which the stream is to be extracted.
//		pBstr			Addresses the BSTR to hold the extracted string.  If
//						allocated by this function the caller must call
//						SysFreeString to release the mempory.
//
//  RETURN VALUES:
//
//  WBEM_S_NO_ERROR				success, pBstr contains the extracted text
//  WBEM_E_FAILED				otherwise
//
//***************************************************************************

HRESULT CXMLTranslator::SaveStreamAsBSTR (IStream *pStream, BSTR *pBstr)
{
	HRESULT hr = WBEM_E_FAILED;

	/*
	FILE *outputFile = fopen( "//xml.htm", "w");
	if(!outputFile)
		return WBEM_E_FAILED;
	*/


	// Write the XML into the supplied BSTR

	STATSTG statstg;
	if (SUCCEEDED(pStream->Stat(&statstg, STATFLAG_NONAME)))
	{
		ULONG cbSize = (statstg.cbSize).LowPart;
		OLECHAR *pText = new OLECHAR [(cbSize/2) + 1];

		if (SUCCEEDED(pStream->Read(pText, cbSize, NULL)))
		{
			// Terminate the string
			pText [cbSize/2] = NULL;

			// The following must be freed by the caller using SysFreeString
			*pBstr =SysAllocString (pText);
			delete [] pText;
			hr = WBEM_S_NO_ERROR;
		}
	}

	// fclose(outputFile);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\adapters\xml\wmixmlt\wmi2xml.cpp ===
//***************************************************************************
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
//  WBEM2XML.CPP
//
//  alanbos  18-Feb-98   Created.
//
//  The WBEM -> XML translator
//
//***************************************************************************

#include "precomp.h"

static BYTE NEWLINE [] = { 0x0D, 0x00, 0x0A, 0x00 };
static BYTE UTF16SIG [] = { 0xFF, 0xFE };
static OLECHAR *CDATASTART = OLESTR("<![CDATA[");
static OLECHAR *CDATAEND = OLESTR("]]>");
static OLECHAR *AMPERSAND = OLESTR("&amp;");
static OLECHAR *LEFTCHEVRON = OLESTR("&lt;");
static OLECHAR *RIGHTCHEVRON = OLESTR("&gt;");

//***************************************************************************
//
//  CWmiToXml::CWmiToXml
//
//  DESCRIPTION:
//
//  Constructor: Used for GetObject invocations
//
//***************************************************************************

CWmiToXml::CWmiToXml(BSTR bsNamespacePath,
					IStream *pStream, IWbemClassObject *pObject,
					VARIANT_BOOL bAllowWMIExtensions,
					WmiXMLFilterEnum iQualifierFilter,
					VARIANT_BOOL bHostFilter,
					WmiXMLDTDVersionEnum iDTDVersion,
					VARIANT_BOOL bNamespaceInDeclGroup,
					WmiXMLClassOriginFilterEnum	iClassOriginFilter,
					WmiXMLDeclGroupTypeEnum	iDeclGroupType)
{
	m_pStream = pStream;
	m_pStream->AddRef ();
	m_pObject = pObject;
	m_pObject->AddRef ();
	m_pEnum = NULL;
	m_bAllowWMIExtensions = bAllowWMIExtensions;
	m_iQualifierFilter = iQualifierFilter;
	m_iDTDVersion = iDTDVersion;
	m_bHostFilter = bHostFilter;
	m_bIsClass = false;
	m_bsNamespacePath = SysAllocString(bsNamespacePath); 
	m_bNamespaceInDeclGroup = bNamespaceInDeclGroup;
	m_iClassOriginFilter = iClassOriginFilter;
	m_iDeclGroupType = iDeclGroupType;
}

//***************************************************************************
//
//  CWmiToXml::CWmiToXml
//
//  DESCRIPTION:
//
//  Constructor: Used for ExecQuery invocations
//
//***************************************************************************

CWmiToXml::CWmiToXml(BSTR bsNamespacePath,
					IStream *pStream, IEnumWbemClassObject *pEnum,
					VARIANT_BOOL bAllowWMIExtensions,
					WmiXMLFilterEnum iQualifierFilter,
					VARIANT_BOOL bHostFilter,
					WmiXMLDTDVersionEnum iDTDVersion,
					VARIANT_BOOL bNamespaceInDeclGroup,
					WmiXMLClassOriginFilterEnum	iClassOriginFilter,
					WmiXMLDeclGroupTypeEnum	iDeclGroupType)
{
	m_pStream = pStream;
	m_pStream->AddRef ();
	m_pEnum = pEnum;
	m_pEnum->AddRef ();
	m_pObject = NULL;
	m_bAllowWMIExtensions = bAllowWMIExtensions;
	m_iQualifierFilter = iQualifierFilter;
	m_iDTDVersion = iDTDVersion;
	m_bHostFilter = bHostFilter;
	m_bIsClass = false;
	m_bsNamespacePath = SysAllocString(bsNamespacePath); 
	m_bNamespaceInDeclGroup = bNamespaceInDeclGroup;
	m_iClassOriginFilter = iClassOriginFilter;
	m_iDeclGroupType = iDeclGroupType;
}

//***************************************************************************
//
//  CWmiToXml::~CWmiToXml
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CWmiToXml::~CWmiToXml(void)
{
    if (m_pStream)
		m_pStream->Release ();

	if (m_pObject)
		m_pObject->Release ();

	if (m_pEnum)
		m_pEnum->Release ();

	SysFreeString (m_bsNamespacePath);
}

STDMETHODIMP CWmiToXml::MapCommonHeaders (BSTR pszSchemaURL)
{
	// WRITESIG
	WRITEBSTR(OLESTR("<?xml version=\"1.0\" ?>"))
	WRITENL
	
	if (pszSchemaURL)
	{
		WRITEBSTR(OLESTR("<!DOCTYPE CIM SYSTEM \""))
		WRITEBSTR(pszSchemaURL)
		WRITEBSTR(OLESTR("\">"))
		WRITENL
	}

	WRITEBSTR(OLESTR("<CIM CIMVERSION=\"2.0\" DTDVERSION=\"2.0\" >"))
	WRITENL
	WRITEBSTR(OLESTR("<DECLARATION>"))
	WRITENL
	return S_OK;
}

STDMETHODIMP CWmiToXml::MapDeclGroupHeaders ()
{
	switch(m_iDeclGroupType)
	{
		case wmiXMLDeclGroup:
			WRITEBSTR(OLESTR("<DECLGROUP>"))
			WRITENL
			if (m_bNamespaceInDeclGroup == VARIANT_TRUE)
				MapNamespacePath (m_bsNamespacePath);
			break;
		case wmiXMLDeclGroupWithName:
			WRITEBSTR(OLESTR("<DECLGROUP.WITHNAME>"))
			WRITENL
			if (m_bNamespaceInDeclGroup == VARIANT_TRUE)
				MapNamespacePath (m_bsNamespacePath);
			break;
		case wmiXMLDeclGroupWithPath:
			WRITEBSTR(OLESTR("<DECLGROUP.WITHPATH>"))
			WRITENL
			break;
	}


	return S_OK;
}

STDMETHODIMP CWmiToXml::MapDeclGroupTrailers ()
{
	switch(m_iDeclGroupType)
	{
		case wmiXMLDeclGroup:
			WRITEBSTR(OLESTR("</DECLGROUP>"))
			WRITENL
			break;
		case wmiXMLDeclGroupWithName:
			WRITEBSTR(OLESTR("</DECLGROUP.WITHNAME>"))
			WRITENL
			break;
		case wmiXMLDeclGroupWithPath:
			WRITEBSTR(OLESTR("</DECLGROUP.WITHPATH>"))
			WRITENL
			break;
	}
	return S_OK;
}

STDMETHODIMP CWmiToXml::MapCommonTrailers ()
{
	WRITEBSTR(OLESTR("</DECLARATION>"))
	WRITEBSTR(OLESTR("</CIM>"))

	return S_OK;
}


STDMETHODIMP CWmiToXml::MapEnum (BSTR pszSchemaURL)
{
	HRESULT hr = S_OK;
	ULONG	dummy = 0;

	
	// Map the Headers
	MapCommonHeaders(pszSchemaURL);

	// We need to optimize on DeclGroup generation in case of an Association query where
	// the namespaces of the resulting objects might not be unique. In this case, the best alogirithm
	// would be the one that sorts the resulting objects into different namespaces and generates on declgroup
	// declaration per unique namespace. However, this requires a bidirectional enumerator which we want
	// to avoid due to high memory consumption. Hence we use a semi-optimal algorithm in which the rule is 
	// we do not generate a new DeclGroup if the namespace of the current object is the same as that of
	// the previous object in the output (or the enumerator).

	BSTR strLastNamespacePath = NULL;

	while (SUCCEEDED(hr) && SUCCEEDED(hr = m_pEnum->Next (INFINITE, 1, &m_pObject, &dummy)) && dummy != 0)
	{
		BSTR strCurrentNamespace = GetNamespace(m_pObject);
		if(strCurrentNamespace)
		{
			if( !strLastNamespacePath ||
				_wcsicmp(strLastNamespacePath, strCurrentNamespace) != 0)
			{
				if(strLastNamespacePath)
					MapDeclGroupTrailers();
				MapDeclGroupHeaders();
				if (strLastNamespacePath)
					SysFreeString(strLastNamespacePath);
				strLastNamespacePath = SysAllocString(strCurrentNamespace); 
			}
			SysFreeString(strCurrentNamespace);

			// Map the object to XML
			hr = MapObjectWithoutHeaders ();

		}
		m_pObject->Release ();
		m_pObject = NULL;
	}
	if(strLastNamespacePath)
	{
		MapDeclGroupTrailers();
		SysFreeString(strLastNamespacePath);
	}

	// Write the trailers
	MapCommonTrailers();

	LARGE_INTEGER	offset;
	offset.LowPart = offset.HighPart = 0;
	m_pStream->Seek (offset, STREAM_SEEK_SET, NULL);
	
	return hr;
}

STDMETHODIMP CWmiToXml::MapObject (BSTR pszSchemaURL)
{
	// Map the Headers
	MapCommonHeaders(pszSchemaURL);
	MapDeclGroupHeaders();

	HRESULT hr = MapObjectWithoutHeaders();

	// Write the trailers
	MapDeclGroupTrailers();
	MapCommonTrailers();

	LARGE_INTEGER	offset;
	offset.LowPart = offset.HighPart = 0;
	m_pStream->Seek (offset, STREAM_SEEK_SET, NULL);
	
	return hr;
}


STDMETHODIMP CWmiToXml::MapObjectWithoutHeaders ()
{
	HRESULT hr = WBEM_E_FAILED;
	IWbemQualifierSet *pQualSet= NULL;
	m_pObject->GetQualifierSet (&pQualSet);

	VARIANT var;
	VariantInit (&var);
	
	// Is this a class or an instance
	long flav = 0;
	
	if (SUCCEEDED (m_pObject->Get(L"__GENUS", 0, &var, NULL, &flav)))
		m_bIsClass = (WBEM_GENUS_CLASS == var.lVal);

	switch(m_iDeclGroupType)
	{
		case wmiXMLDeclGroup:
			WRITEBSTR(OLESTR("<VALUE.OBJECT>"));
			WRITENL
			hr = (m_bIsClass) ? MapClass (pQualSet) : MapInstance (pQualSet);
			WRITEBSTR(OLESTR("</VALUE.OBJECT>"));
			WRITENL
			break;
		case wmiXMLDeclGroupWithName:
			WRITEBSTR(OLESTR("<VALUE.NAMEDOBJECT>"));
			WRITENL
			hr = (m_bIsClass) ? MapClass (pQualSet) : MapNamedInstance (pQualSet);
			WRITEBSTR(OLESTR("</VALUE.NAMEDOBJECT>"));
			WRITENL
			break;
		case wmiXMLDeclGroupWithPath:
			WRITEBSTR(OLESTR("<VALUE.OBJECTWITHPATH>"));
			WRITENL
			hr = (m_bIsClass) ? MapWithPathClass (pQualSet) : MapWithPathInstance (pQualSet);
			WRITEBSTR(OLESTR("</VALUE.OBJECTWITHPATH>"));
			WRITENL
			break;
	}


	if (pQualSet)
		pQualSet->Release ();

	VariantClear (&var);
	return hr;
}
STDMETHODIMP CWmiToXml::MapWithPathClass (IWbemQualifierSet *pQualSet)
{
	// First map an element of type CLASSPATH
	//==========================================
	HRESULT hr = WBEM_E_FAILED;

	// Get the __PATH of the object
	VARIANT var;
	VariantInit (&var);
	if (WBEM_S_NO_ERROR == m_pObject->Get(L"__PATH", 0, &var, NULL, NULL))
	{
		// Parse the object path
		CObjectPathParser pathParser (e_ParserAcceptRelativeNamespace);
		ParsedObjectPath  *pParsedPath;
		pathParser.Parse (var.bstrVal, &pParsedPath) ;

		if (pParsedPath)
		{
			if(SUCCEEDED(MapClassPath (pParsedPath)))
				hr = MapClass(pQualSet);
			pathParser.Free(pParsedPath);
		}

		VariantClear(&var);
	}
	return hr;
}

STDMETHODIMP CWmiToXml::MapClass (IWbemQualifierSet *pQualSet)
{
	HRESULT hr = WBEM_E_FAILED;
	VARIANT var;
	VariantInit (&var);
	long flav = 0;
	BSTR bsClass = NULL;
	BSTR bsSuperClass = NULL;

	// Get the class attribute
	if (WBEM_S_NO_ERROR == m_pObject->Get(L"__CLASS", 0, &var, NULL, &flav))
		if ((VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
			bsClass = SysAllocString (var.bstrVal);

	VariantClear (&var);
	
	// Get the superclass attribute
	if (WBEM_S_NO_ERROR == m_pObject->Get(L"__SUPERCLASS", 0, &var, NULL, &flav))
		if ((VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
			bsSuperClass = SysAllocString (var.bstrVal);

	VariantClear (&var);
		
	if (pQualSet)
	{
		WRITEBSTR(OLESTR("<CLASS NAME=\""))
			
		// Write the CLASSNAME
		WRITEBSTR(bsClass)
		WRITEBSTR(OLESTR("\""))
	
		// Write the superclass if specified
		if (bsSuperClass)
		{
			WRITEBSTR(OLESTR(" SUPERCLASS=\""))
			WRITEBSTR(bsSuperClass)
			WRITEBSTR(OLESTR("\""))
		}
				
		WRITEBSTR(OLESTR(">"))
		WRITENL

		if (SUCCEEDED(hr = MapQualifiers (pQualSet)))
			if (SUCCEEDED(hr = MapProperties()))
					hr = MapMethods ();

		WRITEBSTR(OLESTR("</CLASS>"))
		
		WRITENL
	}
	
	SysFreeString (bsClass);
	SysFreeString (bsSuperClass);	
	return hr;
}

STDMETHODIMP CWmiToXml::MapClassPath (ParsedObjectPath *pParsedPath)
{
	HRESULT hr = WBEM_E_FAILED;
	
	WRITEBSTR(OLESTR("<CLASSPATH>"))
	WRITENL
	MapNamespacePath (pParsedPath);
	WRITENL	
	MapClassName (pParsedPath->m_pClass);	
	WRITEBSTR(OLESTR("</CLASSPATH>"))
	
	return S_OK;
}

STDMETHODIMP CWmiToXml::MapLocalClassPath (ParsedObjectPath *pParsedPath)
{
	HRESULT hr = WBEM_E_FAILED;
	
	WRITEBSTR(OLESTR("<LOCALCLASSPATH>"))
	WRITENL
	MapLocalNamespacePath (pParsedPath);
	WRITENL	
	MapClassName (pParsedPath->m_pClass);	
	WRITEBSTR(OLESTR("</LOCALCLASSPATH>"))
	
	return S_OK;
}

STDMETHODIMP CWmiToXml::MapClassName (BSTR bsClassName)
{
	WRITEBSTR(OLESTR("<CLASSNAME NAME=\""))
	WRITEBSTR(bsClassName)
	WRITEBSTR(OLESTR("\"/>"))
	return S_OK;
}
		
STDMETHODIMP CWmiToXml::MapNamedInstance (IWbemQualifierSet *pQualSet)
{
	// First map an element of type INSTANCENAME
	//==========================================
	HRESULT hr = WBEM_E_FAILED;

	// Get the __RELPATH of the object
		VARIANT var;
		VariantInit (&var);
	if (WBEM_S_NO_ERROR == m_pObject->Get(L"__PATH", 0, &var, NULL, NULL))
	{
		// Parse the object path
		CObjectPathParser pathParser (e_ParserAcceptRelativeNamespace);
		ParsedObjectPath  *pParsedPath;
		pathParser.Parse (var.bstrVal, &pParsedPath) ;

		if (pParsedPath)
		{
			if(SUCCEEDED(MapInstanceName (pParsedPath)))
			{
				hr = MapInstance(pQualSet);
			}
			pathParser.Free(pParsedPath);
		}

		VariantClear(&var);
	}
	return hr;
}

STDMETHODIMP CWmiToXml::MapWithPathInstance (IWbemQualifierSet *pQualSet)
{
	// First map an element of type INSTANCEPATH
	//==========================================
	HRESULT hr = WBEM_E_FAILED;

	// Get the __RELPATH of the object
		VARIANT var;
		VariantInit (&var);
	if (WBEM_S_NO_ERROR == m_pObject->Get(L"__PATH", 0, &var, NULL, NULL))
	{
		// Parse the object path
		CObjectPathParser pathParser (e_ParserAcceptRelativeNamespace);
		ParsedObjectPath  *pParsedPath;
		pathParser.Parse (var.bstrVal, &pParsedPath) ;

		if (pParsedPath)
		{
			if(SUCCEEDED(MapInstancePath (pParsedPath)))
				hr = MapInstance(pQualSet);
			pathParser.Free(pParsedPath);
		}

		VariantClear(&var);
	}
	return hr;
}


STDMETHODIMP CWmiToXml::MapInstance (IWbemQualifierSet *pQualSet)
{
	HRESULT hr = WBEM_E_FAILED;

	if (pQualSet)
	{
		WRITEBSTR(OLESTR("<INSTANCE CLASSNAME=\""))

		VARIANT var;
		VariantInit (&var);
		long flav = 0;
		BSTR bsClass = NULL;
		
		// Get the class attribute
		if (WBEM_S_NO_ERROR == m_pObject->Get(L"__CLASS", 0, &var, NULL, &flav))
			if ((VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
				bsClass = SysAllocString (var.bstrVal);

		VariantClear (&var);

		// Map the class name
		// Write the CLASSNAME
		WRITEBSTR(bsClass)
		WRITEBSTR(OLESTR("\">"))
		WRITENL

		if (SUCCEEDED (hr = MapQualifiers (pQualSet)))
				hr = MapProperties ();

		WRITEBSTR(OLESTR("</INSTANCE>"))

		WRITENL

		SysFreeString (bsClass);
	}
	
	return hr;
}

STDMETHODIMP CWmiToXml::MapInstancePath (ParsedObjectPath *pParsedPath)
{
	WRITEBSTR(OLESTR("<INSTANCEPATH>"))
	WRITENL
	MapNamespacePath (pParsedPath);
	WRITENL
	MapInstanceName (pParsedPath);
	WRITENL
	WRITEBSTR(OLESTR("</INSTANCEPATH>"))
	return S_OK;
}

STDMETHODIMP CWmiToXml::MapLocalInstancePath (ParsedObjectPath *pParsedPath)
{
	WRITEBSTR(OLESTR("<LOCALINSTANCEPATH>"))
	WRITENL
	MapLocalNamespacePath (pParsedPath);
	WRITENL
	MapInstanceName (pParsedPath);
	WRITENL
	WRITEBSTR(OLESTR("</LOCALINSTANCEPATH>"))
	return S_OK;
}

STDMETHODIMP CWmiToXml::MapInstanceName (ParsedObjectPath *pParsedPath)
{
	WRITEBSTR(OLESTR("<INSTANCENAME CLASSNAME=\""))
	WRITEBSTR(pParsedPath->m_pClass)
	WRITEBSTR(OLESTR("\">"))
	WRITENL

	// Now write the key bindings - only if not singleton
	if (!(pParsedPath->m_bSingletonObj))
	{
		if ((1 == pParsedPath->m_dwNumKeys) &&
			!((pParsedPath->m_paKeys [0])->m_pName))
		{
			// Use the short form
			WRITENL
			MapKeyValue ((pParsedPath->m_paKeys [0])->m_vValue);
			WRITENL
		}
		else
		{
			for (DWORD numKey = 0; numKey < pParsedPath->m_dwNumKeys; numKey++)
			{
				WRITEBSTR(OLESTR("<KEYBINDING "))
				
				// Write the key name
				WRITEBSTR(OLESTR(" NAME=\""))
				WRITEBSTR((pParsedPath->m_paKeys [numKey])->m_pName)
				WRITEBSTR(OLESTR("\">"))
				WRITENL

				// Write the key value
				MapKeyValue ((pParsedPath->m_paKeys [numKey])->m_vValue);
				WRITENL

				WRITEBSTR(OLESTR("</KEYBINDING>"))
				WRITENL
			}
		}
	}

	WRITEBSTR(OLESTR("</INSTANCENAME>"))
	return S_OK;
}

STDMETHODIMP CWmiToXml::MapNamespacePath (BSTR bsNamespacePath)
{
	CObjectPathParser pathParser (e_ParserAcceptRelativeNamespace);
	ParsedObjectPath  *pParsedPath;
	pathParser.Parse (bsNamespacePath, &pParsedPath) ;

	if (pParsedPath)
	{
		MapNamespacePath (pParsedPath);
		delete pParsedPath;
	}

	return S_OK;
}

STDMETHODIMP CWmiToXml::MapNamespacePath (ParsedObjectPath *pParsedPath)
{
	WRITEBSTR(OLESTR("<NAMESPACEPATH>"))
	WRITENL
	WRITEBSTR(OLESTR("<HOST>"))

	HRESULT hr = WBEM_S_NO_ERROR;

	if (VARIANT_TRUE == m_bHostFilter)
	{
		if (pParsedPath->m_pServer && _wcsicmp(pParsedPath->m_pServer, L"."))
			WRITEWSTR(pParsedPath->m_pServer)
		else // Use GetComputerName to get the name of the machine
		{
			LPWSTR pszHostName = NULL;
			if(pszHostName = GetHostName())
			{
				WRITEBSTR(pszHostName)
				delete [] pszHostName;
			}
			else
				hr = E_FAIL;
		}
	}
	else 
		WRITEBSTR(OLESTR("."))
			
	WRITEBSTR(OLESTR("</HOST>"))
	WRITENL

	// If this value has no namespace component use the object's namespace path
	if (0 < pParsedPath->m_dwNumNamespaces)
		MapLocalNamespacePath (pParsedPath);
	
	WRITEBSTR(OLESTR("</NAMESPACEPATH>"))
	WRITENL

	return hr;
}

STDMETHODIMP CWmiToXml::MapLocalNamespacePath (ParsedObjectPath *pObjectPath)
{
	WRITEBSTR(OLESTR("<LOCALNAMESPACEPATH>"))
	WRITENL

	for (DWORD dwIndex = 0; dwIndex < pObjectPath->m_dwNumNamespaces; dwIndex++)
	{
		WRITEBSTR(OLESTR("<NAMESPACE NAME=\""))
		WRITEWSTR(pObjectPath->m_paNamespaces [dwIndex])
		WRITEBSTR(OLESTR("\"/>"))
		WRITENL
	}

	WRITEBSTR(OLESTR("</LOCALNAMESPACEPATH>"))

	return WBEM_S_NO_ERROR;
}
			
STDMETHODIMP CWmiToXml::MapReference (BSTR name, VARIANT &var, long flavor)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	IWbemQualifierSet *pQualSet = NULL;

	if (WBEM_S_NO_ERROR == m_pObject->GetPropertyQualifierSet (name, &pQualSet))
	{
		WRITEBSTR(OLESTR("<PROPERTY.REFERENCE NAME=\""))

		// The property name
		WRITEBSTR(name)
		WRITEBSTR(OLESTR("\""))

		// The originating class of this property
		BSTR propertyOrigin = NULL;
		
		if (WBEM_S_NO_ERROR == m_pObject->GetPropertyOrigin (name, &propertyOrigin))
		{
			MapClassOrigin (propertyOrigin);
			SysFreeString(propertyOrigin);
		}

		MapLocal (flavor);

		// The strong class of this property
		MapStrongType (pQualSet);

		WRITEBSTR(OLESTR(">"))
		WRITENL

		// Map the qualifiers
		MapQualifiers (pQualSet);
		pQualSet->Release ();

		MapReferenceValue (var);

		WRITEBSTR(OLESTR("</PROPERTY.REFERENCE>"))
		WRITENL
	}

	return hr;
}

//***************************************************************************
//
//  CWmiToXml::IsReference
//
//  DESCRIPTION:
//
//		The purpose of this function is to examine a single
//		VARIANT value and determine whether it represents a 
//		reference or not.
//
//		This is required because when mapping from a reference
//		property value we may encounter nested references within
//		the object path.  Unfortunately the object path syntax
//		is such that we cannot be certain whether a key value
//		represents a reference or a string, datetime or char
//		property.  (This is because a textual object path does
//		not contain as much information as its XML equivalent.)
//
//		This function performs a heuristic test on the value to
//		determine whether it is a reference.
//  
//***************************************************************************

ParsedObjectPath *CWmiToXml::IsReference (VARIANT &var)
{
	ParsedObjectPath *pObjectPath = NULL;

	// TODO - could get the class of which this is a property value
	// and retrieve the type of the current key property - that would
	// be the authoritative answer but it doesn't come cheap.

	if ((VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
	{
		bool isValidPath = false;

		// Parse the object path
		CObjectPathParser	parser (e_ParserAcceptRelativeNamespace);
		BOOL status = parser.Parse (var.bstrVal, &pObjectPath);

		if ((0 == status) && pObjectPath)
		{
			// If it's an instance path we should be OK
			if (pObjectPath->IsInstance ())
				isValidPath = true;
			else if (pObjectPath->IsClass ())
			{
				// Hmmm - could be a classpath.  If we have a server
				// and some namespaces that would be a lot better

				if (pObjectPath->m_pServer && (0 < pObjectPath->m_dwNumNamespaces))
					isValidPath = true;
				else
				{
					// A potential local class path
					// TODO - try grabbing the class to see if it exists in
					// the current namespace.
				}
			}
		}

		if (!isValidPath)
		{
			// Reject for now - too ambiguous
			parser.Free(pObjectPath);
			pObjectPath = NULL;
		}
	}
	
	return pObjectPath;
}

void CWmiToXml::MapReferenceValue (VARIANT &var)
{
	// Map the value - this will be a classpath or instancepath
	if ((VT_BSTR == var.vt) && (NULL != var.bstrVal) && (wcslen (var.bstrVal) > 0))
	{
		// Parse the object path
		CObjectPathParser	parser (e_ParserAcceptRelativeNamespace);
		ParsedObjectPath  *pObjectPath = NULL;
		BOOL status = parser.Parse (var.bstrVal, &pObjectPath) ;
		
		if ((0 == status) && pObjectPath && (pObjectPath->IsClass () || pObjectPath->IsInstance ()))
			MapReferenceValue (pObjectPath);

		if (pObjectPath)
			parser.Free(pObjectPath);
	}
}

void CWmiToXml::MapReferenceValue (ParsedObjectPath  *pObjectPath)
{		
	WRITEBSTR(OLESTR("<VALUE.REFERENCE>"))
	WRITENL

	bool bIsAbsolutePath = (NULL != pObjectPath->m_pServer);
	bool bIsRelativePath = false;

	if (!bIsAbsolutePath)
		bIsRelativePath = (0 < pObjectPath->m_dwNumNamespaces);

	// Is this is a class or is it an instance?
	if (pObjectPath->IsClass ())
	{
		if (bIsAbsolutePath)
			MapClassPath (pObjectPath);
		else if (bIsRelativePath)
			MapLocalClassPath (pObjectPath);
		else
			MapClassName (pObjectPath->m_pClass);
	}
	else if (pObjectPath->IsInstance ())
	{
		if (bIsAbsolutePath)
			MapInstancePath (pObjectPath);
		else if (bIsRelativePath)
			MapLocalInstancePath (pObjectPath);
		else
			MapInstanceName (pObjectPath);
	}

	WRITENL
	WRITEBSTR(OLESTR("</VALUE.REFERENCE>"))
}

STDMETHODIMP CWmiToXml::MapQualifiers (
			IWbemQualifierSet *pQualSet, IWbemQualifierSet *pQualSet2)
{
	if (wmiXMLFilterNone != m_iQualifierFilter)
	{
		// Map the requested filter to the flags value - default is ALL
		LONG lFlags = 0;

		if (wmiXMLFilterLocal == m_iQualifierFilter)
			lFlags = WBEM_FLAG_LOCAL_ONLY;
		else if (wmiXMLFilterPropagated == m_iQualifierFilter)
			lFlags = WBEM_FLAG_PROPAGATED_ONLY;

		pQualSet->BeginEnumeration (lFlags);

		VARIANT var;
		VariantInit (&var);
		long flavor = 0;
		BSTR name = NULL;
		
		while (WBEM_S_NO_ERROR  == pQualSet->Next (0, &name, &var, &flavor))
		{
			MapQualifier (name, flavor, var);
			SysFreeString (name);
			name = NULL;
			VariantClear (&var);
		}

		pQualSet->EndEnumeration ();

		// Now check the subsiduary set for any qualifiers not in the first set
		if (pQualSet2)
		{
			pQualSet2->BeginEnumeration (lFlags);
			
			while (WBEM_S_NO_ERROR == pQualSet2->Next (0, &name, &var, &flavor))
			{
				// Is this qualifier in the primary set?
				if (WBEM_E_NOT_FOUND == pQualSet->Get (name, 0, NULL, NULL))
					MapQualifier (name, flavor, var);

				SysFreeString (name);
				name = NULL;
				VariantClear (&var);
			}
				
			pQualSet2->EndEnumeration ();
		}
	}

	return WBEM_S_NO_ERROR;
}

void CWmiToXml::MapLocal (long flavor)
{
	// default is false
	if (WBEM_FLAVOR_ORIGIN_PROPAGATED == (WBEM_FLAVOR_MASK_ORIGIN & flavor))
		WRITEBSTR(OLESTR(" PROPAGATED=\"true\""))
}

STDMETHODIMP CWmiToXml::MapQualifier (BSTR name, long flavor, VARIANT &var)
{
	// The qualifier name
	WRITEBSTR(OLESTR("<QUALIFIER NAME=\""))
	WRITEBSTR(name)
	WRITEBSTR(OLESTR("\""))
	MapLocal (flavor);
	
	// The qualifier CIM type
	WRITEBSTR(OLESTR(" TYPE=\""))
	switch (var.vt & ~VT_ARRAY)
	{
		case VT_I4:
			WRITEBSTR(OLESTR("sint32"))
			break;

		case VT_R8:
			WRITEBSTR(OLESTR("real64"))
			break;

		case VT_BOOL:
			WRITEBSTR(OLESTR("boolean"))
			break;

		case VT_BSTR:
			WRITEBSTR(OLESTR("string"))
			break;
	}

	WRITEBSTR(OLESTR("\""))

	// Whether the qualifier is overridable - default is true
	if (WBEM_FLAVOR_NOT_OVERRIDABLE == (WBEM_FLAVOR_MASK_PERMISSIONS & flavor))
		WRITEBSTR(OLESTR(" OVERRIDABLE=\"false\""))
	
	// Whether the qualifier is propagated to subclasses - default is true
	if (!(WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS & flavor))
		WRITEBSTR(OLESTR(" TOSUBCLASS=\"false\""))

	// Whether the qualifier is propagated to instances - default is false
	if ((WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE & flavor))
		WRITEBSTR(OLESTR(" TOINSTANCE=\"true\""))
		
	// Currently set TRANSLATABLE as "false" by default

	WRITEBSTR(OLESTR(">"))
	WRITENL

	// Now map the value
	MapValue (var);

	WRITEBSTR(OLESTR("</QUALIFIER>"))
	WRITENL

	return WBEM_S_NO_ERROR;
}
			
STDMETHODIMP CWmiToXml::MapValue (VARIANT &var)
{
	if (VT_NULL == var.vt)
		return WBEM_S_NO_ERROR;

	if (var.vt & VT_ARRAY)
	{
		long uBound = 0;
		if (FAILED(SafeArrayGetUBound (var.parray, 1, &uBound)))
			return WBEM_E_FAILED;

		WRITEBSTR(OLESTR("<VALUE.ARRAY>"))

		for (long i = 0; i <= uBound; i++)
		{
			WRITEBSTR(OLESTR("<VALUE>"))
			
			// Write the value itself
			switch (var.vt & ~VT_ARRAY)
			{
				case VT_I4:
				{
					long val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapLongValue (val);
				}
					break;

				case VT_R8:
				{
					double val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapDoubleValue (val);
				}
					break;

				case VT_BOOL:
				{
					VARIANT_BOOL val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapBoolValue ((val) ? true : false);					
				}
					break;

				case VT_BSTR:
				{
					BSTR val = NULL;
					SafeArrayGetElement (var.parray, &i, &val);
					MapStringValue (val);
					SysFreeString (val);
				}
					break;
			}
			WRITEBSTR(OLESTR("</VALUE>"))
			WRITENL
		}

		WRITEBSTR(OLESTR("</VALUE.ARRAY>"))
	}
	else
	{	
		// Simple value
		WRITEBSTR(OLESTR("<VALUE>"))
		switch (var.vt)
		{
			case VT_I4:
				MapLongValue (var.lVal);
				break;

			case VT_R8:
				MapDoubleValue (var.dblVal);
				break;
 
			case VT_BOOL:
				MapBoolValue ((var.boolVal) ? true : false);
				break;

			case VT_BSTR:
				MapStringValue (var.bstrVal);
				break;
		}

		WRITEBSTR(OLESTR("</VALUE>"))
	}

	WRITENL

	return WBEM_S_NO_ERROR;
}


STDMETHODIMP CWmiToXml::MapKeyValue (VARIANT &var)
{
	ParsedObjectPath *pObjectPath = NULL;
	
	if (pObjectPath = IsReference (var))
	{
		MapReferenceValue (pObjectPath);
		WRITENL
		delete pObjectPath;
	}
	else
	{
		// Simple value
		WRITEBSTR(OLESTR("<KEYVALUE"))

		switch (var.vt)
		{
			case VT_I4:
				WRITEBSTR(OLESTR(" VALUETYPE=\"numeric\">"))
				MapLongValue (var.lVal);
				break;

			case VT_R8:
				WRITEBSTR(OLESTR(" VALUETYPE=\"numeric\">"))
				MapDoubleValue (var.dblVal);
				break;
 
			case VT_BOOL:
				WRITEBSTR(OLESTR(" VALUETYPE=\"boolean\">"))
				MapBoolValue ((var.boolVal) ? true : false);
				break;
				
			case VT_BSTR:
				WRITEBSTR(OLESTR(">"))
				MapStringValue (var.bstrVal);
				break;
		}

		WRITEBSTR(OLESTR("</KEYVALUE>"))
	}

	return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWmiToXml::MapProperties ()
{
	m_pObject->BeginEnumeration (WBEM_FLAG_NONSYSTEM_ONLY);

	VARIANT var;
	VariantInit (&var);
	long flavor = 0;
	CIMTYPE cimtype = CIM_ILLEGAL;
	BSTR name = NULL;

	while (WBEM_S_NO_ERROR  == m_pObject->Next (0, &name, &var, &cimtype, &flavor))
	{
		switch (cimtype & ~CIM_FLAG_ARRAY)
		{
			case CIM_OBJECT:
				MapObjectProperty (name, var, (cimtype & CIM_FLAG_ARRAY) ? true : false, flavor);
				break;

			case CIM_REFERENCE:
				MapReference (name, var, flavor);
				break;

			default:
				MapProperty (name, var, cimtype & ~CIM_FLAG_ARRAY, 
										(cimtype & CIM_FLAG_ARRAY) ? true : false, flavor);
				break;
		}

		SysFreeString (name);
		VariantClear (&var);
	}

	m_pObject->EndEnumeration ();
	return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWmiToXml::MapProperty (BSTR name, VARIANT &var, CIMTYPE cimtype, 
										bool isArray, long flavor)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	IWbemQualifierSet *pQualSet= NULL;
			
	if (WBEM_S_NO_ERROR == (hr = m_pObject->GetPropertyQualifierSet (name, &pQualSet)))
	{
		// The property name
		if (isArray)
			WRITEBSTR(OLESTR("<PROPERTY.ARRAY NAME=\""))
		else
			WRITEBSTR(OLESTR("<PROPERTY NAME=\""))
		WRITEBSTR(name)
		WRITEBSTR(OLESTR("\""));
			
		// The originating class of this property
		BSTR propertyOrigin = NULL;

		if (WBEM_S_NO_ERROR == m_pObject->GetPropertyOrigin (name, &propertyOrigin))
		{
			MapClassOrigin (propertyOrigin);
			SysFreeString(propertyOrigin);
		}

		MapLocal (flavor);

		// The property CIM type
		hr = MapType (cimtype);

		// Map the Array Size attribute if this is an array type
		if (isArray)
			MapArraySize (pQualSet);
		
		WRITEBSTR(OLESTR(">"))
		WRITENL

		// Map the qualifiers (note that system properties have no qualifiers)
		MapQualifiers (pQualSet);

		// Now map the value
		hr = MapValue (cimtype, isArray, var);

		if (isArray)
			WRITEBSTR(OLESTR("</PROPERTY.ARRAY>"))
		else
			WRITEBSTR(OLESTR("</PROPERTY>"))

		WRITENL

		pQualSet->Release ();
	}
	
	return hr;
}

STDMETHODIMP CWmiToXml::MapObjectProperty (BSTR name, VARIANT &var, 
										bool isArray, long flavor)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	IWbemQualifierSet *pQualSet= NULL;

	/*
	 * Only map embedded objects when WMI extensions are allowed
	 */

	if (m_bAllowWMIExtensions)
	{
		if (WBEM_S_NO_ERROR == (hr = m_pObject->GetPropertyQualifierSet (name, &pQualSet)))
		{
			// The property name
			if (isArray)
				WRITEBSTR(OLESTR("<PROPERTY.OBJECTARRAY NAME=\""))
			else
				WRITEBSTR(OLESTR("<PROPERTY.OBJECT NAME=\""))
			WRITEBSTR(name)
			WRITEBSTR(OLESTR("\""));
				
			// The originating class of this property
			BSTR propertyOrigin = NULL;

			if (WBEM_S_NO_ERROR == m_pObject->GetPropertyOrigin (name, &propertyOrigin))
			{
				MapClassOrigin (propertyOrigin);
				SysFreeString(propertyOrigin);
			}

			MapLocal (flavor);
			MapStrongType (pQualSet);

			if (isArray)
				MapArraySize (pQualSet);

			WRITEBSTR(OLESTR(">"))
			WRITENL

			MapQualifiers (pQualSet);
			
			// Now map the value
			hr = MapEmbeddedObjectValue (isArray, var);

			if (isArray)
				WRITEBSTR(OLESTR("</PROPERTY.OBJECTARRAY>"))
			else
				WRITEBSTR(OLESTR("</PROPERTY.OBJECT>"))

			WRITENL

			pQualSet->Release ();
		}
	}
	
	return hr;
}

bool CWmiToXml::PropertyIsLocal (BSTR name, long flavor, IWbemQualifierSet *pQualSet)
{
	bool isLocal = false;

	if (WBEM_FLAVOR_ORIGIN_LOCAL == (WBEM_FLAVOR_MASK_ORIGIN & flavor))
		isLocal = true;
	else
	{
		// If we are dealing with a class we are done 
		if (!m_bIsClass)
		{
			// Check if any of the qualifiers have the local bit set
			pQualSet->BeginEnumeration (WBEM_FLAG_LOCAL_ONLY);
		
			if (WBEM_S_NO_ERROR == pQualSet->Next (0, NULL, NULL, NULL))
				isLocal = true;
			else 
			{
				// NOTE this needs RAID #29202 to be implemented for all this to work because
				// currently deletion of a property from an instance ALWAYS returns
				// WBEM_S_RESET_TO_DEFAULT.

				IWbemClassObject *pClone = NULL;

				if (WBEM_S_NO_ERROR == m_pObject->Clone (&pClone))
				{
					// If delete returns WBEM_S_RESET_TO_DEFAULT, we may have
					// an override deal here.
					if (WBEM_S_RESET_TO_DEFAULT == pClone->Delete (name))
					{
						isLocal = true;
					}

					pClone->Release ();
				}
			}

			pQualSet->EndEnumeration ();		
		}
	}

	return isLocal;
}

	
void CWmiToXml::MapArraySize (IWbemQualifierSet *pQualSet)
{
	// TODO - RAID 29167 covers the fact that case (1) below
	// should not be valid (but this is what the MOF compiler
	// does) - need to change the code when that bug is fixed
	// to be more strict.

	/*
	 * We defined the ARRAYSIZE element if the qualifier set
	 * satisfies one of the following constraints:
	 *
	 * 1) MAX is present with a positive integer value, and MIN
	 *    is absent.
	 *
	 * 2) MAX and MIN are both present, with the same positive
	 *    integer value.
	 */

	VARIANT var;
	VariantInit (&var);
	bool	isFixed = false;
	
	if (WBEM_S_NO_ERROR == pQualSet->Get(L"MAX", 0, &var, NULL))
	{
		if ((V_VT(&var) == VT_I4) && (0 < var.lVal))
		{
			// Promising - have a candidate MAX value.  Now
			// look for a MIN
			long arraySize = var.lVal;

			if (WBEM_S_NO_ERROR == pQualSet->Get(L"MIN", 0, &var, NULL))
			{
				if ((V_VT(&var) == VT_I4) && (0 < var.lVal))
				{
					// Have a value - check if it's the same as MAX

					isFixed = (arraySize == var.lVal);
				}
			}
			else
				isFixed = true;		// NO MIN only max
		}
	}

	if (isFixed)
	{
		WRITEBSTR(OLESTR(" ARRAYSIZE=\""))
		MapLongValue (var.lVal);
		WRITEBSTR(OLESTR("\""))
	}
	
	VariantClear (&var);
}

void CWmiToXml::MapStrongType (IWbemQualifierSet *pQualSet)
{
	WRITEBSTR(OLESTR(" REFERENCECLASS=\""))
	GetClassName (pQualSet);
	WRITEBSTR(OLESTR("\""))
}

void CWmiToXml::GetClassName (IWbemQualifierSet *pQualSet)
{
	VARIANT var;
	VariantClear (&var);

	if ((WBEM_S_NO_ERROR == pQualSet->Get(L"CIMTYPE",  0, &var,  NULL))
		&& (VT_BSTR == var.vt))
	{
		// Split out the class (if any) from the ref
		LPWSTR ptr = wcschr (var.bstrVal, OLECHAR(':'));

		if ((NULL != ptr) && (1 < wcslen(ptr)))
		{
			int classLen = wcslen(ptr) - 1;
			LPWSTR classPtr = new OLECHAR[classLen + 1];
			wcscpy (classPtr, ptr+1);
			BSTR pszClass = SysAllocString(classPtr);
			delete [] classPtr;
			classPtr = NULL;
			WRITEBSTR(pszClass)
			SysFreeString(pszClass);
		}
	}

	VariantClear(&var);
}

STDMETHODIMP CWmiToXml::MapType (CIMTYPE cimtype)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	WRITEBSTR(OLESTR(" TYPE=\""))
	switch (cimtype)
	{
		case CIM_SINT8:
			WRITEBSTR(OLESTR("sint8"))
			break;

		case CIM_UINT8:
			WRITEBSTR(OLESTR("uint8"))
			break;
		
		case CIM_SINT16:
			WRITEBSTR(OLESTR("sint16"))
			break;

		case CIM_UINT16:
			WRITEBSTR(OLESTR("uint16"))
			break;

		case CIM_SINT32:
			WRITEBSTR(OLESTR("sint32"))
			break;

		case CIM_UINT32:
			WRITEBSTR(OLESTR("uint32"))
			break;

		case CIM_SINT64:
			WRITEBSTR(OLESTR("sint64"))
			break;

		case CIM_UINT64:
			WRITEBSTR(OLESTR("uint64"))
			break;

		case CIM_REAL32:
			WRITEBSTR(OLESTR("real32"))
			break;

		case CIM_REAL64:
			WRITEBSTR(OLESTR("real64"))
			break;

		case CIM_BOOLEAN:
			WRITEBSTR(OLESTR("boolean"))
			break;

		case CIM_STRING:
			WRITEBSTR(OLESTR("string"))
			break;

		case CIM_DATETIME:
			WRITEBSTR(OLESTR("datetime"))
			break;

		case CIM_CHAR16:
			WRITEBSTR(OLESTR("char16"))
			break;

		default:
			// Don't recognize this type
			hr = WBEM_E_FAILED;
	}

	WRITEBSTR(OLESTR("\""))

	return hr;
}

STDMETHODIMP CWmiToXml::MapValue (CIMTYPE cimtype, bool isArray, VARIANT &var)
{
	if (VT_NULL == var.vt)
		return WBEM_S_NO_ERROR;

	if (isArray)
	{
		long uBound = 0;
		if (FAILED(SafeArrayGetUBound (var.parray, 1, &uBound)))
			return WBEM_E_FAILED;

		WRITEBSTR(OLESTR("<VALUE.ARRAY>"))

		for (long i = 0; i <= uBound; i++)
		{
			WRITEBSTR(OLESTR("<VALUE>"))
			
			switch (cimtype)
			{
				case CIM_UINT8:
				{
					unsigned char val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapByteValue (val);
				}
					break;

				case CIM_SINT8:
				case CIM_SINT16:
				{
					short val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapShortValue (val);
				}
					break;

				case CIM_UINT16:
				case CIM_UINT32:
				case CIM_SINT32:
				{
					long val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapLongValue (val);
				}
					break;

				case CIM_REAL32:
				{
					float val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapFloatValue (val);
				}
					break;

				case CIM_REAL64:
				{
					double val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapDoubleValue (val);
				}
					break;

				case CIM_BOOLEAN:
				{
					VARIANT_BOOL val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapBoolValue ((val)? true : false);					
				}
					break;

				case CIM_CHAR16:
				{
					long val = 0;
					SafeArrayGetElement (var.parray, &i, &val);
					MapCharValue (val);
				}
					break;

				case CIM_STRING:
				{
					BSTR val = NULL;
					SafeArrayGetElement (var.parray, &i, &val);
					MapStringValue (val);
					SysFreeString (val);
				}
					break;

				case CIM_UINT64:
				case CIM_SINT64:
				case CIM_DATETIME:
				{
					BSTR val = NULL;
					SafeArrayGetElement (var.parray, &i, &val);
					WRITEBSTR(val)
					SysFreeString(val);
				}
					break;
			}
			WRITEBSTR(OLESTR("</VALUE>"))
			WRITENL
		}

		WRITEBSTR(OLESTR("</VALUE.ARRAY>"))
	}
	else
	{	
		// Simple value
		WRITEBSTR(OLESTR("<VALUE>"))
		switch (cimtype)
		{
			case CIM_UINT8:
				MapByteValue (var.bVal);
				break;

			case CIM_SINT8:
			case CIM_SINT16:
				MapShortValue (var.iVal);
				break;

			case CIM_UINT16:
			case CIM_UINT32:
			case CIM_SINT32:
				MapLongValue (var.lVal);
				break;

			case CIM_REAL32:
				MapFloatValue (var.fltVal);
				break;

			case CIM_REAL64:
				MapDoubleValue (var.dblVal);
				break;

			case CIM_BOOLEAN:
				MapBoolValue ((var.boolVal) ? true : false);					
				break;

			case CIM_CHAR16:
				MapCharValue (var.iVal);
				break;

			case CIM_STRING:
				MapStringValue (var.bstrVal);
				break;

			case CIM_UINT64:
			case CIM_SINT64:
			case CIM_DATETIME:
				WRITEBSTR(var.bstrVal)
				break;
		}
		WRITEBSTR(OLESTR("</VALUE>"))
		WRITENL
	}

	WRITENL

	return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWmiToXml::MapEmbeddedObjectValue (bool isArray, VARIANT &var)
{
	HRESULT hr = WBEM_S_NO_ERROR;

	if (VT_NULL == var.vt)
		return WBEM_S_NO_ERROR;

	if (isArray)
	{
		long uBound = 0;
		if (FAILED(SafeArrayGetUBound (var.parray, 1, &uBound)))
			return WBEM_E_FAILED;

		WRITEBSTR(OLESTR("<VALUE.OBJECTARRAY>"))
		for (long i = 0; i<=uBound; i++)
		{
			IUnknown *pNextElement = NULL;
			if(SUCCEEDED(hr = SafeArrayGetElement(var.parray, (LONG *)&i, (LPVOID )&pNextElement )))
			{
				IWbemClassObject *pEmbeddedObject = NULL;
				if(SUCCEEDED(hr = pNextElement->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
				{
					CWmiToXml wbemToXml (NULL, m_pStream, pEmbeddedObject, m_bAllowWMIExtensions,
											m_iQualifierFilter, m_bHostFilter, m_iDTDVersion,
											m_bNamespaceInDeclGroup,
											m_iClassOriginFilter,
											m_iDeclGroupType);
					hr = wbemToXml.MapObjectWithoutHeaders();
					pEmbeddedObject->Release();
				}
				pNextElement->Release();
				pNextElement = NULL;
			}
			
		}
		WRITEBSTR(OLESTR("<VALUE.OBJECTARRAY>"))
	}
	else
	{	

		// TODO - need different constructor 
		// here to say "just generate a VALUE.OBJECT rather
		// than a DECLGROUP"
		IWbemClassObject *pEmbeddedObject = NULL;
		if(SUCCEEDED(hr = (var.punkVal)->QueryInterface(IID_IWbemClassObject, (LPVOID *)&pEmbeddedObject)))
		{
		
			CWmiToXml wbemToXml (NULL, m_pStream, pEmbeddedObject, m_bAllowWMIExtensions,
										m_iQualifierFilter, m_bHostFilter, m_iDTDVersion,
										m_bNamespaceInDeclGroup,
										m_iClassOriginFilter,
										m_iDeclGroupType);
			hr = wbemToXml.MapObjectWithoutHeaders();
			pEmbeddedObject->Release();
		}
	}

	return hr;
}

STDMETHODIMP CWmiToXml::MapMethods ()
{
	m_pObject->BeginMethodEnumeration (0);
	BSTR name = NULL;
	IWbemClassObject *pInParams = NULL;
	IWbemClassObject *pOutParams = NULL;

	while (WBEM_S_NO_ERROR == m_pObject->NextMethod (0, &name, &pInParams, &pOutParams))
	{
		MapMethod (name, pInParams, pOutParams);

		if (pInParams)
		{
			pInParams->Release ();
			pInParams = NULL;
		}

		if (pOutParams)
		{
			pOutParams->Release ();
			pOutParams = NULL;
		}

		SysFreeString (name);
	}

	m_pObject->EndMethodEnumeration ();
	return WBEM_S_NO_ERROR;
}

void CWmiToXml::MapMethod (BSTR name, IWbemClassObject *pInParams, IWbemClassObject *pOutParams)
{ 
	// The method name
	WRITEBSTR(OLESTR("<METHOD NAME=\""))
	WRITEBSTR(name)
	WRITEBSTR(OLESTR("\" "))

	// The method return type (default is void).  This is the type of
	// the ReturnType property if present (otherwise defaults to void)
	CIMTYPE returnCimtype = 0;
	if ((pOutParams) && 
		(WBEM_S_NO_ERROR == pOutParams->Get (L"ReturnValue", 0, NULL, &returnCimtype, NULL)))
		MapType(returnCimtype);
	
	// The class origin
	BSTR	methodOrigin = NULL;

	if (WBEM_S_NO_ERROR == m_pObject->GetMethodOrigin (name, &methodOrigin))
	{
		MapClassOrigin (methodOrigin);
		SysFreeString(methodOrigin);
	}

	WRITEBSTR(OLESTR(">"))
	WRITENL

	// Now do the qualifiers
	IWbemQualifierSet *pQualSet = NULL;
	if (WBEM_S_NO_ERROR == m_pObject->GetMethodQualifierSet (name, &pQualSet))
	{
		MapQualifiers (pQualSet);
		pQualSet->Release ();
		pQualSet = NULL;
	}

	VARIANT idVar;
	VariantInit (&idVar);
	idVar.vt = VT_I4;
	idVar.lVal = 0;
		
	long nextId = 0;	// The next method ID to expect
	long fixedIndex = 0;
	
	// For each id, 
	//		Get the name of the parameter (could be in, out or both)
	//		If just an in-parameter or just an out-parameter it's easy
	//		If both it's a bit tricky
	//

	while (true)
	{
		BSTR nextInParamName = NULL;
		BSTR nextOutParamName = NULL;
	
		if (pInParams)
		{
			SAFEARRAY *pArray = NULL;
		
			if (WBEM_S_NO_ERROR == 
					pInParams->GetNames (L"ID", WBEM_FLAG_ONLY_IF_IDENTICAL|WBEM_FLAG_NONSYSTEM_ONLY, 
											&idVar, &pArray))
			{
				// Did we get a match?
				if (pArray)
				{
					if ((1 == pArray->cDims) && (1 == (pArray->rgsabound[0]).cElements))
						SafeArrayGetElement (pArray, &fixedIndex, &nextInParamName);

					SafeArrayDestroy (pArray);
				}
			}
		}

		if (pOutParams)
		{
			SAFEARRAY *pArray = NULL;
		
			if (WBEM_S_NO_ERROR == 
					pOutParams->GetNames (L"ID", WBEM_FLAG_ONLY_IF_IDENTICAL|WBEM_FLAG_NONSYSTEM_ONLY, 
											&idVar, &pArray))
			{
				// Did we get a match?
				if (pArray)
				{
					if ((1 == pArray->cDims) && (1 == (pArray->rgsabound[0]).cElements))
						SafeArrayGetElement (pArray, &fixedIndex, &nextOutParamName);

					SafeArrayDestroy (pArray);
				}
			}
		}

		// If [in] or [out] this is easy
		if ((nextInParamName && !nextOutParamName) || (!nextInParamName && nextOutParamName))
		{
			VARIANT var;
			VariantInit (&var);
			IWbemQualifierSet *pParamQualSet = NULL;
			CIMTYPE cimtype = 0;

			if (nextInParamName)
			{
				if (WBEM_S_NO_ERROR == pInParams->Get (nextInParamName, 0, &var, &cimtype, NULL))
				{
					pInParams->GetPropertyQualifierSet (nextInParamName, &pParamQualSet);
					MapParameter(nextInParamName, pParamQualSet, cimtype);
				}	
			}
			else
			{
				if (WBEM_S_NO_ERROR == pOutParams->Get (nextOutParamName, 0, &var, &cimtype, NULL))
				{
					pOutParams->GetPropertyQualifierSet (nextOutParamName, &pParamQualSet);
					MapParameter(nextOutParamName, pParamQualSet, cimtype);
				}
			}
	
			if (pParamQualSet)
				pParamQualSet->Release ();

			VariantClear (&var);				
		}
		else if (nextInParamName && nextOutParamName)
		{
			// The [in,out] case and we have to do a merge 

			if (0 == _wcsicmp (nextInParamName, nextOutParamName))
			{
				VARIANT var;
				VariantInit (&var);
				CIMTYPE cimtype = 0;

				IWbemQualifierSet *pInParamQualSet = NULL;
				IWbemQualifierSet *pOutParamQualSet = NULL;

				if (WBEM_S_NO_ERROR == pInParams->Get (nextInParamName, 0, &var, &cimtype, NULL))
				{
					pInParams->GetPropertyQualifierSet (nextInParamName, &pInParamQualSet);
					pOutParams->GetPropertyQualifierSet (nextInParamName, &pOutParamQualSet);
					MapParameter(nextInParamName, pInParamQualSet, cimtype, pOutParamQualSet);

				}

				if (pInParamQualSet)
					pInParamQualSet->Release ();

				if (pOutParamQualSet)
					pOutParamQualSet->Release ();

				VariantClear (&var);
			}
			else
			{
				// Bad news - conflicting IDs in the [in] and [out] parameter set
				SysFreeString (nextInParamName);
				SysFreeString (nextOutParamName);
				break;	
			}
		}
		else
		{
			// Next id not found - stop now and break out
			SysFreeString (nextInParamName);
			SysFreeString (nextOutParamName);
			break;
		}

		SysFreeString (nextInParamName);
		SysFreeString (nextOutParamName);
		idVar.iVal = idVar.iVal + 1;
	}
	
	WRITEBSTR(OLESTR("</METHOD>"))
	WRITENL
}

void CWmiToXml::MapClassOrigin (BSTR &classOrigin)
{
	if ( (m_bIsClass && (m_iClassOriginFilter & wmiXMLClassOriginFilterClass)) ||
		 ((!m_bIsClass) && (m_iClassOriginFilter & wmiXMLClassOriginFilterInstance)) )
	{
		WRITEBSTR(OLESTR(" CLASSORIGIN=\""))
		WRITEBSTR(classOrigin)
		WRITEBSTR(OLESTR("\""))
	}
}
	
void CWmiToXml::MapParameter (BSTR paramName, 
							   IWbemQualifierSet *pQualSet, 
							   CIMTYPE cimtype,
							   IWbemQualifierSet *pQualSet2)
{
	/*
	 * For vanilla CIM XML we don't handle embedded object parameters
	 */

	if ((CIM_OBJECT != (cimtype & ~CIM_FLAG_ARRAY)) || m_bAllowWMIExtensions)
	{
		if (cimtype & CIM_FLAG_ARRAY)
		{
			// Map the array parameter
			if (CIM_REFERENCE == (cimtype & ~CIM_FLAG_ARRAY))
			{
				WRITEBSTR(OLESTR("<PARAMETER.REFARRAY NAME=\""))
				WRITEBSTR(paramName)
				WRITEBSTR(OLESTR("\" "))
				MapStrongType (pQualSet);
				WRITEBSTR(OLESTR(" "))
				MapArraySize (pQualSet);
				WRITEBSTR(OLESTR(">"))
				WRITENL

				// Map the qualifiers of the parameter
				if (pQualSet || pQualSet2)
					MapQualifiers (pQualSet, pQualSet2);

				WRITENL
				WRITEBSTR(OLESTR("</PARAMETER.REFARRAY>"))
			}
			else if (CIM_OBJECT == (cimtype & ~CIM_FLAG_ARRAY))
			{
				WRITEBSTR(OLESTR("<PARAMETER.OBJECTARRAY NAME=\""))
				WRITEBSTR(paramName)
				WRITEBSTR(OLESTR("\" "))
				MapStrongType (pQualSet);
				WRITEBSTR(OLESTR(" "))
				MapArraySize (pQualSet);
				WRITEBSTR(OLESTR(">"))
				WRITENL

				// Map the qualifiers of the parameter
				if (pQualSet || pQualSet2)
					MapQualifiers (pQualSet, pQualSet2);

				WRITENL
				WRITEBSTR(OLESTR("</PARAMETER.OBJECTARRAY>"))
			}
			else
			{
				WRITEBSTR(OLESTR("<PARAMETER.ARRAY NAME=\""))
				WRITEBSTR(paramName)
				WRITEBSTR(OLESTR("\" "))
				MapType (cimtype & ~CIM_FLAG_ARRAY);
				WRITEBSTR(OLESTR(" "))
				MapArraySize (pQualSet);
				WRITEBSTR(OLESTR(">"))
				WRITENL

				// Map the qualifiers of the parameter
				if (pQualSet || pQualSet2)
					MapQualifiers (pQualSet, pQualSet2);

				WRITENL
				WRITEBSTR(OLESTR("</PARAMETER.ARRAY>"))
			}
		}
		else if (cimtype == CIM_REFERENCE)
		{
			// Map the reference parameter
			WRITEBSTR(OLESTR("<PARAMETER.REFERENCE NAME=\""))
			WRITEBSTR(paramName)
			WRITEBSTR(OLESTR("\" "))
			MapStrongType (pQualSet);
			WRITEBSTR(OLESTR(">"))
			WRITENL

			// Map the qualifiers of the parameter
			if (pQualSet || pQualSet2)
				MapQualifiers (pQualSet, pQualSet2);

			WRITENL
			WRITEBSTR(OLESTR("</PARAMETER.REFERENCE>"))
		}
		else if (cimtype == CIM_OBJECT)
		{
			WRITEBSTR(OLESTR("<PARAMETER.OBJECT NAME=\""))
			WRITEBSTR(paramName)
			WRITEBSTR(OLESTR("\" "))
			MapStrongType (pQualSet);
			WRITEBSTR(OLESTR(">"))
			WRITENL

			// Map the qualifiers of the parameter
			if (pQualSet || pQualSet2)
				MapQualifiers (pQualSet, pQualSet2);

			WRITENL
			WRITEBSTR(OLESTR("</PARAMETER.OBJECT>"))
		}
		else
		{
			// Vanilla parameter
			WRITEBSTR(OLESTR("<PARAMETER NAME=\""))
			WRITEBSTR(paramName)
			WRITEBSTR(OLESTR("\" "))
			MapType (cimtype);
			WRITEBSTR(OLESTR(">"))
			WRITENL

			// Map the qualifiers of the parameter
			if (pQualSet || pQualSet2)
				MapQualifiers (pQualSet, pQualSet2);

			WRITENL
			WRITEBSTR(OLESTR("</PARAMETER>"))
		}
		
		WRITENL
	}
}


void CWmiToXml::MapByteValue (unsigned char val)
{
	OLECHAR	wStr[32];
	swprintf (wStr, L"%d", val);
	WRITEBSTR(wStr)
}

void CWmiToXml::MapLongValue (long val)
{
	OLECHAR	wStr[32];
	swprintf (wStr, L"%d", val);
	WRITEBSTR(wStr)
}

void CWmiToXml::MapShortValue (short val)
{
	OLECHAR wStr[32];
	swprintf (wStr, L"%d", val);
	WRITEBSTR(wStr)
}

void CWmiToXml::MapDoubleValue (double val)
{
	OLECHAR floatStr [64];
	swprintf (floatStr, L"%G", val);
	WRITEBSTR(floatStr)
}

void CWmiToXml::MapFloatValue (float val)
{
	OLECHAR floatStr [64];
	swprintf (floatStr, L"%G", val);
	WRITEBSTR(floatStr)
}

void CWmiToXml::MapCharValue (long val)
{
	OLECHAR charStr [2];
	swprintf (charStr, L"%c", val);
	WRITEBSTR(charStr)
}

void CWmiToXml::MapBoolValue (bool val)
{
	if (true == val)
		WRITEBSTR(OLESTR("TRUE"))
	else
		WRITEBSTR(OLESTR("FALSE"))
}

void CWmiToXml::MapStringValue (BSTR &val)
{
	/*
	 * Quote from http://www.w3.org/TR/REC-xml:
	 *
	 *  The ampersand character (&) and the left angle bracket (<) may 
	 *  appear in their literal form only when used as markup delimiters, 
	 *  or within a comment, a processing instruction, or a CDATA section.
	 *
	 *  If they are needed elsewhere, they must be escaped using either 
	 *  numeric character references or the strings "&amp;" and "&lt;" 
	 *  respectively. 
	 * 
	 *  The right angle bracket (>) must, for compatibility, be escaped 
	 *  using "&gt;" or a character reference when it appears in the string 
	 *  "]]>" in content, when that string is not marking the end of a CDATA 
	 *  section.
	 *
	 *  In the content of elements, character data is any string of characters 
	 *  which does not contain the start-delimiter of any markup. In a CDATA 
	 *  section, character data is any string of characters not including the 
	 *  CDATA-section-close delimiter, "]]>".
	 */

	// Check that < or & do not occur in the value
	size_t length = wcslen (val);
	size_t offset = 0;
	WCHAR	*pWchar = NULL;

	if ((offset = wcscspn (val, L"<&")) < length)
	{
		// A reserved character (< &) appears in the value -
		// need to escape.  We can use CDATA if it does not
		// contain the string ]]>

		if (wcsstr (val, CDATAEND))
		{
			// Bad luck - can't use CDATA. Have to escape
			// each reserved character and the CDATAEND sequence!
			// Easiest way to do this is escape all occurences
			// of >.
			//	<	->		&lt;
			//	&	->		&amp;
			//	>	->		&gt;

			offset = wcscspn (val, L"<&>");
			WCHAR *pStr = val; 

			while (true)
			{
				// Write the initial block that's safe
				if (offset > 0)
					WRITEWSTRL(pStr,offset)

				pStr += offset;

				// Escape the offending character
				if (L'<' == *pStr)
					WRITELT
				else if (L'>' == *pStr)
					WRITEGT
				else
					WRITEAMP

				// Skip over the reserved character
				pStr += 1;

				// Find the next position 
				if ((offset = wcscspn (pStr, L"<&>")) >= wcslen (pStr))
					break;
			}

			// Any data left?
			if (pStr && (0 < wcslen (pStr)))
				WRITEWSTR(pStr)
		}
		else
		{
			// Can escape the whole value inside a CDATA
			WRITECDATASTART
			WRITEBSTR(val)
			WRITECDATAEND
		}
	}
	else if (pWchar = wcsstr (val, CDATAEND))
	{
		// Yuck we need to escape the > inside this sequence
		//
		// ]]>  -> ]]&gt;

		WCHAR *pStr = val; 
		
		while (true)
		{
			offset =  wcslen (pStr) - wcslen (pWchar);

			// Write the initial block that's safe
			// (NOTE: the additional two characters for the "]]"
			//  which we don't need to escape)
			WRITEWSTRL(pStr,(offset+2))

			// Skip over the CDATAEND sequence
			pStr += offset + 3;

			// Escape the offending character
			WRITEGT
			
			// Find the next position 
			if (!(pWchar = wcsstr (pStr, CDATAEND)))
				break;
		}

		// Any data left?
		if (pStr && (0 < wcslen (pStr)))
			WRITEWSTR(pStr)
	}
	else
	{
		// Just write the value
		WRITEBSTR(val)	
	}
}

void CWmiToXml::MapReturnParameter(BSTR strParameterName, VARIANT &variant)
{
	// Could be a PARAMETER or PARAMETER.ARRAY
	if(variant.vt & VT_ARRAY)
		WRITEBSTR(OLESTR("<PARAMVALUE.ARRAY NAME=\""))
	else 
		WRITEBSTR(OLESTR("<PARAMVALUE NAME=\""))

	WRITEBSTR(strParameterName);
	WRITEBSTR(OLESTR("\">"));

	// Convert the property value to XML
	MapValue(variant);
	if(variant.vt & VT_ARRAY)
		WRITEBSTR(OLESTR("</PARAMVALUE.ARRAY>"))
	else 
		WRITEBSTR(OLESTR("</PARAMVALUE>"))
}

// Returns the host name on both Win9x and NT platforms in Unicode form
LPWSTR CWmiToXml::GetHostName()
{
	LPWSTR pszRetValue =  NULL;
	TCHAR pszHostName[200];
	DWORD dwLength = 199;
	if(GetComputerName(pszHostName, &dwLength))
	{
#ifdef UNICODE
		pszRetValue = new WCHAR[dwLength + 1];
		wcscpy(pszRetValue, pszHostName);
#else
		// Convert to Wide characters
		if(dwLength = mbstowcs(NULL, pszHostName, 0))
		{
			pszRetValue = new WCHAR[dwLength + 1];
			mbstowcs(pszRetValue, pszHostName, dwLength);
			pszRetValue[dwLength] = NULL;
		}

#endif
	}
	return pszRetValue;
}

BSTR CWmiToXml::GetNamespace(IWbemClassObject *pObject)
{
	HRESULT hr = WBEM_E_FAILED;
	BSTR retVal = NULL;

	// Get the __PATH of the object
	VARIANT var;
	VariantInit (&var);
	if (WBEM_S_NO_ERROR == pObject->Get(L"__NAMESPACE", 0, &var, NULL, NULL))
	{
		retVal = SysAllocString(var.bstrVal);
		VariantClear(&var);
	}
	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\action.h ===
#ifndef _ACTION_H__
#define _ACTION_H__


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  File Name:	Action.h
//  
//	Description:	Contains the class definition for the base performance
//				action object that is used by the Performance Engine.  All 
//				"actions" MUST Derive from this class, and implement the 
//				Execute and Destructor functions as defined in this class.
//
//	This code was implemented on top of skeleton code of WMI Performance
//	Test module.
//	However, they are not compatible due to great amount of changes.
//
//  (c) 1999 Microsoft Corporation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class CAction
{
public:
	CAction(IWbemServices* pWbem);
	virtual ~CAction();
	virtual void ReleaseAction() = 0;	

	virtual HRESULT Execute() = 0;
												

protected:
	HRESULT	m_hStatus;			
	IWbemServices* m_pWbem;
	
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtadapt.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Test app to test the hi perf portion of the WMIPROV.DLL
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <process.h>
//#include <objbase.h>
#include <stdio.h>
#include <wbemcli.h>
//#include <wbemint.h>
//#include <wbemcomn.h>
//#include <cominit.h>


///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT WbemSetProxyBlanket( IUnknown *pInterface, DWORD dwAuthnSvc, DWORD dwAuthzSvc, OLECHAR *pServerPrincName,
                             DWORD dwAuthLevel, DWORD dwImpLevel, RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
                             DWORD dwCapabilities )
{
    IUnknown * pUnk = NULL;
    IClientSecurity * pCliSec = NULL;

    HRESULT sc = pInterface->QueryInterface(IID_IUnknown, (void **) &pUnk);
    if(sc != S_OK)
        return sc;

    sc = pInterface->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
    if(sc != S_OK)
    {
        pUnk->Release();
        return sc;
    }


    sc = pCliSec->SetBlanket(pInterface, dwAuthnSvc, dwAuthzSvc, pServerPrincName, dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities);
    pCliSec->Release();
    pCliSec = NULL;
    sc = pUnk->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
    if(sc == S_OK)
    {
        sc = pCliSec->SetBlanket(pUnk, dwAuthnSvc, dwAuthzSvc, pServerPrincName, dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities);
        pCliSec->Release();
    }
    else if (sc == 0x80004002)
        sc = S_OK;
    pUnk->Release();
    return sc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Function:	main
//
///////////////////////////////////////////////////////////////////////////////////////////////////////

#define	NUMINSTANCES	1

IWbemServices*	g_pNameSpace = NULL;
WCHAR			g_wcsObjectPath[2048];
DWORD			g_dwNumReps = 1;
DWORD			g_dwNumThreads = 1;
BOOL			g_fAddDel = FALSE;

unsigned __stdcall RefreshThread( void * pvData )
{
	DWORD	dwThreadId = (DWORD) pvData;

	IWbemRefresher*				pRefresher = NULL;
	IWbemConfigureRefresher*	pConfig = NULL;
	BOOL						fEnum = FALSE;

	CoInitializeEx( NULL, COINIT_MULTITHREADED );

	HRESULT hr = CoCreateInstance( CLSID_WbemRefresher, NULL, CLSCTX_INPROC_SERVER, IID_IWbemRefresher, (void**) &pRefresher );
	if ( SUCCEEDED( hr ) )
	{
		IWbemConfigureRefresher*	pConfig = NULL;

		// Need an interface through which we can configure the refresher
		hr = pRefresher->QueryInterface( IID_IWbemConfigureRefresher, (void**) &pConfig );

		if ( SUCCEEDED( hr ) )
		{
			IWbemClassObject*		pRefreshable = NULL;
			IWbemHiPerfEnum*		pEnum = NULL;
			long					lID = 0;
			IWbemObjectAccess*		pObjAccess = NULL;
			IWbemClassObject*		pObj = NULL;

			// Add an object or an enumerator.  If the path to the object contains
			// an L'=', then it is an object path, otherwise we assume it is a class
			// name and therefore return an enumerator.

			if ( NULL != wcschr( g_wcsObjectPath, L'=' ) )
			{
				if ( !g_fAddDel )
				{
					hr = pConfig->AddObjectByPath( g_pNameSpace, g_wcsObjectPath, 0, NULL, &pObj, &lID );

					if ( SUCCEEDED( hr ) )
					{
						pObj->QueryInterface( IID_IWbemObjectAccess, (void**) &pObjAccess );
						pObj->Release();
					}
					else
					{
						printf( "AddObjectByPath() failed, 0x%x\n", hr );
					}

				}

			}
			else
			{
				if ( !g_fAddDel )
				{
					hr = pConfig->AddEnum( g_pNameSpace, g_wcsObjectPath, 0, NULL, &pEnum, &lID );

					if ( FAILED(hr) )
					{
						printf( "AddEnum() failed, 0x%x\n", hr );
					}
				}

				fEnum = TRUE;
			}

			// Add an object and then the enumerator
			if ( SUCCEEDED( hr ) )
			{
				DWORD				dwNumReturned = NUMINSTANCES;
				BOOL				fGotHandles = 0;

				DWORD	dwValue = 0,
						dwNumObjects = 0;
				WORD	wValue = 0;
				BYTE	bVal = 0;
				IWbemObjectAccess**	apEnumAccess = NULL;

				for ( DWORD x = 0; SUCCEEDED( hr ) && x < g_dwNumReps; x++ )
				{
					if ( g_fAddDel )
					{
						if ( fEnum )
						{
							hr = pConfig->AddEnum( g_pNameSpace, g_wcsObjectPath, 0, NULL, &pEnum, &lID );
						}
						else
						{
							hr = pConfig->AddObjectByPath( g_pNameSpace, g_wcsObjectPath, 0, NULL, &pObj, &lID );

							if ( SUCCEEDED( hr ) )
							{
								pObj->QueryInterface( IID_IWbemObjectAccess, (void**) &pObjAccess );
								pObj->Release();
							}
						}
					}

					// Refresh and if we have an enumerator, retrieve the
					// objects and release them

					hr = pRefresher->Refresh( 0L );

					if ( pEnum )
					{
						hr = pEnum->GetObjects( 0L, dwNumObjects, apEnumAccess, &dwNumReturned );

						if ( FAILED( hr ) && WBEM_E_BUFFER_TOO_SMALL == hr )
						{
							IWbemObjectAccess**	apTempAccess = new IWbemObjectAccess*[dwNumReturned];

							if ( NULL != apTempAccess )
							{
								ZeroMemory( apTempAccess, dwNumReturned * sizeof(IWbemObjectAccess*) );

								if ( NULL != apEnumAccess )
								{
									CopyMemory( apTempAccess, apEnumAccess, dwNumObjects * sizeof(IWbemObjectAccess*) );
									delete [] apEnumAccess;
								}

								// Store the new values and retry
								apEnumAccess = apTempAccess;
								dwNumObjects = dwNumReturned;

								hr = pEnum->GetObjects( 0L, dwNumObjects, apEnumAccess, &dwNumReturned );
							}
							else
							{
								hr = WBEM_E_OUT_OF_MEMORY;
							}

						}	// IF Buffer too small


						for ( DWORD nCtr = 0; nCtr < dwNumReturned; nCtr++ )
						{
							apEnumAccess[nCtr]->Release();
						}

					}	// IF refresh succeeded


					printf ( "Thread %d Refreshed %d instances of %S from provider: rep# %d\n", dwThreadId, dwNumReturned, g_wcsObjectPath, x );

					if ( g_fAddDel )
					{
						if ( fEnum )
						{
							pConfig->Remove( lID, 0L );
							if (pEnum)
								pEnum->Release();
						}
						else
						{
							if (pObjAccess)
								pObjAccess->Release();
							pObjAccess = NULL;
						}
					}


				}	// FOR Refresh

				// Release anything we got back from the refresher and any
				// memory we may have allocated.
				if ( fEnum )
				{
					if ( !g_fAddDel && pEnum )
						pEnum->Release();

					if ( NULL != apEnumAccess )
					{
						delete [] apEnumAccess;
					}

				}
				else
				{
					if ( !g_fAddDel && pObjAccess)
						pObjAccess->Release();
				}

			}

			if (pConfig)
				pConfig->Release();
		}

		// Cleanup
		g_pNameSpace->Release();

	}

	if ( NULL != pRefresher )
		pRefresher->Release();

	CoUninitialize();

	return 0;

}

extern "C" int __cdecl main( int argc, char *argv[] )
{
	WCHAR	wcsSvrName[256];
	BOOL	fEnum = FALSE;

	wcscpy( wcsSvrName, L"." );

	CoInitializeEx( NULL, COINIT_MULTITHREADED );
//	InitializeSecurity(RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE );

	// See if we were told to go remote or not.
	if ( argc > 1 )
	{
		MultiByteToWideChar( CP_ACP, 0L, argv[1], -1, g_wcsObjectPath, 2048 );

		if ( argc > 2 )
		{
			g_fAddDel = strtoul( argv[2], NULL, 10 );

			if ( argc > 3 )
			{
				g_dwNumReps = strtoul( argv[3], NULL, 10 );

				if ( argc > 4 )
				{
					g_dwNumThreads = strtoul( argv[4], NULL, 10 );

					if ( argc > 5 )
					{
						MultiByteToWideChar( CP_ACP, 0L, argv[5], -1, wcsSvrName, 2048 );
					}
				}
			}
		}
	}
	else
	{
		printf( "No object path!\n" );
		printf( "Usage: refreshertest.exe <object_path> <delete_object> <Num_Refreshes> <Num_threads> <Server - Opt>\n" );
		return 0;
	} 

	IWbemLocator*		pWbemLocator = NULL;

	HRESULT hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**) &pWbemLocator );

	WCHAR	wszNameSpace[255];

	swprintf( wszNameSpace, L"\\\\%s\\root\\wmi", wcsSvrName );

	// Name space to connect to
	BSTR	bstrNameSpace = SysAllocString( wszNameSpace );

	hr = pWbemLocator->ConnectServer(	bstrNameSpace,	// NameSpace Name
										NULL,			// UserName
										NULL,			// Password
										NULL,			// Locale
										0L,				// Security Flags
										NULL,			// Authority
										NULL,			// Wbem Context
										&g_pNameSpace		// Namespace
										);

	SysFreeString( bstrNameSpace );

	if ( SUCCEEDED( hr ) )
	{

		WbemSetProxyBlanket(g_pNameSpace, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CONNECT, 
						RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

		HANDLE*	ahThreads = new HANDLE[g_dwNumThreads];

		for ( DWORD	dwCtr = 0; dwCtr < g_dwNumThreads; dwCtr++ )
		{
			ahThreads[dwCtr] = (HANDLE) _beginthreadex( NULL, 0, RefreshThread, (void*) dwCtr, 0, NULL );
			Sleep(1000);
		}

		// Wait for all the threads to get signalled
		WaitForMultipleObjects( g_dwNumThreads, ahThreads, TRUE, INFINITE );

		delete [] ahThreads;

	}

	// Cleanup main objects
	if ( NULL != pWbemLocator )
		pWbemLocator->Release();

	CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtess.h ===
/////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _BVT_ESS_HEADER
#define _BVT_ESS_HEADER


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtcimv2.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTCIMv2.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <bvt.h>


#define NO_ERRORS_EXPECTED       FALSE,__FILE__,__LINE__
#define ERRORS_CAN_BE_EXPECTED   TRUE,__FILE__,__LINE__
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 200
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CIMV2_OpenNamespace()
{
    //==========================================================================
    // Open CIMV2 namespace
    //==========================================================================
    int nRc = FATAL_ERROR;
    IWbemServices   * pNamespace    = NULL;
    CHString sNamespace;

    if( g_Options.GetSpecificOptionForAPITest(L"NAMESPACE",sNamespace, 200) )
    {
	    // =====================================================================
        //  Open the namespace
	    // =====================================================================
        nRc = OpenNamespaceAndKeepOpen( &pNamespace, WPTR sNamespace,FALSE,fCompareResults);
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 201
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CIMV2_EnumerateClasses()
{
    int nRc = FATAL_ERROR;
    //==========================================================================
    // Get class enumerator for the namespace to get list of classes
    //==========================================================================
    CHString sNamespace;

    if( g_Options.GetSpecificOptionForAPITest(L"NAMESPACE",sNamespace, 200) )
    {
        IWbemServices   * pNamespace    = NULL;
	    // =====================================================================
        //  Open the namespace
	    // =====================================================================
        nRc = OpenNamespaceAndKeepOpen( &pNamespace, WPTR sNamespace,FALSE,fCompareResults);

        if( SUCCESS == nRc )
        {
            // =============================================================
            //  Get the list of classes to make sure they are in namespace
            // =============================================================
            CHString sClassesToCompare;
            if( g_Options.GetSpecificOptionForAPITest( L"NAMESPACE",sClassesToCompare, 201 ) )
            {
                // =========================================================
                // Make sure those classes are in the namespace
                // =========================================================
                nRc = EnumerateClassesAndCompare(sClassesToCompare, 201,pNamespace,  (WCHAR*)((const WCHAR*)sNamespace));
            }
        }
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 202
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CIMV2_EnumerateInstances()
{
    int nRc = FATAL_ERROR;
    //==========================================================================
    // Get instance enumerator for classes Win32_logicalDisk,  Win32_Process 
    //==========================================================================
    IWbemServices   * pNamespace    = NULL;
    CHString sNamespace;

    if( g_Options.GetSpecificOptionForAPITest(L"NAMESPACE",sNamespace, 200) )
    {
        IWbemServices   * pNamespace    = NULL;
	    // =====================================================================
        //  Open the namespace
	    // =====================================================================
        nRc = OpenNamespaceAndKeepOpen( &pNamespace, sNamespace,FALSE,fCompareResults);
        if( SUCCESS == nRc )
        {
            // =============================================================
            //  Get the list of classes to get instances for
            // =============================================================
            CHString sInstanceList;
            CHString sInstanceCompareList;

            if( g_Options.GetSpecificOptionForAPITest( L"INSTANCES",sInstanceList, 202 ) )
            {
                 // =========================================================
                 //  Get the enumeration flags
                 // =========================================================
                 ItemList FlagList;
                 nRc = GetFlags(202, FlagList);
                 if( SUCCESS == nRc )
                 {
                     for( int i = 0; i < FlagList.Size(); i++ )
                     {
                         ItemInfo * p = FlagList.GetAt(i);
                        // ===================================================
                        // Make sure those instances are in the namespace
                        // ===================================================
                        nRc = GetInstanceAndCompare(pNamespace, p->dwFlags, sInstanceList, 202, (WCHAR*)((const WCHAR*) sNamespace));
                     }
                 }
            }
        }
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 203
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CIMV2_GetObjects()
{
    int nRc = FATAL_ERROR;
    //==========================================================================
    // Get classes/instances using path of the object
    //==========================================================================
    CHString sNamespace;

    if( g_Options.GetSpecificOptionForAPITest(L"NAMESPACE",sNamespace, 203) )
    {
        IWbemServices   * pNamespace    = NULL;
	    // =====================================================================
        //  Open the namespace
	    // =====================================================================
        nRc = OpenNamespaceAndKeepOpen( &pNamespace, sNamespace,FALSE,fCompareResults);

        if( SUCCESS == nRc )
        {
            // =============================================================
            //  Get the list of objexts to get
            // =============================================================
            CHString sObjects;
            if( g_Options.GetSpecificOptionForAPITest(L"LIST", sObjects, 203 ) )
            {
                // =========================================================
                // Get the requested objects
                // =========================================================
                nRc = GetSpecificObjects(sObjects, pNamespace, 203, (WCHAR*)((const WCHAR*)sNamespace));
            }
        }
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }

    return nRc;   
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 204
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CIMV2_ExecuteQueries()
{
    int nRc = FATAL_ERROR;
// Execute Association/Reference queries
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 205
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CIMV2_EnumerateClassAMethods()
{
    int nRc = FATAL_ERROR;
// Enumerate methods for a class/instance.
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 206
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CIMV2_EnumerateInstanceMethods()
{
    int nRc = FATAL_ERROR;
// Enumerate methods for a class/instance.
    return nRc;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 207
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CIMV2_ExecuteMethod()
{
    int nRc = FATAL_ERROR;
// Execute a method on one of the instance say Terminate method on Win32_process and check if the instance is removed.
    return nRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtess.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTESS.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <bvt.h>
#include "bvtess.h"
#include <initguid.h>
#include <stdio.h>

CCriticalSection   g_EventCritSec;
int g_fPermConsumerStarted = TRUE;



#define NO_ERRORS_EXPECTED       FALSE,__FILE__,__LINE__
#define ERRORS_CAN_BE_EXPECTED   TRUE,__FILE__,__LINE__

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int FireEvent(WCHAR * wcsEventInfo, int & nTotalExpected)
{
    EventInfo Event;

    int nRc = CrackEvent(wcsEventInfo, Event, NO_ERRORS_EXPECTED);
    if( SUCCESS == nRc )
    {
        //=====================================================
        //  Open up the requested namespace
        //=====================================================
        IWbemServices * pNamespace = NULL;

        nRc = OpenNamespaceAndKeepOpen( &pNamespace, Event.Namespace, FALSE, FALSE);
        if( nRc == SUCCESS )
        {
            //=====================================================
            //  Run the requested tests 
            //=====================================================
            nRc = RunTests(Event.Section,FALSE,TRUE);
            if( SUCCESS != nRc )
            {
                gp_LogFile->LogError(__FILE__,__LINE__,FATAL_ERROR, L"Firing Events for Permanent consumers in Namespace %s, not as expected.", Event.Namespace);
            }
            else
            {
                nTotalExpected += Event.Results;
            }
        }
        SAFE_RELEASE_PTR(pNamespace);
    }
    return nRc;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int TestSemiSyncEvent(WCHAR * wcsEventInfo, BOOL fCompareResults)
{
    EventInfo Event;

    int nRc = CrackEvent(wcsEventInfo, Event, NO_ERRORS_EXPECTED);
    if( SUCCESS == nRc )
    {
        //=====================================================
        //  Open up the requested namespace
        //=====================================================
        IWbemServices * pNamespace = NULL;

        nRc = OpenNamespaceAndKeepOpen( &pNamespace, Event.Namespace, FALSE,fCompareResults);
        if( nRc == SUCCESS )
        {
            //=====================================================
            // Set up the query first
            //=====================================================
            IEnumWbemClassObject * pEnum = NULL; 
            IWbemContext * pCtx = NULL;

            nRc = ExecNotificationQueryAndLogErrors(pNamespace, &pEnum, Event.Query,
                                                    Event.Language, WPTR Event.Namespace, pCtx, NO_ERRORS_EXPECTED);

            //=====================================================
            //  Run the requested tests 
            //=====================================================
            if( SUCCESS == nRc )
            {
                nRc = RunTests(Event.Section,fCompareResults,TRUE);
                if( SUCCESS == nRc )
                {
                    nRc = CompareResultsFromEnumeration(pEnum, Event.Results, WPTR Event.Query, WPTR Event.Namespace);
                    if( SUCCESS != nRc )
                    {
                        gp_LogFile->LogError(__FILE__,__LINE__,FATAL_ERROR, L"Semi-sync Events for query: %s, in Namespace %s, not as expected.", Event.Query, Event.Namespace);
                    }
                }
            }
            SAFE_RELEASE_PTR(pEnum);
        }
        SAFE_RELEASE_PTR(pNamespace);
    }
    return nRc;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
int TestAsyncEvent(WCHAR * wcsEventInfo, BOOL fCompareResults)
{
    EventInfo Event;

    int nRc = CrackEvent(wcsEventInfo, Event, NO_ERRORS_EXPECTED);
    if( SUCCESS == nRc )
    {
        //=====================================================
        //  Open up the requested namespace
        //=====================================================
        IWbemServices * pNamespace = NULL;

        nRc = OpenNamespaceAndKeepOpen( &pNamespace, Event.Namespace, FALSE,fCompareResults);
        if( nRc == SUCCESS )
        {
            //=====================================================
            // Set up the query first
            //=====================================================
            IWbemContext * pCtx = NULL;
            CSinkEx * pHandler = NULL;

            pHandler = new CSinkEx;
            if( pHandler )
            {
                nRc = ExecNotificationQueryAsyncAndLogErrors(pNamespace, pHandler, Event.Query,
                                           Event.Language, (WCHAR*)((const WCHAR*) Event.Namespace), pCtx, NO_ERRORS_EXPECTED);
                //=====================================================
                //  Run the requested tests 
                //=====================================================
                if( SUCCESS == nRc )
                {
                    //=================================================
                    //  Wait for the signal, then run the tests, then
                    //  try 3 times to see if we got the event.
                    //=================================================
                    nRc = RunTests(Event.Section,fCompareResults,TRUE);
                    if( SUCCESS == nRc )
                    {
                        HRESULT hr = WBEM_E_FAILED;
                        for( int i=0; i < 3; i++ )
                        {
        	                pHandler->WaitForSignal(1000);
			                hr = pHandler->GetStatusCode();
    		                if(SUCCEEDED(hr))
                            {
                                break;
                            }
                        }
                        //=============================================
                        //  We got the event
                        //=============================================
                        if( S_OK == hr )
                        {
                            if( pHandler->GetNumberOfObjectsReceived() != Event.Results )
                            {
                                gp_LogFile->LogError(__FILE__,__LINE__,FATAL_ERROR, L"Async Events for query: %s, in Namespace %s, not as expected.", Event.Query, Event.Namespace);
                            }
                        }
                        //=============================================
                        //  We never received the event
                        //=============================================
                        else
                        {
                            gp_LogFile->LogError(__FILE__,__LINE__,FATAL_ERROR, L"Didn't receive expected async event for Query: %s, in Namespace %s.  HRESULT from GetStatusCode was: 0x%x", Event.Query, Event.Namespace, hr );
                        }
                    }
                }
            }

            //=====================================================
            // Cancel the async call, then if the return codes are
            // ok so far, and this one isn't replace it.
            //=====================================================
            int nTmp = CancelAsyncCallAndLogErrors(pNamespace, pHandler, Event.Query,
                                                   Event.Language, (WCHAR*)((const WCHAR*)Event.Namespace), NO_ERRORS_EXPECTED );
            if( nRc == S_OK && nTmp != S_OK )
            {
                nRc = nTmp;
            }
            SAFE_RELEASE_PTR(pHandler);
        }
        SAFE_RELEASE_PTR(pNamespace);
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 300 : Temporary Semi Sync Events
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int TempSemiSyncEvents(BOOL fCompareResults, BOOL fSuppress)
{	
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(300, fSuppress);

	// =====================================================================
    //  Run the requested tests and get the namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(300, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        //=========================================================
        //  Get the types of tests to run
        //=========================================================
        CHString sEventList;
        if( g_Options.GetSpecificOptionForAPITest(L"EVENT_LIST",sEventList, 300))
        {
            ItemList MasterList;
            //=======================================================
            //  Get the list of the events to test
            //=======================================================
            if( InitMasterList(sEventList,MasterList))
            {
               if( SUCCESS == nRc )
               {
                    for( int i = 0; i < MasterList.Size(); i++ )
                    {
                        ItemInfo * p = MasterList.GetAt(i);
                        CHString sEventInfo;

                        //===========================================
                        //  Get the query information
                        //===========================================
                        if( g_Options.GetSpecificOptionForAPITest(WPTR p->Item,sEventInfo,300))
                        {
                            nRc = TestSemiSyncEvent(WPTR sEventInfo, fCompareResults);
                        }
                    }
               }
            }
        }
    }
    SAFE_RELEASE_PTR(pNamespace);
    LogTestEnding(300,nRc, fSuppress);

    return nRc;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 301 : Temporary Async Events
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int TempAsyncEvents(BOOL fCompareResults,BOOL fSuppress)
{	
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(301, fSuppress);

	// =====================================================================
    //  Run the requested tests and get the namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(301, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        //=========================================================
        //  Get the types of tests to run
        //=========================================================
        CHString sEventList;
        if( g_Options.GetSpecificOptionForAPITest(L"EVENT_LIST",sEventList, 301))
        {
            ItemList MasterList;
            //=======================================================
            //  Get the list of the events to test
            //=======================================================
            if( InitMasterList(sEventList,MasterList))
            {
               if( SUCCESS == nRc )
               {
                    for( int i = 0; i < MasterList.Size(); i++ )
                    {
                        ItemInfo * p = MasterList.GetAt(i);
                        CHString sEventInfo;

                        //===========================================
                        //  Get the query information
                        //===========================================
                        if( g_Options.GetSpecificOptionForAPITest( (WCHAR*)((const WCHAR*)p->Item),sEventInfo,300))
                        {
                            nRc = TestAsyncEvent( (WCHAR*)((const WCHAR*)sEventInfo), fCompareResults);
                        }
                    }
               }
            }
        }
    }
    SAFE_RELEASE_PTR(pNamespace);

    LogTestEnding(301,nRc, fSuppress);

    return nRc;
}

//************************************************************************************
//
//  Test302:  
//  
//************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CompareExpectedResultsForPermanentEvents(DWORD dwTotalEventsExpected, WCHAR * sOutputLocation, int nRetry, int nSleep )
{
    int nRc = FATAL_ERROR;
    DWORD dwNumber = 0;

    for( int i=0; i < nRetry; i++ )
    {
        Sleep(nSleep);

	    //==========================
        // Get it from the registry
    	//==========================
        HKEY hKey;

        if( ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,L"SOFTWARE\\BVT", &hKey))
        {
            DWORD dwType = 0;
            DWORD dwSize = sizeof(DWORD);
            RegQueryValueEx( hKey, L"PermEvents", 0, &dwType,(LPBYTE) &dwNumber, &dwSize);

            DWORD dwNum = 0;
            RegSetValueEx( hKey, L"PermEvents", 0, REG_DWORD,(LPBYTE) &dwNum, sizeof(REG_DWORD));
            RegCloseKey(hKey);
            break;
        }
    }

    if( nRc == FATAL_ERROR )
    {
        if( dwNumber != dwTotalEventsExpected )
        {
            gp_LogFile->LogError(__FILE__,__LINE__,FATAL_ERROR, L"Results for Permanent Event Consumer not as expected.  Expected %ld, received %ld", dwTotalEventsExpected, dwNumber );
        }
        else
        {
            nRc = SUCCESS;
        }
    }
    return nRc;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
int SpawnOffPermEventConsumer( )
{
    int nRc = FATAL_ERROR;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&si,sizeof(si));
    si.cb=sizeof(si);

    CHString sReg;
    if( g_Options.GetSpecificOptionForAPITest(L"REGISTER_PERM_EVENT_CONSUMER",sReg, 302))
    {
        WCHAR wcsDir[MAX_PATH*2];
        DWORD dw = GetCurrentDirectory(MAX_PATH,wcsDir);
        wcscat( wcsDir, L"\\");
        wcscat( wcsDir, WPTR sReg );

        if( CreateProcess(wcsDir,NULL,NULL,NULL,NULL,NULL,NULL,NULL,&si,&pi))
        {
            g_fPermConsumerStarted = TRUE;

            nRc = SUCCESS;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int PermanentEvents(BOOL fCompareResults, BOOL fSuppress)
{	
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(302,fSuppress);

    CAutoBlock Block(&g_EventCritSec);

	// =====================================================================
    //  Run the requested tests and get the namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(302, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        //=========================================================
        //  Get the mofs to run
        //=========================================================
        CHString sMOF;
        if( g_Options.GetSpecificOptionForAPITest(L"MOF_COMMAND",sMOF, 302))
        {
            HRESULT hr = _wsystem(WPTR sMOF);

            if( !g_fPermConsumerStarted )
            {
                nRc =  SpawnOffPermEventConsumer();
            }
            if( SUCCESS == nRc )
            {
                //=========================================================
                //  Now, fire the events
                //=========================================================
                CHString sEventList;
                if( g_Options.GetSpecificOptionForAPITest(L"FIRE_EVENTS",sEventList, 302))
                {
                    ItemList MasterList;
                    int nTotalEventsExpected = 0;
                    //=======================================================
                    //  Get the list of the events to test
                    //=======================================================
                    if( InitMasterList(sEventList,MasterList))
                    {
                       if( SUCCESS == nRc )
                       {
                            for( int i = 0; i < MasterList.Size(); i++ )
                            {
                                ItemInfo * p = MasterList.GetAt(i);
                                CHString sEventInfo;

                                //===========================================
                                //  Get the query information
                                //===========================================
                                if( g_Options.GetSpecificOptionForAPITest(p->Item,sEventInfo,302))
                                {
                                    nRc = FireEvent(WPTR sEventInfo, nTotalEventsExpected );
                                }
                            }
                       }
                    }
                    //=======================================================
                    //  See if we got what we expected
                    //=======================================================
                    if( fCompareResults )
                    {
                        CHString sFileLocation;
                        if(g_Options.GetSpecificOptionForAPITest(L"PERM_EVENT_OUTPUT_FILE",sFileLocation, 302))
                        {
                            CHString sRetry;
                            if(g_Options.GetSpecificOptionForAPITest(L"RETRY",sRetry, 302))
                            {
                                CHString sSleep;
                                if(g_Options.GetSpecificOptionForAPITest(L"SLEEP_IN_MILLISECONDS",sSleep, 302))
                                {
                                    nRc = CompareExpectedResultsForPermanentEvents(nTotalEventsExpected, WPTR sFileLocation, _wtoi(WPTR sRetry), _wtoi(WPTR sSleep));
                                }
                            }
                        }
                    }
                }
            }

        }
    }
    SAFE_RELEASE_PTR(pNamespace);
    LogTestEnding(302,nRc, fSuppress);

    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 303
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int PermanentInstances(BOOL fCompareResults, BOOL fSuppressHeader )
{
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(303,fSuppressHeader);

	// =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(303, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        nRc = CreateInstancesForSpecificTest(pNamespace, WPTR sNamespace,L"INSTANCE_LIST",303,TRUE);
    }
	// =====================================================================
    //  Release the pointers
	// =====================================================================
    SAFE_RELEASE_PTR(pNamespace);
    LogTestEnding(303,nRc,fSuppressHeader);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 304
//*****************************************************************************************************************

int PermanentClasses(BOOL fCompareResults, BOOL fSuppressHeader )
{
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(304,fSuppressHeader);
	// =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(304, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        //=========================================================
        // Create classes with different properties. Some of 
        // these should be in the following inheritance chain and 
        // some should not inherit from the others at all:  
        // classes = {A, B, C, D:A, E:A, F:E, G:F, H:G, I:F}.  
        // A mix of simple string & sint32 keys are fine.
        //=========================================================
        nRc = CreateClassesForSpecificTest(pNamespace, WPTR sNamespace,L"CLASSES",304);
    }

	// =====================================================================
    //  Release the pointers
    // =====================================================================
    SAFE_RELEASE_PTR(pNamespace);

    LogTestEnding(304,nRc,fSuppressHeader);

    return nRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtprov.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTCIMv2.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <bvt.h>
#include "bvtrefresh.h"

#define NO_ERRORS_EXPECTED       FALSE,__FILE__,__LINE__
#define ERRORS_CAN_BE_EXPECTED   TRUE,__FILE__,__LINE__

int TestSemiSyncEvent(WCHAR * wcsEventInfo, BOOL fCompareResults);
int TestAsyncEvent(WCHAR * wcsEventInfo, BOOL fCompareResults);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetListOfProviders( int nWhichTest, ItemList & MasterList )
{
    int nRc = FATAL_ERROR;
    CHString sProviders;

    if( g_Options.GetSpecificOptionForAPITest(L"PROVIDERS",sProviders,nWhichTest) )
    {
        //=======================================================
        //  Parse the list of Providers to process
        //=======================================================
         if( InitMasterList(sProviders,MasterList))
         {
             nRc = SUCCESS;
         }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetNextProviderNamespace( int i, int nWhichTest, ItemList & MasterList, CHString & sNamespace, CHString & sKey )
{
    int nRc = FATAL_ERROR;

    ItemInfo * p = MasterList.GetAt(i);
    if( p )
    {
        CHString sTmp;
        sKey = p->Item;
        if( g_Options.GetSpecificOptionForAPITest(sKey,sTmp, nWhichTest) )
        {
            nRc = CrackNamespace(WPTR sTmp,sNamespace, NO_ERRORS_EXPECTED);
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetNextNamespaceAndRunRequestedTests( int nWhichTest, int & i, ItemList & MasterList, CHString & sNamespace, CHString & sKey,
                      BOOL fCompareResults, BOOL fSuppressHeader, IWbemServices ** ppNamespace )
{
    //==========================================================================
    // Open the requested namespaces
    //==========================================================================
    int nRc = FATAL_ERROR;

    if( i == -1 )
    {
        LogTestBeginning(nWhichTest,fSuppressHeader);
    
        nRc = GetListOfProviders( nWhichTest, MasterList );
    }
    else
    { 
        nRc = SUCCESS;
    }

    if( SUCCESS == nRc )
    {
        i++;
	    // =====================================================================
        //  Make sure we are still in range
	    // =====================================================================
        if( i < MasterList.Size() )
        {
            nRc = GetNextProviderNamespace(i, 200, MasterList, sNamespace, sKey);
            if( SUCCESS == nRc )
            {
	            // ==============================================================
                //  Open the namespace
	            // ==============================================================
                nRc = OpenNamespaceAndKeepOpen( ppNamespace,WPTR sNamespace,FALSE,fCompareResults);
            }
        }
        else
        {
            nRc = NO_MORE_DATA;
        }
    }
    if( SUCCESS == nRc )
    {
        nRc = RunRequestedTests(nWhichTest, fCompareResults);
    }

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 200
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ProviderOpenNamespace(BOOL fCompareResults, BOOL fSuppressHeader)
{
    //==========================================================================
    // Open the requested namespaces
    //==========================================================================
    int nRc = FATAL_ERROR;
    IWbemServices   * pNamespace    = NULL;
    ItemList MasterList;
    CHString sNamespace, sKey;
    int i = -1;

    while(TRUE)
    {
        nRc = GetNextNamespaceAndRunRequestedTests( 200, i, MasterList, sNamespace, sKey, fCompareResults, fSuppressHeader, &pNamespace );
        // ==============================================================
        //  Release the pointers
	    // ==============================================================
        SAFE_RELEASE_PTR(pNamespace);
        if( nRc == NO_MORE_DATA )
        {
            nRc = SUCCESS;
            break;
        }
        if( nRc == FATAL_ERROR )
        {
            break;
        }
    }
    LogTestEnding(200,nRc,fSuppressHeader);

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 201
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ProviderEnumerateClasses(BOOL fCompareResults, BOOL fSuppressHeader)
{
    int nRc = FATAL_ERROR;
    IWbemServices   * pNamespace = NULL;
    ItemList MasterList;
    CHString sNamespace;
    int i = -1;

    while(TRUE)
    {
        CHString sKey;
        nRc = GetNextNamespaceAndRunRequestedTests( 201, i, MasterList, sNamespace, sKey, fCompareResults, fSuppressHeader, &pNamespace );
        if( SUCCESS != nRc )
        {
            break;
        }
        // =============================================================
        //  Get the list of classes to make sure they are in namespace
        // =============================================================
        CHString sClasses;
        if( g_Options.GetSpecificOptionForAPITest( WPTR sKey,sClasses, 201 ) )
        {
            ItemList ClassList;

            if(InitMasterList(sClasses, ClassList))
            {
                for( int i = 0; i < ClassList.Size(); i++ )
                {
                    ItemInfo * pClass = ClassList.GetAt(i);
                    CHString sClassName;

                    if( g_Options.GetSpecificOptionForAPITest( WPTR pClass->Item,sClassName, 201 ) )
                    {
                        // =========================================================
                        //  Get the class name and expected results,
                        // =========================================================
                        CHString sClass;
                        ItemList Results;

                        nRc = CrackClassNameAndResults(WPTR sClassName, sClass, Results, NO_ERRORS_EXPECTED );
                        if( SUCCESS == nRc )
                        {
                            // =========================================================
                            //  Get the enumeration flags
                            // =========================================================
                            ItemList FlagList;
                            nRc = GetFlags(201, FlagList);
                            if( SUCCESS == nRc )
                            {
                                for( int x = 0; x < FlagList.Size(); x++ )
                                {
                                    ItemInfo * p = FlagList.GetAt(x);
                                    // =========================================================
                                    // Make sure those classes are in the namespace
                                    // =========================================================
                                    IEnumWbemClassObject * pEnum = NULL;
                                    nRc = EnumerateClassesAndLogErrors( pNamespace,&pEnum, p->dwFlags, WPTR sClass, WPTR sNamespace, NO_ERRORS_EXPECTED );
                                    if( SUCCESS == nRc )
                                    {
                                        if( fCompareResults )
                                        {
                                            if( x < Results.Size() )
                                            {
                                                ItemInfo * pResults = Results.GetAt(x);
                                                nRc = CompareResultsFromEnumeration(pEnum,pResults->Results,WPTR sClass, WPTR sNamespace);
                                            }
                                        }
                                    }
                                    SAFE_RELEASE_PTR(pEnum);
                                }
                            }
                        }
                    }
                }
            }
        }
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    if( nRc == NO_MORE_DATA )
    {
        nRc = SUCCESS;
    }
    LogTestEnding(201,nRc,fSuppressHeader);

    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 202
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ProviderExecuteQueries(BOOL fCompareResults, BOOL fSuppressHeader)
{
    int nRc = FATAL_ERROR;
    IWbemServices   * pNamespace = NULL;
    ItemList MasterList;
    CHString sNamespace;
    int i = -1;

    while(TRUE)
    {
        CHString sKey;
        nRc = GetNextNamespaceAndRunRequestedTests( 202, i, MasterList, sNamespace, sKey, fCompareResults, fSuppressHeader, &pNamespace );
        if( SUCCESS != nRc )
        {
            break;
        }

        // =============================================================
        //  Get the list of queries
        // =============================================================
        CHString sQueries;
        if( g_Options.GetSpecificOptionForAPITest( WPTR sKey,sQueries, 202 ) )
        {
            ItemList List;
            if(InitMasterList(sQueries, List))
            {
                for( int i = 0; i < List.Size(); i++ )
                {
                    ItemInfo * p = List.GetAt(i);
                    CHString sQuery;

                    if( g_Options.GetSpecificOptionForAPITest(p->Item,sQuery,202) )
                    {
                        EventInfo Query;
                        nRc =  CrackEvent(WPTR sQuery, Query,NO_ERRORS_EXPECTED);
                        if( SUCCESS == nRc )
                        {
                            //==================================================================
                            // Regular query
                            //==================================================================
                            nRc = QueryAndCompareResults( pNamespace,WPTR Query.Query,Query.Results,WPTR sNamespace);
                            if( nRc != S_OK )
                            {
                                break;
                            }
                        }
                    }
                }
            }
        }
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    if( nRc == NO_MORE_DATA )
    {
        nRc = SUCCESS;
    }
    LogTestEnding(202,nRc,fSuppressHeader);

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 203
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 204
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ProviderEnumerateInstances(BOOL fCompareResults, BOOL fSuppressHeader)
{
    int nRc = FATAL_ERROR;
    IWbemServices   * pNamespace = NULL;
    ItemList MasterList;
    CHString sNamespace;
    int i = -1;

    while(TRUE)
    {
        CHString sKey;
        nRc = GetNextNamespaceAndRunRequestedTests( 204, i, MasterList, sNamespace, sKey, fCompareResults, fSuppressHeader, &pNamespace );
        if( SUCCESS != nRc )
        {
            break;
        }
        // =============================================================
        //  Get the list of instances
        // =============================================================
        CHString sInstances;
        if( g_Options.GetSpecificOptionForAPITest( WPTR sKey,sInstances, 204 ) )
        {
            // =========================================================
            //  Get the enumeration flags
            // =========================================================
            ItemList FlagList;
            nRc = GetFlags(204, FlagList);
            if( SUCCESS == nRc )
            {
                for( int x = 0; x < FlagList.Size(); x++ )
                {
                    ItemInfo * p = FlagList.GetAt(x);
                    // =================================================
                    // Make sure those instances are in the namespace
                    // =================================================
                    nRc = EnumerateInstancesAndCompare( sInstances, 204, fCompareResults, pNamespace,(WCHAR*)((const WCHAR*)sNamespace));
                }
            }
        }
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    if( nRc == NO_MORE_DATA )
    {
        nRc = SUCCESS;
    }
    LogTestEnding(204,nRc,fSuppressHeader);

    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 205
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ProviderGetObjects(BOOL fCompareResults, BOOL fSuppressHeader)
{
    int nRc = FATAL_ERROR;
    IWbemServices   * pNamespace = NULL;
    ItemList MasterList;
    CHString sNamespace;
    int i = -1;

    while(TRUE)
    {
        CHString sKey;
        nRc = GetNextNamespaceAndRunRequestedTests( 205, i, MasterList, sNamespace, sKey, fCompareResults, fSuppressHeader, &pNamespace );
        if( SUCCESS != nRc )
        {
            break;
        }
        // =============================================================
        //  Get the list of instances
        // =============================================================
        CHString sObjects;
        if( g_Options.GetSpecificOptionForAPITest( WPTR sKey,sObjects, 205 ) )
        {
            // =========================================================
            //  Get the enumeration flags
            // =========================================================
            ItemList FlagList;
            nRc = GetFlags(205, FlagList);
            if( SUCCESS == nRc )
            {
                for( int x = 0; x < FlagList.Size(); x++ )
                {
                    ItemInfo * p = FlagList.GetAt(x);
                    // =================================================
                    // Get the specific objects
                    // =================================================
                    nRc = GetSpecificObjects(sObjects, pNamespace, 205,WPTR sNamespace);
                }
            }
        }
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    if( nRc == NO_MORE_DATA )
    {
        nRc = SUCCESS;
    }
    LogTestEnding(205,nRc,fSuppressHeader);

    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 206
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ProviderEnumerateMethods(BOOL fCompareResults, BOOL fSuppressHeader)
{
    int nRc = FATAL_ERROR;
    IWbemServices   * pNamespace = NULL;
    ItemList MasterList;
    CHString sNamespace;
    int i = -1;

    while(TRUE)
    {
        CHString sKey;
        nRc = GetNextNamespaceAndRunRequestedTests( 206, i, MasterList, sNamespace, sKey, fCompareResults, fSuppressHeader, &pNamespace );
        if( SUCCESS != nRc )
        {
            break;
        }
        // =============================================================
        //  Get the list of Methods 
        // =============================================================
        CHString sObjects;
        if( g_Options.GetSpecificOptionForAPITest( WPTR sKey,sObjects, 206 ) )
        {
            // =========================================================
            //  Get the enumeration flags
            // =========================================================
            ItemList FlagList;
            nRc = GetFlags(206, FlagList);
            if( SUCCESS == nRc )
            {
                for( int x = 0; x < FlagList.Size(); x++ )
                {
                    ItemInfo * p = FlagList.GetAt(x);
                    // =========================================================
                    // Delete the methods
                    // =========================================================
                    nRc = EnumerateMethodsAndCompare(sObjects, pNamespace, 206,fCompareResults,WPTR sNamespace);
                }
            }
        }
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    if( nRc == NO_MORE_DATA )
    {
        nRc = SUCCESS;
    }
    LogTestEnding(206,nRc,fSuppressHeader);

    return nRc;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 207
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ProviderExecuteMethods(BOOL fCompareResults, BOOL fSuppressHeader)
{
    int nRc = FATAL_ERROR;
    IWbemServices   * pNamespace = NULL;
    ItemList MasterList;
    CHString sNamespace;
    int i = -1;

    while(TRUE)
    {
        CHString sKey;
        nRc = GetNextNamespaceAndRunRequestedTests( 207, i, MasterList, sNamespace, sKey, fCompareResults, fSuppressHeader, &pNamespace );
        if( SUCCESS != nRc )
        {
            break;
        }
        // =============================================================
        //  Get the list of Methods 
        // =============================================================
        CHString sObjects;
        if( g_Options.GetSpecificOptionForAPITest( WPTR sKey,sObjects, 207 ) )
        {
            // =========================================================
            //  Get the enumeration flags
            // =========================================================
            ItemList FlagList;
            nRc = GetFlags(207, FlagList);
            if( SUCCESS == nRc )
            {
                for( int x = 0; x < FlagList.Size(); x++ )
                {
                    ItemInfo * p = FlagList.GetAt(x);
                    // =========================================================
                    // Delete the methods
                    // =========================================================
                    nRc = ExecuteMethodsAndCompare(sObjects, pNamespace, 207,fCompareResults,WPTR sNamespace);
                }
            }
        }
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    if( nRc == NO_MORE_DATA )
    {
        nRc = SUCCESS;
    }
    LogTestEnding(207,nRc,fSuppressHeader);

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 208
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ProviderSemiSyncEvents(BOOL fCompareResults, BOOL fSuppressHeader)
{
    int nRc = FATAL_ERROR;
    IWbemServices   * pNamespace = NULL;
    ItemList MasterList;
    CHString sNamespace;
    int i = -1;

    while(TRUE)
    {
        CHString sKey;
        nRc = GetNextNamespaceAndRunRequestedTests( 208, i, MasterList, sNamespace, sKey, fCompareResults, fSuppressHeader, &pNamespace );
        if( SUCCESS != nRc )
        {
            break;
        }
        // =============================================================
        //  Get the list of Methods 
        // =============================================================
        CHString sEvents;
        if( g_Options.GetSpecificOptionForAPITest( WPTR sKey,sEvents, 208 ) )
        {
            ItemList EventList;

            if(InitMasterList(sEvents, EventList))
            {
                for( int i = 0; i < EventList.Size(); i++ )
                {
                    ItemInfo * pEvent = EventList.GetAt(i);
                    CHString sEventInfo;
                    // ==================================================
                    //  Get the event info
                    // ==================================================
                    if( g_Options.GetSpecificOptionForAPITest( WPTR pEvent->Item,sEventInfo, 208 ) )
                    {
                        nRc = TestSemiSyncEvent( WPTR sEventInfo, fCompareResults);
                    }
                }
            }
        }
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    if( nRc == NO_MORE_DATA )
    {
        nRc = SUCCESS;
    }
    LogTestEnding(208,nRc,fSuppressHeader);

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 209
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ProviderTempAsyncEvents(BOOL fCompareResults, BOOL fSuppressHeader)
{
    int nRc = FATAL_ERROR;
    IWbemServices   * pNamespace = NULL;
    ItemList MasterList;
    CHString sNamespace;
    int i = -1;

    while(TRUE)
    {
        CHString sKey;
        nRc = GetNextNamespaceAndRunRequestedTests( 209, i, MasterList, sNamespace, sKey, fCompareResults, fSuppressHeader, &pNamespace );
        if( SUCCESS != nRc )
        {
            break;
        }
        // =============================================================
        //  Get the list of Methods 
        // =============================================================
        CHString sEvents;
        if( g_Options.GetSpecificOptionForAPITest( WPTR sKey,sEvents, 209 ) )
        {
            ItemList EventList;

            if(InitMasterList(sEvents, EventList))
            {
                for( int i = 0; i < EventList.Size(); i++ )
                {
                    ItemInfo * pEvent = EventList.GetAt(i);
                    CHString sEventInfo;
                    // ==================================================
                    //  Get the event info
                    // ==================================================
                    if( g_Options.GetSpecificOptionForAPITest( WPTR pEvent->Item,sEventInfo, 209 ) )
                    {
                        nRc = TestAsyncEvent( WPTR sEventInfo, fCompareResults);
                    }
                }
            }
        }
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    if( nRc == NO_MORE_DATA )
    {
        nRc = SUCCESS;
    }
    LogTestEnding(209,nRc,fSuppressHeader);

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 210
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int RefreshLoop( WCHAR * wcsClass, IWbemServices * pNamespace)
{
    int nRc = FATAL_ERROR;
	long		lLoopCount	= 0;		// Refresh loop counter
	CRefresher	aRefClient;

    // Initialize our container class
    // ==============================

	aRefClient.Initialize(pNamespace, wcsClass);

    // Add items to the refresher
    // ==========================

	// Add an enumerator
	// =================
	HRESULT hr = aRefClient.AddEnum(wcsClass);
	if ( SUCCEEDED( hr ) )
    {
    	hr = aRefClient.AddObjects(wcsClass);
        if( SUCCEEDED(hr) )
        {
            // Begin the refreshing loop
            // =========================
        	for ( lLoopCount = 0; lLoopCount < cdwNumReps; lLoopCount++ )
	        {
		        // Refresh!!
		        // =========
		        hr = aRefClient.Refresh();
		        if ( SUCCEEDED (hr) )
		        {
            		aRefClient.EnumerateObjectData();
		            aRefClient.EnumerateEnumeratorData();
                }
                else
                {
                    break;
                }
            }
        }

	}

	aRefClient.RemoveEnum();
	aRefClient.RemoveObjects();

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ProviderRefresher(BOOL fCompareResults, BOOL fSuppressHeader)
{
    int nRc = FATAL_ERROR;
    IWbemServices   * pNamespace = NULL;
    ItemList MasterList;
    CHString sNamespace;
    int i = -1;

    while(TRUE)
    {
        CHString sKey;
        nRc = GetNextNamespaceAndRunRequestedTests( 210, i, MasterList, sNamespace, sKey, fCompareResults, fSuppressHeader, &pNamespace );
        if( SUCCESS != nRc )
        {
            break;
        }
        // =============================================================
        //  Get the list of Methods 
        // =============================================================
        CHString sEvents;
        if( g_Options.GetSpecificOptionForAPITest( WPTR sKey,sEvents, 210) )
        {
            ItemList EventList;

            if(InitMasterList(sEvents, EventList))
            {
                for( int i = 0; i < EventList.Size(); i++ )
                {
                    ItemInfo * pEvent = EventList.GetAt(i);
                    CHString sEventInfo;
                    // ==================================================
                    //  Get the event info
                    // ==================================================
                    if( g_Options.GetSpecificOptionForAPITest( WPTR pEvent->Item,sEventInfo, 210 ) )
                    {
                      //  nRc = RefreshLoop( WPTR sEventInfo, pNamespace);
                    }
                }
            }
        }
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    if( nRc == NO_MORE_DATA )
    {
        nRc = SUCCESS;
    }
    LogTestEnding(210,nRc,fSuppressHeader);

    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 211
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ProviderCreateClasses(BOOL fCompareResults, BOOL fSuppressHeader)
{
    int nRc = FATAL_ERROR;
    IWbemServices   * pNamespace = NULL;
    ItemList MasterList;
    CHString sNamespace;
    int i = -1;

    while(TRUE)
    {
        CHString sKey;
        nRc = GetNextNamespaceAndRunRequestedTests( 211, i, MasterList, sNamespace, sKey, fCompareResults, fSuppressHeader, &pNamespace );
        if( SUCCESS != nRc )
        {
            break;
        }
        // =========================================================
        //  Get the enumeration flags
        // =========================================================
        ItemList FlagList;
        nRc = GetFlags(211, FlagList);
        if( SUCCESS == nRc )
        {
            for( int x = 0; x < FlagList.Size(); x++ )
            {
                ItemInfo * p = FlagList.GetAt(x);
                // =========================================================
                // Create classes
                // =========================================================
                nRc = CreateClassesForSpecificTest(pNamespace, WPTR sNamespace, WPTR sKey,211);
            }
        }
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    if( nRc == NO_MORE_DATA )
    {
        nRc = SUCCESS;
    }
    LogTestEnding(211,nRc,fSuppressHeader);

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 212
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ProviderCreateInstances(BOOL fCompareResults, BOOL fSuppressHeader)
{
    int nRc = FATAL_ERROR;
    IWbemServices   * pNamespace = NULL;
    ItemList MasterList;
    CHString sNamespace;
    int i = -1;

    while(TRUE)
    {
        CHString sKey;
        nRc = GetNextNamespaceAndRunRequestedTests( 212, i, MasterList, sNamespace, sKey, fCompareResults, fSuppressHeader, &pNamespace );
        if( SUCCESS != nRc )
        {
            break;
        }
        // =========================================================
        //  Get the enumeration flags
        // =========================================================
        ItemList FlagList;
        nRc = GetFlags(212, FlagList);
        if( SUCCESS == nRc )
        {
            for( int x = 0; x < FlagList.Size(); x++ )
            {
                ItemInfo * p = FlagList.GetAt(x);
                // =========================================================
                // Create Instances
                // =========================================================
                 nRc = CreateInstancesForSpecificTest(pNamespace, WPTR sNamespace,WPTR sKey,212,TRUE);
            }
        }
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    if( nRc == NO_MORE_DATA )
    {
        nRc = SUCCESS;
    }
    LogTestEnding(212,nRc,fSuppressHeader);

    return nRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtrefresh.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
///////////////////////////////////////////////////////////////////
//
//	RefClint.h : Refresher client header file
//
//	Created by a-dcrews and sanjes
//
///////////////////////////////////////////////////////////////////

#ifndef _REFCLINT_H_
#define _REFCLINT_H_

#include <wbemcli.h>

///////////////////////////////////////////////////////////////////
//
//	Globals and constants
//
///////////////////////////////////////////////////////////////////

const long	clNumInstances		= 5;					// The number of Win32_BasicHiPerf instances
const DWORD	cdwNumReps			= 100;					// The number of sample refreshes 

///////////////////////////////////////////////////////////////////
//
//	CRefresherMember
//
//	This class facilitates the management of objects or enumerators 
//	that have been added to the refresher and the unique ID assigned
//	to them.
//
///////////////////////////////////////////////////////////////////

template<class T>
class CRefresherMember
{
	T*		m_pMember;
	long	m_lID;

public:
	CRefresherMember() : m_pMember( NULL ), m_lID( 0 ) {}
	virtual ~CRefresherMember() { if ( NULL != m_pMember) m_pMember->Release(); }

	void Set(T* pMember, long lID);
	void Reset();

	T* GetMember();
	long GetID(){ return m_lID; }
};

template <class T> inline void CRefresherMember<T>::Set(T* pMember, long lID) 
{ 
	if ( NULL != pMember )
		pMember->AddRef();
	m_pMember = pMember;  
	m_lID = lID;
}

template <class T> inline void CRefresherMember<T>::Reset()
{
	if (NULL != m_pMember)
		m_pMember->Release();

	m_pMember = NULL;
	m_lID = 0;
}

template <class T> inline T* CRefresherMember<T>::GetMember()
{
	if ( NULL != m_pMember )
		m_pMember->AddRef();

	return m_pMember;
}


///////////////////////////////////////////////////////////////////
//
//	CRefresher
//
//	This class encapsulates the basic functionality of a WMI client
//	using the high performance refresher interface.
//
///////////////////////////////////////////////////////////////////

class CRefresher
{
	IWbemServices*				m_pNameSpace;		// A pointer to the namespace
	IWbemRefresher*				m_pRefresher;		// A pointer to the refresher
	IWbemConfigureRefresher*	m_pConfig;			// A pointer to the refresher's manager

	CRefresherMember<IWbemHiPerfEnum>	m_Enum;							// The enumerator added to the refresher
	CRefresherMember<IWbemObjectAccess>	m_Instances[clNumInstances];	// The instances added to the refreshrer

protected:
	HRESULT SetHandles(WCHAR * wscClass);

public:
	CRefresher();
	virtual ~CRefresher();
	
	HRESULT Initialize(IWbemServices* pNameSpace, WCHAR * wcsClass);

	HRESULT AddObjects(WCHAR * wcsClass);
	HRESULT RemoveObjects();
	HRESULT EnumerateObjectData();

	HRESULT AddEnum(WCHAR * wcsClass);
	HRESULT RemoveEnum();
	HRESULT EnumerateEnumeratorData();

	HRESULT Refresh();
};

#endif	//_REFCLINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtreposit.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTReposit.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <bvt.h>


#define NO_ERRORS_EXPECTED       FALSE,__FILE__,__LINE__
#define ERRORS_CAN_BE_EXPECTED   TRUE,__FILE__,__LINE__

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 1
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int BasicConnectUsingIWbemLocator(BOOL fCompareResults, BOOL fSuppressHeader )
{
    int nRc = FATAL_ERROR;
    IWbemServices   * pNamespace    = NULL;
    CHString sNamespace;

    LogTestBeginning(1,fSuppressHeader);

    if( g_Options.GetSpecificOptionForAPITest(L"NAMESPACE",sNamespace, 1) )
    {
	    // =====================================================================
        //  Open the namespace
	    // =====================================================================
        nRc = OpenNamespaceAndKeepOpen( &pNamespace, WPTR sNamespace,FALSE,fCompareResults);
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }

    LogTestEnding(1,nRc,fSuppressHeader);

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 2
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int BasicSyncConnectUsingIWbemConnection(BOOL fCompareResults, BOOL fSuppressHeader )
{
    int nRc = FATAL_ERROR;
    IWbemConnection * pConnection   = NULL;
    CHString sNamespace;
    CHString sClass;

    LogTestBeginning(2,fSuppressHeader);

    if( g_Options.GetSpecificOptionForAPITest(L"NAMESPACE",sNamespace,2) )
    {
        if( g_Options.GetSpecificOptionForAPITest(L"CLASS",sClass,2) )
        {
            nRc = CoCreateInstanceAndLogErrors(CLSID_WbemConnection,IID_IWbemConnection,(void**)&pConnection,NO_ERRORS_EXPECTED);
            if( SUCCESS == nRc )
            {
	            // =================================================================
                //  Test Open with all three types:
                //
                //      IWbemServices
                //      IWbemServicesEx
                //      IWbemClassObject
                //
                //  Initialize all vars
                // =================================================================
                short FatalErrors = 0;

 	            // =================================================================
                //  Open the namespace with IWbemServices
	            // =================================================================
                IWbemServices   * pNamespace        = NULL;
                nRc = OpenObjectAndLogErrors(pConnection, IID_IWbemServices, (void**) &pNamespace, WPTR sNamespace,NO_ERRORS_EXPECTED);
	            if ( nRc != SUCCESS )
                {
                    FatalErrors++;
                }
                SAFE_RELEASE_PTR(pNamespace);

	            // =================================================================
                //  Open the namespace with IWbemServicesEx
	            // =================================================================
                IWbemServicesEx * pNamespaceEx      = NULL;
                nRc = OpenObjectAndLogErrors(pConnection, IID_IWbemServicesEx, (void**) &pNamespaceEx,WPTR sNamespace,NO_ERRORS_EXPECTED);
	            if ( nRc != SUCCESS )
                {
                    FatalErrors++;
                }
                SAFE_RELEASE_PTR(pNamespaceEx);

	            // =================================================================
                //  Open the Class for IWbemClassObject
	            // =================================================================
                IWbemClassObject* pWbemClassObject  = NULL;
                nRc = OpenObjectAndLogErrors(pConnection, IID_IWbemClassObject, (void**) &pWbemClassObject, WPTR sClass,NO_ERRORS_EXPECTED);
	            if ( nRc != SUCCESS )
                {
                    FatalErrors++;
                }
                SAFE_RELEASE_PTR(pWbemClassObject);

	            // =================================================================
                //  Check to see if there were any fatal errors
	            // =================================================================
                if( !FatalErrors )
                {
                    nRc = SUCCESS;
                }
            }
    	    // =====================================================================
            //  Release the locator
	        // =====================================================================
            SAFE_RELEASE_PTR(pConnection);
        }
    }

    LogTestEnding(2,nRc,fSuppressHeader);
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 3
//*****************************************************************************************************************
int BasicAsyncConnectUsingIWbemConnection(BOOL fCompareResults, BOOL fSuppressHeader )
{
    int nRc    = FATAL_ERROR;
    HRESULT hr = S_OK;
    IWbemConnection * pConnection   = NULL;
    CHString sNamespace;
    CHString sClass;
  
    LogTestBeginning(3,fSuppressHeader);
    if( g_Options.GetSpecificOptionForAPITest(L"NAMESPACE",sNamespace,2) )
    {
        if( g_Options.GetSpecificOptionForAPITest(L"CLASS",sClass,2))
        {
            nRc = CoCreateInstanceAndLogErrors(CLSID_WbemConnection,IID_IWbemConnection,(void**)&pConnection,NO_ERRORS_EXPECTED);
            if( SUCCESS == nRc )
            {
 	            // =================================================================
                //  Test Open with all three types:
                //
                //      IWbemServices
                //      IWbemServicesEx
                //      IWbemClassObject
                //
                //  Initialize all the vars
	            // =================================================================
                short FatalErrors = 0;
                CSinkEx * pHandler = NULL;

                pHandler = new CSinkEx;
                if( pHandler )
                {
                    // =================================================================
                    //  Open the namespace with IWbemServices
	                // =================================================================
                    nRc = OpenObjectAsyncAndLogErrors(pConnection, IID_IWbemServices,WPTR sNamespace,pHandler,NO_ERRORS_EXPECTED);
	                if ( nRc == FATAL_ERROR )
                    {
                        FatalErrors++;
                    }
                    else
                    {
                        IWbemServices * pNamespace = NULL;

			            pHandler->WaitForSignal(INFINITE);
			            hr = pHandler->GetStatusCode();
			            if(SUCCEEDED(hr))
                        {
				            pNamespace = (IWbemServices*)pHandler->GetInterface();
			            }

                        SAFE_RELEASE_PTR(pNamespace);
                    }
                }
                else
                {
                    gp_LogFile->LogError(__FILE__,__LINE__,FATAL_ERROR, L"Allocation of new CSinkEx Failed - Out of memory.");
                }
                SAFE_DELETE_PTR(pHandler);


	            // =================================================================
                //  Open the namespace with IWbemServicesEx
	            // =================================================================
                pHandler = new CSinkEx;
                if( pHandler )
                {
                    nRc = OpenObjectAsyncAndLogErrors(pConnection, IID_IWbemServicesEx,WPTR sNamespace, pHandler,NO_ERRORS_EXPECTED);
	                if ( nRc == FATAL_ERROR )
                    {
                        FatalErrors++;
                    }
                    else
                    {
                        IWbemServicesEx * pNamespace = NULL;

			            pHandler->WaitForSignal(INFINITE);
			            hr = pHandler->GetStatusCode();
			            if(SUCCEEDED(hr))
                        {
				            pNamespace = (IWbemServicesEx*)pHandler->GetInterface();
			            }

                        SAFE_RELEASE_PTR(pNamespace);
                    }
                }
                else
                {
                    gp_LogFile->LogError(__FILE__,__LINE__,FATAL_ERROR, L"Allocation of new CSinkEx Failed - Out of memory.");
                }
                SAFE_DELETE_PTR(pHandler);

	            // =================================================================
                //  Open the class for IWbemClassObject
	            // =================================================================
                pHandler = new CSinkEx;
                if( pHandler )
                {
                    nRc = OpenObjectAsyncAndLogErrors(pConnection, IID_IWbemClassObject, WPTR sClass, pHandler,NO_ERRORS_EXPECTED);
	                if ( nRc == FATAL_ERROR )
                    {
                        FatalErrors++;
                    }
                    else
                    {
                        IWbemClassObject * pWbemClassObject  = NULL;
        
			            pHandler->WaitForSignal(INFINITE);
			            hr = pHandler->GetStatusCode();
			            if(SUCCEEDED(hr))
                        {
				            pWbemClassObject = (IWbemClassObject*)pHandler->GetInterface();
			            }

                        SAFE_RELEASE_PTR(pWbemClassObject);
                    }
                }
                else
                {
                    gp_LogFile->LogError(__FILE__,__LINE__,FATAL_ERROR, L"Allocation of new CSinkEx Failed - Out of memory.");
                }
                SAFE_DELETE_PTR(pHandler);

	            // =================================================================
                //  Check to see if there are any fatal errors
	            // =================================================================
                if( !FatalErrors )
                {
                    nRc = SUCCESS;
                }
            }

	        // =====================================================================
            //  Release the locator
	        // =====================================================================
            SAFE_RELEASE_PTR(pConnection);
        }
    }

    LogTestEnding(3,nRc,fSuppressHeader);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 4
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateNewTestNamespace(BOOL fCompareResults, BOOL fSuppressHeader )
{
    int nRc = SUCCESS;
    CHString sNamespace;
    CHString sParentNamespace;
    CHString sInstance;

    LogTestBeginning(4,fSuppressHeader);
    if( g_Options.GetSpecificOptionForAPITest(L"PARENT_NAMESPACE",sParentNamespace, 4))
    {
  
        if( g_Options.GetSpecificOptionForAPITest(L"NAMESPACE",sNamespace, 4))
        {
            if( g_Options.GetSpecificOptionForAPITest(L"CLASSES",sInstance, 4 ))
            {
                IWbemLocator * pLocator = NULL;

                nRc = CoCreateInstanceAndLogErrors(CLSID_WbemLocator,IID_IWbemLocator,(void**)&pLocator,NO_ERRORS_EXPECTED);
                if( SUCCESS == nRc )
                {
                    //==========================================================================
                    //  Parse the namespace name to get the parent first, and open the parent
                    //  this one must be existing 
                    //==========================================================================
                    IWbemServices * pParentNamespace = NULL;
                    IWbemServices * pChildNamespace  = NULL;

                    nRc = ConnectServerAndLogErrors(pLocator,&pParentNamespace, WPTR sParentNamespace,NO_ERRORS_EXPECTED);
                    if( nRc == SUCCESS )
                    {
                        //==============================================================
                        //  If we got here, then we know that the child namespace does 
                        //  not exist, so create it.
                        //==============================================================
                        nRc = CreateInstances(pParentNamespace,sInstance, WPTR sParentNamespace, 4 );
                        if( SUCCESS == nRc )
                        {
                            //==========================================================
                            //  Open the namespace with IWbemServices as the new parent
                            //==========================================================
                            nRc = ConnectServerAndLogErrors(pLocator, &pChildNamespace,WPTR sNamespace,NO_ERRORS_EXPECTED);
                        }
                    }
                    SAFE_RELEASE_PTR(pParentNamespace);
                    SAFE_RELEASE_PTR(pChildNamespace);
                }
                // =============================================================================
                //  Release the locator
	            // =============================================================================
                SAFE_RELEASE_PTR(pLocator);
            }
        }
    }
    LogTestEnding(4,nRc,fSuppressHeader);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 5
//*****************************************************************************************************************

int CreateNewClassesInTestNamespace(BOOL fCompareResults, BOOL fSuppressHeader )
{
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(5,fSuppressHeader);
	// =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(5, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        //=========================================================
        // Create classes with different properties. Some of 
        // these should be in the following inheritance chain and 
        // some should not inherit from the others at all:  
        // classes = {A, B, C, D:A, E:A, F:E, G:F, H:G, I:F}.  
        // A mix of simple string & sint32 keys are fine.
        //=========================================================
        nRc = CreateClassesForSpecificTest(pNamespace, WPTR sNamespace,L"CLASSES",5);
    }

	// =====================================================================
    //  Release the pointers
    // =====================================================================
    SAFE_RELEASE_PTR(pNamespace);

    LogTestEnding(5,nRc,fSuppressHeader);

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 6
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteAndRecreateNewClassesInTestNamespace(BOOL fCompareResults, BOOL fSuppressHeader )
{
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(6,fSuppressHeader);
	// =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(6, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        //=========================================
        //  Get all of the class operations for 
        //  this test:
        //     Classes to be deleted
        //     Classes to be compared
        //     Classes to be added
        //     Classes to be compared
        //     Classes to be added_deleted
        //     Classes to be compared
        //=============================================
        CHString sDeleteClasses;
        CHString sClassesAfterDelete;
        CHString sAddClasses; 
        CHString sClassesAfterAdd; 
        CHString sDeleteAddClassOrder; 
        CHString sClassesAfterDeleteAdd;

        if( g_Options.GetSpecificOptionForAPITest( L"DELETE_CLASSES", sDeleteClasses, 6))
        {
            if( g_Options.GetSpecificOptionForAPITest( L"CLASSES_AFTER_DELETE", sClassesAfterDelete, 6))
            {
                 if( g_Options.GetSpecificOptionForAPITest( L"ADD_CLASSES", sAddClasses, 6))
                 {
                    if( g_Options.GetSpecificOptionForAPITest( L"CLASSES_AFTER_ADD", sClassesAfterAdd, 6))
                    {
                        if( g_Options.GetSpecificOptionForAPITest( L"DELETE_ADD_CLASS_ORDER", sDeleteAddClassOrder, 6))
                        {
                            if( g_Options.GetSpecificOptionForAPITest( L"CLASSES_AFTER_DELETE_ADD", sClassesAfterDeleteAdd, 6))
                            {
                                nRc = DeleteClasses(sDeleteClasses, 6, fCompareResults,pNamespace,WPTR sNamespace);
                                if( nRc == SUCCESS )
                                {
                                    nRc = EnumerateClassesAndCompare(sClassesAfterDelete, 6,fCompareResults, pNamespace,WPTR sNamespace);
                                    if( nRc == SUCCESS )
                                    {
                                        nRc = AddClasses(sAddClasses, pNamespace, WPTR sNamespace, 6 );
                                        if( nRc == SUCCESS )
                                        {
                                            nRc = EnumerateClassesAndCompare(sClassesAfterAdd,6,fCompareResults, pNamespace, WPTR sNamespace);
                                            if( nRc == SUCCESS )
                                            {
                                                nRc = DeleteAndAddClasses(sDeleteAddClassOrder, pNamespace, WPTR sNamespace, 6);
                                                if( nRc == SUCCESS )
                                                {
                                                    nRc = EnumerateClassesAndCompare(sClassesAfterDeleteAdd,6, fCompareResults,pNamespace, WPTR sNamespace);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    // =====================================================================
    //  Release the pointers
    // =====================================================================
    SAFE_RELEASE_PTR(pNamespace);

    LogTestEnding(6,nRc,fSuppressHeader);

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 7
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateSimpleAssociations(BOOL fCompareResults, BOOL fSuppressHeader )
{
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(7,fSuppressHeader);
	// =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(7, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        //=================================================
        //  Get the list of associations to create
        //=================================================
        CHString sItemList;

        if( g_Options.GetSpecificOptionForAPITest(L"CLASSES",sItemList, 7))
        {
            ItemList MasterList;
            //=======================================================
            //  Parse the list of the associations to be created
            //=======================================================
            if( InitMasterList(sItemList,MasterList))
            {
                for( int i = 0; i < MasterList.Size(); i++ )
                {
                    ItemInfo * p = MasterList.GetAt(i);
                    CHString sItemInformation;

                    // =============================================================
                    //  Get definition of the association
                    // =============================================================
                    int nWhichTest = 0;
                    CHString sClassDef;

                    nRc = GetClassDefinitionSection(7, sClassDef, nWhichTest );
                    if( SUCCESS == nRc )
                    {
                        if( g_Options.GetSpecificOptionForAPITest(p->Item,sItemInformation,nWhichTest) )
                        {
                            //===========================================================
                            //  Create the association
                            //===========================================================
                            nRc = CreateAssociationAndLogErrors(pNamespace,p->Item,WPTR sItemInformation,WPTR sNamespace);
                            if( nRc != SUCCESS )
                            {
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
	// =====================================================================
    //  Release the pointers
    // =====================================================================
    SAFE_RELEASE_PTR(pNamespace);

    LogTestEnding(7,nRc,fSuppressHeader);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 8
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int QueryAllClassesInTestNamespace(BOOL fCompareResults, BOOL fSuppressHeader )
{
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(8,fSuppressHeader);
    // =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(8, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        //==================================================================
        // Query classes in test namespace
        //==================================================================
        CHString sQueryList;
        if( g_Options.GetSpecificOptionForAPITest(L"QUERY_LIST",sQueryList, 8))
        {
            ItemList MasterList;
            //=======================================================
            //  Get the list of the queries
            //=======================================================
            if( InitMasterList(sQueryList,MasterList))
            {
                for( int i = 0; i < MasterList.Size(); i++ )
                {
                    ItemInfo * p = MasterList.GetAt(i);
                    CHString sQuery;

                    if( g_Options.GetSpecificOptionForAPITest(p->Item,sQuery,8) )
                    {
                        EventInfo Query;
                        nRc =  CrackEvent(WPTR sQuery, Query,NO_ERRORS_EXPECTED);
                        if( SUCCESS == nRc )
                        {
                            //==================================================================
                            // Regular query
                            //==================================================================
                            nRc = QueryAndCompareResults( pNamespace,WPTR Query.Query,Query.Results,WPTR sNamespace);
                            if( nRc != S_OK )
                            {
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
	// =====================================================================
    //  Release the pointers
    // =====================================================================
    SAFE_RELEASE_PTR(pNamespace);

    LogTestEnding(8,nRc,fSuppressHeader);
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 9
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateClassInstances(BOOL fCompareResults, BOOL fSuppressHeader )
{
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(9,fSuppressHeader);

	// =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(9, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        nRc = CreateInstancesForSpecificTest(pNamespace, WPTR sNamespace,L"INSTANCE_LIST",9,TRUE);
    }
	// =====================================================================
    //  Release the pointers
	// =====================================================================
    SAFE_RELEASE_PTR(pNamespace);
    LogTestEnding(9,nRc,fSuppressHeader);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 10
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteClassInstances(BOOL fCompareResults, BOOL fSuppressHeader )
{
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(10,fSuppressHeader);

	// =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(10, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        // =============================================================
        //  Get the list of instances to delete
        // =============================================================
        CHString sInstanceList;
        if( g_Options.GetSpecificOptionForAPITest( L"INSTANCE_LIST",sInstanceList, 10 ) )
        {
            // =========================================================
            // Delete the instances in the namespace
            // =========================================================
            nRc = DeleteInstancesAndCompareResults(sInstanceList, 10, pNamespace, WPTR sNamespace);
        }
    }
	// =====================================================================
    //  Release the pointers
	// =====================================================================
    SAFE_RELEASE_PTR(pNamespace);

    LogTestEnding(10,nRc,fSuppressHeader);

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 11
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int EnumerateClassInstances(BOOL fCompareResults, BOOL fSuppressHeader )
{
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(11,fSuppressHeader);

	// =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(11, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        // =============================================================
        //  Get the list of classes to get instances for
        // =============================================================
        CHString sInstanceList;
        
        if( g_Options.GetSpecificOptionForAPITest( L"INSTANCE_LIST", sInstanceList, 11 ) )
        {
            // =========================================================
            //  Get the enumeration flags
            // =========================================================
            ItemList FlagList;
            nRc = GetFlags(11, FlagList);
            if( SUCCESS == nRc )
            {
                for( int i = 0; i < FlagList.Size(); i++ )
                {
                    ItemInfo * p = FlagList.GetAt(i);
                    // =================================================
                    // Make sure those instances are in the namespace
                    // =================================================
                    nRc = EnumerateInstancesAndCompare( sInstanceList, 11, fCompareResults, pNamespace,WPTR sNamespace);
                }
            }
        }
    }
	// =====================================================================
    //  Release the pointers
	// =====================================================================
    SAFE_RELEASE_PTR(pNamespace);
    LogTestEnding(11,nRc,fSuppressHeader);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 12
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateAssociationInstances(BOOL fCompareResults, BOOL fSuppressHeader )
{
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(12,fSuppressHeader);

	// =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(12, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        nRc = CreateInstancesForSpecificTest(pNamespace, WPTR sNamespace,L"INSTANCE_LIST",12,TRUE);
    }
	// =====================================================================
    //  Release the pointers
	// =====================================================================
    SAFE_RELEASE_PTR(pNamespace);

    LogTestEnding(12,nRc,fSuppressHeader);

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 13
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteAssociationInstances(BOOL fCompareResults, BOOL fSuppressHeader )
{
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(13,fSuppressHeader);

	// =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(13, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        // =============================================================
        //  Get the list of instances to delete
        // =============================================================
        CHString sInstanceList;
        if( g_Options.GetSpecificOptionForAPITest(L"INSTANCE_LIST", sInstanceList, 13 ) )
        {
            // =========================================================
            // Delete the instances in the namespace
            // =========================================================
            nRc = DeleteInstancesAndCompareResults(sInstanceList,13, pNamespace, WPTR sNamespace);
         }
    }
	// =====================================================================
    //  Release the pointers
	// =====================================================================
    SAFE_RELEASE_PTR(pNamespace);
    LogTestEnding(13,nRc,fSuppressHeader);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 14
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int EnumerateAssociationInstances(BOOL fCompareResults, BOOL fSuppressHeader )
{
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(14,fSuppressHeader);

	// =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(14, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        // =============================================================
        //  Get the list of classes to get instances for
        // =============================================================
        CHString sInstanceList;
        
        if( g_Options.GetSpecificOptionForAPITest( L"INSTANCE_LIST", sInstanceList, 14 ) )
        {
             // =========================================================
             //  Get the enumeration flags
             // =========================================================
             ItemList FlagList;
             nRc = GetFlags(14, FlagList);
             if( SUCCESS == nRc )
             {
                 for( int i = 0; i < FlagList.Size(); i++ )
                 {
                     ItemInfo * p = FlagList.GetAt(i);
                    // =========================================================
                    // Make sure those instances are in the namespace
                    // =========================================================
                    nRc = EnumerateInstancesAndCompare( sInstanceList, 14, fCompareResults, pNamespace,WPTR sNamespace);
                 }
             }
        }
    }
	// =====================================================================
    //  Release the pointers
	// =====================================================================
    SAFE_RELEASE_PTR(pNamespace);
    LogTestEnding(14,nRc,fSuppressHeader);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 15
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteClassDeletesInstances(BOOL fCompareResults, BOOL fSuppressHeader )
{
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(15,fSuppressHeader);

	// =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(15, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        // =============================================================
        //  Get the list of classes to delete
        // =============================================================
        CHString sClassList;
        
        if( g_Options.GetSpecificOptionForAPITest( L"CLASSES", sClassList, 15 ) )
        {
             // =========================================================
             //  Get the enumeration flags
             // =========================================================
             ItemList FlagList;
             nRc = GetFlags(15, FlagList);
             if( SUCCESS == nRc )
             {
                 for( int i = 0; i < FlagList.Size(); i++ )
                 {
                     ItemInfo * p = FlagList.GetAt(i);
                    // ==================================================
                    // Make sure those instances are in the namespace
                    // ==================================================
                    nRc = DeleteClasses(sClassList,15,fCompareResults,pNamespace,WPTR sNamespace);
                 }
             }
        }
    }
 	 
    // =====================================================================
    //  Release the pointers
    // =====================================================================
    SAFE_RELEASE_PTR(pNamespace);
    LogTestEnding(15,nRc,fSuppressHeader);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 16
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetObjects(BOOL fCompareResults, BOOL fSuppressHeader )
{
    //==========================================================================
    // Get the various types of objects (classes/instances) using the various
    // types of paths accepted by WMI ( WMI path/ UMI path/ HTTP path)
    //==========================================================================
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;
    LogTestBeginning(16,fSuppressHeader);
	// =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(16, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        // =============================================================
        //  Get the list of objexts to get
        // =============================================================
        CHString sObjects;
        if( g_Options.GetSpecificOptionForAPITest( L"OBJECT_LIST",sObjects, 16 ) )
        {
            // =========================================================
            // Get the requested objects
            // =========================================================
            nRc = GetSpecificObjects(sObjects, pNamespace, 16,WPTR sNamespace);
        }
    }
	// =====================================================================
    //  Release the pointers
	// =====================================================================
    SAFE_RELEASE_PTR(pNamespace);
    LogTestEnding(16,nRc,fSuppressHeader);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 17
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateMethods(BOOL fCompareResults, BOOL fSuppressHeader )
{
	// =====================================================================
    // Getting a list of Methods for a class and instance
	// =====================================================================
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

     LogTestBeginning(17,fSuppressHeader);

	// =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(17, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        // =============================================================
        //  Get the list of methods to create
        // =============================================================
        CHString sObjects;
        if( g_Options.GetSpecificOptionForAPITest( L"METHOD_LIST",sObjects, 17 ) )
        {
            // =========================================================
            // Create the methods
            // =========================================================
            nRc = CreateMethodsAndCompare(sObjects, pNamespace, 17, fCompareResults, WPTR sNamespace);
        }

    }
    SAFE_RELEASE_PTR(pNamespace);

    LogTestEnding(17,nRc,fSuppressHeader);

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 18
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteMethods(BOOL fCompareResults, BOOL fSuppressHeader )
{
	// =====================================================================
    // Getting a list of Methods for a class and instance
	// =====================================================================
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(18,fSuppressHeader);

	// =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(18, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        // =============================================================
        //  Get the list of methods to delete
        // =============================================================
        CHString sObjects;
        if( g_Options.GetSpecificOptionForAPITest( L"METHOD_LIST",sObjects, 18 ) )
        {
            // =========================================================
            // Delete the methods
            // =========================================================
            nRc = DeleteMethodsAndCompare(sObjects, pNamespace, 18,fCompareResults,WPTR sNamespace);
        }

    }
    SAFE_RELEASE_PTR(pNamespace);

    LogTestEnding(18,nRc,fSuppressHeader);

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 19
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ListMethods(BOOL fCompareResults, BOOL fSuppressHeader )
{
	// =====================================================================
    // Getting a list of Methods for a class and instance
	// =====================================================================
    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(19,fSuppressHeader);

	// =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(19, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        // =============================================================
        //  Get the list of methods to delete
        // =============================================================
        CHString sObjects;
        if( g_Options.GetSpecificOptionForAPITest( L"METHOD_LIST",sObjects, 19 ) )
        {
            // =========================================================
            // Delete the methods
            // =========================================================
            nRc = EnumerateMethodsAndCompare(sObjects, pNamespace, 19,fCompareResults,WPTR sNamespace);
        }

    }
    SAFE_RELEASE_PTR(pNamespace);

    LogTestEnding(19,nRc,fSuppressHeader);

    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 20
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteAllNonSystemClasses(BOOL fCompareResults, BOOL fSuppressHeader )
{

    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(20,fSuppressHeader);
  	// =====================================================================
    //  Run the requested tests and get then namespace open
	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(20, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        IEnumWbemClassObject * pEnum = NULL;

        //===========================================================
        //  Begin enumerating all of the classes in the namespace
        //===========================================================
        nRc = EnumerateClassesAndLogErrors(pNamespace,&pEnum, WBEM_FLAG_RETURN_IMMEDIATELY|WBEM_FLAG_FORWARD_ONLY , NULL, WPTR sNamespace,NO_ERRORS_EXPECTED);
        if( nRc == S_OK )
        {
            //===================================================
            //  while we get the classes in the namespace
            //===================================================
  	       IWbemClassObject * pClass = NULL;
           while( TRUE )
            {
                nRc = NextClassAndLogErrors(pEnum, &pClass,WPTR sNamespace,NO_ERRORS_EXPECTED);
                if( nRc == NO_MORE_DATA )
                {
                    nRc = SUCCESS;
                    break;
                }
                if( nRc != SUCCESS )
                { 
                    break;
                }
                CVARIANT vProperty;
                CIMTYPE pType = 0;
                LONG    lFlavor = 0;
                //===================================================
                //  Get the name of the class
                //===================================================
                nRc = GetPropertyAndLogErrors( pClass, L"__CLASS", &vProperty, &pType, &lFlavor, NULL,WPTR sNamespace, NO_ERRORS_EXPECTED);
                if( nRc == S_OK )
                {
                    //===============================================
                    //  filter out system classes
                    //===============================================
                    if( wcsncmp( vProperty.GetStr(), L"__", 2 ) != 0 )
                    {
                        //===============================================
                        //  Delete it, however, it may not be there if
                        //  the parent class has already been deleted.
                        //===============================================
                        DeleteClassAndLogErrors(pNamespace,  vProperty.GetStr(), WPTR sNamespace,ERRORS_CAN_BE_EXPECTED);
                    }
                }
                SAFE_RELEASE_PTR(pClass);
            }

            SAFE_RELEASE_PTR(pClass);
        }
    }
    SAFE_RELEASE_PTR(pNamespace);
    LogTestEnding(20,nRc,fSuppressHeader);
    return nRc;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 21
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteRequestedNamespace(BOOL fCompareResults, BOOL fSuppressHeader )
{

    int nRc = FATAL_ERROR;
    CHString sNamespace;
    IWbemServices * pNamespace = NULL;

    LogTestBeginning(21,fSuppressHeader);
  	// =====================================================================
    //  Run the requested tests
    //  Go to the parent namespace
 	// =====================================================================
    nRc = RunRequestedTestsAndOpenNamespace(21, sNamespace, &pNamespace, fCompareResults);
    if( SUCCESS == nRc )
    {
        //==================================================================
        //  Get the name of the namespace to delete
        //==================================================================
        CHString sObjects;
        if( g_Options.GetSpecificOptionForAPITest( L"NAMESPACE_TO_DELETE",sObjects, 21 ) )
        {
            // =========================================================
            //  See if the instance exists
            // =========================================================
            IWbemClassObject * pClass = NULL;

            nRc = GetClassObjectAndLogErrors( pNamespace, sObjects, &pClass,WPTR sNamespace,ERRORS_CAN_BE_EXPECTED);
    
            SAFE_RELEASE_PTR(pClass);

            if( SUCCESS == nRc )
            {
                // =========================================================
                // Delete the instances of the namespace
                // =========================================================
                nRc = DeleteInstanceAndLogErrors(pNamespace, sObjects, WPTR sNamespace, NO_ERRORS_EXPECTED );
            }
            else
            {
                if( nRc == FAILED_AS_EXPECTED )
                {
                    nRc = SUCCESS;
                }
            }
        }
    }
    SAFE_RELEASE_PTR(pNamespace);
    LogTestEnding(21,nRc,fSuppressHeader);
    return nRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtrefresh.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTREFRESH.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <bvt.h>
#include "BVTRefresh.h"


///////////////////////////////////////////////////////////////////
//
//	Counter data
//
//	These structures are used as a matter of convienience and 
//	clarity.  A real client should enumerate the properties
//	of an object in order to determine the number and names
//	of the counter properties.
//
///////////////////////////////////////////////////////////////////
// The number of counter properties for Win32_BasicHiPerf

enum 
{
	Ctr1,
	Ctr2,
	Ctr3,
	Ctr4,
	Ctr5,
	NumCtrs
};

// The names and handles (set by SetHandles()) for a Win32_BasicHiPerf object

struct CCounterData
{
	WCHAR	m_wcsName[256];
	long	m_lHandle;
} g_aCounters[] =
{
	L"Counter1", 0,
	L"Counter2", 0,
	L"Counter3", 0,
	L"Counter4", 0,
	L"Counter5", 0,
};


///////////////////////////////////////////////////////////////////
//
//	CRefresher
//
///////////////////////////////////////////////////////////////////
CRefresher::CRefresher() : m_pNameSpace(NULL), m_pRefresher(NULL), m_pConfig(NULL)
{
}

CRefresher::~CRefresher()
{
    SAFE_RELEASE_PTR(m_pNameSpace);
    SAFE_RELEASE_PTR(m_pRefresher);
    SAFE_RELEASE_PTR(m_pConfig);
}

///////////////////////////////////////////////////////////////////
//
//	Helper methods
//
///////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////
//
//	SetHandles will initialize the IWbemObjectAccess handle values 
//	in the counter array.
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
HRESULT CRefresher::SetHandles(WCHAR * wcsClass)
{
	HRESULT hr = WBEM_NO_ERROR;

	IWbemClassObject*	pObj = NULL;
	long lIndex;

    // Get an IWbemObjectAccess interface to one of the sample objects
    // ===============================================================

	hr = m_pNameSpace->GetObject( CBSTR(wcsClass), 0, NULL, &pObj, NULL );
	if ( SUCCEEDED( hr ) ) 
    {

        // Get the alternate interface
	    // ===========================
    	IWbemObjectAccess*	pAccess = NULL;
    	hr = pObj->QueryInterface( IID_IWbemObjectAccess, ( LPVOID* )&pAccess );
        if( SUCCEEDED(hr))
        {
        
            // Set the access handles for all of the counter properties
            // ========================================================
        	for ( lIndex = Ctr1; lIndex < NumCtrs; lIndex++ )
	        {	
		        long lHandle;
        		hr = pAccess->GetPropertyHandle( g_aCounters[lIndex].m_wcsName, NULL, &lHandle );
                if( SUCCEEDED(hr))
                {
		    		g_aCounters[lIndex].m_lHandle = lHandle;
                }
            }
        }
        SAFE_RELEASE_PTR(pAccess);
	}	
  
    SAFE_RELEASE_PTR(pObj);
	return hr;
}
///////////////////////////////////////////////////////////////////
//
//	Class method API
//
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
//
//	Initialize will create the refresher and configuration manager
//	and set the IWbemObjectAccess handles which are used to access
//	property values of the instances.
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
HRESULT CRefresher::Initialize(IWbemServices* pNameSpace, WCHAR * wcsClass)
{
	HRESULT hr = WBEM_NO_ERROR;

	// Copy the namespace pointer
	// ==========================

	if ( NULL == pNameSpace )
    {
		return WBEM_E_INVALID_PARAMETER;
    }

	m_pNameSpace = pNameSpace;
	m_pNameSpace->AddRef();

	// Create the refresher and refresher manager
	// ==========================================

	hr = CoCreateInstance( CLSID_WbemRefresher, NULL, CLSCTX_INPROC_SERVER, IID_IWbemRefresher, (void**) &m_pRefresher );
	if ( SUCCEEDED(hr))
    {
	    hr = m_pRefresher->QueryInterface( IID_IWbemConfigureRefresher, (void**) &m_pConfig );
	    if( SUCCEEDED(hr))
        {
        	// Set the access handles
        	// ======================
            hr = SetHandles(wcsClass);
        }
    }
	return hr;
}
///////////////////////////////////////////////////////////////////
//
//	AddObject will add a set of objects to the refresher.  The 
//	method will update m_aInstances with the instance data. 
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
HRESULT CRefresher::AddObjects(WCHAR * wcsClass)
{
	HRESULT hr = WBEM_NO_ERROR;

	long	lIndex = 0;
	WCHAR	wcsObjName[256];

    // Loop through all instances of the class and add them to the refresher
    // =============================================================================

	for ( lIndex = 0; lIndex < clNumInstances; lIndex++ )
	{
		IWbemClassObject*	pObj = NULL;
		IWbemObjectAccess*	pAccess = NULL;
		long lID;

		// Set the object path (e.g. Win32_BasicHiPerf=1)
		// ==============================================

		swprintf( wcsObjName, L"%s=%i", wcsClass, lIndex );
	
		// Add the object
		// ==============
		hr = m_pConfig->AddObjectByPath( m_pNameSpace, wcsObjName, 0, NULL, &pObj, &lID );
		if ( SUCCEEDED( hr ) )
		{

    		// Save the IWbemObjectAccess interface
	    	// ====================================
		    hr = pObj->QueryInterface( IID_IWbemObjectAccess, (void**) &pAccess );
            SAFE_RELEASE_PTR(pObj);
    		m_Instances[lIndex].Set(pAccess, lID);

	    	// Set does it's own AddRef()
		    // ==========================
            SAFE_RELEASE_PTR(pAccess);
    	}
    }
	
	return hr;
}
///////////////////////////////////////////////////////////////////
//
//	RemoveObjects calls Remove() on the refresher's configuration 
//	manager to remove all of the objects from the refresher.
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
HRESULT CRefresher::RemoveObjects()
{
	HRESULT hr = WBEM_NO_ERROR;

	long lInstance = 0;

	// Remove the instances
	// ====================

	for ( lInstance = 0; lInstance < clNumInstances; lInstance++ )
	{
		m_pConfig->Remove( m_Instances[lInstance].GetID(), 0L );

		m_Instances[lInstance].Reset();
	}

	return hr;
}
///////////////////////////////////////////////////////////////////
//
//	ShowInstanceData will output all of the counter data for all
//	of the instances within the refresher.
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
HRESULT CRefresher::EnumerateObjectData()
{
	HRESULT hr = WBEM_NO_ERROR;

	long lInstance;
	long lCounter;

// Cycle through all of the instances and print all the counter data
// =================================================================

	// Instance loop
	// =============

	for (lInstance = 0; lInstance < clNumInstances; lInstance++)
	{
		// Counter loop
		// ============

		for (lCounter = Ctr1; lCounter < NumCtrs; lCounter++)
		{
			DWORD dwVal;
			IWbemObjectAccess* pAccess = m_Instances[lInstance].GetMember();

			// Read the counter property value using the high performance IWbemObjectAccess->ReadDWORD().
			// NOTE: Remember to never to this while a refresh is in process!
			// ==========================================================================================

			hr = pAccess->ReadDWORD( g_aCounters[lCounter].m_lHandle, &dwVal);
			if (FAILED(hr))
			{
                break;
			}
			SAFE_RELEASE_PTR(pAccess);
		}
	}
	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	AddEnum will add an enumerator to the refresher.  The 
//	function will return a status code.  The enumerator class member 
//	will updated.
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
HRESULT CRefresher::AddEnum(WCHAR * wcsClass)
{
	HRESULT hr = WBEM_NO_ERROR;

	IWbemHiPerfEnum*	pEnum = NULL;
	long lID;

// Add an enumerator to the refresher
// ==================================

	hr = m_pConfig->AddEnum( m_pNameSpace,wcsClass, 0, NULL, &pEnum, &lID );

	m_Enum.Set(pEnum, lID);

	// Set does it's own AddRef
	// ========================
	SAFE_RELEASE_PTR(pEnum);
	return hr;
}

///////////////////////////////////////////////////////////////////
//
//	RemoveEnum calls Remove() on the refresher's configuration 
//	manager to remove the enumerator from the refresher.
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
HRESULT CRefresher::RemoveEnum()
{
	HRESULT hr = WBEM_NO_ERROR;

	// Remove the enumerator
	// =====================

	hr = m_pConfig->Remove( m_Enum.GetID(), 0L );

	m_Enum.Reset();

	return hr;
}
///////////////////////////////////////////////////////////////////
//
//	ShowEnumeratorData will output the number of instances within 
//	an enumerator.  Property values from the instances may obtained
//	using the standard WMI methods.
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
HRESULT CRefresher::EnumerateEnumeratorData()
{
	HRESULT hr = WBEM_NO_ERROR;

	DWORD	dwNumReturned = clNumInstances;
	DWORD	dwNumObjects = 0;

	IWbemObjectAccess**	apEnumAccess = NULL;

	IWbemHiPerfEnum*	pEnum = m_Enum.GetMember();

    // Fetch the instances from the enumerator
    // =======================================
	// Try to get the instances from the enumerator
	// ============================================
	hr = pEnum->GetObjects( 0L, dwNumObjects, apEnumAccess, &dwNumReturned );

	// Is the buffer too small?
	// ========================

	if ( WBEM_E_BUFFER_TOO_SMALL == hr )
	{
		// Increase the buffer size
		// ========================

		delete [] apEnumAccess;

		apEnumAccess = new IWbemObjectAccess*[dwNumReturned];
		dwNumObjects = dwNumReturned; 
		memset( apEnumAccess, 0, sizeof( apEnumAccess ));

		if ( NULL != apEnumAccess )
		{
			hr = pEnum->GetObjects( 0L, dwNumObjects, apEnumAccess, &dwNumReturned );
		}
		else
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}	


	// Release the objects from the enumerator's object array
	// ======================================================
	
	for ( DWORD nCtr = 0; nCtr < dwNumReturned; nCtr++ )
	{
		if (NULL != apEnumAccess[nCtr])
		{
			apEnumAccess[nCtr]->Release();
			apEnumAccess[nCtr] = NULL;
		}
	}

	if ( NULL != apEnumAccess )
		delete [] apEnumAccess;

	pEnum->Release();

	return hr;
}

HRESULT CRefresher::Refresh()
///////////////////////////////////////////////////////////////////
//
//	Refresh simply calls the IWbemRefresher->Refresh() method to 
//	update all members of the refresher.
//
//	Returns a status code. Use the SUCCEEDED() and FAILED() macros
//	to interpret results.
//
///////////////////////////////////////////////////////////////////
{
	return m_pRefresher->Refresh( 0L );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtscript.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTReposit.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "bvt.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 1001
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ExecuteScript(int nTest)
{
    int nRc = FATAL_ERROR;
    CHString sScript;
    CHString sNamespace;

    if( g_Options.GetSpecificOptionForAPITest(L"NAMESPACE",sNamespace, 1000) )
    {
        gp_LogFile->LogError( __FILE__, __LINE__ ,SUCCESS, L"Executing script: %s for namespace: %s", sScript,sNamespace);
    
        if( sScript = sNamespace)
        {
            nRc = _wsystem(sScript);
            if( nRc != SUCCESS )
            {
                 gp_LogFile->LogError( __FILE__, __LINE__ ,FATAL_ERROR, L"Executing script failed: %s for namespace: %s", sScript, sNamespace);
            }
        }
        else
        {
            gp_LogFile->LogError( __FILE__, __LINE__ ,FATAL_ERROR, L"Couldn't build command line for script: %s for namespace: %s", sScript, sNamespace);
        }
    }
    return nRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\bvt\whistler\bvtapilib\bvt.h ===
/////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _BVT_HEADER
#define _BVT_HEADER

/////////////////////////////////////////////////////////////////////////////////////////////
//***********************************