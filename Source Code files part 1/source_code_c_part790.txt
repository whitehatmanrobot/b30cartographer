PMSGW)(void);
    // like 'AFX_PMSG' but for CWnd derived classes only

typedef void (AFX_MSG_CALL CWinThread::*AFX_PMSGT)(void);
    // like 'AFX_PMSG' but for CWinThread-derived classes only

/////////////////////////////////////////////////////////////////////////////
// CDialog - a modal or modeless dialog

class CDialog : public CWnd
{
    DECLARE_DYNAMIC(CDialog)

    // Modeless construct
public:
    CDialog();

    BOOL Create(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
    BOOL Create(UINT nIDTemplate, CWnd* pParentWnd = NULL);
    BOOL CreateIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd = NULL,
            void* lpDialogInit = NULL);
    BOOL CreateIndirect(HGLOBAL hDialogTemplate, CWnd* pParentWnd = NULL);

    // Modal construct
public:
    CDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
    CDialog(UINT nIDTemplate, CWnd* pParentWnd = NULL);
    BOOL InitModalIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd = NULL,
            void* lpDialogInit = NULL);
    BOOL InitModalIndirect(HGLOBAL hDialogTemplate, CWnd* pParentWnd = NULL);

// Attributes
public:
    void MapDialogRect(LPRECT lpRect) const;
    void SetHelpID(UINT nIDR);

// Operations
public:
    // modal processing
    virtual INT_PTR DoModal();

    // support for passing on tab control - use 'PostMessage' if needed
    void NextDlgCtrl() const;
    void PrevDlgCtrl() const;
    void GotoDlgCtrl(CWnd* pWndCtrl);

    // default button access
    void SetDefID(UINT nID);
    DWORD GetDefID() const;

    // termination
    void EndDialog(int nResult);

// Overridables (special message map entries)
    virtual BOOL OnInitDialog();
    virtual void OnSetFont(CFont* pFont);
protected:
    virtual void OnOK();
    virtual void OnCancel();

// Implementation
public:
    virtual ~CDialog();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
            AFX_CMDHANDLERINFO* pHandlerInfo);
    virtual BOOL CheckAutoCenter();

protected:
    UINT m_nIDHelp;                 // Help ID (0 for none, see HID_BASE_RESOURCE)

    // parameters for 'DoModal'
    LPCTSTR m_lpszTemplateName;     // name or MAKEINTRESOURCE
    HGLOBAL m_hDialogTemplate;      // indirect (m_lpDialogTemplate == NULL)
    LPCDLGTEMPLATE m_lpDialogTemplate;  // indirect if (m_lpszTemplateName == NULL)
    void* m_lpDialogInit;           // DLGINIT resource data
    CWnd* m_pParentWnd;             // parent/owner window
    HWND m_hWndTop;                 // top level parent window (may be disabled)

#ifndef _AFX_NO_OCC_SUPPORT
    _AFX_OCC_DIALOG_INFO* m_pOccDialogInfo;
    virtual BOOL SetOccDialogInfo(_AFX_OCC_DIALOG_INFO* pOccDialogInfo);
#endif
    virtual void PreInitDialog();

    // implementation helpers
    HWND PreModal();
    void PostModal();

    BOOL CreateIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd,
            void* lpDialogInit, HINSTANCE hInst);
    BOOL CreateIndirect(HGLOBAL hDialogTemplate, CWnd* pParentWnd,
            HINSTANCE hInst);

protected:
    //{{AFX_MSG(CDialog)
    afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT HandleInitDialog(WPARAM, LPARAM);
    afx_msg LRESULT HandleSetFont(WPARAM, LPARAM);
    //}}AFX_MSG
#ifndef _AFX_NO_GRAYDLG_SUPPORT
    afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
#endif
    DECLARE_MESSAGE_MAP()
};

// all CModalDialog functionality is now in CDialog
#define CModalDialog    CDialog

/////////////////////////////////////////////////////////////////////////////
// Standard Windows controls

class CStatic : public CWnd
{
    DECLARE_DYNAMIC(CStatic)

// Constructors
public:
    CStatic();
    BOOL Create(LPCTSTR lpszText, DWORD dwStyle,
                            const RECT& rect, CWnd* pParentWnd, UINT nID = 0xffff);

// Operations
    HICON SetIcon(HICON hIcon);
    HICON GetIcon() const;

#if (WINVER >= 0x400)
    HENHMETAFILE SetEnhMetaFile(HENHMETAFILE hMetaFile);
    HENHMETAFILE GetEnhMetaFile() const;
    HBITMAP SetBitmap(HBITMAP hBitmap);
    HBITMAP GetBitmap() const;
    HCURSOR SetCursor(HCURSOR hCursor);
    HCURSOR GetCursor();
#endif

// Implementation
public:
    virtual ~CStatic();
};

class CButton : public CWnd
{
    DECLARE_DYNAMIC(CButton)

// Constructors
public:
    CButton();
    BOOL Create(LPCTSTR lpszCaption, DWORD dwStyle,
                            const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
    UINT GetState() const;
    void SetState(BOOL bHighlight);
    int GetCheck() const;
    void SetCheck(int nCheck);
    UINT GetButtonStyle() const;
    void SetButtonStyle(UINT nStyle, BOOL bRedraw = TRUE);

#if (WINVER >= 0x400)
    HICON SetIcon(HICON hIcon);
    HICON GetIcon() const;
    HBITMAP SetBitmap(HBITMAP hBitmap);
    HBITMAP GetBitmap() const;
    HCURSOR SetCursor(HCURSOR hCursor);
    HCURSOR GetCursor();
#endif

// Overridables (for owner draw only)
    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
    virtual ~CButton();
protected:
    virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

class CListBox : public CWnd
{
    DECLARE_DYNAMIC(CListBox)

// Constructors
public:
    CListBox();
    BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes

    // for entire listbox
    int GetCount() const;
    int GetHorizontalExtent() const;
    void SetHorizontalExtent(int cxExtent);
    int GetTopIndex() const;
    int SetTopIndex(int nIndex);
    LCID GetLocale() const;
    LCID SetLocale(LCID nNewLocale);
#if (WINVER >= 0x400)
    int InitStorage(int nItems, UINT nBytes);
    UINT ItemFromPoint(CPoint pt, BOOL& bOutside) const;
#endif
    // for single-selection listboxes
    int GetCurSel() const;
    int SetCurSel(int nSelect);

    // for multiple-selection listboxes
    int GetSel(int nIndex) const;           // also works for single-selection
    int SetSel(int nIndex, BOOL bSelect = TRUE);
    int GetSelCount() const;
    int GetSelItems(int nMaxItems, LPINT rgIndex) const;
    void SetAnchorIndex(int nIndex);
    int GetAnchorIndex() const;

    // for listbox items
    DWORD_PTR GetItemData(int nIndex) const;
    int SetItemData(int nIndex, DWORD_PTR dwItemData);
    void* GetItemDataPtr(int nIndex) const;
    int SetItemDataPtr(int nIndex, void* pData);
    int GetItemRect(int nIndex, LPRECT lpRect) const;
    int GetText(int nIndex, LPTSTR lpszBuffer) const;
    void GetText(int nIndex, CString& rString) const;
    int GetTextLen(int nIndex) const;

    // Settable only attributes
    void SetColumnWidth(int cxWidth);
    BOOL SetTabStops(int nTabStops, LPINT rgTabStops);
    void SetTabStops();
    BOOL SetTabStops(const int& cxEachStop);    // takes an 'int'

    int SetItemHeight(int nIndex, UINT cyItemHeight);
    int GetItemHeight(int nIndex) const;
    int FindStringExact(int nIndexStart, LPCTSTR lpszFind) const;
    int GetCaretIndex() const;
    int SetCaretIndex(int nIndex, BOOL bScroll = TRUE);

// Operations
    // manipulating listbox items
    int AddString(LPCTSTR lpszItem);
    int DeleteString(UINT nIndex);
    int InsertString(int nIndex, LPCTSTR lpszItem);
    void ResetContent();
    int Dir(UINT attr, LPCTSTR lpszWildCard);

    // selection helpers
    int FindString(int nStartAfter, LPCTSTR lpszItem) const;
    int SelectString(int nStartAfter, LPCTSTR lpszItem);
    int SelItemRange(BOOL bSelect, int nFirstItem, int nLastItem);

// Overridables (must override draw, measure and compare for owner draw)
    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
    virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
    virtual void DeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct);
    virtual int VKeyToItem(UINT nKey, UINT nIndex);
    virtual int CharToItem(UINT nKey, UINT nIndex);

// Implementation
public:
    virtual ~CListBox();
protected:
    virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

class CCheckListBox : public CListBox
{
    DECLARE_DYNAMIC(CCheckListBox)

// Constructors
public:
    CCheckListBox();
    BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
    void SetCheckStyle(UINT nStyle);
    UINT GetCheckStyle();
    void SetCheck(int nIndex, int nCheck);
    int GetCheck(int nIndex);
    void Enable(int nIndex, BOOL bEnabled = TRUE);
    BOOL IsEnabled(int nIndex);

    virtual CRect OnGetCheckPosition(CRect rectItem, CRect rectCheckBox);

// Overridables (must override draw, measure and compare for owner draw)
    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
    virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);

// Implementation
protected:
    void PreDrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
    void PreMeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    int PreCompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
    void PreDeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct);

    virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);

#if _MFC_VER >= 0x0600
    void SetSelectionCheck( int nCheck );
#endif

#ifdef _DEBUG
    virtual void PreSubclassWindow();
#endif

    int CalcMinimumItemHeight();
    void InvalidateCheck(int nIndex);
    void InvalidateItem(int nIndex);
    int CheckFromPoint(CPoint point, BOOL& bInCheck);

    int m_cyText;
    UINT m_nStyle;

    // Message map functions
protected:
    //{{AFX_MSG(CCheckListBox)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
    afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBAddString(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBFindString(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBFindStringExact(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBGetItemData(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBGetText(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBInsertString(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBSelectString(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBSetItemData(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnLBSetItemHeight(WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

class CComboBox : public CWnd
{
    DECLARE_DYNAMIC(CComboBox)

// Constructors
public:
    CComboBox();
    BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
    // for entire combo box
    int GetCount() const;
    int GetCurSel() const;
    int SetCurSel(int nSelect);
    LCID GetLocale() const;
    LCID SetLocale(LCID nNewLocale);
// Win4
    int GetTopIndex() const;
    int SetTopIndex(int nIndex);
    int InitStorage(int nItems, UINT nBytes);
    void SetHorizontalExtent(UINT nExtent);
    UINT GetHorizontalExtent() const;
    int SetDroppedWidth(UINT nWidth);
    int GetDroppedWidth() const;

    // for edit control
    DWORD GetEditSel() const;
    BOOL LimitText(int nMaxChars);
    BOOL SetEditSel(int nStartChar, int nEndChar);

    // for combobox item
    DWORD_PTR GetItemData(int nIndex) const;
    int SetItemData(int nIndex, DWORD_PTR dwItemData);
    void* GetItemDataPtr(int nIndex) const;
    int SetItemDataPtr(int nIndex, void* pData);
    int GetLBText(int nIndex, LPTSTR lpszText) const;
    void GetLBText(int nIndex, CString& rString) const;
    int GetLBTextLen(int nIndex) const;

    int SetItemHeight(int nIndex, UINT cyItemHeight);
    int GetItemHeight(int nIndex) const;
    int FindStringExact(int nIndexStart, LPCTSTR lpszFind) const;
    int SetExtendedUI(BOOL bExtended = TRUE);
    BOOL GetExtendedUI() const;
    void GetDroppedControlRect(LPRECT lprect) const;
    BOOL GetDroppedState() const;

// Operations
    // for drop-down combo boxes
    void ShowDropDown(BOOL bShowIt = TRUE);

    // manipulating listbox items
    int AddString(LPCTSTR lpszString);
    int DeleteString(UINT nIndex);
    int InsertString(int nIndex, LPCTSTR lpszString);
    void ResetContent();
    int Dir(UINT attr, LPCTSTR lpszWildCard);

    // selection helpers
    int FindString(int nStartAfter, LPCTSTR lpszString) const;
    int SelectString(int nStartAfter, LPCTSTR lpszString);

    // Clipboard operations
    void Clear();
    void Copy();
    void Cut();
    void Paste();

// Overridables (must override draw, measure and compare for owner draw)
    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
    virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
    virtual void DeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct);

// Implementation
public:
    virtual ~CComboBox();
protected:
    virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

class CEdit : public CWnd
{
    DECLARE_DYNAMIC(CEdit)

// Constructors
public:
    CEdit();
    BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
    BOOL CanUndo() const;
    int GetLineCount() const;
    BOOL GetModify() const;
    void SetModify(BOOL bModified = TRUE);
    void GetRect(LPRECT lpRect) const;
    DWORD GetSel() const;
    void GetSel(int& nStartChar, int& nEndChar) const;
    HLOCAL GetHandle() const;
    void SetHandle(HLOCAL hBuffer);
#if (WINVER >= 0x400)
    void SetMargins(UINT nLeft, UINT nRight);
    DWORD GetMargins() const;
    void SetLimitText(UINT nMax);
    UINT GetLimitText() const;
    CPoint PosFromChar(UINT nChar) const;
    int CharFromPos(CPoint pt) const;
#endif

    // NOTE: first word in lpszBuffer must contain the size of the buffer!
    int GetLine(int nIndex, LPTSTR lpszBuffer) const;
    int GetLine(int nIndex, LPTSTR lpszBuffer, int nMaxLength) const;

// Operations
    void EmptyUndoBuffer();
    BOOL FmtLines(BOOL bAddEOL);

    void LimitText(int nChars = 0);
    int LineFromChar(int nIndex = -1) const;
    int LineIndex(int nLine = -1) const;
    int LineLength(int nLine = -1) const;
    void LineScroll(int nLines, int nChars = 0);
    void ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE);
    void SetPasswordChar(TCHAR ch);
    void SetRect(LPCRECT lpRect);
    void SetRectNP(LPCRECT lpRect);
    void SetSel(DWORD dwSelection, BOOL bNoScroll = FALSE);
    void SetSel(int nStartChar, int nEndChar, BOOL bNoScroll = FALSE);
    BOOL SetTabStops(int nTabStops, LPINT rgTabStops);
    void SetTabStops();
    BOOL SetTabStops(const int& cxEachStop);    // takes an 'int'

    // Clipboard operations
    BOOL Undo();
    void Clear();
    void Copy();
    void Cut();
    void Paste();

    BOOL SetReadOnly(BOOL bReadOnly = TRUE);
    int GetFirstVisibleLine() const;
    TCHAR GetPasswordChar() const;

// Implementation
public:
    virtual ~CEdit();
};

class CScrollBar : public CWnd
{
    DECLARE_DYNAMIC(CScrollBar)

// Constructors
public:
    CScrollBar();
    BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
    int GetScrollPos() const;
    int SetScrollPos(int nPos, BOOL bRedraw = TRUE);
    void GetScrollRange(LPINT lpMinPos, LPINT lpMaxPos) const;
    void SetScrollRange(int nMinPos, int nMaxPos, BOOL bRedraw = TRUE);
    void ShowScrollBar(BOOL bShow = TRUE);

    BOOL EnableScrollBar(UINT nArrowFlags = ESB_ENABLE_BOTH);

    BOOL SetScrollInfo(LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE);
    BOOL GetScrollInfo(LPSCROLLINFO lpScrollInfo, UINT nMask = SIF_ALL);
    int GetScrollLimit();

// Implementation
public:
    virtual ~CScrollBar();
};

/////////////////////////////////////////////////////////////////////////////
// CFrameWnd - base class for SDI and other frame windows

// Frame window styles
#define FWS_ADDTOTITLE  0x00008000L // modify title based on content
#define FWS_PREFIXTITLE 0x00004000L // show document name before app name
#define FWS_SNAPTOBARS  0x00002000L // snap size to size of contained bars

struct CPrintPreviewState;  // forward reference (see afxext.h)
class CControlBar;          // forward reference (see afxext.h)
#if _MFC_VER >= 0x0600
class CReBar;				// forward reference (see afxext.h)
#endif

class CDockBar;             // forward reference (see afxpriv.h)
class CMiniDockFrameWnd;    // forward reference (see afxpriv.h)
class CDockState;           // forward reference (see afxpriv.h)

class COleFrameHook;        // forward reference (see ..\src\oleimpl2.h)

class CFrameWnd : public CWnd
{
    DECLARE_DYNCREATE(CFrameWnd)

// Constructors
public:
    static AFX_DATA const CRect rectDefault;
    CFrameWnd();

    BOOL LoadAccelTable(LPCTSTR lpszResourceName);
    BOOL Create(LPCTSTR lpszClassName,
                            LPCTSTR lpszWindowName,
                            DWORD dwStyle = WS_OVERLAPPEDWINDOW,
                            const RECT& rect = rectDefault,
                            CWnd* pParentWnd = NULL,        // != NULL for popups
                            LPCTSTR lpszMenuName = NULL,
                            DWORD dwExStyle = 0,
                            CCreateContext* pContext = NULL);

    // dynamic creation - load frame and associated resources
    virtual BOOL LoadFrame(UINT nIDResource,
                            DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE,
                            CWnd* pParentWnd = NULL,
                            CCreateContext* pContext = NULL);

    // special helper for view creation
    CWnd* CreateView(CCreateContext* pContext, UINT nID = AFX_IDW_PANE_FIRST);

// Attributes
    virtual CDocument* GetActiveDocument();

    // Active child view maintenance
    CView* GetActiveView() const;           // active view or NULL
    void SetActiveView(CView* pViewNew, BOOL bNotify = TRUE);
            // active view or NULL, bNotify == FALSE if focus should not be set

    // Active frame (for frames within frames -- MDI)
    virtual CFrameWnd* GetActiveFrame();

    // For customizing the default messages on the status bar
    virtual void GetMessageString(UINT nID, CString& rMessage) const;

    BOOL m_bAutoMenuEnable;
            // TRUE => menu items without handlers will be disabled

    BOOL IsTracking() const;

// Operations
    virtual void RecalcLayout(BOOL bNotify = TRUE);
    virtual void ActivateFrame(int nCmdShow = -1);
    void InitialUpdateFrame(CDocument* pDoc, BOOL bMakeVisible);
#if _MFC_VER >= 0x0600
	void SetTitle(LPCTSTR lpszTitle);
	CString GetTitle() const;
#endif

    // to set text of standard status bar
    void SetMessageText(LPCTSTR lpszText);
    void SetMessageText(UINT nID);

    // control bar docking
    void EnableDocking(DWORD dwDockStyle);
    void DockControlBar(CControlBar* pBar, UINT nDockBarID = 0,
            LPCRECT lpRect = NULL);
    void FloatControlBar(CControlBar* pBar, CPoint point,
            DWORD dwStyle = CBRS_ALIGN_TOP);
    CControlBar* GetControlBar(UINT nID);

    // frame window based modality
    virtual void BeginModalState();
    virtual void EndModalState();
    BOOL InModalState() const;
    void ShowOwnedWindows(BOOL bShow);

    // saving and loading control bar state
    void LoadBarState(LPCTSTR lpszProfileName);
    void SaveBarState(LPCTSTR lpszProfileName) const;
    void ShowControlBar(CControlBar* pBar, BOOL bShow, BOOL bDelay);
    void SetDockState(const CDockState& state);
    void GetDockState(CDockState& state) const;

// Overridables
    virtual void OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState);
    virtual CWnd* GetMessageBar();

    // border space negotiation
    enum BorderCmd
            { borderGet = 1, borderRequest = 2, borderSet = 3 };
    virtual BOOL NegotiateBorderSpace(UINT nBorderCmd, LPRECT lpRectBorder);

protected:
    virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);

// Command Handlers
public:
    afx_msg void OnContextHelp();   // for Shift+F1 help
    afx_msg void OnUpdateControlBarMenu(CCmdUI* pCmdUI);
    afx_msg BOOL OnBarCheck(UINT nID);

// Implementation
public:
    virtual ~CFrameWnd();
    int m_nWindow;  // general purpose window number - display as ":n"
                                    // -1 => unknown, 0 => only window viewing document
                                    // 1 => first of many windows viewing document, 2=> second

    HMENU m_hMenuDefault;       // default menu resource for this frame
    HACCEL m_hAccelTable;       // accelerator table
    DWORD m_dwPromptContext;    // current help prompt context for message box
    BOOL m_bHelpMode;           // if TRUE, then Shift+F1 help mode is active
    CFrameWnd* m_pNextFrameWnd; // next CFrameWnd in app global list
    CRect m_rectBorder;         // for OLE border space negotiation
    COleFrameHook* m_pNotifyHook;

    CPtrList m_listControlBars; // array of all control bars that have this
                                                            // window as their dock site
    int m_nShowDelay;           // SW_ command for delay show/hide

    CMiniDockFrameWnd* CreateFloatingFrame(DWORD dwStyle);
    DWORD CanDock(CRect rect, DWORD dwDockStyle,
            CDockBar** ppDockBar = NULL); // called by CDockContext
    void AddControlBar(CControlBar *pBar);
    void RemoveControlBar(CControlBar *pBar);
    void DockControlBar(CControlBar* pBar, CDockBar* pDockBar,
            LPCRECT lpRect = NULL);
    void ReDockControlBar(CControlBar* pBar, CDockBar* pDockBar,
            LPCRECT lpRect = NULL);
    void NotifyFloatingWindows(DWORD dwFlags);
    void DestroyDockBars();

protected:
    UINT m_nIDHelp;             // Help ID (0 for none, see HID_BASE_RESOURCE)
    UINT m_nIDTracking;         // tracking command ID or string IDS
    UINT m_nIDLastMessage;      // last displayed message string IDS
    CView* m_pViewActive;       // current active view
    BOOL (CALLBACK* m_lpfnCloseProc)(CFrameWnd* pFrameWnd);
    UINT m_cModalStack;         // BeginModalState depth
    HWND* m_phWndDisable;       // windows disabled because of BeginModalState
    HMENU m_hMenuAlt;           // menu to update to (NULL means default)
    CString m_strTitle;         // default title (original)
    BOOL m_bInRecalcLayout;     // avoid recursion in RecalcLayout
    CRuntimeClass* m_pFloatingFrameClass;
    static const DWORD dwDockBarMap[4][2];

public:
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
    virtual BOOL IsFrameWnd() const;
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
            AFX_CMDHANDLERINFO* pHandlerInfo);
    virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
    virtual void OnUpdateFrameMenu(HMENU hMenuAlt);
    virtual HACCEL GetDefaultAccelerator();
    virtual BOOL PreTranslateMessage(MSG* pMsg);

    // idle update of frame user interface
    enum IdleFlags
            { idleMenu = 1, idleTitle = 2, idleNotify = 4, idleLayout = 8 };
    UINT m_nIdleFlags;          // set of bit flags for idle processing
    virtual void DelayUpdateFrameMenu(HMENU hMenuAlt);
    void DelayUpdateFrameTitle();
    void DelayRecalcLayout(BOOL bNotify = TRUE);

    // for Shift+F1 help support
    BOOL CanEnterHelpMode();
    virtual void ExitHelpMode();

    // implementation helpers
#if _MFC_VER >= 0x0600
    void UpdateFrameTitleForDocument(LPCTSTR lpszDocName);
protected:
#else
protected:
    void UpdateFrameTitleForDocument(LPCTSTR lpszDocName);
#endif
    LPCTSTR GetIconWndClass(DWORD dwDefaultStyle, UINT nIDResource);
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    virtual void PostNcDestroy();   // default to delete this.
    int OnCreateHelper(LPCREATESTRUCT lpcs, CCreateContext* pContext);
    void BringToTop(int nCmdShow);
            // bring window to top for SW_ commands which affect z-order

    // implementation helpers for Shift+F1 help mode
    BOOL ProcessHelpMsg(MSG& msg, DWORD* pContext);
    HWND SetHelpCapture(POINT point, BOOL* pbDescendant);

    // CFrameWnd list management
    void AddFrameWnd();
    void RemoveFrameWnd();

    friend class CWnd;  // for access to m_bModalDisable
#if _MFC_VER >= 0x0600
	friend class CReBar; // for access to m_bInRecalcLayout
#endif

    //{{AFX_MSG(CFrameWnd)
    // Windows messages
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    afx_msg void OnClose();
#if _MFC_VER >= 0x0600
	afx_msg void OnInitMenu(CMenu*);
#endif
    afx_msg void OnInitMenuPopup(CMenu*, UINT, BOOL);
    afx_msg void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);
    afx_msg LRESULT OnPopMessageString(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnSetMessageString(WPARAM wParam, LPARAM lParam);
#if _MFC_VER >= 0x0600
	afx_msg LRESULT OnHelpPromptAddr(WPARAM wParam, LPARAM lParam);
#endif
    afx_msg void OnIdleUpdateCmdUI();
    afx_msg void OnEnterIdle(UINT nWhy, CWnd* pWho);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
    afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
    afx_msg BOOL OnNcActivate(BOOL bActive);
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg BOOL OnQueryEndSession();
    afx_msg void OnEndSession(BOOL bEnding);
    afx_msg void OnDropFiles(HDROP hDropInfo);
    afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
    afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnActivateTopLevel(WPARAM wParam, LPARAM lParam);
    afx_msg void OnEnable(BOOL bEnable);
    afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
    afx_msg BOOL OnQueryNewPalette();
    // standard commands
    afx_msg BOOL OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnUpdateKeyIndicator(CCmdUI* pCmdUI);
    afx_msg void OnHelp();
    afx_msg void OnUpdateContextHelp(CCmdUI* pCmdUI);
    //}}AFX_MSG
protected:
    afx_msg LRESULT OnDDEInitiate(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnDDEExecute(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnDDETerminate(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnRegisteredMouseWheel(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()

    friend class CWinApp;
};

/////////////////////////////////////////////////////////////////////////////
// MDI Support

class CMDIFrameWnd : public CFrameWnd
{
    DECLARE_DYNCREATE(CMDIFrameWnd)

public:
// Constructors
    CMDIFrameWnd();

// Operations
    void MDIActivate(CWnd* pWndActivate);
    CMDIChildWnd* MDIGetActive(BOOL* pbMaximized = NULL) const;
    void MDIIconArrange();
    void MDIMaximize(CWnd* pWnd);
    void MDINext();
    void MDIRestore(CWnd* pWnd);
    CMenu* MDISetMenu(CMenu* pFrameMenu, CMenu* pWindowMenu);
    void MDITile();
    void MDICascade();
    void MDITile(int nType);
    void MDICascade(int nType);
#if _MFC_VER >= 0x0600
	CMDIChildWnd* CreateNewChild(CRuntimeClass* pClass,	UINT nResource,
		HMENU hMenu = NULL, HACCEL hAccel = NULL);
#endif

// Overridables
    // MFC 1.0 backward compatible CreateClient hook (called by OnCreateClient)
    virtual BOOL CreateClient(LPCREATESTRUCT lpCreateStruct, CMenu* pWindowMenu);
    // customize if using an 'Window' menu with non-standard IDs
    virtual HMENU GetWindowMenuPopup(HMENU hMenuBar);

// Implementation
public:
    HWND m_hWndMDIClient;       // MDI Client window handle

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual BOOL LoadFrame(UINT nIDResource,
                            DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE,
                            CWnd* pParentWnd = NULL,
                            CCreateContext* pContext = NULL);
    virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
            AFX_CMDHANDLERINFO* pHandlerInfo);
    virtual void OnUpdateFrameMenu(HMENU hMenuAlt);
    virtual void DelayUpdateFrameMenu(HMENU hMenuAlt);
    virtual CFrameWnd* GetActiveFrame();

protected:
    virtual LRESULT DefWindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam);
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

    //{{AFX_MSG(CMDIFrameWnd)
    afx_msg void OnDestroy();
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnUpdateMDIWindowCmd(CCmdUI* pCmdUI);
    afx_msg BOOL OnMDIWindowCmd(UINT nID);
    afx_msg void OnWindowNew();
    afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
    afx_msg void OnIdleUpdateCmdUI();
    afx_msg LRESULT OnMenuChar(UINT nChar, UINT, CMenu*);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

class CMDIChildWnd : public CFrameWnd
{
    DECLARE_DYNCREATE(CMDIChildWnd)

// Constructors
public:
    CMDIChildWnd();

    virtual BOOL Create(LPCTSTR lpszClassName,
                            LPCTSTR lpszWindowName,
                            DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW,
                            const RECT& rect = rectDefault,
                            CMDIFrameWnd* pParentWnd = NULL,
                            CCreateContext* pContext = NULL);

// Attributes
    CMDIFrameWnd* GetMDIFrame();

// Operations
    void MDIDestroy();
    void MDIActivate();
    void MDIMaximize();
    void MDIRestore();
#if _MFC_VER >= 0x0600
	void SetHandles(HMENU hMenu, HACCEL hAccel);
#endif

// Implementation
protected:
    HMENU m_hMenuShared;        // menu when we are active

public:
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual BOOL LoadFrame(UINT nIDResource, DWORD dwDefaultStyle,
                                    CWnd* pParentWnd, CCreateContext* pContext = NULL);
            // 'pParentWnd' parameter is required for MDI Child
    virtual BOOL DestroyWindow();
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    virtual void ActivateFrame(int nCmdShow = -1);
    virtual void OnUpdateFrameMenu(BOOL bActive, CWnd* pActivateWnd,
            HMENU hMenuAlt);

    BOOL m_bPseudoInactive;     // TRUE if window is MDI active according to
                                                            //  windows, but not according to MFC...

protected:
    virtual CWnd* GetMessageBar();
    virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
    virtual LRESULT DefWindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam);
    BOOL UpdateClientEdge(LPRECT lpRect = NULL);

    //{{AFX_MSG(CMDIChildWnd)
    afx_msg void OnMDIActivate(BOOL bActivate, CWnd*, CWnd*);
    afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnWindowPosChanging(LPWINDOWPOS lpWndPos);
    afx_msg BOOL OnNcActivate(BOOL bActive);
    afx_msg void OnDestroy();
#if _MFC_VER >= 0x0600
	afx_msg BOOL OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult);
#endif
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CMiniFrameWnd

// MiniFrame window styles
#define MFS_SYNCACTIVE      0x00000100L // syncronize activation w/ parent
#define MFS_4THICKFRAME     0x00000200L // thick frame all around (no tiles)
#define MFS_THICKFRAME      0x00000400L // use instead of WS_THICKFRAME
#define MFS_MOVEFRAME       0x00000800L // no sizing, just moving
#define MFS_BLOCKSYSMENU    0x00001000L // block hit testing on system menu

class CMiniFrameWnd : public CFrameWnd
{
    DECLARE_DYNCREATE(CMiniFrameWnd)

// Constructors
public:
    CMiniFrameWnd();
    BOOL Create(LPCTSTR lpClassName, LPCTSTR lpWindowName,
            DWORD dwStyle, const RECT& rect,
            CWnd* pParentWnd = NULL, UINT nID = 0);
    BOOL CreateEx(DWORD dwExStyle, LPCTSTR lpClassName, LPCTSTR lpWindowName,
            DWORD dwStyle, const RECT& rect,
            CWnd* pParentWnd = NULL, UINT nID = 0);

// Implementation
public:
    ~CMiniFrameWnd();

    static void AFX_CDECL Initialize();

    //{{AFX_MSG(CMiniFrameWnd)
    afx_msg BOOL OnNcActivate(BOOL bActive);
    afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpParams);
    afx_msg UINT OnNcHitTest(CPoint point);
    afx_msg void OnNcPaint();
    afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint pt);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint pt);
    afx_msg void OnMouseMove(UINT nFlags, CPoint pt);
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnGetMinMaxInfo(MINMAXINFO* pMMI);
    afx_msg LRESULT OnGetText(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetTextLength(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnFloatStatus(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnQueryCenterWnd(WPARAM wParam, LPARAM lParam);
    afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpcs);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    virtual void CalcWindowRect(LPRECT lpClientRect,
            UINT nAdjustType = adjustBorder);

    static void PASCAL CalcBorders(LPRECT lpClientRect,
            DWORD dwStyle = WS_THICKFRAME | WS_CAPTION, DWORD dwExStyle = 0);

protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

protected:
    BOOL m_bSysTracking;
    BOOL m_bInSys;
    BOOL m_bActive;
    CString m_strCaption;

    void InvertSysMenu();
};

/////////////////////////////////////////////////////////////////////////////
// class CView is the client area UI for a document

class CPrintDialog;     // forward reference (see afxdlgs.h)
class CPreviewView;     // forward reference (see afxpriv.h)
class CSplitterWnd;     // forward reference (see afxext.h)
class COleServerDoc;    // forward reference (see afxole.h)

typedef DWORD DROPEFFECT;
class COleDataObject;   // forward reference (see afxole.h)

#ifdef _AFXDLL
class CView : public CWnd
#else
class AFX_NOVTABLE CView : public CWnd
#endif
{
    DECLARE_DYNAMIC(CView)

// Constructors
protected:
    CView();

// Attributes
public:
    CDocument* GetDocument() const;

// Operations
public:
    // for standard printing setup (override OnPreparePrinting)
    BOOL DoPreparePrinting(CPrintInfo* pInfo);

// Overridables
public:
    virtual BOOL IsSelected(const CObject* pDocItem) const; // support for OLE

    // OLE scrolling support (used for drag/drop as well)
    virtual BOOL OnScroll(UINT nScrollCode, UINT nPos, BOOL bDoScroll = TRUE);
    virtual BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll = TRUE);

    // OLE drag/drop support
    virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject,
            DWORD dwKeyState, CPoint point);
    virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject,
            DWORD dwKeyState, CPoint point);
    virtual void OnDragLeave();
    virtual BOOL OnDrop(COleDataObject* pDataObject,
            DROPEFFECT dropEffect, CPoint point);
    virtual DROPEFFECT OnDropEx(COleDataObject* pDataObject,
            DROPEFFECT dropDefault, DROPEFFECT dropList, CPoint point);
    virtual DROPEFFECT OnDragScroll(DWORD dwKeyState, CPoint point);

    virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = NULL);

    virtual void OnInitialUpdate(); // called first time after construct

protected:
    // Activation
    virtual void OnActivateView(BOOL bActivate, CView* pActivateView,
                                    CView* pDeactiveView);
    virtual void OnActivateFrame(UINT nState, CFrameWnd* pFrameWnd);

    // General drawing/updating
    virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
    virtual void OnDraw(CDC* pDC) = 0;

    // Printing support
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
            // must override to enable printing and print preview

    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

    // Advanced: end print preview mode, move to point
    virtual void OnEndPrintPreview(CDC* pDC, CPrintInfo* pInfo, POINT point,
            CPreviewView* pView);

// Implementation
public:
    virtual ~CView();
#ifdef _DEBUG
    virtual void Dump(CDumpContext&) const;
    virtual void AssertValid() const;
#endif //_DEBUG

    // Advanced: for implementing custom print preview
    BOOL DoPrintPreview(UINT nIDResource, CView* pPrintView,
                    CRuntimeClass* pPreviewViewClass, CPrintPreviewState* pState);

    virtual void CalcWindowRect(LPRECT lpClientRect,
            UINT nAdjustType = adjustBorder);
    virtual CScrollBar* GetScrollBarCtrl(int nBar) const;
    static CSplitterWnd* PASCAL GetParentSplitter(
            const CWnd* pWnd, BOOL bAnyState);

protected:
    CDocument* m_pDocument;

#if _MFC_VER >= 0x600
public:
#endif
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
            AFX_CMDHANDLERINFO* pHandlerInfo);
#if _MFC_VER >= 0x600
protected:
#endif
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void PostNcDestroy();

    // friend classes that call protected CView overridables
    friend class CDocument;
    friend class CDocTemplate;
    friend class CPreviewView;
    friend class CFrameWnd;
    friend class CMDIFrameWnd;
    friend class CMDIChildWnd;
    friend class CSplitterWnd;
    friend class COleServerDoc;
    friend class CDocObjectServer;

    //{{AFX_MSG(CView)
    afx_msg int OnCreate(LPCREATESTRUCT lpcs);
    afx_msg void OnDestroy();
    afx_msg void OnPaint();
    afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
    // commands
    afx_msg void OnUpdateSplitCmd(CCmdUI* pCmdUI);
    afx_msg BOOL OnSplitCmd(UINT nID);
    afx_msg void OnUpdateNextPaneMenu(CCmdUI* pCmdUI);
    afx_msg BOOL OnNextPaneCmd(UINT nID);

    // not mapped commands - must be mapped in derived class
    afx_msg void OnFilePrint();
    afx_msg void OnFilePrintPreview();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// class CCtrlView allows almost any control to be a view

#ifdef _AFXDLL
class CCtrlView : public CView
#else
class AFX_NOVTABLE CCtrlView : public CView
#endif
{
    DECLARE_DYNCREATE(CCtrlView)

public:
    CCtrlView(LPCTSTR lpszClass, DWORD dwStyle);

// Attributes
protected:
    CString m_strClass;
    DWORD m_dwDefaultStyle;

// Overrides
    virtual void OnDraw(CDC*);
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

// Implementation
public:
#ifdef _DEBUG
    virtual void Dump(CDumpContext&) const;
    virtual void AssertValid() const;
#endif //_DEBUG

protected:
    afx_msg void OnPaint();
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// class CScrollView supports simple scrolling and scaling

class CScrollView : public CView
{
    DECLARE_DYNAMIC(CScrollView)

// Constructors
protected:
    CScrollView();

public:
    static AFX_DATA const SIZE sizeDefault;
            // used to specify default calculated page and line sizes

    // in logical units - call one of the following Set routines
    void SetScaleToFitSize(SIZE sizeTotal);
    void SetScrollSizes(int nMapMode, SIZE sizeTotal,
                            const SIZE& sizePage = sizeDefault,
                            const SIZE& sizeLine = sizeDefault);

// Attributes
public:
    CPoint GetScrollPosition() const;       // upper corner of scrolling
    CSize GetTotalSize() const;             // logical size

    // for device units
    CPoint GetDeviceScrollPosition() const;
    void GetDeviceScrollSizes(int& nMapMode, SIZE& sizeTotal,
                    SIZE& sizePage, SIZE& sizeLine) const;

// Operations
public:
    void ScrollToPosition(POINT pt);    // set upper left position
    void FillOutsideRect(CDC* pDC, CBrush* pBrush);
    void ResizeParentToFit(BOOL bShrinkOnly = TRUE);
    BOOL DoMouseWheel(UINT fFlags, short zDelta, CPoint point);

// Implementation
protected:
    int m_nMapMode;
    CSize m_totalLog;           // total size in logical units (no rounding)
    CSize m_totalDev;           // total size in device units
    CSize m_pageDev;            // per page scroll size in device units
    CSize m_lineDev;            // per line scroll size in device units

    BOOL m_bCenter;             // Center output if larger than total size
    BOOL m_bInsideUpdate;       // internal state for OnSize callback
    void CenterOnPoint(CPoint ptCenter);
    void ScrollToDevicePosition(POINT ptDev); // explicit scrolling no checking

protected:
    virtual void OnDraw(CDC* pDC) = 0;      // pass on pure virtual

    void UpdateBars();          // adjust scrollbars etc
    BOOL GetTrueClientSize(CSize& size, CSize& sizeSb);
            // size with no bars
    void GetScrollBarSizes(CSize& sizeSb);
    void GetScrollBarState(CSize sizeClient, CSize& needSb,
            CSize& sizeRange, CPoint& ptMove, BOOL bInsideClient);

public:
    virtual ~CScrollView();
#ifdef _DEBUG
    virtual void Dump(CDumpContext&) const;
    virtual void AssertValid() const;
#endif //_DEBUG
    virtual void CalcWindowRect(LPRECT lpClientRect,
            UINT nAdjustType = adjustBorder);
    virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = NULL);

    // scrolling implementation support for OLE
    virtual BOOL OnScroll(UINT nScrollCode, UINT nPos, BOOL bDoScroll = TRUE);
    virtual BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll = TRUE);

    //{{AFX_MSG(CScrollView)
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
    afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
    afx_msg BOOL OnMouseWheel(UINT fFlags, short zDelta, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CWinThread

typedef UINT (AFX_CDECL *AFX_THREADPROC)(LPVOID);

class COleMessageFilter;        // forward reference (see afxole.h)

class CWinThread : public CCmdTarget
{
    DECLARE_DYNAMIC(CWinThread)

public:
// Constructors
    CWinThread();
    BOOL CreateThread(DWORD dwCreateFlags = 0, UINT nStackSize = 0,
            LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);

// Attributes
    CWnd* m_pMainWnd;       // main window (usually same AfxGetApp()->m_pMainWnd)
    CWnd* m_pActiveWnd;     // active main window (may not be m_pMainWnd)
    BOOL m_bAutoDelete;     // enables 'delete this' after thread termination

    // only valid while running
    HANDLE m_hThread;       // this thread's HANDLE
    operator HANDLE() const;
    DWORD m_nThreadID;      // this thread's ID

    int GetThreadPriority();
    BOOL SetThreadPriority(int nPriority);

// Operations
    DWORD SuspendThread();
    DWORD ResumeThread();
    BOOL PostThreadMessage(UINT message, WPARAM wParam, LPARAM lParam);

// Overridables
    // thread initialization
    virtual BOOL InitInstance();

    // running and idle processing
    virtual int Run();
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    virtual BOOL PumpMessage();     // low level message pump
    virtual BOOL OnIdle(LONG lCount); // return TRUE if more idle processing
    virtual BOOL IsIdleMessage(MSG* pMsg);  // checks for special messages

    // thread termination
    virtual int ExitInstance(); // default will 'delete this'

    // Advanced: exception handling
    virtual LRESULT ProcessWndProcException(CException* e, const MSG* pMsg);

    // Advanced: handling messages sent to message filter hook
    virtual BOOL ProcessMessageFilter(int code, LPMSG lpMsg);

    // Advanced: virtual access to m_pMainWnd
    virtual CWnd* GetMainWnd();

// Implementation
public:
    virtual ~CWinThread();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
    int m_nDisablePumpCount; // Diagnostic trap to detect illegal re-entrancy
#endif
    void CommonConstruct();
    virtual void Delete();
            // 'delete this' only if m_bAutoDelete == TRUE

    // message pump for Run
    MSG m_msgCur;                   // current message

public:
    // constructor used by implementation of AfxBeginThread
    CWinThread(AFX_THREADPROC pfnThreadProc, LPVOID pParam);

    // valid after construction
    LPVOID m_pThreadParams; // generic parameters passed to starting function
    AFX_THREADPROC m_pfnThreadProc;

    // set after OLE is initialized
    void (AFXAPI* m_lpfnOleTermOrFreeLib)(BOOL, BOOL);
    COleMessageFilter* m_pMessageFilter;

protected:
    CPoint m_ptCursorLast;      // last mouse position
    UINT m_nMsgLast;            // last mouse message
    BOOL DispatchThreadMessageEx(MSG* msg);  // helper
    void DispatchThreadMessage(MSG* msg);  // obsolete
};

// global helpers for threads

CWinThread* AFXAPI AfxBeginThread(AFX_THREADPROC pfnThreadProc, LPVOID pParam,
    int nPriority = THREAD_PRIORITY_NORMAL, UINT nStackSize = 0,
    DWORD dwCreateFlags = 0, LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);
CWinThread* AFXAPI AfxBeginThread(CRuntimeClass* pThreadClass,
    int nPriority = THREAD_PRIORITY_NORMAL, UINT nStackSize = 0,
    DWORD dwCreateFlags = 0, LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);

CWinThread* AFXAPI AfxGetThread();
void AFXAPI AfxEndThread(UINT nExitCode, BOOL bDelete = TRUE);

void AFXAPI AfxInitThread();
void AFXAPI AfxTermThread(HINSTANCE hInstTerm = NULL);

/////////////////////////////////////////////////////////////////////////////
// Global functions for access to the one and only CWinApp

#define afxCurrentWinApp    AfxGetModuleState()->m_pCurrentWinApp
#define afxCurrentInstanceHandle    AfxGetModuleState()->m_hCurrentInstanceHandle
#define afxCurrentResourceHandle    AfxGetModuleState()->m_hCurrentResourceHandle
#define afxCurrentAppName   AfxGetModuleState()->m_lpszCurrentAppName
#define afxContextIsDLL     AfxGetModuleState()->m_bDLL
#define afxRegisteredClasses    AfxGetModuleState()->m_fRegisteredClasses

#ifndef _AFX_NO_OCC_SUPPORT
#define afxOccManager   AfxGetModuleState()->m_pOccManager
#endif

// Advanced initialization: for overriding default WinMain
BOOL AFXAPI AfxWinInit(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    LPTSTR lpCmdLine, int nCmdShow);
void AFXAPI AfxWinTerm();

// Global Windows state data helper functions (inlines)
CWinApp* AFXAPI AfxGetApp();
CWnd* AFXAPI AfxGetMainWnd();
HINSTANCE AFXAPI AfxGetInstanceHandle();
HINSTANCE AFXAPI AfxGetResourceHandle();
void AFXAPI AfxSetResourceHandle(HINSTANCE hInstResource);
LPCTSTR AFXAPI AfxGetAppName();

// Use instead of PostQuitMessage in OLE server applications
void AFXAPI AfxPostQuitMessage(int nExitCode);

// Use AfxFindResourceHandle to find resource in chain of extension DLLs
#ifndef _AFXDLL
#define AfxFindResourceHandle(lpszResource, lpszType) AfxGetResourceHandle()
#else
HINSTANCE AFXAPI AfxFindResourceHandle(LPCTSTR lpszName, LPCTSTR lpszType);
#endif

#if _MFC_VER >= 0x0600
LONG AFXAPI AfxDelRegTreeHelper(HKEY hParentKey, const CString& strKeyName);
#endif

class CRecentFileList;          // forward reference (see afxpriv.h)

// access to message filter in CWinApp
COleMessageFilter* AFXAPI AfxOleGetMessageFilter();

/////////////////////////////////////////////////////////////////////////////
// CCommandLineInfo

class CCommandLineInfo : public CObject
{
public:
    // Sets default values
    CCommandLineInfo();

    //plain char* version on UNICODE for source-code backwards compatibility
    virtual void ParseParam(const TCHAR* pszParam, BOOL bFlag, BOOL bLast);
#ifdef _UNICODE
    virtual void ParseParam(const char* pszParam, BOOL bFlag, BOOL bLast);
#endif

    BOOL m_bShowSplash;
    BOOL m_bRunEmbedded;
    BOOL m_bRunAutomated;
    enum { FileNew, FileOpen, FilePrint, FilePrintTo, FileDDE,
            AppUnregister, FileNothing = -1 } m_nShellCommand;

    // not valid for FileNew
    CString m_strFileName;

    // valid only for FilePrintTo
    CString m_strPrinterName;
    CString m_strDriverName;
    CString m_strPortName;

    ~CCommandLineInfo();
// Implementation
protected:
    void ParseParamFlag(const char* pszParam);
    void ParseParamNotFlag(const TCHAR* pszParam);
#ifdef _UNICODE
    void ParseParamNotFlag(const char* pszParam);
#endif
    void ParseLast(BOOL bLast);
};

/////////////////////////////////////////////////////////////////////////////
// CDocManager

class CDocManager : public CObject
{
    DECLARE_DYNAMIC(CDocManager)
public:

// Constructor
    CDocManager();

    //Document functions
    virtual void AddDocTemplate(CDocTemplate* pTemplate);
    virtual POSITION GetFirstDocTemplatePosition() const;
    virtual CDocTemplate* GetNextDocTemplate(POSITION& pos) const;
    virtual void RegisterShellFileTypes(BOOL bCompat);
    void UnregisterShellFileTypes();
    virtual CDocument* OpenDocumentFile(LPCTSTR lpszFileName); // open named file
    virtual BOOL SaveAllModified(); // save before exit
    virtual void CloseAllDocuments(BOOL bEndSession); // close documents before exiting
    virtual int GetOpenDocumentCount();

    // helper for standard commdlg dialogs
    virtual BOOL DoPromptFileName(CString& fileName, UINT nIDSTitle,
                    DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate);

//Commands
    // Advanced: process async DDE request
    virtual BOOL OnDDECommand(LPTSTR lpszCommand);
    virtual void OnFileNew();
    virtual void OnFileOpen();

// Implementation
protected:
    CPtrList m_templateList;
#if _MFC_VER >= 0x0600
	int GetDocumentCount();	// helper to count number of total documents
#endif

public:
    static CPtrList* pStaticList;       // for static CDocTemplate objects
    static BOOL bStaticInit;            // TRUE during static initialization
    static CDocManager* pStaticDocManager;  // for static CDocTemplate objects

public:
    virtual ~CDocManager();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CWinApp - the root of all Windows applications

#if defined( _AFX_NO_CTL3D_SUPPORT )
#define Enable3dControls()
#define Enable3dControlsStatic()
#endif

#define _AFX_MRU_COUNT   4      // default support for 4 entries in file MRU
#define _AFX_MRU_MAX_COUNT 16   // currently allocated id range supports 16

class CWinApp : public CWinThread
{
    DECLARE_DYNAMIC(CWinApp)
public:

// Constructor
    CWinApp(LPCTSTR lpszAppName = NULL);     // app name defaults to EXE name

// Attributes
    // Startup args (do not change)
    HINSTANCE m_hInstance;
    HINSTANCE m_hPrevInstance;
    LPTSTR m_lpCmdLine;
    int m_nCmdShow;

    // Running args (can be changed in InitInstance)
    LPCTSTR m_pszAppName;  // human readable name
                                                            //  (from constructor or AFX_IDS_APP_TITLE)
    LPCTSTR m_pszRegistryKey;   // used for registry entries
    CDocManager* m_pDocManager;

    // Support for Shift+F1 help mode.
    BOOL m_bHelpMode;           // are we in Shift+F1 mode?

public:  // set in constructor to override default
    LPCTSTR m_pszExeName;       // executable name (no spaces)
    LPCTSTR m_pszHelpFilePath;  // default based on module path
    LPCTSTR m_pszProfileName;   // default based on app name

// Initialization Operations - should be done in InitInstance
protected:
    void LoadStdProfileSettings(UINT nMaxMRU = _AFX_MRU_COUNT); // load MRU file list and last preview state
    void EnableShellOpen();

#ifndef _AFX_NO_GRAYDLG_SUPPORT
    void SetDialogBkColor(COLORREF clrCtlBk = RGB(192, 192, 192),
                            COLORREF clrCtlText = RGB(0, 0, 0));
            // set dialog box and message box background color
#endif

    void SetRegistryKey(LPCTSTR lpszRegistryKey);
    void SetRegistryKey(UINT nIDRegistryKey);
            // enables app settings in registry instead of INI files
            //  (registry key is usually a "company name")

#if !defined( _AFX_NO_CTL3D_SUPPORT )
    BOOL Enable3dControls(); // use CTL3D32.DLL for 3D controls in dialogs
#ifndef _AFXDLL
    BOOL Enable3dControlsStatic();  // statically link CTL3D.LIB instead
#endif
#endif

    void RegisterShellFileTypes(BOOL bCompat=FALSE);
            // call after all doc templates are registered
    void RegisterShellFileTypesCompat();
            // for backwards compatibility
    void UnregisterShellFileTypes();

// Helper Operations - usually done in InitInstance
public:
    // Cursors
    HCURSOR LoadCursor(LPCTSTR lpszResourceName) const;
    HCURSOR LoadCursor(UINT nIDResource) const;
    HCURSOR LoadStandardCursor(LPCTSTR lpszCursorName) const; // for IDC_ values
    HCURSOR LoadOEMCursor(UINT nIDCursor) const;             // for OCR_ values

    // Icons
    HICON LoadIcon(LPCTSTR lpszResourceName) const;
    HICON LoadIcon(UINT nIDResource) const;
    HICON LoadStandardIcon(LPCTSTR lpszIconName) const;       // for IDI_ values
    HICON LoadOEMIcon(UINT nIDIcon) const;                   // for OIC_ values

    // Profile settings (to the app specific .INI file, or registry)
    UINT GetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nDefault);
    BOOL WriteProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nValue);
    CString GetProfileString(LPCTSTR lpszSection, LPCTSTR lpszEntry,
                            LPCTSTR lpszDefault = NULL);
    BOOL WriteProfileString(LPCTSTR lpszSection, LPCTSTR lpszEntry,
                            LPCTSTR lpszValue);
    BOOL GetProfileBinary(LPCTSTR lpszSection, LPCTSTR lpszEntry,
                            LPBYTE* ppData, UINT* pBytes);
    BOOL WriteProfileBinary(LPCTSTR lpszSection, LPCTSTR lpszEntry,
                            LPBYTE pData, UINT nBytes);

    BOOL Unregister();
    LONG DelRegTree(HKEY hParentKey, const CString& strKeyName);

// Running Operations - to be done on a running application
    // Dealing with document templates
    void AddDocTemplate(CDocTemplate* pTemplate);
    POSITION GetFirstDocTemplatePosition() const;
    CDocTemplate* GetNextDocTemplate(POSITION& pos) const;

    // Dealing with files
    virtual CDocument* OpenDocumentFile(LPCTSTR lpszFileName); // open named file
    virtual void AddToRecentFileList(LPCTSTR lpszPathName);  // add to MRU

    // Printer DC Setup routine, 'struct tagPD' is a PRINTDLG structure
    void SelectPrinter(HANDLE hDevNames, HANDLE hDevMode,
            BOOL bFreeOld = TRUE);
    BOOL CreatePrinterDC(CDC& dc);
#ifndef _UNICODE
    BOOL GetPrinterDeviceDefaults(struct tagPDA* pPrintDlg);
#else
    BOOL GetPrinterDeviceDefaults(struct tagPDW* pPrintDlg);
#endif

    // Command line parsing
    BOOL RunEmbedded();
    BOOL RunAutomated();
    void ParseCommandLine(CCommandLineInfo& rCmdInfo);
    BOOL ProcessShellCommand(CCommandLineInfo& rCmdInfo);

// Overridables
    // hooks for your initialization code
    virtual BOOL InitApplication();

    // exiting
    virtual BOOL SaveAllModified(); // save before exit
    void HideApplication();
    void CloseAllDocuments(BOOL bEndSession); // close documents before exiting

    // Advanced: to override message boxes and other hooks
    virtual int DoMessageBox(LPCTSTR lpszPrompt, UINT nType, UINT nIDPrompt);
    virtual void DoWaitCursor(int nCode); // 0 => restore, 1=> begin, -1=> end

    // Advanced: process async DDE request
    virtual BOOL OnDDECommand(LPTSTR lpszCommand);

    // Advanced: Help support
    virtual void WinHelp(DWORD_PTR dwData, UINT nCmd = HELP_CONTEXT);

// Command Handlers
protected:
    // map to the following for file new/open
    afx_msg void OnFileNew();
    afx_msg void OnFileOpen();

    // map to the following to enable print setup
    afx_msg void OnFilePrintSetup();

    // map to the following to enable help
    afx_msg void OnContextHelp();   // shift-F1
    afx_msg void OnHelp();          // F1 (uses current context)
    afx_msg void OnHelpIndex();     // ID_HELP_INDEX
    afx_msg void OnHelpFinder();    // ID_HELP_FINDER, ID_DEFAULT_HELP
    afx_msg void OnHelpUsing();     // ID_HELP_USING

// Implementation
protected:
    HGLOBAL m_hDevMode;             // printer Dev Mode
    HGLOBAL m_hDevNames;            // printer Device Names
    DWORD m_dwPromptContext;        // help context override for message box

    int m_nWaitCursorCount;         // for wait cursor (>0 => waiting)
    HCURSOR m_hcurWaitCursorRestore; // old cursor to restore after wait cursor

    CRecentFileList* m_pRecentFileList;

    void UpdatePrinterSelection(BOOL bForceDefaults);
    void SaveStdProfileSettings();  // save options to .INI file

public: // public for implementation access
    CCommandLineInfo* m_pCmdInfo;

    ATOM m_atomApp, m_atomSystemTopic;   // for DDE open
    UINT m_nNumPreviewPages;        // number of default printed pages

    size_t  m_nSafetyPoolSize;      // ideal size

    void (AFXAPI* m_lpfnDaoTerm)();

    void DevModeChange(LPTSTR lpDeviceName);
    void SetCurrentHandles();
    int GetOpenDocumentCount();

    // helpers for standard commdlg dialogs
    BOOL DoPromptFileName(CString& fileName, UINT nIDSTitle,
                    DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate);
    INT_PTR DoPrintDialog(CPrintDialog* pPD);

    void EnableModeless(BOOL bEnable); // to disable OLE in-place dialogs

    // overrides for implementation
    virtual BOOL InitInstance();
    virtual int ExitInstance(); // return app exit code
    virtual int Run();
    virtual BOOL OnIdle(LONG lCount); // return TRUE if more idle processing
    virtual LRESULT ProcessWndProcException(CException* e, const MSG* pMsg);

public:
    virtual ~CWinApp();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    // helpers for registration
    HKEY GetSectionKey(LPCTSTR lpszSection);
    HKEY GetAppRegistryKey();

protected:
    //{{AFX_MSG(CWinApp)
    afx_msg void OnAppExit();
    afx_msg void OnUpdateRecentFileMenu(CCmdUI* pCmdUI);
    afx_msg BOOL OnOpenRecentFile(UINT nID);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// class CWaitCursor

class CWaitCursor
{
// Construction/Destruction
public:
    CWaitCursor();
    ~CWaitCursor();

// Operations
public:
    void Restore();
};

/////////////////////////////////////////////////////////////////////////////
// class CDocTemplate creates documents

#ifdef _AFXDLL
class CDocTemplate : public CCmdTarget
#else
class AFX_NOVTABLE CDocTemplate : public CCmdTarget
#endif
{
    DECLARE_DYNAMIC(CDocTemplate)

// Constructors
protected:
    CDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
            CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass);

public:
    virtual void LoadTemplate();

// Attributes
public:
    // setup for OLE containers
    void SetContainerInfo(UINT nIDOleInPlaceContainer);

    // setup for OLE servers
    void SetServerInfo(UINT nIDOleEmbedding, UINT nIDOleInPlaceServer = 0,
            CRuntimeClass* pOleFrameClass = NULL, CRuntimeClass* pOleViewClass = NULL);

    // iterating over open documents
    virtual POSITION GetFirstDocPosition() const = 0;
    virtual CDocument* GetNextDoc(POSITION& rPos) const = 0;

// Operations
public:
    virtual void AddDocument(CDocument* pDoc);      // must override
    virtual void RemoveDocument(CDocument* pDoc);   // must override

    enum DocStringIndex
    {
            windowTitle,        // default window title
            docName,            // user visible name for default document
            fileNewName,        // user visible name for FileNew
            // for file based documents:
            filterName,         // user visible name for FileOpen
            filterExt,          // user visible extension for FileOpen
            // for file based documents with Shell open support:
            regFileTypeId,      // REGEDIT visible registered file type identifier
            regFileTypeName,    // Shell visible registered file type name
    };
    virtual BOOL GetDocString(CString& rString,
            enum DocStringIndex index) const; // get one of the info strings
    CFrameWnd* CreateOleFrame(CWnd* pParentWnd, CDocument* pDoc,
            BOOL bCreateView);

// Overridables
public:
    enum Confidence
    {
            noAttempt,
            maybeAttemptForeign,
            maybeAttemptNative,
            yesAttemptForeign,
            yesAttemptNative,
            yesAlreadyOpen
    };
    virtual Confidence MatchDocType(LPCTSTR lpszPathName,
                                    CDocument*& rpDocMatch);
    virtual CDocument* CreateNewDocument();
    virtual CFrameWnd* CreateNewFrame(CDocument* pDoc, CFrameWnd* pOther);
    virtual void InitialUpdateFrame(CFrameWnd* pFrame, CDocument* pDoc,
            BOOL bMakeVisible = TRUE);
    virtual BOOL SaveAllModified();     // for all documents
    virtual void CloseAllDocuments(BOOL bEndSession);
    virtual CDocument* OpenDocumentFile(
            LPCTSTR lpszPathName, BOOL bMakeVisible = TRUE) = 0;
                                    // open named file
                                    // if lpszPathName == NULL => create new file with this type
    virtual void SetDefaultTitle(CDocument* pDocument) = 0;

// Implementation
public:
    BOOL m_bAutoDelete;
    virtual ~CDocTemplate();

    // back pointer to OLE or other server (NULL if none or disabled)
    CObject* m_pAttachedFactory;

    // menu & accelerator resources for in-place container
    HMENU m_hMenuInPlace;
    HACCEL m_hAccelInPlace;

    // menu & accelerator resource for server editing embedding
    HMENU m_hMenuEmbedding;
    HACCEL m_hAccelEmbedding;

    // menu & accelerator resource for server editing in-place
    HMENU m_hMenuInPlaceServer;
    HACCEL m_hAccelInPlaceServer;

#ifdef _DEBUG
    virtual void Dump(CDumpContext&) const;
    virtual void AssertValid() const;
#endif
    virtual void OnIdle();             // for all documents
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
            AFX_CMDHANDLERINFO* pHandlerInfo);

protected:
    UINT m_nIDResource;                 // IDR_ for frame/menu/accel as well
    UINT m_nIDServerResource;           // IDR_ for OLE inplace frame/menu/accel
    UINT m_nIDEmbeddingResource;        // IDR_ for OLE open frame/menu/accel
    UINT m_nIDContainerResource;        // IDR_ for container frame/menu/accel

    CRuntimeClass* m_pDocClass;         // class for creating new documents
    CRuntimeClass* m_pFrameClass;       // class for creating new frames
    CRuntimeClass* m_pViewClass;        // class for creating new views
    CRuntimeClass* m_pOleFrameClass;    // class for creating in-place frame
    CRuntimeClass* m_pOleViewClass;     // class for creating in-place view

    CString m_strDocStrings;    // '\n' separated names
            // The document names sub-strings are represented as _one_ string:
            // windowTitle\ndocName\n ... (see DocStringIndex enum)
};

// SDI support (1 document only)
class CSingleDocTemplate : public CDocTemplate
{
    DECLARE_DYNAMIC(CSingleDocTemplate)

// Constructors
public:
    CSingleDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
            CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass);

// Implementation
public:
    virtual ~CSingleDocTemplate();
    virtual void AddDocument(CDocument* pDoc);
    virtual void RemoveDocument(CDocument* pDoc);
    virtual POSITION GetFirstDocPosition() const;
    virtual CDocument* GetNextDoc(POSITION& rPos) const;
    virtual CDocument* OpenDocumentFile(
            LPCTSTR lpszPathName, BOOL bMakeVisible = TRUE);
    virtual void SetDefaultTitle(CDocument* pDocument);

#ifdef _DEBUG
    virtual void Dump(CDumpContext&) const;
    virtual void AssertValid() const;
#endif //_DEBUG

protected:  // standard implementation
    CDocument* m_pOnlyDoc;
};

// MDI support (zero or more documents)
class CMultiDocTemplate : public CDocTemplate
{
    DECLARE_DYNAMIC(CMultiDocTemplate)

// Constructors
public:
    CMultiDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
            CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass);

// Implementation
public:
    // Menu and accel table for MDI Child windows of this type
    HMENU m_hMenuShared;
    HACCEL m_hAccelTable;

    virtual ~CMultiDocTemplate();
    virtual void LoadTemplate();
    virtual void AddDocument(CDocument* pDoc);
    virtual void RemoveDocument(CDocument* pDoc);
    virtual POSITION GetFirstDocPosition() const;
    virtual CDocument* GetNextDoc(POSITION& rPos) const;
    virtual CDocument* OpenDocumentFile(
            LPCTSTR lpszPathName, BOOL bMakeVisible = TRUE);
    virtual void SetDefaultTitle(CDocument* pDocument);

#ifdef _DEBUG
    virtual void Dump(CDumpContext&) const;
    virtual void AssertValid() const;
#endif //_DEBUG

protected:  // standard implementation
    CPtrList m_docList;          // open documents of this type
    UINT m_nUntitledCount;   // start at 0, for "Document1" title
};

/////////////////////////////////////////////////////////////////////////////
// class CDocument is the main document data abstraction

#ifdef _AFXDLL
class CDocument : public CCmdTarget
#else
class AFX_NOVTABLE CDocument : public CCmdTarget
#endif
{
    DECLARE_DYNAMIC(CDocument)

public:
// Constructors
    CDocument();

// Attributes
public:
    const CString& GetTitle() const;
    virtual void SetTitle(LPCTSTR lpszTitle);
    const CString& GetPathName() const;
    virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU = TRUE);

    CDocTemplate* GetDocTemplate() const;
    virtual BOOL IsModified();
    virtual void SetModifiedFlag(BOOL bModified = TRUE);

// Operations
    void AddView(CView* pView);
    void RemoveView(CView* pView);
    virtual POSITION GetFirstViewPosition() const;
    virtual CView* GetNextView(POSITION& rPosition) const;

    // Update Views (simple update - DAG only)
    void UpdateAllViews(CView* pSender, LPARAM lHint = 0L,
            CObject* pHint = NULL);

// Overridables
    // Special notifications
    virtual void OnChangedViewList(); // after Add or Remove view
    virtual void DeleteContents(); // delete doc items etc

    // File helpers
    virtual BOOL OnNewDocument();
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
    virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
    virtual void OnCloseDocument();
    virtual void ReportSaveLoadException(LPCTSTR lpszPathName,
                            CException* e, BOOL bSaving, UINT nIDPDefault);
    virtual CFile* GetFile(LPCTSTR lpszFileName, UINT nOpenFlags,
            CFileException* pError);
    virtual void ReleaseFile(CFile* pFile, BOOL bAbort);

    // advanced overridables, closing down frame/doc, etc.
    virtual BOOL CanCloseFrame(CFrameWnd* pFrame);
    virtual BOOL SaveModified(); // return TRUE if ok to continue
    virtual void PreCloseFrame(CFrameWnd* pFrame);

// Implementation
protected:
    // default implementation
    CString m_strTitle;
    CString m_strPathName;
    CDocTemplate* m_pDocTemplate;
    CPtrList m_viewList;                // list of views
    BOOL m_bModified;                   // changed since last saved

public:
    BOOL m_bAutoDelete;     // TRUE => delete document when no more views
    BOOL m_bEmbedded;       // TRUE => document is being created by OLE

#ifdef _DEBUG
    virtual void Dump(CDumpContext&) const;
    virtual void AssertValid() const;
#endif //_DEBUG
    virtual ~CDocument();

    // implementation helpers
    virtual BOOL DoSave(LPCTSTR lpszPathName, BOOL bReplace = TRUE);
    virtual BOOL DoFileSave();
    virtual void UpdateFrameCounts();
    void DisconnectViews();
    void SendInitialUpdate();

    // overridables for implementation
    virtual HMENU GetDefaultMenu(); // get menu depending on state
    virtual HACCEL GetDefaultAccelerator();
    virtual void OnIdle();
    virtual void OnFinalRelease();

    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
            AFX_CMDHANDLERINFO* pHandlerInfo);
    friend class CDocTemplate;

protected:
    // file menu commands
    //{{AFX_MSG(CDocument)
    afx_msg void OnFileClose();
    afx_msg void OnFileSave();
    afx_msg void OnFileSaveAs();
    //}}AFX_MSG
    // mail enabling
    afx_msg void OnFileSendMail();
    afx_msg void OnUpdateFileSendMail(CCmdUI* pCmdUI);
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// Extra diagnostic tracing options

#ifdef _DEBUG

extern AFX_DATA UINT afxTraceFlags;
enum AfxTraceFlags
{
    traceMultiApp = 1,      // multi-app debugging
    traceAppMsg = 2,        // main message pump trace (includes DDE)
    traceWinMsg = 4,        // Windows message tracing
    traceCmdRouting = 8,    // Windows command routing trace (set 4+8 for control notifications)
    traceOle = 16,          // special OLE callback trace
    traceDatabase = 32,     // special database trace
    traceInternet = 64      // special Internet client trace
};

#endif // _DEBUG

//////////////////////////////////////////////////////////////////////////////
// MessageBox helpers

void AFXAPI AfxFormatString1(CString& rString, UINT nIDS, LPCTSTR lpsz1);
void AFXAPI AfxFormatString2(CString& rString, UINT nIDS,
                            LPCTSTR lpsz1, LPCTSTR lpsz2);
int AFXAPI AfxMessageBox(LPCTSTR lpszText, UINT nType = MB_OK,
                            UINT nIDHelp = 0);
int AFXAPI AfxMessageBox(UINT nIDPrompt, UINT nType = MB_OK,
                            UINT nIDHelp = (UINT)-1);

// Implementation string helpers
void AFXAPI AfxFormatStrings(CString& rString, UINT nIDS,
                            LPCTSTR const* rglpsz, int nString);
void AFXAPI AfxFormatStrings(CString& rString, LPCTSTR lpszFormat,
                            LPCTSTR const* rglpsz, int nString);
BOOL AFXAPI AfxExtractSubString(CString& rString, LPCTSTR lpszFullString,
                            int iSubString, TCHAR chSep = '\n');

/////////////////////////////////////////////////////////////////////////////
// Special target variant APIs

#ifdef _AFXDLL
    #include <afxdll_.h>
#endif

// Windows Version compatibility (obsolete)
#define AfxEnableWin30Compatibility()
#define AfxEnableWin31Compatibility()
#define AfxEnableWin40Compatibility()

// Temporary map management (locks temp map on current thread)
void AFXAPI AfxLockTempMaps();
BOOL AFXAPI AfxUnlockTempMaps(BOOL bDeleteTemps = TRUE);

/////////////////////////////////////////////////////////////////////////////
// Special OLE related functions (see OLELOCK.CPP)

void AFXAPI AfxOleOnReleaseAllObjects();
BOOL AFXAPI AfxOleCanExitApp();
void AFXAPI AfxOleLockApp();
void AFXAPI AfxOleUnlockApp();

void AFXAPI AfxOleSetUserCtrl(BOOL bUserCtrl);
BOOL AFXAPI AfxOleGetUserCtrl();

#ifndef _AFX_NO_OCC_SUPPORT
BOOL AFXAPI AfxOleLockControl(REFCLSID clsid);
BOOL AFXAPI AfxOleUnlockControl(REFCLSID clsid);
BOOL AFXAPI AfxOleLockControl(LPCTSTR lpszProgID);
BOOL AFXAPI AfxOleUnlockControl(LPCTSTR lpszProgID);
void AFXAPI AfxOleUnlockAllControls();
#endif

/////////////////////////////////////////////////////////////////////////////
// Use version 1.0 of the RichEdit control

#define _RICHEDIT_VER 0x0100

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXWIN_INLINE AFX_INLINE
#include <afxwin1.inl>
#include <afxwin2.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

/////////////////////////////////////////////////////////////////////////////

#else //RC_INVOKED
#include <afxres.h>     // standard resource IDs
#endif //RC_INVOKED

#endif //__AFXWIN_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\mfc42\afxwin1.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXWIN.H (part 1)

#ifdef _AFXWIN_INLINE

// Global helper functions
_AFXWIN_INLINE CWinApp* AFXAPI AfxGetApp()
    { return afxCurrentWinApp; }
_AFXWIN_INLINE HINSTANCE AFXAPI AfxGetInstanceHandle()
    { ASSERT(afxCurrentInstanceHandle != NULL);
        return afxCurrentInstanceHandle; }
_AFXWIN_INLINE HINSTANCE AFXAPI AfxGetResourceHandle()
    { ASSERT(afxCurrentResourceHandle != NULL);
        return afxCurrentResourceHandle; }
_AFXWIN_INLINE void AFXAPI AfxSetResourceHandle(HINSTANCE hInstResource)
    { ASSERT(hInstResource != NULL); afxCurrentResourceHandle = hInstResource; }
_AFXWIN_INLINE LPCTSTR AFXAPI AfxGetAppName()
    { ASSERT(afxCurrentAppName != NULL); return afxCurrentAppName; }
_AFXWIN_INLINE COleMessageFilter* AFXAPI AfxOleGetMessageFilter()
    { ASSERT_VALID(AfxGetThread()); return AfxGetThread()->m_pMessageFilter; }
_AFXWIN_INLINE CWnd* AFXAPI AfxGetMainWnd()
    { CWinThread* pThread = AfxGetThread();
        return pThread != NULL ? pThread->GetMainWnd() : NULL; }

#ifdef _AFXDLL
// AFX_MAINTAIN_STATE functions
_AFXWIN_INLINE AFX_MAINTAIN_STATE::AFX_MAINTAIN_STATE(AFX_MODULE_STATE* pNewState)
    {  m_pPrevModuleState = AfxSetModuleState(pNewState); }

#if _MFC_VER >= 0x0600
// AFX_MAINTAIN_STATE2 functions
_AFXWIN_INLINE AFX_MAINTAIN_STATE2::~AFX_MAINTAIN_STATE2()
    {  m_pThreadState->m_pModuleState = m_pPrevModuleState; }
#endif
#endif

// CSize
_AFXWIN_INLINE CSize::CSize()
    { /* random filled */ }
_AFXWIN_INLINE CSize::CSize(int initCX, int initCY)
    { cx = initCX; cy = initCY; }
_AFXWIN_INLINE CSize::CSize(SIZE initSize)
    { *(SIZE*)this = initSize; }
_AFXWIN_INLINE CSize::CSize(POINT initPt)
    { *(POINT*)this = initPt; }
_AFXWIN_INLINE CSize::CSize(DWORD dwSize)
    {
        cx = (short)LOWORD(dwSize);
        cy = (short)HIWORD(dwSize);
    }
_AFXWIN_INLINE BOOL CSize::operator==(SIZE size) const
    { return (cx == size.cx && cy == size.cy); }
_AFXWIN_INLINE BOOL CSize::operator!=(SIZE size) const
    { return (cx != size.cx || cy != size.cy); }
_AFXWIN_INLINE void CSize::operator+=(SIZE size)
    { cx += size.cx; cy += size.cy; }
_AFXWIN_INLINE void CSize::operator-=(SIZE size)
    { cx -= size.cx; cy -= size.cy; }
_AFXWIN_INLINE CSize CSize::operator+(SIZE size) const
    { return CSize(cx + size.cx, cy + size.cy); }
_AFXWIN_INLINE CSize CSize::operator-(SIZE size) const
    { return CSize(cx - size.cx, cy - size.cy); }
_AFXWIN_INLINE CSize CSize::operator-() const
    { return CSize(-cx, -cy); }
_AFXWIN_INLINE CPoint CSize::operator+(POINT point) const
    { return CPoint(cx + point.x, cy + point.y); }
_AFXWIN_INLINE CPoint CSize::operator-(POINT point) const
    { return CPoint(cx - point.x, cy - point.y); }
_AFXWIN_INLINE CRect CSize::operator+(const RECT* lpRect) const
    { return CRect(lpRect) + *this; }
_AFXWIN_INLINE CRect CSize::operator-(const RECT* lpRect) const
    { return CRect(lpRect) - *this; }

// CPoint
_AFXWIN_INLINE CPoint::CPoint()
    { /* random filled */ }
_AFXWIN_INLINE CPoint::CPoint(int initX, int initY)
    { x = initX; y = initY; }
#if !defined(_AFX_CORE_IMPL) || !defined(_AFXDLL) || defined(_DEBUG)
_AFXWIN_INLINE CPoint::CPoint(POINT initPt)
    { *(POINT*)this = initPt; }
#endif
_AFXWIN_INLINE CPoint::CPoint(SIZE initSize)
    { *(SIZE*)this = initSize; }
_AFXWIN_INLINE CPoint::CPoint(DWORD dwPoint)
    {
        x = (short)LOWORD(dwPoint);
        y = (short)HIWORD(dwPoint);
    }
_AFXWIN_INLINE void CPoint::Offset(int xOffset, int yOffset)
    { x += xOffset; y += yOffset; }
_AFXWIN_INLINE void CPoint::Offset(POINT point)
    { x += point.x; y += point.y; }
_AFXWIN_INLINE void CPoint::Offset(SIZE size)
    { x += size.cx; y += size.cy; }
_AFXWIN_INLINE BOOL CPoint::operator==(POINT point) const
    { return (x == point.x && y == point.y); }
_AFXWIN_INLINE BOOL CPoint::operator!=(POINT point) const
    { return (x != point.x || y != point.y); }
_AFXWIN_INLINE void CPoint::operator+=(SIZE size)
    { x += size.cx; y += size.cy; }
_AFXWIN_INLINE void CPoint::operator-=(SIZE size)
    { x -= size.cx; y -= size.cy; }
_AFXWIN_INLINE void CPoint::operator+=(POINT point)
    { x += point.x; y += point.y; }
_AFXWIN_INLINE void CPoint::operator-=(POINT point)
    { x -= point.x; y -= point.y; }
_AFXWIN_INLINE CPoint CPoint::operator+(SIZE size) const
    { return CPoint(x + size.cx, y + size.cy); }
_AFXWIN_INLINE CPoint CPoint::operator-(SIZE size) const
    { return CPoint(x - size.cx, y - size.cy); }
_AFXWIN_INLINE CPoint CPoint::operator-() const
    { return CPoint(-x, -y); }
_AFXWIN_INLINE CPoint CPoint::operator+(POINT point) const
    { return CPoint(x + point.x, y + point.y); }
_AFXWIN_INLINE CSize CPoint::operator-(POINT point) const
    { return CSize(x - point.x, y - point.y); }
_AFXWIN_INLINE CRect CPoint::operator+(const RECT* lpRect) const
    { return CRect(lpRect) + *this; }
_AFXWIN_INLINE CRect CPoint::operator-(const RECT* lpRect) const
    { return CRect(lpRect) - *this; }

// CRect
_AFXWIN_INLINE CRect::CRect()
    { /* random filled */ }
_AFXWIN_INLINE CRect::CRect(int l, int t, int r, int b)
    { left = l; top = t; right = r; bottom = b; }
_AFXWIN_INLINE CRect::CRect(const RECT& srcRect)
    { ::CopyRect(this, &srcRect); }
_AFXWIN_INLINE CRect::CRect(LPCRECT lpSrcRect)
    { ::CopyRect(this, lpSrcRect); }
_AFXWIN_INLINE CRect::CRect(POINT point, SIZE size)
    { right = (left = point.x) + size.cx; bottom = (top = point.y) + size.cy; }
_AFXWIN_INLINE CRect::CRect(POINT topLeft, POINT bottomRight)
    { left = topLeft.x; top = topLeft.y;
        right = bottomRight.x; bottom = bottomRight.y; }
_AFXWIN_INLINE int CRect::Width() const
    { return right - left; }
_AFXWIN_INLINE int CRect::Height() const
    { return bottom - top; }
_AFXWIN_INLINE CSize CRect::Size() const
    { return CSize(right - left, bottom - top); }
_AFXWIN_INLINE CPoint& CRect::TopLeft()
    { return *((CPoint*)this); }
_AFXWIN_INLINE CPoint& CRect::BottomRight()
    { return *((CPoint*)this+1); }
_AFXWIN_INLINE const CPoint& CRect::TopLeft() const
    { return *((CPoint*)this); }
_AFXWIN_INLINE const CPoint& CRect::BottomRight() const
    { return *((CPoint*)this+1); }
_AFXWIN_INLINE CPoint CRect::CenterPoint() const
    { return CPoint((left+right)/2, (top+bottom)/2); }
_AFXWIN_INLINE void CRect::SwapLeftRight()
    { SwapLeftRight(LPRECT(this)); }
_AFXWIN_INLINE void CRect::SwapLeftRight(LPRECT lpRect)
    { LONG temp = lpRect->left; lpRect->left = lpRect->right; lpRect->right = temp; }
_AFXWIN_INLINE CRect::operator LPRECT()
    { return this; }
_AFXWIN_INLINE CRect::operator LPCRECT() const
    { return this; }
_AFXWIN_INLINE BOOL CRect::IsRectEmpty() const
    { return ::IsRectEmpty(this); }
_AFXWIN_INLINE BOOL CRect::IsRectNull() const
    { return (left == 0 && right == 0 && top == 0 && bottom == 0); }
_AFXWIN_INLINE BOOL CRect::PtInRect(POINT point) const
    { return ::PtInRect(this, point); }
_AFXWIN_INLINE void CRect::SetRect(int x1, int y1, int x2, int y2)
    { ::SetRect(this, x1, y1, x2, y2); }
_AFXWIN_INLINE void CRect::SetRect(POINT topLeft, POINT bottomRight)
    { ::SetRect(this, topLeft.x, topLeft.y, bottomRight.x, bottomRight.y); }
_AFXWIN_INLINE void CRect::SetRectEmpty()
    { ::SetRectEmpty(this); }
_AFXWIN_INLINE void CRect::CopyRect(LPCRECT lpSrcRect)
    { ::CopyRect(this, lpSrcRect); }
_AFXWIN_INLINE BOOL CRect::EqualRect(LPCRECT lpRect) const
    { return ::EqualRect(this, lpRect); }
_AFXWIN_INLINE void CRect::InflateRect(int x, int y)
    { ::InflateRect(this, x, y); }
_AFXWIN_INLINE void CRect::InflateRect(SIZE size)
    { ::InflateRect(this, size.cx, size.cy); }
_AFXWIN_INLINE void CRect::DeflateRect(int x, int y)
    { ::InflateRect(this, -x, -y); }
_AFXWIN_INLINE void CRect::DeflateRect(SIZE size)
    { ::InflateRect(this, -size.cx, -size.cy); }
_AFXWIN_INLINE void CRect::OffsetRect(int x, int y)
    { ::OffsetRect(this, x, y); }
_AFXWIN_INLINE void CRect::OffsetRect(POINT point)
    { ::OffsetRect(this, point.x, point.y); }
_AFXWIN_INLINE void CRect::OffsetRect(SIZE size)
    { ::OffsetRect(this, size.cx, size.cy); }
_AFXWIN_INLINE BOOL CRect::IntersectRect(LPCRECT lpRect1, LPCRECT lpRect2)
    { return ::IntersectRect(this, lpRect1, lpRect2);}
_AFXWIN_INLINE BOOL CRect::UnionRect(LPCRECT lpRect1, LPCRECT lpRect2)
    { return ::UnionRect(this, lpRect1, lpRect2); }
_AFXWIN_INLINE void CRect::operator=(const RECT& srcRect)
    { ::CopyRect(this, &srcRect); }
_AFXWIN_INLINE BOOL CRect::operator==(const RECT& rect) const
    { return ::EqualRect(this, &rect); }
_AFXWIN_INLINE BOOL CRect::operator!=(const RECT& rect) const
    { return !::EqualRect(this, &rect); }
_AFXWIN_INLINE void CRect::operator+=(POINT point)
    { ::OffsetRect(this, point.x, point.y); }
_AFXWIN_INLINE void CRect::operator+=(SIZE size)
    { ::OffsetRect(this, size.cx, size.cy); }
_AFXWIN_INLINE void CRect::operator+=(LPCRECT lpRect)
    { InflateRect(lpRect); }
_AFXWIN_INLINE void CRect::operator-=(POINT point)
    { ::OffsetRect(this, -point.x, -point.y); }
_AFXWIN_INLINE void CRect::operator-=(SIZE size)
    { ::OffsetRect(this, -size.cx, -size.cy); }
_AFXWIN_INLINE void CRect::operator-=(LPCRECT lpRect)
    { DeflateRect(lpRect); }
_AFXWIN_INLINE void CRect::operator&=(const RECT& rect)
    { ::IntersectRect(this, this, &rect); }
_AFXWIN_INLINE void CRect::operator|=(const RECT& rect)
    { ::UnionRect(this, this, &rect); }
_AFXWIN_INLINE CRect CRect::operator+(POINT pt) const
    { CRect rect(*this); ::OffsetRect(&rect, pt.x, pt.y); return rect; }
_AFXWIN_INLINE CRect CRect::operator-(POINT pt) const
    { CRect rect(*this); ::OffsetRect(&rect, -pt.x, -pt.y); return rect; }
_AFXWIN_INLINE CRect CRect::operator+(SIZE size) const
    { CRect rect(*this); ::OffsetRect(&rect, size.cx, size.cy); return rect; }
_AFXWIN_INLINE CRect CRect::operator-(SIZE size) const
    { CRect rect(*this); ::OffsetRect(&rect, -size.cx, -size.cy); return rect; }
_AFXWIN_INLINE CRect CRect::operator+(LPCRECT lpRect) const
    { CRect rect(this); rect.InflateRect(lpRect); return rect; }
_AFXWIN_INLINE CRect CRect::operator-(LPCRECT lpRect) const
    { CRect rect(this); rect.DeflateRect(lpRect); return rect; }
_AFXWIN_INLINE CRect CRect::operator&(const RECT& rect2) const
    { CRect rect; ::IntersectRect(&rect, this, &rect2);
        return rect; }
_AFXWIN_INLINE CRect CRect::operator|(const RECT& rect2) const
    { CRect rect; ::UnionRect(&rect, this, &rect2);
        return rect; }
_AFXWIN_INLINE BOOL CRect::SubtractRect(LPCRECT lpRectSrc1, LPCRECT lpRectSrc2)
    { return ::SubtractRect(this, lpRectSrc1, lpRectSrc2); }

// CArchive output helpers
_AFXWIN_INLINE CArchive& AFXAPI operator<<(CArchive& ar, SIZE size)
    { ar.Write(&size, sizeof(SIZE)); return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator<<(CArchive& ar, POINT point)
    { ar.Write(&point, sizeof(POINT)); return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator<<(CArchive& ar, const RECT& rect)
    { ar.Write(&rect, sizeof(RECT)); return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator>>(CArchive& ar, SIZE& size)
    { ar.Read(&size, sizeof(SIZE)); return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator>>(CArchive& ar, POINT& point)
    { ar.Read(&point, sizeof(POINT)); return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator>>(CArchive& ar, RECT& rect)
    { ar.Read(&rect, sizeof(RECT)); return ar; }

// exception support
_AFXWIN_INLINE CResourceException::CResourceException()
    : CSimpleException() { }
_AFXWIN_INLINE CResourceException::CResourceException(BOOL bAutoDelete, UINT nResourceID)
    : CSimpleException(bAutoDelete) { m_nResourceID = nResourceID; }
_AFXWIN_INLINE CResourceException::~CResourceException()
    { }
_AFXWIN_INLINE CUserException::CUserException()
    : CSimpleException() { }
_AFXWIN_INLINE CUserException::CUserException(BOOL bAutoDelete, UINT nResourceID)
    : CSimpleException(bAutoDelete) { m_nResourceID = nResourceID; }
_AFXWIN_INLINE CUserException::~CUserException()
    { }

// CGdiObject
_AFXWIN_INLINE CGdiObject::operator HGDIOBJ() const
    { return this == NULL ? NULL : m_hObject; }
_AFXWIN_INLINE HGDIOBJ CGdiObject::GetSafeHandle() const
    { return this == NULL ? NULL : m_hObject; }
_AFXWIN_INLINE CGdiObject::CGdiObject()
    { m_hObject = NULL; }
_AFXWIN_INLINE CGdiObject::~CGdiObject()
    { DeleteObject(); }
_AFXWIN_INLINE int CGdiObject::GetObject(int nCount, LPVOID lpObject) const
    { ASSERT(m_hObject != NULL); return ::GetObject(m_hObject, nCount, lpObject); }
_AFXWIN_INLINE BOOL CGdiObject::CreateStockObject(int nIndex)
    { return (m_hObject = ::GetStockObject(nIndex)) != NULL; }
_AFXWIN_INLINE BOOL CGdiObject::UnrealizeObject()
    { ASSERT(m_hObject != NULL); return ::UnrealizeObject(m_hObject); }
_AFXWIN_INLINE UINT CGdiObject::GetObjectType() const
    { return (UINT)::GetObjectType(m_hObject); }
_AFXWIN_INLINE BOOL CGdiObject::operator==(const CGdiObject& obj) const
    { return ((HGDIOBJ) obj) == m_hObject; }
_AFXWIN_INLINE BOOL CGdiObject::operator!=(const CGdiObject& obj) const
    { return ((HGDIOBJ) obj) != m_hObject; }

// CPen
_AFXWIN_INLINE CPen::operator HPEN() const
    { return (HPEN)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CPen* PASCAL CPen::FromHandle(HPEN hPen)
    { return (CPen*) CGdiObject::FromHandle(hPen); }
_AFXWIN_INLINE CPen::CPen()
    { }
_AFXWIN_INLINE CPen::~CPen()
    { }
_AFXWIN_INLINE BOOL CPen::CreatePen(int nPenStyle, int nWidth, COLORREF crColor)
    { return Attach(::CreatePen(nPenStyle, nWidth, crColor)); }
_AFXWIN_INLINE BOOL CPen::CreatePenIndirect(LPLOGPEN lpLogPen)
    { return Attach(::CreatePenIndirect(lpLogPen)); }
_AFXWIN_INLINE BOOL CPen::CreatePen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush,
        int nStyleCount, const DWORD* lpStyle)
    { return Attach(::ExtCreatePen(nPenStyle, nWidth, pLogBrush, nStyleCount,
        lpStyle)); }
_AFXWIN_INLINE int CPen::GetExtLogPen(EXTLOGPEN* pLogPen)
    { ASSERT(m_hObject != NULL);
        return ::GetObject(m_hObject, sizeof(EXTLOGPEN), pLogPen); }
_AFXWIN_INLINE int CPen::GetLogPen(LOGPEN* pLogPen)
    { ASSERT(m_hObject != NULL);
        return ::GetObject(m_hObject, sizeof(LOGPEN), pLogPen); }

// CBrush
_AFXWIN_INLINE CBrush::operator HBRUSH() const
    { return (HBRUSH)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CBrush* PASCAL CBrush::FromHandle(HBRUSH hBrush)
    { return (CBrush*) CGdiObject::FromHandle(hBrush); }
_AFXWIN_INLINE CBrush::CBrush()
    { }
_AFXWIN_INLINE CBrush::~CBrush()
    { }
_AFXWIN_INLINE BOOL CBrush::CreateSolidBrush(COLORREF crColor)
    { return Attach(::CreateSolidBrush(crColor)); }
_AFXWIN_INLINE BOOL CBrush::CreateHatchBrush(int nIndex, COLORREF crColor)
    { return Attach(::CreateHatchBrush(nIndex, crColor)); }
_AFXWIN_INLINE BOOL CBrush::CreateBrushIndirect(const LOGBRUSH* lpLogBrush)
    { return Attach(::CreateBrushIndirect(lpLogBrush)); }
_AFXWIN_INLINE BOOL CBrush::CreatePatternBrush(CBitmap* pBitmap)
    { return Attach(::CreatePatternBrush((HBITMAP)pBitmap->GetSafeHandle())); }
_AFXWIN_INLINE BOOL CBrush::CreateDIBPatternBrush(const void* lpPackedDIB, UINT nUsage)
    { return Attach(::CreateDIBPatternBrushPt(lpPackedDIB, nUsage)); }
_AFXWIN_INLINE BOOL CBrush::CreateSysColorBrush(int nIndex)
    { return Attach(::GetSysColorBrush(nIndex)); }
_AFXWIN_INLINE int CBrush::GetLogBrush(LOGBRUSH* pLogBrush)
    { ASSERT(m_hObject != NULL);
        return ::GetObject(m_hObject, sizeof(LOGBRUSH), pLogBrush); }

// CFont
_AFXWIN_INLINE CFont::operator HFONT() const
    { return (HFONT)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CFont* PASCAL CFont::FromHandle(HFONT hFont)
    { return (CFont*) CGdiObject::FromHandle(hFont); }
_AFXWIN_INLINE CFont::CFont()
    { }
_AFXWIN_INLINE CFont::~CFont()
    { }
_AFXWIN_INLINE BOOL CFont::CreateFontIndirect(const LOGFONT* lpLogFont)
    { return Attach(::CreateFontIndirect(lpLogFont)); }
_AFXWIN_INLINE BOOL CFont::CreateFont(int nHeight, int nWidth, int nEscapement,
        int nOrientation, int nWeight, BYTE bItalic, BYTE bUnderline,
        BYTE cStrikeOut, BYTE nCharSet, BYTE nOutPrecision,
        BYTE nClipPrecision, BYTE nQuality, BYTE nPitchAndFamily,
        LPCTSTR lpszFacename)
    { return Attach(::CreateFont(nHeight, nWidth, nEscapement,
        nOrientation, nWeight, bItalic, bUnderline, cStrikeOut,
        nCharSet, nOutPrecision, nClipPrecision, nQuality,
        nPitchAndFamily, lpszFacename)); }
_AFXWIN_INLINE int CFont::GetLogFont(LOGFONT* pLogFont)
    { ASSERT(m_hObject != NULL);
        return ::GetObject(m_hObject, sizeof(LOGFONT), pLogFont); }

// CBitmap
_AFXWIN_INLINE CBitmap::operator HBITMAP() const
    { return (HBITMAP)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CBitmap* PASCAL CBitmap::FromHandle(HBITMAP hBitmap)
    { return (CBitmap*) CGdiObject::FromHandle(hBitmap); }
_AFXWIN_INLINE CBitmap::CBitmap()
    { }
_AFXWIN_INLINE CBitmap::~CBitmap()
    { }
_AFXWIN_INLINE BOOL CBitmap::CreateBitmap(int nWidth, int nHeight, UINT nPlanes,
     UINT nBitcount, const void* lpBits)
    { return Attach(::CreateBitmap(nWidth, nHeight, nPlanes, nBitcount, lpBits)); }
_AFXWIN_INLINE BOOL CBitmap::CreateBitmapIndirect(LPBITMAP lpBitmap)
    { return Attach(::CreateBitmapIndirect(lpBitmap)); }

_AFXWIN_INLINE DWORD CBitmap::SetBitmapBits(DWORD dwCount, const void* lpBits)
    { return ::SetBitmapBits((HBITMAP)m_hObject, dwCount, lpBits); }
_AFXWIN_INLINE DWORD CBitmap::GetBitmapBits(DWORD dwCount, LPVOID lpBits) const
    { return ::GetBitmapBits((HBITMAP)m_hObject, dwCount, lpBits); }
_AFXWIN_INLINE BOOL CBitmap::LoadBitmap(LPCTSTR lpszResourceName)
    { return Attach(::LoadBitmap(AfxFindResourceHandle(
            lpszResourceName, RT_BITMAP), lpszResourceName));}
_AFXWIN_INLINE BOOL CBitmap::LoadMappedBitmap(UINT nIDBitmap, UINT nFlags,
    LPCOLORMAP lpColorMap, int nMapSize)
    { return Attach(::CreateMappedBitmap(AfxFindResourceHandle(
        MAKEINTRESOURCE(nIDBitmap), RT_BITMAP), nIDBitmap, (WORD)nFlags,
        lpColorMap, nMapSize)); }
_AFXWIN_INLINE CSize CBitmap::SetBitmapDimension(int nWidth, int nHeight)
    {
        SIZE size;
        VERIFY(::SetBitmapDimensionEx((HBITMAP)m_hObject, nWidth, nHeight, &size));
        return size;
    }
_AFXWIN_INLINE CSize CBitmap::GetBitmapDimension() const
    {
        SIZE size;
        VERIFY(::GetBitmapDimensionEx((HBITMAP)m_hObject, &size));
        return size;
    }

_AFXWIN_INLINE BOOL CBitmap::LoadBitmap(UINT nIDResource)
    { return Attach(::LoadBitmap(AfxFindResourceHandle(
        MAKEINTRESOURCE(nIDResource), RT_BITMAP), MAKEINTRESOURCE(nIDResource))); }
_AFXWIN_INLINE BOOL CBitmap::LoadOEMBitmap(UINT nIDBitmap)
    { return Attach(::LoadBitmap(NULL, MAKEINTRESOURCE(nIDBitmap))); }
_AFXWIN_INLINE BOOL CBitmap::CreateCompatibleBitmap(CDC* pDC, int nWidth, int nHeight)
    { return Attach(::CreateCompatibleBitmap(pDC->m_hDC, nWidth, nHeight)); }
_AFXWIN_INLINE BOOL CBitmap::CreateDiscardableBitmap(CDC* pDC, int nWidth, int nHeight)
    { return Attach(::CreateDiscardableBitmap(pDC->m_hDC, nWidth, nHeight)); }
_AFXWIN_INLINE int CBitmap::GetBitmap(BITMAP* pBitMap)
    { ASSERT(m_hObject != NULL);
        return ::GetObject(m_hObject, sizeof(BITMAP), pBitMap); }

// CPalette
_AFXWIN_INLINE CPalette::operator HPALETTE() const
    { return (HPALETTE)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CPalette* PASCAL CPalette::FromHandle(HPALETTE hPalette)
    { return (CPalette*) CGdiObject::FromHandle(hPalette); }
_AFXWIN_INLINE CPalette::CPalette()
    { }
_AFXWIN_INLINE CPalette::~CPalette()
    { }
_AFXWIN_INLINE BOOL CPalette::CreatePalette(LPLOGPALETTE lpLogPalette)
    { return Attach(::CreatePalette(lpLogPalette)); }
_AFXWIN_INLINE BOOL CPalette::CreateHalftonePalette(CDC* pDC)
    { ASSERT(pDC != NULL && pDC->m_hDC != NULL); return Attach(
        ::CreateHalftonePalette(pDC->m_hDC)); }
_AFXWIN_INLINE UINT CPalette::GetPaletteEntries(UINT nStartIndex, UINT nNumEntries,
        LPPALETTEENTRY lpPaletteColors) const
    { ASSERT(m_hObject != NULL); return ::GetPaletteEntries((HPALETTE)m_hObject, nStartIndex,
        nNumEntries, lpPaletteColors); }
_AFXWIN_INLINE UINT CPalette::SetPaletteEntries(UINT nStartIndex, UINT nNumEntries,
        LPPALETTEENTRY lpPaletteColors)
    { ASSERT(m_hObject != NULL); return ::SetPaletteEntries((HPALETTE)m_hObject, nStartIndex,
        nNumEntries, lpPaletteColors); }
_AFXWIN_INLINE void CPalette::AnimatePalette(UINT nStartIndex, UINT nNumEntries,
        LPPALETTEENTRY lpPaletteColors)
    { ASSERT(m_hObject != NULL); ::AnimatePalette((HPALETTE)m_hObject, nStartIndex, nNumEntries,
                lpPaletteColors); }
_AFXWIN_INLINE UINT CPalette::GetNearestPaletteIndex(COLORREF crColor) const
    { ASSERT(m_hObject != NULL); return ::GetNearestPaletteIndex((HPALETTE)m_hObject, crColor); }
_AFXWIN_INLINE BOOL CPalette::ResizePalette(UINT nNumEntries)
    { ASSERT(m_hObject != NULL); return ::ResizePalette((HPALETTE)m_hObject, nNumEntries); }
_AFXWIN_INLINE int CPalette::GetEntryCount()
    { ASSERT(m_hObject != NULL); WORD nEntries;
         ::GetObject(m_hObject, sizeof(WORD), &nEntries); return (int)nEntries; }

// CRgn
_AFXWIN_INLINE CRgn::operator HRGN() const
    { return (HRGN)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CRgn* PASCAL CRgn::FromHandle(HRGN hRgn)
    { return (CRgn*) CGdiObject::FromHandle(hRgn); }
_AFXWIN_INLINE CRgn::CRgn()
    { }
_AFXWIN_INLINE CRgn::~CRgn()
    { }
_AFXWIN_INLINE BOOL CRgn::CreateRectRgn(int x1, int y1, int x2, int y2)
    { return Attach(::CreateRectRgn(x1, y1, x2, y2)); }
_AFXWIN_INLINE BOOL CRgn::CreateRectRgnIndirect(LPCRECT lpRect)
    { return Attach(::CreateRectRgnIndirect(lpRect)); }
_AFXWIN_INLINE BOOL CRgn::CreateEllipticRgn(int x1, int y1, int x2, int y2)
    { return Attach(::CreateEllipticRgn(x1, y1, x2, y2)); }
_AFXWIN_INLINE BOOL CRgn::CreateEllipticRgnIndirect(LPCRECT lpRect)
    { return Attach(::CreateEllipticRgnIndirect(lpRect)); }
_AFXWIN_INLINE BOOL CRgn::CreatePolygonRgn(LPPOINT lpPoints, int nCount, int nMode)
    { return Attach(::CreatePolygonRgn(lpPoints, nCount, nMode)); }
_AFXWIN_INLINE BOOL CRgn::CreatePolyPolygonRgn(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount, int nPolyFillMode)
    { return Attach(::CreatePolyPolygonRgn(lpPoints, lpPolyCounts, nCount, nPolyFillMode)); }
_AFXWIN_INLINE BOOL CRgn::CreateRoundRectRgn(int x1, int y1, int x2, int y2, int x3, int y3)
    { return Attach(::CreateRoundRectRgn(x1, y1, x2, y2, x3, y3)); }
_AFXWIN_INLINE BOOL CRgn::CreateFromPath(CDC* pDC)
    { ASSERT(pDC != NULL); return Attach(::PathToRegion(pDC->m_hDC)); }
_AFXWIN_INLINE BOOL CRgn::CreateFromData(const XFORM* lpXForm, int nCount, const RGNDATA* pRgnData)
    { return Attach(::ExtCreateRegion(lpXForm, nCount, pRgnData)); }
_AFXWIN_INLINE int CRgn::GetRegionData(LPRGNDATA lpRgnData, int nDataSize) const
    { ASSERT(m_hObject != NULL); return (int)::GetRegionData((HRGN)m_hObject, nDataSize, lpRgnData); }
_AFXWIN_INLINE void CRgn::SetRectRgn(int x1, int y1, int x2, int y2)
    { ASSERT(m_hObject != NULL); ::SetRectRgn((HRGN)m_hObject, x1, y1, x2, y2); }
_AFXWIN_INLINE void CRgn::SetRectRgn(LPCRECT lpRect)
    { ASSERT(m_hObject != NULL); ::SetRectRgn((HRGN)m_hObject, lpRect->left, lpRect->top,
        lpRect->right, lpRect->bottom); }
_AFXWIN_INLINE int CRgn::CombineRgn(CRgn* pRgn1, CRgn* pRgn2, int nCombineMode)
    { ASSERT(m_hObject != NULL); return ::CombineRgn((HRGN)m_hObject, (HRGN)pRgn1->GetSafeHandle(),
        (HRGN)pRgn2->GetSafeHandle(), nCombineMode); }
_AFXWIN_INLINE int CRgn::CopyRgn(CRgn* pRgnSrc)
    { ASSERT(m_hObject != NULL); return ::CombineRgn((HRGN)m_hObject, (HRGN)pRgnSrc->GetSafeHandle(), NULL, RGN_COPY); }
_AFXWIN_INLINE BOOL CRgn::EqualRgn(CRgn* pRgn) const
    { ASSERT(m_hObject != NULL); return ::EqualRgn((HRGN)m_hObject, (HRGN)pRgn->GetSafeHandle()); }
_AFXWIN_INLINE int CRgn::OffsetRgn(int x, int y)
    { ASSERT(m_hObject != NULL); return ::OffsetRgn((HRGN)m_hObject, x, y); }
_AFXWIN_INLINE int CRgn::OffsetRgn(POINT point)
    { ASSERT(m_hObject != NULL); return ::OffsetRgn((HRGN)m_hObject, point.x, point.y); }
_AFXWIN_INLINE int CRgn::GetRgnBox(LPRECT lpRect) const
    { ASSERT(m_hObject != NULL); return ::GetRgnBox((HRGN)m_hObject, lpRect); }
_AFXWIN_INLINE BOOL CRgn::PtInRegion(int x, int y) const
    { ASSERT(m_hObject != NULL); return ::PtInRegion((HRGN)m_hObject, x, y); }
_AFXWIN_INLINE BOOL CRgn::PtInRegion(POINT point) const
    { ASSERT(m_hObject != NULL); return ::PtInRegion((HRGN)m_hObject, point.x, point.y); }
_AFXWIN_INLINE BOOL CRgn::RectInRegion(LPCRECT lpRect) const
    { ASSERT(m_hObject != NULL); return ::RectInRegion((HRGN)m_hObject, lpRect); }

// CDC
_AFXWIN_INLINE CDC::operator HDC() const
    { return this == NULL ? NULL : m_hDC; }
_AFXWIN_INLINE HDC CDC::GetSafeHdc() const
    { return this == NULL ? NULL : m_hDC; }
_AFXWIN_INLINE CWnd* CDC::GetWindow() const
    { ASSERT(m_hDC != NULL); return CWnd::FromHandle(::WindowFromDC(m_hDC)); }
_AFXWIN_INLINE BOOL CDC::IsPrinting() const
    { return m_bPrinting; }
_AFXWIN_INLINE BOOL CDC::CreateDC(LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName, LPCTSTR lpszOutput, const void* lpInitData)
    { return Attach(::CreateDC(lpszDriverName,
            lpszDeviceName, lpszOutput, (const DEVMODE*)lpInitData)); }
_AFXWIN_INLINE BOOL CDC::CreateIC(LPCTSTR lpszDriverName,
    LPCTSTR lpszDeviceName, LPCTSTR lpszOutput, const void* lpInitData)
    { return Attach(::CreateIC(lpszDriverName,
            lpszDeviceName, lpszOutput, (const DEVMODE*) lpInitData)); }
_AFXWIN_INLINE BOOL CDC::CreateCompatibleDC(CDC* pDC)
    { return Attach(::CreateCompatibleDC(pDC->GetSafeHdc())); }
_AFXWIN_INLINE int CDC::ExcludeUpdateRgn(CWnd* pWnd)
    { ASSERT(m_hDC != NULL); return ::ExcludeUpdateRgn(m_hDC, pWnd->m_hWnd); }
_AFXWIN_INLINE int CDC::GetDeviceCaps(int nIndex) const
    { ASSERT(m_hAttribDC != NULL); return ::GetDeviceCaps(m_hAttribDC, nIndex); }
_AFXWIN_INLINE CPoint CDC::GetBrushOrg() const
    {
        ASSERT(m_hDC != NULL);
        POINT point;
        VERIFY(::GetBrushOrgEx(m_hDC, &point));
        return point;
    }
_AFXWIN_INLINE CPoint CDC::SetBrushOrg(int x, int y)
    {
        ASSERT(m_hDC != NULL);
        POINT point;
        VERIFY(::SetBrushOrgEx(m_hDC, x, y, &point));
        return point;
    }
_AFXWIN_INLINE CPoint CDC::SetBrushOrg(POINT point)
    {
        ASSERT(m_hDC != NULL);
        VERIFY(::SetBrushOrgEx(m_hDC, point.x, point.y, &point));
        return point;
    }

_AFXWIN_INLINE int CDC::EnumObjects(int nObjectType,
        int (CALLBACK* lpfn)(LPVOID, LPARAM), LPARAM lpData)
    { ASSERT(m_hAttribDC != NULL); return ::EnumObjects(m_hAttribDC, nObjectType, (GOBJENUMPROC)lpfn, lpData); }

_AFXWIN_INLINE CBitmap* CDC::SelectObject(CBitmap* pBitmap)
    { ASSERT(m_hDC != NULL); return (CBitmap*) SelectGdiObject(m_hDC, pBitmap->GetSafeHandle()); }
_AFXWIN_INLINE CGdiObject* CDC::SelectObject(CGdiObject* pObject)
    { ASSERT(m_hDC != NULL); return SelectGdiObject(m_hDC, pObject->GetSafeHandle()); }
_AFXWIN_INLINE HGDIOBJ CDC::SelectObject(HGDIOBJ hObject) // Safe for NULL handles
    { ASSERT(m_hDC == m_hAttribDC); // ASSERT a simple CDC object
            return (hObject != NULL) ? ::SelectObject(m_hDC, hObject) : NULL; }
_AFXWIN_INLINE COLORREF CDC::GetNearestColor(COLORREF crColor) const
    { ASSERT(m_hAttribDC != NULL); return ::GetNearestColor(m_hAttribDC, crColor); }
_AFXWIN_INLINE UINT CDC::RealizePalette()
    { ASSERT(m_hDC != NULL); return ::RealizePalette(m_hDC); }
_AFXWIN_INLINE void CDC::UpdateColors()
    { ASSERT(m_hDC != NULL); ::UpdateColors(m_hDC); }
_AFXWIN_INLINE COLORREF CDC::GetBkColor() const
    { ASSERT(m_hAttribDC != NULL); return ::GetBkColor(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetBkMode() const
    { ASSERT(m_hAttribDC != NULL); return ::GetBkMode(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetPolyFillMode() const
    { ASSERT(m_hAttribDC != NULL); return ::GetPolyFillMode(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetROP2() const
    { ASSERT(m_hAttribDC != NULL); return ::GetROP2(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetStretchBltMode() const
    { ASSERT(m_hAttribDC != NULL); return ::GetStretchBltMode(m_hAttribDC); }
_AFXWIN_INLINE COLORREF CDC::GetTextColor() const
    { ASSERT(m_hAttribDC != NULL); return ::GetTextColor(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetMapMode() const
    { ASSERT(m_hAttribDC != NULL); return ::GetMapMode(m_hAttribDC); }

_AFXWIN_INLINE CPoint CDC::GetViewportOrg() const
    {
        ASSERT(m_hAttribDC != NULL);
        POINT point;
        VERIFY(::GetViewportOrgEx(m_hAttribDC, &point));
        return point;
    }
_AFXWIN_INLINE CSize CDC::GetViewportExt() const
    {
        ASSERT(m_hAttribDC != NULL);
        SIZE size;
        VERIFY(::GetViewportExtEx(m_hAttribDC, &size));
        return size;
    }
_AFXWIN_INLINE CPoint CDC::GetWindowOrg() const
    {
        ASSERT(m_hAttribDC != NULL);
        POINT point;
        VERIFY(::GetWindowOrgEx(m_hAttribDC, &point));
        return point;
    }
_AFXWIN_INLINE CSize CDC::GetWindowExt() const
    {
        ASSERT(m_hAttribDC != NULL);
        SIZE size;
        VERIFY(::GetWindowExtEx(m_hAttribDC, &size));
        return size;
    }

// non-virtual helpers calling virtual mapping functions
_AFXWIN_INLINE CPoint CDC::SetViewportOrg(POINT point)
    { ASSERT(m_hDC != NULL); return SetViewportOrg(point.x, point.y); }
_AFXWIN_INLINE CSize CDC::SetViewportExt(SIZE size)
    { ASSERT(m_hDC != NULL); return SetViewportExt(size.cx, size.cy); }
_AFXWIN_INLINE CPoint CDC::SetWindowOrg(POINT point)
    { ASSERT(m_hDC != NULL); return SetWindowOrg(point.x, point.y); }
_AFXWIN_INLINE CSize CDC::SetWindowExt(SIZE size)
    { ASSERT(m_hDC != NULL); return SetWindowExt(size.cx, size.cy); }

_AFXWIN_INLINE void CDC::DPtoLP(LPPOINT lpPoints, int nCount) const
    { ASSERT(m_hAttribDC != NULL); VERIFY(::DPtoLP(m_hAttribDC, lpPoints, nCount)); }
_AFXWIN_INLINE void CDC::DPtoLP(LPRECT lpRect) const
    { ASSERT(m_hAttribDC != NULL); VERIFY(::DPtoLP(m_hAttribDC, (LPPOINT)lpRect, 2)); }
_AFXWIN_INLINE void CDC::LPtoDP(LPPOINT lpPoints, int nCount) const
    { ASSERT(m_hAttribDC != NULL); VERIFY(::LPtoDP(m_hAttribDC, lpPoints, nCount)); }
_AFXWIN_INLINE void CDC::LPtoDP(LPRECT lpRect) const
    { ASSERT(m_hAttribDC != NULL); VERIFY(::LPtoDP(m_hAttribDC, (LPPOINT)lpRect, 2)); }

_AFXWIN_INLINE BOOL CDC::FillRgn(CRgn* pRgn, CBrush* pBrush)
    { ASSERT(m_hDC != NULL); return ::FillRgn(m_hDC, (HRGN)pRgn->GetSafeHandle(), (HBRUSH)pBrush->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CDC::FrameRgn(CRgn* pRgn, CBrush* pBrush, int nWidth, int nHeight)
    { ASSERT(m_hDC != NULL); return ::FrameRgn(m_hDC, (HRGN)pRgn->GetSafeHandle(), (HBRUSH)pBrush->GetSafeHandle(),
        nWidth, nHeight); }
_AFXWIN_INLINE BOOL CDC::InvertRgn(CRgn* pRgn)
    { ASSERT(m_hDC != NULL); return ::InvertRgn(m_hDC, (HRGN)pRgn->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CDC::PaintRgn(CRgn* pRgn)
    { ASSERT(m_hDC != NULL); return ::PaintRgn(m_hDC, (HRGN)pRgn->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CDC::PtVisible(int x, int y) const
    { ASSERT(m_hDC != NULL); return ::PtVisible(m_hDC, x, y); }
_AFXWIN_INLINE BOOL CDC::PtVisible(POINT point) const
    { ASSERT(m_hDC != NULL); return PtVisible(point.x, point.y); } // call virtual
_AFXWIN_INLINE BOOL CDC::RectVisible(LPCRECT lpRect) const
    { ASSERT(m_hDC != NULL); return ::RectVisible(m_hDC, lpRect); }
_AFXWIN_INLINE CPoint CDC::GetCurrentPosition() const
    {
        ASSERT(m_hAttribDC != NULL);
        POINT point;
        VERIFY(::GetCurrentPositionEx(m_hAttribDC, &point));
        return point;
    }

_AFXWIN_INLINE CPoint CDC::MoveTo(POINT point)
    { ASSERT(m_hDC != NULL); return MoveTo(point.x, point.y); }
_AFXWIN_INLINE BOOL CDC::LineTo(POINT point)
    { ASSERT(m_hDC != NULL); return LineTo(point.x, point.y); }
_AFXWIN_INLINE BOOL CDC::Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
    { ASSERT(m_hDC != NULL); return ::Arc(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4); }
_AFXWIN_INLINE BOOL CDC::Arc(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
    { ASSERT(m_hDC != NULL); return ::Arc(m_hDC, lpRect->left, lpRect->top,
        lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
        ptEnd.x, ptEnd.y); }
_AFXWIN_INLINE BOOL CDC::Polyline(LPPOINT lpPoints, int nCount)
    { ASSERT(m_hDC != NULL); return ::Polyline(m_hDC, lpPoints, nCount); }
_AFXWIN_INLINE void CDC::FillRect(LPCRECT lpRect, CBrush* pBrush)
    { ASSERT(m_hDC != NULL); ::FillRect(m_hDC, lpRect, (HBRUSH)pBrush->GetSafeHandle()); }
_AFXWIN_INLINE void CDC::FrameRect(LPCRECT lpRect, CBrush* pBrush)
    { ASSERT(m_hDC != NULL); ::FrameRect(m_hDC, lpRect, (HBRUSH)pBrush->GetSafeHandle()); }
_AFXWIN_INLINE void CDC::InvertRect(LPCRECT lpRect)
    { ASSERT(m_hDC != NULL); ::InvertRect(m_hDC, lpRect); }
_AFXWIN_INLINE BOOL CDC::DrawIcon(int x, int y, HICON hIcon)
    { ASSERT(m_hDC != NULL); return ::DrawIcon(m_hDC, x, y, hIcon); }
_AFXWIN_INLINE BOOL CDC::DrawIcon(POINT point, HICON hIcon)
    { ASSERT(m_hDC != NULL); return ::DrawIcon(m_hDC, point.x, point.y, hIcon); }
#if (WINVER >= 0x400)
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, HBITMAP hBitmap, UINT nFlags, HBRUSH hBrush)
    { ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, hBrush,
        NULL, (LPARAM)hBitmap, 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_BITMAP); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, CBitmap* pBitmap, UINT nFlags, CBrush* pBrush)
    { ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, (HBRUSH)pBrush->GetSafeHandle(),
        NULL, (LPARAM)pBitmap->GetSafeHandle(), 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_BITMAP); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, HICON hIcon, UINT nFlags, HBRUSH hBrush)
    { ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, hBrush, NULL,
        (LPARAM)hIcon, 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_ICON); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, HICON hIcon, UINT nFlags, CBrush* pBrush)
    { ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, (HBRUSH)pBrush->GetSafeHandle(), NULL,
        (LPARAM)hIcon, 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_ICON); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, LPCTSTR lpszText, UINT nFlags, BOOL bPrefixText, int nTextLen, HBRUSH hBrush)
    { ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, hBrush,
        NULL, (LPARAM)lpszText, (WPARAM)nTextLen, pt.x, pt.y, size.cx, size.cy, nFlags|(bPrefixText ? DST_PREFIXTEXT : DST_TEXT)); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, LPCTSTR lpszText, UINT nFlags, BOOL bPrefixText, int nTextLen, CBrush* pBrush)
    { ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, (HBRUSH)pBrush->GetSafeHandle(),
        NULL, (LPARAM)lpszText, (WPARAM)nTextLen, pt.x, pt.y, size.cx, size.cy, nFlags|(bPrefixText ? DST_PREFIXTEXT : DST_TEXT)); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, DRAWSTATEPROC lpDrawProc, LPARAM lData, UINT nFlags, HBRUSH hBrush)
    { ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, hBrush,
        lpDrawProc, lData, 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_COMPLEX); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, DRAWSTATEPROC lpDrawProc, LPARAM lData, UINT nFlags, CBrush* pBrush)
    { ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, (HBRUSH)pBrush->GetSafeHandle(),
        lpDrawProc, lData, 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_COMPLEX); }
_AFXWIN_INLINE BOOL CDC::DrawEdge(LPRECT lpRect, UINT nEdge, UINT nFlags)
    { ASSERT(m_hDC != NULL); return ::DrawEdge(m_hDC, lpRect, nEdge, nFlags); }
_AFXWIN_INLINE BOOL CDC::DrawFrameControl(LPRECT lpRect, UINT nType, UINT nState)
    { ASSERT(m_hDC != NULL); return ::DrawFrameControl(m_hDC, lpRect, nType, nState); }
#endif

_AFXWIN_INLINE BOOL CDC::Chord(int x1, int y1, int x2, int y2, int x3, int y3,
    int x4, int y4)
    { ASSERT(m_hDC != NULL); return ::Chord(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4); }
_AFXWIN_INLINE BOOL CDC::Chord(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
    { ASSERT(m_hDC != NULL); return ::Chord(m_hDC, lpRect->left, lpRect->top,
        lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
        ptEnd.x, ptEnd.y); }
_AFXWIN_INLINE void CDC::DrawFocusRect(LPCRECT lpRect)
    { ASSERT(m_hDC != NULL); ::DrawFocusRect(m_hDC, lpRect); }
_AFXWIN_INLINE BOOL CDC::Ellipse(int x1, int y1, int x2, int y2)
    { ASSERT(m_hDC != NULL); return ::Ellipse(m_hDC, x1, y1, x2, y2); }
_AFXWIN_INLINE BOOL CDC::Ellipse(LPCRECT lpRect)
    { ASSERT(m_hDC != NULL); return ::Ellipse(m_hDC, lpRect->left, lpRect->top,
        lpRect->right, lpRect->bottom); }
_AFXWIN_INLINE BOOL CDC::Pie(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
    { ASSERT(m_hDC != NULL); return ::Pie(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4); }
_AFXWIN_INLINE BOOL CDC::Pie(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
    { ASSERT(m_hDC != NULL); return ::Pie(m_hDC, lpRect->left, lpRect->top,
        lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
        ptEnd.x, ptEnd.y); }
_AFXWIN_INLINE BOOL CDC::Polygon(LPPOINT lpPoints, int nCount)
    { ASSERT(m_hDC != NULL); return ::Polygon(m_hDC, lpPoints, nCount); }
_AFXWIN_INLINE BOOL CDC::PolyPolygon(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount)
    { ASSERT(m_hDC != NULL); return ::PolyPolygon(m_hDC, lpPoints, lpPolyCounts, nCount); }
_AFXWIN_INLINE BOOL CDC::Rectangle(int x1, int y1, int x2, int y2)
    { ASSERT(m_hDC != NULL); return ::Rectangle(m_hDC, x1, y1, x2, y2); }
_AFXWIN_INLINE BOOL CDC::Rectangle(LPCRECT lpRect)
    { ASSERT(m_hDC != NULL); return ::Rectangle(m_hDC, lpRect->left, lpRect->top,
        lpRect->right, lpRect->bottom); }
_AFXWIN_INLINE BOOL CDC::RoundRect(int x1, int y1, int x2, int y2, int x3, int y3)
    { ASSERT(m_hDC != NULL); return ::RoundRect(m_hDC, x1, y1, x2, y2, x3, y3); }
_AFXWIN_INLINE BOOL CDC::RoundRect(LPCRECT lpRect, POINT point)
    { ASSERT(m_hDC != NULL); return ::RoundRect(m_hDC, lpRect->left, lpRect->top,
        lpRect->right, lpRect->bottom, point.x, point.y); }
_AFXWIN_INLINE BOOL CDC::PatBlt(int x, int y, int nWidth, int nHeight, DWORD dwRop)
    { ASSERT(m_hDC != NULL); return ::PatBlt(m_hDC, x, y, nWidth, nHeight, dwRop); }
_AFXWIN_INLINE BOOL CDC::BitBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
    int xSrc, int ySrc, DWORD dwRop)
    { ASSERT(m_hDC != NULL); return ::BitBlt(m_hDC, x, y, nWidth, nHeight,
        pSrcDC->GetSafeHdc(), xSrc, ySrc, dwRop); }
_AFXWIN_INLINE BOOL CDC::StretchBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
    int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, DWORD dwRop)
    { ASSERT(m_hDC != NULL); return ::StretchBlt(m_hDC, x, y, nWidth, nHeight,
        pSrcDC->GetSafeHdc(), xSrc, ySrc, nSrcWidth, nSrcHeight,
        dwRop); }
_AFXWIN_INLINE COLORREF CDC::GetPixel(int x, int y) const
    { ASSERT(m_hDC != NULL); return ::GetPixel(m_hDC, x, y); }
_AFXWIN_INLINE COLORREF CDC::GetPixel(POINT point) const
    { ASSERT(m_hDC != NULL); return ::GetPixel(m_hDC, point.x, point.y); }
_AFXWIN_INLINE COLORREF CDC::SetPixel(int x, int y, COLORREF crColor)
    { ASSERT(m_hDC != NULL); return ::SetPixel(m_hDC, x, y, crColor); }
_AFXWIN_INLINE COLORREF CDC::SetPixel(POINT point, COLORREF crColor)
    { ASSERT(m_hDC != NULL); return ::SetPixel(m_hDC, point.x, point.y, crColor); }
_AFXWIN_INLINE BOOL CDC::FloodFill(int x, int y, COLORREF crColor)
    { ASSERT(m_hDC != NULL); return ::FloodFill(m_hDC, x, y, crColor); }
_AFXWIN_INLINE BOOL CDC::ExtFloodFill(int x, int y, COLORREF crColor, UINT nFillType)
    { ASSERT(m_hDC != NULL); return ::ExtFloodFill(m_hDC, x, y, crColor, nFillType); }
_AFXWIN_INLINE BOOL CDC::TextOut(int x, int y, LPCTSTR lpszString, int nCount)
    { ASSERT(m_hDC != NULL); return ::TextOut(m_hDC, x, y, lpszString, nCount); }
_AFXWIN_INLINE BOOL CDC::TextOut(int x, int y, const CString& str)
    { ASSERT(m_hDC != NULL); return TextOut(x, y, (LPCTSTR)str, str.GetLength()); } // call virtual
_AFXWIN_INLINE BOOL CDC::ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
    LPCTSTR lpszString, UINT nCount, LPINT lpDxWidths)
    { ASSERT(m_hDC != NULL); return ::ExtTextOut(m_hDC, x, y, nOptions, lpRect,
        lpszString, nCount, lpDxWidths); }
_AFXWIN_INLINE BOOL CDC::ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
    const CString& str, LPINT lpDxWidths)
    { ASSERT(m_hDC != NULL); return ::ExtTextOut(m_hDC, x, y, nOptions, lpRect,
        str, str.GetLength(), lpDxWidths); }
_AFXWIN_INLINE CSize CDC::TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount,
    int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin)
    { ASSERT(m_hDC != NULL); return ::TabbedTextOut(m_hDC, x, y, lpszString, nCount,
        nTabPositions, lpnTabStopPositions, nTabOrigin); }
_AFXWIN_INLINE CSize CDC::TabbedTextOut(int x, int y, const CString& str,
    int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin)
    { ASSERT(m_hDC != NULL); return ::TabbedTextOut(m_hDC, x, y, str, str.GetLength(),
        nTabPositions, lpnTabStopPositions, nTabOrigin); }
_AFXWIN_INLINE int CDC::DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect,
        UINT nFormat)
    { ASSERT(m_hDC != NULL);
        return ::DrawText(m_hDC, lpszString, nCount, lpRect, nFormat); }
_AFXWIN_INLINE int CDC::DrawText(const CString& str, LPRECT lpRect, UINT nFormat)
    { ASSERT(m_hDC != NULL);
#if _MFC_VER >= 0x0600
        // these flags would modify the string
        ASSERT((nFormat & (DT_END_ELLIPSIS | DT_MODIFYSTRING)) != (DT_END_ELLIPSIS | DT_MODIFYSTRING));
        ASSERT((nFormat & (DT_PATH_ELLIPSIS | DT_MODIFYSTRING)) != (DT_PATH_ELLIPSIS | DT_MODIFYSTRING));
#endif
        return DrawText((LPCTSTR)str, str.GetLength(), lpRect, nFormat); }
_AFXWIN_INLINE CSize CDC::GetTextExtent(LPCTSTR lpszString, int nCount) const
    {
        ASSERT(m_hAttribDC != NULL);
        SIZE size;
#if _MFC_VER >= 0x0600
        VERIFY(::GetTextExtentPoint32(m_hAttribDC, lpszString, nCount, &size));
#else
        VERIFY(::GetTextExtentPoint(m_hAttribDC, lpszString, nCount, &size));
#endif
        return size;
    }
_AFXWIN_INLINE CSize CDC::GetTextExtent(const CString& str) const
    {
        ASSERT(m_hAttribDC != NULL);
        SIZE size;
#if _MFC_VER >= 0x0600
        VERIFY(::GetTextExtentPoint32(m_hAttribDC, str, str.GetLength(), &size));
#else
        VERIFY(::GetTextExtentPoint(m_hAttribDC, str, str.GetLength(), &size));
#endif
        return size;
    }

_AFXWIN_INLINE CSize CDC::GetOutputTextExtent(LPCTSTR lpszString, int nCount) const
    {
        ASSERT(m_hDC != NULL);
        SIZE size;
#if _MFC_VER >= 0x0600
        VERIFY(::GetTextExtentPoint32(m_hDC, lpszString, nCount, &size));
#else
        VERIFY(::GetTextExtentPoint(m_hDC, lpszString, nCount, &size));
#endif
        return size;
    }
_AFXWIN_INLINE CSize CDC::GetOutputTextExtent(const CString& str) const
    {
        ASSERT(m_hDC != NULL);
        SIZE size;
#if _MFC_VER >= 0x0600
        VERIFY(::GetTextExtentPoint32(m_hDC, str, str.GetLength(), &size));
#else
        VERIFY(::GetTextExtentPoint(m_hDC, str, str.GetLength(), &size));
#endif
        return size;
    }

_AFXWIN_INLINE CSize CDC::GetTabbedTextExtent(LPCTSTR lpszString, int nCount,
    int nTabPositions, LPINT lpnTabStopPositions) const
    { ASSERT(m_hAttribDC != NULL); return ::GetTabbedTextExtent(m_hAttribDC, lpszString, nCount,
        nTabPositions, lpnTabStopPositions); }
_AFXWIN_INLINE  CSize CDC::GetTabbedTextExtent(const CString& str,
        int nTabPositions, LPINT lpnTabStopPositions) const
    { ASSERT(m_hAttribDC != NULL); return ::GetTabbedTextExtent(m_hAttribDC,
        str, str.GetLength(), nTabPositions, lpnTabStopPositions); }
_AFXWIN_INLINE CSize CDC::GetOutputTabbedTextExtent(LPCTSTR lpszString, int nCount,
    int nTabPositions, LPINT lpnTabStopPositions) const
    { ASSERT(m_hDC != NULL); return ::GetTabbedTextExtent(m_hDC, lpszString, nCount,
        nTabPositions, lpnTabStopPositions); }
_AFXWIN_INLINE  CSize CDC::GetOutputTabbedTextExtent(const CString& str,
        int nTabPositions, LPINT lpnTabStopPositions) const
    { ASSERT(m_hDC != NULL); return ::GetTabbedTextExtent(m_hDC,
        str, str.GetLength(), nTabPositions, lpnTabStopPositions); }
_AFXWIN_INLINE BOOL CDC::GrayString(CBrush* pBrush,
    BOOL (CALLBACK* lpfnOutput)(HDC, LPARAM, int),
        LPARAM lpData, int nCount,
        int x, int y, int nWidth, int nHeight)
    { ASSERT(m_hDC != NULL); return ::GrayString(m_hDC, (HBRUSH)pBrush->GetSafeHandle(),
        (GRAYSTRINGPROC)lpfnOutput, lpData, nCount, x, y, nWidth, nHeight); }
_AFXWIN_INLINE UINT CDC::GetTextAlign() const
    { ASSERT(m_hAttribDC != NULL); return ::GetTextAlign(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetTextFace(int nCount, LPTSTR lpszFacename) const
    { ASSERT(m_hAttribDC != NULL); return ::GetTextFace(m_hAttribDC, nCount, lpszFacename); }
_AFXWIN_INLINE  int CDC::GetTextFace(CString& rString) const
    { ASSERT(m_hAttribDC != NULL); int nResult = ::GetTextFace(m_hAttribDC,
        256, rString.GetBuffer(256)); rString.ReleaseBuffer();
        return nResult; }
_AFXWIN_INLINE BOOL CDC::GetTextMetrics(LPTEXTMETRIC lpMetrics) const
    { ASSERT(m_hAttribDC != NULL); return ::GetTextMetrics(m_hAttribDC, lpMetrics); }
_AFXWIN_INLINE BOOL CDC::GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const
    { ASSERT(m_hDC != NULL); return ::GetTextMetrics(m_hDC, lpMetrics); }
_AFXWIN_INLINE int CDC::GetTextCharacterExtra() const
    { ASSERT(m_hAttribDC != NULL); return ::GetTextCharacterExtra(m_hAttribDC); }
_AFXWIN_INLINE BOOL CDC::GetCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const
    { ASSERT(m_hAttribDC != NULL); return ::GetCharWidth(m_hAttribDC, nFirstChar, nLastChar, lpBuffer); }
_AFXWIN_INLINE BOOL CDC::GetOutputCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const
    { ASSERT(m_hDC != NULL); return ::GetCharWidth(m_hDC, nFirstChar, nLastChar, lpBuffer); }
_AFXWIN_INLINE CSize CDC::GetAspectRatioFilter() const
    {
        ASSERT(m_hAttribDC != NULL);
        SIZE size;
        VERIFY(::GetAspectRatioFilterEx(m_hAttribDC, &size));
        return size;
    }
_AFXWIN_INLINE BOOL CDC::ScrollDC(int dx, int dy,
        LPCRECT lpRectScroll, LPCRECT lpRectClip,
        CRgn* pRgnUpdate, LPRECT lpRectUpdate)
    { ASSERT(m_hDC != NULL); return ::ScrollDC(m_hDC, dx, dy, lpRectScroll,
        lpRectClip, (HRGN)pRgnUpdate->GetSafeHandle(), lpRectUpdate); }

// Printer Escape Functions
_AFXWIN_INLINE int CDC::Escape(int nEscape, int nCount, LPCSTR lpszInData, LPVOID lpOutData)
    { ASSERT(m_hDC != NULL); return ::Escape(m_hDC, nEscape, nCount, lpszInData, lpOutData);}

// CDC 3.1 Specific functions
_AFXWIN_INLINE UINT CDC::SetBoundsRect(LPCRECT lpRectBounds, UINT flags)
    { ASSERT(m_hDC != NULL); return ::SetBoundsRect(m_hDC, lpRectBounds, flags); }
_AFXWIN_INLINE UINT CDC::GetBoundsRect(LPRECT lpRectBounds, UINT flags)
    { ASSERT(m_hAttribDC != NULL); return ::GetBoundsRect(m_hAttribDC, lpRectBounds, flags); }
_AFXWIN_INLINE BOOL CDC::ResetDC(const DEVMODE* lpDevMode)
    { ASSERT(m_hAttribDC != NULL); return ::ResetDC(m_hAttribDC, lpDevMode) != NULL; }
_AFXWIN_INLINE UINT CDC::GetOutlineTextMetrics(UINT cbData, LPOUTLINETEXTMETRIC lpotm) const
    { ASSERT(m_hAttribDC != NULL); return ::GetOutlineTextMetrics(m_hAttribDC, cbData, lpotm); }
_AFXWIN_INLINE BOOL CDC::GetCharABCWidths(UINT nFirstChar, UINT nLastChar, LPABC lpabc) const
    { ASSERT(m_hAttribDC != NULL); return ::GetCharABCWidths(m_hAttribDC, nFirstChar, nLastChar, lpabc); }
_AFXWIN_INLINE DWORD CDC::GetFontData(DWORD dwTable, DWORD dwOffset, LPVOID lpData,
    DWORD cbData) const
    { ASSERT(m_hAttribDC != NULL); return ::GetFontData(m_hAttribDC, dwTable, dwOffset, lpData, cbData); }
_AFXWIN_INLINE int CDC::GetKerningPairs(int nPairs, LPKERNINGPAIR lpkrnpair) const
    { ASSERT(m_hAttribDC != NULL); return ::GetKerningPairs(m_hAttribDC, nPairs, lpkrnpair); }
_AFXWIN_INLINE DWORD CDC::GetGlyphOutline(UINT nChar, UINT nFormat, LPGLYPHMETRICS lpgm,
        DWORD cbBuffer, LPVOID lpBuffer, const MAT2* lpmat2) const
    { ASSERT(m_hAttribDC != NULL); return ::GetGlyphOutline(m_hAttribDC, nChar, nFormat,
                lpgm, cbBuffer, lpBuffer, lpmat2); }

// Document handling functions
_AFXWIN_INLINE int CDC::StartDoc(LPDOCINFO lpDocInfo)
    { ASSERT(m_hDC != NULL); return ::StartDoc(m_hDC, lpDocInfo); }
_AFXWIN_INLINE int CDC::StartPage()
    { ASSERT(m_hDC != NULL); return ::StartPage(m_hDC); }
_AFXWIN_INLINE int CDC::EndPage()
    { ASSERT(m_hDC != NULL); return ::EndPage(m_hDC); }
_AFXWIN_INLINE int CDC::SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int))
    { ASSERT(m_hDC != NULL); return ::SetAbortProc(m_hDC, (ABORTPROC)lpfn); }
_AFXWIN_INLINE int CDC::AbortDoc()
    { ASSERT(m_hDC != NULL); return ::AbortDoc(m_hDC); }
_AFXWIN_INLINE int CDC::EndDoc()
    { ASSERT(m_hDC != NULL); return ::EndDoc(m_hDC); }

_AFXWIN_INLINE BOOL CDC::MaskBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
        int xSrc, int ySrc, CBitmap& maskBitmap, int xMask, int yMask, DWORD dwRop)
    { ASSERT(m_hDC != NULL); return ::MaskBlt(m_hDC, x, y, nWidth, nHeight, pSrcDC->GetSafeHdc(),
        xSrc, ySrc,  (HBITMAP)maskBitmap.m_hObject, xMask, yMask, dwRop); }
_AFXWIN_INLINE BOOL CDC::PlgBlt(LPPOINT lpPoint, CDC* pSrcDC, int xSrc, int ySrc,
        int nWidth, int nHeight, CBitmap& maskBitmap, int xMask, int yMask)
    { ASSERT(m_hDC != NULL); return ::PlgBlt(m_hDC, lpPoint, pSrcDC->GetSafeHdc(), xSrc, ySrc, nWidth,
        nHeight, (HBITMAP)maskBitmap.m_hObject, xMask, yMask); }
_AFXWIN_INLINE BOOL CDC::SetPixelV(int x, int y, COLORREF crColor)
    { ASSERT(m_hDC != NULL); return ::SetPixelV(m_hDC, x, y, crColor); }
_AFXWIN_INLINE BOOL CDC::SetPixelV(POINT point, COLORREF crColor)
    { ASSERT(m_hDC != NULL); return ::SetPixelV(m_hDC, point.x, point.y, crColor); }
_AFXWIN_INLINE BOOL CDC::AngleArc(int x, int y, int nRadius,
        float fStartAngle, float fSweepAngle)
    { ASSERT(m_hDC != NULL); return ::AngleArc(m_hDC, x, y, nRadius, fStartAngle, fSweepAngle); }
_AFXWIN_INLINE BOOL CDC::ArcTo(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
    { ASSERT(m_hDC != NULL); return ArcTo(lpRect->left, lpRect->top, lpRect->right,
        lpRect->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y); }
_AFXWIN_INLINE int CDC::GetArcDirection() const
    { ASSERT(m_hAttribDC != NULL); return ::GetArcDirection(m_hAttribDC); }
_AFXWIN_INLINE BOOL CDC::PolyPolyline(const POINT* lpPoints, const DWORD* lpPolyPoints,
        int nCount)
    { ASSERT(m_hDC != NULL); return ::PolyPolyline(m_hDC, lpPoints, lpPolyPoints, nCount); }
_AFXWIN_INLINE BOOL CDC::GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const
    { ASSERT(m_hAttribDC != NULL); return ::GetColorAdjustment(m_hAttribDC, lpColorAdjust); }
_AFXWIN_INLINE CPen* CDC::GetCurrentPen() const
    { ASSERT(m_hAttribDC != NULL); return CPen::FromHandle((HPEN)::GetCurrentObject(m_hAttribDC, OBJ_PEN)); }
_AFXWIN_INLINE CBrush* CDC::GetCurrentBrush() const
    { ASSERT(m_hAttribDC != NULL); return CBrush::FromHandle((HBRUSH)::GetCurrentObject(m_hAttribDC, OBJ_BRUSH)); }
_AFXWIN_INLINE CPalette* CDC::GetCurrentPalette() const
    { ASSERT(m_hAttribDC != NULL); return CPalette::FromHandle((HPALETTE)::GetCurrentObject(m_hAttribDC, OBJ_PAL)); }
_AFXWIN_INLINE CFont* CDC::GetCurrentFont() const
    { ASSERT(m_hAttribDC != NULL); return CFont::FromHandle((HFONT)::GetCurrentObject(m_hAttribDC, OBJ_FONT)); }
_AFXWIN_INLINE CBitmap* CDC::GetCurrentBitmap() const
    { ASSERT(m_hAttribDC != NULL); return CBitmap::FromHandle((HBITMAP)::GetCurrentObject(m_hAttribDC, OBJ_BITMAP)); }
_AFXWIN_INLINE BOOL CDC::PolyBezier(const POINT* lpPoints, int nCount)
    { ASSERT(m_hDC != NULL); return ::PolyBezier(m_hDC, lpPoints, nCount); }

_AFXWIN_INLINE int CDC::DrawEscape(int nEscape, int nInputSize, LPCSTR lpszInputData)
    { ASSERT(m_hDC != NULL); return ::DrawEscape(m_hDC, nEscape, nInputSize, lpszInputData); }
_AFXWIN_INLINE int CDC::Escape(int nEscape, int nInputSize, LPCSTR lpszInputData,
        int nOutputSize, LPSTR lpszOutputData)
    { ASSERT(m_hDC != NULL); return ::ExtEscape(m_hDC, nEscape, nInputSize, lpszInputData,
        nOutputSize, lpszOutputData); }

_AFXWIN_INLINE BOOL CDC::GetCharABCWidths(UINT nFirstChar, UINT nLastChar,
        LPABCFLOAT lpABCF) const
    { ASSERT(m_hAttribDC != NULL); return ::GetCharABCWidthsFloat(m_hAttribDC, nFirstChar, nLastChar, lpABCF); }
_AFXWIN_INLINE BOOL CDC::GetCharWidth(UINT nFirstChar, UINT nLastChar,
        float* lpFloatBuffer) const
    { ASSERT(m_hAttribDC != NULL); return ::GetCharWidthFloat(m_hAttribDC, nFirstChar, nLastChar, lpFloatBuffer); }

_AFXWIN_INLINE BOOL CDC::AbortPath()
    { ASSERT(m_hDC != NULL); return ::AbortPath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::BeginPath()
    { ASSERT(m_hDC != NULL); return ::BeginPath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::CloseFigure()
    { ASSERT(m_hDC != NULL); return ::CloseFigure(m_hDC); }
_AFXWIN_INLINE BOOL CDC::EndPath()
    { ASSERT(m_hDC != NULL); return ::EndPath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::FillPath()
    { ASSERT(m_hDC != NULL); return ::FillPath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::FlattenPath()
    { ASSERT(m_hDC != NULL); return ::FlattenPath(m_hDC); }
_AFXWIN_INLINE float CDC::GetMiterLimit() const
    { ASSERT(m_hDC != NULL); float fMiterLimit;
        VERIFY(::GetMiterLimit(m_hDC, &fMiterLimit)); return fMiterLimit; }
_AFXWIN_INLINE int CDC::GetPath(LPPOINT lpPoints, LPBYTE lpTypes, int nCount) const
    { ASSERT(m_hDC != NULL); return ::GetPath(m_hDC, lpPoints, lpTypes, nCount); }
_AFXWIN_INLINE BOOL CDC::SetMiterLimit(float fMiterLimit)
    { ASSERT(m_hDC != NULL); return ::SetMiterLimit(m_hDC, fMiterLimit, NULL); }
_AFXWIN_INLINE BOOL CDC::StrokeAndFillPath()
    { ASSERT(m_hDC != NULL); return ::StrokeAndFillPath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::StrokePath()
    { ASSERT(m_hDC != NULL); return ::StrokePath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::WidenPath()
    { ASSERT(m_hDC != NULL); return ::WidenPath(m_hDC); }

_AFXWIN_INLINE BOOL CDC::AddMetaFileComment(UINT nDataSize, const BYTE* pCommentData)
    { ASSERT(m_hDC != NULL); return ::GdiComment(m_hDC, nDataSize, pCommentData); }
_AFXWIN_INLINE BOOL CDC::PlayMetaFile(HENHMETAFILE hEnhMF, LPCRECT lpBounds)
    { ASSERT(m_hDC != NULL); return ::PlayEnhMetaFile(m_hDC, hEnhMF, lpBounds); }

// CMenu
_AFXWIN_INLINE CMenu::CMenu()
    { m_hMenu = NULL; }
_AFXWIN_INLINE CMenu::~CMenu()
    { DestroyMenu(); }
_AFXWIN_INLINE BOOL CMenu::CreateMenu()
    { return Attach(::CreateMenu()); }
_AFXWIN_INLINE BOOL CMenu::CreatePopupMenu()
    { return Attach(::CreatePopupMenu()); }
_AFXWIN_INLINE CMenu::operator HMENU() const
    { ASSERT(this == NULL || m_hMenu == NULL || ::IsMenu(m_hMenu));
        return this == NULL ? NULL : m_hMenu; }
_AFXWIN_INLINE CMenu::operator==(const CMenu& menu) const
    { return ((HMENU) menu) == m_hMenu; }
_AFXWIN_INLINE CMenu::operator!=(const CMenu& menu) const
    { return ((HMENU) menu) != m_hMenu; }
_AFXWIN_INLINE HMENU CMenu::GetSafeHmenu() const
    { ASSERT(this == NULL || m_hMenu == NULL || ::IsMenu(m_hMenu));
        return this == NULL ? NULL : m_hMenu; }
_AFXWIN_INLINE BOOL CMenu::DeleteMenu(UINT nPosition, UINT nFlags)
    { ASSERT(::IsMenu(m_hMenu)); return ::DeleteMenu(m_hMenu, nPosition, nFlags); }
_AFXWIN_INLINE BOOL CMenu::AppendMenu(UINT nFlags, UINT_PTR nIDNewItem, LPCTSTR lpszNewItem)
    { ASSERT(::IsMenu(m_hMenu)); return ::AppendMenu(m_hMenu, nFlags, nIDNewItem, lpszNewItem); }
_AFXWIN_INLINE BOOL CMenu::AppendMenu(UINT nFlags, UINT_PTR nIDNewItem, const CBitmap* pBmp)
    { ASSERT(::IsMenu(m_hMenu)); return ::AppendMenu(m_hMenu, nFlags | MF_BITMAP, nIDNewItem,
        (LPCTSTR)pBmp->GetSafeHandle()); }
_AFXWIN_INLINE UINT CMenu::CheckMenuItem(UINT nIDCheckItem, UINT nCheck)
    { ASSERT(::IsMenu(m_hMenu)); return (UINT)::CheckMenuItem(m_hMenu, nIDCheckItem, nCheck); }
_AFXWIN_INLINE UINT CMenu::EnableMenuItem(UINT nIDEnableItem, UINT nEnable)
    { ASSERT(::IsMenu(m_hMenu)); return ::EnableMenuItem(m_hMenu, nIDEnableItem, nEnable); }
#if _MFC_VER >= 0x0600
_AFXWIN_INLINE BOOL CMenu::SetDefaultItem(UINT uItem, BOOL fByPos)
    { ASSERT(::IsMenu(m_hMenu)); return ::SetMenuDefaultItem(m_hMenu, uItem, fByPos); }
_AFXWIN_INLINE UINT CMenu::GetDefaultItem(UINT gmdiFlags, BOOL fByPos)
    { ASSERT(::IsMenu(m_hMenu)); return ::GetMenuDefaultItem(m_hMenu, fByPos, gmdiFlags); }
#endif
_AFXWIN_INLINE UINT CMenu::GetMenuItemCount() const
    { ASSERT(::IsMenu(m_hMenu)); return ::GetMenuItemCount(m_hMenu); }
_AFXWIN_INLINE UINT CMenu::GetMenuItemID(int nPos) const
    { ASSERT(::IsMenu(m_hMenu)); return ::GetMenuItemID(m_hMenu, nPos); }
_AFXWIN_INLINE UINT CMenu::GetMenuState(UINT nID, UINT nFlags) const
    { ASSERT(::IsMenu(m_hMenu)); return ::GetMenuState(m_hMenu, nID, nFlags); }
_AFXWIN_INLINE int CMenu::GetMenuString(UINT nIDItem, LPTSTR lpString, int nMaxCount, UINT nFlags) const
    { ASSERT(::IsMenu(m_hMenu)); return ::GetMenuString(m_hMenu, nIDItem, lpString, nMaxCount, nFlags); }
_AFXWIN_INLINE int CMenu::GetMenuString(UINT nIDItem, CString& rString, UINT nFlags) const
    { ASSERT(::IsMenu(m_hMenu)); int nResult = ::GetMenuString(m_hMenu, nIDItem,
        rString.GetBuffer(256), 256, nFlags); rString.ReleaseBuffer();
        return nResult; }
#if _MFC_VER >= 0x0600
_AFXWIN_INLINE BOOL CMenu::GetMenuItemInfo(UINT nIDItem, LPMENUITEMINFO lpMenuItemInfo, BOOL fByPos)
    { ASSERT(::IsMenu(m_hMenu)); ASSERT_POINTER(lpMenuItemInfo, MENUITEMINFO);
        return ::GetMenuItemInfo(m_hMenu, nIDItem, fByPos, lpMenuItemInfo); }
#endif
_AFXWIN_INLINE CMenu* CMenu::GetSubMenu(int nPos) const
    { ASSERT(::IsMenu(m_hMenu)); return CMenu::FromHandle(::GetSubMenu(m_hMenu, nPos)); }
_AFXWIN_INLINE BOOL CMenu::InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem,
        LPCTSTR lpszNewItem)
    { ASSERT(::IsMenu(m_hMenu)); return ::InsertMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem); }
_AFXWIN_INLINE BOOL CMenu::InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem, const CBitmap* pBmp)
    { ASSERT(::IsMenu(m_hMenu)); return ::InsertMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem,
        (LPCTSTR)pBmp->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CMenu::ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem, LPCTSTR lpszNewItem)
    { ASSERT(::IsMenu(m_hMenu)); return ::ModifyMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem); }
_AFXWIN_INLINE BOOL CMenu::ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem, const CBitmap* pBmp)
    { ASSERT(::IsMenu(m_hMenu)); return ::ModifyMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem,
        (LPCTSTR)pBmp->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CMenu::RemoveMenu(UINT nPosition, UINT nFlags)
    { ASSERT(::IsMenu(m_hMenu)); return ::RemoveMenu(m_hMenu, nPosition, nFlags); }
_AFXWIN_INLINE BOOL CMenu::SetMenuItemBitmaps(UINT nPosition, UINT nFlags,
        const CBitmap* pBmpUnchecked, const CBitmap* pBmpChecked)
    { ASSERT(::IsMenu(m_hMenu)); return ::SetMenuItemBitmaps(m_hMenu, nPosition, nFlags,
        (HBITMAP)pBmpUnchecked->GetSafeHandle(),
        (HBITMAP)pBmpChecked->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CMenu::LoadMenu(LPCTSTR lpszResourceName)
    { return Attach(::LoadMenu(AfxFindResourceHandle(lpszResourceName,
        RT_MENU), lpszResourceName)); }
_AFXWIN_INLINE BOOL CMenu::LoadMenu(UINT nIDResource)
    { return Attach(::LoadMenu(AfxFindResourceHandle(
        MAKEINTRESOURCE(nIDResource), RT_MENU), MAKEINTRESOURCE(nIDResource))); }
_AFXWIN_INLINE BOOL CMenu::LoadMenuIndirect(const void* lpMenuTemplate)
    { return Attach(::LoadMenuIndirect(lpMenuTemplate)); }
// Win4
_AFXWIN_INLINE BOOL CMenu::SetMenuContextHelpId(DWORD dwContextHelpId)
    { return ::SetMenuContextHelpId(m_hMenu, dwContextHelpId); }
_AFXWIN_INLINE DWORD CMenu::GetMenuContextHelpId() const
    { return ::GetMenuContextHelpId(m_hMenu); }
_AFXWIN_INLINE BOOL CMenu::CheckMenuRadioItem(UINT nIDFirst, UINT nIDLast, UINT nIDItem, UINT nFlags)
    { return ::CheckMenuRadioItem(m_hMenu, nIDFirst, nIDLast, nIDItem, nFlags); }

// CCmdUI
_AFXWIN_INLINE void CCmdUI::ContinueRouting()
    { m_bContinueRouting = TRUE; }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXWIN_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\mfc42\atlconv.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCONV_H__
#define __ATLCONV_H__

#ifndef __cplusplus
        #error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atldef.h>

#ifndef _INC_MALLOC
#include <malloc.h>
#endif // _INC_MALLOC

#pragma pack(push,8)

namespace ATL
{
namespace _ATL_SAFE_ALLOCA_IMPL
{
// Following code is to avoid alloca causing a stack overflow.
// It is intended for use from the _ATL_SAFE_ALLOCA macros 
// or Conversion macros.
__declspec(selectany) DWORD _Atlosplatform = 0;
inline BOOL _AtlGetVersionEx()
{
        OSVERSIONINFO osi;
        memset(&osi, 0, sizeof(OSVERSIONINFO));
        osi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&osi);
        _Atlosplatform = osi.dwPlatformId;
        return TRUE;
}

// From VC7 CRT sources.
#define _ATL_MIN_STACK_REQ_WIN9X 0x11000
#define _ATL_MIN_STACK_REQ_WINNT 0x2000

/***
* void _resetstkoflw(void) - Recovers from Stack Overflow
*
* Purpose:
*       Sets the guard page to its position before the stack overflow.
*
* Exit:
*       Returns nonzero on success, zero on failure
*
*******************************************************************************/

inline int _Atlresetstkoflw(void)
{
        static BOOL bTemp = _AtlGetVersionEx();
        
    LPBYTE pStack, pGuard, pStackBase, pMaxGuard, pMinGuard;
    MEMORY_BASIC_INFORMATION mbi;
    SYSTEM_INFO si;
    DWORD PageSize;
    DWORD flNewProtect;
    DWORD flOldProtect;

    // Use _alloca() to get the current stack pointer

    pStack = (LPBYTE)_alloca(1);

    // Find the base of the stack.

    if (VirtualQuery(pStack, &mbi, sizeof mbi) == 0)
        return 0;
    pStackBase = (LPBYTE)mbi.AllocationBase;

    // Find the page just below where the stack pointer currently points.
    // This is the highest potential guard page.

    GetSystemInfo(&si);
    PageSize = si.dwPageSize;

    pMaxGuard = (LPBYTE) (((DWORD_PTR)pStack & ~(DWORD_PTR)(PageSize - 1))
                       - PageSize);

    // If the potential guard page is too close to the start of the stack
    // region, abandon the reset effort for lack of space.  Win9x has a
    // larger reserved stack requirement.

    pMinGuard = pStackBase + ((_Atlosplatform == VER_PLATFORM_WIN32_WINDOWS)
                              ? _ATL_MIN_STACK_REQ_WIN9X
                              : _ATL_MIN_STACK_REQ_WINNT);

    if (pMaxGuard < pMinGuard)
        return 0;

    // On a non-Win9x system, do nothing if a guard page is already present,
    // else set up the guard page to the bottom of the committed range.
    // For Win9x, just set guard page below the current stack page.

    if (_Atlosplatform != VER_PLATFORM_WIN32_WINDOWS) {

        // Find first block of committed memory in the stack region

        pGuard = pStackBase;
        do {
            if (VirtualQuery(pGuard, &mbi, sizeof mbi) == 0)
                return 0;
            pGuard = pGuard + mbi.RegionSize;
        } while ((mbi.State & MEM_COMMIT) == 0);
        pGuard = (LPBYTE)mbi.BaseAddress;

        // If first committed block is already marked as a guard page,
        // there is nothing that needs to be done, so return success.

        if (mbi.Protect & PAGE_GUARD)
            return 1;

        // Fail if the first committed block is above the highest potential
        // guard page.  Should never happen.

        if (pMaxGuard < pGuard)
            return 0;

                // Make sure to leave enough room so the next overflow will have
        // the proper reserved stack requirement available.

        if (pGuard < pMinGuard)
            pGuard = pMinGuard;

        VirtualAlloc(pGuard, PageSize, MEM_COMMIT, PAGE_READWRITE);
    }
    else {
        pGuard = pMaxGuard;
    }

    // Enable the new guard page.

    flNewProtect = _Atlosplatform == VER_PLATFORM_WIN32_WINDOWS
                   ? PAGE_NOACCESS
                   : PAGE_READWRITE | PAGE_GUARD;

    return VirtualProtect(pGuard, PageSize, flNewProtect, &flOldProtect);
}

#ifndef _ATL_STACK_MARGIN
#define        _ATL_STACK_MARGIN        0x2000 // Minimum stack space available after allocaiton with _ATL_SAFE_ALLOCA
#endif

// Verifies if sufficient space is available on the stack.
inline bool _AtlVerifyStackAvailable(SIZE_T Size)
{
    bool bStackAvailable = true;

    __try
    {
        PVOID p = _alloca(Size + _ATL_STACK_MARGIN);
        p;
    }
    __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                   EXCEPTION_EXECUTE_HANDLER :
                   EXCEPTION_CONTINUE_SEARCH)
    {
        bStackAvailable = false;
        _Atlresetstkoflw();
    }
    return bStackAvailable;
}

// Helper Classes to manage heap buffers for _ATL_SAFE_ALLOCA

// Default allocator used by ATL
class _CCRTAllocator
{
public :
        static void * Allocate(SIZE_T nRequestedSize)
        {
                return malloc(nRequestedSize);
        }
        static void Free(void* p)
        {
                free(p);
        }
};

template < class Allocator>
class CAtlSafeAllocBufferManager
{
private :
        struct CAtlSafeAllocBufferNode
        {
                CAtlSafeAllocBufferNode* m_pNext;
#ifdef _WIN64
                BYTE _pad[8];
#else
                BYTE _pad[4];
#endif
                void* GetData()
                {
                        return (this + 1);
                }
        };

        CAtlSafeAllocBufferNode* m_pHead;
public :
        
        CAtlSafeAllocBufferManager() : m_pHead(NULL) {};
        void* Allocate(SIZE_T nRequestedSize)
        {
                CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(nRequestedSize + sizeof(CAtlSafeAllocBufferNode));
                if (p == NULL)
                        return NULL;
                
                // Add buffer to the list
                p->m_pNext = m_pHead;
                m_pHead = p;
                
                return p->GetData();
        }
        ~CAtlSafeAllocBufferManager()
        {
                // Walk the list and free the buffers
                while (m_pHead != NULL)
                {
                        CAtlSafeAllocBufferNode* p = m_pHead;
                        m_pHead = m_pHead->m_pNext;
                        Allocator::Free(p);
                }
        }
};

// Use one of the following macros before using _ATL_SAFE_ALLOCA
// EX version allows specifying a different heap allocator
#define USES_ATL_SAFE_ALLOCA_EX(x)        ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<x> _AtlSafeAllocaManager

#ifndef USES_ATL_SAFE_ALLOCA
#define USES_ATL_SAFE_ALLOCA                USES_ATL_SAFE_ALLOCA_EX(ATL::_ATL_SAFE_ALLOCA_IMPL::_CCRTAllocator)
#endif

// nRequestedSize - requested size in bytes 
// nThreshold - size in bytes beyond which memory is allocated from the heap.

// Defining _ATL_SAFE_ALLOCA_ALWAYS_ALLOCATE_THRESHOLD_SIZE always allocates the size specified
// for threshold if the stack space is available irrespective of requested size.
// This available for testing purposes. It will help determine the max stack usage due to _alloca's

#ifdef _ATL_SAFE_ALLOCA_ALWAYS_ALLOCATE_THRESHOLD_SIZE
#define _ATL_SAFE_ALLOCA(nRequestedSize, nThreshold)        \
        (((nRequestedSize) <= (nThreshold) && ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(nThreshold) ) ?        \
                _alloca(nThreshold) :        \
                ((ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(nThreshold)) ? _alloca(nThreshold) : 0),        \
                        _AtlSafeAllocaManager.Allocate(nRequestedSize))
#else
#define _ATL_SAFE_ALLOCA(nRequestedSize, nThreshold)        \
        (((nRequestedSize) <= (nThreshold) && ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(nRequestedSize) ) ?        \
                _alloca(nRequestedSize) :        \
                _AtlSafeAllocaManager.Allocate(nRequestedSize))
#endif

// Use 1024 bytes as the default threshold in ATL
#ifndef _ATL_SAFE_ALLOCA_DEF_THRESHOLD
#define _ATL_SAFE_ALLOCA_DEF_THRESHOLD        1024
#endif

}        // namespace _ATL_SAFE_ALLOCA_IMPL

}        // namespace ATL

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#ifdef _CONVERSION_USES_THREAD_LOCALE
        #ifndef _DEBUG
                #define USES_CONVERSION int _convert; _convert; UINT _acp = GetACP(); _acp; LPCWSTR _lpw; _lpw; LPCSTR _lpa; _lpa
        #else
                #define USES_CONVERSION int _convert = 0; _convert; UINT _acp = GetACP(); _acp; LPCWSTR _lpw = NULL; _lpw; LPCSTR _lpa = NULL; _lpa
        #endif
#else
        #ifndef _DEBUG
                #define USES_CONVERSION int _convert; _convert; UINT _acp = CP_ACP; _acp; LPCWSTR _lpw; _lpw; LPCSTR _lpa; _lpa
        #else
                #define USES_CONVERSION int _convert = 0; _convert; UINT _acp = CP_ACP; _acp; LPCWSTR _lpw = NULL; _lpw; LPCSTR _lpa = NULL; _lpa
        #endif
#endif

#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#ifdef _CONVERSION_USES_THREAD_LOCALE
        #ifndef _DEBUG
                #define USES_CONVERSION_EX int _convert_ex; _convert_ex; UINT _acp_ex = GetACP(); _acp_ex; LPCWSTR _lpw_ex; _lpw_ex; LPCSTR _lpa_ex; _lpa_ex; USES_ATL_SAFE_ALLOCA
        #else
                #define USES_CONVERSION_EX int _convert_ex = 0; _convert_ex; UINT _acp_ex = GetACP(); _acp_ex; LPCWSTR _lpw_ex = NULL; _lpw_ex; LPCSTR _lpa_ex = NULL; _lpa_ex; USES_ATL_SAFE_ALLOCA
        #endif
#else
        #ifndef _DEBUG
                #define USES_CONVERSION_EX int _convert_ex; _convert_ex; UINT _acp_ex = CP_ACP; _acp_ex; LPCWSTR _lpw_ex; _lpw_ex; LPCSTR _lpa_ex; _lpa_ex; USES_ATL_SAFE_ALLOCA
        #else
                #define USES_CONVERSION_EX int _convert_ex = 0; _convert_ex; UINT _acp_ex = CP_ACP; _acp_ex; LPCWSTR _lpw_ex = NULL; _lpw_ex; LPCSTR _lpa_ex = NULL; _lpa_ex; USES_ATL_SAFE_ALLOCA
        #endif
#endif


#ifdef _WINGDI_
        ATLAPI_(LPDEVMODEA) AtlDevModeW2A(LPDEVMODEA lpDevModeA, LPDEVMODEW lpDevModeW);
#endif

/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers
inline LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars, UINT acp)
{
        ATLASSERT(lpa != NULL);
        ATLASSERT(lpw != NULL);
        if (lpw == NULL || lpa == NULL)
                return NULL;
        // verify that no illegal character present
        // since lpw was allocated based on the size of lpa
        // don't worry about the number of chars
        lpw[0] = '\0';
        int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);
        if(ret == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }                
        return lpw;
}

inline LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars, UINT acp)
{
        ATLASSERT(lpw != NULL);
        ATLASSERT(lpa != NULL);
        if (lpa == NULL || lpw == NULL)
                return NULL;
        // verify that no illegal character present
        // since lpa was allocated based on the size of lpw
        // don't worry about the number of chars
        lpa[0] = '\0';
        int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);
        if(ret == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }
        return lpa;
}
inline LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
        return AtlA2WHelper(lpw, lpa, nChars, CP_ACP);
}

inline LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
        return AtlW2AHelper(lpa, lpw, nChars, CP_ACP);
}

#ifdef _CONVERSION_USES_THREAD_LOCALE
        #ifdef ATLA2WHELPER
                #undef ATLA2WHELPER
                #undef ATLW2AHELPER
        #endif
        #define ATLA2WHELPER AtlA2WHelper
        #define ATLW2AHELPER AtlW2AHelper
#else
        #ifndef ATLA2WHELPER
                #define ATLA2WHELPER AtlA2WHelper
                #define ATLW2AHELPER AtlW2AHelper
        #endif
#endif

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#ifdef _CONVERSION_USES_THREAD_LOCALE
        #define A2W(lpa) (\
                ((_lpa = lpa) == NULL) ? NULL : (\
                        _convert = (lstrlenA(_lpa)+1),\
                        ATLA2WHELPER((LPWSTR)alloca(_convert*2), _lpa, _convert, _acp)))
#else
        #define A2W(lpa) (\
                ((_lpa = lpa) == NULL) ? NULL : (\
                        _convert = (lstrlenA(_lpa)+1),\
                        ATLA2WHELPER((LPWSTR)alloca(_convert*2), _lpa, _convert)))
#endif

#ifdef _CONVERSION_USES_THREAD_LOCALE
        #define W2A(lpw) (\
                ((_lpw = lpw) == NULL) ? NULL : (\
                        _convert = (lstrlenW(_lpw)+1)*2,\
                        ATLW2AHELPER((LPSTR)alloca(_convert) , _lpw, _convert, _acp)))
#else
        #define W2A(lpw) (\
                ((_lpw = lpw) == NULL) ? NULL : (\
                        _convert = (lstrlenW(_lpw)+1)*2,\
                        ATLW2AHELPER((LPSTR)alloca(_convert), _lpw, _convert)))
#endif

#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

// The call to _alloca will not cause stack overflow if _AtlVerifyStackAvailable returns TRUE.
#ifdef _CONVERSION_USES_THREAD_LOCALE
        #define A2W_EX(lpa, nThreshold) (\
                ((_lpa_ex = lpa) == NULL) ? NULL : (\
                        _convert_ex = (lstrlenA(_lpa_ex)+1),\
                        ATLA2WHELPER(        \
                                (LPWSTR)_ATL_SAFE_ALLOCA(_convert_ex * sizeof(WCHAR), nThreshold), \
                                _lpa_ex, \
                                _convert_ex, \
                                _acp_ex)))
#else
        #define A2W_EX(lpa, nThreshold) (\
                ((_lpa_ex = lpa) == NULL) ? NULL : (\
                        _convert_ex = (lstrlenA(_lpa_ex)+1),\
                        ATLA2WHELPER(        \
                                (LPWSTR)_ATL_SAFE_ALLOCA(_convert_ex * sizeof(WCHAR), nThreshold), \
                                _lpa_ex, \
                                _convert_ex)))
#endif

#ifdef _CONVERSION_USES_THREAD_LOCALE
        #define W2A_EX(lpw, nThreshold) (\
                ((_lpw_ex = lpw) == NULL) ? NULL : (\
                        _convert_ex = (lstrlenW(_lpw_ex)+1) * sizeof(WCHAR),\
                        ATLW2AHELPER(        \
                                (LPSTR)_ATL_SAFE_ALLOCA(_convert_ex, nThreshold), \
                                _lpw_ex, \
                                _convert_ex, \
                                _acp_ex)))
#else
        #define W2A_EX(lpw, nThreshold) (\
                ((_lpw_ex = lpw) == NULL) ? NULL : (\
                        _convert_ex = (lstrlenW(_lpw_ex)+1) * sizeof(WCHAR),\
                        ATLW2AHELPER(        \
                                (LPSTR)_ATL_SAFE_ALLOCA(_convert_ex, nThreshold), \
                                _lpw_ex, \
                                _convert_ex)))
#endif

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))

#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#define A2CW_EX(lpa, nChar) ((LPCWSTR)A2W_EX(lpa, nChar))
#define W2CA_EX(lpw, nChar) ((LPCSTR)W2A_EX(lpw, nChar))

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
        inline int ocslen(LPCOLESTR x) { return lstrlenW(x); }
        inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return lstrcpyW(dest, src); }
        inline OLECHAR* ocscat(LPOLESTR dest, LPCOLESTR src) { return lstrcatW(dest, src); }
        
        inline LPCOLESTR T2COLE_EX(LPCTSTR lp, UINT) { return lp; }
        inline LPCTSTR OLE2CT_EX(LPCOLESTR lp, UINT) { return lp; }
        inline LPOLESTR T2OLE_EX(LPTSTR lp, UINT) { return lp; }
        inline LPTSTR OLE2T_EX(LPOLESTR lp, UINT) { return lp; }        

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
        inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
        inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
        inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }        

#endif         // _ATL_EX_CONVERSION_MACROS_ONLY

        inline LPOLESTR CharNextO(LPCOLESTR lp) {return CharNextW(lp);}
#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
        inline int ocslen(LPCOLESTR x) { return lstrlen(x); }
        inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) { return lstrcpy(dest, src); }
        inline OLECHAR* ocscat(LPOLESTR dest, LPCOLESTR src) { return ocscpy(dest+ocslen(dest), src); }

        inline LPCOLESTR T2COLE_EX(LPCTSTR lp, UINT) { return lp; }
        inline LPCTSTR OLE2CT_EX(LPCOLESTR lp, UINT) { return lp; }
        inline LPOLESTR T2OLE_EX(LPTSTR lp, UINT) { return lp; }
        inline LPTSTR OLE2T_EX(LPOLESTR lp, UINT) { return lp; }
        
#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
        inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
        inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
        inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY
        
        inline LPOLESTR CharNextO(LPCOLESTR lp) {return CharNext(lp);}
#else
        inline int ocslen(LPCOLESTR x) { return lstrlenW(x); }
        //lstrcpyW doesn't work on Win95, so we do this
        inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src)
        {return (LPOLESTR) memcpy(dest, src, (lstrlenW(src)+1)*sizeof(WCHAR));}
        inline OLECHAR* ocscat(LPOLESTR dest, LPCOLESTR src) { return ocscpy(dest+ocslen(dest), src); }
        //CharNextW doesn't work on Win95 so we use this
        
        #define T2COLE_EX(lpa, nChar) A2CW_EX(lpa, nChar)
        #define T2OLE_EX(lpa, nChar) A2W_EX(lpa, nChar)
        #define OLE2CT_EX(lpo, nChar) W2CA_EX(lpo, nChar)
        #define OLE2T_EX(lpo, nChar) W2A_EX(lpo, nChar)

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        #define T2COLE(lpa) A2CW(lpa)
        #define T2OLE(lpa) A2W(lpa)
        #define OLE2CT(lpo) W2CA(lpo)
        #define OLE2T(lpo) W2A(lpo)

#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

        inline LPOLESTR CharNextO(LPCOLESTR lp) {return (LPOLESTR) ((*lp) ? (lp+1) : lp);}
#endif

#ifdef OLE2ANSI
        inline LPOLESTR A2OLE_EX(LPSTR lp, UINT) { return lp;}
        inline LPSTR OLE2A_EX(LPOLESTR lp, UINT) { return lp;}
        #define W2OLE_EX W2A_EX
        #define OLE2W_EX A2W_EX
        inline LPCOLESTR A2COLE_EX(LPCSTR lp, UINT) { return lp;}
        inline LPCSTR OLE2CA_EX(LPCOLESTR lp, UINT) { return lp;}
        #define W2COLE_EX W2CA_EX
        #define OLE2CW_EX A2CW_EX

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline LPOLESTR A2OLE(LPSTR lp) { return lp;}
        inline LPSTR OLE2A(LPOLESTR lp) { return lp;}
        #define W2OLE W2A
        #define OLE2W A2W
        inline LPCOLESTR A2COLE(LPCSTR lp) { return lp;}
        inline LPCSTR OLE2CA(LPCOLESTR lp) { return lp;}
        #define W2COLE W2CA
        #define OLE2CW A2CW
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#else
        inline LPOLESTR W2OLE_EX(LPWSTR lp, UINT) { return lp; }
        inline LPWSTR OLE2W_EX(LPOLESTR lp, UINT) { return lp; }
        #define A2OLE_EX A2W_EX
        #define OLE2A_EX W2A_EX
        inline LPCOLESTR W2COLE_EX(LPCWSTR lp, UINT) { return lp; }
        inline LPCWSTR OLE2CW_EX(LPCOLESTR lp, UINT) { return lp; }
        #define A2COLE_EX A2CW_EX
        #define OLE2CA_EX W2CA_EX

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline LPOLESTR W2OLE(LPWSTR lp) { return lp; }
        inline LPWSTR OLE2W(LPOLESTR lp) { return lp; }
        #define A2OLE A2W
        #define OLE2A W2A
        inline LPCOLESTR W2COLE(LPCWSTR lp) { return lp; }
        inline LPCWSTR OLE2CW(LPCOLESTR lp) { return lp; }
        #define A2COLE A2CW
        #define OLE2CA W2CA
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#endif

#ifdef _UNICODE
        #define T2A_EX W2A_EX
        #define A2T_EX A2W_EX
        inline LPWSTR T2W_EX(LPTSTR lp, UINT) { return lp; }
        inline LPTSTR W2T_EX(LPWSTR lp, UINT) { return lp; }
        #define T2CA_EX W2CA_EX
        #define A2CT_EX A2CW_EX
        inline LPCWSTR T2CW_EX(LPCTSTR lp, UINT) { return lp; }
        inline LPCTSTR W2CT_EX(LPCWSTR lp, UINT) { return lp; }

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        #define T2A W2A
        #define A2T A2W
        inline LPWSTR T2W(LPTSTR lp) { return lp; }
        inline LPTSTR W2T(LPWSTR lp) { return lp; }
        #define T2CA W2CA
        #define A2CT A2CW
        inline LPCWSTR T2CW(LPCTSTR lp) { return lp; }
        inline LPCTSTR W2CT(LPCWSTR lp) { return lp; }

#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#else
        #define T2W_EX A2W_EX
        #define W2T_EX W2A_EX
        inline LPSTR T2A_EX(LPTSTR lp, UINT) { return lp; }
        inline LPTSTR A2T_EX(LPSTR lp, UINT) { return lp; }
        #define T2CW_EX A2CW_EX
        #define W2CT_EX W2CA_EX
        inline LPCSTR T2CA_EX(LPCTSTR lp, UINT) { return lp; }
        inline LPCTSTR A2CT_EX(LPCSTR lp, UINT) { return lp; }

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        #define T2W A2W
        #define W2T W2A
        inline LPSTR T2A(LPTSTR lp) { return lp; }
        inline LPTSTR A2T(LPSTR lp) { return lp; }
        #define T2CW A2CW
        #define W2CT W2CA
        inline LPCSTR T2CA(LPCTSTR lp) { return lp; }
        inline LPCTSTR A2CT(LPCSTR lp) { return lp; }
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#endif

inline BSTR A2WBSTR(LPCSTR lp, int nLen = -1)
{
        if (lp == NULL || nLen == 0)
                return NULL;
        USES_CONVERSION_EX;
        BSTR str = NULL;
        int nConvertedLen = MultiByteToWideChar(_acp_ex, 0, lp,
                nLen, NULL, NULL);
        int nAllocLen = nConvertedLen;
        if (nLen == -1)
                nAllocLen -= 1;  // Don't allocate terminating '\0'
        str = ::SysAllocStringLen(NULL, nAllocLen);
        if (str != NULL)
        {
                int nResult;
                nResult = MultiByteToWideChar(_acp_ex, 0, lp, nLen, str, nConvertedLen);
                ATLASSERT(nResult == nConvertedLen);
                if(nResult != nConvertedLen)
                {
                        SysFreeString(str);
                        return NULL;
                }
        }
        return str;
}

inline BSTR OLE2BSTR(LPCOLESTR lp) {return ::SysAllocString(lp);}
#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
        inline BSTR T2BSTR_EX(LPCTSTR lp) {return ::SysAllocString(lp);}
        inline BSTR A2BSTR_EX(LPCSTR lp) {return A2WBSTR(lp);}
        inline BSTR W2BSTR_EX(LPCWSTR lp) {return ::SysAllocString(lp);}

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline BSTR T2BSTR(LPCTSTR lp) {return T2BSTR_EX(lp); }
        inline BSTR A2BSTR(LPCSTR lp) {return A2BSTR_EX(lp); }
        inline BSTR W2BSTR(LPCWSTR lp) {return W2BSTR_EX(lp); }

#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
        inline BSTR T2BSTR_EX(LPCTSTR lp) {return ::SysAllocString(lp);}
        inline BSTR A2BSTR_EX(LPCSTR lp) {return ::SysAllocString(lp);}
        inline BSTR W2BSTR_EX(LPCWSTR lp) {USES_CONVERSION_EX; return ::SysAllocString(W2COLE_EX(lp));}

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline BSTR T2BSTR(LPCTSTR lp) {return T2BSTR_EX(lp); }
        inline BSTR A2BSTR(LPCSTR lp) {return A2BSTR_EX(lp); }
        inline BSTR W2BSTR(LPCWSTR lp) {USES_CONVERSION; return ::SysAllocString(W2COLE(lp));}
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#else
        inline BSTR T2BSTR_EX(LPCTSTR lp) {return A2WBSTR(lp);}
        inline BSTR A2BSTR_EX(LPCSTR lp) {return A2WBSTR(lp);}
        inline BSTR W2BSTR_EX(LPCWSTR lp) {return ::SysAllocString(lp);}
        
#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline BSTR T2BSTR(LPCTSTR lp) {return T2BSTR_EX(lp); }
        inline BSTR A2BSTR(LPCSTR lp) {return A2BSTR_EX(lp); }
        inline BSTR W2BSTR(LPCWSTR lp) {return W2BSTR_EX(lp); }
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#endif

#ifdef _WINGDI_
/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers
inline LPDEVMODEW AtlDevModeA2W(LPDEVMODEW lpDevModeW, LPDEVMODEA lpDevModeA)
{
        USES_CONVERSION_EX;
        ATLASSERT(lpDevModeW != NULL);
        if (lpDevModeA == NULL || lpDevModeW == NULL)
                return NULL;
        AtlA2WHelper(lpDevModeW->dmDeviceName, (LPCSTR)lpDevModeA->dmDeviceName, 32, _acp_ex);
        memcpy(&lpDevModeW->dmSpecVersion, &lpDevModeA->dmSpecVersion,
                offsetof(DEVMODEW, dmFormName) - offsetof(DEVMODEW, dmSpecVersion));
        AtlA2WHelper(lpDevModeW->dmFormName, (LPCSTR)lpDevModeA->dmFormName, 32, _acp_ex);
        memcpy(&lpDevModeW->dmLogPixels, &lpDevModeA->dmLogPixels,
                sizeof(DEVMODEW) - offsetof(DEVMODEW, dmLogPixels));
        if (lpDevModeA->dmDriverExtra != 0)
                memcpy(lpDevModeW+1, lpDevModeA+1, lpDevModeA->dmDriverExtra);
        lpDevModeW->dmSize = sizeof(DEVMODEW);
        return lpDevModeW;
}

inline LPTEXTMETRICW AtlTextMetricA2W(LPTEXTMETRICW lptmW, LPTEXTMETRICA lptmA)
{
        USES_CONVERSION_EX;
        ATLASSERT(lptmW != NULL);
        if (lptmA == NULL || lptmW == NULL)
                return NULL;
        memcpy(lptmW, lptmA, sizeof(LONG) * 11);
        memcpy(&lptmW->tmItalic, &lptmA->tmItalic, sizeof(BYTE) * 5);

        if(MultiByteToWideChar(_acp_ex, 0, (LPCSTR)&lptmA->tmFirstChar, 1, &lptmW->tmFirstChar, 1) == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }
                
        if(MultiByteToWideChar(_acp_ex, 0, (LPCSTR)&lptmA->tmLastChar, 1, &lptmW->tmLastChar, 1) == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }
                
        if(MultiByteToWideChar(_acp_ex, 0, (LPCSTR)&lptmA->tmDefaultChar, 1, &lptmW->tmDefaultChar, 1)== 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }
                
        if(MultiByteToWideChar(_acp_ex, 0, (LPCSTR)&lptmA->tmBreakChar, 1, &lptmW->tmBreakChar, 1) == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }
        
        return lptmW;
}

inline LPTEXTMETRICA AtlTextMetricW2A(LPTEXTMETRICA lptmA, LPTEXTMETRICW lptmW)
{
        USES_CONVERSION_EX;
        ATLASSERT(lptmA != NULL);
        if (lptmW == NULL || lptmA == NULL)
                return NULL;
        memcpy(lptmA, lptmW, sizeof(LONG) * 11);
        memcpy(&lptmA->tmItalic, &lptmW->tmItalic, sizeof(BYTE) * 5);
        
        if(WideCharToMultiByte(_acp_ex, 0, &lptmW->tmFirstChar, 1, (LPSTR)&lptmA->tmFirstChar, 1, NULL, NULL) == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }

        if(WideCharToMultiByte(_acp_ex, 0, &lptmW->tmLastChar, 1, (LPSTR)&lptmA->tmLastChar, 1, NULL, NULL) == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }

        if(WideCharToMultiByte(_acp_ex, 0, &lptmW->tmDefaultChar, 1, (LPSTR)&lptmA->tmDefaultChar, 1, NULL, NULL) == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }

        if(WideCharToMultiByte(_acp_ex, 0, &lptmW->tmBreakChar, 1, (LPSTR)&lptmA->tmBreakChar, 1, NULL, NULL) == 0)
        {
                ATLASSERT(FALSE);
                return NULL;
        }

        return lptmA;
}

#ifndef ATLDEVMODEA2W
#define ATLDEVMODEA2W AtlDevModeA2W
#define ATLDEVMODEW2A AtlDevModeW2A
#define ATLTEXTMETRICA2W AtlTextMetricA2W
#define ATLTEXTMETRICW2A AtlTextMetricW2A
#endif

// Requires USES_CONVERSION_EX or USES_ATL_SAFE_ALLOCA macro before using the _EX versions of the macros
#define DEVMODEW2A_EX(lpw)\
        ((lpw == NULL) ? NULL : ATLDEVMODEW2A((LPDEVMODEA)_ATL_SAFE_ALLOCA(sizeof(DEVMODEA)+lpw->dmDriverExtra, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), lpw))
#define DEVMODEA2W_EX(lpa)\
        ((lpa == NULL) ? NULL : ATLDEVMODEA2W((LPDEVMODEW)_ATL_SAFE_ALLOCA(sizeof(DEVMODEW)+lpa->dmDriverExtra, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), lpa))
#define TEXTMETRICW2A_EX(lptmw)\
        ((lptmw == NULL) ? NULL : ATLTEXTMETRICW2A((LPTEXTMETRICA)_ATL_SAFE_ALLOCA(sizeof(TEXTMETRICA), _ATL_SAFE_ALLOCA_DEF_THRESHOLD), lptmw))
#define TEXTMETRICA2W_EX(lptma)\
        ((lptma == NULL) ? NULL : ATLTEXTMETRICA2W((LPTEXTMETRICW)_ATL_SAFE_ALLOCA(sizeof(TEXTMETRICW), _ATL_SAFE_ALLOCA_DEF_THRESHOLD), lptma))

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#define DEVMODEW2A(lpw)\
        ((lpw == NULL) ? NULL : ATLDEVMODEW2A((LPDEVMODEA)alloca(sizeof(DEVMODEA)+lpw->dmDriverExtra), lpw))
#define DEVMODEA2W(lpa)\
        ((lpa == NULL) ? NULL : ATLDEVMODEA2W((LPDEVMODEW)alloca(sizeof(DEVMODEW)+lpa->dmDriverExtra), lpa))
#define TEXTMETRICW2A(lptmw)\
        ((lptmw == NULL) ? NULL : ATLTEXTMETRICW2A((LPTEXTMETRICA)alloca(sizeof(TEXTMETRICA)), lptmw))
#define TEXTMETRICA2W(lptma)\
        ((lptma == NULL) ? NULL : ATLTEXTMETRICA2W((LPTEXTMETRICW)alloca(sizeof(TEXTMETRICW)), lptma))
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#ifdef OLE2ANSI
        #define DEVMODEOLE DEVMODEA
        #define LPDEVMODEOLE LPDEVMODEA
        #define TEXTMETRICOLE TEXTMETRICA
        #define LPTEXTMETRICOLE LPTEXTMETRICA
#else
        #define DEVMODEOLE DEVMODEW
        #define LPDEVMODEOLE LPDEVMODEW
        #define TEXTMETRICOLE TEXTMETRICW
        #define LPTEXTMETRICOLE LPTEXTMETRICW
#endif

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
        inline LPDEVMODEW DEVMODEOLE2T_EX(LPDEVMODEOLE lp) { return lp; }
        inline LPDEVMODEOLE DEVMODET2OLE_EX(LPDEVMODEW lp) { return lp; }
        inline LPTEXTMETRICW TEXTMETRICOLE2T_EX(LPTEXTMETRICOLE lp) { return lp; }
        inline LPTEXTMETRICOLE TEXTMETRICT2OLE_EX(LPTEXTMETRICW lp) { return lp; }

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline LPDEVMODEW DEVMODEOLE2T(LPDEVMODEOLE lp) { return lp; }
        inline LPDEVMODEOLE DEVMODET2OLE(LPDEVMODEW lp) { return lp; }
        inline LPTEXTMETRICW TEXTMETRICOLE2T(LPTEXTMETRICOLE lp) { return lp; }
        inline LPTEXTMETRICOLE TEXTMETRICT2OLE(LPTEXTMETRICW lp) { return lp; }
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY
        
#elif defined(OLE2ANSI)
// in these cases the default (TCHAR) is the same as OLECHAR
        inline LPDEVMODE DEVMODEOLE2T_EX(LPDEVMODEOLE lp) { return lp; }
        inline LPDEVMODEOLE DEVMODET2OLE_EX(LPDEVMODE lp) { return lp; }
        inline LPTEXTMETRIC TEXTMETRICOLE2T_EX(LPTEXTMETRICOLE lp) { return lp; }
        inline LPTEXTMETRICOLE TEXTMETRICT2OLE_EX(LPTEXTMETRIC lp) { return lp; }

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        inline LPDEVMODE DEVMODEOLE2T(LPDEVMODEOLE lp) { return lp; }
        inline LPDEVMODEOLE DEVMODET2OLE(LPDEVMODE lp) { return lp; }
        inline LPTEXTMETRIC TEXTMETRICOLE2T(LPTEXTMETRICOLE lp) { return lp; }
        inline LPTEXTMETRICOLE TEXTMETRICT2OLE(LPTEXTMETRIC lp) { return lp; }
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#else
        #define DEVMODEOLE2T_EX(lpo) DEVMODEW2A_EX(lpo)
        #define DEVMODET2OLE_EX(lpa) DEVMODEA2W_EX(lpa)
        #define TEXTMETRICOLE2T_EX(lptmw) TEXTMETRICW2A_EX(lptmw)
        #define TEXTMETRICT2OLE_EX(lptma) TEXTMETRICA2W_EX(lptma)

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

        #define DEVMODEOLE2T(lpo) DEVMODEW2A(lpo)
        #define DEVMODET2OLE(lpa) DEVMODEA2W(lpa)
        #define TEXTMETRICOLE2T(lptmw) TEXTMETRICW2A(lptmw)
        #define TEXTMETRICT2OLE(lptma) TEXTMETRICA2W(lptma)
        
#endif        // _ATL_EX_CONVERSION_MACROS_ONLY

#endif

#endif //_WINGDI_

#pragma pack(pop)

#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLCONV_IMPL
#endif
#endif

#endif // __ATLCONV_H__

/////////////////////////////////////////////////////////////////////////////

#ifdef _ATLCONV_IMPL

#ifdef _WINGDI_

ATLINLINE ATLAPI_(LPDEVMODEA) AtlDevModeW2A(LPDEVMODEA lpDevModeA, LPDEVMODEW lpDevModeW)
{
        USES_CONVERSION_EX;
        ATLASSERT(lpDevModeA != NULL);
        if (lpDevModeW == NULL || lpDevModeA == NULL)
                return NULL;
        AtlW2AHelper((LPSTR)lpDevModeA->dmDeviceName, lpDevModeW->dmDeviceName, 32, _acp_ex);
        memcpy(&lpDevModeA->dmSpecVersion, &lpDevModeW->dmSpecVersion,
                offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion));
        AtlW2AHelper((LPSTR)lpDevModeA->dmFormName, lpDevModeW->dmFormName, 32, _acp_ex);
        memcpy(&lpDevModeA->dmLogPixels, &lpDevModeW->dmLogPixels,
                sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels));
        if (lpDevModeW->dmDriverExtra != 0)
                memcpy(lpDevModeA+1, lpDevModeW+1, lpDevModeW->dmDriverExtra);
        lpDevModeA->dmSize = sizeof(DEVMODEA);
        return lpDevModeA;
}

#endif //_WINGDI

//Prevent pulling in second time
#undef _ATLCONV_IMPL

#endif // _ATLCONV_IMPL
#define _ATL_NO_CONVERSIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\mfc42\afxwin2.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXWIN.H (part 2)

#ifdef _AFXWIN_INLINE

// CWnd
_AFXWIN_INLINE CWnd::operator HWND() const
        { return this == NULL ? NULL : m_hWnd; }
_AFXWIN_INLINE BOOL CWnd::operator==(const CWnd& wnd) const
        { return ((HWND) wnd) == m_hWnd; }
_AFXWIN_INLINE BOOL CWnd::operator!=(const CWnd& wnd) const
        { return ((HWND) wnd) != m_hWnd; }
_AFXWIN_INLINE HWND CWnd::GetSafeHwnd() const
        { return this == NULL ? NULL : m_hWnd; }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE DWORD CWnd::GetStyle() const
        { ASSERT(::IsWindow(m_hWnd)); return (DWORD)GetWindowLong(m_hWnd, GWL_STYLE); }
_AFXWIN_INLINE DWORD CWnd::GetExStyle() const
        { ASSERT(::IsWindow(m_hWnd)); return (DWORD)GetWindowLong(m_hWnd, GWL_EXSTYLE); }
_AFXWIN_INLINE BOOL CWnd::ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags)
        { ASSERT(::IsWindow(m_hWnd)); return ModifyStyle(m_hWnd, dwRemove, dwAdd, nFlags); }
_AFXWIN_INLINE BOOL CWnd::ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags)
        { ASSERT(::IsWindow(m_hWnd)); return ModifyStyleEx(m_hWnd, dwRemove, dwAdd, nFlags); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* CWnd::GetOwner() const
        { return m_hWndOwner != NULL ? CWnd::FromHandle(m_hWndOwner) : GetParent(); }
_AFXWIN_INLINE void CWnd::SetOwner(CWnd* pOwnerWnd)
        { m_hWndOwner = pOwnerWnd != NULL ? pOwnerWnd->m_hWnd : NULL; }
_AFXWIN_INLINE LRESULT CWnd::SendMessage(UINT message, WPARAM wParam, LPARAM lParam)
        { ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, message, wParam, lParam); }
_AFXWIN_INLINE BOOL CWnd::PostMessage(UINT message, WPARAM wParam, LPARAM lParam)
        { ASSERT(::IsWindow(m_hWnd)); return ::PostMessage(m_hWnd, message, wParam, lParam); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE void CWnd::SetWindowText(LPCTSTR lpszString)
        { ASSERT(::IsWindow(m_hWnd)); ::SetWindowText(m_hWnd, lpszString); }
_AFXWIN_INLINE int CWnd::GetWindowText(LPTSTR lpszString, int nMaxCount) const
        { ASSERT(::IsWindow(m_hWnd)); return ::GetWindowText(m_hWnd, lpszString, nMaxCount); }
_AFXWIN_INLINE int CWnd::GetWindowTextLength() const
        { ASSERT(::IsWindow(m_hWnd)); return ::GetWindowTextLength(m_hWnd); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE void CWnd::SetFont(CFont* pFont, BOOL bRedraw)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_SETFONT, (WPARAM)pFont->GetSafeHandle(), bRedraw); }
_AFXWIN_INLINE CFont* CWnd::GetFont() const
        { ASSERT(::IsWindow(m_hWnd)); return CFont::FromHandle(
                (HFONT)::SendMessage(m_hWnd, WM_GETFONT, 0, 0)); }
_AFXWIN_INLINE CMenu* CWnd::GetMenu() const
        { ASSERT(::IsWindow(m_hWnd)); return CMenu::FromHandle(::GetMenu(m_hWnd)); }
_AFXWIN_INLINE BOOL CWnd::SetMenu(CMenu* pMenu)
        { ASSERT(::IsWindow(m_hWnd)); return ::SetMenu(m_hWnd, pMenu->GetSafeHmenu()); }
_AFXWIN_INLINE void CWnd::DrawMenuBar()
        { ASSERT(::IsWindow(m_hWnd)); ::DrawMenuBar(m_hWnd); }
_AFXWIN_INLINE CMenu* CWnd::GetSystemMenu(BOOL bRevert) const
        { ASSERT(::IsWindow(m_hWnd)); return CMenu::FromHandle(::GetSystemMenu(m_hWnd, bRevert)); }
_AFXWIN_INLINE BOOL CWnd::HiliteMenuItem(CMenu* pMenu, UINT nIDHiliteItem, UINT nHilite)
        { ASSERT(::IsWindow(m_hWnd)); return ::HiliteMenuItem(m_hWnd, pMenu->m_hMenu, nIDHiliteItem, nHilite); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE int CWnd::GetDlgCtrlID() const
        { ASSERT(::IsWindow(m_hWnd)); return ::GetDlgCtrlID(m_hWnd); }
_AFXWIN_INLINE int CWnd::SetDlgCtrlID(int nID)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SetWindowLong(m_hWnd, GWL_ID, nID); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE BOOL CWnd::IsIconic() const
        { ASSERT(::IsWindow(m_hWnd)); return ::IsIconic(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::IsZoomed() const
        { ASSERT(::IsWindow(m_hWnd)); return ::IsZoomed(m_hWnd); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE void CWnd::MoveWindow(int x, int y, int nWidth, int nHeight, BOOL bRepaint)
        { ASSERT(::IsWindow(m_hWnd)); ::MoveWindow(m_hWnd, x, y, nWidth, nHeight, bRepaint); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE void CWnd::MoveWindow(LPCRECT lpRect, BOOL bRepaint)
        { MoveWindow(lpRect->left, lpRect->top, lpRect->right - lpRect->left,
                lpRect->bottom - lpRect->top, bRepaint); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE BOOL CWnd::SetWindowPos(const CWnd* pWndInsertAfter, int x, int y, int cx, int cy, UINT nFlags)
        { ASSERT(::IsWindow(m_hWnd)); return ::SetWindowPos(m_hWnd, pWndInsertAfter->GetSafeHwnd(),
                x, y, cx, cy, nFlags); }
#endif //_AFX_NO_OCC_SUPPORT

#ifndef WS_EX_NOINHERITLAYOUT
#define WS_EX_NOINHERITLAYOUT                   0x00100000L // Disable inheritence of mirroring by children
#endif
#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL                         0x00400000L // Right to left mirroring
#endif
#ifndef NOMIRRORBITMAP
#define NOMIRRORBITMAP                          (DWORD)0x80000000 /* Do not Mirror the bitmap in this call*/
#endif
#ifndef LAYOUT_RTL
#define LAYOUT_RTL                              0x00000001 // Right to left
#endif
#ifndef LAYOUT_BTT
#define LAYOUT_BTT                              0x00000002 // Bottom to top
#endif
#ifndef LAYOUT_VBH
#define LAYOUT_VBH                              0x00000004 // Vertical before horizontal
#endif
#ifndef LAYOUT_ORIENTATIONMASK
#define LAYOUT_ORIENTATIONMASK                  LAYOUT_RTL | LAYOUT_BTT | LAYOUT_VBH
#endif
#ifndef LAYOUT_BITMAPORIENTATIONPRESERVED
#define LAYOUT_BITMAPORIENTATIONPRESERVED       0x00000008
#endif

_AFXWIN_INLINE UINT CWnd::ArrangeIconicWindows()
        { ASSERT(::IsWindow(m_hWnd)); return ::ArrangeIconicWindows(m_hWnd); }
_AFXWIN_INLINE int CWnd::SetWindowRgn(HRGN hRgn, BOOL bRedraw)
        { ASSERT(::IsWindow(m_hWnd)); return ::SetWindowRgn(m_hWnd, hRgn, bRedraw); }
_AFXWIN_INLINE int CWnd::GetWindowRgn(HRGN hRgn) const
        { ASSERT(::IsWindow(m_hWnd) && hRgn != NULL); return ::GetWindowRgn(m_hWnd, hRgn); }
_AFXWIN_INLINE void CWnd::BringWindowToTop()
        { ASSERT(::IsWindow(m_hWnd)); ::BringWindowToTop(m_hWnd); }
_AFXWIN_INLINE void CWnd::GetWindowRect(LPRECT lpRect) const
        { ASSERT(::IsWindow(m_hWnd)); ::GetWindowRect(m_hWnd, lpRect); }
_AFXWIN_INLINE void CWnd::GetClientRect(LPRECT lpRect) const
        { ASSERT(::IsWindow(m_hWnd)); ::GetClientRect(m_hWnd, lpRect); }
_AFXWIN_INLINE void CWnd::MapWindowPoints(CWnd* pwndTo, LPPOINT lpPoint, UINT nCount) const
        { ASSERT(::IsWindow(m_hWnd)); ::MapWindowPoints(m_hWnd, pwndTo->GetSafeHwnd(), lpPoint, nCount); }
_AFXWIN_INLINE void CWnd::MapWindowPoints(CWnd* pwndTo, LPRECT lpRect) const
        { ASSERT(::IsWindow(m_hWnd)); ::MapWindowPoints(m_hWnd, pwndTo->GetSafeHwnd(), (LPPOINT)lpRect, 2); }
_AFXWIN_INLINE void CWnd::ClientToScreen(LPPOINT lpPoint) const
        { ASSERT(::IsWindow(m_hWnd)); ::ClientToScreen(m_hWnd, lpPoint); }
_AFXWIN_INLINE void CWnd::ClientToScreen(LPRECT lpRect) const
        { ASSERT(::IsWindow(m_hWnd)); ::ClientToScreen(m_hWnd, (LPPOINT)lpRect);
                ::ClientToScreen(m_hWnd, ((LPPOINT)lpRect)+1);
                if (GetExStyle() & WS_EX_LAYOUTRTL)
                        CRect::SwapLeftRight(lpRect); }
_AFXWIN_INLINE void CWnd::ScreenToClient(LPPOINT lpPoint) const
        { ASSERT(::IsWindow(m_hWnd)); ::ScreenToClient(m_hWnd, lpPoint); }
_AFXWIN_INLINE void CWnd::ScreenToClient(LPRECT lpRect) const
        { ASSERT(::IsWindow(m_hWnd)); ::ScreenToClient(m_hWnd, (LPPOINT)lpRect);
                ::ScreenToClient(m_hWnd, ((LPPOINT)lpRect)+1);
                if (GetExStyle() & WS_EX_LAYOUTRTL)
                        CRect::SwapLeftRight(lpRect); }
_AFXWIN_INLINE CDC* CWnd::BeginPaint(LPPAINTSTRUCT lpPaint)
        { ASSERT(::IsWindow(m_hWnd)); return CDC::FromHandle(::BeginPaint(m_hWnd, lpPaint)); }
_AFXWIN_INLINE void CWnd::EndPaint(LPPAINTSTRUCT lpPaint)
        { ASSERT(::IsWindow(m_hWnd)); ::EndPaint(m_hWnd, lpPaint); }
_AFXWIN_INLINE CDC* CWnd::GetDC()
        { ASSERT(::IsWindow(m_hWnd)); return CDC::FromHandle(::GetDC(m_hWnd)); }
_AFXWIN_INLINE CDC* CWnd::GetWindowDC()
        { ASSERT(::IsWindow(m_hWnd)); return CDC::FromHandle(::GetWindowDC(m_hWnd)); }
_AFXWIN_INLINE int CWnd::ReleaseDC(CDC* pDC)
        { ASSERT(::IsWindow(m_hWnd)); return ::ReleaseDC(m_hWnd, pDC->m_hDC); }
_AFXWIN_INLINE void CWnd::UpdateWindow()
        { ASSERT(::IsWindow(m_hWnd)); ::UpdateWindow(m_hWnd); }
_AFXWIN_INLINE void CWnd::SetRedraw(BOOL bRedraw)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_SETREDRAW, bRedraw, 0); }
_AFXWIN_INLINE BOOL CWnd::GetUpdateRect(LPRECT lpRect, BOOL bErase)
        { ASSERT(::IsWindow(m_hWnd)); return ::GetUpdateRect(m_hWnd, lpRect, bErase); }
_AFXWIN_INLINE int CWnd::GetUpdateRgn(CRgn* pRgn, BOOL bErase)
        { ASSERT(::IsWindow(m_hWnd)); return ::GetUpdateRgn(m_hWnd, (HRGN)pRgn->GetSafeHandle(), bErase); }
_AFXWIN_INLINE void CWnd::Invalidate(BOOL bErase)
        { ASSERT(::IsWindow(m_hWnd)); ::InvalidateRect(m_hWnd, NULL, bErase); }
_AFXWIN_INLINE void CWnd::InvalidateRect(LPCRECT lpRect, BOOL bErase)
        { ASSERT(::IsWindow(m_hWnd)); ::InvalidateRect(m_hWnd, lpRect, bErase); }
_AFXWIN_INLINE void CWnd::InvalidateRgn(CRgn* pRgn, BOOL bErase)
        { ASSERT(::IsWindow(m_hWnd)); ::InvalidateRgn(m_hWnd, (HRGN)pRgn->GetSafeHandle(), bErase); }
_AFXWIN_INLINE void CWnd::ValidateRect(LPCRECT lpRect)
        { ASSERT(::IsWindow(m_hWnd)); ::ValidateRect(m_hWnd, lpRect); }
_AFXWIN_INLINE void CWnd::ValidateRgn(CRgn* pRgn)
        { ASSERT(::IsWindow(m_hWnd)); ::ValidateRgn(m_hWnd, (HRGN)pRgn->GetSafeHandle()); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE BOOL CWnd::ShowWindow(int nCmdShow)
        { ASSERT(::IsWindow(m_hWnd)); return ::ShowWindow(m_hWnd, nCmdShow); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE BOOL CWnd::IsWindowVisible() const
        { ASSERT(::IsWindow(m_hWnd)); return ::IsWindowVisible(m_hWnd); }
_AFXWIN_INLINE void CWnd::ShowOwnedPopups(BOOL bShow)
        { ASSERT(::IsWindow(m_hWnd)); ::ShowOwnedPopups(m_hWnd, bShow); }
_AFXWIN_INLINE void CWnd::SendMessageToDescendants(
        UINT message, WPARAM wParam, LPARAM lParam, BOOL bDeep, BOOL bOnlyPerm)
        { ASSERT(::IsWindow(m_hWnd)); CWnd::SendMessageToDescendants(m_hWnd, message, wParam, lParam, bDeep,
                bOnlyPerm); }
_AFXWIN_INLINE CWnd* CWnd::GetDescendantWindow(int nID, BOOL bOnlyPerm) const
        { ASSERT(::IsWindow(m_hWnd)); return CWnd::GetDescendantWindow(m_hWnd, nID, bOnlyPerm); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE BOOL CWnd::IsDialogMessage(LPMSG lpMsg)
        { ASSERT(::IsWindow(m_hWnd)); return ::IsDialogMessage(m_hWnd, lpMsg); }
#endif

_AFXWIN_INLINE CDC* CWnd::GetDCEx(CRgn* prgnClip, DWORD flags)
        { ASSERT(::IsWindow(m_hWnd)); return CDC::FromHandle(::GetDCEx(m_hWnd, (HRGN)prgnClip->GetSafeHandle(), flags)); }
_AFXWIN_INLINE BOOL CWnd::LockWindowUpdate()
        { ASSERT(::IsWindow(m_hWnd)); return ::LockWindowUpdate(m_hWnd); }
_AFXWIN_INLINE void CWnd::UnlockWindowUpdate()
        { ASSERT(::IsWindow(m_hWnd)); ::LockWindowUpdate(NULL); }
_AFXWIN_INLINE BOOL CWnd::RedrawWindow(LPCRECT lpRectUpdate, CRgn* prgnUpdate,
        UINT flags)
        { ASSERT(::IsWindow(m_hWnd)); return ::RedrawWindow(m_hWnd, lpRectUpdate, (HRGN)prgnUpdate->GetSafeHandle(), flags); }
_AFXWIN_INLINE BOOL CWnd::EnableScrollBar(int nSBFlags, UINT nArrowFlags)
        { ASSERT(::IsWindow(m_hWnd)); return (BOOL)::EnableScrollBar(m_hWnd, nSBFlags, nArrowFlags); }

_AFXWIN_INLINE UINT_PTR CWnd::SetTimer(UINT_PTR nIDEvent, UINT nElapse,
                void (CALLBACK* lpfnTimer)(HWND, UINT, UINT_PTR, DWORD))
        { ASSERT(::IsWindow(m_hWnd)); return ::SetTimer(m_hWnd, nIDEvent, nElapse,
                (TIMERPROC)lpfnTimer); }
_AFXWIN_INLINE BOOL CWnd::KillTimer(UINT_PTR nIDEvent)
        { ASSERT(::IsWindow(m_hWnd)); return ::KillTimer(m_hWnd, nIDEvent); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE BOOL CWnd::IsWindowEnabled() const
        { ASSERT(::IsWindow(m_hWnd)); return ::IsWindowEnabled(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::EnableWindow(BOOL bEnable)
        { ASSERT(::IsWindow(m_hWnd)); return ::EnableWindow(m_hWnd, bEnable); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetActiveWindow()
        { return CWnd::FromHandle(::GetActiveWindow()); }
_AFXWIN_INLINE CWnd* CWnd::SetActiveWindow()
        { ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::SetActiveWindow(m_hWnd)); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetCapture()
        { return CWnd::FromHandle(::GetCapture()); }
_AFXWIN_INLINE CWnd* CWnd::SetCapture()
        { ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::SetCapture(m_hWnd)); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetFocus()
        { return CWnd::FromHandle(::GetFocus()); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* CWnd::SetFocus()
        { ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::SetFocus(m_hWnd)); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetDesktopWindow()
        { return CWnd::FromHandle(::GetDesktopWindow()); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE void CWnd::CheckDlgButton(int nIDButton, UINT nCheck)
        { ASSERT(::IsWindow(m_hWnd)); ::CheckDlgButton(m_hWnd, nIDButton, nCheck); }
_AFXWIN_INLINE void CWnd::CheckRadioButton(int nIDFirstButton, int nIDLastButton,
                int nIDCheckButton)
        { ASSERT(::IsWindow(m_hWnd)); ::CheckRadioButton(m_hWnd, nIDFirstButton, nIDLastButton, nIDCheckButton); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE int CWnd::DlgDirList(LPTSTR lpPathSpec, int nIDListBox,
                int nIDStaticPath, UINT nFileType)
        { ASSERT(::IsWindow(m_hWnd)); return ::DlgDirList(m_hWnd, lpPathSpec, nIDListBox,
                        nIDStaticPath, nFileType); }
_AFXWIN_INLINE int CWnd::DlgDirListComboBox(LPTSTR lpPathSpec, int nIDComboBox,
                int nIDStaticPath, UINT nFileType)
        { ASSERT(::IsWindow(m_hWnd)); return ::DlgDirListComboBox(m_hWnd, lpPathSpec,
                        nIDComboBox, nIDStaticPath, nFileType); }
_AFXWIN_INLINE BOOL CWnd::DlgDirSelect(LPTSTR lpString, int nIDListBox)
        { ASSERT(::IsWindow(m_hWnd)); return ::DlgDirSelectEx(m_hWnd, lpString, _MAX_PATH, nIDListBox); }
_AFXWIN_INLINE BOOL CWnd::DlgDirSelectComboBox(LPTSTR lpString, int nIDComboBox)
        { ASSERT(::IsWindow(m_hWnd)); return ::DlgDirSelectComboBoxEx(m_hWnd, lpString, _MAX_PATH, nIDComboBox);}
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* CWnd::GetDlgItem(int nID) const
        { ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetDlgItem(m_hWnd, nID)); }
_AFXWIN_INLINE void CWnd::GetDlgItem(int nID, HWND* phWnd) const
        { ASSERT(::IsWindow(m_hWnd)); ASSERT(phWnd != NULL); *phWnd = ::GetDlgItem(m_hWnd, nID); }
_AFXWIN_INLINE UINT CWnd::GetDlgItemInt(int nID, BOOL* lpTrans,
                BOOL bSigned) const
        { ASSERT(::IsWindow(m_hWnd)); return ::GetDlgItemInt(m_hWnd, nID, lpTrans, bSigned);}
_AFXWIN_INLINE int CWnd::GetDlgItemText(int nID, LPTSTR lpStr, int nMaxCount) const
        { ASSERT(::IsWindow(m_hWnd)); return ::GetDlgItemText(m_hWnd, nID, lpStr, nMaxCount);}
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* CWnd::GetNextDlgGroupItem(CWnd* pWndCtl, BOOL bPrevious) const
        { ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetNextDlgGroupItem(m_hWnd,
                        pWndCtl->GetSafeHwnd(), bPrevious)); }
_AFXWIN_INLINE CWnd* CWnd::GetNextDlgTabItem(CWnd* pWndCtl, BOOL bPrevious) const
        { ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetNextDlgTabItem(m_hWnd,
                        pWndCtl->GetSafeHwnd(), bPrevious)); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE UINT CWnd::IsDlgButtonChecked(int nIDButton) const
        { ASSERT(::IsWindow(m_hWnd)); return ::IsDlgButtonChecked(m_hWnd, nIDButton); }
_AFXWIN_INLINE LPARAM CWnd::SendDlgItemMessage(int nID, UINT message, WPARAM wParam, LPARAM lParam)
        { ASSERT(::IsWindow(m_hWnd)); return ::SendDlgItemMessage(m_hWnd, nID, message, wParam, lParam); }
_AFXWIN_INLINE void CWnd::SetDlgItemInt(int nID, UINT nValue, BOOL bSigned)
        { ASSERT(::IsWindow(m_hWnd)); ::SetDlgItemInt(m_hWnd, nID, nValue, bSigned); }
_AFXWIN_INLINE void CWnd::SetDlgItemText(int nID, LPCTSTR lpszString)
        { ASSERT(::IsWindow(m_hWnd)); ::SetDlgItemText(m_hWnd, nID, lpszString); }
_AFXWIN_INLINE int CWnd::ScrollWindowEx(int dx, int dy,
        LPCRECT lpRectScroll, LPCRECT lpRectClip,
        CRgn* prgnUpdate, LPRECT lpRectUpdate, UINT flags)
        { ASSERT(::IsWindow(m_hWnd)); return ::ScrollWindowEx(m_hWnd, dx, dy, lpRectScroll, lpRectClip,
                        (HRGN)prgnUpdate->GetSafeHandle(), lpRectUpdate, flags); }
#endif //_AFX_NO_OCC_SUPPORT

_AFXWIN_INLINE void CWnd::ShowScrollBar(UINT nBar, BOOL bShow)
        { ASSERT(::IsWindow(m_hWnd)); ::ShowScrollBar(m_hWnd, nBar, bShow); }
_AFXWIN_INLINE CWnd* CWnd::ChildWindowFromPoint(POINT point) const
        { ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::ChildWindowFromPoint(m_hWnd, point)); }
_AFXWIN_INLINE CWnd* CWnd::ChildWindowFromPoint(POINT point, UINT nFlags) const
        { ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::ChildWindowFromPointEx(m_hWnd, point, nFlags)); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::FindWindow(LPCTSTR lpszClassName, LPCTSTR lpszWindowName)
        { return CWnd::FromHandle(::FindWindow(lpszClassName, lpszWindowName)); }
_AFXWIN_INLINE CWnd* CWnd::GetNextWindow(UINT nFlag) const
        { ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetNextWindow(m_hWnd, nFlag)); }
_AFXWIN_INLINE CWnd* CWnd::GetTopWindow() const
        { ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetTopWindow(m_hWnd)); }
_AFXWIN_INLINE CWnd* CWnd::GetWindow(UINT nCmd) const
        { ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetWindow(m_hWnd, nCmd)); }
_AFXWIN_INLINE CWnd* CWnd::GetLastActivePopup() const
        { ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetLastActivePopup(m_hWnd)); }
_AFXWIN_INLINE BOOL CWnd::IsChild(const CWnd* pWnd) const
        { ASSERT(::IsWindow(m_hWnd)); return ::IsChild(m_hWnd, pWnd->GetSafeHwnd()); }
_AFXWIN_INLINE CWnd* CWnd::GetParent() const
        { ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetParent(m_hWnd)); }
_AFXWIN_INLINE CWnd* CWnd::SetParent(CWnd* pWndNewParent)
        { ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::SetParent(m_hWnd,
                        pWndNewParent->GetSafeHwnd())); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::WindowFromPoint(POINT point)
        { return CWnd::FromHandle(::WindowFromPoint(point)); }
_AFXWIN_INLINE BOOL CWnd::FlashWindow(BOOL bInvert)
        { ASSERT(::IsWindow(m_hWnd)); return ::FlashWindow(m_hWnd, bInvert); }
_AFXWIN_INLINE BOOL CWnd::ChangeClipboardChain(HWND hWndNext)
        { ASSERT(::IsWindow(m_hWnd)); return ::ChangeClipboardChain(m_hWnd, hWndNext); }
_AFXWIN_INLINE HWND CWnd::SetClipboardViewer()
        { ASSERT(::IsWindow(m_hWnd)); return ::SetClipboardViewer(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::OpenClipboard()
        { ASSERT(::IsWindow(m_hWnd)); return ::OpenClipboard(m_hWnd); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetOpenClipboardWindow()
        { return CWnd::FromHandle(::GetOpenClipboardWindow()); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetClipboardOwner()
        { return CWnd::FromHandle(::GetClipboardOwner()); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetClipboardViewer()
        { return CWnd::FromHandle(::GetClipboardViewer()); }
_AFXWIN_INLINE void CWnd::CreateCaret(CBitmap* pBitmap)
        { ASSERT(::IsWindow(m_hWnd)); ::CreateCaret(m_hWnd, (HBITMAP)pBitmap->GetSafeHandle(), 0, 0); }
_AFXWIN_INLINE void CWnd::CreateSolidCaret(int nWidth, int nHeight)
        { ASSERT(::IsWindow(m_hWnd)); ::CreateCaret(m_hWnd, (HBITMAP)0, nWidth, nHeight); }
_AFXWIN_INLINE void CWnd::CreateGrayCaret(int nWidth, int nHeight)
        { ASSERT(::IsWindow(m_hWnd)); ::CreateCaret(m_hWnd, (HBITMAP)1, nWidth, nHeight); }
_AFXWIN_INLINE CPoint PASCAL CWnd::GetCaretPos()
        { CPoint point; ::GetCaretPos((LPPOINT)&point); return point; }
_AFXWIN_INLINE void PASCAL CWnd::SetCaretPos(POINT point)
        { ::SetCaretPos(point.x, point.y); }
_AFXWIN_INLINE void CWnd::HideCaret()
        { ASSERT(::IsWindow(m_hWnd)); ::HideCaret(m_hWnd); }
_AFXWIN_INLINE void CWnd::ShowCaret()
        { ASSERT(::IsWindow(m_hWnd)); ::ShowCaret(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::SetForegroundWindow()
        { ASSERT(::IsWindow(m_hWnd)); return ::SetForegroundWindow(m_hWnd); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetForegroundWindow()
        { return CWnd::FromHandle(::GetForegroundWindow()); }

_AFXWIN_INLINE BOOL CWnd::SendNotifyMessage(UINT message, WPARAM wParam, LPARAM lParam)
        { ASSERT(::IsWindow(m_hWnd)); return ::SendNotifyMessage(m_hWnd, message, wParam, lParam); }

// Win4
_AFXWIN_INLINE HICON CWnd::SetIcon(HICON hIcon, BOOL bBigIcon)
        { ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, WM_SETICON, bBigIcon, (LPARAM)hIcon); }
_AFXWIN_INLINE HICON CWnd::GetIcon(BOOL bBigIcon) const
        { ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, WM_GETICON, bBigIcon, 0); }
_AFXWIN_INLINE void CWnd::Print(CDC* pDC, DWORD dwFlags) const
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PRINT, (WPARAM)pDC->GetSafeHdc(), dwFlags); }
_AFXWIN_INLINE void CWnd::PrintClient(CDC* pDC, DWORD dwFlags) const
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PRINTCLIENT, (WPARAM)pDC->GetSafeHdc(), dwFlags); }
_AFXWIN_INLINE BOOL CWnd::SetWindowContextHelpId(DWORD dwContextHelpId)
        { ASSERT(::IsWindow(m_hWnd)); return ::SetWindowContextHelpId(m_hWnd, dwContextHelpId); }
_AFXWIN_INLINE DWORD CWnd::GetWindowContextHelpId() const
        { ASSERT(::IsWindow(m_hWnd)); return ::GetWindowContextHelpId(m_hWnd); }


// Default message map implementations
_AFXWIN_INLINE void CWnd::OnActivateApp(BOOL, HTASK)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnActivate(UINT, CWnd*, BOOL)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnCancelMode()
        { Default(); }
_AFXWIN_INLINE void CWnd::OnChildActivate()
        { Default(); }
_AFXWIN_INLINE void CWnd::OnClose()
        { Default(); }
_AFXWIN_INLINE void CWnd::OnContextMenu(CWnd*, CPoint)
        { Default(); }
_AFXWIN_INLINE int CWnd::OnCopyData(CWnd*, COPYDATASTRUCT*)
        { return (int)Default(); }
_AFXWIN_INLINE int CWnd::OnCreate(LPCREATESTRUCT)
        { return (int)Default(); }
_AFXWIN_INLINE void CWnd::OnEnable(BOOL)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnEndSession(BOOL)
        { Default(); }
_AFXWIN_INLINE BOOL CWnd::OnEraseBkgnd(CDC*)
        { return (BOOL)Default(); }
_AFXWIN_INLINE void CWnd::OnGetMinMaxInfo(MINMAXINFO*)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnIconEraseBkgnd(CDC*)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnKillFocus(CWnd*)
        { Default(); }
_AFXWIN_INLINE LRESULT CWnd::OnMenuChar(UINT, UINT, CMenu*)
        { return Default(); }
_AFXWIN_INLINE void CWnd::OnMenuSelect(UINT, UINT, HMENU)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnMove(int, int)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnPaint()
        { Default(); }
_AFXWIN_INLINE HCURSOR CWnd::OnQueryDragIcon()
        { return (HCURSOR)Default(); }
_AFXWIN_INLINE BOOL CWnd::OnQueryEndSession()
        { return (BOOL)Default(); }
_AFXWIN_INLINE BOOL CWnd::OnQueryNewPalette()
        { return (BOOL)Default(); }
_AFXWIN_INLINE BOOL CWnd::OnQueryOpen()
        { return (BOOL)Default(); }
_AFXWIN_INLINE BOOL CWnd::OnSetCursor(CWnd*, UINT, UINT)
        { return (BOOL)Default(); }
_AFXWIN_INLINE void CWnd::OnSetFocus(CWnd*)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnShowWindow(BOOL, UINT)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnSize(UINT, int, int)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnTCard(UINT, DWORD)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnWindowPosChanging(WINDOWPOS*)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnWindowPosChanged(WINDOWPOS*)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnDropFiles(HDROP)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnPaletteIsChanging(CWnd*)
        { Default(); }
_AFXWIN_INLINE BOOL CWnd::OnNcActivate(BOOL)
        { return (BOOL)Default(); }
_AFXWIN_INLINE void CWnd::OnNcCalcSize(BOOL, NCCALCSIZE_PARAMS*)
        { Default(); }
_AFXWIN_INLINE BOOL CWnd::OnNcCreate(LPCREATESTRUCT)
        { return (BOOL)Default(); }
_AFXWIN_INLINE UINT CWnd::OnNcHitTest(CPoint)
        { return (UINT)Default(); }
_AFXWIN_INLINE void CWnd::OnNcLButtonDblClk(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnNcLButtonDown(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnNcLButtonUp(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnNcMButtonDblClk(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnNcMButtonDown(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnNcMButtonUp(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnNcMouseMove(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnNcPaint()
        { Default(); }
_AFXWIN_INLINE void CWnd::OnNcRButtonDblClk(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnNcRButtonDown(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnNcRButtonUp(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnSysChar(UINT, UINT, UINT)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnSysCommand(UINT, LPARAM)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnSysDeadChar(UINT, UINT, UINT)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnSysKeyDown(UINT, UINT, UINT)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnSysKeyUp(UINT, UINT, UINT)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnCompacting(UINT)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnFontChange()
        { Default(); }
_AFXWIN_INLINE void CWnd::OnPaletteChanged(CWnd*)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnSpoolerStatus(UINT, UINT)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnTimeChange()
        { Default(); }
_AFXWIN_INLINE void CWnd::OnChar(UINT, UINT, UINT)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnDeadChar(UINT, UINT, UINT)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnKeyDown(UINT, UINT, UINT)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnKeyUp(UINT, UINT, UINT)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnLButtonDblClk(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnLButtonDown(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnLButtonUp(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnMButtonDblClk(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnMButtonDown(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnMButtonUp(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE int CWnd::OnMouseActivate(CWnd*, UINT, UINT)
        { return (int)Default(); }
_AFXWIN_INLINE void CWnd::OnMouseMove(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE BOOL CWnd::OnMouseWheel(UINT, short, CPoint)
        { return (BOOL)Default(); }
_AFXWIN_INLINE LRESULT CWnd::OnRegisteredMouseWheel(WPARAM, LPARAM)
        { return Default(); }
_AFXWIN_INLINE void CWnd::OnRButtonDblClk(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnRButtonDown(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnRButtonUp(UINT, CPoint)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnTimer(UINT_PTR)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnInitMenu(CMenu*)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnInitMenuPopup(CMenu*, UINT, BOOL)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnAskCbFormatName(UINT, LPTSTR)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnChangeCbChain(HWND, HWND)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnDestroyClipboard()
        { Default(); }
_AFXWIN_INLINE void CWnd::OnDrawClipboard()
        { Default(); }
_AFXWIN_INLINE void CWnd::OnHScrollClipboard(CWnd*, UINT, UINT)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnPaintClipboard(CWnd*, HGLOBAL)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnRenderAllFormats()
        { Default(); }
_AFXWIN_INLINE void CWnd::OnRenderFormat(UINT)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnSizeClipboard(CWnd*, HGLOBAL)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnVScrollClipboard(CWnd*, UINT, UINT)
        { Default(); }
_AFXWIN_INLINE UINT CWnd::OnGetDlgCode()
        { return (UINT)Default(); }
_AFXWIN_INLINE void CWnd::OnMDIActivate(BOOL, CWnd*, CWnd*)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnEnterMenuLoop(BOOL)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnExitMenuLoop(BOOL)
        { Default(); }
// Win4 support
_AFXWIN_INLINE void CWnd::OnStyleChanged(int, LPSTYLESTRUCT)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnStyleChanging(int, LPSTYLESTRUCT)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnSizing(UINT, LPRECT)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnMoving(UINT, LPRECT)
        { Default(); }
_AFXWIN_INLINE void CWnd::OnCaptureChanged(CWnd*)
        { Default(); }
_AFXWIN_INLINE BOOL CWnd::OnDeviceChange(UINT, DWORD_PTR)
        { return (BOOL)Default(); }

// CWnd dialog data support
_AFXWIN_INLINE void CWnd::DoDataExchange(CDataExchange*)
        { } // default does nothing

// CWnd modality support
_AFXWIN_INLINE void CWnd::BeginModalState()
        { ::EnableWindow(m_hWnd, FALSE); }
_AFXWIN_INLINE void CWnd::EndModalState()
        { ::EnableWindow(m_hWnd, TRUE); }

// CFrameWnd
_AFXWIN_INLINE void CFrameWnd::DelayUpdateFrameTitle()
        { m_nIdleFlags |= idleTitle; }
_AFXWIN_INLINE void CFrameWnd::DelayRecalcLayout(BOOL bNotify)
        { m_nIdleFlags |= (idleLayout | (bNotify ? idleNotify : 0)); };
_AFXWIN_INLINE BOOL CFrameWnd::InModalState() const
        { return m_cModalStack != 0; }
_AFXWIN_INLINE void CFrameWnd::AddControlBar(CControlBar *pBar)
        { m_listControlBars.AddTail(pBar); }
#if _MFC_VER >= 0x0600
_AFXWIN_INLINE void CFrameWnd::SetTitle(LPCTSTR lpszTitle)
    { m_strTitle = lpszTitle; }
_AFXWIN_INLINE CString CFrameWnd::GetTitle() const
    { return m_strTitle; }
#endif

// CDialog
_AFXWIN_INLINE BOOL CDialog::Create(UINT nIDTemplate, CWnd* pParentWnd)
        { return Create(MAKEINTRESOURCE(nIDTemplate), pParentWnd); }
_AFXWIN_INLINE void CDialog::MapDialogRect(LPRECT lpRect) const
        { ASSERT(::IsWindow(m_hWnd)); ::MapDialogRect(m_hWnd, lpRect); }
_AFXWIN_INLINE void CDialog::SetHelpID(UINT nIDR)
        { m_nIDHelp = nIDR; }
_AFXWIN_INLINE void CDialog::NextDlgCtrl() const
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_NEXTDLGCTL, 0, 0); }
_AFXWIN_INLINE void CDialog::PrevDlgCtrl() const
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_NEXTDLGCTL, 1, 0); }
_AFXWIN_INLINE void CDialog::GotoDlgCtrl(CWnd* pWndCtrl)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_NEXTDLGCTL, (WPARAM)pWndCtrl->m_hWnd, 1L); }
_AFXWIN_INLINE void CDialog::SetDefID(UINT nID)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, DM_SETDEFID, nID, 0); }
_AFXWIN_INLINE DWORD CDialog::GetDefID() const
        { ASSERT(::IsWindow(m_hWnd)); return DWORD(::SendMessage(m_hWnd, DM_GETDEFID, 0, 0)); }

// Window control functions
_AFXWIN_INLINE CStatic::CStatic()
        { }
_AFXWIN_INLINE HICON CStatic::SetIcon(HICON hIcon)
        { ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, STM_SETICON, (WPARAM)hIcon, 0L); }
_AFXWIN_INLINE HICON CStatic::GetIcon() const
        { ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, STM_GETICON, 0, 0L); }
#if (WINVER >= 0x400)
_AFXWIN_INLINE HENHMETAFILE CStatic::SetEnhMetaFile(HENHMETAFILE hMetaFile)
        { ASSERT(::IsWindow(m_hWnd)); return (HENHMETAFILE)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_ENHMETAFILE, (LPARAM)hMetaFile); }
_AFXWIN_INLINE HENHMETAFILE CStatic::GetEnhMetaFile() const
        { ASSERT(::IsWindow(m_hWnd)); return (HENHMETAFILE)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_ENHMETAFILE, 0L); }
_AFXWIN_INLINE HBITMAP CStatic::SetBitmap(HBITMAP hBitmap)
        { ASSERT(::IsWindow(m_hWnd)); return (HBITMAP)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap); }
_AFXWIN_INLINE HBITMAP CStatic::GetBitmap() const
        { ASSERT(::IsWindow(m_hWnd)); return (HBITMAP)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_BITMAP, 0L); }
_AFXWIN_INLINE HCURSOR CStatic::SetCursor(HCURSOR hCursor)
        { ASSERT(::IsWindow(m_hWnd)); return (HCURSOR)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_CURSOR, (LPARAM)hCursor); }
_AFXWIN_INLINE HCURSOR CStatic::GetCursor()
        { ASSERT(::IsWindow(m_hWnd)); return (HCURSOR)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_CURSOR, 0L); }
#endif

_AFXWIN_INLINE CButton::CButton()
        { }
_AFXWIN_INLINE UINT CButton::GetState() const
        { ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, BM_GETSTATE, 0, 0); }
_AFXWIN_INLINE void CButton::SetState(BOOL bHighlight)
        { ::SendMessage(m_hWnd, BM_SETSTATE, bHighlight, 0); }
_AFXWIN_INLINE int CButton::GetCheck() const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, BM_GETCHECK, 0, 0); }
_AFXWIN_INLINE void CButton::SetCheck(int nCheck)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, BM_SETCHECK, nCheck, 0); }
_AFXWIN_INLINE UINT CButton::GetButtonStyle() const
        { ASSERT(::IsWindow(m_hWnd)); return (UINT)GetWindowLong(m_hWnd, GWL_STYLE) & 0xff; }
_AFXWIN_INLINE void CButton::SetButtonStyle(UINT nStyle, BOOL bRedraw)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, BM_SETSTYLE, nStyle, (LPARAM)bRedraw); }
// Win4
#if (WINVER >= 0x400)
_AFXWIN_INLINE HICON CButton::SetIcon(HICON hIcon)
        { ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon); }
_AFXWIN_INLINE HICON CButton::GetIcon() const
        { ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_ICON, 0L); }
_AFXWIN_INLINE HBITMAP CButton::SetBitmap(HBITMAP hBitmap)
        { ASSERT(::IsWindow(m_hWnd)); return (HBITMAP)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap); }
_AFXWIN_INLINE HBITMAP CButton::GetBitmap() const
        { ASSERT(::IsWindow(m_hWnd)); return (HBITMAP)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_BITMAP, 0L); }
_AFXWIN_INLINE HCURSOR CButton::SetCursor(HCURSOR hCursor)
        { ASSERT(::IsWindow(m_hWnd)); return (HCURSOR)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_CURSOR, (LPARAM)hCursor); }
_AFXWIN_INLINE HCURSOR CButton::GetCursor()
        { ASSERT(::IsWindow(m_hWnd)); return (HCURSOR)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_CURSOR, 0L); }
#endif

_AFXWIN_INLINE CListBox::CListBox()
        { }
_AFXWIN_INLINE int CListBox::GetCount() const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0); }
_AFXWIN_INLINE int CListBox::GetCurSel() const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0); }
_AFXWIN_INLINE int CListBox::SetCurSel(int nSelect)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETCURSEL, nSelect, 0); }
_AFXWIN_INLINE int CListBox::GetHorizontalExtent() const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETHORIZONTALEXTENT,
                0, 0); }
_AFXWIN_INLINE void CListBox::SetHorizontalExtent(int cxExtent)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_SETHORIZONTALEXTENT, cxExtent, 0); }
_AFXWIN_INLINE int CListBox::GetSelCount() const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETSELCOUNT, 0, 0); }
_AFXWIN_INLINE int CListBox::GetSelItems(int nMaxItems, LPINT rgIndex) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETSELITEMS, nMaxItems, (LPARAM)rgIndex); }
_AFXWIN_INLINE int CListBox::GetTopIndex() const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETTOPINDEX, 0, 0); }
_AFXWIN_INLINE int CListBox::SetTopIndex(int nIndex)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETTOPINDEX, nIndex, 0);}
_AFXWIN_INLINE DWORD_PTR CListBox::GetItemData(int nIndex) const
        { ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0); }
_AFXWIN_INLINE int CListBox::SetItemData(int nIndex, DWORD_PTR dwItemData)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETITEMDATA, nIndex, (LPARAM)dwItemData); }
_AFXWIN_INLINE void* CListBox::GetItemDataPtr(int nIndex) const
        { ASSERT(::IsWindow(m_hWnd)); return (LPVOID)::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0); }
_AFXWIN_INLINE int CListBox::SetItemDataPtr(int nIndex, void* pData)
        { ASSERT(::IsWindow(m_hWnd)); return SetItemData(nIndex, (DWORD_PTR)(LPVOID)pData); }
_AFXWIN_INLINE int CListBox::GetItemRect(int nIndex, LPRECT lpRect) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETITEMRECT, nIndex, (LPARAM)lpRect); }
_AFXWIN_INLINE int CListBox::GetSel(int nIndex) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETSEL, nIndex, 0); }
_AFXWIN_INLINE int CListBox::SetSel(int nIndex, BOOL bSelect)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETSEL, bSelect, nIndex); }
_AFXWIN_INLINE int CListBox::GetText(int nIndex, LPTSTR lpszBuffer) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETTEXT, nIndex, (LPARAM)lpszBuffer); }
_AFXWIN_INLINE int CListBox::GetTextLen(int nIndex) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETTEXTLEN, nIndex, 0); }
_AFXWIN_INLINE void CListBox::SetColumnWidth(int cxWidth)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_SETCOLUMNWIDTH, cxWidth, 0); }
_AFXWIN_INLINE BOOL CListBox::SetTabStops(int nTabStops, LPINT rgTabStops)
        { ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, nTabStops, (LPARAM)rgTabStops); }
_AFXWIN_INLINE void CListBox::SetTabStops()
        { ASSERT(::IsWindow(m_hWnd)); VERIFY(::SendMessage(m_hWnd, LB_SETTABSTOPS, 0, 0)); }
_AFXWIN_INLINE BOOL CListBox::SetTabStops(const int& cxEachStop)
        { ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, 1, (LPARAM)(LPINT)&cxEachStop); }
_AFXWIN_INLINE int CListBox::SetItemHeight(int nIndex, UINT cyItemHeight)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETITEMHEIGHT, nIndex, MAKELONG(cyItemHeight, 0)); }
_AFXWIN_INLINE int CListBox::GetItemHeight(int nIndex) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETITEMHEIGHT, nIndex, 0L); }
_AFXWIN_INLINE int CListBox::FindStringExact(int nIndexStart, LPCTSTR lpszFind) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind); }
_AFXWIN_INLINE int CListBox::GetCaretIndex() const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCARETINDEX, 0, 0L); }
_AFXWIN_INLINE int CListBox::SetCaretIndex(int nIndex, BOOL bScroll)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETCARETINDEX, nIndex, MAKELONG(bScroll, 0)); }
_AFXWIN_INLINE int CListBox::AddString(LPCTSTR lpszItem)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem); }
_AFXWIN_INLINE int CListBox::DeleteString(UINT nIndex)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_DELETESTRING, nIndex, 0); }
_AFXWIN_INLINE int CListBox::InsertString(int nIndex, LPCTSTR lpszItem)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_INSERTSTRING, nIndex, (LPARAM)lpszItem); }
_AFXWIN_INLINE void CListBox::ResetContent()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_RESETCONTENT, 0, 0); }
_AFXWIN_INLINE int CListBox::Dir(UINT attr, LPCTSTR lpszWildCard)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_DIR, attr, (LPARAM)lpszWildCard); }
_AFXWIN_INLINE int CListBox::FindString(int nStartAfter, LPCTSTR lpszItem) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_FINDSTRING,
                nStartAfter, (LPARAM)lpszItem); }
_AFXWIN_INLINE int CListBox::SelectString(int nStartAfter, LPCTSTR lpszItem)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SELECTSTRING,
                nStartAfter, (LPARAM)lpszItem); }
_AFXWIN_INLINE int CListBox::SelItemRange(BOOL bSelect, int nFirstItem, int nLastItem)
        { ASSERT(::IsWindow(m_hWnd)); return bSelect ?
                (int)::SendMessage(m_hWnd, LB_SELITEMRANGEEX, nFirstItem, nLastItem) :
                (int)::SendMessage(m_hWnd, LB_SELITEMRANGEEX, nLastItem, nFirstItem); }
_AFXWIN_INLINE void CListBox::SetAnchorIndex(int nIndex)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_SETANCHORINDEX, nIndex, 0); }
_AFXWIN_INLINE int CListBox::GetAnchorIndex() const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETANCHORINDEX, 0, 0); }
_AFXWIN_INLINE LCID CListBox::GetLocale() const
        { ASSERT(::IsWindow(m_hWnd)); return (LCID)::SendMessage(m_hWnd, LB_GETLOCALE, 0, 0); }
_AFXWIN_INLINE LCID CListBox::SetLocale(LCID nNewLocale)
        { ASSERT(::IsWindow(m_hWnd)); return (LCID)::SendMessage(m_hWnd, LB_SETLOCALE, (WPARAM)nNewLocale, 0); }
#if (WINVER >= 0x400)
_AFXWIN_INLINE int CListBox::InitStorage(int nItems, UINT nBytes)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_INITSTORAGE, (WPARAM)nItems, nBytes); }
#endif

_AFXWIN_INLINE CCheckListBox::CCheckListBox()
        { m_cyText = 0; m_nStyle = 0; }
_AFXWIN_INLINE UINT CCheckListBox::GetCheckStyle()
        { return m_nStyle; }

_AFXWIN_INLINE CComboBox::CComboBox()
        { }
_AFXWIN_INLINE int CComboBox::GetCount() const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCOUNT, 0, 0); }
_AFXWIN_INLINE int CComboBox::GetCurSel() const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }
_AFXWIN_INLINE int CComboBox::SetCurSel(int nSelect)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETCURSEL, nSelect, 0); }
_AFXWIN_INLINE DWORD CComboBox::GetEditSel() const
        { ASSERT(::IsWindow(m_hWnd)); return DWORD(::SendMessage(m_hWnd, CB_GETEDITSEL, 0, 0)); }
_AFXWIN_INLINE BOOL CComboBox::LimitText(int nMaxChars)
        { ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, CB_LIMITTEXT, nMaxChars, 0); }
_AFXWIN_INLINE BOOL CComboBox::SetEditSel(int nStartChar, int nEndChar)
        { ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, CB_SETEDITSEL, 0, MAKELONG(nStartChar, nEndChar)); }
_AFXWIN_INLINE DWORD_PTR CComboBox::GetItemData(int nIndex) const
        { ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, CB_GETITEMDATA, nIndex, 0); }
_AFXWIN_INLINE int CComboBox::SetItemData(int nIndex, DWORD_PTR dwItemData)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETITEMDATA, nIndex, (LPARAM)dwItemData); }
_AFXWIN_INLINE void* CComboBox::GetItemDataPtr(int nIndex) const
        { ASSERT(::IsWindow(m_hWnd)); return (LPVOID)GetItemData(nIndex); }
_AFXWIN_INLINE int CComboBox::SetItemDataPtr(int nIndex, void* pData)
        { ASSERT(::IsWindow(m_hWnd)); return SetItemData(nIndex, (DWORD_PTR)(LPVOID)pData); }
_AFXWIN_INLINE int CComboBox::GetLBText(int nIndex, LPTSTR lpszText) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETLBTEXT, nIndex, (LPARAM)lpszText); }
_AFXWIN_INLINE int CComboBox::GetLBTextLen(int nIndex) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETLBTEXTLEN, nIndex, 0); }
_AFXWIN_INLINE void CComboBox::ShowDropDown(BOOL bShowIt)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, CB_SHOWDROPDOWN, bShowIt, 0); }
_AFXWIN_INLINE int CComboBox::AddString(LPCTSTR lpszString)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_ADDSTRING, 0, (LPARAM)lpszString); }
_AFXWIN_INLINE int CComboBox::DeleteString(UINT nIndex)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_DELETESTRING, nIndex, 0);}
_AFXWIN_INLINE int CComboBox::InsertString(int nIndex, LPCTSTR lpszString)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_INSERTSTRING, nIndex, (LPARAM)lpszString); }
_AFXWIN_INLINE void CComboBox::ResetContent()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, CB_RESETCONTENT, 0, 0); }
_AFXWIN_INLINE int CComboBox::Dir(UINT attr, LPCTSTR lpszWildCard)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_DIR, attr, (LPARAM)lpszWildCard); }
_AFXWIN_INLINE int CComboBox::FindString(int nStartAfter, LPCTSTR lpszString) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_FINDSTRING, nStartAfter,
                (LPARAM)lpszString); }
_AFXWIN_INLINE int CComboBox::SelectString(int nStartAfter, LPCTSTR lpszString)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SELECTSTRING,
                nStartAfter, (LPARAM)lpszString); }
_AFXWIN_INLINE void CComboBox::Clear()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CLEAR, 0, 0); }
_AFXWIN_INLINE void CComboBox::Copy()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_COPY, 0, 0); }
_AFXWIN_INLINE void CComboBox::Cut()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CUT, 0, 0); }
_AFXWIN_INLINE void CComboBox::Paste()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PASTE, 0, 0); }
_AFXWIN_INLINE int CComboBox::SetItemHeight(int nIndex, UINT cyItemHeight)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETITEMHEIGHT, nIndex, MAKELONG(cyItemHeight, 0)); }
_AFXWIN_INLINE int CComboBox::GetItemHeight(int nIndex) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETITEMHEIGHT, nIndex, 0L); }
_AFXWIN_INLINE int CComboBox::FindStringExact(int nIndexStart, LPCTSTR lpszFind) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind); }
_AFXWIN_INLINE int CComboBox::SetExtendedUI(BOOL bExtended )
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETEXTENDEDUI, bExtended, 0L); }
_AFXWIN_INLINE BOOL CComboBox::GetExtendedUI() const
        { ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, CB_GETEXTENDEDUI, 0, 0L); }
_AFXWIN_INLINE void CComboBox::GetDroppedControlRect(LPRECT lprect) const
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)lprect); }
_AFXWIN_INLINE BOOL CComboBox::GetDroppedState() const
        { ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, CB_GETDROPPEDSTATE, 0, 0L); }
_AFXWIN_INLINE LCID CComboBox::GetLocale() const
        { ASSERT(::IsWindow(m_hWnd)); return (LCID)::SendMessage(m_hWnd, CB_GETLOCALE, 0, 0); }
_AFXWIN_INLINE LCID CComboBox::SetLocale(LCID nNewLocale)
        { ASSERT(::IsWindow(m_hWnd)); return (LCID)::SendMessage(m_hWnd, CB_SETLOCALE, (WPARAM)nNewLocale, 0); }
#if (WINVER >= 0x400)
_AFXWIN_INLINE int CComboBox::GetTopIndex() const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETTOPINDEX, 0, 0); }
_AFXWIN_INLINE int CComboBox::SetTopIndex(int nIndex)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETTOPINDEX, nIndex, 0); }
_AFXWIN_INLINE int CComboBox::InitStorage(int nItems, UINT nBytes)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_INITSTORAGE, (WPARAM)nItems, nBytes); }
_AFXWIN_INLINE void CComboBox::SetHorizontalExtent(UINT nExtent)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, CB_SETHORIZONTALEXTENT, nExtent, 0); }
_AFXWIN_INLINE UINT CComboBox::GetHorizontalExtent() const
        { ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, CB_GETHORIZONTALEXTENT, 0, 0); }
_AFXWIN_INLINE int CComboBox::SetDroppedWidth(UINT nWidth)
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETDROPPEDWIDTH, nWidth, 0); }
_AFXWIN_INLINE int CComboBox::GetDroppedWidth() const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETDROPPEDWIDTH, 0, 0); }
#endif
_AFXWIN_INLINE CEdit::CEdit()
        { }
_AFXWIN_INLINE BOOL CEdit::CanUndo() const
        { ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0); }
_AFXWIN_INLINE int CEdit::GetLineCount() const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0); }
_AFXWIN_INLINE BOOL CEdit::GetModify() const
        { ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0); }
_AFXWIN_INLINE void CEdit::SetModify(BOOL bModified)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0); }
_AFXWIN_INLINE void CEdit::GetRect(LPRECT lpRect) const
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect); }
_AFXWIN_INLINE void CEdit::GetSel(int& nStartChar, int& nEndChar) const
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_GETSEL, (WPARAM)&nStartChar,(LPARAM)&nEndChar); }
_AFXWIN_INLINE DWORD CEdit::GetSel() const
        { ASSERT(::IsWindow(m_hWnd)); return DWORD(::SendMessage(m_hWnd, EM_GETSEL, 0, 0)); }
_AFXWIN_INLINE HLOCAL CEdit::GetHandle() const
        { ASSERT(::IsWindow(m_hWnd)); return (HLOCAL)::SendMessage(m_hWnd, EM_GETHANDLE, 0, 0); }
_AFXWIN_INLINE void CEdit::SetHandle(HLOCAL hBuffer)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETHANDLE, (WPARAM)hBuffer, 0); }
_AFXWIN_INLINE int CEdit::GetLine(int nIndex, LPTSTR lpszBuffer) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer); }
_AFXWIN_INLINE int CEdit::GetLine(int nIndex, LPTSTR lpszBuffer, int nMaxLength) const
        {
                ASSERT(::IsWindow(m_hWnd));
                *(LPWORD)lpszBuffer = (WORD)nMaxLength;
                return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
        }
_AFXWIN_INLINE void CEdit::EmptyUndoBuffer()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0); }
_AFXWIN_INLINE BOOL CEdit::FmtLines(BOOL bAddEOL)
        { ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_FMTLINES, bAddEOL, 0); }
_AFXWIN_INLINE void CEdit::LimitText(int nChars)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_LIMITTEXT, nChars, 0); }
_AFXWIN_INLINE int CEdit::LineFromChar(int nIndex) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_LINEFROMCHAR, nIndex, 0); }
_AFXWIN_INLINE int CEdit::LineIndex(int nLine) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_LINEINDEX, nLine, 0); }
_AFXWIN_INLINE int CEdit::LineLength(int nLine) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_LINELENGTH, nLine, 0); }
_AFXWIN_INLINE void CEdit::LineScroll(int nLines, int nChars)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_LINESCROLL, nChars, nLines); }
_AFXWIN_INLINE void CEdit::ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM) bCanUndo, (LPARAM)lpszNewText); }
_AFXWIN_INLINE void CEdit::SetPasswordChar(TCHAR ch)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETPASSWORDCHAR, ch, 0); }
_AFXWIN_INLINE void CEdit::SetRect(LPCRECT lpRect)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect); }
_AFXWIN_INLINE void CEdit::SetRectNP(LPCRECT lpRect)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETRECTNP, 0, (LPARAM)lpRect); }
_AFXWIN_INLINE void CEdit::SetSel(DWORD dwSelection, BOOL bNoScroll)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETSEL,
                LOWORD(dwSelection), HIWORD(dwSelection));
          if (!bNoScroll)
                ::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0); }
_AFXWIN_INLINE void CEdit::SetSel(int nStartChar, int nEndChar, BOOL bNoScroll)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETSEL, nStartChar, nEndChar);
          if (!bNoScroll)
                ::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0); }
_AFXWIN_INLINE BOOL CEdit::SetTabStops(int nTabStops, LPINT rgTabStops)
        { ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, nTabStops,
                (LPARAM)rgTabStops); }
_AFXWIN_INLINE void CEdit::SetTabStops()
        { ASSERT(::IsWindow(m_hWnd)); VERIFY(::SendMessage(m_hWnd, EM_SETTABSTOPS, 0, 0)); }
_AFXWIN_INLINE BOOL CEdit::SetTabStops(const int& cxEachStop)
        { ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS,
                1, (LPARAM)(LPINT)&cxEachStop); }
_AFXWIN_INLINE BOOL CEdit::Undo()
        { ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0); }
_AFXWIN_INLINE void CEdit::Clear()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CLEAR, 0, 0); }
_AFXWIN_INLINE void CEdit::Copy()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_COPY, 0, 0); }
_AFXWIN_INLINE void CEdit::Cut()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CUT, 0, 0); }
_AFXWIN_INLINE void CEdit::Paste()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PASTE, 0, 0); }
_AFXWIN_INLINE BOOL CEdit::SetReadOnly(BOOL bReadOnly )
        { ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L); }
_AFXWIN_INLINE int CEdit::GetFirstVisibleLine() const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L); }
_AFXWIN_INLINE TCHAR CEdit::GetPasswordChar() const
        { ASSERT(::IsWindow(m_hWnd)); return (TCHAR)::SendMessage(m_hWnd, EM_GETPASSWORDCHAR, 0, 0L); }
#if (WINVER >= 0x400)
_AFXWIN_INLINE void CEdit::SetMargins(UINT nLeft, UINT nRight)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETMARGINS, EC_LEFTMARGIN|EC_RIGHTMARGIN, MAKELONG(nLeft, nRight)); }
_AFXWIN_INLINE DWORD CEdit::GetMargins() const
        { ASSERT(::IsWindow(m_hWnd)); return (DWORD)::SendMessage(m_hWnd, EM_GETMARGINS, 0, 0); }
_AFXWIN_INLINE void CEdit::SetLimitText(UINT nMax)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETLIMITTEXT, nMax, 0); }
_AFXWIN_INLINE UINT CEdit::GetLimitText() const
        { ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, EM_GETLIMITTEXT, 0, 0); }
_AFXWIN_INLINE CPoint CEdit::PosFromChar(UINT nChar) const
        { ASSERT(::IsWindow(m_hWnd)); return CPoint( (DWORD)::SendMessage(m_hWnd, EM_POSFROMCHAR, nChar, 0)); }
_AFXWIN_INLINE int CEdit::CharFromPos(CPoint pt) const
        { ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_CHARFROMPOS, 0, MAKELPARAM(pt.x, pt.y)); }
#endif

_AFXWIN_INLINE CScrollBar::CScrollBar()
        { }
_AFXWIN_INLINE int CScrollBar::GetScrollPos() const
        { ASSERT(::IsWindow(m_hWnd)); return ::GetScrollPos(m_hWnd, SB_CTL); }
_AFXWIN_INLINE int CScrollBar::SetScrollPos(int nPos, BOOL bRedraw)
        { ASSERT(::IsWindow(m_hWnd)); return ::SetScrollPos(m_hWnd, SB_CTL, nPos, bRedraw); }
_AFXWIN_INLINE void CScrollBar::GetScrollRange(LPINT lpMinPos, LPINT lpMaxPos) const
        { ASSERT(::IsWindow(m_hWnd)); ::GetScrollRange(m_hWnd, SB_CTL, lpMinPos, lpMaxPos); }
_AFXWIN_INLINE void CScrollBar::SetScrollRange(int nMinPos, int nMaxPos, BOOL bRedraw)
        { ASSERT(::IsWindow(m_hWnd)); ::SetScrollRange(m_hWnd, SB_CTL, nMinPos, nMaxPos, bRedraw); }
_AFXWIN_INLINE void CScrollBar::ShowScrollBar(BOOL bShow)
        { ASSERT(::IsWindow(m_hWnd)); ::ShowScrollBar(m_hWnd, SB_CTL, bShow); }
_AFXWIN_INLINE BOOL CScrollBar::EnableScrollBar(UINT nArrowFlags)
        { ASSERT(::IsWindow(m_hWnd)); return ::EnableScrollBar(m_hWnd, SB_CTL, nArrowFlags); }
_AFXWIN_INLINE BOOL CScrollBar::SetScrollInfo(LPSCROLLINFO lpScrollInfo, BOOL bRedraw)
        { return CWnd::SetScrollInfo(SB_CTL, lpScrollInfo, bRedraw); }
_AFXWIN_INLINE BOOL CScrollBar::GetScrollInfo(LPSCROLLINFO lpScrollInfo, UINT nMask)
        { return CWnd::GetScrollInfo(SB_CTL, lpScrollInfo, nMask); }
_AFXWIN_INLINE int CScrollBar::GetScrollLimit()
        { return CWnd::GetScrollLimit(SB_CTL); }


// MDI functions
_AFXWIN_INLINE void CMDIFrameWnd::MDIActivate(CWnd* pWndActivate)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDIACTIVATE,
                (WPARAM)pWndActivate->m_hWnd, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDIIconArrange()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDIICONARRANGE, 0, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDIMaximize(CWnd* pWnd)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDIMAXIMIZE, (WPARAM)pWnd->m_hWnd, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDINext()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDINEXT, 0, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDIRestore(CWnd* pWnd)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDIRESTORE, (WPARAM)pWnd->m_hWnd, 0); }
_AFXWIN_INLINE CMenu* CMDIFrameWnd::MDISetMenu(CMenu* pFrameMenu, CMenu* pWindowMenu)
        { ASSERT(::IsWindow(m_hWnd)); return CMenu::FromHandle((HMENU)::SendMessage(
                m_hWndMDIClient, WM_MDISETMENU, (WPARAM)pFrameMenu->GetSafeHmenu(),
                (LPARAM)pWindowMenu->GetSafeHmenu())); }
_AFXWIN_INLINE void CMDIFrameWnd::MDITile()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDITILE, 0, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDICascade()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDICASCADE, 0, 0); }

_AFXWIN_INLINE void CMDIFrameWnd::MDICascade(int nType)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDICASCADE, nType, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDITile(int nType)
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDITILE, nType, 0); }
_AFXWIN_INLINE void CMDIChildWnd::MDIDestroy()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(GetParent()->m_hWnd, WM_MDIDESTROY, (WPARAM)m_hWnd, 0L); }
_AFXWIN_INLINE void CMDIChildWnd::MDIActivate()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(GetParent()->m_hWnd, WM_MDIACTIVATE, (WPARAM)m_hWnd, 0L); }
_AFXWIN_INLINE void CMDIChildWnd::MDIMaximize()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(GetParent()->m_hWnd, WM_MDIMAXIMIZE, (WPARAM)m_hWnd, 0L); }
_AFXWIN_INLINE void CMDIChildWnd::MDIRestore()
        { ASSERT(::IsWindow(m_hWnd)); ::SendMessage(GetParent()->m_hWnd, WM_MDIRESTORE, (WPARAM)m_hWnd, 0L); }

// CView
_AFXWIN_INLINE CDocument* CView::GetDocument() const
        { ASSERT(this != NULL); return m_pDocument; }
_AFXWIN_INLINE CSize CScrollView::GetTotalSize() const
        { ASSERT(this != NULL); return m_totalLog; }

// CDocument
_AFXWIN_INLINE const CString& CDocument::GetTitle() const
        { ASSERT(this != NULL); return m_strTitle; }
_AFXWIN_INLINE const CString& CDocument::GetPathName() const
        { ASSERT(this != NULL); return m_strPathName; }
_AFXWIN_INLINE CDocTemplate* CDocument::GetDocTemplate() const
        { ASSERT(this != NULL); return m_pDocTemplate; }
_AFXWIN_INLINE BOOL CDocument::IsModified()
        { ASSERT(this != NULL); return m_bModified; }
_AFXWIN_INLINE void CDocument::SetModifiedFlag(BOOL bModified)
        { ASSERT(this != NULL); m_bModified = bModified; }

// CWinThread
_AFXWIN_INLINE CWinThread::operator HANDLE() const
        { return this == NULL ? NULL : m_hThread; }
_AFXWIN_INLINE BOOL CWinThread::SetThreadPriority(int nPriority)
        { ASSERT(m_hThread != NULL); return ::SetThreadPriority(m_hThread, nPriority); }
_AFXWIN_INLINE int CWinThread::GetThreadPriority()
        { ASSERT(m_hThread != NULL); return ::GetThreadPriority(m_hThread); }
_AFXWIN_INLINE DWORD CWinThread::ResumeThread()
        { ASSERT(m_hThread != NULL); return ::ResumeThread(m_hThread); }
_AFXWIN_INLINE DWORD CWinThread::SuspendThread()
        { ASSERT(m_hThread != NULL); return ::SuspendThread(m_hThread); }
_AFXWIN_INLINE BOOL CWinThread::PostThreadMessage(UINT message, WPARAM wParam, LPARAM lParam)
        { ASSERT(m_hThread != NULL); return ::PostThreadMessage(m_nThreadID, message, wParam, lParam); }

// CWinApp
_AFXWIN_INLINE HCURSOR CWinApp::LoadCursor(LPCTSTR lpszResourceName) const
        { return ::LoadCursor(AfxFindResourceHandle(lpszResourceName,
                RT_GROUP_CURSOR), lpszResourceName); }
_AFXWIN_INLINE HCURSOR CWinApp::LoadCursor(UINT nIDResource) const
        { return ::LoadCursor(AfxFindResourceHandle(MAKEINTRESOURCE(nIDResource),
                RT_GROUP_CURSOR), MAKEINTRESOURCE(nIDResource)); }
_AFXWIN_INLINE HCURSOR CWinApp::LoadStandardCursor(LPCTSTR lpszCursorName) const
        { return ::LoadCursor(NULL, lpszCursorName); }
_AFXWIN_INLINE HCURSOR CWinApp::LoadOEMCursor(UINT nIDCursor) const
        { return ::LoadCursor(NULL, MAKEINTRESOURCE(nIDCursor)); }
_AFXWIN_INLINE HICON CWinApp::LoadIcon(LPCTSTR lpszResourceName) const
        { return ::LoadIcon(AfxFindResourceHandle(lpszResourceName,
                RT_GROUP_ICON), lpszResourceName); }
_AFXWIN_INLINE HICON CWinApp::LoadIcon(UINT nIDResource) const
        { return ::LoadIcon(AfxFindResourceHandle(MAKEINTRESOURCE(nIDResource),
                RT_GROUP_ICON), MAKEINTRESOURCE(nIDResource)); }
_AFXWIN_INLINE HICON CWinApp::LoadStandardIcon(LPCTSTR lpszIconName) const
        { return ::LoadIcon(NULL, lpszIconName); }
_AFXWIN_INLINE HICON CWinApp::LoadOEMIcon(UINT nIDIcon) const
        { return ::LoadIcon(NULL, MAKEINTRESOURCE(nIDIcon)); }

_AFXWIN_INLINE CWaitCursor::CWaitCursor()
        { AfxGetApp()->BeginWaitCursor(); }
_AFXWIN_INLINE CWaitCursor::~CWaitCursor()
        { AfxGetApp()->EndWaitCursor(); }
_AFXWIN_INLINE void CWaitCursor::Restore()
        { AfxGetApp()->RestoreWaitCursor(); }

/////////////////////////////////////////////////////////////////////////////
// Obsolete and non-portable

_AFXWIN_INLINE void CWnd::CloseWindow()
        { ASSERT(::IsWindow(m_hWnd)); ::CloseWindow(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::OpenIcon()
        { ASSERT(::IsWindow(m_hWnd)); return ::OpenIcon(m_hWnd); }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXWIN_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\mfc42\atldef.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLDEF_H__
#define __ATLDEF_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifdef UNDER_CE
	#error ATL not currently supported for CE
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

///////////////////////////////////////////////////////////////////////////////
// __declspec(novtable) is used on a class declaration to prevent the vtable
// pointer from being initialized in the constructor and destructor for the
// class.  This has many benefits because the linker can now eliminate the
// vtable and all the functions pointed to by the vtable.  Also, the actual
// constructor and destructor code are now smaller.
///////////////////////////////////////////////////////////////////////////////
// This should only be used on a class that is not directly createable but is
// rather only used as a base class.  Additionally, the constructor and
// destructor (if provided by the user) should not call anything that may cause
// a virtual function call to occur back on the object.
///////////////////////////////////////////////////////////////////////////////
// By default, the wizards will generate new ATL object classes with this
// attribute (through the ATL_NO_VTABLE macro).  This is normally safe as long
// the restriction mentioned above is followed.  It is always safe to remove
// this macro from your class, so if in doubt, remove it.
///////////////////////////////////////////////////////////////////////////////

#ifdef _ATL_DISABLE_NO_VTABLE
#define ATL_NO_VTABLE
#else
#define ATL_NO_VTABLE __declspec(novtable)
#endif

#ifdef _ATL_DEBUG_REFCOUNT
#ifndef _ATL_DEBUG_INTERFACES
#define _ATL_DEBUG_INTERFACES
#endif
#endif

#ifdef _ATL_DEBUG_INTERFACES
#ifndef _ATL_DEBUG
#define _ATL_DEBUG
#endif // _ATL_DEBUG
#endif // _ATL_DEBUG_INTERFACES

#ifndef _ATL_HEAPFLAGS
#ifdef _MALLOC_ZEROINIT
#define _ATL_HEAPFLAGS HEAP_ZERO_MEMORY
#else
#define _ATL_HEAPFLAGS 0
#endif
#endif

#ifndef _ATL_PACKING
#define _ATL_PACKING 8
#endif

#if defined(_ATL_DLL)
	#define ATLAPI extern "C" HRESULT __declspec(dllimport) __stdcall
	#define ATLAPI_(x) extern "C" __declspec(dllimport) x __stdcall
	#define ATLINLINE
#elif defined(_ATL_DLL_IMPL)
	#define ATLAPI extern "C" HRESULT __declspec(dllexport) __stdcall
	#define ATLAPI_(x) extern "C" __declspec(dllexport) x __stdcall
	#define ATLINLINE
#else
	#define ATLAPI HRESULT __stdcall
	#define ATLAPI_(x) x __stdcall
	#define ATLINLINE inline
#endif

#if defined (_CPPUNWIND) & (defined(_ATL_EXCEPTIONS) | defined(_AFX))
#define ATLTRY(x) try{x;} catch(...) {}
#else
#define ATLTRY(x) x;
#endif

#define offsetofclass(base, derived) ((DWORD_PTR)(static_cast<base*>((derived*)_ATL_PACKING))-_ATL_PACKING)

/////////////////////////////////////////////////////////////////////////////
// Master version numbers

#define _ATL     1      // Active Template Library
#ifdef _WIN64
#define _ATL_VER 0x0301 // Active Template Library version 3.0
#else
#define _ATL_VER 0x0300 // Active Template Library version 3.0
#endif

/////////////////////////////////////////////////////////////////////////////
// Threading

#ifndef _ATL_SINGLE_THREADED
#ifndef _ATL_APARTMENT_THREADED
#ifndef _ATL_FREE_THREADED
#define _ATL_FREE_THREADED
#endif
#endif
#endif

#endif // __ATLDEF_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\mfc42\dlgprnt2.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include <afx.h>
#include <afxwin.h>
#include <afxdisp.h>
#include <afxole.h>
#include <afxpriv.h>


#include "afxprntx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW


INT_PTR CALLBACK AfxDlgProc(HWND, UINT, WPARAM, LPARAM);

/////////////////////////////////////////////////////////////////////////////
// Private class to support new NT5 printing user interface

//
//  IPrintDialogCallback interface id used by PrintDlgEx.
//
//  {5852A2C3-6530-11D1-B6A3-0000F8757BF9}
//
extern "C" const __declspec(selectany) IID IID_IPrintDialogCallback =
        {0x5852a2c3, 0x6530, 0x11d1, {0xb6, 0xa3, 0x0, 0x0, 0xf8, 0x75, 0x7b, 0xf9}};

BEGIN_INTERFACE_MAP(C_PrintDialogEx, CPrintDialog)
   INTERFACE_PART(C_PrintDialogEx, IID_IPrintDialogCallback, PrintDialogCallback)
END_INTERFACE_MAP()

C_PrintDialogEx::C_PrintDialogEx(BOOL bPrintSetupOnly,
        DWORD dwFlags, CWnd* pParentWnd)
        : CPrintDialog(bPrintSetupOnly, dwFlags, pParentWnd)
{
        memset(&m_pdex, 0, sizeof(m_pdex));
        m_pdex.lStructSize = sizeof(m_pdex);
        m_pdex.Flags = dwFlags;
}

INT_PTR C_PrintDialogEx::DoModal()
{
        ASSERT_VALID(this);

        m_pd.hwndOwner = PreModal();
        AfxUnhookWindowCreate();

        // expand m_pd data into the PRINTDLGEX structure

        m_pdex.hwndOwner = m_pd.hwndOwner;
        m_pdex.hDevMode = m_pd.hDevMode;
        m_pdex.hDevNames = m_pd.hDevNames;
        m_pdex.hDC = m_pd.hDC;
//        m_pdex.Flags = (m_pd.Flags & ~(PD_ENABLEPRINTHOOK | PD_ENABLESETUPHOOK | PD_PRINTSETUP));

        m_pdex.nMinPage = m_pd.nMinPage;
        m_pdex.nMaxPage = m_pd.nMaxPage;
        m_pdex.hInstance = m_pd.hInstance;
        m_pdex.nStartPage = START_PAGE_GENERAL;
        m_pdex.nCopies = m_pd.nCopies;
        m_pdex.lpCallback = &m_xPrintDialogCallback;

        // initialize page ranges

        PRINTPAGERANGE ourPageRange;

        if (m_pdex.Flags & PD_NOPAGENUMS)
        {
                m_pdex.lpPageRanges = NULL;
                m_pdex.nPageRanges = 0;
                m_pdex.nMaxPageRanges = 0;
        }
        else
        {
                ourPageRange.nFromPage = m_pd.nFromPage;
                ourPageRange.nToPage   = m_pd.nToPage;
                m_pdex.nPageRanges = 1;
                m_pdex.nMaxPageRanges = 1;
                m_pdex.lpPageRanges = &ourPageRange;
        }

        HMODULE hCommDlg = GetModuleHandleA("COMDLG32.DLL");
        HRESULT (STDAPICALLTYPE* pfn)(LPPRINTDLGEX);
#ifdef UNICODE
        pfn = (HRESULT (STDAPICALLTYPE*)(LPPRINTDLGEX))
                                GetProcAddress(hCommDlg, "PrintDlgExW");
#else
        pfn = (HRESULT (STDAPICALLTYPE*)(LPPRINTDLGEX))
                                GetProcAddress(hCommDlg, "PrintDlgExA");
#endif

        HRESULT hResult = E_NOTIMPL;
        if (pfn != NULL)
        {
                _AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
                ASSERT(pThreadState->m_pAlternateWndInit == NULL);

                pThreadState->m_pAlternateWndInit = this;

                hResult = pfn(&m_pdex);
                if (SUCCEEDED(hResult))
                        ASSERT(pThreadState->m_pAlternateWndInit == NULL);
                pThreadState->m_pAlternateWndInit = NULL;
        }

        // pull data back...

        PostModal();

        if (!(m_pdex.Flags & PD_NOPAGENUMS))
        {
                m_pd.nToPage = (WORD) m_pdex.lpPageRanges->nToPage;
                m_pd.nFromPage = (WORD) m_pdex.lpPageRanges->nFromPage;
                m_pd.nMinPage = (WORD) m_pdex.nMinPage;
                m_pd.nMaxPage = (WORD) m_pdex.nMaxPage;
        }

        m_pd.hDevMode = m_pdex.hDevMode;
        m_pd.hDevNames = m_pdex.hDevNames;
        m_pd.hDC = m_pdex.hDC;
        m_pd.nCopies = (WORD)m_pdex.nCopies;
        // calculate return code
        int nResult = IDCANCEL;
        if (SUCCEEDED(hResult))
        {
                if (m_pdex.dwResultAction == PD_RESULT_PRINT)
                        nResult = IDOK;
        }
        return nResult;
}


STDMETHODIMP_(ULONG) C_PrintDialogEx::XPrintDialogCallback::AddRef()
{
        METHOD_PROLOGUE_EX_(C_PrintDialogEx, PrintDialogCallback)
        return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) C_PrintDialogEx::XPrintDialogCallback::Release()
{
        METHOD_PROLOGUE_EX_(C_PrintDialogEx, PrintDialogCallback)
        return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP C_PrintDialogEx::XPrintDialogCallback::QueryInterface(
        REFIID iid, LPVOID* ppvObj)
{
        METHOD_PROLOGUE_EX_(C_PrintDialogEx, PrintDialogCallback)
        return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP C_PrintDialogEx::XPrintDialogCallback::InitDone()
{
        METHOD_PROLOGUE_EX(C_PrintDialogEx, PrintDialogCallback)
        return pThis->OnInitDone();
}

STDMETHODIMP C_PrintDialogEx::XPrintDialogCallback::SelectionChange()
{
        METHOD_PROLOGUE_EX(C_PrintDialogEx, PrintDialogCallback)
        return pThis->OnSelectionChange();
}

STDMETHODIMP C_PrintDialogEx::XPrintDialogCallback::HandleMessage(HWND hDlg,
        UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
        METHOD_PROLOGUE_EX(C_PrintDialogEx, PrintDialogCallback)
        return pThis->OnHandleMessage(hDlg, uMsg, wParam, lParam, pResult);
}

HRESULT C_PrintDialogEx::OnInitDone()
{
        return S_FALSE;
}

HRESULT C_PrintDialogEx::OnSelectionChange()
{
        return S_FALSE;
}

HRESULT C_PrintDialogEx::OnHandleMessage(HWND hDlg, UINT uMsg,
        WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
        UNUSED_ALWAYS(hDlg);
        HRESULT hResult = S_FALSE;

        _AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
        if (pThreadState->m_pAlternateWndInit != NULL)
        {
                ASSERT_KINDOF(C_PrintDialogEx, pThreadState->m_pAlternateWndInit);
                pThreadState->m_pAlternateWndInit->SubclassWindow(hDlg);
                pThreadState->m_pAlternateWndInit = NULL;
        }
        ASSERT(pThreadState->m_pAlternateWndInit == NULL);

        if (uMsg == WM_INITDIALOG)
        {
                *pResult = AfxDlgProc(hDlg, uMsg, wParam, lParam);
                hResult = S_FALSE;
        }

        return hResult;
}

IMPLEMENT_DYNAMIC(C_PrintDialogEx, CPrintDialog)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\mfc42\idispids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995 - 1996 Microsoft Corporation. All Rights Reserved.
//
//  File: idispids.h
//
//--------------------------------------------------------------------------

#define DISPID_READYSTATE               (-525)
#define DISPID_READYSTATECHANGE         (-609)
#define DISPID_AMBIENT_TRANSFERPRIORITY (-728)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\mfc42\datapath.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.15 */
/* at Thu Jun 13 20:25:13 1996
 */
/* Compiler settings for datapath.idl:
    Oi, W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __datapath_h__
#define __datapath_h__

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

#ifndef __IObjectWithSite_FWD_DEFINED__
#define __IObjectWithSite_FWD_DEFINED__
typedef interface IObjectWithSite IObjectWithSite;
#endif 	/* __IObjectWithSite_FWD_DEFINED__ */


#ifndef __IDataPathBrowser_FWD_DEFINED__
#define __IDataPathBrowser_FWD_DEFINED__
typedef interface IDataPathBrowser IDataPathBrowser;
#endif 	/* __IDataPathBrowser_FWD_DEFINED__ */


#ifndef __IProvideClassInfo3_FWD_DEFINED__
#define __IProvideClassInfo3_FWD_DEFINED__
typedef interface IProvideClassInfo3 IProvideClassInfo3;
#endif 	/* __IProvideClassInfo3_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "oaidl.h"
#include "olectl.h"
#include "urlmon.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Thu Jun 13 20:25:13 1996
 * using MIDL 3.00.15
 ****************************************/
/* [local] */


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995 - 1996 Microsoft Corporation. All Rights Reserved.
//
//  File: datapath.h

#pragma comment(lib,"uuid3.lib")
//
//--------------------------------------------------------------------------


#include "idispids.h"
typedef BSTR OLE_DATAPATH;
#define SID_SDataPathBrowser IID_IDataPathBrowser

#if 0
////////////////////////////////////////////////////////////////////////////
//  State values for the DISPID_READYSTATE property

enum __MIDL___MIDL__intf_0000_0001
    {	READYSTATE_UNINITIALIZED	= 1,
	READYSTATE_LOADING	= 0,
	READYSTATE_LOADED	= 2,
	READYSTATE_INTERACTIVE	= 3,
	READYSTATE_COMPLETE	= 4
    };
#endif
////////////////////////////////////////////////////////////////////////////
//  DataPath GUIDs (link to uuid3.lib)
EXTERN_C const GUID OLE_DATAPATH_BMP;
EXTERN_C const GUID OLE_DATAPATH_DIB;
EXTERN_C const GUID OLE_DATAPATH_WMF;
EXTERN_C const GUID OLE_DATAPATH_ENHMF;
EXTERN_C const GUID OLE_DATAPATH_GIF;
EXTERN_C const GUID OLE_DATAPATH_JPEG;
EXTERN_C const GUID OLE_DATAPATH_TIFF;
EXTERN_C const GUID OLE_DATAPATH_XBM;
EXTERN_C const GUID OLE_DATAPATH_PCX;
EXTERN_C const GUID OLE_DATAPATH_PICT;
EXTERN_C const GUID OLE_DATAPATH_CGM;
EXTERN_C const GUID OLE_DATAPATH_EPS;
EXTERN_C const GUID OLE_DATAPATH_COMMONIMAGE;
EXTERN_C const GUID OLE_DATAPATH_ALLIMAGE;
EXTERN_C const GUID OLE_DATAPATH_AVI;
EXTERN_C const GUID OLE_DATAPATH_MPEG;
EXTERN_C const GUID OLE_DATAPATH_QUICKTIME;
EXTERN_C const GUID OLE_DATAPATH_BASICAUDIO;
EXTERN_C const GUID OLE_DATAPATH_MIDI;
EXTERN_C const GUID OLE_DATAPATH_WAV;
EXTERN_C const GUID OLE_DATAPATH_RIFF;
EXTERN_C const GUID OLE_DATAPATH_SOUND;
EXTERN_C const GUID OLE_DATAPATH_VIDEO;
EXTERN_C const GUID OLE_DATAPATH_ALLMM;
EXTERN_C const GUID OLE_DATAPATH_ANSITEXT;
EXTERN_C const GUID OLE_DATAPATH_UNICODE;
EXTERN_C const GUID OLE_DATAPATH_RTF;
EXTERN_C const GUID OLE_DATAPATH_HTML;
EXTERN_C const GUID OLE_DATAPATH_POSTSCRIPT;
EXTERN_C const GUID OLE_DATAPATH_ALLTEXT;
EXTERN_C const GUID OLE_DATAPATH_DIF;
EXTERN_C const GUID OLE_DATAPATH_SYLK;
EXTERN_C const GUID OLE_DATAPATH_BIFF;
EXTERN_C const GUID OLE_DATAPATH_PALETTE;
EXTERN_C const GUID OLE_DATAPATH_PENDATA;
////////////////////////////////////////////////////////////////////////////

EXTERN_C const GUID FLAGID_Internet;
EXTERN_C const GUID GUID_PathProperty;
EXTERN_C const GUID GUID_HasPathProperties;

////////////////////////////////////////////////////////////////////////////
//  ARRAYID GUIDs (link to uuid3.lib)
EXTERN_C const GUID ARRAYID_PathProperties;

////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPOBJECTWITHSITE_DEFINED
#define _LPOBJECTWITHSITE_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IObjectWithSite_INTERFACE_DEFINED__
#define __IObjectWithSite_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IObjectWithSite
 * at Thu Jun 13 20:25:13 1996
 * using MIDL 3.00.15
 ****************************************/
/* [unique][object][uuid] */


typedef /* [unique] */ IObjectWithSite __RPC_FAR *LPOBJECTWITHSITE;


EXTERN_C const IID IID_IObjectWithSite;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IObjectWithSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSite(
            /* [in] */ IUnknown __RPC_FAR *pUnkSite) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetSite(
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvSite) = 0;

    };

#else 	/* C style interface */

    typedef struct IObjectWithSiteVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IObjectWithSite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IObjectWithSite __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IObjectWithSite __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSite )(
            IObjectWithSite __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkSite);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSite )(
            IObjectWithSite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvSite);

        END_INTERFACE
    } IObjectWithSiteVtbl;

    interface IObjectWithSite
    {
        CONST_VTBL struct IObjectWithSiteVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IObjectWithSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectWithSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectWithSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectWithSite_SetSite(This,pUnkSite)	\
    (This)->lpVtbl -> SetSite(This,pUnkSite)

#define IObjectWithSite_GetSite(This,riid,ppvSite)	\
    (This)->lpVtbl -> GetSite(This,riid,ppvSite)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectWithSite_SetSite_Proxy(
    IObjectWithSite __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkSite);


void __RPC_STUB IObjectWithSite_SetSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectWithSite_GetSite_Proxy(
    IObjectWithSite __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvSite);


void __RPC_STUB IObjectWithSite_GetSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectWithSite_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0119
 * at Thu Jun 13 20:25:13 1996
 * using MIDL 3.00.15
 ****************************************/
/* [local] */


#endif
#ifndef _LPDATAPATHBROWSER_DEFINED
#define _LPDATAPATHBROWSER_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0119_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0119_v0_0_s_ifspec;

#ifndef __IDataPathBrowser_INTERFACE_DEFINED__
#define __IDataPathBrowser_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDataPathBrowser
 * at Thu Jun 13 20:25:13 1996
 * using MIDL 3.00.15
 ****************************************/
/* [unique][object][local][uuid] */



EXTERN_C const IID IID_IDataPathBrowser;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IDataPathBrowser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BrowseType(
            /* [in] */ REFGUID rguidPathType,
            /* [in] */ LPOLESTR pszDefaultPath,
            /* [in] */ ULONG cchPath,
            /* [size_is][out] */ LPOLESTR pszPath,
            /* [in] */ HWND hWnd) = 0;

    };

#else 	/* C style interface */

    typedef struct IDataPathBrowserVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IDataPathBrowser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IDataPathBrowser __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IDataPathBrowser __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BrowseType )(
            IDataPathBrowser __RPC_FAR * This,
            /* [in] */ REFGUID rguidPathType,
            /* [in] */ LPOLESTR pszDefaultPath,
            /* [in] */ ULONG cchPath,
            /* [size_is][out] */ LPOLESTR pszPath,
            /* [in] */ HWND hWnd);

        END_INTERFACE
    } IDataPathBrowserVtbl;

    interface IDataPathBrowser
    {
        CONST_VTBL struct IDataPathBrowserVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IDataPathBrowser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataPathBrowser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataPathBrowser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataPathBrowser_BrowseType(This,rguidPathType,pszDefaultPath,cchPath,pszPath,hWnd)	\
    (This)->lpVtbl -> BrowseType(This,rguidPathType,pszDefaultPath,cchPath,pszPath,hWnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDataPathBrowser_BrowseType_Proxy(
    IDataPathBrowser __RPC_FAR * This,
    /* [in] */ REFGUID rguidPathType,
    /* [in] */ LPOLESTR pszDefaultPath,
    /* [in] */ ULONG cchPath,
    /* [size_is][out] */ LPOLESTR pszPath,
    /* [in] */ HWND hWnd);


void __RPC_STUB IDataPathBrowser_BrowseType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataPathBrowser_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0120
 * at Thu Jun 13 20:25:13 1996
 * using MIDL 3.00.15
 ****************************************/
/* [local] */


#endif
#ifndef _LPPROVIDECLASSINFO3_DEFINED
#define _LPPROVIDECLASSINFO3_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0120_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0120_v0_0_s_ifspec;

#ifndef __IProvideClassInfo3_INTERFACE_DEFINED__
#define __IProvideClassInfo3_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideClassInfo3
 * at Thu Jun 13 20:25:13 1996
 * using MIDL 3.00.15
 ****************************************/
/* [unique][uuid][object] */


typedef /* [unique] */ IProvideClassInfo3 __RPC_FAR *LPPROVIDECLASSINFO3;


enum __MIDL_IProvideClassInfo3_0001
    {	INTERNETFLAG_USESDATAPATHS	= 0x1
    };

EXTERN_C const IID IID_IProvideClassInfo3;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface IProvideClassInfo3 : public IProvideClassInfo2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGUIDDwordArrays(
            /* [in] */ REFGUID rguidArray,
            /* [out][in] */ CAUUID __RPC_FAR *pcaUUID,
            /* [out][in] */ CADWORD __RPC_FAR *pcadw) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetClassInfoLocale(
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppITypeInfo,
            /* [in] */ LCID lcid) = 0;

        virtual HRESULT STDMETHODCALLTYPE GetFlags(
            /* [in] */ REFGUID guidGroup,
            /* [out] */ DWORD __RPC_FAR *pdwFlags) = 0;

    };

#else 	/* C style interface */

    typedef struct IProvideClassInfo3Vtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            IProvideClassInfo3 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            IProvideClassInfo3 __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            IProvideClassInfo3 __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassInfo )(
            IProvideClassInfo3 __RPC_FAR * This,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTI);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGUID )(
            IProvideClassInfo3 __RPC_FAR * This,
            /* [in] */ DWORD dwGuidKind,
            /* [out] */ GUID __RPC_FAR *pGUID);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGUIDDwordArrays )(
            IProvideClassInfo3 __RPC_FAR * This,
            /* [in] */ REFGUID rguidArray,
            /* [out][in] */ CAUUID __RPC_FAR *pcaUUID,
            /* [out][in] */ CADWORD __RPC_FAR *pcadw);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassInfoLocale )(
            IProvideClassInfo3 __RPC_FAR * This,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppITypeInfo,
            /* [in] */ LCID lcid);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )(
            IProvideClassInfo3 __RPC_FAR * This,
            /* [in] */ REFGUID guidGroup,
            /* [out] */ DWORD __RPC_FAR *pdwFlags);

        END_INTERFACE
    } IProvideClassInfo3Vtbl;

    interface IProvideClassInfo3
    {
        CONST_VTBL struct IProvideClassInfo3Vtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define IProvideClassInfo3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideClassInfo3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideClassInfo3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideClassInfo3_GetClassInfo(This,ppTI)	\
    (This)->lpVtbl -> GetClassInfo(This,ppTI)


#define IProvideClassInfo3_GetGUID(This,dwGuidKind,pGUID)	\
    (This)->lpVtbl -> GetGUID(This,dwGuidKind,pGUID)


#define IProvideClassInfo3_GetGUIDDwordArrays(This,rguidArray,pcaUUID,pcadw)	\
    (This)->lpVtbl -> GetGUIDDwordArrays(This,rguidArray,pcaUUID,pcadw)

#define IProvideClassInfo3_GetClassInfoLocale(This,ppITypeInfo,lcid)	\
    (This)->lpVtbl -> GetClassInfoLocale(This,ppITypeInfo,lcid)

#define IProvideClassInfo3_GetFlags(This,guidGroup,pdwFlags)	\
    (This)->lpVtbl -> GetFlags(This,guidGroup,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProvideClassInfo3_GetGUIDDwordArrays_Proxy(
    IProvideClassInfo3 __RPC_FAR * This,
    /* [in] */ REFGUID rguidArray,
    /* [out][in] */ CAUUID __RPC_FAR *pcaUUID,
    /* [out][in] */ CADWORD __RPC_FAR *pcadw);


void __RPC_STUB IProvideClassInfo3_GetGUIDDwordArrays_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProvideClassInfo3_GetClassInfoLocale_Proxy(
    IProvideClassInfo3 __RPC_FAR * This,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppITypeInfo,
    /* [in] */ LCID lcid);


void __RPC_STUB IProvideClassInfo3_GetClassInfoLocale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProvideClassInfo3_GetFlags_Proxy(
    IProvideClassInfo3 __RPC_FAR * This,
    /* [in] */ REFGUID guidGroup,
    /* [out] */ DWORD __RPC_FAR *pdwFlags);


void __RPC_STUB IProvideClassInfo3_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideClassInfo3_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0121
 * at Thu Jun 13 20:25:13 1996
 * using MIDL 3.00.15
 ****************************************/
/* [local] */


#endif


extern RPC_IF_HANDLE __MIDL__intf_0121_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0121_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\mfc42\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif

#include <winresrc.h>

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wtl10\atlapp.h ===
// WTL Version 3.1
// Copyright (C) 1997-2000 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLAPP_H__
#define __ATLAPP_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlapp.h requires atlbase.h to be included first
#endif

#if (WINVER < 0x0400)
	#error WTL requires Windows version 4.0 or higher
#endif


#include <limits.h>
#if !defined(_ATL_MIN_CRT) & defined(_MT)
#include <process.h>	// for _beginthreadex, _endthreadex
#endif

#include <commctrl.h>
#pragma comment(lib, "comctl32.lib")

#include <atlres.h>


// WTL version number
#define _WTL_VER	0x0310


// This is to support using original VC++ 6.0 headers with WTL
#ifndef _ATL_NO_OLD_HEADERS_WIN64
#if !defined(_WIN64) && !defined(_ATL_TMP_IMPL2)

  #ifndef GetWindowLongPtr
    #define GetWindowLongPtrA   GetWindowLongA
    #define GetWindowLongPtrW   GetWindowLongW
    #ifdef UNICODE
      #define GetWindowLongPtr  GetWindowLongPtrW
    #else
      #define GetWindowLongPtr  GetWindowLongPtrA
    #endif // !UNICODE
  #endif // !GetWindowLongPtr

  #ifndef SetWindowLongPtr
    #define SetWindowLongPtrA   SetWindowLongA
    #define SetWindowLongPtrW   SetWindowLongW
    #ifdef UNICODE
      #define SetWindowLongPtr  SetWindowLongPtrW
    #else
      #define SetWindowLongPtr  SetWindowLongPtrA
    #endif // !UNICODE
  #endif // !SetWindowLongPtr

  #ifndef GWLP_WNDPROC
    #define GWLP_WNDPROC        (-4)
  #endif
  #ifndef GWLP_HINSTANCE
    #define GWLP_HINSTANCE      (-6)
  #endif
  #ifndef GWLP_HWNDPARENT
    #define GWLP_HWNDPARENT     (-8)
  #endif
  #ifndef GWLP_USERDATA
    #define GWLP_USERDATA       (-21)
  #endif
  #ifndef GWLP_ID
    #define GWLP_ID             (-12)
  #endif

  #ifndef DWLP_MSGRESULT
    #define DWLP_MSGRESULT  0
  #endif

  typedef long LONG_PTR;
  typedef unsigned long ULONG_PTR;
  typedef ULONG_PTR DWORD_PTR;

  #ifndef HandleToUlong
#define HandleToUlong( h ) ((ULONG)(ULONG_PTR)(h) )
  #endif
  #ifndef HandleToLong
#define HandleToLong( h ) ((LONG)(LONG_PTR) (h) )
  #endif
  #ifndef LongToHandle
#define LongToHandle( h) ((HANDLE)(LONG_PTR) (h))
  #endif
  #ifndef PtrToUlong
#define PtrToUlong( p ) ((ULONG)(ULONG_PTR) (p) )
  #endif
  #ifndef PtrToLong
#define PtrToLong( p ) ((LONG)(LONG_PTR) (p) )
  #endif
  #ifndef PtrToUint
#define PtrToUint( p ) ((UINT)(UINT_PTR) (p) )
  #endif
  #ifndef PtrToInt
#define PtrToInt( p ) ((INT)(INT_PTR) (p) )
  #endif
  #ifndef PtrToUshort
#define PtrToUshort( p ) ((unsigned short)(ULONG_PTR)(p) )
  #endif
  #ifndef PtrToShort
#define PtrToShort( p ) ((short)(LONG_PTR)(p) )
  #endif
  #ifndef IntToPtr
#define IntToPtr( i )    ((VOID *)(INT_PTR)((int)i))
  #endif
  #ifndef UIntToPtr
#define UIntToPtr( ui )  ((VOID *)(UINT_PTR)((unsigned int)ui))
  #endif
  #ifndef LongToPtr
#define LongToPtr( l )   ((VOID *)(LONG_PTR)((long)l))
  #endif
  #ifndef ULongToPtr
#define ULongToPtr( ul )  ((VOID *)(ULONG_PTR)((unsigned long)ul))
  #endif

#endif //!defined(_WIN64) && !defined(_ATL_TMP_IMPL2)
#endif //!_ATL_NO_OLD_HEADERS_WIN64


namespace WTL
{

enum wtlTraceFlags
{
	atlTraceUI = 0x10000000
};

// Windows version helper
inline bool AtlIsOldWindows()
{
	OSVERSIONINFO ovi;
	ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	BOOL bRet = ::GetVersionEx(&ovi);
	return (!bRet || !((ovi.dwMajorVersion >= 5) || (ovi.dwMajorVersion == 4 && ovi.dwMinorVersion >= 90)));
}

// default GUI font helper
inline HFONT AtlGetDefaultGuiFont()
{
	return (HFONT)::GetStockObject(DEFAULT_GUI_FONT);
}

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CMessageFilter;
class CIdleHandler;
class CMessageLoop;
class CAppModule;
class CServerAppModule;

#ifndef _ATL_TMP_IMPL2
class _U_RECT;
class _U_MENUorID;
class _U_STRINGorID;
#endif //!_ATL_TMP_IMPL2


/////////////////////////////////////////////////////////////////////////////
// CMessageFilter - Interface for message filter support

class CMessageFilter
{
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg) = 0;
};


/////////////////////////////////////////////////////////////////////////////
// CIdleHandler - Interface for idle processing

class CIdleHandler
{
public:
	virtual BOOL OnIdle() = 0;
};

#ifndef _ATL_NO_OLD_NAMES
// for compatilibility with old names only
typedef CIdleHandler	CUpdateUIObject;
#define DoUpdate	OnIdle
#endif //!_ATL_NO_OLD_NAMES


/////////////////////////////////////////////////////////////////////////////
// CMessageLoop - message loop implementation

class CMessageLoop
{
public:
	CSimpleArray<CMessageFilter*> m_aMsgFilter;
	CSimpleArray<CIdleHandler*> m_aIdleHandler;
	MSG m_msg;

// Message filter operations
	BOOL AddMessageFilter(CMessageFilter* pMessageFilter)
	{
		return m_aMsgFilter.Add(pMessageFilter);
	}
	BOOL RemoveMessageFilter(CMessageFilter* pMessageFilter)
	{
		return m_aMsgFilter.Remove(pMessageFilter);
	}
// Idle handler operations
	BOOL AddIdleHandler(CIdleHandler* pIdleHandler)
	{
		return m_aIdleHandler.Add(pIdleHandler);
	}
	BOOL RemoveIdleHandler(CIdleHandler* pIdleHandler)
	{
		return m_aIdleHandler.Remove(pIdleHandler);
	}
#ifndef _ATL_NO_OLD_NAMES
	// for compatilibility with old names only
	BOOL AddUpdateUI(CIdleHandler* pIdleHandler)
	{
		ATLTRACE2(atlTraceUI, 0, "CUpdateUIObject and AddUpdateUI are deprecated. Please change your code to use CIdleHandler and OnIdle\n");
		return AddIdleHandler(pIdleHandler);
	}
	BOOL RemoveUpdateUI(CIdleHandler* pIdleHandler)
	{
		ATLTRACE2(atlTraceUI, 0, "CUpdateUIObject and RemoveUpdateUI are deprecated. Please change your code to use CIdleHandler and OnIdle\n");
		return RemoveIdleHandler(pIdleHandler);
	}
#endif //!_ATL_NO_OLD_NAMES
// message loop
	int Run()
	{
		BOOL bDoIdle = TRUE;
		int nIdleCount = 0;
		BOOL bRet;

		for(;;)
		{
			while(!::PeekMessage(&m_msg, NULL, 0, 0, PM_NOREMOVE) && bDoIdle)
			{
				if(!OnIdle(nIdleCount++))
					bDoIdle = FALSE;
			}

			bRet = ::GetMessage(&m_msg, NULL, 0, 0);

			if(bRet == -1)
			{
				ATLTRACE2(atlTraceUI, 0, _T("::GetMessage returned -1 (error)\n"));
				continue;	// error, don't process
			}
			else if(!bRet)
			{
				ATLTRACE2(atlTraceUI, 0, _T("CMessageLoop::Run - exiting\n"));
				break;		// WM_QUIT, exit message loop
			}

			if(!PreTranslateMessage(&m_msg))
			{
				::TranslateMessage(&m_msg);
				::DispatchMessage(&m_msg);
			}

			if(IsIdleMessage(&m_msg))
			{
				bDoIdle = TRUE;
				nIdleCount = 0;
			}
		}

		return (int)m_msg.wParam;
	}

	static BOOL IsIdleMessage(MSG* pMsg)
	{
		// These messages should NOT cause idle processing
		switch(pMsg->message)
		{
		case WM_MOUSEMOVE:
		case WM_NCMOUSEMOVE:
		case WM_PAINT:
		case 0x0118:	// WM_SYSTIMER (caret blink)
			return FALSE;
		}

		return TRUE;
	}

// Overrideables
	// Override to change message filtering
	virtual BOOL PreTranslateMessage(MSG* pMsg)
	{
		// loop backwards
		for(int i = m_aMsgFilter.GetSize() - 1; i >= 0; i--)
		{
			CMessageFilter* pMessageFilter = m_aMsgFilter[i];
			if(pMessageFilter != NULL && pMessageFilter->PreTranslateMessage(pMsg))
				return TRUE;
		}
		return FALSE;	// not translated
	}
	// override to change idle processing
	virtual BOOL OnIdle(int /*nIdleCount*/)
	{
		for(int i = 0; i < m_aIdleHandler.GetSize(); i++)
		{
			CIdleHandler* pIdleHandler = m_aIdleHandler[i];
			if(pIdleHandler != NULL)
				pIdleHandler->OnIdle();
		}
		return FALSE;	// don't continue
	}
};


/////////////////////////////////////////////////////////////////////////////
// CAppModule - module class for an application

class CAppModule : public CComModule
{
public:
	DWORD m_dwMainThreadID;
	CSimpleMap<DWORD, CMessageLoop*>* m_pMsgLoopMap;
	CSimpleArray<HWND>* m_pSettingChangeNotify;

// Overrides of CComModule::Init and Term
	HRESULT Init(_ATL_OBJMAP_ENTRY* pObjMap, HINSTANCE hInstance, const GUID* pLibID = NULL)
	{
		HRESULT hRet = CComModule::Init(pObjMap, hInstance, pLibID);
		if(FAILED(hRet))
			return hRet;

		m_dwMainThreadID = ::GetCurrentThreadId();
		typedef CSimpleMap<DWORD, CMessageLoop*>	mapClass;
		m_pMsgLoopMap = NULL;
		ATLTRY(m_pMsgLoopMap = new mapClass);
		if(m_pMsgLoopMap == NULL)
			return E_OUTOFMEMORY;
		m_pSettingChangeNotify = NULL;

		return hRet;
	}
	void Term()
	{
		if(m_pSettingChangeNotify != NULL && m_pSettingChangeNotify->GetSize() > 0)
		{
			::DestroyWindow((*m_pSettingChangeNotify)[0]);
		}
		delete m_pSettingChangeNotify;
		delete m_pMsgLoopMap;
		CComModule::Term();
	}

// Message loop map methods
	BOOL AddMessageLoop(CMessageLoop* pMsgLoop)
	{
		ATLASSERT(pMsgLoop != NULL);
		ATLASSERT(m_pMsgLoopMap->Lookup(::GetCurrentThreadId()) == NULL);	// not in map yet
		return m_pMsgLoopMap->Add(::GetCurrentThreadId(), pMsgLoop);
	}
	BOOL RemoveMessageLoop()
	{
		return m_pMsgLoopMap->Remove(::GetCurrentThreadId());
	}
	CMessageLoop* GetMessageLoop(DWORD dwThreadID = ::GetCurrentThreadId()) const
	{
		return m_pMsgLoopMap->Lookup(dwThreadID);
	}

// Setting change notify methods
	BOOL AddSettingChangeNotify(HWND hWnd)
	{
		ATLASSERT(::IsWindow(hWnd));
		if(m_pSettingChangeNotify == NULL)
		{
			typedef CSimpleArray<HWND>	notifyClass;
			ATLTRY(m_pSettingChangeNotify = new notifyClass);
			ATLASSERT(m_pSettingChangeNotify != NULL);
			if(m_pSettingChangeNotify == NULL)
				return FALSE;
		}
		if(m_pSettingChangeNotify->GetSize() == 0)
		{
			// init everything
			_ATL_EMPTY_DLGTEMPLATE templ;
			HWND hNtfWnd = ::CreateDialogIndirect(GetModuleInstance(), &templ, NULL, _SettingChangeDlgProc);
			ATLASSERT(::IsWindow(hNtfWnd));
			if(::IsWindow(hNtfWnd))
			{
				::SetWindowLongPtr(hNtfWnd, GWLP_USERDATA, (LONG_PTR)this);
				m_pSettingChangeNotify->Add(hNtfWnd);
			}
		}
		return m_pSettingChangeNotify->Add(hWnd);
	}

	BOOL RemoveSettingChangeNotify(HWND hWnd)
	{
		if(m_pSettingChangeNotify == NULL)
			return FALSE;
		return m_pSettingChangeNotify->Remove(hWnd);
	}

// Implementation - setting change notify dialog template and dialog procedure
	struct _ATL_EMPTY_DLGTEMPLATE : DLGTEMPLATE
	{
		_ATL_EMPTY_DLGTEMPLATE()
		{
			memset(this, 0, sizeof(_ATL_EMPTY_DLGTEMPLATE));
			style = WS_POPUP;
		}
		WORD wMenu, wClass, wTitle;
	};

#ifdef _WIN64
	static INT_PTR CALLBACK _SettingChangeDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
#else
	static BOOL CALLBACK _SettingChangeDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
#endif
	{
		if(uMsg == WM_SETTINGCHANGE)
		{
			CAppModule* pModule = (CAppModule*)::GetWindowLongPtr(hWnd, GWLP_USERDATA);
			ATLASSERT(pModule != NULL);
			ATLASSERT(pModule->m_pSettingChangeNotify != NULL);
			for(int i = 1; i < pModule->m_pSettingChangeNotify->GetSize(); i++)
				::SendMessageTimeout((*pModule->m_pSettingChangeNotify)[i], uMsg, wParam, lParam, SMTO_ABORTIFHUNG, 1500, NULL);
			return TRUE;
		}
		return FALSE;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CServerAppModule - module class for a COM server application

class CServerAppModule : public CAppModule
{
public:
	HANDLE m_hEventShutdown;
	bool m_bActivity;
	DWORD m_dwTimeOut;
	DWORD m_dwPause;

// Override of CAppModule::Init
	HRESULT Init(_ATL_OBJMAP_ENTRY* pObjMap, HINSTANCE hInstance, const GUID* pLibID = NULL)
	{
		m_dwTimeOut = 5000;
		m_dwPause = 1000;
		return CAppModule::Init(pObjMap, hInstance, pLibID);
	}
	void Term()
	{
		if(m_hEventShutdown != NULL && ::CloseHandle(m_hEventShutdown))
			m_hEventShutdown = NULL;
		CAppModule::Term();
	}

// COM Server methods
	LONG Unlock()
	{
		LONG lRet = CComModule::Unlock();
		if(lRet == 0)
		{
			m_bActivity = true;
			::SetEvent(m_hEventShutdown); // tell monitor that we transitioned to zero
		}
		return lRet;
	}

	void MonitorShutdown()
	{
		while(1)
		{
			::WaitForSingleObject(m_hEventShutdown, INFINITE);
			DWORD dwWait = 0;
			do
			{
				m_bActivity = false;
				dwWait = ::WaitForSingleObject(m_hEventShutdown, m_dwTimeOut);
			}
			while(dwWait == WAIT_OBJECT_0);
			// timed out
			if(!m_bActivity && m_nLockCnt == 0) // if no activity let's really bail
			{
#if ((_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)) & defined(_ATL_FREE_THREADED)
				::CoSuspendClassObjects();
				if(!m_bActivity && m_nLockCnt == 0)
#endif
					break;
			}
		}
		// This handle should be valid now. If it isn't, 
		// check if _Module.Term was called first (it shouldn't)
		if(::CloseHandle(m_hEventShutdown))
			m_hEventShutdown = NULL;
		::PostThreadMessage(m_dwMainThreadID, WM_QUIT, 0, 0);
	}

	bool StartMonitor()
	{
		m_hEventShutdown = ::CreateEvent(NULL, false, false, NULL);
		if(m_hEventShutdown == NULL)
			return false;
		DWORD dwThreadID;
#if !defined(_ATL_MIN_CRT) & defined(_MT)
		HANDLE hThread = (HANDLE)_beginthreadex(NULL, 0, (UINT (WINAPI*)(void*))MonitorProc, this, 0, (UINT*)&dwThreadID);
#else
		HANDLE hThread = ::CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
#endif
		bool bRet = (hThread != NULL);
		if(bRet)
			::CloseHandle(hThread);
		return bRet;
	}

	static DWORD WINAPI MonitorProc(void* pv)
	{
		CServerAppModule* p = (CServerAppModule*)pv;
		p->MonitorShutdown();
#if !defined(_ATL_MIN_CRT) & defined(_MT)
		_endthreadex(0);
#endif
		return 0;
	}

	// Scan command line and perform registration
	// Return value specifies if server should run

	// Parses the command line and registers/unregisters the rgs file if necessary
	bool ParseCommandLine(LPCTSTR lpCmdLine, UINT nResId, HRESULT* pnRetCode)
	{
		TCHAR szTokens[] = _T("-/");
		*pnRetCode = S_OK;

		LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
		while(lpszToken != NULL)
		{
			if(lstrcmpi(lpszToken, _T("UnregServer"))==0)
			{
				*pnRetCode = UnregisterServer(TRUE);
				ATLASSERT(SUCCEEDED(*pnRetCode));
				if(FAILED(*pnRetCode))
					return false;
				*pnRetCode = UpdateRegistryFromResource(nResId, FALSE);
				return false;
			}

			// Register as Local Server
			if(lstrcmpi(lpszToken, _T("RegServer"))==0)
			{
				*pnRetCode = UpdateRegistryFromResource(nResId, TRUE);
				ATLASSERT(SUCCEEDED(*pnRetCode));
				if(FAILED(*pnRetCode))
					return false;
				*pnRetCode = RegisterServer(TRUE);
				return false;
			}

			lpszToken = FindOneOf(lpszToken, szTokens);
		}
		return true;
	}
	
	// Parses the command line and registers/unregisters the appid if necessary
	bool ParseCommandLine(LPCTSTR lpCmdLine, LPCTSTR pAppId, HRESULT* pnRetCode)
	{
		TCHAR szTokens[] = _T("-/");
		*pnRetCode = S_OK;

		LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
		while(lpszToken != NULL)
		{
			if(lstrcmpi(lpszToken, _T("UnregServer"))==0)
			{
				*pnRetCode = UnregisterAppId(pAppId);
				ATLASSERT(SUCCEEDED(*pnRetCode));
				if(FAILED(*pnRetCode))
					return false;
				*pnRetCode = UnregisterServer(TRUE);
				return false;
			}

			// Register as Local Server
			if(lstrcmpi(lpszToken, _T("RegServer"))==0)
			{
				*pnRetCode = RegisterAppId(pAppId);
				ATLASSERT(SUCCEEDED(*pnRetCode));
				if(FAILED(*pnRetCode))
					return false;
				*pnRetCode = RegisterServer(TRUE);
				return false;
			}

			lpszToken = FindOneOf(lpszToken, szTokens);
		}
		return true;
	}

#if !defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)
	// search for an occurence of string p2 in string p1
	static LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
	{
		while(p1 != NULL && *p1 != NULL)
		{
			LPCTSTR p = p2;
			while(p != NULL && *p != NULL)
			{
				if(*p1 == *p)
					return ::CharNext(p1);
				p = ::CharNext(p);
			}
			p1 = ::CharNext(p1);
		}
		return NULL;
	}

	HRESULT RegisterAppId(LPCTSTR pAppId)
	{
		CRegKey keyAppID;
		if(keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ) == ERROR_SUCCESS)
		{
			TCHAR szModule1[_MAX_PATH+1] = {0};
			TCHAR szModule2[_MAX_PATH+1];
			TCHAR* pszFileName;
			::GetModuleFileName(GetModuleInstance(), szModule1, _MAX_PATH);
			::GetFullPathName(szModule1, _MAX_PATH, szModule2, &pszFileName);
			CRegKey keyAppIDEXE;
			if(keyAppIDEXE.Create(keyAppID, pszFileName, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE) == ERROR_SUCCESS)
				keyAppIDEXE.SetValue(pAppId, _T("AppID"));
			if(keyAppIDEXE.Create(keyAppID, pAppId, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE) == ERROR_SUCCESS)
				keyAppIDEXE.SetValue(pszFileName);
		}
		return S_OK;
	}

	HRESULT UnregisterAppId(LPCTSTR pAppId)
	{
		CRegKey keyAppID;
		if(keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ) == ERROR_SUCCESS)
		{
			TCHAR szModule1[_MAX_PATH+1] = {0};
			TCHAR szModule2[_MAX_PATH];
			TCHAR* pszFileName;
			::GetModuleFileName(GetModuleInstance(), szModule1, _MAX_PATH);
			::GetFullPathName(szModule1, _MAX_PATH, szModule2, &pszFileName);
			keyAppID.RecurseDeleteKey(pszFileName);
			keyAppID.RecurseDeleteKey(pAppId);
		}
		return S_OK;
	}
#endif //!defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)
};


/////////////////////////////////////////////////////////////////////////////
// ATL 3.0 Add-ons

// protect template members from windowsx.h macros
#ifdef _INC_WINDOWSX
#undef SubclassWindow
#endif //_INC_WINDOWSX

// define useful macros from windowsx.h
#ifndef GET_X_LPARAM
#define GET_X_LPARAM(lParam)	((int)(short)LOWORD(lParam))
#endif
#ifndef GET_Y_LPARAM
#define GET_Y_LPARAM(lParam)	((int)(short)HIWORD(lParam))
#endif


/////////////////////////////////////////////////////////////////////////////
// Dual argument helper classes

#ifndef _ATL_TMP_IMPL2

class _U_RECT
{
public:
	_U_RECT(LPRECT lpRect) : m_lpRect(lpRect)
	{ }
	_U_RECT(RECT& rc) : m_lpRect(&rc)
	{ }
	LPRECT m_lpRect;
};

class _U_MENUorID
{
public:
	_U_MENUorID(HMENU hMenu) : m_hMenu(hMenu)
	{ }
	_U_MENUorID(UINT nID) : m_hMenu((HMENU)LongToHandle(nID))
	{ }
	HMENU m_hMenu;
};

class _U_STRINGorID
{
public:
	_U_STRINGorID(LPCTSTR lpString) : m_lpstr(lpString)
	{ }
	_U_STRINGorID(UINT nID) : m_lpstr(MAKEINTRESOURCE(nID))
	{ }
	LPCTSTR m_lpstr;
};

#endif //!_ATL_TMP_IMPL2


/////////////////////////////////////////////////////////////////////////////
// Forward notifications support for message maps

#if !defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)

// forward notifications support
#define FORWARD_NOTIFICATIONS() \
	{ \
		bHandled = TRUE; \
		lResult = Atl3ForwardNotifications(m_hWnd, uMsg, wParam, lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

static LRESULT Atl3ForwardNotifications(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	LRESULT lResult = 0;
	switch(uMsg)
	{
	case WM_COMMAND:
	case WM_NOTIFY:
	case WM_PARENTNOTIFY:
	case WM_DRAWITEM:
	case WM_MEASUREITEM:
	case WM_COMPAREITEM:
	case WM_DELETEITEM:
	case WM_VKEYTOITEM:
	case WM_CHARTOITEM:
	case WM_HSCROLL:
	case WM_VSCROLL:
	case WM_CTLCOLORBTN:
	case WM_CTLCOLORDLG:
	case WM_CTLCOLOREDIT:
	case WM_CTLCOLORLISTBOX:
	case WM_CTLCOLORMSGBOX:
	case WM_CTLCOLORSCROLLBAR:
	case WM_CTLCOLORSTATIC:
		lResult = ::SendMessage(::GetParent(hWnd), uMsg, wParam, lParam);
		break;
	default:
		bHandled = FALSE;
		break;
	}
	return lResult;
}


/////////////////////////////////////////////////////////////////////////////
// Reflected message handler macros for message maps

#define REFLECTED_COMMAND_HANDLER(id, code, func) \
	if(uMsg == OCM_COMMAND && id == LOWORD(wParam) && code == HIWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_ID_HANDLER(id, func) \
	if(uMsg == OCM_COMMAND && id == LOWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_CODE_HANDLER(code, func) \
	if(uMsg == OCM_COMMAND && code == HIWORD(wParam)) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_RANGE_HANDLER(idFirst, idLast, func) \
	if(uMsg == OCM_COMMAND && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_RANGE_CODE_HANDLER(idFirst, idLast, code, func) \
	if(uMsg == OCM_COMMAND && code == HIWORD(wParam) && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_HANDLER(id, cd, func) \
	if(uMsg == OCM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom && cd == ((LPNMHDR)lParam)->code) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_ID_HANDLER(id, func) \
	if(uMsg == OCM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_CODE_HANDLER(cd, func) \
	if(uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_RANGE_HANDLER(idFirst, idLast, func) \
	if(uMsg == OCM_NOTIFY && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

#define REFLECTED_NOTIFY_RANGE_CODE_HANDLER(idFirst, idLast, cd, func) \
	if(uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		bHandled = TRUE; \
		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
		if(bHandled) \
			return TRUE; \
	}

/////////////////////////////////////////////////////////////////////////////
// CString forward reference (to be used with atluser.h and atlgdi.h)

#ifdef _WTL_FORWARD_DECLARE_CSTRING

#define __ATLSTR_H__
class CString;	// forward declaration (include atlmisc.h for the whole class)

#endif //_WTL_FORWARD_DECLARE_CSTRING

#endif //!defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)

}; //namespace WTL

// These are always included
#include <atluser.h>
#include <atlgdi.h>

// old names compatibility
#ifdef _ATL_TMP_IMPL1
namespace WTL
{
typedef CFontHandle		CWinFont;
typedef CMenuHandle		CWinMenu;
#define CWinPropertyPageImpl	CPropertyPageImpl
typedef CDCHandle		CWinDC;
}; //namespace WTL
#endif //_ATL_TMP_IMPL1

#ifndef _WTL_NO_AUTOMATIC_NAMESPACE
using namespace WTL;
#endif //!_WTL_NO_AUTOMATIC_NAMESPACE

#endif // __ATLAPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wtl10\atlctrls.h ===
// WTL Version 3.1
// Copyright (C) 1997-2000 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLCTRLS_H__
#define __ATLCTRLS_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlctrls.h requires atlapp.h to be included first
#endif

#ifndef __ATLWIN_H__
	#error atlctrls.h requires atlwin.h to be included first
#endif

#if (_WIN32_IE < 0x0300)
	#error atlctrls.h requires IE Version 3.0 or higher
#endif


#include <richedit.h>
#include <richole.h>

// protect template members from windowsx.h macros
#ifdef _INC_WINDOWSX
#undef GetNextSibling
#undef GetPrevSibling
#endif //_INC_WINDOWSX


namespace WTL
{

// These are wrapper classes for Windows standard and common controls.
// To implement a window based on a control, use following:
// Example: Implementing a window based on a list box
//
// class CMyListBox : CWindowImpl<CMyListBox, CListBox>
// {
// public:
//      BEGIN_MSG_MAP(CMyListBox)
//          // put your message handler entries here
//      END_MSG_MAP()
// };


/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class TBase> class CStaticT;
template <class TBase> class CButtonT;
template <class TBase> class CListBoxT;
template <class TBase> class CComboBoxT;
template <class TBase> class CEditT;
template <class T> class CEditCommands;
template <class TBase> class CScrollBarT;
class CImageList;
template <class TBase> class CListViewCtrlT;
template <class TBase> class CTreeViewCtrlT;
class CTreeItem;
template <class TBase> class CTreeViewCtrlExT;
template <class TBase> class CHeaderCtrlT;
template <class TBase> class CToolBarCtrlT;
template <class TBase> class CStatusBarCtrlT;
template <class TBase> class CTabCtrlT;
class CToolInfo;
template <class TBase> class CToolTipCtrlT;
template <class TBase> class CTrackBarCtrlT;
template <class TBase> class CUpDownCtrlT;
template <class TBase> class CProgressBarCtrlT;
template <class TBase> class CHotKeyCtrlT;
template <class TBase> class CAnimateCtrlT;
template <class TBase> class CRichEditCtrlT;
template <class T> class CRichEditCommands;
template <class TBase> class CDragListBoxT;
template <class T> class CDragListNotifyImpl;
template <class TBase> class CReBarCtrlT;
template <class TBase> class CComboBoxExT;
template <class TBase> class CDateTimePickerCtrlT;
template <class TBase> class CMonthCalendarCtrlT;
#if (_WIN32_IE >= 0x0400)
template <class T> class CFlatScrollBarImpl;
template <class TBase> class CFlatScrollBarT;
template <class TBase> class CIPAddressCtrlT;
template <class TBase> class CPagerCtrlT;
#endif //(_WIN32_IE >= 0x0400)
template <class T> class CCustomDraw;



// --- Standard Windows controls ---

/////////////////////////////////////////////////////////////////////////////
// CStatic - client side for a Windows STATIC control

template <class TBase>
class CStaticT : public TBase
{
public:
// Constructors
	CStaticT(HWND hWnd = NULL) : TBase(hWnd) { }

	CStaticT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return _T("STATIC");
	}

	HICON GetIcon() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HICON)::SendMessage(m_hWnd, STM_GETICON, 0, 0L);
	}
	HICON SetIcon(HICON hIcon)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HICON)::SendMessage(m_hWnd, STM_SETICON, (WPARAM)hIcon, 0L);
	}
	HENHMETAFILE GetEnhMetaFile() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HENHMETAFILE)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_ENHMETAFILE, 0L);
	}
	HENHMETAFILE SetEnhMetaFile(HENHMETAFILE hMetaFile)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HENHMETAFILE)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_ENHMETAFILE, (LPARAM)hMetaFile);
	}
	CBitmapHandle GetBitmap() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CBitmapHandle((HBITMAP)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_BITMAP, 0L));
	}
	CBitmapHandle SetBitmap(HBITMAP hBitmap)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CBitmapHandle((HBITMAP)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap));
	}
	HCURSOR GetCursor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HCURSOR)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_CURSOR, 0L);
	}
	HCURSOR SetCursor(HCURSOR hCursor)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HCURSOR)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_CURSOR, (LPARAM)hCursor);
	}
};

typedef CStaticT<CWindow>	CStatic;


/////////////////////////////////////////////////////////////////////////////
// CButton - client side for a Windows BUTTON control

template <class TBase>
class CButtonT : public TBase
{
public:
// Constructors
	CButtonT(HWND hWnd = NULL) : TBase(hWnd) { }

	CButtonT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return _T("BUTTON");
	}

	UINT GetState() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, BM_GETSTATE, 0, 0L);
	}
	void SetState(BOOL bHighlight)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, BM_SETSTATE, bHighlight, 0L);
	}
	int GetCheck() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, BM_GETCHECK, 0, 0L);
	}
	void SetCheck(int nCheck)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, BM_SETCHECK, nCheck, 0L);
	}
	UINT GetButtonStyle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::GetWindowLong(m_hWnd, GWL_STYLE) & 0xff;
	}
	void SetButtonStyle(UINT nStyle, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, BM_SETSTYLE, nStyle, (LPARAM)bRedraw);
	}

	HICON GetIcon() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HICON)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_ICON, 0L);
	}
	HICON SetIcon(HICON hIcon)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HICON)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
	}
	CBitmapHandle GetBitmap() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CBitmapHandle((HBITMAP)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_BITMAP, 0L));
	}
	CBitmapHandle SetBitmap(HBITMAP hBitmap)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CBitmapHandle((HBITMAP)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap));
	}

// Operations
	void Click()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, BM_CLICK, 0, 0L);
	}
};

typedef CButtonT<CWindow>	CButton;


/////////////////////////////////////////////////////////////////////////////
// CListBox - client side for a Windows LISTBOX control

template <class TBase>
class CListBoxT : public TBase
{
public:
// Constructors
	CListBoxT(HWND hWnd = NULL) : TBase(hWnd) { }

	CListBoxT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return _T("LISTBOX");
	}

	// for entire listbox
	int GetCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0L);
	}
	int SetCount(int cItems)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(((GetStyle() & LBS_NODATA) != 0) && ((GetStyle() & LBS_HASSTRINGS) == 0));
		return (int)::SendMessage(m_hWnd, LB_SETCOUNT, cItems, 0L);
	}
	int GetHorizontalExtent() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETHORIZONTALEXTENT, 0, 0L);
	}
	void SetHorizontalExtent(int cxExtent)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, LB_SETHORIZONTALEXTENT, cxExtent, 0L);
	}
	int GetTopIndex() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETTOPINDEX, 0, 0L);
	}
	int SetTopIndex(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_SETTOPINDEX, nIndex, 0L);
	}
	LCID GetLocale() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LCID)::SendMessage(m_hWnd, LB_GETLOCALE, 0, 0L);
	}
	LCID SetLocale(LCID nNewLocale)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LCID)::SendMessage(m_hWnd, LB_SETLOCALE, (WPARAM)nNewLocale, 0L);
	}

	// for single-selection listboxes
	int GetCurSel() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) == 0);
		return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0L);
	}
	int SetCurSel(int nSelect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) == 0);
		return (int)::SendMessage(m_hWnd, LB_SETCURSEL, nSelect, 0L);
	}

	// for multiple-selection listboxes
	int GetSel(int nIndex) const           // also works for single-selection
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETSEL, nIndex, 0L);
	}
	int SetSel(int nIndex, BOOL bSelect = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
		return (int)::SendMessage(m_hWnd, LB_SETSEL, bSelect, nIndex);
	}
	int GetSelCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
		return (int)::SendMessage(m_hWnd, LB_GETSELCOUNT, 0, 0L);
	}
	int GetSelItems(int nMaxItems, LPINT rgIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
		return (int)::SendMessage(m_hWnd, LB_GETSELITEMS, nMaxItems, (LPARAM)rgIndex);
	}
	int GetAnchorIndex() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
		return (int)::SendMessage(m_hWnd, LB_GETANCHORINDEX, 0, 0L);
	}
	void SetAnchorIndex(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
		::SendMessage(m_hWnd, LB_SETANCHORINDEX, nIndex, 0L);
	}
	int GetCaretIndex() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETCARETINDEX, 0, 0);
	}
	int SetCaretIndex(int nIndex, BOOL bScroll = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_SETCARETINDEX, nIndex, MAKELONG(bScroll, 0));
	}

	// for listbox items
	DWORD_PTR GetItemData(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD_PTR)::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0L);
	}
	int SetItemData(int nIndex, DWORD_PTR dwItemData)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_SETITEMDATA, nIndex, (LPARAM)dwItemData);
	}
	void* GetItemDataPtr(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (void*)::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0L);
	}
	int SetItemDataPtr(int nIndex, void* pData)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItemData(nIndex, (DWORD_PTR)pData);
	}
	int GetItemRect(int nIndex, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETITEMRECT, nIndex, (LPARAM)lpRect);
	}
	int GetText(int nIndex, LPTSTR lpszBuffer) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETTEXT, nIndex, (LPARAM)lpszBuffer);
	}
#ifndef _ATL_NO_COM
#ifdef _OLEAUTO_H_
	BOOL GetTextBSTR(int nIndex, BSTR& bstrText) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(bstrText == NULL);

		int nLen = GetTextLen(nIndex);
		if(nLen == LB_ERR)
			return FALSE;

		LPTSTR lpszText = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));

		if(GetText(nIndex, lpszText) == LB_ERR)
			return FALSE;

		bstrText = ::SysAllocString(T2OLE(lpszText));
		return (bstrText != NULL) ? TRUE : FALSE;
	}
#endif // _OLEAUTO_H_
#endif //!_ATL_NO_COM
#ifdef __ATLSTR_H__
	int GetText(int nIndex, CString& strText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nRet = GetText(nIndex, strText.GetBufferSetLength(GetTextLen(nIndex)));
		strText.ReleaseBuffer();
		return nRet;
	}
#endif //__ATLSTR_H__
	int GetTextLen(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETTEXTLEN, nIndex, 0L);
	}
	int GetItemHeight(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_GETITEMHEIGHT, nIndex, 0L);
	}
	int SetItemHeight(int nIndex, UINT cyItemHeight)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_SETITEMHEIGHT, nIndex, MAKELONG(cyItemHeight, 0));
	}

	// Settable only attributes
	void SetColumnWidth(int cxWidth)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, LB_SETCOLUMNWIDTH, cxWidth, 0L);
	}
	BOOL SetTabStops(int nTabStops, LPINT rgTabStops)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & LBS_USETABSTOPS) != 0);
		return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, nTabStops, (LPARAM)rgTabStops);
	}
	BOOL SetTabStops()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & LBS_USETABSTOPS) != 0);
		return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, 0, 0L);
	}
	BOOL SetTabStops(const int& cxEachStop)    // takes an 'int'
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & LBS_USETABSTOPS) != 0);
		return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, 1, (LPARAM)(LPINT)&cxEachStop);
	}

// Operations
	int InitStorage(int nItems, UINT nBytes)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_INITSTORAGE, (WPARAM)nItems, nBytes);
	}
	void ResetContent()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, LB_RESETCONTENT, 0, 0L);
	}
	UINT ItemFromPoint(POINT pt, BOOL& bOutside) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dw = (DWORD)::SendMessage(m_hWnd, LB_ITEMFROMPOINT, 0, MAKELPARAM(pt.x, pt.y));
		bOutside = (BOOL)HIWORD(dw);
		return (UINT)LOWORD(dw);
	}

	// manipulating listbox items
	int AddString(LPCTSTR lpszItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem);
	}
	int DeleteString(UINT nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_DELETESTRING, nIndex, 0L);
	}
	int InsertString(int nIndex, LPCTSTR lpszItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_INSERTSTRING, nIndex, (LPARAM)lpszItem);
	}
	int Dir(UINT attr, LPCTSTR lpszWildCard)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_DIR, attr, (LPARAM)lpszWildCard);
	}
	int AddFile(LPCTSTR lpstrFileName)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_ADDFILE, 0, (LPARAM)lpstrFileName);
	}

	// selection helpers
	int FindString(int nStartAfter, LPCTSTR lpszItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_FINDSTRING, nStartAfter, (LPARAM)lpszItem);
	}
	int FindStringExact(int nIndexStart, LPCTSTR lpszFind) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind);
	}
	int SelectString(int nStartAfter, LPCTSTR lpszItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LB_SELECTSTRING, nStartAfter, (LPARAM)lpszItem);
	}
	int SelItemRange(BOOL bSelect, int nFirstItem, int nLastItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
		ATLASSERT(nFirstItem <= nLastItem);
		return bSelect ? (int)::SendMessage(m_hWnd, LB_SELITEMRANGEEX, nFirstItem, nLastItem) : (int)::SendMessage(m_hWnd, LB_SELITEMRANGEEX, nLastItem, nFirstItem);
	}
};

typedef CListBoxT<CWindow>	CListBox;


/////////////////////////////////////////////////////////////////////////////
// CComboBox - client side for a Windows COMBOBOX control

template <class TBase>
class CComboBoxT : public TBase
{
public:
// Constructors
	CComboBoxT(HWND hWnd = NULL) : TBase(hWnd) { }

	CComboBoxT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return _T("COMBOBOX");
	}

	// for entire combo box
	int GetCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_GETCOUNT, 0, 0L);
	}
	int GetCurSel() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0L);
	}
	int SetCurSel(int nSelect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_SETCURSEL, nSelect, 0L);
	}
	LCID GetLocale() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LCID)::SendMessage(m_hWnd, CB_GETLOCALE, 0, 0L);
	}
	LCID SetLocale(LCID nNewLocale)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LCID)::SendMessage(m_hWnd, CB_SETLOCALE, (WPARAM)nNewLocale, 0L);
	}
	int GetTopIndex() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_GETTOPINDEX, 0, 0L);
	}
	int SetTopIndex(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_SETTOPINDEX, nIndex, 0L);
	}
	UINT GetHorizontalExtent() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, CB_GETHORIZONTALEXTENT, 0, 0L);
	}
	void SetHorizontalExtent(UINT nExtent)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, CB_SETHORIZONTALEXTENT, nExtent, 0L);
	}
	int GetDroppedWidth() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_GETDROPPEDWIDTH, 0, 0L);
	}
	int SetDroppedWidth(UINT nWidth)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_SETDROPPEDWIDTH, nWidth, 0L);
	}

	// for edit control
	DWORD GetEditSel() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, CB_GETEDITSEL, 0, 0L);
	}
	BOOL SetEditSel(int nStartChar, int nEndChar)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CB_SETEDITSEL, 0, MAKELONG(nStartChar, nEndChar));
	}

	// for combobox item
	DWORD_PTR GetItemData(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD_PTR)::SendMessage(m_hWnd, CB_GETITEMDATA, nIndex, 0L);
	}
	int SetItemData(int nIndex, DWORD_PTR dwItemData)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_SETITEMDATA, nIndex, (LPARAM)dwItemData);
	}
	void* GetItemDataPtr(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (void*)GetItemData(nIndex);
	}
	int SetItemDataPtr(int nIndex, void* pData)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItemData(nIndex, (DWORD_PTR)pData);
	}
	int GetLBText(int nIndex, LPTSTR lpszText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_GETLBTEXT, nIndex, (LPARAM)lpszText);
	}
#ifndef _ATL_NO_COM
	BOOL GetLBTextBSTR(int nIndex, BSTR& bstrText) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(bstrText == NULL);

		int nLen = GetLBTextLen(nIndex);
		if(nLen == CB_ERR)
			return FALSE;

		LPTSTR lpszText = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));

		if(GetLBText(nIndex, lpszText) == CB_ERR)
			return FALSE;

		bstrText = ::SysAllocString(T2OLE(lpszText));
		return (bstrText != NULL) ? TRUE : FALSE;
	}
#endif //!_ATL_NO_COM
#ifdef __ATLSTR_H__
	int GetLBText(int nIndex, CString& strText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nRet = GetLBText(nIndex, strText.GetBufferSetLength(GetLBTextLen(nIndex)));
		strText.ReleaseBuffer();
		return nRet;
	}
#endif //__ATLSTR_H__
	int GetLBTextLen(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_GETLBTEXTLEN, nIndex, 0L);
	}

	int GetItemHeight(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_GETITEMHEIGHT, nIndex, 0L);
	}
	int SetItemHeight(int nIndex, UINT cyItemHeight)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_SETITEMHEIGHT, nIndex, MAKELONG(cyItemHeight, 0));
	}
	BOOL GetExtendedUI() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CB_GETEXTENDEDUI, 0, 0L);
	}
	int SetExtendedUI(BOOL bExtended = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_SETEXTENDEDUI, bExtended, 0L);
	}
	void GetDroppedControlRect(LPRECT lprect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)lprect);
	}
	BOOL GetDroppedState() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CB_GETDROPPEDSTATE, 0, 0L);
	}

// Operations
	int InitStorage(int nItems, UINT nBytes)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_INITSTORAGE, (WPARAM)nItems, nBytes);
	}
	void ResetContent()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, CB_RESETCONTENT, 0, 0L);
	}

	// for edit control
	BOOL LimitText(int nMaxChars)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CB_LIMITTEXT, nMaxChars, 0L);
	}

	// for drop-down combo boxes
	void ShowDropDown(BOOL bShowIt = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, CB_SHOWDROPDOWN, bShowIt, 0L);
	}

	// manipulating listbox items
	int AddString(LPCTSTR lpszString)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_ADDSTRING, 0, (LPARAM)lpszString);
	}
	int DeleteString(UINT nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_DELETESTRING, nIndex, 0L);
	}
	int InsertString(int nIndex, LPCTSTR lpszString)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_INSERTSTRING, nIndex, (LPARAM)lpszString);
	}
	int Dir(UINT attr, LPCTSTR lpszWildCard)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_DIR, attr, (LPARAM)lpszWildCard);
	}

	// selection helpers
	int FindString(int nStartAfter, LPCTSTR lpszString) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_FINDSTRING, nStartAfter, (LPARAM)lpszString);
	}
	int FindStringExact(int nIndexStart, LPCTSTR lpszFind) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind);
	}
	int SelectString(int nStartAfter, LPCTSTR lpszString)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CB_SELECTSTRING, nStartAfter, (LPARAM)lpszString);
	}

	// Clipboard operations
	void Clear()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_CLEAR, 0, 0L);
	}
	void Copy()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_COPY, 0, 0L);
	}
	void Cut()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_CUT, 0, 0L);
	}
	void Paste()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_PASTE, 0, 0L);
	}
};

typedef CComboBoxT<CWindow>	CComboBox;


/////////////////////////////////////////////////////////////////////////////
// CEdit - client side for a Windows EDIT control

template <class TBase>
class CEditT : public TBase
{
public:
// Constructors
	CEditT(HWND hWnd = NULL) : TBase(hWnd) { }

	CEditT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return _T("EDIT");
	}

	BOOL CanUndo() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0L);
	}
	int GetLineCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0L);
	}
	BOOL GetModify() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0L);
	}
	void SetModify(BOOL bModified = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0L);
	}
	void GetRect(LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect);
	}
	DWORD GetSel() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, EM_GETSEL, 0, 0L);
	}
	void GetSel(int& nStartChar, int& nEndChar) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_GETSEL, (WPARAM)&nStartChar, (LPARAM)&nEndChar);
	}
	HLOCAL GetHandle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HLOCAL)::SendMessage(m_hWnd, EM_GETHANDLE, 0, 0L);
	}
	void SetHandle(HLOCAL hBuffer)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETHANDLE, (WPARAM)hBuffer, 0L);
	}
	DWORD GetMargins() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, EM_GETMARGINS, 0, 0L);
	}
	void SetMargins(UINT nLeft, UINT nRight)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETMARGINS, EC_LEFTMARGIN|EC_RIGHTMARGIN, MAKELONG(nLeft, nRight));
	}
	UINT GetLimitText() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, EM_GETLIMITTEXT, 0, 0L);
	}
	void SetLimitText(UINT nMax)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETLIMITTEXT, nMax, 0L);
	}
	POINT PosFromChar(UINT nChar) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, EM_POSFROMCHAR, nChar, 0);
		POINT point = { GET_X_LPARAM(dwRet), GET_Y_LPARAM(dwRet) };
		return point;
	}
	int CharFromPos(POINT pt, int* pLine = NULL) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, EM_CHARFROMPOS, 0, MAKELPARAM(pt.x, pt.y));
		if(pLine != NULL)
			*pLine = (int)(short)HIWORD(dwRet);
		return (int)(short)LOWORD(dwRet);
	}

	// NOTE: first word in lpszBuffer must contain the size of the buffer!
	int GetLine(int nIndex, LPTSTR lpszBuffer) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
	}
	int GetLine(int nIndex, LPTSTR lpszBuffer, int nMaxLength) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		*(LPWORD)lpszBuffer = (WORD)nMaxLength;
		return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
	}

	TCHAR GetPasswordChar() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (TCHAR)::SendMessage(m_hWnd, EM_GETPASSWORDCHAR, 0, 0L);
	}
	void SetPasswordChar(TCHAR ch)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETPASSWORDCHAR, ch, 0L);
	}
	EDITWORDBREAKPROC GetWordBreakProc() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (EDITWORDBREAKPROC)::SendMessage(m_hWnd, EM_GETWORDBREAKPROC, 0, 0L);
	}
	void SetWordBreakProc(EDITWORDBREAKPROC ewbprc)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETWORDBREAKPROC, 0, (LPARAM)ewbprc);
	}
	int GetFirstVisibleLine() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L);
	}
	int GetThumb() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & ES_MULTILINE) != 0);
		return (int)::SendMessage(m_hWnd, EM_GETTHUMB, 0, 0L);
	}
	BOOL SetReadOnly(BOOL bReadOnly = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L);
	}

#if (WINVER >= 0x0500)
	UINT GetImeStatus(UINT uStatus) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, EM_GETIMESTATUS, uStatus, 0L);
	}
	UINT SetImeStatus(UINT uStatus, UINT uData)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, EM_SETIMESTATUS, uStatus, uData);
	}
#endif //(WINVER >= 0x0500)

// Operations
	void EmptyUndoBuffer()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0L);
	}
	BOOL FmtLines(BOOL bAddEOL)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_FMTLINES, bAddEOL, 0L);
	}
	void LimitText(int nChars = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_LIMITTEXT, nChars, 0L);
	}
	int LineFromChar(int nIndex = -1) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_LINEFROMCHAR, nIndex, 0L);
	}
	int LineIndex(int nLine = -1) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_LINEINDEX, nLine, 0L);
	}
	int LineLength(int nLine = -1) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_LINELENGTH, nLine, 0L);
	}
	void LineScroll(int nLines, int nChars = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_LINESCROLL, nChars, nLines);
	}
	void ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM) bCanUndo, (LPARAM)lpszNewText);
	}
	void SetRect(LPCRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect);
	}
	void SetRectNP(LPCRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETRECTNP, 0, (LPARAM)lpRect);
	}
	void SetSel(DWORD dwSelection, BOOL bNoScroll = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETSEL, LOWORD(dwSelection), HIWORD(dwSelection));
		if(!bNoScroll)
			::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0L);
	}
	void SetSel(int nStartChar, int nEndChar, BOOL bNoScroll = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETSEL, nStartChar, nEndChar);
		if(!bNoScroll)
			::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0L);
	}
	void SetSelAll(BOOL bNoScroll = FALSE)
	{
		SetSel(0, -1, bNoScroll);
	}
	void SetSelNone(BOOL bNoScroll = FALSE)
	{
		SetSel(-1, 0, bNoScroll);
	}
	BOOL SetTabStops(int nTabStops, LPINT rgTabStops)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, nTabStops, (LPARAM)rgTabStops);
	}
	BOOL SetTabStops()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, 0, 0L);
	}
	BOOL SetTabStops(const int& cxEachStop)    // takes an 'int'
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, 1, (LPARAM)(LPINT)&cxEachStop);
	}
	void ScrollCaret()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0L);
	}
	int Scroll(int nScrollAction)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & ES_MULTILINE) != 0);
		LRESULT lRet = ::SendMessage(m_hWnd, EM_SCROLL, nScrollAction, 0L);
		if(!(BOOL)HIWORD(lRet))
			return -1;	// failed
		return (int)(short)LOWORD(lRet);
		
	}

	void InsertText(int nInsertAfterChar, LPCTSTR lpstrText, BOOL bNoScroll = FALSE, BOOL bCanUndo = FALSE)
	{
		SetSel(nInsertAfterChar, nInsertAfterChar, bNoScroll);
		ReplaceSel(lpstrText, bCanUndo);
	}
	void AppendText(LPCTSTR lpstrText, BOOL bNoScroll = FALSE, BOOL bCanUndo = FALSE)
	{
		InsertText(GetWindowTextLength(), lpstrText, bNoScroll, bCanUndo);
	}

	// Clipboard operations
	BOOL Undo()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0L);
	}
	void Clear()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_CLEAR, 0, 0L);
	}
	void Copy()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_COPY, 0, 0L);
	}
	void Cut()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_CUT, 0, 0L);
	}
	void Paste()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_PASTE, 0, 0L);
	}
};

typedef CEditT<CWindow>		CEdit;


/////////////////////////////////////////////////////////////////////////////
// CEditCommands - message handlers for standard EDIT commands

// Chain to CEditCommands message map. Your class must also derive from CEdit.
// Example:
// class CMyEdit : public CWindowImpl<CMyEdit, CEdit>,
//                 public CEditCommands<CMyEdit>
// {
// public:
//      BEGIN_MSG_MAP(CMyEdit)
//              // your handlers...
//              CHAIN_MSG_MAP_ALT(CEditCommands<CMyEdit>, 1)
//      END_MSG_MAP()
//      // other stuff...
// };

template <class T>
class CEditCommands
{
public:
	BEGIN_MSG_MAP(CEditCommands< T >)
	ALT_MSG_MAP(1)
		COMMAND_ID_HANDLER(ID_EDIT_CLEAR, OnEditClear)
		COMMAND_ID_HANDLER(ID_EDIT_CLEAR_ALL, OnEditClearAll)
		COMMAND_ID_HANDLER(ID_EDIT_COPY, OnEditCopy)
		COMMAND_ID_HANDLER(ID_EDIT_CUT, OnEditCut)
		COMMAND_ID_HANDLER(ID_EDIT_PASTE, OnEditPaste)
		COMMAND_ID_HANDLER(ID_EDIT_SELECT_ALL, OnEditSelectAll)
		COMMAND_ID_HANDLER(ID_EDIT_UNDO, OnEditUndo)
	END_MSG_MAP()

	LRESULT OnEditClear(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->Clear();
		return 0;
	}
	LRESULT OnEditClearAll(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->SetSel(0, -1);
		pT->Clear();
		return 0;
	}
	LRESULT OnEditCopy(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->Copy();
		return 0;
	}
	LRESULT OnEditCut(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->Cut();
		return 0;
	}
	LRESULT OnEditPaste(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->Paste();
		return 0;
	}
	LRESULT OnEditSelectAll(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->SetSel(0, -1);
		return 0;
	}
	LRESULT OnEditUndo(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->Undo();
		return 0;
	}

// State (update UI) helpers
	BOOL CanCut() const
	{ return HasSelection(); }
	BOOL CanCopy() const
	{ return HasSelection(); }
	BOOL CanClear() const
	{ return HasSelection(); }
	BOOL CanSelectAll() const
	{ return HasText(); }
	BOOL CanFind() const
	{ return HasText(); }
	BOOL CanRepeat() const
	{ return HasText(); }
	BOOL CanReplace() const
	{ return HasText(); }
	BOOL CanClearAll() const
	{ return HasText(); }

// Implementation
	BOOL HasSelection() const
	{
		const T* pT = static_cast<const T*>(this);
		int nMin, nMax;
		::SendMessage(pT->m_hWnd, EM_GETSEL, (WPARAM)&nMin, (LPARAM)&nMax);
		return (nMin != nMax);
	}
	BOOL HasText() const
	{
		const T* pT = static_cast<const T*>(this);
		return (pT->GetWindowTextLength() > 0);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CScrollBar - client side for a Windows SCROLLBAR control

template <class TBase>
class CScrollBarT : public TBase
{
public:
// Constructors
	CScrollBarT(HWND hWnd = NULL) : TBase(hWnd) { }

	CScrollBarT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return _T("SCROLLBAR");
	}

	int GetScrollPos() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetScrollPos(m_hWnd, SB_CTL);
	}
	int SetScrollPos(int nPos, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetScrollPos(m_hWnd, SB_CTL, nPos, bRedraw);
	}
	void GetScrollRange(LPINT lpMinPos, LPINT lpMaxPos) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::GetScrollRange(m_hWnd, SB_CTL, lpMinPos, lpMaxPos);
	}
	void SetScrollRange(int nMinPos, int nMaxPos, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SetScrollRange(m_hWnd, SB_CTL, nMinPos, nMaxPos, bRedraw);
	}
	BOOL GetScrollInfo(LPSCROLLINFO lpScrollInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::GetScrollInfo(m_hWnd, SB_CTL, lpScrollInfo);
	}
	int SetScrollInfo(LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SetScrollInfo(m_hWnd, SB_CTL, lpScrollInfo, bRedraw);
	}
	int GetScrollLimit() const
	{
		int nMin, nMax;
		::GetScrollRange(m_hWnd, SB_CTL, &nMin, &nMax);
		SCROLLINFO info;
		info.cbSize = sizeof(SCROLLINFO);
		info.fMask = SIF_PAGE;
		if(::GetScrollInfo(m_hWnd, SB_CTL, &info))
			nMax -= ((info.nPage-1) > 0) ? (info.nPage-1) : 0;

		return nMax;
	}

// Operations
	void ShowScrollBar(BOOL bShow = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::ShowScrollBar(m_hWnd, SB_CTL, bShow);
	}

	BOOL EnableScrollBar(UINT nArrowFlags = ESB_ENABLE_BOTH)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::EnableScrollBar(m_hWnd, SB_CTL, nArrowFlags);
	}

};

typedef CScrollBarT<CWindow>	CScrollBar;


// --- Windows Common Controls ---

/////////////////////////////////////////////////////////////////////////////
// CImageList

class CImageList
{
public:
	HIMAGELIST m_hImageList;

// Constructor
	CImageList(HIMAGELIST hImageList = NULL) : m_hImageList(hImageList)
	{ }

// Operators, etc.
	CImageList& operator=(HIMAGELIST hImageList)
	{
		m_hImageList = hImageList;
		return *this;
	}

	operator HIMAGELIST() const { return m_hImageList; }

	void Attach(HIMAGELIST hImageList)
	{
		ATLASSERT(m_hImageList == NULL);
		ATLASSERT(hImageList != NULL);
		m_hImageList = hImageList;
	}
	HIMAGELIST Detach()
	{
		HIMAGELIST hImageList = m_hImageList;
		m_hImageList = NULL;
		return hImageList;
	}

	bool IsNull() const { return (m_hImageList == NULL); }

// Attributes
	int GetImageCount() const
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_GetImageCount(m_hImageList);
	}
	COLORREF GetBkColor() const
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_GetBkColor(m_hImageList);
	}
	COLORREF SetBkColor(COLORREF cr)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_SetBkColor(m_hImageList, cr);
	}
	BOOL GetImageInfo(int nImage, IMAGEINFO* pImageInfo) const
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_GetImageInfo(m_hImageList, nImage, pImageInfo);
	}

	HICON GetIcon(int nIndex, UINT uFlags = ILD_NORMAL) const
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_GetIcon(m_hImageList, nIndex, uFlags);
	}
	BOOL GetIconSize(int& cx, int& cy) const
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_GetIconSize(m_hImageList, &cx, &cy);
	}
	BOOL GetIconSize(SIZE& size) const
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_GetIconSize(m_hImageList, (int*)&size.cx, (int*)&size.cy);
	}
	BOOL SetIconSize(int cx, int cy)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_SetIconSize(m_hImageList, cx, cy);
	}
	BOOL SetIconSize(SIZE size)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_SetIconSize(m_hImageList, size.cx, size.cy);
	}
	BOOL SetImageCount(UINT uNewCount)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_SetImageCount(m_hImageList, uNewCount);
	}
	BOOL SetOverlayImage(int nImage, int nOverlay)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_SetOverlayImage(m_hImageList, nImage, nOverlay);
	}

// Operations
	BOOL Create(int cx, int cy, UINT nFlags, int nInitial, int nGrow)
	{
		ATLASSERT(m_hImageList == NULL);
		m_hImageList = ImageList_Create(cx, cy, nFlags, nInitial, nGrow);
		return (m_hImageList != NULL) ? TRUE : FALSE;
	}
	BOOL Create(_U_STRINGorID bitmap, int cx, int nGrow, COLORREF crMask)
	{
		ATLASSERT(m_hImageList == NULL);
		m_hImageList = ImageList_LoadBitmap(_Module.GetResourceInstance(), bitmap.m_lpstr, cx, nGrow, crMask);
		return (m_hImageList != NULL) ? TRUE : FALSE;
	}
	BOOL CreateFromImage(_U_STRINGorID image, int cx, int nGrow, COLORREF crMask, UINT uType, UINT uFlags = LR_DEFAULTCOLOR | LR_DEFAULTSIZE)
	{
		ATLASSERT(m_hImageList == NULL);
		m_hImageList = ImageList_LoadImage(_Module.GetResourceInstance(), image.m_lpstr, cx, nGrow, crMask, uType, uFlags);
		return (m_hImageList != NULL) ? TRUE : FALSE;
	}
	BOOL Merge(HIMAGELIST hImageList1, int nImage1, HIMAGELIST hImageList2, int nImage2, int dx, int dy)
	{
		ATLASSERT(m_hImageList == NULL);
		m_hImageList = ImageList_Merge(hImageList1, nImage1, hImageList2, nImage2, dx, dy);
		return (m_hImageList != NULL) ? TRUE : FALSE;
	}

	BOOL Destroy()
	{
		if (m_hImageList == NULL)
			return FALSE;
		BOOL bRet = ImageList_Destroy(Detach());
		if(bRet)
			m_hImageList = NULL;
		return bRet;
	}

	int Add(HBITMAP hBitmap, HBITMAP hBitmapMask = NULL)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_Add(m_hImageList, hBitmap, hBitmapMask);
	}
	int Add(HBITMAP hBitmap, COLORREF crMask)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_AddMasked(m_hImageList, hBitmap, crMask);
	}
	BOOL Remove(int nImage)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_Remove(m_hImageList, nImage);
	}
	BOOL RemoveAll()
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_RemoveAll(m_hImageList);
	}
	BOOL Replace(int nImage, HBITMAP hBitmap, HBITMAP hBitmapMask)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_Replace(m_hImageList, nImage, hBitmap, hBitmapMask);
	}
	int AddIcon(HICON hIcon)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_AddIcon(m_hImageList, hIcon);
	}
	int ReplaceIcon(int nImage, HICON hIcon)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_ReplaceIcon(m_hImageList, nImage, hIcon);
	}
	HICON ExtractIcon(int nImage)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_ExtractIcon(NULL, m_hImageList, nImage);
	}
	BOOL Draw(HDC hDC, int nImage, int x, int y, UINT nStyle)
	{
		ATLASSERT(m_hImageList != NULL);
		ATLASSERT(hDC != NULL);
		return ImageList_Draw(m_hImageList, nImage, hDC, x, y, nStyle);
	}
	BOOL Draw(HDC hDC, int nImage, POINT pt, UINT nStyle)
	{
		ATLASSERT(m_hImageList != NULL);
		ATLASSERT(hDC != NULL);
		return ImageList_Draw(m_hImageList, nImage, hDC, pt.x, pt.y, nStyle);
	}
	BOOL DrawEx(int nImage, HDC hDC, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle)
	{
		ATLASSERT(m_hImageList != NULL);
		ATLASSERT(hDC != NULL);
		return ImageList_DrawEx(m_hImageList, nImage, hDC, x, y, dx, dy, rgbBk, rgbFg, fStyle);
	}
	BOOL DrawEx(int nImage, HDC hDC, RECT& rect, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle)
	{
		ATLASSERT(m_hImageList != NULL);
		ATLASSERT(hDC != NULL);
		return ImageList_DrawEx(m_hImageList, nImage, hDC, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, rgbBk, rgbFg, fStyle);
	}
	static BOOL DrawIndirect(IMAGELISTDRAWPARAMS* pimldp)
	{
		return ImageList_DrawIndirect(pimldp);
	}
	BOOL Copy(int nSrc, int nDst, UINT uFlags = ILCF_MOVE)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_Copy(m_hImageList, nDst, m_hImageList, nSrc, uFlags);
	}
	HIMAGELIST Read(LPSTREAM lpStream)
	{
		ATLASSERT(m_hImageList == NULL);
		return ImageList_Read(lpStream);
	}
	BOOL Write(LPSTREAM lpStream)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_Write(m_hImageList, lpStream);
	}

	// Drag operations
	BOOL BeginDrag(int nImage, POINT ptHotSpot)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_BeginDrag(m_hImageList, nImage, ptHotSpot.x, ptHotSpot.y);
	}
	BOOL BeginDrag(int nImage, int xHotSpot, int yHotSpot)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_BeginDrag(m_hImageList, nImage, xHotSpot, yHotSpot);
	}
	static void EndDrag()
	{
		ImageList_EndDrag();
	}
	static BOOL DragMove(POINT pt)
	{
		return ImageList_DragMove(pt.x, pt.y);
	}
	static BOOL DragMove(int x, int y)
	{
		return ImageList_DragMove(x, y);
	}
	BOOL SetDragCursorImage(int nDrag, POINT ptHotSpot)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_SetDragCursorImage(m_hImageList, nDrag, ptHotSpot.x, ptHotSpot.y);
	}
	BOOL SetDragCursorImage(int nDrag, int xHotSpot, int yHotSpot)
	{
		ATLASSERT(m_hImageList != NULL);
		return ImageList_SetDragCursorImage(m_hImageList, nDrag, xHotSpot, yHotSpot);
	}
	static BOOL DragShowNolock(BOOL bShow = TRUE)
	{
		return ImageList_DragShowNolock(bShow);
	}
	static CImageList GetDragImage(LPPOINT lpPoint, LPPOINT lpPointHotSpot)
	{
		return CImageList(ImageList_GetDragImage(lpPoint, lpPointHotSpot));
	}
	static BOOL DragEnter(HWND hWnd, POINT point)
	{
		return ImageList_DragEnter(hWnd, point.x, point.y);
	}
	static BOOL DragEnter(HWND hWnd, int x, int y)
	{
		return ImageList_DragEnter(hWnd, x, y);
	}
	static BOOL DragLeave(HWND hWnd)
	{
		return ImageList_DragLeave(hWnd);
	}

#if (_WIN32_IE >= 0x0400)
	CImageList Duplicate()
	{
		ATLASSERT(m_hImageList != NULL);
		return CImageList(ImageList_Duplicate(m_hImageList));
	}
	static CImageList Duplicate(HIMAGELIST hImageList)
	{
		ATLASSERT(hImageList != NULL);
		return CImageList(ImageList_Duplicate(hImageList));
	}
#endif //(_WIN32_IE >= 0x0400)
};


/////////////////////////////////////////////////////////////////////////////
// CToolTipCtrl

class CToolInfo : public TOOLINFO
{
public:
	CToolInfo(UINT nFlags, HWND hWnd, UINT nIDTool = 0, LPRECT lpRect = NULL, LPTSTR lpstrText = LPSTR_TEXTCALLBACK, LPARAM lUserParam = NULL)
	{
		Init(nFlags, hWnd, nIDTool, lpRect, lpstrText, lUserParam);
	}

	operator LPTOOLINFO() { return this; }
	operator LPARAM() { return (LPARAM)this; }

	void Init(UINT nFlags, HWND hWnd, UINT nIDTool = 0, LPRECT lpRect = NULL, LPTSTR lpstrText = LPSTR_TEXTCALLBACK, LPARAM lUserParam = NULL)
	{
		ATLASSERT(::IsWindow(hWnd));
		memset(this, 0, sizeof(TOOLINFO));
		cbSize = sizeof(TOOLINFO);
		uFlags = nFlags;
		if(nIDTool == 0)
		{
			hwnd = ::GetParent(hWnd);
			uFlags |= TTF_IDISHWND;
			uId = (UINT_PTR)hWnd;
		}
		else
		{
			hwnd = hWnd;
			uId = nIDTool;
		}
		if(lpRect != NULL)
			rect = *lpRect;
		hinst = _Module.GetResourceInstance();
		lpszText = lpstrText;
		lParam = lUserParam;
	}
};

template <class TBase>
class CToolTipCtrlT : public TBase
{
public:
// Constructors
	CToolTipCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CToolTipCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return TOOLTIPS_CLASS;
	}

	void GetText(LPTOOLINFO lpToolInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_GETTEXT, 0, (LPARAM)&lpToolInfo);
	}
	void GetText(LPTSTR lpstrText, HWND hWnd, UINT nIDTool = 0) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hWnd != NULL);
		CToolInfo ti(0, hWnd, nIDTool, NULL, lpstrText);
		::SendMessage(m_hWnd, TTM_GETTEXT, 0, ti);
	}
	BOOL GetToolInfo(LPTOOLINFO lpToolInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TTM_GETTOOLINFO, 0, (LPARAM)lpToolInfo);
	}
	BOOL GetToolInfo(HWND hWnd, UINT nIDTool, UINT* puFlags, LPRECT lpRect, LPTSTR lpstrText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hWnd != NULL);
		CToolInfo ti(0, hWnd, nIDTool, NULL, lpstrText);
		BOOL bRet = (BOOL)::SendMessage(m_hWnd, TTM_GETTOOLINFO, 0, ti);
		if(bRet)
		{
			*puFlags = ti.uFlags;
			memcpy(lpRect, &(ti.rect), sizeof(RECT));
		}
		return bRet;
	}
	void SetToolInfo(LPTOOLINFO lpToolInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_SETTOOLINFO, 0, (LPARAM)lpToolInfo);
	}
	void SetToolRect(LPTOOLINFO lpToolInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_NEWTOOLRECT, 0, (LPARAM)lpToolInfo);
	}
	void SetToolRect(HWND hWnd, UINT nIDTool, LPCRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hWnd != NULL);
		ATLASSERT(nIDTool != 0);

		CToolInfo ti(0, hWnd, nIDTool, (LPRECT)lpRect, NULL);
		::SendMessage(m_hWnd, TTM_NEWTOOLRECT, 0, ti);
	}
	int GetToolCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TTM_GETTOOLCOUNT, 0, 0L);
	}
	int GetDelayTime(DWORD dwType) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TTM_GETDELAYTIME, dwType, 0L);
	}
	void SetDelayTime(DWORD dwType, int nTime)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_SETDELAYTIME, dwType, MAKELPARAM(nTime, 0));
	}
	void GetMargin(LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_GETMARGIN, 0, (LPARAM)lpRect);
	}
	void SetMargin(LPRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_SETMARGIN, 0, (LPARAM)lpRect);
	}
	int GetMaxTipWidth() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TTM_GETMAXTIPWIDTH, 0, 0L);
	}
	int SetMaxTipWidth(int nWidth)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TTM_SETMAXTIPWIDTH, 0, nWidth);
	}
	COLORREF GetTipBkColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TTM_GETTIPBKCOLOR, 0, 0L);
	}
	void SetTipBkColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_SETTIPBKCOLOR, (WPARAM)clr, 0L);
	}
	COLORREF GetTipTextColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TTM_GETTIPTEXTCOLOR, 0, 0L);
	}
	void SetTipTextColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_SETTIPTEXTCOLOR, (WPARAM)clr, 0L);
	}
	BOOL GetCurrentTool(LPTOOLINFO lpToolInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TTM_GETCURRENTTOOL, 0, (LPARAM)lpToolInfo);
	}

#if (_WIN32_IE >= 0x0500)
	SIZE GetBubbleSize(LPTOOLINFO lpToolInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, TTM_GETBUBBLESIZE, 0, (LPARAM)lpToolInfo);
		SIZE size = { GET_X_LPARAM(dwRet), GET_Y_LPARAM(dwRet) };
		return size;
	}
	BOOL SetTitle(UINT uIcon, LPCTSTR lpstrTitle)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TTM_SETTITLE, uIcon, (LPARAM)lpstrTitle);
	}
#endif //(_WIN32_IE >= 0x0500)

// Operations
	void Activate(BOOL bActivate)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_ACTIVATE, bActivate, 0L);
	}
	BOOL AddTool(LPTOOLINFO lpToolInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TTM_ADDTOOL, 0, (LPARAM)lpToolInfo);
	}
	BOOL AddTool(HWND hWnd, _U_STRINGorID text = LPSTR_TEXTCALLBACK, LPCRECT lpRectTool = NULL, UINT nIDTool = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hWnd != NULL);
		// the toolrect and toolid must both be zero or both valid
		ATLASSERT((lpRectTool != NULL && nIDTool != 0) || (lpRectTool == NULL && nIDTool == 0));

		CToolInfo ti(0, hWnd, nIDTool, (LPRECT)lpRectTool, (LPTSTR)text.m_lpstr);
		return (BOOL)::SendMessage(m_hWnd, TTM_ADDTOOL, 0, ti);
	}
	void DelTool(LPTOOLINFO lpToolInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_DELTOOL, 0, (LPARAM)lpToolInfo);
	}
	void DelTool(HWND hWnd, UINT nIDTool = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hWnd != NULL);

		CToolInfo ti(0, hWnd, nIDTool, NULL, NULL);
		::SendMessage(m_hWnd, TTM_DELTOOL, 0, ti);
	}
	BOOL HitTest(LPTTHITTESTINFO lpHitTestInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TTM_HITTEST, 0, (LPARAM)lpHitTestInfo);
	}
	BOOL HitTest(HWND hWnd, POINT pt, LPTOOLINFO lpToolInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hWnd != NULL);
		ATLASSERT(lpToolInfo != NULL);

		TTHITTESTINFO hti;
		memset(&hti, 0, sizeof(hti));
		hti.ti.cbSize = sizeof(TOOLINFO);
		hti.hwnd = hWnd;
		hti.pt.x = pt.x;
		hti.pt.y = pt.y;
		if((BOOL)::SendMessage(m_hWnd, TTM_HITTEST, 0, (LPARAM)&hti))
		{
			memcpy(lpToolInfo, &hti.ti, sizeof(TOOLINFO));
			return TRUE;
		}
		return FALSE;
	}
	void RelayEvent(LPMSG lpMsg)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_RELAYEVENT, 0, (LPARAM)lpMsg);
	}
	void UpdateTipText(LPTOOLINFO lpToolInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_UPDATETIPTEXT, 0, (LPARAM)lpToolInfo);
	}
	void UpdateTipText(_U_STRINGorID text, HWND hWnd, UINT nIDTool = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hWnd != NULL);

		CToolInfo ti(0, hWnd, nIDTool, NULL, (LPTSTR)text.m_lpstr);
		::SendMessage(m_hWnd, TTM_UPDATETIPTEXT, 0, ti);
	}

	BOOL EnumTools(UINT nTool, LPTOOLINFO lpToolInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TTM_ENUMTOOLS, nTool, (LPARAM)lpToolInfo);
	}
	void Pop()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_POP, 0, 0L);
	}
	void TrackActivate(LPTOOLINFO lpToolInfo, BOOL bActivate)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_TRACKACTIVATE, bActivate, (LPARAM)lpToolInfo);
	}
	void TrackPosition(int xPos, int yPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_TRACKPOSITION, 0, MAKELPARAM(xPos, yPos));
	}

#if (_WIN32_IE >= 0x0400)
	void Update()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TTM_UPDATE, 0, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	BOOL AdjustRect(LPRECT lpRect, BOOL bLarger /*= TRUE*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TTM_ADJUSTRECT, bLarger, (LPARAM)lpRect);
	}
#endif //(_WIN32_IE >= 0x0500)
};

typedef CToolTipCtrlT<CWindow>		CToolTipCtrl;


/////////////////////////////////////////////////////////////////////////////
// CHeaderCtrl

template <class TBase>
class CHeaderCtrlT : public TBase
{
public:
// Constructors
	CHeaderCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CHeaderCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return WC_HEADER;
	}

	int GetItemCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_GETITEMCOUNT, 0, 0L);
	}
	BOOL GetItem(int nIndex, LPHDITEM pHeaderItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_GETITEM, nIndex, (LPARAM)pHeaderItem);
	}
	BOOL SetItem(int nIndex, LPHDITEM pHeaderItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_SETITEM, nIndex, (LPARAM)pHeaderItem);
	}
	CImageList GetImageList() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, HDM_GETIMAGELIST, 0, 0L));
	}
	CImageList SetImageList(HIMAGELIST hImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, HDM_SETIMAGELIST, 0, (LPARAM)hImageList));
	}
	BOOL GetOrderArray(int nSize, int* lpnArray) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_GETORDERARRAY, nSize, (LPARAM)lpnArray);
	}
	BOOL SetOrderArray(int nSize, int* lpnArray)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_SETORDERARRAY, nSize, (LPARAM)lpnArray);
	}
	BOOL GetItemRect(int nIndex, LPRECT lpItemRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_GETITEMRECT, nIndex, (LPARAM)lpItemRect);
	}
	int SetHotDivider(BOOL bPos, DWORD dwInputValue)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_SETHOTDIVIDER, bPos, dwInputValue);
	}

#if (_WIN32_IE >= 0x0400)
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	int GetBitmapMargin() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_GETBITMAPMARGIN, 0, 0L);
	}
	int SetBitmapMargin(int nWidth)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_SETBITMAPMARGIN, nWidth, 0L);
	}
	int SetFilterChangeTimeout(DWORD dwTimeOut)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_SETFILTERCHANGETIMEOUT, 0, dwTimeOut);
	}
#endif //(_WIN32_IE >= 0x0500)

// Operations
	int InsertItem(int nIndex, LPHDITEM phdi)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_INSERTITEM, nIndex, (LPARAM)phdi);
	}
	BOOL DeleteItem(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_DELETEITEM, nIndex, 0L);
	}
	BOOL Layout(HD_LAYOUT* pHeaderLayout)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, HDM_LAYOUT, 0, (LPARAM)pHeaderLayout);
	}
	int HitTest(LPHDHITTESTINFO lpHitTestInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_HITTEST, 0, (LPARAM)lpHitTestInfo);
	}
	int OrderToIndex(int nOrder)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_ORDERTOINDEX, nOrder, 0L);
	}
	CImageList CreateDragImage(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, HDM_CREATEDRAGIMAGE, nIndex, 0L));
	}

#if (_WIN32_IE >= 0x0500)
	int EditFilter(int nColumn, BOOL bDiscardChanges)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_EDITFILTER, nColumn, MAKELPARAM(bDiscardChanges, 0));
	}
	int ClearFilter(int nColumn)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_CLEARFILTER, nColumn, 0L);
	}
	int ClearAllFilters()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, HDM_CLEARFILTER, (WPARAM)-1, 0L);
	}
#endif //(_WIN32_IE >= 0x0500)
};

typedef CHeaderCtrlT<CWindow>		CHeaderCtrl;


/////////////////////////////////////////////////////////////////////////////
// CListViewCtrl

template <class TBase>
class CListViewCtrlT : public TBase
{
public:
// Constructors
	CListViewCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CListViewCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return WC_LISTVIEW;
	}

	COLORREF GetBkColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, LVM_GETBKCOLOR, 0, 0L);
	}
	BOOL SetBkColor(COLORREF cr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETBKCOLOR, 0, cr);
	}
	CImageList GetImageList(int nImageListType) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, LVM_GETIMAGELIST, nImageListType, 0L));
	}
	CImageList SetImageList(HIMAGELIST hImageList, int nImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, LVM_SETIMAGELIST, nImageList, (LPARAM)hImageList));
	}
	int GetItemCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETITEMCOUNT, 0, 0L);
	}
	void SetItemCount(int nItems)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, LVM_SETITEMCOUNT, nItems, 0L);
	}
	BOOL GetItem(LPLVITEM pItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETITEM, 0, (LPARAM)pItem);
	}
	BOOL SetItem(const LVITEM* pItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEM, 0, (LPARAM)pItem);
	}
	BOOL SetItem(int nItem, int nSubItem, UINT nMask, LPCTSTR lpszItem,
		int nImage, UINT nState, UINT nStateMask, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		LVITEM lvi;
		lvi.mask = nMask;
		lvi.iItem = nItem;
		lvi.iSubItem = nSubItem;
		lvi.stateMask = nStateMask;
		lvi.state = nState;
		lvi.pszText = (LPTSTR) lpszItem;
		lvi.iImage = nImage;
		lvi.lParam = lParam;
		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEM, 0, (LPARAM)&lvi);
	}
	UINT GetItemState(int nItem, UINT nMask) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, LVM_GETITEMSTATE, nItem, nMask);
	}
	BOOL SetItemState(int nItem, UINT nState, UINT nStateMask)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItem(nItem, 0, LVIF_STATE, NULL, 0, nState, nStateMask, 0);
	}
	BOOL SetItemState(int nItem, LPLVITEM pItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEMSTATE, nItem, (LPARAM)pItem);
	}

#ifndef _ATL_NO_COM
	BOOL GetItemText(int nItem, int nSubItem, BSTR& bstrText) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(bstrText == NULL);
		LVITEM lvi;
		memset(&lvi, 0, sizeof(LVITEM));
		lvi.iSubItem = nSubItem;

		LPTSTR lpstrText = NULL;
		int nRes = 0;
		for(int nLen = 256; ; nLen *= 2)
		{
			ATLTRY(lpstrText = new TCHAR[nLen]);
			if(lpstrText == NULL)
				break;
			lpstrText[0] = NULL;
			lvi.cchTextMax = nLen;
			lvi.pszText = lpstrText;
			nRes  = (int)::SendMessage(m_hWnd, LVM_GETITEMTEXT, (WPARAM)nItem, (LPARAM)&lvi);
			if(nRes < nLen - 1)
				break;
			delete [] lpstrText;
			lpstrText = NULL;
		}

		if(lpstrText != NULL)
		{
			if(nRes != 0)
				bstrText = ::SysAllocString(T2OLE(lpstrText));
			delete [] lpstrText;
		}

		return (bstrText != NULL) ? TRUE : FALSE;
	}
#endif //!_ATL_NO_COM

#ifdef __ATLSTR_H__
	int GetItemText(int nItem, int nSubItem, CString& strText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		LVITEM lvi;
		memset(&lvi, 0, sizeof(LVITEM));
		lvi.iSubItem = nSubItem;

		strText.Empty();
		int nRes = 0;
		for(int nLen = 256; ; nLen *= 2)
		{
			lvi.cchTextMax = nLen;
			lvi.pszText = strText.GetBufferSetLength(nLen);
			nRes  = (int)::SendMessage(m_hWnd, LVM_GETITEMTEXT, (WPARAM)nItem, (LPARAM)&lvi);
			if(nRes < nLen - 1)
				break;
		}
		strText.ReleaseBuffer();
		return nRes;
	}
#endif //__ATLSTR_H__

	int GetItemText(int nItem, int nSubItem, LPTSTR lpszText, int nLen) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		LVITEM lvi;
		memset(&lvi, 0, sizeof(LVITEM));
		lvi.iSubItem = nSubItem;
		lvi.cchTextMax = nLen;
		lvi.pszText = lpszText;
		return (int)::SendMessage(m_hWnd, LVM_GETITEMTEXT, (WPARAM)nItem, (LPARAM)&lvi);
	}
	BOOL SetItemText(int nItem, int nSubItem, LPCTSTR lpszText)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItem(nItem, nSubItem, LVIF_TEXT, lpszText, 0, 0, 0, 0);
	}
	DWORD_PTR GetItemData(int nItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		LVITEM lvi;
		memset(&lvi, 0, sizeof(LVITEM));
		lvi.iItem = nItem;
		lvi.mask = LVIF_PARAM;
		::SendMessage(m_hWnd, LVM_GETITEM, 0, (LPARAM)&lvi);
		return (DWORD_PTR)lvi.lParam;
	}
	BOOL SetItemData(int nItem, DWORD_PTR dwData)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItem(nItem, 0, LVIF_PARAM, NULL, 0, 0, 0, (LPARAM)dwData);
	}
	UINT GetCallbackMask() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, LVM_GETCALLBACKMASK, 0, 0L);
	}
	BOOL SetCallbackMask(UINT nMask)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETCALLBACKMASK, nMask, 0L);
	}
	BOOL GetItemPosition(int nItem, LPPOINT lpPoint) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETITEMPOSITION, nItem, (LPARAM)lpPoint);
	}
	BOOL SetItemPosition(int nItem, POINT pt)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(((GetStyle() & LVS_TYPEMASK) == LVS_ICON) || ((GetStyle() & LVS_TYPEMASK) == LVS_SMALLICON));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEMPOSITION32, nItem, (LPARAM)&pt);
	}
	BOOL SetItemPosition(int nItem, int x, int y)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(((GetStyle() & LVS_TYPEMASK) == LVS_ICON) || ((GetStyle() & LVS_TYPEMASK) == LVS_SMALLICON));
		POINT pt = { x, y };
		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEMPOSITION32, nItem, (LPARAM)&pt);
	}
	int GetStringWidth(LPCTSTR lpsz) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETSTRINGWIDTH, 0, (LPARAM)lpsz);
	}
	CEdit GetEditControl() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CEdit((HWND)::SendMessage(m_hWnd, LVM_GETEDITCONTROL, 0, 0L));
	}
	BOOL GetColumn(int nCol, LV_COLUMN* pColumn) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETCOLUMN, nCol, (LPARAM)pColumn);
	}
	BOOL SetColumn(int nCol, const LV_COLUMN* pColumn)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETCOLUMN, nCol, (LPARAM)pColumn);
	}
	int GetColumnWidth(int nCol) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETCOLUMNWIDTH, nCol, 0L);
	}
	BOOL SetColumnWidth(int nCol, int cx)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETCOLUMNWIDTH, nCol, MAKELPARAM(cx, 0));
	}
	BOOL GetViewRect(LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETVIEWRECT, 0, (LPARAM)lpRect);
	}
	COLORREF GetTextColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, LVM_GETTEXTCOLOR, 0, 0L);
	}
	BOOL SetTextColor(COLORREF cr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETTEXTCOLOR, 0, cr);
	}
	COLORREF GetTextBkColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, LVM_GETTEXTBKCOLOR, 0, 0L);
	}
	BOOL SetTextBkColor(COLORREF cr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETTEXTBKCOLOR, 0, cr);
	}
	int GetTopIndex() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETTOPINDEX, 0, 0L);
	}
	int GetCountPerPage() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETCOUNTPERPAGE, 0, 0L);
	}
	BOOL GetOrigin(LPPOINT lpPoint) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETORIGIN, 0, (LPARAM)lpPoint);
	}
	UINT GetSelectedCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, LVM_GETSELECTEDCOUNT, 0, 0L);
	}

	BOOL GetItemRect(int nItem, LPRECT lpRect, UINT nCode) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		lpRect->left = nCode;
		return (BOOL)::SendMessage(m_hWnd, LVM_GETITEMRECT, (WPARAM)nItem, (LPARAM)lpRect);
	}

	HCURSOR GetHotCursor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HCURSOR)::SendMessage(m_hWnd, LVM_GETHOTCURSOR, 0, 0L);
	}
	HCURSOR SetHotCursor(HCURSOR hHotCursor)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HCURSOR)::SendMessage(m_hWnd, LVM_SETHOTCURSOR, 0, (LPARAM)hHotCursor);
	}
	int GetHotItem() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETHOTITEM, 0, 0L);
	}
	int SetHotItem(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_SETHOTITEM, nIndex, 0L);
	}
	BOOL GetColumnOrderArray(int nCount, int* lpnArray) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETCOLUMNORDERARRAY, nCount, (LPARAM)lpnArray);
	}
	BOOL SetColumnOrderArray(int nCount, int* lpnArray)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETCOLUMNORDERARRAY, nCount, (LPARAM)lpnArray);
	}
	CHeaderCtrl GetHeader() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CHeaderCtrl((HWND)::SendMessage(m_hWnd, LVM_GETHEADER, 0, 0L));
	}
	BOOL GetSubItemRect(int nItem, int nSubItem, int nFlag, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & LVS_TYPEMASK) == LVS_REPORT);
		ATLASSERT(lpRect != NULL);
		lpRect->top = nSubItem;
		lpRect->left = nFlag;
		return (BOOL)::SendMessage(m_hWnd, LVM_GETSUBITEMRECT, nItem, (LPARAM)lpRect);
	}
	DWORD SetIconSpacing(int cx, int cy)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & LVS_TYPEMASK) == LVS_ICON);
		return (DWORD)::SendMessage(m_hWnd, LVM_SETICONSPACING, 0, MAKELPARAM(cx, cy));
	}
	int GetISearchString(LPTSTR lpstr) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETISEARCHSTRING, 0, (LPARAM)lpstr);
	}
	void GetItemSpacing(SIZE& sizeSpacing, BOOL bSmallIconView = FALSE) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, LVM_GETITEMSPACING, bSmallIconView, 0L);
		sizeSpacing.cx = GET_X_LPARAM(dwRet);
		sizeSpacing.cy = GET_Y_LPARAM(dwRet);
	}

	// single-selection only
	int GetSelectedIndex() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & LVS_SINGLESEL) != 0);
		return (int)::SendMessage(m_hWnd, LVM_GETNEXTITEM, (WPARAM)-1, MAKELPARAM(LVNI_ALL | LVNI_SELECTED, 0));
	}
	BOOL GetSelectedItem(LPLVITEM pItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & LVS_SINGLESEL) != 0);
		ATLASSERT(pItem != NULL);
		pItem->iItem = (int)::SendMessage(m_hWnd, LVM_GETNEXTITEM, (WPARAM)-1, MAKELPARAM(LVNI_ALL | LVNI_SELECTED, 0));
		if(pItem->iItem == -1)
			return FALSE;
		return (BOOL)::SendMessage(m_hWnd, LVM_GETITEM, 0, (LPARAM)pItem);
	}

	// extended list view styles
	DWORD GetExtendedListViewStyle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0L);
	}
	// dwExMask = 0 means all styles
	DWORD SetExtendedListViewStyle(DWORD dwExStyle, DWORD dwExMask = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, LVM_SETEXTENDEDLISTVIEWSTYLE, dwExMask, dwExStyle);
	}

	// checkboxes only
	BOOL GetCheckState(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetExtendedListViewStyle() & LVS_EX_CHECKBOXES) != 0);
		UINT uRet = GetItemState(nIndex, LVIS_STATEIMAGEMASK);
		return (uRet >> 12) - 1;
	}
	BOOL SetCheckState(int nItem, BOOL bCheck)
	{
		int nCheck = bCheck ? 2 : 1;	// one based index
		return SetItemState(nItem, INDEXTOSTATEIMAGEMASK(nCheck), LVIS_STATEIMAGEMASK);
	}

	// view type
	DWORD GetViewType() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (GetStyle() & LVS_TYPEMASK);
	}

	DWORD SetViewType(DWORD dwType)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(dwType == LVS_ICON || dwType == LVS_SMALLICON || dwType == LVS_LIST || dwType == LVS_REPORT);
		DWORD dwOldType = GetViewType();
		if(dwType != dwOldType)
			ModifyStyle(LVS_TYPEMASK, (dwType & LVS_TYPEMASK));
		return dwOldType;
	}

#if (_WIN32_IE >= 0x0400)
	BOOL GetBkImage(LPLVBKIMAGE plvbki) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETBKIMAGE, 0, (LPARAM)plvbki);
	}
	BOOL SetBkImage(LPLVBKIMAGE plvbki)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETBKIMAGE, 0, (LPARAM)plvbki);
	}
	int GetSelectionMark() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETSELECTIONMARK, 0, 0L);
	}
	int SetSelectionMark(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_SETSELECTIONMARK, 0, nIndex);
	}
	BOOL GetWorkAreas(int nWorkAreas, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETWORKAREAS, nWorkAreas, (LPARAM)lpRect);
	}
	BOOL SetWorkAreas(int nWorkAreas, LPRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETWORKAREAS, nWorkAreas, (LPARAM)lpRect);
	}
	DWORD GetHoverTime() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetExtendedListViewStyle() & (LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE | LVS_EX_TWOCLICKACTIVATE)) != 0);
		return (DWORD)::SendMessage(m_hWnd, LVM_GETHOVERTIME, 0, 0L);
	}
	DWORD SetHoverTime(DWORD dwHoverTime)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetExtendedListViewStyle() & (LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE | LVS_EX_TWOCLICKACTIVATE)) != 0);
		return (DWORD)::SendMessage(m_hWnd, LVM_SETHOVERTIME, 0, dwHoverTime);
	}
	BOOL GetNumberOfWorkAreas(int* pnWorkAreas) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETNUMBEROFWORKAREAS, 0, (LPARAM)pnWorkAreas);
	}
	void SetItemCountEx(int nItems, DWORD dwFlags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(((GetStyle() & LVS_OWNERDATA) != 0) && (((GetStyle() & LVS_TYPEMASK) == LVS_REPORT) || ((GetStyle() & LVS_TYPEMASK) == LVS_LIST)));
		::SendMessage(m_hWnd, LVM_SETITEMCOUNT, nItems, dwFlags);
	}
	CToolTipCtrl GetToolTips() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, LVM_GETTOOLTIPS, 0, 0L));
	}
	CToolTipCtrl SetToolTips(HWND hWndTT)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, LVM_SETTOOLTIPS, (WPARAM)hWndTT, 0L));
	}
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

// Operations
	int InsertColumn(int nCol, const LV_COLUMN* pColumn)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_INSERTCOLUMN, nCol, (LPARAM)pColumn);
	}
	int InsertColumn(int nCol, LPCTSTR lpszColumnHeading, int nFormat, int nWidth, int nSubItem)
	{
		LV_COLUMN column;
		column.mask = LVCF_TEXT|LVCF_FMT;
		column.pszText = (LPTSTR)lpszColumnHeading;
		column.fmt = nFormat;
		if (nWidth != -1)
		{
			column.mask |= LVCF_WIDTH;
			column.cx = nWidth;
		}
		if (nSubItem != -1)
		{
			column.mask |= LVCF_SUBITEM;
			column.iSubItem = nSubItem;
		}
		return InsertColumn(nCol, &column);
	}
	BOOL DeleteColumn(int nCol)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_DELETECOLUMN, nCol, 0L);
	}
	int InsertItem(UINT nMask, int nItem, LPCTSTR lpszItem, UINT nState, UINT nStateMask, int nImage, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		LVITEM item;
		item.mask = nMask;
		item.iItem = nItem;
		item.iSubItem = 0;
		item.pszText = (LPTSTR)lpszItem;
		item.state = nState;
		item.stateMask = nStateMask;
		item.iImage = nImage;
		item.lParam = lParam;
		return InsertItem(&item);
	}
	int InsertItem(const LVITEM* pItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_INSERTITEM, 0, (LPARAM)pItem);
	}
	int InsertItem(int nItem, LPCTSTR lpszItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return InsertItem(LVIF_TEXT, nItem, lpszItem, 0, 0, 0, 0);
	}
	int InsertItem(int nItem, LPCTSTR lpszItem, int nImage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return InsertItem(LVIF_TEXT|LVIF_IMAGE, nItem, lpszItem, 0, 0, nImage, 0);
	}
	int GetNextItem(int nItem, int nFlags) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_GETNEXTITEM, nItem, MAKELPARAM(nFlags, 0));
	}
	BOOL DeleteItem(int nItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_DELETEITEM, nItem, 0L);
	}
	BOOL DeleteAllItems()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_DELETEALLITEMS, 0, 0L);
	}
	int FindItem(LV_FINDINFO* pFindInfo, int nStart) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_FINDITEM, nStart, (LPARAM)pFindInfo);
	}
	int HitTest(LV_HITTESTINFO* pHitTestInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_HITTEST, 0, (LPARAM)pHitTestInfo);
	}
	int HitTest(POINT pt, UINT* pFlags) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		LV_HITTESTINFO hti;
		hti.pt = pt;
		int nRes = (int)::SendMessage(m_hWnd, LVM_HITTEST, 0, (LPARAM)&hti);
		if (pFlags != NULL)
			*pFlags = hti.flags;
		return nRes;
	}
	BOOL EnsureVisible(int nItem, BOOL bPartialOK)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_ENSUREVISIBLE, nItem, MAKELPARAM(bPartialOK, 0));
	}
	BOOL Scroll(SIZE size)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SCROLL, size.cx, size.cy);
	}
	BOOL RedrawItems(int nFirst, int nLast)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_REDRAWITEMS, nFirst, nLast);
	}
	BOOL Arrange(UINT nCode)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_ARRANGE, nCode, 0L);
	}
	CEdit EditLabel(int nItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CEdit((HWND)::SendMessage(m_hWnd, LVM_EDITLABEL, nItem, 0L));
	}
	BOOL Update(int nItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_UPDATE, nItem, 0L);
	}
	BOOL SortItems(PFNLVCOMPARE pfnCompare, LPARAM lParamSort)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SORTITEMS, (WPARAM)lParamSort, (LPARAM)pfnCompare);
	}
	CImageList RemoveImageList(int nImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, LVM_SETIMAGELIST, (WPARAM)nImageList, NULL));
	}

	CImageList CreateDragImage(int nItem, LPPOINT lpPoint)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, LVM_CREATEDRAGIMAGE, nItem, (LPARAM)lpPoint));
	}
	DWORD ApproximateViewRect(int cx = -1, int cy = -1, int nCount = -1)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, LVM_APPROXIMATEVIEWRECT, nCount, MAKELPARAM(cx, cy));
	}
	int SubItemHitTest(LPLVHITTESTINFO lpInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, LVM_SUBITEMHITTEST, 0, (LPARAM)lpInfo);
	}

	int AddColumn(LPCTSTR strItem, int nItem, int nSubItem = -1,
			int nMask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM,
			int nFmt = LVCFMT_LEFT)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		LV_COLUMN lvc;
		lvc.mask = nMask;
		lvc.fmt = nFmt;
		lvc.pszText = (LPTSTR)strItem;
		lvc.cx = GetStringWidth(lvc.pszText) + 15;
		if(nMask & LVCF_SUBITEM)
			lvc.iSubItem = (nSubItem != -1) ? nSubItem : nItem;
		return InsertColumn(nItem, &lvc);
	}
	int AddItem(int nItem, int nSubItem, LPCTSTR strItem, int nImageIndex = -1)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		LVITEM lvItem;
		lvItem.mask = LVIF_TEXT;
		lvItem.iItem = nItem;
		lvItem.iSubItem = nSubItem;
		lvItem.pszText = (LPTSTR)strItem;
		if(nImageIndex != -1)
		{
			lvItem.mask |= LVIF_IMAGE;
			lvItem.iImage = nImageIndex;
		}
		if(nSubItem == 0)
			return InsertItem(&lvItem);
		return SetItem(&lvItem) ? nItem : -1;
	}

#if (_WIN32_IE >= 0x0500)
	BOOL SortItemsEx(PFNLVCOMPARE pfnCompare, LPARAM lParamSort)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, LVM_SORTITEMSEX, (WPARAM)lParamSort, (LPARAM)pfnCompare);
	}
#endif //(_WIN32_IE >= 0x0500)

	// single-selection only
	BOOL SelectItem(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & LVS_SINGLESEL) != 0);

		BOOL bRet = SetItemState(nIndex, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
		if(bRet)
			bRet = EnsureVisible(nIndex, FALSE);
		return bRet;
	}
};

typedef CListViewCtrlT<CWindow>		CListViewCtrl;


/////////////////////////////////////////////////////////////////////////////
// CTreeViewCtrl

template <class TBase>
class CTreeViewCtrlT : public TBase
{
public:
// Constructors
	CTreeViewCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CTreeViewCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return WC_TREEVIEW;
	}

	UINT GetCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, TVM_GETCOUNT, 0, 0L);
	}
	UINT GetIndent() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, TVM_GETINDENT, 0, 0L);
	}
	void SetIndent(UINT nIndent)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TVM_SETINDENT, nIndent, 0L);
	}
	CImageList GetImageList(UINT nImageList) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TVM_GETIMAGELIST, (UINT)nImageList, 0L));
	}
	CImageList SetImageList(HIMAGELIST hImageList, int nImageListType)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TVM_SETIMAGELIST, (UINT)nImageListType, (LPARAM)hImageList));
	}
	BOOL GetItem(LPTVITEM pItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)pItem);
	}
	BOOL SetItem(LPTVITEM pItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SETITEM, 0, (LPARAM)pItem);
	}
	BOOL SetItem(HTREEITEM hItem, UINT nMask, LPCTSTR lpszItem, int nImage,
		int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TVITEM item;
		item.hItem = hItem;
		item.mask = nMask;
		item.pszText = (LPTSTR) lpszItem;
		item.iImage = nImage;
		item.iSelectedImage = nSelectedImage;
		item.state = nState;
		item.stateMask = nStateMask;
		item.lParam = lParam;
		return (BOOL)::SendMessage(m_hWnd, TVM_SETITEM, 0, (LPARAM)&item);
	}
	BOOL GetItemText(HTREEITEM hItem, LPTSTR lpstrText, int nLen) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(lpstrText != NULL);

		TVITEM item;
		item.hItem = hItem;
		item.mask = TVIF_TEXT;
		item.pszText = lpstrText;
		item.cchTextMax = nLen;

		return (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
	}

#ifndef _ATL_NO_COM
	BOOL GetItemText(HTREEITEM hItem, BSTR& bstrText) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(bstrText == NULL);
		TVITEM item;
		item.hItem = hItem;
		item.mask = TVIF_TEXT;

		LPTSTR lpstrText = NULL;
		BOOL bRet = FALSE;
		for(int nLen = 256; ; nLen *= 2)
		{
			ATLTRY(lpstrText = new TCHAR[nLen]);
			if(lpstrText == NULL)
				break;
			lpstrText[0] = NULL;
			item.pszText = lpstrText;
			item.cchTextMax = nLen;
			bRet = (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
			if(!bRet || (lstrlen(item.pszText) < nLen - 1))
				break;
			delete [] lpstrText;
			lpstrText = NULL;
		}

		if(lpstrText != NULL)
		{
			if(bRet)
				bstrText = ::SysAllocString(T2OLE(lpstrText));
			delete [] lpstrText;
		}

		return (bstrText != NULL) ? TRUE : FALSE;
	}
#endif //!_ATL_NO_COM

#ifdef __ATLSTR_H__
	BOOL GetItemText(HTREEITEM hItem, CString& strText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TVITEM item;
		item.hItem = hItem;
		item.mask = TVIF_TEXT;

		strText.Empty();
		BOOL bRet = FALSE;
		for(int nLen = 256; ; nLen *= 2)
		{
			item.pszText = strText.GetBufferSetLength(nLen);
			item.cchTextMax = nLen;
			bRet = (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
			if(!bRet || (lstrlen(item.pszText) < nLen - 1))
				break;
		}
		strText.ReleaseBuffer();
		return bRet;
	}
#endif //__ATLSTR_H__
	BOOL SetItemText(HTREEITEM hItem, LPCTSTR lpszItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItem(hItem, TVIF_TEXT, lpszItem, 0, 0, 0, 0, NULL);
	}
	BOOL GetItemImage(HTREEITEM hItem, int& nImage, int& nSelectedImage) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TVITEM item;
		item.hItem = hItem;
		item.mask = TVIF_IMAGE|TVIF_SELECTEDIMAGE;
		BOOL bRes = (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
		if (bRes)
		{
			nImage = item.iImage;
			nSelectedImage = item.iSelectedImage;
		}
		return bRes;
	}
	BOOL SetItemImage(HTREEITEM hItem, int nImage, int nSelectedImage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItem(hItem, TVIF_IMAGE|TVIF_SELECTEDIMAGE, NULL, nImage, nSelectedImage, 0, 0, NULL);
	}
	UINT GetItemState(HTREEITEM hItem, UINT nStateMask) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TVITEM item;
		item.hItem = hItem;
		item.mask = TVIF_STATE;
		item.stateMask = nStateMask;
		item.state = 0;
		::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
		return item.state;
	}
	BOOL SetItemState(HTREEITEM hItem, UINT nState, UINT nStateMask)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItem(hItem, TVIF_STATE, NULL, 0, 0, nState, nStateMask, NULL);
	}
	DWORD_PTR GetItemData(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TVITEM item;
		item.hItem = hItem;
		item.mask = TVIF_PARAM;
		::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
		return (DWORD_PTR)item.lParam;
	}
	BOOL SetItemData(HTREEITEM hItem, DWORD_PTR dwData)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return SetItem(hItem, TVIF_PARAM, NULL, 0, 0, 0, 0, (LPARAM)dwData);
	}
	CEdit GetEditControl() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CEdit((HWND)::SendMessage(m_hWnd, TVM_GETEDITCONTROL, 0, 0L));
	}
	UINT GetVisibleCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, TVM_GETVISIBLECOUNT, 0, 0L);
	}
	BOOL GetItemRect(HTREEITEM hItem, LPRECT lpRect, BOOL bTextOnly) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		*(HTREEITEM*)lpRect = hItem;
		return (BOOL)::SendMessage(m_hWnd, TVM_GETITEMRECT, (WPARAM)bTextOnly, (LPARAM)lpRect);
	}
	BOOL ItemHasChildren(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TVITEM item;
		item.hItem = hItem;
		item.mask = TVIF_CHILDREN;
		::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
		return item.cChildren;
	}
	CToolTipCtrl GetToolTips() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, TVM_GETTOOLTIPS, 0, 0L));
	}
	CToolTipCtrl SetToolTips(HWND hWndTT)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, TVM_SETTOOLTIPS, (WPARAM)hWndTT, 0L));
	}
	int GetISearchString(LPTSTR lpstr) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TVM_GETISEARCHSTRING, 0, (LPARAM)lpstr);
	}

	// checkboxes only
	BOOL GetCheckState(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & TVS_CHECKBOXES) != 0);
		UINT uRet = GetItemState(hItem, TVIS_STATEIMAGEMASK);
		return (uRet >> 12) - 1;
	}
	BOOL SetCheckState(HTREEITEM hItem, BOOL bCheck)
	{
		int nCheck = bCheck ? 2 : 1;	// one based index
		return SetItemState(hItem, INDEXTOSTATEIMAGEMASK(nCheck), TVIS_STATEIMAGEMASK);
	}

#if (_WIN32_IE >= 0x0400)
	COLORREF GetBkColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TVM_GETBKCOLOR, 0, 0L);
	}
	COLORREF SetBkColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TVM_SETBKCOLOR, 0, (LPARAM)clr);
	}
	COLORREF GetInsertMarkColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TVM_GETINSERTMARKCOLOR, 0, 0L);
	}
	COLORREF SetInsertMarkColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TVM_SETINSERTMARKCOLOR, 0, (LPARAM)clr);
	}
	int GetItemHeight() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TVM_GETITEMHEIGHT, 0, 0L);
	}
	int SetItemHeight(int cyHeight)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TVM_SETITEMHEIGHT, cyHeight, 0L);
	}
	int GetScrollTime() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TVM_GETSCROLLTIME, 0, 0L);
	}
	int SetScrollTime(int nScrollTime)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TVM_SETSCROLLTIME, nScrollTime, 0L);
	}
	COLORREF GetTextColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TVM_GETTEXTCOLOR, 0, 0L);
	}
	COLORREF SetTextColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TVM_SETTEXTCOLOR, 0, (LPARAM)clr);
	}
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	COLORREF GetLineColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TVM_GETLINECOLOR, 0, 0L);
	}
	COLORREF SetLineColor(COLORREF clrNew /*= CLR_DEFAULT*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TVM_SETLINECOLOR, 0, (LPARAM)clrNew);
	}
#endif //(_WIN32_IE >= 0x0500)

// Operations
	HTREEITEM InsertItem(LPTV_INSERTSTRUCT lpInsertStruct)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)lpInsertStruct);
	}
	HTREEITEM InsertItem(LPCTSTR lpszItem, int nImage,
		int nSelectedImage, HTREEITEM hParent, HTREEITEM hInsertAfter)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return InsertItem(TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE, lpszItem, nImage, nSelectedImage, 0, 0, 0, hParent, hInsertAfter); 
	}
	HTREEITEM InsertItem(LPCTSTR lpszItem, HTREEITEM hParent, HTREEITEM hInsertAfter)
	{ 
		ATLASSERT(::IsWindow(m_hWnd));
		return InsertItem(TVIF_TEXT, lpszItem, 0, 0, 0, 0, 0, hParent, hInsertAfter);
	}
	HTREEITEM InsertItem(UINT nMask, LPCTSTR lpszItem, int nImage,
		int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam,
		HTREEITEM hParent, HTREEITEM hInsertAfter)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TV_INSERTSTRUCT tvis;
		tvis.hParent = hParent;
		tvis.hInsertAfter = hInsertAfter;
		tvis.item.mask = nMask;
		tvis.item.pszText = (LPTSTR) lpszItem;
		tvis.item.iImage = nImage;
		tvis.item.iSelectedImage = nSelectedImage;
		tvis.item.state = nState;
		tvis.item.stateMask = nStateMask;
		tvis.item.lParam = lParam;
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)&tvis);
	}
	BOOL DeleteItem(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_DELETEITEM, 0, (LPARAM)hItem);
	}
	BOOL DeleteAllItems()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT);
	}
	BOOL Expand(HTREEITEM hItem, UINT nCode = TVE_EXPAND)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_EXPAND, nCode, (LPARAM)hItem);
	}
	HTREEITEM GetNextItem(HTREEITEM hItem, UINT nCode) const
	{ 
		ATLASSERT(::IsWindow(m_hWnd)); 
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, nCode, (LPARAM)hItem);
	}
	HTREEITEM GetChildItem(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)hItem);
	}
	HTREEITEM GetNextSiblingItem(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXT, (LPARAM)hItem); 
	}
	HTREEITEM GetPrevSiblingItem(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUS, (LPARAM)hItem);
	}
	HTREEITEM GetParentItem(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hItem); 
	}
	HTREEITEM GetFirstVisibleItem() const
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_FIRSTVISIBLE, 0L);
	}
	HTREEITEM GetNextVisibleItem(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXTVISIBLE, (LPARAM)hItem);
	}
	HTREEITEM GetPrevVisibleItem(HTREEITEM hItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUSVISIBLE, (LPARAM)hItem);
	}
	HTREEITEM GetSelectedItem() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CARET, 0L);
	}
	HTREEITEM GetDropHilightItem() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_DROPHILITE, 0L);
	}
	HTREEITEM GetRootItem() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_ROOT, 0L);
	}
	BOOL Select(HTREEITEM hItem, UINT nCode)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, nCode, (LPARAM)hItem);
	}
	BOOL SelectItem(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_CARET, (LPARAM)hItem);
	}
	BOOL SelectDropTarget(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_DROPHILITE, (LPARAM)hItem);
	}
	BOOL SelectSetFirstVisible(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_FIRSTVISIBLE, (LPARAM)hItem);
	}
	CEdit EditLabel(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CEdit((HWND)::SendMessage(m_hWnd, TVM_EDITLABEL, 0, (LPARAM)hItem));
	}
	BOOL EndEditLabelNow(BOOL bCancel)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_ENDEDITLABELNOW, bCancel, 0L);
	}
	HTREEITEM HitTest(TV_HITTESTINFO* pHitTestInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)pHitTestInfo);
	}
	HTREEITEM HitTest(POINT pt, UINT* pFlags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TV_HITTESTINFO hti;
		hti.pt = pt;
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)&hti);
		if (pFlags != NULL)
			*pFlags = hti.flags;
		return hTreeItem;
	}
	BOOL SortChildren(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SORTCHILDREN, 0, (LPARAM)hItem);
	}
	BOOL EnsureVisible(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_ENSUREVISIBLE, 0, (LPARAM)hItem);
	}
	BOOL SortChildrenCB(LPTV_SORTCB pSort)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SORTCHILDRENCB, 0, (LPARAM)pSort);
	}
	CImageList RemoveImageList(int nImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TVM_SETIMAGELIST, (WPARAM)nImageList, NULL));
	}
	CImageList CreateDragImage(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TVM_CREATEDRAGIMAGE, 0, (LPARAM)hItem));
	}

#if (_WIN32_IE >= 0x0400)
	BOOL SetInsertMark(HTREEITEM hTreeItem, BOOL bAfter)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SETINSERTMARK, bAfter, (LPARAM)hTreeItem);
	}
	BOOL RemoveInsertMark()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TVM_SETINSERTMARK, 0, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)
};

typedef CTreeViewCtrlT<CWindow>		CTreeViewCtrl;


/////////////////////////////////////////////////////////////////////////////
// CTreeViewCtrlEx

typedef CTreeViewCtrlExT<CWindow> CTreeViewCtrlEx;	// forward declaration

class CTreeItem
{
public:
	HTREEITEM m_hTreeItem;
	CTreeViewCtrlEx* m_pTreeView;

// Construction
	CTreeItem(HTREEITEM hTreeItem = NULL, CTreeViewCtrlEx* pTreeView = NULL) : m_hTreeItem(hTreeItem), m_pTreeView(pTreeView)
	{ }
 
	CTreeItem(const CTreeItem& posSrc)
	{
		*this = posSrc;
	}

	operator HTREEITEM() { return m_hTreeItem; }

	CTreeItem& operator =(const CTreeItem& itemSrc)
	{
		m_hTreeItem = itemSrc.m_hTreeItem;
		m_pTreeView = itemSrc.m_pTreeView;
		return *this;
	}

// Attributes
	CTreeViewCtrlEx* GetTreeView() const { return m_pTreeView; }

	BOOL operator !() const { return m_hTreeItem == NULL; }
	BOOL IsNull() const { return m_hTreeItem == NULL; }
	
	BOOL GetRect(LPRECT lpRect, BOOL bTextOnly) const;
	BOOL GetText(LPTSTR lpstrText, int nLen) const;
#ifndef _ATL_NO_COM
	BOOL GetText(BSTR& bstrText) const;
#endif //!_ATL_NO_COM
#ifdef __ATLSTR_H__
	BOOL GetText(CString& strText) const;
#endif //__ATLSTR_H__
	BOOL SetText(LPCTSTR lpszItem);
	BOOL GetImage(int& nImage, int& nSelectedImage) const;
	BOOL SetImage(int nImage, int nSelectedImage);
	UINT GetState(UINT nStateMask) const;
	BOOL SetState(UINT nState, UINT nStateMask);
	DWORD_PTR GetData() const;
	BOOL SetData(DWORD_PTR dwData);
	BOOL SetItem(UINT nMask, LPCTSTR lpszItem, int nImage, int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam);

// Operations
	CTreeItem InsertAfter(LPCTSTR lpstrItem, HTREEITEM hItemAfter, int nImageIndex)
	{
		return _Insert(lpstrItem, nImageIndex, hItemAfter);
	}
	CTreeItem AddHead(LPCTSTR lpstrItem, int nImageIndex)
	{
		return _Insert(lpstrItem, nImageIndex, TVI_FIRST);
	}
	CTreeItem AddTail(LPCTSTR lpstrItem, int nImageIndex)
	{
		return _Insert(lpstrItem, nImageIndex, TVI_LAST);
	}

	CTreeItem GetChild() const;
	CTreeItem GetNext(UINT nCode) const;
	CTreeItem GetNextSibling() const;
	CTreeItem GetPrevSibling() const;
	CTreeItem GetParent() const;
	CTreeItem GetFirstVisible() const;
	CTreeItem GetNextVisible() const;
	CTreeItem GetPrevVisible() const;
	CTreeItem GetSelected() const;
	CTreeItem GetDropHilight() const;
	CTreeItem GetRoot() const;
	BOOL HasChildren() const;
	BOOL Delete();
	BOOL Expand(UINT nCode = TVE_EXPAND);
	BOOL Select(UINT nCode);
	BOOL Select();
	BOOL SelectDropTarget();
	BOOL SelectSetFirstVisible();
	HWND EditLabel();
	HIMAGELIST CreateDragImage();
	BOOL SortChildren();
	BOOL EnsureVisible();

	CTreeItem _Insert(LPCTSTR lpstrItem, int nImageIndex, HTREEITEM hItemAfter);
	int GetImageIndex() const;

#if (_WIN32_IE >= 0x0400)
	BOOL SetInsertMark(BOOL bAfter);
#endif //(_WIN32_IE >= 0x0400)
};


template <class TBase>
class CTreeViewCtrlExT : public CTreeViewCtrlT< TBase >
{
public:
// Constructors
	CTreeViewCtrlExT(HWND hWnd = NULL) : CTreeViewCtrlT< TBase >(hWnd) { }

	CTreeViewCtrlExT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// Operations (overides that return CTreeItem)
	CTreeItem InsertItem(LPTV_INSERTSTRUCT lpInsertStruct)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)lpInsertStruct);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem InsertItem(LPCTSTR lpszItem, int nImage,
		int nSelectedImage, HTREEITEM hParent, HTREEITEM hInsertAfter)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return InsertItem(TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE, lpszItem, nImage, nSelectedImage, 0, 0, 0, hParent, hInsertAfter); 
	}
	CTreeItem InsertItem(LPCTSTR lpszItem, HTREEITEM hParent, HTREEITEM hInsertAfter)
	{ 
		ATLASSERT(::IsWindow(m_hWnd));
		return InsertItem(TVIF_TEXT, lpszItem, 0, 0, 0, 0, 0, hParent, hInsertAfter);
	}
	CTreeItem GetNextItem(HTREEITEM hItem, UINT nCode)
	{ 
		ATLASSERT(::IsWindow(m_hWnd)); 
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, nCode, (LPARAM)hItem);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetChildItem(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)hItem);
		return CTreeItem(hTreeItem, this); 
	}
	CTreeItem GetNextSiblingItem(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXT, (LPARAM)hItem); 
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetPrevSiblingItem(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUS, (LPARAM)hItem);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetParentItem(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hItem); 
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetFirstVisibleItem()
	{
		ATLASSERT(::IsWindow(m_hWnd)); 
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_FIRSTVISIBLE, 0L);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetNextVisibleItem(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXTVISIBLE, (LPARAM)hItem);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetPrevVisibleItem(HTREEITEM hItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUSVISIBLE, (LPARAM)hItem);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetSelectedItem()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CARET, 0L);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetDropHilightItem()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_DROPHILITE, 0L);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem GetRootItem()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_ROOT, 0L);
		return CTreeItem(hTreeItem, this);
	}
	CTreeItem HitTest(TV_HITTESTINFO* pHitTestInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)pHitTestInfo);
		return CTreeItem(hTreeItem, this);
	}

	CTreeItem InsertItem(UINT nMask, LPCTSTR lpszItem, int nImage,
		int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam,
		HTREEITEM hParent, HTREEITEM hInsertAfter)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TV_INSERTSTRUCT tvis;
		tvis.hParent = hParent;
		tvis.hInsertAfter = hInsertAfter;
		tvis.item.mask = nMask;
		tvis.item.pszText = (LPTSTR) lpszItem;
		tvis.item.iImage = nImage;
		tvis.item.iSelectedImage = nSelectedImage;
		tvis.item.state = nState;
		tvis.item.stateMask = nStateMask;
		tvis.item.lParam = lParam;
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)&tvis);
		return CTreeItem(hTreeItem, this);
	}

	CTreeItem HitTest(POINT pt, UINT* pFlags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TV_HITTESTINFO hti;
		hti.pt = pt;
		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)&hti);
		if (pFlags != NULL)
			*pFlags = hti.flags;
		return CTreeItem(hTreeItem, this);
	}
};


// CTreeItem inline methods
inline BOOL CTreeItem::GetRect(LPRECT lpRect, BOOL bTextOnly) const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetItemRect(m_hTreeItem,lpRect,bTextOnly);
}
inline CTreeItem CTreeItem::GetNext(UINT nCode) const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetNextItem(m_hTreeItem,nCode);
}
inline CTreeItem CTreeItem::GetChild() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetChildItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetNextSibling() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetNextSiblingItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetPrevSibling() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetPrevSiblingItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetParent() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetParentItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetFirstVisible() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetFirstVisibleItem();
}
inline CTreeItem CTreeItem::GetNextVisible() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetNextVisibleItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetPrevVisible() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetPrevVisibleItem(m_hTreeItem);
}
inline CTreeItem CTreeItem::GetSelected() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetSelectedItem();
}
inline CTreeItem CTreeItem::GetDropHilight() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetDropHilightItem();
}
inline CTreeItem CTreeItem::GetRoot() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetRootItem();
}
inline BOOL CTreeItem::GetText(LPTSTR lpstrText, int nLen) const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetItemText(m_hTreeItem, lpstrText, nLen);
}
#ifndef _ATL_NO_COM
#ifdef _OLEAUTO_H_
inline BOOL CTreeItem::GetText(BSTR& bstrText) const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetItemText(m_hTreeItem, bstrText);
}
#endif // _OLEAUTO_H_
#endif //!_ATL_NO_COM
#ifdef __ATLSTR_H__
inline BOOL CTreeItem::GetText(CString& strText) const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetItemText(m_hTreeItem, strText);
}
#endif //__ATLSTR_H__
inline BOOL CTreeItem::GetImage(int& nImage, int& nSelectedImage) const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetItemImage(m_hTreeItem,nImage,nSelectedImage);
}
inline UINT CTreeItem::GetState(UINT nStateMask) const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetItemState(m_hTreeItem,nStateMask);
}
inline DWORD_PTR CTreeItem::GetData() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->GetItemData(m_hTreeItem);
}
inline BOOL CTreeItem::SetItem(UINT nMask, LPCTSTR lpszItem, int nImage,
		int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam)
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SetItem(m_hTreeItem, nMask, lpszItem, nImage, nSelectedImage, nState, nStateMask, lParam);
}
inline BOOL CTreeItem::SetText(LPCTSTR lpszItem)
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SetItemText(m_hTreeItem,lpszItem);
}
inline BOOL CTreeItem::SetImage(int nImage, int nSelectedImage)
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SetItemImage(m_hTreeItem,nImage,nSelectedImage);
}
inline BOOL CTreeItem::SetState(UINT nState, UINT nStateMask)
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SetItemState(m_hTreeItem,nState,nStateMask);
}
inline BOOL CTreeItem::SetData(DWORD_PTR dwData)
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SetItemData(m_hTreeItem,dwData);
}
inline BOOL CTreeItem::HasChildren() const
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->ItemHasChildren(m_hTreeItem);
}
inline BOOL CTreeItem::Delete()
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->DeleteItem(m_hTreeItem);
}
inline BOOL CTreeItem::Expand(UINT nCode)
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->Expand(m_hTreeItem,nCode);
}
inline BOOL CTreeItem::Select(UINT nCode)
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->Select(m_hTreeItem,nCode);
}
inline BOOL CTreeItem::Select()
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SelectItem(m_hTreeItem);
}
inline BOOL CTreeItem::SelectDropTarget()
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SelectDropTarget(m_hTreeItem);
}
inline BOOL CTreeItem::SelectSetFirstVisible()
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SelectSetFirstVisible(m_hTreeItem);
}
inline HWND CTreeItem::EditLabel()
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->EditLabel(m_hTreeItem);
}
inline HIMAGELIST CTreeItem::CreateDragImage()
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->CreateDragImage(m_hTreeItem);
}
inline BOOL CTreeItem::SortChildren()
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SortChildren(m_hTreeItem);
}
inline BOOL CTreeItem::EnsureVisible()
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->EnsureVisible(m_hTreeItem);
}

inline CTreeItem CTreeItem::_Insert(LPCTSTR lpstrItem, int nImageIndex, HTREEITEM hItemAfter)
{
	ATLASSERT(m_pTreeView != NULL);
	TV_INSERTSTRUCT ins;
	ins.hParent = m_hTreeItem;
	ins.hInsertAfter = hItemAfter;
	ins.item.mask = TVIF_TEXT;
	ins.item.pszText = (LPTSTR)lpstrItem;
	if(nImageIndex != -1)
	{
		ins.item.mask |= TVIF_IMAGE | TVIF_SELECTEDIMAGE;
		ins.item.iImage = nImageIndex;
		ins.item.iSelectedImage = nImageIndex;
	}
	return CTreeItem(m_pTreeView->InsertItem(&ins), m_pTreeView);
}

inline int CTreeItem::GetImageIndex() const
{
	ATLASSERT(m_pTreeView != NULL);
	TVITEM item;
	item.mask = TVIF_HANDLE | TVIF_IMAGE;
	item.hItem = m_hTreeItem;
	m_pTreeView->GetItem(&item);
	return item.iImage;
}

#if (_WIN32_IE >= 0x0400)
inline BOOL CTreeItem::SetInsertMark(BOOL bAfter)
{
	ATLASSERT(m_pTreeView != NULL);
	return m_pTreeView->SetInsertMark(m_hTreeItem, bAfter);
}
#endif //(_WIN32_IE >= 0x0400)


/////////////////////////////////////////////////////////////////////////////
// CToolBarCtrl

template <class TBase>
class CToolBarCtrlT : public TBase
{
public:
// Construction
	CToolBarCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CToolBarCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return TOOLBARCLASSNAME;
	}

	BOOL IsButtonEnabled(int nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONENABLED, nID, 0L);
	}
	BOOL IsButtonChecked(int nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONCHECKED, nID, 0L);
	}
	BOOL IsButtonPressed(int nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONPRESSED, nID, 0L);
	}
	BOOL IsButtonHidden(int nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return(BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONHIDDEN, nID, 0L);
	}
	BOOL IsButtonIndeterminate(int nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONINDETERMINATE, nID, 0L);
	}
	int GetState(int nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_GETSTATE, nID, 0L);
	}
	BOOL SetState(int nID, UINT nState)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETSTATE, nID, MAKELPARAM(nState, 0));
	}
	BOOL GetButton(int nIndex, LPTBBUTTON lpButton) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_GETBUTTON, nIndex, (LPARAM)lpButton);
	}
	int GetButtonCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_BUTTONCOUNT, 0, 0L);
	}
	BOOL GetItemRect(int nIndex, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_GETITEMRECT, nIndex, (LPARAM)lpRect);
	}
	void SetButtonStructSize(int nSize = sizeof(TBBUTTON))
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_BUTTONSTRUCTSIZE, nSize, 0L);
	}
	BOOL SetButtonSize(SIZE size)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETBUTTONSIZE, 0, MAKELPARAM(size.cx, size.cy));
	}
	BOOL SetButtonSize(int cx, int cy)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETBUTTONSIZE, 0, MAKELPARAM(cx, cy));
	}
	BOOL SetBitmapSize(SIZE size)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETBITMAPSIZE, 0, MAKELPARAM(size.cx, size.cy));
	}
	BOOL SetBitmapSize(int cx, int cy)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETBITMAPSIZE, 0, MAKELPARAM(cx, cy));
	}
	CToolTipCtrl GetToolTips() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, TB_GETTOOLTIPS, 0, 0L));
	}
	void SetToolTips(HWND hWndToolTip)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_SETTOOLTIPS, (WPARAM)hWndToolTip, 0L);
	}
	void SetNotifyWnd(HWND hWnd)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_SETPARENT, (WPARAM)hWnd, 0L);
	}
	int GetRows() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_GETROWS, 0, 0L);
	}
	void SetRows(int nRows, BOOL bLarger, LPRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_SETROWS, MAKELPARAM(nRows, bLarger), (LPARAM)lpRect);
	}
	BOOL SetCmdID(int nIndex, UINT nID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETCMDID, nIndex, nID);
	}
	DWORD GetBitmapFlags() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, TB_GETBITMAPFLAGS, 0, 0L);
	}
	int GetBitmap(int nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_GETBITMAP, nID, 0L);
	}
	int GetButtonText(int nID, LPTSTR lpstrText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_GETBUTTONTEXT, nID, (LPARAM)lpstrText);
	}

	CImageList GetImageList() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_GETIMAGELIST, 0, 0L));
	}
	CImageList SetImageList(HIMAGELIST hImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_SETIMAGELIST, 0, (LPARAM)hImageList));
	}
	CImageList GetDisabledImageList() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_GETDISABLEDIMAGELIST, 0, 0L));
	}
	CImageList SetDisabledImageList(HIMAGELIST hImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_SETDISABLEDIMAGELIST, 0, (LPARAM)hImageList));
	}
	CImageList GetHotImageList() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_GETHOTIMAGELIST, 0, 0L));
	}
	CImageList SetHotImageList(HIMAGELIST hImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_SETHOTIMAGELIST, 0, (LPARAM)hImageList));
	}
	DWORD GetStyle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, TB_GETSTYLE, 0, 0L);
	}
	void SetStyle(DWORD dwStyle)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_SETSTYLE, 0, dwStyle);
	}
	DWORD GetButtonSize() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, TB_GETBUTTONSIZE, 0, 0L);
	}
	void GetButtonSize(SIZE& size) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, TB_GETBUTTONSIZE, 0, 0L);
		size.cx = LOWORD(dwRet);
		size.cy = HIWORD(dwRet);
	}
	BOOL GetRect(int nID, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_GETRECT, nID, (LPARAM)lpRect);
	}
	int GetTextRows() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_GETTEXTROWS, 0, 0L);
	}
	BOOL SetButtonWidth(int cxMin, int cxMax)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETBUTTONWIDTH, 0, MAKELPARAM(cxMin, cxMax));
	}
	BOOL SetIndent(int nIndent)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETINDENT, nIndent, 0L);
	}
	BOOL SetMaxTextRows(int nMaxTextRows)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETMAXTEXTROWS, nMaxTextRows, 0L);
	}

#if (_WIN32_IE >= 0x0400)
	BOOL GetAnchorHighlight() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_GETANCHORHIGHLIGHT, 0, 0L);
	}
	BOOL SetAnchorHighlight(BOOL bEnable = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETANCHORHIGHLIGHT, bEnable, 0L);
	}
	int GetButtonInfo(int nID, LPTBBUTTONINFO lptbbi) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_GETBUTTONINFO, nID, (LPARAM)lptbbi);
	}
	BOOL SetButtonInfo(int nID, LPTBBUTTONINFO lptbbi)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETBUTTONINFO, nID, (LPARAM)lptbbi);
	}
	int GetHotItem() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_GETHOTITEM, 0, 0L);
	}
	int SetHotItem(int nItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_SETHOTITEM, nItem, 0L);
	}
	BOOL IsButtonHighlighted(int nButtonID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONHIGHLIGHTED, nButtonID, 0L);
	}
	DWORD SetDrawTextFlags(DWORD dwMask, DWORD dwFlags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, TB_SETDRAWTEXTFLAGS, dwMask, dwFlags);
	}
	BOOL GetColorScheme(LPCOLORSCHEME lpcs) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_GETCOLORSCHEME, 0, (LPARAM)lpcs);
	}
	void SetColorScheme(LPCOLORSCHEME lpcs)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_SETCOLORSCHEME, 0, (LPARAM)lpcs);
	}
	DWORD GetExtendedStyle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, TB_GETEXTENDEDSTYLE, 0, 0L);
	}
	DWORD SetExtendedStyle(DWORD dwStyle)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, TB_SETEXTENDEDSTYLE, 0, dwStyle);
	}
	void GetInsertMark(LPTBINSERTMARK lptbim) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_GETINSERTMARK, 0, (LPARAM)lptbim);
	}
	void SetInsertMark(LPTBINSERTMARK lptbim)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_SETINSERTMARK, 0, (LPARAM)lptbim);
	}
	COLORREF GetInsertMarkColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TB_GETINSERTMARKCOLOR, 0, 0L);
	}
	COLORREF SetInsertMarkColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, TB_SETINSERTMARKCOLOR, 0, (LPARAM)clr);
	}
	BOOL GetMaxSize(LPSIZE lpSize) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_GETMAXSIZE, 0, (LPARAM)lpSize);
	}
	void GetPadding(LPSIZE lpSizePadding) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(lpSizePadding != NULL);
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, TB_GETPADDING, 0, 0L);
		lpSizePadding->cx = GET_X_LPARAM(dwRet);
		lpSizePadding->cy = GET_Y_LPARAM(dwRet);
	}
	void SetPadding(int cx, int cy, LPSIZE lpSizePadding = NULL)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, TB_SETPADDING, 0, MAKELPARAM(cx, cy));
		if(lpSizePadding != NULL)
		{
			lpSizePadding->cx = GET_X_LPARAM(dwRet);
			lpSizePadding->cy = GET_Y_LPARAM(dwRet);
		}
	}
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	int GetString(int nString, LPTSTR lpstrString, int cchMaxLen) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(cchMaxLen, nString), (LPARAM)lpstrString);
	}
	int GetStringBSTR(int nString, BSTR& bstrString) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(bstrString == NULL);
		int nLength = (int)(short)LOWORD(::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(0, nString), NULL));
		if(nLength != -1)
		{
			LPTSTR lpszString = (LPTSTR)_alloca((nLength + 1) * sizeof(TCHAR));
			nLength = (int)::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(nLength + 1, nString), (LPARAM)lpszString);
			if(nLength != -1)
				bstrString = ::SysAllocString(T2OLE(lpszString));
		}
		return nLength;
	}
#ifdef __ATLSTR_H__
	int GetString(int nString, CString& str) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nLength = (int)(short)LOWORD(::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(0, nString), NULL));
		if(nLength != -1)
		{
			nLength = (int)::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(nLength + 1, nString), (LPARAM)str.GetBufferSetLength(nLength+1));
			str.ReleaseBuffer();
		}
		return nLength;
	}
#endif //__ATLSTR_H__
#endif //(_WIN32_IE >= 0x0500)

// Operations
	BOOL EnableButton(int nID, BOOL bEnable = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_ENABLEBUTTON, nID, MAKELPARAM(bEnable, 0));
	}
	BOOL CheckButton(int nID, BOOL bCheck = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_CHECKBUTTON, nID, MAKELPARAM(bCheck, 0));
	}
	BOOL PressButton(int nID, BOOL bPress = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_PRESSBUTTON, nID, MAKELPARAM(bPress, 0));
	}
	BOOL HideButton(int nID, BOOL bHide = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_HIDEBUTTON, nID, MAKELPARAM(bHide, 0));
	}
	BOOL Indeterminate(int nID, BOOL bIndeterminate = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_INDETERMINATE, nID, MAKELPARAM(bIndeterminate, 0));
	}
	int AddBitmap(int nNumButtons, UINT nBitmapID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TBADDBITMAP tbab;
		tbab.hInst = _Module.GetResourceInstance();
		ATLASSERT(tbab.hInst != NULL);
		tbab.nID = nBitmapID;
		return (int)::SendMessage(m_hWnd, TB_ADDBITMAP, (WPARAM)nNumButtons, (LPARAM)&tbab);
	}
	int AddBitmap(int nNumButtons, HBITMAP hBitmap)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TBADDBITMAP tbab;
		tbab.hInst = NULL;
		tbab.nID = (UINT_PTR)hBitmap;
		return (int)::SendMessage(m_hWnd, TB_ADDBITMAP, (WPARAM)nNumButtons, (LPARAM)&tbab);
	}
	BOOL AddButtons(int nNumButtons, LPTBBUTTON lpButtons)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_ADDBUTTONS, nNumButtons, (LPARAM)lpButtons);
	}
	BOOL InsertButton(int nIndex, LPTBBUTTON lpButton)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_INSERTBUTTON, nIndex, (LPARAM)lpButton);
	}
	BOOL DeleteButton(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_DELETEBUTTON, nIndex, 0L);
	}
	UINT CommandToIndex(UINT nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, TB_COMMANDTOINDEX, nID, 0L);
	}
	void SaveState(HKEY hKeyRoot, LPCTSTR lpszSubKey, LPCTSTR lpszValueName)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TBSAVEPARAMS tbs;
		tbs.hkr = hKeyRoot;
		tbs.pszSubKey = lpszSubKey;
		tbs.pszValueName = lpszValueName;
		::SendMessage(m_hWnd, TB_SAVERESTORE, (WPARAM)TRUE, (LPARAM)&tbs);
	}
	void RestoreState(HKEY hKeyRoot, LPCTSTR lpszSubKey, LPCTSTR lpszValueName)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TBSAVEPARAMS tbs;
		tbs.hkr = hKeyRoot;
		tbs.pszSubKey = lpszSubKey;
		tbs.pszValueName = lpszValueName;
		::SendMessage(m_hWnd, TB_SAVERESTORE, (WPARAM)FALSE, (LPARAM)&tbs);
	}
	void Customize()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_CUSTOMIZE, 0, 0L);
	}
	int AddString(UINT nStringID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_ADDSTRING, (WPARAM)_Module.GetResourceInstance(), (LPARAM)nStringID);
	}
	int AddStrings(LPCTSTR lpszStrings)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_ADDSTRING, 0, (LPARAM)lpszStrings);
	}
	void AutoSize()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TB_AUTOSIZE, 0, 0L);
	}

	BOOL ChangeBitmap(int nID, int nBitmap)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_CHANGEBITMAP, nID, MAKELPARAM(nBitmap, 0));
	}
	int LoadImages(int nBitmapID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_LOADIMAGES, nBitmapID, (LPARAM)_Module.GetResourceInstance());
	}
	int LoadStdImages(int nBitmapID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_LOADIMAGES, nBitmapID, (LPARAM)HINST_COMMCTRL);
	}
	BOOL ReplaceBitmap(LPTBREPLACEBITMAP ptbrb)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_REPLACEBITMAP, 0, (LPARAM)ptbrb);
	}

#if (_WIN32_IE >= 0x0400)
	int HitTest(LPPOINT lpPoint)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TB_HITTEST, 0, (LPARAM)lpPoint);
	}
	BOOL InsertMarkHitTest(LPPOINT lpPoint, LPTBINSERTMARK lptbim)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_INSERTMARKHITTEST, (WPARAM)lpPoint, (LPARAM)lptbim);
	}
	BOOL InsertMarkHitTest(int x, int y, LPTBINSERTMARK lptbim)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		POINT pt = { x, y };
		return (BOOL)::SendMessage(m_hWnd, TB_INSERTMARKHITTEST, (WPARAM)&pt, (LPARAM)lptbim);
	}
	BOOL MapAccelerator(TCHAR chAccel, int& nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_MAPACCELERATOR, (WPARAM)chAccel, (LPARAM)&nID);
	}
	BOOL MarkButton(int nID, BOOL bHighlight = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_MARKBUTTON, nID, MAKELPARAM(bHighlight, 0));
	}
	BOOL MoveButton(int nOldPos, int nNewPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TB_MOVEBUTTON, nOldPos, nNewPos);
	}
	HRESULT GetObject(REFIID iid, LPVOID* ppvObject)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HRESULT)::SendMessage(m_hWnd, TB_GETOBJECT, (WPARAM)&iid, (LPARAM)ppvObject);
	}
#endif //(_WIN32_IE >= 0x0400)
};

typedef CToolBarCtrlT<CWindow>		CToolBarCtrl;


/////////////////////////////////////////////////////////////////////////////
// CStatusBarCtrl

template <class TBase>
class CStatusBarCtrlT : public TBase
{
public:
// Constructors
	CStatusBarCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CStatusBarCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Methods
	static LPCTSTR GetWndClassName()
	{
		return STATUSCLASSNAME;
	}

	int GetParts(int nParts, int* pParts) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, SB_GETPARTS, nParts, (LPARAM)pParts);
	}
	BOOL SetParts(int nParts, int* pWidths)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, SB_SETPARTS, nParts, (LPARAM)pWidths);
	}
	int GetTextLength(int nPane, int* pType = NULL) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, SB_GETTEXTLENGTH, (WPARAM)nPane, 0L);
		if (pType != NULL)
			*pType = (int)(short)HIWORD(dwRet);
		return (int)(short)LOWORD(dwRet);
	}
	int GetText(int nPane, LPTSTR lpszText, int* pType = NULL) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, SB_GETTEXT, (WPARAM)nPane, (LPARAM)lpszText);
		if(pType != NULL)
			*pType = (int)(short)HIWORD(dwRet);
		return (int)(short)LOWORD(dwRet);
	}
#ifndef _ATL_NO_COM
	BOOL GetTextBSTR(int nPane, BSTR& bstrText, int* pType = NULL) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		ATLASSERT(bstrText == NULL);
		int nLength = (int)(short)LOWORD(::SendMessage(m_hWnd, SB_GETTEXTLENGTH, (WPARAM)nPane, 0L));
		if(nLength == 0)
			return FALSE;

		LPTSTR lpszText = (LPTSTR)_alloca((nLength + 1) * sizeof(TCHAR));
		if(!GetText(nPane, lpszText, pType))
			return FALSE;

		bstrText = ::SysAllocString(T2OLE(lpszText));
		return (bstrText != NULL) ? TRUE : FALSE;
	}
#endif //!_ATL_NO_COM
#ifdef __ATLSTR_H__
	int GetText(int nPane, CString& strText, int* pType = NULL) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		int nLength = (int)(short)LOWORD(::SendMessage(m_hWnd, SB_GETTEXTLENGTH, (WPARAM)nPane, 0L));
		if(nLength == 0)
			return 0;

		return GetText(nPane, strText.GetBufferSetLength(nLength), pType);
	}
#endif //__ATLSTR_H__
	BOOL SetText(int nPane, LPCTSTR lpszText, int nType = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		return (BOOL)::SendMessage(m_hWnd, SB_SETTEXT, (nPane | nType), (LPARAM)lpszText);
	}
	BOOL GetRect(int nPane, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		return (BOOL)::SendMessage(m_hWnd, SB_GETRECT, nPane, (LPARAM)lpRect);
	}
	BOOL GetBorders(int* pBorders) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, SB_GETBORDERS, 0, (LPARAM)pBorders);
	}
	BOOL GetBorders(int& nHorz, int& nVert, int& nSpacing) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int borders[3];
		BOOL bResult = (BOOL)::SendMessage(m_hWnd, SB_GETBORDERS, 0, (LPARAM)&borders);
		if(bResult)
		{
			nHorz = borders[0];
			nVert = borders[1];
			nSpacing = borders[2];
		}
		return bResult;
	}
	void SetMinHeight(int nMin)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, SB_SETMINHEIGHT, nMin, 0L);
	}
	BOOL SetSimple(BOOL bSimple = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, SB_SIMPLE, bSimple, 0L);
	}
	BOOL IsSimple() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, SB_ISSIMPLE, 0, 0L);
	}

#if (_WIN32_IE >= 0x0400)
	COLORREF SetBkColor(COLORREF clrBk)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, SB_SETBKCOLOR, 0, (LPARAM)clrBk);
	}
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, SB_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, SB_SETUNICODEFORMAT, bUnicode, 0L);
	}
	void GetTipText(int nPane, LPTSTR lpstrText, int nSize) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		::SendMessage(m_hWnd, SB_GETTIPTEXT, MAKEWPARAM(nPane, nSize), (LPARAM)lpstrText);
	}
	void SetTipText(int nPane, LPCTSTR lpstrText)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		::SendMessage(m_hWnd, SB_SETTIPTEXT, nPane, (LPARAM)lpstrText);
	}
	HICON GetIcon(int nPane) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		return (HICON)::SendMessage(m_hWnd, SB_GETICON, nPane, 0L);
	}
	BOOL SetIcon(int nPane, HICON hIcon)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPane < 256);
		return (BOOL)::SendMessage(m_hWnd, SB_SETICON, nPane, (LPARAM)hIcon);
	}
#endif //(_WIN32_IE >= 0x0400)
};

typedef CStatusBarCtrlT<CWindow>		CStatusBarCtrl;


/////////////////////////////////////////////////////////////////////////////
// CTabCtrl

template <class TBase>
class CTabCtrlT : public TBase
{
public:
// Constructors
	CTabCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CTabCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return WC_TABCONTROL;
	}

	CImageList GetImageList() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TCM_GETIMAGELIST, 0, 0L));
	}
	CImageList SetImageList(HIMAGELIST hImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TCM_SETIMAGELIST, 0, (LPARAM)hImageList));
	}
	int GetItemCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TCM_GETITEMCOUNT, 0, 0L);
	}
	BOOL GetItem(int nItem, LPTCITEM pTabCtrlItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_GETITEM, nItem, (LPARAM)pTabCtrlItem);
	}
	BOOL SetItem(int nItem, LPTCITEM pTabCtrlItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_SETITEM, nItem, (LPARAM)pTabCtrlItem);
	}
	BOOL GetItemRect(int nItem, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_GETITEMRECT, nItem, (LPARAM)lpRect);
	}
	int GetCurSel() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TCM_GETCURSEL, 0, 0L);
	}
	int SetCurSel(int nItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TCM_SETCURSEL, nItem, 0L);
	}
	SIZE SetItemSize(SIZE size)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwSize = (DWORD)::SendMessage(m_hWnd, TCM_SETITEMSIZE, 0, MAKELPARAM(size.cx, size.cy));
		SIZE sizeRet = { GET_X_LPARAM(dwSize), GET_Y_LPARAM(dwSize) };
		return sizeRet;
	}
	void SetPadding(SIZE size)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TCM_SETPADDING, 0, MAKELPARAM(size.cx, size.cy));
	}
	int GetRowCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TCM_GETROWCOUNT, 0, 0L);
	}
	CToolTipCtrl GetTooltips() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, TCM_GETTOOLTIPS, 0, 0L));
	}
	void SetTooltips(HWND hWndToolTip)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TCM_SETTOOLTIPS, (WPARAM)hWndToolTip, 0L);
	}
	int GetCurFocus() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TCM_GETCURFOCUS, 0, 0L);
	}

	void SetCurFocus(int nItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TCM_SETCURFOCUS, nItem, 0L);
	}
	BOOL SetItemExtra(int cbExtra)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetItemCount() == 0);	// must be empty
		return (BOOL)::SendMessage(m_hWnd, TCM_SETITEMEXTRA, cbExtra, 0L);
	}
	int SetMinTabWidth(int nWidth = -1)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TCM_SETMINTABWIDTH, 0, nWidth);
	}

#if (_WIN32_IE >= 0x0400)
	DWORD GetExtendedStyle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, TCM_GETEXTENDEDSTYLE, 0, 0L);
	}
	DWORD SetExtendedStyle(DWORD dwExMask, DWORD dwExStyle)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, TCM_SETEXTENDEDSTYLE, dwExMask, dwExStyle);
	}
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

// Operations
	BOOL InsertItem(int nItem, LPTCITEM pTabCtrlItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_INSERTITEM, nItem, (LPARAM)pTabCtrlItem);
	}
	BOOL DeleteItem(int nItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_DELETEITEM, nItem, 0L);
	}
	BOOL DeleteAllItems()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_DELETEALLITEMS, 0, 0L);
	}
	void AdjustRect(BOOL bLarger, LPRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TCM_ADJUSTRECT, bLarger, (LPARAM)lpRect);
	}
	void RemoveImage(int nImage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TCM_REMOVEIMAGE, nImage, 0L);
	}
	int HitTest(TC_HITTESTINFO* pHitTestInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TCM_HITTEST, 0, (LPARAM)pHitTestInfo);
	}
	void DeselectAll(BOOL bExcludeFocus = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TCM_DESELECTALL, bExcludeFocus, 0L);
	}

#if (_WIN32_IE >= 0x0400)
	BOOL HighlightItem(int nIndex, BOOL bHighlight = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TCM_HIGHLIGHTITEM, nIndex, MAKELPARAM(bHighlight, 0));
	}
#endif //(_WIN32_IE >= 0x0400)
};

typedef CTabCtrlT<CWindow>	CTabCtrl;


/////////////////////////////////////////////////////////////////////////////
// CTrackBarCtrl

template <class TBase>
class CTrackBarCtrlT : public TBase
{
public:
// Constructors
	CTrackBarCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CTrackBarCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return TRACKBAR_CLASS;
	}

	int GetLineSize() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETLINESIZE, 0, 0L);
	}
	int SetLineSize(int nSize)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_SETLINESIZE, 0, nSize);
	}
	int GetPageSize() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETPAGESIZE, 0, 0L);
	}
	int SetPageSize(int nSize)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_SETPAGESIZE, 0, nSize);
	}
	int GetRangeMin() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETRANGEMIN, 0, 0L);
	}
	void SetRangeMin(int nMin, BOOL bRedraw = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETRANGEMIN, bRedraw, nMin);
	}
	int GetRangeMax() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETRANGEMAX, 0, 0L);
	}
	void SetRangeMax(int nMax, BOOL bRedraw = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETRANGEMAX, bRedraw, nMax);
	}
	void GetRange(int& nMin, int& nMax) const
	{
		nMin = GetRangeMin();
		nMax = GetRangeMax();
	}
	void SetRange(int nMin, int nMax, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETRANGE, bRedraw, MAKELPARAM(nMin, nMax));
	}
	int GetSelStart() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETSELSTART, 0, 0L);
	}
	void SetSelStart(int nMin)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETSELSTART, 0, (LPARAM)nMin);
	}
	int GetSelEnd() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETSELEND, 0, 0L);
	}
	void SetSelEnd(int nMax)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETSELEND, 0, (LPARAM)nMax);
	}
	void GetSelection(int& nMin, int& nMax) const
	{
		nMin = GetSelStart();
		nMax = GetSelEnd();
	}
	void SetSelection(int nMin, int nMax)
	{
		SetSelStart(nMin);
		SetSelEnd(nMax);
	}
	void GetChannelRect(LPRECT lprc) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_GETCHANNELRECT, 0, (LPARAM)lprc);
	}
	void GetThumbRect(LPRECT lprc) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_GETTHUMBRECT, 0, (LPARAM)lprc);
	}
	int GetPos() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETPOS, 0, 0L);
	}
	void SetPos(int nPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETPOS, TRUE, nPos);
	}
	UINT GetNumTics() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, TBM_GETNUMTICS, 0, 0L);
	}
	DWORD* GetTicArray() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD*)::SendMessage(m_hWnd, TBM_GETPTICS, 0, 0L);
	}
	int GetTic(int nTic) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETTIC, nTic, 0L);
	}
	BOOL SetTic(int nTic)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TBM_SETTIC, 0, nTic);
	}
	int GetTicPos(int nTic) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETTICPOS, nTic, 0L);
	}
	void SetTicFreq(int nFreq)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETTICFREQ, nFreq, 0L);
	}

	int GetThumbLength() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_GETTHUMBLENGTH, 0, 0L);
	}
	void SetThumbLength(int nLength)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETTHUMBLENGTH, nLength, 0L);
	}
	void SetSel(int nStart, int nEnd, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & TBS_ENABLESELRANGE) != 0);
		::SendMessage(m_hWnd, TBM_SETSEL, bRedraw, MAKELPARAM(nStart, nEnd));
	}
	CWindow GetBuddy(BOOL bLeft = TRUE) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow((HWND)::SendMessage(m_hWnd, TBM_GETBUDDY, bLeft, 0L));
	}
	CWindow SetBuddy(HWND hWndBuddy, BOOL bLeft = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow((HWND)::SendMessage(m_hWnd, TBM_SETBUDDY, bLeft, (LPARAM)hWndBuddy));
	}
	CToolTipCtrl GetToolTips() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, TBM_GETTOOLTIPS, 0, 0L));
	}
	void SetToolTips(HWND hWndTT)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETTOOLTIPS, (WPARAM)hWndTT, 0L);
	}
	int SetTipSide(int nSide)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, TBM_SETTIPSIDE, nSide, 0L);
	}

#if (_WIN32_IE >= 0x0400)
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TBM_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, TBM_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

// Operations
	void ClearSel(BOOL bRedraw = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_CLEARSEL, bRedraw, 0L);
	}
	void VerifyPos()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_SETPOS, FALSE, 0L);
	}
	void ClearTics(BOOL bRedraw = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, TBM_CLEARTICS, bRedraw, 0L);
	}
};

typedef CTrackBarCtrlT<CWindow>		CTrackBarCtrl;


/////////////////////////////////////////////////////////////////////////////
// CUpDownCtrl

template <class TBase>
class CUpDownCtrlT : public TBase
{
public:
// Constructors
	CUpDownCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CUpDownCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return UPDOWN_CLASS;
	}

	UINT GetAccel(int nAccel, UDACCEL* pAccel) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)LOWORD(::SendMessage(m_hWnd, UDM_GETACCEL, nAccel, (LPARAM)pAccel));
	}
	BOOL SetAccel(int nAccel, UDACCEL* pAccel)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)LOWORD(::SendMessage(m_hWnd, UDM_SETACCEL, nAccel, (LPARAM)pAccel));
	}
	UINT GetBase() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)LOWORD(::SendMessage(m_hWnd, UDM_GETBASE, 0, 0L));
	}
	int SetBase(int nBase)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, UDM_SETBASE, nBase, 0L);
	}
	CWindow GetBuddy() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow((HWND)::SendMessage(m_hWnd, UDM_GETBUDDY, 0, 0L));
	}
	CWindow SetBuddy(HWND hWndBuddy)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow((HWND)::SendMessage(m_hWnd, UDM_SETBUDDY, (WPARAM)hWndBuddy, 0L));
	}
	int GetPos() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, UDM_GETPOS, 0, 0L);
	}
	int SetPos(int nPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)(short)LOWORD(::SendMessage(m_hWnd, UDM_SETPOS, 0, MAKELPARAM(nPos, 0)));
	}
	DWORD GetRange() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, UDM_GETRANGE, 0, 0L);
	}
	void GetRange(int& nLower, int& nUpper) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, UDM_GETRANGE, 0, 0L);
		nLower = (int)(short)HIWORD(dwRet);
		nUpper = (int)(short)LOWORD(dwRet);
	}
	void SetRange(int nLower, int nUpper)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, UDM_SETRANGE, 0, MAKELPARAM(nUpper, nLower));
	}

#if (_WIN32_IE >= 0x0400)
	void SetRange32(int nLower, int nUpper)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, UDM_SETRANGE32, nLower, nUpper);
	}
	void GetRange32(int& nLower, int& nUpper) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, UDM_GETRANGE32, (WPARAM)&nLower, (LPARAM)&nUpper);
	}
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, UDM_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, UDM_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	int GetPos32(LPBOOL lpbError /*= NULL*/) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, UDM_GETPOS32, 0, (LPARAM)lpbError);
	}
	int SetPos32(int nPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, UDM_SETPOS32, 0, (LPARAM)nPos);
	}
#endif //(_WIN32_IE >= 0x0500)
};

typedef CUpDownCtrlT<CWindow>		CUpDownCtrl;


/////////////////////////////////////////////////////////////////////////////
// CProgressBarCtrl

template <class TBase>
class CProgressBarCtrlT : public TBase
{
public:
// Constructors
	CProgressBarCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CProgressBarCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return PROGRESS_CLASS;
	}

	DWORD SetRange(int nLower, int nUpper)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, PBM_SETRANGE, 0, MAKELPARAM(nLower, nUpper));
	}
	int SetPos(int nPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)(short)LOWORD(::SendMessage(m_hWnd, PBM_SETPOS, nPos, 0L));
	}
	int OffsetPos(int nPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)(short)LOWORD(::SendMessage(m_hWnd, PBM_DELTAPOS, nPos, 0L));
	}
	int SetStep(int nStep)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)(short)LOWORD(::SendMessage(m_hWnd, PBM_SETSTEP, nStep, 0L));
	}
	UINT GetPos() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, PBM_GETPOS, 0, 0L);
	}
	void GetRange(PPBRANGE pPBRange) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(pPBRange != NULL);
		::SendMessage(m_hWnd, PBM_GETRANGE, TRUE, (LPARAM)pPBRange);
	}
	int GetRangeLimit(BOOL bLimit) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PBM_GETRANGE, bLimit, (LPARAM)NULL);
	}
	DWORD SetRange32(int nMin, int nMax)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, PBM_SETRANGE32, nMin, nMax);
	}

#if (_WIN32_IE >= 0x0400)
	COLORREF SetBarColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, PBM_SETBARCOLOR, 0, (LPARAM)clr);
	}
	COLORREF SetBkColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, PBM_SETBKCOLOR, 0, (LPARAM)clr);
	}
#endif //(_WIN32_IE >= 0x0400)

// Operations
	int StepIt()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)(short)LOWORD(::SendMessage(m_hWnd, PBM_STEPIT, 0, 0L));
	}
};

typedef CProgressBarCtrlT<CWindow>	CProgressBarCtrl;


/////////////////////////////////////////////////////////////////////////////
// CHotKeyCtrl

template <class TBase>
class CHotKeyCtrlT : public TBase
{
public:
// Constructors
	CHotKeyCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CHotKeyCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return HOTKEY_CLASS;
	}

	DWORD GetHotKey() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, HKM_GETHOTKEY, 0, 0L);
	}
	void GetHotKey(WORD &wVirtualKeyCode, WORD &wModifiers) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dw = (DWORD)::SendMessage(m_hWnd, HKM_GETHOTKEY, 0, 0L);
		wVirtualKeyCode = LOBYTE(LOWORD(dw));
		wModifiers = HIBYTE(LOWORD(dw));
	}
	void SetHotKey(WORD wVirtualKeyCode, WORD wModifiers)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, HKM_SETHOTKEY, MAKEWORD(wVirtualKeyCode, wModifiers), 0L);
	}

	void SetRules(WORD wInvalidComb, WORD wModifiers)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, HKM_SETRULES, wInvalidComb, MAKELPARAM(wModifiers, 0));
	}
};

typedef CHotKeyCtrlT<CWindow>		CHotKeyCtrl;


/////////////////////////////////////////////////////////////////////////////
// CAnimateCtrl

template <class TBase>
class CAnimateCtrlT : public TBase
{
public:
// Constructors
	CAnimateCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CAnimateCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return ANIMATE_CLASS;
	}

// Operations
	BOOL Open(_U_STRINGorID FileName)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, ACM_OPEN, 0, (LPARAM)FileName.m_lpstr);
	}
	BOOL Play(UINT nFrom, UINT nTo, UINT nRep)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, ACM_PLAY, nRep, MAKELPARAM(nFrom, nTo));
	}
	BOOL Stop()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, ACM_STOP, 0, 0L);
	}
	BOOL Close()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, ACM_OPEN, 0, 0L);
	}
	BOOL Seek(UINT nTo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, ACM_PLAY, 0, MAKELPARAM(nTo, nTo));
	}
};

typedef CAnimateCtrlT<CWindow>		CAnimateCtrl;


/////////////////////////////////////////////////////////////////////////////
// CRichEditCtrl

#ifdef _UNICODE
#if (_RICHEDIT_VER == 0x0100)
#undef RICHEDIT_CLASS
#define RICHEDIT_CLASS	L"RICHEDIT"
#endif //(_RICHEDIT_VER == 0x0100)
#endif //_UNICODE

template <class TBase>
class CRichEditCtrlT : public TBase
{
public:
// Constructors
	CRichEditCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CRichEditCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return RICHEDIT_CLASS;
	}

	static LPCTSTR GetLibraryName()
	{
#if (_RICHEDIT_VER >= 0x0200)
		return _T("RICHED20.DLL");
#else
		return _T("RICHED32.DLL");
#endif
	}

	int GetLineCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0L);
	}
	BOOL GetModify() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0L);
	}
	void SetModify(BOOL bModified = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0L);
	}
	void GetRect(LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect);
	}
	DWORD GetOptions() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, EM_GETOPTIONS, 0, 0L);
	}
	DWORD SetOptions(WORD wOperation, DWORD dwOptions)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, EM_SETOPTIONS, wOperation, dwOptions);
	}

	// NOTE: first word in lpszBuffer must contain the size of the buffer!
	int GetLine(int nIndex, LPTSTR lpszBuffer) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
	}
	int GetLine(int nIndex, LPTSTR lpszBuffer, int nMaxLength) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		*(LPINT)lpszBuffer = nMaxLength;
		return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
	}

	BOOL CanUndo() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0L);
	}
	BOOL CanPaste(UINT nFormat = 0) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_CANPASTE, nFormat, 0L);
	}
	void GetSel(LONG& nStartChar, LONG& nEndChar) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		CHARRANGE cr;
		::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
		nStartChar = cr.cpMin;
		nEndChar = cr.cpMax;
	}
	void GetSel(CHARRANGE &cr) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
	}
	int SetSel(LONG nStartChar, LONG nEndChar)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		CHARRANGE cr = { nStartChar, nEndChar };
		return (int)::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr);
	}
	int SetSel(CHARRANGE &cr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr);
	}
	int SetSelAll()
	{
		return SetSel(0, -1);
	}
	int SetSelNone()
	{
		return SetSel(-1, 0);
	}
	DWORD GetDefaultCharFormat(CHARFORMAT& cf) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT);
		return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 0, (LPARAM)&cf);
	}
	DWORD GetSelectionCharFormat(CHARFORMAT& cf) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT);
		return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 1, (LPARAM)&cf);
	}
	DWORD GetEventMask() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, EM_GETEVENTMASK, 0, 0L);
	}
	LONG GetLimitText() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LONG)::SendMessage(m_hWnd, EM_GETLIMITTEXT, 0, 0L);
	}
	DWORD GetParaFormat(PARAFORMAT& pf) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		pf.cbSize = sizeof(PARAFORMAT);
		return (DWORD)::SendMessage(m_hWnd, EM_GETPARAFORMAT, 0, (LPARAM)&pf);
	}
	// richedit EM_GETSELTEXT is ANSI
	LONG GetSelText(LPSTR lpBuf) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LONG)::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpBuf);
	}
#ifndef _ATL_NO_COM
	BOOL GetSelTextBSTR(BSTR& bstrText) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(bstrText == NULL);

		CHARRANGE cr;
		cr.cpMin = cr.cpMax = 0;
		::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
		LPSTR lpstrText = (char*)_alloca((cr.cpMax - cr.cpMin + 1) * 2);
		lpstrText[0] = 0;
		if(::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpstrText) == 0)
			return FALSE;

		bstrText = ::SysAllocString(A2W(lpstrText));
		return (bstrText != NULL) ? TRUE : FALSE;
	}
#endif //!_ATL_NO_COM
#ifdef __ATLSTR_H__
	LONG GetSelText(CString& strText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));

		CHARRANGE cr;
		cr.cpMin = cr.cpMax = 0;
		::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
		LPSTR lpstrText = (char*)_alloca((cr.cpMax - cr.cpMin + 1) * 2);
		lpstrText[0] = 0;
		LONG lLen = (LONG)::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpstrText);
		if(lLen == 0)
			return 0;

		USES_CONVERSION;
		strText = A2T(lpstrText);
		return lLen;
	}
#endif //__ATLSTR_H__
	WORD GetSelectionType() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (WORD)::SendMessage(m_hWnd, EM_SELECTIONTYPE, 0, 0L);
	}
	COLORREF SetBackgroundColor(COLORREF cr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, EM_SETBKGNDCOLOR, 0, cr);
	}
	COLORREF SetBackgroundColor()	// sets to system background
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, EM_SETBKGNDCOLOR, 1, 0);
	}
	BOOL SetDefaultCharFormat(CHARFORMAT& cf)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT);
		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
	}
	BOOL SetSelectionCharFormat(CHARFORMAT& cf)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT);
		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
	}
	BOOL SetWordCharFormat(CHARFORMAT& cf)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT);
		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD, (LPARAM)&cf);
	}
	DWORD SetEventMask(DWORD dwEventMask)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, EM_SETEVENTMASK, 0, dwEventMask);
	}
	BOOL SetParaFormat(PARAFORMAT& pf)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		pf.cbSize = sizeof(PARAFORMAT);
		return (BOOL)::SendMessage(m_hWnd, EM_SETPARAFORMAT, 0, (LPARAM)&pf);
	}
	BOOL SetTargetDevice(HDC hDC, int cxLineWidth)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_SETTARGETDEVICE, (WPARAM)hDC, cxLineWidth);
	}
	int GetTextLength() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, WM_GETTEXTLENGTH, 0, 0L);
	}
	BOOL SetReadOnly(BOOL bReadOnly = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L);
	}
	int GetFirstVisibleLine() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L);
	}

	int GetTextRange(TEXTRANGE* pTextRange) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETTEXTRANGE, 0, (LPARAM)pTextRange);
	}
	int GetTextRange(LONG nStartChar, LONG nEndChar, LPSTR lpstrText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		TEXTRANGE tr;
		tr.chrg.cpMin = nStartChar;
		tr.chrg.cpMax = nEndChar;
		tr.lpstrText = lpstrText;
		return (int)::SendMessage(m_hWnd, EM_GETTEXTRANGE, 0, (LPARAM)&tr);
	}
	EDITWORDBREAKPROCEX GetWordBreakProcEx() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (EDITWORDBREAKPROCEX)::SendMessage(m_hWnd, EM_GETWORDBREAKPROCEX, 0, 0L);
	}
	EDITWORDBREAKPROCEX SetWordBreakProcEx(EDITWORDBREAKPROCEX pfnEditWordBreakProcEx)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (EDITWORDBREAKPROCEX)::SendMessage(m_hWnd, EM_SETWORDBREAKPROCEX, 0, (LPARAM)pfnEditWordBreakProcEx);
	}

#if (_RICHEDIT_VER >= 0x0200)
	DWORD GetDefaultCharFormat(CHARFORMAT2& cf) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT2);
		return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 0, (LPARAM)&cf);
	}
	BOOL SetDefaultCharFormat(CHARFORMAT2& cf)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT2);
		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
	}
	DWORD GetSelectionCharFormat(CHARFORMAT2& cf) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT2);
		return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 1, (LPARAM)&cf);
	}
	BOOL SetSelectionCharFormat(CHARFORMAT2& cf)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT2);
		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
	}
	BOOL SetWordCharFormat(CHARFORMAT2& cf)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		cf.cbSize = sizeof(CHARFORMAT2);
		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD, (LPARAM)&cf);
	}

	DWORD GetParaFormat(PARAFORMAT2& pf) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		pf.cbSize = sizeof(PARAFORMAT2);
		return (DWORD)::SendMessage(m_hWnd, EM_GETPARAFORMAT, 0, (LPARAM)&pf);
	}
	BOOL SetParaFormat(PARAFORMAT2& pf)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		pf.cbSize = sizeof(PARAFORMAT2);
		return (BOOL)::SendMessage(m_hWnd, EM_SETPARAFORMAT, 0, (LPARAM)&pf);
	}
	TEXTMODE GetTextMode() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (TEXTMODE)::SendMessage(m_hWnd, EM_GETTEXTMODE, 0, 0L);
	}
	BOOL SetTextMode(TEXTMODE enumTextMode)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return !(BOOL)::SendMessage(m_hWnd, EM_SETTEXTMODE, enumTextMode, 0L);
	}
	UNDONAMEID GetUndoName() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UNDONAMEID)::SendMessage(m_hWnd, EM_GETUNDONAME, 0, 0L);
	}
	UNDONAMEID GetRedoName() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UNDONAMEID)::SendMessage(m_hWnd, EM_GETREDONAME, 0, 0L);
	}
	BOOL CanRedo() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_CANREDO, 0, 0L);
	}
	BOOL GetAutoURLDetect() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_GETAUTOURLDETECT, 0, 0L);
	}
	BOOL SetAutoURLDetect(BOOL bAutoDetect = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return !(BOOL)::SendMessage(m_hWnd, EM_AUTOURLDETECT, bAutoDetect, 0L);
	}
	// this method is deprecated, please use SetAutoURLDetect
	BOOL EnableAutoURLDetect(BOOL bEnable = TRUE) { return SetAutoURLDetect(bEnable); }
	UINT SetUndoLimit(UINT uUndoLimit)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, EM_SETUNDOLIMIT, uUndoLimit, 0L);
	}
	void SetPalette(HPALETTE hPalette)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETPALETTE, (WPARAM)hPalette, 0L);
	}
	int GetTextEx(GETTEXTEX* pGetTextEx, LPTSTR lpstrText) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETTEXTEX, (WPARAM)pGetTextEx, (LPARAM)lpstrText);
	}
	int GetTextEx(LPTSTR lpstrText, int nTextLen, DWORD dwFlags = GT_DEFAULT, UINT uCodePage = CP_ACP, LPCSTR lpDefaultChar = NULL, LPBOOL lpUsedDefChar = NULL) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		GETTEXTEX gte;
		gte.cb = nTextLen * sizeof(TCHAR);
		gte.codepage = uCodePage;
		gte.flags = dwFlags;
		gte.lpDefaultChar = lpDefaultChar;
		gte.lpUsedDefChar = lpUsedDefChar;
		return (int)::SendMessage(m_hWnd, EM_GETTEXTEX, (WPARAM)&gte, (LPARAM)lpstrText);
	}
	int GetTextLengthEx(GETTEXTLENGTHEX* pGetTextLengthEx) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETTEXTLENGTHEX, (WPARAM)pGetTextLengthEx, 0L);
	}
	int GetTextLengthEx(DWORD dwFlags = GTL_DEFAULT, UINT uCodePage = CP_ACP) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		GETTEXTLENGTHEX gtle;
		gtle.codepage = uCodePage;
		gtle.flags = dwFlags;
		return (int)::SendMessage(m_hWnd, EM_GETTEXTLENGTHEX, (WPARAM)&gtle, 0L);
	}
#endif //(_RICHEDIT_VER >= 0x0200)

#if (_RICHEDIT_VER >= 0x0300)
	int SetTextEx(SETTEXTEX* pSetTextEx, LPCTSTR lpstrText)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_SETTEXTEX, (WPARAM)pSetTextEx, (LPARAM)lpstrText);
	}
	int SetTextEx(LPCTSTR lpstrText, DWORD dwFlags = ST_DEFAULT, UINT uCodePage = CP_ACP)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		SETTEXTEX ste;
		ste.flags = dwFlags;
		ste.codepage = uCodePage;
		return (int)::SendMessage(m_hWnd, EM_SETTEXTEX, (WPARAM)&ste, (LPARAM)lpstrText);
	}
	int GetEditStyle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_GETEDITSTYLE, 0, 0L);
	}

	int SetEditStyle(int nStyle, int nMask = -1)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		if(nMask == -1)
			nMask = nStyle;	// set everything specified
		return (int)::SendMessage(m_hWnd, EM_SETEDITSTYLE, nStyle, nMask);
	}
	BOOL SetFontSize(int nFontSizeDelta)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nFontSizeDelta >= -1637 && nFontSizeDelta <= 1638);
		return (BOOL)::SendMessage(m_hWnd, EM_SETFONTSIZE, nFontSizeDelta, 0L);
	}
	void GetScrollPos(LPPOINT lpPoint) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(lpPoint != NULL);
		::SendMessage(m_hWnd, EM_GETSCROLLPOS, 0, (LPARAM)lpPoint);
	}
	void SetScrollPos(LPPOINT lpPoint)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(lpPoint != NULL);
		::SendMessage(m_hWnd, EM_SETSCROLLPOS, 0, (LPARAM)lpPoint);
	}
	BOOL GetZoom(int& nNum, int& nDen) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_GETZOOM, (WPARAM)&nNum, (LPARAM)&nDen);
	}
	BOOL SetZoom(int nNum, int nDen)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nNum >= 0 && nNum <= 64);
		ATLASSERT(nDen >= 0 && nDen <= 64);
		return (BOOL)::SendMessage(m_hWnd, EM_SETZOOM, nNum, nDen);
	}
	BOOL SetZoomOff()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_SETZOOM, 0, 0L);
	}
#endif //(_RICHEDIT_VER >= 0x0300)

// Operations
	void LimitText(LONG nChars = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_EXLIMITTEXT, 0, nChars);
	}
	int LineFromChar(LONG nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_EXLINEFROMCHAR, 0, nIndex);
	}
	POINT PosFromChar(LONG nChar) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		POINT point;
		::SendMessage(m_hWnd, EM_POSFROMCHAR, (WPARAM)&point, nChar);
		return point;
	}
	int CharFromPos(POINT pt) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_CHARFROMPOS, 0, MAKELPARAM(pt.x, pt.y));
	}
	void EmptyUndoBuffer()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0L);
	}
	int LineIndex(int nLine = -1) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_LINEINDEX, nLine, 0L);
	}
	int LineLength(int nLine = -1) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, EM_LINELENGTH, nLine, 0L);
	}
	BOOL LineScroll(int nLines, int nChars = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_LINESCROLL, nChars, nLines);
	}
	void ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM) bCanUndo, (LPARAM)lpszNewText);
	}
	void SetRect(LPCRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect);
	}

	BOOL DisplayBand(LPRECT pDisplayRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_DISPLAYBAND, 0, (LPARAM)pDisplayRect);
	}
	LONG FindText(DWORD dwFlags, FINDTEXT& ft) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
#if (_RICHEDIT_VER >= 0x0200) && defined(_UNICODE)
		return (LONG)::SendMessage(m_hWnd, EM_FINDTEXTW, dwFlags, (LPARAM)&ft);
#else
		return (LONG)::SendMessage(m_hWnd, EM_FINDTEXT, dwFlags, (LPARAM)&ft);
#endif
	}
	LONG FindText(DWORD dwFlags, FINDTEXTEX& ft) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
#if (_RICHEDIT_VER >= 0x0200) && defined(_UNICODE)
		return (LONG)::SendMessage(m_hWnd, EM_FINDTEXTEXW, dwFlags, (LPARAM)&ft);
#else
		return (LONG)::SendMessage(m_hWnd, EM_FINDTEXTEX, dwFlags, (LPARAM)&ft);
#endif
	}
	LONG FormatRange(FORMATRANGE& fr, BOOL bDisplay = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LONG)::SendMessage(m_hWnd, EM_FORMATRANGE, bDisplay, (LPARAM)&fr);
	}
	void HideSelection(BOOL bHide = TRUE, BOOL bChangeStyle = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_HIDESELECTION, bHide, bChangeStyle);
	}
	void PasteSpecial(UINT uClipFormat, DWORD dwAspect = 0, HMETAFILE hMF = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		REPASTESPECIAL reps = { dwAspect, (DWORD_PTR)hMF };
		::SendMessage(m_hWnd, EM_PASTESPECIAL, uClipFormat, (LPARAM)&reps);
	}
	void RequestResize()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_REQUESTRESIZE, 0, 0L);
	}
	LONG StreamIn(UINT uFormat, EDITSTREAM& es)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LONG)::SendMessage(m_hWnd, EM_STREAMIN, uFormat, (LPARAM)&es);
	}
	LONG StreamOut(UINT uFormat, EDITSTREAM& es)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (LONG)::SendMessage(m_hWnd, EM_STREAMOUT, uFormat, (LPARAM)&es);
	}

	DWORD FindWordBreak(int nCode, LONG nStartChar)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, EM_FINDWORDBREAK, nCode, nStartChar);
	}

	// Additional operations
	void ScrollCaret()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0L);
	}
	int InsertText(long nInsertAfterChar, LPCTSTR lpstrText, BOOL bCanUndo = FALSE)
	{
		int nRet = SetSel(nInsertAfterChar, nInsertAfterChar);
		ReplaceSel(lpstrText, bCanUndo);
		return nRet;
	}
	int AppendText(LPCTSTR lpstrText, BOOL bCanUndo = FALSE)
	{
		return InsertText(GetWindowTextLength(), lpstrText, bCanUndo);
	}

	// Clipboard operations
	BOOL Undo()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0L);
	}
	void Clear()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_CLEAR, 0, 0L);
	}
	void Copy()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_COPY, 0, 0L);
	}
	void Cut()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_CUT, 0, 0L);
	}
	void Paste()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, WM_PASTE, 0, 0L);
	}

	// OLE support
	IRichEditOle* GetOleInterface() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		IRichEditOle *pRichEditOle = NULL;
		::SendMessage(m_hWnd, EM_GETOLEINTERFACE, 0, (LPARAM)&pRichEditOle);
		return pRichEditOle;
	}
	BOOL SetOleCallback(IRichEditOleCallback* pCallback)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_SETOLECALLBACK, 0, (LPARAM)pCallback);
	}

#if (_RICHEDIT_VER >= 0x0200)
	BOOL Redo()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, EM_REDO, 0, 0L);
	}
	void StopGroupTyping()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_STOPGROUPTYPING, 0, 0L);
	}
	void ShowScrollBar(int nBarType, BOOL bVisible = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, EM_SHOWSCROLLBAR, nBarType, bVisible);
	}
#endif //(_RICHEDIT_VER >= 0x0200)
};

typedef CRichEditCtrlT<CWindow>		CRichEditCtrl;


/////////////////////////////////////////////////////////////////////////////
// CRichEditCommands - message handlers for standard EDIT commands

// Chain to CRichEditCommands message map. Your class must also derive from CRichEditCtrl.
// Example:
// class CMyRichEdit : public CWindowImpl<CMyRichEdit, CRichEditCtrl>,
//                     public CRichEditCommands<CMyRichEdit>
// {
// public:
//      BEGIN_MSG_MAP(CMyRichEdit)
//              // your handlers...
//              CHAIN_MSG_MAP_ALT(CRichEditCommands<CMyRichEdit>, 1)
//      END_MSG_MAP()
//      // other stuff...
// };

template <class T>
class CRichEditCommands : public CEditCommands< T >
{
public:
	BEGIN_MSG_MAP(CRichEditCommands< T >)
	ALT_MSG_MAP(1)
		COMMAND_ID_HANDLER(ID_EDIT_CLEAR, CEditCommands< T >::OnEditClear)
		COMMAND_ID_HANDLER(ID_EDIT_CLEAR_ALL, CEditCommands< T >::OnEditClearAll)
		COMMAND_ID_HANDLER(ID_EDIT_COPY, CEditCommands< T >::OnEditCopy)
		COMMAND_ID_HANDLER(ID_EDIT_CUT, CEditCommands< T >::OnEditCut)
		COMMAND_ID_HANDLER(ID_EDIT_PASTE, CEditCommands< T >::OnEditPaste)
		COMMAND_ID_HANDLER(ID_EDIT_SELECT_ALL, CEditCommands< T >::OnEditSelectAll)
		COMMAND_ID_HANDLER(ID_EDIT_UNDO, CEditCommands< T >::OnEditUndo)
#if (_RICHEDIT_VER >= 0x0200)
		COMMAND_ID_HANDLER(ID_EDIT_REDO, OnEditRedo)
#endif //(_RICHEDIT_VER >= 0x0200)
	END_MSG_MAP()

#if (_RICHEDIT_VER >= 0x0200)
	LRESULT OnEditRedo(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->Redo();
		return 0;
	}
#endif //(_RICHEDIT_VER >= 0x0200)

// State (update UI) helpers
	BOOL CanCut() const
	{ return HasSelection(); }
	BOOL CanCopy() const
	{ return HasSelection(); }
	BOOL CanClear() const
	{ return HasSelection(); }

// Implementation
	BOOL HasSelection() const
	{
		const T* pT = static_cast<const T*>(this);
		return (pT->GetSelectionType() != SEL_EMPTY);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CDragListBox

template <class TBase>
class CDragListBoxT : public CListBoxT< TBase >
{
public:
// Constructors
	CDragListBoxT(HWND hWnd = NULL) : CListBoxT< TBase >(hWnd) { }

	CDragListBoxT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		HWND hWnd = CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
		if(hWnd != NULL)
			MakeDragList();
		return hWnd;
	}

// Operations
	BOOL MakeDragList()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) == 0);
		return ::MakeDragList(m_hWnd);
	}

	int LBItemFromPt(POINT pt, BOOL bAutoScroll = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::LBItemFromPt(m_hWnd, pt, bAutoScroll);
	}

	void DrawInsert(int nItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::DrawInsert(GetParent(), m_hWnd, nItem);
	}

	static UINT GetDragListMessage()
	{
		static UINT uDragListMessage = 0;
		if(uDragListMessage == 0)
		{
			::EnterCriticalSection(&_Module.m_csStaticDataInit);
			if(uDragListMessage == 0)
				uDragListMessage = ::RegisterWindowMessage(DRAGLISTMSGSTRING);
			::LeaveCriticalSection(&_Module.m_csStaticDataInit);
		}
		ATLASSERT(uDragListMessage != 0);
		return uDragListMessage;
	}
};

typedef CDragListBoxT<CWindow>	CDragListBox;

template <class T>
class CDragListNotifyImpl
{
public:
	BEGIN_MSG_MAP(CDragListNotifyImpl< T >)
		MESSAGE_HANDLER(CDragListBox::GetDragListMessage(), OnDragListNotify)
	END_MSG_MAP()

	LRESULT OnDragListNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		uMsg;	// avoid level 4 warning
		ATLASSERT(uMsg == CDragListBox::GetDragListMessage());
		T* pT = static_cast<T*>(this);
		LPDRAGLISTINFO lpDragListInfo = (LPDRAGLISTINFO)lParam;
		LRESULT lRet = 0;
		switch(lpDragListInfo->uNotification)
		{
		case DL_BEGINDRAG:
			lRet = (LPARAM)pT->OnBeginDrag((int)wParam, lpDragListInfo->hWnd, lpDragListInfo->ptCursor);
			break;
		case DL_CANCELDRAG:
			pT->OnCancelDrag((int)wParam, lpDragListInfo->hWnd, lpDragListInfo->ptCursor);
			break;
		case DL_DRAGGING:
			lRet = (LPARAM)pT->OnDragging((int)wParam, lpDragListInfo->hWnd, lpDragListInfo->ptCursor);
			break;
		case DL_DROPPED:
			pT->OnDropped((int)wParam, lpDragListInfo->hWnd, lpDragListInfo->ptCursor);
			break;
		default:
			ATLTRACE2(atlTraceUI, 0, _T("Unknown DragListBox notification\n"));
			bHandled = FALSE;	// don't handle it
			break;
		}
		return lRet;
	}

// Overrideables
	BOOL OnBeginDrag(int /*nCtlID*/, HWND /*hWndDragList*/, POINT /*ptCursor*/)
	{
		return TRUE;	// allow dragging
	}
	void OnCancelDrag(int /*nCtlID*/, HWND /*hWndDragList*/, POINT /*ptCursor*/)
	{
		// nothing to do
	}
	int OnDragging(int /*nCtlID*/, HWND /*hWndDragList*/, POINT /*ptCursor*/)
	{
		return 0;	// don't change cursor
	}
	void OnDropped(int /*nCtlID*/, HWND /*hWndDragList*/, POINT /*ptCursor*/)
	{
		// nothing to do
	}
};


/////////////////////////////////////////////////////////////////////////////
// CReBarCtrl

template <class TBase>
class CReBarCtrlT : public TBase
{
public:
// Constructors
	CReBarCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CReBarCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return REBARCLASSNAME;
	}

	UINT GetBandCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, RB_GETBANDCOUNT, 0, 0L);
	}
	BOOL GetBandInfo(int nBand, LPREBARBANDINFO lprbbi) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_GETBANDINFO, nBand, (LPARAM)lprbbi);
	}
	BOOL SetBandInfo(int nBand, LPREBARBANDINFO lprbbi)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_SETBANDINFO, nBand, (LPARAM)lprbbi);
	}
	BOOL GetBarInfo(LPREBARINFO lprbi) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_GETBARINFO, 0, (LPARAM)lprbi);
	}
	BOOL SetBarInfo(LPREBARINFO lprbi)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_SETBARINFO, 0, (LPARAM)lprbi);
	}
	UINT GetRowCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, RB_GETROWCOUNT, 0, 0L);
	}
	UINT GetRowHeight(int nBand) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, RB_GETROWHEIGHT, nBand, 0L);
	}

#if (_WIN32_IE >= 0x0400)
	COLORREF GetTextColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, RB_GETTEXTCOLOR, 0, 0L);
	}
	COLORREF SetTextColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, RB_SETTEXTCOLOR, 0, (LPARAM)clr);
	}
	COLORREF GetBkColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, RB_GETBKCOLOR, 0, 0L);
	}
	COLORREF SetBkColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, RB_SETBKCOLOR, 0, (LPARAM)clr);
	}
	UINT GetBarHeight() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (UINT)::SendMessage(m_hWnd, RB_GETBARHEIGHT, 0, 0L);
	}
	BOOL GetRect(int nBand, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_GETRECT, nBand, (LPARAM)lpRect);
	}
	CToolTipCtrl GetToolTips() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, RB_GETTOOLTIPS, 0, 0L));
	}
	void SetToolTips(HWND hwndToolTip)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_SETTOOLTIPS, (WPARAM)hwndToolTip, 0L);
	}
	void GetBandBorders(int nBand, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(lpRect != NULL);
		::SendMessage(m_hWnd, RB_GETBANDBORDERS, nBand, (LPARAM)lpRect);
	}
	BOOL GetColorScheme(LPCOLORSCHEME lpColorScheme) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(lpColorScheme != NULL);
		return (BOOL)::SendMessage(m_hWnd, RB_GETCOLORSCHEME, 0, (LPARAM)lpColorScheme);
	}
	void SetColorScheme(LPCOLORSCHEME lpColorScheme)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(lpColorScheme != NULL);
		::SendMessage(m_hWnd, RB_SETCOLORSCHEME, 0, (LPARAM)lpColorScheme);
	}
	HPALETTE GetPalette() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HPALETTE)::SendMessage(m_hWnd, RB_GETPALETTE, 0, 0L);
	}
	HPALETTE SetPalette(HPALETTE hPalette)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HPALETTE)::SendMessage(m_hWnd, RB_SETPALETTE, 0, (LPARAM)hPalette);
	}
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

// Operations
	BOOL InsertBand(int nBand, LPREBARBANDINFO lprbbi)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		lprbbi->cbSize = sizeof(REBARBANDINFO);
		return (BOOL)::SendMessage(m_hWnd, RB_INSERTBAND, nBand, (LPARAM)lprbbi);
	}
	BOOL DeleteBand(int nBand)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_DELETEBAND, nBand, 0L);
	}
	CWindow SetNotifyWnd(HWND hWnd)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow((HWND)::SendMessage(m_hWnd, RB_SETPARENT, (WPARAM)hWnd, 0L));
	}

#if (_WIN32_IE >= 0x0400)
	void BeginDrag(int nBand, DWORD dwPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_BEGINDRAG, nBand, dwPos);
	}
	void BeginDrag(int nBand, int xPos, int yPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_BEGINDRAG, nBand, MAKELPARAM(xPos, yPos));
	}
	void EndDrag()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_ENDDRAG, 0, 0L);
	}
	void DragMove(DWORD dwPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_DRAGMOVE, 0, dwPos);
	}
	void DragMove(int xPos, int yPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_DRAGMOVE, 0, MAKELPARAM(xPos, yPos));
	}
	void GetDropTarget(IDropTarget** ppDropTarget) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_GETDROPTARGET, 0, (LPARAM)ppDropTarget);
	}
	void MaximizeBand(int nBand)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_MAXIMIZEBAND, nBand, 0L);
	}
	void MinimizeBand(int nBand)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_MINIMIZEBAND, nBand, 0L);
	}
	BOOL SizeToRect(LPRECT lpRect)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_SIZETORECT, 0, (LPARAM)lpRect);
	}
	int IdToIndex(UINT uBandID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, RB_IDTOINDEX, uBandID, 0L);
	}
	int HitTest(LPRBHITTESTINFO lprbht) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, RB_HITTEST, 0, (LPARAM)lprbht);
	}
	BOOL ShowBand(int nBand, BOOL bShow)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, RB_SHOWBAND, nBand, bShow);
	}
	BOOL MoveBand(int nBand, int nNewPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nNewPos >= 0 && nNewPos <= ((int)GetBandCount() - 1));
		return (BOOL)::SendMessage(m_hWnd, RB_MOVEBAND, nBand, nNewPos);
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	void PushChevron(int nBand, LPARAM lAppValue)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, RB_PUSHCHEVRON, nBand, lAppValue);
	}
#endif //(_WIN32_IE >= 0x0500)
};

typedef CReBarCtrlT<CWindow>		CReBarCtrl;


/////////////////////////////////////////////////////////////////////////////
// CComboBoxEx

template <class TBase>
class CComboBoxExT : public CComboBoxT< TBase >
{
public:
// Constructors
	CComboBoxExT(HWND hWnd = NULL) : CComboBoxT< TBase >(hWnd) { }

	CComboBoxExT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return WC_COMBOBOXEX;
	}

	CImageList GetImageList() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, CBEM_GETIMAGELIST, 0, 0L));
	}
	CImageList SetImageList(HIMAGELIST hImageList)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, CBEM_SETIMAGELIST, 0, (LPARAM)hImageList));
	}

#if (_WIN32_IE >= 0x0400)
	DWORD GetExtendedStyle() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, CBEM_GETEXTENDEDSTYLE, 0, 0L);
	}
	DWORD SetExtendedStyle(DWORD dwExMask, DWORD dwExStyle)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, CBEM_SETEXTENDEDSTYLE, dwExMask, dwExStyle);
	}
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CBEM_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CBEM_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

// Operations
	int InsertItem(const COMBOBOXEXITEM FAR* lpcCBItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CBEM_INSERTITEM, 0, (LPARAM)lpcCBItem);
	}
	int DeleteItem(int nIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, CBEM_DELETEITEM, nIndex, 0L);
	}
	BOOL GetItem(PCOMBOBOXEXITEM pCBItem) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CBEM_GETITEM, 0, (LPARAM)pCBItem);
	}
	BOOL SetItem(const COMBOBOXEXITEM FAR* lpcCBItem)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CBEM_SETITEM, 0, (LPARAM)lpcCBItem);
	}
	CComboBox GetComboCtrl() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CComboBox((HWND)::SendMessage(m_hWnd, CBEM_GETCOMBOCONTROL, 0, 0L));
	}
	CEdit GetEditCtrl() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CEdit((HWND)::SendMessage(m_hWnd, CBEM_GETEDITCONTROL, 0, 0L));
	}
	BOOL HasEditChanged() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, CBEM_HASEDITCHANGED, 0, 0L);
	}
};

typedef CComboBoxExT<CWindow>		CComboBoxEx;


/////////////////////////////////////////////////////////////////////////////
// CMonthCalendarCtrl

template <class TBase>
class CMonthCalendarCtrlT : public TBase
{
public:
// Constructors
	CMonthCalendarCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CMonthCalendarCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return MONTHCAL_CLASS;
	}

	COLORREF GetColor(int nColorType) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, MCM_GETCOLOR, nColorType, 0L);
	}
	COLORREF SetColor(int nColorType, COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, MCM_SETCOLOR, nColorType, clr);
	}
	BOOL GetCurSel(LPSYSTEMTIME lpSysTime) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_GETCURSEL, 0, (LPARAM)lpSysTime);
	}
	BOOL SetCurSel(LPSYSTEMTIME lpSysTime)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_SETCURSEL, 0, (LPARAM)lpSysTime);
	}
	int GetFirstDayOfWeek(BOOL* pbLocaleVal = NULL) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, MCM_GETFIRSTDAYOFWEEK, 0, 0L);
		if(pbLocaleVal != NULL)
			*pbLocaleVal = (BOOL)HIWORD(dwRet);
		return (int)(short)LOWORD(dwRet);
	}
	int SetFirstDayOfWeek(int nDay, BOOL* pbLocaleVal = NULL)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, MCM_SETFIRSTDAYOFWEEK, 0, nDay);
		if(pbLocaleVal != NULL)
			*pbLocaleVal = (BOOL)HIWORD(dwRet);
		return (int)(short)LOWORD(dwRet);
	}
	int GetMaxSelCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, MCM_GETMAXSELCOUNT, 0, 0L);
	}
	BOOL SetMaxSelCount(int nMax)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_SETMAXSELCOUNT, nMax, 0L);
	}
	int GetMonthDelta() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, MCM_GETMONTHDELTA, 0, 0L);
	}
	int SetMonthDelta(int nDelta)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, MCM_SETMONTHDELTA, nDelta, 0L);
	}
	DWORD GetRange(LPSYSTEMTIME lprgSysTimeArray) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, MCM_GETRANGE, 0, (LPARAM)lprgSysTimeArray);
	}
	BOOL SetRange(DWORD dwFlags, LPSYSTEMTIME lprgSysTimeArray)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_SETRANGE, dwFlags, (LPARAM)lprgSysTimeArray);
	}
	BOOL GetSelRange(LPSYSTEMTIME lprgSysTimeArray) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_GETSELRANGE, 0, (LPARAM)lprgSysTimeArray);
	}
	BOOL SetSelRange(LPSYSTEMTIME lprgSysTimeArray)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_SETSELRANGE, 0, (LPARAM)lprgSysTimeArray);
	}
	BOOL GetToday(LPSYSTEMTIME lpSysTime) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_GETTODAY, 0, (LPARAM)lpSysTime);
	}
	void SetToday(LPSYSTEMTIME lpSysTime)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, MCM_SETTODAY, 0, (LPARAM)lpSysTime);
	}
	BOOL GetMinReqRect(LPRECT lpRectInfo) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_GETMINREQRECT, 0, (LPARAM)lpRectInfo);
	}
	int GetMonthRange() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, MCM_GETMAXTODAYWIDTH, 0, 0L);
	}

#if (_WIN32_IE >= 0x0400)
	BOOL GetUnicodeFormat() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_GETUNICODEFORMAT, 0, 0L);
	}
	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_SETUNICODEFORMAT, bUnicode, 0L);
	}
#endif //(_WIN32_IE >= 0x0400)

// Operations
	int GetMonthRange(DWORD dwFlags, LPSYSTEMTIME lprgSysTimeArray) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, MCM_GETMONTHRANGE, dwFlags, (LPARAM)lprgSysTimeArray);
	}
	BOOL SetDayState(int nMonths, LPMONTHDAYSTATE lpDayStateArray)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, MCM_SETDAYSTATE, nMonths, (LPARAM)lpDayStateArray);
	}
	DWORD HitTest(PMCHITTESTINFO pMCHitTest) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, MCM_HITTEST, 0, (LPARAM)pMCHitTest);
	}
};

typedef CMonthCalendarCtrlT<CWindow>		CMonthCalendarCtrl;


/////////////////////////////////////////////////////////////////////////////
// CDateTimePickerCtrl

template <class TBase>
class CDateTimePickerCtrlT : public TBase
{
public:
// Constructors
	CDateTimePickerCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CDateTimePickerCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Operations
	static LPCTSTR GetWndClassName()
	{
		return DATETIMEPICK_CLASS;
	}

	BOOL SetFormat(LPTSTR lpszFormat)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, DTM_SETFORMAT, 0, (LPARAM)lpszFormat);
	}
	COLORREF GetMonthCalColor(int nColorType) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, DTM_GETMCCOLOR, nColorType, 0L);
	}
	COLORREF SetMonthCalColor(int nColorType, COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, DTM_SETMCCOLOR, nColorType, clr);
	}
	DWORD GetRange(LPSYSTEMTIME lpSysTimeArray) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, DTM_GETRANGE, 0, (LPARAM)lpSysTimeArray);
	}
	BOOL SetRange(DWORD dwFlags, LPSYSTEMTIME lpSysTimeArray)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, DTM_SETRANGE, dwFlags, (LPARAM)lpSysTimeArray);
	}
	DWORD GetSystemTime(LPSYSTEMTIME lpSysTime) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (DWORD)::SendMessage(m_hWnd, DTM_GETSYSTEMTIME, 0, (LPARAM)lpSysTime);
	}
	BOOL SetSystemTime(DWORD dwFlags, LPSYSTEMTIME lpSysTime)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, DTM_SETSYSTEMTIME, dwFlags, (LPARAM)lpSysTime);
	}
	CMonthCalendarCtrl GetMonthCal() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CMonthCalendarCtrl((HWND)::SendMessage(m_hWnd, DTM_GETMONTHCAL, 0, 0L));
	}

#if (_WIN32_IE >= 0x0400)
	CFontHandle GetMonthCalFont() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CFontHandle((HFONT)::SendMessage(m_hWnd, DTM_GETMCFONT, 0, 0L));
	}
	void SetMonthCalFont(HFONT hFont, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, DTM_SETMCFONT, (WPARAM)hFont, MAKELPARAM(bRedraw, 0));
	}
#endif //(_WIN32_IE >= 0x0400)
};

typedef CDateTimePickerCtrlT<CWindow>		CDateTimePickerCtrl;


/////////////////////////////////////////////////////////////////////////////
// CFlatScrollBarImpl - support for flat scroll bars

#if (_WIN32_IE >= 0x0400)

template <class T>
class CFlatScrollBarImpl
{
public:
// Initialization
	BOOL FlatSB_Initialize()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::InitializeFlatSB(pT->m_hWnd);
	}
	HRESULT FlatSB_Uninitialize()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::UninitializeFlatSB(pT->m_hWnd);
	}

// Flat scroll bar properties
	BOOL FlatSB_GetScrollProp(UINT uIndex, LPINT lpnValue) const
	{
		const T* pT = static_cast<const T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_GetScrollProp(pT->m_hWnd, uIndex, lpnValue);
	}
	BOOL FlatSB_SetScrollProp(UINT uIndex, int nValue, BOOL bRedraw = TRUE)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_SetScrollProp(pT->m_hWnd, uIndex, nValue, bRedraw);
	}

// Attributes
	int FlatSB_GetScrollPos(int nBar) const
	{
		const T* pT = static_cast<const T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_GetScrollPos(pT->m_hWnd, nBar);
	}

	int FlatSB_SetScrollPos(int nBar, int nPos, BOOL bRedraw = TRUE)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_SetScrollPos(pT->m_hWnd, nBar, nPos, bRedraw);
	}

	BOOL FlatSB_GetScrollRange(int nBar, LPINT lpMinPos, LPINT lpMaxPos) const
	{
		const T* pT = static_cast<const T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_GetScrollRange(pT->m_hWnd, nBar, lpMinPos, lpMaxPos);
	}

	BOOL FlatSB_SetScrollRange(int nBar, int nMinPos, int nMaxPos, BOOL bRedraw = TRUE)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_SetScrollRange(pT->m_hWnd, nBar, nMinPos, nMaxPos, bRedraw);
	}

	BOOL FlatSB_GetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo) const
	{
		const T* pT = static_cast<const T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_GetScrollInfo(pT->m_hWnd, nBar, lpScrollInfo);
	}

	int FlatSB_SetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_SetScrollInfo(pT->m_hWnd, nBar, lpScrollInfo, bRedraw);
	}

// Operations
	BOOL FlatSB_ShowScrollBar(UINT nBar, BOOL bShow = TRUE)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_ShowScrollBar(pT->m_hWnd, nBar, bShow);
	}

	BOOL FlatSB_EnableScrollBar(UINT uSBFlags, UINT uArrowFlags = ESB_ENABLE_BOTH)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		return ::FlatSB_EnableScrollBar(pT->m_hWnd, uSBFlags, uArrowFlags);
	}
};

template <class TBase>
class CFlatScrollBarT : public TBase, public CFlatScrollBarImpl<CFlatScrollBarT< TBase > >
{
public:
	CFlatScrollBarT(HWND hWnd = NULL) : TBase(hWnd) { }

	CFlatScrollBarT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}
};

typedef CFlatScrollBarT<CWindow>		CFlatScrollBar;

#endif //(_WIN32_IE >= 0x0400)


/////////////////////////////////////////////////////////////////////////////
// CIPAddressCtrl

#if (_WIN32_IE >= 0x0400)

template <class TBase>
class CIPAddressCtrlT : public TBase
{
public:
// Constructors
	CIPAddressCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CIPAddressCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Atteributes
	static LPCTSTR GetWndClassName()
	{
		return WC_IPADDRESS;
	}

	BOOL IsBlank() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, IPM_ISBLANK, 0, 0L);
	}
	int GetAddress(LPDWORD lpdwAddress) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, IPM_GETADDRESS, 0, (LPARAM)lpdwAddress);
	}
	void SetAddress(DWORD dwAddress)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, IPM_SETADDRESS, 0, dwAddress);
	}
	void ClearAddress()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, IPM_CLEARADDRESS, 0, 0L);
	}
	void SetRange(int nField, WORD wRange)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, IPM_SETRANGE, nField, wRange);
	}
	void SetRange(int nField, BYTE nMin, BYTE nMax)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, IPM_SETRANGE, nField, MAKEIPRANGE(nMin, nMax));
	}
	void SetFocus(int nField)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, IPM_SETFOCUS, nField, 0L);
	}
};

typedef CIPAddressCtrlT<CWindow>		CIPAddressCtrl;

#endif //(_WIN32_IE >= 0x0400)


/////////////////////////////////////////////////////////////////////////////
// CPagerCtrl

#if (_WIN32_IE >= 0x0400)

template <class TBase>
class CPagerCtrlT : public TBase
{
public:
// Constructors
	CPagerCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }

	CPagerCtrlT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
	{
		return CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
	}

// Attributes
	static LPCTSTR GetWndClassName()
	{
		return WC_PAGESCROLLER;
	}

	int GetButtonSize() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PGM_GETBUTTONSIZE, 0, 0L);
	}
	int SetButtonSize(int nButtonSize)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PGM_SETBUTTONSIZE, 0, nButtonSize);
	}
	DWORD GetButtonState(int nButton) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nButton == PGB_TOPORLEFT || nButton == PGB_BOTTOMORRIGHT);
		return (DWORD)::SendMessage(m_hWnd, PGM_GETBUTTONSTATE, 0, nButton);
	}
	COLORREF GetBkColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, PGM_GETBKCOLOR, 0, 0L);
	}
	COLORREF SetBkColor(COLORREF clrBk)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (COLORREF)::SendMessage(m_hWnd, PGM_SETBKCOLOR, 0, (LPARAM)clrBk);
	}
	int GetBorder() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PGM_GETBORDER, 0, 0L);
	}
	int SetBorder(int nBorderSize)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PGM_SETBORDER, 0, nBorderSize);
	}
	int GetPos() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PGM_GETPOS, 0, 0L);
	}
	int SetPos(int nPos)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PGM_SETPOS, 0, nPos);
	}

// Operations
	void SetChild(HWND hWndChild)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PGM_SETCHILD, 0, (LPARAM)hWndChild);
	}
	void ForwardMouse(BOOL bForward = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PGM_FORWARDMOUSE, bForward, 0L);
	}
	void RecalcSize()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PGM_RECALCSIZE, 0, 0L);
	}
	void GetDropTarget(IDropTarget** ppDropTarget)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(ppDropTarget != NULL);
		::SendMessage(m_hWnd, PGM_GETDROPTARGET, 0, (LPARAM)ppDropTarget);
	}
};

typedef CPagerCtrlT<CWindow>		CPagerCtrl;

#endif //(_WIN32_IE >= 0x0400)


/////////////////////////////////////////////////////////////////////////////
// CCustomDraw - MI class for custom-draw support

template <class T>
class CCustomDraw
{
public:
#if !defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)
	BOOL m_bHandledCD;

	BOOL IsMsgHandled() const
	{
		return m_bHandledCD;
	}
	void SetMsgHandled(BOOL bHandled)
	{
		m_bHandledCD = bHandled;
	}
#endif //!defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)

// Message map and handlers
	BEGIN_MSG_MAP(CCustomDraw< T >)
		NOTIFY_CODE_HANDLER(NM_CUSTOMDRAW, OnCustomDraw)
	ALT_MSG_MAP(1)
		REFLECTED_NOTIFY_CODE_HANDLER(NM_CUSTOMDRAW, OnCustomDraw)
	END_MSG_MAP()

// message handler
	LRESULT OnCustomDraw(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		pT->SetMsgHandled(TRUE);
		LPNMCUSTOMDRAW lpNMCustomDraw = (LPNMCUSTOMDRAW)pnmh;
		DWORD dwRet = 0;
		switch(lpNMCustomDraw->dwDrawStage)
		{
		case CDDS_PREPAINT:
			dwRet = pT->OnPrePaint(idCtrl, lpNMCustomDraw);
			break;
		case CDDS_POSTPAINT:
			dwRet = pT->OnPostPaint(idCtrl, lpNMCustomDraw);
			break;
		case CDDS_PREERASE:
			dwRet = pT->OnPreErase(idCtrl, lpNMCustomDraw);
			break;
		case CDDS_POSTERASE:
			dwRet = pT->OnPostErase(idCtrl, lpNMCustomDraw);
			break;
		case CDDS_ITEMPREPAINT:
			dwRet = pT->OnItemPrePaint(idCtrl, lpNMCustomDraw);
			break;
		case CDDS_ITEMPOSTPAINT:
			dwRet = pT->OnItemPostPaint(idCtrl, lpNMCustomDraw);
			break;
		case CDDS_ITEMPREERASE:
			dwRet = pT->OnItemPreErase(idCtrl, lpNMCustomDraw);
			break;
		case CDDS_ITEMPOSTERASE:
			dwRet = pT->OnItemPostErase(idCtrl, lpNMCustomDraw);
			break;
		default:
			pT->SetMsgHandled(FALSE);
			break;
		}
		bHandled = pT->IsMsgHandled();
		return dwRet;
	}

// Overrideables
	DWORD OnPrePaint(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
	{
		return CDRF_DODEFAULT;
	}
	DWORD OnPostPaint(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
	{
		return CDRF_DODEFAULT;
	}
	DWORD OnPreErase(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
	{
		return CDRF_DODEFAULT;
	}
	DWORD OnPostErase(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
	{
		return CDRF_DODEFAULT;
	}
	DWORD OnItemPrePaint(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
	{
		return CDRF_DODEFAULT;
	}
	DWORD OnItemPostPaint(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
	{
		return CDRF_DODEFAULT;
	}
	DWORD OnItemPreErase(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
	{
		return CDRF_DODEFAULT;
	}
	DWORD OnItemPostErase(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
	{
		return CDRF_DODEFAULT;
	}
};

}; //namespace WTL

#endif // __ATLCTRLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wtl10\atlcrack.h ===
// WTL Version 3.1
// Copyright (C) 1997-2000 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLCRACK_H__
#define __ATLCRACK_H__

#pragma once


// For ATL 3.0, message map using cracked handlers MUST use BEGIN_MSG_MAP_EX
#if !defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)

#define BEGIN_MSG_MAP_EX(theClass) \
public: \
	BOOL m_bATL3MsgHandled; \
	/* "handled" management for cracked handlers */ \
	BOOL IsMsgHandled() const \
	{ \
		return m_bATL3MsgHandled; \
	} \
	void SetMsgHandled(BOOL bHandled) \
	{ \
		m_bATL3MsgHandled = bHandled; \
	} \
	BOOL ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID = 0) \
	{ \
		BOOL bATL3OldMsgHandled = m_bATL3MsgHandled; \
		BOOL bRet = _ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, dwMsgMapID); \
		m_bATL3MsgHandled = bATL3OldMsgHandled; \
		return bRet; \
	} \
	BOOL _ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID) \
	{ \
		BOOL bHandled = TRUE; \
		hWnd; \
		uMsg; \
		wParam; \
		lParam; \
		lResult; \
		bHandled; \
		switch(dwMsgMapID) \
		{ \
		case 0:

#endif //!defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)


///////////////////////////////////////////////////////////////////////////////
// Standard Windows message macros

#define MSG_WM_CREATE(func) \
	if (uMsg == WM_CREATE) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((LPCREATESTRUCT)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_INITDIALOG(func) \
	if (uMsg == WM_INITDIALOG) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HWND)wParam, lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_COPYDATA(func) \
	if (uMsg == WM_COPYDATA) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HWND)wParam, (PCOPYDATASTRUCT)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DESTROY(func) \
	if (uMsg == WM_DESTROY) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MOVE(func) \
	if (uMsg == WM_MOVE) \
	{ \
		SetMsgHandled(TRUE); \
		func(CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SIZE(func) \
	if (uMsg == WM_SIZE) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CSize(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ACTIVATE(func) \
	if (uMsg == WM_ACTIVATE) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)LOWORD(wParam), (BOOL)HIWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SETFOCUS(func) \
	if (uMsg == WM_SETFOCUS) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_KILLFOCUS(func) \
	if (uMsg == WM_KILLFOCUS) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ENABLE(func) \
	if (uMsg == WM_ENABLE) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_PAINT(func) \
	if (uMsg == WM_PAINT) \
	{ \
		SetMsgHandled(TRUE); \
		func((HDC)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CLOSE(func) \
	if (uMsg == WM_CLOSE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_QUERYENDSESSION(func) \
	if (uMsg == WM_QUERYENDSESSION) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)wParam, (UINT)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_QUERYOPEN(func) \
	if (uMsg == WM_QUERYOPEN) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func(); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ERASEBKGND(func) \
	if (uMsg == WM_ERASEBKGND) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SYSCOLORCHANGE(func) \
	if (uMsg == WM_SYSCOLORCHANGE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ENDSESSION(func) \
	if (uMsg == WM_ENDSESSION) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)wParam, (UINT)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SHOWWINDOW(func) \
	if (uMsg == WM_SHOWWINDOW) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)wParam, (int)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CTLCOLOREDIT(func) \
	if (uMsg == WM_CTLCOLOREDIT) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CTLCOLORLISTBOX(func) \
	if (uMsg == WM_CTLCOLORLISTBOX) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CTLCOLORBTN(func) \
	if (uMsg == WM_CTLCOLORBTN) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CTLCOLORDLG(func) \
	if (uMsg == WM_CTLCOLORDLG) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CTLCOLORSCROLLBAR(func) \
	if (uMsg == WM_CTLCOLORSCROLLBAR) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CTLCOLORSTATIC(func) \
	if (uMsg == WM_CTLCOLORSTATIC) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SETTINGCHANGE(func) \
	if (uMsg == WM_SETTINGCHANGE) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPCTSTR)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DEVMODECHANGE(func) \
	if (uMsg == WM_DEVMODECHANGE) \
	{ \
		SetMsgHandled(TRUE); \
		func((LPCTSTR)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ACTIVATEAPP(func) \
	if (uMsg == WM_ACTIVATEAPP) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)wParam, (DWORD)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_FONTCHANGE(func) \
	if (uMsg == WM_FONTCHANGE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_TIMECHANGE(func) \
	if (uMsg == WM_TIMECHANGE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CANCELMODE(func) \
	if (uMsg == WM_CANCELMODE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SETCURSOR(func) \
	if (uMsg == WM_SETCURSOR) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HWND)wParam, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MOUSEACTIVATE(func) \
	if (uMsg == WM_MOUSEACTIVATE) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HWND)wParam, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CHILDACTIVATE(func) \
	if (uMsg == WM_CHILDACTIVATE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_GETMINMAXINFO(func) \
	if (uMsg == WM_GETMINMAXINFO) \
	{ \
		SetMsgHandled(TRUE); \
		func((LPMINMAXINFO)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ICONERASEBKGND(func) \
	if (uMsg == WM_ICONERASEBKGND) \
	{ \
		SetMsgHandled(TRUE); \
		func((HDC)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SPOOLERSTATUS(func) \
	if (uMsg == WM_SPOOLERSTATUS) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (UINT)LOWORD(lParam)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DRAWITEM(func) \
	if (uMsg == WM_DRAWITEM) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPDRAWITEMSTRUCT)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MEASUREITEM(func) \
	if (uMsg == WM_MEASUREITEM) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPMEASUREITEMSTRUCT)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DELETEITEM(func) \
	if (uMsg == WM_DELETEITEM) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPDELETEITEMSTRUCT)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CHARTOITEM(func) \
	if (uMsg == WM_CHARTOITEM) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_VKEYTOITEM(func) \
	if (uMsg == WM_VKEYTOITEM) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_QUERYDRAGICON(func) \
	if (uMsg == WM_QUERYDRAGICON) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func(); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_COMPAREITEM(func) \
	if (uMsg == WM_COMPAREITEM) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)wParam, (LPCOMPAREITEMSTRUCT)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_COMPACTING(func) \
	if (uMsg == WM_COMPACTING) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCCREATE(func) \
	if (uMsg == WM_NCCREATE) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((LPCREATESTRUCT)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCDESTROY(func) \
	if (uMsg == WM_NCDESTROY) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCCALCSIZE(func) \
	if (uMsg == WM_NCCALCSIZE) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((BOOL)wParam, lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCHITTEST(func) \
	if (uMsg == WM_NCHITTEST) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func(CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCPAINT(func) \
	if (uMsg == WM_NCPAINT) \
	{ \
		SetMsgHandled(TRUE); \
		func((HRGN)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCACTIVATE(func) \
	if (uMsg == WM_NCACTIVATE) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((BOOL)wParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_GETDLGCODE(func) \
	if (uMsg == WM_GETDLGCODE) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((LPMSG)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCMOUSEMOVE(func) \
	if (uMsg == WM_NCMOUSEMOVE) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCLBUTTONDOWN(func) \
	if (uMsg == WM_NCLBUTTONDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCLBUTTONUP(func) \
	if (uMsg == WM_NCLBUTTONUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCLBUTTONDBLCLK(func) \
	if (uMsg == WM_NCLBUTTONDBLCLK) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCRBUTTONDOWN(func) \
	if (uMsg == WM_NCRBUTTONDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCRBUTTONUP(func) \
	if (uMsg == WM_NCRBUTTONUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCRBUTTONDBLCLK(func) \
	if (uMsg == WM_NCRBUTTONDBLCLK) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCMBUTTONDOWN(func) \
	if (uMsg == WM_NCMBUTTONDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCMBUTTONUP(func) \
	if (uMsg == WM_NCMBUTTONUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NCMBUTTONDBLCLK(func) \
	if (uMsg == WM_NCMBUTTONDBLCLK) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_KEYDOWN(func) \
	if (uMsg == WM_KEYDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_KEYUP(func) \
	if (uMsg == WM_KEYUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CHAR(func) \
	if (uMsg == WM_CHAR) \
	{ \
		SetMsgHandled(TRUE); \
		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DEADCHAR(func) \
	if (uMsg == WM_DEADCHAR) \
	{ \
		SetMsgHandled(TRUE); \
		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SYSKEYDOWN(func) \
	if (uMsg == WM_SYSKEYDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SYSKEYUP(func) \
	if (uMsg == WM_SYSKEYUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SYSCHAR(func) \
	if (uMsg == WM_SYSCHAR) \
	{ \
		SetMsgHandled(TRUE); \
		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SYSDEADCHAR(func) \
	if (uMsg == WM_SYSDEADCHAR) \
	{ \
		SetMsgHandled(TRUE); \
		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SYSCOMMAND(func) \
	if (uMsg == WM_SYSCOMMAND) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_TCARD(func) \
	if (uMsg == WM_TCARD) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (DWORD)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_TIMER(func) \
	if (uMsg == WM_TIMER) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (TIMERPROC*)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_HSCROLL(func) \
	if (uMsg == WM_HSCROLL) \
	{ \
		SetMsgHandled(TRUE); \
		func((int)LOWORD(wParam), (short)HIWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_VSCROLL(func) \
	if (uMsg == WM_VSCROLL) \
	{ \
		SetMsgHandled(TRUE); \
		func((int)LOWORD(wParam), (short)HIWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_INITMENU(func) \
	if (uMsg == WM_INITMENU) \
	{ \
		SetMsgHandled(TRUE); \
		func((HMENU)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_INITMENUPOPUP(func) \
	if (uMsg == WM_INITMENUPOPUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((HMENU)wParam, (UINT)LOWORD(lParam), (BOOL)HIWORD(lParam)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MENUSELECT(func) \
	if (uMsg == WM_MENUSELECT) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), (HMENU)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MENUCHAR(func) \
	if (uMsg == WM_MENUCHAR) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((TCHAR)LOWORD(wParam), (UINT)HIWORD(wParam), (HMENU)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NOTIFY(func) \
	if (uMsg == WM_NOTIFY) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((int)wParam, (LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ENTERIDLE(func) \
	if (uMsg == WM_ENTERIDLE) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MOUSEMOVE(func) \
	if (uMsg == WM_MOUSEMOVE) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MOUSEWHEEL(func) \
	if (uMsg == WM_MOUSEWHEEL) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)LOWORD(wParam), (short)HIWORD(wParam), CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_LBUTTONDOWN(func) \
	if (uMsg == WM_LBUTTONDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_LBUTTONUP(func) \
	if (uMsg == WM_LBUTTONUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_LBUTTONDBLCLK(func) \
	if (uMsg == WM_LBUTTONDBLCLK) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_RBUTTONDOWN(func) \
	if (uMsg == WM_RBUTTONDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_RBUTTONUP(func) \
	if (uMsg == WM_RBUTTONUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_RBUTTONDBLCLK(func) \
	if (uMsg == WM_RBUTTONDBLCLK) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MBUTTONDOWN(func) \
	if (uMsg == WM_MBUTTONDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MBUTTONUP(func) \
	if (uMsg == WM_MBUTTONUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MBUTTONDBLCLK(func) \
	if (uMsg == WM_MBUTTONDBLCLK) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_PARENTNOTIFY(func) \
	if (uMsg == WM_PARENTNOTIFY) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MDIACTIVATE(func) \
	if (uMsg == WM_MDIACTIVATE) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam, (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_RENDERFORMAT(func) \
	if (uMsg == WM_RENDERFORMAT) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_RENDERALLFORMATS(func) \
	if (uMsg == WM_RENDERALLFORMATS) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DESTROYCLIPBOARD(func) \
	if (uMsg == WM_DESTROYCLIPBOARD) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DRAWCLIPBOARD(func) \
	if (uMsg == WM_DRAWCLIPBOARD) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_PAINTCLIPBOARD(func) \
	if (uMsg == WM_PAINTCLIPBOARD) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam, (const LPPAINTSTRUCT)::GlobalLock((HGLOBAL)lParam)); \
		::GlobalUnlock((HGLOBAL)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_VSCROLLCLIPBOARD(func) \
	if (uMsg == WM_VSCROLLCLIPBOARD) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CONTEXTMENU(func) \
	if (uMsg == WM_CONTEXTMENU) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SIZECLIPBOARD(func) \
	if (uMsg == WM_SIZECLIPBOARD) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam, (const LPRECT)::GlobalLock((HGLOBAL)lParam)); \
		::GlobalUnlock((HGLOBAL)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ASKCBFORMATNAME(func) \
	if (uMsg == WM_ASKCBFORMATNAME) \
	{ \
		SetMsgHandled(TRUE); \
		func((DWORD)wParam, (LPTSTR)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CHANGECBCHAIN(func) \
	if (uMsg == WM_CHANGECBCHAIN) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam, (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_HSCROLLCLIPBOARD(func) \
	if (uMsg == WM_HSCROLLCLIPBOARD) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_QUERYNEWPALETTE(func) \
	if (uMsg == WM_QUERYNEWPALETTE) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func(); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_PALETTECHANGED(func) \
	if (uMsg == WM_PALETTECHANGED) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_PALETTEISCHANGING(func) \
	if (uMsg == WM_PALETTEISCHANGING) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DROPFILES(func) \
	if (uMsg == WM_DROPFILES) \
	{ \
		SetMsgHandled(TRUE); \
		func((HDROP)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_WINDOWPOSCHANGING(func) \
	if (uMsg == WM_WINDOWPOSCHANGING) \
	{ \
		SetMsgHandled(TRUE); \
		func((LPWINDOWPOS)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_WINDOWPOSCHANGED(func) \
	if (uMsg == WM_WINDOWPOSCHANGED) \
	{ \
		SetMsgHandled(TRUE); \
		func((LPWINDOWPOS)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_EXITMENULOOP(func) \
	if (uMsg == WM_EXITMENULOOP) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ENTERMENULOOP(func) \
	if (uMsg == WM_ENTERMENULOOP) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_STYLECHANGED(func) \
	if (uMsg == WM_STYLECHANGED) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPSTYLESTRUCT)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_STYLECHANGING(func) \
	if (uMsg == WM_STYLECHANGING) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPSTYLESTRUCT)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SIZING(func) \
	if (uMsg == WM_SIZING) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPRECT)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_MOVING(func) \
	if (uMsg == WM_MOVING) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPRECT)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CAPTURECHANGED(func) \
	if (uMsg == WM_CAPTURECHANGED) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_DEVICECHANGE(func) \
	if (uMsg == WM_DEVICECHANGE) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)wParam, (DWORD)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_COMMAND(func) \
	if (uMsg == WM_COMMAND) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_DISPLAYCHANGE(func) \
	if (uMsg == WM_DISPLAYCHANGE) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, CSize(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_ENTERSIZEMOVE(func) \
	if (uMsg == WM_ENTERSIZEMOVE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_EXITSIZEMOVE(func) \
	if (uMsg == WM_EXITSIZEMOVE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_GETFONT(func) \
	if (uMsg == WM_GETFONT) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func(); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_GETHOTKEY(func) \
	if (uMsg == WM_GETHOTKEY) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func(); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_GETICON(func) \
	if (uMsg == WM_GETICON) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)wParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_GETTEXT(func) \
	if (uMsg == WM_GETTEXT) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((int)wParam, (LPTSTR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_GETTEXTLENGTH(func) \
	if (uMsg == WM_GETTEXTLENGTH) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func(); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_HELP(func) \
	if (uMsg == WM_HELP) \
	{ \
		SetMsgHandled(TRUE); \
		func((LPHELPINFO)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_HOTKEY(func) \
	if (uMsg == WM_HOTKEY) \
	{ \
		SetMsgHandled(TRUE); \
		func((int)wParam, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_INPUTLANGCHANGE(func) \
	if (uMsg == WM_INPUTLANGCHANGE) \
	{ \
		SetMsgHandled(TRUE); \
		func((DWORD)wParam, (HKL)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_INPUTLANGCHANGEREQUEST(func) \
	if (uMsg == WM_INPUTLANGCHANGEREQUEST) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)wParam, (HKL)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NEXTDLGCTL(func) \
	if (uMsg == WM_NEXTDLGCTL) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)LOWORD(lParam), wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NEXTMENU(func) \
	if (uMsg == WM_NEXTMENU) \
	{ \
		SetMsgHandled(TRUE); \
		func((int)wParam, (LPMDINEXTMENU)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_NOTIFYFORMAT(func) \
	if (uMsg == WM_NOTIFYFORMAT) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HWND)wParam, (int)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_POWERBROADCAST(func) \
	if (uMsg == WM_POWERBROADCAST) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((DWORD)wParam, (DWORD)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_PRINT(func) \
	if (uMsg == WM_PRINT) \
	{ \
		SetMsgHandled(TRUE); \
		func((HDC)wParam, (UINT)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_PRINTCLIENT(func) \
	if (uMsg == WM_PRINTCLIENT) \
	{ \
		SetMsgHandled(TRUE); \
		func((HDC)wParam, (UINT)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_RASDIALEVENT(func) \
	if (uMsg == WM_RASDIALEVENT) \
	{ \
		SetMsgHandled(TRUE); \
		func((RASCONNSTATE)wParam, (DWORD)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SETFONT(func) \
	if (uMsg == WM_SETFONT) \
	{ \
		SetMsgHandled(TRUE); \
		func((HFONT)wParam, (BOOL)LOWORD(lParam)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SETHOTKEY(func) \
	if (uMsg == WM_SETHOTKEY) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((int)LOBYTE(LOWORD(wParam)), (UINT)HIBYTE(LOWORD(wParam))); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SETICON(func) \
	if (uMsg == WM_SETICON) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)wParam, (HICON)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SETREDRAW(func) \
	if (uMsg == WM_SETREDRAW) \
	{ \
		SetMsgHandled(TRUE); \
		func((BOOL)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_SETTEXT(func) \
	if (uMsg == WM_SETTEXT) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((LPCTSTR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_USERCHANGED(func) \
	if (uMsg == WM_USERCHANGED) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

///////////////////////////////////////////////////////////////////////////////
// New NT4 & NT5 messages

#if(_WIN32_WINNT >= 0x0400)

#define MSG_WM_MOUSEHOVER(func) \
	if (uMsg == WM_MOUSEHOVER) \
	{ \
		SetMsgHandled(TRUE); \
		func(wParam, CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_MOUSELEAVE(func) \
	if (uMsg == WM_MOUSELEAVE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#endif /* _WIN32_WINNT >= 0x0400 */

#if(WINVER >= 0x0500)

#define MSG_WM_MENURBUTTONUP(func) \
	if (uMsg == WM_MENURBUTTONUP) \
	{ \
		SetMsgHandled(TRUE); \
		func(wParam, (HMENU)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_MENUDRAG(func) \
	if (uMsg == WM_MENUDRAG) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func(wParam, (HMENU)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_MENUGETOBJECT(func) \
	if (uMsg == WM_MENUGETOBJECT) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((PMENUGETOBJECTINFO)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_UNINITMENUPOPUP(func) \
	if (uMsg == WM_UNINITMENUPOPUP) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(lParam), (HMENU)wParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_MENUCOMMAND(func) \
	if (uMsg == WM_MENUCOMMAND) \
	{ \
		SetMsgHandled(TRUE); \
		func(wParam, (HMENU)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#endif /* WINVER >= 0x0500 */

#if(_WIN32_WINNT >= 0x0500)

#define MSG_WM_APPCOMMAND(func) \
	if (uMsg == WM_APPCOMMAND) \
	{ \
		SetMsgHandled(TRUE); \
		func((HWND)wParam, GET_APPCOMMAND_LPARAM(lParam), GET_DEVICE_LPARAM(lParam), GET_KEYSTATE_LPARAM(lParam)); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_NCXBUTTONDOWN(func) \
	if (uMsg == WM_NCXBUTTONDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func(GET_XBUTTON_WPARAM(wParam), GET_NCHITTEST_WPARAM(wParam), CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_NCXBUTTONUP(func) \
	if (uMsg == WM_NCXBUTTONUP) \
	{ \
		SetMsgHandled(TRUE); \
		func(GET_XBUTTON_WPARAM(wParam), GET_NCHITTEST_WPARAM(wParam), CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_NCXBUTTONDBLCLK(func) \
	if (uMsg == WM_NCXBUTTONDBLCLK) \
	{ \
		SetMsgHandled(TRUE); \
		func(GET_XBUTTON_WPARAM(wParam), GET_NCHITTEST_WPARAM(wParam), CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_XBUTTONDOWN(func) \
	if (uMsg == WM_XBUTTONDOWN) \
	{ \
		SetMsgHandled(TRUE); \
		func(GET_XBUTTON_WPARAM(wParam), GET_KEYSTATE_WPARAM(wParam), CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_XBUTTONUP(func) \
	if (uMsg == WM_XBUTTONUP) \
	{ \
		SetMsgHandled(TRUE); \
		func(GET_XBUTTON_WPARAM(wParam), GET_KEYSTATE_WPARAM(wParam), CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MSG_WM_XBUTTONDBLCLK(func) \
	if (uMsg == WM_XBUTTONDBLCLK) \
	{ \
		SetMsgHandled(TRUE); \
		func(GET_XBUTTON_WPARAM(wParam), GET_KEYSTATE_WPARAM(wParam), CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#endif //(_WIN32_WINNT >= 0x0500)

///////////////////////////////////////////////////////////////////////////////
// ATL defined messages

#define MSG_WM_FORWARDMSG(func) \
	if (uMsg == WM_FORWARDMSG) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((LPMSG)lParam, (DWORD)wParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

///////////////////////////////////////////////////////////////////////////////
// Dialog specific messages

#define MSG_DM_GETDEFID(func) \
	if (uMsg == DM_GETDEFID) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func(); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_DM_SETDEFID(func) \
	if (uMsg == DM_SETDEFID) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_DM_REPOSITION(func) \
	if (uMsg == DM_REPOSITION) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

///////////////////////////////////////////////////////////////////////////////
// Reflected messages

#define MSG_OCM_COMMAND(func) \
	if (uMsg == OCM_COMMAND) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_NOTIFY(func) \
	if (uMsg == OCM_NOTIFY) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((int)wParam, (LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_PARENTNOTIFY(func) \
	if (uMsg == OCM_PARENTNOTIFY) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_DRAWITEM(func) \
	if (uMsg == OCM_DRAWITEM) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPDRAWITEMSTRUCT)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_MEASUREITEM(func) \
	if (uMsg == OCM_MEASUREITEM) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPMEASUREITEMSTRUCT)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_COMPAREITEM(func) \
	if (uMsg == OCM_COMPAREITEM) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)wParam, (LPCOMPAREITEMSTRUCT)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_DELETEITEM(func) \
	if (uMsg == OCM_DELETEITEM) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)wParam, (LPDELETEITEMSTRUCT)lParam); \
		lResult = TRUE; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_VKEYTOITEM(func) \
	if (uMsg == OCM_VKEYTOITEM) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_CHARTOITEM(func) \
	if (uMsg == OCM_CHARTOITEM) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_HSCROLL(func) \
	if (uMsg == OCM_HSCROLL) \
	{ \
		SetMsgHandled(TRUE); \
		func((int)LOWORD(wParam), (short)HIWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_VSCROLL(func) \
	if (uMsg == OCM_VSCROLL) \
	{ \
		SetMsgHandled(TRUE); \
		func((int)LOWORD(wParam), (short)HIWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_CTLCOLOREDIT(func) \
	if (uMsg == OCM_CTLCOLOREDIT) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_CTLCOLORLISTBOX(func) \
	if (uMsg == OCM_CTLCOLORLISTBOX) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_CTLCOLORBTN(func) \
	if (uMsg == OCM_CTLCOLORBTN) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_CTLCOLORDLG(func) \
	if (uMsg == OCM_CTLCOLORDLG) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_CTLCOLORSCROLLBAR(func) \
	if (uMsg == OCM_CTLCOLORSCROLLBAR) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_OCM_CTLCOLORSTATIC(func) \
	if (uMsg == OCM_CTLCOLORSTATIC) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

///////////////////////////////////////////////////////////////////////////////
// Edit specific messages

#define MSG_WM_CLEAR(func) \
	if (uMsg == WM_CLEAR) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_COPY(func) \
	if (uMsg == WM_COPY) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_CUT(func) \
	if (uMsg == WM_CUT) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_PASTE(func) \
	if (uMsg == WM_PASTE) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define MSG_WM_UNDO(func) \
	if (uMsg == WM_UNDO) \
	{ \
		SetMsgHandled(TRUE); \
		func(); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

///////////////////////////////////////////////////////////////////////////////
// Generic message handlers

#define MESSAGE_HANDLER_EX(msg, func) \
	if(uMsg == msg) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func(uMsg, wParam, lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define MESSAGE_RANGE_HANDLER_EX(msgFirst, msgLast, func) \
	if(uMsg >= msgFirst && uMsg <= msgLast) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func(uMsg, wParam, lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

///////////////////////////////////////////////////////////////////////////////
// Commands and notifications

#define COMMAND_HANDLER_EX(id, code, func) \
	if (uMsg == WM_COMMAND && code == HIWORD(wParam) && id == LOWORD(wParam)) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define COMMAND_ID_HANDLER_EX(id, func) \
	if (uMsg == WM_COMMAND && id == LOWORD(wParam)) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define COMMAND_CODE_HANDLER_EX(code, func) \
	if (uMsg == WM_COMMAND && code == HIWORD(wParam)) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define NOTIFY_HANDLER_EX(id, cd, func) \
	if (uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code && id == ((LPNMHDR)lParam)->idFrom) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define NOTIFY_ID_HANDLER_EX(id, func) \
	if (uMsg == WM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define NOTIFY_CODE_HANDLER_EX(cd, func) \
	if (uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define COMMAND_RANGE_HANDLER_EX(idFirst, idLast, func) \
	if(uMsg == WM_COMMAND && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define COMMAND_RANGE_CODE_HANDLER_EX(idFirst, idLast, code, func) \
	if(uMsg == WM_COMMAND && code == HIWORD(wParam) && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define NOTIFY_RANGE_HANDLER_EX(idFirst, idLast, func) \
	if(uMsg == WM_NOTIFY && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define NOTIFY_RANGE_CODE_HANDLER_EX(idFirst, idLast, cd, func) \
	if(uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_HANDLER_EX(id, code, func) \
	if (uMsg == OCM_COMMAND && code == HIWORD(wParam) && id == LOWORD(wParam)) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define REFLECTED_COMMAND_ID_HANDLER_EX(id, func) \
	if (uMsg == OCM_COMMAND && id == LOWORD(wParam)) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define REFLECTED_COMMAND_CODE_HANDLER_EX(code, func) \
	if (uMsg == OCM_COMMAND && code == HIWORD(wParam)) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define REFLECTED_NOTIFY_HANDLER_EX(id, cd, func) \
	if (uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code && id == ((LPNMHDR)lParam)->idFrom) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define REFLECTED_NOTIFY_ID_HANDLER_EX(id, func) \
	if (uMsg == OCM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define REFLECTED_NOTIFY_CODE_HANDLER_EX(cd, func) \
	if (uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_RANGE_HANDLER_EX(idFirst, idLast, func) \
	if(uMsg == OCM_COMMAND && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#define REFLECTED_COMMAND_RANGE_CODE_HANDLER_EX(idFirst, idLast, code, func) \
	if(uMsg == OCM_COMMAND && code == HIWORD(wParam) && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
	{ \
		SetMsgHandled(TRUE); \
		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
		lResult = 0; \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define REFLECTED_NOTIFY_RANGE_HANDLER_EX(idFirst, idLast, func) \
	if(uMsg == OCM_NOTIFY && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}
#define REFLECTED_NOTIFY_RANGE_CODE_HANDLER_EX(idFirst, idLast, cd, func) \
	if(uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
	{ \
		SetMsgHandled(TRUE); \
		lResult = func((LPNMHDR)lParam); \
		if(IsMsgHandled()) \
			return TRUE; \
	}

#endif //__ATLCRACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wtl10\atlctrlx.h ===
// WTL Version 3.1
// Copyright (C) 1997-2000 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLCTRLX_H__
#define __ATLCTRLX_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlctrlx.h requires atlapp.h to be included first
#endif

#ifndef __ATLCTRLS_H__
	#error atlctrlx.h requires atlctrls.h to be included first
#endif


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T, class TBase = CButton, class TWinTraits = CControlWinTraits> class CBitmapButtonImpl;
class CBitmapButton;
template <class T, class TBase = CListViewCtrl, class TWinTraits = CCheckListViewCtrlTraits> class CCheckListViewCtrlImpl;
class CCheckListViewCtrl;
template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CHyperLinkImpl;
class CHyperLink;
class CWaitCursor;
template <class T, class TBase = CStatusBarCtrl> class CMultiPaneStatusBarCtrlImpl;
class CMultiPaneStatusBarCtrl;
template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CPaneContainerImpl;
class CPaneContainer;


/////////////////////////////////////////////////////////////////////////////
// CBitmapButton - bitmap button implementation

// bitmap button extended styles
#define BMPBTN_HOVER		0x00000001
#define BMPBTN_AUTO3D_SINGLE	0x00000002
#define BMPBTN_AUTO3D_DOUBLE	0x00000004
#define BMPBTN_AUTOSIZE		0x00000008
#define BMPBTN_SHAREIMAGELISTS	0x00000010
#define BMPBTN_AUTOFIRE		0x00000020

template <class T, class TBase /*= CButton */, class TWinTraits /*= CControlWinTraits */ >
class ATL_NO_VTABLE CBitmapButtonImpl : public CWindowImpl< T, TBase, TWinTraits>
{
public:
	DECLARE_WND_SUPERCLASS(NULL, TBase::GetWndClassName())

	enum
	{
		_nImageNormal = 0,
		_nImagePushed,
		_nImageFocusOrHover,
		_nImageDisabled,

		_nImageCount = 4,
	};

	enum
	{
		ID_TIMER_FIRST = 1000,
		ID_TIMER_REPEAT = 1001
	};

	// Bitmap button specific extended styles
	DWORD m_dwExtendedStyle;

	CImageList m_ImageList;
	int m_nImage[_nImageCount];

	CToolTipCtrl m_tip;
	LPTSTR m_lpstrToolTipText;

	// Internal states
	unsigned m_fMouseOver:1;
	unsigned m_fFocus:1;
	unsigned m_fPressed:1;


// Constructor/Destructor
	CBitmapButtonImpl(DWORD dwExtendedStyle = BMPBTN_AUTOSIZE, HIMAGELIST hImageList = NULL) : 
			m_ImageList(hImageList), m_dwExtendedStyle(dwExtendedStyle), m_lpstrToolTipText(NULL),
			m_fMouseOver(0), m_fFocus(0), m_fPressed(0)
	{
		m_nImage[_nImageNormal] = -1;
		m_nImage[_nImagePushed] = -1;
		m_nImage[_nImageFocusOrHover] = -1;
		m_nImage[_nImageDisabled] = -1;
	}

	~CBitmapButtonImpl()
	{
		if((m_dwExtendedStyle & BMPBTN_SHAREIMAGELISTS) == 0)
			m_ImageList.Destroy();
		delete [] m_lpstrToolTipText;
	}

	// overridden to provide proper initialization
	BOOL SubclassWindow(HWND hWnd)
	{
		BOOL bRet = CWindowImpl< T, TBase, TWinTraits>::SubclassWindow(hWnd);
		if(bRet)
			Init();
		return bRet;
	}

// Attributes
	DWORD GetBitmapButtonExtendedStyle() const
	{
		return m_dwExtendedStyle;
	}
	DWORD SetBitmapButtonExtendedStyle(DWORD dwExtendedStyle, DWORD dwMask = 0)
	{
		DWORD dwPrevStyle = m_dwExtendedStyle;
		if(dwMask == 0)
			m_dwExtendedStyle = dwExtendedStyle;
		else
			m_dwExtendedStyle = (m_dwExtendedStyle & ~dwMask) | (dwExtendedStyle & dwMask);
		return dwPrevStyle;
	}
	HIMAGELIST GetImageList() const
	{
		return m_ImageList;
	}
	HIMAGELIST SetImageList(HIMAGELIST hImageList)
	{
		HIMAGELIST hImageListPrev = m_ImageList;
		m_ImageList = hImageList;
		if((m_dwExtendedStyle & BMPBTN_AUTOSIZE) != 0 && ::IsWindow(m_hWnd))
			SizeToImage();
		return hImageListPrev;
	}
	int GetToolTipTextLength() const
	{
		return (m_lpstrToolTipText == NULL) ? -1 : lstrlen(m_lpstrToolTipText);
	}
	bool GetToolTipText(LPTSTR lpstrText, int nLength) const
	{
		ATLASSERT(lpstrText != NULL);
		if(m_lpstrToolTipText == NULL)
			return false;
		return (lstrcpyn(lpstrText, m_lpstrToolTipText, min(nLength, lstrlen(m_lpstrToolTipText) + 1)) != NULL);
	}
	bool SetToolTipText(LPCTSTR lpstrText)
	{
		if(m_lpstrToolTipText != NULL)
		{
			delete [] m_lpstrToolTipText;
			m_lpstrToolTipText = NULL;
		}
		if(lpstrText == NULL)
		{
			if(m_tip.IsWindow())
				m_tip.Activate(FALSE);
			return true;
		}
		ATLTRY(m_lpstrToolTipText = new TCHAR[lstrlen(lpstrText) + 1]);
		if(m_lpstrToolTipText == NULL)
			return false;
		bool bRet = (lstrcpy(m_lpstrToolTipText, lpstrText) != NULL);
		if(bRet && m_tip.IsWindow())
		{
			m_tip.Activate(TRUE);
			m_tip.AddTool(m_hWnd, m_lpstrToolTipText);
		}
		return bRet;
	}

// Operations
	void SetImages(int nNormal, int nPushed = -1, int nFocusOrHover = -1, int nDisabled = -1)
	{
		if(nNormal != -1)
			m_nImage[_nImageNormal] = nNormal;
		if(nPushed != -1)
			m_nImage[_nImagePushed] = nPushed;
		if(nFocusOrHover != -1)
			m_nImage[_nImageFocusOrHover] = nFocusOrHover;
		if(nDisabled != -1)
			m_nImage[_nImageDisabled] = nDisabled;
	}
	BOOL SizeToImage()
	{
		ATLASSERT(::IsWindow(m_hWnd) && m_ImageList.m_hImageList != NULL);
		int cx = 0;
		int cy = 0;
		if(!m_ImageList.GetIconSize(cx, cy))
			return FALSE;
		return ResizeClient(cx, cy);
	}

// Overrideables
	void DoPaint(CDCHandle dc)
	{
		ATLASSERT(m_ImageList.m_hImageList != NULL);	// image list must be set
		ATLASSERT(m_nImage[0] != -1);			// main bitmap must be set

		// set bitmap according to the current button state
		int nImage = -1;
		bool bHover = IsHoverMode();
		if(m_fPressed == 1)
			nImage = m_nImage[_nImagePushed];
		else if((!bHover && m_fFocus == 1) || (bHover && m_fMouseOver == 1))
			nImage = m_nImage[_nImageFocusOrHover];
		else if(!IsWindowEnabled())
			nImage = m_nImage[_nImageDisabled];
		if(nImage == -1)	// not there, use default one
			nImage = m_nImage[_nImageNormal];

		// draw the button image
		int xyPos = 0;
		if((m_fPressed == 1) && ((m_dwExtendedStyle & (BMPBTN_AUTO3D_SINGLE | BMPBTN_AUTO3D_DOUBLE)) != 0) && (m_nImage[_nImagePushed] == -1))
			xyPos = 1;
		m_ImageList.Draw(dc, nImage, xyPos, xyPos, ILD_NORMAL);

		// draw 3D border if required
		if((m_dwExtendedStyle & (BMPBTN_AUTO3D_SINGLE | BMPBTN_AUTO3D_DOUBLE)) != 0)
		{
			RECT rect;
			GetClientRect(&rect);

			if(m_fPressed == 1)
				dc.DrawEdge(&rect, ((m_dwExtendedStyle & BMPBTN_AUTO3D_SINGLE) != 0) ? BDR_SUNKENOUTER : EDGE_SUNKEN, BF_RECT);
			else if(!bHover || m_fMouseOver == 1)
				dc.DrawEdge(&rect, ((m_dwExtendedStyle & BMPBTN_AUTO3D_SINGLE) != 0) ? BDR_RAISEDINNER : EDGE_RAISED, BF_RECT);

			if(!bHover && m_fFocus == 1)
			{
				::InflateRect(&rect, -2 * ::GetSystemMetrics(SM_CXEDGE), -2 * ::GetSystemMetrics(SM_CYEDGE));
				dc.DrawFocusRect(&rect);
			}
		}
	}

// Message map and handlers
	typedef CBitmapButtonImpl< T, TBase, TWinTraits >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_CREATE, OnCreate)
		MESSAGE_RANGE_HANDLER(WM_MOUSEFIRST, WM_MOUSELAST, OnMouseMessage)
		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
		MESSAGE_HANDLER(WM_PAINT, OnPaint)
		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
		MESSAGE_HANDLER(WM_SETFOCUS, OnFocus)
		MESSAGE_HANDLER(WM_KILLFOCUS, OnFocus)
		MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
		MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDblClk)
		MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
		MESSAGE_HANDLER(WM_CAPTURECHANGED, OnCaptureChanged)
		MESSAGE_HANDLER(WM_ENABLE, OnEnable)
		MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
		MESSAGE_HANDLER(WM_MOUSELEAVE, OnMouseLeave)
		MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
		MESSAGE_HANDLER(WM_KEYUP, OnKeyUp)
		MESSAGE_HANDLER(WM_TIMER, OnTimer)
	END_MSG_MAP()

	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		Init();
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		MSG msg = { m_hWnd, uMsg, wParam, lParam };
		if(m_tip.IsWindow())
			m_tip.RelayEvent(&msg);
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		return 1;	// no background needed
	}

	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		if(wParam != NULL)
		{
			pT->DoPaint((HDC)wParam);
		}
		else
		{
			CPaintDC dc(m_hWnd);
			pT->DoPaint(dc.m_hDC);
		}
		return 0;
	}

	LRESULT OnFocus(UINT uMsg, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		m_fFocus = (uMsg == WM_SETFOCUS) ? 1 : 0;
		Invalidate();
		UpdateWindow();
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		LRESULT lRet = 0;
		if(IsHoverMode())
			SetCapture();
		else
			lRet = DefWindowProc(uMsg, wParam, lParam);
		if(::GetCapture() == m_hWnd)
		{
			m_fPressed = 1;
			Invalidate();
			UpdateWindow();
		}
		if((m_dwExtendedStyle & BMPBTN_AUTOFIRE) != 0)
		{
			int nElapse = 250;
			int nDelay = 0;
			if(::SystemParametersInfo(SPI_GETKEYBOARDDELAY, 0, &nDelay, 0))
				nElapse += nDelay * 250;	// all milli-seconds
			SetTimer(ID_TIMER_FIRST, nElapse);
		}
		return lRet;
	}

	LRESULT OnLButtonDblClk(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		LRESULT lRet = 0;
		if(!IsHoverMode())
			lRet = DefWindowProc(uMsg, wParam, lParam);
		if(::GetCapture() != m_hWnd)
			SetCapture();
		if(m_fPressed == 0)
		{
			m_fPressed = 1;
			Invalidate();
			UpdateWindow();
		}
		return lRet;
	}

	LRESULT OnLButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		LRESULT lRet = 0;
		bool bHover = IsHoverMode();
		if(!bHover)
			lRet = DefWindowProc(uMsg, wParam, lParam);
		if(::GetCapture() == m_hWnd)
		{
			if(bHover && m_fPressed == 1)
				::SendMessage(GetParent(), WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), BN_CLICKED), (LPARAM)m_hWnd);
			::ReleaseCapture();
		}
		return lRet;
	}

	LRESULT OnCaptureChanged(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(m_fPressed == 1)
		{
			m_fPressed = 0;
			Invalidate();
			UpdateWindow();
		}
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnEnable(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		Invalidate();
		UpdateWindow();
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnMouseMove(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		if(::GetCapture() == m_hWnd)
		{
			POINT ptCursor = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
			ClientToScreen(&ptCursor);
			RECT rect;
			GetWindowRect(&rect);
			unsigned int uPressed = ::PtInRect(&rect, ptCursor) ? 1 : 0;
			if(m_fPressed != uPressed)
			{
				m_fPressed = uPressed;
				Invalidate();
				UpdateWindow();
			}
		}
		else if(IsHoverMode() && m_fMouseOver == 0)
		{
			m_fMouseOver = 1;
			Invalidate();
			UpdateWindow();
			StartTrackMouseLeave();
		}
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnMouseLeave(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		if(m_fMouseOver == 1)
		{
			m_fMouseOver = 0;
			Invalidate();
			UpdateWindow();
		}
		return 0;
	}

	LRESULT OnKeyDown(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(wParam == VK_SPACE && IsHoverMode())
			return 0;	// ignore if in hover mode
		if(wParam == VK_SPACE && m_fPressed == 0)
		{
			m_fPressed = 1;
			Invalidate();
			UpdateWindow();
		}
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnKeyUp(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(wParam == VK_SPACE && IsHoverMode())
			return 0;	// ignore if in hover mode
		if(wParam == VK_SPACE && m_fPressed == 1)
		{
			m_fPressed = 0;
			Invalidate();
			UpdateWindow();
		}
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnTimer(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		ATLASSERT((m_dwExtendedStyle & BMPBTN_AUTOFIRE) != 0);
		switch(wParam)	// timer ID
		{
		case ID_TIMER_FIRST:
			KillTimer(ID_TIMER_FIRST);
			if(m_fPressed == 1)
			{
				::SendMessage(GetParent(), WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), BN_CLICKED), (LPARAM)m_hWnd);
				int nElapse = 250;
				int nRepeat = 40;
				if(::SystemParametersInfo(SPI_GETKEYBOARDSPEED, 0, &nRepeat, 0))
					nElapse = 10000 / (10 * nRepeat + 25);	// milli-seconds, approximated
				SetTimer(ID_TIMER_REPEAT, nElapse);
			}
			break;
		case ID_TIMER_REPEAT:
			if(m_fPressed == 1)
				::SendMessage(GetParent(), WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), BN_CLICKED), (LPARAM)m_hWnd);
			else if(::GetCapture() != m_hWnd)
				KillTimer(ID_TIMER_REPEAT);
			break;
		default:	// not our timer
			break;
		}
		return 0;
	}

// Implementation
	void Init()
	{
		// We need this style to prevent Windows from painting the button
		ModifyStyle(0, BS_OWNERDRAW);

		// create a tool tip
		m_tip.Create(m_hWnd);
		ATLASSERT(m_tip.IsWindow());
		if(m_tip.IsWindow() && m_lpstrToolTipText != NULL)
		{
			m_tip.Activate(TRUE);
			m_tip.AddTool(m_hWnd, m_lpstrToolTipText);
		}

		if(m_ImageList.m_hImageList != NULL && (m_dwExtendedStyle & BMPBTN_AUTOSIZE) != 0)
			SizeToImage();
	}

	BOOL StartTrackMouseLeave()
	{
		TRACKMOUSEEVENT tme;
		tme.cbSize = sizeof(tme);
		tme.dwFlags = TME_LEAVE;
		tme.hwndTrack = m_hWnd;
		return _TrackMouseEvent(&tme);
	}

	bool IsHoverMode() const
	{
		return ((m_dwExtendedStyle & BMPBTN_HOVER) != 0);
	}
};


class CBitmapButton : public CBitmapButtonImpl<CBitmapButton>
{
public:
	DECLARE_WND_SUPERCLASS(_T("WTL_BitmapButton"), GetWndClassName())

	CBitmapButton(DWORD dwExtendedStyle = BMPBTN_AUTOSIZE, HIMAGELIST hImageList = NULL) : 
		CBitmapButtonImpl<CBitmapButton>(dwExtendedStyle, hImageList)
	{ }
};


/////////////////////////////////////////////////////////////////////////////
// CCheckListCtrlView - list view control with check boxes

template <DWORD t_dwStyle, DWORD t_dwExStyle, DWORD t_dwExListViewStyle>
class CCheckListViewCtrlImplTraits
{
public:
	static DWORD GetWndStyle(DWORD dwStyle)
	{
		return dwStyle == 0 ? t_dwStyle : dwStyle;
	}
	static DWORD GetWndExStyle(DWORD dwExStyle)
	{
		return dwExStyle == 0 ? t_dwExStyle : dwExStyle;
	}
	static DWORD GetExtendedLVStyle()
	{
		return t_dwExListViewStyle;
	}
};

typedef CCheckListViewCtrlImplTraits<WS_CHILD | WS_VISIBLE | LVS_REPORT | LVS_SHOWSELALWAYS, WS_EX_CLIENTEDGE, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT>	CCheckListViewCtrlTraits;

template <class T, class TBase /*= CListViewCtrl */, class TWinTraits /*= CCheckListViewCtrlTraits */>
class ATL_NO_VTABLE CCheckListViewCtrlImpl : public CWindowImpl<T, TBase, TWinTraits>
{
public:
	DECLARE_WND_SUPERCLASS(NULL, TBase::GetWndClassName())

// Attributes
	static DWORD GetExtendedLVStyle()
	{
		return TWinTraits::GetExtendedLVStyle();
	}

// Operations
	BOOL SubclassWindow(HWND hWnd)
	{
		BOOL bRet = CWindowImplBaseT< TBase, TWinTraits>::SubclassWindow(hWnd);
		if(bRet)
		{
			T* pT = static_cast<T*>(this);
			pT;
			ATLASSERT((pT->GetExtendedLVStyle() & LVS_EX_CHECKBOXES) != 0);
			SetExtendedListViewStyle(pT->GetExtendedLVStyle());
		}
		return bRet;
	}

	void CheckSelectedItems(int nCurrItem)
	{
		// first check if this item is selected
		LVITEM lvi;
		lvi.iItem = nCurrItem;
		lvi.iSubItem = 0;
		lvi.mask = LVIF_STATE;
		lvi.stateMask = LVIS_SELECTED;
		GetItem(&lvi);
		// if item is not selected, don't do anything
		if(!(lvi.state & LVIS_SELECTED))
			return;
		// new check state will be reverse of the current state,
		BOOL bCheck = !GetCheckState(nCurrItem);
		int nItem = -1;
		int nOldItem = -1;
		while((nItem = GetNextItem(nOldItem, LVNI_SELECTED)) != -1)
		{
			if(nItem != nCurrItem)
				SetCheckState(nItem, bCheck);
			nOldItem = nItem;
		}
	}

// Implementation
	typedef CCheckListViewCtrlImpl< T, TBase, TWinTraits >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_CREATE, OnCreate)
		MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
		MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDown)
		MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
	END_MSG_MAP()

	LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		// first let list view control initialize everything
		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
		T* pT = static_cast<T*>(this);
		pT;
		ATLASSERT((pT->GetExtendedLVStyle() & LVS_EX_CHECKBOXES) != 0);
		SetExtendedListViewStyle(pT->GetExtendedLVStyle());
		return lRet;
	}

	LRESULT OnLButtonDown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		POINT ptMsg = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
		LVHITTESTINFO lvh;
		lvh.pt = ptMsg;
		if(HitTest(&lvh) != -1 && lvh.flags == LVHT_ONITEMSTATEICON && ::GetKeyState(VK_CONTROL) >= 0)
			CheckSelectedItems(lvh.iItem);
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnKeyDown(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(wParam == VK_SPACE)
		{
			int nCurrItem = GetNextItem(-1, LVNI_FOCUSED);
			if(nCurrItem != -1  && ::GetKeyState(VK_CONTROL) >= 0)
				CheckSelectedItems(nCurrItem);
		}
		bHandled = FALSE;
		return 1;
	}
};

class CCheckListViewCtrl : public CCheckListViewCtrlImpl<CCheckListViewCtrl>
{
public:
	DECLARE_WND_SUPERCLASS(_T("WTL_CheckListView"), GetWndClassName())
};


/////////////////////////////////////////////////////////////////////////////
// CHyperLink - hyper link control implementation

#if (WINVER < 0x0500)
__declspec(selectany) struct
{
	enum { cxWidth = 32, cyHeight = 32 };
	int xHotSpot;
	int yHotSpot;
	unsigned char arrANDPlane[cxWidth * cyHeight / 8];
	unsigned char arrXORPlane[cxWidth * cyHeight / 8];
} _AtlHyperLink_CursorData = 
{
	5, 0, 
	{
		0xF9, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 
		0xF0, 0xFF, 0xFF, 0xFF, 0xF0, 0x3F, 0xFF, 0xFF, 0xF0, 0x07, 0xFF, 0xFF, 0xF0, 0x01, 0xFF, 0xFF, 
		0xF0, 0x00, 0xFF, 0xFF, 0x10, 0x00, 0x7F, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 
		0x80, 0x00, 0x7F, 0xFF, 0xC0, 0x00, 0x7F, 0xFF, 0xC0, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x7F, 0xFF, 
		0xE0, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xF8, 0x01, 0xFF, 0xFF, 
		0xF8, 0x01, 0xFF, 0xFF, 0xF8, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
	},
	{
		0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
		0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0xC0, 0x00, 0x00, 0x06, 0xD8, 0x00, 0x00, 
		0x06, 0xDA, 0x00, 0x00, 0x06, 0xDB, 0x00, 0x00, 0x67, 0xFB, 0x00, 0x00, 0x77, 0xFF, 0x00, 0x00, 
		0x37, 0xFF, 0x00, 0x00, 0x17, 0xFF, 0x00, 0x00, 0x1F, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0x00, 0x00, 
		0x0F, 0xFE, 0x00, 0x00, 0x07, 0xFE, 0x00, 0x00, 0x07, 0xFE, 0x00, 0x00, 0x03, 0xFC, 0x00, 0x00, 
		0x03, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	}
};
#endif //(WINVER < 0x0500)


template <class T, class TBase /*= CWindow */, class TWinTraits /*= CControlWinTraits */ >
class ATL_NO_VTABLE CHyperLinkImpl : public CWindowImpl< T, TBase, TWinTraits >
{
public:
	LPTSTR m_lpstrLabel;
	LPTSTR m_lpstrHyperLink;
	HCURSOR m_hCursor;
	HFONT m_hFont;
	RECT m_rcLink;
	bool m_bPaintLabel;
	CToolTipCtrl m_tip;

	bool m_bVisited;
	COLORREF m_clrLink;
	COLORREF m_clrVisited;


// Constructor/Destructor
	CHyperLinkImpl() : m_lpstrLabel(NULL), m_lpstrHyperLink(NULL),
			m_hCursor(NULL), m_hFont(NULL), m_bPaintLabel(true), m_bVisited(false),
			m_clrLink(RGB(0, 0, 255)), m_clrVisited(RGB(128, 0, 128))
	{
		::SetRectEmpty(&m_rcLink);
	}

	~CHyperLinkImpl()
	{
		free(m_lpstrLabel);
		free(m_lpstrHyperLink);
		if(m_hFont != NULL)
			::DeleteObject(m_hFont);
#if (WINVER < 0x0500)
		// It was created, not loaded, so we have to destroy it
		if(m_hCursor != NULL)
			::DestroyCursor(m_hCursor);
#endif //(WINVER < 0x0500)
	}

// Attributes
	bool GetLabel(LPTSTR lpstrBuffer, int nLength) const
	{
		if(m_lpstrLabel == NULL)
			return false;
		ATLASSERT(lpstrBuffer != NULL);
		if(nLength > lstrlen(m_lpstrLabel) + 1)
		{
			lstrcpy(lpstrBuffer, m_lpstrLabel);
			return true;
		}
		return false;
	}

	bool SetLabel(LPCTSTR lpstrLabel)
	{
		free(m_lpstrLabel);
		m_lpstrLabel = NULL;
		ATLTRY(m_lpstrLabel = (LPTSTR)malloc((lstrlen(lpstrLabel) + 1) * sizeof(TCHAR)));
		if(m_lpstrLabel == NULL)
			return false;
		lstrcpy(m_lpstrLabel, lpstrLabel);
		CalcLabelRect();
		return true;
	}

	bool GetHyperLink(LPTSTR lpstrBuffer, int nLength) const
	{
		if(m_lpstrHyperLink == NULL)
			return false;
		ATLASSERT(lpstrBuffer != NULL);
		if(nLength > lstrlen(m_lpstrHyperLink) + 1)
		{
			lstrcpy(lpstrBuffer, m_lpstrHyperLink);
			return true;
		}
		return false;
	}

	bool SetHyperLink(LPCTSTR lpstrLink)
	{
		free(m_lpstrHyperLink);
		m_lpstrHyperLink = NULL;
		ATLTRY(m_lpstrHyperLink = (LPTSTR)malloc((lstrlen(lpstrLink) + 1) * sizeof(TCHAR)));
		if(m_lpstrHyperLink == NULL)
			return false;
		lstrcpy(m_lpstrHyperLink, lpstrLink);
		if(m_lpstrLabel == NULL)
			CalcLabelRect();
		return true;
	}

// Operations
	BOOL SubclassWindow(HWND hWnd)
	{
		ATLASSERT(m_hWnd == NULL);
		ATLASSERT(::IsWindow(hWnd));
		BOOL bRet = CWindowImpl< T, TBase, TWinTraits >::SubclassWindow(hWnd);
		if(bRet)
			Init();
		return bRet;
	}

	bool Navigate()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_lpstrHyperLink != NULL);
		DWORD_PTR dwRet = (DWORD_PTR)::ShellExecute(0, _T("open"), m_lpstrHyperLink, 0, 0, SW_SHOWNORMAL);
		if(dwRet > 32)
		{
			m_bVisited = true;
			Invalidate();
		}
		return (dwRet > 32);
	}

// Message map and handlers
	BEGIN_MSG_MAP(CHyperLinkImpl)
		MESSAGE_HANDLER(WM_CREATE, OnCreate)
		MESSAGE_RANGE_HANDLER(WM_MOUSEFIRST, WM_MOUSELAST, OnMouseMessage)
		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
		MESSAGE_HANDLER(WM_PAINT, OnPaint)
		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
		MESSAGE_HANDLER(WM_SETFOCUS, OnFocus)
		MESSAGE_HANDLER(WM_KILLFOCUS, OnFocus)
		MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
		MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
		MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
		MESSAGE_HANDLER(WM_CHAR, OnChar)
		MESSAGE_HANDLER(WM_GETDLGCODE, OnGetDlgCode)
		MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
	END_MSG_MAP()

	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		Init();
		return 0;
	}

	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(m_bPaintLabel)
		{
			HBRUSH hBrush = (HBRUSH)::SendMessage(GetParent(), WM_CTLCOLORSTATIC, wParam, (LPARAM)m_hWnd);
			if(hBrush != NULL)
			{
				CDCHandle dc = (HDC)wParam;
				RECT rect;
				GetClientRect(&rect);
				dc.FillRect(&rect, hBrush);
			}
		}
		else
		{
			bHandled = FALSE;
		}
		return 1;
	}

	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(!m_bPaintLabel)
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = static_cast<T*>(this);
		if(wParam != NULL)
		{
			pT->DoPaint((HDC)wParam);
		}
		else
		{
			CPaintDC dc(m_hWnd);
			pT->DoPaint(dc.m_hDC);
		}

		return 0;
	}

	LRESULT OnFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(m_bPaintLabel)
			Invalidate();
		else
			bHandled = FALSE;
		return 0;
	}

	LRESULT OnMouseMove(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
		if(m_lpstrHyperLink != NULL && ::PtInRect(&m_rcLink, pt))
			::SetCursor(m_hCursor);
		else
			bHandled = FALSE;
		return 0;
	}

	LRESULT OnLButtonDown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
	{
		POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
		if(::PtInRect(&m_rcLink, pt))
		{
			SetFocus();
			SetCapture();
		}
		return 0;
	}

	LRESULT OnLButtonUp(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
	{
		if(GetCapture() == m_hWnd)
		{
			ReleaseCapture();
			POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
			if(::PtInRect(&m_rcLink, pt))
				Navigate();
		}
		return 0;
	}

	LRESULT OnSetCursor(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		POINT pt;
		GetCursorPos(&pt);
		ScreenToClient(&pt);
		if(m_lpstrHyperLink != NULL && ::PtInRect(&m_rcLink, pt))
		{
			return TRUE;
		}
		bHandled = FALSE;
		return FALSE;
	}

	LRESULT OnChar(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		if(wParam == VK_RETURN || wParam == VK_SPACE)
			Navigate();
		return 0;
	}

	LRESULT OnGetDlgCode(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		return DLGC_WANTCHARS;
	}

	LRESULT OnMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		MSG msg = { m_hWnd, uMsg, wParam, lParam };
		if(m_tip.IsWindow())
			m_tip.RelayEvent(&msg);
		bHandled = FALSE;
		return 1;
	}

// Implementation
	void Init()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		// Check if we should paint a label
		TCHAR lpszBuffer[8];
		if(::GetClassName(m_hWnd, lpszBuffer, 8))
		{
			if(lstrcmpi(lpszBuffer, _T("static")) == 0)
			{
				ModifyStyle(0, SS_NOTIFY);	// we need this
				DWORD dwStyle = GetStyle() & 0x000000FF;
				if(dwStyle == SS_ICON || dwStyle == SS_BLACKRECT || dwStyle == SS_GRAYRECT || 
						dwStyle == SS_WHITERECT || dwStyle == SS_BLACKFRAME || dwStyle == SS_GRAYFRAME || 
						dwStyle == SS_WHITEFRAME || dwStyle == SS_OWNERDRAW || 
						dwStyle == SS_BITMAP || dwStyle == SS_ENHMETAFILE)
					m_bPaintLabel = false;
			}
		}

		// create or load a cursor
#if (WINVER >= 0x0500)
		m_hCursor = ::LoadCursor(NULL, IDC_HAND);
#else
		m_hCursor = ::CreateCursor(_Module.GetModuleInstance(), _AtlHyperLink_CursorData.xHotSpot, _AtlHyperLink_CursorData.yHotSpot, _AtlHyperLink_CursorData.cxWidth, _AtlHyperLink_CursorData.cyHeight, _AtlHyperLink_CursorData.arrANDPlane, _AtlHyperLink_CursorData.arrXORPlane);
#endif //!(WINVER >= 0x0500)
		ATLASSERT(m_hCursor != NULL);

		// set font
		if(m_bPaintLabel)
		{
			CWindow wnd = GetParent();
			CFontHandle font = wnd.GetFont();
			if(font.m_hFont != NULL)
			{
				LOGFONT lf;
				font.GetLogFont(&lf);
				lf.lfUnderline = TRUE;
				m_hFont = ::CreateFontIndirect(&lf);
			}
		}

		// set label (defaults to window text)
		if(m_lpstrLabel == NULL)
		{
			int nLen = GetWindowTextLength();
			if(nLen > 0)
			{
				LPTSTR lpszText = (LPTSTR)_alloca((nLen+1)*sizeof(TCHAR));
				if(GetWindowText(lpszText, nLen+1))
					SetLabel(lpszText);
			}
		}

		// set hyperlink (defaults to label)
		if(m_lpstrHyperLink == NULL && m_lpstrLabel != NULL)
			SetHyperLink(m_lpstrLabel);

		CalcLabelRect();

		// create a tool tip
		m_tip.Create(m_hWnd);
		ATLASSERT(m_tip.IsWindow());
		m_tip.Activate(TRUE);
		m_tip.AddTool(m_hWnd, m_lpstrHyperLink);

		// set link colors
		if(m_bPaintLabel)
		{
			CRegKey rk;
			LONG lRet = rk.Open(HKEY_CURRENT_USER, _T("Software\\Microsoft\\Internet Explorer\\Settings"));
			if(lRet == 0)
			{
				TCHAR szBuff[12];
				DWORD dwCount = 12 * sizeof(TCHAR);
				lRet = rk.QueryValue(szBuff, _T("Anchor Color"), &dwCount);
				if(lRet == 0)
				{
					COLORREF clr = _ParseColorString(szBuff);
					ATLASSERT(clr != CLR_INVALID);
					if(clr != CLR_INVALID)
						m_clrLink = clr;
				}

				dwCount = 12 * sizeof(TCHAR);
				lRet = rk.QueryValue(szBuff, _T("Anchor Color Visited"), &dwCount);
				if(lRet == 0)
				{
					COLORREF clr = _ParseColorString(szBuff);
					ATLASSERT(clr != CLR_INVALID);
					if(clr != CLR_INVALID)
						m_clrVisited = clr;
				}
			}
		}
	}

	static COLORREF _ParseColorString(LPTSTR lpstr)
	{
		int c[3] = { -1, -1, -1 };
		LPTSTR p;
		for(int i = 0; i < 2; i++)
		{
			for(p = lpstr; *p != _T('\0'); p = ::CharNext(p))
			{
				if(*p == _T(','))
				{
					*p = _T('\0');
					c[i] = _ttoi(lpstr);
					lpstr = &p[1];
					break;
				}
			}
			if(c[i] == -1)
				return CLR_INVALID;
		}
		if(*lpstr == _T('\0'))
			return CLR_INVALID;
		c[2] = _ttoi(lpstr);

		return RGB(c[0], c[1], c[2]);
	}

	bool CalcLabelRect()
	{
		if(!::IsWindow(m_hWnd))
			return false;
		if(m_lpstrLabel == NULL && m_lpstrHyperLink == NULL)
			return false;

		CClientDC dc(m_hWnd);
		RECT rect;
		GetClientRect(&rect);
		m_rcLink = rect;
		if(m_bPaintLabel)
		{
			HFONT hOldFont = NULL;
			if(m_hFont != NULL)
				hOldFont = dc.SelectFont(m_hFont);
			LPTSTR lpstrText = (m_lpstrLabel != NULL) ? m_lpstrLabel : m_lpstrHyperLink;
			DWORD dwStyle = GetStyle();
			int nDrawStyle = DT_LEFT;
			if (dwStyle & SS_CENTER)
				nDrawStyle = DT_CENTER;
			else if (dwStyle & SS_RIGHT)
				nDrawStyle = DT_RIGHT;
			dc.DrawText(lpstrText, -1, &m_rcLink, nDrawStyle | DT_WORDBREAK | DT_CALCRECT);
			if(m_hFont != NULL)
				dc.SelectFont(hOldFont);
		}

		return true;
	}

	void DoPaint(CDCHandle dc)
	{
		dc.SetBkMode(TRANSPARENT);
		dc.SetTextColor(m_bVisited ? m_clrVisited : m_clrLink);
		if(m_hFont != NULL)
			dc.SelectFont(m_hFont);
		LPTSTR lpstrText = (m_lpstrLabel != NULL) ? m_lpstrLabel : m_lpstrHyperLink;
		DWORD dwStyle = GetStyle();
		int nDrawStyle = DT_LEFT;
		if (dwStyle & SS_CENTER)
			nDrawStyle = DT_CENTER;
		else if (dwStyle & SS_RIGHT)
			nDrawStyle = DT_RIGHT;
		dc.DrawText(lpstrText, -1, &m_rcLink, nDrawStyle | DT_WORDBREAK);
		if(GetFocus() == m_hWnd)
			dc.DrawFocusRect(&m_rcLink);
	}
};


class CHyperLink : public CHyperLinkImpl<CHyperLink>
{
public:
	DECLARE_WND_CLASS(_T("WTL_HyperLink"))
};


/////////////////////////////////////////////////////////////////////////////
// CWaitCursor - displays a wait cursor

class CWaitCursor
{
public:
// Data
	HCURSOR m_hWaitCursor;
	HCURSOR m_hOldCursor;
	bool m_bInUse;

// Constructor/destructor
	CWaitCursor(bool bSet = true, LPCTSTR lpstrCursor = IDC_WAIT, bool bSys = true) : m_hOldCursor(NULL), m_bInUse(false)
	{
		HINSTANCE hInstance = bSys ? NULL : _Module.GetResourceInstance();
		m_hWaitCursor = ::LoadCursor(hInstance, lpstrCursor);
		ATLASSERT(m_hWaitCursor != NULL);

		if(bSet)
			Set();
	}

	~CWaitCursor()
	{
		Restore();
	}

// Methods
	bool Set()
	{
		if(m_bInUse)
			return false;
		m_hOldCursor = ::SetCursor(m_hWaitCursor);
		m_bInUse = true;
		return true;
	}

	bool Restore()
	{
		if(!m_bInUse)
			return false;
		::SetCursor(m_hOldCursor);
		m_bInUse = false;
		return true;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CMultiPaneStatusBarCtrl - Status Bar with multiple panes

template <class T, class TBase /*= CStatusBarCtrl */ >
class ATL_NO_VTABLE CMultiPaneStatusBarCtrlImpl : public CWindowImpl< T, TBase >
{
public:
	DECLARE_WND_SUPERCLASS(NULL, TBase::GetWndClassName())

// Data
	enum { m_cxPaneMargin = 3 };

	int m_nPanes;
	int* m_pPane;

// Constructor/destructor
	CMultiPaneStatusBarCtrlImpl() : m_nPanes(0), m_pPane(NULL)
	{ }

	~CMultiPaneStatusBarCtrlImpl()
	{
		delete [] m_pPane;
	}

// Methods
	HWND Create(HWND hWndParent, LPCTSTR lpstrText, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | SBARS_SIZEGRIP, UINT nID = ATL_IDW_STATUS_BAR)
	{
		return CWindowImpl< T, TBase >::Create(hWndParent, rcDefault, lpstrText, dwStyle, 0, nID);
	}

	HWND Create(HWND hWndParent, UINT nTextID = ATL_IDS_IDLEMESSAGE, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | SBARS_SIZEGRIP, UINT nID = ATL_IDW_STATUS_BAR)
	{
		TCHAR szText[128];	// max text lentgth is 127 for status bars
		szText[0] = 0;
		::LoadString(_Module.GetResourceInstance(), nTextID, szText, 127);
		return Create(hWndParent, szText, dwStyle, nID);
	}

	BOOL SetPanes(int* pPanes, int nPanes, bool bSetText = true)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPanes > 0);

		m_nPanes = nPanes;
		delete [] m_pPane;
		m_pPane = NULL;

		ATLTRY(m_pPane = new int[nPanes]);
		ATLASSERT(m_pPane != NULL);
		if(m_pPane == NULL)
			return FALSE;
		memcpy(m_pPane, pPanes, nPanes * sizeof(int));

		int* pPanesPos = NULL;
		ATLTRY(pPanesPos = (int*)_alloca(nPanes * sizeof(int)));
		ATLASSERT(pPanesPos != NULL);

		// get status bar DC and set font
		CClientDC dc(m_hWnd);
		HFONT hOldFont = dc.SelectFont(GetFont());

		// get status bar borders
		int arrBorders[3];
		GetBorders(arrBorders);

		TCHAR szBuff[256];
		SIZE size;
		int cxLeft = arrBorders[0];

		// calculate right edge of each part
		for(int i = 0; i < nPanes; i++)
		{
			if(pPanes[i] == ID_DEFAULT_PANE)
			{
				// will be resized later
				pPanesPos[i] = 100 + cxLeft + arrBorders[2];
			}
			else
			{
				::LoadString(_Module.GetResourceInstance(), pPanes[i], szBuff, sizeof(szBuff) / sizeof(TCHAR));
				dc.GetTextExtent(szBuff, lstrlen(szBuff), &size);
				T* pT = static_cast<T*>(this);
				pT;
				pPanesPos[i] = cxLeft + size.cx + arrBorders[2] + 2 * pT->m_cxPaneMargin;
			}
			cxLeft = pPanesPos[i];
		}

		BOOL bRet = SetParts(nPanes, pPanesPos);

		if(bRet && bSetText)
		{
			for(int i = 0; i < nPanes; i++)
			{
				if(pPanes[i] != ID_DEFAULT_PANE)
				{
					::LoadString(_Module.GetResourceInstance(), pPanes[i], szBuff, sizeof(szBuff) / sizeof(TCHAR));
					SetPaneText(m_pPane[i], szBuff);
				}
			}
		}

		dc.SelectFont(hOldFont);
		return bRet;
	}

	bool GetPaneTextLength(int nPaneID, int* pcchLength = NULL, int* pnType = NULL) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return false;

		int nLength = GetTextLength(nIndex, pnType);
		if(pcchLength != NULL)
			*pcchLength = nLength;

		return true;
	}

	BOOL GetPaneText(int nPaneID, LPTSTR lpstrText, int* pcchLength = NULL, int* pnType = NULL) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return FALSE;

		int nLength = GetText(nIndex, lpstrText, pnType);
		if(pcchLength != NULL)
			*pcchLength = nLength;

		return TRUE;
	}

	BOOL SetPaneText(int nPaneID, LPCTSTR lpstrText, int nType = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return FALSE;

		return SetText(nIndex, lpstrText, nType);
	}

	BOOL GetPaneRect(int nPaneID, LPRECT lpRect) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return FALSE;

		return GetRect(nIndex, lpRect);
	}

	BOOL SetPaneWidth(int nPaneID, int cxWidth)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(nPaneID != ID_DEFAULT_PANE);	// Can't resize this one
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return FALSE;

		// get pane positions
		int* pPanesPos = NULL;
		ATLTRY(pPanesPos = (int*)_alloca(m_nPanes * sizeof(int)));
		GetParts(m_nPanes, pPanesPos);
		// calculate offset
		int cxPaneWidth = pPanesPos[nIndex] - ((nIndex == 0) ? 0 : pPanesPos[nIndex - 1]);
		int cxOff = cxWidth - cxPaneWidth;
		// find variable width pane
		int nDef = m_nPanes;
		for(int i = 0; i < m_nPanes; i++)
		{
			if(m_pPane[i] == ID_DEFAULT_PANE)
			{
				nDef = i;
				break;
			}
		}
		// resize
		if(nIndex < nDef)	// before default pane
		{
			for(int i = nIndex; i < nDef; i++)
				pPanesPos[i] += cxOff;
				
		}
		else			// after default one
		{
			for(int i = nDef; i < nIndex; i++)
				pPanesPos[i] -= cxOff;
		}
		// set pane postions
		return SetParts(m_nPanes, pPanesPos);
	}

#if (_WIN32_IE >= 0x0400)
	BOOL GetPaneTipText(int nPaneID, LPTSTR lpstrText, int nSize) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return FALSE;

		GetTipText(nIndex, lpstrText, nSize);
		return TRUE;
	}

	BOOL SetPaneTipText(int nPaneID, LPCTSTR lpstrText)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return FALSE;

		SetTipText(nIndex, lpstrText);
		return TRUE;
	}

	BOOL GetPaneIcon(int nPaneID, HICON& hIcon) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return FALSE;

		hIcon = GetIcon(nIndex);
		return TRUE;
	}

	BOOL SetPaneIcon(int nPaneID, HICON hIcon)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		int nIndex  = GetPaneIndexFromID(nPaneID);
		if(nIndex == -1)
			return FALSE;

		return SetIcon(nIndex, hIcon);
	}
#endif //(_WIN32_IE >= 0x0400)

// Message map and handlers
	BEGIN_MSG_MAP(CMultiPaneStatusBarCtrlImpl< T >)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
	END_MSG_MAP()

	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
		if(wParam != SIZE_MINIMIZED && m_nPanes > 0)
		{
			T* pT = static_cast<T*>(this);
			pT->UpdatePanesLayout();
		}
		return lRet;
	}

// Implementation
	BOOL UpdatePanesLayout()
	{
		// get pane positions
		int* pPanesPos = NULL;
		ATLTRY(pPanesPos = (int*)_alloca(m_nPanes * sizeof(int)));
		ATLASSERT(pPanesPos != NULL);
		if(pPanesPos == NULL)
			return FALSE;
		int nRet = GetParts(m_nPanes, pPanesPos);
		ATLASSERT(nRet == m_nPanes);
		if(nRet != m_nPanes)
			return FALSE;
		// calculate offset
		RECT rcClient;
		GetClientRect(&rcClient);
		int cxOff = rcClient.right - (pPanesPos[m_nPanes - 1] + ::GetSystemMetrics(SM_CXVSCROLL) + ::GetSystemMetrics(SM_CXEDGE));
		// find variable width pane
		int i;
		for(i = 0; i < m_nPanes; i++)
		{
			if(m_pPane[i] == ID_DEFAULT_PANE)
				break;
		}
		// resize all panes from the variable one to the right
		if((i < m_nPanes) && (pPanesPos[i] + cxOff) > ((i == 0) ? 0 : pPanesPos[i - 1]))
		{
			for(; i < m_nPanes; i++)
				pPanesPos[i] += cxOff;
		}
		// set pane postions
		return SetParts(m_nPanes, pPanesPos);
	}

	int GetPaneIndexFromID(int nPaneID) const
	{
		for(int i = 0; i < m_nPanes; i++)
		{
			if(m_pPane[i] == nPaneID)
				return i;
		}

		return -1;	// not found
	}
};

class CMultiPaneStatusBarCtrl : public CMultiPaneStatusBarCtrlImpl<CMultiPaneStatusBarCtrl>
{
public:
	DECLARE_WND_SUPERCLASS(_T("WTL_MultiPaneStatusBar"), GetWndClassName())
};


/////////////////////////////////////////////////////////////////////////////
// CPaneContainer - provides header with title and close button for panes

// pane container extended styles
#define PANECNT_NOCLOSEBUTTON	0x00000001
#define PANECNT_VERTICAL	0x00000002

template <class T, class TBase /*= CWindow */, class TWinTraits /*= CControlWinTraits */ >
class ATL_NO_VTABLE CPaneContainerImpl : public CWindowImpl< T, TBase, TWinTraits >, public CCustomDraw< T >
{
public:
	DECLARE_WND_CLASS_EX(NULL, 0, -1)

// Constants
	enum
	{
		m_cxyBorder = 2,
		m_cxyTextOffset = 4,
		m_cxyBtnOffset = 1,

		m_cchTitle = 80,

		m_cxImageTB = 13,
		m_cyImageTB = 11,
		m_cxyBtnAddTB = 7,

		m_cxToolBar = m_cxImageTB + m_cxyBtnAddTB + m_cxyBorder + m_cxyBtnOffset,

		m_xBtnImageLeft = 6,
		m_yBtnImageTop = 5,
		m_xBtnImageRight = 12,
		m_yBtnImageBottom = 11,

		m_nCloseBtnID = ID_PANE_CLOSE
	};

// Data members
	CToolBarCtrl m_tb;
	CWindow m_wndClient;
	int m_cxyHeader;
	TCHAR m_szTitle[m_cchTitle];
	DWORD m_dwExtendedStyle;	// Pane container specific extended styles


// Constructor
	CPaneContainerImpl() : m_cxyHeader(0), m_dwExtendedStyle(0)
	{
		m_szTitle[0] = 0;
	}

// Attributes
	DWORD GetPaneContainerExtendedStyle() const
	{
		return m_dwExtendedStyle;
	}

	DWORD SetPaneContainerExtendedStyle(DWORD dwExtendedStyle, DWORD dwMask = 0)
	{
		DWORD dwPrevStyle = m_dwExtendedStyle;
		if(dwMask == 0)
			m_dwExtendedStyle = dwExtendedStyle;
		else
			m_dwExtendedStyle = (m_dwExtendedStyle & ~dwMask) | (dwExtendedStyle & dwMask);
		if(m_hWnd != NULL)
		{
			T* pT = static_cast<T*>(this);
			bool bUpdate = false;

			if(((dwPrevStyle & PANECNT_NOCLOSEBUTTON) != 0) && ((dwExtendedStyle & PANECNT_NOCLOSEBUTTON) == 0))	// add close button
			{
				pT->CreateCloseButton();
				bUpdate = true;
			}
			else if(((dwPrevStyle & PANECNT_NOCLOSEBUTTON) == 0) && ((dwExtendedStyle & PANECNT_NOCLOSEBUTTON) != 0))	// remove close button
			{
				pT->DestroyCloseButton();
				bUpdate = true;
			}

			if((dwPrevStyle & PANECNT_VERTICAL) != (dwExtendedStyle & PANECNT_VERTICAL))	// change orientation
			{
				CalcSize();
				bUpdate = true;
			}

			if(bUpdate)
				pT->UpdateLayout();
		}
		return dwPrevStyle;
	}

	HWND GetClient() const
	{
		return m_wndClient;
	}

	HWND SetClient(HWND hWndClient)
	{
		HWND hWndOldClient = m_wndClient;
		m_wndClient = hWndClient;
		if(m_hWnd != NULL)
		{
			T* pT = static_cast<T*>(this);
			pT->UpdateLayout();
		}
		return hWndOldClient;
	}

	BOOL GetTitle(LPTSTR lpstrTitle, int cchLength) const
	{
		ATLASSERT(lpstrTitle != NULL);
		return (lstrcpyn(lpstrTitle, m_szTitle, cchLength) != NULL);
	}

	BOOL SetTitle(LPCTSTR lpstrTitle)
	{
		ATLASSERT(lpstrTitle != NULL);
		BOOL bRet = (lstrcpyn(m_szTitle, lpstrTitle, m_cchTitle) != NULL);
		if(bRet && m_hWnd != NULL)
		{
			T* pT = static_cast<T*>(this);
			pT->UpdateLayout();
		}
		return bRet;
	}

	int GetTitleLength() const
	{
		return lstrlen(m_szTitle);
	}

// Methods
	HWND Create(HWND hWndParent, LPCTSTR lpstrTitle = NULL, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
			DWORD dwExStyle = 0, UINT nID = 0, LPVOID lpCreateParam = NULL)
	{
		if(lpstrTitle != NULL)
			lstrcpyn(m_szTitle, lpstrTitle, m_cchTitle);
		return CWindowImpl< T, TBase, TWinTraits >::Create(hWndParent, rcDefault, NULL, dwStyle, dwExStyle, nID, lpCreateParam);
	}

	HWND Create(HWND hWndParent, UINT uTitleID, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
			DWORD dwExStyle = 0, UINT nID = 0, LPVOID lpCreateParam = NULL)
	{
		if(uTitleID != 0U)
			::LoadString(_Module.GetResourceInstance(), uTitleID, m_szTitle, m_cchTitle);
		return CWindowImpl< T, TBase, TWinTraits >::Create(hWndParent, rcDefault, NULL, dwStyle, dwExStyle, nID, lpCreateParam);
	}

	BOOL EnableCloseButton(BOOL bEnable)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		pT;	// avoid level 4 warning
		return (m_tb.m_hWnd != NULL) ? m_tb.EnableButton(pT->m_nCloseBtnID, bEnable) : FALSE;
	}

	void UpdateLayout()
	{
		RECT rcClient;
		GetClientRect(&rcClient);
		T* pT = static_cast<T*>(this);
		pT->UpdateLayout(rcClient.right, rcClient.bottom);
	}

// Message map and handlers
	BEGIN_MSG_MAP(CPaneContainerImpl)
		MESSAGE_HANDLER(WM_CREATE, OnCreate)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
		MESSAGE_HANDLER(WM_PAINT, OnPaint)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
		MESSAGE_HANDLER(WM_COMMAND, OnCommand)
		FORWARD_NOTIFICATIONS()
	END_MSG_MAP()

	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->CalcSize();

		if((m_dwExtendedStyle & PANECNT_NOCLOSEBUTTON) == 0)
			pT->CreateCloseButton();

		return 0;
	}

	LRESULT OnSize(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->UpdateLayout(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
		return 0;
	}

	LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		if(m_wndClient.m_hWnd != NULL)
			m_wndClient.SetFocus();
		return 0;
	}

	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		return 1;	// no background needed
	}

	LRESULT OnPaint(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		CPaintDC dc(m_hWnd);

		T* pT = static_cast<T*>(this);
		pT->DrawPaneTitle(dc.m_hDC);

		if(m_wndClient.m_hWnd == NULL)	// no client window
			pT->DrawPane(dc.m_hDC);

		return 0;
	}

	LRESULT OnNotify(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		if(m_tb.m_hWnd == NULL)
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = static_cast<T*>(this);
		LPNMHDR lpnmh = (LPNMHDR)lParam;
		LRESULT lRet = 0;

		// pass toolbar custom draw notifications to the base class
		if(lpnmh->code == NM_CUSTOMDRAW && lpnmh->hwndFrom == m_tb.m_hWnd)
			lRet = CCustomDraw< T >::OnCustomDraw(0, lpnmh, bHandled);
		// tooltip notifications come with the tooltip window handle and button ID,
		// pass them to the parent if we don't handle them
		else if(lpnmh->code == TTN_GETDISPINFO && lpnmh->idFrom == pT->m_nCloseBtnID)
			bHandled = pT->GetToolTipText(lpnmh);
		// only let notifications not from the toolbar go to the parent
		else if(lpnmh->hwndFrom != m_tb.m_hWnd && lpnmh->idFrom != pT->m_nCloseBtnID)
			bHandled = FALSE;

		return lRet;
	}

	LRESULT OnCommand(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		// if command comes from the close button, substitute HWND of the pane container instead
		if(m_tb.m_hWnd != NULL && (HWND)lParam == m_tb.m_hWnd)
			return ::SendMessage(GetParent(), WM_COMMAND, wParam, (LPARAM)m_hWnd);

		bHandled = FALSE;
		return 1;
	}

// Custom draw overrides
	DWORD OnPrePaint(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
	{
		return CDRF_NOTIFYITEMDRAW;	// we need per-item notifications
	}

	DWORD OnItemPrePaint(int /*idCtrl*/, LPNMCUSTOMDRAW lpNMCustomDraw)
	{
		CDCHandle dc = lpNMCustomDraw->hdc;
#if (_WIN32_IE >= 0x0400)
		RECT& rc = lpNMCustomDraw->rc;
#else //!(_WIN32_IE >= 0x0400)
		RECT rc;
		m_tb.GetItemRect(0, &rc);
#endif //!(_WIN32_IE >= 0x0400)

		dc.FillRect(&rc, (HBRUSH)LongToPtr(COLOR_3DFACE + 1));

		return CDRF_NOTIFYPOSTPAINT;
	}

	DWORD OnItemPostPaint(int /*idCtrl*/, LPNMCUSTOMDRAW lpNMCustomDraw)
	{
		CDCHandle dc = lpNMCustomDraw->hdc;
#if (_WIN32_IE >= 0x0400)
		RECT& rc = lpNMCustomDraw->rc;
#else //!(_WIN32_IE >= 0x0400)
		RECT rc;
		m_tb.GetItemRect(0, &rc);
#endif //!(_WIN32_IE >= 0x0400)

		RECT rcImage = { m_xBtnImageLeft, m_yBtnImageTop, m_xBtnImageRight + 1, m_yBtnImageBottom + 1 };
		::OffsetRect(&rcImage, rc.left, rc.top);
		T* pT = static_cast<T*>(this);

		if((lpNMCustomDraw->uItemState & CDIS_DISABLED) != 0)
		{
			RECT rcShadow = rcImage;
			::OffsetRect(&rcShadow, 1, 1);
			CPen pen1;
			pen1.CreatePen(PS_SOLID, 0, ::GetSysColor(COLOR_3DHILIGHT));
			pT->DrawButtonImage(dc, rcShadow, pen1);
			CPen pen2;
			pen2.CreatePen(PS_SOLID, 0, ::GetSysColor(COLOR_3DSHADOW));
			pT->DrawButtonImage(dc, rcImage, pen2);
		}
		else
		{
			if((lpNMCustomDraw->uItemState & CDIS_SELECTED) != 0)
				::OffsetRect(&rcImage, 1, 1);
			CPen pen;
			pen.CreatePen(PS_SOLID, 0, ::GetSysColor(COLOR_BTNTEXT));
			pT->DrawButtonImage(dc, rcImage, pen);
		}

		return CDRF_DODEFAULT;	// continue with the default item painting
	}

// Implementation - overrideable methods
	void UpdateLayout(int cxWidth, int cyHeight)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		RECT rect;

		if(IsVertical())
		{
			::SetRect(&rect, 0, 0, m_cxyHeader, cyHeight);
			if(m_tb.m_hWnd != NULL)
				m_tb.SetWindowPos(NULL, m_cxyBorder, m_cxyBorder + m_cxyBtnOffset, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);

			if(m_wndClient.m_hWnd != NULL)
				m_wndClient.SetWindowPos(NULL, m_cxyHeader, 0, cxWidth - m_cxyHeader, cyHeight, SWP_NOZORDER);
			else
				rect.right = cxWidth;
		}
		else
		{
			::SetRect(&rect, 0, 0, cxWidth, m_cxyHeader);
			if(m_tb.m_hWnd != NULL)
				m_tb.SetWindowPos(NULL, rect.right - m_cxToolBar, m_cxyBorder + m_cxyBtnOffset, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);

			if(m_wndClient.m_hWnd != NULL)
				m_wndClient.SetWindowPos(NULL, 0, m_cxyHeader, cxWidth, cyHeight - m_cxyHeader, SWP_NOZORDER);
			else
				rect.bottom = cyHeight;
		}

		InvalidateRect(&rect);
	}

	void CreateCloseButton()
	{
		ATLASSERT(m_tb.m_hWnd == NULL);
		// create toolbar for the "x" button
		m_tb.Create(m_hWnd, rcDefault, NULL, WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NORESIZE | CCS_NOPARENTALIGN | CCS_NOMOVEY | TBSTYLE_TOOLTIPS | TBSTYLE_FLAT, 0);
		ATLASSERT(m_tb.IsWindow());

		if(m_tb.m_hWnd != NULL)
		{
			T* pT = static_cast<T*>(this);
			pT;	// avoid level 4 warning

			m_tb.SetButtonStructSize();

			TBBUTTON tbbtn;
			memset(&tbbtn, 0, sizeof(tbbtn));
			tbbtn.idCommand = pT->m_nCloseBtnID;
			tbbtn.fsState = TBSTATE_ENABLED;
			tbbtn.fsStyle = TBSTYLE_BUTTON;
			m_tb.AddButtons(1, &tbbtn);

			m_tb.SetBitmapSize(m_cxImageTB, m_cyImageTB);
			m_tb.SetButtonSize(m_cxImageTB + m_cxyBtnAddTB, m_cyImageTB + m_cxyBtnAddTB);

			if(IsVertical())
				m_tb.SetWindowPos(NULL, m_cxyBorder + m_cxyBtnOffset, m_cxyBorder + m_cxyBtnOffset, m_cxImageTB + m_cxyBtnAddTB, m_cyImageTB + m_cxyBtnAddTB, SWP_NOZORDER | SWP_NOACTIVATE);
			else
				m_tb.SetWindowPos(NULL, 0, 0, m_cxImageTB + m_cxyBtnAddTB, m_cyImageTB + m_cxyBtnAddTB, SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);
		}
	}

	void DestroyCloseButton()
	{
		if(m_tb.m_hWnd != NULL)
			m_tb.DestroyWindow();
	}

	void CalcSize()
	{
		T* pT = static_cast<T*>(this);
		CFontHandle font = pT->GetTitleFont();
		LOGFONT lf;
		font.GetLogFont(lf);
		if(IsVertical())
		{
			m_cxyHeader = m_cxImageTB + m_cxyBtnAddTB + m_cxyBorder;
		}
		else
		{
			int cyFont = abs(lf.lfHeight) + m_cxyBorder + 2 * m_cxyTextOffset;
			int cyBtn = m_cyImageTB + m_cxyBtnAddTB + m_cxyBorder + 2 * m_cxyBtnOffset;
			m_cxyHeader = max(cyFont, cyBtn);
		}
	}

	HFONT GetTitleFont() const
	{
		return AtlGetDefaultGuiFont();
	}

	BOOL GetToolTipText(LPNMHDR /*lpnmh*/)
	{
		return FALSE;
	}

	void DrawPaneTitle(CDCHandle dc)
	{
		RECT rect;
		GetClientRect(&rect);

		if(IsVertical())
		{
			rect.right = rect.left + m_cxyHeader;
			dc.DrawEdge(&rect, EDGE_ETCHED, BF_LEFT | BF_TOP | BF_BOTTOM | BF_ADJUST);
			dc.FillRect(&rect, (HBRUSH)LongToPtr(COLOR_3DFACE + 1));
		}
		else
		{
			rect.bottom = rect.top + m_cxyHeader;
			dc.DrawEdge(&rect, EDGE_ETCHED, BF_LEFT | BF_TOP | BF_RIGHT | BF_ADJUST);
			dc.FillRect(&rect, (HBRUSH)LongToPtr(COLOR_3DFACE + 1));
			// draw title only for horizontal pane container
			dc.SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
			dc.SetBkMode(TRANSPARENT);
			T* pT = static_cast<T*>(this);
			HFONT hFontOld = dc.SelectFont(pT->GetTitleFont());
			rect.left += m_cxyTextOffset;
			rect.right -= m_cxyTextOffset;
			if(m_tb.m_hWnd != NULL)
				rect.right -= m_cxToolBar;;
			dc.DrawText(m_szTitle, -1, &rect, DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);
			dc.SelectFont(hFontOld);
		}
	}

	// called only if pane is empty
	void DrawPane(CDCHandle dc)
	{
		RECT rect;
		GetClientRect(&rect);
		if(IsVertical())
			rect.left += m_cxyHeader;
		else
			rect.top += m_cxyHeader;
		if((GetExStyle() & WS_EX_CLIENTEDGE) == 0)
			dc.DrawEdge(&rect, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
		dc.FillRect(&rect, (HBRUSH)LongToPtr(COLOR_APPWORKSPACE + 1));
	}

	// drawing helper - draws "x" button image
	void DrawButtonImage(CDCHandle dc, RECT& rcImage, HPEN hPen)
	{
		HPEN hPenOld = dc.SelectPen(hPen);

		dc.MoveTo(rcImage.left, rcImage.top);
		dc.LineTo(rcImage.right, rcImage.bottom);
		dc.MoveTo(rcImage.left + 1, rcImage.top);
		dc.LineTo(rcImage.right + 1, rcImage.bottom);

		dc.MoveTo(rcImage.left, rcImage.bottom - 1);
		dc.LineTo(rcImage.right, rcImage.top - 1);
		dc.MoveTo(rcImage.left + 1, rcImage.bottom - 1);
		dc.LineTo(rcImage.right + 1, rcImage.top - 1);

		dc.SelectPen(hPenOld);
	}

	bool IsVertical() const
	{
		return ((m_dwExtendedStyle & PANECNT_VERTICAL) != 0);
	}
};

class CPaneContainer : public CPaneContainerImpl<CPaneContainer>
{
public:
	DECLARE_WND_CLASS_EX(_T("WTL_PaneContainer"), 0, -1)
};

}; //namespace WTL

#endif // __ATLCTRLX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wtl10\atldlgs.h ===
// WTL Version 3.1
// Copyright (C) 1997-2000 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLDLGS_H__
#define __ATLDLGS_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atldlgs.h requires atlapp.h to be included first
#endif

#ifndef __ATLWIN_H__
	#error atldlgs.h requires atlwin.h to be included first
#endif

#include <commdlg.h>
#include <shlobj.h>


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T> class CFileDialogImpl;
class CFileDialog;
template <class T> class CFolderDialogImpl;
class CFolderDialog;
template <class T> class CFontDialogImpl;
class CFontDialog;
#ifdef _RICHEDIT_
template <class T> class CRichEditFontDialogImpl;
class CRichEditFontDialog;
#endif //_RICHEDIT_
template <class T> class CColorDialogImpl;
class CColorDialog;
template <class T> class CPrintDialogImpl;
class CPrintDialog;
template <class T> class CPageSetupDialogImpl;
#if (WINVER >= 0x0500)
template <class T> class CPrintDialogExImpl;
class CPrintDialogEx;
#endif //(WINVER >= 0x0500)
class CPageSetupDialog;
template <class T> class CFindReplaceDialogImpl;
class CFindReplaceDialog;

class CPropertySheetWindow;
template <class T, class TBase = CPropertySheetWindow> class CPropertySheetImpl;
class CPropertySheet;
class CPropertyPageWindow;
template <class T, class TBase = CPropertyPageWindow> class CPropertyPageImpl;
template <WORD t_wDlgTemplateID> class CPropertyPage;

/////////////////////////////////////////////////////////////////////////////
// CFileDialogImpl - used for File Open or File Save As

// compatibility with the old (vc6.0) headers
#if (_WIN32_WINNT >= 0x0500) && !defined(OPENFILENAME_SIZE_VERSION_400)
#ifndef CDSIZEOF_STRUCT
#define CDSIZEOF_STRUCT(structname, member)  (((int)((LPBYTE)(&((structname*)0)->member) - ((LPBYTE)((structname*)0)))) + sizeof(((structname*)0)->member))
#endif
#define OPENFILENAME_SIZE_VERSION_400A  CDSIZEOF_STRUCT(OPENFILENAMEA,lpTemplateName)
#define OPENFILENAME_SIZE_VERSION_400W  CDSIZEOF_STRUCT(OPENFILENAMEW,lpTemplateName)
#ifdef UNICODE
#define OPENFILENAME_SIZE_VERSION_400  OPENFILENAME_SIZE_VERSION_400W
#else
#define OPENFILENAME_SIZE_VERSION_400  OPENFILENAME_SIZE_VERSION_400A
#endif // !UNICODE
#endif // (_WIN32_WINNT >= 0x0500) && !defined(OPENFILENAME_SIZE_VERSION_400)

template <class T>
class ATL_NO_VTABLE CFileDialogImpl : public CDialogImplBase
{
public:
	OPENFILENAME m_ofn;
	BOOL m_bOpenFileDialog;			// TRUE for file open, FALSE for file save
	TCHAR m_szFileTitle[_MAX_FNAME];	// contains file title after return
	TCHAR m_szFileName[_MAX_PATH];		// contains full path name after return

	CFileDialogImpl(BOOL bOpenFileDialog, // TRUE for FileOpen, FALSE for FileSaveAs
			LPCTSTR lpszDefExt = NULL,
			LPCTSTR lpszFileName = NULL,
			DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
			LPCTSTR lpszFilter = NULL,
			HWND hWndParent = NULL)
	{
		memset(&m_ofn, 0, sizeof(m_ofn)); // initialize structure to 0/NULL
		m_szFileName[0] = '\0';
		m_szFileTitle[0] = '\0';

		m_bOpenFileDialog = bOpenFileDialog;

		m_ofn.lStructSize = sizeof(m_ofn);
#if (_WIN32_WINNT >= 0x0500)
		// adjust struct size if running on older version of Windows
		if(AtlIsOldWindows())
		{
			ATLASSERT(sizeof(m_ofn) > OPENFILENAME_SIZE_VERSION_400);	// must be
			m_ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
		}
#endif //(_WIN32_WINNT >= 0x0500)
		m_ofn.lpstrFile = m_szFileName;
		m_ofn.nMaxFile = _MAX_PATH;
		m_ofn.lpstrDefExt = lpszDefExt;
		m_ofn.lpstrFileTitle = (LPTSTR)m_szFileTitle;
		m_ofn.nMaxFileTitle = _MAX_FNAME;
		m_ofn.Flags |= dwFlags | OFN_EXPLORER | OFN_ENABLEHOOK | OFN_ENABLESIZING;
		m_ofn.lpstrFilter = lpszFilter;
		m_ofn.hInstance = _Module.GetResourceInstance();
		m_ofn.lpfnHook = (LPOFNHOOKPROC)T::StartDialogProc;
		m_ofn.hwndOwner = hWndParent;

		// setup initial file name
		if(lpszFileName != NULL)
			lstrcpyn(m_szFileName, lpszFileName, _MAX_PATH);
	}

	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_ofn.Flags & OFN_ENABLEHOOK);
		ATLASSERT(m_ofn.lpfnHook != NULL);	// can still be a user hook

		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		if(m_ofn.hwndOwner == NULL)		// set only if not specified before
			m_ofn.hwndOwner = hWndParent;

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CDialogImplBase*)this);

		BOOL bRet;
		if(m_bOpenFileDialog)
			bRet = ::GetOpenFileName(&m_ofn);
		else
			bRet = ::GetSaveFileName(&m_ofn);

		m_hWnd = NULL;

		return bRet ? IDOK : IDCANCEL;
	}

// Attributes
	CWindow GetFileDialogWindow() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CWindow(GetParent());
	}

	int GetFilePath(LPTSTR lpstrFilePath, int nLength) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		return (int)GetFileDialogWindow().SendMessage(CDM_GETFILEPATH, nLength, (LPARAM)lpstrFilePath);
	}

	int GetFolderIDList(LPVOID lpBuff, int nLength) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		return (int)GetFileDialogWindow().SendMessage(CDM_GETFOLDERIDLIST, nLength, (LPARAM)lpBuff);
	}

	int GetFolderPath(LPTSTR lpstrFolderPath, int nLength) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		return (int)GetFileDialogWindow().SendMessage(CDM_GETFOLDERPATH, nLength, (LPARAM)lpstrFolderPath);
	}

	int GetSpec(LPTSTR lpstrSpec, int nLength) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		return (int)GetFileDialogWindow().SendMessage(CDM_GETSPEC, nLength, (LPARAM)lpstrSpec);
	}

	void SetControlText(int nCtrlID, LPCTSTR lpstrText)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		GetFileDialogWindow().SendMessage(CDM_SETCONTROLTEXT, nCtrlID, (LPARAM)lpstrText);
	}

	void SetDefExt(LPCTSTR lpstrExt)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		GetFileDialogWindow().SendMessage(CDM_SETDEFEXT, 0, (LPARAM)lpstrExt);
	}

	BOOL GetReadOnlyPref() const	// return TRUE if readonly checked
	{
		return m_ofn.Flags & OFN_READONLY ? TRUE : FALSE;
	}

// Operations
	void HideControl(int nCtrlID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(m_ofn.Flags & OFN_EXPLORER);

		GetFileDialogWindow().SendMessage(CDM_HIDECONTROL, nCtrlID);
	}

// Special override for common dialogs
	BOOL EndDialog(INT_PTR /*nRetCode*/ = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		GetFileDialogWindow().SendMessage(WM_COMMAND, MAKEWPARAM(IDCANCEL, 0));
		return TRUE;
	}

// Message map and handlers
	BEGIN_MSG_MAP(CFileDialogImpl< T >)
		NOTIFY_CODE_HANDLER(CDN_FILEOK, _OnFileOK)
		NOTIFY_CODE_HANDLER(CDN_FOLDERCHANGE, _OnFolderChange)
		NOTIFY_CODE_HANDLER(CDN_HELP, _OnHelp)
		NOTIFY_CODE_HANDLER(CDN_INITDONE, _OnInitDone)
		NOTIFY_CODE_HANDLER(CDN_SELCHANGE, _OnSelChange)
		NOTIFY_CODE_HANDLER(CDN_SHAREVIOLATION, _OnShareViolation)
		NOTIFY_CODE_HANDLER(CDN_TYPECHANGE, _OnTypeChange)
	END_MSG_MAP()

	LRESULT _OnFileOK(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		return !pT->OnFileOK((LPOFNOTIFY)pnmh);
	}
	LRESULT _OnFolderChange(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		pT->OnFolderChange((LPOFNOTIFY)pnmh);
		return 0;
	}
	LRESULT _OnHelp(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		pT->OnHelp((LPOFNOTIFY)pnmh);
		return 0;
	}
	LRESULT _OnInitDone(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		pT->OnInitDone((LPOFNOTIFY)pnmh);
		return 0;
	}
	LRESULT _OnSelChange(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		pT->OnSelChange((LPOFNOTIFY)pnmh);
		return 0;
	}
	LRESULT _OnShareViolation(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		return pT->OnShareViolation((LPOFNOTIFY)pnmh);
	}
	LRESULT _OnTypeChange(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		T* pT = static_cast<T*>(this);
		pT->OnTypeChange((LPOFNOTIFY)pnmh);
		return 0;
	}

// Overrideables
	BOOL OnFileOK(LPOFNOTIFY /*lpon*/)
	{
		return TRUE;
	}
	void OnFolderChange(LPOFNOTIFY /*lpon*/)
	{
	}
	void OnHelp(LPOFNOTIFY /*lpon*/)
	{
	}
	void OnInitDone(LPOFNOTIFY /*lpon*/)
	{
	}
	void OnSelChange(LPOFNOTIFY /*lpon*/)
	{
	}
	int OnShareViolation(LPOFNOTIFY /*lpon*/)
	{
		return 0;
	}
	void OnTypeChange(LPOFNOTIFY /*lpon*/)
	{
	}
};


class CFileDialog : public CFileDialogImpl<CFileDialog>
{
public:
	CFileDialog(BOOL bOpenFileDialog, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCTSTR lpszFilter = NULL,
		HWND hWndParent = NULL)
		: CFileDialogImpl<CFileDialog>(bOpenFileDialog, lpszDefExt, lpszFileName, dwFlags, lpszFilter, hWndParent)
	{ }

	// override base class map and references to handlers
	DECLARE_EMPTY_MSG_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFolderDialogImpl - used for browsing for a folder

template <class T>
class ATL_NO_VTABLE CFolderDialogImpl
{
public:
	BROWSEINFO m_bi;
	TCHAR m_szFolderDisplayName[MAX_PATH];
	TCHAR m_szFolderPath[MAX_PATH];
	HWND m_hWnd;	// used only in the callback function

// Constructor
	CFolderDialogImpl(HWND hWndParent = NULL, LPCTSTR lpstrTitle = NULL, UINT uFlags = BIF_RETURNONLYFSDIRS)
	{
		memset(&m_bi, 0, sizeof(m_bi)); // initialize structure to 0/NULL

		m_bi.hwndOwner = hWndParent;
		m_bi.pidlRoot = NULL;
		m_bi.pszDisplayName = m_szFolderDisplayName;
		m_bi.lpszTitle = lpstrTitle;
		m_bi.ulFlags = uFlags;
		m_bi.lpfn = BrowseCallbackProc;
		m_bi.lParam = (LPARAM)this;

		m_szFolderPath[0] = 0;
		m_szFolderDisplayName[0] = 0;

		m_hWnd = NULL;
	}

// Operations
	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		if(m_bi.hwndOwner == NULL)	// set only if not specified before
			m_bi.hwndOwner = hWndParent;

		INT_PTR nRet = -1;
		LPITEMIDLIST pItemIDList = ::SHBrowseForFolder(&m_bi);
		if(pItemIDList != NULL)
		{
			if(::SHGetPathFromIDList(pItemIDList, m_szFolderPath))
			{
				IMalloc* pMalloc = NULL;
				if(SUCCEEDED(::SHGetMalloc(&pMalloc)))
				{
					pMalloc->Free(pItemIDList);
					pMalloc->Release();
				}
				nRet = IDOK;
			}
			else
			{
				nRet = IDCANCEL;
			}
		}
		return nRet;
	}

	// filled after a call to DoModal
	LPCTSTR GetFolderPath() const
	{
		return m_szFolderPath;
	}
	LPCTSTR GetFolderDisplayName() const
	{
		return m_szFolderDisplayName;
	}
	int GetFolderImageIndex() const
	{
		return m_bi.iImage;
	}

// Callback function and overrideables
	static int CALLBACK BrowseCallbackProc(HWND hWnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
	{
#ifndef BFFM_VALIDATEFAILED
#ifdef UNICODE
		const int BFFM_VALIDATEFAILED = 4;
#else
		const int BFFM_VALIDATEFAILED = 3;
#endif
#endif //!BFFM_VALIDATEFAILED
		int nRet = 0;
		T* pT = (T*)lpData;
		pT->m_hWnd = hWnd;
		switch(uMsg)
		{
		case BFFM_INITIALIZED:
			pT->OnInitialized();
			break;
		case BFFM_SELCHANGED:
			pT->OnSelChanged((LPITEMIDLIST)lParam);
			break;
		case BFFM_VALIDATEFAILED:
			nRet = pT->OnValidateFailed((LPCTSTR)lParam);
			break;
		default:
			ATLTRACE2(atlTraceUI, 0, _T("Unknown message received in CFolderDialogImpl::BrowseCallbackProc\n"));
			break;
		}
		pT->m_hWnd = NULL;
		return nRet;
	}
	void OnInitialized()
	{
	}
	void OnSelChanged(LPITEMIDLIST /*pItemIDList*/)
	{
	}
	int OnValidateFailed(LPCTSTR /*lpstrFolderPath*/)
	{
		return 1;	// 1=continue, 0=EndDialog
	}

	// Commands - valid to call only from handlers
	void EnableOK(BOOL bEnable)
	{
		ATLASSERT(m_hWnd != NULL);
		::SendMessage(m_hWnd, BFFM_ENABLEOK, bEnable, 0L);
	}
	void SetSelection(LPITEMIDLIST pItemIDList)
	{
		ATLASSERT(m_hWnd != NULL);
		::SendMessage(m_hWnd, BFFM_SETSELECTION, FALSE, (LPARAM)pItemIDList);
	}
	void SetSelection(LPCTSTR lpstrFolderPath)
	{
		ATLASSERT(m_hWnd != NULL);
		::SendMessage(m_hWnd, BFFM_SETSELECTION, TRUE, (LPARAM)lpstrFolderPath);
	}
	void SetStatusText(LPCTSTR lpstrText)
	{
		ATLASSERT(m_hWnd != NULL);
		::SendMessage(m_hWnd, BFFM_SETSTATUSTEXT, 0, (LPARAM)lpstrText);
	}
};

class CFolderDialog : public CFolderDialogImpl<CFolderDialog>
{
public:
	CFolderDialog(HWND hWndParent = NULL, LPCTSTR lpstrTitle = NULL, UINT uFlags = BIF_RETURNONLYFSDIRS)
		: CFolderDialogImpl<CFolderDialog>(hWndParent, lpstrTitle, uFlags)
	{
		m_bi.lpfn = NULL;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CCommonDialogImplBase - base class for common dialog classes

class ATL_NO_VTABLE CCommonDialogImplBase : public CWindowImplBase
{
public:
	static UINT_PTR APIENTRY HookProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		if(uMsg != WM_INITDIALOG)
			return 0;
		CCommonDialogImplBase* pT = (CCommonDialogImplBase*)_Module.ExtractCreateWndData();
		ATLASSERT(pT != NULL);
		ATLASSERT(pT->m_hWnd == NULL);
		ATLASSERT(::IsWindow(hWnd));
		// subclass dialog's window
		if(!pT->SubclassWindow(hWnd))
		{
			ATLTRACE2(atlTraceUI, 0, _T("Subclassing a common dialog failed\n"));
			return 0;
		}
		// check message map for WM_INITDIALOG handler
		LRESULT lRes;
		if(pT->ProcessWindowMessage(pT->m_hWnd, uMsg, wParam, lParam, lRes, 0) == FALSE)
			return 0;
		return lRes;
	}

// Special override for common dialogs
	BOOL EndDialog(INT_PTR /*nRetCode*/ = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		SendMessage(WM_COMMAND, MAKEWPARAM(IDABORT, 0));
		return TRUE;
	}

// Implementation - try to override these, to prevent errors
	HWND Create(HWND, _U_RECT, LPCTSTR, DWORD, DWORD, _U_MENUorID, ATOM, LPVOID)
	{
		ATLASSERT(FALSE);	// should not be called
		return NULL;
	}
	static LRESULT CALLBACK StartWindowProc(HWND /*hWnd*/, UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/)
	{
		ATLASSERT(FALSE);	// should not be called
		return 0;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CFontDialogImpl - font selection dialog

template <class T>
class ATL_NO_VTABLE CFontDialogImpl : public CCommonDialogImplBase
{
public:
	CHOOSEFONT m_cf;
	TCHAR m_szStyleName[64];	// contains style name after return
	LOGFONT m_lf;			// default LOGFONT to store the info

// Constructors
	CFontDialogImpl(LPLOGFONT lplfInitial = NULL,
			DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
			HDC hDCPrinter = NULL,
			HWND hWndParent = NULL)
	{
		memset(&m_cf, 0, sizeof(m_cf));
		memset(&m_lf, 0, sizeof(m_lf));
		memset(&m_szStyleName, 0, sizeof(m_szStyleName));

		m_cf.lStructSize = sizeof(m_cf);
		m_cf.hwndOwner = hWndParent;
		m_cf.rgbColors = RGB(0, 0, 0);
		m_cf.lpszStyle = (LPTSTR)&m_szStyleName;
		m_cf.Flags = dwFlags | CF_ENABLEHOOK;
		m_cf.lpfnHook = (LPCFHOOKPROC)T::HookProc;

		if(lplfInitial != NULL)
		{
			m_cf.lpLogFont = lplfInitial;
			m_cf.Flags |= CF_INITTOLOGFONTSTRUCT;
			memcpy(&m_lf, m_cf.lpLogFont, sizeof(m_lf));
		}
		else
		{
			m_cf.lpLogFont = &m_lf;
		}

		if(hDCPrinter != NULL)
		{
			m_cf.hDC = hDCPrinter;
			m_cf.Flags |= CF_PRINTERFONTS;
		}
	}

// Operations
	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_cf.Flags & CF_ENABLEHOOK);
		ATLASSERT(m_cf.lpfnHook != NULL);	// can still be a user hook

		if(m_cf.hwndOwner == NULL)		// set only if not specified before
			m_cf.hwndOwner = hWndParent;

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);

		BOOL bRet = ::ChooseFont(&m_cf);

		m_hWnd = NULL;

		if(bRet)	// copy logical font from user's initialization buffer (if needed)
			memcpy(&m_lf, m_cf.lpLogFont, sizeof(m_lf));

		return bRet ? IDOK : IDCANCEL;
	}

	// Get the selected font (works during DoModal displayed or after)
	void GetCurrentFont(LPLOGFONT lplf) const
	{
		ATLASSERT(lplf != NULL);

		if(m_hWnd != NULL)
			::SendMessage(m_hWnd, WM_CHOOSEFONT_GETLOGFONT, 0, (LPARAM)lplf);
		else
			*lplf = m_lf;
	}

	// Helpers for parsing information after successful return
	LPCTSTR GetFaceName() const   // return the face name of the font
	{
		return (LPCTSTR)m_cf.lpLogFont->lfFaceName;
	}
	LPCTSTR GetStyleName() const  // return the style name of the font
	{
		return m_cf.lpszStyle;
	}
	int GetSize() const           // return the pt size of the font
	{
		return m_cf.iPointSize;
	}
	COLORREF GetColor() const     // return the color of the font
	{
		return m_cf.rgbColors;
	}
	int GetWeight() const         // return the chosen font weight
	{
		return (int)m_cf.lpLogFont->lfWeight;
	}
	BOOL IsStrikeOut() const      // return TRUE if strikeout
	{
		return m_cf.lpLogFont->lfStrikeOut ? TRUE : FALSE;
	}
	BOOL IsUnderline() const      // return TRUE if underline
	{
		return m_cf.lpLogFont->lfUnderline ? TRUE : FALSE;
	}
	BOOL IsBold() const           // return TRUE if bold font
	{
		return m_cf.lpLogFont->lfWeight == FW_BOLD ? TRUE : FALSE;
	}
	BOOL IsItalic() const         // return TRUE if italic font
	{
		return m_cf.lpLogFont->lfItalic ? TRUE : FALSE;
	}
};

class CFontDialog : public CFontDialogImpl<CFontDialog>
{
public:
	CFontDialog(LPLOGFONT lplfInitial = NULL,
		DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
		HDC hDCPrinter = NULL,
		HWND hWndParent = NULL)
		: CFontDialogImpl<CFontDialog>(lplfInitial, dwFlags, hDCPrinter, hWndParent)
	{ }

	DECLARE_EMPTY_MSG_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CRichEditFontDialogImpl - font selection for the Rich Edit ctrl

#ifdef _RICHEDIT_

template <class T>
class ATL_NO_VTABLE CRichEditFontDialogImpl : public CFontDialogImpl< T >
{
public:
	CRichEditFontDialogImpl(const CHARFORMAT& charformat,
			DWORD dwFlags = CF_SCREENFONTS,
			HDC hDCPrinter = NULL,
			HWND hWndParent = NULL)
			: CFontDialogImpl< T >(NULL, dwFlags, hDCPrinter, hWndParent)
	{
		m_cf.Flags |= CF_INITTOLOGFONTSTRUCT;
		m_cf.Flags |= FillInLogFont(charformat);
		m_cf.lpLogFont = &m_lf;

		if(charformat.dwMask & CFM_COLOR)
			m_cf.rgbColors = charformat.crTextColor;
	}

	void GetCharFormat(CHARFORMAT& cf) const
	{
		USES_CONVERSION;
		cf.dwEffects = 0;
		cf.dwMask = 0;
		if((m_cf.Flags & CF_NOSTYLESEL) == 0)
		{
			cf.dwMask |= CFM_BOLD | CFM_ITALIC;
			cf.dwEffects |= (IsBold()) ? CFE_BOLD : 0;
			cf.dwEffects |= (IsItalic()) ? CFE_ITALIC : 0;
		}
		if((m_cf.Flags & CF_NOSIZESEL) == 0)
		{
			cf.dwMask |= CFM_SIZE;
			//GetSize() returns in tenths of points so mulitply by 2 to get twips
			cf.yHeight = GetSize() * 2;
		}

		if((m_cf.Flags & CF_NOFACESEL) == 0)
		{
			cf.dwMask |= CFM_FACE;
			cf.bPitchAndFamily = m_cf.lpLogFont->lfPitchAndFamily;
#if (_RICHEDIT_VER >= 0x0200)
			lstrcpy(cf.szFaceName, GetFaceName());
#else
			lstrcpyA(cf.szFaceName, T2A((LPTSTR)(LPCTSTR)GetFaceName()));
#endif //(_RICHEDIT_VER >= 0x0200)
		}

		if(m_cf.Flags & CF_EFFECTS)
		{
			cf.dwMask |= CFM_UNDERLINE | CFM_STRIKEOUT | CFM_COLOR;
			cf.dwEffects |= (IsUnderline()) ? CFE_UNDERLINE : 0;
			cf.dwEffects |= (IsStrikeOut()) ? CFE_STRIKEOUT : 0;
			cf.crTextColor = GetColor();
		}
		if((m_cf.Flags & CF_NOSCRIPTSEL) == 0)
		{
			cf.bCharSet = m_cf.lpLogFont->lfCharSet;
			cf.dwMask |= CFM_CHARSET;
		}
		cf.yOffset = 0;
	}

	DWORD FillInLogFont(const CHARFORMAT& cf)
	{
		USES_CONVERSION;
		DWORD dwFlags = 0;
		if(cf.dwMask & CFM_SIZE)
		{
			HDC hDC = ::CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
			LONG yPerInch = ::GetDeviceCaps(hDC, LOGPIXELSY);
			m_lf.lfHeight = -(int)((cf.yHeight * yPerInch) / 1440);
		}
		else
			m_lf.lfHeight = 0;

		m_lf.lfWidth = 0;
		m_lf.lfEscapement = 0;
		m_lf.lfOrientation = 0;

		if((cf.dwMask & (CFM_ITALIC|CFM_BOLD)) == (CFM_ITALIC|CFM_BOLD))
		{
			m_lf.lfWeight = (cf.dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;
			m_lf.lfItalic = (BYTE)((cf.dwEffects & CFE_ITALIC) ? TRUE : FALSE);
		}
		else
		{
			dwFlags |= CF_NOSTYLESEL;
			m_lf.lfWeight = FW_DONTCARE;
			m_lf.lfItalic = FALSE;
		}

		if((cf.dwMask & (CFM_UNDERLINE|CFM_STRIKEOUT|CFM_COLOR)) ==
			(CFM_UNDERLINE|CFM_STRIKEOUT|CFM_COLOR))
		{
			dwFlags |= CF_EFFECTS;
			m_lf.lfUnderline = (BYTE)((cf.dwEffects & CFE_UNDERLINE) ? TRUE : FALSE);
			m_lf.lfStrikeOut = (BYTE)((cf.dwEffects & CFE_STRIKEOUT) ? TRUE : FALSE);
		}
		else
		{
			m_lf.lfUnderline = (BYTE)FALSE;
			m_lf.lfStrikeOut = (BYTE)FALSE;
		}

		if(cf.dwMask & CFM_CHARSET)
			m_lf.lfCharSet = cf.bCharSet;
		else
			dwFlags |= CF_NOSCRIPTSEL;
		m_lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
		m_lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		m_lf.lfQuality = DEFAULT_QUALITY;
		if(cf.dwMask & CFM_FACE)
		{
			m_lf.lfPitchAndFamily = cf.bPitchAndFamily;
#if (_RICHEDIT_VER >= 0x0200)
			lstrcpy(m_lf.lfFaceName, cf.szFaceName);
#else
			lstrcpy(m_lf.lfFaceName, A2T((LPSTR)cf.szFaceName));
#endif //(_RICHEDIT_VER >= 0x0200)
		}
		else
		{
			m_lf.lfPitchAndFamily = DEFAULT_PITCH|FF_DONTCARE;
			m_lf.lfFaceName[0] = (TCHAR)0;
		}
		return dwFlags;
	}
};

class CRichEditFontDialog : public CRichEditFontDialogImpl<CRichEditFontDialog>
{
public:
	CRichEditFontDialog(const CHARFORMAT& charformat,
		DWORD dwFlags = CF_SCREENFONTS,
		HDC hDCPrinter = NULL,
		HWND hWndParent = NULL)
		: CRichEditFontDialogImpl<CRichEditFontDialog>(charformat, dwFlags, hDCPrinter, hWndParent)
	{ }

	DECLARE_EMPTY_MSG_MAP()
};

#endif // _RICHEDIT_

/////////////////////////////////////////////////////////////////////////////
// CColorDialogImpl - color selection

static const UINT _nMsgCOLOROK = ::RegisterWindowMessage(COLOROKSTRING);
const UINT _nMsgSETRGB = ::RegisterWindowMessage(SETRGBSTRING);

template <class T>
class ATL_NO_VTABLE CColorDialogImpl : public CCommonDialogImplBase
{
public:
	CHOOSECOLOR m_cc;

// Constructors
	CColorDialogImpl(COLORREF clrInit = 0, DWORD dwFlags = 0, HWND hWndParent = NULL)
	{
		memset(&m_cc, 0, sizeof(m_cc));

		m_cc.lStructSize = sizeof(m_cc);
		m_cc.lpCustColors = GetCustomColors();
		m_cc.hwndOwner = hWndParent;
		m_cc.Flags = dwFlags | CC_ENABLEHOOK;
		m_cc.lpfnHook = (LPCCHOOKPROC)T::HookProc;

		if(clrInit != 0)
		{
			m_cc.rgbResult = clrInit;
			m_cc.Flags |= CC_RGBINIT;
		}
	}

// Operations
	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_cc.Flags & CC_ENABLEHOOK);
		ATLASSERT(m_cc.lpfnHook != NULL);	// can still be a user hook

		if(m_cc.hwndOwner == NULL)		// set only if not specified before
			m_cc.hwndOwner = hWndParent;

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);

		BOOL bRet = ::ChooseColor(&m_cc);

		m_hWnd = NULL;

		return bRet ? IDOK : IDCANCEL;
	}

	// Set the current color while dialog is displayed
	void SetCurrentColor(COLORREF clr)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		SendMessage(_nMsgSETRGB, 0, (LPARAM)clr);
	}

	// Helpers for parsing information after successful return
	COLORREF GetColor() const
	{
		return m_cc.rgbResult;
	}

	static COLORREF* GetCustomColors()
	{
		static COLORREF rgbCustomColors[16] =
		{
			RGB(255, 255, 255), RGB(255, 255, 255), 
			RGB(255, 255, 255), RGB(255, 255, 255), 
			RGB(255, 255, 255), RGB(255, 255, 255), 
			RGB(255, 255, 255), RGB(255, 255, 255), 
			RGB(255, 255, 255), RGB(255, 255, 255), 
			RGB(255, 255, 255), RGB(255, 255, 255), 
			RGB(255, 255, 255), RGB(255, 255, 255), 
			RGB(255, 255, 255), RGB(255, 255, 255), 
		};

		return rgbCustomColors;
	}

// Overridable callbacks
	BEGIN_MSG_MAP(CColorDialogImpl< T >)
		MESSAGE_HANDLER(_nMsgCOLOROK, _OnColorOK)
	END_MSG_MAP()

	LRESULT _OnColorOK(UINT, WPARAM, LPARAM, BOOL&)
	{
		T* pT = static_cast<T*>(this);
		return pT->OnColorOK();
	}

	BOOL OnColorOK()        // validate color
	{
		return FALSE;
	}
};

class CColorDialog : public CColorDialogImpl<CColorDialog>
{
public:
	CColorDialog(COLORREF clrInit = 0, DWORD dwFlags = 0, HWND hWndParent = NULL)
		: CColorDialogImpl<CColorDialog>(clrInit, dwFlags, hWndParent)
	{ }

	// override base class map and references to handlers
	DECLARE_EMPTY_MSG_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CPrintDialogImpl - used for Print... and PrintSetup...

// global helper
static HDC _AtlCreateDC(HGLOBAL hDevNames, HGLOBAL hDevMode)
{
	if(hDevNames == NULL)
		return NULL;

	LPDEVNAMES lpDevNames = (LPDEVNAMES)::GlobalLock(hDevNames);
	LPDEVMODE  lpDevMode = (hDevMode != NULL) ? (LPDEVMODE)::GlobalLock(hDevMode) : NULL;

	if(lpDevNames == NULL)
		return NULL;

	HDC hDC = ::CreateDC((LPCTSTR)lpDevNames + lpDevNames->wDriverOffset,
					  (LPCTSTR)lpDevNames + lpDevNames->wDeviceOffset,
					  (LPCTSTR)lpDevNames + lpDevNames->wOutputOffset,
					  lpDevMode);

	::GlobalUnlock(hDevNames);
	if(hDevMode != NULL)
		::GlobalUnlock(hDevMode);
	return hDC;
}

template <class T>
class ATL_NO_VTABLE CPrintDialogImpl : public CCommonDialogImplBase
{
public:
	// print dialog parameter block (note this is a reference)
	PRINTDLG& m_pd;

// Constructors
	CPrintDialogImpl(BOOL bPrintSetupOnly = FALSE,	// TRUE for Print Setup, FALSE for Print Dialog
			DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS | PD_NOSELECTION,
			HWND hWndParent = NULL)
			: m_pd(m_pdActual)
	{
		memset(&m_pdActual, 0, sizeof(m_pdActual));

		m_pd.lStructSize = sizeof(m_pdActual);
		m_pd.hwndOwner = hWndParent;
		m_pd.Flags = (dwFlags | PD_ENABLEPRINTHOOK | PD_ENABLESETUPHOOK);
		m_pd.lpfnPrintHook = (LPPRINTHOOKPROC)T::HookProc;
		m_pd.lpfnSetupHook = (LPSETUPHOOKPROC)T::HookProc;

		if(bPrintSetupOnly)
			m_pd.Flags |= PD_PRINTSETUP;
		else
			m_pd.Flags |= PD_RETURNDC;

		m_pd.Flags &= ~PD_RETURNIC; // do not support information context
	}

// Operations
	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_pd.Flags & PD_ENABLEPRINTHOOK);
		ATLASSERT(m_pd.Flags & PD_ENABLESETUPHOOK);
		ATLASSERT(m_pd.lpfnPrintHook != NULL);	// can still be a user hook
		ATLASSERT(m_pd.lpfnSetupHook != NULL);	// can still be a user hook
		ATLASSERT((m_pd.Flags & PD_RETURNDEFAULT) == 0);	// use GetDefaults for this

		if(m_pd.hwndOwner == NULL)		// set only if not specified before
			m_pd.hwndOwner = hWndParent;

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);

		BOOL bRet = ::PrintDlg(&m_pd);

		m_hWnd = NULL;

		return bRet ? IDOK : IDCANCEL;
	}

	// GetDefaults will not display a dialog but will get device defaults
	BOOL GetDefaults()
	{
		m_pd.Flags |= PD_RETURNDEFAULT;
		ATLASSERT(m_pd.hDevMode == NULL);	// must be NULL
		ATLASSERT(m_pd.hDevNames == NULL);	// must be NULL

		return ::PrintDlg(&m_pd);
	}

	// Helpers for parsing information after successful return num. copies requested
	int GetCopies() const
	{
		if(m_pd.Flags & PD_USEDEVMODECOPIES)
		{
			LPDEVMODE lpDevMode = GetDevMode();
			return (lpDevMode != NULL) ? lpDevMode->dmCopies : -1;
		}

		return m_pd.nCopies;
	}
	BOOL PrintCollate() const       // TRUE if collate checked
	{
		return m_pd.Flags & PD_COLLATE ? TRUE : FALSE;
	}
	BOOL PrintSelection() const     // TRUE if printing selection
	{
		return m_pd.Flags & PD_SELECTION ? TRUE : FALSE;
	}
	BOOL PrintAll() const           // TRUE if printing all pages
	{
		return !PrintRange() && !PrintSelection() ? TRUE : FALSE;
	}
	BOOL PrintRange() const         // TRUE if printing page range
	{
		return m_pd.Flags & PD_PAGENUMS ? TRUE : FALSE;
	}
	int GetFromPage() const         // starting page if valid
	{
		return (PrintRange() ? m_pd.nFromPage :-1);
	}
	int GetToPage() const           // starting page if valid
	{
		return (PrintRange() ? m_pd.nToPage :-1);
	}
	LPDEVMODE GetDevMode() const    // return DEVMODE
	{
		if(m_pd.hDevMode == NULL)
			return NULL;

		return (LPDEVMODE)::GlobalLock(m_pd.hDevMode);
	}
	LPCTSTR GetDriverName() const   // return driver name
	{
		if(m_pd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pd.hDevNames);
		if(lpDev == NULL)
			return NULL;

		return (LPCTSTR)lpDev + lpDev->wDriverOffset;
	}
	LPCTSTR GetDeviceName() const   // return device name
	{
		if(m_pd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pd.hDevNames);
		if(lpDev == NULL)
			return NULL;

		return (LPCTSTR)lpDev + lpDev->wDeviceOffset;
	}
	LPCTSTR GetPortName() const     // return output port name
	{
		if(m_pd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pd.hDevNames);
		if(lpDev == NULL)
			return NULL;

		return (LPCTSTR)lpDev + lpDev->wOutputOffset;
	}
	HDC GetPrinterDC() const        // return HDC (caller must delete)
	{
		ATLASSERT(m_pd.Flags & PD_RETURNDC);
		return m_pd.hDC;
	}

	// This helper creates a DC based on the DEVNAMES and DEVMODE structures.
	// This DC is returned, but also stored in m_pd.hDC as though it had been
	// returned by CommDlg.  It is assumed that any previously obtained DC
	// has been/will be deleted by the user.  This may be
	// used without ever invoking the print/print setup dialogs.
	HDC CreatePrinterDC()
	{
		m_pd.hDC = _AtlCreateDC(m_pd.hDevNames, m_pd.hDevMode);
		return m_pd.hDC;
	}

// Implementation
	PRINTDLG m_pdActual; // the Print/Print Setup need to share this

	// The following handle the case of print setup... from the print dialog
	CPrintDialogImpl(PRINTDLG& pdInit) : m_pd(pdInit)
	{ }

	BEGIN_MSG_MAP(CPrintDialogImpl< T >)
#ifdef psh1
		COMMAND_ID_HANDLER(psh1, OnPrintSetup) // print setup button when print is displayed
#else //!psh1
		COMMAND_ID_HANDLER(0x0400, OnPrintSetup) // value from dlgs.h
#endif //!psh1
	END_MSG_MAP()

	LRESULT OnPrintSetup(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& /*bHandled*/)
	{
		CPrintDialogImpl< T >* pDlgSetup = NULL;
		ATLTRY(pDlgSetup = new CPrintDialogImpl< T >(m_pd));
		ATLASSERT(pDlgSetup != NULL);

		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)pDlgSetup);
		LRESULT lRet = DefWindowProc(WM_COMMAND, MAKEWPARAM(wID, wNotifyCode), (LPARAM)hWndCtl);

		delete pDlgSetup;
		return lRet;
	}
};

class CPrintDialog : public CPrintDialogImpl<CPrintDialog>
{
public:
	CPrintDialog(BOOL bPrintSetupOnly = FALSE,
		DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS | PD_NOSELECTION,
		HWND hWndParent = NULL)
		: CPrintDialogImpl<CPrintDialog>(bPrintSetupOnly, dwFlags, hWndParent)
	{ }
	CPrintDialog(PRINTDLG& pdInit) : CPrintDialogImpl<CPrintDialog>(pdInit)
	{ }
};


/////////////////////////////////////////////////////////////////////////////
// CPrintDialogExImpl - new print dialog for Windows 2000

#if (WINVER >= 0x0500)

}; //namespace WTL

#include <atlcom.h>

extern "C" const __declspec(selectany) IID IID_IPrintDialogCallback = {0x5852a2c3, 0x6530, 0x11d1, {0xb6, 0xa3, 0x0, 0x0, 0xf8, 0x75, 0x7b, 0xf9}};
extern "C" const __declspec(selectany) IID IID_IPrintDialogServices = {0x509aaeda, 0x5639, 0x11d1, {0xb6, 0xa1, 0x0, 0x0, 0xf8, 0x75, 0x7b, 0xf9}};

namespace WTL
{

template <class T>
class ATL_NO_VTABLE CPrintDialogExImpl : 
				public CWindow,
				public CMessageMap,
				public IPrintDialogCallback,
				public IObjectWithSiteImpl< T >
{
public:
	PRINTDLGEX m_pdex;

// Constructor
	CPrintDialogExImpl(DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS | PD_NOSELECTION | PD_NOCURRENTPAGE,
				HWND hWndParent = NULL)
	{
		memset(&m_pdex, 0, sizeof(m_pdex));

		m_pdex.lStructSize = sizeof(PRINTDLGEX);
		m_pdex.hwndOwner = hWndParent;
		m_pdex.Flags = dwFlags;
		m_pdex.nStartPage = START_PAGE_GENERAL;
		// callback object will be set in DoModal

		m_pdex.Flags &= ~PD_RETURNIC; // do not support information context
	}

// Operations
	HRESULT DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_hWnd == NULL);
		ATLASSERT((m_pdex.Flags & PD_RETURNDEFAULT) == 0);	// use GetDefaults for this

		if(m_pdex.hwndOwner == NULL)		// set only if not specified before
			m_pdex.hwndOwner = hWndParent;

		T* pT = static_cast<T*>(this);
		m_pdex.lpCallback = (IUnknown*)(IPrintDialogCallback*)pT;

		HRESULT hResult = ::PrintDlgEx(&m_pdex);

		m_hWnd = NULL;

		return hResult;
	}

	BOOL EndDialog(INT_PTR /*nRetCode*/ = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		SendMessage(WM_COMMAND, MAKEWPARAM(IDABORT, 0));
		return TRUE;
	}

	// GetDefaults will not display a dialog but will get device defaults
	HRESULT GetDefaults()
	{
		m_pdex.Flags |= PD_RETURNDEFAULT;
		ATLASSERT(m_pdex.hDevMode == NULL);	// must be NULL
		ATLASSERT(m_pdex.hDevNames == NULL);	// must be NULL

		return ::PrintDlgEx(&m_pdex);
	}

	// Helpers for parsing information after successful return num. copies requested
	int GetCopies() const
	{
		if(m_pdex.Flags & PD_USEDEVMODECOPIES)
		{
			LPDEVMODE lpDevMode = GetDevMode();
			return (lpDevMode != NULL) ? lpDevMode->dmCopies : -1;
		}

		return m_pdex.nCopies;
	}
	BOOL PrintCollate() const       // TRUE if collate checked
	{
		return m_pdex.Flags & PD_COLLATE ? TRUE : FALSE;
	}
	BOOL PrintSelection() const     // TRUE if printing selection
	{
		return m_pdex.Flags & PD_SELECTION ? TRUE : FALSE;
	}
	BOOL PrintAll() const           // TRUE if printing all pages
	{
		return !PrintRange() && !PrintSelection() ? TRUE : FALSE;
	}
	BOOL PrintRange() const         // TRUE if printing page range
	{
		return m_pdex.Flags & PD_PAGENUMS ? TRUE : FALSE;
	}
	LPDEVMODE GetDevMode() const    // return DEVMODE
	{
		if(m_pdex.hDevMode == NULL)
			return NULL;

		return (LPDEVMODE)::GlobalLock(m_pdex.hDevMode);
	}
	LPCTSTR GetDriverName() const   // return driver name
	{
		if(m_pdex.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pdex.hDevNames);
		if(lpDev == NULL)
			return NULL;

		return (LPCTSTR)lpDev + lpDev->wDriverOffset;
	}
	LPCTSTR GetDeviceName() const   // return device name
	{
		if(m_pdex.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pdex.hDevNames);
		if(lpDev == NULL)
			return NULL;

		return (LPCTSTR)lpDev + lpDev->wDeviceOffset;
	}
	LPCTSTR GetPortName() const     // return output port name
	{
		if(m_pdex.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pdex.hDevNames);
		if(lpDev == NULL)
			return NULL;

		return (LPCTSTR)lpDev + lpDev->wOutputOffset;
	}
	HDC GetPrinterDC() const        // return HDC (caller must delete)
	{
		ATLASSERT(m_pdex.Flags & PD_RETURNDC);
		return m_pdex.hDC;
	}

	// This helper creates a DC based on the DEVNAMES and DEVMODE structures.
	// This DC is returned, but also stored in m_pdex.hDC as though it had been
	// returned by CommDlg.  It is assumed that any previously obtained DC
	// has been/will be deleted by the user.  This may be
	// used without ever invoking the print/print setup dialogs.
	HDC CreatePrinterDC()
	{
		m_pdex.hDC = _AtlCreateDC(m_pdex.hDevNames, m_pdex.hDevMode);
		return m_pdex.hDC;
	}

// Implementation - interfaces

// IUnknown
	STDMETHOD(QueryInterface)(REFIID riid, void** ppvObject)
	{
		if(ppvObject == NULL)
			return E_POINTER;

		T* pT = static_cast<T*>(this);
		if(IsEqualGUID(riid, IID_IUnknown) || IsEqualGUID(riid, IID_IPrintDialogCallback))
		{
			*ppvObject = (IPrintDialogCallback*)pT;
			// AddRef() not needed
			return S_OK;
		}
		else if(IsEqualGUID(riid, IID_IObjectWithSite))
		{
			*ppvObject = (IObjectWithSite*)pT;
			// AddRef() not needed
			return S_OK;
		}

		return E_NOINTERFACE;
	}
	virtual ULONG STDMETHODCALLTYPE AddRef()
	{
		return 1;
	}
	virtual ULONG STDMETHODCALLTYPE Release()
	{
		return 1;
	}

// IPrintDialogCallback
	STDMETHOD(InitDone)()
	{
		return S_FALSE;
	}
	STDMETHOD(SelectionChange)()
	{
		return S_FALSE;
	}
	STDMETHOD(HandleMessage)(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plResult)
	{
		// set up m_hWnd the first time
		if(m_hWnd == NULL)
			Attach(hWnd);

		// call message map
		HRESULT hRet = ProcessWindowMessage(hWnd, uMsg, wParam, lParam, *plResult, 0) ? S_OK : S_FALSE;
		if(hRet == S_OK && uMsg == WM_NOTIFY)	// return in DWLP_MSGRESULT
			::SetWindowLongPtr(GetParent(), DWLP_MSGRESULT, (LONG_PTR)*plResult);

		if(uMsg == WM_INITDIALOG && hRet == S_OK && (BOOL)*plResult != FALSE)
			hRet = S_FALSE;

		return hRet;
	}
};

class CPrintDialogEx : public CPrintDialogExImpl<CPrintDialogEx>
{
public:
	CPrintDialogEx(
		DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS | PD_NOSELECTION | PD_NOCURRENTPAGE,
		HWND hWndParent = NULL)
		: CPrintDialogExImpl<CPrintDialogEx>(dwFlags, hWndParent)
	{ }

	DECLARE_EMPTY_MSG_MAP()
};

#endif //(WINVER >= 0x0500)

/////////////////////////////////////////////////////////////////////////////
// CPageSetupDialogImpl - Page Setup dialog

template <class T>
class ATL_NO_VTABLE CPageSetupDialogImpl : public CCommonDialogImplBase
{
public:
	PAGESETUPDLG m_psd;
	CWndProcThunk m_thunkPaint;


// Constructors
	CPageSetupDialogImpl(DWORD dwFlags = PSD_MARGINS | PSD_INWININIINTLMEASURE, HWND hWndParent = NULL)
	{
		memset(&m_psd, 0, sizeof(m_psd));

		m_psd.lStructSize = sizeof(m_psd);
		m_psd.hwndOwner = hWndParent;
		m_psd.Flags = (dwFlags | PSD_ENABLEPAGESETUPHOOK | PSD_ENABLEPAGEPAINTHOOK);
		m_psd.lpfnPageSetupHook = (LPPAGESETUPHOOK)T::HookProc;
		m_thunkPaint.Init((WNDPROC)T::PaintHookProc, this);
		m_psd.lpfnPagePaintHook = (LPPAGEPAINTHOOK)&(m_thunkPaint.thunk);
	}

	DECLARE_EMPTY_MSG_MAP()

// Attributes
	LPDEVMODE GetDevMode() const    // return DEVMODE
	{
		if(m_psd.hDevMode == NULL)
			return NULL;

		return (LPDEVMODE)::GlobalLock(m_psd.hDevMode);
	}
	LPCTSTR GetDriverName() const   // return driver name
	{
		if(m_psd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_psd.hDevNames);
		return (LPCTSTR)lpDev + lpDev->wDriverOffset;
	}
	LPCTSTR GetDeviceName() const   // return device name
	{
		if(m_psd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_psd.hDevNames);
		return (LPCTSTR)lpDev + lpDev->wDeviceOffset;
	}
	LPCTSTR GetPortName() const     // return output port name
	{
		if(m_psd.hDevNames == NULL)
			return NULL;

		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_psd.hDevNames);
		return (LPCTSTR)lpDev + lpDev->wOutputOffset;
	}
	HDC CreatePrinterDC()
	{
		return _AtlCreateDC(m_psd.hDevNames, m_psd.hDevMode);
	}
	SIZE GetPaperSize() const
	{
		SIZE size;
		size.cx = m_psd.ptPaperSize.x;
		size.cy = m_psd.ptPaperSize.y;
		return size;
	}
	void GetMargins(LPRECT lpRectMargins, LPRECT lpRectMinMargins) const
	{
		if(lpRectMargins != NULL)
			memcpy(lpRectMargins, &m_psd.rtMargin, sizeof(RECT));
		if(lpRectMinMargins != NULL)
			memcpy(lpRectMinMargins, &m_psd.rtMinMargin, sizeof(RECT));
	}

// Operations
	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_psd.Flags & PSD_ENABLEPAGESETUPHOOK);
		ATLASSERT(m_psd.Flags & PSD_ENABLEPAGEPAINTHOOK);
		ATLASSERT(m_psd.lpfnPageSetupHook != NULL);	// can still be a user hook
		ATLASSERT(m_psd.lpfnPagePaintHook != NULL);	// can still be a user hook

		if(m_psd.hwndOwner == NULL)		// set only if not specified before
			m_psd.hwndOwner = hWndParent;

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);

		BOOL bRet = ::PageSetupDlg(&m_psd);

		m_hWnd = NULL;

		return bRet ? IDOK : IDCANCEL;
	}

// Implementation
	static UINT CALLBACK PaintHookProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		CPageSetupDialogImpl< T >* pDlg = (CPageSetupDialogImpl< T >*)hWnd;
		ATLASSERT(pDlg->m_hWnd == ::GetParent(hWnd));
		UINT uRet = 0;
		switch(uMsg)
		{
		case WM_PSD_PAGESETUPDLG:
			uRet = pDlg->PreDrawPage(LOWORD(wParam), HIWORD(wParam), (LPPAGESETUPDLG)lParam);
			break;
		case WM_PSD_FULLPAGERECT:
		case WM_PSD_MINMARGINRECT:
		case WM_PSD_MARGINRECT:
		case WM_PSD_GREEKTEXTRECT:
		case WM_PSD_ENVSTAMPRECT:
		case WM_PSD_YAFULLPAGERECT:
			uRet = pDlg->OnDrawPage(uMsg, (HDC)wParam, (LPRECT)lParam);
			break;
		default:
			ATLTRACE2(atlTraceUI, 0, _T("CPageSetupDialogImpl::PaintHookProc - unknown message received\n"));
			break;
		}
		return uRet;
	}

// Overridables
	UINT PreDrawPage(WORD /*wPaper*/, WORD /*wFlags*/, LPPAGESETUPDLG /*pPSD*/)
	{
		// return 1 to prevent any more drawing
		return 0;
	}
	UINT OnDrawPage(UINT /*uMsg*/, HDC /*hDC*/, LPRECT /*lpRect*/)
	{
		return 0; // do the default
	}
};

class CPageSetupDialog : public CPageSetupDialogImpl<CPageSetupDialog>
{
public:
	CPageSetupDialog(DWORD dwFlags = PSD_MARGINS | PSD_INWININIINTLMEASURE, HWND hWndParent = NULL)
		: CPageSetupDialogImpl<CPageSetupDialog>(dwFlags, hWndParent)
	{ }

	// override PaintHookProc and references to handlers
	static UINT CALLBACK PaintHookProc(HWND, UINT, WPARAM, LPARAM)
	{
		return 0;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CFindReplaceDialogImpl - Find/FindReplace modeless dialogs

template <class T>
class ATL_NO_VTABLE CFindReplaceDialogImpl : public CCommonDialogImplBase
{
public:
	FINDREPLACE m_fr;
	TCHAR m_szFindWhat[128];
	TCHAR m_szReplaceWith[128];

// Constructors
	CFindReplaceDialogImpl()
	{
		memset(&m_fr, 0, sizeof(m_fr));
		m_szFindWhat[0] = '\0';
		m_szReplaceWith[0] = '\0';

		m_fr.lStructSize = sizeof(m_fr);
		m_fr.Flags = FR_ENABLEHOOK;
		m_fr.lpfnHook = (LPFRHOOKPROC)T::HookProc;
		m_fr.lpstrFindWhat = (LPTSTR)m_szFindWhat;
	}

	// Note: You must allocate the object on the heap.
	//       If you do not, you must override OnFinalMessage()
	virtual void OnFinalMessage(HWND /*hWnd*/)
	{
		delete this;
	}

	HWND Create(BOOL bFindDialogOnly, // TRUE for Find, FALSE for FindReplace
			LPCTSTR lpszFindWhat,
			LPCTSTR lpszReplaceWith = NULL,
			DWORD dwFlags = FR_DOWN,
			HWND hWndParent = NULL)
	{
		ATLASSERT(m_fr.Flags & FR_ENABLEHOOK);
		ATLASSERT(m_fr.lpfnHook != NULL);

		m_fr.wFindWhatLen = sizeof(m_szFindWhat)/sizeof(TCHAR);
		m_fr.lpstrReplaceWith = (LPTSTR)m_szReplaceWith;
		m_fr.wReplaceWithLen = sizeof(m_szReplaceWith)/sizeof(TCHAR);
		m_fr.Flags |= dwFlags;

		if(hWndParent == NULL)
			m_fr.hwndOwner = ::GetActiveWindow();
		else
			m_fr.hwndOwner = hWndParent;
		ATLASSERT(m_fr.hwndOwner != NULL); // must have an owner for modeless dialog

		if(lpszFindWhat != NULL)
			lstrcpyn(m_szFindWhat, lpszFindWhat, sizeof(m_szFindWhat)/sizeof(TCHAR));

		if(lpszReplaceWith != NULL)
			lstrcpyn(m_szReplaceWith, lpszReplaceWith, sizeof(m_szReplaceWith)/sizeof(TCHAR));

		ATLASSERT(m_hWnd == NULL);
		_Module.AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);
		HWND hWnd;

		if(bFindDialogOnly)
			hWnd = ::FindText(&m_fr);
		else
			hWnd = ::ReplaceText(&m_fr);

		ATLASSERT(m_hWnd == hWnd);
		return hWnd;
	}

	static const UINT GetFindReplaceMsg()
	{
		static const UINT nMsgFindReplace = ::RegisterWindowMessage(FINDMSGSTRING);
		return nMsgFindReplace;
	}
	// call while handling FINDMSGSTRING registered message
	// to retreive the object
	static T* PASCAL GetNotifier(LPARAM lParam)
	{
		ATLASSERT(lParam != NULL);
		T* pDlg = (T*)(lParam - offsetof(T, m_fr));
		return pDlg;
	}

// Operations
	// Helpers for parsing information after successful return
	LPCTSTR GetFindString() const    // get find string
	{
		return (LPCTSTR)m_fr.lpstrFindWhat;
	}
	LPCTSTR GetReplaceString() const // get replacement string
	{
		return (LPCTSTR)m_fr.lpstrReplaceWith;
	}
	BOOL SearchDown() const          // TRUE if search down, FALSE is up
	{
		return m_fr.Flags & FR_DOWN ? TRUE : FALSE;
	}
	BOOL FindNext() const            // TRUE if command is find next
	{
		return m_fr.Flags & FR_FINDNEXT ? TRUE : FALSE;
	}
	BOOL MatchCase() const           // TRUE if matching case
	{
		return m_fr.Flags & FR_MATCHCASE ? TRUE : FALSE;
	}
	BOOL MatchWholeWord() const      // TRUE if matching whole words only
	{
		return m_fr.Flags & FR_WHOLEWORD ? TRUE : FALSE;
	}
	BOOL ReplaceCurrent() const      // TRUE if replacing current string
	{
		return m_fr. Flags & FR_REPLACE ? TRUE : FALSE;
	}
	BOOL ReplaceAll() const          // TRUE if replacing all occurrences
	{
		return m_fr.Flags & FR_REPLACEALL ? TRUE : FALSE;
	}
	BOOL IsTerminating() const       // TRUE if terminating dialog
	{
		return m_fr.Flags & FR_DIALOGTERM ? TRUE : FALSE ;
	}
};

class CFindReplaceDialog : public CFindReplaceDialogImpl<CFindReplaceDialog>
{
public:
	DECLARE_EMPTY_MSG_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CPropertySheetWindow - client side for a property sheet

class CPropertySheetWindow : public CWindow
{
public:
// Constructors
	CPropertySheetWindow(HWND hWnd = NULL) : CWindow(hWnd) { }

	CPropertySheetWindow& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// Attributes
	int GetPageCount() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HWND hWndTabCtrl = GetTabControl();
		ATLASSERT(hWndTabCtrl != NULL);
		return (int)::SendMessage(hWndTabCtrl, TCM_GETITEMCOUNT, 0, 0L);
	}
	HWND GetActivePage() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HWND)::SendMessage(m_hWnd, PSM_GETCURRENTPAGEHWND, 0, 0L);
	}
	int GetActiveIndex() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HWND hWndTabCtrl = GetTabControl();
		ATLASSERT(hWndTabCtrl != NULL);
		return (int)::SendMessage(hWndTabCtrl, TCM_GETCURSEL, 0, 0L);
	}
	BOOL SetActivePage(int nPageIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_SETCURSEL, nPageIndex, 0L);
	}
	BOOL SetActivePage(HPROPSHEETPAGE hPage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hPage != NULL);
		return (BOOL)::SendMessage(m_hWnd, PSM_SETCURSEL, 0, (LPARAM)hPage);
	}
	BOOL SetActivePageByID(int nPageID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_SETCURSELID, 0, nPageID);
	}
	void SetTitle(LPCTSTR lpszText, UINT nStyle = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT((nStyle & ~PSH_PROPTITLE) == 0); // only PSH_PROPTITLE is valid
		ATLASSERT(lpszText != NULL);
		::SendMessage(m_hWnd, PSM_SETTITLE, nStyle, (LPARAM)lpszText);
	}
	HWND GetTabControl() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HWND)::SendMessage(m_hWnd, PSM_GETTABCONTROL, 0, 0L);
	}
	void SetFinishText(LPCTSTR lpszText)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText);
	}
	void SetWizardButtons(DWORD dwFlags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::PostMessage(m_hWnd, PSM_SETWIZBUTTONS, 0, dwFlags);
	}

// Operations
	void AddPage(HPROPSHEETPAGE hPage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hPage != NULL);
		::SendMessage(m_hWnd, PSM_ADDPAGE, 0, (LPARAM)hPage);
	}
	BOOL AddPage(LPCPROPSHEETPAGE pPage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(pPage != NULL);
		HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(pPage);
		if(hPage == NULL)
			return FALSE;
		::SendMessage(m_hWnd, PSM_ADDPAGE, 0, (LPARAM)hPage);
		return TRUE;
	}
	void RemovePage(int nPageIndex)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_REMOVEPAGE, nPageIndex, 0L);
	}
	void RemovePage(HPROPSHEETPAGE hPage)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(hPage != NULL);
		::SendMessage(m_hWnd, PSM_REMOVEPAGE, 0, (LPARAM)hPage);
	}
	BOOL PressButton(int nButton)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_PRESSBUTTON, nButton, 0L);
	}
	BOOL Apply()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_APPLY, 0, 0L);
	}
	void CancelToClose()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(HWND hWndPage, BOOL bChanged = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(::IsWindow(hWndPage));
		UINT uMsg = bChanged ? PSM_CHANGED : PSM_UNCHANGED;
		::SendMessage(m_hWnd, uMsg, (WPARAM)hWndPage, 0L);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return ::SendMessage(m_hWnd, PSM_QUERYSIBLINGS, wParam, lParam);
	}
	void RebootSystem()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_REBOOTSYSTEM, 0, 0L);
	}
	void RestartWindows()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		::SendMessage(m_hWnd, PSM_RESTARTWINDOWS, 0, 0L);
	}
	BOOL IsDialogMessage(LPMSG lpMsg)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_ISDIALOGMESSAGE, 0, (LPARAM)lpMsg);
	}

#if (_WIN32_IE >= 0x0500)
	int HwndToIndex(HWND hWnd) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PSM_HWNDTOINDEX, (WPARAM)hWnd, 0L);
	}
	HWND IndexToHwnd(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HWND)::SendMessage(m_hWnd, PSM_INDEXTOHWND, nIndex, 0L);
	}
	int PageToIndex(HPROPSHEETPAGE hPage) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PSM_PAGETOINDEX, 0, (LPARAM)hPage);
	}
	HPROPSHEETPAGE IndexToPage(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HPROPSHEETPAGE)::SendMessage(m_hWnd, PSM_INDEXTOPAGE, nIndex, 0L);
	}
	int IdToIndex(int nID) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PSM_IDTOINDEX, 0, nID);
	}
	int IndexToId(int nIndex) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PSM_INDEXTOID, nIndex, 0L);
	}
	int GetResult() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (int)::SendMessage(m_hWnd, PSM_GETRESULT, 0, 0L);
	}
	BOOL RecalcPageSizes()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (BOOL)::SendMessage(m_hWnd, PSM_RECALCPAGESIZES, 0, 0L);
	}
#endif //(_WIN32_IE >= 0x0500)

// Implementation - override to prevent usage
	HWND Create(LPCTSTR, HWND, _U_RECT = NULL, LPCTSTR = NULL, DWORD = 0, DWORD = 0, _U_MENUorID = 0U, LPVOID = NULL)
	{
		ATLASSERT(FALSE);
		return NULL;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CPropertySheetImpl - implements a property sheet

#if (_MSC_VER >= 1200)
typedef HPROPSHEETPAGE	_HPROPSHEETPAGE_TYPE;
#else
// we use void* here instead of HPROPSHEETPAGE becuase HPROPSHEETPAGE
// is a _PSP*, but _PSP is not defined properly
typedef void*	_HPROPSHEETPAGE_TYPE;
#endif

template <class T, class TBase /*= CPropertySheetWindow */ >
class ATL_NO_VTABLE CPropertySheetImpl : public CWindowImplBaseT< TBase >
{
public:
	PROPSHEETHEADER m_psh;
	CSimpleArray<_HPROPSHEETPAGE_TYPE> m_arrPages;

// Construction/Destruction
	CPropertySheetImpl(_U_STRINGorID title = (LPCTSTR)NULL, UINT uStartPage = 0, HWND hWndParent = NULL)
	{
		memset(&m_psh, 0, sizeof(PROPSHEETHEADER));
		m_psh.dwSize = sizeof(PROPSHEETHEADER);
		m_psh.dwFlags = PSH_USECALLBACK;
		m_psh.hInstance = _Module.GetResourceInstance();
		m_psh.phpage = NULL;	// will be set later
		m_psh.nPages = 0;	// will be set later
		m_psh.pszCaption = title.m_lpstr;
		m_psh.nStartPage = uStartPage;
		m_psh.hwndParent = hWndParent;	// if NULL, will be set in DoModal/Create
		m_psh.pfnCallback = T::PropSheetCallback;
	}

	~CPropertySheetImpl()
	{
		if(m_arrPages.GetSize() > 0)	// sheet never created, destroy all pages
		{
			for(int i = 0; i < m_arrPages.GetSize(); i++)
				::DestroyPropertySheetPage((HPROPSHEETPAGE)m_arrPages[i]);
		}
	}

	static int CALLBACK PropSheetCallback(HWND hWnd, UINT uMsg, LPARAM)
	{
		if(uMsg == PSCB_INITIALIZED)
		{
			ATLASSERT(hWnd != NULL);
			T* pT = (T*)_Module.ExtractCreateWndData();
			// subclass the sheet window
			pT->SubclassWindow(hWnd);
			// remove page handles array
			pT->_CleanUpPages();
		}

		return 0;
	}

	HWND Create(HWND hWndParent = NULL)
	{
		ATLASSERT(m_hWnd == NULL);

		m_psh.dwFlags |= PSH_MODELESS;
		if(m_psh.hwndParent == NULL)
			m_psh.hwndParent = hWndParent;
		m_psh.phpage = (HPROPSHEETPAGE*)m_arrPages.GetData();
		m_psh.nPages = m_arrPages.GetSize();

		T* pT = static_cast<T*>(this);
		_Module.AddCreateWndData(&m_thunk.cd, pT);

		HWND hWnd = (HWND)::PropertySheet(&m_psh);
		_CleanUpPages();	// ensure clean-up, required if call failed

		ATLASSERT(m_hWnd == hWnd);

		return hWnd;
	}

	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
	{
		ATLASSERT(m_hWnd == NULL);

		m_psh.dwFlags &= ~PSH_MODELESS;
		if(m_psh.hwndParent == NULL)
			m_psh.hwndParent = hWndParent;
		m_psh.phpage = (HPROPSHEETPAGE*)m_arrPages.GetData();
		m_psh.nPages = m_arrPages.GetSize();

		T* pT = static_cast<T*>(this);
		_Module.AddCreateWndData(&m_thunk.cd, pT);

		INT_PTR nRet = ::PropertySheet(&m_psh);
		_CleanUpPages();	// ensure clean-up, required if call failed

		return nRet;
	}

	// implementation helper - clean up pages array
	void _CleanUpPages()
	{
		m_psh.nPages = 0;
		m_psh.phpage = NULL;
		m_arrPages.RemoveAll();
	}

// Attributes (extended overrides of client class methods)
// These now can be called before the sheet is created
// Note: Calling these after the sheet is created gives unpredictable results
	int GetPageCount() const
	{
		if(m_hWnd == NULL)	// not created yet
			return m_arrPages.GetSize();
		return TBase::GetPageCount();
	}
	int GetActiveIndex() const
	{
		if(m_hWnd == NULL)	// not created yet
			return m_psh.nStartPage;
		return TBase::GetActiveIndex();
	}
	HPROPSHEETPAGE GetPage(int nPageIndex) const
	{
		ATLASSERT(m_hWnd == NULL);	// can't do this after it's created
		return (HPROPSHEETPAGE)m_arrPages[nPageIndex];
	}
	int GetPageIndex(HPROPSHEETPAGE hPage) const
	{
		ATLASSERT(m_hWnd == NULL);	// can't do this after it's created
		return m_arrPages.Find((_HPROPSHEETPAGE_TYPE&)hPage);
	}
	BOOL SetActivePage(int nPageIndex)
	{
		if(m_hWnd == NULL)	// not created yet
		{
			ATLASSERT(nPageIndex >= 0 && nPageIndex < m_arrPages.GetSize());
			m_psh.nStartPage = nPageIndex;
			return TRUE;
		}
		return TBase::SetActivePage(nPageIndex);
	}
	BOOL SetActivePage(HPROPSHEETPAGE hPage)
	{
		ATLASSERT(hPage != NULL);
		if (m_hWnd == NULL)	// not created yet
		{
			int nPageIndex = GetPageIndex(hPage);
			if(nPageIndex == -1)
				return FALSE;

			return SetActivePage(nPageIndex);
		}
		return TBase::SetActivePage(hPage);

	}
	void SetTitle(LPCTSTR lpszText, UINT nStyle = 0)
	{
		ATLASSERT((nStyle & ~PSH_PROPTITLE) == 0); // only PSH_PROPTITLE is valid
		ATLASSERT(lpszText != NULL);

		if(m_hWnd == NULL)
		{
			// set internal state
			m_psh.pszCaption = lpszText;	// must exist until sheet is created
			m_psh.dwFlags &= ~PSH_PROPTITLE;
			m_psh.dwFlags |= nStyle;
		}
		else
		{
			// set external state
			TBase::SetTitle(lpszText, nStyle);
		}
	}
	void SetWizardMode()
	{
		m_psh.dwFlags |= PSH_WIZARD;
	}
	void EnableHelp()
	{
		m_psh.dwFlags |= PSH_HASHELP;
	}

// Operations
	BOOL AddPage(HPROPSHEETPAGE hPage)
	{
		ATLASSERT(hPage != NULL);
		BOOL bRet = TRUE;
		if(m_hWnd != NULL)
			TBase::AddPage(hPage);
		else	// sheet not created yet, use internal data
			bRet = m_arrPages.Add((_HPROPSHEETPAGE_TYPE&)hPage);
		return bRet;
	}
	BOOL AddPage(LPCPROPSHEETPAGE pPage)
	{
		ATLASSERT(pPage != NULL);
		HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(pPage);
		if(hPage == NULL)
			return FALSE;
		BOOL bRet = AddPage(hPage);
		if(!bRet)
			::DestroyPropertySheetPage(hPage);
		return bRet;
	}
	BOOL RemovePage(HPROPSHEETPAGE hPage)
	{
		ATLASSERT(hPage != NULL);
		if (m_hWnd == NULL)		// not created yet
		{
			int nPage = GetPageIndex(hPage);
			if(nPage == -1)
				return FALSE;
			return RemovePage(nPage);
		}
		TBase::RemovePage(hPage);
		return TRUE;

	}
	BOOL RemovePage(int nPageIndex)
	{
		BOOL bRet = TRUE;
		if(m_hWnd != NULL)
			TBase::RemovePage(nPageIndex);
		else	// sheet not created yet, use internal data
			bRet = m_arrPages.RemoveAt(nPageIndex);
		return bRet;
	}

#if (_WIN32_IE >= 0x0400)
	void SetHeader(LPCTSTR szbmHeader)
	{
		ATLASSERT(m_hWnd == NULL);	// can't do this after it's created

		m_psh.dwFlags &= ~PSH_WIZARD;
		m_psh.dwFlags |= (PSH_HEADER | PSH_WIZARD97);
		m_psh.pszbmHeader = szbmHeader;
	}

	void SetHeader(HBITMAP hbmHeader)
	{
		ATLASSERT(m_hWnd == NULL);	// can't do this after it's created

		m_psh.dwFlags &= ~PSH_WIZARD;
		m_psh.dwFlags |= (PSH_HEADER | PSH_USEHBMHEADER | PSH_WIZARD97);
		m_psh.hbmHeader = hbmHeader;
	}

	void SetWatermark(LPCTSTR szbmWatermark, HPALETTE hplWatermark = NULL)
	{
		ATLASSERT(m_hWnd == NULL);	// can't do this after it's created

		m_psh.dwFlags &= ~PSH_WIZARD;
		m_psh.dwFlags |= PSH_WATERMARK | PSH_WIZARD97;
		m_psh.pszbmWatermark = szbmWatermark;

		if (hplWatermark != NULL)
		{
			m_psh.dwFlags |= PSH_USEHPLWATERMARK;
			m_psh.hplWatermark = hplWatermark;
		}
	}

	void SetWatermark(HBITMAP hbmWatermark, HPALETTE hplWatermark = NULL)
	{
		ATLASSERT(m_hWnd == NULL);	// can't do this after it's created

		m_psh.dwFlags &= ~PSH_WIZARD;
		m_psh.dwFlags |= (PSH_WATERMARK | PSH_USEHBMWATERMARK | PSH_WIZARD97);
		m_psh.hbmWatermark = hbmWatermark;

		if (hplWatermark != NULL)
		{
			m_psh.dwFlags |= PSH_USEHPLWATERMARK;
			m_psh.hplWatermark = hplWatermark;
		}
	}

	void StretchWatermark(bool bStretchWatermark)
	{
		ATLASSERT(m_hWnd == NULL);	// can't do this after it's created
		if (bStretchWatermark)
			m_psh.dwFlags |= PSH_STRETCHWATERMARK;
		else
			m_psh.dwFlags &= ~PSH_STRETCHWATERMARK;
	}
#endif

// Message map and handlers handlers
	typedef CPropertySheetImpl< T, TBase >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_COMMAND, OnCommand)
	END_MSG_MAP()

	LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
		if(HIWORD(wParam) == BN_CLICKED && (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &&
		   ((m_psh.dwFlags & PSH_MODELESS) != 0) && (GetActivePage() == NULL))
			DestroyWindow();
		return lRet;
	}
};

// for non-customized sheets
class CPropertySheet : public CPropertySheetImpl<CPropertySheet>
{
public:
	CPropertySheet(_U_STRINGorID title = (LPCTSTR)NULL, UINT uStartPage = 0, HWND hWndParent = NULL)
		: CPropertySheetImpl<CPropertySheet>(title, uStartPage, hWndParent)
	{ }

	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_COMMAND, CPropertySheetImpl<CPropertySheet>::OnCommand)
	END_MSG_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CPropertyPageWindow - client side for a property page

class CPropertyPageWindow : public CWindow
{
public:
// Constructors
	CPropertyPageWindow(HWND hWnd = NULL) : CWindow(hWnd) { }

	CPropertyPageWindow& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// Attributes
	CPropertySheetWindow GetPropertySheet() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return CPropertySheetWindow(GetParent());
	}

// Operations
	BOOL Apply()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		return GetPropertySheet().Apply();
	}
	void CancelToClose()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		GetPropertySheet().CancelToClose();
	}
	void SetModified(BOOL bChanged = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		GetPropertySheet().SetModified(m_hWnd, bChanged);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		return GetPropertySheet().QuerySiblings(wParam, lParam);
	}
	void RebootSystem()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		GetPropertySheet().RebootSystem();
	}
	void RestartWindows()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		GetPropertySheet().RestartWindows();
	}
	void SetWizardButtons(DWORD dwFlags)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);
		GetPropertySheet().SetWizardButtons(dwFlags);
	}

// Implementation - overrides to prevent usage
	HWND Create(LPCTSTR, HWND, _U_RECT = NULL, LPCTSTR = NULL, DWORD = 0, DWORD = 0, _U_MENUorID = 0U, LPVOID = NULL)
	{
		ATLASSERT(FALSE);
		return NULL;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CPropertyPageImpl - implements a property page

template <class T, class TBase /*= CPropertyPageWindow */ >
class ATL_NO_VTABLE CPropertyPageImpl : public CDialogImplBaseT< TBase >
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CPropertyPageImpl(_U_STRINGorID title = (LPCTSTR)NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = _Module.GetResourceInstance();
		T* pT = static_cast<T*>(this);
		m_psp.pszTemplate = MAKEINTRESOURCE(pT->IDD);
		m_psp.pfnDlgProc = T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)pT;

		if(title.m_lpstr != NULL)
			SetTitle(title);
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		hWnd;	// avoid level 4 warning
		if(uMsg == PSPCB_CREATE)
		{
			ATLASSERT(hWnd == NULL);
			CDialogImplBaseT< TBase >* pPage = (CDialogImplBaseT< TBase >*)(T*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

// Attributes
	void SetTitle(_U_STRINGorID title)
	{
		m_psp.pszTitle = title.m_lpstr;
		m_psp.dwFlags |= PSP_USETITLE;
	}

#if (_WIN32_IE >= 0x0500)
	void SetHeaderTitle(LPCTSTR lpstrHeaderTitle)
	{
		ATLASSERT(m_hWnd == NULL);	// can't do this after it's created
		m_psp.dwFlags |= PSP_USEHEADERTITLE;
		m_psp.pszHeaderTitle = lpstrHeaderTitle;
	}
	void SetHeaderSubTitle(LPCTSTR lpstrHeaderSubTitle)
	{
		ATLASSERT(m_hWnd == NULL);	// can't do this after it's created
		m_psp.dwFlags |= PSP_USEHEADERSUBTITLE;
		m_psp.pszHeaderSubTitle = lpstrHeaderSubTitle;
	}
#endif //(_WIN32_IE >= 0x0500)

// Operations
	void EnableHelp()
	{
		m_psp.dwFlags |= PSP_HASHELP;
	}

// Message map and handlers
	typedef CPropertyPageImpl< T, TBase >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()

	LRESULT OnNotify(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		NMHDR* pNMHDR = (NMHDR*)lParam;

		// don't handle messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = static_cast<T*>(this);
		LRESULT lResult = 0;
		switch(pNMHDR->code)
		{
		case PSN_SETACTIVE:
			lResult = pT->OnSetActive() ? 0 : -1;
			break;
		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;
		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;
		case PSN_RESET:
			pT->OnReset();
			break;
		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;
		case PSN_WIZNEXT:
			lResult = pT->OnWizardNext();
			break;
		case PSN_WIZBACK:
			lResult = pT->OnWizardBack();
			break;
		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;
		case PSN_HELP:
			pT->OnHelp();
			break;
#if (_WIN32_IE >= 0x0400)
		case PSN_GETOBJECT:
			if(!pT->OnGetObject((LPNMOBJECTNOTIFY)lParam))
				bHandled = FALSE;
			break;
#endif //(_WIN32_IE >= 0x0400)
#if (_WIN32_IE >= 0x0500)
		case PSN_TRANSLATEACCELERATOR:
			{
				LPPSHNOTIFY lpPSHNotify = (LPPSHNOTIFY)lParam;
				lResult = pT->OnTranslateAccelerator((LPMSG)lpPSHNotify->lParam) ? PSNRET_MESSAGEHANDLED : PSNRET_NOERROR;
			}
			break;
		case PSN_QUERYINITIALFOCUS:
			{
				LPPSHNOTIFY lpPSHNotify = (LPPSHNOTIFY)lParam;
				lResult = (LRESULT)pT->OnQueryInitialFocus((HWND)lpPSHNotify->lParam);
			}
			break;
#endif //(_WIN32_IE >= 0x0500)
		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

// Overridables
	BOOL OnSetActive()
	{
		return TRUE;
	}
	BOOL OnKillActive()
	{
		return TRUE;
	}
	BOOL OnApply()
	{
		return TRUE;
	}
	void OnReset()
	{
	}
	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	int OnWizardBack()
	{
		// 0  = goto next page
		// -1 = prevent page change
		// >0 = jump to page by dlg ID
		return 0;
	}
	int OnWizardNext()
	{
		// 0  = goto next page
		// -1 = prevent page change
		// >0 = jump to page by dlg ID
		return 0;
	}
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	void OnHelp()
	{
	}
#if (_WIN32_IE >= 0x0400)
	BOOL OnGetObject(LPNMOBJECTNOTIFY /*lpObjectNotify*/)
	{
		return FALSE;	// not processed
	}
#endif //(_WIN32_IE >= 0x0400)
#if (_WIN32_IE >= 0x0500)
	BOOL OnTranslateAccelerator(LPMSG /*lpMsg*/)
	{
		return FALSE;	// not translated
	}
	HWND OnQueryInitialFocus(HWND /*hWndFocus*/)
	{
		return NULL;	// default
	}
#endif //(_WIN32_IE >= 0x0500)
};

// for non-customized pages
template <WORD t_wDlgTemplateID>
class CPropertyPage : public CPropertyPageImpl<CPropertyPage<t_wDlgTemplateID> >
{
public:
	enum { IDD = t_wDlgTemplateID };

	CPropertyPage(_U_STRINGorID title = (LPCTSTR)NULL) : CPropertyPageImpl<CPropertyPage>(title)
	{ }

	DECLARE_EMPTY_MSG_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CAxPropertyPageImpl - property page that hosts ActiveX controls

#ifndef _ATL_NO_HOSTING

// Note: You must #include <atlhost.h> to use these classes

template <class T, class TBase = CPropertyPageWindow>
class ATL_NO_VTABLE CAxPropertyPageImpl : public CPropertyPageImpl< T, TBase >
{
public:
// Data members
	HGLOBAL m_hInitData;
	HGLOBAL m_hDlgRes;
	HGLOBAL m_hDlgResSplit;

// Constructor/destructor
	CAxPropertyPageImpl(_U_STRINGorID title = (LPCTSTR)NULL) : 
			CPropertyPageImpl< T, TBase >(title),
			m_hInitData(NULL), m_hDlgRes(NULL), m_hDlgResSplit(NULL)
	{
		T* pT = static_cast<T*>(this);
		pT;	// avoid level 4 warning

		// initialize ActiveX hosting and modify dialog template
		AtlAxWinInit();

		HINSTANCE hInstance = _Module.GetResourceInstance();
		LPCTSTR lpTemplateName = MAKEINTRESOURCE(pT->IDD);
		HRSRC hDlg = ::FindResource(hInstance, lpTemplateName, (LPTSTR)RT_DIALOG);
		if(hDlg != NULL)
		{
			HRSRC hDlgInit = ::FindResource(hInstance, lpTemplateName, (LPTSTR)_ATL_RT_DLGINIT);

			BYTE* pInitData = NULL;
			if(hDlgInit != NULL)
			{
				m_hInitData = ::LoadResource(hInstance, hDlgInit);
				pInitData = (BYTE*)::LockResource(m_hInitData);
			}

			m_hDlgRes = ::LoadResource(hInstance, hDlg);
			DLGTEMPLATE* pDlg = (DLGTEMPLATE*)::LockResource(m_hDlgRes);
			LPCDLGTEMPLATE lpDialogTemplate = _DialogSplitHelper::SplitDialogTemplate(pDlg, pInitData);
			if(lpDialogTemplate != pDlg)
				m_hDlgResSplit = ::GlobalHandle(lpDialogTemplate);

			// set up property page to use in-memory dialog template
			if(lpDialogTemplate != NULL)
			{
				m_psp.dwFlags |= PSP_DLGINDIRECT;
				m_psp.pResource = lpDialogTemplate;
			}
			else
			{
				ATLASSERT(FALSE && _T("CAxPropertyPageImpl - ActiveX initializtion failed!"));
			}
		}
		else
		{
			ATLASSERT(FALSE && _T("CAxPropertyPageImpl - Cannot find dialog template!"));
		}
	}

	~CAxPropertyPageImpl()
	{
		if(m_hInitData != NULL)
		{
			UnlockResource(m_hInitData);
			::FreeResource(m_hInitData);
		}
		if(m_hDlgRes != NULL)
		{
			UnlockResource(m_hDlgRes);
			::FreeResource(m_hDlgRes);
		}
		if(m_hDlgResSplit != NULL)
		{
			::GlobalFree(m_hDlgResSplit);
		}
	}

// Methods
	// call this one to handle keyboard message for ActiveX controls
	BOOL PreTranslateMessage(LPMSG pMsg)
	{
		if ((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
		   (pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
			return FALSE;
		// find a direct child of the dialog from the window that has focus
		HWND hWndCtl = ::GetFocus();
		if (IsChild(hWndCtl) && ::GetParent(hWndCtl) != m_hWnd)
		{
			do
			{
				hWndCtl = ::GetParent(hWndCtl);
			}
			while (::GetParent(hWndCtl) != m_hWnd);
		}
		// give controls a chance to translate this message
		return (BOOL)::SendMessage(hWndCtl, WM_FORWARDMSG, 0, (LPARAM)pMsg);
	}

// Overridables
#if (_WIN32_IE >= 0x0500)
	// new default implementation for ActiveX hosting pages
	BOOL OnTranslateAccelerator(LPMSG lpMsg)
	{
		T* pT = static_cast<T*>(this);
		return pT->PreTranslateMessage(lpMsg);
	}
#endif //(_WIN32_IE >= 0x0500)
};

// for non-customized pages
template <WORD t_wDlgTemplateID>
class CAxPropertyPage : public CAxPropertyPageImpl<CAxPropertyPage<t_wDlgTemplateID> >
{
public:
	enum { IDD = t_wDlgTemplateID };

	CAxPropertyPage(_U_STRINGorID title = (LPCTSTR)NULL) : CAxPropertyPageImpl<CAxPropertyPage>(title)
	{ }

#if (_WIN32_IE >= 0x0500)
	// not empty so we handle accelerators
	BEGIN_MSG_MAP(CAxPropertyPage)
		CHAIN_MSG_MAP(CAxPropertyPageImpl<CAxPropertyPage<t_wDlgTemplateID> >)
	END_MSG_MAP()
#else //!(_WIN32_IE >= 0x0500)
	DECLARE_EMPTY_MSG_MAP()
#endif //!(_WIN32_IE >= 0x0500)
};

#endif //_ATL_NO_HOSTING

}; //namespace WTL

#endif // __ATLDLGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wtl10\atlctrlw.h ===
// WTL Version 3.1
// Copyright (C) 1997-2000 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLCTRLW_H__
#define __ATLCTRLW_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlctrlw.h requires atlapp.h to be included first
#endif

#ifndef __ATLCTRLS_H__
	#error atlctrlw.h requires atlctrls.h to be included first
#endif

#if (_WIN32_IE < 0x0400)
	#error atlctrlw.h requires _WIN32_IE >= 0x0400
#endif


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Command Bars

// Window Styles:
#define CBRWS_TOP		CCS_TOP
#define CBRWS_BOTTOM		CCS_BOTTOM
#define CBRWS_NORESIZE		CCS_NORESIZE
#define CBRWS_NOPARENTALIGN	CCS_NOPARENTALIGN
#define CBRWS_NODIVIDER		CCS_NODIVIDER

// Extended styles
#define CBR_EX_TRANSPARENT	0x00000001L
#define CBR_EX_SHAREMENU	0x00000002L
#define CBR_EX_ALTFOCUSMODE	0x00000004L

// standard command bar styles
#define ATL_SIMPLE_CMDBAR_PANE_STYLE \
	(WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CBRWS_NODIVIDER | CBRWS_NORESIZE | CBRWS_NOPARENTALIGN)

// Messages - support chevrons for frame windows
#define CBRM_GETCMDBAR			(WM_USER + 301) // return command bar HWND
#define CBRM_GETMENU			(WM_USER + 302)	// returns loaded or attached menu
#define CBRM_TRACKPOPUPMENU		(WM_USER + 303)	// displays a popup menu

typedef struct tagCBRPOPUPMENU
{
	int cbSize;
	HMENU hMenu;		// popup menu do display
	UINT uFlags;		// TPM_* flags for ::TrackPopupMenuEx
	int x;
	int y;
	LPTPMPARAMS lptpm;	// ptr to TPMPARAMS for ::TrackPopupMenuEx
} CBRPOPUPMENU, *LPCBRPOPUPMENU;

// helper class
template <class T>
class CSimpleStack : public CSimpleArray< T >
{
public:
	BOOL Push(T t)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - STACK-PUSH (%8.8X) size = %i\n", t, GetSize());
#endif
		return Add(t);
	}
	T Pop()
	{
		int nLast = GetSize() - 1;
		if(nLast < 0)
			return NULL;	// must be able to convert to NULL
		T t = m_aT[nLast];
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - STACK-POP (%8.8X) size = %i\n", t, GetSize());
#endif
		if(!RemoveAt(nLast))
			return NULL;
		return t;
	}
	T GetCurrent()
	{
		int nLast = GetSize() - 1;
		if(nLast < 0)
			return NULL;	// must be able to convert to NULL
		return m_aT[nLast];
	}
};


/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T, class TBase = CCommandBarCtrlBase, class TWinTraits = CControlWinTraits> class CCommandBarCtrlImpl;
class CCommandBarCtrl;


/////////////////////////////////////////////////////////////////////////////
// CCommandBarCtrlBase - base class for the Command Bar implementation

class CCommandBarCtrlBase : public CToolBarCtrl
{
public:
	struct _MsgHookData
	{
		HHOOK hMsgHook;
		DWORD dwUsage;

		_MsgHookData() : hMsgHook(NULL), dwUsage(0) { }
	};

	typedef CSimpleMap<DWORD, _MsgHookData*>	CMsgHookMap;
	static CMsgHookMap* s_pmapMsgHook;

	static HHOOK s_hCreateHook;
	static bool s_bW2K;  // For animation flag
	static CCommandBarCtrlBase* s_pCurrentBar;
	static bool s_bStaticInit;

	CSimpleStack<HWND> m_stackMenuWnd;
	CSimpleStack<HMENU> m_stackMenuHandle;

	HWND m_hWndHook;
	DWORD m_dwMagic;


	CCommandBarCtrlBase() : m_hWndHook(NULL), m_dwMagic(1314)
	{
		// init static variables
		if(!s_bStaticInit)
		{
			::EnterCriticalSection(&_Module.m_csStaticDataInit);
			if(!s_bStaticInit)
			{
				// Just in case...
				INITCOMMONCONTROLSEX iccx;
				iccx.dwSize = sizeof(iccx);
				iccx.dwICC = ICC_COOL_CLASSES | ICC_BAR_CLASSES;
				::InitCommonControlsEx(&iccx);
				// Animation on Win2000 only
				s_bW2K = !AtlIsOldWindows();
				// done
				s_bStaticInit = true;
			}
			::LeaveCriticalSection(&_Module.m_csStaticDataInit);
		}
	}

	bool IsCommandBarBase() const { return m_dwMagic == 1314; }
};

__declspec(selectany) CCommandBarCtrlBase::CMsgHookMap* CCommandBarCtrlBase::s_pmapMsgHook = NULL;
__declspec(selectany) HHOOK CCommandBarCtrlBase::s_hCreateHook = NULL;
__declspec(selectany) CCommandBarCtrlBase* CCommandBarCtrlBase::s_pCurrentBar = NULL;
__declspec(selectany) bool CCommandBarCtrlBase::s_bW2K = false;
__declspec(selectany) bool CCommandBarCtrlBase::s_bStaticInit = false;


/////////////////////////////////////////////////////////////////////////////
// CCommandBarCtrl - ATL implementation of Command Bars

template <class T, class TBase /*= CCommandBarCtrlBase */, class TWinTraits /*= CControlWinTraits */ >
class ATL_NO_VTABLE CCommandBarCtrlImpl : public CWindowImpl< T, TBase, TWinTraits >
{
public:
	DECLARE_WND_SUPERCLASS(NULL, TBase::GetWndClassName())

// Declarations
	struct _MenuItemData	// menu item data
	{
		DWORD dwMagic;
		LPTSTR lpstrText;
		UINT fType;
		UINT fState;
		int iButton;

		_MenuItemData() { dwMagic = 0x1313; }
		bool IsCmdBarMenuItem() { return (dwMagic == 0x1313); }
	};

	struct _ToolBarData	// toolbar resource data
	{
		WORD wVersion;
		WORD wWidth;
		WORD wHeight;
		WORD wItemCount;
		//WORD aItems[wItemCount]

		WORD* items()
			{ return (WORD*)(this+1); }
	};

// Constants
	enum _CmdBarDrawConstants
	{
		s_kcxGap = 1,
		s_kcxTextMargin = 2,
		s_kcxButtonMargin = 3,
		s_kcyButtonMargin = 3
	};

	enum
	{
		_nMaxMenuItemTextLength = 100,
		_chChevronShortcut = _T('/')
	};

// Data members
	HMENU m_hMenu;
	HIMAGELIST m_hImageList;
	CSimpleValArray<WORD> m_arrCommand;

	CContainedWindow m_wndParent;
	CContainedWindow m_wndMDIClient;

	bool m_bMenuActive;
	bool m_bAttachedMenu;
	bool m_bImagesVisible;
	bool m_bPopupItem;
	bool m_bContextMenu;
	bool m_bEscapePressed;

	int m_nPopBtn;
	int m_nNextPopBtn;

	SIZE m_szBitmap;
	SIZE m_szButton;

	COLORREF m_clrMask;
	CFont m_fontMenu;

	bool m_bSkipMsg;
	UINT m_uSysKey;

	HWND m_hWndFocus;		// Alternate focus mode
	DWORD m_dwExtendedStyle;	// Command Bar specific extended styles

	bool m_bParentActive;

// Constructor/destructor
	CCommandBarCtrlImpl() : 
			m_hMenu(NULL), 
			m_hImageList(NULL), 
			m_wndParent(this, 1), 
			m_bMenuActive(false), 
			m_bAttachedMenu(false), 
			m_nPopBtn(-1), 
			m_nNextPopBtn(-1), 
			m_bPopupItem(false),
			m_bImagesVisible(true),
			m_wndMDIClient(this, 2),
			m_bSkipMsg(false),
			m_uSysKey(0),
			m_hWndFocus(NULL),
			m_bContextMenu(false),
			m_bEscapePressed(false),
			m_clrMask(RGB(192, 192, 192)),
			m_dwExtendedStyle(CBR_EX_TRANSPARENT | CBR_EX_SHAREMENU),
			m_bParentActive(true)
	{
		m_szBitmap.cx = 16;
		m_szBitmap.cy = 15;
		m_szButton.cx = m_szBitmap.cx + s_kcxButtonMargin;
		m_szButton.cy = m_szBitmap.cy + s_kcyButtonMargin;
 	}

	~CCommandBarCtrlImpl()
	{
		if(m_wndParent.IsWindow())
/*scary!*/			m_wndParent.UnsubclassWindow();

		if(m_wndMDIClient.IsWindow())
/*scary!*/			m_wndMDIClient.UnsubclassWindow();

		if(m_hMenu != NULL && (m_dwExtendedStyle & CBR_EX_SHAREMENU) == 0)
			::DestroyMenu(m_hMenu);

		if(m_hImageList != NULL)
			::ImageList_Destroy(m_hImageList);
	}

// Attributes
	DWORD GetCommandBarExtendedStyle() const
	{
		return m_dwExtendedStyle;
	}
	DWORD SetCommandBarExtendedStyle(DWORD dwExtendedStyle, DWORD dwMask = 0)
	{
		DWORD dwPrevStyle = m_dwExtendedStyle;
		if(dwMask == 0)
			m_dwExtendedStyle = dwExtendedStyle;
		else
			m_dwExtendedStyle = (m_dwExtendedStyle & ~dwMask) | (dwExtendedStyle & dwMask);
		return dwPrevStyle;
	}

	CMenuHandle GetMenu() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return m_hMenu;
	}

	COLORREF GetImageMaskColor() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return m_clrMask;
	}
	COLORREF SetImageMaskColor(COLORREF clrMask)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		COLORREF clrOld = m_clrMask;
		m_clrMask = clrMask;
		return clrOld;
	}

	bool GetImagesVisible() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return m_bImagesVisible;
	}
	bool SetImagesVisible(bool bVisible)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		bool bOld = m_bImagesVisible;
		m_bImagesVisible = bVisible;
		return bOld;
	}

	void GetImageSize(SIZE& size) const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		size = m_szBitmap;
	}
	bool SetImageSize(SIZE& size)
	{
		ATLASSERT(::IsWindow(m_hWnd));

		if(m_hImageList != NULL)
		{
			if(::ImageList_GetImageCount(m_hImageList) == 0)	// empty
			{
				::ImageList_Destroy(m_hImageList);
				m_hImageList = NULL;
			}
			else
			{
				return false;		// can't set, image list exists
			}
		}

		if(size.cx == 0 || size.cy == 0)
			return false;

		m_szBitmap = size;
		m_szButton.cx = m_szBitmap.cx + s_kcxButtonMargin;
		m_szButton.cy = m_szBitmap.cy + s_kcyButtonMargin;

		return true;
	}

	HWND GetCmdBar() const
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return (HWND)::SendMessage(m_hWnd, CBRM_GETCMDBAR, 0, 0L);
	}

// Methods
	HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			UINT nID = 0, LPVOID lpCreateParam = NULL)
	{
		// These styles are required for command bars
		dwStyle |= TBSTYLE_LIST | TBSTYLE_FLAT;
		return CWindowImpl< T, TBase, TWinTraits >::Create(hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
	}

	BOOL AttachToWindow(HWND hWnd)
	{
		ATLASSERT(m_hWnd == NULL);
		ATLASSERT(::IsWindow(hWnd));
		BOOL bRet = SubclassWindow(hWnd);
		if(bRet)
		{
			m_bAttachedMenu = true;
			GetSystemSettings();
		}
		return bRet;
	}

	BOOL LoadMenu(_U_STRINGorID menu)
	{
		ATLASSERT(::IsWindow(m_hWnd));

		if(m_bAttachedMenu)	// doesn't work in this mode
			return FALSE;
		if(menu.m_lpstr == NULL)
			return FALSE;

		HMENU hMenu = ::LoadMenu(_Module.GetResourceInstance(), menu.m_lpstr);
		if(hMenu == NULL)
			return FALSE;

		return AttachMenu(hMenu);
	}

	BOOL AttachMenu(HMENU hMenu)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(::IsMenu(hMenu));
		if(hMenu != NULL && !::IsMenu(hMenu))
			return FALSE;

		// destroy old menu, if needed, and set new one
		if(m_hMenu != NULL && (m_dwExtendedStyle & CBR_EX_SHAREMENU) == 0)
			::DestroyMenu(m_hMenu);
		m_hMenu = hMenu;

		if(m_bAttachedMenu)	// Nothing else in this mode
			return TRUE;

		// Build buttons according to menu
		SetRedraw(FALSE);

		// Clear all
		BOOL bRet;
		int nCount = GetButtonCount();
		for(int i = 0; i < nCount; i++)
		{
			bRet = DeleteButton(0);
			ATLASSERT(bRet);
		}


		// Add buttons for each menu item
		if(m_hMenu != NULL)
		{
			int nItems = ::GetMenuItemCount(m_hMenu);

			T* pT = static_cast<T*>(this);
			pT;	// avoid level 4 warning
			TCHAR szString[pT->_nMaxMenuItemTextLength];
			for(int i = 0; i < nItems; i++)
			{
				CMenuItemInfo mii;
				mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_SUBMENU;
				mii.fType = MFT_STRING;
				mii.dwTypeData = szString;
				mii.cch = pT->_nMaxMenuItemTextLength;
				bRet = ::GetMenuItemInfo(m_hMenu, i, TRUE, &mii);
				ATLASSERT(bRet);
				// If we have more than the buffer, we assume we have bitmaps bits
				if(lstrlen(szString) > pT->_nMaxMenuItemTextLength - 1)
				{
					mii.fType = MFT_BITMAP;
					::SetMenuItemInfo(m_hMenu, i, TRUE, &mii);
					szString[0] = 0;
				}

				// NOTE: Command Bar currently supports only drop-down menu items
				ATLASSERT(mii.hSubMenu != NULL);

				TBBUTTON btn;
				btn.iBitmap = 0;
				btn.idCommand = i;
				btn.fsState = (BYTE)(((mii.fState & MFS_DISABLED) == 0) ? TBSTATE_ENABLED : 0);
				btn.fsStyle = TBSTYLE_BUTTON | TBSTYLE_AUTOSIZE | TBSTYLE_DROPDOWN;
				btn.dwData = 0;
				btn.iString = 0;

				bRet = InsertButton(-1, &btn);
				ATLASSERT(bRet);

				TBBUTTONINFO bi;
				memset(&bi, 0, sizeof(bi));
				bi.cbSize = sizeof(TBBUTTONINFO);
				bi.dwMask = TBIF_TEXT;
				bi.pszText = szString;

				bRet = SetButtonInfo(i, &bi);
				ATLASSERT(bRet);
			}
		}

		SetRedraw(TRUE);
		Invalidate();
		UpdateWindow();

		return TRUE;
	}

	BOOL LoadImages(_U_STRINGorID image)
	{
		return _LoadImagesHelper(image, false);
	}

	BOOL LoadMappedImages(UINT nIDImage, UINT nFlags = 0, LPCOLORMAP lpColorMap = NULL, int nMapSize = 0)
	{
		return _LoadImagesHelper(nIDImage, true, nFlags , lpColorMap, nMapSize);
	}

	BOOL _LoadImagesHelper(_U_STRINGorID image, bool bMapped, UINT nFlags = 0, LPCOLORMAP lpColorMap = NULL, int nMapSize = 0)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		HINSTANCE hInstance = _Module.GetResourceInstance();

		HRSRC hRsrc = ::FindResource(hInstance, image.m_lpstr, (LPTSTR)RT_TOOLBAR);
		if(hRsrc == NULL)
			return FALSE;

		HGLOBAL hGlobal = ::LoadResource(hInstance, hRsrc);
		if(hGlobal == NULL)
			return FALSE;

		_ToolBarData* pData = (_ToolBarData*)::LockResource(hGlobal);
		if(pData == NULL)
			return FALSE;
		ATLASSERT(pData->wVersion == 1);

		WORD* pItems = pData->items();
		int nItems = pData->wItemCount;

		// Add bitmap to our image list (create it if it doesn't exist)
		if(m_hImageList == NULL)
		{
			m_hImageList = ::ImageList_Create(pData->wWidth, pData->wHeight, ILC_COLOR | ILC_MASK, pData->wItemCount, 1);
			ATLASSERT(m_hImageList != NULL);
			if(m_hImageList == NULL)
				return FALSE;
		}

		CBitmap bmp;
		if(bMapped)
		{
			ATLASSERT(HIWORD(PtrToUlong(image.m_lpstr)) == 0);	// if mapped, must be a numeric ID
			int nIDImage = (int)(short)LOWORD(PtrToUlong(image.m_lpstr));
			bmp.LoadMappedBitmap(nIDImage, (WORD)nFlags, lpColorMap, nMapSize);
		}
		else
		{
			bmp.LoadBitmap(image.m_lpstr);
		}
		ATLASSERT(bmp.m_hBitmap != NULL);
		if(bmp.m_hBitmap == NULL)
			return FALSE;
		if(::ImageList_AddMasked(m_hImageList, bmp, m_clrMask) == -1)
			return FALSE;

		// Fill the array with command IDs
		for(int i = 0; i < nItems; i++)
		{
			if(pItems[i] != 0)
				m_arrCommand.Add(pItems[i]);
		}

		ATLASSERT(::ImageList_GetImageCount(m_hImageList) == m_arrCommand.GetSize());
		if(::ImageList_GetImageCount(m_hImageList) != m_arrCommand.GetSize())
			return FALSE;

		// Set some internal stuff
		m_szBitmap.cx = pData->wWidth;
		m_szBitmap.cy = pData->wHeight;
		m_szButton.cx = m_szBitmap.cx + 2 * s_kcxButtonMargin;
		m_szButton.cy = m_szBitmap.cy + 2 * s_kcyButtonMargin;

		return TRUE;
	}

	BOOL AddBitmap(_U_STRINGorID bitmap, int nCommandID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		CBitmap bmp;
		bmp.LoadBitmap(bitmap.m_lpstr);
		if(bmp.m_hBitmap == NULL)
			return FALSE;
		return AddBitmap(bmp, nCommandID);
	}

	BOOL AddBitmap(HBITMAP hBitmap, UINT nCommandID)
	{
		// Create image list if it doesn't exist
		if(m_hImageList == NULL)
		{
			m_hImageList = ::ImageList_Create(m_szBitmap.cx, m_szBitmap.cy, ILC_COLOR | ILC_MASK, 1, 1);
			if(m_hImageList == NULL)
				return FALSE;
		}
		// check bitmap size
		CBitmapHandle bmp = hBitmap;
		SIZE size = { 0, 0 };
		bmp.GetSize(size);
		if(size.cx != m_szBitmap.cx || size.cy != m_szBitmap.cy)
		{
			ATLASSERT(FALSE);	// must match size!
			return FALSE;
		}
		// add bitmap
		int nRet = ::ImageList_AddMasked(m_hImageList, hBitmap, m_clrMask);
		if(nRet == -1)
			return FALSE;
		BOOL bRet = m_arrCommand.Add((WORD)nCommandID);
		ATLASSERT(::ImageList_GetImageCount(m_hImageList) == m_arrCommand.GetSize());
		return bRet;
	}

	BOOL AddIcon(HICON hIcon, UINT nCommandID)
	{
		// create image list if it doesn't exist
		if(m_hImageList == NULL)
		{
			m_hImageList = ::ImageList_Create(m_szBitmap.cx, m_szBitmap.cy, ILC_COLOR | ILC_MASK, 1, 1);
			if(m_hImageList == NULL)
				return FALSE;
		}

		int nRet = ::ImageList_AddIcon(m_hImageList, hIcon);
		if(nRet == -1)
			return FALSE;
		BOOL bRet = m_arrCommand.Add((WORD)nCommandID);
		ATLASSERT(::ImageList_GetImageCount(m_hImageList) == m_arrCommand.GetSize());
		return bRet;
	}

	BOOL ReplaceBitmap(_U_STRINGorID bitmap, int nCommandID)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		CBitmap bmp;
		bmp.LoadBitmap(bitmap.m_lpstr);
		if(bmp.m_hBitmap == NULL)
			return FALSE;
		return ReplaceBitmap(bmp, nCommandID);
	}

	BOOL ReplaceBitmap(HBITMAP hBitmap, UINT nCommandID)
	{
		BOOL bRet = FALSE;
		for(int i = 0; i < m_arrCommand.GetSize(); i++)
		{
			if(m_arrCommand[i] == nCommandID)
			{
				bRet = ::ImageList_Remove(m_hImageList, i);
				if(bRet)
					m_arrCommand.RemoveAt(i);
				break;
			}
		}
		if(bRet)
			bRet = AddBitmap(hBitmap, nCommandID);
		return bRet;
	}

	BOOL ReplaceIcon(HICON hIcon, UINT nCommandID)
	{
		BOOL bRet = FALSE;
		for(int i = 0; i < m_arrCommand.GetSize(); i++)
		{
			if(m_arrCommand[i] == nCommandID)
			{
				bRet = (::ImageList_ReplaceIcon(m_hImageList, i, hIcon) != -1);
				break;
			}
		}
		return bRet;
	}

	BOOL RemoveImage(int nCommandID)
	{
		ATLASSERT(::IsWindow(m_hWnd));

		BOOL bRet = FALSE;
		for(int i = 0; i < m_arrCommand.GetSize(); i++)
		{
			if(m_arrCommand[i] == nCommandID)
			{
				bRet = ::ImageList_Remove(m_hImageList, i);
				if(bRet)
					m_arrCommand.RemoveAt(i);
				break;
			}
		}
		return bRet;
	}

	BOOL RemoveAllImages()
	{
		ATLASSERT(::IsWindow(m_hWnd));

		ATLTRACE2(atlTraceUI, 0, "CmdBar - Removing all images\n");
		BOOL bRet = ::ImageList_RemoveAll(m_hImageList);
		if(bRet)
			m_arrCommand.RemoveAll();
		return bRet;
	}

	BOOL TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, LPTPMPARAMS lpParams = NULL)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(::IsMenu(hMenu));
		if(!::IsMenu(hMenu))
			return FALSE;
		m_bContextMenu = true;
		return DoTrackPopupMenu(hMenu, uFlags, x, y, lpParams);
	}

	// NOTE: Limited support for MDI - no icon or min/max/close buttons
	BOOL SetMDIClient(HWND hWndMDIClient)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(::IsWindow(hWndMDIClient));
		if(!::IsWindow(hWndMDIClient))
			return FALSE;
#ifdef _DEBUG
		LPCTSTR lpszMDIClientClass = _T("MDICLIENT");
		int nNameLen = lstrlen(lpszMDIClientClass) + 1;
		LPTSTR lpstrClassName = (LPTSTR)_alloca(nNameLen * sizeof(TCHAR));
		::GetClassName(hWndMDIClient, lpstrClassName, nNameLen);
		ATLASSERT(lstrcmpi(lpstrClassName, lpszMDIClientClass) == 0);
		if(lstrcmpi(lpstrClassName, lpszMDIClientClass) != 0)
			return FALSE;	// not an "MDIClient" window
#endif //_DEBUG
		if(m_wndMDIClient.IsWindow())
			m_wndMDIClient.UnsubclassWindow();	// scary!

		return m_wndMDIClient.SubclassWindow(hWndMDIClient);
	}

// Message map and handlers
	BEGIN_MSG_MAP(CCommandBarCtrlImpl)
		MESSAGE_HANDLER(WM_CREATE, OnCreate)
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
		MESSAGE_HANDLER(WM_INITMENU, OnInitMenu)
		MESSAGE_HANDLER(WM_INITMENUPOPUP, OnInitMenuPopup)
		MESSAGE_HANDLER(WM_MENUSELECT, OnMenuSelect)
		MESSAGE_HANDLER(GetAutoPopupMessage(), OnInternalAutoPopup)
		MESSAGE_HANDLER(GetGetBarMessage(), OnInternalGetBar)
		MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
		MESSAGE_HANDLER(WM_MENUCHAR, OnMenuChar)

		MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
		MESSAGE_HANDLER(WM_KEYUP, OnKeyUp)
		MESSAGE_HANDLER(WM_CHAR, OnChar)
		MESSAGE_HANDLER(WM_SYSKEYDOWN, OnSysKeyDown)
		MESSAGE_HANDLER(WM_SYSKEYUP, OnSysKeyUp)
		MESSAGE_HANDLER(WM_SYSCHAR, OnSysChar)
// public API handlers - these stay to support chevrons in atlframe.h
		MESSAGE_HANDLER(CBRM_GETMENU, OnAPIGetMenu)
		MESSAGE_HANDLER(CBRM_TRACKPOPUPMENU, OnAPITrackPopupMenu)
		MESSAGE_HANDLER(CBRM_GETCMDBAR, OnAPIGetCmdBar)

		MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
		MESSAGE_HANDLER(WM_MEASUREITEM, OnMeasureItem)

		MESSAGE_HANDLER(WM_FORWARDMSG, OnForwardMsg)
	ALT_MSG_MAP(1)		// Parent window messages
		NOTIFY_CODE_HANDLER(TBN_HOTITEMCHANGE, OnParentHotItemChange)
		NOTIFY_CODE_HANDLER(TBN_DROPDOWN, OnParentDropDown)
		MESSAGE_HANDLER(WM_INITMENUPOPUP, OnParentInitMenuPopup)
		MESSAGE_HANDLER(GetGetBarMessage(), OnParentInternalGetBar)
		MESSAGE_HANDLER(WM_SYSCOMMAND, OnParentSysCommand)
		MESSAGE_HANDLER(CBRM_GETMENU, OnParentAPIGetMenu)
		MESSAGE_HANDLER(WM_MENUCHAR, OnParentMenuChar)
		MESSAGE_HANDLER(CBRM_TRACKPOPUPMENU, OnParentAPITrackPopupMenu)
		MESSAGE_HANDLER(CBRM_GETCMDBAR, OnParentAPIGetCmdBar)

		MESSAGE_HANDLER(WM_DRAWITEM, OnParentDrawItem)
		MESSAGE_HANDLER(WM_MEASUREITEM, OnParentMeasureItem)

		MESSAGE_HANDLER(WM_ACTIVATE, OnParentActivate)
		NOTIFY_CODE_HANDLER(NM_CUSTOMDRAW, OnParentCustomDraw)
	ALT_MSG_MAP(2)		// MDI client window messages
		MESSAGE_HANDLER(WM_MDISETMENU, OnMDISetMenu)
	ALT_MSG_MAP(3)		// Message hook messages
		MESSAGE_HANDLER(WM_MOUSEMOVE, OnHookMouseMove)
		MESSAGE_HANDLER(WM_SYSKEYDOWN, OnHookSysKeyDown)
		MESSAGE_HANDLER(WM_SYSKEYUP, OnHookSysKeyUp)
		MESSAGE_HANDLER(WM_SYSCHAR, OnHookSysChar)
		MESSAGE_HANDLER(WM_KEYDOWN, OnHookKeyDown)
		MESSAGE_HANDLER(WM_NEXTMENU, OnHookNextMenu)
		MESSAGE_HANDLER(WM_CHAR, OnHookChar)
	END_MSG_MAP()

	LRESULT OnForwardMsg(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
	{
		LPMSG pMsg = (LPMSG)lParam;
		LRESULT lRet = 0;
		ProcessWindowMessage(pMsg->hwnd, pMsg->message, pMsg->wParam, pMsg->lParam, lRet, 3);
		return lRet;
	}

	LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		// Let the toolbar initialize itself
		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
		// get and use system settings
		GetSystemSettings();
		// Parent init
		CWindow wndParent = GetParent();
		CWindow wndTopLevelParent = wndParent.GetTopLevelParent();
		m_wndParent.SubclassWindow(wndTopLevelParent);
		// Toolbar Init
		SetButtonStructSize();
		SetImageList(NULL);

		// Create message hook if needed
		::EnterCriticalSection(&_Module.m_csWindowCreate);
		if(s_pmapMsgHook == NULL)
		{
			ATLTRY(s_pmapMsgHook = new CMsgHookMap);
			ATLASSERT(s_pmapMsgHook != NULL);
		}

		if(s_pmapMsgHook != NULL)
		{
			DWORD dwThreadID = ::GetCurrentThreadId();
			_MsgHookData* pData = s_pmapMsgHook->Lookup(dwThreadID);
			if(pData == NULL)
			{
				ATLTRY(pData = new _MsgHookData);
				ATLASSERT(pData != NULL);
				HHOOK hMsgHook = ::SetWindowsHookEx(WH_GETMESSAGE, MessageHookProc, _Module.GetModuleInstance(), dwThreadID);
				ATLASSERT(hMsgHook != NULL);
				if(pData != NULL && hMsgHook != NULL)
				{
					pData->hMsgHook = hMsgHook;
					pData->dwUsage = 1;
					BOOL bRet = s_pmapMsgHook->Add(dwThreadID, pData);
					bRet;
					ATLASSERT(bRet);
				}
			}
			else
			{
				(pData->dwUsage)++;
			}
		}
		::LeaveCriticalSection(&_Module.m_csWindowCreate);

		return lRet;
	}

	LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
		::EnterCriticalSection(&_Module.m_csWindowCreate);
		ATLASSERT(s_pmapMsgHook != NULL);
		if(s_pmapMsgHook != NULL)
		{
			DWORD dwThreadID = ::GetCurrentThreadId();
			_MsgHookData* pData = s_pmapMsgHook->Lookup(dwThreadID);
			if(pData != NULL)
			{
				(pData->dwUsage)--;
				if(pData->dwUsage == 0)
				{
					BOOL bRet = ::UnhookWindowsHookEx(pData->hMsgHook);
					ATLASSERT(bRet);
					bRet = s_pmapMsgHook->Remove(dwThreadID);
					ATLASSERT(bRet);
					if(bRet)
						delete pData;
				}

				if(s_pmapMsgHook->GetSize() == 0)
				{
					delete s_pmapMsgHook;
					s_pmapMsgHook = NULL;
				}
			}
		}
		::LeaveCriticalSection(&_Module.m_csWindowCreate);
		return lRet;
	}

	LRESULT OnKeyDown(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - OnKeyDown\n");
#endif
		// Simulate Alt+Space for the parent
		if(wParam == VK_SPACE)
		{
			m_wndParent.PostMessage(WM_SYSKEYDOWN, wParam, lParam | (1 << 29));
			bHandled = TRUE;
			return 0;
		}
		bHandled = FALSE;
		return 0;
	}

	LRESULT OnKeyUp(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - OnKeyUp\n");
#endif
		if(wParam != VK_SPACE)
			bHandled = FALSE;
		return 0;
	}

	LRESULT OnChar(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - OnChar\n");
#endif
		if(wParam != VK_SPACE)
			bHandled = FALSE;
		else
			return 0;
		// Security
		if(!m_wndParent.IsWindowEnabled() || ::GetFocus() != m_hWnd)
			return 0;

		// Handle mnemonic press when we have focus
		int nID = 0;
		if(wParam != VK_RETURN && !MapAccelerator((TCHAR)LOWORD(wParam), nID))
		{
			::MessageBeep(0);
		}
		else
		{
			PostMessage(WM_KEYDOWN, VK_DOWN, 0L);
			if(wParam != VK_RETURN)
				SetHotItem(nID);
		}
		return 0;
	}

	LRESULT OnSysKeyDown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - OnSysKeyDown\n");
#endif
		bHandled = FALSE;
		return 0;
	}

	LRESULT OnSysKeyUp(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - OnSysKeyUp\n");
#endif
		bHandled = FALSE;
		return 0;
	}

	LRESULT OnSysChar(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - OnSysChar\n");
#endif
		bHandled = FALSE;
		return 0;
	}

	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(m_bAttachedMenu || (m_dwExtendedStyle & CBR_EX_TRANSPARENT))
		{
			bHandled = FALSE;
			return 0;
		}

		RECT rect;
		GetClientRect(&rect);
		::FillRect((HDC)wParam, &rect, (HBRUSH)LongToPtr(COLOR_MENU + 1));

		return 1;	// don't do the default erase
	}

	LRESULT OnInitMenu(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		int nIndex = GetHotItem();
		SendMessage(WM_MENUSELECT, MAKEWPARAM(nIndex, MF_POPUP|MF_HILITE), (LPARAM)m_hMenu);
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnInitMenuPopup(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		if((BOOL)HIWORD(lParam))	// System menu, do nothing
		{
			bHandled = FALSE;
			return 1;
		}

		if(!(m_bAttachedMenu || m_bMenuActive))		// Not attached or ours, do nothing
		{
			bHandled = FALSE;
			return 1;
		}

		ATLTRACE2(atlTraceUI, 0, "CmdBar - OnInitMenuPopup\n");

		// forward to the parent or subclassed window, so it can handle update UI
		LRESULT lRet = 0;
		if(m_bAttachedMenu)
			lRet = DefWindowProc(uMsg, wParam, (lParam || m_bContextMenu) ? lParam : GetHotItem());
		else
			lRet = m_wndParent.DefWindowProc(uMsg, wParam, (lParam || m_bContextMenu) ? lParam : GetHotItem());

		// Convert menu items to ownerdraw, add our data
		if(m_bImagesVisible)
		{
			CMenuHandle menuPopup = (HMENU)wParam;
			ATLASSERT(menuPopup.m_hMenu != NULL);

			T* pT = static_cast<T*>(this);
			pT;	// avoid level 4 warning
			TCHAR szString[pT->_nMaxMenuItemTextLength];
			BOOL bRet;
			for(int i = 0; i < menuPopup.GetMenuItemCount(); i++)
			{
				CMenuItemInfo mii;
				mii.cch = pT->_nMaxMenuItemTextLength;
				mii.fMask = MIIM_CHECKMARKS | MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_SUBMENU | MIIM_TYPE;
				mii.dwTypeData = szString;
				bRet = menuPopup.GetMenuItemInfo(i, TRUE, &mii);
				ATLASSERT(bRet);

				if(!(mii.fType & MFT_OWNERDRAW))	// Not already an ownerdraw item
				{
					mii.fMask = MIIM_DATA | MIIM_TYPE | MIIM_STATE;
					_MenuItemData* pMI = NULL;
					ATLTRY(pMI = new _MenuItemData);
					ATLASSERT(pMI != NULL);
					if(pMI != NULL)
					{
						pMI->fType = mii.fType;
						pMI->fState = mii.fState;
						mii.fType |= MFT_OWNERDRAW;
						pMI->iButton = -1;
						for(int j = 0; j < m_arrCommand.GetSize(); j++)
						{
							if(m_arrCommand[j] == mii.wID)
							{
								pMI->iButton = j;
								break;
							}
						}
						pMI->lpstrText = NULL;
						ATLTRY(pMI->lpstrText = new TCHAR[lstrlen(szString) + 1]);
						ATLASSERT(pMI->lpstrText != NULL);
						if(pMI->lpstrText != NULL)
							lstrcpy(pMI->lpstrText, szString);
						mii.dwItemData = (ULONG_PTR)pMI;
						bRet = menuPopup.SetMenuItemInfo(i, TRUE, &mii);
						ATLASSERT(bRet);
					}
				}
			}

			// Add it to the list
			m_stackMenuHandle.Push(menuPopup.m_hMenu);
		}

		return lRet;
	}

	LRESULT OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		if(!m_bAttachedMenu)	// Not attached, do nothing, forward to parent
		{
			m_bPopupItem = (lParam != NULL) && ((HMENU)lParam != m_hMenu) && (HIWORD(wParam) & MF_POPUP);
			if(m_wndParent.IsWindow())
				m_wndParent.SendMessage(uMsg, wParam, lParam);
			bHandled = FALSE;
			return 1;
		}

		// Check if a menu is closing, do a cleanup
		if(HIWORD(wParam) == 0xFFFF && lParam == NULL)	// Menu closing
		{
#ifdef _CMDBAR_EXTRA_TRACE
			ATLTRACE2(atlTraceUI, 0, "CmdBar - OnMenuSelect - CLOSING!!!!\n");
#endif
			ATLASSERT(m_stackMenuWnd.GetSize() == 0);
			// Restore the menu items to the previous state for all menus that were converted
			if(m_bImagesVisible)
			{
				HMENU hMenu;
				while((hMenu = m_stackMenuHandle.Pop()) != NULL)
				{
					CMenuHandle menuPopup = hMenu;
					ATLASSERT(menuPopup.m_hMenu != NULL);
					// Restore state and delete menu item data
					BOOL bRet;
					for(int i = 0; i < menuPopup.GetMenuItemCount(); i++)
					{
						CMenuItemInfo mii;
						mii.fMask = MIIM_DATA | MIIM_TYPE;
						bRet = menuPopup.GetMenuItemInfo(i, TRUE, &mii);
						ATLASSERT(bRet);

						_MenuItemData* pMI = (_MenuItemData*)mii.dwItemData;
						if(pMI != NULL && pMI->IsCmdBarMenuItem())
						{
							mii.fMask = MIIM_DATA | MIIM_TYPE | MIIM_STATE;
							mii.fType = pMI->fType;
							mii.dwTypeData = pMI->lpstrText;
							mii.cch = lstrlen(pMI->lpstrText);
							mii.dwItemData = NULL;

							bRet = menuPopup.SetMenuItemInfo(i, TRUE, &mii);
							ATLASSERT(bRet);

							delete [] pMI->lpstrText;
							pMI->dwMagic = 0x6666;
							delete pMI;
						}
					}
				}
			}
		}

		bHandled = FALSE;
		return 1;
	}

	LRESULT OnInternalAutoPopup(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		int nIndex = (int)wParam;
		DoPopupMenu(nIndex, false);
		return 0;
	}

	LRESULT OnInternalGetBar(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		// Let's make sure we're not embedded in another process
		if(wParam && !::IsBadWritePtr((LPVOID)wParam, sizeof DWORD))
			*((DWORD*)wParam) = GetCurrentProcessId();
		if(IsWindowVisible())
			return (LRESULT)static_cast<CCommandBarCtrlBase*>(this);
		else
			return NULL;
	}

	LRESULT OnSettingChange(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		GetSystemSettings();
		return 0;
	}

	LRESULT OnWindowPosChanging(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);

		LPWINDOWPOS lpWP = (LPWINDOWPOS)lParam;
		int cyMin = ::GetSystemMetrics(SM_CYMENU);
		if(lpWP->cy < cyMin)
		lpWP->cy = cyMin;

		return lRet;
	}

	LRESULT OnMenuChar(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - OnMenuChar\n");
#endif
		bHandled = TRUE;
		LRESULT lRet;

		if(m_bMenuActive && LOWORD(wParam) != 0x0D)
			lRet = 0;
		else
			lRet = MAKELRESULT(1, 1);
		if(m_bMenuActive && HIWORD(wParam) == MF_POPUP)
		{
			T* pT = static_cast<T*>(this);
			pT;	// avoid level 4 warning

			// Convert character to lower/uppercase and possibly Unicode, using current keyboard layout
			TCHAR ch = (TCHAR)LOWORD(wParam);
			CMenuHandle menu = (HMENU)lParam;
			int nCount = ::GetMenuItemCount(menu);
			int nRetCode = MNC_EXECUTE;
			BOOL bRet;
			TCHAR szString[pT->_nMaxMenuItemTextLength];
			WORD wMnem = 0;
			bool bFound = false;
			for(int i = 0; i < nCount; i++)
			{
				CMenuItemInfo mii;
				mii.cch = pT->_nMaxMenuItemTextLength;
				mii.fMask = MIIM_CHECKMARKS | MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_SUBMENU | MIIM_TYPE;
				mii.dwTypeData = szString;
				bRet = menu.GetMenuItemInfo(i, TRUE, &mii);
				if(!bRet || (mii.fType & MFT_SEPARATOR))
					continue;
				_MenuItemData* pmd = (_MenuItemData*)mii.dwItemData;
				if(pmd != NULL && pmd->IsCmdBarMenuItem())
				{
					LPTSTR p = pmd->lpstrText;

					if(p != NULL)
					{
						while(*p && *p != _T('&'))
							p = ::CharNext(p);
						if(p != NULL && *p)
						{
							DWORD dwP = MAKELONG(*(++p), 0);
							DWORD dwC = MAKELONG(ch, 0);
							if(::CharLower((LPTSTR)ULongToPtr(dwP)) == ::CharLower((LPTSTR)ULongToPtr(dwC)))
							{
								if(!bFound)
								{
									wMnem = (WORD)i;
									bFound = true;
									PostMessage(TB_SETHOTITEM, (WPARAM)-1, 0L);
									GiveFocusBack();
								}
								else
								{
									nRetCode = MNC_SELECT;
									break;
								}
							}
						}
					}
				}
			}
			if(bFound)
			{
				bHandled = TRUE;
				lRet = MAKELRESULT(wMnem, nRetCode);
			}
		} 
		else if(!m_bMenuActive)
		{
			int nID = 0;
			if(!MapAccelerator((TCHAR)LOWORD(wParam), nID))
			{
				bHandled = FALSE;
				PostMessage(TB_SETHOTITEM, (WPARAM)-1, 0L);
				GiveFocusBack();

#if (_WIN32_IE >= 0x0500)
				// check if we should display chevron menu
				T* pT = static_cast<T*>(this);
				pT;	// avoid level 4 warning
				if((TCHAR)LOWORD(wParam) == pT->_chChevronShortcut)
				{
					// assume we are in a rebar
					HWND hWndReBar = GetParent();
					int nCount = (int)::SendMessage(hWndReBar, RB_GETBANDCOUNT, 0, 0L);
					for(int i = 0; i < nCount; i++)
					{
						REBARBANDINFO rbbi = { sizeof(REBARBANDINFO), RBBIM_CHILD | RBBIM_STYLE };
						BOOL bRet = (BOOL)::SendMessage(hWndReBar, RB_GETBANDINFO, i, (LPARAM)&rbbi);
						if(bRet && rbbi.hwndChild == m_hWnd && (rbbi.fStyle & RBBS_USECHEVRON) != 0)
						{
							::PostMessage(hWndReBar, RB_PUSHCHEVRON, i, 0L);
							PostMessage(WM_KEYDOWN, VK_DOWN, 0L);
							bHandled = TRUE;
							break;
						}
					}
				}
#endif //(_WIN32_IE >= 0x0500)
			}
			else if(m_wndParent.IsWindowEnabled())
			{
				TakeFocus();
				PostMessage(WM_KEYDOWN, VK_DOWN, 0L);
				SetHotItem(nID);
			}
		}

		return lRet;
	}

	LRESULT OnDrawItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		LPDRAWITEMSTRUCT lpDrawItemStruct = (LPDRAWITEMSTRUCT)lParam;
		_MenuItemData* pmd = (_MenuItemData*)lpDrawItemStruct->itemData;
		if(lpDrawItemStruct->CtlType == ODT_MENU && pmd->IsCmdBarMenuItem())
		{
			T* pT = static_cast<T*>(this);
			pT->DrawItem(lpDrawItemStruct);
		}
		else
		{
			bHandled = FALSE;
		}
		return (LRESULT)TRUE;
	}

	LRESULT OnMeasureItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		LPMEASUREITEMSTRUCT lpMeasureItemStruct = (LPMEASUREITEMSTRUCT)lParam;
		_MenuItemData* pmd = (_MenuItemData*)lpMeasureItemStruct->itemData;
		if(lpMeasureItemStruct->CtlType == ODT_MENU && pmd->IsCmdBarMenuItem())
		{
			T* pT = static_cast<T*>(this);
			pT->MeasureItem(lpMeasureItemStruct);
		}
		else
		{
			bHandled = FALSE;
		}
		return (LRESULT)TRUE;
	}

// API message handlers
	LRESULT OnAPIGetMenu(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		return (LRESULT)m_hMenu;
	}

	LRESULT OnAPITrackPopupMenu(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
	{
		if(lParam == NULL)
			return FALSE;
		LPCBRPOPUPMENU lpCBRPopupMenu = (LPCBRPOPUPMENU)lParam;
		if(lpCBRPopupMenu->cbSize != sizeof(CBRPOPUPMENU))
			return FALSE;
		if(!::IsMenu(lpCBRPopupMenu->hMenu))
			return FALSE;

		m_bContextMenu = true;
		return DoTrackPopupMenu(lpCBRPopupMenu->hMenu, lpCBRPopupMenu->uFlags, lpCBRPopupMenu->x, lpCBRPopupMenu->y, lpCBRPopupMenu->lptpm);
	}

	LRESULT OnAPIGetCmdBar(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		return (LRESULT)m_hWnd;
	}

// Parent window message handlers
	// Do not hot track if application in background, OK for modeless dialogs
	LRESULT OnParentHotItemChange(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
	{
		DWORD dwProcessID;
		::GetWindowThreadProcessId(::GetActiveWindow(), &dwProcessID);

		LPNMTBHOTITEM lpNMHT = (LPNMTBHOTITEM)pnmh;

		// Check if this comes from us
		if(pnmh->hwndFrom != m_hWnd)
		{
			bHandled = FALSE;
			return 0;
		}

		if((!m_wndParent.IsWindowEnabled() || ::GetCurrentProcessId() != dwProcessID) && lpNMHT->dwFlags & HICF_MOUSE)
		{
			return 1;
		}
		else
		{
#ifndef HICF_LMOUSE
			const DWORD HICF_LMOUSE = 0x00000080;	// left mouse button selected
#endif
			bHandled = FALSE;

			// Send WM_MENUSELECT to the app if it needs to display a status text
			if(!(lpNMHT->dwFlags & HICF_MOUSE)	
				&& !(lpNMHT->dwFlags & HICF_ACCELERATOR)
				&& !(lpNMHT->dwFlags & HICF_LMOUSE))
			{
				if(lpNMHT->dwFlags & HICF_ENTERING)
					m_wndParent.SendMessage(WM_MENUSELECT, 0, (LPARAM)m_hMenu);
				if(lpNMHT->dwFlags & HICF_LEAVING)
					m_wndParent.SendMessage(WM_MENUSELECT, MAKEWPARAM(0, 0xFFFF), NULL);
			}

			return 0;
		}
	}

	LRESULT OnParentDropDown(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
	{
		// Check if this comes from us
		if(pnmh->hwndFrom != m_hWnd)
		{
			bHandled = FALSE;
			return 1;
		}

		if(::GetFocus() != m_hWnd)
			TakeFocus();
		LPNMTOOLBAR pNMToolBar = (LPNMTOOLBAR)pnmh;
		int nIndex = CommandToIndex(pNMToolBar->iItem);
		m_bContextMenu = false;
		m_bEscapePressed = false;
		DoPopupMenu(nIndex, true);

		return TBDDRET_DEFAULT;
	}

	LRESULT OnParentInitMenuPopup(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return OnInitMenuPopup(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnParentInternalGetBar(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return OnInternalGetBar(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnParentSysCommand(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		bHandled = FALSE;
		if((m_uSysKey == VK_MENU 
			|| (m_uSysKey == VK_F10 && !(::GetKeyState(VK_SHIFT) & 0x80))
			|| m_uSysKey == VK_SPACE) 
			&& wParam == SC_KEYMENU)
		{
			if(::GetFocus() == m_hWnd)
			{
				GiveFocusBack();		// exit menu "loop"
				PostMessage(TB_SETHOTITEM, (WPARAM)-1, 0L);
			}
			else if(m_uSysKey != VK_SPACE && !m_bSkipMsg)
			{
				TakeFocus();			// enter menu "loop"
				bHandled = TRUE;
			}
			else if(m_uSysKey != VK_SPACE)
			{
				bHandled = TRUE;
			}
		}
		m_bSkipMsg = false;
		return 0;
	}

	LRESULT OnParentAPIGetMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return OnAPIGetMenu(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnParentMenuChar(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return OnMenuChar(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnParentAPITrackPopupMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return OnAPITrackPopupMenu(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnParentAPIGetCmdBar(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return OnAPIGetCmdBar(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnParentDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return OnDrawItem(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnParentMeasureItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return OnMeasureItem(uMsg, wParam, lParam, bHandled);
	}

	LRESULT OnParentActivate(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		m_bParentActive = (wParam != WA_INACTIVE);
		Invalidate();
		UpdateWindow();
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnParentCustomDraw(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
	{
		LRESULT lRet = CDRF_DODEFAULT;
		bHandled = FALSE;
		if(pnmh->hwndFrom == m_hWnd)
		{
			LPNMTBCUSTOMDRAW lpTBCustomDraw = (LPNMTBCUSTOMDRAW)pnmh;
			if(lpTBCustomDraw->nmcd.dwDrawStage == CDDS_PREPAINT)
			{
				lRet = CDRF_NOTIFYITEMDRAW;
				bHandled = TRUE;
			}
			else if(lpTBCustomDraw->nmcd.dwDrawStage == CDDS_ITEMPREPAINT && !m_bParentActive)
			{
				lpTBCustomDraw->clrText = ::GetSysColor(COLOR_GRAYTEXT);
				bHandled = TRUE;
			}
		}
		return lRet;
	}

// MDI client window message handlers
	LRESULT OnMDISetMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		m_wndMDIClient.DefWindowProc(uMsg, NULL, lParam);
		HMENU hOldMenu = GetMenu();
		BOOL bRet = AttachMenu((HMENU)wParam);
		bRet;
		ATLASSERT(bRet);
		return (LRESULT)hOldMenu;
	}

// Message hook handlers
	LRESULT OnHookMouseMove(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		static POINT s_point = { -1, -1 };
		DWORD dwPoint = ::GetMessagePos();
		POINT point = { GET_X_LPARAM(dwPoint), GET_Y_LPARAM(dwPoint) };

		bHandled = FALSE;
		if(m_bMenuActive)
		{
			if(::WindowFromPoint(point) == m_hWnd)
			{
				ScreenToClient(&point);
				int nHit = HitTest(&point);

				if((point.x != s_point.x || point.y != s_point.y) && nHit >= 0 && nHit < ::GetMenuItemCount(m_hMenu) && nHit != m_nPopBtn && m_nPopBtn != -1)
				{
					TBBUTTON tbb;
					GetButton(nHit, &tbb);
					if((tbb.fsState & TBSTATE_ENABLED) != 0)
					{
						m_nNextPopBtn = nHit | 0xFFFF0000;
						HWND hWndMenu = m_stackMenuWnd.GetCurrent();
						ATLASSERT(hWndMenu != NULL);

						// this one is needed to close a menu if mouse button was down
						::PostMessage(hWndMenu, WM_LBUTTONUP, 0, MAKELPARAM(point.x, point.y));
						// this one closes a popup menu
						::PostMessage(hWndMenu, WM_KEYDOWN, VK_ESCAPE, 0L);

						bHandled = TRUE;
					}
				}
			}
		}
		else
		{
			ScreenToClient(&point);
		}

		s_point = point;
		return 0;
	}

	LRESULT OnHookSysKeyDown(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		bHandled = FALSE;
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - Hook WM_SYSKEYDOWN (0x%2.2X)\n", wParam);
#endif

		if(wParam != VK_SPACE && (!m_bMenuActive && ::GetFocus() == m_hWnd) || m_bMenuActive)
		{
			PostMessage(TB_SETHOTITEM, (WPARAM)-1, 0L);
			GiveFocusBack();
			if(!m_bMenuActive)
				m_bSkipMsg = true;
		}
		else
		{
			m_uSysKey = (UINT)wParam;
		}
		return 0;
	}

	LRESULT OnHookSysKeyUp(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		bHandled = FALSE;
		wParam;
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - Hook WM_SYSKEYUP (0x%2.2X)\n", wParam);
#endif
		return 0;
	}

	LRESULT OnHookSysChar(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		bHandled = FALSE;
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - Hook WM_SYSCHAR (0x%2.2X)\n", wParam);
#endif

		if(!m_bMenuActive && m_hWndHook != m_hWnd && wParam != VK_SPACE)
			bHandled = TRUE;
		return 0;
	}

	LRESULT OnHookKeyDown(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - Hook WM_KEYDOWN (0x%2.2X)\n", wParam);
#endif
		bHandled = FALSE;

		if(wParam == VK_ESCAPE)
		{
			if(m_bMenuActive && !m_bContextMenu)
			{
				int nHot = GetHotItem();
				if(nHot == -1)
					nHot = m_nPopBtn;
				if(nHot == -1)
					nHot = 0;
				SetHotItem(nHot);
				bHandled = TRUE;
				TakeFocus();
				m_bEscapePressed = true; // To keep focus
			}
			else if(::GetFocus() == m_hWnd && m_wndParent.IsWindow())
			{
				SetHotItem(-1);
				GiveFocusBack();
				bHandled = TRUE;
			}
		}
		else if(wParam == VK_RETURN || wParam == VK_UP || wParam == VK_DOWN)
		{
			if(!m_bMenuActive && ::GetFocus() == m_hWnd && m_wndParent.IsWindow())
			{
				int nHot = GetHotItem();
				if(nHot != -1)
				{
					if(wParam != VK_RETURN)
					{
// IE4 only: WM_KEYDOWN doesn't generate TBN_DROPDOWN, we need to simulate a mouse click
#if (_WIN32_IE < 0x0500)
						DWORD dwMajor = 0, dwMinor = 0;
						AtlGetCommCtrlVersion(&dwMajor, &dwMinor);
						if(dwMajor <= 4 || (dwMajor == 5 && dwMinor < 80))
						{
							RECT rect;
							GetItemRect(nHot, &rect);
							PostMessage(WM_LBUTTONDOWN, MK_LBUTTON, MAKELPARAM(rect.left, rect.top));
						}
#endif //(_WIN32_IE < 0x0500)
						PostMessage(WM_KEYDOWN, VK_DOWN, 0L);
					}
				}
				else
				{
					ATLTRACE2(atlTraceUI, 0, "CmdBar - Can't find hot button\n");
				}
			}
			if(wParam == VK_RETURN && m_bMenuActive)
			{
				PostMessage(TB_SETHOTITEM, (WPARAM)-1, 0L);
				m_nNextPopBtn = -1;
				GiveFocusBack();
			}
		}
		else if(wParam == VK_LEFT || wParam == VK_RIGHT)
		{
#if (WINVER >= 0x0500)
			bool bRTL = ((GetExStyle() & WS_EX_LAYOUTRTL) != 0);
			WPARAM wpNext = bRTL ? VK_LEFT : VK_RIGHT;
			WPARAM wpPrev = bRTL ? VK_RIGHT : VK_LEFT;
#else // !(WINVER >= 0x0500)
			WPARAM wpNext = VK_RIGHT;
			WPARAM wpPrev = VK_LEFT;
#endif // !(WINVER >= 0x0500)

			if(m_bMenuActive && !m_bContextMenu && !(wParam == wpNext && m_bPopupItem))
			{
				bool bAction = false;
				T* pT = static_cast<T*>(this);
				if(wParam == wpPrev && s_pCurrentBar->m_stackMenuWnd.GetSize() == 1)
				{
					m_nNextPopBtn = pT->GetPreviousMenuItem();
					if(m_nNextPopBtn != -1)
						bAction = true;
				}
				else if(wParam == wpNext)
				{
					m_nNextPopBtn = pT->GetNextMenuItem();;
					if(m_nNextPopBtn != -1)
						bAction = true;
				}
				HWND hWndMenu = m_stackMenuWnd.GetCurrent();
				ATLASSERT(hWndMenu != NULL);

				// Close the popup menu
				if(bAction)
				{
					::PostMessage(hWndMenu, WM_KEYDOWN, VK_ESCAPE, 0L);
					if(wParam == wpNext)
					{
						int cItem = m_stackMenuWnd.GetSize() - 1;
						while(cItem >= 0)
						{
							hWndMenu = m_stackMenuWnd[cItem];
							if(hWndMenu != NULL)
								::PostMessage(hWndMenu, WM_KEYDOWN, VK_ESCAPE, 0L);
							cItem--;
						}
					}
					bHandled = TRUE;
				}
			}
		}
		return 0;
	}

	LRESULT OnHookNextMenu(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - Hook WM_NEXTMENU\n");
#endif
		bHandled = FALSE;
		return 1;
	}

 	LRESULT OnHookChar(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - Hook WM_CHAR (0x%2.2X)\n", wParam);
#endif
		bHandled = (wParam == VK_ESCAPE);
		if(wParam != VK_ESCAPE && wParam != VK_RETURN && m_bMenuActive)
		{
			SetHotItem(-1);
			GiveFocusBack();
		}
		return 0;
	}

// Implementation - ownerdraw overrideables and helpers
	void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
	{
		_MenuItemData* pmd = (_MenuItemData*)lpDrawItemStruct->itemData;
		CDCHandle dc = lpDrawItemStruct->hDC;
		const RECT& rcItem = lpDrawItemStruct->rcItem;

		if(pmd->fType & MFT_SEPARATOR)
		{
			// draw separator
			RECT rc = rcItem;
			rc.top += (rc.bottom - rc.top) / 2;	// vertical center
			dc.DrawEdge(&rc, EDGE_ETCHED, BF_TOP);	// draw separator line
		}
		else		// not a separator
		{
			BOOL bDisabled = lpDrawItemStruct->itemState & ODS_GRAYED;
			BOOL bSelected = lpDrawItemStruct->itemState & ODS_SELECTED;
			BOOL bChecked = lpDrawItemStruct->itemState & ODS_CHECKED;
			BOOL bHasImage = FALSE;

			if(LOWORD(lpDrawItemStruct->itemID) == (WORD)-1)
				bSelected = FALSE;
			RECT rcButn = { rcItem.left, rcItem.top, rcItem.left + m_szButton.cx, rcItem.top + m_szButton.cy };			// button rect
			::OffsetRect(&rcButn, 0, ((rcItem.bottom - rcItem.top) - (rcButn.bottom - rcButn.top)) / 2);	// center vertically

			int iButton = pmd->iButton;
			if(iButton >= 0)
			{
				bHasImage = TRUE;

				// calc drawing point
				SIZE sz = { rcButn.right - rcButn.left - m_szBitmap.cx, rcButn.bottom - rcButn.top - m_szBitmap.cy };
				sz.cx /= 2;
				sz.cy /= 2;
				POINT point = { rcButn.left + sz.cx, rcButn.top + sz.cy };

				// draw disabled or normal
				if(!bDisabled)
				{
					// normal - fill background depending on state
					if(!bChecked || bSelected)
					{
						dc.FillRect(&rcButn, (HBRUSH)LongToPtr((bChecked && !bSelected) ? (COLOR_3DLIGHT + 1) : (COLOR_MENU + 1)));
					}
					else
					{
						COLORREF crTxt = dc.SetTextColor(::GetSysColor(COLOR_BTNFACE));
						COLORREF crBk = dc.SetBkColor(::GetSysColor(COLOR_BTNHILIGHT));
						CBrush hbr(CDCHandle::GetHalftoneBrush());
						dc.SetBrushOrg(rcButn.left, rcButn.top);
						dc.FillRect(&rcButn, hbr);
						dc.SetTextColor(crTxt);
						dc.SetBkColor(crBk);
					}

					// draw pushed-in or popped-out edge
					if(bSelected || bChecked)
					{
						RECT rc2 = rcButn;
						dc.DrawEdge(&rc2, bChecked ? BDR_SUNKENOUTER : BDR_RAISEDINNER, BF_RECT);
					}
					// draw the image
					::ImageList_Draw(m_hImageList, iButton, dc, point.x, point.y, ILD_TRANSPARENT);
				}
				else
				{
					DrawBitmapDisabled(dc, iButton, point);
				}
			}
			else
			{
				// no image - look for custom checked/unchecked bitmaps
				CMenuItemInfo info;
				info.fMask = MIIM_CHECKMARKS | MIIM_TYPE;
				::GetMenuItemInfo((HMENU)lpDrawItemStruct->hwndItem, lpDrawItemStruct->itemID, MF_BYCOMMAND, &info);
				if(bChecked || info.hbmpUnchecked != NULL)
				{
					BOOL bRadio = ((info.fType & MFT_RADIOCHECK) != 0);
					bHasImage = Draw3DCheckmark(dc, rcButn, bSelected, bDisabled, bRadio, bChecked ? info.hbmpChecked : info.hbmpUnchecked);
				}
			}

			// draw item text
			int cxButn = m_szButton.cx;
			COLORREF colorBG = ::GetSysColor(bSelected ? COLOR_HIGHLIGHT : COLOR_MENU);
			if(bSelected || lpDrawItemStruct->itemAction == ODA_SELECT)
			{
				RECT rcBG = rcItem;
				if(bHasImage)
					rcBG.left += cxButn + s_kcxGap;
				dc.FillRect(&rcBG, (HBRUSH)LongToPtr(bSelected ? (COLOR_HIGHLIGHT + 1) : (COLOR_MENU + 1)));
			}

			// calc text rectangle and colors
			RECT rcText = rcItem;
			rcText.left += cxButn + s_kcxGap + s_kcxTextMargin;
			rcText.right -= cxButn;
			dc.SetBkMode(TRANSPARENT);
			COLORREF colorText = ::GetSysColor(bDisabled ?  (bSelected ? COLOR_GRAYTEXT : COLOR_3DSHADOW) : (bSelected ? COLOR_HIGHLIGHTTEXT : COLOR_MENUTEXT));

			// font already selected by Windows
			if(bDisabled && (!bSelected || colorText == colorBG))
			{
				// disabled - draw shadow text shifted down and right 1 pixel (unles selected)
				RECT rcDisabled = rcText;
				::OffsetRect(&rcDisabled, 1, 1);
				DrawMenuText(dc, rcDisabled, pmd->lpstrText, ::GetSysColor(COLOR_3DHILIGHT));
			}
			DrawMenuText(dc, rcText, pmd->lpstrText, colorText); // finally!
		}
	}

	void DrawMenuText(CDCHandle& dc, RECT& rc, LPCTSTR lpstrText, COLORREF color)
	{
		int nTab = -1;
		for(int i = 0; i < lstrlen(lpstrText); i++)
		{
			if(lpstrText[i] == '\t')
			{
				nTab = i;
				break;
			}
		}
		dc.SetTextColor(color);
		dc.DrawText(lpstrText, nTab, &rc, DT_SINGLELINE | DT_LEFT | DT_VCENTER);
		if(nTab != -1)
			dc.DrawText(&lpstrText[nTab + 1], -1, &rc, DT_SINGLELINE | DT_RIGHT | DT_VCENTER);
	}

	void DrawBitmapDisabled(CDCHandle& dc, int nImage, POINT point)
	{
		// create memory DC
		CDC dcMem;
		dcMem.CreateCompatibleDC(dc);
		// create mono or color bitmap
		CBitmap bmp;
		bmp.CreateCompatibleBitmap(dc, m_szBitmap.cx, m_szBitmap.cy);
		ATLASSERT(bmp.m_hBitmap != NULL);
		// draw image into memory DC--fill BG white first
		HBITMAP hBmpOld = dcMem.SelectBitmap(bmp);
		dcMem.PatBlt(0, 0, m_szBitmap.cx, m_szBitmap.cy, WHITENESS);
		// If white is the text color, we can't use the normal painting since
		// it would blend with the WHITENESS, but the mask is OK
		UINT uDrawStyle = (::GetSysColor(COLOR_BTNTEXT) == RGB(255, 255, 255)) ? ILD_MASK : ILD_NORMAL;
		::ImageList_Draw(m_hImageList, nImage, dcMem, 0, 0, uDrawStyle);
		dc.DitherBlt(point.x, point.y, m_szBitmap.cx, m_szBitmap.cy, dcMem, NULL, 0, 0);
		dcMem.SelectBitmap(hBmpOld);		// restore
	}

	BOOL Draw3DCheckmark(CDCHandle& dc, const RECT& rc, BOOL bSelected, BOOL bDisabled, BOOL bRadio, HBITMAP hBmpCheck)
	{
		// get checkmark bitmap, if none, use Windows standard
		SIZE size = { 0, 0 };
		CBitmapHandle bmp = hBmpCheck;
		if(hBmpCheck != NULL)
		{
			bmp.GetSize(size);
		}
		else
		{
			size.cx = ::GetSystemMetrics(SM_CXMENUCHECK); 
			size.cy = ::GetSystemMetrics(SM_CYMENUCHECK); 
			bmp.CreateCompatibleBitmap(dc, size.cx, size.cy);
			ATLASSERT(bmp.m_hBitmap != NULL);
		}
		// center bitmap in caller's rectangle
		RECT rcDest = rc;
		if((rc.right - rc.left) > size.cx)
		{
			rcDest.left = rc.left + (rc.right - rc.left - size.cx) / 2;
			rcDest.right = rcDest.left + size.cx;
		}
		if((rc.bottom - rc.top) > size.cy)
		{
			rcDest.top = rc.top + (rc.bottom - rc.top - size.cy) / 2;
			rcDest.bottom = rcDest.top + size.cy;
		}
		// paint background
		if(!bDisabled)
		{
			if(bSelected)
			{
				dc.FillRect(&rcDest, (HBRUSH)LongToPtr(COLOR_MENU + 1));
			}
			else
			{
				COLORREF clrTextOld = dc.SetTextColor(::GetSysColor(COLOR_BTNFACE));
				COLORREF clrBkOld = dc.SetBkColor(::GetSysColor(COLOR_BTNHILIGHT));
				CBrush hbr(CDCHandle::GetHalftoneBrush());
				dc.SetBrushOrg(rcDest.left, rcDest.top);
				dc.FillRect(&rcDest, hbr);
				dc.SetTextColor(clrTextOld);
				dc.SetBkColor(clrBkOld);
			}
		}

		// create source image
		CDC dcSource;
		dcSource.CreateCompatibleDC(dc);
		HBITMAP hBmpOld = dcSource.SelectBitmap(bmp);
		// set colors
		const COLORREF clrBlack = RGB(0, 0, 0);
		const COLORREF clrWhite = RGB(255, 255, 255);
		COLORREF clrTextOld = dc.SetTextColor(clrBlack);
		COLORREF clrBkOld = dc.SetBkColor(clrWhite);
		// create mask
		CDC dcMask;
		dcMask.CreateCompatibleDC(dc);
		CBitmap bmpMask;
		bmpMask.CreateBitmap(size.cx, size.cy, 1, 1, NULL);
		HBITMAP hBmpOld1 = dcMask.SelectBitmap(bmpMask);

		// draw the checkmark transparently
		int cx = rcDest.right - rcDest.left;
		int cy = rcDest.bottom - rcDest.top;	
		if(hBmpCheck != NULL)
		{
			// build mask based on transparent color	
			dcSource.SetBkColor(m_clrMask);
			dcMask.SetBkColor(clrBlack);
			dcMask.SetTextColor(clrWhite);
			dcMask.BitBlt(0, 0, size.cx, size.cy, dcSource, 0, 0, SRCCOPY);
			// draw bitmap using the mask
			dc.BitBlt(rcDest.left, rcDest.top, cx, cy, dcSource, 0, 0, SRCINVERT);
			dc.BitBlt(rcDest.left, rcDest.top, cx, cy, dcMask, 0, 0, SRCAND);
			dc.BitBlt(rcDest.left, rcDest.top, cx, cy, dcSource, 0, 0, SRCINVERT);
		}
		else
		{
			const DWORD ROP_DSno = 0x00BB0226L;
			const DWORD ROP_DSa = 0x008800C6L;
			const DWORD ROP_DSo = 0x00EE0086L;
			const DWORD ROP_DSna = 0x00220326L;

			// draw mask
			RECT rcSource = { 0, 0, size.cx, size.cy };
			dcMask.DrawFrameControl(&rcSource, DFC_MENU, bRadio ? DFCS_MENUBULLET : DFCS_MENUCHECK);

			// draw shadow if disabled
			if(bDisabled)
			{
				// offset by one pixel
				int x = rcDest.left + 1;
				int y = rcDest.top + 1;
				// paint source bitmap
				const int nColor = COLOR_3DHILIGHT;
				dcSource.FillRect(&rcSource, (HBRUSH)LongToPtr(nColor + 1));
				// draw checkmark - special case black and white colors
				COLORREF clrCheck = ::GetSysColor(nColor);
				if(clrCheck == clrWhite)
				{
					dc.BitBlt(x, y, cx, cy, dcMask,  0, 0,   ROP_DSno);
					dc.BitBlt(x, y, cx, cy, dcSource, 0, 0, ROP_DSa);
				}
				else
				{
					if(clrCheck != clrBlack)
					{
						ATLASSERT(dcSource.GetTextColor() == clrBlack);
						ATLASSERT(dcSource.GetBkColor() == clrWhite);
						dcSource.BitBlt(0, 0, size.cx, size.cy, dcMask, 0, 0, ROP_DSna);
					}
					dc.BitBlt(x, y, cx, cy, dcMask,  0,  0,  ROP_DSa);
					dc.BitBlt(x, y, cx, cy, dcSource, 0, 0, ROP_DSo);
				}
			}

			// paint source bitmap
			const int nColor = bDisabled ? COLOR_BTNSHADOW : COLOR_MENUTEXT;
			dcSource.FillRect(&rcSource, (HBRUSH)LongToPtr(nColor + 1));
			// draw checkmark - special case black and white colors
			COLORREF clrCheck = ::GetSysColor(nColor);
			if(clrCheck == clrWhite)
			{
				dc.BitBlt(rcDest.left, rcDest.top, cx, cy, dcMask,  0, 0,   ROP_DSno);
				dc.BitBlt(rcDest.left, rcDest.top, cx, cy, dcSource, 0, 0, ROP_DSa);
			}
			else
			{
				if(clrCheck != clrBlack)
				{
					ATLASSERT(dcSource.GetTextColor() == clrBlack);
					ATLASSERT(dcSource.GetBkColor() == clrWhite);
					dcSource.BitBlt(0, 0, size.cx, size.cy, dcMask, 0, 0, ROP_DSna);
				}
				dc.BitBlt(rcDest.left, rcDest.top, cx, cy, dcMask,  0,  0,  ROP_DSa);
				dc.BitBlt(rcDest.left, rcDest.top, cx, cy, dcSource, 0, 0, ROP_DSo);
			}
		}
		// restore all
		dc.SetTextColor(clrTextOld);			
		dc.SetBkColor(clrBkOld);
		dcSource.SelectBitmap(hBmpOld);
		dcMask.SelectBitmap(hBmpOld1);
		if(hBmpCheck == NULL)
			bmp.DeleteObject();
		// draw pushed-in hilight
		if(!bDisabled)
		{
			if(rc.right - rc.left > size.cx)
				::InflateRect(&rcDest, 1,1);	// inflate checkmark by one pixel all around
			dc.DrawEdge(&rcDest, BDR_SUNKENOUTER, BF_RECT);
		}

		return TRUE;
	}

	void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)
	{
		_MenuItemData* pmd = (_MenuItemData*)lpMeasureItemStruct->itemData;

		if(pmd->fType & MFT_SEPARATOR)	// separator - use half system height and zero width
		{
			lpMeasureItemStruct->itemHeight = ::GetSystemMetrics(SM_CYMENU) / 2;
			lpMeasureItemStruct->itemWidth  = 0;
		}
		else
		{
			// compute size of text - use DrawText with DT_CALCRECT
			CWindowDC dc(NULL);
			HFONT hOldFont;
			if(pmd->fState & MFS_DEFAULT)
			{
				// need bold version of font
				LOGFONT lf;
				m_fontMenu.GetLogFont(lf);
				lf.lfWeight += 200;
				CFont fontBold;
				fontBold.CreateFontIndirect(&lf);
				ATLASSERT(fontBold.m_hFont != NULL);
				hOldFont = dc.SelectFont(fontBold);
			}
			else
			{
				hOldFont = dc.SelectFont(m_fontMenu);
			}

			RECT rcText = { 0, 0, 0, 0 };
			dc.DrawText(pmd->lpstrText, -1, &rcText, DT_SINGLELINE | DT_LEFT | DT_VCENTER | DT_CALCRECT);
			int cx = rcText.right - rcText.left;
			dc.SelectFont(hOldFont);

			LOGFONT lf;
			m_fontMenu.GetLogFont(lf);
			int cy = lf.lfHeight;
			if(cy < 0)
				cy = -cy;
			cy += 8;

			// height of item is the bigger of these two
			lpMeasureItemStruct->itemHeight = max(cy, (int)m_szButton.cy);

			// width is width of text plus a bunch of stuff
			cx += 2 * s_kcxTextMargin;	// L/R margin for readability
			cx += s_kcxGap;			// space between button and menu text
			cx += 2 * m_szButton.cx;	// button width (L=button; R=empty margin)

			// Windows adds 1 to returned value
			cx -= ::GetSystemMetrics(SM_CXMENUCHECK) - 1;
			lpMeasureItemStruct->itemWidth = cx;		// done deal
		}
	}

// Implementation - Hook procs
	static LRESULT CALLBACK CreateHookProc(int nCode, WPARAM wParam, LPARAM lParam)
	{
		LRESULT lRet = 0;
		TCHAR szClassName[7];

		if(nCode == HCBT_CREATEWND)
		{
			HWND hWndMenu = (HWND)wParam;
#ifdef _CMDBAR_EXTRA_TRACE
			ATLTRACE2(atlTraceUI, 0, "CmdBar - HCBT_CREATEWND (HWND = %8.8X)\n", hWndMenu);
#endif

			::GetClassName(hWndMenu, szClassName, 7);
			if(!lstrcmp(_T("#32768"), szClassName))
				s_pCurrentBar->m_stackMenuWnd.Push(hWndMenu);
		}
		else if(nCode == HCBT_DESTROYWND)
		{
			HWND hWndMenu = (HWND)wParam;
#ifdef _CMDBAR_EXTRA_TRACE
			ATLTRACE2(atlTraceUI, 0, "CmdBar - HCBT_DESTROYWND (HWND = %8.8X)\n", hWndMenu);
#endif

			::GetClassName(hWndMenu, szClassName, 7);
			if(!lstrcmp(_T("#32768"), szClassName))
			{
				ATLASSERT(hWndMenu == s_pCurrentBar->m_stackMenuWnd.GetCurrent());
				s_pCurrentBar->m_stackMenuWnd.Pop();
			}
		}
		else if(nCode < 0)
		{
			lRet = ::CallNextHookEx(s_hCreateHook, nCode, wParam, lParam);
		}
		return lRet;
	}

	static LRESULT CALLBACK MessageHookProc(int nCode, WPARAM wParam, LPARAM lParam)
	{
		LPMSG pMsg = (LPMSG)lParam;

		if(nCode == HC_ACTION && wParam == PM_REMOVE && pMsg->message != GetGetBarMessage() && pMsg->message != WM_FORWARDMSG)
		{
			CCommandBarCtrlBase* pCmdBar = NULL;
			HWND hWnd = pMsg->hwnd;
			DWORD dwPID = 0;
			while(pCmdBar == NULL && hWnd != NULL)
			{
				pCmdBar = (CCommandBarCtrlBase*)::SendMessage(hWnd, GetGetBarMessage(), (WPARAM)&dwPID, 0L);
				hWnd = ::GetParent(hWnd);
			}

			if(pCmdBar != NULL && dwPID == GetCurrentProcessId())
			{
				pCmdBar->m_hWndHook = pMsg->hwnd;
				ATLASSERT(pCmdBar->IsCommandBarBase());

				if(::IsWindow(pCmdBar->m_hWnd))
					pCmdBar->SendMessage(WM_FORWARDMSG, 0, (LPARAM)pMsg);
				else
					ATLTRACE2(atlTraceUI, 0, "CmdBar - Hook skipping message, can't find command bar!\n");
			}
		}

		LRESULT lRet = 0;
		ATLASSERT(s_pmapMsgHook != NULL);
		if(s_pmapMsgHook != NULL)
		{
			DWORD dwThreadID = ::GetCurrentThreadId();
			_MsgHookData* pData = s_pmapMsgHook->Lookup(dwThreadID);
			if(pData != NULL)
			{
				lRet = ::CallNextHookEx(pData->hMsgHook, nCode, wParam, lParam);
			}
		}
		return lRet;
	}

// Implementation
	void DoPopupMenu(int nIndex, bool bAnimate)
	{
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - DoPopupMenu, bAnimate = %s\n", bAnimate ? "true" : "false");
#endif

		// Menu animation flags
#ifndef TPM_VERPOSANIMATION
		const UINT TPM_VERPOSANIMATION = 0x1000L;
#endif
#ifndef TPM_NOANIMATION
		const UINT TPM_NOANIMATION = 0x4000L;
#endif
		// get popup menu and it's position
		RECT rect;
		GetItemRect(nIndex, &rect);
		ClientToScreen(&rect);
		TPMPARAMS TPMParams;
		TPMParams.cbSize = sizeof(TPMPARAMS);
		TPMParams.rcExclude = rect;
		HMENU hMenuPopup = ::GetSubMenu(m_hMenu, nIndex);
		ATLASSERT(hMenuPopup != NULL);

		// get button ID
		TBBUTTON tbb;
		GetButton(nIndex, &tbb);
		int nCmdID = tbb.idCommand;

		m_nPopBtn = nIndex;	// remember current button's index

		// press button and display popup menu
		PressButton(nCmdID, TRUE);
		SetHotItem(nCmdID);
		DoTrackPopupMenu(hMenuPopup, TPM_LEFTBUTTON | TPM_VERTICAL | TPM_LEFTALIGN | TPM_TOPALIGN |
			(s_bW2K ? (bAnimate ? TPM_VERPOSANIMATION : TPM_NOANIMATION) : 0), rect.left, rect.bottom, &TPMParams);
		PressButton(nCmdID, FALSE);
		if(::GetFocus() != m_hWnd)
			SetHotItem(-1);

		m_nPopBtn = -1;		// restore

		// eat next message if click is on the same button
		MSG msg;
		if(::PeekMessage(&msg, m_hWnd, NULL, NULL, PM_NOREMOVE))
		{
			if(msg.message == WM_LBUTTONDOWN && ::PtInRect(&rect, msg.pt))
				::PeekMessage(&msg, m_hWnd, WM_LBUTTONDOWN, WM_LBUTTONDOWN, PM_REMOVE);
		}

		// check if another popup menu should be displayed
		if(m_nNextPopBtn != -1)
		{
			PostMessage(GetAutoPopupMessage(), m_nNextPopBtn & 0xFFFF);
			if(!(m_nNextPopBtn & 0xFFFF0000) && !m_bPopupItem)
				PostMessage(WM_KEYDOWN, VK_DOWN, 0);
			m_nNextPopBtn = -1;
		}
		else
		{
			m_bContextMenu = false;
			// If user didn't hit escape, give focus back
			if(!m_bEscapePressed)
			{
				GiveFocusBack();
			}
			else
			{
				SetHotItem(nCmdID);
				SetAnchorHighlight(TRUE);
			}
		}
	}

	BOOL DoTrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, LPTPMPARAMS lpParams = NULL)
	{
		CMenuHandle menuPopup = hMenu;

		::EnterCriticalSection(&_Module.m_csWindowCreate);

		ATLASSERT(s_hCreateHook == NULL);

		s_pCurrentBar = static_cast<CCommandBarCtrlBase*>(this);

		s_hCreateHook = ::SetWindowsHookEx(WH_CBT, CreateHookProc, _Module.GetModuleInstance(), GetCurrentThreadId());
		ATLASSERT(s_hCreateHook != NULL);

		m_bPopupItem = false;
		m_bMenuActive = true;

		BOOL bTrackRet = menuPopup.TrackPopupMenuEx(uFlags, x, y, m_hWnd, lpParams);
		m_bMenuActive = false;

		::UnhookWindowsHookEx(s_hCreateHook);

		s_hCreateHook = NULL;
		s_pCurrentBar = NULL;

		::LeaveCriticalSection(&_Module.m_csWindowCreate);

		// cleanup - convert menus back to original state
#ifdef _CMDBAR_EXTRA_TRACE
		ATLTRACE2(atlTraceUI, 0, "CmdBar - TrackPopupMenu - cleanup\n");
#endif

		ATLASSERT(m_stackMenuWnd.GetSize() == 0);

		UpdateWindow();
		CWindow wndTL = GetTopLevelParent();
		wndTL.UpdateWindow();

		// restore the menu items to the previous state for all menus that were converted
		if(m_bImagesVisible)
		{
			HMENU hMenuSav;
			while((hMenuSav = m_stackMenuHandle.Pop()) != NULL)
			{
				menuPopup = hMenuSav;
				BOOL bRet;
				// restore state and delete menu item data
				for(int i = 0; i < menuPopup.GetMenuItemCount(); i++)
				{
					CMenuItemInfo mii;
					mii.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID;
					bRet = menuPopup.GetMenuItemInfo(i, TRUE, &mii);
					ATLASSERT(bRet);

					_MenuItemData* pMI = (_MenuItemData*)mii.dwItemData;
					if(pMI != NULL && pMI->IsCmdBarMenuItem())
					{
						mii.fMask = MIIM_DATA | MIIM_TYPE | MIIM_STATE;
						mii.fType = pMI->fType;
						mii.fState = pMI->fState;
						mii.dwTypeData = pMI->lpstrText;
						mii.cch = lstrlen(pMI->lpstrText);
						mii.dwItemData = NULL;

						bRet = menuPopup.SetMenuItemInfo(i, TRUE, &mii);
						// this one triggers WM_MEASUREITEM
						menuPopup.ModifyMenu(i, MF_BYPOSITION | mii.fType | mii.fState, mii.wID, pMI->lpstrText);
						ATLASSERT(bRet);

						delete [] pMI->lpstrText;
						delete pMI;
					}
				}
			}
		}
		return bTrackRet;
	}

	int GetPreviousMenuItem() const
	{
		if(m_nPopBtn == -1)
			return -1;
#if (_WIN32_IE >= 0x0500)
		RECT rcClient;
		GetClientRect(&rcClient);
#endif //(_WIN32_IE >= 0x0500)
		int nNextPopBtn;
		for(nNextPopBtn = m_nPopBtn - 1; nNextPopBtn != m_nPopBtn; nNextPopBtn--)
		{
			if(nNextPopBtn < 0)
				nNextPopBtn = ::GetMenuItemCount(m_hMenu) - 1;
			TBBUTTON tbb = { 0 };
			GetButton(nNextPopBtn, &tbb);
#if (_WIN32_IE >= 0x0500)
			RECT rcBtn;
			GetItemRect(nNextPopBtn, &rcBtn);
			if((tbb.fsState & TBSTATE_ENABLED) != 0 && (tbb.fsState & TBSTATE_HIDDEN) == 0 && rcBtn.right <= rcClient.right)
				break;
#else //!(_WIN32_IE >= 0x0500)
			if((tbb.fsState & TBSTATE_ENABLED) != 0 && (tbb.fsState & TBSTATE_HIDDEN) == 0)
				break;
#endif //!(_WIN32_IE >= 0x0500)
		}
		return (nNextPopBtn != m_nPopBtn) ? nNextPopBtn : -1;
	}

	int GetNextMenuItem() const
	{
		if(m_nPopBtn == -1)
			return -1;
#if (_WIN32_IE >= 0x0500)
		RECT rcClient;
		GetClientRect(&rcClient);
#endif //(_WIN32_IE >= 0x0500)
		int nNextPopBtn;
		int nCount = ::GetMenuItemCount(m_hMenu);
		for(nNextPopBtn = m_nPopBtn + 1; nNextPopBtn != m_nPopBtn; nNextPopBtn++)
		{
			if(nNextPopBtn >= nCount)
				nNextPopBtn = 0;
			TBBUTTON tbb = { 0 };
			GetButton(nNextPopBtn, &tbb);
#if (_WIN32_IE >= 0x0500)
			RECT rcBtn;
			GetItemRect(nNextPopBtn, &rcBtn);
			if((tbb.fsState & TBSTATE_ENABLED) != 0 && (tbb.fsState & TBSTATE_HIDDEN) == 0 && rcBtn.right <= rcClient.right)
				break;
#else //!(_WIN32_IE >= 0x0500)
			if((tbb.fsState & TBSTATE_ENABLED) != 0 && (tbb.fsState & TBSTATE_HIDDEN) == 0)
				break;
#endif //!(_WIN32_IE >= 0x0500)
		}
		return (nNextPopBtn != m_nPopBtn) ? nNextPopBtn : -1;
	}

	void GetSystemSettings()
	{
		// refresh our font
		NONCLIENTMETRICS info;
		info.cbSize = sizeof(info);
		::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(info), &info, 0);
		LOGFONT logfont;
		memset(&logfont, 0, sizeof(LOGFONT));
		if(m_fontMenu.m_hFont != NULL)
			m_fontMenu.GetLogFont(logfont);
		if(logfont.lfHeight != info.lfMenuFont.lfHeight ||
		   logfont.lfWidth != info.lfMenuFont.lfWidth ||
		   logfont.lfEscapement != info.lfMenuFont.lfEscapement ||
		   logfont.lfOrientation != info.lfMenuFont.lfOrientation ||
		   logfont.lfWeight != info.lfMenuFont.lfWeight ||
		   logfont.lfItalic != info.lfMenuFont.lfItalic ||
		   logfont.lfUnderline != info.lfMenuFont.lfUnderline ||
		   logfont.lfStrikeOut != info.lfMenuFont.lfStrikeOut ||
		   logfont.lfCharSet != info.lfMenuFont.lfCharSet ||
		   logfont.lfOutPrecision != info.lfMenuFont.lfOutPrecision ||
		   logfont.lfClipPrecision != info.lfMenuFont.lfClipPrecision ||
		   logfont.lfQuality != info.lfMenuFont.lfQuality ||
		   logfont.lfPitchAndFamily != info.lfMenuFont.lfPitchAndFamily ||
		   lstrcmp(logfont.lfFaceName, info.lfMenuFont.lfFaceName) != 0)
		{
			HFONT hFontMenu = ::CreateFontIndirect(&info.lfMenuFont);
			ATLASSERT(hFontMenu != NULL);
			if(hFontMenu != NULL)
			{
				if(m_fontMenu.m_hFont != NULL)
					m_fontMenu.DeleteObject();
				m_fontMenu.Attach(hFontMenu);
				SetFont(m_fontMenu);
				AddStrings(_T("NS\0"));	// for proper item height
				AutoSize();
			}
		}
	}

// Implementation - alternate focus mode support
	void TakeFocus()
	{
		if((m_dwExtendedStyle & CBR_EX_ALTFOCUSMODE) && m_hWndFocus == NULL)
			m_hWndFocus = ::GetFocus();
		SetFocus();
	}

	void GiveFocusBack()
	{
		if((m_dwExtendedStyle & CBR_EX_ALTFOCUSMODE) && ::IsWindow(m_hWndFocus))
			::SetFocus(m_hWndFocus);
		else if(!(m_dwExtendedStyle & CBR_EX_ALTFOCUSMODE) && m_wndParent.IsWindow())
			m_wndParent.SetFocus();
		m_hWndFocus = NULL;
		SetAnchorHighlight(FALSE);
	}

// Implementation - internal message helpers
	static UINT GetAutoPopupMessage()
	{
		static UINT uAutoPopupMessage = 0;
		if(uAutoPopupMessage == 0)
		{
			::EnterCriticalSection(&_Module.m_csStaticDataInit);
			if(uAutoPopupMessage == 0)
				uAutoPopupMessage = ::RegisterWindowMessage(_T("WTL_CmdBar_InternalAutoPopupMsg"));
			::LeaveCriticalSection(&_Module.m_csStaticDataInit);
		}
		ATLASSERT(uAutoPopupMessage != 0);
		return uAutoPopupMessage;
	}

	static UINT GetGetBarMessage()
	{
		static UINT uGetBarMessage = 0;
		if(uGetBarMessage == 0)
		{
			::EnterCriticalSection(&_Module.m_csStaticDataInit);
			if(uGetBarMessage == 0)
				uGetBarMessage = ::RegisterWindowMessage(_T("WTL_CmdBar_InternalGetBarMsg"));
			::LeaveCriticalSection(&_Module.m_csStaticDataInit);
		}
		ATLASSERT(uGetBarMessage != 0);
		return uGetBarMessage;
	}
};


class CCommandBarCtrl : public CCommandBarCtrlImpl<CCommandBarCtrl>
{
public:
	DECLARE_WND_SUPERCLASS(_T("WTL_CommandBar"), GetWndClassName())
};

}; //namespace WTL

#endif // __ATLCTRLW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wtl10\atlddx.h ===
// WTL Version 3.1
// Copyright (C) 1997-2000 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLDDX_H__
#define __ATLDDX_H__

#pragma once

#if defined(_ATL_USE_DDX_FLOAT) && defined(_ATL_MIN_CRT)
	#error Cannot use floating point DDX with _ATL_MIN_CRT defined
#endif //defined(_ATL_USE_DDX_FLOAT) && defined(_ATL_MIN_CRT)

#ifdef _ATL_USE_DDX_FLOAT
#include <float.h>
#ifndef _DEBUG
#include <stdio.h>
#endif //!_DEBUG
#endif //_ATL_USE_DDX_FLOAT

namespace WTL
{

// Constants
#define DDX_LOAD	FALSE
#define DDX_SAVE	TRUE

// DDX map macros
#define BEGIN_DDX_MAP(thisClass) \
	BOOL DoDataExchange(BOOL bSaveAndValidate = FALSE, UINT nCtlID = (UINT)-1) \
	{ \
		bSaveAndValidate; \
		nCtlID;

#define DDX_TEXT(nID, var) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
		{ \
			if(!DDX_Text(nID, var, sizeof(var), bSaveAndValidate)) \
				return FALSE; \
		}

#define DDX_TEXT_LEN(nID, var, len) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
		{ \
			if(!DDX_Text(nID, var, sizeof(var), bSaveAndValidate, TRUE, len)) \
				return FALSE; \
		}

#define DDX_INT(nID, var) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
		{ \
			if(!DDX_Int(nID, var, TRUE, bSaveAndValidate)) \
				return FALSE; \
		}

#define DDX_INT_RANGE(nID, var, min, max) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
		{ \
			if(!DDX_Int(nID, var, TRUE, bSaveAndValidate, TRUE, min, max)) \
				return FALSE; \
		}

#define DDX_UINT(nID, var) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
		{ \
			if(!DDX_Int(nID, var, FALSE, bSaveAndValidate)) \
				return FALSE; \
		}

#define DDX_UINT_RANGE(nID, var, min, max) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
		{ \
			if(!DDX_Int(nID, var, FALSE, bSaveAndValidate, TRUE, min, max)) \
				return FALSE; \
		}

#ifdef _ATL_USE_DDX_FLOAT
#define DDX_FLOAT(nID, var) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
		{ \
			if(!DDX_Float(nID, var, bSaveAndValidate)) \
				return FALSE; \
		}

#define DDX_FLOAT_RANGE(nID, var, min, max) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
		{ \
			if(!DDX_Float(nID, var, bSaveAndValidate, TRUE, min, max)) \
				return FALSE; \
		}
#endif //_ATL_USE_DDX_FLOAT

#define DDX_CONTROL(nID, obj) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
			DDX_Control(nID, obj, bSaveAndValidate);

#define DDX_CHECK(nID, var) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
			DDX_Check(nID, var, bSaveAndValidate);

#define DDX_RADIO(nID, var) \
		if(nCtlID == (UINT)-1 || nCtlID == nID) \
			DDX_Radio(nID, var, bSaveAndValidate);

#define END_DDX_MAP() \
		return TRUE; \
	}


/////////////////////////////////////////////////////////////////////////////
// CWinDataExchange - provides support for DDX

template <class T>
class CWinDataExchange
{
public:
// Data exchange method - override in your derived class
	BOOL DoDataExchange(BOOL /*bSaveAndValidate*/ = FALSE, UINT /*nCtlID*/ = (UINT)-1)
	{
		// this one should never be called, override it in
		// your derived class by implementing DDX map
		ATLASSERT(FALSE);
		return FALSE;
	}

// Helpers for validation error reporting
	enum _XDataType
	{
		ddxDataNull = 0,
		ddxDataText = 1,
		ddxDataInt = 2,
		ddxDataFloat = 3,
		ddxDataDouble = 4
	};

	struct _XTextData
	{
		int nLength;
		int nMaxLength;
	};

	struct _XIntData
	{
		long nVal;
		long nMin;
		long nMax;
	};

	struct _XFloatData
	{
		double nVal;
		double nMin;
		double nMax;
	};

	struct _XData
	{
		_XDataType nDataType;
		union
		{
			_XTextData textData;
			_XIntData intData;
			_XFloatData floatData;
		};
	};

// Text exchange
	BOOL DDX_Text(UINT nID, LPTSTR lpstrText, int nSize, BOOL bSave, BOOL bValidate = FALSE, int nLength = 0)
	{
		T* pT = static_cast<T*>(this);
		BOOL bSuccess = TRUE;

		if(bSave)
		{
			HWND hWndCtrl = pT->GetDlgItem(nID);
			int nRetLen = ::GetWindowText(hWndCtrl, lpstrText, nSize);
			if(nRetLen < ::GetWindowTextLength(hWndCtrl))
				bSuccess = FALSE;
		}
		else
		{
			ATLASSERT(!bValidate || lstrlen(lpstrText) <= nLength);
			bSuccess = pT->SetDlgItemText(nID, lpstrText);
		}

		if(!bSuccess)
		{
			pT->OnDataExchangeError(nID, bSave);
		}
		else if(bSave && bValidate)	// validation
		{
			ATLASSERT(nLength > 0);
			if(lstrlen(lpstrText) > nLength)
			{
				_XData data;
				data.nDataType = ddxDataText;
				data.textData.nLength = lstrlen(lpstrText);
				data.textData.nMaxLength = nLength;
				pT->OnDataValidateError(nID, bSave, data);
				bSuccess = FALSE;
			}
		}
		return bSuccess;
	}

	BOOL DDX_Text(UINT nID, BSTR& bstrText, int /*nSize*/, BOOL bSave, BOOL bValidate = FALSE, int nLength = 0)
	{
		T* pT = static_cast<T*>(this);
		BOOL bSuccess = TRUE;

		if(bSave)
		{
			bSuccess = pT->GetDlgItemText(nID, bstrText);
		}
		else
		{
			USES_CONVERSION;
			LPTSTR lpstrText = OLE2T(bstrText);
			ATLASSERT(!bValidate || lstrlen(lpstrText) <= nLength);
			bSuccess = pT->SetDlgItemText(nID, lpstrText);
		}

		if(!bSuccess)
		{
			pT->OnDataExchangeError(nID, bSave);
		}
		else if(bSave && bValidate)	// validation
		{
			ATLASSERT(nLength > 0);
			if((int)::SysStringLen(bstrText) > nLength)
			{
				_XData data;
				data.nDataType = ddxDataText;
				data.textData.nLength = (int)::SysStringLen(bstrText);
				data.textData.nMaxLength = nLength;
				pT->OnDataValidateError(nID, bSave, data);
				bSuccess = FALSE;
			}
		}
		return bSuccess;
	}

	BOOL DDX_Text(UINT nID, CComBSTR& bstrText, int /*nSize*/, BOOL bSave, BOOL bValidate = FALSE, int nLength = 0)
	{
		T* pT = static_cast<T*>(this);
		BOOL bSuccess = TRUE;

		if(bSave)
		{
			bSuccess = pT->GetDlgItemText(nID, (BSTR&)bstrText);
		}
		else
		{
			USES_CONVERSION;
			LPTSTR lpstrText = OLE2T(bstrText);
			ATLASSERT(!bValidate || lstrlen(lpstrText) <= nLength);
			bSuccess = pT->SetDlgItemText(nID, lpstrText);
		}

		if(!bSuccess)
		{
			pT->OnDataExchangeError(nID, bSave);
		}
		else if(bSave && bValidate)	// validation
		{
			ATLASSERT(nLength > 0);
			if((int)bstrText.Length() > nLength)
			{
				_XData data;
				data.nDataType = ddxDataText;
				data.textData.nLength = (int)bstrText.Length();
				data.textData.nMaxLength = nLength;
				pT->OnDataValidateError(nID, bSave, data);
				bSuccess = FALSE;
			}
		}
		return bSuccess;
	}

#ifdef __ATLSTR_H__
	BOOL DDX_Text(UINT nID, CString& strText, int /*nSize*/, BOOL bSave, BOOL bValidate = FALSE, int nLength = 0)
	{
		T* pT = static_cast<T*>(this);
		BOOL bSuccess = TRUE;

		if(bSave)
		{
			HWND hWndCtrl = pT->GetDlgItem(nID);
			int nLen = ::GetWindowTextLength(hWndCtrl);
			int nRetLen = ::GetWindowText(hWndCtrl, strText.GetBufferSetLength(nLen), nLen + 1);
			if(nRetLen < nLen)
				bSuccess = FALSE;
			strText.ReleaseBuffer();
		}
		else
		{
			bSuccess = pT->SetDlgItemText(nID, strText);
		}

		if(!bSuccess)
		{
			pT->OnDataExchangeError(nID, bSave);
		}
		else if(bSave && bValidate)	// validation
		{
			ATLASSERT(nLength > 0);
			if(strText.GetLength() > nLength)
			{
				_XData data;
				data.nDataType = ddxDataText;
				data.textData.nLength = strText.GetLength();
				data.textData.nMaxLength = nLength;
				pT->OnDataValidateError(nID, bSave, data);
				bSuccess = FALSE;
			}
		}
		return bSuccess;
	}
#endif //__ATLSTR_H__

// Numeric exchange
	template <class Type>
	BOOL DDX_Int(UINT nID, Type& nVal, BOOL bSigned, BOOL bSave, BOOL bValidate = FALSE, Type nMin = 0, Type nMax = 0)
	{
		T* pT = static_cast<T*>(this);
		BOOL bSuccess = TRUE;

		if(bSave)
		{
			nVal = (Type)pT->GetDlgItemInt(nID, &bSuccess, bSigned);
		}
		else
		{
			ATLASSERT(!bValidate || nVal >= nMin && nVal <= nMax);
			bSuccess = pT->SetDlgItemInt(nID, nVal, bSigned);
		}

		if(!bSuccess)
		{
			pT->OnDataExchangeError(nID, bSave);
		}
		else if(bSave && bValidate)	// validation
		{
			ATLASSERT(nMin != nMax);
			if(nVal < nMin || nVal > nMax)
			{
				_XData data;
				data.nDataType = ddxDataInt;
				data.intData.nVal = (long)nVal;
				data.intData.nMin = (long)nMin;
				data.intData.nMax = (long)nMax;
				pT->OnDataValidateError(nID, bSave, data);
				bSuccess = FALSE;
			}
		}
		return bSuccess;
	}

// Float exchange
#ifdef _ATL_USE_DDX_FLOAT
	static BOOL _AtlSimpleFloatParse(LPCTSTR lpszText, double& d)
	{
		ATLASSERT(lpszText != NULL);
		while (*lpszText == ' ' || *lpszText == '\t')
			lpszText++;

		TCHAR chFirst = lpszText[0];
		d = _tcstod(lpszText, (LPTSTR*)&lpszText);
		if (d == 0.0 && chFirst != '0')
			return FALSE;   // could not convert
		while (*lpszText == ' ' || *lpszText == '\t')
			lpszText++;

		if (*lpszText != '\0')
			return FALSE;   // not terminated properly

		return TRUE;
	}

	BOOL DDX_Float(UINT nID, float& nVal, BOOL bSave, BOOL bValidate = FALSE, float nMin = 0.F, float nMax = 0.F)
	{
		T* pT = static_cast<T*>(this);
		BOOL bSuccess = TRUE;
		TCHAR szBuff[32];

		if(bSave)
		{
			pT->GetDlgItemText(nID, szBuff, sizeof(szBuff) / sizeof(TCHAR));
			double d = 0;
			if(_AtlSimpleFloatParse(szBuff, d))
				nVal = (float)d;
			else
				bSuccess = FALSE;
		}
		else
		{
			ATLASSERT(!bValidate || nVal >= nMin && nVal <= nMax);
			_stprintf(szBuff, _T("%.*g"), FLT_DIG, nVal);
			bSuccess = pT->SetDlgItemText(nID, szBuff);
		}

		if(!bSuccess)
		{
			pT->OnDataExchangeError(nID, bSave);
		}
		else if(bSave && bValidate)	// validation
		{
			ATLASSERT(nMin != nMax);
			if(nVal < nMin || nVal > nMax)
			{
				_XData data;
				data.nDataType = ddxDataFloat;
				data.floatData.nVal = (double)nVal;
				data.floatData.nMin = (double)nMin;
				data.floatData.nMax = (double)nMax;
				pT->OnDataValidateError(nID, bSave, data);
				bSuccess = FALSE;
			}
		}
		return bSuccess;
	}

	BOOL DDX_Float(UINT nID, double& nVal, BOOL bSave, BOOL bValidate = FALSE, double nMin = 0., double nMax = 0.)
	{
		T* pT = static_cast<T*>(this);
		BOOL bSuccess = TRUE;
		TCHAR szBuff[32];

		if(bSave)
		{
			pT->GetDlgItemText(nID, szBuff, sizeof(szBuff) / sizeof(TCHAR));
			double d = 0;
			if(_AtlSimpleFloatParse(szBuff, d))
				nVal = d;
			else
				bSuccess = FALSE;
		}
		else
		{
			ATLASSERT(!bValidate || nVal >= nMin && nVal <= nMax);
			_stprintf(szBuff, _T("%.*g"), DBL_DIG, nVal);
			bSuccess = pT->SetDlgItemText(nID, szBuff);
		}

		if(!bSuccess)
		{
			pT->OnDataExchangeError(nID, bSave);
		}
		else if(bSave && bValidate)	// validation
		{
			ATLASSERT(nMin != nMax);
			if(nVal < nMin || nVal > nMax)
			{
				_XData data;
				data.nDataType = ddxDataFloat;
				data.floatData.nVal = nVal;
				data.floatData.nMin = nMin;
				data.floatData.nMax = nMax;
				pT->OnDataValidateError(nID, bSave, data);
				bSuccess = FALSE;
			}
		}
		return bSuccess;
	}
#endif //_ATL_USE_DDX_FLOAT

// Control subclassing
	template <class TControl>
	void DDX_Control(UINT nID, TControl& ctrl, BOOL bSave)
	{
		T* pT = static_cast<T*>(this);
		if(!bSave && ctrl.m_hWnd == NULL)
			ctrl.SubclassWindow(pT->GetDlgItem(nID));
	}

// Control state
	void DDX_Check(UINT nID, int& nValue, BOOL bSave)
	{
		T* pT = static_cast<T*>(this);
		HWND hWndCtrl = pT->GetDlgItem(nID);
		if(bSave)
		{
			nValue = (int)::SendMessage(hWndCtrl, BM_GETCHECK, 0, 0L);
			ATLASSERT(nValue >= 0 && nValue <= 2);
		}
		else
		{
			if(nValue < 0 || nValue > 2)
			{
				ATLTRACE2(atlTraceUI, 0, "ATL: Warning - dialog data checkbox value (%d) out of range.\n", nValue);
				nValue = 0;  // default to off
			}
			::SendMessage(hWndCtrl, BM_SETCHECK, nValue, 0L);
		}
	}

	void DDX_Radio(UINT nID, int& nValue, BOOL bSave)
	{
		T* pT = static_cast<T*>(this);
		HWND hWndCtrl = pT->GetDlgItem(nID);
		ATLASSERT(hWndCtrl != NULL);

		// must be first in a group of auto radio buttons
		ATLASSERT(::GetWindowLong(hWndCtrl, GWL_STYLE) & WS_GROUP);
		ATLASSERT(::SendMessage(hWndCtrl, WM_GETDLGCODE, 0, 0L) & DLGC_RADIOBUTTON);

		if(bSave)
			nValue = -1;     // value if none found

		// walk all children in group
		int nButton = 0;
		do
		{
			if(::SendMessage(hWndCtrl, WM_GETDLGCODE, 0, 0L) & DLGC_RADIOBUTTON)
			{
				// control in group is a radio button
				if(bSave)
				{
					if(::SendMessage(hWndCtrl, BM_GETCHECK, 0, 0L) != 0)
					{
						ATLASSERT(nValue == -1);    // only set once
						nValue = nButton;
					}
				}
				else
				{
					// select button
					::SendMessage(hWndCtrl, BM_SETCHECK, (nButton == nValue), 0L);
				}
				nButton++;
			}
			else
			{
				ATLTRACE2(atlTraceUI, 0, "ATL: Warning - skipping non-radio button in group.\n");
			}
			hWndCtrl = ::GetWindow(hWndCtrl, GW_HWNDNEXT);
		}
		while (hWndCtrl != NULL && !(GetWindowLong(hWndCtrl, GWL_STYLE) & WS_GROUP));
	}

// Overrideables
	void OnDataExchangeError(UINT nCtrlID, BOOL /*bSave*/)
	{
		// Override to display an error message
		::MessageBeep((UINT)-1);
		T* pT = static_cast<T*>(this);
		::SetFocus(pT->GetDlgItem(nCtrlID));
	}

	void OnDataValidateError(UINT nCtrlID, BOOL /*bSave*/, _XData& /*data*/)
	{
		// Override to display an error message
		::MessageBeep((UINT)-1);
		T* pT = static_cast<T*>(this);
		::SetFocus(pT->GetDlgItem(nCtrlID));
	}
};

}; //namespace WTL

#endif //__ATLDDX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wtl10\atlgdi.h ===
// WTL Version 3.1
// Copyright (C) 1997-2000 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLGDI_H__
#define __ATLGDI_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlgdi.h requires atlbase.h to be included first
#endif


// protect template members from windowsx.h macros
#ifdef _INC_WINDOWSX
#undef CopyRgn
#undef CreateBrush
#undef CreatePen
#undef SelectBrush
#undef SelectPen
#undef SelectFont
#undef SelectBitmap
#endif //_INC_WINDOWSX

// required libraries
#ifndef _ATL_NO_MSIMG
#pragma comment(lib, "msimg32.lib")
#endif //!_ATL_NO_MSIMG
#ifndef _ATL_NO_OPENGL
#pragma comment(lib, "opengl32.lib")
#endif //!_ATL_NO_OPENGL


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <bool t_bManaged> class CPenT;
template <bool t_bManaged> class CBrushT;
template <bool t_bManaged> class CFontT;
template <bool t_bManaged> class CBitmapT;
template <bool t_bManaged> class CPaletteT;
template <bool t_bManaged> class CRgnT;
template <bool t_bManaged> class CDCT;
class CPaintDC;
class CClientDC;
class CWindowDC;
class CEnhMetaFileInfo;
template <bool t_bManaged> class CEnhMetaFileT;
class CEnhMetaFileDC;


/////////////////////////////////////////////////////////////////////////////
// CPen

typedef CPenT<false>		CPenHandle;
typedef CPenT<true>		CPen;

template <bool t_bManaged>
class CPenT
{
public:
// Data members
	HPEN m_hPen;

// Constructor/destructor/operators
	CPenT(HPEN hPen = NULL) : m_hPen(hPen)
	{ }

	~CPenT()
	{
		if(t_bManaged && m_hPen != NULL)
			DeleteObject();
	}

	CPenT<t_bManaged>& operator=(HPEN hPen)
	{
		m_hPen = hPen;
		return *this;
	}

	void Attach(HPEN hPen)
	{
		if(t_bManaged && m_hPen != NULL)
			::DeleteObject(m_hPen);
		m_hPen = hPen;
	}
	HPEN Detach()
	{
		HPEN hPen = m_hPen;
		m_hPen = NULL;
		return hPen;
	}

	operator HPEN() const { return m_hPen; }

	bool IsNull() const { return (m_hPen == NULL); }

// Create methods
	HPEN CreatePen(int nPenStyle, int nWidth, COLORREF crColor)
	{
		ATLASSERT(m_hPen == NULL);
		m_hPen = ::CreatePen(nPenStyle, nWidth, crColor);
		return m_hPen;
	}
	HPEN CreatePen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush, int nStyleCount = 0, const DWORD* lpStyle = NULL)
	{
		ATLASSERT(m_hPen == NULL);
		m_hPen = ::ExtCreatePen(nPenStyle, nWidth, pLogBrush, nStyleCount, lpStyle);
		return m_hPen;
	}
	HPEN CreatePenIndirect(LPLOGPEN lpLogPen)
	{
		ATLASSERT(m_hPen == NULL);
		m_hPen = ::CreatePenIndirect(lpLogPen);
		return m_hPen;
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hPen != NULL);
		BOOL bRet = ::DeleteObject(m_hPen);
		if(bRet)
			m_hPen = NULL;
		return bRet;
	}

// Attributes
	int GetLogPen(LOGPEN* pLogPen) const
	{
		ATLASSERT(m_hPen != NULL);
		return ::GetObject(m_hPen, sizeof(LOGPEN), pLogPen);
	}
	bool GetLogPen(LOGPEN& LogPen) const
	{
		ATLASSERT(m_hPen != NULL);
		return (::GetObject(m_hPen, sizeof(LOGPEN), &LogPen) == sizeof(LOGPEN));
	}
	int GetExtLogPen(EXTLOGPEN* pLogPen) const
	{
		ATLASSERT(m_hPen != NULL);
		return ::GetObject(m_hPen, sizeof(EXTLOGPEN), pLogPen);
	}
	bool GetExtLogPen(EXTLOGPEN& ExtLogPen) const
	{
		ATLASSERT(m_hPen != NULL);
		return (::GetObject(m_hPen, sizeof(EXTLOGPEN), &ExtLogPen) == sizeof(EXTLOGPEN));
	}
};


/////////////////////////////////////////////////////////////////////////////
// CBrush

typedef CBrushT<false>		CBrushHandle;
typedef CBrushT<true>		CBrush;

template <bool t_bManaged>
class CBrushT
{
public:
// Data members
	HBRUSH m_hBrush;

// Constructor/destructor/operators
	CBrushT(HBRUSH hBrush = NULL) : m_hBrush(hBrush)
	{ }

	~CBrushT()
	{
		if(t_bManaged && m_hBrush != NULL)
			DeleteObject();
	}

	CBrushT<t_bManaged>& operator=(HBRUSH hBrush)
	{
		m_hBrush = hBrush;
		return *this;
	}

	void Attach(HBRUSH hBrush)
	{
		if(t_bManaged && m_hBrush != NULL)
			::DeleteObject(m_hBrush);
		m_hBrush = hBrush;
	}
	HBRUSH Detach()
	{
		HBRUSH hBrush = m_hBrush;
		m_hBrush = NULL;
		return hBrush;
	}

	operator HBRUSH() const { return m_hBrush; }

	bool IsNull() const { return (m_hBrush == NULL); }

// Create methods
	HBRUSH CreateSolidBrush(COLORREF crColor)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreateSolidBrush(crColor);
		return m_hBrush;
	}
	HBRUSH CreateHatchBrush(int nIndex, COLORREF crColor)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreateHatchBrush(nIndex, crColor);
		return m_hBrush;
	}
	HBRUSH CreateBrushIndirect(const LOGBRUSH* lpLogBrush)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreateBrushIndirect(lpLogBrush);
		return m_hBrush;
	}
	HBRUSH CreatePatternBrush(HBITMAP hBitmap)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreatePatternBrush(hBitmap);
		return m_hBrush;
	}
	HBRUSH CreateDIBPatternBrush(HGLOBAL hPackedDIB, UINT nUsage)
	{
		ATLASSERT(hPackedDIB != NULL);
		const void* lpPackedDIB = ::GlobalLock(hPackedDIB);
		ATLASSERT(lpPackedDIB != NULL);
		m_hBrush = ::CreateDIBPatternBrushPt(lpPackedDIB, nUsage);
		::GlobalUnlock(hPackedDIB);
		return m_hBrush;
	}
	HBRUSH CreateDIBPatternBrush(const void* lpPackedDIB, UINT nUsage)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreateDIBPatternBrushPt(lpPackedDIB, nUsage);
		return m_hBrush;
	}
	HBRUSH CreateSysColorBrush(int nIndex)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::GetSysColorBrush(nIndex);
		return m_hBrush;
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hBrush != NULL);
		BOOL bRet = ::DeleteObject(m_hBrush);
		if(bRet)
			m_hBrush = NULL;
		return bRet;
	}

// Attributes
	int GetLogBrush(LOGBRUSH* pLogBrush) const
	{
		ATLASSERT(m_hBrush != NULL);
		return ::GetObject(m_hBrush, sizeof(LOGBRUSH), pLogBrush);
	}
	bool GetLogBrush(LOGBRUSH& LogBrush) const
	{
		ATLASSERT(m_hBrush != NULL);
		return (::GetObject(m_hBrush, sizeof(LOGBRUSH), &LogBrush) == sizeof(LOGBRUSH));
	}
};


/////////////////////////////////////////////////////////////////////////////
// CFont

typedef CFontT<false>		CFontHandle;
typedef CFontT<true>		CFont;

template <bool t_bManaged>
class CFontT
{
public:
// Data members
	HFONT m_hFont;

// Constructor/destructor/operators
	CFontT(HFONT hFont = NULL) : m_hFont(hFont)
	{ }

	~CFontT()
	{
		if(t_bManaged && m_hFont != NULL)
			DeleteObject();
	}

	CFontT<t_bManaged>& operator=(HFONT hFont)
	{
		m_hFont = hFont;
		return *this;
	}

	void Attach(HFONT hFont)
	{
		if(t_bManaged && m_hFont != NULL)
			::DeleteObject(m_hFont);
		m_hFont = hFont;
	}
	HFONT Detach()
	{
		HFONT hFont = m_hFont;
		m_hFont = NULL;
		return hFont;
	}

	operator HFONT() const { return m_hFont; }

	bool IsNull() const { return (m_hFont == NULL); }

// Create methods
	HFONT CreateFontIndirect(const LOGFONT* lpLogFont)
	{
		ATLASSERT(m_hFont == NULL);
		m_hFont = ::CreateFontIndirect(lpLogFont);
		return m_hFont;
	}

#if (_WIN32_WINNT >= 0x0500)
	HFONT CreateFontIndirectEx(CONST ENUMLOGFONTEXDV* penumlfex)
	{
		ATLASSERT(m_hFont == NULL);
		m_hFont = ::CreateFontIndirectEx(penumlfex);
		return m_hFont;
	}
#endif //(_WIN32_WINNT >= 0x0500)

	HFONT CreateFont(int nHeight, int nWidth, int nEscapement,
			int nOrientation, int nWeight, BYTE bItalic, BYTE bUnderline,
			BYTE cStrikeOut, BYTE nCharSet, BYTE nOutPrecision,
			BYTE nClipPrecision, BYTE nQuality, BYTE nPitchAndFamily,
			LPCTSTR lpszFacename)
	{
		ATLASSERT(m_hFont == NULL);
		m_hFont = ::CreateFont(nHeight, nWidth, nEscapement,
			nOrientation, nWeight, bItalic, bUnderline, cStrikeOut,
			nCharSet, nOutPrecision, nClipPrecision, nQuality,
			nPitchAndFamily, lpszFacename);
		return m_hFont;
	}
	HFONT CreatePointFont(int nPointSize, LPCTSTR lpszFaceName, HDC hDC = NULL)
	{
		LOGFONT logFont;
		memset(&logFont, 0, sizeof(LOGFONT));
		logFont.lfCharSet = DEFAULT_CHARSET;
		logFont.lfHeight = nPointSize;
		lstrcpyn(logFont.lfFaceName, lpszFaceName, sizeof(logFont.lfFaceName)/sizeof(TCHAR));
		return CreatePointFontIndirect(&logFont, hDC);
	}
	HFONT CreatePointFontIndirect(const LOGFONT* lpLogFont, HDC hDC = NULL)
	{
		HDC hDC1 = (hDC != NULL) ? hDC : (::GetDC(NULL));

		// convert nPointSize to logical units based on hDC
		LOGFONT logFont = *lpLogFont;
		POINT pt;
		pt.y = ::GetDeviceCaps(hDC1, LOGPIXELSY) * logFont.lfHeight;
		pt.y /= 720;    // 72 points/inch, 10 decipoints/point
		::DPtoLP(hDC1, &pt, 1);
		POINT ptOrg = { 0, 0 };
		::DPtoLP(hDC1, &ptOrg, 1);
		logFont.lfHeight = -abs(pt.y - ptOrg.y);

		if(hDC == NULL)
			::ReleaseDC(NULL, hDC1);

		return CreateFontIndirect(&logFont);
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hFont != NULL);
		BOOL bRet = ::DeleteObject(m_hFont);
		if(bRet)
			m_hFont = NULL;
		return bRet;
	}

// Attributes
	int GetLogFont(LOGFONT* pLogFont) const
	{
		ATLASSERT(m_hFont != NULL);
		return ::GetObject(m_hFont, sizeof(LOGFONT), pLogFont);
	}
	bool GetLogFont(LOGFONT& LogFont) const
	{
		ATLASSERT(m_hFont != NULL);
		return (::GetObject(m_hFont, sizeof(LOGFONT), &LogFont) == sizeof(LOGFONT));
	}
};


/////////////////////////////////////////////////////////////////////////////
// CBitmap

typedef CBitmapT<false>		CBitmapHandle;
typedef CBitmapT<true>		CBitmap;

template <bool t_bManaged>
class CBitmapT
{
public:
// Data members
	HBITMAP m_hBitmap;

// Constructor/destructor/operators
	CBitmapT(HBITMAP hBitmap = NULL) : m_hBitmap(hBitmap)
	{ }

	~CBitmapT()
	{
		if(t_bManaged && m_hBitmap != NULL)
			DeleteObject();
	}

	CBitmapT<t_bManaged>& operator=(HBITMAP hBitmap)
	{
		m_hBitmap = hBitmap;
		return *this;
	}

	void Attach(HBITMAP hBitmap)
	{
		if(t_bManaged && m_hBitmap != NULL)
			::DeleteObject(m_hBitmap);
		m_hBitmap = hBitmap;
	}
	HBITMAP Detach()
	{
		HBITMAP hBitmap = m_hBitmap;
		m_hBitmap = NULL;
		return hBitmap;
	}

	operator HBITMAP() const { return m_hBitmap; }

	bool IsNull() const { return (m_hBitmap == NULL); }

// Create and load methods
	HBITMAP LoadBitmap(_U_STRINGorID bitmap)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(_Module.GetResourceInstance(), bitmap.m_lpstr);
		return m_hBitmap;
	}
	HBITMAP LoadOEMBitmap(UINT nIDBitmap) // for OBM_/OCR_/OIC_
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(NULL, MAKEINTRESOURCE(nIDBitmap));
		return m_hBitmap;
	}
	HBITMAP LoadMappedBitmap(UINT nIDBitmap, UINT nFlags = 0, LPCOLORMAP lpColorMap = NULL, int nMapSize = 0)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateMappedBitmap(_Module.GetResourceInstance(), nIDBitmap, (WORD)nFlags, lpColorMap, nMapSize);
		return m_hBitmap;
	}
	HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitcount, const void* lpBits)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateBitmap(nWidth, nHeight, nPlanes, nBitcount, lpBits);
		return m_hBitmap;
	}
	HBITMAP CreateBitmapIndirect(LPBITMAP lpBitmap)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateBitmapIndirect(lpBitmap);
		return m_hBitmap;
	}
	HBITMAP CreateCompatibleBitmap(HDC hDC, int nWidth, int nHeight)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateCompatibleBitmap(hDC, nWidth, nHeight);
		return m_hBitmap;
	}
	HBITMAP CreateDiscardableBitmap(HDC hDC, int nWidth, int nHeight)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateDiscardableBitmap(hDC, nWidth, nHeight);
		return m_hBitmap;
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hBitmap != NULL);
		BOOL bRet = ::DeleteObject(m_hBitmap);
		if(bRet)
			m_hBitmap = NULL;
		return bRet;
	}

// Attributes
	int GetBitmap(BITMAP* pBitMap) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetObject(m_hBitmap, sizeof(BITMAP), pBitMap);
	}
	bool GetBitmap(BITMAP& bm) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return (::GetObject(m_hBitmap, sizeof(BITMAP), &bm) == sizeof(BITMAP));
	}
	bool GetSize(SIZE& size) const
	{
		ATLASSERT(m_hBitmap != NULL);
		BITMAP bm;
		if(!GetBitmap(&bm))
			return false;
		size.cx = bm.bmWidth;
		size.cy = bm.bmHeight;
		return true;
	}

	DWORD GetBitmapBits(DWORD dwCount, LPVOID lpBits) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetBitmapBits(m_hBitmap, dwCount, lpBits);
	}
	DWORD SetBitmapBits(DWORD dwCount, const void* lpBits)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::SetBitmapBits(m_hBitmap, dwCount, lpBits);
	}
	BOOL GetBitmapDimension(LPSIZE lpSize) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetBitmapDimensionEx(m_hBitmap, lpSize);
	}
	BOOL SetBitmapDimension(int nWidth, int nHeight, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::SetBitmapDimensionEx(m_hBitmap, nWidth, nHeight, lpSize);
	}

// DIB support
	HBITMAP CreateDIBitmap(HDC hDC, CONST BITMAPINFOHEADER* lpbmih, DWORD dwInit, CONST VOID* lpbInit, CONST BITMAPINFO* lpbmi, UINT uColorUse)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateDIBitmap(hDC, lpbmih, dwInit, lpbInit, lpbmi, uColorUse);
		return m_hBitmap;
	}
	HBITMAP CreateDIBSection(HDC hDC, CONST BITMAPINFO* lpbmi, UINT uColorUse, VOID** ppvBits, HANDLE hSection, DWORD dwOffset)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateDIBSection(hDC, lpbmi, uColorUse, ppvBits, hSection, dwOffset);
		return m_hBitmap;
	}
	int GetDIBits(HDC hDC, UINT uStartScan, UINT cScanLines,  LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT uColorUse) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetDIBits(hDC, m_hBitmap, uStartScan, cScanLines,  lpvBits, lpbmi, uColorUse);
	}
	int SetDIBits(HDC hDC, UINT uStartScan, UINT cScanLines, CONST VOID* lpvBits, CONST BITMAPINFO* lpbmi, UINT uColorUse)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::SetDIBits(hDC, m_hBitmap, uStartScan, cScanLines, lpvBits, lpbmi, uColorUse);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CPalette

typedef CPaletteT<false>	CPaletteHandle;
typedef CPaletteT<true>		CPalette;

template <bool t_bManaged>
class CPaletteT
{
public:
// Data members
	HPALETTE m_hPalette;

// Constructor/destructor/operators
	CPaletteT(HPALETTE hPalette = NULL) : m_hPalette(hPalette)
	{ }

	~CPaletteT()
	{
		if(t_bManaged && m_hPalette != NULL)
			DeleteObject();
	}

	CPaletteT<t_bManaged>& operator=(HPALETTE hPalette)
	{
		m_hPalette = hPalette;
		return *this;
	}

	void Attach(HPALETTE hPalette)
	{
		if(t_bManaged && m_hPalette != NULL)
			::DeleteObject(m_hPalette);
		m_hPalette = hPalette;
	}
	HPALETTE Detach()
	{
		HPALETTE hPalette = m_hPalette;
		m_hPalette = NULL;
		return hPalette;
	}

	operator HPALETTE() const { return m_hPalette; }

	bool IsNull() const { return (m_hPalette == NULL); }

// Create methods
	HPALETTE CreatePalette(LPLOGPALETTE lpLogPalette)
	{
		ATLASSERT(m_hPalette == NULL);
		m_hPalette = ::CreatePalette(lpLogPalette);
		return m_hPalette;
	}
	HPALETTE CreateHalftonePalette(HDC hDC)
	{
		ATLASSERT(m_hPalette == NULL);
		ATLASSERT(hDC != NULL);
		m_hPalette = ::CreateHalftonePalette(hDC);
		return m_hPalette;
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hPalette != NULL);
		BOOL bRet = ::DeleteObject(m_hPalette);
		if(bRet)
			m_hPalette = NULL;
		return bRet;
	}

// Attributes
	int GetEntryCount() const
	{
		ATLASSERT(m_hPalette != NULL);
		WORD nEntries;
		::GetObject(m_hPalette, sizeof(WORD), &nEntries);
		return (int)nEntries;
	}
	UINT GetPaletteEntries(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors) const
	{
		ATLASSERT(m_hPalette != NULL);
		return ::GetPaletteEntries(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
	}
	UINT SetPaletteEntries(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors)
	{
		ATLASSERT(m_hPalette != NULL);
		return ::SetPaletteEntries(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
	}

// Operations
	void AnimatePalette(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors)
	{
		ATLASSERT(m_hPalette != NULL);
		::AnimatePalette(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
	}
	BOOL ResizePalette(UINT nNumEntries)
	{
		ATLASSERT(m_hPalette != NULL);
		return ::ResizePalette(m_hPalette, nNumEntries);
	}
	UINT GetNearestPaletteIndex(COLORREF crColor) const
	{
		ATLASSERT(m_hPalette != NULL);
		return ::GetNearestPaletteIndex(m_hPalette, crColor);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CRgn

typedef CRgnT<false>		CRgnHandle;
typedef CRgnT<true>		CRgn;

template <bool t_bManaged>
class CRgnT
{
public:
// Data members
	HRGN m_hRgn;

// Constructor/destructor/operators
	CRgnT(HRGN hRgn = NULL) : m_hRgn(hRgn)
	{ }

	~CRgnT()
	{
		if(t_bManaged && m_hRgn != NULL)
			DeleteObject();
	}

	CRgnT<t_bManaged>& operator=(HRGN hRgn)
	{
		m_hRgn = hRgn;
		return *this;
	}

	void Attach(HRGN hRgn)
	{
		if(t_bManaged && m_hRgn != NULL)
			::DeleteObject(m_hRgn);
		m_hRgn = hRgn;
	}
	HRGN Detach()
	{
		HRGN hRgn = m_hRgn;
		m_hRgn = NULL;
		return hRgn;
	}

	operator HRGN() const { return m_hRgn; }

	bool IsNull() const { return (m_hRgn == NULL); }

// Create methods
	HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateRectRgn(x1, y1, x2, y2);
		return m_hRgn;
	}
	HRGN CreateRectRgnIndirect(LPCRECT lpRect)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateRectRgnIndirect(lpRect);
		return m_hRgn;
	}
	HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateEllipticRgn(x1, y1, x2, y2);
		return m_hRgn;
	}
	HRGN CreateEllipticRgnIndirect(LPCRECT lpRect)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateEllipticRgnIndirect(lpRect);
		return m_hRgn;
	}
	HRGN CreatePolygonRgn(LPPOINT lpPoints, int nCount, int nMode)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreatePolygonRgn(lpPoints, nCount, nMode);
		return m_hRgn;
	}
	HRGN CreatePolyPolygonRgn(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount, int nPolyFillMode)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreatePolyPolygonRgn(lpPoints, lpPolyCounts, nCount, nPolyFillMode);
		return m_hRgn;
	}
	HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int x3, int y3)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateRoundRectRgn(x1, y1, x2, y2, x3, y3);
		return m_hRgn;
	}
	HRGN CreateFromPath(HDC hDC)
	{
		ATLASSERT(m_hRgn == NULL);
		ATLASSERT(hDC != NULL);
		m_hRgn = ::PathToRegion(hDC);
		return m_hRgn;
	}
	HRGN CreateFromData(const XFORM* lpXForm, int nCount, const RGNDATA* pRgnData)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::ExtCreateRegion(lpXForm, nCount, pRgnData);
		return m_hRgn;
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hRgn != NULL);
		BOOL bRet = ::DeleteObject(m_hRgn);
		if(bRet)
			m_hRgn = NULL;
		return bRet;
	}

// Operations
	void SetRectRgn(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hRgn != NULL);
		::SetRectRgn(m_hRgn, x1, y1, x2, y2);
	}
	void SetRectRgn(LPCRECT lpRect)
	{
		ATLASSERT(m_hRgn != NULL);
		::SetRectRgn(m_hRgn, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
	int CombineRgn(HRGN hRgnSrc1, HRGN hRgnSrc2, int nCombineMode)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::CombineRgn(m_hRgn, hRgnSrc1, hRgnSrc2, nCombineMode);
	}
	int CombineRgn(HRGN hRgnSrc, int nCombineMode)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::CombineRgn(m_hRgn, m_hRgn, hRgnSrc, nCombineMode);
	}
	int CopyRgn(HRGN hRgnSrc)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::CombineRgn(m_hRgn, hRgnSrc, NULL, RGN_COPY);
	}
	BOOL EqualRgn(HRGN hRgn) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::EqualRgn(m_hRgn, hRgn);
	}
	int OffsetRgn(int x, int y)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::OffsetRgn(m_hRgn, x, y);
	}
	int OffsetRgn(POINT point)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::OffsetRgn(m_hRgn, point.x, point.y);
	}
	int GetRgnBox(LPRECT lpRect) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::GetRgnBox(m_hRgn, lpRect);
	}
	BOOL PtInRegion(int x, int y) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::PtInRegion(m_hRgn, x, y);
	}
	BOOL PtInRegion(POINT point) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::PtInRegion(m_hRgn, point.x, point.y);
	}
	BOOL RectInRegion(LPCRECT lpRect) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::RectInRegion(m_hRgn, lpRect);
	}
	int GetRegionData(LPRGNDATA lpRgnData, int nDataSize) const
	{
		ATLASSERT(m_hRgn != NULL);
		return (int)::GetRegionData(m_hRgn, nDataSize, lpRgnData);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CDC - The device context class

typedef CDCT<false>		CDCHandle;
typedef CDCT<true>		CDC;

template <bool t_bManaged>
class CDCT
{
public:
// Data members
	HDC m_hDC;

// Constructor/destructor/operators
	CDCT(HDC hDC = NULL) : m_hDC(hDC)
	{
	}

	~CDCT()
	{
		if(t_bManaged && m_hDC != NULL)
			::DeleteDC(Detach());
	}

	CDCT<t_bManaged>& operator=(HDC hDC)
	{
		m_hDC = hDC;
		return *this;
	}

	void Attach(HDC hDC)
	{
		if(t_bManaged && m_hDC != NULL)
			::DeleteDC(m_hDC);
		m_hDC = hDC;
	}

	HDC Detach()
	{
		HDC hDC = m_hDC;
		m_hDC = NULL;
		return hDC;
	}

	operator HDC() const { return m_hDC; }

	bool IsNull() const { return (m_hDC == NULL); }

// Operations
	HWND WindowFromDC() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::WindowFromDC(m_hDC);
	}

	CPenHandle GetCurrentPen() const
	{
		ATLASSERT(m_hDC != NULL);
		return CPenHandle((HPEN)::GetCurrentObject(m_hDC, OBJ_PEN));
	}
	CBrushHandle GetCurrentBrush() const
	{
		ATLASSERT(m_hDC != NULL);
		return CBrushHandle((HBRUSH)::GetCurrentObject(m_hDC, OBJ_BRUSH));
	}
	CPaletteHandle GetCurrentPalette() const
	{
		ATLASSERT(m_hDC != NULL);
		return CPaletteHandle((HPALETTE)::GetCurrentObject(m_hDC, OBJ_PAL));
	}
	CFontHandle GetCurrentFont() const
	{
		ATLASSERT(m_hDC != NULL);
		return CFontHandle((HFONT)::GetCurrentObject(m_hDC, OBJ_FONT));
	}
	CBitmapHandle GetCurrentBitmap() const
	{
		ATLASSERT(m_hDC != NULL);
		return CBitmapHandle((HBITMAP)::GetCurrentObject(m_hDC, OBJ_BITMAP));
	}

	HDC CreateDC(LPCTSTR lpszDriverName, LPCTSTR lpszDeviceName, LPCTSTR lpszOutput, const DEVMODE* lpInitData)
	{
		ATLASSERT(m_hDC == NULL);
		m_hDC = ::CreateDC(lpszDriverName, lpszDeviceName, lpszOutput, lpInitData);
		return m_hDC;
	}

	HDC CreateCompatibleDC(HDC hDC = NULL)
	{
		ATLASSERT(m_hDC == NULL);
		m_hDC = ::CreateCompatibleDC(hDC);
		return m_hDC;
	}

	BOOL DeleteDC()
	{
		if(m_hDC == NULL)
			return FALSE;

		return ::DeleteDC(Detach());
	}

// Device-Context Functions
	int SaveDC()
	{
		ATLASSERT(m_hDC != NULL);
		return ::SaveDC(m_hDC);
	}

	BOOL RestoreDC(int nSavedDC)
	{
		ATLASSERT(m_hDC != NULL);
		return ::RestoreDC(m_hDC, nSavedDC);
	}

	int GetDeviceCaps(int nIndex) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetDeviceCaps(m_hDC, nIndex);
	}
	UINT SetBoundsRect(LPCRECT lpRectBounds, UINT flags)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBoundsRect(m_hDC, lpRectBounds, flags);
	}
	UINT GetBoundsRect(LPRECT lpRectBounds, UINT flags) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetBoundsRect(m_hDC, lpRectBounds, flags);
	}
	BOOL ResetDC(const DEVMODE* lpDevMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ResetDC(m_hDC, lpDevMode) != NULL;
	}

// Drawing-Tool Functions
	BOOL GetBrushOrg(LPPOINT lpPoint) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetBrushOrgEx(m_hDC, lpPoint);
	}
	BOOL SetBrushOrg(int x, int y, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBrushOrgEx(m_hDC, x, y, lpPoint);
	}
	BOOL SetBrushOrg(POINT point, LPPOINT lpPointRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBrushOrgEx(m_hDC, point.x, point.y, lpPointRet);
	}
	int EnumObjects(int nObjectType, int (CALLBACK* lpfn)(LPVOID, LPARAM), LPARAM lpData)
	{
		ATLASSERT(m_hDC != NULL);
#ifdef STRICT
		return ::EnumObjects(m_hDC, nObjectType, (GOBJENUMPROC)lpfn, lpData);
#else
		return ::EnumObjects(m_hDC, nObjectType, (GOBJENUMPROC)lpfn, (LPVOID)lpData);
#endif
	}

// Type-safe selection helpers
	HPEN SelectPen(HPEN hPen)
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(hPen == NULL || ::GetObjectType(hPen) == OBJ_PEN || ::GetObjectType(hPen) == OBJ_EXTPEN);
		return (HPEN)::SelectObject(m_hDC, hPen);
	}
	HBRUSH SelectBrush(HBRUSH hBrush)
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(hBrush == NULL || ::GetObjectType(hBrush) == OBJ_BRUSH);
		return (HBRUSH)::SelectObject(m_hDC, hBrush);
	}
	HFONT SelectFont(HFONT hFont)
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(hFont == NULL || ::GetObjectType(hFont) == OBJ_FONT);
		return (HFONT)::SelectObject(m_hDC, hFont);
	}
	HBITMAP SelectBitmap(HBITMAP hBitmap)
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(hBitmap == NULL || ::GetObjectType(hBitmap) == OBJ_BITMAP);
		return (HBITMAP)::SelectObject(m_hDC, hBitmap);
	}
	int SelectRgn(HRGN hRgn)       // special return for regions
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(hRgn == NULL || ::GetObjectType(hRgn) == OBJ_REGION);
		return PtrToInt(::SelectObject(m_hDC, hRgn));
	}
// Type-safe selection helpers for stock objects
	HPEN SelectStockPen(int nPen)
	{
		ATLASSERT(m_hDC != NULL);
#if (_WIN32_WINNT >= 0x0500)
		ATLASSERT(nPen == WHITE_PEN || nPen == BLACK_PEN || nPen == NULL_PEN || nPen == DC_PEN);
#else
		ATLASSERT(nPen == WHITE_PEN || nPen == BLACK_PEN || nPen == NULL_PEN);
#endif //!(_WIN32_WINNT >= 0x0500)
		return SelectPen((HPEN)::GetStockObject(nPen));
	}
	HBRUSH SelectStockBrush(int nBrush)
	{
#if (_WIN32_WINNT >= 0x0500)
		ATLASSERT((nBrush >= WHITE_BRUSH && nBrush <= HOLLOW_BRUSH) || nBrush == DC_BRUSH);
#else
		ATLASSERT(nBrush >= WHITE_BRUSH && nBrush <= HOLLOW_BRUSH);
#endif //!(_WIN32_WINNT >= 0x0500)
		return SelectBrush((HBRUSH)::GetStockObject(nBrush));
	}
	HFONT SelectStockFont(int nFont)
	{
		ATLASSERT((nFont >= OEM_FIXED_FONT && nFont <= SYSTEM_FIXED_FONT) || nFont == DEFAULT_GUI_FONT);
		return SelectFont((HFONT)::GetStockObject(nFont));
	}
	HPALETTE SelectStockPalette(int nPalette, BOOL bForceBackground)
	{
		ATLASSERT(nPalette == DEFAULT_PALETTE); // the only one supported
		return SelectPalette((HPALETTE)::GetStockObject(nPalette), bForceBackground);
	}

// Color and Color Palette Functions
	COLORREF GetNearestColor(COLORREF crColor) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetNearestColor(m_hDC, crColor);
	}
	HPALETTE SelectPalette(HPALETTE hPalette, BOOL bForceBackground)
	{
		ATLASSERT(m_hDC != NULL);

		return ::SelectPalette(m_hDC, hPalette, bForceBackground);
	}
	UINT RealizePalette()
	{
		ATLASSERT(m_hDC != NULL);
		return ::RealizePalette(m_hDC);
	}
	void UpdateColors()
	{
		ATLASSERT(m_hDC != NULL);
		::UpdateColors(m_hDC);
	}

// Drawing-Attribute Functions
	COLORREF GetBkColor() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetBkColor(m_hDC);
	}
	int GetBkMode() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetBkMode(m_hDC);
	}
	int GetPolyFillMode() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPolyFillMode(m_hDC);
	}
	int GetROP2() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetROP2(m_hDC);
	}
	int GetStretchBltMode() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetStretchBltMode(m_hDC);
	}
	COLORREF GetTextColor() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextColor(m_hDC);
	}

	COLORREF SetBkColor(COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBkColor(m_hDC, crColor);
	}
	int SetBkMode(int nBkMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBkMode(m_hDC, nBkMode);
	}
	int SetPolyFillMode(int nPolyFillMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPolyFillMode(m_hDC, nPolyFillMode);
	}
	int SetROP2(int nDrawMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetROP2(m_hDC, nDrawMode);
	}
	int SetStretchBltMode(int nStretchMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetStretchBltMode(m_hDC, nStretchMode);
	}
	COLORREF SetTextColor(COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetTextColor(m_hDC, crColor);
	}

	BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetColorAdjustment(m_hDC, lpColorAdjust);
	}
	BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetColorAdjustment(m_hDC, lpColorAdjust);
	}

// Mapping Functions
	int GetMapMode() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetMapMode(m_hDC);
	}
	BOOL GetViewportOrg(LPPOINT lpPoint) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetViewportOrgEx(m_hDC, lpPoint);
	}
	int SetMapMode(int nMapMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetMapMode(m_hDC, nMapMode);
	}
	// Viewport Origin
	BOOL SetViewportOrg(int x, int y, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetViewportOrgEx(m_hDC, x, y, lpPoint);
	}
	BOOL SetViewportOrg(POINT point, LPPOINT lpPointRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return SetViewportOrg(point.x, point.y, lpPointRet);
	}
	BOOL OffsetViewportOrg(int nWidth, int nHeight, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::OffsetViewportOrgEx(m_hDC, nWidth, nHeight, lpPoint);
	}

	// Viewport Extent
	BOOL GetViewportExt(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetViewportExtEx(m_hDC, lpSize);
	}
	BOOL SetViewportExt(int x, int y, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetViewportExtEx(m_hDC, x, y, lpSize);
	}
	BOOL SetViewportExt(SIZE size, LPSIZE lpSizeRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return SetViewportExt(size.cx, size.cy, lpSizeRet);
	}
	BOOL ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ScaleViewportExtEx(m_hDC, xNum, xDenom, yNum, yDenom, lpSize);
	}

	// Window Origin
	BOOL GetWindowOrg(LPPOINT lpPoint) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetWindowOrgEx(m_hDC, lpPoint);
	}
	BOOL SetWindowOrg(int x, int y, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetWindowOrgEx(m_hDC, x, y, lpPoint);
	}
	BOOL SetWindowOrg(POINT point, LPPOINT lpPointRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return SetWindowOrg(point.x, point.y, lpPointRet);
	}
	BOOL OffsetWindowOrg(int nWidth, int nHeight, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::OffsetWindowOrgEx(m_hDC, nWidth, nHeight, lpPoint);
	}

	// Window extent
	BOOL GetWindowExt(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetWindowExtEx(m_hDC, lpSize);
	}
	BOOL SetWindowExt(int x, int y, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetWindowExtEx(m_hDC, x, y, lpSize);
	}
	BOOL SetWindowExt(SIZE size, LPSIZE lpSizeRet)
	{
		ATLASSERT(m_hDC != NULL);
		return SetWindowExt(size.cx, size.cy, lpSizeRet);
	}
	BOOL ScaleWindowExt(int xNum, int xDenom, int yNum, int yDenom, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ScaleWindowExtEx(m_hDC, xNum, xDenom, yNum, yDenom, lpSize);
	}

// Coordinate Functions
	BOOL DPtoLP(LPPOINT lpPoints, int nCount = 1) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::DPtoLP(m_hDC, lpPoints, nCount);
	}
	BOOL DPtoLP(LPRECT lpRect) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::DPtoLP(m_hDC, (LPPOINT)lpRect, 2);
	}
	BOOL DPtoLP(LPSIZE lpSize) const
	{
		SIZE sizeWinExt;
		if(!GetWindowExt(&sizeWinExt))
			return FALSE;
		SIZE sizeVpExt;
		if(!GetViewportExt(&sizeVpExt))
			return FALSE;
		lpSize->cx = MulDiv(lpSize->cx, abs(sizeWinExt.cx), abs(sizeVpExt.cx));
		lpSize->cy = MulDiv(lpSize->cy, abs(sizeWinExt.cy), abs(sizeVpExt.cy));
		return TRUE;
	}
	BOOL LPtoDP(LPPOINT lpPoints, int nCount = 1) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::LPtoDP(m_hDC, lpPoints, nCount);
	}
	BOOL LPtoDP(LPRECT lpRect) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::LPtoDP(m_hDC, (LPPOINT)lpRect, 2);
	}
	BOOL LPtoDP(LPSIZE lpSize) const
	{
		SIZE sizeWinExt;
		if(!GetWindowExt(&sizeWinExt))
			return FALSE;
		SIZE sizeVpExt;
		if(!GetViewportExt(&sizeVpExt))
			return FALSE;
		lpSize->cx = ::MulDiv(lpSize->cx, abs(sizeVpExt.cx), abs(sizeWinExt.cx));
		lpSize->cy = ::MulDiv(lpSize->cy, abs(sizeVpExt.cy), abs(sizeWinExt.cy));
		return TRUE;
	}

// Special Coordinate Functions (useful for dealing with metafiles and OLE)
	#define HIMETRIC_INCH   2540    // HIMETRIC units per inch

	void DPtoHIMETRIC(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		int nMapMode;
		if((nMapMode = GetMapMode()) < MM_ISOTROPIC && nMapMode != MM_TEXT)
		{
			// when using a constrained map mode, map against physical inch
			((CDCHandle*)this)->SetMapMode(MM_HIMETRIC);
			DPtoLP(lpSize);
			((CDCHandle*)this)->SetMapMode(nMapMode);
		}
		else
		{
			// map against logical inch for non-constrained mapping modes
			int cxPerInch = GetDeviceCaps(LOGPIXELSX);
			int cyPerInch = GetDeviceCaps(LOGPIXELSY);
			ATLASSERT(cxPerInch != 0 && cyPerInch != 0);
			lpSize->cx = MulDiv(lpSize->cx, HIMETRIC_INCH, cxPerInch);
			lpSize->cy = MulDiv(lpSize->cy, HIMETRIC_INCH, cyPerInch);
		}
	}

	void HIMETRICtoDP(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		int nMapMode;
		if((nMapMode = GetMapMode()) < MM_ISOTROPIC && nMapMode != MM_TEXT)
		{
			// when using a constrained map mode, map against physical inch
			((CDCHandle*)this)->SetMapMode(MM_HIMETRIC);
			LPtoDP(lpSize);
			((CDCHandle*)this)->SetMapMode(nMapMode);
		}
		else
		{
			// map against logical inch for non-constrained mapping modes
			int cxPerInch = GetDeviceCaps(LOGPIXELSX);
			int cyPerInch = GetDeviceCaps(LOGPIXELSY);
			ATLASSERT(cxPerInch != 0 && cyPerInch != 0);
			lpSize->cx = MulDiv(lpSize->cx, cxPerInch, HIMETRIC_INCH);
			lpSize->cy = MulDiv(lpSize->cy, cyPerInch, HIMETRIC_INCH);
		}
	}

	void LPtoHIMETRIC(LPSIZE lpSize) const
	{
		LPtoDP(lpSize);
		DPtoHIMETRIC(lpSize);
	}

	void HIMETRICtoLP(LPSIZE lpSize) const
	{
		HIMETRICtoDP(lpSize);
		DPtoLP(lpSize);
	}

// Region Functions
	BOOL FillRgn(HRGN hRgn, HBRUSH hBrush)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FillRgn(m_hDC, hRgn, hBrush);
	}
	BOOL FrameRgn(HRGN hRgn, HBRUSH hBrush, int nWidth, int nHeight)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FrameRgn(m_hDC, hRgn, hBrush, nWidth, nHeight);
	}
	BOOL InvertRgn(HRGN hRgn)
	{
		ATLASSERT(m_hDC != NULL);
		return ::InvertRgn(m_hDC, hRgn);
	}
	BOOL PaintRgn(HRGN hRgn)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PaintRgn(m_hDC, hRgn);
	}

// Clipping Functions
	int GetClipBox(LPRECT lpRect) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetClipBox(m_hDC, lpRect);
	}
	BOOL PtVisible(int x, int y) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::PtVisible(m_hDC, x, y);
	}
	BOOL PtVisible(POINT point) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::PtVisible(m_hDC, point.x, point.y);
	}
	BOOL RectVisible(LPCRECT lpRect) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::RectVisible(m_hDC, lpRect);
	}
	int SelectClipRgn(HRGN hRgn)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SelectClipRgn(m_hDC, (HRGN)hRgn);
	}
	int ExcludeClipRect(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExcludeClipRect(m_hDC, x1, y1, x2, y2);
	}
	int ExcludeClipRect(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExcludeClipRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
	int ExcludeUpdateRgn(HWND hWnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExcludeUpdateRgn(m_hDC, hWnd);
	}
	int IntersectClipRect(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hDC != NULL);
		return ::IntersectClipRect(m_hDC, x1, y1, x2, y2);
	}
	int IntersectClipRect(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::IntersectClipRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
	int OffsetClipRgn(int x, int y)
	{
		ATLASSERT(m_hDC != NULL);
		return ::OffsetClipRgn(m_hDC, x, y);
	}
	int OffsetClipRgn(SIZE size)
	{
		ATLASSERT(m_hDC != NULL);
		return ::OffsetClipRgn(m_hDC, size.cx, size.cy);
	}
	int SelectClipRgn(HRGN hRgn, int nMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExtSelectClipRgn(m_hDC, hRgn, nMode);
	}

// Line-Output Functions
	BOOL GetCurrentPosition(LPPOINT lpPoint) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCurrentPositionEx(m_hDC, lpPoint);
	}
	BOOL MoveTo(int x, int y, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::MoveToEx(m_hDC, x, y, lpPoint);
	}
	BOOL MoveTo(POINT point, LPPOINT lpPointRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return MoveTo(point.x, point.y, lpPointRet);
	}
	BOOL LineTo(int x, int y)
	{
		ATLASSERT(m_hDC != NULL);
		return ::LineTo(m_hDC, x, y);
	}
	BOOL LineTo(POINT point)
	{
		ATLASSERT(m_hDC != NULL);
		return LineTo(point.x, point.y);
	}
	BOOL Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Arc(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
	}
	BOOL Arc(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Arc(m_hDC, lpRect->left, lpRect->top,
			lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
			ptEnd.x, ptEnd.y);
	}
	BOOL Polyline(LPPOINT lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Polyline(m_hDC, lpPoints, nCount);
	}

	BOOL AngleArc(int x, int y, int nRadius, float fStartAngle, float fSweepAngle)
	{
		ATLASSERT(m_hDC != NULL);
		return ::AngleArc(m_hDC, x, y, nRadius, fStartAngle, fSweepAngle);
	}
	BOOL ArcTo(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ArcTo(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
	}
	BOOL ArcTo(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ArcTo(lpRect->left, lpRect->top, lpRect->right,
		lpRect->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y);
	}
	int GetArcDirection() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetArcDirection(m_hDC);
	}
	int SetArcDirection(int nArcDirection)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetArcDirection(m_hDC, nArcDirection);
	}

	BOOL PolyDraw(const POINT* lpPoints, const BYTE* lpTypes, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyDraw(m_hDC, lpPoints, lpTypes, nCount);
	}
	BOOL PolylineTo(const POINT* lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolylineTo(m_hDC, lpPoints, nCount);
	}
	BOOL PolyPolyline(const POINT* lpPoints,
		const DWORD* lpPolyPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyPolyline(m_hDC, lpPoints, lpPolyPoints, nCount);
	}

	BOOL PolyBezier(const POINT* lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyBezier(m_hDC, lpPoints, nCount);
	}
	BOOL PolyBezierTo(const POINT* lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyBezierTo(m_hDC, lpPoints, nCount);
	}

// Simple Drawing Functions
	BOOL FillRect(LPCRECT lpRect, HBRUSH hBrush)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FillRect(m_hDC, lpRect, hBrush);
	}
	BOOL FrameRect(LPCRECT lpRect, HBRUSH hBrush)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FrameRect(m_hDC, lpRect, hBrush);
	}
	BOOL InvertRect(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::InvertRect(m_hDC, lpRect);
	}
	BOOL DrawIcon(int x, int y, HICON hIcon)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawIcon(m_hDC, x, y, hIcon);
	}
	BOOL DrawIcon(POINT point, HICON hIcon)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawIcon(m_hDC, point.x, point.y, hIcon);
	}
	BOOL DrawIconEx(int x, int y, HICON hIcon, int cxWidth, int cyWidth, UINT uStepIfAniCur = 0, HBRUSH hbrFlickerFreeDraw = NULL, UINT uFlags = DI_NORMAL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawIconEx(m_hDC, x, y, hIcon, cxWidth, cyWidth, uStepIfAniCur, hbrFlickerFreeDraw, uFlags);
	}
	BOOL DrawIconEx(POINT point, HICON hIcon, SIZE size, UINT uStepIfAniCur = 0, HBRUSH hbrFlickerFreeDraw = NULL, UINT uFlags = DI_NORMAL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawIconEx(m_hDC, point.x, point.y, hIcon, size.cx, size.cy, uStepIfAniCur, hbrFlickerFreeDraw, uFlags);
	}
	BOOL DrawState(POINT pt, SIZE size, HBITMAP hBitmap, UINT nFlags, HBRUSH hBrush = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawState(m_hDC, hBrush, NULL, (LPARAM)hBitmap, 0, pt.x, pt.y, size.cx, size.cy, nFlags | DST_BITMAP);
	}
	BOOL DrawState(POINT pt, SIZE size, HICON hIcon, UINT nFlags, HBRUSH hBrush = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawState(m_hDC, hBrush, NULL, (LPARAM)hIcon, 0, pt.x, pt.y, size.cx, size.cy, nFlags | DST_ICON);
	}
	BOOL DrawState(POINT pt, SIZE size, LPCTSTR lpszText, UINT nFlags, BOOL bPrefixText = TRUE, int nTextLen = 0, HBRUSH hBrush = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawState(m_hDC, hBrush, NULL, (LPARAM)lpszText, (WPARAM)nTextLen, pt.x, pt.y, size.cx, size.cy, nFlags | (bPrefixText ? DST_PREFIXTEXT : DST_TEXT));
	}
	BOOL DrawState(POINT pt, SIZE size, DRAWSTATEPROC lpDrawProc, LPARAM lData, UINT nFlags, HBRUSH hBrush = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawState(m_hDC, hBrush, lpDrawProc, lData, 0, pt.x, pt.y, size.cx, size.cy, nFlags | DST_COMPLEX);
	}

// Ellipse and Polygon Functions
	BOOL Chord(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Chord(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
	}
	BOOL Chord(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Chord(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y);
	}
	void DrawFocusRect(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		::DrawFocusRect(m_hDC, lpRect);
	}
	BOOL Ellipse(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Ellipse(m_hDC, x1, y1, x2, y2);
	}
	BOOL Ellipse(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Ellipse(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
	BOOL Pie(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Pie(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
	}
	BOOL Pie(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Pie(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y);
	}
	BOOL Polygon(LPPOINT lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Polygon(m_hDC, lpPoints, nCount);
	}
	BOOL PolyPolygon(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyPolygon(m_hDC, lpPoints, lpPolyCounts, nCount);
	}
	BOOL Rectangle(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Rectangle(m_hDC, x1, y1, x2, y2);
	}
	BOOL Rectangle(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Rectangle(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
	BOOL RoundRect(int x1, int y1, int x2, int y2, int x3, int y3)
	{
		ATLASSERT(m_hDC != NULL);
		return ::RoundRect(m_hDC, x1, y1, x2, y2, x3, y3);
	}
	BOOL RoundRect(LPCRECT lpRect, POINT point)
	{
		ATLASSERT(m_hDC != NULL);
		return ::RoundRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, point.x, point.y);
	}

// Bitmap Functions
	BOOL PatBlt(int x, int y, int nWidth, int nHeight, DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PatBlt(m_hDC, x, y, nWidth, nHeight, dwRop);
	}
	BOOL BitBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC,
		int xSrc, int ySrc, DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::BitBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, dwRop);
	}
	BOOL StretchBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::StretchBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, nSrcWidth, nSrcHeight, dwRop);
	}
	COLORREF GetPixel(int x, int y) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPixel(m_hDC, x, y);
	}
	COLORREF GetPixel(POINT point) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPixel(m_hDC, point.x, point.y);
	}
	COLORREF SetPixel(int x, int y, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixel(m_hDC, x, y, crColor);
	}
	COLORREF SetPixel(POINT point, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixel(m_hDC, point.x, point.y, crColor);
	}
	BOOL FloodFill(int x, int y, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FloodFill(m_hDC, x, y, crColor);
	}
	BOOL ExtFloodFill(int x, int y, COLORREF crColor, UINT nFillType)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExtFloodFill(m_hDC, x, y, crColor, nFillType);
	}
	BOOL MaskBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC, int xSrc, int ySrc, HBITMAP hMaskBitmap, int xMask, int yMask, DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::MaskBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, hMaskBitmap, xMask, yMask, dwRop);
	}
	BOOL PlgBlt(LPPOINT lpPoint, HDC hSrcDC, int xSrc, int ySrc, int nWidth, int nHeight, HBITMAP hMaskBitmap, int xMask, int yMask)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PlgBlt(m_hDC, lpPoint, hSrcDC, xSrc, ySrc, nWidth, nHeight, hMaskBitmap, xMask, yMask);
	}
	BOOL SetPixelV(int x, int y, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixelV(m_hDC, x, y, crColor);
	}
	BOOL SetPixelV(POINT point, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixelV(m_hDC, point.x, point.y, crColor);
	}

#ifndef _ATL_NO_MSIMG
	BOOL AlphaBlend(int x, int y, int nWidth, int nHeight, HDC hSrcDC, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, BLENDFUNCTION bf)
	{
		ATLASSERT(m_hDC != NULL);
		return ::AlphaBlend(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, nSrcWidth, nSrcHeight, bf);
	}
	BOOL TransparentBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, UINT crTransparent)
	{
		ATLASSERT(m_hDC != NULL);
		return ::TransparentBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, nSrcWidth, nSrcHeight, crTransparent);
	}
	BOOL GradientFill(const PTRIVERTEX pVertices, DWORD nVertices, void* pMeshElements, DWORD nMeshElements, DWORD dwMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::GradientFill(m_hDC, pVertices, nVertices, pMeshElements, nMeshElements, dwMode);
	}
#endif //!_ATL_NO_MSIMG

// Extra bitmap functions
	// Helper function for painting a disabled toolbar or menu bitmap
	// This function can take either an HBITMAP (for SS) or a DC with 
	//           the bitmap already painted (for cmdbar)
	BOOL DitherBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC, HBITMAP hBitmap, int xSrc, int ySrc)
	{
		ATLASSERT(m_hDC != NULL || hBitmap != NULL);
		ATLASSERT(nWidth > 0 && nHeight > 0);
		
		// Create a generic DC for all BitBlts
		CDCHandle dc = (hSrcDC != NULL) ? hSrcDC : ::CreateCompatibleDC(m_hDC);
		ATLASSERT(dc.m_hDC != NULL);
		if(dc.m_hDC == NULL)
			return FALSE;
		
		// Create a DC for the monochrome DIB section
		CDC dcBW = ::CreateCompatibleDC(m_hDC);
		ATLASSERT(dcBW.m_hDC != NULL);
		if(dcBW.m_hDC == NULL)
		{
			if(hSrcDC == NULL)
				::DeleteDC(dc);
			return FALSE;
		}

		// Create the monochrome DIB section with a black and white palette
		struct RGBBWBITMAPINFO
		{
			BITMAPINFOHEADER bmiHeader; 
			RGBQUAD          bmiColors[2]; 
		};

		RGBBWBITMAPINFO rgbBWBitmapInfo = 
		{
			{ sizeof(BITMAPINFOHEADER), nWidth, nHeight, 1, 1, BI_RGB, 0, 0, 0, 0, 0 },
			{ { 0x00, 0x00, 0x00, 0x00 }, { 0xFF, 0xFF, 0xFF, 0x00 } }
		};

		VOID *pbitsBW;
		CBitmap bmpBW = ::CreateDIBSection(dcBW, (LPBITMAPINFO)&rgbBWBitmapInfo, DIB_RGB_COLORS, &pbitsBW, NULL, 0);
		ATLASSERT(bmpBW.m_hBitmap != NULL);
		if(bmpBW.m_hBitmap == NULL)
		{
			if(hSrcDC == NULL)
				::DeleteDC(dc);
			return FALSE;
		}
		
		// Attach the monochrome DIB section and the bitmap to the DCs
		HBITMAP hbmOldBW = dcBW.SelectBitmap(bmpBW);
		HBITMAP hbmOldDC = NULL;
		if(hBitmap != NULL)
			hbmOldDC = dc.SelectBitmap(hBitmap);

		// Block: Dark gray removal: we want (128, 128, 128) pixels to become black and not white
		{
			CDC dcTemp1 = ::CreateCompatibleDC(m_hDC);
			CDC dcTemp2 = ::CreateCompatibleDC(m_hDC);
			CBitmap bmpTemp1;
			bmpTemp1.CreateCompatibleBitmap(dc, nWidth, nHeight);
			CBitmap bmpTemp2;
			bmpTemp2.CreateBitmap(nWidth, nHeight, 1, 1, NULL);
			HBITMAP hOldBmp1 = dcTemp1.SelectBitmap(bmpTemp1);
			HBITMAP hOldBmp2 = dcTemp2.SelectBitmap(bmpTemp2);
			// Let's copy our image, it will be altered
			dcTemp1.BitBlt(0, 0, nWidth, nHeight, dc, xSrc, ySrc, SRCCOPY);

			// All dark gray pixels will become white, the others black
			dcTemp1.SetBkColor(RGB(128, 128, 128));
			dcTemp2.BitBlt(0, 0, nWidth, nHeight, dcTemp1, 0, 0, SRCCOPY);
			// Do an XOR to set to black these white pixels
			dcTemp1.BitBlt(0, 0, nWidth, nHeight, dcTemp2, 0, 0, SRCINVERT);

			// BitBlt the bitmap into the monochrome DIB section
			// The DIB section will do a true monochrome conversion
			// The magenta background being closer to white will become white
			dcBW.BitBlt(0, 0, nWidth, nHeight, dcTemp1, 0, 0, SRCCOPY);

			// Cleanup
			dcTemp1.SelectBitmap(hOldBmp1);
			dcTemp2.SelectBitmap(hOldBmp2);
		}
		
		// Paint the destination rectangle in gray
		RECT rc = { x, y, x + nWidth, y + nHeight };
		FillRect(&rc, ::GetSysColorBrush(COLOR_3DFACE));

		// BitBlt the black bits in the monochrome bitmap into COLOR_3DHILIGHT bits in the destination DC
		// The magic ROP comes from the Charles Petzold's book
		CBrush brushHilight;
		brushHilight.CreateSolidBrush(::GetSysColor(COLOR_3DHILIGHT));
		HBRUSH hOldBrush = SelectBrush(brushHilight);
		BitBlt(x + 1, y + 1, nWidth, nHeight, dcBW, 0, 0, 0xB8074A);

		// BitBlt the black bits in the monochrome bitmap into COLOR_3DSHADOW bits in the destination DC
		CBrush brushShadow;
		brushShadow.CreateSolidBrush(::GetSysColor(COLOR_3DSHADOW));
		SelectBrush(brushShadow);
		BitBlt(x, y, nWidth, nHeight, dcBW, 0, 0, 0xB8074A);

		SelectBrush(hOldBrush);
		dcBW.SelectBitmap(hbmOldBW);
		dc.SelectBitmap(hbmOldDC);

		if(hSrcDC == NULL)
			::DeleteDC(dc);

		return TRUE;
	}

// Text Functions
	BOOL TextOut(int x, int y, LPCTSTR lpszString, int nCount = -1)
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		return ::TextOut(m_hDC, x, y, lpszString, nCount);
	}
	BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect, LPCTSTR lpszString, UINT nCount = -1, LPINT lpDxWidths = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		return ::ExtTextOut(m_hDC, x, y, nOptions, lpRect, lpszString, nCount, lpDxWidths);
	}
	SIZE TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount = -1, int nTabPositions = 0, LPINT lpnTabStopPositions = NULL, int nTabOrigin = 0)
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		LONG lRes = ::TabbedTextOut(m_hDC, x, y, lpszString, nCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
		SIZE size = { GET_X_LPARAM(lRes), GET_Y_LPARAM(lRes) };
		return size;
	}
	int DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect, UINT nFormat)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawText(m_hDC, lpszString, nCount, lpRect, nFormat);
	}
	BOOL GetTextExtent(LPCTSTR lpszString, int nCount, LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		return ::GetTextExtentPoint32(m_hDC, lpszString, nCount, lpSize);
	}
	BOOL GetTabbedTextExtent(LPCTSTR lpszString, int nCount, int nTabPositions, LPINT lpnTabStopPositions) const
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		return ::GetTabbedTextExtent(m_hDC, lpszString, nCount, nTabPositions, lpnTabStopPositions);
	}
	BOOL GrayString(HBRUSH hBrush, BOOL (CALLBACK* lpfnOutput)(HDC, LPARAM, int), LPARAM lpData, int nCount, int x, int y, int nWidth, int nHeight)
	{
		ATLASSERT(m_hDC != NULL);
		return ::GrayString(m_hDC, hBrush, (GRAYSTRINGPROC)lpfnOutput, lpData, nCount, x, y, nWidth, nHeight);
	}
	UINT GetTextAlign() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextAlign(m_hDC);
	}
	UINT SetTextAlign(UINT nFlags)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetTextAlign(m_hDC, nFlags);
	}
	int GetTextFace(LPTSTR lpszFacename, int nCount) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextFace(m_hDC, nCount, lpszFacename);
	}
	int GetTextFaceLen() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextFace(m_hDC, 0, NULL);
	}
#ifndef _ATL_NO_COM
#ifdef _OLEAUTO_H_
	BOOL GetTextFace(BSTR& bstrFace) const
	{
		USES_CONVERSION;
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(bstrFace == NULL);

		int nLen = GetTextFaceLen();
		if(nLen == 0)
			return FALSE;

		LPTSTR lpszText = (LPTSTR)_alloca(nLen * sizeof(TCHAR));

		if(!GetTextFace(lpszText, nLen))
			return FALSE;

		bstrFace = ::SysAllocString(T2OLE(lpszText));
		return (bstrFace != NULL) ? TRUE : FALSE;
	}
#endif
#endif //!_ATL_NO_COM
#ifdef __ATLSTR_H__
	int GetTextFace(CString& strFace) const
	{
		ATLASSERT(m_hDC != NULL);

		int nLen = GetTextFaceLen();
		if(nLen == 0)
			return 0;

		int nRet = GetTextFace(strFace.GetBufferSetLength(nLen), nLen);
		strFace.ReleaseBuffer();
		return nRet;
	}
#endif //__ATLSTR_H__
	BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextMetrics(m_hDC, lpMetrics);
	}
	int SetTextJustification(int nBreakExtra, int nBreakCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetTextJustification(m_hDC, nBreakExtra, nBreakCount);
	}
	int GetTextCharacterExtra() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextCharacterExtra(m_hDC);
	}
	int SetTextCharacterExtra(int nCharExtra)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetTextCharacterExtra(m_hDC, nCharExtra);
	}

// Advanced Drawing
	BOOL DrawEdge(LPRECT lpRect, UINT nEdge, UINT nFlags)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawEdge(m_hDC, lpRect, nEdge, nFlags);
	}
	BOOL DrawFrameControl(LPRECT lpRect, UINT nType, UINT nState)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawFrameControl(m_hDC, lpRect, nType, nState);
	}

// Scrolling Functions
	BOOL ScrollDC(int dx, int dy, LPCRECT lpRectScroll, LPCRECT lpRectClip, HRGN hRgnUpdate, LPRECT lpRectUpdate)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ScrollDC(m_hDC, dx, dy, lpRectScroll, lpRectClip, hRgnUpdate, lpRectUpdate);
	}

// Font Functions
	BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharWidth(m_hDC, nFirstChar, nLastChar, lpBuffer);
	}
	// GetCharWidth32 is not supported under Win9x
	BOOL GetCharWidth32(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharWidth32(m_hDC, nFirstChar, nLastChar, lpBuffer);
	}
	DWORD SetMapperFlags(DWORD dwFlag)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetMapperFlags(m_hDC, dwFlag);
	}
	BOOL GetAspectRatioFilter(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetAspectRatioFilterEx(m_hDC, lpSize);
	}

	BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar, LPABC lpabc) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharABCWidths(m_hDC, nFirstChar, nLastChar, lpabc);
	}
	DWORD GetFontData(DWORD dwTable, DWORD dwOffset, LPVOID lpData, DWORD cbData) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetFontData(m_hDC, dwTable, dwOffset, lpData, cbData);
	}
	int GetKerningPairs(int nPairs, LPKERNINGPAIR lpkrnpair) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetKerningPairs(m_hDC, nPairs, lpkrnpair);
	}
	UINT GetOutlineTextMetrics(UINT cbData, LPOUTLINETEXTMETRIC lpotm) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetOutlineTextMetrics(m_hDC, cbData, lpotm);
	}
	DWORD GetGlyphOutline(UINT nChar, UINT nFormat, LPGLYPHMETRICS lpgm, DWORD cbBuffer, LPVOID lpBuffer, const MAT2* lpmat2) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetGlyphOutline(m_hDC, nChar, nFormat, lpgm, cbBuffer, lpBuffer, lpmat2);
	}

	BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar, LPABCFLOAT lpABCF) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharABCWidthsFloat(m_hDC, nFirstChar, nLastChar, lpABCF);
	}
	BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar, float* lpFloatBuffer) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharWidthFloat(m_hDC, nFirstChar, nLastChar, lpFloatBuffer);
	}

// Printer/Device Escape Functions
	int Escape(int nEscape, int nCount, LPCSTR lpszInData, LPVOID lpOutData)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Escape(m_hDC, nEscape, nCount, lpszInData, lpOutData);
	}
	int Escape(int nEscape, int nInputSize, LPCSTR lpszInputData,
		int nOutputSize, LPSTR lpszOutputData)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExtEscape(m_hDC, nEscape, nInputSize, lpszInputData, nOutputSize, lpszOutputData);
	}
	int DrawEscape(int nEscape, int nInputSize, LPCSTR lpszInputData)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawEscape(m_hDC, nEscape, nInputSize, lpszInputData);
	}

	// Escape helpers
	int StartDoc(LPCTSTR lpszDocName)  // old Win3.0 version
	{
		DOCINFO di;
		memset(&di, 0, sizeof(DOCINFO));
		di.cbSize = sizeof(DOCINFO);
		di.lpszDocName = lpszDocName;
		return StartDoc(&di);
	}

	int StartDoc(LPDOCINFO lpDocInfo)
	{
		ATLASSERT(m_hDC != NULL);
		return ::StartDoc(m_hDC, lpDocInfo);
	}
	int StartPage()
	{
		ATLASSERT(m_hDC != NULL);
		return ::StartPage(m_hDC);
	}
	int EndPage()
	{
		ATLASSERT(m_hDC != NULL);
		return ::EndPage(m_hDC);
	}
	int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int))
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetAbortProc(m_hDC, (ABORTPROC)lpfn);
	}
	int AbortDoc()
	{
		ATLASSERT(m_hDC != NULL);
		return ::AbortDoc(m_hDC);
	}
	int EndDoc()
	{
		ATLASSERT(m_hDC != NULL);
		return ::EndDoc(m_hDC);
	}

// MetaFile Functions
	BOOL PlayMetaFile(HMETAFILE hMF)
	{
		ATLASSERT(m_hDC != NULL);
		if(::GetDeviceCaps(m_hDC, TECHNOLOGY) == DT_METAFILE)
		{
			// playing metafile in metafile, just use core windows API
			return ::PlayMetaFile(m_hDC, hMF);
		}

		// for special playback, lParam == pDC
		return ::EnumMetaFile(m_hDC, hMF, EnumMetaFileProc, (LPARAM)this);
	}
	BOOL PlayMetaFile(HENHMETAFILE hEnhMetaFile, LPCRECT lpBounds)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PlayEnhMetaFile(m_hDC, hEnhMetaFile, lpBounds);
	}
	BOOL AddMetaFileComment(UINT nDataSize, const BYTE* pCommentData) // can be used for enhanced metafiles only
	{
		ATLASSERT(m_hDC != NULL);
		return ::GdiComment(m_hDC, nDataSize, pCommentData);
	}

	// Special handling for metafile playback
	static int CALLBACK EnumMetaFileProc(HDC hDC, HANDLETABLE* pHandleTable, METARECORD* pMetaRec, int nHandles, LPARAM lParam)
	{
		CDCHandle* pDC = (CDCHandle*)lParam;

		switch (pMetaRec->rdFunction)
		{
		case META_SETMAPMODE:
			pDC->SetMapMode((int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETWINDOWEXT:
			pDC->SetWindowExt((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETWINDOWORG:
			pDC->SetWindowOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETVIEWPORTEXT:
			pDC->SetViewportExt((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETVIEWPORTORG:
			pDC->SetViewportOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SCALEWINDOWEXT:
			pDC->ScaleWindowExt((int)(short)pMetaRec->rdParm[3], (int)(short)pMetaRec->rdParm[2], 
				(int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SCALEVIEWPORTEXT:
			pDC->ScaleViewportExt((int)(short)pMetaRec->rdParm[3], (int)(short)pMetaRec->rdParm[2],
				(int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_OFFSETVIEWPORTORG:
			pDC->OffsetViewportOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SAVEDC:
			pDC->SaveDC();
			break;
		case META_RESTOREDC:
			pDC->RestoreDC((int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETBKCOLOR:
			pDC->SetBkColor(*(UNALIGNED COLORREF*)&pMetaRec->rdParm[0]);
			break;
		case META_SETTEXTCOLOR:
			pDC->SetTextColor(*(UNALIGNED COLORREF*)&pMetaRec->rdParm[0]);
			break;

		// need to watch out for SelectObject(HFONT), for custom font mapping
		case META_SELECTOBJECT:
			{
				HGDIOBJ hObject = pHandleTable->objectHandle[pMetaRec->rdParm[0]];
				UINT nObjType = ::GetObjectType(hObject);
				if(nObjType == 0)
				{
					// object type is unknown, determine if it is a font
					HFONT hStockFont = (HFONT)::GetStockObject(SYSTEM_FONT);
					HFONT hFontOld = (HFONT)::SelectObject(pDC->m_hDC, hStockFont);
					HGDIOBJ hObjOld = ::SelectObject(pDC->m_hDC, hObject);
					if(hObjOld == hStockFont)
					{
						// got the stock object back, so must be selecting a font
						pDC->SelectFont((HFONT)hObject);
						break;  // don't play the default record
					}
					else
					{
						// didn't get the stock object back, so restore everything
						::SelectObject(pDC->m_hDC, hFontOld);
						::SelectObject(pDC->m_hDC, hObjOld);
					}
					// and fall through to PlayMetaFileRecord...
				}
				else if(nObjType == OBJ_FONT)
				{
					// play back as CDCHandle::SelectFont(HFONT)
					pDC->SelectFont((HFONT)hObject);
					break;  // don't play the default record
				}
			}
			// fall through...

		default:
			::PlayMetaFileRecord(hDC, pHandleTable, pMetaRec, nHandles);
			break;
		}

		return 1;
	}

// Path Functions
	BOOL AbortPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::AbortPath(m_hDC);
	}
	BOOL BeginPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::BeginPath(m_hDC);
	}
	BOOL CloseFigure()
	{
		ATLASSERT(m_hDC != NULL);
		return ::CloseFigure(m_hDC);
	}
	BOOL EndPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::EndPath(m_hDC);
	}
	BOOL FillPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::FillPath(m_hDC);
	}
	BOOL FlattenPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::FlattenPath(m_hDC);
	}
	BOOL StrokeAndFillPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::StrokeAndFillPath(m_hDC);
	}
	BOOL StrokePath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::StrokePath(m_hDC);
	}
	BOOL WidenPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::WidenPath(m_hDC);
	}
	BOOL GetMiterLimit(PFLOAT pfMiterLimit) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetMiterLimit(m_hDC, pfMiterLimit);
	}
	BOOL SetMiterLimit(float fMiterLimit)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetMiterLimit(m_hDC, fMiterLimit, NULL);
	}
	int GetPath(LPPOINT lpPoints, LPBYTE lpTypes, int nCount) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPath(m_hDC, lpPoints, lpTypes, nCount);
	}
	BOOL SelectClipPath(int nMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SelectClipPath(m_hDC, nMode);
	}

// Misc Helper Functions
	static CBrushHandle PASCAL GetHalftoneBrush()
	{
		HBRUSH halftoneBrush = NULL;
		WORD grayPattern[8];
		for(int i = 0; i < 8; i++)
			grayPattern[i] = (WORD)(0x5555 << (i & 1));
		HBITMAP grayBitmap = CreateBitmap(8, 8, 1, 1, &grayPattern);
		if(grayBitmap != NULL)
		{
			halftoneBrush = ::CreatePatternBrush(grayBitmap);
			DeleteObject(grayBitmap);
		}
		return CBrushHandle(halftoneBrush);
	}
	void DrawDragRect(LPCRECT lpRect, SIZE size, LPCRECT lpRectLast, SIZE sizeLast, HBRUSH hBrush = NULL, HBRUSH hBrushLast = NULL)
	{
		// first, determine the update region and select it
		HRGN hRgnNew;
		HRGN hRgnOutside, hRgnInside;
		hRgnOutside = ::CreateRectRgnIndirect(lpRect);
		RECT rect = *lpRect;
		::InflateRect(&rect, -size.cx, -size.cy);
		::IntersectRect(&rect, &rect, lpRect);
		hRgnInside = ::CreateRectRgnIndirect(&rect);
		hRgnNew = ::CreateRectRgn(0, 0, 0, 0);
		::CombineRgn(hRgnNew, hRgnOutside, hRgnInside, RGN_XOR);

		HBRUSH hBrushOld = NULL;
		if(hBrush == NULL)
			hBrush = CDCHandle::GetHalftoneBrush();
		if(hBrushLast == NULL)
			hBrushLast = hBrush;

		HRGN hRgnLast = NULL, hRgnUpdate = NULL;
		if(lpRectLast != NULL)
		{
			// find difference between new region and old region
			hRgnLast = ::CreateRectRgn(0, 0, 0, 0);
			::SetRectRgn(hRgnOutside, lpRectLast->left, lpRectLast->top, lpRectLast->right, lpRectLast->bottom);
			rect = *lpRectLast;
			::InflateRect(&rect, -sizeLast.cx, -sizeLast.cy);
			::IntersectRect(&rect, &rect, lpRectLast);
			::SetRectRgn(hRgnInside, rect.left, rect.top, rect.right, rect.bottom);
			::CombineRgn(hRgnLast, hRgnOutside, hRgnInside, RGN_XOR);

			// only diff them if brushes are the same
			if(hBrush == hBrushLast)
			{
				hRgnUpdate = ::CreateRectRgn(0, 0, 0, 0);
				::CombineRgn(hRgnUpdate, hRgnLast, hRgnNew, RGN_XOR);
			}
		}
		if(hBrush != hBrushLast && lpRectLast != NULL)
		{
			// brushes are different -- erase old region first
			SelectClipRgn(hRgnLast);
			GetClipBox(&rect);
			hBrushOld = SelectBrush(hBrushLast);
			PatBlt(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, PATINVERT);
			SelectBrush(hBrushOld);
			hBrushOld = NULL;
		}

		// draw into the update/new region
		SelectClipRgn(hRgnUpdate != NULL ? hRgnUpdate : hRgnNew);
		GetClipBox(&rect);
		hBrushOld = SelectBrush(hBrush);
		PatBlt(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, PATINVERT);

		// cleanup DC
		if(hBrushOld != NULL)
			SelectBrush(hBrushOld);
		SelectClipRgn(NULL);
	}
	void FillSolidRect(LPCRECT lpRect, COLORREF clr)
	{
		ATLASSERT(m_hDC != NULL);

		::SetBkColor(m_hDC, clr);
		::ExtTextOut(m_hDC, 0, 0, ETO_OPAQUE, lpRect, NULL, 0, NULL);
	}
	void FillSolidRect(int x, int y, int cx, int cy, COLORREF clr)
	{
		ATLASSERT(m_hDC != NULL);

		::SetBkColor(m_hDC, clr);
		RECT rect = { x, y, x + cx, y + cy };
		::ExtTextOut(m_hDC, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
	}
	void Draw3dRect(LPCRECT lpRect, COLORREF clrTopLeft, COLORREF clrBottomRight)
	{
		Draw3dRect(lpRect->left, lpRect->top, lpRect->right - lpRect->left,
			lpRect->bottom - lpRect->top, clrTopLeft, clrBottomRight);
	}
	void Draw3dRect(int x, int y, int cx, int cy, COLORREF clrTopLeft, COLORREF clrBottomRight)
	{
		FillSolidRect(x, y, cx - 1, 1, clrTopLeft);
		FillSolidRect(x, y, 1, cy - 1, clrTopLeft);
		FillSolidRect(x + cx, y, -1, cy, clrBottomRight);
		FillSolidRect(x, y + cy, cx, -1, clrBottomRight);
	}

// DIB support
	int SetDIBitsToDevice(int x, int y, DWORD dwWidth, DWORD dwHeight, int xSrc, int ySrc, UINT uStartScan, UINT cScanLines, CONST VOID* lpvBits, CONST BITMAPINFO* lpbmi, UINT uColorUse)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetDIBitsToDevice(m_hDC, x, y, dwWidth, dwHeight, xSrc, ySrc, uStartScan, cScanLines, lpvBits, lpbmi, uColorUse);
	}
	int StretchDIBits(int x, int y, int nWidth, int nHeight, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, CONST VOID* lpvBits, CONST BITMAPINFO* lpbmi, UINT uColorUse, DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::StretchDIBits(m_hDC, x, y, nWidth, nHeight, xSrc, ySrc, nSrcWidth, nSrcHeight, lpvBits, lpbmi, uColorUse, dwRop);
	}
	UINT GetDIBColorTable(UINT uStartIndex, UINT cEntries, RGBQUAD* pColors) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetDIBColorTable(m_hDC, uStartIndex, cEntries, pColors);
	}
	UINT SetDIBColorTable(UINT uStartIndex, UINT cEntries, CONST RGBQUAD* pColors)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetDIBColorTable(m_hDC, uStartIndex, cEntries, pColors);
	}

// OpenGL support
#ifndef _ATL_NO_OPENGL
	int ChoosePixelFormat(CONST PIXELFORMATDESCRIPTOR* ppfd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ChoosePixelFormat(m_hDC, ppfd);
	}
	int DescribePixelFormat(int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DescribePixelFormat(m_hDC, iPixelFormat, nBytes, ppfd);
	}
	int GetPixelFormat() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPixelFormat(m_hDC);
	}
	BOOL SetPixelFormat(int iPixelFormat, CONST PIXELFORMATDESCRIPTOR* ppfd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixelFormat(m_hDC, iPixelFormat, ppfd);
	}
	BOOL SwapBuffers()
	{
		ATLASSERT(m_hDC != NULL);
		return ::SwapBuffers(m_hDC);
	}

	HGLRC wglCreateContext()
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglCreateContext(m_hDC);
	}
	HGLRC wglCreateLayerContext(int iLayerPlane)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglCreateLayerContext(m_hDC, iLayerPlane);
	}
	BOOL wglMakeCurrent(HGLRC hglrc)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglMakeCurrent(m_hDC, hglrc);
	}
	BOOL wglUseFontBitmaps(DWORD dwFirst, DWORD dwCount, DWORD listBase)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglUseFontBitmaps(m_hDC, dwFirst, dwCount, listBase);
	}
	BOOL wglUseFontOutlines(DWORD dwFirst, DWORD dwCount, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglUseFontOutlines(m_hDC, dwFirst, dwCount, listBase, deviation, extrusion, format, lpgmf);
	}
	BOOL wglDescribeLayerPlane(int iPixelFormat, int iLayerPlane, UINT nBytes, LPLAYERPLANEDESCRIPTOR plpd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglDescribeLayerPlane(m_hDC, iPixelFormat, iLayerPlane, nBytes, plpd);
	}
	int wglSetLayerPaletteEntries(int iLayerPlane, int iStart, int cEntries, CONST COLORREF* pclr)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglSetLayerPaletteEntries(m_hDC, iLayerPlane, iStart, cEntries, pclr);
	}
	int wglGetLayerPaletteEntries(int iLayerPlane, int iStart, int cEntries, COLORREF* pclr)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglGetLayerPaletteEntries(m_hDC, iLayerPlane, iStart, cEntries, pclr);
	}
	BOOL wglRealizeLayerPalette(int iLayerPlane, BOOL bRealize)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglRealizeLayerPalette(m_hDC, iLayerPlane, bRealize);
	}
	BOOL wglSwapLayerBuffers(UINT uPlanes)
	{
		ATLASSERT(m_hDC != NULL);
		return ::wglSwapLayerBuffers(m_hDC, uPlanes);
	}
#endif //!_ATL_NO_OPENGL

// New for Windows 2000 only
#if (_WIN32_WINNT >= 0x0500)

	COLORREF GetDCPenColor() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetDCPenColor(m_hDC);
	}
	COLORREF SetDCPenColor(COLORREF clr)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetDCPenColor(m_hDC, clr);
	}
	COLORREF GetDCBrushColor() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetDCBrushColor(m_hDC);
	}
	COLORREF SetDCBrushColor(COLORREF clr)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetDCBrushColor(m_hDC, clr);
	}

	DWORD GetFontUnicodeRanges(LPGLYPHSET lpgs) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetFontUnicodeRanges(m_hDC, lpgs);
	}
	DWORD GetGlyphIndices(LPCTSTR lpstr, int cch, LPWORD pgi, DWORD dwFlags) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetGlyphIndices(m_hDC, lpstr, cch, pgi, dwFlags);
	}

	BOOL GetTextExtentPointI(LPWORD pgiIn, int cgi, LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextExtentPointI(m_hDC, pgiIn, cgi, lpSize);
	}
	BOOL GetTextExtentExPointI(LPWORD pgiIn, int cgi, int nMaxExtent, LPINT lpnFit, LPINT alpDx, LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextExtentExPointI(m_hDC, pgiIn, cgi, nMaxExtent, lpnFit, alpDx, lpSize);
	}
	BOOL GetCharWidthI(UINT giFirst, UINT cgi, LPWORD pgi, LPINT lpBuffer) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharWidthI(m_hDC, giFirst, cgi, pgi, lpBuffer);
	}
	BOOL GetCharABCWidthsI(UINT giFirst, UINT cgi, LPWORD pgi, LPABC lpabc) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharABCWidthsI(m_hDC, giFirst, cgi, pgi, lpabc);
	}

#endif //(_WIN32_WINNT >= 0x0500)

// New for Windows 2000 and Windows 98
#if (WINVER >= 0x0500)

	BOOL ColorCorrectPalette(HPALETTE hPalette, DWORD dwFirstEntry, DWORD dwNumOfEntries)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ColorCorrectPalette(m_hDC, hPalette, dwFirstEntry, dwNumOfEntries);
	}

#endif //(WINVER >= 0x0500)
};


/////////////////////////////////////////////////////////////////////////////
// CDC Helpers

class CPaintDC : public CDC
{
public:
// Data members
	HWND m_hWnd;
	PAINTSTRUCT m_ps;

// Constructor/destructor
	CPaintDC(HWND hWnd)
	{
		ATLASSERT(::IsWindow(hWnd));
		m_hWnd = hWnd;
		m_hDC = ::BeginPaint(hWnd, &m_ps);
	}
	~CPaintDC()
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(::IsWindow(m_hWnd));
		::EndPaint(m_hWnd, &m_ps);
		Detach();
	}
};

class CClientDC : public CDC
{
public:
// Data members
	HWND m_hWnd;

// Constructor/destructor
	CClientDC(HWND hWnd)
	{
		ATLASSERT(hWnd == NULL || ::IsWindow(hWnd));
		m_hWnd = hWnd;
		m_hDC = ::GetDC(hWnd);
	}
	~CClientDC()
	{
		ATLASSERT(m_hDC != NULL);
		::ReleaseDC(m_hWnd, Detach());
	}
};

class CWindowDC : public CDC
{
public:
// Data members
	HWND m_hWnd;

// Constructor/destructor
	CWindowDC(HWND hWnd)
	{
		ATLASSERT(hWnd == NULL || ::IsWindow(hWnd));
		m_hWnd = hWnd;
		m_hDC = ::GetWindowDC(hWnd);
	}
	~CWindowDC()
	{
		ATLASSERT(m_hDC != NULL);
		::ReleaseDC(m_hWnd, Detach());
	}
};


/////////////////////////////////////////////////////////////////////////////
// Enhanced metafile support

class CEnhMetaFileInfo
{
public:
// Data members
	HENHMETAFILE m_hEMF;
	BYTE* m_pBits;
	TCHAR* m_pDesc;
	ENHMETAHEADER m_header;
	PIXELFORMATDESCRIPTOR m_pfd;

// Constructor/destructor
	CEnhMetaFileInfo(HENHMETAFILE hEMF) : m_pBits(NULL), m_pDesc(NULL), m_hEMF(hEMF)
	{ }

	~CEnhMetaFileInfo()
	{
		delete [] m_pBits;
		delete [] m_pDesc;
	}

// Operations
	BYTE* GetEnhMetaFileBits()
	{
		ATLASSERT(m_hEMF != NULL);
		UINT nBytes = ::GetEnhMetaFileBits(m_hEMF, 0, NULL);
		delete [] m_pBits;
		m_pBits = NULL;
		ATLTRY(m_pBits = new BYTE[nBytes]);
		if (m_pBits != NULL)
			::GetEnhMetaFileBits(m_hEMF, nBytes, m_pBits);
		return m_pBits;
	}
	LPTSTR GetEnhMetaFileDescription()
	{
		ATLASSERT(m_hEMF != NULL);
		UINT nLen = ::GetEnhMetaFileDescription(m_hEMF, 0, NULL);
		delete [] m_pDesc;
		m_pDesc = NULL;
		ATLTRY(m_pDesc = new TCHAR[nLen]);
		if (m_pDesc != NULL)
			nLen = ::GetEnhMetaFileDescription(m_hEMF, nLen, m_pDesc);
		return m_pDesc;
	}
	ENHMETAHEADER* GetEnhMetaFileHeader()
	{
		ATLASSERT(m_hEMF != NULL);
		memset(&m_header, 0, sizeof(m_header));
		m_header.iType = EMR_HEADER;
		m_header.nSize = sizeof(ENHMETAHEADER);
		UINT n = ::GetEnhMetaFileHeader(m_hEMF, sizeof(ENHMETAHEADER), &m_header);
		return (n != 0) ? &m_header : NULL;
	}
	PIXELFORMATDESCRIPTOR* GetEnhMetaFilePixelFormat()
	{
		ATLASSERT(m_hEMF != NULL);
		memset(&m_pfd, 0, sizeof(m_pfd));
		UINT n = ::GetEnhMetaFilePixelFormat(m_hEMF, sizeof(m_pfd), &m_pfd);
		return (n != 0) ? &m_pfd : NULL;
	}
};


typedef CEnhMetaFileT<false>	CEnhMetaFileHandle;
typedef CEnhMetaFileT<true>	CEnhMetaFile;

template <bool t_bManaged>
class CEnhMetaFileT
{
public:
// Data members
	HENHMETAFILE m_hEMF;

// Constructor/destructor
	CEnhMetaFileT(HENHMETAFILE hEMF = NULL) : m_hEMF(hEMF)
	{
	}

	~CEnhMetaFileT()
	{
		if(t_bManaged && m_hEMF != NULL)
			DeleteObject();
	}

// Operations
	CEnhMetaFileT<t_bManaged>& operator=(HENHMETAFILE hEMF)
	{
		Attach(hEMF);
		return *this;
	}

	void Attach(HENHMETAFILE hEMF)
	{
		if(t_bManaged && m_hEMF != NULL)
			DeleteObject();
		m_hEMF = hEMF;
	}
	HENHMETAFILE Detach()
	{
		HENHMETAFILE hEMF = m_hEMF;
		m_hEMF = NULL;
		return hEMF;
	}

	operator HENHMETAFILE() const { return m_hEMF; }

	bool IsNull() const { return (m_hEMF == NULL); }

	BOOL DeleteObject()
	{
		ATLASSERT(m_hEMF != NULL);
		BOOL bRet = ::DeleteEnhMetaFile(m_hEMF);
		m_hEMF = NULL;
		return bRet;
	}

	UINT GetEnhMetaFileBits(UINT cbBuffer, LPBYTE lpbBuffer) const
	{
		ATLASSERT(m_hEMF != NULL);
		return ::GetEnhMetaFileBits(m_hEMF, cbBuffer, lpbBuffer);
	}
	UINT GetEnhMetaFileDescription(UINT cchBuffer, LPTSTR lpszDescription) const
	{
		ATLASSERT(m_hEMF != NULL);
		return ::GetEnhMetaFileDescription(m_hEMF, cchBuffer, lpszDescription);
	}
	UINT GetEnhMetaFileHeader(LPENHMETAHEADER lpemh) const
	{
		ATLASSERT(m_hEMF != NULL);
		lpemh->iType = EMR_HEADER;
		lpemh->nSize = sizeof(ENHMETAHEADER);
		return ::GetEnhMetaFileHeader(m_hEMF, sizeof(ENHMETAHEADER), lpemh);
	}
	UINT GetEnhMetaFilePaletteEntries(UINT cEntries, LPPALETTEENTRY lppe) const
	{
		ATLASSERT(m_hEMF != NULL);
		return ::GetEnhMetaFilePaletteEntries(m_hEMF, cEntries, lppe);
	}
	UINT GetEnhMetaFilePixelFormat(DWORD cbBuffer, PIXELFORMATDESCRIPTOR* ppfd) const
	{
		ATLASSERT(m_hEMF != NULL);
		return ::GetEnhMetaFilePixelFormat(m_hEMF, cbBuffer, ppfd);
	}
};


class CEnhMetaFileDC : public CDC
{
public:
// Constructor/destructor
	CEnhMetaFileDC()
	{
	}
	CEnhMetaFileDC(HDC hdc, LPCRECT lpRect)
	{
		Create(hdc, NULL, lpRect, NULL);
		ATLASSERT(m_hDC != NULL);
	}
	CEnhMetaFileDC(HDC hdcRef, LPCTSTR lpFilename, LPCRECT lpRect, LPCTSTR lpDescription)
	{
		Create(hdcRef, lpFilename, lpRect, lpDescription);
		ATLASSERT(m_hDC != NULL);
	}

	~CEnhMetaFileDC()
	{
		HENHMETAFILE hEMF = Close();
		if (hEMF != NULL)
			::DeleteEnhMetaFile(hEMF);
	}

// Operations
	void Create(HDC hdcRef, LPCTSTR lpFilename, LPCRECT lpRect, LPCTSTR lpDescription)
	{
		ATLASSERT(m_hDC == NULL);
		m_hDC = ::CreateEnhMetaFile(hdcRef, lpFilename, lpRect, lpDescription);
	}
	HENHMETAFILE Close()
	{
		HENHMETAFILE hEMF = NULL;
		if (m_hDC != NULL)
		{
			hEMF = ::CloseEnhMetaFile(m_hDC);
			m_hDC = NULL;
		}
		return hEMF;
	}
};

}; //namespace WTL

#endif // __ATLGDI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wtl10\atlframe.h ===
// WTL Version 3.1
// Copyright (C) 1997-2000 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLFRAME_H__
#define __ATLFRAME_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlframe.h requires atlapp.h to be included first
#endif

#ifndef __ATLWIN_H__
	#error atlframe.h requires atlwin.h to be included first
#endif


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T, class TBase = CWindow, class TWinTraits = CFrameWinTraits> class CFrameWindowImpl;
class CMDIWindow;
template <class T, class TBase = CMDIWindow, class TWinTraits = CFrameWinTraits> class CMDIFrameWindowImpl;
template <class T, class TBase = CMDIWindow, class TWinTraits = CMDIChildWinTraits> class CMDIChildWindowImpl;
template <class T> class COwnerDraw;
class CUpdateUIBase;
template <class T> class CUpdateUI;
template <class T> class CDialogResize;


/////////////////////////////////////////////////////////////////////////////
// CFrameWndClassInfo - Manages frame window Windows class information

class CFrameWndClassInfo
{
public:
	WNDCLASSEX m_wc;
	LPCTSTR m_lpszOrigName;
	WNDPROC pWndProc;
	LPCTSTR m_lpszCursorID;
	BOOL m_bSystemCursor;
	ATOM m_atom;
	TCHAR m_szAutoName[5 + sizeof(void*) * 2];	// sizeof(void*) * 2 is the number of digits %p outputs
	UINT m_uCommonResourceID;

	ATOM Register(WNDPROC* pProc)
	{
		if (m_atom == 0)
		{
			::EnterCriticalSection(&_Module.m_csWindowCreate);
			if(m_atom == 0)
			{
				HINSTANCE hInst = _Module.GetModuleInstance();
				if (m_lpszOrigName != NULL)
				{
					ATLASSERT(pProc != NULL);
					LPCTSTR lpsz = m_wc.lpszClassName;
					WNDPROC proc = m_wc.lpfnWndProc;

					WNDCLASSEX wc;
					wc.cbSize = sizeof(WNDCLASSEX);
					if(!::GetClassInfoEx(NULL, m_lpszOrigName, &wc))
					{
						::LeaveCriticalSection(&_Module.m_csWindowCreate);
						return 0;
					}
					memcpy(&m_wc, &wc, sizeof(WNDCLASSEX));
					pWndProc = m_wc.lpfnWndProc;
					m_wc.lpszClassName = lpsz;
					m_wc.lpfnWndProc = proc;
				}
				else
				{
					m_wc.hCursor = ::LoadCursor(m_bSystemCursor ? NULL : hInst,
						m_lpszCursorID);
				}

				m_wc.hInstance = hInst;
				m_wc.style &= ~CS_GLOBALCLASS;	// we don't register global classes
				if (m_wc.lpszClassName == NULL)
				{
					wsprintf(m_szAutoName, _T("ATL:%p"), &m_wc);
					m_wc.lpszClassName = m_szAutoName;
				}
				WNDCLASSEX wcTemp;
				memcpy(&wcTemp, &m_wc, sizeof(WNDCLASSEX));
				m_atom = (ATOM)::GetClassInfoEx(m_wc.hInstance, m_wc.lpszClassName, &wcTemp);

				if (m_atom == 0)
				{
					if(m_uCommonResourceID != 0)	// use it if not zero
					{
						m_wc.hIcon = (HICON)::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(m_uCommonResourceID), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR);
						m_wc.hIconSm = (HICON)::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(m_uCommonResourceID), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
					}
					m_atom = ::RegisterClassEx(&m_wc);
				}
			}
			::LeaveCriticalSection(&_Module.m_csWindowCreate);
		}

		if (m_lpszOrigName != NULL)
		{
			ATLASSERT(pProc != NULL);
			ATLASSERT(pWndProc != NULL);
			*pProc = pWndProc;
		}
		return m_atom;
	}
};

#define DECLARE_FRAME_WND_CLASS(WndClassName, uCommonResourceID) \
static CFrameWndClassInfo& GetWndClassInfo() \
{ \
	static CFrameWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), 0, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, (HBRUSH)(COLOR_WINDOW + 1), NULL, WndClassName, NULL }, \
		NULL, NULL, IDC_ARROW, TRUE, 0, _T(""), uCommonResourceID \
	}; \
	return wc; \
}

#define DECLARE_FRAME_WND_CLASS_EX(WndClassName, uCommonResourceID, style, bkgnd) \
static CFrameWndClassInfo& GetWndClassInfo() \
{ \
	static CFrameWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), style, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, (HBRUSH)(bkgnd + 1), NULL, WndClassName, NULL }, \
		NULL, NULL, IDC_ARROW, TRUE, 0, _T(""), uCommonResourceID \
	}; \
	return wc; \
}

#define DECLARE_FRAME_WND_SUPERCLASS(WndClassName, OrigWndClassName, uCommonResourceID) \
static CFrameWndClassInfo& GetWndClassInfo() \
{ \
	static CFrameWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), 0, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, NULL, NULL, WndClassName, NULL }, \
		OrigWndClassName, NULL, NULL, TRUE, 0, _T(""), uCommonResourceID \
	}; \
	return wc; \
}


// Command Chaining Macros

#define CHAIN_COMMANDS(theChainClass) \
	{ \
		if(uMsg == WM_COMMAND && theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \
			return TRUE; \
	}

#define CHAIN_COMMANDS_MEMBER(theChainMember) \
	{ \
		if(uMsg == WM_COMMAND && theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) \
			return TRUE; \
	}

#define CHAIN_COMMANDS_ALT(theChainClass, msgMapID) \
	{ \
		if(uMsg == WM_COMMAND && theChainClass::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \
			return TRUE; \
	}

#define CHAIN_COMMANDS_ALT_MEMBER(theChainMember, msgMapID) \
	{ \
		if(uMsg == WM_COMMAND && theChainMember.ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, msgMapID)) \
			return TRUE; \
	}


// Client window command chaining macro
#define CHAIN_CLIENT_COMMANDS() \
	if(uMsg == WM_COMMAND && m_hWndClient != NULL) \
		::SendMessage(m_hWndClient, uMsg, wParam, lParam);

/////////////////////////////////////////////////////////////////////////////
// CFrameWindowImpl

// standard toolbar styles
#define ATL_SIMPLE_TOOLBAR_STYLE \
	(WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | TBSTYLE_TOOLTIPS)
// toolbar in a rebar pane
#define ATL_SIMPLE_TOOLBAR_PANE_STYLE \
	(WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NORESIZE | CCS_NOPARENTALIGN | TBSTYLE_TOOLTIPS | TBSTYLE_FLAT)
// standard rebar styles
#if (_WIN32_IE >= 0x0400)
#define ATL_SIMPLE_REBAR_STYLE \
	(WS_CHILD | WS_VISIBLE | WS_BORDER | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | RBS_VARHEIGHT | RBS_BANDBORDERS | RBS_AUTOSIZE)
#else
#define ATL_SIMPLE_REBAR_STYLE \
	(WS_CHILD | WS_VISIBLE | WS_BORDER | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | RBS_VARHEIGHT | RBS_BANDBORDERS)
#endif //!(_WIN32_IE >= 0x0400)
// rebar without borders
#if (_WIN32_IE >= 0x0400)
#define ATL_SIMPLE_REBAR_NOBORDER_STYLE \
	(WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | RBS_VARHEIGHT | RBS_BANDBORDERS | RBS_AUTOSIZE | CCS_NODIVIDER)
#else
#define ATL_SIMPLE_REBAR_NOBORDER_STYLE \
	(WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | RBS_VARHEIGHT | RBS_BANDBORDERS | CCS_NODIVIDER)
#endif //!(_WIN32_IE >= 0x0400)

// command bar support
#ifndef __ATLCTRLW_H__

#define CBRM_GETCMDBAR			(WM_USER + 301) // return command bar HWND
#define CBRM_GETMENU			(WM_USER + 302)	// returns loaded or attached menu
#define CBRM_TRACKPOPUPMENU		(WM_USER + 303)	// displays a popup menu

// Menu animation flags
#ifndef TPM_VERPOSANIMATION
#define TPM_VERPOSANIMATION 0x1000L
#endif

struct _AtlFrameWnd_CmdBarPopupMenu
{
	int cbSize;
	HMENU hMenu;
	UINT uFlags;
	int x;
	int y;
	LPTPMPARAMS lptpm;
};

#define CBRPOPUPMENU _AtlFrameWnd_CmdBarPopupMenu

#endif //!__ATLCTRLW_H__


template <class TBase = CWindow, class TWinTraits = CFrameWinTraits>
class ATL_NO_VTABLE CFrameWindowImplBase : public CWindowImplBaseT< TBase, TWinTraits >
{
public:
	DECLARE_FRAME_WND_CLASS(NULL, 0)

// Data members
	HWND m_hWndToolBar;
	HWND m_hWndStatusBar;
	HWND m_hWndClient;

	HACCEL m_hAccel;

	struct _AtlToolBarData
	{
		WORD wVersion;
		WORD wWidth;
		WORD wHeight;
		WORD wItemCount;
		//WORD aItems[wItemCount]

		WORD* items()
			{ return (WORD*)(this+1); }
	};

#if (_WIN32_IE >= 0x0500)
	struct _ChevronMenuInfo
	{
		HMENU hMenu;
		LPNMREBARCHEVRON lpnm;
		bool bCmdBar;
	};
#endif //(_WIN32_IE >= 0x0500)

// Constructor
	CFrameWindowImplBase() : m_hWndToolBar(NULL), m_hWndStatusBar(NULL), m_hWndClient(NULL), m_hAccel(NULL)
	{ }

// Methods
#ifndef _ATL_TMP_IMPL2
	HWND Create(HWND hWndParent, _U_RECT rect, LPCTSTR szWindowName, DWORD dwStyle, DWORD dwExStyle, _U_MENUorID MenuOrID, ATOM atom, LPVOID lpCreateParam)
	{
		ATLASSERT(m_hWnd == NULL);

		if(atom == 0)
			return NULL;

		_Module.AddCreateWndData(&m_thunk.cd, this);

		if(MenuOrID.m_hMenu == NULL && (dwStyle & WS_CHILD))
			MenuOrID.m_hMenu = (HMENU)(UINT_PTR)this;
		if(rect.m_lpRect == NULL)
			rect.m_lpRect = &TBase::rcDefault;

		HWND hWnd = ::CreateWindowEx(dwExStyle, (LPCTSTR)(LONG_PTR)MAKELONG(atom, 0), szWindowName,
			dwStyle, rect.m_lpRect->left, rect.m_lpRect->top, rect.m_lpRect->right - rect.m_lpRect->left,
			rect.m_lpRect->bottom - rect.m_lpRect->top, hWndParent, MenuOrID.m_hMenu,
			_Module.GetModuleInstance(), lpCreateParam);

		ATLASSERT(m_hWnd == hWnd);

		return hWnd;
	}
#endif //!_ATL_TMP_IMPL2

	static HWND CreateSimpleToolBarCtrl(HWND hWndParent, UINT nResourceID, BOOL bInitialSeparator = FALSE, 
			DWORD dwStyle = ATL_SIMPLE_TOOLBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
	{
		HINSTANCE hInst = _Module.GetResourceInstance();
		HRSRC hRsrc = ::FindResource(hInst, MAKEINTRESOURCE(nResourceID), RT_TOOLBAR);
		if (hRsrc == NULL)
			return NULL;

		HGLOBAL hGlobal = ::LoadResource(hInst, hRsrc);
		if (hGlobal == NULL)
			return NULL;

		_AtlToolBarData* pData = (_AtlToolBarData*)::LockResource(hGlobal);
		if (pData == NULL)
			return NULL;
		ATLASSERT(pData->wVersion == 1);

		WORD* pItems = pData->items();
		int nItems = pData->wItemCount + (bInitialSeparator ? 1 : 0);
		TBBUTTON* pTBBtn = (TBBUTTON*)_alloca(nItems * sizeof(TBBUTTON));

		// set initial separator (half width)
		if(bInitialSeparator)
		{
			pTBBtn[0].iBitmap = 4;
			pTBBtn[0].idCommand = 0;
			pTBBtn[0].fsState = 0;
			pTBBtn[0].fsStyle = TBSTYLE_SEP;
			pTBBtn[0].dwData = 0;
			pTBBtn[0].iString = 0;
		}

		int nBmp = 0;
		for(int i = 0, j = bInitialSeparator ? 1 : 0; i < pData->wItemCount; i++, j++)
		{
			if(pItems[i] != 0)
			{
				pTBBtn[j].iBitmap = nBmp++;
				pTBBtn[j].idCommand = pItems[i];
				pTBBtn[j].fsState = TBSTATE_ENABLED;
				pTBBtn[j].fsStyle = TBSTYLE_BUTTON;
				pTBBtn[j].dwData = 0;
				pTBBtn[j].iString = 0;
			}
			else
			{
				pTBBtn[j].iBitmap = 8;
				pTBBtn[j].idCommand = 0;
				pTBBtn[j].fsState = 0;
				pTBBtn[j].fsStyle = TBSTYLE_SEP;
				pTBBtn[j].dwData = 0;
				pTBBtn[j].iString = 0;
			}
		}

		HWND hWnd = ::CreateWindowEx(0, TOOLBARCLASSNAME, NULL, dwStyle, 0,0,100,100,
				hWndParent, (HMENU)LongToHandle(nID), _Module.GetModuleInstance(), NULL);

		::SendMessage(hWnd, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0L);

		TBADDBITMAP tbab;
		tbab.hInst = hInst;
		tbab.nID = nResourceID;
		::SendMessage(hWnd, TB_ADDBITMAP, nBmp, (LPARAM)&tbab);
		::SendMessage(hWnd, TB_ADDBUTTONS, nItems, (LPARAM)pTBBtn);
		::SendMessage(hWnd, TB_SETBITMAPSIZE, 0, MAKELONG(pData->wWidth, pData->wHeight));
		::SendMessage(hWnd, TB_SETBUTTONSIZE, 0, MAKELONG(pData->wWidth + 7, pData->wHeight + 7));

		return hWnd;
	}

	static HWND CreateSimpleReBarCtrl(HWND hWndParent, DWORD dwStyle = ATL_SIMPLE_REBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
	{
		// Ensure style combinations for proper rebar painting
		if(dwStyle & CCS_NODIVIDER && dwStyle & WS_BORDER)
			dwStyle &= ~WS_BORDER;
		else if(!(dwStyle & WS_BORDER) && !(dwStyle & CCS_NODIVIDER))
			dwStyle |= CCS_NODIVIDER;

		// Create rebar window
		HWND hWndReBar = ::CreateWindowEx(0, REBARCLASSNAME, NULL, dwStyle, 0, 0, 100, 100, hWndParent, (HMENU)LongToHandle(nID), _Module.GetModuleInstance(), NULL);
		if(hWndReBar == NULL)
		{
			ATLTRACE2(atlTraceUI, 0, _T("Failed to create rebar.\n"));
			return NULL;
		}

		// Initialize and send the REBARINFO structure
		REBARINFO rbi;
		rbi.cbSize = sizeof(REBARINFO);
		rbi.fMask  = 0;
		if(!::SendMessage(hWndReBar, RB_SETBARINFO, 0, (LPARAM)&rbi))
		{
			ATLTRACE2(atlTraceUI, 0, _T("Failed to initialize rebar.\n"));
			::DestroyWindow(hWndReBar);
			return NULL;
		}

		return hWndReBar;
	}

	BOOL CreateSimpleReBar(DWORD dwStyle = ATL_SIMPLE_REBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
	{
		ATLASSERT(!::IsWindow(m_hWndToolBar));
		m_hWndToolBar = CreateSimpleReBarCtrl(m_hWnd, dwStyle, nID);
		return (m_hWndToolBar != NULL);
	}

	static BOOL AddSimpleReBarBandCtrl(HWND hWndReBar, HWND hWndBand, int nID = 0, LPTSTR lpstrTitle = NULL, BOOL bNewRow = FALSE, int cxWidth = 0, BOOL bFullWidthAlways = FALSE)
	{
		ATLASSERT(::IsWindow(hWndReBar));	// must be already created
#ifdef _DEBUG
		// block - check if this is really a rebar
		{
			TCHAR lpszClassName[sizeof(REBARCLASSNAME)];
			::GetClassName(hWndReBar, lpszClassName, sizeof(REBARCLASSNAME));
			ATLASSERT(lstrcmp(lpszClassName, REBARCLASSNAME) == 0);
		}
#endif //_DEBUG
		ATLASSERT(::IsWindow(hWndBand));	// must be already created

		// Get number of buttons on the toolbar
		int nBtnCount = (int)::SendMessage(hWndBand, TB_BUTTONCOUNT, 0, 0L);

		// Set band info structure
		REBARBANDINFO rbBand;
		rbBand.cbSize = sizeof(REBARBANDINFO);
#if (_WIN32_IE >= 0x0400)
		rbBand.fMask = RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_STYLE | RBBIM_ID | RBBIM_SIZE | RBBIM_IDEALSIZE;
#else
		rbBand.fMask = RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_STYLE | RBBIM_ID | RBBIM_SIZE;
#endif //!(_WIN32_IE >= 0x0400)
		if(lpstrTitle != NULL)
			rbBand.fMask |= RBBIM_TEXT;
		rbBand.fStyle = RBBS_CHILDEDGE;
#if (_WIN32_IE >= 0x0500)
		if(nBtnCount > 0)	// add chevron style for toolbar with buttons
			rbBand.fStyle |= RBBS_USECHEVRON;
#endif //(_WIN32_IE >= 0x0500)
		if(bNewRow)
			rbBand.fStyle |= RBBS_BREAK;

		rbBand.lpText = lpstrTitle;
		rbBand.hwndChild = hWndBand;
		if(nID == 0)	// calc band ID
			nID = ATL_IDW_BAND_FIRST + (int)::SendMessage(hWndReBar, RB_GETBANDCOUNT, 0, 0L);
		rbBand.wID = nID;

		// Calculate the size of the band
		BOOL bRet;
		RECT rcTmp;
		if(nBtnCount > 0)
		{
			bRet = (BOOL)::SendMessage(hWndBand, TB_GETITEMRECT, nBtnCount - 1, (LPARAM)&rcTmp);
			ATLASSERT(bRet);
			rbBand.cx = (cxWidth != 0) ? cxWidth : rcTmp.right;
			rbBand.cyMinChild = rcTmp.bottom - rcTmp.top;
			if(bFullWidthAlways)
			{
				rbBand.cxMinChild = rbBand.cx;
			}
			else if(lpstrTitle == 0)
			{
				bRet = (BOOL)::SendMessage(hWndBand, TB_GETITEMRECT, 0, (LPARAM)&rcTmp);
				ATLASSERT(bRet);
				rbBand.cxMinChild = rcTmp.right;
			}
			else
			{
				rbBand.cxMinChild = 0;
			}
		}
		else	// no buttons, either not a toolbar or really has no buttons
		{
			bRet = ::GetWindowRect(hWndBand, &rcTmp);
			ATLASSERT(bRet);
			rbBand.cx = (cxWidth != 0) ? cxWidth : (rcTmp.right - rcTmp.left);
			rbBand.cxMinChild = (bFullWidthAlways) ? rbBand.cx : 0;
			rbBand.cyMinChild = rcTmp.bottom - rcTmp.top;
		}

#if (_WIN32_IE >= 0x0400)
		rbBand.cxIdeal = rbBand.cx;
#endif //(_WIN32_IE >= 0x0400)

		// Add the band
		LRESULT lRes = ::SendMessage(hWndReBar, RB_INSERTBAND, (WPARAM)-1, (LPARAM)&rbBand);
		if(lRes == 0)
		{
			ATLTRACE2(atlTraceUI, 0, _T("Failed to add a band to the rebar.\n"));
			return FALSE;
		}

#if (_WIN32_IE >= 0x0501)
		::SendMessage(hWndBand, TB_SETEXTENDEDSTYLE, 0, TBSTYLE_EX_HIDECLIPPEDBUTTONS);
#endif //(_WIN32_IE >= 0x0501)

		return TRUE;
	}

	BOOL AddSimpleReBarBand(HWND hWndBand, LPTSTR lpstrTitle = NULL, BOOL bNewRow = FALSE, int cxWidth = 0, BOOL bFullWidthAlways = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWndToolBar));	// must be an existing rebar
		ATLASSERT(::IsWindow(hWndBand));	// must be created
		return AddSimpleReBarBandCtrl(m_hWndToolBar, hWndBand, 0, lpstrTitle, bNewRow, cxWidth, bFullWidthAlways);
	}

#if (_WIN32_IE >= 0x0400)
	void SizeSimpleReBarBands()
	{
		ATLASSERT(::IsWindow(m_hWndToolBar));	// must be an existing rebar

		int nCount = (int)::SendMessage(m_hWndToolBar, RB_GETBANDCOUNT, 0, 0L);

		for(int i = 0; i < nCount; i++)
		{
			REBARBANDINFO rbBand;
			rbBand.cbSize = sizeof(REBARBANDINFO);
			rbBand.fMask = RBBIM_SIZE;
			BOOL bRet = (BOOL)::SendMessage(m_hWndToolBar, RB_GETBANDINFO, i, (LPARAM)&rbBand);
			ATLASSERT(bRet);
			RECT rect = { 0, 0, 0, 0 };
			::SendMessage(m_hWndToolBar, RB_GETBANDBORDERS, i, (LPARAM)&rect);
			rbBand.cx += rect.left + rect.right;
			bRet = (BOOL)::SendMessage(m_hWndToolBar, RB_SETBANDINFO, i, (LPARAM)&rbBand);
			ATLASSERT(bRet);
		}
	}
#endif //(_WIN32_IE >= 0x0400)

	BOOL CreateSimpleStatusBar(LPCTSTR lpstrText, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | SBARS_SIZEGRIP, UINT nID = ATL_IDW_STATUS_BAR)
	{
		ATLASSERT(!::IsWindow(m_hWndStatusBar));
		m_hWndStatusBar = ::CreateStatusWindow(dwStyle, lpstrText, m_hWnd, nID);
		return (m_hWndStatusBar != NULL);
	}

	BOOL CreateSimpleStatusBar(UINT nTextID = ATL_IDS_IDLEMESSAGE, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | SBARS_SIZEGRIP, UINT nID = ATL_IDW_STATUS_BAR)
	{
		TCHAR szText[128];	// max text lentgth is 127 for status bars
		szText[0] = 0;
		::LoadString(_Module.GetResourceInstance(), nTextID, szText, 128);
		return CreateSimpleStatusBar(szText, dwStyle, nID);
	}

	void UpdateLayout(BOOL bResizeBars = TRUE)
	{
		RECT rect;
		GetClientRect(&rect);

		// position bars and offset their dimensions
		UpdateBarsPosition(rect, bResizeBars);

		// resize client window
		if(m_hWndClient != NULL)
			::SetWindowPos(m_hWndClient, NULL, rect.left, rect.top,
				rect.right - rect.left, rect.bottom - rect.top,
				SWP_NOZORDER | SWP_NOACTIVATE);
	}

	void UpdateBarsPosition(RECT& rect, BOOL bResizeBars = TRUE)
	{
		// resize toolbar
		if(m_hWndToolBar != NULL && ((DWORD)::GetWindowLong(m_hWndToolBar, GWL_STYLE) & WS_VISIBLE))
		{
			if(bResizeBars)
				::SendMessage(m_hWndToolBar, WM_SIZE, 0, 0);
			RECT rectTB;
			::GetWindowRect(m_hWndToolBar, &rectTB);
			rect.top += rectTB.bottom - rectTB.top;
		}

		// resize status bar
		if(m_hWndStatusBar != NULL && ((DWORD)::GetWindowLong(m_hWndStatusBar, GWL_STYLE) & WS_VISIBLE))
		{
			if(bResizeBars)
				::SendMessage(m_hWndStatusBar, WM_SIZE, 0, 0);
			RECT rectSB;
			::GetWindowRect(m_hWndStatusBar, &rectSB);
			rect.bottom -= rectSB.bottom - rectSB.top;
		}
	}

	BOOL PreTranslateMessage(MSG* pMsg)
	{
		if(m_hAccel != NULL && ::TranslateAccelerator(m_hWnd, m_hAccel, pMsg))
			return TRUE;
		return FALSE;
	}

	typedef CFrameWindowImplBase< TBase, TWinTraits >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
		MESSAGE_HANDLER(WM_MENUSELECT, OnMenuSelect)
		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
		NOTIFY_CODE_HANDLER(TTN_GETDISPINFOA, OnToolTipTextA)
		NOTIFY_CODE_HANDLER(TTN_GETDISPINFOW, OnToolTipTextW)
	END_MSG_MAP()

	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(m_hWndClient != NULL)	// view will paint itself instead
			return 1;

		bHandled = FALSE;
		return 0;
	}

	LRESULT OnMenuSelect(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		bHandled = FALSE;

		if(m_hWndStatusBar == NULL)
			return 1;

		WORD wFlags = HIWORD(wParam);
		if(wFlags == 0xFFFF && lParam == NULL)	// menu closing
			::SendMessage(m_hWndStatusBar, SB_SIMPLE, FALSE, 0L);
		else
		{
			TCHAR szBuff[256];
			szBuff[0] = 0;
			if(!(wFlags & MF_POPUP))
			{
				WORD wID = LOWORD(wParam);
				// check for special cases
				if(wID >= 0xF000 && wID < 0xF1F0)				// system menu IDs
					wID = (WORD)(((wID - 0xF000) >> 4) + ATL_IDS_SCFIRST);
				else if(wID >= ID_FILE_MRU_FIRST && wID <= ID_FILE_MRU_LAST)	// MRU items
					wID = ATL_IDS_MRU_FILE;
				else if(wID >= ATL_IDM_FIRST_MDICHILD)				// MDI child windows
					wID = ATL_IDS_MDICHILD;

				int nRet = ::LoadString(_Module.GetResourceInstance(), wID, szBuff, 256);
				for(int i = 0; i < nRet; i++)
				{
					if(szBuff[i] == _T('\n'))
					{
						szBuff[i] = 0;
						break;
					}
				}
			}
			::SendMessage(m_hWndStatusBar, SB_SIMPLE, TRUE, 0L);
			::SendMessage(m_hWndStatusBar, SB_SETTEXT, (255 | SBT_NOBORDERS), (LPARAM)szBuff);
		}

		return 1;
	}

	LRESULT OnSetFocus(UINT, WPARAM, LPARAM, BOOL& bHandled)
	{
		if(m_hWndClient != NULL && ::IsWindowVisible(m_hWndClient))
			::SetFocus(m_hWndClient);

		bHandled = FALSE;
		return 1;
	}

	LRESULT OnDestroy(UINT, WPARAM, LPARAM, BOOL& bHandled)
	{
		if((GetStyle() & (WS_CHILD | WS_POPUP)) == 0)
			::PostQuitMessage(1);

		bHandled = FALSE;
		return 1;
	}

	LRESULT OnToolTipTextA(int idCtrl, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		LPNMTTDISPINFOA pDispInfo = (LPNMTTDISPINFOA)pnmh;
		pDispInfo->szText[0] = 0;

		if((idCtrl != 0) && !(pDispInfo->uFlags & TTF_IDISHWND))
		{
			char szBuff[256];
			szBuff[0] = 0;
			int nRet = ::LoadStringA(_Module.GetResourceInstance(), idCtrl, szBuff, 256);
			for(int i = 0; i < nRet; i++)
			{
				if(szBuff[i] == '\n')
				{
					lstrcpynA(pDispInfo->szText, &szBuff[i + 1], sizeof(pDispInfo->szText) / sizeof(pDispInfo->szText[0]));
					break;
				}
			}
#if (_WIN32_IE >= 0x0300)
			if(nRet > 0)	// string was loaded, save it
				pDispInfo->uFlags |= TTF_DI_SETITEM;
#endif //(_WIN32_IE >= 0x0300)
		}

		return 0;
	}

	LRESULT OnToolTipTextW(int idCtrl, LPNMHDR pnmh, BOOL& /*bHandled*/)
	{
		LPNMTTDISPINFOW pDispInfo = (LPNMTTDISPINFOW)pnmh;
		pDispInfo->szText[0] = 0;

		if((idCtrl != 0) && !(pDispInfo->uFlags & TTF_IDISHWND))
		{
			wchar_t szBuff[256];
			szBuff[0] = 0;
			int nRet = ::LoadStringW(_Module.GetResourceInstance(), idCtrl, szBuff, 256);
			for(int i = 0; i < nRet; i++)
			{
				if(szBuff[i] == L'\n')
				{
					lstrcpynW(pDispInfo->szText, &szBuff[i + 1], sizeof(pDispInfo->szText) / sizeof(pDispInfo->szText[0]));
					break;
				}
			}
#if (_WIN32_IE >= 0x0300)
			if(nRet > 0)	// string was loaded, save it
				pDispInfo->uFlags |= TTF_DI_SETITEM;
#endif //(_WIN32_IE >= 0x0300)
		}

		return 0;
	}

#if (_WIN32_IE >= 0x0500)
	bool PrepareChevronMenu(_ChevronMenuInfo& cmi)
	{
		// get rebar and toolbar
		REBARBANDINFO rbbi;
		rbbi.cbSize = sizeof(REBARBANDINFO);
		rbbi.fMask = RBBIM_CHILD;
		BOOL bRet = (BOOL)::SendMessage(cmi.lpnm->hdr.hwndFrom, RB_GETBANDINFO, cmi.lpnm->uBand, (LPARAM)&rbbi);
		ATLASSERT(bRet);

		// assume the band is a toolbar
		CWindow wnd = rbbi.hwndChild;
		int nCount = (int)wnd.SendMessage(TB_BUTTONCOUNT);
		if(nCount <= 0)		// probably not a toolbar
			return false;

		// check if it's a command bar
		CMenuHandle menuCmdBar = (HMENU)wnd.SendMessage(CBRM_GETMENU);
		cmi.bCmdBar = (menuCmdBar.m_hMenu != NULL);

		// build a menu from hidden items
		CMenuHandle menu;
		bRet = menu.CreatePopupMenu();
		ATLASSERT(bRet);
		RECT rcClient;
		bRet = wnd.GetClientRect(&rcClient);
		ATLASSERT(bRet);
		for(int i = 0; i < nCount; i++)
		{
			TBBUTTON tbb;
			bRet = (BOOL)wnd.SendMessage(TB_GETBUTTON, i, (LPARAM)&tbb);
			ATLASSERT(bRet);
			RECT rcButton;
			bRet = (BOOL)wnd.SendMessage(TB_GETITEMRECT, i, (LPARAM)&rcButton);
			ATLASSERT(bRet);
			bool bEnabled = ((tbb.fsState & TBSTATE_ENABLED) != 0);
			if(rcButton.right > rcClient.right)
			{
				if(tbb.fsStyle & BTNS_SEP)
				{
					if(menu.GetMenuItemCount() > 0)
						menu.AppendMenu(MF_SEPARATOR);
				}
				else if(cmi.bCmdBar)
				{
					TCHAR szBuff[100];
					CMenuItemInfo mii;
					mii.fMask = MIIM_TYPE | MIIM_SUBMENU;
					mii.dwTypeData = szBuff;
					mii.cch = sizeof(szBuff) / sizeof(TCHAR);
					bRet = menuCmdBar.GetMenuItemInfo(i, TRUE, &mii);
					ATLASSERT(bRet);
					// Note: CmdBar currently supports only drop-down items
					ATLASSERT(::IsMenu(mii.hSubMenu));
					bRet = menu.AppendMenu(MF_STRING | MF_POPUP | (bEnabled ? MF_ENABLED : MF_GRAYED), (UINT_PTR)mii.hSubMenu, mii.dwTypeData);
					ATLASSERT(bRet);
				}
				else
				{
					// get button's text
					TCHAR szBuff[100];
					LPTSTR lpstrText = szBuff;
					if(wnd.SendMessage(TB_GETBUTTONTEXT, tbb.idCommand, (LPARAM)szBuff) == -1)
					{
						// no text for this button, try a resource string
						lpstrText = _T("?");
						::LoadString(_Module.GetResourceInstance(), tbb.idCommand, szBuff, sizeof(szBuff) / sizeof(TCHAR));
						for(int n = 0; n < lstrlen(szBuff); n++)
						{
							if(szBuff[n] == _T('\n'))
							{
								lpstrText = &szBuff[n + 1];
								break;
							}
						}
					}
					bRet = menu.AppendMenu(MF_STRING | (bEnabled ? MF_ENABLED : MF_GRAYED), tbb.idCommand, lpstrText);
					ATLASSERT(bRet);
				}
			}
		}

		if(menu.GetMenuItemCount() == 0)	// no hidden buttons after all
		{
			menu.DestroyMenu();
			::MessageBeep((UINT)-1);
			return false;
		}

		cmi.hMenu = menu;
		return true;
	}

	void DisplayChevronMenu(_ChevronMenuInfo& cmi)
	{
		// convert chevron rect to screen coordinates
		CWindow wndFrom = cmi.lpnm->hdr.hwndFrom;
		RECT rc = cmi.lpnm->rc;
		wndFrom.ClientToScreen(&rc);
		// set up flags and rect
		UINT uMenuFlags = TPM_LEFTBUTTON | TPM_VERTICAL | TPM_LEFTALIGN | TPM_TOPALIGN | (!AtlIsOldWindows() ? TPM_VERPOSANIMATION : 0);
		TPMPARAMS TPMParams;
		TPMParams.cbSize = sizeof(TPMPARAMS);
		TPMParams.rcExclude = rc;
		// check if this window has a command bar
		HWND hWndCmdBar = (HWND)::SendMessage(m_hWnd, CBRM_GETCMDBAR, 0, 0L);
		if(::IsWindow(hWndCmdBar))
		{
			CBRPOPUPMENU CBRPopupMenu = { sizeof(CBRPOPUPMENU), cmi.hMenu, uMenuFlags, rc.left, rc.bottom, &TPMParams };
			::SendMessage(hWndCmdBar, CBRM_TRACKPOPUPMENU, 0, (LPARAM)&CBRPopupMenu);
		}
		else
		{
			::TrackPopupMenuEx(cmi.hMenu, uMenuFlags, rc.left, rc.bottom, m_hWnd, &TPMParams);
		}
	}

	void CleanupChevronMenu(_ChevronMenuInfo& cmi)
	{
		CMenuHandle menu = cmi.hMenu;
		// if menu is from a command bar, detach submenus so they are not destroyed
		if(cmi.bCmdBar)
		{
			for(int i = menu.GetMenuItemCount() - 1; i >=0; i--)
				menu.RemoveMenu(i, MF_BYPOSITION);
		}
		// destroy menu
		menu.DestroyMenu();
		// convert chevron rect to screen coordinates
		CWindow wndFrom = cmi.lpnm->hdr.hwndFrom;
		RECT rc = cmi.lpnm->rc;
		wndFrom.ClientToScreen(&rc);
		// eat next message if click is on the same button
		MSG msg;
		if(::PeekMessage(&msg, m_hWnd, NULL, NULL, PM_NOREMOVE))
		{
			if(msg.message == WM_LBUTTONDOWN && ::PtInRect(&rc, msg.pt))
				::PeekMessage(&msg, m_hWnd, WM_LBUTTONDOWN, WM_LBUTTONDOWN, PM_REMOVE);
		}
	}
#endif //(_WIN32_IE >= 0x0500)
};


template <class T, class TBase /*= CWindow */, class TWinTraits /*= CFrameWinTraits */ >
class ATL_NO_VTABLE CFrameWindowImpl : public CFrameWindowImplBase< TBase, TWinTraits >
{
public:
	HWND Create(HWND hWndParent = NULL, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
	{
		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);

		dwStyle = T::GetWndStyle(dwStyle);
		dwExStyle = T::GetWndExStyle(dwExStyle);

		if(rect.m_lpRect == NULL)
			rect.m_lpRect = &TBase::rcDefault;

		return CFrameWindowImplBase< TBase, TWinTraits >::Create(hWndParent, rect, szWindowName, dwStyle, dwExStyle, hMenu, atom, lpCreateParam);
	}

	HWND CreateEx(HWND hWndParent = NULL, _U_RECT rect = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0, LPVOID lpCreateParam = NULL)
	{
		TCHAR szWindowName[256];
		szWindowName[0] = 0;
		::LoadString(_Module.GetResourceInstance(), T::GetWndClassInfo().m_uCommonResourceID, szWindowName, 256);

		HMENU hMenu = ::LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));

		T* pT = static_cast<T*>(this);
		HWND hWnd = pT->Create(hWndParent, rect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);

		if(hWnd != NULL)
			m_hAccel = ::LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));

		return hWnd;
	}

	BOOL CreateSimpleToolBar(UINT nResourceID = 0, DWORD dwStyle = ATL_SIMPLE_TOOLBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
	{
		ATLASSERT(!::IsWindow(m_hWndToolBar));
		if(nResourceID == 0)
			nResourceID = T::GetWndClassInfo().m_uCommonResourceID;
		m_hWndToolBar = T::CreateSimpleToolBarCtrl(m_hWnd, nResourceID, TRUE, dwStyle, nID);
		return (m_hWndToolBar != NULL);
	}

// message map and handlers
	typedef CFrameWindowImpl< T, TBase, TWinTraits >	thisClass;
	typedef CFrameWindowImplBase< TBase, TWinTraits >	baseClass;

	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
#ifndef _ATL_NO_REBAR_SUPPORT
#if (_WIN32_IE >= 0x0400)
		NOTIFY_CODE_HANDLER(RBN_AUTOSIZE, OnReBarAutoSize)
#endif //(_WIN32_IE >= 0x0400)
#if (_WIN32_IE >= 0x0500)
		NOTIFY_CODE_HANDLER(RBN_CHEVRONPUSHED, OnChevronPushed)
#endif //(_WIN32_IE >= 0x0500)
#endif //!_ATL_NO_REBAR_SUPPORT
		CHAIN_MSG_MAP(baseClass)
	END_MSG_MAP()

	LRESULT OnSize(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(wParam != SIZE_MINIMIZED)
		{
			T* pT = static_cast<T*>(this);
			pT->UpdateLayout();
		}
		bHandled = FALSE;
		return 1;
	}

#ifndef _ATL_NO_REBAR_SUPPORT
#if (_WIN32_IE >= 0x0400)
	LRESULT OnReBarAutoSize(int /*idCtrl*/, LPNMHDR /*pnmh*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->UpdateLayout(FALSE);
		return 0;
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	LRESULT OnChevronPushed(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		_ChevronMenuInfo cmi = { NULL, (LPNMREBARCHEVRON)pnmh, false };
		if(!pT->PrepareChevronMenu(cmi))
		{
			bHandled = FALSE;
			return 1;
		}
		// display a popup menu with hidden items
		pT->DisplayChevronMenu(cmi);
		// cleanup
		pT->CleanupChevronMenu(cmi);
		return 0;
	}
#endif //(_WIN32_IE >= 0x0500)
#endif //!_ATL_NO_REBAR_SUPPORT
};


/////////////////////////////////////////////////////////////////////////////
// CMDIWindow

class CMDIWindow : public CWindow
{
public:
// Data members
	HWND m_hWndMDIClient;
	HMENU m_hMenu;

// Constructors
	CMDIWindow(HWND hWnd = NULL) : CWindow(hWnd), m_hWndMDIClient(NULL), m_hMenu(NULL) { }

	CMDIWindow& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// Operations
	HWND MDIGetActive(BOOL* lpbMaximized = NULL)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		return (HWND)::SendMessage(m_hWndMDIClient, WM_MDIGETACTIVE, 0, (LPARAM)lpbMaximized);
	}

	void MDIActivate(HWND hWndChildToActivate)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		ATLASSERT(::IsWindow(hWndChildToActivate));
		::SendMessage(m_hWndMDIClient, WM_MDIACTIVATE, (WPARAM)hWndChildToActivate, 0);
	}

	void MDINext(HWND hWndChild, BOOL bPrevious = FALSE)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		ATLASSERT(hWndChild == NULL || ::IsWindow(hWndChild));
		::SendMessage(m_hWndMDIClient, WM_MDINEXT, (WPARAM)hWndChild, (LPARAM)bPrevious);
	}

	void MDIMaximize(HWND hWndChildToMaximize)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		ATLASSERT(::IsWindow(hWndChildToMaximize));
		::SendMessage(m_hWndMDIClient, WM_MDIMAXIMIZE, (WPARAM)hWndChildToMaximize, 0);
	}

	void MDIRestore(HWND hWndChildToRestore)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		ATLASSERT(::IsWindow(hWndChildToRestore));
		::SendMessage(m_hWndMDIClient, WM_MDIRESTORE, (WPARAM)hWndChildToRestore, 0);
	}

	void MDIDestroy(HWND hWndChildToDestroy)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		ATLASSERT(::IsWindow(hWndChildToDestroy));
		::SendMessage(m_hWndMDIClient, WM_MDIDESTROY, (WPARAM)hWndChildToDestroy, 0);
	}

	BOOL MDICascade(UINT uFlags = 0)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		return (BOOL)::SendMessage(m_hWndMDIClient, WM_MDICASCADE, (WPARAM)uFlags, 0);
	}

	BOOL MDITile(UINT uFlags = MDITILE_HORIZONTAL)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		return (BOOL)::SendMessage(m_hWndMDIClient, WM_MDITILE, (WPARAM)uFlags, 0);
	}
	void MDIIconArrange()
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		::SendMessage(m_hWndMDIClient, WM_MDIICONARRANGE, 0, 0);
	}

	HMENU MDISetMenu(HMENU hMenuFrame, HMENU hMenuWindow)
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		return (HMENU)::SendMessage(m_hWndMDIClient, WM_MDISETMENU, (WPARAM)hMenuFrame, (LPARAM)hMenuWindow);
	}

	HMENU MDIRefreshMenu()
	{
		ATLASSERT(::IsWindow(m_hWndMDIClient));
		return (HMENU)::SendMessage(m_hWndMDIClient, WM_MDIREFRESHMENU, 0, 0);
	}

// Additional operations
	static HMENU GetStandardWindowMenu(HMENU hMenu)
	{
		int nCount = ::GetMenuItemCount(hMenu);
		if(nCount == -1)
			return NULL;
		int nLen = ::GetMenuString(hMenu, nCount - 2, NULL, 0, MF_BYPOSITION);
		if(nLen == 0)
			return NULL;
		LPTSTR lpszText = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));
		if(::GetMenuString(hMenu, nCount - 2, lpszText, nLen + 1, MF_BYPOSITION) != nLen)
			return NULL;
		if(lstrcmp(lpszText, _T("&Window")))
			return NULL;
		return ::GetSubMenu(hMenu, nCount - 2);
	}

	void SetMDIFrameMenu()
	{
		HMENU hWindowMenu = GetStandardWindowMenu(m_hMenu);
		MDISetMenu(m_hMenu, hWindowMenu);
		MDIRefreshMenu();
		::DrawMenuBar(GetMDIFrame());
	}

	HWND GetMDIFrame() const
	{
		return ::GetParent(m_hWndMDIClient);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CMDIFrameWindowImpl

// MDI child command chaining macro
#define CHAIN_MDI_CHILD_COMMANDS() \
	if(uMsg == WM_COMMAND) \
	{ \
		HWND hWndChild = MDIGetActive(); \
		if(hWndChild != NULL) \
			::SendMessage(hWndChild, uMsg, wParam, lParam); \
	}


template <class T, class TBase /*= CMDIWindow */, class TWinTraits /*= CFrameWinTraits */ >
class ATL_NO_VTABLE CMDIFrameWindowImpl : public CFrameWindowImplBase<TBase, TWinTraits >
{
public:
	HWND Create(HWND hWndParent = NULL, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
	{
		m_hMenu = hMenu;
		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);

		dwStyle = T::GetWndStyle(dwStyle);
		dwExStyle = T::GetWndExStyle(dwExStyle);

		if(rect.m_lpRect == NULL)
			rect.m_lpRect = &TBase::rcDefault;

		return CFrameWindowImplBase<TBase, TWinTraits >::Create(hWndParent, rect, szWindowName, dwStyle, dwExStyle, hMenu, atom, lpCreateParam);
	}

	HWND CreateEx(HWND hWndParent = NULL, _U_RECT rect = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0, LPVOID lpCreateParam = NULL)
	{
		TCHAR szWindowName[256];
		szWindowName[0] = 0;
		::LoadString(_Module.GetResourceInstance(), T::GetWndClassInfo().m_uCommonResourceID, szWindowName, 256);

		HMENU hMenu = ::LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));

		T* pT = static_cast<T*>(this);
		HWND hWnd = pT->Create(hWndParent, rect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);

		if(hWnd != NULL)
			m_hAccel = ::LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));

		return hWnd;
	}

	BOOL CreateSimpleToolBar(UINT nResourceID = 0, DWORD dwStyle = ATL_SIMPLE_TOOLBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
	{
		ATLASSERT(!::IsWindow(m_hWndToolBar));
		if(nResourceID == 0)
			nResourceID = T::GetWndClassInfo().m_uCommonResourceID;
		m_hWndToolBar = T::CreateSimpleToolBarCtrl(m_hWnd, nResourceID, TRUE, dwStyle, nID);
		return (m_hWndToolBar != NULL);
	}

	virtual WNDPROC GetWindowProc()
	{
		return MDIFrameWindowProc;
	}

	static LRESULT CALLBACK MDIFrameWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		CMDIFrameWindowImpl< T, TBase, TWinTraits >* pThis = (CMDIFrameWindowImpl< T, TBase, TWinTraits >*)hWnd;
		// set a ptr to this message and save the old value
#if defined(_ATL_TMP_IMPL1) || defined(_ATL_TMP_IMPL2)
		_ATL_MSG msg(pThis->m_hWnd, uMsg, wParam, lParam);
		const _ATL_MSG* pOldMsg = pThis->m_pCurrentMsg;
#else
		MSG msg = { pThis->m_hWnd, uMsg, wParam, lParam, 0, { 0, 0 } };
		const MSG* pOldMsg = pThis->m_pCurrentMsg;
#endif
		pThis->m_pCurrentMsg = &msg;
		// pass to the message map to process
		LRESULT lRes;
		BOOL bRet = pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0);
		// restore saved value for the current message
		ATLASSERT(pThis->m_pCurrentMsg == &msg);
		pThis->m_pCurrentMsg = pOldMsg;
		// do the default processing if message was not handled
		if(!bRet)
		{
			if(uMsg != WM_NCDESTROY)
				lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
			else
			{
				// unsubclass, if needed
				LONG_PTR pfnWndProc = ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC);
				lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
				if(pThis->m_pfnSuperWindowProc != ::DefWindowProc && ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC) == pfnWndProc)
					::SetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC, (LONG_PTR)pThis->m_pfnSuperWindowProc);
#ifdef _ATL_TMP_IMPL2
				// mark window as destryed
				pThis->m_dwState |= WINSTATE_DESTROYED;
#else
				// clear out window handle
				HWND hWnd = pThis->m_hWnd;
				pThis->m_hWnd = NULL;
				// clean up after window is destroyed
				pThis->OnFinalMessage(hWnd);
#endif
			}
		}
#ifdef _ATL_TMP_IMPL2
		if(pThis->m_dwState & WINSTATE_DESTROYED && pThis->m_pCurrentMsg == NULL)
		{
			// clear out window handle
			HWND hWnd = pThis->m_hWnd;
			pThis->m_hWnd = NULL;
			pThis->m_dwState &= ~WINSTATE_DESTROYED;
			// clean up after window is destroyed
			pThis->OnFinalMessage(hWnd);
		}
#endif
		return lRes;
	}

	// Overriden to call DefWindowProc which uses DefFrameProc
	LRESULT DefWindowProc()
	{
		const MSG* pMsg = m_pCurrentMsg;
		LRESULT lRes = 0;
		if (pMsg != NULL)
			lRes = DefWindowProc(pMsg->message, pMsg->wParam, pMsg->lParam);
		return lRes;
	}

	LRESULT DefWindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		return ::DefFrameProc(m_hWnd, m_hWndMDIClient, uMsg, wParam, lParam);
	}

	BOOL PreTranslateMessage(MSG* pMsg)
	{
		if(CFrameWindowImplBase<TBase, TWinTraits>::PreTranslateMessage(pMsg))
			return TRUE;
		return ::TranslateMDISysAccel(m_hWndMDIClient, pMsg);
	}

	HWND CreateMDIClient(HMENU hWindowMenu = NULL, UINT nID = ATL_IDW_CLIENT, UINT nFirstChildID = ATL_IDM_FIRST_MDICHILD)
	{
		DWORD dwStyle = WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | MDIS_ALLCHILDSTYLES;
		DWORD dwExStyle = WS_EX_CLIENTEDGE;

		CLIENTCREATESTRUCT ccs;
		ccs.hWindowMenu = hWindowMenu;
		ccs.idFirstChild = nFirstChildID;

		if((GetStyle() & (WS_HSCROLL | WS_VSCROLL)) != 0)
		{
			// parent MDI frame's scroll styles move to the MDICLIENT
			dwStyle |= (GetStyle() & (WS_HSCROLL | WS_VSCROLL));

			// fast way to turn off the scrollbar bits (without a resize)
			ModifyStyle(WS_HSCROLL | WS_VSCROLL, 0, SWP_NOREDRAW | SWP_FRAMECHANGED);
		}

		// Create MDICLIENT window
		m_hWndClient = ::CreateWindowEx(dwExStyle, _T("MDIClient"), NULL,
			dwStyle, 0, 0, 1, 1, m_hWnd, (HMENU)LongToHandle(nID),
			_Module.GetModuleInstance(), (LPVOID)&ccs);
		if (m_hWndClient == NULL)
		{
			ATLTRACE2(atlTraceUI, 0, _T("MDI Frame failed to create MDICLIENT.\n"));
			return NULL;
		}

		// Move it to the top of z-order
		::BringWindowToTop(m_hWndClient);

		// set as MDI client window
		m_hWndMDIClient = m_hWndClient;

		// update to proper size
		T* pT = static_cast<T*>(this);
		pT->UpdateLayout();

		return m_hWndClient;
	}

	typedef CMDIFrameWindowImpl< T, TBase, TWinTraits >	thisClass;
	typedef CFrameWindowImplBase<TBase, TWinTraits >	baseClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
		MESSAGE_HANDLER(WM_MDISETMENU, OnMDISetMenu)
#ifndef _ATL_NO_REBAR_SUPPORT
#if (_WIN32_IE >= 0x0400)
		NOTIFY_CODE_HANDLER(RBN_AUTOSIZE, OnReBarAutoSize)
#endif //(_WIN32_IE >= 0x0400)
#if (_WIN32_IE >= 0x0500)
		NOTIFY_CODE_HANDLER(RBN_CHEVRONPUSHED, OnChevronPushed)
#endif //(_WIN32_IE >= 0x0500)
#endif //!_ATL_NO_REBAR_SUPPORT
		CHAIN_MSG_MAP(baseClass)
	END_MSG_MAP()

	LRESULT OnSize(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		if(wParam != SIZE_MINIMIZED)
		{
			T* pT = static_cast<T*>(this);
			pT->UpdateLayout();
		}
		// message must be handled, otherwise DefFrameProc would resize the client again
		return 0;
	}

	LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		// don't allow CFrameWindowImplBase to handle this one
		return DefWindowProc(uMsg, wParam, lParam);
	}

	LRESULT OnMDISetMenu(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		SetMDIFrameMenu();
		return 0;
	}

#ifndef _ATL_NO_REBAR_SUPPORT
#if (_WIN32_IE >= 0x0400)
	LRESULT OnReBarAutoSize(int /*idCtrl*/, LPNMHDR /*pnmh*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->UpdateLayout(FALSE);
		return 0;
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	LRESULT OnChevronPushed(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		_ChevronMenuInfo cmi = { NULL, (LPNMREBARCHEVRON)pnmh, false };
		if(!pT->PrepareChevronMenu(cmi))
		{
			bHandled = FALSE;
			return 1;
		}
		// display a popup menu with hidden items
		pT->DisplayChevronMenu(cmi);
		// cleanup
		pT->CleanupChevronMenu(cmi);
		return 0;
	}
#endif //(_WIN32_IE >= 0x0500)
#endif //!_ATL_NO_REBAR_SUPPORT
};


/////////////////////////////////////////////////////////////////////////////
// CMDIChildWindowImpl

template <class T, class TBase /*= CMDIWindow */, class TWinTraits /*= CMDIChildWinTraits */ >
class ATL_NO_VTABLE CMDIChildWindowImpl : public CFrameWindowImplBase<TBase, TWinTraits >
{
public:
	HWND Create(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			UINT nMenuID = 0, LPVOID lpCreateParam = NULL)
	{
		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);

		if(nMenuID != 0)
			m_hMenu = ::LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(nMenuID));

		dwStyle = T::GetWndStyle(dwStyle);
		dwExStyle = T::GetWndExStyle(dwExStyle);

		dwExStyle |= WS_EX_MDICHILD;	// force this one
		m_pfnSuperWindowProc = ::DefMDIChildProc;
		m_hWndMDIClient = hWndParent;
		ATLASSERT(::IsWindow(m_hWndMDIClient));

		if(rect.m_lpRect == NULL)
			rect.m_lpRect = &TBase::rcDefault;

		HWND hWnd = CFrameWindowImplBase<TBase, TWinTraits >::Create(hWndParent, rect, szWindowName, dwStyle, dwExStyle, (UINT)0U, atom, lpCreateParam);

		if(hWnd != NULL && ::IsWindowVisible(m_hWnd) && !::IsChild(hWnd, ::GetFocus()))
			::SetFocus(hWnd);

		return hWnd;
	}

	HWND CreateEx(HWND hWndParent, _U_RECT rect = NULL, LPCTSTR lpcstrWindowName = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0, LPVOID lpCreateParam = NULL)
	{
		TCHAR szWindowName[256];
		szWindowName[0] = 0;
		if(lpcstrWindowName == NULL)
		{
			::LoadString(_Module.GetResourceInstance(), T::GetWndClassInfo().m_uCommonResourceID, szWindowName, 256);
			lpcstrWindowName = szWindowName;
		}

		T* pT = static_cast<T*>(this);
		HWND hWnd = pT->Create(hWndParent, rect, lpcstrWindowName, dwStyle, dwExStyle, T::GetWndClassInfo().m_uCommonResourceID, lpCreateParam);

		if(hWnd != NULL)
			m_hAccel = ::LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));

		return hWnd;
	}

	BOOL CreateSimpleToolBar(UINT nResourceID = 0, DWORD dwStyle = ATL_SIMPLE_TOOLBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
	{
		ATLASSERT(!::IsWindow(m_hWndToolBar));
		if(nResourceID == 0)
			nResourceID = T::GetWndClassInfo().m_uCommonResourceID;
		m_hWndToolBar = T::CreateSimpleToolBarCtrl(m_hWnd, nResourceID, TRUE, dwStyle, nID);
		return (m_hWndToolBar != NULL);
	}

	BOOL UpdateClientEdge(LPRECT lpRect = NULL)
	{
		// only adjust for active MDI child window
		HWND hWndChild = MDIGetActive();
		if(hWndChild != NULL && hWndChild != m_hWnd)
			return FALSE;

		// need to adjust the client edge style as max/restore happens
		DWORD dwStyle = ::GetWindowLong(m_hWndMDIClient, GWL_EXSTYLE);
		DWORD dwNewStyle = dwStyle;
		if(hWndChild != NULL && ((GetExStyle() & WS_EX_CLIENTEDGE) == 0) && ((GetStyle() & WS_MAXIMIZE) != 0))
			dwNewStyle &= ~(WS_EX_CLIENTEDGE);
		else
			dwNewStyle |= WS_EX_CLIENTEDGE;

		if(dwStyle != dwNewStyle)
		{
			// SetWindowPos will not move invalid bits
			::RedrawWindow(m_hWndMDIClient, NULL, NULL,
				RDW_INVALIDATE | RDW_ALLCHILDREN);
			// remove/add WS_EX_CLIENTEDGE to MDI client area
			::SetWindowLong(m_hWndMDIClient, GWL_EXSTYLE, dwNewStyle);
			::SetWindowPos(m_hWndMDIClient, NULL, 0, 0, 0, 0,
				SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE |
				SWP_NOZORDER | SWP_NOCOPYBITS);

			// return new client area
			if (lpRect != NULL)
				::GetClientRect(m_hWndMDIClient, lpRect);

			return TRUE;
		}

		return FALSE;
	}

	typedef CMDIChildWindowImpl< T, TBase, TWinTraits >	thisClass;
	typedef CFrameWindowImplBase<TBase, TWinTraits >	baseClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
		MESSAGE_HANDLER(WM_WINDOWPOSCHANGING, OnWindowPosChanging)
		MESSAGE_HANDLER(WM_MENUSELECT, OnMenuSelect)
		MESSAGE_HANDLER(WM_MDIACTIVATE, OnMDIActivate)
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
#ifndef _ATL_NO_REBAR_SUPPORT
#if (_WIN32_IE >= 0x0400)
		NOTIFY_CODE_HANDLER(RBN_AUTOSIZE, OnReBarAutoSize)
#endif //(_WIN32_IE >= 0x0400)
#if (_WIN32_IE >= 0x0500)
		NOTIFY_CODE_HANDLER(RBN_CHEVRONPUSHED, OnChevronPushed)
#endif //(_WIN32_IE >= 0x0500)
#endif //!_ATL_NO_REBAR_SUPPORT
		CHAIN_MSG_MAP(baseClass)
	END_MSG_MAP()

	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		DefWindowProc(uMsg, wParam, lParam);	// needed for MDI children
		if(wParam != SIZE_MINIMIZED)
		{
			T* pT = static_cast<T*>(this);
			pT->UpdateLayout();
		}
		return 0;
	}

	LRESULT OnWindowPosChanging(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		// update MDI client edge and adjust MDI child rect
		LPWINDOWPOS lpWndPos = (LPWINDOWPOS)lParam;

		if(!(lpWndPos->flags & SWP_NOSIZE))
		{
			CWindow wnd(m_hWndMDIClient);
			RECT rectClient;

			if(UpdateClientEdge(&rectClient) && ((GetStyle() & WS_MAXIMIZE) != 0))
			{
				::AdjustWindowRectEx(&rectClient, GetStyle(), FALSE, GetExStyle());
				lpWndPos->x = rectClient.left;
				lpWndPos->y = rectClient.top;
				lpWndPos->cx = rectClient.right - rectClient.left;
				lpWndPos->cy = rectClient.bottom - rectClient.top;
			}
		}

		bHandled = FALSE;
		return 1;
	}

	LRESULT OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		return ::SendMessage(GetMDIFrame(), uMsg, wParam, lParam);
	}

	LRESULT OnMDIActivate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		if((HWND)lParam == m_hWnd && m_hMenu != NULL)
			SetMDIFrameMenu();
		else if((HWND)lParam == NULL)
			::SendMessage(GetMDIFrame(), WM_MDISETMENU, 0, 0);

		bHandled = FALSE;
		return 1;
	}

	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		UpdateClientEdge();
		bHandled = FALSE;
		return 1;
	}

#ifndef _ATL_NO_REBAR_SUPPORT
#if (_WIN32_IE >= 0x0400)
	LRESULT OnReBarAutoSize(int /*idCtrl*/, LPNMHDR /*pnmh*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->UpdateLayout(FALSE);
		return 0;
	}
#endif //(_WIN32_IE >= 0x0400)

#if (_WIN32_IE >= 0x0500)
	LRESULT OnChevronPushed(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		_ChevronMenuInfo cmi = { NULL, (LPNMREBARCHEVRON)pnmh, false };
		if(!pT->PrepareChevronMenu(cmi))
		{
			bHandled = FALSE;
			return 1;
		}
		// display a popup menu with hidden items
		pT->DisplayChevronMenu(cmi);
		// cleanup
		pT->CleanupChevronMenu(cmi);
		return 0;
	}
#endif //(_WIN32_IE >= 0x0500)
#endif //!_ATL_NO_REBAR_SUPPORT
};


/////////////////////////////////////////////////////////////////////////////
// COwnerDraw - MI class for owner-draw support

template <class T>
class COwnerDraw
{
public:
#if !defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)
	BOOL m_bHandledOD;

	BOOL IsMsgHandled() const
	{
		return m_bHandledOD;
	}
	void SetMsgHandled(BOOL bHandled)
	{
		m_bHandledOD = bHandled;
	}
#endif //!defined(_ATL_TMP_IMPL1) && !defined(_ATL_TMP_IMPL2)

// Message map and handlers
	BEGIN_MSG_MAP(COwnerDraw< T >)
		MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
		MESSAGE_HANDLER(WM_MEASUREITEM, OnMeasureItem)
		MESSAGE_HANDLER(WM_COMPAREITEM, OnCompareItem)
		MESSAGE_HANDLER(WM_DELETEITEM, OnDeleteItem)
	ALT_MSG_MAP(1)
		MESSAGE_HANDLER(OCM_DRAWITEM, OnDrawItem)
		MESSAGE_HANDLER(OCM_MEASUREITEM, OnMeasureItem)
		MESSAGE_HANDLER(OCM_COMPAREITEM, OnCompareItem)
		MESSAGE_HANDLER(OCM_DELETEITEM, OnDeleteItem)
	END_MSG_MAP()

	LRESULT OnDrawItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		pT->SetMsgHandled(TRUE);
		pT->DrawItem((LPDRAWITEMSTRUCT)lParam);
		bHandled = pT->IsMsgHandled();
		return (LRESULT)TRUE;
	}
	LRESULT OnMeasureItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		pT->SetMsgHandled(TRUE);
		pT->MeasureItem((LPMEASUREITEMSTRUCT)lParam);
		bHandled = pT->IsMsgHandled();
		return (LRESULT)TRUE;
	}
	LRESULT OnCompareItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		pT->SetMsgHandled(TRUE);
		bHandled = pT->IsMsgHandled();
		return (LRESULT)pT->CompareItem((LPCOMPAREITEMSTRUCT)lParam);
	}
	LRESULT OnDeleteItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		pT->SetMsgHandled(TRUE);
		pT->DeleteItem((LPDELETEITEMSTRUCT)lParam);
		bHandled = pT->IsMsgHandled();
		return (LRESULT)TRUE;
	}

// Overrideables
	void DrawItem(LPDRAWITEMSTRUCT /*lpDrawItemStruct*/)
	{
		// must be implemented
		ATLASSERT(FALSE);
	}
	void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)
	{
		if(lpMeasureItemStruct->CtlType != ODT_MENU)
		{
			// return default height for a system font
			T* pT = static_cast<T*>(this);
			HWND hWnd = pT->GetDlgItem(lpMeasureItemStruct->CtlID);
			CClientDC dc(hWnd);
			TEXTMETRIC tm;
			dc.GetTextMetrics(&tm);

			lpMeasureItemStruct->itemHeight = tm.tmHeight;
		}
		else
			lpMeasureItemStruct->itemHeight = ::GetSystemMetrics(SM_CYMENU);
	}
	int CompareItem(LPCOMPAREITEMSTRUCT /*lpCompareItemStruct*/)
	{
		// all items are equal
		return 0;
	}
	void DeleteItem(LPDELETEITEMSTRUCT /*lpDeleteItemStruct*/)
	{
		// default - nothing
	}
};


/////////////////////////////////////////////////////////////////////////////
// Update UI macros

// these build the Update UI map inside a class definition
#define BEGIN_UPDATE_UI_MAP(thisClass) \
	static const _AtlUpdateUIMap* GetUpdateUIMap() \
	{ \
		static const _AtlUpdateUIMap theMap[] = \
		{

#define UPDATE_ELEMENT(nID, wType) \
			{ nID,  wType },

#define END_UPDATE_UI_MAP() \
			{ (WORD)-1, 0 } \
		}; \
		return theMap; \
	}

///////////////////////////////////////////////////////////////////////////////
// CUpdateUI - manages UI elements updating

class CUpdateUIBase
{
public:
	// constants
	enum
	{
		// UI element type
		UPDUI_MENUPOPUP		= 0x0001,
		UPDUI_MENUBAR		= 0x0002,
		UPDUI_CHILDWINDOW	= 0x0004,
		UPDUI_TOOLBAR		= 0x0008,
		UPDUI_STATUSBAR		= 0x0010,
		// state
		UPDUI_ENABLED		= 0x0000,
		UPDUI_DISABLED		= 0x0100,
		UPDUI_CHECKED		= 0x0200,
		UPDUI_CHECKED2		= 0x0400,
		UPDUI_RADIO		= 0x0800,
		UPDUI_DEFAULT		= 0x1000,
		UPDUI_TEXT		= 0x2000,
	};

	// element data
	struct _AtlUpdateUIElement
	{
		HWND m_hWnd;
		WORD m_wType;
		bool operator==(const _AtlUpdateUIElement& e) const
		{ return (m_hWnd == e.m_hWnd && m_wType == e.m_wType); }
	};

	// map data
	struct _AtlUpdateUIMap
	{
		WORD m_nID;
		WORD m_wType;
	};

	// instance data
	struct _AtlUpdateUIData
	{
		WORD m_wState;
		void* m_lpData;
	};

	CSimpleArray<_AtlUpdateUIElement> m_UIElements;	// elements data
	const _AtlUpdateUIMap* m_pUIMap;		// static UI data
	_AtlUpdateUIData* m_pUIData;			// instance UI data
	WORD m_wDirtyType;				// global dirty flag

	bool m_bBlockAccelerators;


// Constructor, destructor
	CUpdateUIBase() : m_pUIMap(NULL), m_pUIData(NULL), m_wDirtyType(0), m_bBlockAccelerators(false)
	{ }

	~CUpdateUIBase()
	{
		if(m_pUIMap != NULL && m_pUIData != NULL)
		{
			const _AtlUpdateUIMap* pUIMap = m_pUIMap;
			_AtlUpdateUIData* pUIData = m_pUIData;
			while(pUIMap->m_nID != (WORD)-1)
			{
				if(pUIData->m_wState & UPDUI_TEXT)
					free(pUIData->m_lpData);
				pUIMap++;
				pUIData++;
			}
			delete [] m_pUIData;
		}
	}

// Check for disabled commands
	bool UIGetBlockAccelerators() const
	{
		return m_bBlockAccelerators;
	}

	bool UISetBlockAccelerators(bool bBlock)
	{
		bool bOld = m_bBlockAccelerators;
		m_bBlockAccelerators = bBlock;
		return bOld;
	}

// Add elements
	BOOL UIAddMenuBar(HWND hWnd)			// menu bar (main menu)
	{
		if(hWnd == NULL)
			return FALSE;
		_AtlUpdateUIElement e;
		e.m_hWnd = hWnd;
		e.m_wType = UPDUI_MENUBAR;
		return m_UIElements.Add(e);
	}
	BOOL UIAddToolBar(HWND hWnd)			// toolbar
	{
		if(hWnd == NULL)
			return FALSE;
		_AtlUpdateUIElement e;
		e.m_hWnd = hWnd;
		e.m_wType = UPDUI_TOOLBAR;
		return m_UIElements.Add(e);
	}
	BOOL UIAddStatusBar(HWND hWnd)			// status bar
	{
		if(hWnd == NULL)
			return FALSE;
		_AtlUpdateUIElement e;
		e.m_hWnd = hWnd;
		e.m_wType = UPDUI_STATUSBAR;
		return m_UIElements.Add(e);
	}
	BOOL UIAddChildWindowContainer(HWND hWnd)	// child window
	{
		if(hWnd == NULL)
			return FALSE;
		_AtlUpdateUIElement e;
		e.m_hWnd = hWnd;
		e.m_wType = UPDUI_CHILDWINDOW;
		return m_UIElements.Add(e);
	}

// Message map for popup menu updates and accelerator blocking
	BEGIN_MSG_MAP(CUpdateUIBase)
		MESSAGE_HANDLER(WM_INITMENUPOPUP, OnInitMenuPopup)
		MESSAGE_HANDLER(WM_COMMAND, OnCommand)
	END_MSG_MAP()

	LRESULT OnInitMenuPopup(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		bHandled = FALSE;
		HMENU hMenu = (HMENU)wParam;
		if(hMenu == NULL)
			return 1;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return 1;
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		while(pMap->m_nID != (WORD)-1)
		{
			if(pMap->m_wType & UPDUI_MENUPOPUP)
				UIUpdateMenuBarElement(pMap->m_nID, pUIData, hMenu);
			pMap++;
			pUIData++;
		}
		return 0;
	}

	LRESULT OnCommand(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		bHandled = FALSE;
		if(m_bBlockAccelerators && HIWORD(wParam) == 1)	// accelerators only
		{
			int nID = LOWORD(wParam);
			if((UIGetState(nID) & UPDUI_DISABLED) == UPDUI_DISABLED)
			{
				ATLTRACE2(atlTraceUI, 0, _T("CUpdateUIBase::OnCommand - blocked disabled command 0x%4.4X\n"), nID);
				bHandled = TRUE;	// eat the command, UI item is disabled
			}
		}
		return 0;
	}

// methods for setting UI element state
	BOOL UIEnable(int nID, BOOL bEnable, BOOL bForceUpdate = FALSE)
	{
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
		{
			if(nID == (int)pMap->m_nID)
			{
				if(bEnable)
				{
					if(pUIData->m_wState & UPDUI_DISABLED)
					{
						pUIData->m_wState |= pMap->m_wType;
						pUIData->m_wState &= ~UPDUI_DISABLED;
					}
				}
				else
				{
					if(!(pUIData->m_wState & UPDUI_DISABLED))
					{
						pUIData->m_wState |= pMap->m_wType;
						pUIData->m_wState |= UPDUI_DISABLED;
					}
				}

				if(bForceUpdate)
					pUIData->m_wState |= pMap->m_wType;
				if(pUIData->m_wState & pMap->m_wType)
					m_wDirtyType |= pMap->m_wType;

				break;	// found
			}
		}

		return TRUE;
	}

	BOOL UISetCheck(int nID, int nCheck, BOOL bForceUpdate = FALSE)
	{
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
		{
			if(nID == (int)pMap->m_nID)
			{
				switch(nCheck)
				{
				case 0:
					if((pUIData->m_wState & UPDUI_CHECKED) || (pUIData->m_wState & UPDUI_CHECKED2))
					{
						pUIData->m_wState |= pMap->m_wType;
						pUIData->m_wState &= ~(UPDUI_CHECKED | UPDUI_CHECKED2);
					}
					break;
				case 1:
					if(!(pUIData->m_wState & UPDUI_CHECKED))
					{
						pUIData->m_wState |= pMap->m_wType;
						pUIData->m_wState &= ~UPDUI_CHECKED2;
						pUIData->m_wState |= UPDUI_CHECKED;
					}
					break;
				case 2:
					if(!(pUIData->m_wState & UPDUI_CHECKED2))
					{
						pUIData->m_wState |= pMap->m_wType;
						pUIData->m_wState &= ~UPDUI_CHECKED;
						pUIData->m_wState |= UPDUI_CHECKED2;
					}
					break;
				}

				if(bForceUpdate)
					pUIData->m_wState |= pMap->m_wType;
				if(pUIData->m_wState & pMap->m_wType)
					m_wDirtyType |= pMap->m_wType;

				break;	// found
			}
		}

		return TRUE;
	}

	BOOL UISetRadio(int nID, BOOL bRadio, BOOL bForceUpdate = FALSE)
	{
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
		{
			if(nID == (int)pMap->m_nID)
			{
				if(bRadio)
				{
					if(!(pUIData->m_wState & UPDUI_RADIO))
					{
						pUIData->m_wState |= pMap->m_wType;
						pUIData->m_wState |= UPDUI_RADIO;
					}
				}
				else
				{
					if(pUIData->m_wState & UPDUI_RADIO)
					{
						pUIData->m_wState |= pMap->m_wType;
						pUIData->m_wState &= ~UPDUI_RADIO;
					}
				}

				if(bForceUpdate)
					pUIData->m_wState |= pMap->m_wType;
				if(pUIData->m_wState & pMap->m_wType)
					m_wDirtyType |= pMap->m_wType;

				break;	// found
			}
		}

		return TRUE;
	}

	BOOL UISetText(int nID, LPCTSTR lpstrText, BOOL bForceUpdate = FALSE)
	{
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;
		if(lpstrText == NULL)
			lpstrText = _T("");

		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
		{
			if(nID == (int)pMap->m_nID)
			{
				if(pUIData->m_lpData == NULL || lstrcmp((LPTSTR)pUIData->m_lpData, lpstrText))
				{
					int nStrLen = lstrlen(lpstrText);
					free(pUIData->m_lpData);
					pUIData->m_lpData = NULL;
					ATLTRY(pUIData->m_lpData = malloc((nStrLen + 1) * sizeof(TCHAR)));
					if(pUIData->m_lpData == NULL)
					{
						ATLTRACE2(atlTraceUI, 0, _T("UISetText - malloc failed\n"));
						break;
					}
					lstrcpy((LPTSTR)pUIData->m_lpData, lpstrText);
					pUIData->m_wState |= (UPDUI_TEXT | pMap->m_wType);
				}

				if(bForceUpdate)
					pUIData->m_wState |= (UPDUI_TEXT | pMap->m_wType);
				if(pUIData->m_wState | pMap->m_wType)
					m_wDirtyType |= pMap->m_wType;

				break;	// found
			}
		}

		return TRUE;
	}

// methods for complete state set/get
	BOOL UISetState(int nID, DWORD dwState)
	{
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;
		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
		{
			if(nID == (int)pMap->m_nID)
			{		
				pUIData->m_wState |= dwState | pMap->m_wType;
				m_wDirtyType |= pMap->m_wType;
				break;	// found
			}
		}
		return TRUE;
	}
	DWORD UIGetState(int nID)
	{
		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return 0;
		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
		{
			if(nID == (int)pMap->m_nID)
				return pUIData->m_wState;
		}
		return 0;
	}

// methods for updating UI
	BOOL UIUpdateMenuBar(BOOL bForceUpdate = FALSE, BOOL bMainMenu = FALSE)
	{
		if(!(m_wDirtyType & UPDUI_MENUBAR) && !bForceUpdate)
			return TRUE;

		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		while(pMap->m_nID != (WORD)-1)
		{
			for(int i = 0; i < m_UIElements.GetSize(); i++)
			{
				if(m_UIElements[i].m_wType == UPDUI_MENUBAR)
				{
					HMENU hMenu = ::GetMenu(m_UIElements[i].m_hWnd);
					if(hMenu != NULL && (pUIData->m_wState & UPDUI_MENUBAR) && (pMap->m_wType & UPDUI_MENUBAR))
						UIUpdateMenuBarElement(pMap->m_nID, pUIData, hMenu);
				}
				if(bMainMenu)
					::DrawMenuBar(m_UIElements[i].m_hWnd);
			}
			pMap++;
			pUIData->m_wState &= ~UPDUI_MENUBAR;
			if(pUIData->m_wState & UPDUI_TEXT)
			{
				free(pUIData->m_lpData);
				pUIData->m_lpData = NULL;
				pUIData->m_wState &= ~UPDUI_TEXT;
			}
			pUIData++;
		}

		m_wDirtyType &= ~UPDUI_MENUBAR;
		return TRUE;
	}

	BOOL UIUpdateToolBar(BOOL bForceUpdate = FALSE)
	{
		if(!(m_wDirtyType & UPDUI_TOOLBAR) && !bForceUpdate)
			return TRUE;

		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		while(pMap->m_nID != (WORD)-1)
		{
			for(int i = 0; i < m_UIElements.GetSize(); i++)
			{
				if(m_UIElements[i].m_wType == UPDUI_TOOLBAR)
				{
					if((pUIData->m_wState & UPDUI_TOOLBAR) && (pMap->m_wType & UPDUI_TOOLBAR))
						UIUpdateToolBarElement(pMap->m_nID, pUIData, m_UIElements[i].m_hWnd);
				}
			}
			pMap++;
			pUIData->m_wState &= ~UPDUI_TOOLBAR;
			pUIData++;
		}

		m_wDirtyType &= ~UPDUI_TOOLBAR;
		return TRUE;
	}

	BOOL UIUpdateStatusBar(BOOL bForceUpdate = FALSE)
	{
		if(!(m_wDirtyType & UPDUI_STATUSBAR) && !bForceUpdate)
			return TRUE;

		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		while(pMap->m_nID != (WORD)-1)
		{
			for(int i = 0; i < m_UIElements.GetSize(); i++)
			{
				if(m_UIElements[i].m_wType == UPDUI_STATUSBAR)
				{
					if((pUIData->m_wState & UPDUI_STATUSBAR) && (pMap->m_wType & UPDUI_STATUSBAR))
						UIUpdateStatusBarElement(pMap->m_nID, pUIData, m_UIElements[i].m_hWnd);
				}
			}
			pMap++;
			pUIData->m_wState &= ~UPDUI_STATUSBAR;
			if(pUIData->m_wState & UPDUI_TEXT)
			{
				free(pUIData->m_lpData);
				pUIData->m_lpData = NULL;
				pUIData->m_wState &= ~UPDUI_TEXT;
			}
			pUIData++;
		}

		m_wDirtyType &= ~UPDUI_STATUSBAR;
		return TRUE;
	}

	BOOL UIUpdateChildWindows(BOOL bForceUpdate = FALSE)
	{
		if(!(m_wDirtyType & UPDUI_CHILDWINDOW) && !bForceUpdate)
			return TRUE;

		const _AtlUpdateUIMap* pMap = m_pUIMap;
		_AtlUpdateUIData* pUIData = m_pUIData;
		if(pUIData == NULL)
			return FALSE;

		while(pMap->m_nID != (WORD)-1)
		{
			for(int i = 0; i < m_UIElements.GetSize(); i++)
			{
				if(m_UIElements[i].m_wType == UPDUI_CHILDWINDOW)
				{
					if((pUIData->m_wState & UPDUI_CHILDWINDOW) && (pMap->m_wType & UPDUI_CHILDWINDOW))
						UIUpdateChildWindow(pMap->m_nID, pUIData, m_UIElements[i].m_hWnd);
				}
			}
			pMap++;
			pUIData->m_wState &= ~UPDUI_CHILDWINDOW;
			if(pUIData->m_wState & UPDUI_TEXT)
			{
				free(pUIData->m_lpData);
				pUIData->m_lpData = NULL;
				pUIData->m_wState &= ~UPDUI_TEXT;
			}
			pUIData++;
		}

		m_wDirtyType &= ~UPDUI_CHILDWINDOW;
		return TRUE;
	}

// internal element specific methods
	static void UIUpdateMenuBarElement(int nID, _AtlUpdateUIData* pUIData, HMENU hMenu)
	{
		MENUITEMINFO mii;
		memset(&mii, 0, sizeof(MENUITEMINFO));
		mii.cbSize = sizeof(MENUITEMINFO);
		mii.fMask = MIIM_STATE;
		mii.wID = nID;

		if(pUIData->m_wState & UPDUI_DISABLED)
			mii.fState |= MFS_DISABLED | MFS_GRAYED;
		else
			mii.fState |= MFS_ENABLED;

		if(pUIData->m_wState & UPDUI_CHECKED)
			mii.fState |= MFS_CHECKED;
		else
			mii.fState |= MFS_UNCHECKED;

		if(pUIData->m_wState & UPDUI_DEFAULT)
			mii.fState |= MFS_DEFAULT;

		if(pUIData->m_wState & UPDUI_TEXT)
		{
			mii.fMask |= MIIM_TYPE;
			mii.fType = MFT_STRING;
			mii.dwTypeData = (LPTSTR)pUIData->m_lpData;
		}

		::SetMenuItemInfo(hMenu, nID, FALSE, &mii);
	}

	static void UIUpdateToolBarElement(int nID, _AtlUpdateUIData* pUIData, HWND hWndToolBar)
	{
		// Note: only handles enabled/disabled, checked state, and radio (press)
		::SendMessage(hWndToolBar, TB_ENABLEBUTTON, nID, (LPARAM)(pUIData->m_wState & UPDUI_DISABLED) ? FALSE : TRUE);
		::SendMessage(hWndToolBar, TB_CHECKBUTTON, nID, (LPARAM)(pUIData->m_wState & UPDUI_CHECKED) ? TRUE : FALSE);
		::SendMessage(hWndToolBar, TB_INDETERMINATE, nID, (LPARAM)(pUIData->m_wState & UPDUI_CHECKED2) ? TRUE : FALSE);
		::SendMessage(hWndToolBar, TB_PRESSBUTTON, nID, (LPARAM)(pUIData->m_wState & UPDUI_RADIO) ? TRUE : FALSE);
	}

	static void UIUpdateStatusBarElement(int nID, _AtlUpdateUIData* pUIData, HWND hWndStatusBar)
	{
		// Note: only handles text
		if(pUIData->m_wState & UPDUI_TEXT)
			::SendMessage(hWndStatusBar, SB_SETTEXT, nID, (LPARAM)pUIData->m_lpData);
	}

	static void UIUpdateChildWindow(int nID, _AtlUpdateUIData* pUIData, HWND hWnd)
	{
		HWND hChild = ::GetDlgItem(hWnd, nID);

		::EnableWindow(hChild, (pUIData->m_wState & UPDUI_DISABLED) ? FALSE : TRUE);
		// for check and radio, assume that window is a button
		int nCheck = BST_UNCHECKED;
		if(pUIData->m_wState & UPDUI_CHECKED || pUIData->m_wState & UPDUI_RADIO)
			nCheck = BST_CHECKED;
		else if(pUIData->m_wState & UPDUI_CHECKED2)
			nCheck = BST_INDETERMINATE;
		::SendMessage(hChild, BM_SETCHECK, nCheck, 0L);
		if(pUIData->m_wState & UPDUI_DEFAULT)
		{
			DWORD dwRet = (DWORD)::SendMessage(hWnd, DM_GETDEFID, 0, 0L);
			if(HIWORD(dwRet) == DC_HASDEFID)
			{
				HWND hOldDef = ::GetDlgItem(hWnd, (int)(short)LOWORD(dwRet));
				// remove BS_DEFPUSHBUTTON
				::SendMessage(hOldDef, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
			}
			::SendMessage(hWnd, DM_SETDEFID, nID, 0L);
		}
		if(pUIData->m_wState & UPDUI_TEXT)
			::SetWindowText(hChild, (LPTSTR)pUIData->m_lpData);
	}
};

template <class T>
class CUpdateUI : public CUpdateUIBase
{
public:
	CUpdateUI()
	{
		T* pT = static_cast<T*>(this);
		pT;
		const _AtlUpdateUIMap* pMap = pT->GetUpdateUIMap();
		m_pUIMap = pMap;
		ATLASSERT(m_pUIMap != NULL);
		int nCount;
		for(nCount = 1; pMap->m_nID != (WORD)-1; nCount++)
			pMap++;

		// check for duplicates (debug only)
#ifdef _DEBUG
		for(int i = 0; i < nCount; i++)
		{
			for(int j = 0; j < nCount; j++)
			{
				// shouldn't have duplicates in the update UI map
				if(i != j)
					ATLASSERT(m_pUIMap[j].m_nID != m_pUIMap[i].m_nID);
			}
		}
#endif //_DEBUG

		ATLTRY(m_pUIData = new _AtlUpdateUIData[nCount]);
		ATLASSERT(m_pUIData != NULL);

		if(m_pUIData != NULL)
			memset(m_pUIData, 0, sizeof(_AtlUpdateUIData) * nCount);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CDialogResize - provides support for resizing dialog controls
//                 (works for any window that has child controls)

// Put CDialogResize in the list of base classes for a dialog (or even plain window),
// then implement DLGRESIZE map by specifying controls and groups of control
// and using DLSZ_* values to specify how are they supposed to be resized.


// dialog resize map macros
#define BEGIN_DLGRESIZE_MAP(thisClass) \
	static const _AtlDlgResizeMap* GetDlgResizeMap() \
	{ \
		static const _AtlDlgResizeMap theMap[] = \
		{

#define END_DLGRESIZE_MAP() \
			{ -1, 0 }, \
		}; \
		return theMap; \
	}

#define DLGRESIZE_CONTROL(id, flags) \
		{ id, flags },

#define BEGIN_DLGRESIZE_GROUP() \
		{ -1, _DLSZ_BEGIN_GROUP },

#define END_DLGRESIZE_GROUP() \
		{ -1, _DLSZ_END_GROUP },


template <class T>
class CDialogResize
{
public:
// Data declarations and members
	enum
	{
		DLSZ_SIZE_X		= 0x00000001,
		DLSZ_SIZE_Y		= 0x00000002,
		DLSZ_MOVE_X		= 0x00000004,
		DLSZ_MOVE_Y		= 0x00000008,
		DLSZ_REPAINT		= 0x00000010,

		// internal use only
		_DLSZ_BEGIN_GROUP	= 0x00001000,
		_DLSZ_END_GROUP		= 0x00002000,
		_DLSZ_GRIPPER		= 0x00004000
	};

	struct _AtlDlgResizeMap
	{
		int m_nCtlID;
		DWORD m_dwResizeFlags;
	};

	struct _AtlDlgResizeData
	{
		int m_nCtlID;
		DWORD m_dwResizeFlags;
		RECT m_rect;
		int GetGroupCount() const
		{
			return (int)LOBYTE(HIWORD(m_dwResizeFlags));
		}
		void SetGroupCount(int nCount)
		{
			ATLASSERT(nCount > 0 && nCount < 256);
			DWORD dwCount = (DWORD)MAKELONG(0, MAKEWORD(nCount, 0));
			m_dwResizeFlags &= 0xFF00FFFF;
			m_dwResizeFlags |= dwCount;
		}
		bool operator==(const _AtlDlgResizeData& r) const
		{ return (m_nCtlID == r.m_nCtlID && m_dwResizeFlags == r.m_dwResizeFlags); }
	};

	CSimpleArray<_AtlDlgResizeData> m_arrData;
	SIZE m_sizeDialog;
	POINT m_ptMinTrackSize;
	bool m_bGripper;


// Constructor
	CDialogResize() : m_bGripper(false)
	{
		m_sizeDialog.cx = 0;
		m_sizeDialog.cy = 0;
		m_ptMinTrackSize.x = -1;
		m_ptMinTrackSize.y = -1;
	}

// Operations
	void DlgResize_Init(bool bAddGripper = true, bool bUseMinTrackSize = true, DWORD dwForceStyle = WS_THICKFRAME | WS_CLIPCHILDREN)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));

		// Force specified styles (default WS_THICKFRAME | WS_CLIPCHILDREN to enable resizing border and reduce flicker)
		if((pT->GetStyle() & dwForceStyle) != dwForceStyle)
			pT->ModifyStyle(0, dwForceStyle);

		// Cleanup in case of multiple initialization
		// block: first check for the gripper control, destroy it if needed
		{
			CWindow wndGripper = pT->GetDlgItem(ATL_IDW_STATUS_BAR);
			if(wndGripper.IsWindow() && m_arrData.GetSize() > 0 && (m_arrData[0].m_dwResizeFlags & _DLSZ_GRIPPER) != 0)
				wndGripper.DestroyWindow();
		}
		// clear out everything else
		m_arrData.RemoveAll();
		m_sizeDialog.cx = 0;
		m_sizeDialog.cy = 0;
		m_ptMinTrackSize.x = -1;
		m_ptMinTrackSize.y = -1;

		// Get initial dialog client size
		RECT rectDlg;
		pT->GetClientRect(&rectDlg);
		m_sizeDialog.cx = rectDlg.right;
		m_sizeDialog.cy = rectDlg.bottom;

		// Create gripper if requested
		m_bGripper = false;
		if(bAddGripper)
		{
			// shouldn't exist already
			ATLASSERT(!::IsWindow(pT->GetDlgItem(ATL_IDW_STATUS_BAR)));
			if(!::IsWindow(pT->GetDlgItem(ATL_IDW_STATUS_BAR)))
			{
				CWindow wndGripper;
				wndGripper.Create(_T("SCROLLBAR"), pT->m_hWnd, rectDlg, NULL, WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | SBS_SIZEBOX | SBS_SIZEGRIP | SBS_SIZEBOXBOTTOMRIGHTALIGN, 0, ATL_IDW_STATUS_BAR);
				ATLASSERT(wndGripper.IsWindow());
				if(wndGripper.IsWindow())
				{
					m_bGripper = true;
					RECT rectCtl;
					wndGripper.GetWindowRect(&rectCtl);
					pT->ScreenToClient(&rectCtl);
					_AtlDlgResizeData data = { ATL_IDW_STATUS_BAR, DLSZ_MOVE_X | DLSZ_MOVE_Y | DLSZ_REPAINT | _DLSZ_GRIPPER, { rectCtl.left, rectCtl.top, rectCtl.right, rectCtl.bottom } };
					m_arrData.Add(data);
				}
			}
		}

		// Get min track position if requested
		if(bUseMinTrackSize)
		{
			RECT rect;
			pT->GetWindowRect(&rect);
			m_ptMinTrackSize.x = rect.right - rect.left;
			m_ptMinTrackSize.y = rect.bottom - rect.top;
		}

		// Walk the map and initialize data
		const _AtlDlgResizeMap* pMap = pT->GetDlgResizeMap();
		ATLASSERT(pMap != NULL);
		int nGroupStart = -1;
		for(int nCount = 1; !(pMap->m_nCtlID == -1 && pMap->m_dwResizeFlags == 0); nCount++, pMap++)
		{
			if(pMap->m_nCtlID == -1)
			{
				switch(pMap->m_dwResizeFlags)
				{
				case _DLSZ_BEGIN_GROUP:
					ATLASSERT(nGroupStart == -1);
					nGroupStart = m_arrData.GetSize();
					break;
				case _DLSZ_END_GROUP:
					{
						ATLASSERT(nGroupStart != -1);
						int nGroupCount = m_arrData.GetSize() - nGroupStart;
						m_arrData[nGroupStart].SetGroupCount(nGroupCount);
						nGroupStart = -1;
					}
					break;
				default:
					ATLASSERT(FALSE && _T("Invalid DLGRESIZE Map Entry"));
					break;
				}
			}
			else
			{
				// this ID conflicts with the default gripper one
				ATLASSERT(m_bGripper ? (pMap->m_nCtlID != ATL_IDW_STATUS_BAR) : TRUE);

				CWindow ctl = pT->GetDlgItem(pMap->m_nCtlID);
				ATLASSERT(ctl.IsWindow());
				RECT rectCtl;
				ctl.GetWindowRect(&rectCtl);
				pT->ScreenToClient(&rectCtl);

				DWORD dwGroupFlag = (nGroupStart != -1 && m_arrData.GetSize() == nGroupStart) ? _DLSZ_BEGIN_GROUP : 0;
				_AtlDlgResizeData data = { pMap->m_nCtlID, pMap->m_dwResizeFlags | dwGroupFlag, { rectCtl.left, rectCtl.top, rectCtl.right, rectCtl.bottom } };
				m_arrData.Add(data);
			}
		}
		ATLASSERT((nGroupStart == -1) && _T("No End Group Entry in the DLGRESIZE Map"));
	}

	void DlgResize_UpdateLayout(int cxWidth, int cyHeight)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->SetRedraw(FALSE);
		RECT rectGroup = { 0, 0, 0, 0 };
		for(int i = 0; i < m_arrData.GetSize(); i++)
		{
			if((m_arrData[i].m_dwResizeFlags & _DLSZ_BEGIN_GROUP) != 0)	// start of a group
			{
				int nGroupCount = m_arrData[i].GetGroupCount();
				ATLASSERT(nGroupCount > 0 && i + nGroupCount - 1 < m_arrData.GetSize());
				rectGroup = m_arrData[i].m_rect;
				int j;
				for(j = 1; j < nGroupCount; j++)
				{
					rectGroup.left = min(rectGroup.left, m_arrData[i + j].m_rect.left);
					rectGroup.top = min(rectGroup.top, m_arrData[i + j].m_rect.top);
					rectGroup.right = max(rectGroup.right, m_arrData[i + j].m_rect.right);
					rectGroup.bottom = max(rectGroup.bottom, m_arrData[i + j].m_rect.bottom);
				}
				RECT rcThis;
				RECT rcNext;
				for(j = 0; j < nGroupCount; j++)
				{
					int xyStartNext = -1;
					if((j < (nGroupCount - 1)) && ((m_arrData[i + j].m_dwResizeFlags & (DLSZ_SIZE_X | DLSZ_SIZE_Y)) != 0) && ((m_arrData[i + j + 1].m_dwResizeFlags & (DLSZ_SIZE_X | DLSZ_SIZE_Y)) != 0))
					{
						CWindow ctlThis = pT->GetDlgItem(m_arrData[i + j].m_nCtlID);
						ctlThis.GetWindowRect(&rcThis);
						pT->ScreenToClient(&rcThis);
						CWindow ctlNext = pT->GetDlgItem(m_arrData[i + j + 1].m_nCtlID);
						ctlNext.GetWindowRect(&rcNext);
						pT->ScreenToClient(&rcNext);
						if((m_arrData[i + j].m_dwResizeFlags & DLSZ_SIZE_X) == DLSZ_SIZE_X && (m_arrData[i + j + 1].m_dwResizeFlags & DLSZ_SIZE_X) == DLSZ_SIZE_X)
						{
							if(rcNext.left >= rcThis.right)
								xyStartNext = m_arrData[i + j + 1].m_rect.left;
						}
						else if((m_arrData[i + j].m_dwResizeFlags & DLSZ_SIZE_Y) == DLSZ_SIZE_Y && (m_arrData[i + j + 1].m_dwResizeFlags & DLSZ_SIZE_Y) == DLSZ_SIZE_Y)
						{
							if(rcNext.top >= rcThis.bottom)
								xyStartNext = m_arrData[i + j + 1].m_rect.top;
						}
					}
					pT->DlgResize_PositionControl(cxWidth, cyHeight, rectGroup, m_arrData[i + j], true, xyStartNext);
				}
				// increment to skip all group controls
				i += nGroupCount - 1;
			}
			else		// one control entry
			{
				pT->DlgResize_PositionControl(cxWidth, cyHeight, rectGroup, m_arrData[i], false);
			}
		}
		pT->SetRedraw(TRUE);
		pT->RedrawWindow(NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ALLCHILDREN);
	}

// Message map and handlers
	BEGIN_MSG_MAP(CDialogResize)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
		MESSAGE_HANDLER(WM_GETMINMAXINFO, OnGetMinMaxInfo)
	END_MSG_MAP()

	LRESULT OnSize(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		if(m_bGripper)
		{
			CWindow wndGripper = pT->GetDlgItem(ATL_IDW_STATUS_BAR);
			if(wParam == SIZE_MAXIMIZED)
				wndGripper.ShowWindow(SW_HIDE);
			else if(wParam == SIZE_RESTORED)
				wndGripper.ShowWindow(SW_SHOW);
		}
		if(wParam != SIZE_MINIMIZED)
		{
			ATLASSERT(::IsWindow(pT->m_hWnd));
			pT->DlgResize_UpdateLayout(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
		}
		return 0;
	}

	LRESULT OnGetMinMaxInfo(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
	{
		if(m_ptMinTrackSize.x != -1 && m_ptMinTrackSize.y != -1)
		{
			LPMINMAXINFO lpMMI = (LPMINMAXINFO)lParam;
			lpMMI->ptMinTrackSize =  m_ptMinTrackSize;
		}
		return 0;
	}

// Implementation
	bool DlgResize_PositionControl(int cxWidth, int cyHeight, RECT& rectGroup, _AtlDlgResizeData& data, bool bGroup, int xyStartNext = -1)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		CWindow ctl;
		RECT rectCtl;

		ctl = pT->GetDlgItem(data.m_nCtlID);
		if(!ctl.GetWindowRect(&rectCtl))
			return false;
		if(!pT->ScreenToClient(&rectCtl))
			return false;

		if(bGroup)
		{
			if((data.m_dwResizeFlags & (DLSZ_SIZE_X | DLSZ_MOVE_X)) != 0)
			{
				rectCtl.left = rectGroup.left + ::MulDiv(data.m_rect.left - rectGroup.left, rectGroup.right - rectGroup.left + (cxWidth - m_sizeDialog.cx), rectGroup.right - rectGroup.left);

				if((data.m_dwResizeFlags & DLSZ_SIZE_X) != 0)
				{
					if(xyStartNext != -1)
						rectCtl.right = rectGroup.left + ::MulDiv(xyStartNext - rectGroup.left, rectGroup.right - rectGroup.left + (cxWidth - m_sizeDialog.cx), rectGroup.right - rectGroup.left) - (xyStartNext - data.m_rect.right);
					else
						rectCtl.right = rectGroup.left + ::MulDiv(data.m_rect.right - rectGroup.left, rectGroup.right - rectGroup.left + (cxWidth - m_sizeDialog.cx), rectGroup.right - rectGroup.left);
				}
				else
				{
					rectCtl.right = rectCtl.left + (data.m_rect.right - data.m_rect.left);
				}
			}

			if((data.m_dwResizeFlags & (DLSZ_SIZE_Y | DLSZ_MOVE_Y)) != 0)
			{
				rectCtl.top = rectGroup.top + ::MulDiv(data.m_rect.top - rectGroup.top, rectGroup.bottom - rectGroup.top + (cyHeight - m_sizeDialog.cy), rectGroup.bottom - rectGroup.top);

				if((data.m_dwResizeFlags & DLSZ_SIZE_Y) != 0)
				{
					if(xyStartNext != -1)
						rectCtl.bottom = rectGroup.top + ::MulDiv(xyStartNext - rectGroup.top, rectGroup.bottom - rectGroup.top + (cyHeight - m_sizeDialog.cy), rectGroup.bottom - rectGroup.top)  - (xyStartNext - data.m_rect.bottom);
					else
						rectCtl.bottom = rectGroup.top + ::MulDiv(data.m_rect.bottom - rectGroup.top, rectGroup.bottom - rectGroup.top + (cyHeight - m_sizeDialog.cy), rectGroup.bottom - rectGroup.top);
				}
				else
				{
					rectCtl.bottom = rectCtl.top + (data.m_rect.bottom - data.m_rect.top);
				}
			}
		}
		else
		{
			if((data.m_dwResizeFlags & (DLSZ_SIZE_X | DLSZ_MOVE_X)) != 0)
			{
				rectCtl.right = data.m_rect.right + (cxWidth - m_sizeDialog.cx);

				if((data.m_dwResizeFlags & DLSZ_MOVE_X) != 0)
					rectCtl.left = rectCtl.right - (data.m_rect.right - data.m_rect.left);
			}

			if((data.m_dwResizeFlags & (DLSZ_SIZE_Y | DLSZ_MOVE_Y)) != 0)
			{
				rectCtl.bottom = data.m_rect.bottom + (cyHeight - m_sizeDialog.cy);

				if((data.m_dwResizeFlags & DLSZ_MOVE_Y) != 0)
					rectCtl.top = rectCtl.bottom - (data.m_rect.bottom - data.m_rect.top);
			}
		}

		if((data.m_dwResizeFlags & DLSZ_REPAINT) != 0)
			ctl.Invalidate();

		if((data.m_dwResizeFlags & (DLSZ_SIZE_X | DLSZ_SIZE_Y | DLSZ_MOVE_X | DLSZ_MOVE_Y | DLSZ_REPAINT)) != 0)
			ctl.SetWindowPos(NULL, &rectCtl, SWP_NOZORDER | SWP_NOACTIVATE);

		return true;
	}
};


// command bar support
#ifndef __ATLCTRLW_H__
#undef CBRM_GETMENU
#undef CBRM_TRACKPOPUPMENU
#undef CBRM_GETCMDBAR
#undef CBRPOPUPMENU
#endif //!__ATLCTRLW_H__

}; //namespace WTL

#endif // __ATLFRAME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wtl10\atlres.h ===
// WTL Version 3.1
// Copyright (C) 1997-2000 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLRES_H__
#define __ATLRES_H__

#pragma once

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif //APSTUDIO_INVOKED

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif //!WINVER

#include <winresrc.h>

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif //APSTUDIO_INVOKED

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif //IDC_STATIC
#define IDC_STATIC      (-1)

#endif //!_INC_WINDOWS
#endif //RC_INVOKED

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif //APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// ATL resource types

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif //RC_INVOKED

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif //APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard window components

#define ID_SEPARATOR                    0       // special separator value
#define ID_DEFAULT_PANE                 0       // default status bar pane

#ifndef RC_INVOKED  // code only
// standard control bars (IDW = window ID)
#define ATL_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define ATL_IDW_STATUS_BAR              0xE801  // Status bar window
#define ATL_IDW_COMMAND_BAR             0xE802  // Command bar window

// parts of a frame window
#define ATL_IDW_CLIENT                  0xE900
#define ATL_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define ATL_IDW_PANE_LAST               0xE9FF
#define ATL_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define ATL_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define ATL_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define ATL_IDW_PANE_SAVE               0xEA21  // to shift ATL_IDW_PANE_FIRST

// bands for a rebar
#define ATL_IDW_BAND_FIRST		0xEB00
#define ATL_IDW_BAND_LAST		0xEBFF
#endif //!RC_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define ATL_IDM_WINDOW_FIRST            0xE130
#define ATL_IDM_WINDOW_LAST             0xE13F
#define ATL_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151
#define ID_PANE_CLOSE                   0xE152

// Format
#define ID_FORMAT_FONT                  0xE160

// Scroll
#define ID_SCROLL_UP                    0xE170
#define ID_SCROLL_DOWN                  0xE171
#define ID_SCROLL_PAGE_UP               0xE172
#define ID_SCROLL_PAGE_DOWN             0xE173
#define ID_SCROLL_TOP                   0xE174
#define ID_SCROLL_BOTTOM                0xE175
#define ID_SCROLL_LEFT                  0xE176
#define ID_SCROLL_RIGHT                 0xE177
#define ID_SCROLL_PAGE_LEFT             0xE178
#define ID_SCROLL_PAGE_RIGHT            0xE179
#define ID_SCROLL_ALL_LEFT              0xE17A
#define ID_SCROLL_ALL_RIGHT             0xE17B

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// View commands (same number used as IDW used for toolbar and status bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REFRESH			0xE803

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif //IDC_STATIC
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

// idle status bar message
#define ATL_IDS_IDLEMESSAGE             0xE001

#ifndef RC_INVOKED      // code only
#define ATL_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define ATL_IDS_SCSIZE                  0xEF00
#define ATL_IDS_SCMOVE                  0xEF01
#define ATL_IDS_SCMINIMIZE              0xEF02
#define ATL_IDS_SCMAXIMIZE              0xEF03
#define ATL_IDS_SCNEXTWINDOW            0xEF04
#define ATL_IDS_SCPREVWINDOW            0xEF05
#define ATL_IDS_SCCLOSE                 0xEF06
#define ATL_IDS_SCRESTORE               0xEF12
#define ATL_IDS_SCTASKLIST              0xEF13

#define ATL_IDS_MDICHILD                0xEF1F
#define ATL_IDS_MRU_FILE                0xEFDA

/////////////////////////////////////////////////////////////////////////////
// Misc. control IDs

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define ATL_IDC_TAB_CONTROL             0x3020


#endif //__ATLRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wtl10\atlprint.h ===
// WTL Version 3.1
// Copyright (C) 1997-2000 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLPRINT_H__
#define __ATLPRINT_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlprint.h requires atlapp.h to be included first
#endif

#ifndef __ATLWIN_H__
	#error atlprint.h requires atlwin.h to be included first
#endif


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <unsigned int t_nInfo> class CPrinterInfo;
template <bool t_bManaged> class CPrinterT;
template <bool t_bManaged> class CDevModeT;
class CPrinterDC;
class CPrintJobInfo;
class CPrintJob;
class CPrintPreview;
template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CPrintPreviewWindowImpl;
class CPrintPreviewWindow;


/////////////////////////////////////////////////////////////////////////////

template <unsigned int t_nInfo>
class _printer_info
{
public:
	typedef void infotype;
};

template <> class _printer_info<1> {public: typedef PRINTER_INFO_1 infotype;};
template <> class _printer_info<2> {public: typedef PRINTER_INFO_2 infotype;};
template <> class _printer_info<3> {public: typedef PRINTER_INFO_3 infotype;};
template <> class _printer_info<4> {public: typedef PRINTER_INFO_4 infotype;};
template <> class _printer_info<5> {public: typedef PRINTER_INFO_5 infotype;};
template <> class _printer_info<6> {public: typedef PRINTER_INFO_6 infotype;};
template <> class _printer_info<7> {public: typedef PRINTER_INFO_7 infotype;};
// these are not in the old (vc6.0) headers
#ifdef _ATL_USE_NEW_PRINTER_INFO
template <> class _printer_info<8> {public: typedef PRINTER_INFO_8 infotype;};
template <> class _printer_info<9> {public: typedef PRINTER_INFO_9 infotype;};
#endif //_ATL_USE_NEW_PRINTER_INFO

//This class wraps all of the PRINTER_INFO_* structures
//and provided by ::GetPrinter.
template <unsigned int t_nInfo>
class CPrinterInfo
{
public:
// Data members
	_printer_info<t_nInfo>::infotype* m_pi;

// Constructor/destructor
	CPrinterInfo() : m_pi(NULL)
	{ }
	CPrinterInfo(HANDLE hPrinter) : m_pi(NULL)
	{
		GetPrinterInfo(hPrinter);
	}
	~CPrinterInfo()
	{
		Cleanup();
	}

// Operations
	bool GetPrinterInfo(HANDLE hPrinter)
	{
		Cleanup();
		return GetPrinterInfoHelper(hPrinter, (BYTE**)&m_pi, t_nInfo);
	}

// Implementation
	void Cleanup()
	{
		delete [] (BYTE*)m_pi;
		m_pi = NULL;
	}
	static bool GetPrinterInfoHelper(HANDLE hPrinter, BYTE** pi, int nIndex)
	{
		ATLASSERT(pi != NULL);
		DWORD dw = 0;
		BYTE* pb = NULL;
		::GetPrinter(hPrinter, nIndex, NULL, 0, &dw);
		if (dw > 0)
		{
			ATLTRY(pb = new BYTE[dw]);
			if (pb != NULL)
			{
				memset(pb, 0, dw);
				DWORD dwNew;
				if (!::GetPrinter(hPrinter, nIndex, pb, dw, &dwNew))
				{
					delete [] pb;
					pb = NULL;
				}
			}
		}
		*pi = pb;
		return (pb != NULL);
	}
};

//Provides a wrapper class for a HANDLE to a printer.
template <bool t_bManaged>
class CPrinterT
{
public:
// Data members
	HANDLE m_hPrinter;

// Constructor/destructor
	CPrinterT(HANDLE hPrinter = NULL) : m_hPrinter(hPrinter)
	{ }

	~CPrinterT()
	{
		ClosePrinter();
	}

// Operations
	CPrinterT& operator=(HANDLE hPrinter)
	{
		if (hPrinter != m_hPrinter)
		{
			ClosePrinter();
			m_hPrinter = hPrinter;
		}
		return *this;
	}

	bool IsNull() const { return (m_hPrinter == NULL); }

	bool OpenPrinter(HANDLE hDevNames, const DEVMODE* pDevMode = NULL)
	{
		bool b = false;
		DEVNAMES* pdn = (DEVNAMES*)::GlobalLock(hDevNames);
		if (pdn != NULL)
		{
			LPTSTR lpszPrinterName = (LPTSTR)pdn + pdn->wDeviceOffset;
			b = OpenPrinter(lpszPrinterName, pDevMode);
			::GlobalUnlock(hDevNames);
		}
		return b;
	}
	bool OpenPrinter(LPCTSTR lpszPrinterName, const DEVMODE* pDevMode = NULL)
	{
		ClosePrinter();
		PRINTER_DEFAULTS pdefs = {NULL, (DEVMODE*)pDevMode, PRINTER_ACCESS_USE};
		::OpenPrinter((LPTSTR) lpszPrinterName, &m_hPrinter, 
			(pDevMode == NULL) ? NULL : &pdefs);

		return (m_hPrinter != NULL);
	}
	bool OpenPrinter(LPCTSTR lpszPrinterName, PRINTER_DEFAULTS* pprintdefs)
	{
		ClosePrinter();
		::OpenPrinter((LPTSTR) lpszPrinterName, &m_hPrinter, pprintdefs);
		return (m_hPrinter != NULL);
	}
	bool OpenDefaultPrinter(const DEVMODE* pDevMode = NULL)
	{
		ClosePrinter();
		TCHAR buffer[512];
		buffer[0] = 0;
		::GetProfileString(_T("windows"), _T("device"), _T(",,,"), buffer, sizeof(buffer));
		int nLen = lstrlen(buffer);
		if (nLen != 0)
		{
			LPTSTR lpsz = buffer;
			while (*lpsz)
			{
				if (*lpsz == ',')
				{
					*lpsz = 0;
					break;
				}
				lpsz = CharNext(lpsz);
			}
			PRINTER_DEFAULTS pdefs = {NULL, (DEVMODE*)pDevMode, PRINTER_ACCESS_USE};
			::OpenPrinter(buffer, &m_hPrinter, (pDevMode == NULL) ? NULL : &pdefs);
		}
		return m_hPrinter != NULL;
	}
	void ClosePrinter()
	{
		if (m_hPrinter != NULL)
		{
			if (t_bManaged)
				::ClosePrinter(m_hPrinter);
			m_hPrinter = NULL;
		}
	}

	bool PrinterProperties(HWND hWnd = NULL)
	{
		if (hWnd == NULL)
			hWnd = ::GetActiveWindow();
		return !!::PrinterProperties(hWnd, m_hPrinter);
	}
	HANDLE CopyToHDEVNAMES() const
	{
		HANDLE h = NULL;
		CPrinterInfo<5> pinfon5;
		CPrinterInfo<2> pinfon2;
		LPTSTR lpszPrinterName = NULL;
		//Some printers fail for PRINTER_INFO_5 in some situations
		if (pinfon5.GetPrinterInfo(m_hPrinter))
			lpszPrinterName = pinfon5.m_pi->pPrinterName;
		else if (pinfon2.GetPrinterInfo(m_hPrinter))
			lpszPrinterName = pinfon2.m_pi->pPrinterName;
		if (lpszPrinterName != NULL)
		{
			int nLen = sizeof(DEVNAMES)+ (lstrlen(lpszPrinterName)+1)*sizeof(TCHAR);
			h = GlobalAlloc(GMEM_MOVEABLE, nLen);
			BYTE* pv = (BYTE*)GlobalLock(h);
			DEVNAMES* pdev = (DEVNAMES*)pv;
			if (pv != NULL)
			{
				memset(pv, 0, nLen);
				pdev->wDeviceOffset = sizeof(DEVNAMES)/sizeof(TCHAR);
				pv = pv + sizeof(DEVNAMES); //now points to end
				lstrcpy((LPTSTR)pv, lpszPrinterName);
				GlobalUnlock(h);
			}
		}
		return h;
	}
	HDC CreatePrinterDC(const DEVMODE* pdm = NULL)
	{
		CPrinterInfo<5> pinfo5;
		CPrinterInfo<2> pinfo2;
		HDC hDC = NULL;
		LPTSTR lpszPrinterName = NULL;
		//Some printers fail for PRINTER_INFO_5 in some situations
		if (pinfo5.GetPrinterInfo(m_hPrinter))
			lpszPrinterName = pinfo5.m_pi->pPrinterName;
		else if (pinfo2.GetPrinterInfo(m_hPrinter))
			lpszPrinterName = pinfo2.m_pi->pPrinterName;
		if (lpszPrinterName != NULL)
			hDC = ::CreateDC(NULL, lpszPrinterName, NULL, pdm);
		return hDC;
	}
	HDC CreatePrinterIC(const DEVMODE* pdm = NULL)
	{
		CPrinterInfo<5> pinfo5;
		CPrinterInfo<2> pinfo2;
		HDC hDC = NULL;
		LPTSTR lpszPrinterName = NULL;
		//Some printers fail for PRINTER_INFO_5 in some situations
		if (pinfo5.GetPrinterInfo(m_hPrinter))
			lpszPrinterName = pinfo5.m_pi->pPrinterName;
		else if (pinfo2.GetPrinterInfo(m_hPrinter))
			lpszPrinterName = pinfo2.m_pi->pPrinterName;
		if (lpszPrinterName != NULL)
			hDC = ::CreateIC(NULL, lpszPrinterName, NULL, pdm);
		return hDC;
	}

	void Attach(HANDLE hPrinter)
	{
		ClosePrinter();
		m_hPrinter = hPrinter;
	}

	HANDLE Detach()
	{
		HANDLE hPrinter = m_hPrinter;
		m_hPrinter = NULL;
		return hPrinter;
	}
	operator HANDLE() const {return m_hPrinter;}
};

typedef CPrinterT<false>	CPrinterHandle;
typedef CPrinterT<true> 	CPrinter;


template <bool t_bManaged>
class CDevModeT
{
public:
// Data members
	HANDLE m_hDevMode;
	DEVMODE* m_pDevMode;

// Constructor/destructor
	CDevModeT(HANDLE hDevMode = NULL) : m_hDevMode(hDevMode)
	{
		m_pDevMode = (m_hDevMode != NULL) ? (DEVMODE*)GlobalLock(m_hDevMode) : NULL;
	}
	~CDevModeT()
	{
		Cleanup();
	}

// Operations
	CDevModeT<t_bManaged>& operator=(HANDLE hDevMode)
	{
		Attach(hDevMode);
		return *this;
	}

	void Attach(HANDLE hDevModeNew)
	{
		Cleanup();
		m_hDevMode = hDevModeNew;
		m_pDevMode = (m_hDevMode != NULL) ? (DEVMODE*)GlobalLock(m_hDevMode) : NULL;
	}

	HANDLE Detach()
	{
		if (m_hDevMode != NULL)
			GlobalUnlock(m_hDevMode);
		HANDLE hDevMode = m_hDevMode;
		m_hDevMode = NULL;
		return hDevMode;
	}

	bool IsNull() const { return (m_hDevMode == NULL); }

	bool CopyFromPrinter(HANDLE hPrinter)
	{
		CPrinterInfo<2> pinfo;
		bool b = pinfo.GetPrinterInfo(hPrinter);
		if (b)
		 b = CopyFromDEVMODE(pinfo.m_pi->pDevMode);
		return b;
	}
	bool CopyFromDEVMODE(const DEVMODE* pdm)
	{
		if (pdm == NULL)
			return false;
		int nSize = pdm->dmSize + pdm->dmDriverExtra;
		HANDLE h = GlobalAlloc(GMEM_MOVEABLE, nSize);
		if (h != NULL)
		{
			void* p = GlobalLock(h);
			memcpy(p, pdm, nSize);
			GlobalUnlock(h);
		}
		Attach(h);
		return (h != NULL);
	}
	bool CopyFromHDEVMODE(HANDLE hdm)
	{
		bool b = false;
		if (hdm != NULL)
		{
			DEVMODE* pdm = (DEVMODE*)GlobalLock(hdm);
			b = CopyFromDEVMODE(pdm);
			GlobalUnlock(hdm);
		}
		return b;
	}
	HANDLE CopyToHDEVMODE()
	{
		if ((m_hDevMode == NULL) || (m_pDevMode == NULL))
			return NULL;
		int nSize = m_pDevMode->dmSize + m_pDevMode->dmDriverExtra;
		HANDLE h = GlobalAlloc(GMEM_MOVEABLE, nSize);
		if (h != NULL)
		{
			void* p = GlobalLock(h);
			memcpy(p, m_pDevMode, nSize);
		}
		return h;
	}
	//If this devmode was for another printer, this will create a new devmode
	//based on the existing devmode, but retargeted at the new printer
	bool UpdateForNewPrinter(HANDLE hPrinter)
	{
		LONG nLen = ::DocumentProperties(NULL, hPrinter, NULL, NULL, NULL, 0);
		DEVMODE* pdm = (DEVMODE*) alloca(nLen);
		memset(pdm, 0, nLen);
		LONG l = ::DocumentProperties(NULL, hPrinter, NULL, pdm, m_pDevMode,
			DM_IN_BUFFER|DM_OUT_BUFFER);
		bool b = false;
		if (l == IDOK)
			b = CopyFromDEVMODE(pdm);
		return b;
	}
	bool DocumentProperties(HANDLE hPrinter, HWND hWnd = NULL)
	{
		CPrinterInfo<1> pi;
		pi.GetPrinterInfo(hPrinter);
		if (hWnd == NULL)
			hWnd = ::GetActiveWindow();

		LONG nLen = ::DocumentProperties(hWnd, hPrinter, pi.m_pi->pName, NULL, NULL, 0);
		DEVMODE* pdm = (DEVMODE*) alloca(nLen);
		memset(pdm, 0, nLen);
		LONG l = ::DocumentProperties(hWnd, hPrinter, pi.m_pi->pName, pdm,
			m_pDevMode, DM_IN_BUFFER|DM_OUT_BUFFER|DM_PROMPT);
		bool b = false;
		if (l == IDOK)
			b = CopyFromDEVMODE(pdm);
		return b;
	}
	operator HANDLE() const {return m_hDevMode;}
	operator DEVMODE*() const {return m_pDevMode;}

// Implementation
	void Cleanup()
	{
		if (m_hDevMode != NULL)
		{
			GlobalUnlock(m_hDevMode);
			if(t_bManaged)
				GlobalFree(m_hDevMode);
			m_hDevMode = NULL;
		}
	}
};

typedef CDevModeT<false>	CDevModeHandle;
typedef CDevModeT<true> 	CDevMode;


class CPrinterDC : public CDC
{
public:
// Constructors/destructor
	CPrinterDC()
	{
		CPrinter printer;
		printer.OpenDefaultPrinter();
		Attach(printer.CreatePrinterDC());
		ATLASSERT(m_hDC != NULL);
	}
	CPrinterDC(HANDLE hPrinter, const DEVMODE* pdm = NULL)
	{
		CPrinterHandle p;
		p.Attach(hPrinter);
		Attach(p.CreatePrinterDC(pdm));
		ATLASSERT(m_hDC != NULL);
	}
	~CPrinterDC()
	{
		DeleteDC();
	}
};


//Defines callbacks used by CPrintJob (not a COM interface)
class ATL_NO_VTABLE IPrintJobInfo
{
public:
	virtual void BeginPrintJob(HDC hDC) = 0;				//allocate handles needed, etc
	virtual void EndPrintJob(HDC hDC, bool bAborted) = 0;			// free handles, etc
	virtual void PrePrintPage(UINT nPage, HDC hDC) = 0;
	virtual bool PrintPage(UINT nPage, HDC hDC) = 0;
	virtual void PostPrintPage(UINT nPage, HDC hDC) = 0;
    // If you want per page devmodes, return the DEVMODE* to use for nPage
    // You can optimize by only returning a new DEVMODE* when it is different
    // from the one for nLastPage, otherwise return NULL.
    // When nLastPage==0, the current DEVMODE* will be the default passed to
    // StartPrintJob.
    // Note: During print preview, nLastPage will always be "0".
	virtual DEVMODE* GetNewDevModeForPage(UINT nLastPage, UINT nPage) = 0;
	virtual bool IsValidPage(UINT nPage) = 0;
};


//Provides a default implementatin for IPrintJobInfo
//Typically, MI'd into a document or view class
class ATL_NO_VTABLE CPrintJobInfo : public IPrintJobInfo
{
public:
	virtual void BeginPrintJob(HDC /*hDC*/) //allocate handles needed, etc
	{
	}
	virtual void EndPrintJob(HDC /*hDC*/, bool /*bAborted*/)	// free handles, etc
	{
	}
	virtual void PrePrintPage(UINT /*nPage*/, HDC hDC)
	{
		m_nPJState = ::SaveDC(hDC);
	}
	virtual bool PrintPage(UINT /*nPage*/, HDC /*hDC*/) = 0;
	virtual void PostPrintPage(UINT /*nPage*/, HDC hDC)
	{
		RestoreDC(hDC, m_nPJState);
	}
	virtual DEVMODE* GetNewDevModeForPage(UINT /*nLastPage*/, UINT /*nPage*/)
	{
		return NULL;
	}
	virtual bool IsValidPage(UINT /*nPage*/)
	{
		return true;
	}
private:
	int m_nPJState;
};


//Wraps a set of tasks for a specific printer (StartDoc/EndDoc)
//Handles aborting, background printing
class CPrintJob
{
public:
	CPrinterHandle m_printer;
	IPrintJobInfo* m_pInfo;
	DEVMODE* m_pDefDevMode;
	DOCINFO m_docinfo;
	DWORD m_dwJobID;
	bool m_bCancel;
	bool m_bComplete;
	unsigned long m_nStartPage;
	unsigned long m_nEndPage;
	CPrintJob()
	{
		m_dwJobID = 0;
		m_bCancel = false;
		m_bComplete = true;
	}
	~CPrintJob()
	{
		ATLASSERT(IsJobComplete()); //premature destruction?
	}
	bool IsJobComplete() const { return m_bComplete; }
	bool StartPrintJob(bool bBackground, HANDLE hPrinter, DEVMODE* pDefaultDevMode,
		IPrintJobInfo* pInfo, LPCTSTR lpszDocName, 
		unsigned long nStartPage, unsigned long nEndPage)
	{
		ATLASSERT(m_bComplete); //previous job not done yet?
		if (pInfo == NULL)
			return false;
		memset(&m_docinfo, 0, sizeof(m_docinfo));
		m_docinfo.cbSize = sizeof(m_docinfo);
		m_docinfo.lpszDocName = lpszDocName;
		m_pInfo = pInfo;
		m_nStartPage = nStartPage;
		m_nEndPage = nEndPage;
		m_printer.Attach(hPrinter);
		m_pDefDevMode = pDefaultDevMode;
		m_bComplete = false;
		if (!bBackground)
		{
			m_bComplete = true;
			return StartHelper();
		}

		//Create a thread and return

		DWORD dwThreadID = 0;
		HANDLE hThread = CreateThread(NULL, 0, StartProc, (void*)this, 0, &dwThreadID);
		CloseHandle(hThread);
		return (hThread != NULL);
	}

// Implementation
	static DWORD WINAPI StartProc(void* p)
	{
		CPrintJob* pThis = (CPrintJob*)p;
		pThis->StartHelper();
		pThis->m_bComplete = true;
		return 0;
	}
	bool StartHelper()
	{
		CDC dcPrinter;
		dcPrinter.Attach(m_printer.CreatePrinterDC(m_pDefDevMode));
		if (dcPrinter.IsNull())
			return false;
			
		m_dwJobID = ::StartDoc(dcPrinter, &m_docinfo);
		if (m_dwJobID == 0)
			return false;

		m_pInfo->BeginPrintJob(dcPrinter);

		//print all the pages now
		unsigned long nPage;
		unsigned long nLastPage=0;
		for (nPage = m_nStartPage; nPage <= m_nEndPage; nPage++)
		{
			if (!m_pInfo->IsValidPage(nPage))
				break;
			DEVMODE* pdm = m_pInfo->GetNewDevModeForPage(nLastPage, nPage);
			if (pdm != NULL)
    			dcPrinter.ResetDC(pdm);
			dcPrinter.StartPage();
			m_pInfo->PrePrintPage(nPage, dcPrinter);
			if (!m_pInfo->PrintPage(nPage, dcPrinter))
				m_bCancel = true;
			m_pInfo->PostPrintPage(nPage, dcPrinter);
			dcPrinter.EndPage();
			if (m_bCancel)
				break;
			nLastPage = nPage;
		}

		m_pInfo->EndPrintJob(dcPrinter, m_bCancel);
		if (m_bCancel)
			::AbortDoc(dcPrinter);
		else
			::EndDoc(dcPrinter);
		m_dwJobID = 0;
		return true;
	}
	//Cancels a print job.	Can be called asynchronously.
	bool CancelPrintJob()
	{
		m_bCancel = 1;
	}
};


// Adds print preview support to an existing window
class CPrintPreview
{
public:
// Data members
	IPrintJobInfo* m_pInfo;
	CPrinterHandle m_printer;
	CEnhMetaFile m_meta;
	DEVMODE* m_pDefDevMode;
	DEVMODE* m_pCurDevMode;
	SIZE m_sizeCurPhysOffset;

// Constructor
	CPrintPreview() : m_pInfo(NULL), m_pDefDevMode(NULL), m_pCurDevMode(NULL)
	{
		m_sizeCurPhysOffset.cx = 0;
		m_sizeCurPhysOffset.cy = 0;
	}

// Operations
	void SetPrintPreviewInfo(HANDLE hPrinter, DEVMODE* pDefaultDevMode, IPrintJobInfo* pji)
	{
		m_printer.Attach(hPrinter);
		m_pDefDevMode = pDefaultDevMode;
		m_pInfo = pji;
		m_nCurPage = 0;
		m_pCurDevMode = NULL;
	}
	void SetEnhMetaFile(HENHMETAFILE hEMF)
	{
		m_meta = hEMF;
	}
	void SetPage(int nPage)
	{
		if (!m_pInfo->IsValidPage(nPage))
			return;
		m_nCurPage = nPage;
		m_pCurDevMode = m_pInfo->GetNewDevModeForPage(0, nPage);
		if (m_pCurDevMode == NULL)
			m_pCurDevMode = m_pDefDevMode;
		CDC dcPrinter = m_printer.CreatePrinterDC(m_pCurDevMode);

		int iWidth = dcPrinter.GetDeviceCaps(PHYSICALWIDTH); 
		int iHeight = dcPrinter.GetDeviceCaps(PHYSICALHEIGHT); 
		int nLogx = dcPrinter.GetDeviceCaps(LOGPIXELSX);
		int nLogy = dcPrinter.GetDeviceCaps(LOGPIXELSY);

		RECT rcMM = {0,0, MulDiv(iWidth, 2540, nLogx), MulDiv(iHeight, 2540, nLogy)};

		m_sizeCurPhysOffset.cx = dcPrinter.GetDeviceCaps(PHYSICALOFFSETX);
		m_sizeCurPhysOffset.cy = dcPrinter.GetDeviceCaps(PHYSICALOFFSETY);
		
		CEnhMetaFileDC dcMeta(dcPrinter, &rcMM);
		m_pInfo->PrePrintPage(nPage, dcMeta);
		m_pInfo->PrintPage(nPage, dcMeta);
		m_pInfo->PostPrintPage(nPage, dcMeta);
		m_meta.Attach(dcMeta.Close());
	}
	void GetPageRect(RECT& rc, LPRECT prc)
	{
		int x1 = rc.right-rc.left;
		int y1 = rc.bottom - rc.top;
		if ((x1 < 0) || (y1 < 0))
			return;

		CEnhMetaFileInfo emfinfo(m_meta);
		ENHMETAHEADER* pmh = emfinfo.GetEnhMetaFileHeader();

		//Compute whether we are OK vertically or horizontally
		int x2 = pmh->szlDevice.cx;
		int y2 = pmh->szlDevice.cy;
		int y1p = MulDiv(x1, y2, x2);
		int x1p = MulDiv(y1, x2, y2);
		ATLASSERT( (x1p <= x1) || (y1p <= y1));
		if (x1p <= x1)
		{
			prc->left = rc.left + (x1 - x1p)/2;
			prc->right = prc->left + x1p;
			prc->top = rc.top;
			prc->bottom = rc.bottom;
		}
		else
		{
			prc->left = rc.left;
			prc->right = rc.right;
			prc->top = rc.top + (y1 - y1p)/2;
			prc->bottom = prc->top + y1p;
		}
	}

// Painting helper
	void DoPaint(CDCHandle dc, RECT& rc)
	{
		CEnhMetaFileInfo emfinfo(m_meta);
		ENHMETAHEADER* pmh = emfinfo.GetEnhMetaFileHeader();
		int nOffsetX = MulDiv(m_sizeCurPhysOffset.cx, rc.right-rc.left, pmh->szlDevice.cx);
		int nOffsetY = MulDiv(m_sizeCurPhysOffset.cy, rc.bottom-rc.top, pmh->szlDevice.cy);

		dc.OffsetWindowOrg(-nOffsetX, -nOffsetY);
		dc.PlayMetaFile(m_meta, &rc);
	}

// Implementation - data
	int m_nCurPage;
};

template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class ATL_NO_VTABLE CPrintPreviewWindowImpl : public CWindowImpl<T, TBase, TWinTraits>, public CPrintPreview
{
public:
	DECLARE_WND_CLASS_EX(NULL, CS_VREDRAW | CS_HREDRAW, -1)

	enum { m_cxOffset = 10, m_cyOffset = 10 };

// Constructor
	CPrintPreviewWindowImpl() : m_nMaxPage(0), m_nMinPage(0)
	{ }

// Operations
	void SetPrintPreviewInfo(HANDLE hPrinter, DEVMODE* pDefaultDevMode, 
		IPrintJobInfo* pji, int nMinPage, int nMaxPage)
	{
		CPrintPreview::SetPrintPreviewInfo(hPrinter, pDefaultDevMode, pji);
		m_nMinPage = nMinPage;
		m_nMaxPage = nMaxPage;
	}
	bool NextPage()
	{
		if (m_nCurPage == m_nMaxPage)
			return false;
		SetPage(m_nCurPage + 1);
		Invalidate();
		return true;
	}
	bool PrevPage()
	{
		if (m_nCurPage == m_nMinPage)
			return false;
		if (m_nCurPage == 0)
			return false;
		SetPage(m_nCurPage - 1);
		Invalidate();
		return true;
	}

// Message map and handlers
	BEGIN_MSG_MAP(CPrintPreviewWindowImpl)
		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
		MESSAGE_HANDLER(WM_PAINT, OnPaint)
	END_MSG_MAP()

	LRESULT OnEraseBkgnd(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		return 1;	// no need for the background
	}

	LRESULT OnPaint(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		CPaintDC dc(m_hWnd);
		RECT rcClient;
		GetClientRect(&rcClient);
		RECT rcArea = rcClient;
		::InflateRect(&rcArea, -pT->m_cxOffset, -pT->m_cyOffset);
		if (rcArea.left > rcArea.right)
			rcArea.right = rcArea.left;
		if (rcArea.top > rcArea.bottom)
			rcArea.bottom = rcArea.top;
		RECT rc;
		GetPageRect(rcArea, &rc);
		CRgn rgn1, rgn2;
		rgn1.CreateRectRgnIndirect(&rc);
		rgn2.CreateRectRgnIndirect(&rcClient);
		rgn2.CombineRgn(rgn1, RGN_DIFF);
		dc.SelectClipRgn(rgn2);
		dc.FillRect(&rcClient, (HBRUSH)LongToPtr(COLOR_BTNSHADOW+1));
		dc.SelectClipRgn(NULL);
		dc.FillRect(&rc, (HBRUSH)GetStockObject(WHITE_BRUSH));
		pT->DoPaint(dc.m_hDC, rc);
		return 0;
	}

// Implementation - data
	int m_nMinPage;
	int m_nMaxPage;
};


class CPrintPreviewWindow : public CPrintPreviewWindowImpl<CPrintPreviewWindow>
{
public:
	DECLARE_WND_CLASS_EX(_T("WTL_PrintPreview"), CS_VREDRAW | CS_HREDRAW, -1)
};

}; //namespace WTL

#endif // __ATLPRINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wtl10\atlmisc.h ===
// WTL Version 3.1
// Copyright (C) 1997-2000 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLMISC_H__
#define __ATLMISC_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlmisc.h requires atlapp.h to be included first
#endif


#ifndef _WTL_NO_WTYPES
#define __ATLTYPES_H__
#endif //!_WTL_NO_WTYPES

#ifdef _ATL_TMP_NO_CSTRING
#define _WTL_NO_CSTRING
#endif

#ifndef _WTL_NO_CSTRING
#define __ATLSTR_H__
#if defined(_ATL_USE_CSTRING_FLOAT) && defined(_ATL_MIN_CRT)
	#error Cannot use CString floating point formatting with _ATL_MIN_CRT defined
#endif //defined(_ATL_USE_CSTRING_FLOAT) && defined(_ATL_MIN_CRT)
#ifndef _DEBUG
#include <stdio.h>
#endif //!_DEBUG
#endif //!_WTL_NO_CSTRING


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

#ifndef _WTL_NO_WTYPES
class CSize;
class CPoint;
class CRect;
#endif //!_WTL_NO_WTYPES
#ifndef _WTL_NO_CSTRING
class CString;
#endif //!_WTL_NO_CSTRING
template <class T, int t_cchItemLen> class CRecentDocumentListBase;
class CRecentDocumentList;
class CFindFile;


/////////////////////////////////////////////////////////////////////////////
// CSize - Wrapper for Windows SIZE structure.

#ifndef _WTL_NO_WTYPES

class CSize : public tagSIZE
{
public:
// Constructors
	CSize();
	CSize(int initCX, int initCY);
	CSize(SIZE initSize);
	CSize(POINT initPt);
	CSize(DWORD dwSize);

// Operations
	BOOL operator==(SIZE size) const;
	BOOL operator!=(SIZE size) const;
	void operator+=(SIZE size);
	void operator-=(SIZE size);
	void SetSize(int CX, int CY);

// Operators returning CSize values
	CSize operator+(SIZE size) const;
	CSize operator-(SIZE size) const;
	CSize operator-() const;

// Operators returning CPoint values
	CPoint operator+(POINT point) const;
	CPoint operator-(POINT point) const;

// Operators returning CRect values
	CRect operator+(const RECT* lpRect) const;
	CRect operator-(const RECT* lpRect) const;
};


/////////////////////////////////////////////////////////////////////////////
// CPoint - Wrapper for Windows POINT structure.

class CPoint : public tagPOINT
{
public:
// Constructors
	CPoint();
	CPoint(int initX, int initY);
	CPoint(POINT initPt);
	CPoint(SIZE initSize);
	CPoint(DWORD dwPoint);

// Operations
	void Offset(int xOffset, int yOffset);
	void Offset(POINT point);
	void Offset(SIZE size);
	BOOL operator==(POINT point) const;
	BOOL operator!=(POINT point) const;
	void operator+=(SIZE size);
	void operator-=(SIZE size);
	void operator+=(POINT point);
	void operator-=(POINT point);
	void SetPoint(int X, int Y);

// Operators returning CPoint values
	CPoint operator+(SIZE size) const;
	CPoint operator-(SIZE size) const;
	CPoint operator-() const;
	CPoint operator+(POINT point) const;

// Operators returning CSize values
	CSize operator-(POINT point) const;

// Operators returning CRect values
	CRect operator+(const RECT* lpRect) const;
	CRect operator-(const RECT* lpRect) const;
};


/////////////////////////////////////////////////////////////////////////////
// CRect - Wrapper for Windows RECT structure.

class CRect : public tagRECT
{
public:
// Constructors
	CRect();
	CRect(int l, int t, int r, int b);
	CRect(const RECT& srcRect);
	CRect(LPCRECT lpSrcRect);
	CRect(POINT point, SIZE size);
	CRect(POINT topLeft, POINT bottomRight);

// Attributes (in addition to RECT members)
	int Width() const;
	int Height() const;
	CSize Size() const;
	CPoint& TopLeft();
	CPoint& BottomRight();
	const CPoint& TopLeft() const;
	const CPoint& BottomRight() const;
	CPoint CenterPoint() const;

	// convert between CRect and LPRECT/LPCRECT (no need for &)
	operator LPRECT();
	operator LPCRECT() const;

	BOOL IsRectEmpty() const;
	BOOL IsRectNull() const;
	BOOL PtInRect(POINT point) const;

// Operations
	void SetRect(int x1, int y1, int x2, int y2);
	void SetRect(POINT topLeft, POINT bottomRight);
	void SetRectEmpty();
	void CopyRect(LPCRECT lpSrcRect);
	BOOL EqualRect(LPCRECT lpRect) const;

	void InflateRect(int x, int y);
	void InflateRect(SIZE size);
	void InflateRect(LPCRECT lpRect);
	void InflateRect(int l, int t, int r, int b);
	void DeflateRect(int x, int y);
	void DeflateRect(SIZE size);
	void DeflateRect(LPCRECT lpRect);
	void DeflateRect(int l, int t, int r, int b);

	void OffsetRect(int x, int y);
	void OffsetRect(SIZE size);
	void OffsetRect(POINT point);
	void NormalizeRect();

	// absolute position of rectangle
	void MoveToY(int y);
	void MoveToX(int x);
	void MoveToXY(int x, int y);
	void MoveToXY(POINT point);

	// operations that fill '*this' with result
	BOOL IntersectRect(LPCRECT lpRect1, LPCRECT lpRect2);
	BOOL UnionRect(LPCRECT lpRect1, LPCRECT lpRect2);
	BOOL SubtractRect(LPCRECT lpRectSrc1, LPCRECT lpRectSrc2);

// Additional Operations
	void operator=(const RECT& srcRect);
	BOOL operator==(const RECT& rect) const;
	BOOL operator!=(const RECT& rect) const;
	void operator+=(POINT point);
	void operator+=(SIZE size);
	void operator+=(LPCRECT lpRect);
	void operator-=(POINT point);
	void operator-=(SIZE size);
	void operator-=(LPCRECT lpRect);
	void operator&=(const RECT& rect);
	void operator|=(const RECT& rect);

// Operators returning CRect values
	CRect operator+(POINT point) const;
	CRect operator-(POINT point) const;
	CRect operator+(LPCRECT lpRect) const;
	CRect operator+(SIZE size) const;
	CRect operator-(SIZE size) const;
	CRect operator-(LPCRECT lpRect) const;
	CRect operator&(const RECT& rect2) const;
	CRect operator|(const RECT& rect2) const;
	CRect MulDiv(int nMultiplier, int nDivisor) const;
};


/////////////////////////////////////////////////////////////////////////////
// CSize, CPoint, CRect Implementation

// CSize
inline CSize::CSize()
	{ /* random filled */ }
inline CSize::CSize(int initCX, int initCY)
	{ cx = initCX; cy = initCY; }
inline CSize::CSize(SIZE initSize)
	{ *(SIZE*)this = initSize; }
inline CSize::CSize(POINT initPt)
	{ *(POINT*)this = initPt; }
inline CSize::CSize(DWORD dwSize)
	{
		cx = (short)LOWORD(dwSize);
		cy = (short)HIWORD(dwSize);
	}
inline BOOL CSize::operator==(SIZE size) const
	{ return (cx == size.cx && cy == size.cy); }
inline BOOL CSize::operator!=(SIZE size) const
	{ return (cx != size.cx || cy != size.cy); }
inline void CSize::operator+=(SIZE size)
	{ cx += size.cx; cy += size.cy; }
inline void CSize::operator-=(SIZE size)
	{ cx -= size.cx; cy -= size.cy; }
inline void CSize::SetSize(int CX, int CY)
	{ cx = CX; cy = CY; }	
inline CSize CSize::operator+(SIZE size) const
	{ return CSize(cx + size.cx, cy + size.cy); }
inline CSize CSize::operator-(SIZE size) const
	{ return CSize(cx - size.cx, cy - size.cy); }
inline CSize CSize::operator-() const
	{ return CSize(-cx, -cy); }
inline CPoint CSize::operator+(POINT point) const
	{ return CPoint(cx + point.x, cy + point.y); }
inline CPoint CSize::operator-(POINT point) const
	{ return CPoint(cx - point.x, cy - point.y); }
inline CRect CSize::operator+(const RECT* lpRect) const
	{ return CRect(lpRect) + *this; }
inline CRect CSize::operator-(const RECT* lpRect) const
	{ return CRect(lpRect) - *this; }

// CPoint
inline CPoint::CPoint()
	{ /* random filled */ }
inline CPoint::CPoint(int initX, int initY)
	{ x = initX; y = initY; }
inline CPoint::CPoint(POINT initPt)
	{ *(POINT*)this = initPt; }
inline CPoint::CPoint(SIZE initSize)
	{ *(SIZE*)this = initSize; }
inline CPoint::CPoint(DWORD dwPoint)
	{
		x = (short)LOWORD(dwPoint);
		y = (short)HIWORD(dwPoint);
	}
inline void CPoint::Offset(int xOffset, int yOffset)
	{ x += xOffset; y += yOffset; }
inline void CPoint::Offset(POINT point)
	{ x += point.x; y += point.y; }
inline void CPoint::Offset(SIZE size)
	{ x += size.cx; y += size.cy; }
inline BOOL CPoint::operator==(POINT point) const
	{ return (x == point.x && y == point.y); }
inline BOOL CPoint::operator!=(POINT point) const
	{ return (x != point.x || y != point.y); }
inline void CPoint::operator+=(SIZE size)
	{ x += size.cx; y += size.cy; }
inline void CPoint::operator-=(SIZE size)
	{ x -= size.cx; y -= size.cy; }
inline void CPoint::operator+=(POINT point)
	{ x += point.x; y += point.y; }
inline void CPoint::operator-=(POINT point)
	{ x -= point.x; y -= point.y; }
inline void CPoint::SetPoint(int X, int Y)
	{ x = X; y = Y; }
inline CPoint CPoint::operator+(SIZE size) const
	{ return CPoint(x + size.cx, y + size.cy); }
inline CPoint CPoint::operator-(SIZE size) const
	{ return CPoint(x - size.cx, y - size.cy); }
inline CPoint CPoint::operator-() const
	{ return CPoint(-x, -y); }
inline CPoint CPoint::operator+(POINT point) const
	{ return CPoint(x + point.x, y + point.y); }
inline CSize CPoint::operator-(POINT point) const
	{ return CSize(x - point.x, y - point.y); }
inline CRect CPoint::operator+(const RECT* lpRect) const
	{ return CRect(lpRect) + *this; }
inline CRect CPoint::operator-(const RECT* lpRect) const
	{ return CRect(lpRect) - *this; }

// CRect
inline CRect::CRect()
	{ /* random filled */ }
inline CRect::CRect(int l, int t, int r, int b)
	{ left = l; top = t; right = r; bottom = b; }
inline CRect::CRect(const RECT& srcRect)
	{ ::CopyRect(this, &srcRect); }
inline CRect::CRect(LPCRECT lpSrcRect)
	{ ::CopyRect(this, lpSrcRect); }
inline CRect::CRect(POINT point, SIZE size)
	{ right = (left = point.x) + size.cx; bottom = (top = point.y) + size.cy; }
inline CRect::CRect(POINT topLeft, POINT bottomRight)
	{ left = topLeft.x; top = topLeft.y;
		right = bottomRight.x; bottom = bottomRight.y; }
inline int CRect::Width() const
	{ return right - left; }
inline int CRect::Height() const
	{ return bottom - top; }
inline CSize CRect::Size() const
	{ return CSize(right - left, bottom - top); }
inline CPoint& CRect::TopLeft()
	{ return *((CPoint*)this); }
inline CPoint& CRect::BottomRight()
	{ return *((CPoint*)this + 1); }
inline const CPoint& CRect::TopLeft() const
	{ return *((CPoint*)this); }
inline const CPoint& CRect::BottomRight() const
	{ return *((CPoint*)this + 1); }
inline CPoint CRect::CenterPoint() const
	{ return CPoint((left + right) / 2, (top + bottom) / 2); }
inline CRect::operator LPRECT()
	{ return this; }
inline CRect::operator LPCRECT() const
	{ return this; }
inline BOOL CRect::IsRectEmpty() const
	{ return ::IsRectEmpty(this); }
inline BOOL CRect::IsRectNull() const
	{ return (left == 0 && right == 0 && top == 0 && bottom == 0); }
inline BOOL CRect::PtInRect(POINT point) const
	{ return ::PtInRect(this, point); }
inline void CRect::SetRect(int x1, int y1, int x2, int y2)
	{ ::SetRect(this, x1, y1, x2, y2); }
inline void CRect::SetRect(POINT topLeft, POINT bottomRight)
	{ ::SetRect(this, topLeft.x, topLeft.y, bottomRight.x, bottomRight.y); }
inline void CRect::SetRectEmpty()
	{ ::SetRectEmpty(this); }
inline void CRect::CopyRect(LPCRECT lpSrcRect)
	{ ::CopyRect(this, lpSrcRect); }
inline BOOL CRect::EqualRect(LPCRECT lpRect) const
	{ return ::EqualRect(this, lpRect); }
inline void CRect::InflateRect(int x, int y)
	{ ::InflateRect(this, x, y); }
inline void CRect::InflateRect(SIZE size)
	{ ::InflateRect(this, size.cx, size.cy); }
inline void CRect::DeflateRect(int x, int y)
	{ ::InflateRect(this, -x, -y); }
inline void CRect::DeflateRect(SIZE size)
	{ ::InflateRect(this, -size.cx, -size.cy); }
inline void CRect::OffsetRect(int x, int y)
	{ ::OffsetRect(this, x, y); }
inline void CRect::OffsetRect(POINT point)
	{ ::OffsetRect(this, point.x, point.y); }
inline void CRect::OffsetRect(SIZE size)
	{ ::OffsetRect(this, size.cx, size.cy); }
inline BOOL CRect::IntersectRect(LPCRECT lpRect1, LPCRECT lpRect2)
	{ return ::IntersectRect(this, lpRect1, lpRect2);}
inline BOOL CRect::UnionRect(LPCRECT lpRect1, LPCRECT lpRect2)
	{ return ::UnionRect(this, lpRect1, lpRect2); }
inline void CRect::operator=(const RECT& srcRect)
	{ ::CopyRect(this, &srcRect); }
inline BOOL CRect::operator==(const RECT& rect) const
	{ return ::EqualRect(this, &rect); }
inline BOOL CRect::operator!=(const RECT& rect) const
	{ return !::EqualRect(this, &rect); }
inline void CRect::operator+=(POINT point)
	{ ::OffsetRect(this, point.x, point.y); }
inline void CRect::operator+=(SIZE size)
	{ ::OffsetRect(this, size.cx, size.cy); }
inline void CRect::operator+=(LPCRECT lpRect)
	{ InflateRect(lpRect); }
inline void CRect::operator-=(POINT point)
	{ ::OffsetRect(this, -point.x, -point.y); }
inline void CRect::operator-=(SIZE size)
	{ ::OffsetRect(this, -size.cx, -size.cy); }
inline void CRect::operator-=(LPCRECT lpRect)
	{ DeflateRect(lpRect); }
inline void CRect::operator&=(const RECT& rect)
	{ ::IntersectRect(this, this, &rect); }
inline void CRect::operator|=(const RECT& rect)
	{ ::UnionRect(this, this, &rect); }
inline CRect CRect::operator+(POINT pt) const
	{ CRect rect(*this); ::OffsetRect(&rect, pt.x, pt.y); return rect; }
inline CRect CRect::operator-(POINT pt) const
	{ CRect rect(*this); ::OffsetRect(&rect, -pt.x, -pt.y); return rect; }
inline CRect CRect::operator+(SIZE size) const
	{ CRect rect(*this); ::OffsetRect(&rect, size.cx, size.cy); return rect; }
inline CRect CRect::operator-(SIZE size) const
	{ CRect rect(*this); ::OffsetRect(&rect, -size.cx, -size.cy); return rect; }
inline CRect CRect::operator+(LPCRECT lpRect) const
	{ CRect rect(this); rect.InflateRect(lpRect); return rect; }
inline CRect CRect::operator-(LPCRECT lpRect) const
	{ CRect rect(this); rect.DeflateRect(lpRect); return rect; }
inline CRect CRect::operator&(const RECT& rect2) const
	{ CRect rect; ::IntersectRect(&rect, this, &rect2);
		return rect; }
inline CRect CRect::operator|(const RECT& rect2) const
	{ CRect rect; ::UnionRect(&rect, this, &rect2);
		return rect; }
inline BOOL CRect::SubtractRect(LPCRECT lpRectSrc1, LPCRECT lpRectSrc2)
	{ return ::SubtractRect(this, lpRectSrc1, lpRectSrc2); }

inline void CRect::NormalizeRect()
{
	int nTemp;
	if (left > right)
	{
		nTemp = left;
		left = right;
		right = nTemp;
	}
	if (top > bottom)
	{
		nTemp = top;
		top = bottom;
		bottom = nTemp;
	}
}

inline void CRect::MoveToY(int y)
	{ bottom = Height() + y; top = y; }
inline void CRect::MoveToX(int x)
	{ right = Width() + x; left = x; }
inline void CRect::MoveToXY(int x, int y)
	{ MoveToX(x); MoveToY(y); }
inline void CRect::MoveToXY(POINT pt)
	{ MoveToX(pt.x); MoveToY(pt.y); }

inline void CRect::InflateRect(LPCRECT lpRect)
{
	left -= lpRect->left;
	top -= lpRect->top;
	right += lpRect->right;
	bottom += lpRect->bottom;
}

inline void CRect::InflateRect(int l, int t, int r, int b)
{
	left -= l;
	top -= t;
	right += r;
	bottom += b;
}

inline void CRect::DeflateRect(LPCRECT lpRect)
{
	left += lpRect->left;
	top += lpRect->top;
	right -= lpRect->right;
	bottom -= lpRect->bottom;
}

inline void CRect::DeflateRect(int l, int t, int r, int b)
{
	left += l;
	top += t;
	right -= r;
	bottom -= b;
}

inline CRect CRect::MulDiv(int nMultiplier, int nDivisor) const
{
	return CRect(
		::MulDiv(left, nMultiplier, nDivisor),
		::MulDiv(top, nMultiplier, nDivisor),
		::MulDiv(right, nMultiplier, nDivisor),
		::MulDiv(bottom, nMultiplier, nDivisor));
}

#endif //!_WTL_NO_WTYPES


/////////////////////////////////////////////////////////////////////////////
// CString - String class

#ifndef _WTL_NO_CSTRING

struct CStringData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this + 1); }
};

// Globals

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
_declspec(selectany) int rgInitData[] = { -1, 0, 0, 0 };
_declspec(selectany) CStringData* _atltmpDataNil = (CStringData*)&rgInitData;
_declspec(selectany) LPCTSTR _atltmpPchNil = (LPCTSTR)(((BYTE*)&rgInitData) + sizeof(CStringData));


class CString
{
public:
// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(TCHAR ch, int nRepeat = 1);
	CString(LPCSTR lpsz);
	CString(LPCWSTR lpsz);
	CString(LPCTSTR lpch, int nLength);
	CString(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(int nIndex) const;      // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator=(char ch);
#endif
	const CString& operator=(LPCSTR lpsz);
	const CString& operator=(LPCWSTR lpsz);
	const CString& operator=(const unsigned char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator+=(char ch);
#endif
	const CString& operator+=(LPCTSTR lpsz);

	friend CString __stdcall operator+(const CString& string1, const CString& string2);
	friend CString __stdcall operator+(const CString& string, TCHAR ch);
	friend CString __stdcall operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
	friend CString __stdcall operator+(const CString& string, char ch);
	friend CString __stdcall operator+(char ch, const CString& string);
#endif
	friend CString __stdcall operator+(const CString& string, LPCTSTR lpsz);
	friend CString __stdcall operator+(LPCTSTR lpsz, const CString& string);

	// string comparison
	int Compare(LPCTSTR lpsz) const;         // straight character
	int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(LPCTSTR lpszCharSet) const;
	CString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// advanced manipulation
	// replace occurrences of chOld with chNew
	int Replace(TCHAR chOld, TCHAR chNew);
	// replace occurrences of substring lpszOld with lpszNew;
	// empty lpszNew removes instances of lpszOld
	int Replace(LPCTSTR lpszOld, LPCTSTR lpszNew);
	// remove occurrences of chRemove
	int Remove(TCHAR chRemove);
	// insert character at zero-based index; concatenates
	// if index is past end of string
	int Insert(int nIndex, TCHAR ch);
	// insert substring at zero-based index; concatenates
	// if index is past end of string
	int Insert(int nIndex, LPCTSTR pstr);
	// delete nCount characters starting at zero-based index
	int Delete(int nIndex, int nCount = 1);

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr
	int ReverseFind(TCHAR ch) const;
	int FindOneOf(LPCTSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// Concatentation for non strings
	const CString& Append(int n)
	{
		TCHAR szBuffer[10];
		wsprintf(szBuffer,_T("%d"),n);
		ConcatInPlace(SafeStrlen(szBuffer), szBuffer);
		return *this;
	}

	// simple formatting
	void __cdecl Format(LPCTSTR lpszFormat, ...);
	void __cdecl Format(UINT nFormatID, ...);

	// formatting for localization (uses FormatMessage API)
	BOOL __cdecl FormatMessage(LPCTSTR lpszFormat, ...);
	BOOL __cdecl FormatMessage(UINT nFormatID, ...);

	// Windows support
	BOOL LoadString(UINT nID);          // load from string resource
										// 255 chars max
#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif

#ifndef _ATL_NO_COM
	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;
#endif //!_ATL_NO_COM

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPTSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CString();
	int GetAllocLength() const;

	static BOOL __stdcall _IsValidString(LPCWSTR lpsz, int nLength)
	{
		if(lpsz == NULL)
			return FALSE;
		return !::IsBadStringPtrW(lpsz, nLength);
	}

	static BOOL __stdcall _IsValidString(LPCSTR lpsz, int nLength)
	{
		if(lpsz == NULL)
			return FALSE;
		return !::IsBadStringPtrA(lpsz, nLength);
	}

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	BOOL AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	BOOL ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	BOOL AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);

	static int __stdcall _LoadString(UINT nID, LPTSTR lpszBuf, UINT nMaxBuf)
	{
#ifdef _DEBUG
		// LoadString without annoying warning from the Debug kernel if the
		//  segment containing the string is not present
		if (::FindResource(_Module.GetResourceInstance(), MAKEINTRESOURCE((nID>>4) + 1), RT_STRING) == NULL)
		{
			lpszBuf[0] = '\0';
			return 0; // not found
		}
#endif //_DEBUG
		int nLen = ::LoadString(_Module.GetResourceInstance(), nID, lpszBuf, nMaxBuf);
		if (nLen == 0)
			lpszBuf[0] = '\0';
		return nLen;
	}

	static const CString& __stdcall _GetEmptyString()
	{
		return *(CString*)&_atltmpPchNil;
	}

// CString conversion helpers
	static int __cdecl _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
	{
		if (count == 0 && mbstr != NULL)
			return 0;

		int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1, mbstr, (int)count, NULL, NULL);
		ATLASSERT(mbstr == NULL || result <= (int)count);
		if (result > 0)
			mbstr[result - 1] = 0;
		return result;
	}

	static int __cdecl _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
	{
		if (count == 0 && wcstr != NULL)
			return 0;

		int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1, wcstr, (int)count);
		ATLASSERT(wcstr == NULL || result <= (int)count);
		if (result > 0)
			wcstr[result - 1] = 0;
		return result;
	}

// Helpers to avoid CRT startup code
	static TCHAR* _cstrchr(const TCHAR* p, TCHAR ch)
	{
		//strchr for '\0' should succeed
		while (*p != 0)
		{
			if (*p == ch)
				break;
			p = ::CharNext(p);
		}
		return (TCHAR*)((*p == ch) ? p : NULL);
	}
	static TCHAR* _cstrchr_db(const TCHAR* p, TCHAR ch1, TCHAR ch2)
	{
		const TCHAR* lpsz = NULL;
		while (*p != 0)
		{
			if (*p == ch1 && *(p + 1) == ch2)
			{
				lpsz = p;
				break;
			}
			p = ::CharNext(p);
		}
		return (TCHAR*)lpsz;
	}
	static TCHAR* _cstrrchr(const TCHAR* p, TCHAR ch)
	{
		const TCHAR* lpsz = NULL;
		while (*p != 0)
		{
			if (*p == ch)
				lpsz = p;
			p = ::CharNext(p);
		}
		return (TCHAR*)lpsz;
	}
	static TCHAR* _cstrrev(TCHAR* pStr)
	{
		// Optimize NULL, zero-length, and single-char case.
		if ((pStr == NULL) || (pStr[0] == '\0') || (pStr[1] == '\0'))
			return pStr;

		TCHAR* p = pStr;

		while (p[1] != 0) 
		{
			TCHAR* pNext = ::CharNext(p);
			if(pNext > p + 1)
			{
				char p1 = *(char*)p;
				*(char*)p = *(char*)(p + 1);
				*(char*)(p + 1) = p1;
			}
			p = pNext;
		}

		TCHAR* q = pStr;

		while (q < p)
		{
			TCHAR t = *q;
			*q = *p;
			*p = t;
			q++;
			p--;
		}
		return (TCHAR*)pStr;
	}
	static TCHAR* _cstrstr(const TCHAR* pStr, const TCHAR* pCharSet)
	{
		int nLen = lstrlen(pCharSet);
		if (nLen == 0)
			return (TCHAR*)pStr;

		const TCHAR* pRet = NULL;
		const TCHAR* pCur = pStr;
		while((pStr = _cstrchr(pCur, *pCharSet)) != NULL)
		{
			if(memcmp(pCur, pCharSet, nLen * sizeof(TCHAR)) == 0)
			{
				pRet = pCur;
				break;
			}
			pCur = ::CharNext(pCur);
		}
		return (TCHAR*) pRet;
	}
	static int _cstrspn(const TCHAR* pStr, const TCHAR* pCharSet)
	{
		int nRet = 0;
		TCHAR* p = (TCHAR*)pStr;
		while (*p != 0)
		{
			TCHAR* pNext = ::CharNext(p);
			if(pNext > p + 1)
			{
				if(_cstrchr_db(pCharSet, *p, *(p + 1)) == NULL)
					break;
				nRet += 2;
			}
			else
			{
				if(_cstrchr(pCharSet, *p) == NULL)
					break;
				nRet++;
			}
			p = pNext;
		}
		return nRet;
	}
	static int _cstrcspn(const TCHAR* pStr, const TCHAR* pCharSet)
	{
		int nRet = 0;
		TCHAR* p = (TCHAR*)pStr;
		while (*p != 0)
		{
			TCHAR* pNext = ::CharNext(p);
			if(pNext > p + 1)
			{
				if(_cstrchr_db(pCharSet, *p, *(p + 1)) != NULL)
					break;
				nRet += 2;
			}
			else
			{
				if(_cstrchr(pCharSet, *p) != NULL)
					break;
				nRet++;
			}
			p = pNext;
		}
		return nRet;
	}
	static TCHAR* _cstrpbrk(const TCHAR* p, const TCHAR* lpszCharSet)
	{
		while (*p != 0)
		{
			if (_cstrchr(lpszCharSet, *p) != NULL)
			{
				return (TCHAR*)p;
				break;
			}
			p = ::CharNext(p);
		}
		return NULL;
	}

	static int _cstrisdigit(TCHAR ch)
	{
		WORD type;
		GetStringTypeEx(GetThreadLocale(), CT_CTYPE1, &ch, 1, &type);
		return (type & C1_DIGIT) == C1_DIGIT;
	}

	static int _cstrisspace(TCHAR ch)
	{
		WORD type;
		GetStringTypeEx(GetThreadLocale(), CT_CTYPE1, &ch, 1, &type);
		return (type & C1_SPACE) == C1_SPACE;
	}

	static int _cstrcmp(const TCHAR* pstrOne, const TCHAR* pstrOther)
	{
		return lstrcmp(pstrOne, pstrOther);
	}

	static int _cstrcmpi(const TCHAR* pstrOne, const TCHAR* pstrOther)
	{
		return lstrcmpi(pstrOne, pstrOther);
	}

	static int _cstrcoll(const TCHAR* pstrOne, const TCHAR* pstrOther)
	{
		int nRet = CompareString(GetThreadLocale(), 0, pstrOne, -1, pstrOther, -1);
		ATLASSERT(nRet != 0);
		return nRet - 2;  // Convert to strcmp convention.  This really is documented.
	}

	static int _cstrcolli(const TCHAR* pstrOne, const TCHAR* pstrOther)
	{
		int nRet = CompareString(GetThreadLocale(), NORM_IGNORECASE, pstrOne, -1, pstrOther, -1);
		ATLASSERT(nRet != 0);
		return nRet - 2;  // Convert to strcmp convention.  This really is documented.
	}
};

// Compare helpers
bool __stdcall operator==(const CString& s1, const CString& s2);
bool __stdcall operator==(const CString& s1, LPCTSTR s2);
bool __stdcall operator==(LPCTSTR s1, const CString& s2);
bool __stdcall operator!=(const CString& s1, const CString& s2);
bool __stdcall operator!=(const CString& s1, LPCTSTR s2);
bool __stdcall operator!=(LPCTSTR s1, const CString& s2);
bool __stdcall operator<(const CString& s1, const CString& s2);
bool __stdcall operator<(const CString& s1, LPCTSTR s2);
bool __stdcall operator<(LPCTSTR s1, const CString& s2);
bool __stdcall operator>(const CString& s1, const CString& s2);
bool __stdcall operator>(const CString& s1, LPCTSTR s2);
bool __stdcall operator>(LPCTSTR s1, const CString& s2);
bool __stdcall operator<=(const CString& s1, const CString& s2);
bool __stdcall operator<=(const CString& s1, LPCTSTR s2);
bool __stdcall operator<=(LPCTSTR s1, const CString& s2);
bool __stdcall operator>=(const CString& s1, const CString& s2);
bool __stdcall operator>=(const CString& s1, LPCTSTR s2);
bool __stdcall operator>=(LPCTSTR s1, const CString& s2);


/////////////////////////////////////////////////////////////////////////////
// CString Implementation

inline CStringData* CString::GetData() const
	{ ATLASSERT(m_pchData != NULL); return ((CStringData*)m_pchData) - 1; }
inline void CString::Init()
	{ m_pchData = _GetEmptyString().m_pchData; }
inline CString::CString(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
inline const CString& CString::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
inline const CString& CString::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
inline const CString& CString::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
inline CString __stdcall operator+(const CString& string, char ch)
	{ return string + (TCHAR)ch; }
inline CString __stdcall operator+(char ch, const CString& string)
	{ return (TCHAR)ch + string; }
#endif

inline int CString::GetLength() const
	{ return GetData()->nDataLength; }
inline int CString::GetAllocLength() const
	{ return GetData()->nAllocLength; }
inline BOOL CString::IsEmpty() const
	{ return GetData()->nDataLength == 0; }
inline CString::operator LPCTSTR() const
	{ return m_pchData; }
inline int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
inline int CString::Compare(LPCTSTR lpsz) const
	{ return _cstrcmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CString::CompareNoCase(LPCTSTR lpsz) const
	{ return _cstrcmpi(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CString::Collate(LPCTSTR lpsz) const
	{ return _cstrcoll(m_pchData, lpsz); }   // locale sensitive

inline TCHAR CString::GetAt(int nIndex) const
{
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline TCHAR CString::operator[](int nIndex) const
{
	// same as GetAt
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline bool __stdcall operator==(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) == 0; }
inline bool __stdcall operator==(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
inline bool __stdcall operator==(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) == 0; }
inline bool __stdcall operator!=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) != 0; }
inline bool __stdcall operator!=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
inline bool __stdcall operator!=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) != 0; }
inline bool __stdcall operator<(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) < 0; }
inline bool __stdcall operator<(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) < 0; }
inline bool __stdcall operator<(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) > 0; }
inline bool __stdcall operator>(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) > 0; }
inline bool __stdcall operator>(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) > 0; }
inline bool __stdcall operator>(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) < 0; }
inline bool __stdcall operator<=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) <= 0; }
inline bool __stdcall operator<=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) <= 0; }
inline bool __stdcall operator<=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) >= 0; }
inline bool __stdcall operator>=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) >= 0; }
inline bool __stdcall operator>=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) >= 0; }
inline bool __stdcall operator>=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) <= 0; }

inline CString::CString()
{
	Init();
}

inline CString::CString(const CString& stringSrc)
{
	ATLASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ATLASSERT(stringSrc.GetData() != _atltmpDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

inline BOOL CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
	ATLASSERT(nLen >= 0);
	ATLASSERT(nLen <= INT_MAX - 1);    // max size (enough room for 1 extra)

	if (nLen == 0)
	{
		Init();
	}
	else
	{
		CStringData* pData = NULL;
		ATLTRY(pData = (CStringData*)new BYTE[sizeof(CStringData) + (nLen + 1) * sizeof(TCHAR)]);
		if(pData == NULL)
			return FALSE;

		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
		pData->nDataLength = nLen;
		pData->nAllocLength = nLen;
		m_pchData = pData->data();
	}

	return TRUE;
}

inline void CString::Release()
{
	if (GetData() != _atltmpDataNil)
	{
		ATLASSERT(GetData()->nRefs != 0);
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
		Init();
	}
}

inline void PASCAL CString::Release(CStringData* pData)
{
	if (pData != _atltmpDataNil)
	{
		ATLASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) <= 0)
			delete[] (BYTE*)pData;
	}
}

inline void CString::Empty()
{
	if (GetData()->nDataLength == 0)
		return;

	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = _T("");

	ATLASSERT(GetData()->nDataLength == 0);
	ATLASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

inline void CString::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CStringData* pData = GetData();
		Release();
		if(AllocBuffer(pData->nDataLength))
			memcpy(m_pchData, pData->data(), (pData->nDataLength + 1) * sizeof(TCHAR));
	}
	ATLASSERT(GetData()->nRefs <= 1);
}

inline BOOL CString::AllocBeforeWrite(int nLen)
{
	BOOL bRet = TRUE;
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		bRet = AllocBuffer(nLen);
	}
	ATLASSERT(GetData()->nRefs <= 1);
	return bRet;
}

inline CString::~CString()
//  free any attached data
{
	if (GetData() != _atltmpDataNil)
	{
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
	}
}

inline void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		if(dest.AllocBuffer(nNewLen))
			memcpy(dest.m_pchData, m_pchData + nCopyIndex, nCopyLen * sizeof(TCHAR));
	}
}

inline CString::CString(LPCTSTR lpsz)
{
	Init();
	if (lpsz != NULL && HIWORD(lpsz) == NULL)
	{
		UINT nID = LOWORD((DWORD_PTR)lpsz);
		if (!LoadString(nID))
			ATLTRACE2(atlTraceUI, 0, _T("Warning: implicit LoadString(%u) in CString failed\n"), nID);
	}
	else
	{
		int nLen = SafeStrlen(lpsz);
		if (nLen != 0)
		{
			if(AllocBuffer(nLen))
				memcpy(m_pchData, lpsz, nLen * sizeof(TCHAR));
		}
	}
}

#ifdef _UNICODE
inline CString::CString(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		if(AllocBuffer(nSrcLen))
		{
			_mbstowcsz(m_pchData, lpsz, nSrcLen + 1);
			ReleaseBuffer();
		}
	}
}
#else //_UNICODE
inline CString::CString(LPCWSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if (nSrcLen != 0)
	{
		if(AllocBuffer(nSrcLen * 2))
		{
			_wcstombsz(m_pchData, lpsz, (nSrcLen * 2) + 1);
			ReleaseBuffer();
		}
	}
}
#endif //!_UNICODE

// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

inline void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	if(AllocBeforeWrite(nSrcLen))
	{
		memcpy(m_pchData, lpszSrcData, nSrcLen * sizeof(TCHAR));
		GetData()->nDataLength = nSrcLen;
		m_pchData[nSrcLen] = '\0';
	}
}

inline const CString& CString::operator=(const CString& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != _atltmpDataNil) || stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ATLASSERT(stringSrc.GetData() != _atltmpDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

inline const CString& CString::operator=(LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || _IsValidString(lpsz, FALSE));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

#ifdef _UNICODE
inline const CString& CString::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if(AllocBeforeWrite(nSrcLen))
	{
		_mbstowcsz(m_pchData, lpsz, nSrcLen + 1);
		ReleaseBuffer();
	}
	return *this;
}
#else //!_UNICODE
inline const CString& CString::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if(AllocBeforeWrite(nSrcLen * 2))
	{
		_wcstombsz(m_pchData, lpsz, (nSrcLen * 2) + 1);
		ReleaseBuffer();
	}
	return *this;
}
#endif  //!_UNICODE

// Concatenation
// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = TCHAR, LPCTSTR
//          CString + ?
//          ? + CString

inline BOOL CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

	BOOL bRet = TRUE;
	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		bRet = AllocBuffer(nNewLen);
		if (bRet)
		{
			memcpy(m_pchData, lpszSrc1Data, nSrc1Len * sizeof(TCHAR));
			memcpy(m_pchData + nSrc1Len, lpszSrc2Data, nSrc2Len * sizeof(TCHAR));
		}
	}
	return bRet;
}

inline CString __stdcall operator+(const CString& string1, const CString& string2)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

inline CString __stdcall operator+(const CString& string, LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || CString::_IsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData, CString::SafeStrlen(lpsz), lpsz);
	return s;
}

inline CString __stdcall operator+(LPCTSTR lpsz, const CString& string)
{
	ATLASSERT(lpsz == NULL || CString::_IsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(CString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

inline void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CStringData* pOldData = GetData();
		if (ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData))
		{
			ATLASSERT(pOldData != NULL);
			CString::Release(pOldData);
		}
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData + GetData()->nDataLength, lpszSrcData, nSrcLen * sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ATLASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

inline const CString& CString::operator+=(LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || _IsValidString(lpsz, FALSE));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

inline const CString& CString::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

inline const CString& CString::operator+=(const CString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

inline LPTSTR CString::GetBuffer(int nMinBufLength)
{
	ATLASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;

		if(AllocBuffer(nMinBufLength))
		{
			memcpy(m_pchData, pOldData->data(), (nOldLen + 1) * sizeof(TCHAR));
			GetData()->nDataLength = nOldLen;
			CString::Release(pOldData);
		}
	}
	ATLASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ATLASSERT(m_pchData != NULL);
	return m_pchData;
}

inline void CString::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ATLASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

inline LPTSTR CString::GetBufferSetLength(int nNewLength)
{
	ATLASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

inline void CString::FreeExtra()
{
	ATLASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CStringData* pOldData = GetData();
		if(AllocBuffer(GetData()->nDataLength))
		{
			memcpy(m_pchData, pOldData->data(), pOldData->nDataLength * sizeof(TCHAR));
			ATLASSERT(m_pchData[GetData()->nDataLength] == '\0');
			CString::Release(pOldData);
		}
	}
	ATLASSERT(GetData() != NULL);
}

inline LPTSTR CString::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

inline void CString::UnlockBuffer()
{
	ATLASSERT(GetData()->nRefs == -1);
	if (GetData() != _atltmpDataNil)
		GetData()->nRefs = 1;
}

inline int CString::Find(TCHAR ch) const
{
	// find first single character
	LPTSTR lpsz = _cstrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline int CString::FindOneOf(LPCTSTR lpszCharSet) const
{
	ATLASSERT(_IsValidString(lpszCharSet, FALSE));
	LPTSTR lpsz = _cstrpbrk(m_pchData, lpszCharSet);
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline void CString::MakeUpper()
{
	CopyBeforeWrite();
	CharUpper(m_pchData);
}

inline void CString::MakeLower()
{
	CopyBeforeWrite();
	CharLower(m_pchData);
}

inline void CString::MakeReverse()
{
	CopyBeforeWrite();
	_cstrrev(m_pchData);
}

inline void CString::SetAt(int nIndex, TCHAR ch)
{
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
inline void CString::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}
inline void CString::OemToAnsi()
{
	CopyBeforeWrite();
	::OemToAnsi(m_pchData, m_pchData);
}
#endif

inline CString::CString(TCHAR ch, int nLength)
{
	ATLASSERT(!_istlead(ch));    // can't create a lead byte string
	Init();
	if (nLength >= 1)
	{
		if(AllocBuffer(nLength))
		{
#ifdef _UNICODE
			for (int i = 0; i < nLength; i++)
				m_pchData[i] = ch;
#else
			memset(m_pchData, ch, nLength);
#endif
		}
	}
}

inline CString::CString(LPCTSTR lpch, int nLength)
{
	Init();
	if (nLength != 0)
	{
		if(AllocBuffer(nLength))
			memcpy(m_pchData, lpch, nLength * sizeof(TCHAR));
	}
}

inline const CString& CString::operator=(TCHAR ch)
{
	ATLASSERT(!_istlead(ch));    // can't set single lead byte
	AssignCopy(1, &ch);
	return *this;
}

inline CString __stdcall operator+(const CString& string1, TCHAR ch)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
	return s;
}

inline CString __stdcall operator+(TCHAR ch, const CString& string)
{
	CString s;
	s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

inline CString CString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

inline CString CString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	CString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

inline CString CString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

inline CString CString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

// strspn equivalent
inline CString CString::SpanIncluding(LPCTSTR lpszCharSet) const
{
	ATLASSERT(_IsValidString(lpszCharSet, FALSE));
	return Left(_cstrspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
inline CString CString::SpanExcluding(LPCTSTR lpszCharSet) const
{
	ATLASSERT(_IsValidString(lpszCharSet, FALSE));
	return Left(_cstrcspn(m_pchData, lpszCharSet));
}

inline int CString::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _cstrrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
inline int CString::Find(LPCTSTR lpszSub) const
{
	ATLASSERT(_IsValidString(lpszSub, FALSE));

	// find first matching substring
	LPTSTR lpsz = _cstrstr(m_pchData, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline void CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
	ATLASSERT(_IsValidString(lpszFormat, FALSE));

	enum _FormatModifiers
	{
		FORCE_ANSI =	0x10000,
		FORCE_UNICODE =	0x20000,
		FORCE_INT64 =	0x40000
	};

	va_list argListSave = argList;

	// make a guess at the maximum length of the resulting string
	int nMaxLen = 0;
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = ::CharNext(lpsz))
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(lpsz = ::CharNext(lpsz)) == '%')
		{
			nMaxLen += (int)lstrlen(lpsz);
			continue;
		}

		int nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = ::CharNext(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' || *lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = _ttoi(lpsz);
			for (; *lpsz != '\0' && _cstrisdigit(*lpsz); lpsz = ::CharNext(lpsz))
				;
		}
		ATLASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = ::CharNext(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = ::CharNext(lpsz);
			}
			else
			{
				nPrecision = _ttoi(lpsz);
				for (; *lpsz != '\0' && _cstrisdigit(*lpsz); lpsz = ::CharNext(lpsz))
					;
			}
			ATLASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
		if(lpsz[0] == _T('I') && lpsz[1] == _T('6') && lpsz[2] == _T('4'))
		{
			lpsz += 3;
			nModifier = FORCE_INT64;
		}
		else
		{
			switch (*lpsz)
			{
			// modifiers that affect size
			case 'h':
				nModifier = FORCE_ANSI;
				lpsz = ::CharNext(lpsz);
				break;
			case 'l':
				nModifier = FORCE_UNICODE;
				lpsz = ::CharNext(lpsz);
				break;

			// modifiers that do not affect size
			case 'F':
			case 'N':
			case 'L':
				lpsz = ::CharNext(lpsz);
				break;
			}
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR);
			break;
		case 'c' | FORCE_ANSI:
		case 'C' | FORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, char);
			break;
		case 'c' | FORCE_UNICODE:
		case 'C' | FORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR);
			break;

		// strings
		case 's':
		{
			LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
			if (pstrNextArg == NULL)
			{
				nItemLen = 6;  // "(null)"
			}
			else
			{
				nItemLen = lstrlen(pstrNextArg);
				nItemLen = max(1, nItemLen);
			}
			break;
		}

		case 'S':
		{
#ifndef _UNICODE
			LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
			if (pstrNextArg == NULL)
			{
				nItemLen = 6;  // "(null)"
			}
			else
			{
				nItemLen = (int)wcslen(pstrNextArg);
				nItemLen = max(1, nItemLen);
			}
#else
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			{
				nItemLen = 6; // "(null)"
			}
			else
			{
				nItemLen = lstrlenA(pstrNextArg);
				nItemLen = max(1, nItemLen);
			}
#endif
			break;
		}

		case 's' | FORCE_ANSI:
		case 'S' | FORCE_ANSI:
		{
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			{
				nItemLen = 6; // "(null)"
			}
			else
			{
				nItemLen = lstrlenA(pstrNextArg);
				nItemLen = max(1, nItemLen);
			}
			break;
		}

		case 's' | FORCE_UNICODE:
		case 'S' | FORCE_UNICODE:
		{
			LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
			if (pstrNextArg == NULL)
			{
				nItemLen = 6; // "(null)"
			}
			else
			{
				nItemLen = (int)wcslen(pstrNextArg);
				nItemLen = max(1, nItemLen);
			}
			break;
		}
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			nItemLen = max(nItemLen, nWidth);
			if (nPrecision != 0)
				nItemLen = min(nItemLen, nPrecision);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				if (nModifier & FORCE_INT64)
					va_arg(argList, __int64);
				else
					va_arg(argList, int);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth + nPrecision);
				break;

#ifndef _ATL_USE_CSTRING_FLOAT
			case 'e':
			case 'f':
			case 'g':
			case 'G':
				ATLASSERT(!"Floating point (%%e, %%f, %%g, and %%G) is not supported by the WTL::CString class.");
#ifndef _DEBUG
				::OutputDebugString(_T("Floating point (%%e, %%f, %%g, and %%G) is not supported by the WTL::CString class."));
				::DebugBreak();
#endif //!_DEBUG
				break;
#else //_ATL_USE_CSTRING_FLOAT
			case 'e':
			case 'g':
			case 'G':
				va_arg(argList, double);
				nItemLen = 128;
				nItemLen = max(nItemLen, nWidth + nPrecision);
				break;
			case 'f':
				{
					double f;
					LPTSTR pszTemp;

					// 312 == strlen("-1+(309 zeroes).")
					// 309 zeroes == max precision of a double
					// 6 == adjustment in case precision is not specified,
					//   which means that the precision defaults to 6
					pszTemp = (LPTSTR)_alloca(max(nWidth, 312 + nPrecision + 6));

					f = va_arg(argList, double);
					_stprintf(pszTemp, _T( "%*.*f" ), nWidth, nPrecision + 6, f);
					nItemLen = _tcslen(pszTemp);
				}
				break;
#endif //_ATL_USE_CSTRING_FLOAT

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth + nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ATLASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}

	GetBuffer(nMaxLen);
#ifndef _ATL_USE_CSTRING_FLOAT
	int nRet = wvsprintf(m_pchData, lpszFormat, argListSave);
#else //_ATL_USE_CSTRING_FLOAT
	int nRet = _vstprintf(m_pchData, lpszFormat, argListSave);
#endif //_ATL_USE_CSTRING_FLOAT
	nRet;	// ref
	ATLASSERT(nRet <= GetAllocLength());
	ReleaseBuffer();

	va_end(argListSave);
}

// formatting (using wsprintf style formatting)
inline void __cdecl CString::Format(LPCTSTR lpszFormat, ...)
{
	ATLASSERT(_IsValidString(lpszFormat, FALSE));

	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

inline void __cdecl CString::Format(UINT nFormatID, ...)
{
	CString strFormat;
	BOOL bRet = strFormat.LoadString(nFormatID);
	bRet;	// ref
	ATLASSERT(bRet != 0);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
}

// formatting (using FormatMessage style formatting)
inline BOOL __cdecl CString::FormatMessage(LPCTSTR lpszFormat, ...)
{
	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, lpszFormat);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
			lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 || lpszTemp == NULL)
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free the temporary
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

inline BOOL __cdecl CString::FormatMessage(UINT nFormatID, ...)
{
	// get format string from string table
	CString strFormat;
	BOOL bRetTmp = strFormat.LoadString(nFormatID);
	bRetTmp;	// ref
	ATLASSERT(bRetTmp != 0);

	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, nFormatID);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
			strFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 || lpszTemp == NULL)
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free lpszTemp
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

inline void CString::TrimRight()
{
	CopyBeforeWrite();

	// find beginning of trailing spaces by starting at beginning (DBCS aware)
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	while (*lpsz != '\0')
	{
		if (_cstrisspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
		{
			lpszLast = NULL;
		}
		lpsz = ::CharNext(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(DWORD_PTR)(lpszLast - m_pchData);
	}
}

inline void CString::TrimLeft()
{
	CopyBeforeWrite();

	// find first non-space character
	LPCTSTR lpsz = m_pchData;
	while (_cstrisspace(*lpsz))
		lpsz = ::CharNext(lpsz);

	// fix up data and length
	int nDataLength = GetData()->nDataLength - (int)(DWORD_PTR)(lpsz - m_pchData);
	memmove(m_pchData, lpsz, (nDataLength + 1) * sizeof(TCHAR));
	GetData()->nDataLength = nDataLength;
}

inline int CString::Delete(int nIndex, int nCount /* = 1 */)
{
	if (nIndex < 0)
		nIndex = 0;
	int nNewLength = GetData()->nDataLength;
	if (nCount > 0 && nIndex < nNewLength)
	{
		CopyBeforeWrite();
		int nBytesToCopy = nNewLength - (nIndex + nCount) + 1;

		memmove(m_pchData + nIndex, m_pchData + nIndex + nCount, nBytesToCopy * sizeof(TCHAR));
		GetData()->nDataLength = nNewLength - nCount;
	}

	return nNewLength;
}

inline int CString::Insert(int nIndex, TCHAR ch)
{
	CopyBeforeWrite();

	if (nIndex < 0)
		nIndex = 0;

	int nNewLength = GetData()->nDataLength;
	if (nIndex > nNewLength)
		nIndex = nNewLength;
	nNewLength++;

	if (GetData()->nAllocLength < nNewLength)
	{
		CStringData* pOldData = GetData();
		LPTSTR pstr = m_pchData;
		if(!AllocBuffer(nNewLength))
			return -1;
		memcpy(m_pchData, pstr, (pOldData->nDataLength + 1) * sizeof(TCHAR));
		CString::Release(pOldData);
	}

	// move existing bytes down
	memmove(m_pchData + nIndex + 1, m_pchData + nIndex, (nNewLength - nIndex) * sizeof(TCHAR));
	m_pchData[nIndex] = ch;
	GetData()->nDataLength = nNewLength;

	return nNewLength;
}

inline int CString::Insert(int nIndex, LPCTSTR pstr)
{
	if (nIndex < 0)
		nIndex = 0;

	int nInsertLength = SafeStrlen(pstr);
	int nNewLength = GetData()->nDataLength;
	if (nInsertLength > 0)
	{
		CopyBeforeWrite();
		if (nIndex > nNewLength)
			nIndex = nNewLength;
		nNewLength += nInsertLength;

		if (GetData()->nAllocLength < nNewLength)
		{
			CStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			if(!AllocBuffer(nNewLength))
				return -1;
			memcpy(m_pchData, pstr, (pOldData->nDataLength + 1) * sizeof(TCHAR));
			CString::Release(pOldData);
		}

		// move existing bytes down
		memmove(m_pchData + nIndex + nInsertLength, m_pchData + nIndex, (nNewLength - nIndex - nInsertLength + 1) * sizeof(TCHAR));
		memcpy(m_pchData + nIndex, pstr, nInsertLength * sizeof(TCHAR));
		GetData()->nDataLength = nNewLength;
	}

	return nNewLength;
}

inline int CString::Replace(TCHAR chOld, TCHAR chNew)
{
	int nCount = 0;

	// short-circuit the nop case
	if (chOld != chNew)
	{
		// otherwise modify each character that matches in the string
		CopyBeforeWrite();
		LPTSTR psz = m_pchData;
		LPTSTR pszEnd = psz + GetData()->nDataLength;
		while (psz < pszEnd)
		{
			// replace instances of the specified character only
			if (*psz == chOld)
			{
				*psz = chNew;
				nCount++;
			}
			psz = ::CharNext(psz);
		}
	}
	return nCount;
}

inline int CString::Replace(LPCTSTR lpszOld, LPCTSTR lpszNew)
{
	// can't have empty or NULL lpszOld

	int nSourceLen = SafeStrlen(lpszOld);
	if (nSourceLen == 0)
		return 0;
	int nReplacementLen = SafeStrlen(lpszNew);

	// loop once to figure out the size of the result string
	int nCount = 0;
	LPTSTR lpszStart = m_pchData;
	LPTSTR lpszEnd = m_pchData + GetData()->nDataLength;
	LPTSTR lpszTarget;
	while (lpszStart < lpszEnd)
	{
		while ((lpszTarget = _cstrstr(lpszStart, lpszOld)) != NULL)
		{
			nCount++;
			lpszStart = lpszTarget + nSourceLen;
		}
		lpszStart += lstrlen(lpszStart) + 1;
	}

	// if any changes were made, make them
	if (nCount > 0)
	{
		CopyBeforeWrite();

		// if the buffer is too small, just
		//   allocate a new buffer (slow but sure)
		int nOldLength = GetData()->nDataLength;
		int nNewLength =  nOldLength + (nReplacementLen - nSourceLen) * nCount;
		if (GetData()->nAllocLength < nNewLength || GetData()->nRefs > 1)
		{
			CStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			if(!AllocBuffer(nNewLength))
				return -1;
			memcpy(m_pchData, pstr, pOldData->nDataLength * sizeof(TCHAR));
			CString::Release(pOldData);
		}
		// else, we just do it in-place
		lpszStart = m_pchData;
		lpszEnd = m_pchData + GetData()->nDataLength;

		// loop again to actually do the work
		while (lpszStart < lpszEnd)
		{
			while ( (lpszTarget = _cstrstr(lpszStart, lpszOld)) != NULL)
			{
				int nBalance = nOldLength - ((int)(DWORD_PTR)(lpszTarget - m_pchData) + nSourceLen);
				memmove(lpszTarget + nReplacementLen, lpszTarget + nSourceLen, nBalance * sizeof(TCHAR));
				memcpy(lpszTarget, lpszNew, nReplacementLen * sizeof(TCHAR));
				lpszStart = lpszTarget + nReplacementLen;
				lpszStart[nBalance] = '\0';
				nOldLength += (nReplacementLen - nSourceLen);
			}
			lpszStart += lstrlen(lpszStart) + 1;
		}
		ATLASSERT(m_pchData[nNewLength] == '\0');
		GetData()->nDataLength = nNewLength;
	}

	return nCount;
}

inline int CString::Remove(TCHAR chRemove)
{
	CopyBeforeWrite();

	LPTSTR pstrSource = m_pchData;
	LPTSTR pstrDest = m_pchData;
	LPTSTR pstrEnd = m_pchData + GetData()->nDataLength;

	while (pstrSource < pstrEnd)
	{
		if (*pstrSource != chRemove)
		{
			*pstrDest = *pstrSource;
			pstrDest = ::CharNext(pstrDest);
		}
		pstrSource = ::CharNext(pstrSource);
	}
	*pstrDest = '\0';
	int nCount = (int)(DWORD_PTR)(pstrSource - pstrDest);
	GetData()->nDataLength -= nCount;

	return nCount;
}

#ifdef _UNICODE
#define CHAR_FUDGE 1    // one TCHAR unused is good enough
#else
#define CHAR_FUDGE 2    // two BYTES unused for case of DBC last char
#endif

inline BOOL CString::LoadString(UINT nID)
{
	// try fixed buffer first (to avoid wasting space in the heap)
	TCHAR szTemp[256];
	int nCount =  sizeof(szTemp) / sizeof(szTemp[0]);
	int nLen = _LoadString(nID, szTemp, nCount);
	if (nCount - nLen > CHAR_FUDGE)
	{
		*this = szTemp;
		return nLen > 0;
	}

	// try buffer size of 512, then larger size until entire string is retrieved
	int nSize = 256;
	do
	{
		nSize += 256;
		nLen = _LoadString(nID, GetBuffer(nSize - 1), nSize);
	} while (nSize - nLen <= CHAR_FUDGE);
	ReleaseBuffer();

	return nLen > 0;
}

#ifndef _ATL_NO_COM
inline BSTR CString::AllocSysString() const
{
#if defined(_UNICODE) || defined(OLE2ANSI)
	BSTR bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
#else
	int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
		GetData()->nDataLength, NULL, NULL);
	BSTR bstr = ::SysAllocStringLen(NULL, nLen);
	if(bstr != NULL)
		MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength, bstr, nLen);
#endif
	return bstr;
}

inline BSTR CString::SetSysString(BSTR* pbstr) const
{
#if defined(_UNICODE) || defined(OLE2ANSI)
	::SysReAllocStringLen(pbstr, m_pchData, GetData()->nDataLength);
#else
	int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
		GetData()->nDataLength, NULL, NULL);
	if(::SysReAllocStringLen(pbstr, NULL, nLen))
		MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength, *pbstr, nLen);
#endif
	ATLASSERT(*pbstr != NULL);
	return *pbstr;
}
#endif //!_ATL_NO_COM

#endif //!_WTL_NO_CSTRING


/////////////////////////////////////////////////////////////////////////////
// CRecentDocumentList - MRU List Support

// forward declaration
inline bool AtlCompactPath(LPTSTR lpstrOut, LPCTSTR lpstrIn, int cchLen);

template <class T, int t_cchItemLen = MAX_PATH>
class CRecentDocumentListBase
{
public:
// Declarations
	struct _DocEntry
	{
		TCHAR szDocName[t_cchItemLen];
		bool operator==(const _DocEntry& de) const
		{ return (lstrcmpi(szDocName, de.szDocName) == 0); }
	};

	enum
	{
		m_nMaxEntries_Min = 2,
		m_nMaxEntries_Max = ID_FILE_MRU_LAST - ID_FILE_MRU_FIRST + 1,
		m_cchMaxItemLen_Min = 6,
		m_cchMaxItemLen_Max = t_cchItemLen
	};

// Data members
	CSimpleArray<_DocEntry> m_arrDocs;
	int m_nMaxEntries;	// default is 4
	HMENU m_hMenu;

	TCHAR m_szNoEntries[t_cchItemLen];

	int m_cchMaxItemLen;

// Constructor
	CRecentDocumentListBase() : m_hMenu(NULL), m_nMaxEntries(4), m_cchMaxItemLen(-1)
	{
		ATLASSERT(t_cchItemLen > m_cchMaxItemLen_Min);
	}

// Attributes
	HMENU GetMenuHandle() const
	{
		return m_hMenu;
	}
	void SetMenuHandle(HMENU hMenu)
	{
		ATLASSERT(hMenu == NULL || ::IsMenu(hMenu));
		m_hMenu = hMenu;
		if(m_hMenu == NULL || (::GetMenuString(m_hMenu, ID_FILE_MRU_FIRST, m_szNoEntries, t_cchItemLen, MF_BYCOMMAND) == 0))
			lstrcpy(m_szNoEntries, _T("(empty)"));
	}
	int GetMaxEntries() const
	{
		return m_nMaxEntries;
	}
	void SetMaxEntries(int nMaxEntries)
	{
		ATLASSERT(nMaxEntries > m_nMaxEntries_Min && nMaxEntries < m_nMaxEntries_Max);
		if(nMaxEntries < m_nMaxEntries_Min)
			nMaxEntries = m_nMaxEntries_Min;
		else if(nMaxEntries > m_nMaxEntries_Max)
			nMaxEntries = m_nMaxEntries_Max;
		m_nMaxEntries = nMaxEntries;
	}
	int GetMaxItemLength() const
	{
		return m_cchMaxItemLen;
	}
	void SetMaxItemLength(int cchMaxLen)
	{
		ATLASSERT((cchMaxLen >= m_cchMaxItemLen_Min && cchMaxLen <= m_cchMaxItemLen_Max) || cchMaxLen == -1);
		if(cchMaxLen != -1)
		{
			if(cchMaxLen < m_cchMaxItemLen_Min)
				cchMaxLen = m_cchMaxItemLen_Min;
			else if(cchMaxLen > m_cchMaxItemLen_Max)
				cchMaxLen = m_cchMaxItemLen_Max;
		}
		m_cchMaxItemLen = cchMaxLen;
		T* pT = static_cast<T*>(this);
		pT->UpdateMenu();
	}

// Operations
	BOOL AddToList(LPCTSTR lpstrDocName)
	{
		_DocEntry de;
		if(lstrcpy(de.szDocName, lpstrDocName) == NULL)
			return FALSE;

		for(int i = 0; i < m_arrDocs.GetSize(); i++)
		{
			if(lstrcmpi(m_arrDocs[i].szDocName, lpstrDocName) == 0)
			{
				m_arrDocs.RemoveAt(i);
				break;
			}
		}

		if(m_arrDocs.GetSize() == m_nMaxEntries)
			m_arrDocs.RemoveAt(0);

		BOOL bRet = m_arrDocs.Add(de);
		if(bRet)
		{
			T* pT = static_cast<T*>(this);
			bRet = pT->UpdateMenu();
		}
		return bRet;
	}
	BOOL GetFromList(int nItemID, LPTSTR lpstrDocName)
	{
		int nIndex = m_arrDocs.GetSize() - (nItemID - ID_FILE_MRU_FIRST) - 1;
		if(nIndex < 0 || nIndex >= m_arrDocs.GetSize())
			return FALSE;
		return (lstrcpy(lpstrDocName, m_arrDocs[nIndex].szDocName) != NULL);
	}
	BOOL RemoveFromList(int nItemID)
	{
		int nIndex = m_arrDocs.GetSize() - (nItemID - ID_FILE_MRU_FIRST) - 1;
		BOOL bRet = m_arrDocs.RemoveAt(nIndex);
		if(bRet)
		{
			T* pT = static_cast<T*>(this);
			bRet = pT->UpdateMenu();
		}
		return bRet;
	}
	BOOL MoveToTop(int nItemID)
	{
		int nIndex = m_arrDocs.GetSize() - 1 - (nItemID - ID_FILE_MRU_FIRST);
		if(nIndex < 0 || nIndex >= m_arrDocs.GetSize())
			return FALSE;
		_DocEntry de;
		de = m_arrDocs[nIndex];
		m_arrDocs.RemoveAt(nIndex);
		BOOL bRet = m_arrDocs.Add(de);
		if(bRet)
		{
			T* pT = static_cast<T*>(this);
			bRet = pT->UpdateMenu();
		}
		return bRet;
	}

	BOOL ReadFromRegistry(LPCTSTR lpstrRegKey)
	{
		CRegKey rkParent;
		CRegKey rk;

		LONG lRet = rkParent.Open(HKEY_CURRENT_USER, lpstrRegKey);
		if(lRet != ERROR_SUCCESS)
			return FALSE;
		lRet = rk.Open(rkParent, _T("Recent Document List"));
		if(lRet != ERROR_SUCCESS)
			return FALSE;

		DWORD dwRet;
		lRet = rk.QueryValue(dwRet, _T("DocumentCount"));
		if(lRet == ERROR_SUCCESS || dwRet > 0 && dwRet < (ID_FILE_MRU_LAST - ID_FILE_MRU_FIRST + 1))
			m_nMaxEntries = dwRet;

		m_arrDocs.RemoveAll();

		TCHAR szRetString[t_cchItemLen];
		_DocEntry de;

		for(int nItem = m_nMaxEntries; nItem > 0; nItem--)
		{
			TCHAR szBuff[11];
			wsprintf(szBuff, _T("Document%i"), nItem);
			DWORD dwCount = t_cchItemLen * sizeof(TCHAR);
			lRet = rk.QueryValue(szRetString, szBuff, &dwCount);
			if(lRet == ERROR_SUCCESS && (lstrcpy(de.szDocName, szRetString) != NULL))
				m_arrDocs.Add(de);
		}

		rk.Close();
		rkParent.Close();

		T* pT = static_cast<T*>(this);
		return pT->UpdateMenu();
	}
	BOOL WriteToRegistry(LPCTSTR lpstrRegKey)
	{
		CRegKey rkParent;
		CRegKey rk;

		LONG lRet = rkParent.Create(HKEY_CURRENT_USER, lpstrRegKey);
		if(lRet != ERROR_SUCCESS)
			return FALSE;
		lRet = rk.Create(rkParent, _T("Recent Document List"));
		if(lRet != ERROR_SUCCESS)
			return FALSE;

		lRet = rk.SetValue(m_nMaxEntries, _T("DocumentCount"));
		ATLASSERT(lRet == ERROR_SUCCESS);

		// set new values
		int nItem;
		for(nItem = m_arrDocs.GetSize(); nItem > 0; nItem--)
		{
			TCHAR szBuff[11];
			wsprintf(szBuff, _T("Document%i"), nItem);
			TCHAR szDocName[t_cchItemLen];
			GetFromList(ID_FILE_MRU_FIRST + nItem - 1, szDocName);
			lRet = rk.SetValue(szDocName, szBuff);
			ATLASSERT(lRet == ERROR_SUCCESS);
		}

		// delete unused keys
		for(nItem = m_arrDocs.GetSize() + 1; nItem < (ID_FILE_MRU_LAST - ID_FILE_MRU_FIRST + 1); nItem++)
		{
			TCHAR szBuff[11];
			wsprintf(szBuff, _T("Document%i"), nItem);
			rk.DeleteValue(szBuff);
		}

		rk.Close();
		rkParent.Close();

		return TRUE;
	}

// Implementation
	BOOL UpdateMenu()
	{
		if(m_hMenu == NULL)
			return FALSE;
		ATLASSERT(::IsMenu(m_hMenu));

		int nItems = ::GetMenuItemCount(m_hMenu);
		int nInsertPoint;
		for(nInsertPoint = 0; nInsertPoint < nItems; nInsertPoint++)
		{
			MENUITEMINFO mi;
			mi.cbSize = sizeof(MENUITEMINFO);
			mi.fMask = MIIM_ID;
			::GetMenuItemInfo(m_hMenu, nInsertPoint, TRUE, &mi);
			if (mi.wID == ID_FILE_MRU_FIRST)
				break;
		}
		ATLASSERT(nInsertPoint < nItems && "You need a menu item with an ID = ID_FILE_MRU_FIRST");

		int nItem;
		for(nItem = ID_FILE_MRU_FIRST; nItem < ID_FILE_MRU_FIRST + m_nMaxEntries; nItem++)
		{
			// keep the first one as an insertion point
			if (nItem != ID_FILE_MRU_FIRST)
				::DeleteMenu(m_hMenu, nItem, MF_BYCOMMAND);
		}

		TCHAR szItemText[t_cchItemLen + 6];		// add space for &, 2 digits, and a space
		int nSize = m_arrDocs.GetSize();
		nItem = 0;
		if(nSize > 0)
		{
			for(nItem = 0; nItem < nSize; nItem++)
			{
				if(m_cchMaxItemLen == -1)
				{
					wsprintf(szItemText, _T("&%i %s"), nItem + 1, m_arrDocs[nSize - 1 - nItem].szDocName);
				}
				else
				{
					TCHAR szBuff[t_cchItemLen];
					T* pT = static_cast<T*>(this);
					pT;	// avoid level 4 warning
					bool bRet = pT->CompactDocumentName(szBuff, m_arrDocs[nSize - 1 - nItem].szDocName, m_cchMaxItemLen);
					bRet;	// avoid level 4 warning
					ATLASSERT(bRet);
					wsprintf(szItemText, _T("&%i %s"), nItem + 1, szBuff);
				}
				::InsertMenu(m_hMenu, nInsertPoint + nItem, MF_BYPOSITION | MF_STRING, ID_FILE_MRU_FIRST + nItem, szItemText);
			}
		}
		else	// empty
		{
			::InsertMenu(m_hMenu, nInsertPoint, MF_BYPOSITION | MF_STRING, ID_FILE_MRU_FIRST, m_szNoEntries);
			::EnableMenuItem(m_hMenu, ID_FILE_MRU_FIRST, MF_GRAYED);
			nItem++;
		}
		::DeleteMenu(m_hMenu, nInsertPoint + nItem, MF_BYPOSITION);

		return TRUE;
	}

// Overrideable
	// override to provide a different method of compacting document names
	static bool CompactDocumentName(LPTSTR lpstrOut, LPCTSTR lpstrIn, int cchLen)
	{
		return AtlCompactPath(lpstrOut, lpstrIn, cchLen);
	}
};

class CRecentDocumentList : public CRecentDocumentListBase<CRecentDocumentList>
{
public:
// nothing here
};


/////////////////////////////////////////////////////////////////////////////
// CFindFile - file search helper class

class CFindFile
{
public:
// Data members
	WIN32_FIND_DATA m_fd;
	TCHAR m_lpszRoot[MAX_PATH];
	TCHAR m_chDirSeparator;
	HANDLE m_hFind;
	BOOL m_bFound;

// Constructor/destructor
	CFindFile() : m_hFind(NULL), m_chDirSeparator('\\'), m_bFound(FALSE)
	{ }

	~CFindFile()
	{
		Close();
	}

// Attributes
	ULONGLONG GetFileSize() const
	{
		ATLASSERT(m_hFind != NULL);

		ULARGE_INTEGER nFileSize;

		if(m_bFound)
		{
			nFileSize.LowPart = m_fd.nFileSizeLow;
			nFileSize.HighPart = m_fd.nFileSizeHigh;
		}
		else
		{
			nFileSize.QuadPart = 0;
		}

		return nFileSize.QuadPart;
	}
	BOOL GetFileName(LPTSTR lpstrFileName, int cchLength) const
	{
		ATLASSERT(m_hFind != NULL);
		if(lstrlen(m_fd.cFileName) >= cchLength)
			return FALSE;
		return (m_bFound && (lstrcpy(lpstrFileName, m_fd.cFileName) != NULL));
	}
	BOOL GetFilePath(LPTSTR lpstrFilePath, int cchLength) const
	{
		ATLASSERT(m_hFind != NULL);

		int nLen = lstrlen(m_lpszRoot);
		ATLASSERT(nLen > 0);
		if(nLen == 0)
			return FALSE;
		bool bAddSep = (m_lpszRoot[nLen - 1] != '\\' && m_lpszRoot[nLen - 1] != '/');

		if((lstrlen(m_lpszRoot) + (bAddSep ?  1 : 0)) >= cchLength)
			return FALSE;

		BOOL bRet = (lstrcpy(lpstrFilePath, m_lpszRoot) != NULL);
		if(bRet)
		{
			TCHAR szSeparator[2] = { m_chDirSeparator, 0 };
			bRet = (lstrcat(lpstrFilePath, szSeparator) != NULL);
		}
		return bRet;
	}
	BOOL GetFileTitle(LPTSTR lpstrFileTitle, int cchLength) const
	{
		ATLASSERT(m_hFind != NULL);

		TCHAR szBuff[MAX_PATH];
		if(!GetFileName(szBuff, MAX_PATH))
			return FALSE;
		TCHAR szNameBuff[_MAX_FNAME];
		_tsplitpath(szBuff, NULL, NULL, szNameBuff, NULL);
		if(lstrlen(szNameBuff) >= cchLength)
			return FALSE;
		return (lstrcpy(lpstrFileTitle, szNameBuff) != NULL);
	}
	BOOL GetFileURL(LPTSTR lpstrFileURL, int cchLength) const
	{
		ATLASSERT(m_hFind != NULL);

		TCHAR szBuff[MAX_PATH];
		if(!GetFilePath(szBuff, MAX_PATH))
			return FALSE;
		LPCTSTR lpstrFileURLPrefix = _T("file://");
		if(lstrlen(szBuff) + lstrlen(lpstrFileURLPrefix) >= cchLength)
			return FALSE;
		if(lstrcpy(lpstrFileURL, lpstrFileURLPrefix) == NULL)
			return FALSE;
		return (lstrcat(lpstrFileURL, szBuff) != NULL);
	}
	BOOL GetRoot(LPTSTR lpstrRoot, int cchLength) const
	{
		ATLASSERT(m_hFind != NULL);
		if(lstrlen(m_lpszRoot) >= cchLength)
			return FALSE;
		return (lstrcpy(lpstrRoot, m_lpszRoot) != NULL);
	}
#ifndef _WTL_NO_CSTRING
	CString GetFileName() const
	{
		ATLASSERT(m_hFind != NULL);

		CString ret;

		if(m_bFound)
			ret = m_fd.cFileName;
		return ret;
	}
	CString GetFilePath() const
	{
		ATLASSERT(m_hFind != NULL);

		CString strResult = m_lpszRoot;
		if(strResult[strResult.GetLength() - 1] != '\\' &&
			strResult[strResult.GetLength() - 1] != '/')
			strResult += m_chDirSeparator;
		strResult += GetFileName();
		return strResult;
	}
	CString GetFileTitle() const
	{
		ATLASSERT(m_hFind != NULL);

		CString strFullName = GetFileName();
		CString strResult;

		_tsplitpath(strFullName, NULL, NULL, strResult.GetBuffer(MAX_PATH), NULL);
		strResult.ReleaseBuffer();
		return strResult;
	}
	CString GetFileURL() const
	{
		ATLASSERT(m_hFind != NULL);

		CString strResult("file://");
		strResult += GetFilePath();
		return strResult;
	}
	CString GetRoot() const
	{
		ATLASSERT(m_hFind != NULL);

		CString str = m_lpszRoot;
		return str;
	}
#endif //!_WTL_NO_CSTRING
	BOOL GetLastWriteTime(FILETIME* pTimeStamp) const
	{
		ATLASSERT(m_hFind != NULL);
		ATLASSERT(pTimeStamp != NULL);

		if(m_bFound && pTimeStamp != NULL)
		{
			*pTimeStamp = m_fd.ftLastWriteTime;
			return TRUE;
		}

		return FALSE;
	}
	BOOL GetLastAccessTime(FILETIME* pTimeStamp) const
	{
		ATLASSERT(m_hFind != NULL);
		ATLASSERT(pTimeStamp != NULL);

		if(m_bFound && pTimeStamp != NULL)
		{
			*pTimeStamp = m_fd.ftLastAccessTime;
			return TRUE;
		}

		return FALSE;
	}
	BOOL GetCreationTime(FILETIME* pTimeStamp) const
	{
		ATLASSERT(m_hFind != NULL);

		if(m_bFound && pTimeStamp != NULL)
		{
			*pTimeStamp = m_fd.ftCreationTime;
			return TRUE;
		}

		return FALSE;
	}
	BOOL MatchesMask(DWORD dwMask) const
	{
		ATLASSERT(m_hFind != NULL);

		if(m_bFound)
			return ((m_fd.dwFileAttributes & dwMask) != 0);

		return FALSE;
	}
	BOOL IsDots() const
	{
		ATLASSERT(m_hFind != NULL);

		// return TRUE if the file name is "." or ".." and
		// the file is a directory

		BOOL bResult = FALSE;
		if(m_bFound && IsDirectory())
		{
			if(m_fd.cFileName[0] == '.' && (m_fd.cFileName[1] == '\0' || (m_fd.cFileName[1] == '.' && m_fd.cFileName[2] == '\0')))
				bResult = TRUE;
		}

		return bResult;
	}

	BOOL IsReadOnly() const
	{
		return MatchesMask(FILE_ATTRIBUTE_READONLY);
	}
	BOOL IsDirectory() const
	{
		return MatchesMask(FILE_ATTRIBUTE_DIRECTORY);
	}
	BOOL IsCompressed() const
	{
		return MatchesMask(FILE_ATTRIBUTE_COMPRESSED);
	}
	BOOL IsSystem() const
	{
		return MatchesMask(FILE_ATTRIBUTE_SYSTEM);
	}
	BOOL IsHidden() const
	{
		return MatchesMask(FILE_ATTRIBUTE_HIDDEN);
	}
	BOOL IsTemporary() const
	{
		return MatchesMask(FILE_ATTRIBUTE_TEMPORARY);
	}
	BOOL IsNormal() const
	{
		return MatchesMask(FILE_ATTRIBUTE_NORMAL);
	}
	BOOL IsArchived() const
	{
		return MatchesMask(FILE_ATTRIBUTE_ARCHIVE);
	}

// Operations
	BOOL FindFile(LPCTSTR pstrName = NULL)
	{
		Close();

		if(pstrName == NULL)
			pstrName = _T("*.*");
		lstrcpy(m_fd.cFileName, pstrName);

		m_hFind = ::FindFirstFile(pstrName, &m_fd);

		if(m_hFind == INVALID_HANDLE_VALUE)
			return FALSE;

		LPCTSTR pstr = _tfullpath(m_lpszRoot, pstrName, MAX_PATH);

		// passed name isn't a valid path but was found by the API
		ATLASSERT(pstr != NULL);
		if(pstr == NULL)
		{
			Close();
			::SetLastError(ERROR_INVALID_NAME);
			return FALSE;
		}
		else
		{
			// find the last forward or backward whack
			LPTSTR pstrBack  = _tcsrchr(m_lpszRoot, '\\');
			LPTSTR pstrFront = _tcsrchr(m_lpszRoot, '/');

			if(pstrFront != NULL || pstrBack != NULL)
			{
				if(pstrFront == NULL)
					pstrFront = m_lpszRoot;
				if(pstrBack == NULL)
					pstrBack = m_lpszRoot;

				// from the start to the last whack is the root

				if(pstrFront >= pstrBack)
					*pstrFront = '\0';
				else
					*pstrBack = '\0';
			}
		}

		m_bFound = TRUE;

		return TRUE;
	}

	BOOL FindNextFile()
	{
		ATLASSERT(m_hFind != NULL);

		if(m_hFind == NULL)
			return FALSE;

		if(!m_bFound)
			return FALSE;

		m_bFound = ::FindNextFile(m_hFind, &m_fd);

		return m_bFound;
	}
	void Close()
	{
		m_bFound = FALSE;

		if(m_hFind != NULL && m_hFind != INVALID_HANDLE_VALUE)
		{
			::FindClose(m_hFind);
			m_hFind = NULL;
		}
	}
};


/////////////////////////////////////////////////////////////////////////////
// Global functions for loading resources

inline HACCEL AtlLoadAccelerators(_U_STRINGorID table)
{
	return ::LoadAccelerators(_Module.GetResourceInstance(), table.m_lpstr);
}

inline HMENU AtlLoadMenu(_U_STRINGorID menu)
{
	return ::LoadMenu(_Module.GetResourceInstance(), menu.m_lpstr);
}

inline HBITMAP AtlLoadBitmap(_U_STRINGorID bitmap)
{
	return ::LoadBitmap(_Module.GetResourceInstance(), bitmap.m_lpstr);
}

#ifdef OEMRESOURCE
inline HBITMAP AtlLoadSysBitmap(LPCTSTR lpBitmapName)
{
#ifdef _DEBUG
	WORD wID = (WORD)lpBitmapName;
	ATLASSERT(wID >= 32734 && wID <= 32767);
#endif //_DEBUG
	return ::LoadBitmap(NULL, lpBitmapName);
}
#endif //OEMRESOURCE

inline HCURSOR AtlLoadCursor(_U_STRINGorID cursor)
{
	return ::LoadCursor(_Module.GetResourceInstance(), cursor.m_lpstr);
}

inline HCURSOR AtlLoadSysCursor(LPCTSTR lpCursorName)
{
	ATLASSERT(lpCursorName == IDC_ARROW || lpCursorName == IDC_IBEAM || lpCursorName == IDC_WAIT ||
		lpCursorName == IDC_CROSS || lpCursorName == IDC_UPARROW || lpCursorName == IDC_SIZE ||
		lpCursorName == IDC_ICON || lpCursorName == IDC_SIZENWSE || lpCursorName == IDC_SIZENESW ||
		lpCursorName == IDC_SIZEWE || lpCursorName == IDC_SIZENS || lpCursorName == IDC_SIZEALL ||
		lpCursorName == IDC_NO || lpCursorName == IDC_APPSTARTING || lpCursorName == IDC_HELP);
	return ::LoadCursor(NULL, lpCursorName);
}

inline HICON AtlLoadIcon(_U_STRINGorID icon)
{
	return ::LoadIcon(_Module.GetResourceInstance(), icon.m_lpstr);
}

inline HICON AtlLoadSysIcon(LPCTSTR lpIconName)
{
	ATLASSERT(lpIconName == IDI_APPLICATION ||
		lpIconName == IDI_ASTERISK ||
		lpIconName == IDI_EXCLAMATION ||
		lpIconName == IDI_HAND ||
		lpIconName == IDI_QUESTION ||
		lpIconName == IDI_WINLOGO);
	return ::LoadIcon(NULL, lpIconName);
}

inline HBITMAP AtlLoadBitmapImage(_U_STRINGorID bitmap, UINT fuLoad = LR_DEFAULTCOLOR)
{
	return (HBITMAP)::LoadImage(_Module.GetResourceInstance(), bitmap.m_lpstr, IMAGE_BITMAP, 0, 0, fuLoad);
}

inline HCURSOR AtlLoadCursorImage(_U_STRINGorID cursor, UINT fuLoad = LR_DEFAULTCOLOR | LR_DEFAULTSIZE, int cxDesired = 0, int cyDesired = 0)
{
	return (HCURSOR)::LoadImage(_Module.GetResourceInstance(), cursor.m_lpstr, IMAGE_CURSOR, cxDesired, cyDesired, fuLoad);
}

inline HICON AtlLoadIconImage(_U_STRINGorID icon, UINT fuLoad = LR_DEFAULTCOLOR | LR_DEFAULTSIZE, int cxDesired = 0, int cyDesired = 0)
{
	return (HICON)::LoadImage(_Module.GetResourceInstance(), icon.m_lpstr, IMAGE_ICON, cxDesired, cyDesired, fuLoad);
}

#ifdef OEMRESOURCE
inline HBITMAP AtlLoadSysBitmapImage(WORD wBitmapID, UINT fuLoad = LR_DEFAULTCOLOR)
{
	ATLASSERT(wBitmapID >= 32734 && wBitmapID <= 32767);
	ATLASSERT((fuLoad & LR_LOADFROMFILE) == 0);	// this one doesn't load from a file
	return (HBITMAP)::LoadImage(NULL, MAKEINTRESOURCE(wBitmapID), IMAGE_BITMAP, 0, 0, fuLoad);
}
#endif //OEMRESOURCE

inline HCURSOR AtlLoadSysCursorImage(_U_STRINGorID cursor, UINT fuLoad = LR_DEFAULTCOLOR | LR_DEFAULTSIZE, int cxDesired = 0, int cyDesired = 0)
{
#ifdef _DEBUG
	WORD wID = (WORD)cursor.m_lpstr;
	ATLASSERT((wID >= 32512 && wID <= 32516) || (wID >= 32640 && wID <= 32648) || (wID == 32650) || (wID == 32651));
	ATLASSERT((fuLoad & LR_LOADFROMFILE) == 0);	// this one doesn't load from a file
#endif //_DEBUG
	return (HCURSOR)::LoadImage(NULL, cursor.m_lpstr, IMAGE_CURSOR, cxDesired, cyDesired, fuLoad);
}

inline HICON AtlLoadSysIconImage(_U_STRINGorID icon, UINT fuLoad = LR_DEFAULTCOLOR | LR_DEFAULTSIZE, int cxDesired = 0, int cyDesired = 0)
{
#ifdef _DEBUG
	WORD wID = (WORD)icon.m_lpstr;
	ATLASSERT(wID >= 32512 && wID <= 32517);
	ATLASSERT((fuLoad & LR_LOADFROMFILE) == 0);	// this one doesn't load from a file
#endif //_DEBUG
	return (HICON)::LoadImage(NULL, icon.m_lpstr, IMAGE_ICON, cxDesired, cyDesired, fuLoad);
}

inline int AtlLoadString(UINT uID, LPTSTR lpBuffer, int nBufferMax)
{
	return ::LoadString(_Module.GetResourceInstance(), uID, lpBuffer, nBufferMax);
}

inline bool AtlLoadString(UINT uID, BSTR& bstrText)
{
	USES_CONVERSION;
	ATLASSERT(bstrText == NULL);

	LPTSTR lpstrText = NULL;
	int nRes = 0;
	for(int nLen = 256; ; nLen *= 2)
	{
		ATLTRY(lpstrText = new TCHAR[nLen]);
		if(lpstrText == NULL)
			break;
		nRes = ::LoadString(_Module.GetResourceInstance(), uID, lpstrText, nLen);
		if(nRes < nLen - 1)
			break;
		delete [] lpstrText;
		lpstrText = NULL;
	}

	if(lpstrText != NULL)
	{
		if(nRes != 0)
			bstrText = ::SysAllocString(T2OLE(lpstrText));
		delete [] lpstrText;
	}

	return (bstrText != NULL) ? true : false;
}


/////////////////////////////////////////////////////////////////////////////
// Global functions for stock GDI objects

inline HPEN AtlGetStockPen(int nPen)
{
#if (_WIN32_WINNT >= 0x0500)
	ATLASSERT(nPen == WHITE_PEN || nPen == BLACK_PEN || nPen == NULL_PEN || nPen == DC_PEN);
#else
	ATLASSERT(nPen == WHITE_PEN || nPen == BLACK_PEN || nPen == NULL_PEN);
#endif //!(_WIN32_WINNT >= 0x0500)
	return (HPEN)::GetStockObject(nPen);
}

inline HBRUSH AtlGetStockBrush(int nBrush)
{
#if (_WIN32_WINNT >= 0x0500)
	ATLASSERT((nBrush >= WHITE_BRUSH && nBrush <= HOLLOW_BRUSH) || nBrush == DC_BRUSH);
#else
	ATLASSERT(nBrush >= WHITE_BRUSH && nBrush <= HOLLOW_BRUSH);
#endif //!(_WIN32_WINNT >= 0x0500)
	return (HBRUSH)::GetStockObject(nBrush);
}

inline HFONT AtlGetStockFont(int nFont)
{
	ATLASSERT((nFont >= OEM_FIXED_FONT && nFont <= SYSTEM_FIXED_FONT) || nFont == DEFAULT_GUI_FONT);
	return (HFONT)::GetStockObject(nFont);
}

inline HPALETTE AtlGetStockPalette(int nPalette)
{
	ATLASSERT(nPalette == DEFAULT_PALETTE); // the only one supported
	return (HPALETTE)::GetStockObject(nPalette);
}


/////////////////////////////////////////////////////////////////////////////
// Global function for compacting a path by replacing parts with ellipsis

// helper for multi-byte character sets
inline bool _IsDBCSTrailByte(LPCTSTR lpstr, int nChar)
{
#ifndef _UNICODE
	for(int i = nChar; i > 0; i--)
	{
		if(!::IsDBCSLeadByte(lpstr[i - 1]))
			break;
	}
	return ((nChar > 0) && (((nChar - i) & 1) != 0));
#else //_UNICODE
	lpstr;	nChar;
	return false;
#endif //_UNICODE
}

inline bool AtlCompactPath(LPTSTR lpstrOut, LPCTSTR lpstrIn, int cchLen)
{
	ATLASSERT(lpstrOut != NULL);
	ATLASSERT(lpstrIn != NULL);
	ATLASSERT(cchLen > 0);

	LPCTSTR szEllipsis = _T("...");
	const int cchEndEllipsis = 3;
	const int cchMidEllipsis = 4;

	if(lstrlen(lpstrIn) + 1 < cchLen)
		return (lstrcpy(lpstrOut, lpstrIn) != NULL);

	// check if the separator is a slash or a backslash
	TCHAR chSlash = _T('\\');
	for(LPTSTR lpstr = (LPTSTR)lpstrIn; *lpstr != 0; lpstr = ::CharNext(lpstr))
	{
		if((*lpstr == _T('/')) || (*lpstr == _T('\\')))
			chSlash = *lpstr;
	}

	// find the filename portion of the path
	LPCTSTR lpstrFileName = lpstrIn;
	for(LPCTSTR pPath = lpstrIn; *pPath; pPath = ::CharNext(pPath))
	{
		if((pPath[0] == _T('\\') || pPath[0] == _T(':') || pPath[0] == _T('/'))
				&& pPath[1] && pPath[1] != _T('\\') && pPath[1] != _T('/'))
			lpstrFileName = pPath + 1;
	}
	int cchFileName = lstrlen(lpstrFileName);

	// handle just the filename without a path
	if(lpstrFileName == lpstrIn && cchLen > cchEndEllipsis)
	{
		bool bRet = (lstrcpyn(lpstrOut, lpstrIn, cchLen - cchEndEllipsis) != NULL);
		if(bRet)
		{
#ifndef _UNICODE
			if(_IsDBCSTrailByte(lpstrIn, cchLen - cchEndEllipsis))
				lpstrOut[cchLen - cchEndEllipsis - 1] = 0;
#endif //_UNICODE
			bRet = (lstrcat(lpstrOut, szEllipsis) != NULL);
		}
		return bRet;
	}

	// handle just ellipsis
	if((cchLen < (cchMidEllipsis + cchEndEllipsis)))
	{
		for(int i = 0; i < cchLen - 1; i++)
			lpstrOut[i] = ((i + 1) == cchMidEllipsis) ? chSlash : _T('.');
		lpstrOut[i] = 0;
		return true;
	}

	// calc how much we have to copy
	int cchToCopy = cchLen - (cchMidEllipsis + cchFileName);

	if(cchToCopy < 0)
		cchToCopy = 0;

#ifndef _UNICODE
	if(cchToCopy > 0 && _IsDBCSTrailByte(lpstrIn, cchToCopy))
		cchToCopy--;
#endif //_UNICODE

	bool bRet = (lstrcpyn(lpstrOut, lpstrIn, cchToCopy) != NULL);
	if(!bRet)
		return false;

	// add ellipsis
	bRet = (lstrcat(lpstrOut, szEllipsis) != NULL);
	if(!bRet)
		return false;
	TCHAR szSlash[2] = { chSlash, 0 };
	bRet = (lstrcat(lpstrOut, szSlash) != NULL);
	if(!bRet)
		return false;

	// add filename (and ellipsis, if needed)
	if(cchLen > (cchMidEllipsis + cchFileName))
	{
		bRet = (lstrcat(lpstrOut, lpstrFileName) != NULL);
	}
	else
	{
		cchToCopy = cchLen - cchMidEllipsis - cchEndEllipsis;
#ifndef _UNICODE
		if(cchToCopy > 0 && _IsDBCSTrailByte(lpstrFileName, cchToCopy))
			cchToCopy--;
#endif //_UNICODE
		bRet = (lstrcpyn(&lpstrOut[cchMidEllipsis], lpstrFileName, cchToCopy) != NULL);
		if(bRet)
			bRet = (lstrcat(lpstrOut, szEllipsis) != NULL);
	}

	return bRet;
}

}; //namespace WTL

#endif // __ATLMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wtl10\atlscrl.h ===
// WTL Version 3.1
// Copyright (C) 1997-2000 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLSCRL_H__
#define __ATLSCRL_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlscrl.h requires atlapp.h to be included first
#endif

#ifndef __ATLWIN_H__
	#error atlscrl.h requires atlwin.h to be included first
#endif

#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
#include <zmouse.h>
#endif //!((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T> class CScrollImpl;
template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CScrollWindowImpl;
template <class T> class CMapScrollImpl;
template <class T, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CMapScrollWindowImpl;
#if defined(__ATLCTRLS_H__) && (_WIN32_IE >= 0x0400)
template <class TBase = CWindow> class CFSBWindowT;
#endif //defined(__ATLCTRLS_H__) && (_WIN32_IE >= 0x0400)


/////////////////////////////////////////////////////////////////////////////
// CScrollImpl - Provides scrolling support to any window

// Scroll extended styles
#define SCRL_SCROLLCHILDREN	0x00000001
#define SCRL_ERASEBACKGROUND	0x00000002
#define SCRL_NOTHUMBTRACKING	0x00000004
#if (WINVER >= 0x0500)
#define SCRL_SMOOTHSCROLL	0x00000008
#endif //(WINVER >= 0x0500)


template <class T>
class CScrollImpl
{
public:
	enum { uSCROLL_FLAGS = SW_INVALIDATE };

	POINT m_ptOffset;
	SIZE m_sizeAll;
	SIZE m_sizeLine;
	SIZE m_sizePage;
	SIZE m_sizeClient;
	int m_zDelta;			// current wheel value
	int m_nWheelLines;		// number of lines to scroll on wheel
#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
	UINT m_uMsgMouseWheel;		// MSH_MOUSEWHEEL
	// Note that this message must be forwarded from a top level window
#endif //!((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
	UINT m_uScrollFlags;
	DWORD m_dwExtendedStyle;	// scroll specific extended styles

// Constructor
	CScrollImpl() : m_zDelta(0), m_nWheelLines(3), m_uScrollFlags(0U), m_dwExtendedStyle(0)
	{
		m_ptOffset.x = 0;
		m_ptOffset.y = 0;
		m_sizeAll.cx = 0;
		m_sizeAll.cy = 0;
		m_sizePage.cx = 0;
		m_sizePage.cy = 0;
		m_sizeLine.cx = 0;
		m_sizeLine.cy = 0;
		m_sizeClient.cx = 0;
		m_sizeClient.cy = 0;

		SetScrollExtendedStyle(SCRL_SCROLLCHILDREN | SCRL_ERASEBACKGROUND);
	}

// Attributes & Operations
	DWORD GetScrollExtendedStyle() const
	{
		return m_dwExtendedStyle;
	}

	DWORD SetScrollExtendedStyle(DWORD dwExtendedStyle, DWORD dwMask = 0)
	{
		DWORD dwPrevStyle = m_dwExtendedStyle;
		if(dwMask == 0)
			m_dwExtendedStyle = dwExtendedStyle;
		else
			m_dwExtendedStyle = (m_dwExtendedStyle & ~dwMask) | (dwExtendedStyle & dwMask);
		// cache scroll flags
		T* pT = static_cast<T*>(this);
		pT;	// avoid level 4 warning
		m_uScrollFlags = pT->uSCROLL_FLAGS | (IsScrollingChildren() ? SW_SCROLLCHILDREN : 0) | (IsErasingBackground() ? SW_ERASE : 0);
#if (WINVER >= 0x0500)
		m_uScrollFlags |= (IsSmoothScroll() ? SW_SMOOTHSCROLL : 0);
#endif //(WINVER >= 0x0500)
		return dwPrevStyle;
	}

	// offset operations
	void SetScrollOffset(int x, int y, BOOL bRedraw = TRUE)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));

		m_ptOffset.x = x;
		m_ptOffset.y = y;

		SCROLLINFO si;
		si.cbSize = sizeof(si);
		si.fMask = SIF_POS;

		si.nPos = m_ptOffset.x;
		pT->SetScrollInfo(SB_HORZ, &si, bRedraw);

		si.nPos = m_ptOffset.y;
		pT->SetScrollInfo(SB_VERT, &si, bRedraw);

		if(bRedraw)
			pT->Invalidate();
	}
	void SetScrollOffset(POINT ptOffset, BOOL bRedraw = TRUE)
	{
		SetScrollOffset(ptOffset.x, ptOffset.y, bRedraw);
	}
	void GetScrollOffset(POINT& ptOffset) const
	{
		ptOffset = m_ptOffset;
	}

	// size operations
	void SetScrollSize(int cx, int cy, BOOL bRedraw = TRUE)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));

		m_sizeAll.cx = cx;
		m_sizeAll.cy = cy;

		m_ptOffset.x = 0;
		m_ptOffset.y = 0;

		SCROLLINFO si;
		si.cbSize = sizeof(si);
		si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
		si.nMin = 0;

		si.nMax = m_sizeAll.cx - 1;
		si.nPage = m_sizeClient.cx;
		si.nPos = m_ptOffset.x;
		pT->SetScrollInfo(SB_HORZ, &si, bRedraw);

		si.nMax = m_sizeAll.cy - 1;
		si.nPage = m_sizeClient.cy;
		si.nPos = m_ptOffset.y;
		pT->SetScrollInfo(SB_VERT, &si, bRedraw);

		SetScrollLine(0, 0);
		SetScrollPage(0, 0);

		if(bRedraw)
			pT->Invalidate();
	}
	void SetScrollSize(SIZE size, BOOL bRedraw = TRUE)
	{
		SetScrollSize(size.cx, size.cy, bRedraw);
	}
	void GetScrollSize(SIZE& sizeWnd) const
	{
		sizeWnd = m_sizeAll;
	}

	// line operations
	void SetScrollLine(int cxLine, int cyLine)
	{
		ATLASSERT(cxLine >= 0 && cyLine >= 0);
		ATLASSERT(m_sizeAll.cx != 0 && m_sizeAll.cy != 0);

		m_sizeLine.cx = CalcLineOrPage(cxLine, m_sizeAll.cx, 100);
		m_sizeLine.cy = CalcLineOrPage(cyLine, m_sizeAll.cy, 100);
	}
	void SetScrollLine(SIZE sizeLine)
	{
		SetScrollLine(sizeLine.cx, sizeLine.cy);
	}
	void GetScrollLine(SIZE& sizeLine) const
	{
		sizeLine = m_sizeLine;
	}

	// page operations
	void SetScrollPage(int cxPage, int cyPage)
	{
		ATLASSERT(cxPage >= 0 && cyPage >= 0);
		ATLASSERT(m_sizeAll.cx != 0 && m_sizeAll.cy != 0);

		m_sizePage.cx = CalcLineOrPage(cxPage, m_sizeAll.cx, 10);
		m_sizePage.cy = CalcLineOrPage(cyPage, m_sizeAll.cy, 10);
	}
	void SetScrollPage(SIZE sizePage)
	{
		SetScrollPage(sizePage.cx, sizePage.cy);
	}
	void GetScrollPage(SIZE& sizePage) const
	{
		sizePage = m_sizePage;
	}

	// commands
	void ScrollLineDown()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_VERT, SB_LINEDOWN, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
	}

	void ScrollLineUp()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_VERT, SB_LINEUP, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
	}

	void ScrollPageDown()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_VERT, SB_PAGEDOWN, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
	}

	void ScrollPageUp()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_VERT, SB_PAGEUP, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
	}

	void ScrollTop()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_VERT, SB_TOP, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
	}

	void ScrollBottom()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_VERT, SB_BOTTOM, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
	}

	void ScrollLineRight()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_HORZ, SB_LINEDOWN, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
	}

	void ScrollLineLeft()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_HORZ, SB_LINEUP, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
	}

	void ScrollPageRight()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_HORZ, SB_PAGEDOWN, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
	}

	void ScrollPageLeft()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_HORZ, SB_PAGEUP, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
	}

	void ScrollAllLeft()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_HORZ, SB_TOP, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
	}

	void ScrollAllRight()
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_HORZ, SB_BOTTOM, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
	}

	BEGIN_MSG_MAP(CScrollImpl< T >)
		MESSAGE_HANDLER(WM_CREATE, OnCreate)
		MESSAGE_HANDLER(WM_VSCROLL, OnVScroll)
		MESSAGE_HANDLER(WM_HSCROLL, OnHScroll)
		MESSAGE_HANDLER(WM_MOUSEWHEEL, OnMouseWheel)
#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
		MESSAGE_HANDLER(m_uMsgMouseWheel, OnMouseWheel)
#endif //(_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
		MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
		MESSAGE_HANDLER(WM_PAINT, OnPaint)
		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
	// standard scroll commands
	ALT_MSG_MAP(1)
		COMMAND_ID_HANDLER(ID_SCROLL_UP, OnScrollUp)
		COMMAND_ID_HANDLER(ID_SCROLL_DOWN, OnScrollDown)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_UP, OnScrollPageUp)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_DOWN, OnScrollPageDown)
		COMMAND_ID_HANDLER(ID_SCROLL_TOP, OnScrollTop)
		COMMAND_ID_HANDLER(ID_SCROLL_BOTTOM, OnScrollBottom)
		COMMAND_ID_HANDLER(ID_SCROLL_LEFT, OnScrollLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_RIGHT, OnScrollRight)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_LEFT, OnScrollPageLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_RIGHT, OnScrollPageRight)
		COMMAND_ID_HANDLER(ID_SCROLL_ALL_LEFT, OnScrollAllLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_ALL_RIGHT, OnScrollAllRight)
	END_MSG_MAP()

	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		GetSystemSettings();
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnVScroll(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_VERT, (int)(short)LOWORD(wParam), (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
		return 0;
	}

	LRESULT OnHScroll(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		pT->DoScroll(SB_HORZ, (int)(short)LOWORD(wParam), (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
		return 0;
	}

	LRESULT OnMouseWheel(UINT uMsg, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));

#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
		uMsg;
		int zDelta = (int)(short)HIWORD(wParam);
#else
		int zDelta = (uMsg == WM_MOUSEWHEEL) ? (int)(short)HIWORD(wParam) : (int)wParam;
#endif //!((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
		int nScrollCode = (m_nWheelLines == WHEEL_PAGESCROLL) ? ((zDelta > 0) ? SB_PAGEUP : SB_PAGEDOWN) : ((zDelta > 0) ? SB_LINEUP : SB_LINEDOWN);
		m_zDelta += zDelta;		// cumulative
		int zTotal = (m_nWheelLines == WHEEL_PAGESCROLL) ? abs(m_zDelta) : abs(m_zDelta) * m_nWheelLines;
		if((pT->GetStyle() & WS_VSCROLL) != 0)
		{
			for(short i = 0; i < zTotal; i += WHEEL_DELTA)
			{
				pT->DoScroll(SB_VERT, nScrollCode, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
				pT->UpdateWindow();
			}
		}
		else		// can't scroll vertically, scroll horizontally
		{
			for(short i = 0; i < zTotal; i += WHEEL_DELTA)
			{
				pT->DoScroll(SB_HORZ, nScrollCode, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
				pT->UpdateWindow();
			}
		}
		int nSteps = m_zDelta / WHEEL_DELTA;
		m_zDelta -= nSteps * WHEEL_DELTA;

		return 0;
	}

	LRESULT OnSettingChange(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		GetSystemSettings();
		return 0;
	}

	LRESULT OnSize(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));

		m_sizeClient.cx = GET_X_LPARAM(lParam);
		m_sizeClient.cy = GET_Y_LPARAM(lParam);

		SCROLLINFO si;
		si.cbSize = sizeof(si);
		si.fMask = SIF_PAGE | SIF_POS;

		si.nPage = m_sizeClient.cx;
		si.nPos = m_ptOffset.x;
		pT->SetScrollInfo(SB_HORZ, &si, FALSE);

		si.nPage = m_sizeClient.cy;
		si.nPos = m_ptOffset.y;
		pT->SetScrollInfo(SB_VERT, &si, FALSE);

		bool bUpdate = false;
		int cxMax = m_sizeAll.cx - m_sizeClient.cx;
		int cyMax = m_sizeAll.cy - m_sizeClient.cy;
		int x = m_ptOffset.x;
		int y = m_ptOffset.y;
		if(m_ptOffset.x > cxMax)
		{
			bUpdate = true;
			x = (cxMax >= 0) ? cxMax : 0;
		}
		if(m_ptOffset.y > cyMax)
		{
			bUpdate = true;
			y = (cyMax >= 0) ? cyMax : 0;
		}
		if(bUpdate)
			SetScrollOffset(x, y);

		bHandled = FALSE;
		return 1;
	}

	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		if(wParam != NULL)
		{
			CDCHandle dc = (HDC)wParam;
			dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y);
			pT->DoPaint(dc);
		}
		else
		{
			CPaintDC dc(pT->m_hWnd);
			dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y);
			pT->DoPaint(dc.m_hDC);
		}
		return 0;
	}

	// scrolling handlers
	LRESULT OnScrollUp(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollLineUp();
		return 0;
	}
	LRESULT OnScrollDown(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollLineDown();
		return 0;
	}
	LRESULT OnScrollPageUp(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollPageUp();
		return 0;
	}
	LRESULT OnScrollPageDown(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollPageDown();
		return 0;
	}
	LRESULT OnScrollTop(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollTop();
		return 0;
	}
	LRESULT OnScrollBottom(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollBottom();
		return 0;
	}
	LRESULT OnScrollLeft(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollLineLeft();
		return 0;
	}
	LRESULT OnScrollRight(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollLineRight();
		return 0;
	}
	LRESULT OnScrollPageLeft(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollPageLeft();
		return 0;
	}
	LRESULT OnScrollPageRight(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollPageRight();
		return 0;
	}
	LRESULT OnScrollAllLeft(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollAllLeft();
		return 0;
	}
	LRESULT OnScrollAllRight(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		ScrollAllRight();
		return 0;
	}

// Overrideables
	void DoPaint(CDCHandle /*dc*/)
	{
		// must be implemented in a derived class
		ATLASSERT(FALSE);
	}

// Implementation
	void DoScroll(int nType, int nScrollCode, int& cxyOffset, int cxySizeAll, int cxySizePage, int cxySizeLine)
	{
		T* pT = static_cast<T*>(this);
		RECT rect;
		pT->GetClientRect(&rect);
		int cxyClient = (nType == SB_VERT) ? rect.bottom : rect.right;
		int cxyMax = cxySizeAll - cxyClient;

		if(cxyMax < 0)		// can't scroll, client area is bigger
			return;

		BOOL bUpdate = TRUE;
		int cxyScroll = 0;

		switch(nScrollCode)
		{
		case SB_TOP:		// top or all left
			cxyScroll = cxyOffset;
			cxyOffset = 0;
			break;
		case SB_BOTTOM:		// bottom or all right
			cxyScroll = cxyOffset - cxyMax;
			cxyOffset = cxyMax;
			break;
		case SB_LINEUP:		// line up or line left
			if(cxyOffset >= cxySizeLine)
			{
				cxyScroll = cxySizeLine;
				cxyOffset -= cxySizeLine;
			}
			else
			{
				cxyScroll = cxyOffset;
				cxyOffset = 0;
			}
			break;
		case SB_LINEDOWN:	// line down or line right
			if(cxyOffset < cxyMax - cxySizeLine)
			{
				cxyScroll = -cxySizeLine;
				cxyOffset += cxySizeLine;
			}
			else
			{
				cxyScroll = cxyOffset - cxyMax;
				cxyOffset = cxyMax;
			}
			break;
		case SB_PAGEUP:		// page up or page left
			if(cxyOffset >= cxySizePage)
			{
				cxyScroll = cxySizePage;
				cxyOffset -= cxySizePage;
			}
			else
			{
				cxyScroll = cxyOffset;
				cxyOffset = 0;
			}
			break;
		case SB_PAGEDOWN:	// page down or page right
			if(cxyOffset < cxyMax - cxySizePage)
			{
				cxyScroll = -cxySizePage;
				cxyOffset += cxySizePage;
			}
			else
			{
				cxyScroll = cxyOffset - cxyMax;
				cxyOffset = cxyMax;
			}
			break;
		case SB_THUMBTRACK:
			if(IsNoThumbTracking())
				break;
			// else fall through
		case SB_THUMBPOSITION:
			{
				SCROLLINFO si;
				si.cbSize = sizeof(SCROLLINFO);
				si.fMask = SIF_TRACKPOS;
				if(pT->GetScrollInfo(nType, &si))
				{
					cxyScroll = cxyOffset - si.nTrackPos;
					cxyOffset = si.nTrackPos;
				}
			}
			break;
		case SB_ENDSCROLL:
		default:
			bUpdate = FALSE;
			break;
		}

		if(bUpdate && cxyScroll != 0)
		{
			pT->SetScrollPos(nType, cxyOffset, TRUE);
			if(nType == SB_VERT)
				pT->ScrollWindowEx(0, cxyScroll, m_uScrollFlags);
			else
				pT->ScrollWindowEx(cxyScroll, 0, m_uScrollFlags);
		}
	}
	int CalcLineOrPage(int nVal, int nMax, int nDiv)
	{
		if(nVal == 0)
		{
			nVal = nMax / nDiv;
			if(nVal < 1)
				nVal = 1;
		}
		else if(nVal > nMax)
			nVal = nMax;

		return nVal;
	}
	void GetSystemSettings()
	{
#ifndef SPI_GETWHEELSCROLLLINES
		const UINT SPI_GETWHEELSCROLLLINES = 104;
#endif //!SPI_GETWHEELSCROLLLINES
		::SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &m_nWheelLines, 0);

#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
		if(m_uMsgMouseWheel != 0)
			m_uMsgMouseWheel = ::RegisterWindowMessage(MSH_MOUSEWHEEL);

		HWND hWndWheel = FindWindow(MSH_WHEELMODULE_CLASS, MSH_WHEELMODULE_TITLE);
		if(::IsWindow(hWndWheel))
		{
			UINT uMsgScrollLines = ::RegisterWindowMessage(MSH_SCROLL_LINES);
			if(uMsgScrollLines != 0)
				m_nWheelLines = ::SendMessage(hWndWheel, uMsgScrollLines, 0, 0L);
		}
#endif //!((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
	}
	bool IsScrollingChildren() const
	{
		return (m_dwExtendedStyle & SCRL_SCROLLCHILDREN) != 0;
	}
	bool IsErasingBackground() const
	{
		return (m_dwExtendedStyle & SCRL_ERASEBACKGROUND) != 0;
	}
	bool IsNoThumbTracking() const
	{
		return (m_dwExtendedStyle & SCRL_NOTHUMBTRACKING) != 0;
	}
#if (WINVER >= 0x0500)
	bool IsSmoothScroll() const
	{
		return (m_dwExtendedStyle & SCRL_SMOOTHSCROLL) != 0;
	}
#endif //(WINVER >= 0x0500)
};


/////////////////////////////////////////////////////////////////////////////
// CScrollWindowImpl - Implements a scrollable window

template <class T, class TBase /*= CWindow */, class TWinTraits /*= CControlWinTraits */ >
class ATL_NO_VTABLE CScrollWindowImpl : public CWindowImpl<T, TBase, TWinTraits>, public CScrollImpl< T >
{
public:
	BEGIN_MSG_MAP(CScrollImpl< T >)
		MESSAGE_HANDLER(WM_VSCROLL, CScrollImpl< T >::OnVScroll)
		MESSAGE_HANDLER(WM_HSCROLL, CScrollImpl< T >::OnHScroll)
		MESSAGE_HANDLER(WM_MOUSEWHEEL, CScrollImpl< T >::OnMouseWheel)
#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
		MESSAGE_HANDLER(m_uMsgMouseWheel, CScrollImpl< T >::OnMouseWheel)
#endif //(_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
		MESSAGE_HANDLER(WM_SETTINGCHANGE, CScrollImpl< T >::OnSettingChange)
		MESSAGE_HANDLER(WM_SIZE, CScrollImpl< T >::OnSize)
		MESSAGE_HANDLER(WM_PAINT, CScrollImpl< T >::OnPaint)
		MESSAGE_HANDLER(WM_PRINTCLIENT, CScrollImpl< T >::OnPaint)
	ALT_MSG_MAP(1)
		COMMAND_ID_HANDLER(ID_SCROLL_UP, CScrollImpl< T >::OnScrollUp)
		COMMAND_ID_HANDLER(ID_SCROLL_DOWN, CScrollImpl< T >::OnScrollDown)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_UP, CScrollImpl< T >::OnScrollPageUp)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_DOWN, CScrollImpl< T >::OnScrollPageDown)
		COMMAND_ID_HANDLER(ID_SCROLL_TOP, CScrollImpl< T >::OnScrollTop)
		COMMAND_ID_HANDLER(ID_SCROLL_BOTTOM, CScrollImpl< T >::OnScrollBottom)
		COMMAND_ID_HANDLER(ID_SCROLL_LEFT, CScrollImpl< T >::OnScrollLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_RIGHT, CScrollImpl< T >::OnScrollRight)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_LEFT, CScrollImpl< T >::OnScrollPageLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_RIGHT, CScrollImpl< T >::OnScrollPageRight)
		COMMAND_ID_HANDLER(ID_SCROLL_ALL_LEFT, CScrollImpl< T >::OnScrollAllLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_ALL_RIGHT, CScrollImpl< T >::OnScrollAllRight)
	END_MSG_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CMapScrollImpl - Provides mapping and scrolling support to any window

template <class T>
class CMapScrollImpl : public CScrollImpl< T >
{
public:
	int m_nMapMode;
	RECT m_rectLogAll;
	SIZE m_sizeLogLine;
	SIZE m_sizeLogPage;

// Constructor
	CMapScrollImpl() : m_nMapMode(MM_TEXT)
	{
		::SetRectEmpty(&m_rectLogAll);
		m_sizeLogPage.cx = 0;
		m_sizeLogPage.cy = 0;
		m_sizeLogLine.cx = 0;
		m_sizeLogLine.cy = 0;
	}

// Attributes & Operations
	// mapping mode operations
	void SetScrollMapMode(int nMapMode)
	{
		ATLASSERT(nMapMode >= MM_MIN && nMapMode <= MM_MAX_FIXEDSCALE);
		m_nMapMode = nMapMode;
	}
	int GetScrollMapMode() const
	{
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
		return m_nMapMode;
	}

	// offset operations
	void SetScrollOffset(int x, int y, BOOL bRedraw = TRUE)
	{
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
		POINT ptOff = { x, y };
		// block: convert logical to device units
		{
			CWindowDC dc(NULL);
			dc.SetMapMode(m_nMapMode);
			dc.LPtoDP(&ptOff);
		}
		CScrollImpl< T >::SetScrollOffset(ptOff, bRedraw);
	}
	void SetScrollOffset(POINT ptOffset, BOOL bRedraw = TRUE)
	{
		SetScrollOffset(ptOffset.x, ptOffset.y, bRedraw);
	}
	void GetScrollOffset(POINT& ptOffset) const
	{
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
		ptOffset = m_ptOffset;
		// block: convert logical to device units
		{
			CWindowDC dc(NULL);
			dc.SetMapMode(m_nMapMode);
			dc.DPtoLP(&ptOffset);
		}
	}

	// size operations
	void SetScrollSize(int xMin, int yMin, int xMax, int yMax, BOOL bRedraw = TRUE)
	{
		ATLASSERT(xMax > xMin && yMax > yMin);
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);

		::SetRect(&m_rectLogAll, xMin, yMax, xMax, yMin);

		SIZE sizeAll;
		sizeAll.cx = xMax - xMin + 1;
		sizeAll.cy = yMax - xMin + 1;
		// block: convert logical to device units
		{
			CWindowDC dc(NULL);
			dc.SetMapMode(m_nMapMode);
			dc.LPtoDP(&sizeAll);
		}
		CScrollImpl< T >::SetScrollSize(sizeAll, bRedraw);
		SetScrollLine(0, 0);
		SetScrollPage(0, 0);
	}
	void SetScrollSize(RECT& rcScroll, BOOL bRedraw = TRUE)
	{
		SetScrollSize(rcScroll.left, rcScroll.top, rcScroll.right, rcScroll.bottom, bRedraw);
	}
	void SetScrollSize(int cx, int cy, BOOL bRedraw = TRUE)
	{
		SetScrollSize(0, 0, cx, cy, bRedraw);
	}
	void SetScrollSize(SIZE size, BOOL bRedraw = NULL)
	{
		SetScrollSize(0, 0, size.cx, size.cy, bRedraw);
	}
	void GetScrollSize(RECT& rcScroll) const
	{
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
		rcScroll = m_rectLogAll;
	}

	// line operations
	void SetScrollLine(int cxLine, int cyLine)
	{
		ATLASSERT(cxLine >= 0 && cyLine >= 0);
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);

		m_sizeLogLine.cx = cxLine;
		m_sizeLogLine.cy = cyLine;
		SIZE sizeLine = m_sizeLogLine;
		// block: convert logical to device units
		{
			CWindowDC dc(NULL);
			dc.SetMapMode(m_nMapMode);
			dc.LPtoDP(&sizeLine);
		}
		CScrollImpl< T >::SetScrollLine(sizeLine);
	}
	void SetScrollLine(SIZE sizeLine)
	{
		SetScrollLine(sizeLine.cx, sizeLine.cy);
	}
	void GetScrollLine(SIZE& sizeLine) const
	{
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
		sizeLine = m_sizeLogLine;
	}

	// page operations
	void SetScrollPage(int cxPage, int cyPage)
	{
		ATLASSERT(cxPage >= 0 && cyPage >= 0);
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);

		m_sizeLogPage.cx = cxPage;
		m_sizeLogPage.cy = cyPage;
		SIZE sizePage = m_sizeLogPage;
		// block: convert logical to device units
		{
			CWindowDC dc(NULL);
			dc.SetMapMode(m_nMapMode);
			dc.LPtoDP(&sizePage);
		}
		CScrollImpl< T >::SetScrollPage(sizePage);
	}
	void SetScrollPage(SIZE sizePage)
	{
		SetScrollPage(sizePage.cx, sizePage.cy);
	}
	void GetScrollPage(SIZE& sizePage) const
	{
		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
		sizePage = m_sizeLogPage;
	}

	BEGIN_MSG_MAP(CMapScrollImpl< T >)
		MESSAGE_HANDLER(WM_VSCROLL, CScrollImpl< T >::OnVScroll)
		MESSAGE_HANDLER(WM_HSCROLL, CScrollImpl< T >::OnHScroll)
		MESSAGE_HANDLER(WM_MOUSEWHEEL, CScrollImpl< T >::OnMouseWheel)
#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
		MESSAGE_HANDLER(m_uMsgMouseWheel, CScrollImpl< T >::OnMouseWheel)
#endif //(_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
		MESSAGE_HANDLER(WM_SETTINGCHANGE, CScrollImpl< T >::OnSettingChange)
		MESSAGE_HANDLER(WM_SIZE, CScrollImpl< T >::OnSize)
		MESSAGE_HANDLER(WM_PAINT, OnPaint)
		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
	ALT_MSG_MAP(1)
		COMMAND_ID_HANDLER(ID_SCROLL_UP, CScrollImpl< T >::OnScrollUp)
		COMMAND_ID_HANDLER(ID_SCROLL_DOWN, CScrollImpl< T >::OnScrollDown)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_UP, CScrollImpl< T >::OnScrollPageUp)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_DOWN, CScrollImpl< T >::OnScrollPageDown)
		COMMAND_ID_HANDLER(ID_SCROLL_TOP, CScrollImpl< T >::OnScrollTop)
		COMMAND_ID_HANDLER(ID_SCROLL_BOTTOM, CScrollImpl< T >::OnScrollBottom)
		COMMAND_ID_HANDLER(ID_SCROLL_LEFT, CScrollImpl< T >::OnScrollLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_RIGHT, CScrollImpl< T >::OnScrollRight)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_LEFT, CScrollImpl< T >::OnScrollPageLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_RIGHT, CScrollImpl< T >::OnScrollPageRight)
		COMMAND_ID_HANDLER(ID_SCROLL_ALL_LEFT, CScrollImpl< T >::OnScrollAllLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_ALL_RIGHT, CScrollImpl< T >::OnScrollAllRight)
	END_MSG_MAP()

	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		ATLASSERT(::IsWindow(pT->m_hWnd));
		if(wParam != NULL)
		{
			CDCHandle dc = (HDC)wParam;
			dc.SetMapMode(m_nMapMode);
			if(m_nMapMode == MM_TEXT)
				dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y);
			else
				dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y + m_sizeAll.cy);
			dc.SetWindowOrg(m_rectLogAll.left, m_rectLogAll.bottom);
			pT->DoPaint(dc);
		}
		else
		{
			CPaintDC dc(pT->m_hWnd);
			dc.SetMapMode(m_nMapMode);
			if(m_nMapMode == MM_TEXT)
				dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y);
			else
				dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y + m_sizeAll.cy);
			dc.SetWindowOrg(m_rectLogAll.left, m_rectLogAll.bottom);
			pT->DoPaint(dc.m_hDC);
		}
		return 0;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CMapScrollWindowImpl - Implements scrolling window with mapping

template <class T, class TBase /*= CWindow */, class TWinTraits /*= CControlWinTraits */ >
class ATL_NO_VTABLE CMapScrollWindowImpl : public CWindowImpl< T, TBase, TWinTraits >, public CMapScrollImpl< T >
{
public:
	BEGIN_MSG_MAP(CMapScrollWindowImpl< T >)
		MESSAGE_HANDLER(WM_VSCROLL, CScrollImpl< T >::OnVScroll)
		MESSAGE_HANDLER(WM_HSCROLL, CScrollImpl< T >::OnHScroll)
		MESSAGE_HANDLER(WM_MOUSEWHEEL, CScrollImpl< T >::OnMouseWheel)
#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
		MESSAGE_HANDLER(m_uMsgMouseWheel, CScrollImpl< T >::OnMouseWheel)
#endif //(_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
		MESSAGE_HANDLER(WM_SETTINGCHANGE, CScrollImpl< T >::OnSettingChange)
		MESSAGE_HANDLER(WM_SIZE, CScrollImpl< T >::OnSize)
		MESSAGE_HANDLER(WM_PAINT, CMapScrollImpl< T >::OnPaint)
		MESSAGE_HANDLER(WM_PRINTCLIENT, CMapScrollImpl< T >::OnPaint)
	ALT_MSG_MAP(1)
		COMMAND_ID_HANDLER(ID_SCROLL_UP, CScrollImpl< T >::OnScrollUp)
		COMMAND_ID_HANDLER(ID_SCROLL_DOWN, CScrollImpl< T >::OnScrollDown)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_UP, CScrollImpl< T >::OnScrollPageUp)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_DOWN, CScrollImpl< T >::OnScrollPageDown)
		COMMAND_ID_HANDLER(ID_SCROLL_TOP, CScrollImpl< T >::OnScrollTop)
		COMMAND_ID_HANDLER(ID_SCROLL_BOTTOM, CScrollImpl< T >::OnScrollBottom)
		COMMAND_ID_HANDLER(ID_SCROLL_LEFT, CScrollImpl< T >::OnScrollLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_RIGHT, CScrollImpl< T >::OnScrollRight)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_LEFT, CScrollImpl< T >::OnScrollPageLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_RIGHT, CScrollImpl< T >::OnScrollPageRight)
		COMMAND_ID_HANDLER(ID_SCROLL_ALL_LEFT, CScrollImpl< T >::OnScrollAllLeft)
		COMMAND_ID_HANDLER(ID_SCROLL_ALL_RIGHT, CScrollImpl< T >::OnScrollAllRight)
	END_MSG_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFSBWindow - Use as a base instead of CWindow to get flat scroll bar support

#if defined(__ATLCTRLS_H__) && (_WIN32_IE >= 0x0400)

template <class TBase /*= CWindow */ > class CFSBWindowT : public TBase, public CFlatScrollBarImpl<CFSBWindowT< TBase > >
{
public:
// Constructors
	CFSBWindowT(HWND hWnd = NULL) : TBase(hWnd)
	{ }

	CFSBWindowT< TBase >& operator=(HWND hWnd)
	{
		m_hWnd = hWnd;
		return *this;
	}

// CWindow overrides that use flat scroll bar API
// (only those methods that are used by scroll window classes)
	int SetScrollPos(int nBar, int nPos, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return FlatSB_SetScrollPos(nBar, nPos, bRedraw);
	}

	BOOL GetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return FlatSB_GetScrollInfo(nBar, lpScrollInfo);
	}

	BOOL SetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		return FlatSB_SetScrollInfo(nBar, lpScrollInfo, bRedraw);
	}
};

typedef CFSBWindowT<CWindow>	CFSBWindow;

#endif //defined(__ATLCTRLS_H__) && (_WIN32_IE >= 0x0400)

}; //namespace WTL

#endif //__ATLSCRL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wtl10\atlsplit.h ===
// WTL Version 3.1
// Copyright (C) 1997-2000 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLSPLIT_H__
#define __ATLSPLIT_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlsplit.h requires atlapp.h to be included first
#endif

#ifndef __ATLWIN_H__
	#error atlsplit.h requires atlwin.h to be included first
#endif


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

template <class T, bool t_bVertical = true> class CSplitterImpl;
template <class T, bool t_bVertical = true, class TBase = CWindow, class TWinTraits = CControlWinTraits> class CSplitterWindowImpl;
template <bool t_bVertical = true> class CSplitterWindowT;


/////////////////////////////////////////////////////////////////////////////
// CSplitterImpl - Provides splitter support to any window

// Splitter panes constants
#define SPLIT_PANE_LEFT			 0
#define SPLIT_PANE_RIGHT		 1
#define SPLIT_PANE_TOP			 SPLIT_PANE_LEFT
#define SPLIT_PANE_BOTTOM		 SPLIT_PANE_RIGHT
#define SPLIT_PANE_NONE			-1

// Splitter extended styles
#define SPLIT_PROPORTIONAL		0x00000001
#define SPLIT_NONINTERACTIVE		0x00000002
#define SPLIT_RIGHTALIGNED		0x00000004
#define SPLIT_BOTTOMALIGNED		SPLIT_RIGHTALIGNED

// Note: SPLIT_PROPORTIONAL and SPLIT_RIGHTALIGNED/SPLIT_BOTTOMALIGNED are 
// mutually exclusive. If both are set, splitter defaults to SPLIT_PROPORTIONAL


template <class T, bool t_bVertical /*= true */ >
class CSplitterImpl
{
public:
	enum { m_nPanesCount = 2, m_nPropMax = 10000 };

	HWND m_hWndPane[m_nPanesCount];
	RECT m_rcSplitter;
	int m_xySplitterPos;
	int m_nDefActivePane;
	int m_cxySplitBar;		// splitter bar width/height
	static HCURSOR m_hCursor;
	int m_cxyMin;			// minimum pane size
	int m_cxyBarEdge;		// splitter bar edge
	bool m_bFullDrag;
	int m_cxyDragOffset;
	int m_nProportionalPos;
	DWORD m_dwExtendedStyle;	// splitter specific extended styles
	int m_nSinglePane;		// single pane mode

// Constructor
	CSplitterImpl() :
			m_xySplitterPos(-1), m_nDefActivePane(SPLIT_PANE_NONE), 
			m_cxySplitBar(0), m_cxyMin(0), m_cxyBarEdge(0), m_bFullDrag(true), 
			m_cxyDragOffset(0), m_nProportionalPos(0),
			m_dwExtendedStyle(SPLIT_PROPORTIONAL),
			m_nSinglePane(SPLIT_PANE_NONE)
	{
		m_hWndPane[SPLIT_PANE_LEFT] = NULL;
		m_hWndPane[SPLIT_PANE_RIGHT] = NULL;

		::SetRectEmpty(&m_rcSplitter);

		if(m_hCursor == NULL)
		{
			::EnterCriticalSection(&_Module.m_csStaticDataInit);
			if(m_hCursor == NULL)
				m_hCursor = ::LoadCursor(NULL, t_bVertical ? IDC_SIZEWE : IDC_SIZENS);
			::LeaveCriticalSection(&_Module.m_csStaticDataInit);
		}
	}

// Attributes
	void SetSplitterRect(LPRECT lpRect = NULL, bool bUpdate = true)
	{
		if(lpRect == NULL)
		{
			T* pT = static_cast<T*>(this);
			pT->GetClientRect(&m_rcSplitter);
		}
		else
		{
			m_rcSplitter = *lpRect;
		}

		if(IsProportional())
			UpdateProportionalPos();
		else if(IsRightAligned())
			UpdateRightAlignPos();

		if(bUpdate)
			UpdateSplitterLayout();
	}

	void GetSplitterRect(LPRECT lpRect) const
	{
		ATLASSERT(lpRect != NULL);
		*lpRect = m_rcSplitter;
	}

	bool SetSplitterPos(int xyPos = -1, bool bUpdate = true)
	{
		if(xyPos == -1)		// -1 == middle
		{
			if(t_bVertical)
				xyPos = (m_rcSplitter.right - m_rcSplitter.left) / 2;
			else
				xyPos = (m_rcSplitter.bottom - m_rcSplitter.top) / 2;
		}

		// Adjust if out of valid range
		int cxyMax = 0;
		if(t_bVertical)
			cxyMax = m_rcSplitter.right - m_rcSplitter.left;
		else
			cxyMax = m_rcSplitter.bottom - m_rcSplitter.top;

		if(xyPos < m_cxyMin + m_cxyBarEdge)
			xyPos = m_cxyMin;
		else if(xyPos > (cxyMax - m_cxySplitBar - m_cxyBarEdge - m_cxyMin))
			xyPos = cxyMax - m_cxySplitBar - m_cxyBarEdge - m_cxyMin;

		// Set new position and update if requested
		bool bRet = (m_xySplitterPos != xyPos);
		m_xySplitterPos = xyPos;

		if(IsProportional())
			StoreProportionalPos();
		else if(IsRightAligned())
			StoreRightAlignPos();

		if(bUpdate && bRet)
			UpdateSplitterLayout();

		return bRet;
	}

	int GetSplitterPos() const
	{
		return m_xySplitterPos;
	}

	bool SetSinglePaneMode(int nPane = SPLIT_PANE_NONE)
	{
		ATLASSERT(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT || nPane == SPLIT_PANE_NONE);
		if(!(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT || nPane == SPLIT_PANE_NONE))
			return false;

		if(nPane != SPLIT_PANE_NONE)
		{
			if(!::IsWindowVisible(m_hWndPane[nPane]))
				::ShowWindow(m_hWndPane[nPane], SW_SHOW);
			int nOtherPane = (nPane == SPLIT_PANE_LEFT) ? SPLIT_PANE_RIGHT : SPLIT_PANE_LEFT;
			::ShowWindow(m_hWndPane[nOtherPane], SW_HIDE);
			if(m_nDefActivePane != nPane)
				m_nDefActivePane = nPane;
		}
		else if(m_nSinglePane != SPLIT_PANE_NONE)
		{
			int nOtherPane = (m_nSinglePane == SPLIT_PANE_LEFT) ? SPLIT_PANE_RIGHT : SPLIT_PANE_LEFT;
			::ShowWindow(m_hWndPane[nOtherPane], SW_SHOW);
		}

		m_nSinglePane = nPane;
		UpdateSplitterLayout();
		return true;
	}

	int GetSinglePaneMode() const
	{
		return m_nSinglePane;
	}

	DWORD GetSplitterExtendedStyle() const
	{
		return m_dwExtendedStyle;
	}

	DWORD SetSplitterExtendedStyle(DWORD dwExtendedStyle, DWORD dwMask = 0)
	{
		DWORD dwPrevStyle = m_dwExtendedStyle;
		if(dwMask == 0)
			m_dwExtendedStyle = dwExtendedStyle;
		else
			m_dwExtendedStyle = (m_dwExtendedStyle & ~dwMask) | (dwExtendedStyle & dwMask);
#ifdef _DEBUG
		if(IsProportional() && IsRightAligned())
			ATLTRACE2(atlTraceUI, 0, "CSplitterImpl::SetSplitterExtendedStyle - SPLIT_PROPORTIONAL and SPLIT_RIGHTALIGNED are mutually exclusive, defaulting to SPLIT_PROPORTIONAL.\n");
#endif //_DEBUG
		return dwPrevStyle;
	}

// Splitter operations
	void SetSplitterPanes(HWND hWndLeftTop, HWND hWndRightBottom, bool bUpdate = true)
	{
		m_hWndPane[SPLIT_PANE_LEFT] = hWndLeftTop;
		m_hWndPane[SPLIT_PANE_RIGHT] = hWndRightBottom;
		ATLASSERT(m_hWndPane[SPLIT_PANE_LEFT] == NULL || m_hWndPane[SPLIT_PANE_RIGHT] == NULL || m_hWndPane[SPLIT_PANE_LEFT] != m_hWndPane[SPLIT_PANE_RIGHT]);
		if(bUpdate)
			UpdateSplitterLayout();
	}

	bool SetSplitterPane(int nPane, HWND hWnd, bool bUpdate = true)
	{
		ATLASSERT(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT);

		if(nPane != SPLIT_PANE_LEFT && nPane != SPLIT_PANE_RIGHT)
			return false;
		m_hWndPane[nPane] = hWnd;
		ATLASSERT(m_hWndPane[SPLIT_PANE_LEFT] == NULL || m_hWndPane[SPLIT_PANE_RIGHT] == NULL || m_hWndPane[SPLIT_PANE_LEFT] != m_hWndPane[SPLIT_PANE_RIGHT]);
		if(bUpdate)
			UpdateSplitterLayout();
		return true;
	}

	HWND GetSplitterPane(int nPane) const
	{
		ATLASSERT(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT);

		if(nPane != SPLIT_PANE_LEFT && nPane != SPLIT_PANE_RIGHT)
			return false;
		return m_hWndPane[nPane];
	}

	bool SetActivePane(int nPane)
	{
		ATLASSERT(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT);

		if(nPane != SPLIT_PANE_LEFT && nPane != SPLIT_PANE_RIGHT)
			return false;
		if(m_nSinglePane != SPLIT_PANE_NONE && nPane != m_nSinglePane)
			return false;
		::SetFocus(m_hWndPane[nPane]);
		m_nDefActivePane = nPane;
		return true;
	}

	int GetActivePane() const
	{
		int nRet = SPLIT_PANE_NONE;
		HWND hWndFocus = ::GetFocus();
		if(hWndFocus != NULL)
		{
			for(int nPane = 0; nPane < m_nPanesCount; nPane++)
			{
				if(hWndFocus == m_hWndPane[nPane] || ::IsChild(m_hWndPane[nPane], hWndFocus))
				{
					nRet = nPane;
					break;
				}
			}
		}
		return nRet;
	}

	bool ActivateNextPane(bool bNext = true)
	{
		int nPane = m_nSinglePane;
		if(nPane == SPLIT_PANE_NONE)
		{
			switch(GetActivePane())
			{
			case SPLIT_PANE_LEFT:
				nPane = SPLIT_PANE_RIGHT;
				break;
			case SPLIT_PANE_RIGHT:
				nPane = SPLIT_PANE_LEFT;
				break;
			default:
				nPane = bNext ? SPLIT_PANE_LEFT : SPLIT_PANE_RIGHT;
				break;
			}
		}
		return SetActivePane(nPane);
	}

	bool SetDefaultActivePane(int nPane)
	{
		ATLASSERT(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT);

		if(nPane != SPLIT_PANE_LEFT && nPane != SPLIT_PANE_RIGHT)
			return false;
		m_nDefActivePane = nPane;
		return true;
	}

	bool SetDefaultActivePane(HWND hWnd)
	{
		for(int nPane = 0; nPane < m_nPanesCount; nPane++)
		{
			if(hWnd == m_hWndPane[nPane])
			{
				m_nDefActivePane = nPane;
				return true;
			}
		}
		return false;	// not found
	}

	int GetDefaultActivePane() const
	{
		return m_nDefActivePane;
	}

	void DrawSplitter(CDCHandle dc)
	{
		ATLASSERT(dc.m_hDC != NULL);
		if(m_nSinglePane == SPLIT_PANE_NONE && m_xySplitterPos == -1)
			return;

		T* pT = static_cast<T*>(this);
		if(m_nSinglePane == SPLIT_PANE_NONE)
		{
			pT->DrawSplitterBar(dc);

			for(int nPane = 0; nPane < m_nPanesCount; nPane++)
			{
				if(m_hWndPane[nPane] == NULL)
					pT->DrawSplitterPane(dc, nPane);
			}
		}
		else
		{
			if(m_hWndPane[m_nSinglePane] == NULL)
				pT->DrawSplitterPane(dc, m_nSinglePane);
		}
	}

// Overrideables
	void DrawSplitterBar(CDCHandle dc)
	{
		RECT rect;
		if(GetSplitterBarRect(&rect))
		{
			dc.FillRect(&rect, (HBRUSH)LongToPtr(COLOR_3DFACE + 1));
			if(m_cxyMin == 0)	// draw 3D edge if needed
				dc.DrawEdge(&rect, EDGE_RAISED, (t_bVertical) ? (BF_LEFT | BF_RIGHT) : (BF_TOP | BF_BOTTOM));
		}
	}

	// called only if pane is empty
	void DrawSplitterPane(CDCHandle dc, int nPane)
	{
		RECT rect;
		if(GetSplitterPaneRect(nPane, &rect))
		{
			T* pT = static_cast<T*>(this);
			if((pT->GetExStyle() & WS_EX_CLIENTEDGE) == 0)
				dc.DrawEdge(&rect, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
			dc.FillRect(&rect, (HBRUSH)LongToPtr(COLOR_APPWORKSPACE + 1));
		}
	}

// Message map and handlers
	typedef CSplitterImpl< T, t_bVertical>	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_CREATE, OnCreate)
		MESSAGE_HANDLER(WM_PAINT, OnPaint)
		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
		if(IsInteractive())
		{
			MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
			MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
			MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
			MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
			MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDoubleClick)
		}
		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
		MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
		MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
	END_MSG_MAP()

	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		GetSystemSettings(false);
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnPaint(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		// try setting position if not set
		if(m_nSinglePane == SPLIT_PANE_NONE && m_xySplitterPos == -1)
			pT->SetSplitterPos();
		// do painting
		CPaintDC dc(pT->m_hWnd);
		pT->DrawSplitter(dc.m_hDC);
		return 0;
	}

	LRESULT OnSetCursor(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		if((HWND)wParam == pT->m_hWnd && LOWORD(lParam) == HTCLIENT)
		{
			DWORD dwPos = ::GetMessagePos();
			POINT ptPos = { GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos) };
			pT->ScreenToClient(&ptPos);
			if(IsOverSplitterBar(ptPos.x, ptPos.y))
				return 1;
		}

		bHandled = FALSE;
		return 0;
	}

	LRESULT OnMouseMove(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		T* pT = static_cast<T*>(this);
		int xPos = GET_X_LPARAM(lParam);
		int yPos = GET_Y_LPARAM(lParam);
		if((wParam & MK_LBUTTON) && ::GetCapture() == pT->m_hWnd)
		{
			int xyNewSplitPos = 0;
			if(t_bVertical)
				xyNewSplitPos = xPos - m_rcSplitter.left - m_cxyDragOffset;
			else
				xyNewSplitPos = yPos - m_rcSplitter.top - m_cxyDragOffset;

			if(xyNewSplitPos == -1)	// avoid -1, that means middle
				xyNewSplitPos = -2;

			if(m_xySplitterPos != xyNewSplitPos)
			{
				if(m_bFullDrag)
				{
					if(pT->SetSplitterPos(xyNewSplitPos, true))
						pT->UpdateWindow();
				}
				else
				{
					DrawGhostBar();
					pT->SetSplitterPos(xyNewSplitPos, false);
					DrawGhostBar();
				}
			}
		}
		else		// not dragging, just set cursor
		{
			if(IsOverSplitterBar(xPos, yPos))
				::SetCursor(m_hCursor);
			bHandled = FALSE;
		}

		return 0;
	}

	LRESULT OnLButtonDown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
	{
		int xPos = GET_X_LPARAM(lParam);
		int yPos = GET_Y_LPARAM(lParam);
		if(IsOverSplitterBar(xPos, yPos))
		{
			T* pT = static_cast<T*>(this);
			pT->SetCapture();
			::SetCursor(m_hCursor);
			if(!m_bFullDrag)
				DrawGhostBar();
			if(t_bVertical)
				m_cxyDragOffset = xPos - m_rcSplitter.left - m_xySplitterPos;
			else
				m_cxyDragOffset = yPos - m_rcSplitter.top - m_xySplitterPos;
		}
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnLButtonUp(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(!m_bFullDrag)
		{
			DrawGhostBar();
			T* pT = static_cast<T*>(this);
			UpdateSplitterLayout();
			pT->UpdateWindow();
		}
		::ReleaseCapture();
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnLButtonDoubleClick(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		pT->SetSplitterPos();	// middle
		return 0;
	}

	LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM, BOOL& bHandled)
	{
		if(m_nSinglePane == SPLIT_PANE_NONE)
		{
			if(m_nDefActivePane == SPLIT_PANE_LEFT || m_nDefActivePane == SPLIT_PANE_RIGHT)
				::SetFocus(m_hWndPane[m_nDefActivePane]);
		}
		else
		{
			::SetFocus(m_hWndPane[m_nSinglePane]);
		}
		bHandled = FALSE;
		return 1;
	}

	LRESULT OnMouseActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
	{
		T* pT = static_cast<T*>(this);
		LRESULT lRet = pT->DefWindowProc(uMsg, wParam, lParam);
		if(lRet == MA_ACTIVATE || lRet == MA_ACTIVATEANDEAT)
		{
			DWORD dwPos = ::GetMessagePos();
			POINT pt = { GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos) };
			pT->ScreenToClient(&pt);
			RECT rcPane;
			for(int nPane = 0; nPane < m_nPanesCount; nPane++)
			{
				if(GetSplitterPaneRect(nPane, &rcPane) && ::PtInRect(&rcPane, pt))
				{
					m_nDefActivePane = nPane;
					break;
				}
			}
		}
		return lRet;
	}

	LRESULT OnSettingChange(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		GetSystemSettings(true);
		return 0;
	}

// Implementation - internal helpers
	void UpdateSplitterLayout()
	{
		if(m_nSinglePane == SPLIT_PANE_NONE && m_xySplitterPos == -1)
			return;

		T* pT = static_cast<T*>(this);
		RECT rect = { 0, 0, 0, 0 };
		if(m_nSinglePane == SPLIT_PANE_NONE)
		{
			if(GetSplitterBarRect(&rect))
				pT->InvalidateRect(&rect);

			for(int nPane = 0; nPane < m_nPanesCount; nPane++)
			{
				if(GetSplitterPaneRect(nPane, &rect))
				{
					if(m_hWndPane[nPane] != NULL)
						::SetWindowPos(m_hWndPane[nPane], NULL, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, SWP_NOZORDER);
					else
						pT->InvalidateRect(&rect);
				}
			}
		}
		else
		{
			if(GetSplitterPaneRect(m_nSinglePane, &rect))
			{
				if(m_hWndPane[m_nSinglePane] != NULL)
					::SetWindowPos(m_hWndPane[m_nSinglePane], NULL, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, SWP_NOZORDER);
				else
					pT->InvalidateRect(&rect);
			}
		}
	}

	bool GetSplitterBarRect(LPRECT lpRect) const
	{
		ATLASSERT(lpRect != NULL);
		if(m_nSinglePane != SPLIT_PANE_NONE || m_xySplitterPos == -1)
			return false;

		if(t_bVertical)
		{
			lpRect->left = m_rcSplitter.left + m_xySplitterPos;
			lpRect->top = m_rcSplitter.top;
			lpRect->right = m_rcSplitter.left + m_xySplitterPos + m_cxySplitBar + m_cxyBarEdge;
			lpRect->bottom = m_rcSplitter.bottom;
		}
		else
		{
			lpRect->left = m_rcSplitter.left;
			lpRect->top = m_rcSplitter.top + m_xySplitterPos;
			lpRect->right = m_rcSplitter.right;
			lpRect->bottom = m_rcSplitter.top + m_xySplitterPos + m_cxySplitBar + m_cxyBarEdge;
		}

		return true;
	}

	bool GetSplitterPaneRect(int nPane, LPRECT lpRect) const
	{
		ATLASSERT(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT);
		ATLASSERT(lpRect != NULL);
		bool bRet = true;
		if(m_nSinglePane != SPLIT_PANE_NONE)
		{
			if(nPane == m_nSinglePane)
				*lpRect = m_rcSplitter;
			else
				bRet = false;
		}
		else if(nPane == SPLIT_PANE_LEFT)
		{
			if(t_bVertical)
			{
				lpRect->left = m_rcSplitter.left;
				lpRect->top = m_rcSplitter.top;
				lpRect->right = m_rcSplitter.left + m_xySplitterPos;
				lpRect->bottom = m_rcSplitter.bottom;
			}
			else
			{
				lpRect->left = m_rcSplitter.left;
				lpRect->top = m_rcSplitter.top;
				lpRect->right = m_rcSplitter.right;
				lpRect->bottom = m_rcSplitter.top + m_xySplitterPos;
			}
		}	
		else if(nPane == SPLIT_PANE_RIGHT)
		{
			if(t_bVertical)
			{
				lpRect->left = m_rcSplitter.left + m_xySplitterPos + m_cxySplitBar + m_cxyBarEdge;
				lpRect->top = m_rcSplitter.top;
				lpRect->right = m_rcSplitter.right;
				lpRect->bottom = m_rcSplitter.bottom;
			}
			else
			{
				lpRect->left = m_rcSplitter.left;
				lpRect->top = m_rcSplitter.top + m_xySplitterPos + m_cxySplitBar + m_cxyBarEdge;
				lpRect->right = m_rcSplitter.right;
				lpRect->bottom = m_rcSplitter.bottom;
			}
		}
		else
		{
			bRet = false;
		}
		return bRet;
	}

	bool IsOverSplitterRect(int x, int y) const
	{
		// -1 == don't check
		return ((x == -1 || (x >= m_rcSplitter.left && x <= m_rcSplitter.right)) &&
			(y == -1 || (y >= m_rcSplitter.top && y <= m_rcSplitter.bottom)));
	}

	bool IsOverSplitterBar(int x, int y) const
	{
		if(m_nSinglePane != SPLIT_PANE_NONE)
			return false;
		if(m_xySplitterPos == -1 || !IsOverSplitterRect(x, y))
			return false;
		int xy = (t_bVertical) ? x : y;
		int xyOff = (t_bVertical) ? m_rcSplitter.left : m_rcSplitter.top;
		return ((xy >= (xyOff + m_xySplitterPos)) && (xy < xyOff + m_xySplitterPos + m_cxySplitBar + m_cxyBarEdge));
	}

	void DrawGhostBar()
	{
		RECT rect = { 0, 0, 0, 0 };
		if(GetSplitterBarRect(&rect))
		{
			// invert the brush pattern (looks just like frame window sizing)
			T* pT = static_cast<T*>(this);
			CWindowDC dc(pT->m_hWnd);
			CBrush brush = CDCHandle::GetHalftoneBrush();
			if(brush.m_hBrush != NULL)
			{
				CBrushHandle brushOld = dc.SelectBrush(brush);
				dc.PatBlt(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, PATINVERT);
				dc.SelectBrush(brushOld);
			}
		}
	}

	void GetSystemSettings(bool bUpdate)
	{
		m_cxySplitBar = ::GetSystemMetrics(t_bVertical ? SM_CXSIZEFRAME : SM_CYSIZEFRAME);

		T* pT = static_cast<T*>(this);
		if((pT->GetExStyle() & WS_EX_CLIENTEDGE))
		{
			m_cxyBarEdge = 2 * ::GetSystemMetrics(t_bVertical ? SM_CXEDGE : SM_CYEDGE);
			m_cxyMin = 0;
		}
		else
		{
			m_cxyBarEdge = 0;
			m_cxyMin = 2 * ::GetSystemMetrics(t_bVertical ? SM_CXEDGE : SM_CYEDGE);
		}

		::SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &m_bFullDrag, 0);

		if(bUpdate)
			UpdateSplitterLayout();
	}

	bool IsProportional() const
	{
		return (m_dwExtendedStyle & SPLIT_PROPORTIONAL) != 0;
	}

	void StoreProportionalPos()
	{
		int cxyTotal = t_bVertical ? (m_rcSplitter.right - m_rcSplitter.left) : (m_rcSplitter.bottom - m_rcSplitter.top);
		if(cxyTotal > 0)
			m_nProportionalPos = ::MulDiv(m_xySplitterPos, m_nPropMax, cxyTotal);
		else
			m_nProportionalPos = 0;
	}

	void UpdateProportionalPos()
	{
		int cxyTotal = t_bVertical ? (m_rcSplitter.right - m_rcSplitter.left) : (m_rcSplitter.bottom - m_rcSplitter.top);
		if(cxyTotal > 0)
		{
			int xyNewPos = ::MulDiv(m_nProportionalPos, cxyTotal, m_nPropMax);
			T* pT = static_cast<T*>(this);
			pT->SetSplitterPos(xyNewPos, false);
		}
	}

	bool IsRightAligned() const
	{
		return (m_dwExtendedStyle & SPLIT_RIGHTALIGNED) != 0;
	}

	void StoreRightAlignPos()
	{
		int cxyTotal = t_bVertical ? (m_rcSplitter.right - m_rcSplitter.left) : (m_rcSplitter.bottom - m_rcSplitter.top);
		if(cxyTotal > 0)
			m_nProportionalPos = cxyTotal - m_xySplitterPos;
		else
			m_nProportionalPos = 0;
	}

	void UpdateRightAlignPos()
	{
		int cxyTotal = t_bVertical ? (m_rcSplitter.right - m_rcSplitter.left) : (m_rcSplitter.bottom - m_rcSplitter.top);
		if(cxyTotal > 0)
		{
			T* pT = static_cast<T*>(this);
			pT->SetSplitterPos(cxyTotal - m_nProportionalPos, false);
		}
	}

	bool IsInteractive() const
	{
		return !(m_dwExtendedStyle & SPLIT_NONINTERACTIVE);
	}
};

template <class T, bool t_bVertical> HCURSOR CSplitterImpl< T, t_bVertical>::m_hCursor = NULL;


/////////////////////////////////////////////////////////////////////////////
// CSplitterWindowImpl - Implements a splitter window

template <class T, bool t_bVertical /*= true */, class TBase /*= CWindow */, class TWinTraits /*= CControlWinTraits */ >
class ATL_NO_VTABLE CSplitterWindowImpl : public CWindowImpl< T, TBase, TWinTraits >, public CSplitterImpl< T , t_bVertical >
{
public:
	DECLARE_WND_CLASS_EX(NULL, CS_DBLCLKS, COLOR_WINDOW)

	typedef CSplitterWindowImpl< T , t_bVertical, TBase, TWinTraits >	thisClass;
	typedef CSplitterImpl< T , t_bVertical >				baseClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
		MESSAGE_HANDLER(WM_SIZE, OnSize)
		CHAIN_MSG_MAP(baseClass)
		FORWARD_NOTIFICATIONS()
	END_MSG_MAP()

	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		// handled, no background painting needed
		return 1;
	}

	LRESULT OnSize(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if(wParam != SIZE_MINIMIZED)
			SetSplitterRect();

		bHandled = FALSE;
		return 1;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CSplitterWindow - Implements a splitter window to be used as is

template <bool t_bVertical /*= true */ >
class CSplitterWindowT : public CSplitterWindowImpl<CSplitterWindowT<t_bVertical>, t_bVertical>
{
public:
	DECLARE_WND_CLASS_EX(_T("WTL_SplitterWindow"), CS_DBLCLKS, COLOR_WINDOW)
};

typedef CSplitterWindowT<true>	CSplitterWindow;
typedef CSplitterWindowT<false>	CHorSplitterWindow;

}; //namespace WTL

#endif // __ATLSPLIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\buffer.inc ===
BREAK <Disk I/O Buffer Header>


;**	BUFFER.INC
;
;	Field definition for I/O buffer information

BUFFINFO	STRUC
buf_next	DW	?		; Pointer to next buffer in list
buf_prev	DW	?		; Pointer to prev buffer in list
buf_ID		DB	?		; Drive of buffer (bit 7 = 0)
					; SFT table index (bit 7 = 1)
					; = FFH if buffer free
buf_flags	DB	?		; Bit 7 = 1 if Remote file buffer
					;	= 0 if Local device buffer
					; Bit 6 = 1 if buffer dirty
					; Bit 5 = Reserved
					; Bit 4 = Search bit (bit 7 = 1)
					; Bit 3 = 1 if buffer is DATA
					; Bit 2 = 1 if buffer is DIR
					; Bit 1 = 1 if buffer is FAT
					; Bit 0 = Reserved
buf_sector	DD	?		; Sector number of buffer (bit 7 = 0)
; The next two items are often refed as a word (bit 7 = 0)
buf_wrtcnt	DB	?		; For FAT sectors, # times sector written out
buf_wrtcntinc	DW	?		; "   "     "   , # sectors between each write
buf_DPB 	DD	?		; Pointer to drive parameters
buf_fill	DW	?		; How full buffer is (bit 7 = 1)
buf_reserved	DB	?		; make DWORD boundary for 386
BUFFINFO	ENDS

buf_offset	EQU	DWORD PTR buf_sector
					;For bit 7 = 1, this is the byte
					;offset of the start of the buffer in
					;the file pointed to by buf_ID.  Thus
					;the buffer starts at location
					;buf_offset in the file and contains
					;buf_fill bytes.

BUFINSIZ	EQU	SIZE BUFFINFO
					; Size of structure in bytes

buf_Free	EQU	0FFh		; buf_id of free buffer

;Flag byte masks
buf_isnet	EQU	10000000B
buf_dirty	EQU	01000000B
;***
buf_visit	EQU	00100000B
;***
buf_snbuf	EQU	00010000B

buf_isDATA	EQU	00001000B
buf_isDIR	EQU	00000100B
buf_isFAT	EQU	00000010B
buf_type_0	EQU	11110001B	; AND sets type to "none"

buf_NetID	EQU	BUFINSIZ

;
; Buffer Hash Entry Structure
;
;BUFFER_HASH_ENTRY	STRUC		; DOS 4.00
;EMS_PAGE_NUM	DW	-1		; logical page number for EMS handle
;BUFFER_BUCKET	DD	 ?		; pointer to buffers
;DIRTY_COUNT	DB	 0		; number of dirty buffers
;BUFFER_RESERVED DB	 0		; reserved
;BUFFER_HASH_ENTRY	ENDS
;
;MaxBuffinBucket EQU	15		; Max number of buffers per bucket
;MaxBucketinPage EQU	 2		; Max number of buckets per 16kb page
;
;
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to hlls
(C)Copyright Microsoft Corp. 1984-1988
$
.xcref
.xcref ??_out
ifndef ?QUIET
?QUIET  equ 1
endif
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
ifdef PMODE
?pmd=1
??_out <! 286 protect mode>
else
?pmd=0
endif
ifdef ?386regs
if ?386regs
??_out <! 386 registers enabled>
endif
else
?386regs=0
endif
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<Pascal calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
ifdef ?pmd
.286p
endif
if ?386regs
.xcref ?n,?ax,?eax,?bx,?ebx
.xcref ?cx,?ecx,?dx,?edx
.xcref ?si,?esi,?di,?edi,?es,?ds,?fs
.xcref ?gs
else
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
endif
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5,?pmd,?lds,?exp
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?lds = 0
?exp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
if ?386regs
?n = 0000000000000000b
?ax = 0000000000000001b
?eax = 0000000000000010b
?bx = 0000000000000100b
?ebx = 0000000000001000b
?cx = 0000000000010000b
?ecx = 0000000000100000b
?dx = 0000000001000000b
?edx = 0000000010000000b
?si = 0000000100000000b
?esi = 0000001000000000b
?di = 0000010000000000b
?edi = 0000100000000000b
?ds = 0001000000000000b
?es = 0010000000000000b
?fs = 0100000000000000b
?gs = 1000000000000000b
else
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
endif
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
if ?386regs
mpush macro r
irp x,<ax,eax,bx,ebx,cx,ecx,dx,edx,si,esi,di,edi,ds,es,fs,gs>
if (r and ?&&x)
	push	x
endif
endm
endm
else
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
endif
if ?386regs
mpop macro r
irp x,<gs,fs,es,ds,edi,di,esi,si,edx,dx,ecx,cx,ebx,bx,eax,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
else
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
endif
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
.ERRNDEF ?&&x
n=n or ?&&x
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
if ?pmd
parmR macro n,r,r2
??error <Sorry: ParmR can't be used with PMODE=1>
endm
else
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
?lds=0
?exp=0
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
ifidn <x>,<LOADDS>
?lds=1
endif
ifidn <x>,<EXPORTED>
?exp=1
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp+?exp+?lds
ife ?nx
ife ?pmd
?ia=2
endif
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
ife ?386regs
?pas = ?pas and (not (?sp+?cs+?ss))
endif
if ?uf
if ?386regs
?pas = ?pas and (not (?si+?di))
else
?pas = ?pas and (not (?bp+?si+?di))
endif
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w+?exp+?lds
if ?pmd
ife ?nd
if ?lds
mov ax,_DATA
else
if ?exp
mov ax,ds
nop
endif
endif
endif
ife ?nx
if ???+?po
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
push ds
if ?lds+?exp
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
else
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
endif
else
if ?pmd
if ?exp
mov ax,ds
nop
else
if ?lds
mov ax,_DATA
endif
endif
if ?ff+???+?po+?rp
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
if ?exp+?lds
push ds
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
ife ?pmd
	sub	sp,???
endif
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w+?exp+?lds
if ?pmd
ife ?nx
pop ds
endif
ife ?nx
if ?chkstk1+???+?po
leave
endif
else
if ?ff+???+?po+?rp
leave
endif
endif
else
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
endif
else
if ?pmd
if ?ff+???+?po+?rp
leave
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc\wtl10\atluser.h ===
// WTL Version 3.1
// Copyright (C) 1997-2000 Microsoft Corporation
// All rights reserved.
//
// This file is a part of Windows Template Library.
// The code and information is provided "as-is" without
// warranty of any kind, either expressed or implied.

#ifndef __ATLUSER_H__
#define __ATLUSER_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atluser.h requires atlbase.h to be included first
#endif


namespace WTL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CMenuItemInfo;
template <bool t_bManaged> class CMenuT;


/////////////////////////////////////////////////////////////////////////////
// CMenu

class CMenuItemInfo : public MENUITEMINFO
{
public:
	CMenuItemInfo()
	{
		memset(this, 0, sizeof(MENUITEMINFO));
		cbSize = sizeof(MENUITEMINFO);
	}
};

typedef CMenuT<false>		CMenuHandle;
typedef CMenuT<true>		CMenu;

template <bool t_bManaged>
class CMenuT
{
public:
// Data members
	HMENU m_hMenu;

// Constructor/destructor/operators
	CMenuT(HMENU hMenu = NULL) : m_hMenu(hMenu)
	{ }

	~CMenuT()
	{
		if(t_bManaged && m_hMenu != NULL)
			DestroyMenu();
	}

	CMenuT<t_bManaged>& operator=(HMENU hMenu)
	{
		m_hMenu = hMenu;
		return *this;
	}

	void Attach(HMENU hMenuNew)
	{
		ATLASSERT(::IsMenu(hMenuNew));
		if(t_bManaged && m_hMenu != NULL)
			::DestroyMenu(m_hMenu);
		m_hMenu = hMenuNew;
	}

	HMENU Detach()
	{
		HMENU hMenu = m_hMenu;
		m_hMenu = NULL;
		return hMenu;
	}

	operator HMENU() const { return m_hMenu; }

	BOOL IsMenu() const
	{
		return ::IsMenu(m_hMenu);
	}

// Create and load methods
	BOOL CreateMenu()
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::CreateMenu();
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
	BOOL CreatePopupMenu()
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::CreatePopupMenu();
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
	BOOL LoadMenu(_U_STRINGorID menu)
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::LoadMenu(_Module.GetResourceInstance(), menu.m_lpstr);
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
	BOOL LoadMenuIndirect(const void* lpMenuTemplate)
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::LoadMenuIndirect(lpMenuTemplate);
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
	BOOL DestroyMenu()
	{
		if (m_hMenu == NULL)
			return FALSE;
		return ::DestroyMenu(Detach());
	}

// Menu Operations
	BOOL DeleteMenu(UINT nPosition, UINT nFlags)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::DeleteMenu(m_hMenu, nPosition, nFlags);
	}
	BOOL TrackPopupMenu(UINT nFlags, int x, int y, HWND hWnd, LPCRECT lpRect = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::TrackPopupMenu(m_hMenu, nFlags, x, y, 0, hWnd, lpRect);
	}
	BOOL TrackPopupMenuEx(UINT uFlags, int x, int y, HWND hWnd, LPTPMPARAMS lptpm = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::TrackPopupMenuEx(m_hMenu, uFlags, x, y, hWnd, lptpm);
	}

#if (WINVER >= 0x0500)
	BOOL GetMenuInfo(LPMENUINFO lpMenuInfo) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuInfo(m_hMenu, lpMenuInfo);
	}
	BOOL SetMenuInfo(LPCMENUINFO lpMenuInfo)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::SetMenuInfo(m_hMenu, lpMenuInfo);
	}
#endif //(WINVER >= 0x0500)

// Menu Item Operations
	BOOL AppendMenu(UINT nFlags, UINT_PTR nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::AppendMenu(m_hMenu, nFlags, nIDNewItem, lpszNewItem);
	}
	BOOL AppendMenu(UINT nFlags, UINT_PTR nIDNewItem, HBITMAP hBmp)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::AppendMenu(m_hMenu, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
	}
	UINT CheckMenuItem(UINT nIDCheckItem, UINT nCheck)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return (UINT)::CheckMenuItem(m_hMenu, nIDCheckItem, nCheck);
	}
	UINT EnableMenuItem(UINT nIDEnableItem, UINT nEnable)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::EnableMenuItem(m_hMenu, nIDEnableItem, nEnable);
	}
	BOOL HiliteMenuItem(HWND hWnd, UINT uIDHiliteItem, UINT uHilite)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::HiliteMenuItem(hWnd, m_hMenu, uIDHiliteItem, uHilite);
	}
	int GetMenuItemCount() const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuItemCount(m_hMenu);
	}
	UINT GetMenuItemID(int nPos) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuItemID(m_hMenu, nPos);
	}
	UINT GetMenuState(UINT nID, UINT nFlags) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuState(m_hMenu, nID, nFlags);
	}
	int GetMenuString(UINT nIDItem, LPTSTR lpString, int nMaxCount, UINT nFlags) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuString(m_hMenu, nIDItem, lpString, nMaxCount, nFlags);
	}
	int GetMenuStringLen(UINT nIDItem, UINT nFlags) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuString(m_hMenu, nIDItem, NULL, 0, nFlags);
	}
#ifndef _ATL_NO_COM
	BOOL GetMenuString(UINT nIDItem, BSTR& bstrText, UINT nFlags) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsMenu(m_hMenu));
		ATLASSERT(bstrText == NULL);

		int nLen = GetMenuStringLen(nIDItem, nFlags);
		if(nLen == 0)
		{
			bstrText = ::SysAllocString(OLESTR(""));
			return (bstrText != NULL) ? TRUE : FALSE;
		}

		nLen++;		// increment to include terminating NULL char
		LPTSTR lpszText = (LPTSTR)_alloca((nLen) * sizeof(TCHAR));

		if(!GetMenuString(nIDItem, lpszText, nLen, nFlags))
			return FALSE;

		bstrText = ::SysAllocString(T2OLE(lpszText));
		return (bstrText != NULL) ? TRUE : FALSE;
	}
#endif //!_ATL_NO_COM
#ifdef __ATLSTR_H__
	int GetMenuString(UINT nIDItem, CString& strText, UINT nFlags) const
	{
		ATLASSERT(::IsMenu(m_hMenu));

		int nLen = GetMenuStringLen(nIDItem, nFlags);
		if(nLen == 0)
			return 0;

		nLen++;		// increment to include terminating NULL char
		int nRet = GetMenuString(nIDItem, strText.GetBufferSetLength(nLen), nLen, nFlags);
		strText.ReleaseBuffer();
		return nRet;
	}
#endif //__ATLSTR_H__
	CMenuHandle GetSubMenu(int nPos) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return CMenuHandle(::GetSubMenu(m_hMenu, nPos));
	}
	BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::InsertMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem);
	}
	BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem, HBITMAP hBmp)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::InsertMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
	}
	BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::ModifyMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem);
	}
	BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem, HBITMAP hBmp)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::ModifyMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
	}
	BOOL RemoveMenu(UINT nPosition, UINT nFlags)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::RemoveMenu(m_hMenu, nPosition, nFlags);
	}
	BOOL SetMenuItemBitmaps(UINT nPosition, UINT nFlags, HBITMAP hBmpUnchecked, HBITMAP hBmpChecked)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::SetMenuItemBitmaps(m_hMenu, nPosition, nFlags, hBmpUnchecked, hBmpChecked);
	}
	BOOL CheckMenuRadioItem(UINT nIDFirst, UINT nIDLast, UINT nIDItem, UINT nFlags)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::CheckMenuRadioItem(m_hMenu, nIDFirst, nIDLast, nIDItem, nFlags);
	}

	BOOL GetMenuItemInfo(UINT uItem, BOOL bByPosition, LPMENUITEMINFO lpmii) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return (BOOL)::GetMenuItemInfo(m_hMenu, uItem, bByPosition, lpmii);
	}
	BOOL SetMenuItemInfo(UINT uItem, BOOL bByPosition, LPMENUITEMINFO lpmii)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return (BOOL)::SetMenuItemInfo(m_hMenu, uItem, bByPosition, lpmii);
	}
	BOOL InsertMenuItem(UINT uItem, BOOL bByPosition, LPMENUITEMINFO lpmii)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return (BOOL)::InsertMenuItem(m_hMenu, uItem, bByPosition, lpmii);
	}

	UINT GetMenuDefaultItem(BOOL bByPosition = FALSE, UINT uFlags = 0U) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuDefaultItem(m_hMenu, (UINT)bByPosition, uFlags);
	}
	BOOL SetMenuDefaultItem(UINT uItem = (UINT)-1,  BOOL bByPosition = FALSE)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::SetMenuDefaultItem(m_hMenu, uItem, (UINT)bByPosition);
	}
	BOOL GetMenuItemRect(HWND hWnd, UINT uItem, LPRECT lprcItem) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuItemRect(hWnd, m_hMenu, uItem, lprcItem);
	}
	int MenuItemFromPoint(HWND hWnd, POINT point) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::MenuItemFromPoint(hWnd, m_hMenu, point);
	}

// Context Help Functions
	BOOL SetMenuContextHelpId(DWORD dwContextHelpId)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::SetMenuContextHelpId(m_hMenu, dwContextHelpId);
	}
	DWORD GetMenuContextHelpId() const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuContextHelpId(m_hMenu);
	}
};

}; //namespace WTL

#endif // __ATLUSER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\dirent.inc ===
;**	Break <Directory entry>

;	NOTE:  These offsets are also used in the DTA for
;	extended FCB SearchFirst/Next.  DIR_NAME lines up
;	with the FCB filename field, and the rest of the
;	DIR_ENTRY fields follow.  -DavidOls

;**	DIRENT.INC - FAT Directory Entry Definition
;
;	+---------------------------+
;	|  (12 BYTE) filename/ext   |	    0	    0
;	+---------------------------+
;	|     (BYTE) attributes     |	    11	    B
;	+---------------------------+
;	|    (10 BYTE) reserved     |	    12	    C
;	+---------------------------+
;	| (WORD) time of last write |	    22	    16
;	+---------------------------+
;	| (WORD) date of last write |	    24	    18
;	+---------------------------+
;	|   (WORD) First cluster    |	    26	    1A
;	+---------------------------+
;	|     (DWORD) file size     |	    28	    1C
;	+---------------------------+
;
;   First byte of filename  = E5 -> free directory entry
;			    = 00 -> end of allocated directory
;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
;

DIR_ENTRY   STRUC
DIR_NAME    db	    11 DUP (?)	; file name
DIR_ATTR    db	    ?		; attribute bits
DIR_CODEPG  dw	    ?		; code page DOS 4.00
DIR_EXTCLUSTER dw	?		; extended attribute starting cluster
DIR_ATTR2   db	    ?		; reserved
DIR_PAD     db	    5  DUP (?)	; reserved for expansion
DIR_TIME    dw	    ?		; time of last write
DIR_DATE    dw	    ?		; date of last write
DIR_FIRST   dw	    ?		; first allocation unit of file
DIR_SIZE_L  dw	    ?		; low 16 bits of file size
DIR_SIZE_H  dw	    ?		; high 16 bits of file size

;	    Caution:  An extended FCB SearchFirst/Next on a network
;	    drive under Novell Netware 286 or 386 returns the time/date
;	    in the SIZE fields for subdirectory files.  Ordinarily,
;	    this field is zero for subdirectory files.

DIR_ENTRY   ENDS

ATTR_READ_ONLY	equ	 1h
ATTR_HIDDEN	equ	 2h
ATTR_SYSTEM	equ	 4h
ATTR_VOLUME_ID	equ	 8h
ATTR_DIRECTORY	equ	10h
ATTR_ARCHIVE	equ	20h
ATTR_DEVICE	equ	40h	; This is a VERY special bit.
				;   NO directory entry on a disk EVER
				;   has this bit set. It is set non-zero
				;   when a device is found by GETPATH

ATTR_ALL	equ	attr_hidden+attr_system+attr_directory
				; OR of hard attributes for FINDENTRY

ATTR_IGNORE	equ	attr_read_only+attr_archive+attr_device
				; ignore this(ese) attribute(s) during
				; search first/next

ATTR_CHANGEABLE equ	attr_read_only+attr_hidden+attr_system+attr_archive
				; changeable via CHMOD


DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\dossym.inc ===
;	PAGE 80,132
	.xall

; Revision History:
;	
;	M003	- added A20OFF_FLAG for MS PASCAL 3.2 compatibility support
;		  for DOS5.X running in HMA. 
;
;	M004	- added bit definition SETSSSP for DOS_FLAG for supporting
;		  exe files without stack segment. 
;		  This is no longer needed as we modify SP only. Removing 
;		  this equate. 9/26/90
;
;       M009	- addded comments relating to mace mkeyrate ver 1.0 support 
;		  with DOS in HMA.
;
;	M025	- Added SWITCHES=/W for suppressing mandatory loading
;		  of WINA20.386
;
;	M027	- Support for copy protected apps. Defined bit 2 of DOS_FLAG
;	

TRUE	    EQU 0FFFFh
FALSE	    EQU 0

Installed   = TRUE
IFNDEF	DEBUG
    DEBUG	= FALSE
ENDIF

include dbcs.sw
include dosmac.INC
include VERSIONA.INC
include VERSION.INC


BREAK <Control character definitions>

c_DEL	    EQU     7Fh 		;    ASCII rubout or delete previous char
c_BS	    EQU     08h 		; ^H ASCII backspace
c_CR	    EQU     0Dh 		; ^M ASCII carriage return
c_LF	    EQU     0Ah 		; ^J ASCII linefeed
c_ETB	    EQU     17h 		; ^W ASCII end of transmission
c_NAK	    EQU     15h 		; ^U ASCII negative acknowledge
c_ETX	    EQU     03h 		; ^C ASCII end of text
c_HT	    EQU     09h 		; ^I ASCII tab

BREAK <Read This and Weep>

include buffer.INC

BREAK <User stack inside of system call and SysVars>
; Location of user registers relative user stack pointer

user_environ	STRUC
user_AX     DW	    ?			; 00 hex offsets to
user_BX     DW	    ?			; 02	 facilitate debugging
user_CX     DW	    ?			; 04
user_DX     DW	    ?			; 06
user_SI     DW	    ?			; 08
user_DI     DW	    ?			; 0A
user_BP     DW	    ?			; 0C
user_DS     DW	    ?			; 0E
user_ES     DW	    ?			; 10
user_IP     DW	    ?			; 12
user_CS     DW	    ?			; 14
user_F	    DW	    ?			; 16
user_environ	ENDS


	BREAK <Disk map>

;	MSDOS partitions the disk into 4 sections:
;
;  phys sector 0:   +-------------------+
;	|	    | boot/reserved	|
;	|	    +-------------------+
;	|	    |  File allocation	|
;	v	    |	   table(s)	|
;		    |  (multiple copies |
;		    |	  are kept)	|
;		    +-------------------+
;		    |	  Directory	|
;		    +-------------------+
;		    |	  File space	|
;		    +-------------------+
;		    |	Unaddressable	|
;		    |  (to end of disk) |
;		    +-------------------+
;
; All partition boundaries are sector boundaries.  The size of the FAT is
; adjusted to maximize the file space addressable.

include dirent.INC

BREAK <File allocation Table information>
;
; The File Allocation Table uses a 12-bit entry for each allocation unit on
; the disk.  These entries are packed, two for every three bytes.  The contents
; of entry number N is found by 1) multiplying N by 1.5; 2) adding the result
; to the base address of the Allocation Table; 3) fetching the 16-bit word
; at this address; 4) If N was odd (so that N*1.5 was not an integer), shift
; the word right four bits; 5) mask to 12 bits (AND with 0FFF hex).  Entry
; number zero is used as an end-of-file trap in the OS and is passed to the
; BIOS to help determine disk format.  Entry 1 is reserved for future use.
; The first available allocation unit is assigned entry number two, and even
; though it is the first, is called cluster 2.	Entries greater than 0FF8H
; (12-bit fats) or 0FFF8H (16-bit fats) are end of file marks; entries of zero
; are unallocated.  Otherwise, the contents of a FAT entry is the number of
; the next cluster in the file.
;
; Clusters with bad sectors are tagged with FF7H.  Any non-zero number would
; do because these clusters show as allocated, but are not part of any
; allocation chain and thus will never be allocated to a file.	A particular
; number is selected so that disk checking programs know what to do (ie.  a
; cluster with entry FF7H which is not in a chain is not an error).




;**	Character Type Flags
;
;	These flags are used in a lookup table indexed by the character code.
;	They're used to quickly classify characters when parsing paths.
;	I think that these are only used to parse FCBs - jgl

FCHK	equ 1		; I think this means "normal name char, no chks needed" -jgl
FDELIM	equ 2		; is a delimiter
FSPCHK	equ 4		; set if character is not a space or equivalent
FFCB	equ 8		; is valid in an FCB


	include error.INC

;** Bit definitions for DOS_FLAG
;
; Bit 0 - this is set when a $open call is made from $exec. This is used in
;	  $open to indicate to the redirector that this open is being made
;	  by an exec call.
;
; Bit 2
;
; M003, M027:
;
; The start up code of MS PASCAL 3.2 programs depend on the 1M address wrap 
; if they load below 64K. This is a likely possiblity in DOS 5.x with DOS in
; the HMA. By default DOS will turn A20 OFF before Xferring control to the
; user program in the case of an Exec call. The next call to DOS will turn
; A20 line ON. It has been observed that MS PASCAL 3.2 start up does an int
; 21 ah=25h call before executing the faulty code. This will turn A20 On. 
; In order to support this we will set Bit 2 of this flag in the DOS exec
; call (msproc.asm) if DOS is running in the HMA. In $set_interrupt_vector in
; getset.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
; is non zero then A20 will be turned OFF before returning to the user. 
; Bit 2 will be unconditionally cleared here.
;
; M009, M027:
;
; Mace utilities MKEYRATE.COM version 1.0 copyright 1987 is an execpacked 
; program converted to a com file. Therefore if DOS is loaded high and if 
; this program is loaded below 64K it will blurt out "packed file is corrupt".
; This program does an int 21 ah=49h before executing the buggy execpacked
; code. This int21 call turns a20 on and hence the problem. In $dealloc
; alloc.asm A20OFF_COUNT is set to 1 if bit 2 of DOS_FLAG was previously set 
; by a call to exec and if A20OFF_COUNT is 0. In msdisp.asm, if A20OFF_COUNT 
; is non zero then A20 will be turned OFF before returning to the user. 
; Bit 2 will be unconditionally cleared here.
;
;
;

EXECOPEN	EQU	00000001b	; bit 0 of DOS_FLAG
SUPPRESS_WINA20	EQU	00000010b	; M025
EXECA20OFF	EQU	00000100b	; bit 2 of DOS_FLAG



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\pdb.inc ===
;	SCCSID = @(#)pdb.asm	1.1 85/04/10
BREAK <Process data block>

;**	Process data block (otherwise known as program header)
;

;	These offset are documented in the MSDOS Encyclopedia, so nothing
;	can be rearranged here, ever.  Reserved areas are probably safe
;	for use.


FilPerProc	    EQU     20

Process_data_block  STRUC
PDB_Exit_Call	DW	?		; INT int_abort system terminate
PDB_block_len	DW	?		; size of execution block
		DB	?
PDB_CPM_Call	DB	5 DUP (?)	; ancient call to system
PDB_Exit	DD	?		; pointer to exit routine
PDB_Ctrl_C	DD	?		; pointer to ^C routine
PDB_Fatal_abort DD	?		; pointer to fatal error
PDB_Parent_PID	DW	?		; PID of parent (terminate PID)
PDB_JFN_Table	DB	FilPerProc DUP (?)
PDB_environ	DW	?		; seg addr of environment
PDB_User_stack	DD	?		; stack of self during system calls
PDB_JFN_Length	DW	?		; number of handles allowed
PDB_JFN_Pointer DD	?		; pointer to JFN table
PDB_Next_PDB	DD	?		; pointer to nested PDB's

PDB_InterCon	DB	?		; *** jh-3/28/90 *** 
PDB_Append	DB	?		; *** Not sure if still used ***

PDB_Novell_Used	DB	2 DUP (?)	; Novell shell (redir) uses these

PDB_Version	DW	?		; DOS version reported to this app

PDB_PAD1	DB	0Eh DUP (?)
PDB_Call_system DB	5   DUP (?)	; portable method of system call
PDB_PAD2	DB	7h  DUP (?)	; reserved so FCB 1 can be used as
					;  an extended FCB
PDB_FCB1	DB	10h dup (?)	; default FCB 1
PDB_FCB2	DB	10h dup (?)	; default FCB 2
PDB_PAD3	DB	4   dup (?)	; not sure if this is used by PDB_FCB2
PDB_TAIL	DB	128 dup (?)	; command tail and default DTA



Process_data_block  ENDS


;
;PDB_Append	equ	BYTE PTR  PDB_PAD1 + 1    ; reincluded because APPEND
;                        ; wouldn't build w/o it.  feb 1990, leaf
;
;PDB_InterCon	EQU	BYTE PTR PDB_PAD1	; 2/12/KK
;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\dosmac.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Macro definitions for MSDOS.
;
;       Revision history:
;        	M019 DB 10/26/90 - Added Cmp32 macro.

TRUE    EQU 0FFFFh
FALSE   EQU 0

SUBTTL BREAK a listing into pages and give new subtitles
PAGE
BREAK   MACRO   subtitle
	SUBTTL  subtitle
	PAGE
ENDM
.xcref  break

BREAK   <ASMVAR - handle assembly variables once and for all>

AsmVars Macro   varlist
IRP     var,<varlist>
AsmVar  var
ENDM
ENDM

AsmVar  Macro   var
IFNDEF  var
var = FALSE
ENDIF
ENDM

BREAK <I_NEED: declare a variable external, if necessary, and allocate a size>

;
; declare a variable external and allocate a size
;
AsmVar  InstalledData
I_NEED  MACRO   sym,len
IF NOT InstalledData
	DOSDATA    SEGMENT WORD PUBLIC 'DATA'
    IFIDN   <len>,<WORD>
	EXTRN   &sym:WORD
    ELSE
	IFIDN   <len>,<DWORD>
	EXTRN   &sym:DWORD
	ELSE
	EXTRN   &sym:BYTE
	ENDIF
    ENDIF
	DOSDATA    ENDS
ENDIF
ENDM
	.xcref I_need


; call a procedure that may be external.  The call will be short.

invoke  MACRO   name
.xcref
	IF2
	    IFNDEF name
	EXTRN   name:NEAR
	    ENDIF
	ENDIF
.cref
	CALL    name
ENDM
.xcref  invoke

PAGE
;
; jump to a label that may be external.  The jump will be near.
;
transfer    MACRO   name
.xcref
	IF2
	    IFNDEF name
	EXTRN   name:NEAR
	    ENDIF
	ENDIF
.cref
	JUMP    name
ENDM
.xcref  transfer

;
; get a short address in a word
;
short_addr  MACRO   name
    IFDIF   <name>,<?>
.xcref
	IF2
	    IFNDEF name
	EXTRN   name:NEAR
	    ENDIF
	ENDIF
.cref
	DW  OFFSET DOSCODE:name
    ELSE
	DW  ?
    ENDIF
ENDM
.xcref  short_addr

;
; get a long address in a dword
;
long_addr   MACRO   name
.xcref
	IF2
	    IFNDEF name
	EXTRN   name:NEAR
	    ENDIF
	ENDIF
.cref
	DD  name
ENDM
.xcref  long_addr

;
; declare a PROC near or far but PUBLIC nonetheless
;
.xcref ?frame
.xcref ?aframe
.xcref ?stackdepth
.xcref ?initstack
?frame        =   0                     ; initial
?aframe       =   0                     ; initial
?stackdepth   =   0                     ; initial stack size
?initstack    =   0                     ; initial stack size

procedure   MACRO   name,distance
	?frame =    0
	?aframe =   2                   ;; remember the pushed BP
	PUBLIC  name
name    PROC    distance
	ASSUME	DS:nothing,ES:nothing
	?initstack    = ?stackdepth     ;; beginning of procedure
ENDM
.xcref  procedure


; end a procedure and check that stack depth is preserved

EndProc MACRO   name, chk
	IFDIF   <chk>,<NoCheck>       ;; check the stack size
	IF2
	IF ?initstack NE ?stackdepth    ;; is it different?
	%OUT    ***** Possible stack size error in name *****
	ENDIF
	ENDIF
	ENDIF
name    ENDP
ENDM
.xcref  endproc
PAGE
;
; define a data item to be public and of an appropriate size/type
;

I_AM    MACRO   name,size,init
;; declare the object public
	PUBLIC  name
;; declare the type of the object
    IFIDN <size>,<WORD>
name    LABEL WORD
	I_AM_SIZE   =   1
	I_AM_LEN    =   2
    ELSE
	IFIDN <size>,<DWORD>
name    LABEL DWORD
	I_AM_SIZE   =   2
	I_AM_LEN    =   2
	ELSE
	    IFIDN <size>,<BYTE>
name    LABEL BYTE
	I_AM_SIZE   =   1
	I_AM_LEN    =   1
	    ELSE
name    LABEL BYTE
	I_AM_SIZE   =   size
	I_AM_LEN    =   1
	    ENDIF
	ENDIF
    ENDIF
;; if no initialize then allocate blank storage
    IFB <init>
	DB  I_AM_SIZE*I_AM_LEN DUP (?)
    ELSE
IF NOT InstalledData
	IRP itm,<init>
	    IF I_AM_LEN EQ 1
		DB  itm
	    ELSE
		DW  itm
	    ENDIF
	    I_AM_SIZE = I_AM_SIZE - 1
	ENDM
	IF I_AM_SIZE NE 0
	    %out    ***** initialization of name not complete *****
	ENDIF
ELSE
	DB  I_AM_SIZE*I_AM_LEN DUP (?)
ENDIF
    ENDIF
ENDM
.xcref  I_AM
.xcref  I_AM_SIZE
.xcref  I_AM_LEN
I_AM_SIZE   = 0
I_AM_LEN    = 0

PAGE

;
; define an entry in a procedure
;
entry macro name
	PUBLIC  name
name:
endm
.xcref  entry

BREAK <ERROR - store an error code then jump to a label>

error macro code
.xcref
	MOV AL,code
	transfer    SYS_RET_ERR
.cref
ENDM
.xcref  error

BREAK <JUMP - real jump that links up shortwise>
;
; given a label <lbl> either 2 byte jump to another label <lbl>_J
; if it is near enough or 3 byte jump to <lbl>
;

jump    macro lbl
    local a
.xcref

    ifndef lbl&_J                       ;; is this the first invocation
a:      JMP lbl
    ELSE
	IF (lbl&_J GE $) OR ($-lbl&_J GT 126)
a:      JMP lbl                         ;; is the jump too far away?
	ELSE
a:      JMP lbl&_J                      ;; do the short one...
	ENDIF
    ENDIF
    lbl&_j = a
.cref
endm
.xcref  jump

BREAK <RETURN - return from a function>

return  macro x
    local a
.xcref
a:
	RET
ret_l = a
.cref
endm
.xcref  return

BREAK <CONDRET - conditional return>

condret macro   cc,ncc
    local   a
.xcref
.xcref a
.cref
    ifdef   ret_l                       ;; if ret_l is defined
	if (($ - ret_l) le 126) and ($ gt ret_l)
					;;     if ret_l is near enough then
	    a:  j&cc    ret_l           ;;         a: j<CC> to ret_l
	    ret_&cc = a                 ;;         define ret_<CC> to be a:
	    exitm
	endif
    endif
    ifdef   ret_&cc                     ;; if ret_<CC> defined
	if (($ - ret_&cc) le 126) and ($ gt ret_&cc)
					;;     if ret_<CC> is near enough
	    a:  j&cc    ret_&cc         ;;         a: j<CC> to ret_<CC>
	    ret_&cc = a                 ;;         define ret_<CC> to be a:
	    exitm
	endif
    endif
    j&ncc   a                           ;; j<NCC> a:
    return                              ;; return
    a:                                  ;; a:
    ret_&cc = ret_l                     ;; define ret_<CC> to be ret_l
endm
.xcref  condret

BREAK <RETZ - return if zero, links up shortwise if necessary>

retz    macro
    condret z,nz
endm
.xcref  retz

BREAK <RETNZ - return if not zero, links up shortwise if necessary>

retnz   macro
    condret nz,z
endm
.xcref  retnz

BREAK <RETC - return if carry set, links up shortwise if necessary>

retc    macro
    condret c,nc
endm
.xcref  retc

BREAK <RETNC - return if not carry, links up shortwise if necessary>

retnc   macro
    condret nc,c
endm
.xcref  retnc

BREAK <CONTEXT - set the DOS context to a particular register>

context macro   r
	PUSH    SS
	POP     r
	ASSUME  r:DOSDATA
endm
.xcref  context

BREAK <SaveReg - save a set of registers>

SaveReg MACRO	reglist 		;; push those registers
IRP reg,<reglist>
	?stackdepth = ?stackdepth + 1
	PUSH    reg
ENDM
ENDM
.xcref  SaveReg

Save	MACRO	arglist		;; push those arguments
IRP arg,<arglist>
	?stackdepth = ?stackdepth + 1
	PUSH	arg
ENDM
ENDM
.xcref	Save

BREAK <RestoreReg - unsave some registers>

RestoreReg  MACRO   reglist		;; pop those registers
IRP reg,<reglist>
	?stackdepth = ?stackdepth - 1
	POP     reg
ENDM
ENDM
.xcref  RestoreReg

Restore MACRO	 arglist		;; pop those arguments
IRP arg,<arglist>
	?stackdepth = ?stackdepth - 1
	POP	arg
ENDM
ENDM
.xcref	Restore

BREAK <Critical section macros>

EnterCrit MACRO section
;        Invoke  E&section
ENDM

LeaveCrit MACRO section
;        Invoke  L&section
ENDM

Break   <message - display a message>

AsmVars <ShareF,Cargs,Redirector>

if debug
fmt     MACRO   typ,lev,fmts,args
local   a,b,c
	PUSHF
IFNB <typ>
	TEST    BugTyp,typ
	JZ      c
	CMP     BugLev,lev
	JB      c
ENDIF
	PUSH    AX
	PUSH    BP
	MOV     BP,SP
If (not sharef) and (not redirector)
DOSDATA segment
a       db      fmts,0
DOSDATA	 ends
	MOV	AX,OFFSET DOSDATA:a
else
	jmp     short b
a       db      fmts,0
if sharef
b:      mov     ax,offset share:a
else
b:      mov     ax,offset netwrk:a
endif
endif
	PUSH    AX
cargs = 2
IRP item,<args>
IFIDN   <AX>,<item>
	push	[bp+2]
     ;	MOV	AX,[BP+2]
ELSE
     ;	MOV	AX,item
	push	item
ENDIF
   ;	PUSH	AX
cargs = cargs + 2
ENDM
	invoke  PFMT
	ADD     SP,Cargs
	POP     BP
	POP     AX
c:
	POPF
ENDM
else
fmt macro
endm
endif

Break   <DOSAssume - validate assumes>

AsmVar  Debug,$temp

;**	DOSAssume - Check that a register addresses DOSSEG
;
;	DOSAssume  reglist, message


IF debug
DOSAssume   Macro   reglist,message
local a,b
    $temp   =	0
    IRP r,<reglist>
	IFIDN <r>,<DS>
	    $temp = $temp OR 2
	ELSE
	    IFIDN <r>,<ES>
		$temp = $temp OR 4
	    ELSE
		IFIDN <r>,<SS>
		    $temp = $temp OR 1
		ELSE
		    %out ***** Invalid register reg in DOSAssume *****
		ENDIF
	    ENDIF
	ENDIF
    ENDM
	Invoke  SegCheck
	jmp	short a
	db	$temp
	db	message,0
a:

    IRP r,<reglist>
	ASSUME	r:DOSDATA
    ENDM
ENDM

ELSE

DOSAssume   Macro   reglist,message
IRP r,<reglist>
    ASSUME  r:DOSDATA
ENDM
ENDM
ENDIF

BREAK   <ASSERT - make assertions about registers>

IF DEBUG
Assert  MACRO   kind, objs, message
	LOCAL   a,b
    IFIDN   <kind>,<Z>
	CMP     objs,0
	JZ      a
	fmt <>,<>,<message>
a:
    ELSE
	IFIDN   <kind>,<NZ>
	CMP     objs,0
	JNZ     a
	fmt <>,<>,<message>
a:
	ELSE
    PUSH    AX
	    IRP obj,<objs>
	PUSH    obj
	    ENDM
	    IF SHAREF
    MOV     AX,OFFSET b
	    ELSE
    MOV     AX,OFFSET DOSDATA:b
	    ENDIF
    PUSH    AX
	    IFIDN   <kind>,<ISBUF>
	Invoke  BUFCheck
	    ENDIF
	    IFIDN   <kind>,<ISSFT>
	Invoke  SFTCheck
	    ENDIF
	    IFIDN   <kind>,<ISDPB>
	Invoke  DPBCheck
	    ENDIF
    POP     AX
	    IF SHAREF
    JMP SHORT a
b   DB  Message,0
a:
	    ELSE
DOSDATA	 segment
b   db  Message,0
DOSDATA	 ends
	    ENDIF
	ENDIF
    ENDIF
ENDM
ELSE
Assert  Macro
ENDM
ENDIF

Break   <CallInstall - hook to installable pieces>

CallInstall MACRO   name,mpx,fn,save,restore
IF Installed
    IFNB    <save>
	SaveReg <save>
    ENDIF
	MOV     AX,(mpx SHL 8) + fn
	INT     2Fh
    IFNB    <restore>
	RestoreReg  <restore>
    ENDIF
ELSE
	Invoke  name
ENDIF
ENDM

Break   <Stack frame manipulators>

localvar    macro   name,length
local   a
	ifidn   <length>,<BYTE>
	    ?frame =  ?frame + 1
	    a = ?frame
	    name EQU  BYTE PTR [BP-a]
	else
	    ifidn   <length>,<WORD>
		?frame =  ?frame + 2
		a = ?frame
		name EQU  WORD PTR [BP-a]
	    else
		ifidn   <length>,<DWORD>
		    ?frame =  ?frame + 4
		    a = ?frame
		    name EQU  DWORD PTR [BP-a]
		    name&l EQU  WORD PTR [BP-a]
		    name&h EQU  WORD PTR [BP-a+2]
		else
		    ?frame =  ?frame + length
		    a = ?frame
		    name EQU  BYTE PTR [BP-a]
		endif
	    endif
	endif
endm

enter   macro
	push    bp
	mov     bp,sp
	sub     sp,?frame
endm

leave   macro
	mov     sp,bp
	pop     bp
endm

Argvar  macro   name,length
local   a
	ifidn   <length>,<BYTE>
	    a = ?aframe
	    ?aframe =  ?aframe + 1
	    name EQU  BYTE PTR [BP+a]
	else
	    ifidn   <length>,<WORD>
		a = ?aframe
		?aframe =  ?aframe + 2
		name EQU  WORD PTR [BP+a]
	    else
		ifidn   <length>,<DWORD>
		    a = ?aframe
		    ?aframe =  ?aframe + 4
		    name EQU  DWORD PTR [BP+a]
		    name&l EQU  WORD PTR [BP+a]
		    name&h EQU  WORD PTR [BP+a+2]
		else
		    a = ?aframe
		    ?aframe =  ?aframe + length
		    name EQU  BYTE PTR [BP+a]
		endif
	    endif
	endif
endm


save_world 	macro

	push	es
	invoke	save_user_world

endm

restore_world	macro

	invoke	restore_user_world
	pop	es

endm

;
; This macro gets the DOS data segment value and puts it in the specified
; segment register.  This can only be used in the DOSCODE segment.
;

getdseg	macro 	r

	mov	r, cs:[DosDseg]
	assume	r:dosdata
endm

;
; This macro does the necessary extrns to allow use of the getdseg macro.
;
allow_getdseg macro

ifdef ROMDOS
	extrn	BioDataSeg:word
	bdata	segment at 70H
	extrn	DosDataSg:word
	bdata	ends
else
	extrn	DosDseg:word
endif

endm



BREAK <LJcc - Long Conditional Jumps>

LJE macro l
 LJ JE JNE l
endm

LJNE macro l
 LJ jne JE l
endm

LJZ macro l
 LJE l
endm

LJNZ macro l
 LJNE l
endm

LJC macro l
 LJ jc JNC l
endm

LJNC macro l
 LJ jnc JC l
endm

LJA macro l
 LJ ja JNA l
endm

LJNA macro l
 LJ jna JA l
endm

LJB macro l
 LJ jb JNB l
endm

LJNB macro l
 LJ jnb JB l
endm

LJS macro l
 LJ js JNS l
endm

LJNS macro l
 LJ jns JS l
endm

LJAE macro l
 LJ jae JNAE l
endm

LJBE macro l
 LJ jbe JNBE l
endm

LJL macro l
 LJ jl JNL l
endm

LJG macro l
 LJ jg JNG l
endm

LJLE macro l
 LJ jle JNLE l
endm

DLJE macro l
 DLJ JE JNE l
endm

DLJNE macro l
 DLJ jne JE l
endm

DLJZ macro l
 DLJE l
endm

DLJNZ macro l
 DLJNE l
endm

DLJC macro l
 DLJ jc JNC l
endm

DLJNC macro l
 DLJ jnc JC l
endm

DLJA macro l
 DLJ ja JNA l
endm

DLJNA macro l
 DLJ jna JA l
endm

DLJB macro l
 DLJ jb JNB l
endm

DLJNB macro l
 DLJ jnb JB l
endm

DLJS macro l
 DLJ js JNS l
endm

DLJNS macro l
 DLJ jns JS l
endm

DLJAE macro l
 DLJ jae JNAE l
endm

DLJBE macro l
 DLJ jbe JNBE l
endm

DLJG macro l
 DLJ jg JNG l
endm

DLJL macro l
 DLJ jl JNL l
endm

DLJLE macro l
 DLJ jle JNLE l
endm


;*	LJ - generate long conditional jump
;
;	if target preceeds us and is in range just use a short jump
;	else use a long jump
;
;	LJ <direct jmp>,<skip jmp>,<label>

LJ MACRO dirop,idirop,l
 local a
 IF ((.TYPE l) XOR 20h) AND 0A0h
  idirop a			       ;; not defined or is external
  jmp l
a:
 ELSE				       ;; is local definied
  IF (($-l) LT 124) AND ($ GT l)
   dirop l			      ;; is before and within range
  ELSE
   idirop a			      ;; is out of range or forward (pass 2)
   jmp l
a:
  ENDIF
 ENDIF
ENDM


;*	DLJ - generate debug long conditional jump
;
;	If DEBUG is defined then we generate a long jump, else a short
;	one.
;
;	DLJ <direct jmp>,<skip jmp>,<label>

DLJ MACRO dirop,idirop,l
 local a
 IF DEBUG
  idirop a
  jmp l
a:
 ELSE
  dirop l
 ENDIF
ENDM

.xcref	LJE, LJNE, LJZ, LJNZ, LJC, LJNC, LJA, LJNA
.xcref	LJB, LJNB, LJS, LJNS, LJAE, LJBE, LJG, LJL, LJLE
.xcref	DLJE, DLJNE, DLJZ, DLJNZ, DLJC, DLJNC, DLJA, DLJNA
.xcref	DLJB, DLJNB, DLJS, DLJNS, DLJAE, DLJBE, DLJG, DLJL, DLJLE
.xcref	LJ,DLJ



;**	SHORT offset macro
;
;	expands to SHORT if non debug, to nul if debug.
;
;	this allows us to code
;
;		jmp	SHRT foobar
;
;	and get a long form if debugging is turned on (because the extra
;	debug code puts the target out of range)

if DEBUG
  SHRT	EQU	<>
else
  SHRT	EQU	SHORT
endif


;**	FALLTHRU - Verifies Fallthrough Validity

FALLTHRU MACRO	labl
;	BUGBUG - restore align when we make code segment word aligned
;	align	2		; don't have errnz fail due to alignment
    IF2 			; of following label
	.errnz	labl-$
    ENDIF
	ENDM


;**	INTTEST - Generate an INT 3 for testing

INTTEST MACRO
if DEBUG
	int	3
endif
	ENDM


;**	DPUBLIC - Make a public symbol for debugging

DPUBLIC MACRO	arg
if DEBUG
	public	arg
endif
	ENDM

;*	Debug Traps
;
;	These are removed as the code is exercised

TRAP	macro			; Like INTTEST but is normally left in during
	int	3		; debugging; indicates "should not occur"
	ENDM

TRAPC	macro
	local	l
	jnc	short l
	int	3
l:
	ENDM

TRAPNC	macro
	local	l
	jc	short l
	int	3
l:
	ENDM

TRAPA	macro
	local	l
	jna	short l
	int	3
l:
	ENDM

TRAPNA	macro
	local	l
	ja	short l
	int	3
l:
	ENDM

TRAPZ	macro
	local	l
	jnz	short l
	int	3
l:
	ENDM

TRAPNZ	macro
	local	l
	jz	short l
	int	3
l:
	ENDM



	BREAK	<Structure Field Macros>


;**	Follows - Verify that a field follows another
;
;	FOLLOWS field1, field2 [, size]
;
;	This macro generates an error if "field1" doesn't immeidately
;	follow "field2".  If "size" is specified then an error is generated
;	if Field1 is not of the proper size.

FOLLOWS macro	field1, field2, fldsiz
	.errnz	field1 - size field2 - field2
IFNB	<fldsiz>
	.errnz	size field1 - fldsiz
ENDIF
	ENDM



;**	LAST - Verify that a field is the last field in a structure
;
;	LAST	fieldname, structname
;
;	Generates an error if fieldname is not last in structname.

LAST	macro	fldnam, strunam
	.errnz	size strunam - fldnam - size fldnam
	endm



;**	TESTB - Use Byte form for Word TESTS, when possible
;
;	TESTB is used in place of 16-bit TEST instructions.  It substitutes
;	a smaller 8-bit test when possible.

TESTB	macro	targ,mask,thirdarg
	local	mask2,delta

ifnb <thirdarg>
	.err	mask must be enclosed in brackets
endif

ifidn <targ>,<[bx]>
	test	targ,mask
	exitm
endif
ifidn <targ>,<[si]>
	test	targ,mask
	exitm
endif
ifidn <targ>,<[di]>		; don't process these operands specially
	test	targ,mask
	exitm
endif
ifidn <targ>,<[BX]>
	test	targ,mask
	exitm
endif
ifidn <targ>,<[SI]>
	test	targ,mask
	exitm
endif
ifidn <targ>,<[DI]>
	test	targ,mask
	exitm
endif
ifidn <targ>,<SI>
	test	targ,mask
	exitm
endif
ifidn <targ>,<DI>
	test	targ,mask
	exitm
endif
ifidn <targ>,<BP>
	test	targ,mask
	exitm
endif
delta	=	0
mask2	=	mask

    if	mask2 AND 0ff00h
;	have a mask bit in the high half
	if mask2 AND 0ffh
	    test targ,mask
	    exitm
	endif
	mask2 = mask2 SHR 8
	delta = 1
    endif

ifidn <targ>,<AX>
	if delta
	    test targ,mask
	else
	    test AL,mask2
	endif
	exitm
endif
ifidn <targ>,<BX>
	if delta
	  test	BH,mask2
	else
	  test	BL,mask2
	endif
	exitm
endif
ifidn <targ>,<CX>
	if delta
	  test	CH,mask2
	else
	  test	CL,mask2
	endif
	exitm
endif
ifidn <targ>,<DX>
	if delta
	  test	DH,mask2
	else
	  test	DL,mask2
	endif
	exitm
endif
ifidn <targ>,<ax>
	if delta
	    test targ,mask
	else
	    test AL,mask2
	endif
	exitm
endif
ifidn <targ>,<bx>
	if delta
	  test	BH,mask2
	else
	  test	BL,mask2
	endif
	exitm
endif
ifidn <targ>,<cx>
	if delta
	  test	CH,mask2
	else
	  test	CL,mask2
	endif
	exitm
endif
ifidn <targ>,<dx>
	if delta
	  test	DH,mask2
	else
	  test	DL,mask2
	endif
	exitm
endif

	test	byte ptr targ+delta,mask2
	endm


;
; Some old versions of the 80286 have a bug in the chip.  The popf
; instruction will enable interrupts.  Therefore in a section of code with
; interrupts disabled and you need a popf instruction use the 'popff'
; macro instead.
;

POPFF	macro
	jmp	$+3
	iret
	push	cs
	call	$-2
	endm

Break   <Cmp32 - 32-bit compare>
;----------------------------------------------------------------------------
;
; Macro Name : Cmp32
;
; Inputs:
;       msw1 -- 1st operand, most  significant word; MUST BE REGISTER.
;       lsw1 -- 1st operand, least significant word; MUST BE REGISTER.
;       msw2 -- 2nd operand, most  significant word.
;       lsw2 -- 2nd operand, least significant word.
; Function:
;       Compare 2 32-bit operands.  Implemented as a macro.
; Outputs:
;       CF = 1 if 1st operand <  2nd operand
;          = 0 if 1st operand >= 2nd operand
;	ZF = 1 if 1st operand == 2nd operand
;          = 0 if 1st operand <> 2nd operand
;-----------------------------------------------------------------------------
;M019: Created.

Cmp32   MACRO   msw1,lsw1,msw2,lsw2
        LOCAL   cmp32x

        cmp     msw1,msw2
        jne     cmp32x
        cmp     lsw1,lsw2
cmp32x:
	ENDM

Break	<HRDSVC - SVC call where hard error is possible>
;----------------------------------------------------------------------------
;
; Macro Name : HRDSVC
;
; Inputs:
;	iSVC -- SVC index
; Function:
;	Make a DEM SVC. If hard error happens handle it.
; Outputs:
;	CF = 1 if operation failed
;	   = 0 if operation successful
;-----------------------------------------------------------------------------

HRDSVC	MACRO	iSVC
	LOCAL	hs_nerr,hs_fail,hs_retry

	SVC	iSVC
	jnc	hs_nerr

	; Check if hard err to be handled . If no harderr then it
	; will come back without effecting any reg or carry flags.
	; Else it will do an int24. If user chooses retry it
	; will retry the SVC call. On fail or abort it will
	; come back with usual dos style setup.
	; If user chose "Abort" it wont come back

	invoke	TestHrdErr
hs_nerr:
        ENDM

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\error.inc ===
BREAK	<DOS error codes>

;**	ERROR.INC - DOS Error Codes
;
;    The newer (DOS 2.0 and above) "XENIX-style" calls
;    return error codes through AX.	If an error occurred then
;    the carry bit will be set and the error code is in AX.	If no error
;    occurred then the carry bit is reset and AX contains returned info.
;
;    Since the set of error codes is being extended as we extend the operating
;    system, we have provided a means for applications to ask the system for a
;    recommended course of action when they receive an error.
;
;    The GetExtendedError system call returns a universal error, an error
;    location and a recommended course of action.	The universal error code is
;    a symptom of the error REGARDLESS of the context in which GetExtendedError
;    is issued.


;	2.0 error codes

error_invalid_function		EQU	1
error_file_not_found		EQU	2
error_path_not_found		EQU	3
error_too_many_open_files	EQU	4
error_access_denied		EQU	5
error_invalid_handle		EQU	6
error_arena_trashed		EQU	7
error_not_enough_memory 	EQU	8
error_invalid_block		EQU	9
error_bad_environment		EQU	10
error_bad_format		EQU	11
error_invalid_access		EQU	12
error_invalid_data		EQU	13
;**** reserved			EQU	14	; *****
error_invalid_drive		EQU	15
error_current_directory 	EQU	16
error_not_same_device		EQU	17
error_no_more_files		EQU	18

;	These are the universal int 24 mappings for the old INT 24 set of errors

error_write_protect		EQU	19
error_bad_unit			EQU	20
error_not_ready 		EQU	21
error_bad_command		EQU	22
error_CRC			EQU	23
error_bad_length		EQU	24
error_Seek			EQU	25
error_not_DOS_disk		EQU	26
error_sector_not_found		EQU	27
error_out_of_paper		EQU	28
error_write_fault		EQU	29
error_read_fault		EQU	30
error_gen_failure		EQU	31

;	the new 3.0 error codes reported through INT 24

error_sharing_violation 	EQU	32
error_lock_violation		EQU	33
error_wrong_disk		EQU	34
error_FCB_unavailable		EQU	35
error_sharing_buffer_exceeded	EQU	36
error_Code_Page_Mismatched	EQU	37    ; DOS 4.00 			;AN000;
error_handle_EOF		EQU	38    ; DOS 4.00 			;AN000;
error_handle_Disk_Full		EQU	39    ; DOS 4.00 			;AN000;

;	New OEM network-related errors are 50-79

error_not_supported		EQU	50

error_net_access_denied		EQU	65	;M028

;	End of INT 24 reportable errors

error_file_exists		EQU	80
error_DUP_FCB			EQU	81	; *****
error_cannot_make		EQU	82
error_FAIL_I24			EQU	83

;	New 3.0 network related error codes

error_out_of_structures 	EQU	84
error_Already_assigned		EQU	85
error_invalid_password		EQU	86
error_invalid_parameter 	EQU	87
error_NET_write_fault		EQU	88
error_sys_comp_not_loaded	EQU	90    ; DOS 4.00				;AN000;




	BREAK <Interrupt 24 error codes>

;**	Int24 Error Codes

error_I24_write_protect 	EQU	0
error_I24_bad_unit		EQU	1
error_I24_not_ready		EQU	2
error_I24_bad_command		EQU	3
error_I24_CRC			EQU	4
error_I24_bad_length		EQU	5
error_I24_Seek			EQU	6
error_I24_not_DOS_disk		EQU	7
error_I24_sector_not_found	EQU	8
error_I24_out_of_paper		EQU	9
error_I24_write_fault		EQU	0Ah
error_I24_read_fault		EQU	0Bh
error_I24_gen_failure		EQU	0Ch
; NOTE: Code 0DH is used by MT-DOS.
error_I24_wrong_disk		EQU	0Fh


;	THE FOLLOWING ARE MASKS FOR THE AH REGISTER ON Int 24
;
;	NOTE: ABORT is ALWAYS allowed

Allowed_FAIL			EQU	00001000B
Allowed_RETRY			EQU	00010000B
Allowed_IGNORE			EQU	00100000B

I24_operation			EQU	00000001B	;Z if READ,NZ if Write
I24_area			EQU	00000110B	; 00 if DOS
							; 01 if FAT
							; 10 if root DIR
							; 11 if DATA
I24_class			EQU	10000000B	;Z if DISK, NZ if FAT or char


	BREAK <GetExtendedError CLASSes ACTIONs LOCUSs>

;**	The GetExtendedError call takes an error code and returns CLASS,
;	ACTION and LOCUS codes to help programs determine the proper action
;	to take for error codes that they don't explicitly understand.


;	Values for error CLASS

errCLASS_OutRes 	EQU	1	; Out of Resource
errCLASS_TempSit	EQU	2	; Temporary Situation
errCLASS_Auth		EQU	3	; Permission problem
errCLASS_Intrn		EQU	4	; Internal System Error
errCLASS_HrdFail	EQU	5	; Hardware Failure
errCLASS_SysFail	EQU	6	; System Failure
errCLASS_Apperr 	EQU	7	; Application Error
errCLASS_NotFnd 	EQU	8	; Not Found
errCLASS_BadFmt 	EQU	9	; Bad Format
errCLASS_Locked 	EQU	10	; Locked
errCLASS_Media		EQU	11	; Media Failure
errCLASS_Already	EQU	12	; Collision with Existing Item
errCLASS_Unk		EQU	13	; Unknown/other

;	Values for error ACTION

errACT_Retry		EQU	1	; Retry
errACT_DlyRet		EQU	2	; Delay Retry, retry after pause
errACT_User		EQU	3	; Ask user to regive info
errACT_Abort		EQU	4	; abort with clean up
errACT_Panic		EQU	5	; abort immediately
errACT_Ignore		EQU	6	; ignore
errACT_IntRet		EQU	7	; Retry after User Intervention

;	Values for error LOCUS

errLOC_Unk		EQU	1	; No appropriate value
errLOC_Disk		EQU	2	; Random Access Mass Storage
errLOC_Net		EQU	3	; Network
errLOC_SerDev		EQU	4	; Serial Device
errLOC_Mem		EQU	5	; Memory
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\sf.inc ===
BREAK <Internal system file table format>


;**	SF.INC - System File Table
;
;   AN000   version 4.00   Jan. 1988
;   AN003   PTM 3680 --  make NAME offset the same as before (<=3.30)
;   AN009   PTM 3839	 reorder SFT for MS WINDOWS


;**	System File Table SuperStructure
;
;	The system file table entries are allocated in contiguous groups.
;	There may be more than one such groups; the SF "superstructure"
;	tracks the groups.

SF		STRUC
SFLink		DD	?
SFCount 	DW	?		; number of entries
SFTable 	DW	?		; beginning of array of the following
SF		ENDS


;**	System file table entry
;
;	These are the structures which are at SFTABLE in the SF structure.

sf_entry	STRUC
sf_ref_count	DW	?		; number of processes sharing entry
					;   if FCB then ref count
sf_mode 	DW	?		; mode of access or high bit on if FCB
sf_attr 	DB	?		; attribute of file
sf_flags	DW	?		;Bits 8-15
					; Bit 15 = 1 if remote file
					;	 = 0 if local file or device
					; Bit 14 = 1 if date/time is not to be
					;   set from clock at CLOSE.  Set by
					;   FILETIMES and FCB_CLOSE.  Reset by
					;   other reseters of the dirty bit
					;   (WRITE)
					; Bit 13 = Pipe bit (reserved)
					;
					; Bits 0-7 (old FCB_devid bits)
					; If remote file or local file, bit
					; 6=0 if dirty Device ID number, bits
					; 0-5 if local file.
					; bit 7=0 for local file, bit 7
					;      =1 for local I/O device
					; If local I/O device, bit 6=0 if EOF (input)
					;		Bit 5=1 if Raw mode
					;		Bit 0=1 if console input device
					;		Bit 1=1 if console output device
					;		Bit 2=1 if null device
					;		Bit 3=1 if clock device
sf_devptr	DD	?		; Points to device header
sf_time 	DW	?		; Time associated with file
sf_date 	DW	?		; Date associated with file
sf_size 	DD	?		; Size associated with file
sf_position	DD	?		; LRU count for FCBs

; SHARING INFO
sf_chain	DD	?		; link to next SF
sf_PID		DW	?
sf_NTHandle	DD	?		; NT File Handle
sf_entry	ENDS

sf_OpenAge	EQU	WORD PTR sf_position+2
sf_LRU		EQU	WORD PTR sf_position

sf_default_number   EQU     5h

;
; Note that we need to mark an SFT as being busy for OPEN/CREATE.  This is
; because an INT 24 may prevent us from 'freeing' it.  We mark this as such
; by placing a -1 in the ref_count field.
;

sf_busy EQU -1


; Flag word masks
sf_isfcb		EQU	1000000000000000B
sf_isnet		EQU	1000000000000000B
sf_close_nodate 	EQU	0100000000000000B
sf_pipe 		EQU	0010000000000000B
sf_no_inherit		EQU	0001000000000000B
sf_net_spool		EQU	0000100000000000B
sf_scs_console          EQU     0000010000000000B   ; special for NT DOSEM
sf_nt_seek		EQU	0000001000000000B   ; special for NT DOSEM
sf_nt_pipe_in		EQU	0000000100000000B   ; for stdin redirection
                                                    ; true if seek is needed
                                                    ; with next read/write operation

devid_file_clean	EQU	40h	; true if file and not written
devid_file_mask_drive	EQU	3Fh	; mask for drive number

devid_device		EQU	80h	; true if a device
devid_device_EOF	EQU	40h	; true if end of file reached
devid_device_raw	EQU	20h	; true if in raw mode
devid_device_special	EQU	10h	; true if special device
devid_device_clock	EQU	08h	; true if clock device
devid_device_null	EQU	04h	; true if null device
devid_device_con_out	EQU	02h	; true if console output
devid_device_con_in	EQU	01h	; true if consle input

;
; structure of devid field as returned by IOCTL is:
;
;	BIT	7   6	5   4	3   2	1   0
;	      |---|---|---|---|---|---|---|---|
;	      | I | E | R | S | I | I | I | I |
;	      | S | O | A | P | S | S | S | S |
;	      | D | F | W | E | C | N | C | C |
;	      | E |   |   | C | L | U | O | I |
;	      | V |   |   | L | K | L | T | N |
;	      |---|---|---|---|---|---|---|---|
;	ISDEV = 1 if this channel is a device
;	      = 0 if this channel is a disk file
;
;	If ISDEV = 1
;
;	      EOF = 0 if End Of File on input
;	      RAW = 1 if this device is in Raw mode
;		  = 0 if this device is cooked
;	      ISCLK = 1 if this device is the clock device
;	      ISNUL = 1 if this device is the null device
;	      ISCOT = 1 if this device is the console output
;	      ISCIN = 1 if this device is the console input
;
;	If ISDEV = 0
;	      EOF = 0 if channel has been written
;	      Bits 0-5	are  the  block  device  number  for
;		  the channel (0 = A, 1 = B, ...)
;
devid_ISDEV	EQU	80h
devid_EOF	EQU	40h
devid_RAW	EQU	20h
devid_SPECIAL	EQU	10H
devid_ISCLK	EQU	08h
devid_ISNUL	EQU	04h
devid_ISCOT	EQU	02h
devid_ISCIN	EQU	01h

devid_block_dev EQU	1Fh		; mask for block device number

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file contains the function declarations for
*	commonly used library functions which either don't fit somewhere
*	else, or, like toupper/tolower, can't be declared in the normal
*	place for other reasons.
*	[ANSI]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifdef	_DLL
#define _LOADDS_ _loadds
#else
#define _LOADDS_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* define NULL pointer value */

#ifndef NULL
#if (_MSC_VER >= 600)
#define NULL	((void *)0)
#elif (defined(M_I86SM) || defined(M_I86MM))
#define NULL	0
#else
#define NULL	0L
#endif
#endif

/* definition of the return type for the onexit() function */

#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1

#ifndef _ONEXIT_T_DEFINED
typedef int (_FAR_ _cdecl _LOADDS_ * _cdecl onexit_t)();
#define _ONEXIT_T_DEFINED
#endif


/* data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
	int quot;
	int rem;
} div_t;

typedef struct _ldiv_t {
	long quot;
	long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif

/* maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff


/* min and max macros */

#define max(a,b)	(((a) > (b)) ? (a) : (b))
#define min(a,b)	(((a) < (b)) ? (a) : (b))


/* sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */

#define _MAX_PATH	260	/* max. length of full pathname */
#define _MAX_DRIVE	3	/* max. length of drive component */
#define _MAX_DIR	256	/* max. length of path component */
#define _MAX_FNAME	256	/* max. length of file name component */
#define _MAX_EXT	256	/* max. length of extension component */

/* external variable declarations */

#ifdef	_MT
extern int _far * _cdecl _far volatile _errno(void);
extern unsigned _far * _cdecl _far __doserrno(void);
#define errno	    (*_errno())
#define _doserrno   (*__doserrno())
#else
extern int _near _cdecl volatile errno; 	/* XENIX style error number */
extern int _near _cdecl _doserrno;		/* MS-DOS system error value */
#endif
extern char * _near _cdecl sys_errlist[];	/* perror error message table */
extern int _near _cdecl sys_nerr;		/* # of entries in sys_errlist table */

#ifdef _DLL
extern char ** _FAR_ _cdecl environ;		/* pointer to environment table */
extern int _FAR_ _cdecl _fmode; 		/* default file translation mode */
extern int _FAR_ _cdecl _fileinfo;		/* open file info mode (for spawn) */
#else
extern char ** _near _cdecl environ;		/* pointer to environment table */
extern int _near _cdecl _fmode; 		/* default file translation mode */
extern int _near _cdecl _fileinfo;		/* open file info mode (for spawn) */
#endif

extern unsigned int _near _cdecl _psp;		/* Program Segment Prefix */

/* OS major/minor version numbers */

#ifndef _WINDLL
extern unsigned char _near _cdecl _osmajor;
extern unsigned char _near _cdecl _osminor;
#endif

#define DOS_MODE	0	/* Real Address Mode */
#define OS2_MODE	1	/* Protected Address Mode */

extern unsigned char _near _cdecl _osmode;


/* function prototypes */

#ifdef	_MT
double _FAR_ _pascal atof(const char _FAR_ *);
double _FAR_ _pascal strtod(const char _FAR_ *, char _FAR_ * _FAR_ *);
ldiv_t _FAR_ _pascal ldiv(long, long);
#else	/* not _MT */
double _FAR_ _cdecl atof(const char _FAR_ *);
double _FAR_ _cdecl strtod(const char _FAR_ *, char _FAR_ * _FAR_ *);
ldiv_t _FAR_ _cdecl ldiv(long, long);
#endif

void _FAR_ _cdecl abort(void);
int _FAR_ _cdecl abs(int);
int _FAR_ _cdecl atexit(void (_cdecl _FAR_ _LOADDS_ *)(void));
int _FAR_ _cdecl atoi(const char _FAR_ *);
long _FAR_ _cdecl atol(const char _FAR_ *);
long double _FAR_ _cdecl _atold(const char _FAR_ *);
void _FAR_ * _FAR_ _cdecl bsearch(const void _FAR_ *, const void _FAR_ *,
	size_t, size_t, int (_FAR_ _cdecl *)(const void _FAR_ *,
	const void _FAR_ *));
void _FAR_ * _FAR_ _cdecl calloc(size_t, size_t);
div_t _FAR_ _cdecl div(int, int);
char _FAR_ * _FAR_ _cdecl ecvt(double, int, int _FAR_ *, int _FAR_ *);
void _FAR_ _cdecl exit(int);
void _FAR_ _cdecl _exit(int);
char _FAR_ * _FAR_ _cdecl fcvt(double, int, int _FAR_ *, int _FAR_ *);
void _FAR_ _cdecl free(void _FAR_ *);
char _FAR_ * _FAR_ _cdecl _fullpath(char _FAR_ *, const char _FAR_ *,
	size_t);
#ifndef _WINDLL
char _FAR_ * _FAR_ _cdecl gcvt(double, int, char _FAR_ *);
#endif
char _FAR_ * _FAR_ _cdecl getenv(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl itoa(int, char _FAR_ *, int);
long _FAR_ _cdecl labs(long);
unsigned long _FAR_ _cdecl _lrotl(unsigned long, int);
unsigned long _FAR_ _cdecl _lrotr(unsigned long, int);
char _FAR_ * _FAR_ _cdecl ltoa(long, char _FAR_ *, int);
void _FAR_ _cdecl _makepath(char _FAR_ *, const char _FAR_ *,
	const char _FAR_ *, const char _FAR_ *, const char _FAR_ *);
void _FAR_ * _FAR_ _cdecl malloc(size_t);
onexit_t _FAR_ _cdecl onexit(onexit_t);
#ifndef _WINDOWS
void _FAR_ _cdecl perror(const char _FAR_ *);
#endif
int _FAR_ _cdecl putenv(const char _FAR_ *);
void _FAR_ _cdecl qsort(void _FAR_ *, size_t, size_t, int (_FAR_ _cdecl *)
	(const void _FAR_ *, const void _FAR_ *));
unsigned int _FAR_ _cdecl _rotl(unsigned int, int);
unsigned int _FAR_ _cdecl _rotr(unsigned int, int);
int _FAR_ _cdecl rand(void);
void _FAR_ * _FAR_ _cdecl realloc(void _FAR_ *, size_t);
void _FAR_ _cdecl _searchenv(const char _FAR_ *, const char _FAR_ *,
	char _FAR_ *);
void _FAR_ _cdecl _splitpath(const char _FAR_ *, char _FAR_ *,
	char _FAR_ *, char _FAR_ *, char _FAR_ *);
void _FAR_ _cdecl srand(unsigned int);
long _FAR_ _cdecl strtol(const char _FAR_ *, char _FAR_ * _FAR_ *,
	int);
long double _FAR_ _cdecl _strtold(const char _FAR_ *,
	char _FAR_ * _FAR_ *);
unsigned long _FAR_ _cdecl strtoul(const char _FAR_ *,
	char _FAR_ * _FAR_ *, int);
void _FAR_ _cdecl swab(char _FAR_ *, char _FAR_ *, int);
#ifndef _WINDOWS
int _FAR_ _cdecl system(const char _FAR_ *);
#endif
char _FAR_ * _FAR_ _cdecl ultoa(unsigned long, char _FAR_ *, int);

#ifndef tolower 	/* tolower has been undefined - use function */
int _FAR_ _cdecl tolower(int);
#endif	/* tolower */

#ifndef toupper 	/* toupper has been undefined - use function */
int _FAR_ _cdecl toupper(int);
#endif	/* toupper */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\mult.inc ===
;       SCCSID = @(#)mult.asm   1.2 85/04/12
	Break <Multiplex channels>

; The current set of defined multiplex channels is (* means documented):
;
;   Channel(h)  Issuer          Receiver    Function
;      00       server          PSPRINT     print job control
;     *01       print/apps      PRINT       Queueing of files
;      02       BIOS            REDIR       signal open/close of printers
;
;      05       command         REDIR       obtain text of net int 24 message
;     *06       server/assign   ASSIGN      Install check
;
;      08       external driver IBMBIO      interface to internal routines
;
;      10       sharer/server   Sharer      install check
;      11       DOS/server      Redir       install check/redirection funcs
;      12       sharer/redir    DOS         dos functions and structure maint
;      13       MSNET           MSNET       movement of NCBs
;      13       external driver IBMBIO      Reset_Int_13, allows installation
;                                           of alternative INT_13 drivers after
;                                           boot_up
;      14 (IBM) DOS             NLSFUNC     down load NLS country info,DOS 3.3
;      14 (MS)  APPS            POPUP       MSDOS 4 popup screen functions
;      15       APPS            MSCDEX      CD-ROM extensions interface
;      16       WIN386          WIN386      Windows communications
;      17       Clipboard       WINDOWS     Clipboard interface
;     *18       Applications    MS-Manger   Toggle interface to manager
;      19       Shell
;      1A       Ansi.sys
;      1B       Fastopen,Vdisk   IBMBIO     EMS INT 67H stub handler
;
;      40h      OS/2
;      41h      Lanman
;      42h      Lanman
;      43h      Himem
;                               AL = 20h    reserved for Mach 20 Himem support
;                               AL = 30h    reserved for Himem external A20 code
;      44h      Dosextender
;      45H      Windows profiler
;      46h      Windows/286 DOS extender
;      47h      Basic Compiler Vn. 7.0
;      48h      Doskey
;      49h      DOS 5.x install 
;      4ah      Multi Purpose
;                multMULTSWPDSK         0 - Swap Disk in drive A (BIOS)
;                multMULTGETHMAPTR      1 - Get available HMA & ptr
;                multMULTALLOCHMA       2 - Allocate HMA (bx == no of bytes)
;                multMULTTASKSHELL      5 - Shell/switcher API
;		 multMULTRPLTOM		6 - Top Of Memory for RPL support
;      4bh      Task Switcher API
;
;      4ch      APPS            APM             Advanced power management
;      4dh      Kana Kanji Converter, MSKK
;
;      55h	COMMAND.COM
;		 multCOMFIRST		0 - API to determine whether 1st
;					    instance of command.com
;      AB       Unspecified IBM use
;      AC       Graphics
;      AD       NLS (toronto)
;      AE
;      AF       Mode
;      B0       GRAFTABL        GRAFTABL
;
;      D7       Banyan VINES


;MUX 00-3F reserverd for IBM
;MUX 80-BF reserverd for IBM

;MUX 40-7F reserved for Microsoft

;MUX C0-FF users



MultSHARE   EQU     10h                 ; sharer
    ;   1   MFT_enter
    ;   2   MFTClose
    ;   3   MFTclU
    ;   4   MFTCloseP
    ;   5   MFTCloN
    ;   6   set_block
    ;   7   clr_block
    ;   8   chk_block
    ;   9   MFT_get
    ;   10  ShSave
    ;   11  ShChk
    ;   12  ShCol
    ;   13  ShCloseFile

MultNET     EQU     11h                 ; Network support
MultIFS     EQU     11h                 ; Network support
    ;   1   IFS_RMDIR
    ;   2   IFS_SEQ_RMDIR
    ;   3   IFS_MKDIR
    ;   4   IFS_SEQ_MKDIR
    ;   5   IFS_CHDIR
    ;   6   IFS_CLOSE
    ;   7   IFS_COMMIT
    ;   8   IFS_READ
    ;   9   IFS_WRITE
    ;   10  IFS_LOCK
    ;   11  IFS_UNLOCK
    ;   12  IFS_DISK_INFO
    ;   13  IFS_SET_FILE_ATTRIBUTE
    ;   14  IFS_SEQ_SET_FILE_ATTRIBUTE
    ;   15  IFS_GET_FILE_INFO
    ;   16  IFS_SEQ_GET_FILE_INFO
    ;   17  IFS_RENAME
    ;   18  IFS_SEQ_RENAME
    ;   19  IFS_DELETE
    ;   20  IFS_SEQ_DELETE
    ;   21  IFS_OPEN
    ;   22  IFS_SEQ_OPEN
    ;   23  IFS_CREATE
    ;   24  IFS_SEQ_CREATE
    ;   25  IFS_SEQ_SEARCH_FIRST
    ;   26  IFS_SEQ_SEARCH_NEXT
    ;   27  IFS_SEARCH_FIRST
    ;   28  IFS_SEARCH_NEXT
    ;   29  IFS_ABORT
    ;   30  IFS_ASSOPER
    ;   31  Printer_SET_STRING
    ;   32  IFSFlushBuf
    ;   33  IFSBufWrite
    ;   34  IFSResetEnvironment
    ;   35  IFSSpoolCheck
    ;   36  IFSSpoolClose
    ;   37  IFSDeviceOper
    ;   38  IFSSpoolEchoCheck
    ;   39      - - -   Unused   - - -
    ;   40      - - -   Unused   - - -
    ;   41      - - -   Unused   - - -
    ;   42  SERVER_DOSCALL_CLOSEFILES_FOR_UID
    ;   43  DEVICE_IOCTL
    ;   44  IFS_UPDATE_CB
    ;   45  IFS_FILE_XATTRIBUTES
    ;   46  IFS_XOPEN
    ;   47  IFS_DEPENDENT_IOCTL

MultDOS     EQU     12h                 ; DOS call back
    ;   1   DOS_CLOSE
    ;   2   RECSET
    ;   3   Get DOSGROUP
    ;   4   PATHCHRCMP
    ;   5   OUT
    ;   6   NET_I24_ENTRY
    ;   7   PLACEBUF
    ;   8   FREE_SFT
    ;   9   BUFWRITE
    ;   10  SHARE_VIOLATION
    ;   11  SHARE_ERROR
    ;   12  SET_SFT_MODE
    ;   13  DATE16
    ;   14  Unused              (was SETVISIT)
    ;   15  SCANPLACE
    ;   16  Unused              (was SKIPVISIT)
    ;   17  StrCpy
    ;   18  StrLen
    ;   19  Ucase
    ;   20  POINTCOMP
    ;   21  CHECKFLUSH
    ;   22  SFFromSFN
    ;   23  GetCDSFromDrv
    ;   24  Get_User_Stack
    ;   25  GetThisDrv
    ;   26  DriveFromText
    ;   27  SETYEAR
    ;   28  DSUM
    ;   29  DSLIDE
    ;   30  StrCmp
    ;   31  initcds
    ;   32  pjfnfromhandle
    ;   33  $NameTrans
    ;   34  CAL_LK
    ;   35  DEVNAME
    ;   36  Idle
    ;   37  DStrLen
    ;   38  NLS_OPEN      DOS 3.3
    ;   39  $CLOSE        DOS 3.3
    ;   40  NLS_LSEEK     DOS 3.3
    ;   41  $READ         DOS 3.3
    ;   42  FastInit      DOS 4.0
    ;   43  NLS_IOCTL     DOS 3.3
    ;   44  GetDevList    DOS 3.3
    ;   45  NLS_GETEXT    DOS 3.3
    ;   46  MSG_RETRIEVAL DOS 4.0
    ;   47  FAKE_VERSION  DOS 4.0
    ;
NLSFUNC     EQU     14h                 ; NLSFUNC CALL , DOS 3.3
    ;   0   NLSInstall
    ;   1   ChgCodePage
    ;   2   GetExtInfo
    ;   3   SetCodePage
    ;   4   GetCntry
    ;

multANSI    EQU     1Ah			; ANSI multiplex number
    ;   0   INSTALL_CHECK		; install check for ANSI
    ;   1   IOCTL_2F			; 2F interface to IOCTL
    ;   2   DA_INFO_2F			; J.K. Information passing to ANSI.

multMULT    	EQU     4ah
 multMULTRPLTOM	EQU	06h

    ;   0   swap disk function for single floppy drive m/cs
    ;       BIOS broadcasts with cx==0, and apps who handle
    ;       swap disk messaging set cx == -1. BIOS sets dl == requested
    ;       drive
    ;
    ;   1   Get available HMA & pointer to it. Returns in BX & ES:DI
    ;   2   Allocate HMA. BX == number of bytes in HMA to be allocated
    ;       returns pointer in ES:DI
    ;
    ;   3-4 currently used by nobody
    ;	5   Switcher API
    ;   6   Top of Memory for RPL.
    ;		BIOS issues INT 2f AX=4a06 & DX = Top of Mem and any RPL
    ;		code present in TOM should respond with a new TOM in DX
    ;		to protect itself from MSLOAD & SYSINIT tromping over it.
    ;		SYSINIT builds an arena with owner type 8 & name 'RPL' to
    ;		protect the RPL code from COMMAND.COM transient protion.
    ;		It is the responsibility of RPL program to release the mem.
    ;   7   Reserved for PROTMAN support.

MultAPM         EQU     4ch
    ;       00h     APM_VER_CHK
    ;       01h     APM_SUS_SYS_REQ
    ;       FFh     APM_SUS_RES_BATT_NOTIFY

;FASTOPEN is not chained through INT 2F   ; DOS 3.3 F.C.
;         it calls Multdos 42 to set up an entry routine address
    ;   0   Install status  (reserved)
    ;   1   Lookup
    ;   2   Insert
    ;   3   Delete
    ;   4   Purge           (reserved)

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\syscall.inc ===
;	SCCSID = @(#)syscall.asm	1.1 85/04/10
;BREAK <system call definitions>
SUBTTL	system call definitions
PAGE

Abort				EQU 0	;  0	  0
Std_Con_Input			EQU 1	;  1	  1
Std_Con_Output			EQU 2	;  2	  2
Std_Aux_Input			EQU 3	;  3	  3
Std_Aux_Output			EQU 4	;  4	  4
Std_Printer_Output		EQU 5	;  5	  5
Raw_Con_IO			EQU 6	;  6	  6
Raw_Con_Input			EQU 7	;  7	  7
Std_Con_Input_No_Echo		EQU 8	;  8	  8
Std_Con_String_Output		EQU 9	;  9	  9
Std_Con_String_Input		EQU 10	; 10	  A
Std_Con_Input_Status		EQU 11	; 11	  B
Std_Con_Input_Flush		EQU 12	; 12	  C
Disk_Reset			EQU 13	; 13	  D
Set_Default_Drive		EQU 14	; 14	  E
FCB_Open			EQU 15	; 15	  F
FCB_Close			EQU 16	; 16	 10
Dir_Search_First		EQU 17	; 17	 11
Dir_Search_Next 		EQU 18	; 18	 12
FCB_Delete			EQU 19	; 19	 13
FCB_Seq_Read			EQU 20	; 20	 14
FCB_Seq_Write			EQU 21	; 21	 15
FCB_Create			EQU 22	; 22	 16
FCB_Rename			EQU 23	; 23	 17
Get_Default_Drive		EQU 25	; 25	 19
Set_DMA 			EQU 26	; 26	 1A
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Get_Default_DPB 		EQU 31	; 31	 1F
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
FCB_Random_Read 		EQU 33	; 33	 21
FCB_Random_Write		EQU 34	; 34	 22
Get_FCB_File_Length		EQU 35	; 35	 23
Get_FCB_Position		EQU 36	; 36	 24
Set_Interrupt_Vector		EQU 37	; 37	 25
Create_Process_Data_Block	EQU 38	; 38	 26
FCB_Random_Read_Block		EQU 39	; 39	 27
FCB_Random_Write_Block		EQU 40	; 40	 28
Parse_File_Descriptor		EQU 41	; 41	 29
Get_Date			EQU 42	; 42	 2A
Set_Date			EQU 43	; 43	 2B
Get_Time			EQU 44	; 44	 2C
Set_Time			EQU 45	; 45	 2D
Set_Verify_On_Write		EQU 46	; 46	 2E
; Extended functionality group
Get_DMA 			EQU 47	; 47	 2F
Get_Version			EQU 48	; 48	 30
Keep_Process			EQU 49	; 49	 31
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Get_DPB 			EQU 50	; 50	 32
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
Set_CTRL_C_Trapping		EQU 51	; 51	 33
Get_InDOS_Flag			EQU 52	; 52	 34
Get_Interrupt_Vector		EQU 53	; 53	 35
Get_Drive_Freespace		EQU 54	; 54	 36
Char_Oper			EQU 55	; 55	 37
International			EQU 56	; 56	 38
;   Directory Group
MKDir				EQU 57	; 57	 39
RMDir				EQU 58	; 58	 3A
CHDir				EQU 59	; 59	 3B
;   File Group
Creat				EQU 60	; 60	 3C
Open				EQU 61	; 61	 3D
Close				EQU 62	; 62	 3E
Read				EQU 63	; 63	 3F
Write				EQU 64	; 64	 40
Unlink				EQU 65	; 65	 41
LSeek				EQU 66	; 66	 42
CHMod				EQU 67	; 67	 43
IOCtl				EQU 68	; 68	 44
XDup				EQU 69	; 69	 45
XDup2				EQU 70	; 70	 46
Current_Dir			EQU 71	; 71	 47
;    Memory Group
Alloc				EQU 72	; 72	 48
Dealloc 			EQU 73	; 73	 49
Setblock			EQU 74	; 74	 4A
;    Process Group
Exec				EQU 75	; 75	 4B
Exit				EQU 76	; 76	 4C
WaitProcess			EQU 77	; 77	 4D
Find_First			EQU 78	; 78	 4E
;   Special Group
Find_Next			EQU 79	; 79	 4F
; SPECIAL SYSTEM GROUP
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Set_Current_PDB 		EQU 80	; 80	 50
Get_Current_PDB 		EQU 81	; 81	 51
Get_In_Vars			EQU 82	; 82	 52
SetDPB				EQU 83	; 83	 53
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
Get_Verify_On_Write		EQU 84	; 84	 54
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Dup_PDB 			EQU 85	; 85	 55
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
Rename				EQU 86	; 86	 56
File_Times			EQU 87	; 87	 57
AllocOper			EQU 88	; 88	 58
; Network extention system calls
GetExtendedError		EQU 89	; 89	 59
CreateTempFile			EQU 90	; 90	 5A
CreateNewFile			EQU 91	; 91	 5B
LockOper			EQU 92	; 92	 5C Lock and Unlock
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
					;	    CloseByName, CloseUser,
					;	    CloseUserProcess,
					;	    GetOpenFileList
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
UserOper			EQU 94	; 94	 5E Get and Set
AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
xNameTrans			EQU 96	; 96	 60
PathParse			EQU 97	; 97	 61
GetCurrentPSP			EQU 98	; 98	 62
Hongeul 			EQU 99	; 99	 63
ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Set_Printer_Flag		EQU 100 ; 100	 64
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
GetExtCntry			EQU 101 ; 101	 65
GetSetCdPg			EQU 102 ; 102	 66
ExtHandle			EQU 103 ; 103	 67
Commit				EQU 104 ; 104	 68
GetSetMediaID			EQU 105 ; 105	 69
IFS_IOCTL			EQU 107 ; 107	 6B
ExtOpen 			EQU 108 ; 108	 6C
;
;
Set_Oem_Handler 		EQU 248 ; 248	 F8
OEM_C1				EQU 249 ; 249	 F9
OEM_C2				EQU 250 ; 250	 FA
OEM_C3				EQU 251 ; 251	 FB
OEM_C4				EQU 252 ; 252	 FC
OEM_C5				EQU 253 ; 253	 FD
OEM_C6				EQU 254 ; 254	 FE
OEM_C7				EQU 255 ; 255	 FF

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *									    *
 *	This file is only modified by the official builder to update the    *
 *	VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG 
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <ver.h> 
#endif 

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#define VERSION 		    "3.1"
#define VER_PRODUCTVERSION_STR      "3.10\0"
#define VER_PRODUCTVERSION          3,10,0,103

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\ver.h ===
/*****************************************************************************\
*                                                                             *
* ver.h -       Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL and VER.LIB.  These libraries are    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               The API is unchanged for LIB and DLL versions.                *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with VER.LIB (default is for VER.DLL)
*
\*****************************************************************************/

#ifndef _INC_VER
#define _INC_VER

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#define LOWORD(l)		((WORD)(l))
#define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define MAKEINTRESOURCE(i)	(LPSTR)((DWORD)((WORD)(i)))
#endif  /* WINAPI */

#else   /* LIB */

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/* ----- RC defines ----- */
#ifdef RC_INVOKED
#define ID(id)			id
#else
#define ID(id)			MAKEINTRESOURCE(id)
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO		ID(16)		/* Version stamp res type */
#define VS_VERSION_INFO		ID(1)  		/* Version stamp res ID */
#define VS_USER_DEFINED		ID(100)		/* User-defined res IDs */

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FFI_SIGNATURE	0xFEEF04BDL
#define	VS_FFI_STRUCVERSION	0x00010000L
#define	VS_FFI_FILEFLAGSMASK	0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FF_DEBUG		0x00000001L
#define	VS_FF_PRERELEASE	0x00000002L
#define	VS_FF_PATCHED		0x00000004L
#define	VS_FF_PRIVATEBUILD	0x00000008L
#define	VS_FF_INFOINFERRED	0x00000010L
#define	VS_FF_SPECIALBUILD	0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define	VOS_UNKNOWN		0x00000000L
#define	VOS_DOS			0x00010000L
#define	VOS_OS216		0x00020000L
#define	VOS_OS232		0x00030000L
#define	VOS_NT			0x00040000L

#define	VOS__BASE		0x00000000L
#define	VOS__WINDOWS16		0x00000001L
#define	VOS__PM16		0x00000002L
#define	VOS__PM32		0x00000003L
#define	VOS__WINDOWS32		0x00000004L

#define	VOS_DOS_WINDOWS16	0x00010001L
#define	VOS_DOS_WINDOWS32	0x00010004L
#define	VOS_OS216_PM16		0x00020002L
#define	VOS_OS232_PM32		0x00030003L
#define	VOS_NT_WINDOWS32	0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define	VFT_UNKNOWN		0x00000000L
#define	VFT_APP			0x00000001L
#define	VFT_DLL			0x00000002L
#define	VFT_DRV			0x00000003L
#define	VFT_FONT		0x00000004L
#define	VFT_VXD			0x00000005L
#define	VFT_STATIC_LIB		0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define	VFT2_UNKNOWN		0x00000000L
#define VFT2_DRV_PRINTER	0x00000001L
#define	VFT2_DRV_KEYBOARD	0x00000002L
#define	VFT2_DRV_LANGUAGE	0x00000003L
#define	VFT2_DRV_DISPLAY	0x00000004L
#define	VFT2_DRV_MOUSE		0x00000005L
#define	VFT2_DRV_NETWORK	0x00000006L
#define	VFT2_DRV_SYSTEM		0x00000007L
#define	VFT2_DRV_INSTALLABLE	0x00000008L
#define	VFT2_DRV_SOUND		0x00000009L
#define	VFT2_DRV_COMM		0x0000000AL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER	0x00000001L
#define	VFT2_FONT_VECTOR	0x00000002L
#define	VFT2_FONT_TRUETYPE	0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE	0x0001

#define VFF_CURNEDEST		0x0001
#define VFF_FILEINUSE		0x0002
#define VFF_BUFFTOOSMALL	0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL	0x0001
#define VIFF_DONTDELETEOLD	0x0002

#define VIF_TEMPFILE		0x00000001L
#define VIF_MISMATCH		0x00000002L
#define VIF_SRCOLD		0x00000004L

#define VIF_DIFFLANG		0x00000008L
#define VIF_DIFFCODEPG		0x00000010L
#define VIF_DIFFTYPE		0x00000020L

#define VIF_WRITEPROT		0x00000040L
#define VIF_FILEINUSE		0x00000080L
#define VIF_OUTOFSPACE		0x00000100L
#define VIF_ACCESSVIOLATION	0x00000200L
#define VIF_SHARINGVIOLATION	0x00000400L
#define VIF_CANNOTCREATE	0x00000800L
#define VIF_CANNOTDELETE	0x00001000L
#define VIF_CANNOTRENAME	0x00002000L
#define VIF_CANNOTDELETECUR	0x00004000L
#define VIF_OUTOFMEMORY		0x00008000L

#define VIF_CANNOTREADSRC	0x00010000L
#define VIF_CANNOTREADDST	0x00020000L

#define VIF_BUFFTOOSMALL	0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef signed short int SHORT;

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

UINT WINAPI VerFindFile(UINT uFlags, LPCSTR szFileName,
      LPCSTR szWinDir, LPCSTR szAppDir,
      LPSTR szCurDir, UINT FAR* lpuCurDirLen,
      LPSTR szDestDir, UINT FAR* lpuDestDirLen);

DWORD WINAPI VerInstallFile(UINT uFlags,
      LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir,
      LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, UINT FAR* lpuTmpFileLen);

/* Returns size of version info in bytes */
DWORD WINAPI GetFileVersionInfoSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD FAR *lpdwHandle);   /* Information for use by GetFileVersionInfo */

/* Read version info into buffer */
BOOL WINAPI GetFileVersionInfo(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD dwHandle,           /* Information from GetFileVersionSize */
      DWORD dwLen,              /* Length of buffer for info */
      void FAR* lpData);        /* Buffer to place the data structure */

/* Returns size of resource in bytes */
DWORD WINAPI GetFileResourceSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD FAR *lpdwFileOffset); /* Returns file offset of resource */

/* Reads file resource into buffer */
BOOL WINAPI GetFileResource(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD dwFileOffset,       /* File offset or NULL */
      DWORD dwResLen,           /* Length of resource to read or NULL */
      void FAR* lpData);        /* Pointer to data buffer */

UINT WINAPI VerLanguageName(UINT wLang, LPSTR szLang, UINT nSize);

UINT WINAPI GetWindowsDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

UINT WINAPI GetSystemDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

BOOL WINAPI VerQueryValue(const void FAR* pBlock, LPCSTR lpSubBlock,
      void FAR* FAR* lplpBuffer, UINT FAR* lpuLen);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#pragma pack()

#endif  /* !RC_INVOKED */
#endif  /* !_INC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\version.inc ===
; Some modules really want TRUE to be 0FFH.  Best to let them have their way.
ifndef TRUE
	TRUE	   EQU	   0FFFFh
endif
ifndef TRUEBYTE
	TRUEBYTE   EQU     0FFh
endif
ifndef FALSE
	FALSE	   EQU	   0
endif


; This flag should be defined to create the ROM executable version of DOS.
; To build the regular version, it should be UNDEFINED.
;
; ROMDOS	equ	TRUE

; This flag should be defined to enable a special version of the EXEC
; function that will find and execute ROM executable programs.
;
; ROMEXEC	equ	TRUE

if1
	ifdef romdos
		%out ***** BUILDING ROM EXECUTABLE DOS *****
	endif
endif

;
; Use the following switches to control cmacros.inc
;
?PLM       =       0
?WIN       =       0

memS       EQU     1			; Small model
;
; Use the switches below to produce the standard Microsoft version or the IBM
; version of the operating system
;
; The below chart will indicate how to set the switches to build the various
; versions
;
;                     IBMVER          IBMCOPYRIGHT
; --------------------------------------------------------
;  IBM Version     |   TRUE              TRUE
; --------------------------------------------------------
;  ISA Version     |   TRUE              FALSE
; --------------------------------------------------------
;  non ISA Version |   FALSE             FALSE
;
ifndef NEC_98
IBMVER          EQU     TRUE
else    ;NEC_98
IBMVER          EQU     FALSE
endif   ;NEC_98
IBMCOPYRIGHT    EQU     FALSE

;smr; removal of bufferflag; BUFFERFLAG	EQU	NOT IBMCOPYRIGHT

;mw 8/23/90 ; removal of ROMVER, superceded by ROMDOS and ROMEXEC, above...
; ROMVER		EQU	FALSE

ifndef NEC_98
CPU8086		EQU	FALSE
else    ;NEC_98
CPU8086		EQU	TRUE
endif   ;NEC_98

ifndef	MSVER	
MSVER           EQU     NOT IBMVER
endif
IBM             EQU     IBMVER
;
;
  IF1
	IF IBMVER
	    IF IBMCOPYRIGHT
              %OUT ... IBM version build switch on ...
	    ELSE
              ; %OUT ... ISA version build switch on ...
	    ENDIF
	ELSE
	    IF NOT IBMCOPYRIGHT
              %OUT ... non ISA version build switch on ...
	    ELSE
	      %OUT !!!!!!!!!  VERSION SWITCHES SET INCORECTLY  !!!!!!!!!
	      %OUT !!!!!!!!! CHECK SETTINGS IN INC\VERSION.INC !!!!!!!!!
	    ENDIF
	ENDIF   
	IF CPU8086
	    %OUT !!!!!!! 8080 / 8086 Version !!!!!!!
	ENDIF
  ENDIF

;****************************************************************************
;
;		<<< Followings are the DBCS relating Definition >>>
;
;
;	To build DBCS version, Define DBCS by using MASM option via
;	Dos environment.
;
;	ex.		set MASM=-DDBCS
;
;
;
;	To build Country/Region depend version, Define JAPAN, KOREA ,TAIWAN or PRC
;	by using MASM option via Dos environment.
;
;	ex.		set MASM=-DJAPAN
;			set MASM=-DKOREA
;			set MASM=-DTAIWAN
;			set MASM=-DPRC
;
;****************************************************************************


BUGFIX	   EQU	   TRUE


IBMJAPVER  EQU	   FALSE		; if TRUE define DBCS also
IBMJAPAN   EQU	   FALSE		; if TRUE define DBCS also


	ifdef xxTAIWANxx
CSIBIOS    EQU	   FALSE		; BIOS	       CSI
CSIDRV	   EQU	   TRUE 		; Device Drive CSI
CSITSR	   EQU	   FALSE		; TSR	       CSI
	else
CSIBIOS    EQU	   FALSE
CSIDRV	   EQU	   FALSE
CSITSR	   EQU	   FALSE
	endif

;
; Set DBCS Blank constant
;
	ifndef DBCS
DB_SPACE EQU	 2020h
DB_SP_HI EQU	 20h
DB_SP_LO EQU	 20h
	else

	ifdef JAPAN
DB_SPACE EQU	 8140h
DB_SP_HI EQU	 81h
DB_SP_LO EQU	 40h
	endif

	ifdef TAIWAN ; by gchang, 06/23/94
DB_SPACE EQU	 0A140h
DB_SP_HI EQU	 0A1h
DB_SP_LO EQU	 40h
	endif

	ifdef PRC ; by gchang, 06/23/94
DB_SPACE EQU	 0A1A1h
DB_SP_HI EQU	 0A1h
DB_SP_LO EQU	 0A1h
	endif

	ifdef KOREA
DB_SPACE EQU	 0A1A1h
DB_SP_HI EQU	 0A1h
DB_SP_LO EQU	 0A1h
	endif

	endif

ifndef altvect				; avoid jerking off vector.inc
ALTVECT    EQU	   FALSE		;Switch to build ALTVECT version
endif

;
	IF1

	ifdef DBCS
%OUT    DBCS Version Build Switch ON

	ifdef JAPAN
%OUT    JAPAN Version Build Switch ON
	endif

	ifdef TAIWAN
%OUT    TAIWAN Version Build Switch ON
	endif

	ifdef KOREA
%OUT    KOREA Version Build Switch ON
	endif

	endif

	ENDIF

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*	Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains the function declarations for the string
*	manipulation functions.
*	[ANSI/System V]
*
****/

#if defined(_DLL) && !defined(_MT)
#error Cannot define _DLL without _MT
#endif

#ifdef _MT
#define _FAR_ _far
#else
#define _FAR_
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* function prototypes */

void _FAR_ * _FAR_ _cdecl memccpy(void _FAR_ *, const void _FAR_ *,
	int, unsigned int);
void _FAR_ * _FAR_ _cdecl memchr(const void _FAR_ *, int, size_t);
int _FAR_ _cdecl memcmp(const void _FAR_ *, const void _FAR_ *,
	size_t);
int _FAR_ _cdecl memicmp(const void _FAR_ *, const void _FAR_ *,
	unsigned int);
void _FAR_ * _FAR_ _cdecl memcpy(void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memmove(void _FAR_ *, const void _FAR_ *,
	size_t);
void _FAR_ * _FAR_ _cdecl memset(void _FAR_ *, int, size_t);
void _FAR_ _cdecl movedata(unsigned int, unsigned int, unsigned int,
	unsigned int, unsigned int);
char _FAR_ * _FAR_ _cdecl strcat(char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strchr(const char _FAR_ *, int);
int _FAR_ _cdecl strcmp(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl strcmpi(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl strcoll(const char _FAR_ *, const char _FAR_ *);
int _FAR_ _cdecl stricmp(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strcpy(char _FAR_ *, const char _FAR_ *);
size_t _FAR_ _cdecl strcspn(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strdup(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl _strerror(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strerror(int);
size_t _FAR_ _cdecl strlen(const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strlwr(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strncat(char _FAR_ *, const char _FAR_ *,
	size_t);
int _FAR_ _cdecl strncmp(const char _FAR_ *, const char _FAR_ *,
	size_t);
int _FAR_ _cdecl strnicmp(const char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl strncpy(char _FAR_ *, const char _FAR_ *,
	size_t);
char _FAR_ * _FAR_ _cdecl strnset(char _FAR_ *, int, size_t);
char _FAR_ * _FAR_ _cdecl strpbrk(const char _FAR_ *,
	const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strrchr(const char _FAR_ *, int);
char _FAR_ * _FAR_ _cdecl strrev(char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strset(char _FAR_ *, int);
size_t _FAR_ _cdecl strspn(const char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strstr(const char _FAR_ *,
	const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strtok(char _FAR_ *, const char _FAR_ *);
char _FAR_ * _FAR_ _cdecl strupr(char _FAR_ *);
size_t _FAR_ _cdecl strxfrm (char _FAR_ *, const char _FAR_ *,
	size_t);

/* model independent function prototypes */

void _far * _far _cdecl _fmemccpy(void _far *, const void _far *,
	int, unsigned int);
void _far * _far _cdecl _fmemchr(const void _far *, int, size_t);
int _far _cdecl _fmemcmp(const void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemcpy(void _far *, const void _far *,
	size_t);
int _far _cdecl _fmemicmp(const void _far *, const void _far *,
	unsigned int);
void _far * _far _cdecl _fmemmove(void _far *, const void _far *,
	size_t);
void _far * _far _cdecl _fmemset(void _far *, int, size_t);
char _far * _far _cdecl _fstrcat(char _far *, const char _far *);
char _far * _far _cdecl _fstrchr(const char _far *, int);
int _far _cdecl _fstrcmp(const char _far *, const char _far *);
int _far _cdecl _fstricmp(const char _far *, const char _far *);
char _far * _far _cdecl _fstrcpy(char _far *, const char _far *);
size_t _far _cdecl _fstrcspn(const char _far *, const char _far *);
char _far * _far _cdecl _fstrdup(const char _far *);
char _near * _far _cdecl _nstrdup(const char _far *);
size_t _far _cdecl _fstrlen(const char _far *);
char _far * _far _cdecl _fstrlwr(char _far *);
char _far * _far _cdecl _fstrncat(char _far *, const char _far *,
	size_t);
int _far _cdecl _fstrncmp(const char _far *, const char _far *,
	size_t);
int _far _cdecl _fstrnicmp(const char _far *, const char _far *,
	size_t);
char _far * _far _cdecl _fstrncpy(char _far *, const char _far *,
	size_t);
char _far * _far _cdecl _fstrnset(char _far *, int, size_t);
char _far * _far _cdecl _fstrpbrk(const char _far *,
	const char _far *);
char _far * _far _cdecl _fstrrchr(const char _far *, int);
char _far * _far _cdecl _fstrrev(char _far *);
char _far * _far _cdecl _fstrset(char _far *, int);
size_t _far _cdecl _fstrspn(const char _far *, const char _far *);
char _far * _far _cdecl _fstrstr(const char _far *,
	const char _far *);
char _far * _far _cdecl _fstrtok(char _far *, const char _far *);
char _far * _far _cdecl _fstrupr(char _far *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\versiona.inc ===
major_version	    equ     5	    ;Major DOS version
minor_version	    equ     00	    ;Minor DOS Version for int 21h/30h
minor_version_NT    equ     50	    ;Minor DOS VersionN for int 21h/3306

expected_version    equ     (MINOR_VERSION SHL 8)+MAJOR_VERSION

DOSREVNM	equ	00000000B	; bits 0-2 = revision number of DOS
					; currently 0.
DOSINROM	equ	00001000B	; bit 3 of ver flags returned in BH
DOSINHMA	equ	00010000B	; bit 4 of ver flags 


;      if1
;      %OUT  ... for DOS Version 5.00 ...
;      endif

       ;******************************
       ;Each assembler program should:
       ;  mov ah,030h			;DOS Get Version function
       ;  int 021h			;Version ret. in AX,minor version first
       ;  cmp ax,expected_version	;ALL utilities should check for an
       ;  jne error_handler		; EXACT version match.
       ;******************************


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\windowsx.h ===
/*****************************************************************************\
*                                                                             *
* windowsx.h -  Macro APIs, window message crackers, and control APIs         *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_WINDOWSX
#define _INC_WINDOWSX

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****** KERNEL Macro APIs ****************************************************/

#define     GetInstanceModule(hInstance) \
                GetModuleHandle((LPCSTR)MAKELP(0, hInstance))

#define     GlobalPtrHandle(lp)         \
                ((HGLOBAL)LOWORD(GlobalHandle(SELECTOROF(lp))))

#define     GlobalLockPtr(lp)		\
                ((BOOL)SELECTOROF(GlobalLock(GlobalPtrHandle(lp))))
#define     GlobalUnlockPtr(lp) 	\
                GlobalUnlock(GlobalPtrHandle(lp))

#define     GlobalAllocPtr(flags, cb)	\
                (GlobalLock(GlobalAlloc((flags), (cb))))
#define     GlobalReAllocPtr(lp, cbNew, flags)	\
                (GlobalUnlockPtr(lp), GlobalLock(GlobalReAlloc(GlobalPtrHandle(lp) , (cbNew), (flags))))
#define     GlobalFreePtr(lp)		\
                (GlobalUnlockPtr(lp), (BOOL)GlobalFree(GlobalPtrHandle(lp)))

/****** GDI Macro APIs *******************************************************/

#define     DeletePen(hpen)	    DeleteObject((HGDIOBJ)(HPEN)(hpen))
#define     SelectPen(hdc, hpen)    ((HPEN)SelectObject((hdc), (HGDIOBJ)(HPEN)(hpen)))
#define     GetStockPen(i)	    ((HPEN)GetStockObject(i))

#define     DeleteBrush(hbr)	    DeleteObject((HGDIOBJ)(HBRUSH)(hbr))
#define     SelectBrush(hdc, hbr)   ((HBRUSH)SelectObject((hdc), (HGDIOBJ)(HBRUSH)(hbr)))
#define     GetStockBrush(i)	    ((HBRUSH)GetStockObject(i))

#define     DeleteRgn(hrgn)	    DeleteObject((HGDIOBJ)(HRGN)(hrgn))

#define     CopyRgn(hrgnDst, hrgnSrc)               CombineRgn(hrgnDst, hrgnSrc, 0, RGN_COPY)
#define     IntersectRgn(hrgnResult, hrgnA, hrgnB)  CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_AND)
#define     SubtractRgn(hrgnResult, hrgnA, hrgnB)   CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_DIFF)
#define     UnionRgn(hrgnResult, hrgnA, hrgnB)      CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_OR)
#define     XorRgn(hrgnResult, hrgnA, hrgnB)        CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_XOR)

#define     DeletePalette(hpal)     DeleteObject((HGDIOBJ)(HPALETTE)(hpal))

#define     DeleteFont(hfont)	    DeleteObject((HGDIOBJ)(HFONT)(hfont))
#define     SelectFont(hdc, hfont)  ((HFONT)SelectObject((hdc), (HGDIOBJ)(HFONT)(hfont)))
#define     GetStockFont(i)	    ((HFONT)GetStockObject(i))

#define     DeleteBitmap(hbm)       DeleteObject((HGDIOBJ)(HBITMAP)(hbm))
#define     SelectBitmap(hdc, hbm)  ((HBITMAP)SelectObject((hdc), (HGDIOBJ)(HBITMAP)(hbm)))

#define     InsetRect(lprc, dx, dy) InflateRect((lprc), -(dx), -(dy))

/****** USER Macro APIs ******************************************************/

#define     GetWindowInstance(hwnd) ((HINSTANCE)GetWindowWord(hwnd, GWW_HINSTANCE))

#define     GetWindowStyle(hwnd)    ((DWORD)GetWindowLong(hwnd, GWL_STYLE))
#define     GetWindowExStyle(hwnd)  ((DWORD)GetWindowLong(hwnd, GWL_EXSTYLE))

#define     GetWindowOwner(hwnd)    GetWindow(hwnd, GW_OWNER)

#define     GetFirstChild(hwnd)     GetTopWindow(hwnd)
#define     GetFirstSibling(hwnd)   GetWindow(hwnd, GW_HWNDFIRST)
#define     GetLastSibling(hwnd)    GetWindow(hwnd, GW_HWNDLAST)
#define     GetNextSibling(hwnd)    GetWindow(hwnd, GW_HWNDNEXT)
#define     GetPrevSibling(hwnd)    GetWindow(hwnd, GW_HWNDPREV)

#define     GetWindowID(hwnd)	    GetDlgCtrlID(hwnd)

#define     SetWindowRedraw(hwnd, fRedraw)  \
                    ((void)SendMessage(hwnd, WM_SETREDRAW, (WPARAM)(BOOL)(fRedraw), 0L))

#define     SubclassWindow(hwnd, lpfn)	\
		(SetWindowLong((hwnd), GWL_WNDPROC, (LPARAM)(lpfn)))

#define     IsMinimized(hwnd)	IsIconic(hwnd)
#define     IsMaximized(hwnd)	IsZoomed(hwnd)
#define     IsRestored(hwnd)    ((GetWindowStyle(hwnd) & (WS_MINIMIZE | WS_MAXIMIZE)) == 0L)

#define     SetWindowFont(hwnd, hfont, fRedraw) FORWARD_WM_SETFONT((hwnd), (hfont), (fRedraw), SendMessage)

#define     GetWindowFont(hwnd)                 FORWARD_WM_GETFONT((hwnd), SendMessage)

#if (WINVER >= 0x030a)
#define     MapWindowRect(hwndFrom, hwndTo, lprc) \
                    MapWindowPoints((hwndFrom), (hwndTo), (POINT FAR*)(lprc), 2)
#endif  /* WINVER >= 0x030a */

#define     IsLButtonDown()	(GetKeyState(VK_LBUTTON) < 0)
#define     IsRButtonDown()	(GetKeyState(VK_RBUTTON) < 0)
#define     IsMButtonDown()	(GetKeyState(VK_MBUTTON) < 0)

#define     SubclassDialog(hwndDlg, lpfn) \
		(SetWindowLong(hwndDlg, DWL_DLGPROC, (LPARAM)(lpfn)))

#define     SetDlgMsgResult(hwnd, msg, result)	 \
    (((msg) == WM_CTLCOLOR || (msg) == WM_COMPAREITEM || (msg) == WM_VKEYTOITEM ||  \
    (msg) == WM_CHARTOITEM || (msg) == WM_QUERYDRAGICON || (msg) == WM_INITDIALOG)  \
    ? (BOOL)LOWORD(result) : (SetWindowLong((hwnd), DWL_MSGRESULT, (LPARAM)(LRESULT)(result)), TRUE))

#define     DefDlgProcEx(hwnd, msg, wParam, lParam, pfRecursion) \
    (*(pfRecursion) = TRUE, DefDlgProc(hwnd, msg, wParam, lParam))

#define     CheckDefDlgRecursion(pfRecursion) \
    if (*(pfRecursion)) { *(pfRecursion) = FALSE; return FALSE; }

/****** Message crackers ****************************************************/

#define HANDLE_MSG(hwnd, message, fn)    \
    case (message): return HANDLE_##message((hwnd), (wParam), (lParam), (fn))

/* void Cls_OnCompacting(HWND hwnd, UINT compactRatio); */
#define HANDLE_WM_COMPACTING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_COMPACTING(hwnd, compactRatio, fn) \
    (void)(fn)((hwnd), WM_COMPACTING, (WPARAM)(UINT)(compactRatio), 0L)

/* void Cls_OnWinIniChange(HWND hwnd, LPCSTR lpszSectionName); */
#define HANDLE_WM_WININICHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_WININICHANGE(hwnd, lpszSectionName, fn) \
    (void)(fn)((hwnd), WM_WININICHANGE, 0, (LPARAM)(LPCSTR)(lpszSectionName))

/* void Cls_OnSysColorChange(HWND hwnd); */
#define HANDLE_WM_SYSCOLORCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_SYSCOLORCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_SYSCOLORCHANGE, 0, 0L)

/* BOOL Cls_OnQueryNewPalette(HWND hwnd); */
#define HANDLE_WM_QUERYNEWPALETTE(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYNEWPALETTE(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYNEWPALETTE, 0, 0L)

/* void Cls_OnPaletteIsChanging(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTEISCHANGING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTEISCHANGING(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTEISCHANGING, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTECHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTECHANGED(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTECHANGED, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnFontChange(HWND hwnd); */
#define HANDLE_WM_FONTCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_FONTCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_FONTCHANGE, 0, 0L)

/* void Cls_OnSpoolerStatus(HWND hwnd, UINT status, int cJobInQueue); */
#define HANDLE_WM_SPOOLERSTATUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SPOOLERSTATUS(hwnd, status, cJobInQueue, fn) \
    (void)(fn)((hwnd), WM_SPOOLERSTATUS, (WPARAM)(status), MAKELPARAM((UINT)(cJobInQueue), 0))

/* void Cls_OnDevModeChange(HWND hwnd, LPCSTR lpszDeviceName); */
#define HANDLE_WM_DEVMODECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_DEVMODECHANGE(hwnd, lpszDeviceName, fn) \
    (void)(fn)((hwnd), WM_DEVMODECHANGE, 0,(LPARAM)(LPCSTR)(lpszDeviceName))

/* void Cls_OnTimeChange(HWND hwnd); */
#define HANDLE_WM_TIMECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_TIMECHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_TIMECHANGE, 0, 0L)

/* void Cls_OnPower(HWND hwnd, int code); */
#define HANDLE_WM_POWER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_POWER(hwnd, code, fn) \
    (void)(fn)((hwnd), WM_POWER, (WPARAM)(code), 0L)

/* BOOL Cls_OnQueryEndSession(HWND hwnd); */
#define HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYENDSESSION(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYENDSESSION, 0, 0L)

/* void Cls_OnEndSession(HWND hwnd, BOOL fEnding); */
#define HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENDSESSION(hwnd, fEnding, fn) \
    (void)(fn)((hwnd), WM_ENDSESSION, (WPARAM)(BOOL)(fEnding), 0L)

/* void Cls_OnQuit(HWND hwnd, int exitCode); */
#define HANDLE_WM_QUIT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_QUIT(hwnd, exitCode, fn) \
    (void)(fn)((hwnd), WM_QUIT, (WPARAM)(exitCode), 0L)

/* void Cls_OnSystemError(HWND hwnd, int errCode); */
#define HANDLE_WM_SYSTEMERROR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_SYSTEMERROR(hwnd, errCode, fn) \
    (void)(fn)((hwnd), WM_SYSTEMERROR, (WPARAM)(errCode), 0L)

/* BOOL Cls_OnCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_CREATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (CREATESTRUCT FAR*)(lParam)) ? 0L : (LRESULT)-1L)
#define FORWARD_WM_CREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_CREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* BOOL Cls_OnNCCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_NCCREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (CREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_NCCREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCCREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* void Cls_OnDestroy(HWND hwnd); */
#define HANDLE_WM_DESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROY, 0, 0L)

/* void Cls_OnNCDestroy(HWND hwnd); */
#define HANDLE_WM_NCDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_NCDESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_NCDESTROY, 0, 0L)

/* void Cls_OnShowWindow(HWND hwnd, BOOL fShow, UINT status); */
#define HANDLE_WM_SHOWWINDOW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_SHOWWINDOW(hwnd, fShow, status, fn) \
    (void)(fn)((hwnd), WM_SHOWWINDOW, (WPARAM)(BOOL)(fShow), MAKELPARAM((UINT)(status), 0))

/* void Cls_OnSetRedraw(HWND hwnd, BOOL fRedraw); */
#define HANDLE_WM_SETREDRAW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_SETREDRAW(hwnd, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETREDRAW, (WPARAM)(fRedraw), 0L)

/* void Cls_OnEnable(HWND hwnd, BOOL fEnable); */
#define HANDLE_WM_ENABLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENABLE(hwnd, fEnable, fn) \
    (void)(fn)((hwnd), WM_ENABLE, (WPARAM)(BOOL)(fEnable), 0L)

/* void Cls_OnSetText(HWND hwnd, LPCSTR lpszText); */
#define HANDLE_WM_SETTEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_SETTEXT(hwnd, lpszText, fn) \
    (void)(fn)((hwnd), WM_SETTEXT, 0, (LPARAM)(LPCSTR)(lpszText))

/* INT Cls_OnGetText(HWND hwnd, int cchTextMax, LPSTR lpszText) */
#define HANDLE_WM_GETTEXT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (int)(wParam), (LPSTR)(lParam))
#define FORWARD_WM_GETTEXT(hwnd, cchTextMax, lpszText, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXT, (WPARAM)(int)(cchTextMax), (LPARAM)(LPSTR)(lpszText))

/* INT Cls_OnGetTextLength(HWND hwnd); */
#define HANDLE_WM_GETTEXTLENGTH(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)(hwnd)
#define FORWARD_WM_GETTEXTLENGTH(hwnd, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXTLENGTH, 0, 0L)

/* BOOL Cls_OnWindowPosChanging(HWND hwnd, WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGING(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (WINDOWPOS FAR*)(lParam))
#define FORWARD_WM_WINDOWPOSCHANGING(hwnd, lpwpos, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_WINDOWPOSCHANGING, 0, (LPARAM)(WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnWindowPosChanged(HWND hwnd, const WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const WINDOWPOS FAR*)(lParam)), 0L)
#define FORWARD_WM_WINDOWPOSCHANGED(hwnd, lpwpos, fn) \
    (void)(fn)((hwnd), WM_WINDOWPOSCHANGED, 0, (LPARAM)(const WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnMove(HWND hwnd, int x, int y); */
#define HANDLE_WM_MOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_MOVE(hwnd, x, y, fn) \
    (void)(fn)((hwnd), WM_MOVE, 0, MAKELPARAM((int)(x), (int)(y)))

/* void Cls_OnSize(HWND hwnd, UINT state, int cx, int cy); */
#define HANDLE_WM_SIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SIZE(hwnd, state, cx, cy, fn) \
    (void)(fn)((hwnd), WM_SIZE, (WPARAM)(UINT)(state), MAKELPARAM((int)(cx), (int)(cy)))

/* void Cls_OnClose(HWND hwnd); */
#define HANDLE_WM_CLOSE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLOSE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLOSE, 0, 0L)

/* BOOL Cls_OnQueryOpen(HWND hwnd); */
#define HANDLE_WM_QUERYOPEN(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYOPEN(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYOPEN, 0, 0L)

/* void Cls_OnGetMinMaxInfo(HWND hwnd, MINMAXINFO FAR* lpMinMaxInfo); */
#define HANDLE_WM_GETMINMAXINFO(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MINMAXINFO FAR*)(lParam)), 0L)
#define FORWARD_WM_GETMINMAXINFO(hwnd, lpMinMaxInfo, fn) \
    (void)(fn)((hwnd), WM_GETMINMAXINFO, 0, (LPARAM)(MINMAXINFO FAR*)(lpMinMaxInfo))

/* void Cls_OnPaint(HWND hwnd); */
#define HANDLE_WM_PAINT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PAINT(hwnd, fn) \
    (void)(fn)((hwnd), WM_PAINT, 0, 0L)

/* BOOL Cls_OnEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ERASEBKGND(hwnd, hdc, fn) \
   (BOOL)(DWORD)(fn)((hwnd), WM_ERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* BOOL Cls_OnIconEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ICONERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ICONERASEBKGND(hwnd, hdc, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_ICONERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* void Cls_OnNCPaint(HWND hwnd, HRGN hrgn); */
#define HANDLE_WM_NCPAINT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HRGN)(wParam)), 0L)
#define FORWARD_WM_NCPAINT(hwnd, hrgn, fn) \
    (void)(fn)((hwnd), WM_NCPAINT, (WPARAM)(HRGN)(hrgn), 0L)

/* UINT Cls_OnNCCalcSize(HWND hwnd, BOOL fCalcValidRects, NCCALCSIZE_PARAMS FAR* lpcsp) */
#define HANDLE_WM_NCCALCSIZE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (NCCALCSIZE_PARAMS FAR*)(lParam))
#define FORWARD_WM_NCCALCSIZE(hwnd, fCalcValidRects, lpcsp, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCCALCSIZE, (WPARAM)(fCalcValidRects), (LPARAM)(NCCALCSIZE_PARAMS FAR*)(lpcsp))

/* UINT Cls_OnNCHitTest(HWND hwnd, int x, int y); */
#define HANDLE_WM_NCHITTEST(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_NCHITTEST(hwnd, x, y, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCHITTEST, 0, MAKELPARAM((int)(x), (int)(y)))

/* HICON Cls_OnQueryDragIcon(HWND hwnd); */
#define HANDLE_WM_QUERYDRAGICON(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_QUERYDRAGICON(hwnd, fn) \
    (HICON)(UINT)(DWORD)(fn)((hwnd), WM_QUERYDRAGICON, 0, 0L)

#ifdef _INC_SHELLAPI
/* void Cls_OnDropFiles(HWND hwnd, HDROP hdrop); */
#define HANDLE_WM_DROPFILES(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HDROP)(wParam)), 0L)
#define FORWARD_WM_DROPFILES(hwnd, hdrop, fn) \
    (void)(fn)((hwnd), WM_DROPFILES, (WPARAM)(hdrop), 0L)
#endif  /* _INC_SHELLAPI */

/* void Cls_OnActivate(HWND hwnd, UINT state, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_ACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATE(hwnd, state, hwndActDeact, fMinimized, fn) \
    (void)(fn)((hwnd), WM_ACTIVATE, (WPARAM)(UINT)(state), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnActivateApp(HWND hwnd, BOOL fActivate, HTASK htaskActDeact); */
#define HANDLE_WM_ACTIVATEAPP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HTASK)LOWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATEAPP(hwnd, fActivate, htaskActDeact, fn) \
    (void)(fn)((hwnd), WM_ACTIVATEAPP, (WPARAM)(BOOL)(fActivate), MAKELPARAM((htaskActDeact),0))

/* BOOL Cls_OnNCActivate(HWND hwnd, BOOL fActive, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_NCACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam))
#define FORWARD_WM_NCACTIVATE(hwnd, fActive, hwndActDeact, fMinimized, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCACTIVATE, (WPARAM)(BOOL)(fActive), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnSetFocus(HWND hwnd, HWND hwndOldFocus) */
#define HANDLE_WM_SETFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_SETFOCUS(hwnd, hwndOldFocus, fn) \
    (void)(fn)((hwnd), WM_SETFOCUS, (WPARAM)(HWND)(hwndOldFocus), 0L)

/* void Cls_OnKillFocus(HWND hwnd, HWND hwndNewFocus); */
#define HANDLE_WM_KILLFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_KILLFOCUS(hwnd, hwndNewFocus, fn) \
    (void)(fn)((hwnd), WM_KILLFOCUS, (WPARAM)(HWND)(hwndNewFocus), 0L)

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_CHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_CHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_DEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_DEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_DEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnSysDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSDEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSDEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSDEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MOUSEMOVE(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MOUSEMOVE, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_LBUTTONDBLCLK : WM_LBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_LBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_RBUTTONDBLCLK : WM_RBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnRButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_RBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_RBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_MBUTTONDBLCLK : WM_MBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnMButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_MBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnNCMouseMove(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMOUSEMOVE(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMOUSEMOVE, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCLBUTTONDBLCLK : WM_NCLBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCLButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCLBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCRBUTTONDBLCLK : WM_NCRBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCRButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCRBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCMBUTTONDBLCLK : WM_NCMBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCMButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* int Cls_OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_MOUSEACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam))
#define FORWARD_WM_MOUSEACTIVATE(hwnd, hwndTopLevel, codeHitTest, msg, fn) \
    (int)(DWORD)(fn)((hwnd), WM_MOUSEACTIVATE, (WPARAM)(HWND)(hwndTopLevel), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnCancelMode(HWND hwnd); */
#define HANDLE_WM_CANCELMODE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CANCELMODE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CANCELMODE, 0, 0L)

/* void Cls_OnTimer(HWND hwnd, UINT id); */
#define HANDLE_WM_TIMER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_TIMER(hwnd, id, fn) \
    (void)(fn)((hwnd), WM_TIMER, (WPARAM)(UINT)(id), 0L)

/* void Cls_OnInitMenu(HWND hwnd, HMENU hMenu); */
#define HANDLE_WM_INITMENU(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam)), 0L)
#define FORWARD_WM_INITMENU(hwnd, hMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENU, (WPARAM)(HMENU)(hMenu), 0L)

/* void Cls_OnInitMenuPopup(HWND hwnd, HMENU hMenu, int item, BOOL fSystemMenu); */
#define HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam), (int)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_INITMENUPOPUP(hwnd, hMenu, item, fSystemMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENUPOPUP, (WPARAM)(HMENU)(hMenu), MAKELPARAM((item),(fSystemMenu)))

/* void Cls_OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags); */
#define HANDLE_WM_MENUSELECT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)HIWORD(lParam), (LOWORD(lParam) & MF_POPUP) ? 0 : (int)(wParam), \
                            (LOWORD(lParam) & MF_POPUP) ? (HMENU)(wParam) : 0, LOWORD(lParam)), 0L)
#define FORWARD_WM_MENUSELECT(hwnd, hmenu, item, hmenuPopup, flags, fn) \
    (void)(fn)((hwnd), WM_MENUSELECT, ((flags) & MF_POPUP) ? (WPARAM)(HMENU)(hmenuPopup) : (WPARAM)(int)(item), MAKELPARAM((flags), (hmenu)))

/* DWORD Cls_OnMenuChar(HWND hwnd, UINT ch, UINT flags, HMENU hmenu); */
#define HANDLE_WM_MENUCHAR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam), LOWORD(lParam), (HMENU)HIWORD(lParam));
#define FORWARD_WM_MENUCHAR(hwnd, ch, flags, hmenu, fn) \
    (DWORD)(fn)((hwnd), WM_MENUCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((flags), (UINT)(hmenu)))

/* void Cls_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify); */
#define HANDLE_WM_COMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
    (void)(fn)((hwnd), WM_COMMAND, (WPARAM)(int)(id), MAKELPARAM((UINT)(hwndCtl), (codeNotify)))

/* void Cls_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_HSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnVScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_VSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam),  (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnCut(HWND hwnd); */
#define HANDLE_WM_CUT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CUT(hwnd, fn) \
    (void)(fn)((hwnd), WM_CUT, 0, 0L)

/* void Cls_OnCopy(HWND hwnd); */
#define HANDLE_WM_COPY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_COPY(hwnd, fn) \
    (void)(fn)((hwnd), WM_COPY, 0, 0L)

/* void Cls_OnPaste(HWND hwnd); */
#define HANDLE_WM_PASTE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PASTE(hwnd, fn) \
    (void)(fn)((hwnd), WM_PASTE, 0, 0L)

/* void Cls_OnClear(HWND hwnd); */
#define HANDLE_WM_CLEAR(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLEAR(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLEAR, 0, 0L)

/* void Cls_OnUndo(HWND hwnd); */
#define HANDLE_WM_UNDO(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_UNDO(hwnd, fn) \
    (void)(fn)((hwnd), WM_UNDO, 0, 0L)

/* HANDLE Cls_OnRenderFormat(HWND hwnd, UINT fmt); */
#define HANDLE_WM_RENDERFORMAT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HANDLE)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_RENDERFORMAT(hwnd, fmt, fn) \
    (HANDLE)(UINT)(DWORD)(fn)((hwnd), WM_RENDERFORMAT, (WPARAM)(UINT)(fmt), 0L)

/* void Cls_OnRenderAllFormats(HWND hwnd); */
#define HANDLE_WM_RENDERALLFORMATS(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_RENDERALLFORMATS(hwnd, fn) \
    (void)(fn)((hwnd), WM_RENDERALLFORMATS, 0, 0L)

/* void Cls_OnDestroyClipboard(HWND hwnd); */
#define HANDLE_WM_DESTROYCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROYCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROYCLIPBOARD, 0, 0L)

/* void Cls_OnDrawClipboard(HWND hwnd); */
#define HANDLE_WM_DRAWCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DRAWCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DRAWCLIPBOARD, 0, 0L)

/* void Cls_OnPaintClipboard(HWND hwnd, HWND hwndCBViewer, const PAINTSTRUCT FAR* lpPaintStruct) */
#define HANDLE_WM_PAINTCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const PAINTSTRUCT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_PAINTCLIPBOARD(hwnd, hwndCBViewer, lpPaintStruct, fn) \
    (void)(fn)((hwnd), WM_PAINTCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(lpPaintStruct))

/* void Cls_OnSizeClipboard(HWND hwnd, HWND hwndCBViewer, const RECT FAR* lprc); */
#define HANDLE_WM_SIZECLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const RECT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SIZECLIPBOARD(hwnd, hwndCBViewer, lprc, fn) \
    (void)(fn)((hwnd), WM_SIZECLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(lprc))

/* void Cls_OnVScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_VSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnHScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_HSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnAskCBFormatName(HWND hwnd, int cchMax, LPSTR rgchName); */
#define HANDLE_WM_ASKCBFORMATNAME(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (LPSTR)(lParam)), 0L)
#define FORWARD_WM_ASKCBFORMATNAME(hwnd, cchMax, rgchName, fn) \
    (void)(fn)((hwnd), WM_ASKCBFORMATNAME, (WPARAM)(int)(cchMax), (LPARAM)(rgchName))

/* void Cls_OnChangeCBChain(HWND hwnd, HWND hwndRemove, HWND hwndNext); */
#define HANDLE_WM_CHANGECBCHAIN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHANGECBCHAIN(hwnd, hwndRemove, hwndNext, fn) \
    (void)(fn)((hwnd), WM_CHANGECBCHAIN, (WPARAM)(HWND)(hwndRemove), MAKELPARAM((UINT)(hwndNext), 0))

/* BOOL Cls_OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_SETCURSOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam));
#define FORWARD_WM_SETCURSOR(hwnd, hwndCursor, codeHitTest, msg, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_SETCURSOR, (WPARAM)(HWND)(hwndCursor), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnSysCommand(HWND hwnd, UINT cmd, int x, int y); */
#define HANDLE_WM_SYSCOMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSCOMMAND(hwnd, cmd, x, y, fn) \
    (void)(fn)((hwnd), WM_SYSCOMMAND, (WPARAM)(UINT)(cmd), MAKELPARAM((x), (y)))

/* HWND Cls_MDICreate(HWND hwnd, const MDICREATESTRUCT FAR* lpmcs); */
#define HANDLE_WM_MDICREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (MDICREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_MDICREATE(hwnd, lpmcs, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDICREATE, 0, (LPARAM)(lpmcs))

/* void Cls_MDIDestroy(HWND hwnd, HWND hwndDestroy); */
#define HANDLE_WM_MDIDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIDESTROY(hwnd, hwndDestroy, fn) \
    (void)(fn)((hwnd), WM_MDIDESTROY, (WPARAM)(hwndDestroy), 0L)

/* NOTE: Usable only by MDI client windows */
/* void Cls_MDIActivate(HWND hwnd, BOOL fActive, HWND hwndActivate, HWND hwndDeactivate); */
#define HANDLE_WM_MDIACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (HWND)HIWORD(lParam)), 0L)
#define FORWARD_WM_MDIACTIVATE(hwnd, fActive, hwndActivate, hwndDeactivate, fn) \
    (void)(fn)(hwnd, WM_MDIACTIVATE, (WPARAM)(fActive), MAKELPARAM((hwndActivate), (hwndDeactivate)))

/* void Cls_MDIRestore(HWND hwnd, HWND hwndRestore); */
#define HANDLE_WM_MDIRESTORE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIRESTORE(hwnd, hwndRestore, fn) \
    (void)(fn)((hwnd), WM_MDIRESTORE, (WPARAM)(hwndRestore), 0L)

/* HWND Cls_MDINext(HWND hwnd, HWND hwndCur, BOOL fPrev); */
#define HANDLE_WM_MDINEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_MDINEXT(hwnd, hwndCur, fPrev, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDINEXT, (WPARAM)(hwndCur), MAKELPARAM((fPrev), 0))

/* void Cls_MDIMaximize(HWND hwnd, HWND hwndMaximize); */
#define HANDLE_WM_MDIMAXIMIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIMAXIMIZE(hwnd, hwndMaximize, fn) \
    (void)(fn)((hwnd), WM_MDIMAXIMIZE, (WPARAM)(hwndMaximize), 0L)

/* BOOL Cls_MDITile(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDITILE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDITILE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDITILE, (WPARAM)(cmd), 0L)

/* BOOL Cls_MDICascade(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDICASCADE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDICASCADE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDICASCADE, (WPARAM)(cmd), 0L)

/* void Cls_MDIIconArrange(HWND hwnd); */
#define HANDLE_WM_MDIICONARRANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_MDIICONARRANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_MDIICONARRANGE, 0, 0L)

/* HWND Cls_MDIGetActive(HWND hwnd); */
#define HANDLE_WM_MDIGETACTIVE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_MDIGETACTIVE(hwnd, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDIGETACTIVE, 0, 0L)

/* HMENU Cls_MDISetMenu(HWND hwnd, BOOL fRefresh, HMENU hmenuFrame, HMENU hmenuWindow); */
#define HANDLE_WM_MDISETMENU(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (HMENU)LOWORD(lParam), (HMENU)HIWORD(lParam))
#define FORWARD_WM_MDISETMENU(hwnd, fRefresh, hmenuFrame, hmenuWindow, fn) \
    (HMENU)(UINT)(DWORD)(fn)((hwnd), WM_MDISETMENU, (WPARAM)(fRefresh), MAKELPARAM((hmenuFrame), (hmenuWindow)))

/* void Cls_OnChildActivate(HWND hwnd); */
#define HANDLE_WM_CHILDACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CHILDACTIVATE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CHILDACTIVATE, 0, 0L)

/* BOOL Cls_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam); */
#define HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(BOOL)(fn)((hwnd), (HWND)(wParam), lParam);
#define FORWARD_WM_INITDIALOG(hwnd, hwndFocus, lParam, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_INITDIALOG, (WPARAM)(HWND)(hwndFocus), (lParam))

/* HWND Cls_OnNextDlgCtl(HWND hwnd, HWND hwndSetFocus, BOOL fNext) */
#define HANDLE_WM_NEXTDLGCTL(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HWND)(fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam))
#define FORWARD_WM_NEXTDLGCTL(hwnd, hwndSetFocus, fNext, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_NEXTDLGCTL, (WPARAM)(HWND)(hwndSetFocus), MAKELPARAM((fNext), 0))

/* void Cls_OnParentNotify(HWND hwnd, UINT msg, HWND hwndChild, int idChild); */
#define HANDLE_WM_PARENTNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_PARENTNOTIFY(hwnd, msg, hwndChild, idChild, fn) \
    (void)(fn)((hwnd), WM_PARENTNOTIFY, (WPARAM)(UINT)(msg), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(idChild)))

/* void Cls_OnEnterIdle(HWND hwnd, UINT source, HWND hwndSource); */
#define HANDLE_WM_ENTERIDLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_ENTERIDLE(hwnd, source, hwndSource, fn) \
    (void)(fn)((hwnd), WM_ENTERIDLE, (WPARAM)(UINT)(source), MAKELPARAM((UINT)(HWND)(hwndSource), 0))

/* UINT Cls_OnGetDlgCode(HWND hwnd, MSG FAR* lpmsg); */
#define HANDLE_WM_GETDLGCODE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd, (MSG FAR*)(lParam))
#define FORWARD_WM_GETDLGCODE(hwnd, lpmsg, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_GETDLGCODE, (SELECTOROF(lpmsg) ? lpmsg->wParam : 0), (LPARAM)(lpmsg))

/* HBRUSH Cls_OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type); */
#define HANDLE_WM_CTLCOLOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)LOWORD(lParam), (int)(HIWORD(lParam)))
#define FORWARD_WM_CTLCOLOR(hwnd, hdc, hwndChild, type, fn) \
    (HBRUSH)(UINT)(DWORD)(fn)((hwnd), WM_CTLCOLOR, (WPARAM)(HDC)(hdc), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(int)(type)))

/* void Cls_OnSetFont(HWND hwndCtl, HFONT hfont, BOOL fRedraw); */
#define HANDLE_WM_SETFONT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HFONT)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SETFONT(hwnd, hfont, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETFONT, (WPARAM)(HFONT)(hfont), MAKELPARAM((UINT)(BOOL)(fRedraw), 0))

/* HFONT Cls_OnGetFont(HWND hwnd); */
#define HANDLE_WM_GETFONT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HFONT)(fn)(hwnd)
#define FORWARD_WM_GETFONT(hwnd, fn) \
    (HFONT)(UINT)(DWORD)(fn)((hwnd), WM_GETFONT, 0, 0L)

/* void Cls_OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT FAR* lpDrawItem); */
#define HANDLE_WM_DRAWITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DRAWITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DRAWITEM(hwnd, lpDrawItem, fn) \
    (void)(fn)((hwnd), WM_DRAWITEM, 0, (LPARAM)(const DRAWITEMSTRUCT FAR*)(lpDrawItem))

/* void Cls_OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT FAR* lpMeasureItem); */
#define HANDLE_WM_MEASUREITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MEASUREITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_MEASUREITEM(hwnd, lpMeasureItem, fn) \
    (void)(fn)((hwnd), WM_MEASUREITEM, 0, (LPARAM)(MEASUREITEMSTRUCT FAR*)(lpMeasureItem))

/* void Cls_OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT FAR* lpDeleteItem) */
#define HANDLE_WM_DELETEITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DELETEITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DELETEITEM(hwnd, lpDeleteItem, fn) \
    (void)(fn)((hwnd), WM_DELETEITEM, 0, (LPARAM)(const DELETEITEMSTRUCT FAR*)(lpDeleteItem))

/* int Cls_OnCompareItem(HWND hwnd, const COMPAREITEMSTRUCT FAR* lpCompareItem); */
#define HANDLE_WM_COMPAREITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (const COMPAREITEMSTRUCT FAR*)(lParam))
#define FORWARD_WM_COMPAREITEM(hwnd, lpCompareItem, fn) \
    (int)(DWORD)(fn)((hwnd), WM_COMPAREITEM, 0, (LPARAM)(const COMPAREITEMSTRUCT FAR*)(lpCompareItem))

/* int Cls_OnVkeyToItem(HWND hwnd, UINT vk, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_VKEYTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_VKEYTOITEM(hwnd, vk, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_VKEYTOITEM, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* int Cls_OnCharToItem(HWND hwnd, UINT ch, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_CHARTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_CHARTOITEM(hwnd, ch, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_CHARTOITEM, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* void Cls_OnQueueSync(HWND hwnd); */
#define HANDLE_WM_QUEUESYNC(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_QUEUESYNC(hwnd, fn) \
    (void)(fn)((hwnd), WM_QUEUESYNC, 0, 0L)

/* void Cls_OnCommNotify(HWND hwnd, int cid, UINT flags); */
#define HANDLE_WM_COMMNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_COMMNOTIFY(hwnd, cid, flags, fn) \
    (void)(fn)((hwnd), WM_COMMNOTIFY, (WPARAM)(cid), MAKELPARAM((flags), 0))

/****** Static control message APIs ******************************************/

#define Static_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Static_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Static_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Static_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Static_SetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_SETICON, (WPARAM)(HICON)(hIcon), 0L))
#define Static_GetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_GETICON, 0, 0L))

/****** Button control message APIs ******************************************/

#define Button_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Button_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Button_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Button_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Button_GetCheck(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETCHECK, 0, 0L))
#define Button_SetCheck(hwndCtl, check)     ((void)SendMessage((hwndCtl), BM_SETCHECK, (WPARAM)(int)(check), 0L))

#define Button_GetState(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETSTATE, 0, 0L))
#define Button_SetState(hwndCtl, state)     ((UINT)(DWORD)SendMessage((hwndCtl), BM_SETSTATE, (WPARAM)(int)(state), 0L))

#define Button_SetStyle(hwndCtl, style, fRedraw) ((void)SendMessage((hwndCtl), BM_SETSTYLE, (WPARAM)LOWORD(style), MAKELPARAM(((fRedraw) ? TRUE : FALSE), 0)))

/****** Edit control message APIs ********************************************/

#define Edit_Enable(hwndCtl, fEnable)           EnableWindow((hwndCtl), (fEnable))

#define Edit_GetText(hwndCtl, lpch, cchMax)     GetWindowText((hwndCtl), (lpch), (cchMax))
#define Edit_GetTextLength(hwndCtl)             GetWindowTextLength(hwndCtl)
#define Edit_SetText(hwndCtl, lpsz)             SetWindowText((hwndCtl), (lpsz))

#define Edit_LimitText(hwndCtl, cchMax)         ((void)SendMessage((hwndCtl), EM_LIMITTEXT, (WPARAM)(cchMax), 0L))

#define Edit_GetLineCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINECOUNT, 0, 0L))
#define Edit_GetLine(hwndCtl, line, lpch, cchMax) ((*((int FAR*)(lpch)) = (cchMax)), ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINE, (WPARAM)(int)(line), (LPARAM)(LPSTR)(lpch))))

#define Edit_GetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_GETRECT, 0, (LPARAM)(RECT FAR*)(lprc)))
#define Edit_SetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_SETRECT, 0, (LPARAM)(const RECT FAR*)(lprc)))
#define Edit_SetRectNoPaint(hwndCtl, lprc)      ((void)SendMessage((hwndCtl), EM_SETRECTNP, 0, (LPARAM)(const RECT FAR*)(lprc)))

#define Edit_GetSel(hwndCtl)                    ((DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L))
#define Edit_SetSel(hwndCtl, ichStart, ichEnd)  ((void)SendMessage((hwndCtl), EM_SETSEL, 0, MAKELPARAM((ichStart), (ichEnd))))
#define Edit_ReplaceSel(hwndCtl, lpszReplace)   ((void)SendMessage((hwndCtl), EM_REPLACESEL, 0, (LPARAM)(LPCSTR)(lpszReplace)))

#define Edit_GetModify(hwndCtl)                 ((BOOL)(DWORD)SendMessage((hwndCtl), EM_GETMODIFY, 0, 0L))
#define Edit_SetModify(hwndCtl, fModified)      ((void)SendMessage((hwndCtl), EM_SETMODIFY, (WPARAM)(UINT)(fModified), 0L))

#define Edit_LineFromChar(hwndCtl, ich)         ((int)(DWORD)SendMessage((hwndCtl), EM_LINEFROMCHAR, (WPARAM)(int)(ich), 0L))
#define Edit_LineIndex(hwndCtl, line)           ((int)(DWORD)SendMessage((hwndCtl), EM_LINEINDEX, (WPARAM)(int)(line), 0L))
#define Edit_LineLength(hwndCtl, line)          ((int)(DWORD)SendMessage((hwndCtl), EM_LINELENGTH, (WPARAM)(int)(line), 0L))

#define Edit_Scroll(hwndCtl, dv, dh)            ((void)SendMessage((hwndCtl), EM_LINESCROLL, 0, MAKELPARAM((dv), (dh))))

#define Edit_CanUndo(hwndCtl)                   ((BOOL)(DWORD)SendMessage((hwndCtl), EM_CANUNDO, 0, 0L))
#define Edit_Undo(hwndCtl)                      ((BOOL)(DWORD)SendMessage((hwndCtl), EM_UNDO, 0, 0L))
#define Edit_EmptyUndoBuffer(hwndCtl)           ((void)SendMessage((hwndCtl), EM_EMPTYUNDOBUFFER, 0, 0L))

#define Edit_SetPasswordChar(hwndCtl, ch)       ((void)SendMessage((hwndCtl), EM_SETPASSWORDCHAR, (WPARAM)(UINT)(ch), 0L))

#define Edit_SetTabStops(hwndCtl, cTabs, lpTabs) ((void)SendMessage((hwndCtl), EM_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(const int FAR*)(lpTabs)))

#define Edit_FmtLines(hwndCtl, fAddEOL)         ((BOOL)(DWORD)SendMessage((hwndCtl), EM_FMTLINES, (WPARAM)(BOOL)(fAddEOL), 0L))

#define Edit_GetHandle(hwndCtl)                 ((HLOCAL)(UINT)(DWORD)SendMessage((hwndCtl), EM_GETHANDLE, 0, 0L))
#define Edit_SetHandle(hwndCtl, h)              ((void)SendMessage((hwndCtl), EM_SETHANDLE, (WPARAM)(UINT)(HLOCAL)(h), 0L))

#if (WINVER >= 0x030a)
#define Edit_GetFirstVisibleLine(hwndCtl)       ((int)(DWORD)SendMessage((hwndCtl), EM_GETFIRSTVISIBLELINE, 0, 0L))

#define Edit_SetReadOnly(hwndCtl, fReadOnly)    ((BOOL)(DWORD)SendMessage((hwndCtl), EM_SETREADONLY, (WPARAM)(BOOL)(fReadOnly), 0L))

#define Edit_GetPasswordChar(hwndCtl)           ((char)(DWORD)SendMessage((hwndCtl), EM_GETPASSWORDCHAR, 0, 0L))

#define Edit_SetWordBreakProc(hwndCtl, lpfnWordBreak) ((void)SendMessage((hwndCtl), EM_SETWORDBREAKPROC, 0, (LPARAM)(EDITWORDBREAKPROC)(lpfnWordBreak)))
#define Edit_GetWordBreakProc(hwndCtl)          ((EDITWORDBREAKPROC)SendMessage((hwndCtl), EM_GETWORDBREAKPROC, 0, 0L))
#endif /* WINVER >= 0x030a */

/****** ScrollBar control message APIs ***************************************/

/* NOTE: flags parameter is a collection of ESB_* values, NOT a boolean! */
#define ScrollBar_Enable(hwndCtl, flags)            EnableScrollBar((hwndCtl), SB_CTL, (flags))

#define ScrollBar_Show(hwndCtl, fShow)              ShowWindow((hwndCtl), (fShow) ? SW_SHOWNORMAL : SW_HIDE)

#define ScrollBar_SetPos(hwndCtl, pos, fRedraw)     SetScrollPos((hwndCtl), SB_CTL, (pos), (fRedraw))
#define ScrollBar_GetPos(hwndCtl)                   GetScrollPos((hwndCtl), SB_CTL)

#define ScrollBar_SetRange(hwndCtl, posMin, posMax, fRedraw)    SetScrollRange((hwndCtl), SB_CTL, (posMin), (posMax), (fRedraw))
#define ScrollBar_GetRange(hwndCtl, lpposMin, lpposMax)         GetScrollRange((hwndCtl), SB_CTL, (lpposMin), (lpposMax))

/****** ListBox control message APIs *****************************************/

#define ListBox_Enable(hwndCtl, fEnable)            EnableWindow((hwndCtl), (fEnable))

#define ListBox_GetCount(hwndCtl)                   ((int)(DWORD)SendMessage((hwndCtl), LB_GETCOUNT, 0, 0L))
#define ListBox_ResetContent(hwndCtl)               ((BOOL)(DWORD)SendMessage((hwndCtl), LB_RESETCONTENT, 0, 0L))

#define ListBox_AddString(hwndCtl, lpsz)            ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ListBox_InsertString(hwndCtl, index, lpsz)  ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ListBox_AddItemData(hwndCtl, data)          ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(data)))
#define ListBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_DeleteString(hwndCtl, index)        ((int)(DWORD)SendMessage((hwndCtl), LB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ListBox_GetTextLen(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXTLEN, (WPARAM)(int)(index), 0L))
#define ListBox_GetText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ListBox_GetItemData(hwndCtl, index)         ((LRESULT)(DWORD)SendMessage((hwndCtl), LB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ListBox_SetItemData(hwndCtl, index, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_FindString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_FindItemData(hwndCtl, indexStart, data) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_SetSel(hwndCtl, fSelect, index)     ((int)(DWORD)SendMessage((hwndCtl), LB_SETSEL, (WPARAM)(BOOL)(fSelect), MAKELPARAM((index), 0)))
#define ListBox_SelItemRange(hwndCtl, fSelect, first, last)    ((int)(DWORD)SendMessage((hwndCtl), LB_SELITEMRANGE, (WPARAM)(BOOL)(fSelect), MAKELPARAM((first), (last))))

#define ListBox_GetCurSel(hwndCtl)                  ((int)(DWORD)SendMessage((hwndCtl), LB_GETCURSEL, 0, 0L))
#define ListBox_SetCurSel(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), LB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ListBox_SelectString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_SelectItemData(hwndCtl, indexStart, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_GetSel(hwndCtl, index)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETSEL, (WPARAM)(int)(index), 0L))
#define ListBox_GetSelCount(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELCOUNT, 0, 0L))
#define ListBox_GetTopIndex(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETTOPINDEX, 0, 0L))
#define ListBox_GetSelItems(hwndCtl, cItems, lpItems) ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELITEMS, (WPARAM)(int)(cItems), (LPARAM)(int FAR*)(lpItems)))

#define ListBox_SetTopIndex(hwndCtl, indexTop)      ((int)(DWORD)SendMessage((hwndCtl), LB_SETTOPINDEX, (WPARAM)(int)(indexTop), 0L))

#define ListBox_SetColumnWidth(hwndCtl, cxColumn)   ((void)SendMessage((hwndCtl), LB_SETCOLUMNWIDTH, (WPARAM)(int)(cxColumn), 0L))
#define ListBox_GetHorizontalExtent(hwndCtl)        ((int)(DWORD)SendMessage((hwndCtl), LB_GETHORIZONTALEXTENT, 0, 0L))
#define ListBox_SetHorizontalExtent(hwndCtl, cxExtent)     ((void)SendMessage((hwndCtl), LB_SETHORIZONTALEXTENT, (WPARAM)(int)(cxExtent), 0L))

#define ListBox_SetTabStops(hwndCtl, cTabs, lpTabs) ((BOOL)(DWORD)SendMessage((hwndCtl), LB_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(int FAR*)(lpTabs)))

#define ListBox_GetItemRect(hwndCtl, index, lprc)   ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMRECT, (WPARAM)(int)(index), (LPARAM)(RECT FAR*)(lprc)))

#define ListBox_SetCaretIndex(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_SETCARETINDEX, (WPARAM)(int)(index), 0L))
#define ListBox_GetCaretIndex(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETCARETINDEX, 0, 0L))

#define ListBox_SetAnchorIndex(hwndCtl, index)      ((void)SendMessage((hwndCtl), LB_SETANCHORINDEX, (WPARAM)(int)(index), 0L))            /* ;Internal */
#define ListBox_GetAnchorIndex(hwndCtl)             ((int)(DWORD)SendMessage((hwndCtl), LB_GETANCHORINDEX, 0, 0L))                        /* ;Internal */

#if (WINVER >= 0x030a)
#define ListBox_FindStringExact(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ListBox_SetItemHeight(hwndCtl, index, cy)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMHEIGHT, (WPARAM)(int)(index), MAKELPARAM((cy), 0)))
#define ListBox_GetItemHeight(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMHEIGHT, (WPARAM)(int)(index), 0L))
#endif  /* WINVER >= 0x030a */

#define ListBox_Dir(hwndCtl, attrs, lpszFileSpec)   ((int)(DWORD)SendMessage((hwndCtl), LB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))
#define ListBox_AddFile(hwndCtl, lpszFilename)      ((int)(DWORD)SendMessage((hwndCtl), LB_ADDFILE, 0, (LPARAM)(LPCSTR)(lpszFilename)))    /* ;Internal */

/****** ComboBox control message APIs ****************************************/

#define ComboBox_Enable(hwndCtl, fEnable)       EnableWindow((hwndCtl), (fEnable))

#define ComboBox_GetText(hwndCtl, lpch, cchMax) GetWindowText((hwndCtl), (lpch), (cchMax))
#define ComboBox_GetTextLength(hwndCtl)         GetWindowTextLength(hwndCtl)
#define ComboBox_SetText(hwndCtl, lpsz)         SetWindowText((hwndCtl), (lpsz))

#define ComboBox_LimitText(hwndCtl, cchLimit)   ((int)(DWORD)SendMessage((hwndCtl), CB_LIMITTEXT, (WPARAM)(int)(cchLimit), 0L))

#define ComboBox_GetEditSel(hwndCtl)            ((DWORD)SendMessage((hwndCtl), CB_GETEDITSEL, 0, 0L))
#define ComboBox_SetEditSel(hwndCtl, ichStart, ichEnd) ((int)(DWORD)SendMessage((hwndCtl), CB_SETEDITSEL, 0, MAKELPARAM((ichStart), (ichEnd))))

#define ComboBox_GetCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), CB_GETCOUNT, 0, 0L))
#define ComboBox_ResetContent(hwndCtl)          ((int)(DWORD)SendMessage((hwndCtl), CB_RESETCONTENT, 0, 0L))

#define ComboBox_AddString(hwndCtl, lpsz)       ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ComboBox_InsertString(hwndCtl, index, lpsz) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ComboBox_AddItemData(hwndCtl, data)     ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(data)))
#define ComboBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_DeleteString(hwndCtl, index)   ((int)(DWORD)SendMessage((hwndCtl), CB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ComboBox_GetLBTextLen(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXTLEN, (WPARAM)(int)(index), 0L))
#define ComboBox_GetLBText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ComboBox_GetItemData(hwndCtl, index)        ((LRESULT)(DWORD)SendMessage((hwndCtl), CB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ComboBox_SetItemData(hwndCtl, index, data)  ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_FindString(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ComboBox_FindItemData(hwndCtl, indexStart, data)    ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_GetCurSel(hwndCtl)                 ((int)(DWORD)SendMessage((hwndCtl), CB_GETCURSEL, 0, 0L))
#define ComboBox_SetCurSel(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), CB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ComboBox_SelectString(hwndCtl, indexStart, lpszSelect)  ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszSelect)))
#define ComboBox_SelectItemData(hwndCtl, indexStart, data)      ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_Dir(hwndCtl, attrs, lpszFileSpec)  ((int)(DWORD)SendMessage((hwndCtl), CB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))

#define ComboBox_ShowDropdown(hwndCtl, fShow)       ((BOOL)(DWORD)SendMessage((hwndCtl), CB_SHOWDROPDOWN, (WPARAM)(BOOL)(fShow), 0L))

#if (WINVER >= 0x030a)
#define ComboBox_FindStringExact(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ComboBox_GetDroppedState(hwndCtl)           ((BOOL)(DWORD)SendMessage((hwndCtl), CB_GETDROPPEDSTATE, 0, 0L))
#define ComboBox_GetDroppedControlRect(hwndCtl, lprc) ((void)SendMessage((hwndCtl), CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)(RECT FAR*)(lprc)))

#define ComboBox_GetItemHeight(hwndCtl)             ((int)(DWORD)SendMessage((hwndCtl), CB_GETITEMHEIGHT, 0, 0L))
#define ComboBox_SetItemHeight(hwndCtl, cyItem)     ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMHEIGHT, (WPARAM)(int)(index), 0L))

#define ComboBox_GetExtendedUI(hwndCtl)             ((UINT)(DWORD)SendMessage((hwndCtl), CB_GETEXTENDEDUI, 0, 0L))
#define ComboBox_SetExtendedUI(hwndCtl, flags)      ((int)(DWORD)SendMessage((hwndCtl), CB_SETEXTENDEDUI, (WPARAM)(UINT)(flags), 0L))
#endif  /* WINVER >= 0x030a */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* !_INC_WINDOWSX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\sdk\inc16\windows.h ===
/*****************************************************************************\
*                                                                             *
* windows.h -   Windows functions, types, and definitions                     *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1985-1992, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file:
*
* WINVER            Windows version number (0x030a).  To exclude
*                   definitions introduced in version 3.1 (or above)
*                   #define WINVER 0x0300 before #including <windows.h>
*
* #define:          To prevent inclusion of:
*
* NOKERNEL          KERNEL APIs and definitions
* NOGDI             GDI APIs and definitions
* NOUSER            USER APIs and definitions
* NOSOUND           Sound APIs and definitions
* NOCOMM            Comm driver APIs and definitions
* NODRIVERS         Installable driver APIs and definitions
*
* NOMINMAX          min() and max() macros
* NOLOGERROR        LogError() and related definitions
* NOPROFILER        Profiler APIs
* NOMEMMGR          Local and global memory management
* NOLFILEIO         _l* file I/O routines
* NOOPENFILE        OpenFile and related definitions
* NORESOURCE        Resource management
* NOATOM            Atom management
* NOLANGUAGE        Character test routines
* NOLSTRING         lstr* string management routines
* NODBCS            Double-byte character set routines
* NOKEYBOARDINFO    Keyboard driver routines
* NOGDICAPMASKS     GDI device capability constants
* NOCOLOR           COLOR_* color values
* NOGDIOBJ          GDI pens, brushes, fonts
* NODRAWTEXT        DrawText() and related definitions
* NOTEXTMETRIC      TEXTMETRIC and related APIs
* NOSCALABLEFONT    Truetype scalable font support
* NOBITMAP          Bitmap support
* NORASTEROPS       GDI Raster operation definitions
* NOMETAFILE        Metafile support
* NOSYSMETRICS      GetSystemMetrics() and related SM_* definitions
* NOSYSTEMPARAMSINFO SystemParametersInfo() and SPI_* definitions
* NOMSG             APIs and definitions that use MSG structure
* NOWINSTYLES       Window style definitions
* NOWINOFFSETS      Get/SetWindowWord/Long offset definitions
* NOSHOWWINDOW      ShowWindow and related definitions
* NODEFERWINDOWPOS  DeferWindowPos and related definitions
* NOVIRTUALKEYCODES VK_* virtual key codes
* NOKEYSTATES       MK_* message key state flags
* NOWH              SetWindowsHook and related WH_* definitions
* NOMENUS           Menu APIs
* NOSCROLL          Scrolling APIs and scroll bar control
* NOCLIPBOARD       Clipboard APIs and definitions
* NOICONS           IDI_* icon IDs
* NOMB              MessageBox and related definitions
* NOSYSCOMMANDS     WM_SYSCOMMAND SC_* definitions
* NOMDI             MDI support
* NOCTLMGR          Control management and controls
* NOWINMESSAGES     WM_* window messages
* NOHELP            Help support
*
\****************************************************************************/

#ifndef _INC_WINDOWS
#define _INC_WINDOWS    /* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#pragma warning(4:4020)
#pragma warning(disable:4001)
#pragma warning(disable:4103)
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifdef NOWIN31                      /* ;Internal */
#define WINVER  0x0300              /* ;Internal */
#endif                              /* ;Internal */
                                    /* ;Internal */
/* If WINVER is not defined, assume version 3.1 */
#ifndef WINVER
#define WINVER  0x030a
#endif

#ifdef RC_INVOKED
/* Don't include definitions that RC.EXE can't parse */
#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NODBCS
#define NOSYSTEMPARAMSINFO
#define NOCOMM
#define NOOEMRESOURCE
#endif  /* RC_INVOKED */

/* Temp internal compatibility hacks */ /* ;Internal */
#define NOOEMRESOURCE               /* ;Internal */
#ifdef OEMRESOURCE                  /* ;Internal */
#undef NOOEMRESOURCE                /* ;Internal */
#endif                              /* ;Internal */
#define NOCOMM                      /* ;Internal */
#ifdef USECOMM                      /* ;Internal */
#undef NOCOMM                       /* ;Internal */
#endif                              /* ;Internal */
                                    /* ;Internal */
/* Handle OEMRESOURCE for 3.0 compatibility */
#if (WINVER < 0x030a)
#define NOOEMRESOURCE
#ifdef OEMRESOURCE
#undef NOOEMRESOURCE
#endif
#endif

/******* Common definitions and typedefs ***********************************/

#define VOID                void

#define FAR                 _far
#define NEAR                _near
#define PASCAL              _pascal
#define CDECL               _cdecl
#define CONST               const                   /* ;Internal */

#ifdef BUILDDLL                                     /* ;Internal */
#define WINAPI              _loadds _far _pascal    /* ;Internal */
#define CALLBACK            _loadds _far _pascal    /* ;Internal */
#else                                               /* ;Internal */
#define WINAPI              _far _pascal
#define CALLBACK            _far _pascal
#endif                                              /* ;Internal */
                                                    /* ;Internal */
#define API                 WINAPI                  /* ;Internal */

/****** Simple types & common helper macros *********************************/

typedef int                 BOOL;
#define FALSE               0
#define TRUE                1

typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef unsigned long       DWORD;

typedef unsigned int        UINT;

#ifdef STRICT
typedef signed long         LONG;
#else
#define LONG long
#endif

#define LOBYTE(w)           ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((UINT)(w) >> 8) & 0xFF))

#define LOWORD(l)           ((WORD)(DWORD)(l))
#define HIWORD(l)           ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))

#define MAKELONG(low, high) ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))

#ifndef NOMINMAX
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif
#endif  /* NOMINMAX */

/* Types use for passing & returning polymorphic values */
typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

#define MAKELPARAM(low, high)   ((LPARAM)MAKELONG(low, high))
#define MAKELRESULT(low, high)  ((LRESULT)MAKELONG(low, high))

/****** Common pointer types ************************************************/

#ifndef NULL
#define NULL                0
#endif

typedef char NEAR*          PSTR;
typedef char NEAR*          NPSTR;

#define SZ char                         /* ;Internal */

typedef char FAR*           LPSTR;
typedef const char FAR*     LPCSTR;

typedef BYTE NEAR*          PBYTE;
typedef BYTE FAR*           LPBYTE;

typedef int NEAR*           PINT;
typedef int FAR*            LPINT;

typedef WORD NEAR*          PWORD;
typedef WORD FAR*           LPWORD;

typedef long NEAR*          PLONG;
typedef long FAR*           LPLONG;

typedef DWORD NEAR*         PDWORD;
typedef DWORD FAR*          LPDWORD;

typedef void FAR*           LPVOID;

#define MAKELP(sel, off)    ((void FAR*)MAKELONG((off), (sel)))
#define SELECTOROF(lp)      HIWORD(lp)
#define OFFSETOF(lp)        LOWORD(lp)

#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)

/****** Common handle types *************************************************/

#ifdef STRICT
typedef const void NEAR*        HANDLE;
#define DECLARE_HANDLE(name)    struct name##__ { int unused; }; \
                                typedef const struct name##__ NEAR* name
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ FAR* name
#else   /* STRICT */
typedef UINT                    HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */

typedef HANDLE*             PHANDLE;
typedef HANDLE NEAR*        SPHANDLE;
typedef HANDLE FAR*         LPHANDLE;

typedef HANDLE              HGLOBAL;
typedef HANDLE              HLOCAL;

typedef HANDLE              GLOBALHANDLE;
typedef HANDLE              LOCALHANDLE;

typedef UINT                ATOM;

#ifdef STRICT
typedef void (CALLBACK*     FARPROC)(void);
typedef void (NEAR PASCAL*  NEARPROC)(void);
#else
typedef int (CALLBACK*      FARPROC)();
typedef int (NEAR PASCAL*   NEARPROC)();
#endif

DECLARE_HANDLE(HSTR);

/****** KERNEL typedefs, structures, and functions **************************/

DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;  /* HMODULEs can be used in place of HINSTANCEs */

#ifndef NOKERNEL

/****** Application entry point function ************************************/

#ifdef STRICT
int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
#endif

/****** System Information **************************************************/

DWORD   WINAPI GetVersion(void);

DWORD   WINAPI GetFreeSpace(UINT);
UINT    WINAPI GetCurrentPDB(void);

UINT    WINAPI GetWindowsDirectory(LPSTR, UINT);
UINT    WINAPI GetSystemDirectory(LPSTR, UINT);

#if (WINVER >= 0x030a)
UINT    WINAPI GetFreeSystemResources(UINT);
#define GFSR_SYSTEMRESOURCES   0x0000
#define GFSR_GDIRESOURCES      0x0001
#define GFSR_USERRESOURCES     0x0002
#define GFSR_VALID             0x0002  /* ;Internal */
#endif  /* WINVER >= 0x030a */

DWORD   WINAPI GetWinFlags(void);

#define WF_PMODE        0x0001
#define WF_CPU286       0x0002
#define WF_CPU386       0x0004
#define WF_CPU486       0x0008
#define WF_STANDARD     0x0010
#define WF_WIN286       0x0010
#define WF_ENHANCED     0x0020
#define WF_WIN386       0x0020
#define WF_CPU086       0x0040
#define WF_CPU186       0x0080
#define WF_LARGEFRAME   0x0100
#define WF_CPUEM        0x0100
#define WF_SMALLFRAME   0x0200
#define WF_80x87        0x0400
#define WF_PAGING       0x0800
#define WF_WINNT        0x4000
#define WF_WLO          0x8000

LPSTR   WINAPI GetDOSEnvironment(void);

DWORD   WINAPI GetCurrentTime(void);
DWORD   WINAPI GetTickCount(void);
DWORD   WINAPI GetTimerResolution(void);

/****** Error handling ******************************************************/

#if (WINVER >= 0x030a)
#ifndef NOLOGERROR

void    WINAPI LogError(UINT err, void FAR* lpInfo);
void    WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING             0x8000
#define ERR_PARAM               0x4000

/* Internal error value masks */            /* ;Internal */
#define ERR_TYPE_MASK           0x0fff      /* ;Internal */
#define ERR_FLAGS_MASK          0xc000      /* ;Internal */
                                            /* ;Internal */
#define ERR_SIZE_MASK           0x3000
#define ERR_SIZE_SHIFT          12          /* ;Internal */
#define ERR_BYTE                0x1000
#define ERR_WORD                0x2000
#define ERR_DWORD               0x3000
                                            /* ;Internal */
/* Error option flags (set by [kernel] ErrorOptions win.ini variable) *//* ;Internal */
                                            /* ;Internal */
#define ERO_PARAM_ERROR_BREAK   0x0001      /* ;Internal */
#define ERO_BUFFER_FILL         0x0002      /* ;Internal */

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE           0x6001
#define ERR_BAD_FLAGS           0x6002
#define ERR_BAD_INDEX           0x6003
#define ERR_BAD_DVALUE          0x7004
#define ERR_BAD_DFLAGS          0x7005
#define ERR_BAD_DINDEX          0x7006
#define ERR_BAD_PTR             0x7007
#define ERR_BAD_FUNC_PTR        0x7008
#define ERR_BAD_SELECTOR        0x6009
#define ERR_BAD_STRING_PTR      0x700a
#define ERR_BAD_HANDLE          0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS          0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069

/* Debug fill constants */              /* ;Internal */
                                        /* ;Internal */
#define DBGFILL_ALLOC           0xfd    /* ;Internal */
#define DBGFILL_FREE            0xfb    /* ;Internal */
#define DBGFILL_BUFFER          0xf9    /* ;Internal */
#define DBGFILL_STACK           0xf7    /* ;Internal */

/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001
#define ERR_GREALLOC            0x0002
#define ERR_GLOCK               0x0003
#define ERR_LALLOC              0x0004
#define ERR_LREALLOC            0x0005
#define ERR_LLOCK               0x0006
#define ERR_ALLOCRES            0x0007
#define ERR_LOCKRES             0x0008
#define ERR_LOADMODULE          0x0009

/* USER errors */
#define ERR_CREATEDLG           0x0040
#define ERR_CREATEDLG2          0x0041
#define ERR_REGISTERCLASS       0x0042
#define ERR_DCBUSY              0x0043
#define ERR_CREATEWND           0x0044
#define ERR_STRUCEXTRA          0x0045
#define ERR_LOADSTR             0x0046
#define ERR_LOADMENU            0x0047
#define ERR_NESTEDBEGINPAINT    0x0048
#define ERR_BADINDEX            0x0049
#define ERR_CREATEMENU          0x004a

/* GDI errors */
#define ERR_CREATEDC            0x0080
#define ERR_CREATEMETA          0x0081
#define ERR_DELOBJSELECTED      0x0082
#define ERR_SELBITMAP           0x0083

/* Debugging support (DEBUG SYSTEM ONLY) */
typedef struct tagWINDEBUGINFO
{
    UINT    flags;
    DWORD   dwOptions;
    DWORD   dwFilter;
    char    achAllocModule[8];
    DWORD   dwAllocBreak;
    DWORD   dwAllocCount;
} WINDEBUGINFO;

BOOL    WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
BOOL    WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);

void    FAR _cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);
void    WINAPI DebugFillBuffer(void FAR* lpb, UINT cb);                 /* ;Internal */

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS         0x0001
#define WDI_FILTER          0x0002
#define WDI_ALLOCBREAK      0x0004
#define WDI_VALID           0x0007  /* ;Internal */

/* dwOptions values */
#define DBO_CHECKHEAP       0x0001
#define DBO_BUFFERFILL      0x0004
#define DBO_DISABLEGPTRAPPING 0x0010
#define DBO_CHECKFREE       0x0020

#define DBO_SILENT          0x8000

#define DBO_TRACEBREAK      0x2000
#define DBO_WARNINGBREAK    0x1000
#define DBO_NOERRORBREAK    0x0800
#define DBO_NOFATALBREAK    0x0400
#define DBO_INT3BREAK       0x0100

/* DebugOutput flags values */
#define DBF_TRACE           0x0000
#define DBF_WARNING         0x4000
#define DBF_ERROR           0x8000
#define DBF_FATAL           0xc000
#define DBF_SEVMASK         0xc000  /* ;Internal */
#define DBF_FILTERMASK      0x3fff  /* ;Internal */

/* dwFilter values */
#define DBF_KERNEL          0x1000
#define DBF_KRN_MEMMAN      0x0001
#define DBF_KRN_LOADMODULE  0x0002
#define DBF_KRN_SEGMENTLOAD 0x0004
#define DBF_USER            0x0800
#define DBF_GDI             0x0400
#define DBF_MMSYSTEM        0x0040
#define DBF_PENWIN          0x0020
#define DBF_APPLICATION     0x0008
#define DBF_DRIVER          0x0010

#endif  /* NOLOGERROR */
#endif  /* WINVER >= 0x030a */

void    WINAPI FatalExit(int);
void    WINAPI FatalAppExit(UINT, LPCSTR);

BOOL    WINAPI ExitWindows(DWORD dwReturnCode, UINT wReserved);

#define EW_RESTARTWINDOWS 0x42
#if (WINVER >= 0x030a)
#define EW_REBOOTSYSTEM   0x43
#define EW_EXITANDEXECAPP 0x44   /* ;Internal */

BOOL    WINAPI ExitWindowsExec(LPCSTR, LPCSTR);
#endif  /* WINVER >= 0x030a */

void    WINAPI DebugBreak(void);
void    WINAPI OutputDebugString(LPCSTR);

/* SetErrorMode() constants */
#define SEM_FAILCRITICALERRORS  0x0001
#define SEM_NOGPFAULTERRORBOX   0x0002
#define SEM_NOOPENFILEERRORBOX  0x8000

UINT    WINAPI SetErrorMode(UINT);

/****** Pointer validation **************************************************/

#if (WINVER >= 0x030a)

BOOL    WINAPI IsBadReadPtr(const void FAR* lp, UINT cb);
BOOL    WINAPI IsBadWritePtr(void FAR* lp, UINT cb);
BOOL    WINAPI IsBadHugeReadPtr(const void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadHugeWritePtr(void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadCodePtr(FARPROC lpfn);
BOOL    WINAPI IsBadStringPtr(const void FAR* lpsz, UINT cchMax);
#endif  /* WINVER >= 0x030a */

/****** Profiling support ***************************************************/

#ifndef NOPROFILER

int     WINAPI ProfInsChk(void);
void    WINAPI ProfSetup(int,int);
void    WINAPI ProfSampRate(int,int);
void    WINAPI ProfStart(void);
void    WINAPI ProfStop(void);
void    WINAPI ProfClear(void);
void    WINAPI ProfFlush(void);
void    WINAPI ProfFinish(void);
#endif  /* NOPROFILER */

/****** Catch/Throw and stack management ************************************/

typedef int CATCHBUF[9];
typedef int FAR* LPCATCHBUF;

int     WINAPI Catch(int FAR*);
void    WINAPI Throw(const int FAR*, int);

void    WINAPI SwitchStackBack(void);
void    WINAPI SwitchStackTo(UINT, UINT, UINT);

/****** Module Management ***************************************************/

#define HINSTANCE_ERROR ((HINSTANCE)32)

LONG    WINAPI GetExpWinVer(HINSTANCE);                 /* ;Internal */

HINSTANCE   WINAPI LoadModule(LPCSTR, LPVOID);
BOOL        WINAPI FreeModule(HINSTANCE);

HINSTANCE   WINAPI LoadLibrary(LPCSTR);
void        WINAPI FreeLibrary(HINSTANCE);

UINT    WINAPI WinExec(LPCSTR, UINT);

HMODULE WINAPI GetModuleHandle(LPCSTR);

int     WINAPI GetModuleUsage(HINSTANCE);
int     WINAPI GetModuleFileName(HINSTANCE, LPSTR, int);

FARPROC WINAPI GetProcAddress(HINSTANCE, LPCSTR);

int     WINAPI GetInstanceData(HINSTANCE, BYTE*, int);

HGLOBAL WINAPI GetCodeHandle(FARPROC);

typedef struct tagSEGINFO
{
    UINT offSegment;
    UINT cbSegment;
    UINT flags;
    UINT cbAlloc;
    HGLOBAL h;
    UINT alignShift;
    UINT reserved[2];
} SEGINFO;
typedef SEGINFO FAR* LPSEGINFO;

void    WINAPI GetCodeInfo(FARPROC lpProc, SEGINFO FAR* lpSegInfo);

FARPROC WINAPI MakeProcInstance(FARPROC, HINSTANCE);
void    WINAPI FreeProcInstance(FARPROC);

LONG    WINAPI SetSwapAreaSize(UINT);
void    WINAPI SwapRecording(UINT);
void    WINAPI ValidateCodeSegments(void);

/* Windows Exit Procedure flag values */
#define WEP_SYSTEM_EXIT 1
#define WEP_FREE_DLL    0

/****** Task Management *****************************************************/

#endif  /* NOKERNEL */

DECLARE_HANDLE(HTASK);

#ifndef NOKERNEL

UINT    WINAPI GetNumTasks(void);

#if (WINVER >= 0x030a)
BOOL    WINAPI IsTask(HTASK);
#endif  /* WINVER >= 0x030a */

HTASK   WINAPI GetCurrentTask(void);
int     WINAPI SetPriority(HTASK, int);     /* ;Internal */

void    WINAPI Yield(void);
void    WINAPI DirectedYield(HTASK);

DWORD   WINAPI GetAppCompatFlags(HTASK);                /* ;Internal */
                                                        /* ;Internal */
/* GetAppCompatFlags flag values */                     /* ;Internal */
#define GACF_IGNORENODISCARD    0x0001                  /* ;Internal */
#define GACF_FORCETEXTBAND      0x0002                  /* ;Internal */
#define GACF_ONELANDGRXBAND     0x0004                  /* ;Internal */
#define GACF_IGNORETOPMOST      0x0008                  /* ;Internal */
#define GACF_CALLTTDEVICE       0x0010                  /* ;Internal */
#define GACF_MULTIPLEBANDS      0x0020                  /* ;Internal */
#define GACF_ALWAYSSENDNCPAINT  0x0040                  /* ;Internal */
#define GACF_EDITSETTEXTMUNGE   0x0080                  /* ;Internal */
#define GACF_MOREEXTRAWNDWORDS  0x0100                  /* ;Internal */
#define GACF_TTIGNORERASTERDUPE 0x0200                  /* ;Internal */
#define GACF_HACKWINFLAGS       0x0400                  /* ;Internal */
#define GACF_DELAYHWHNDSHAKECHK 0x0800                  /* ;Internal */
#define GACF_ENUMHELVNTMSRMN    0x1000                  /* ;Internal */
#define GACF_ENUMTTNOTDEVICE    0x2000                  /* ;Internal */
#define GACF_SUBTRACTCLIPSIBS   0x4000                  /* ;Internal */
#define GACF_FORCETTGRAPHICS    0x8000                  /* ;Internal */
#define GACF_NOHRGN1            0x00010000              /* ;Internal */
#define GACF_NCCALCSIZEONMOVE   0x00020000              /* ;Internal */
#define GACF_SENDMENUDBLCLK     0x00040000              /* ;Internal */
#define GACF_30AVGWIDTH         0x00080000              /* ;Internal */

/****** Global memory management ********************************************/

#ifndef NOMEMMGR

/* Global Memory Flags */

#define GMEM_FIXED          0x0000
#define GMEM_MOVEABLE       0x0002
#define GMEM_NOCOMPACT      0x0010
#define GMEM_NODISCARD      0x0020
#define GMEM_ZEROINIT       0x0040
#define GMEM_MODIFY         0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE          0x2000
#define GMEM_DDESHARE       0x2000
#define GMEM_NOTIFY         0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#define GHND                (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR                (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalDiscard(h)    GlobalReAlloc(h, 0L, GMEM_MOVEABLE)

HGLOBAL WINAPI GlobalAlloc(UINT, DWORD);
HGLOBAL WINAPI GlobalReAlloc(HGLOBAL, DWORD, UINT);
HGLOBAL WINAPI GlobalFree(HGLOBAL);

DWORD   WINAPI GlobalDosAlloc(DWORD);
UINT    WINAPI GlobalDosFree(UINT);

#ifdef STRICT
void FAR* WINAPI GlobalLock(HGLOBAL);
#else
char FAR* WINAPI GlobalLock(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnlock(HGLOBAL);

DWORD   WINAPI GlobalSize(HGLOBAL);
DWORD   WINAPI GlobalHandle(UINT);

/* GlobalFlags return flags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED      0x4000
#define GMEM_LOCKCOUNT      0x00FF
UINT    WINAPI GlobalFlags(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI GlobalWire(HGLOBAL);
#else
char FAR* WINAPI GlobalWire(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnWire(HGLOBAL);

UINT    WINAPI GlobalPageLock(HGLOBAL);
UINT    WINAPI GlobalPageUnlock(HGLOBAL);

void    WINAPI GlobalFix(HGLOBAL);
void    WINAPI GlobalUnfix(HGLOBAL);

HGLOBAL WINAPI GlobalLRUNewest(HGLOBAL);
HGLOBAL WINAPI GlobalLRUOldest(HGLOBAL);

DWORD   WINAPI GlobalCompact(DWORD);

#ifdef STRICT
typedef BOOL (CALLBACK* GNOTIFYPROC)(HGLOBAL);
#else
typedef FARPROC GNOTIFYPROC;
#endif

void    WINAPI GlobalNotify(GNOTIFYPROC);

HGLOBAL WINAPI LockSegment(UINT);
void    WINAPI UnlockSegment(UINT);

#define LockData(dummy)     LockSegment((UINT)-1)
#define UnlockData(dummy)   UnlockSegment((UINT)-1)

UINT    WINAPI AllocSelector(UINT);
UINT    WINAPI FreeSelector(UINT);
UINT    WINAPI AllocDStoCSAlias(UINT);
UINT    WINAPI PrestoChangoSelector(UINT sourceSel, UINT destSel);
DWORD   WINAPI GetSelectorBase(UINT);
UINT    WINAPI SetSelectorBase(UINT, DWORD);
DWORD   WINAPI GetSelectorLimit(UINT);
UINT    WINAPI SetSelectorLimit(UINT, DWORD);

void    WINAPI LimitEmsPages(DWORD);

void    WINAPI ValidateFreeSpaces(void);

/* Low system memory notification message */
#define WM_COMPACTING       0x0041

/***** Local Memory Management */

/* Local Memory Flags */
#define LMEM_FIXED          0x0000
#define LMEM_MOVEABLE       0x0002
#define LMEM_NOCOMPACT      0x0010
#define LMEM_NODISCARD      0x0020
#define LMEM_ZEROINIT       0x0040
#define LMEM_MODIFY         0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LHND                (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR                (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND         (LMEM_MOVEABLE)
#define NONZEROLPTR         (LMEM_FIXED)

extern UINT NEAR* PASCAL pLocalHeap;                    /* ;Internal */
#define LocalFreeze(dummy)  (*(pLocalHeap+1) += 1)      /* ;Internal */
#define LocalMelt(dummy)    (*(pLocalHeap+1) -= 1)      /* ;Internal */

#define LocalDiscard(h)     LocalReAlloc(h, 0, LMEM_MOVEABLE)


HLOCAL  WINAPI LocalAlloc(UINT, UINT);
HLOCAL  WINAPI LocalReAlloc(HLOCAL, UINT, UINT);
HLOCAL  WINAPI LocalFree(HLOCAL);

#ifdef STRICT
void NEAR* WINAPI LocalLock(HLOCAL);
#else
char NEAR* WINAPI LocalLock(HLOCAL);
#endif

BOOL    WINAPI LocalUnlock(HLOCAL);

UINT    WINAPI LocalSize(HLOCAL);
#ifdef STRICT
HLOCAL  WINAPI LocalHandle(void NEAR*);
#else
HLOCAL  WINAPI LocalHandle(UINT);
#endif
UINT    WINAPI LocalHandleDelta(UINT);              /* ;Internal */

/* LocalFlags return flags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED      0x4000
#define LMEM_LOCKCOUNT      0x00FF

UINT    WINAPI LocalFlags(HLOCAL);

BOOL    WINAPI LocalInit(UINT, UINT, UINT);
UINT    WINAPI LocalCompact(UINT);
UINT    WINAPI LocalShrink(HLOCAL, UINT);

/* LocalNotify callback */                                          /* ;Internal */
#ifdef STRICT                                                       /* ;Internal */
typedef BOOL (CALLBACK* LNOTIFYPROC)(UINT, HLOCAL, void NEAR*);   /* ;Internal */
#else                                                               /* ;Internal */
typedef FARPROC LNOTIFYPROC;                                        /* ;Internal */
#endif                                                              /* ;Internal */
                                                                    /* ;Internal */
#define LNOTIFY_OUTOFMEM    0                                       /* ;Internal */
#define LNOTIFY_MOVE        1                                       /* ;Internal */
#define LNOTIFY_DISCARD     2                                       /* ;Internal */
                                                                    /* ;Internal */
LNOTIFYPROC WINAPI LocalNotify(LNOTIFYPROC);                        /* ;Internal */
                                                                    /* ;Internal */
#endif  /* NOMEMMGR */

/****** File I/O ************************************************************/

#ifndef NOLFILEIO

typedef int HFILE;      /* Polymorphic with C runtime file handle type */

#define HFILE_ERROR ((HFILE)-1)

#ifndef NOOPENFILE

/* OpenFile() Structure */
typedef struct tagOFSTRUCT
{
    BYTE cBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    char szPathName[128];
} OFSTRUCT;
typedef OFSTRUCT*       POFSTRUCT;
typedef OFSTRUCT NEAR* NPOFSTRUCT;
typedef OFSTRUCT FAR*  LPOFSTRUCT;

/* OpenFile() Flags */
#define OF_READ             0x0000
#define OF_WRITE            0x0001
#define OF_READWRITE        0x0002
#define OF_SHARE_COMPAT     0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE            0x0100
#define OF_DELETE           0x0200
#define OF_VERIFY           0x0400      /* Used with OF_REOPEN */
#define OF_SEARCH           0x0400      /* Used without OF_REOPEN */
#define OF_CANCEL           0x0800
#define OF_CREATE           0x1000
#define OF_PROMPT           0x2000
#define OF_EXIST            0x4000
#define OF_REOPEN           0x8000

HFILE   WINAPI OpenFile(LPCSTR, OFSTRUCT FAR*, UINT);

#endif  /* NOOPENFILE */

/* _lopen() flags */
#define READ        0
#define WRITE       1
#define READ_WRITE  2

HFILE   WINAPI _lopen(LPCSTR, int);
HFILE   WINAPI _lcreat(LPCSTR, int);

HFILE   WINAPI _lclose(HFILE);

LONG    WINAPI _llseek(HFILE, LONG, int);

/* _llseek origin values */
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

UINT    WINAPI _lread(HFILE, void _huge*, UINT);
UINT    WINAPI _lwrite(HFILE, const void _huge*, UINT);

#if (WINVER >= 0x030a)
long    WINAPI _hread(HFILE, void _huge*, long);
long    WINAPI _hwrite(HFILE, const void _huge*, long);
#endif  /* WINVER >= 0x030a */

UINT    WINAPI DeletePathname(LPCSTR);   /* ;Internal */

#endif  /* NOLFILEIO */

/* GetTempFileName() Flags */
#define TF_FORCEDRIVE       (BYTE)0x80

int     WINAPI GetTempFileName(BYTE, LPCSTR, UINT, LPSTR);
BYTE    WINAPI GetTempDrive(char);

/* GetDriveType return values */
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED     3
#define DRIVE_REMOTE    4
UINT    WINAPI GetDriveType(int);

UINT    WINAPI SetHandleCount(UINT);

/****** Network support *****************************************************/
UINT WINAPI WNetAddConnection(LPSTR, LPSTR, LPSTR);
UINT WINAPI WNetGetConnection(LPSTR, LPSTR, UINT FAR*);
UINT WINAPI WNetCancelConnection(LPSTR, BOOL);
/* Errors */
#define WN_SUCCESS                      0x0000
#define WN_NOT_SUPPORTED                0x0001
#define WN_NET_ERROR                    0x0002
#define WN_MORE_DATA                    0x0003
#define WN_BAD_POINTER                  0x0004
#define WN_BAD_VALUE                    0x0005
#define WN_BAD_PASSWORD                 0x0006
#define WN_ACCESS_DENIED                0x0007
#define WN_FUNCTION_BUSY                0x0008
#define WN_WINDOWS_ERROR                0x0009
#define WN_BAD_USER                     0x000A
#define WN_OUT_OF_MEMORY                0x000B
#define WN_CANCEL                       0x000C
#define WN_CONTINUE                     0x000D

/* Connection errors */
#define WN_NOT_CONNECTED                0x0030
#define WN_OPEN_FILES                   0x0031
#define WN_BAD_NETNAME                  0x0032
#define WN_BAD_LOCALNAME                0x0033
#define WN_ALREADY_CONNECTED            0x0034
#define WN_DEVICE_ERROR                 0x0035
#define WN_CONNECTION_CLOSED            0x0036

/****** Resource Management *************************************************/

DECLARE_HANDLE(HRSRC);

HRSRC   WINAPI FindResource(HINSTANCE, LPCSTR, LPCSTR);
HGLOBAL WINAPI LoadResource(HINSTANCE, HRSRC);
BOOL    WINAPI FreeResource(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI LockResource(HGLOBAL);
#else
char FAR* WINAPI LockResource(HGLOBAL);
#endif

#define     UnlockResource(h)       GlobalUnlock(h)

DWORD   WINAPI SizeofResource(HINSTANCE, HRSRC);

int     WINAPI AccessResource(HINSTANCE, HRSRC);

HGLOBAL WINAPI AllocResource(HINSTANCE, HRSRC, DWORD);

#ifdef STRICT
typedef HGLOBAL (CALLBACK* RSRCHDLRPROC)(HGLOBAL, HINSTANCE, HRSRC);
#else
typedef FARPROC RSRCHDLRPROC;
#endif

RSRCHDLRPROC WINAPI SetResourceHandler(HINSTANCE, LPCSTR, RSRCHDLRPROC);

#define MAKEINTRESOURCE(i)  ((LPCSTR)MAKELP(0, (i)))

#ifndef NORESOURCE

/* Predefined Resource Types */
#define RT_CURSOR           MAKEINTRESOURCE(1)
#define RT_BITMAP           MAKEINTRESOURCE(2)
#define RT_ICON             MAKEINTRESOURCE(3)
#define RT_MENU             MAKEINTRESOURCE(4)
#define RT_DIALOG           MAKEINTRESOURCE(5)
#define RT_STRING           MAKEINTRESOURCE(6)
#define RT_FONTDIR          MAKEINTRESOURCE(7)
#define RT_FONT             MAKEINTRESOURCE(8)
#define RT_ACCELERATOR      MAKEINTRESOURCE(9)
#define RT_RCDATA           MAKEINTRESOURCE(10)

/* If any new types are added above this point, */  /* ;Internal */
/* DIFFERENCE must be changed.  The GROUP_*     */  /* ;Internal */
/* values minus the non-GROUP values must be    */  /* ;Internal */
/* equal to DIFFERENCE                          */  /* ;Internal */
#define DIFFERENCE          11                      /* ;Internal */
#define RT_GROUP_CURSOR     MAKEINTRESOURCE(12)
#define RT_GROUP_ICON       MAKEINTRESOURCE(14)

#endif  /* NORESOURCE */

#ifdef OEMRESOURCE

/* OEM Resource Ordinal Numbers */
#define OBM_CLOSE           32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#if (WINVER >= 0x030a)
#define OBM_UPARROWI        32737
#define OBM_DNARROWI        32736
#define OBM_RGARROWI        32735
#define OBM_LFARROWI        32734
#endif  /* WINVER >= 0x030a */

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_SIZE            32640
#define OCR_ICON            32641
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_ICOCUR          32647

#define OIC_SAMPLE          32512
#define OIC_HAND            32513
#define OIC_QUES            32514
#define OIC_BANG            32515
#define OIC_NOTE            32516

#endif  /* OEMRESOURCE */

/****** Atom Management *****************************************************/

#define MAKEINTATOM(i)      ((LPCSTR)MAKELP(0, (i)))

#ifndef NOATOM

BOOL    WINAPI InitAtomTable(int);
ATOM    WINAPI AddAtom(LPCSTR);
ATOM    WINAPI DeleteAtom(ATOM);
ATOM    WINAPI FindAtom(LPCSTR);
UINT    WINAPI GetAtomName(ATOM, LPSTR, int);
ATOM    WINAPI GlobalAddAtom(LPCSTR);
ATOM    WINAPI GlobalDeleteAtom(ATOM);
ATOM    WINAPI GlobalFindAtom(LPCSTR);
UINT    WINAPI GlobalGetAtomName(ATOM, LPSTR, int);
HLOCAL  WINAPI GetAtomHandle(ATOM);

#endif  /* NOATOM */

/****** WIN.INI Support *****************************************************/

/* User Profile Routines */
UINT    WINAPI GetProfileInt(LPCSTR, LPCSTR, int);
int     WINAPI GetProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int);
BOOL    WINAPI WriteProfileString(LPCSTR, LPCSTR, LPCSTR);

UINT    WINAPI GetPrivateProfileInt(LPCSTR, LPCSTR, int, LPCSTR);
int     WINAPI GetPrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int, LPCSTR);
BOOL    WINAPI WritePrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPCSTR);

#define WM_WININICHANGE     0x001A

/****** International & Char Translation Support ****************************/

void    WINAPI AnsiToOem(const char _huge*, char _huge*);
void    WINAPI OemToAnsi(const char _huge*, char _huge*);

void    WINAPI AnsiToOemBuff(LPCSTR, LPSTR, UINT);
void    WINAPI OemToAnsiBuff(LPCSTR, LPSTR, UINT);

LPSTR   WINAPI AnsiNext(LPCSTR);
LPSTR   WINAPI AnsiPrev(LPCSTR, LPCSTR);

LPSTR   WINAPI AnsiUpper(LPSTR);
LPSTR   WINAPI AnsiLower(LPSTR);

UINT    WINAPI AnsiUpperBuff(LPSTR, UINT);
UINT    WINAPI AnsiLowerBuff(LPSTR, UINT);

/* Language driver entry point ordinal */    /* ;Internal */
#define ORD_LANGDRIVER    1                  /* ;Internal */

#ifndef  NOLANGUAGE
BOOL    WINAPI IsCharAlpha(char);
BOOL    WINAPI IsCharAlphaNumeric(char);
BOOL    WINAPI IsCharUpper(char);
BOOL    WINAPI IsCharLower(char);
#endif

#ifndef NOLSTRING
int     WINAPI lstrcmp(LPCSTR, LPCSTR);
int     WINAPI lstrcmpi(LPCSTR, LPCSTR);
LPSTR   WINAPI lstrcpy(LPSTR, LPCSTR);
LPSTR   WINAPI lstrcat(LPSTR, LPCSTR);
int     WINAPI lstrlen(LPCSTR);
#if (WINVER >= 0x030a)
LPSTR   WINAPI lstrcpyn(LPSTR, LPCSTR, int);
void    WINAPI hmemcpy(void _huge*, const void _huge*, long);
#endif  /* WINVER >= 0x030a */
#endif  /* NOLSTRING */

#if (WINVER >= 0x030a)
#ifndef NODBCS
BOOL    WINAPI IsDBCSLeadByte(BYTE);
UINT    WINAPI GetSystemDefaultLangID(void);
#endif  /* NODBCS */
#endif  /* WINVER >= 0x030a */

int     WINAPI LoadString(HINSTANCE, UINT, LPSTR, int);

/****** Keyboard Driver Functions *******************************************/

#ifndef NOKEYBOARDINFO

DWORD   WINAPI OemKeyScan(UINT);
UINT    WINAPI VkKeyScan(UINT);
int     WINAPI GetKeyboardType(int);
UINT    WINAPI MapVirtualKey(UINT, UINT);
int     WINAPI GetKBCodePage(void);
int     WINAPI GetKeyNameText(LONG, LPSTR, int);
int     WINAPI ToAscii(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags);

#endif

#endif  /* NOKERNEL */

/****** GDI typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HDC);

#ifndef NOGDI

#ifdef STRICT
typedef const void NEAR* HGDIOBJ;
#else
DECLARE_HANDLE(HGDIOBJ);
#endif

#endif  /* NOGDI */

DECLARE_HANDLE(HBITMAP);
DECLARE_HANDLE(HPEN);
DECLARE_HANDLE(HBRUSH);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HPALETTE);
DECLARE_HANDLE(HFONT);

typedef struct tagRECT
{
    int left;
    int top;
    int right;
    int bottom;
} RECT;
typedef RECT*      PRECT;
typedef RECT NEAR* NPRECT;
typedef RECT FAR*  LPRECT;

typedef struct tagPOINT
{
    int x;
    int y;
} POINT;
typedef POINT*       PPOINT;
typedef POINT NEAR* NPPOINT;
typedef POINT FAR*  LPPOINT;

#if (WINVER >= 0x030a)
typedef struct tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;
typedef SIZE NEAR* NPSIZE;
typedef SIZE FAR*  LPSIZE;
#endif  /* WINVER >= 0x030a */

#define MAKEPOINT(l)        (*((POINT FAR*)&(l)))

#ifndef NOGDI

/****** DC Management *******************************************************/

HDC     WINAPI CreateDC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateIC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateCompatibleDC(HDC);

BOOL    WINAPI DeleteDC(HDC);

DWORD   WINAPI GetDCOrg(HDC);
DWORD   WINAPI SetDCOrg(HDC, int, int);    /* ;Internal */

int     WINAPI SaveDC(HDC);
BOOL    WINAPI RestoreDC(HDC, int);

int     WINAPI SetEnvironment(LPCSTR, const void FAR*, UINT);
int     WINAPI GetEnvironment(LPCSTR, void FAR*, UINT);

int     WINAPI MulDiv(int, int, int);

#if (WINVER >= 0x030a)
/* Drawing bounds accumulation APIs */
UINT    WINAPI SetBoundsRect(HDC hDC, const RECT FAR* lprcBounds, UINT flags);
UINT    WINAPI GetBoundsRect(HDC hDC, RECT FAR* lprcBounds, UINT flags);

#define DCB_RESET       0x0001
#define DCB_ACCUMULATE  0x0002
#define DCB_DIRTY       DCB_ACCUMULATE
#define DCB_SET         (DCB_RESET | DCB_ACCUMULATE)
#define DCB_ENABLE      0x0004
#define DCB_DISABLE     0x0008
#define DCB_WINDOWMGR   0x8000                          /* ;Internal */
                                                        /* ;Internal */
/* Internal SelectBitmap stuff */                       /* ;Internal */
/*HBITMAP WINAPI SelectBitmap(HDC hDC, HBITMAP hbm);*/     /* ;Internal */
#endif  /* WINVER >= 0x030a */

/****** Device Capabilities *************************************************/

int WINAPI GetDeviceCaps(HDC, int);

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0
#define TECHNOLOGY    2
#define HORZSIZE      4
#define VERTSIZE      6
#define HORZRES       8
#define VERTRES       10
#define BITSPIXEL     12
#define PLANES        14
#define NUMBRUSHES    16
#define NUMPENS       18
#define NUMMARKERS    20
#define NUMFONTS      22
#define NUMCOLORS     24
#define PDEVICESIZE   26
#define CURVECAPS     28
#define LINECAPS      30
#define POLYGONALCAPS 32
#define TEXTCAPS      34
#define CLIPCAPS      36
#define RASTERCAPS    38
#define ASPECTX       40
#define ASPECTY       42
#define ASPECTXY      44

#define LOGPIXELSX    88
#define LOGPIXELSY    90

#define SIZEPALETTE  104
#define NUMRESERVED  106
#define COLORRES     108

#ifndef NOGDICAPMASKS

/* GetDeviceCaps() return value masks */

/* TECHNOLOGY */
#define DT_PLOTTER          0
#define DT_RASDISPLAY       1
#define DT_RASPRINTER       2
#define DT_RASCAMERA        3
#define DT_CHARSTREAM       4
#define DT_METAFILE         5
#define DT_DISPFILE         6

/* CURVECAPS */
#define CC_NONE             0x0000
#define CC_CIRCLES          0x0001
#define CC_PIE              0x0002
#define CC_CHORD            0x0004
#define CC_ELLIPSES         0x0008
#define CC_WIDE             0x0010
#define CC_STYLED           0x0020
#define CC_WIDESTYLED       0x0040
#define CC_INTERIORS        0x0080
#define CC_ROUNDRECT        0x0100

/* LINECAPS */
#define LC_NONE             0x0000
#define LC_POLYLINE         0x0002
#define LC_MARKER           0x0004
#define LC_POLYMARKER       0x0008
#define LC_WIDE             0x0010
#define LC_STYLED           0x0020
#define LC_WIDESTYLED       0x0040
#define LC_INTERIORS        0x0080

/* POLYGONALCAPS */
#define PC_NONE             0x0000
#define PC_POLYGON          0x0001
#define PC_RECTANGLE        0x0002
#define PC_WINDPOLYGON      0x0004
#define PC_SCANLINE         0x0008
#define PC_WIDE             0x0010
#define PC_STYLED           0x0020
#define PC_WIDESTYLED       0x0040
#define PC_INTERIORS        0x0080

/* TEXTCAPS */
#define TC_OP_CHARACTER     0x0001
#define TC_OP_STROKE        0x0002
#define TC_CP_STROKE        0x0004
#define TC_CR_90            0x0008
#define TC_CR_ANY           0x0010
#define TC_SF_X_YINDEP      0x0020
#define TC_SA_DOUBLE        0x0040
#define TC_SA_INTEGER       0x0080
#define TC_SA_CONTIN        0x0100
#define TC_EA_DOUBLE        0x0200
#define TC_IA_ABLE          0x0400
#define TC_UA_ABLE          0x0800
#define TC_SO_ABLE          0x1000
#define TC_RA_ABLE          0x2000
#define TC_VA_ABLE          0x4000
#define TC_RESERVED         0x8000

/* CLIPCAPS */
#define CP_NONE             0x0000
#define CP_RECTANGLE        0x0001
#define CP_REGION           0x0002

/* RASTERCAPS */
#define RC_NONE
#define RC_BITBLT           0x0001
#define RC_BANDING          0x0002
#define RC_SCALING          0x0004
#define RC_BITMAP64         0x0008
#define RC_GDI20_OUTPUT     0x0010
#define RC_GDI20_STATE      0x0020
#define RC_SAVEBITMAP       0x0040
#define RC_DI_BITMAP        0x0080
#define RC_PALETTE          0x0100
#define RC_DIBTODEV         0x0200
#define RC_BIGFONT          0x0400
#define RC_STRETCHBLT       0x0800
#define RC_FLOODFILL        0x1000
#define RC_STRETCHDIB       0x2000
#define RC_OP_DX_OUTPUT     0x4000
#define RC_DEVBITS          0x8000

#endif  /* NOGDICAPMASKS */

/****** Coordinate transformation support ***********************************/

int     WINAPI SetMapMode(HDC, int);
int     WINAPI GetMapMode(HDC);

/* Map modes */
#define MM_TEXT             1
#define MM_LOMETRIC         2
#define MM_HIMETRIC         3
#define MM_LOENGLISH        4
#define MM_HIENGLISH        5
#define MM_TWIPS            6
#define MM_ISOTROPIC        7
#define MM_ANISOTROPIC      8

DWORD   WINAPI SetWindowOrg(HDC, int, int);
DWORD   WINAPI GetWindowOrg(HDC);

DWORD   WINAPI SetWindowExt(HDC, int, int);
DWORD   WINAPI GetWindowExt(HDC);

DWORD   WINAPI OffsetWindowOrg(HDC, int, int);
DWORD   WINAPI ScaleWindowExt(HDC, int, int, int, int);

DWORD   WINAPI SetViewportOrg(HDC, int, int);
DWORD   WINAPI GetViewportOrg(HDC);

DWORD   WINAPI SetViewportExt(HDC, int, int);
DWORD   WINAPI GetViewportExt(HDC);

DWORD   WINAPI OffsetViewportOrg(HDC, int, int);
DWORD   WINAPI ScaleViewportExt(HDC, int, int, int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI SetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetWindowOrgEx(HDC, POINT FAR*);

BOOL    WINAPI SetWindowExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetWindowExtEx(HDC, SIZE FAR*);

BOOL    WINAPI OffsetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleWindowExtEx(HDC, int, int, int, int, SIZE FAR*);

BOOL    WINAPI SetViewportExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetViewportExtEx(HDC, SIZE FAR*);

BOOL    WINAPI SetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetViewportOrgEx(HDC, POINT FAR*);

BOOL    WINAPI OffsetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleViewportExtEx(HDC, int, int, int, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DPtoLP(HDC, POINT FAR*, int);
BOOL    WINAPI LPtoDP(HDC, POINT FAR*, int);

int     WINAPI SetRelAbs(HDC, int);   /* ;Internal */
int     WINAPI GetRelAbs(HDC);        /* ;Internal */

/* Coordinate Modes */
#define ABSOLUTE    1
#define RELATIVE    2

/****** Color support *******************************************************/

typedef DWORD COLORREF;

#define RGB(r,g,b)          ((COLORREF)(((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))

#define GetRValue(rgb)      ((BYTE)(rgb))
#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)      ((BYTE)((rgb)>>16))

COLORREF WINAPI GetNearestColor(HDC, COLORREF);

#ifndef NOCOLOR

COLORREF WINAPI GetSysColor(int);
void    WINAPI SetSysColors(int, const int FAR*, const COLORREF FAR*);

#define COLOR_SCROLLBAR            0
#define COLOR_BACKGROUND           1
#define COLOR_ACTIVECAPTION        2
#define COLOR_INACTIVECAPTION      3
#define COLOR_MENU                 4
#define COLOR_WINDOW               5
#define COLOR_WINDOWFRAME          6
#define COLOR_MENUTEXT             7
#define COLOR_WINDOWTEXT           8
#define COLOR_CAPTIONTEXT          9
#define COLOR_ACTIVEBORDER        10
#define COLOR_INACTIVEBORDER      11
#define COLOR_APPWORKSPACE        12
#define COLOR_HIGHLIGHT           13
#define COLOR_HIGHLIGHTTEXT       14
#define COLOR_BTNFACE             15
#define COLOR_BTNSHADOW           16
#define COLOR_GRAYTEXT            17
#define COLOR_BTNTEXT             18
#if (WINVER >= 0x030a)
#define COLOR_INACTIVECAPTIONTEXT 19
#define COLOR_BTNHIGHLIGHT        20
#define COLOR_MAX                 20            /* ;Internal */
#else  /* WINVER >= 0x030a */                   /* ;Internal */
#define COLOR_MAX                 18            /* ;Internal */
#endif  /* WINVER >= 0x030a */
#define COLOR_ENDCOLORS           COLOR_MAX     /* ;Internal */

#endif  /* NOCOLOR */

#define WM_SYSCOLORCHANGE   0x0015

/****** GDI Object Support **************************************************/

#ifndef NOGDIOBJ

HGDIOBJ WINAPI GetStockObject(int);

BOOL    WINAPI IsGDIObject(HGDIOBJ);
#define GDIOBJ_PEN        1    /* ;Internal */
#define GDIOBJ_BRUSH      2    /* ;Internal */
#define GDIOBJ_FONT       3    /* ;Internal */
#define GDIOBJ_PALETTE    4    /* ;Internal */
#define GDIOBJ_BITMAP     5    /* ;Internal */
#define GDIOBJ_RGN        6    /* ;Internal */
#define GDIOBJ_DC         7    /* ;Internal */
#define GDIOBJ_IC         8    /* ;Internal */
#define GDIOBJ_DISABLEDDC 9    /* ;Internal */
#define GDIOBJ_METADC    10    /* ;Internal */
#define GDIOBJ_METAFILE  11    /* ;Internal */

BOOL    WINAPI DeleteObject(HGDIOBJ);
HGDIOBJ WINAPI SelectObject(HDC, HGDIOBJ);
int     WINAPI GetObject(HGDIOBJ, int, void FAR*);
BOOL    WINAPI UnrealizeObject(HGDIOBJ);

#ifdef STRICT
typedef (CALLBACK* GOBJENUMPROC)(void FAR*, LPARAM);
#else
typedef FARPROC GOBJENUMPROC;
#endif

#ifdef STRICT
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPARAM);
#else
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPSTR);
#endif

/* Object types for EnumObjects() */
#define OBJ_PEN             1
#define OBJ_BRUSH           2

/****** Pen support *********************************************************/

/* Logical Pen */
typedef struct tagLOGPEN
{
    UINT    lopnStyle;
    POINT   lopnWidth;
    COLORREF lopnColor;
} LOGPEN;
typedef LOGPEN*       PLOGPEN;
typedef LOGPEN NEAR* NPLOGPEN;
typedef LOGPEN FAR*  LPLOGPEN;

/* Pen Styles */
#define PS_SOLID            0
#define PS_DASH             1
#define PS_DOT              2
#define PS_DASHDOT          3
#define PS_DASHDOTDOT       4
#define PS_NULL             5
#define PS_INSIDEFRAME      6

HPEN    WINAPI CreatePen(int, int, COLORREF);
HPEN    WINAPI CreatePenIndirect(LOGPEN FAR*);

/* Stock pens for use with GetStockObject(); */
#define WHITE_PEN           6
#define BLACK_PEN           7
#define NULL_PEN            8

/****** Brush support *******************************************************/

/* Brush Styles */
#define BS_SOLID            0
#define BS_NULL             1
#define BS_HOLLOW           BS_NULL
#define BS_HATCHED          2
#define BS_PATTERN          3
#define BS_INDEXED          4
#define BS_DIBPATTERN       5

/* Hatch Styles */
#define HS_HORIZONTAL       0
#define HS_VERTICAL         1
#define HS_FDIAGONAL        2
#define HS_BDIAGONAL        3
#define HS_CROSS            4
#define HS_DIAGCROSS        5

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
{
    UINT     lbStyle;
    COLORREF lbColor;
    int      lbHatch;
} LOGBRUSH;
typedef LOGBRUSH*       PLOGBRUSH;
typedef LOGBRUSH NEAR* NPLOGBRUSH;
typedef LOGBRUSH FAR*  LPLOGBRUSH;

typedef LOGBRUSH            PATTERN;
typedef PATTERN*       PPATTERN;
typedef PATTERN NEAR* NPPATTERN;
typedef PATTERN FAR*  LPPATTERN;

HBRUSH  WINAPI CreateSolidBrush(COLORREF);
HBRUSH  WINAPI CreateHatchBrush(int, COLORREF);
HBRUSH  WINAPI CreatePatternBrush(HBITMAP);
HBRUSH  WINAPI CreateDIBPatternBrush(HGLOBAL, UINT);
HBRUSH  WINAPI CreateBrushIndirect(LOGBRUSH FAR*);

/* Stock brushes for use with GetStockObject() */
#define WHITE_BRUSH         0
#define LTGRAY_BRUSH        1
#define GRAY_BRUSH          2
#define DKGRAY_BRUSH        3
#define BLACK_BRUSH         4
#define NULL_BRUSH          5
#define HOLLOW_BRUSH        NULL_BRUSH

DWORD   WINAPI SetBrushOrg(HDC, int, int);
DWORD   WINAPI GetBrushOrg(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetBrushOrgEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

/****** Region support ******************************************************/

HRGN    WINAPI CreateRectRgn(int, int, int, int);
HRGN    WINAPI CreateRectRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgn(int, int, int, int);
HRGN    WINAPI CreatePolygonRgn(const POINT FAR*, int, int);
HRGN    WINAPI CreatePolyPolygonRgn(const POINT FAR*, const int FAR*, int, int);
HRGN    WINAPI CreateRoundRectRgn(int, int, int, int, int, int);

/* Region type flags */
#define ERROR               0
#define NULLREGION          1
#define SIMPLEREGION        2
#define COMPLEXREGION       3

void    WINAPI SetRectRgn(HRGN, int, int, int, int);

int     WINAPI CombineRgn(HRGN, HRGN, HRGN, int);

/* CombineRgn() command values */
#define RGN_AND             1
#define RGN_OR              2
#define RGN_XOR             3
#define RGN_DIFF            4
#define RGN_COPY            5

BOOL    WINAPI EqualRgn(HRGN, HRGN);
int     WINAPI OffsetRgn(HRGN, int, int);

int     WINAPI GetRgnBox(HRGN, RECT FAR*);

BOOL    WINAPI RectInRegion(HRGN, const RECT FAR*);
BOOL    WINAPI PtInRegion(HRGN, int, int);

/****** Color palette Support ************************************************/

#define PALETTERGB(r,g,b)   (0x02000000L | RGB(r,g,b))
#define PALETTEINDEX(i)     ((COLORREF)(0x01000000L | (DWORD)(WORD)(i)))

typedef struct tagPALETTEENTRY
{
    BYTE    peRed;
    BYTE    peGreen;
    BYTE    peBlue;
    BYTE    peFlags;
} PALETTEENTRY;
typedef PALETTEENTRY FAR* LPPALETTEENTRY;

/* Palette entry flags */
#define PC_RESERVED     0x01    /* palette index used for animation */
#define PC_EXPLICIT     0x02    /* palette index is explicit to device */
#define PC_NOCOLLAPSE   0x04    /* do not match color to system palette */

/* Logical Palette */
typedef struct tagLOGPALETTE
{
    WORD    palVersion;
    WORD    palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE;
typedef LOGPALETTE*       PLOGPALETTE;
typedef LOGPALETTE NEAR* NPLOGPALETTE;
typedef LOGPALETTE FAR*  LPLOGPALETTE;

HPALETTE WINAPI CreatePalette(const LOGPALETTE FAR*);

HPALETTE WINAPI SelectPalette(HDC, HPALETTE, BOOL);

UINT    WINAPI RealizePalette(HDC);

int     WINAPI UpdateColors(HDC);
void    WINAPI AnimatePalette(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);

UINT    WINAPI SetPaletteEntries(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);
UINT    WINAPI GetPaletteEntries(HPALETTE, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetNearestPaletteIndex(HPALETTE, COLORREF);

BOOL    WINAPI ResizePalette(HPALETTE, UINT);

UINT    WINAPI GetSystemPaletteEntries(HDC, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetSystemPaletteUse(HDC);
UINT    WINAPI SetSystemPaletteUse(HDC, UINT);

/* Get/SetSystemPaletteUse() values */
#define SYSPAL_STATIC   1
#define SYSPAL_NOSTATIC 2

/* Palette window messages */
#define WM_QUERYNEWPALETTE  0x030F
#define WM_PALETTEISCHANGING 0x0310
#define WM_PALETTECHANGED   0x0311
#define WM_PALETTEGONNACHANGE   WM_PALETTEISCHANGING    /* ;Internal */
#define WM_CHANGEPALETTE        WM_PALETTECHANGED       /* ;Internal */

/****** Clipping support *****************************************************/

int     WINAPI SelectClipRgn(HDC, HRGN);
int     WINAPI GetClipBox(HDC, RECT FAR*);

int     WINAPI IntersectClipRect(HDC, int, int, int, int);
int     WINAPI OffsetClipRgn(HDC, int, int);
int     WINAPI ExcludeClipRect(HDC, int, int, int, int);

BOOL    WINAPI PtVisible(HDC, int, int);
BOOL    WINAPI RectVisible(HDC, const RECT FAR*);

#if (WINVER >= 0x030a)                                  /* ;Internal */
/* DC hook callback function */                         /* ;Internal */
                                                        /* ;Internal */
typedef UINT (CALLBACK* DCHOOKPROC)(HDC hDC, UINT code, DWORD data, DWORD lParam); /* ;Internal */
                                                        /* ;Internal */
BOOL    WINAPI SetDCHook(HDC hDC, DCHOOKPROC lpNewProc, DWORD data);   /* ;Internal */
DWORD   WINAPI GetDCHook(HDC hDC, DCHOOKPROC FAR* lplpproc);          /* ;Internal */
                                                        /* ;Internal */
/* Callback reason code values */                       /* ;Internal */
                                                        /* ;Internal */
#define DCHC_INVALIDVISRGN 0x0001                       /* ;Internal */
#define DCHC_DELETEDC      0x0002                       /* ;Internal */
                                                        /* ;Internal */
UINT WINAPI SetHookFlags(HDC hDC, UINT flags);          /* ;Internal */
                                                        /* ;Internal */
#define DCHF_INVALIDATEVISRGN 0x0001                    /* ;Internal */
#define DCHF_VALIDATEVISRGN   0x0002                    /* ;Internal */
#endif  /* WINVER >= 0x030a */                          /* ;Internal */

/****** General drawing support ********************************************/

DWORD   WINAPI MoveTo(HDC, int, int);
DWORD   WINAPI GetCurrentPosition(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI MoveToEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetCurrentPositionEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI LineTo(HDC, int, int);
BOOL    WINAPI Polyline(HDC, const POINT FAR*, int);

#ifdef STRICT
typedef void (CALLBACK* LINEDDAPROC)(int, int, LPARAM);
#else
typedef FARPROC LINEDDAPROC;
#endif

void    WINAPI LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);

BOOL    WINAPI Rectangle(HDC, int, int, int, int);
BOOL    WINAPI RoundRect(HDC, int, int, int, int, int, int);

BOOL    WINAPI Ellipse(HDC, int, int, int, int);
BOOL    WINAPI Arc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Chord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Pie(HDC, int, int, int, int, int, int, int, int);

BOOL    WINAPI Polygon(HDC, const POINT FAR*, int);
BOOL    WINAPI PolyPolygon(HDC, const POINT FAR*, int FAR*, int);

/* PolyFill Modes */
#define ALTERNATE   1
#define WINDING     2

int     WINAPI SetPolyFillMode(HDC, int);
int     WINAPI GetPolyFillMode(HDC);

BOOL    WINAPI FloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI ExtFloodFill(HDC, int, int, COLORREF, UINT);

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

BOOL    WINAPI FillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI FrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI InvertRgn(HDC, HRGN);
BOOL    WINAPI PaintRgn(HDC, HRGN);

/* Rectangle output routines */
int     WINAPI FillRect(HDC, const RECT FAR*, HBRUSH);
int     WINAPI FrameRect(HDC, const RECT FAR*, HBRUSH);
void    WINAPI InvertRect(HDC, const RECT FAR*);

void    WINAPI DrawFocusRect(HDC, const RECT FAR*);

BOOL    WINAPI FastWindowFrame(HDC, const RECT FAR*, UINT, UINT, DWORD); /* ;Internal */

/****** Text support ********************************************************/

BOOL    WINAPI TextOut(HDC, int, int, LPCSTR, int);
LONG    WINAPI TabbedTextOut(HDC, int, int, LPCSTR, int, int, int FAR*, int);
BOOL    WINAPI ExtTextOut(HDC, int, int, UINT, const RECT FAR*, LPCSTR, UINT, int FAR*);

#define ETO_GRAYED      0x0001
#define ETO_OPAQUE      0x0002
#define ETO_CLIPPED     0x0004

DWORD   WINAPI GetTextExtent(HDC, LPCSTR, int);
DWORD   WINAPI GetTabbedTextExtent(HDC, LPCSTR, int, int, int FAR*);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetTextExtentPoint(HDC, LPCSTR, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

/* DrawText() Format Flags */
#ifndef NODRAWTEXT
#define DT_TOP              0x0000
#define DT_LEFT             0x0000
#define DT_CENTER           0x0001
#define DT_RIGHT            0x0002
#define DT_VCENTER          0x0004
#define DT_BOTTOM           0x0008
#define DT_WORDBREAK        0x0010
#define DT_SINGLELINE       0x0020
#define DT_EXPANDTABS       0x0040
#define DT_TABSTOP          0x0080
#define DT_NOCLIP           0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT         0x0400
#define DT_NOPREFIX         0x0800
#define DT_INTERNAL         0x1000
#define DT_VALID            0x1fff  /* ;Internal: Union of all those above */

int     WINAPI DrawText(HDC, LPCSTR, int, RECT FAR*, UINT);
#endif  /* NODRAWTEXT */

#ifdef STRICT
typedef BOOL (CALLBACK* GRAYSTRINGPROC)(HDC, LPARAM, int);
#else
typedef FARPROC GRAYSTRINGPROC;
#endif

BOOL    WINAPI GrayString(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);

BOOL    WINAPI GetCharWidth(HDC, UINT, UINT, int FAR*);

COLORREF WINAPI SetTextColor(HDC, COLORREF);
COLORREF WINAPI GetTextColor(HDC);

COLORREF WINAPI SetBkColor(HDC, COLORREF);
COLORREF WINAPI GetBkColor(HDC);

int     WINAPI SetBkMode(HDC, int);
int     WINAPI GetBkMode(HDC);

/* Background Modes */
#define TRANSPARENT     1
#define OPAQUE          2
#define TRANSPARENT1    3           /* ;Internal */

UINT    WINAPI SetTextAlign(HDC, UINT);
UINT    WINAPI GetTextAlign(HDC);

/* Text Alignment Options */
#define TA_NOUPDATECP                0x0000
#define TA_UPDATECP                  0x0001
#define TA_LEFT                      0x0000
#define TA_RIGHT                     0x0002
#define TA_CENTER                    0x0006
#define TA_TOP                       0x0000
#define TA_BOTTOM                    0x0008
#define TA_BASELINE                  0x0018

int     WINAPI SetTextCharacterExtra(HDC, int);
int     WINAPI GetTextCharacterExtra(HDC);

int     WINAPI SetTextJustification(HDC, int, int);

/****** Font support ********************************************************/

#ifndef NOGDIOBJ
/* Logical Font */
#define LF_FACESIZE         32
typedef struct tagLOGFONT
{
    int     lfHeight;
    int     lfWidth;
    int     lfEscapement;
    int     lfOrientation;
    int     lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    char    lfFaceName[LF_FACESIZE];
} LOGFONT;
typedef LOGFONT*       PLOGFONT;
typedef LOGFONT NEAR* NPLOGFONT;
typedef LOGFONT FAR*  LPLOGFONT;

/* weight values */
#define FW_DONTCARE         0
#define FW_THIN             100
#define FW_EXTRALIGHT       200
#define FW_LIGHT            300
#define FW_NORMAL           400
#define FW_MEDIUM           500
#define FW_SEMIBOLD         600
#define FW_BOLD             700
#define FW_EXTRABOLD        800
#define FW_HEAVY            900

#define FW_ULTRALIGHT       FW_EXTRALIGHT
#define FW_REGULAR          FW_NORMAL
#define FW_DEMIBOLD         FW_SEMIBOLD
#define FW_ULTRABOLD        FW_EXTRABOLD
#define FW_BLACK            FW_HEAVY

/* CharSet values */
#define ANSI_CHARSET        0
#define DEFAULT_CHARSET     1
#define SYMBOL_CHARSET      2
#define SHIFTJIS_CHARSET    128
#define HANGEUL_CHARSET     129
#define CHINESEBIG5_CHARSET 136
#define GB2312_CHARSET      134
#define OEM_CHARSET         255

/* OutPrecision values */
#define OUT_DEFAULT_PRECIS      0
#define OUT_STRING_PRECIS       1
#define OUT_CHARACTER_PRECIS    2
#define OUT_STROKE_PRECIS       3
#if (WINVER >= 0x030a)
#define OUT_TT_PRECIS           4
#define OUT_DEVICE_PRECIS       5
#define OUT_RASTER_PRECIS       6
#define OUT_TT_ONLY_PRECIS      7
#endif  /* WINVER >= 0x030a */

/* ClipPrecision values */
#define CLIP_DEFAULT_PRECIS     0x00
#define CLIP_CHARACTER_PRECIS   0x01
#define CLIP_STROKE_PRECIS      0x02
#define CLIP_MASK               0x0F
#if (WINVER >= 0x030a)
#define CLIP_LH_ANGLES          0x10
#define CLIP_TT_ALWAYS          0x20
#define CLIP_EMBEDDED           0x80
#endif  /* WINVER >= 0x030a */

/* Quality values */
#define DEFAULT_QUALITY     0
#define DRAFT_QUALITY       1
#define PROOF_QUALITY       2

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

HFONT   WINAPI CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPCSTR);
HFONT   WINAPI CreateFontIndirect(const LOGFONT FAR*);

/* Stock fonts for use with GetStockObject() */
#define OEM_FIXED_FONT      10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT       12
#define SYSTEM_FONT         13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16


DWORD   WINAPI SetMapperFlags(HDC, DWORD);
#define ASPECT_FILTERING             0x00000001L

int     WINAPI AddFontResource(LPCSTR);
BOOL    WINAPI RemoveFontResource(LPCSTR);

#define WM_FONTCHANGE       0x001D

int     WINAPI GetTextFace(HDC, int, LPSTR);

DWORD   WINAPI GetAspectRatioFilter(HDC);
#if (WINVER >= 0x030a)
BOOL    WINAPI GetAspectRatioFilterEx(HDC, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

#endif  /* NOGDIOBJ */

#ifndef NOTEXTMETRIC

typedef struct tagTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
} TEXTMETRIC;
typedef TEXTMETRIC*       PTEXTMETRIC;
typedef TEXTMETRIC NEAR* NPTEXTMETRIC;
typedef TEXTMETRIC FAR*  LPTEXTMETRIC;

/* tmPitchAndFamily values */
#define TMPF_FIXED_PITCH    0x01
#define TMPF_VECTOR         0x02
#define TMPF_DEVICE         0x08
#if (WINVER >= 0x030a)
#define TMPF_TRUETYPE       0x04
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetTextMetrics(HDC, TEXTMETRIC FAR*);

#if (WINVER >= 0x030a)
#ifndef NOSCALABLEFONT

typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, FAR* LPPANOSE;

typedef struct tagOUTLINETEXTMETRIC
{
    UINT    otmSize;
    TEXTMETRIC otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
    int     otmsCharSlopeRise;
    int     otmsCharSlopeRun;
    int     otmItalicAngle;
    UINT    otmEMSquare;
    int     otmAscent;
    int     otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
    int     otmMacAscent;
    int     otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
    int     otmsStrikeoutPosition;
    int     otmsUnderscorePosition;
    int     otmsUnderscoreSize;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRIC, FAR* LPOUTLINETEXTMETRIC;

WORD    WINAPI GetOutlineTextMetrics(HDC, UINT, OUTLINETEXTMETRIC FAR*);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

#ifndef NOGDIOBJ
#if (WINVER >= 0x030a)

/* Structure passed to FONTENUMPROC */
/* NOTE: NEWTEXTMETRIC is the same as TEXTMETRIC plus 4 new fields */
typedef struct tagNEWTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRIC;
typedef NEWTEXTMETRIC*       PNEWTEXTMETRIC;
typedef NEWTEXTMETRIC NEAR* NPNEWTEXTMETRIC;
typedef NEWTEXTMETRIC FAR*  LPNEWTEXTMETRIC;

/* ntmFlags field flags */
#define NTM_REGULAR     0x00000040L
#define NTM_BOLD        0x00000020L
#define NTM_ITALIC      0x00000001L

#define LF_FULLFACESIZE     64

/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONT
{
    LOGFONT elfLogFont;
    char    elfFullName[LF_FULLFACESIZE];
    char    elfStyle[LF_FACESIZE];
} ENUMLOGFONT, FAR* LPENUMLOGFONT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

#ifdef STRICT
#ifndef NOGDIOBJ

typedef int (CALLBACK* OLDFONTENUMPROC)(const LOGFONT FAR*, const TEXTMETRIC FAR*, int, LPARAM);

#if (WINVER >= 0x030a)
typedef int (CALLBACK* FONTENUMPROC)(const ENUMLOGFONT FAR*, const NEWTEXTMETRIC FAR*, int, LPARAM);

int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPARAM);

#else   /* WINVER >= 0x030a */
typedef OLDFONTENUMPROC FONTENUMPROC;
#endif  /* WINVER >= 0x030a) */

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPARAM);
#endif  /* NOGDIOBJ */

#else   /* STRICT */

typedef FARPROC OLDFONTENUMPROC;
typedef FARPROC FONTENUMPROC;

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPSTR);

#if (WINVER >= 0x030a)
int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPSTR);
#endif  /* WINVER >= 0x030a */

#endif  /* !STRICT */

/* EnumFonts font type values */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0X0002
#if (WINVER >= 0x030a)
#define TRUETYPE_FONTTYPE   0x0004
#endif  /* WINVER >= 0x030a */

#endif  /* NOTEXTMETRIC */

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x030a)

DWORD   WINAPI ConvertOutlineFontFile(LPCSTR, LPCSTR, LPCSTR);   /* ;Internal */
DWORD   WINAPI GetFontData(HDC, DWORD, DWORD, void FAR*, DWORD);
BOOL    WINAPI CreateScalableFontResource(UINT, LPCSTR, LPCSTR, LPCSTR);

typedef struct tagGLYPHMETRICS
{
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    int     gmCellIncX;
    int     gmCellIncY;
} GLYPHMETRICS, FAR* LPGLYPHMETRICS;

typedef struct tagFIXED
{
    UINT    fract;
    int     value;
} FIXED, FAR* LPFIXED;

typedef struct tagMAT2
{
    FIXED  eM11;
    FIXED  eM12;
    FIXED  eM21;
    FIXED  eM22;
} MAT2, FAR* LPMAT2;

DWORD   WINAPI GetGlyphOutline(HDC, UINT, UINT, GLYPHMETRICS FAR*, DWORD, void FAR*, const MAT2 FAR*);

/* GetGlyphOutline constants */
#define GGO_METRICS        0
#define GGO_BITMAP         1
#define GGO_NATIVE         2

#define TT_POLYGON_TYPE   24

#define TT_PRIM_LINE       1
#define TT_PRIM_QSPLINE    2

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, FAR* LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    UINT    wType;
    UINT    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, FAR* LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, FAR* LPTTPOLYGONHEADER;

typedef UINT FAR* LPFONTDIR;                               /* ;Internal */
                                                           /* ;Internal */
DWORD   WINAPI EngineMakeFontDir(HDC, LPFONTDIR, LPCSTR);  /* ;Internal */
                                                           /* ;Internal */
typedef struct tagABC
{
    int   abcA;
    UINT  abcB;
    int   abcC;
} ABC;
typedef ABC FAR* LPABC;

BOOL    WINAPI GetCharABCWidths(HDC, UINT, UINT, ABC FAR*);

typedef struct tagKERNINGPAIR
{
    WORD wFirst;
    WORD wSecond;
    int  iKernAmount;
} KERNINGPAIR, FAR* LPKERNINGPAIR;

int     WINAPI GetKerningPairs(HDC, int, KERNINGPAIR FAR*);

typedef struct tagRASTERIZER_STATUS
{
    int   nSize;
    int   wFlags;
    int   nLanguageID;
} RASTERIZER_STATUS;
typedef RASTERIZER_STATUS FAR* LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE    0x0001
#define TT_ENABLED      0x0002

BOOL    WINAPI GetRasterizerCaps(RASTERIZER_STATUS FAR*, int);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

/****** Bitmap support ******************************************************/

#ifndef NOBITMAP
typedef struct tagBITMAP
{
    int     bmType;
    int     bmWidth;
    int     bmHeight;
    int     bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} BITMAP;
typedef BITMAP*       PBITMAP;
typedef BITMAP NEAR* NPBITMAP;
typedef BITMAP FAR*  LPBITMAP;

/* Bitmap Header structures */
typedef struct tagRGBTRIPLE
{
    BYTE    rgbtBlue;
    BYTE    rgbtGreen;
    BYTE    rgbtRed;
} RGBTRIPLE;
typedef RGBTRIPLE FAR* LPRGBTRIPLE;

typedef struct tagRGBQUAD
{
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER
{
    DWORD   bcSize;
    short   bcWidth;
    short   bcHeight;
    WORD    bcPlanes;
    WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER*      PBITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR* LPBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER
{
    DWORD   biSize;
    LONG    biWidth;
    LONG    biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biCompression;
    DWORD   biSizeImage;
    LONG    biXPelsPerMeter;
    LONG    biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
} BITMAPINFOHEADER;
typedef BITMAPINFOHEADER*      PBITMAPINFOHEADER;
typedef BITMAPINFOHEADER FAR* LPBITMAPINFOHEADER;

/* constants for the biCompression field */
#define BI_RGB      0L
#define BI_RLE8     1L
#define BI_RLE4     2L

typedef struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD          bmiColors[1];
} BITMAPINFO;
typedef BITMAPINFO*     PBITMAPINFO;
typedef BITMAPINFO FAR* LPBITMAPINFO;

typedef struct tagBITMAPCOREINFO
{
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE        bmciColors[1];
} BITMAPCOREINFO;
typedef BITMAPCOREINFO*      PBITMAPCOREINFO;
typedef BITMAPCOREINFO FAR* LPBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER
{
    UINT    bfType;
    DWORD   bfSize;
    UINT    bfReserved1;
    UINT    bfReserved2;
    DWORD   bfOffBits;
} BITMAPFILEHEADER;
typedef BITMAPFILEHEADER*      PBITMAPFILEHEADER;
typedef BITMAPFILEHEADER FAR* LPBITMAPFILEHEADER;

/* Pel Array */                             /* ;Internal */
typedef struct tagPELARRAY                  /* ;Internal */
{                                           /* ;Internal */
    int     paXCount;                       /* ;Internal */
    int     paYCount;                       /* ;Internal */
    int     paXExt;                         /* ;Internal */
    int     paYExt;                         /* ;Internal */
    BYTE    paRGBs;                         /* ;Internal */
} PELARRAY;                                 /* ;Internal */
typedef PELARRAY*       PPELARRAY;          /* ;Internal */
typedef PELARRAY NEAR* NPPELARRAY;          /* ;Internal */
typedef PELARRAY FAR*  LPPELARRAY;          /* ;Internal */

HBITMAP WINAPI CreateBitmap(int, int, UINT, UINT, const void FAR*);
HBITMAP WINAPI CreateBitmapIndirect(BITMAP FAR* );
HBITMAP WINAPI CreateCompatibleBitmap(HDC, int, int);
HBITMAP WINAPI CreateDiscardableBitmap(HDC, int, int);
HBITMAP WINAPI CreateDIBitmap(HDC, BITMAPINFOHEADER FAR*, DWORD, const void FAR*, BITMAPINFO FAR*, UINT);

HBITMAP WINAPI LoadBitmap(HINSTANCE, LPCSTR);

/* DIB color table identifiers */
#define DIB_RGB_COLORS  0
#define DIB_PAL_COLORS  1

/* constants for CreateDIBitmap */
#define CBM_INIT        0x00000004L
#endif  /* NOBITMAP */

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1
#define R2_NOTMERGEPEN      2
#define R2_MASKNOTPEN       3
#define R2_NOTCOPYPEN       4
#define R2_MASKPENNOT       5
#define R2_NOT              6
#define R2_XORPEN           7
#define R2_NOTMASKPEN       8
#define R2_MASKPEN          9
#define R2_NOTXORPEN        10
#define R2_NOP              11
#define R2_MERGENOTPEN      12
#define R2_COPYPEN          13
#define R2_MERGEPENNOT      14
#define R2_MERGEPEN         15
#define R2_WHITE            16

/* Ternary raster operations */
#define SRCCOPY             0x00CC0020L
#define SRCPAINT            0x00EE0086L
#define SRCAND              0x008800C6L
#define SRCINVERT           0x00660046L
#define SRCERASE            0x00440328L
#define NOTSRCCOPY          0x00330008L
#define NOTSRCERASE         0x001100A6L
#define MERGECOPY           0x00C000CAL
#define MERGEPAINT          0x00BB0226L
#define PATCOPY             0x00F00021L
#define PATPAINT            0x00FB0A09L
#define PATINVERT           0x005A0049L
#define DSTINVERT           0x00550009L
#define BLACKNESS           0x00000042L
#define WHITENESS           0x00FF0062L

#endif  /* NORASTEROPS */

#ifndef NOBITMAP
BOOL    WINAPI BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);

BOOL    WINAPI PatBlt(HDC, int, int, int, int, DWORD);

BOOL    WINAPI StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI StretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);

COLORREF WINAPI SetPixel(HDC, int, int, COLORREF);
COLORREF WINAPI GetPixel(HDC, int, int);

/* StretchBlt() Modes */
#define BLACKONWHITE    1
#define WHITEONBLACK    2
#define COLORONCOLOR    3

/* new StretchBlt() Modes (simpler names) */
#define STRETCH_ANDSCANS        1
#define STRETCH_ORSCANS         2
#define STRETCH_DELETESCANS     3

int     WINAPI SetStretchBltMode(HDC, int);
int     WINAPI GetStretchBltMode(HDC);

DWORD   WINAPI SetBitmapDimension(HBITMAP, int, int);
DWORD   WINAPI GetBitmapDimension(HBITMAP);
#if (WINVER >= 0x030a)
BOOL    WINAPI SetBitmapDimensionEx(HBITMAP, int, int, SIZE FAR*);
BOOL    WINAPI GetBitmapDimensionEx(HBITMAP, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
int     WINAPI SetROP2(HDC, int);
int     WINAPI GetROP2(HDC);

LONG    WINAPI SetBitmapBits(HBITMAP, DWORD, const void FAR*);
LONG    WINAPI GetBitmapBits(HBITMAP, LONG, void FAR*);

int     WINAPI SetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
int     WINAPI GetDIBits(HDC, HBITMAP, UINT, UINT, void FAR*, BITMAPINFO FAR*, UINT);

int     WINAPI SetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    void FAR*, BITMAPINFO FAR*, UINT);
#endif  /* NOBITMAP */

/****** Metafile support ****************************************************/

#ifndef NOMETAFILE

DECLARE_HANDLE(HMETAFILE);

HDC     WINAPI CreateMetaFile(LPCSTR);
HMETAFILE WINAPI CloseMetaFile(HDC);

HMETAFILE WINAPI GetMetaFile(LPCSTR);
BOOL      WINAPI DeleteMetaFile(HMETAFILE);
HMETAFILE WINAPI CopyMetaFile(HMETAFILE, LPCSTR);

BOOL    WINAPI PlayMetaFile(HDC, HMETAFILE);

HGLOBAL WINAPI GetMetaFileBits(HMETAFILE);
HMETAFILE WINAPI SetMetaFileBits(HGLOBAL);
#if (WINVER >= 0x030a)
HMETAFILE WINAPI SetMetaFileBitsBetter(HGLOBAL);
#endif  /* WINVER >= 0x030a */

/* Clipboard Metafile Picture Structure */
typedef struct tagMETAFILEPICT
{
    int     mm;
    int     xExt;
    int     yExt;
    HMETAFILE hMF;
} METAFILEPICT;
typedef METAFILEPICT FAR* LPMETAFILEPICT;

typedef struct tagMETAHEADER
{
    UINT    mtType;
    UINT    mtHeaderSize;
    UINT    mtVersion;
    DWORD   mtSize;
    UINT    mtNoObjects;
    DWORD   mtMaxRecord;
    UINT    mtNoParameters;
} METAHEADER;

typedef struct tagHANDLETABLE
{
    HGDIOBJ objectHandle[1];
} HANDLETABLE;
typedef HANDLETABLE*      PHANDLETABLE;
typedef HANDLETABLE FAR* LPHANDLETABLE;

typedef struct tagMETARECORD
{
    DWORD   rdSize;
    UINT    rdFunction;
    UINT    rdParm[1];
} METARECORD;
typedef METARECORD*      PMETARECORD;
typedef METARECORD FAR* LPMETARECORD;

/* Metafile Functions */
#define META_SETBKCOLOR              0x0201
#define META_SETBKMODE               0x0102
#define META_SETMAPMODE              0x0103
#define META_SETROP2                 0x0104
#define META_SETRELABS               0x0105
#define META_SETPOLYFILLMODE         0x0106
#define META_SETSTRETCHBLTMODE       0x0107
#define META_SETTEXTCHAREXTRA        0x0108
#define META_SETTEXTCOLOR            0x0209
#define META_SETTEXTJUSTIFICATION    0x020A
#define META_SETWINDOWORG            0x020B
#define META_SETWINDOWEXT            0x020C
#define META_SETVIEWPORTORG          0x020D
#define META_SETVIEWPORTEXT          0x020E
#define META_OFFSETWINDOWORG         0x020F
#define META_SCALEWINDOWEXT          0x0410
#define META_OFFSETVIEWPORTORG       0x0211
#define META_SCALEVIEWPORTEXT        0x0412
#define META_LINETO                  0x0213
#define META_MOVETO                  0x0214
#define META_EXCLUDECLIPRECT         0x0415
#define META_INTERSECTCLIPRECT       0x0416
#define META_ARC                     0x0817
#define META_ELLIPSE                 0x0418
#define META_FLOODFILL               0x0419
#define META_PIE                     0x081A
#define META_RECTANGLE               0x041B
#define META_ROUNDRECT               0x061C
#define META_PATBLT                  0x061D
#define META_SAVEDC                  0x001E
#define META_SETPIXEL                0x041F
#define META_OFFSETCLIPRGN           0x0220
#define META_TEXTOUT                 0x0521
#define META_BITBLT                  0x0922
#define META_STRETCHBLT              0x0B23
#define META_POLYGON                 0x0324
#define META_POLYLINE                0x0325
#define META_ESCAPE                  0x0626
#define META_RESTOREDC               0x0127
#define META_FILLREGION              0x0228
#define META_FRAMEREGION             0x0429
#define META_INVERTREGION            0x012A
#define META_PAINTREGION             0x012B
#define META_SELECTCLIPREGION        0x012C
#define META_SELECTOBJECT            0x012D
#define META_SETTEXTALIGN            0x012E
#define META_DRAWTEXT                0x062F

#define META_CHORD                   0x0830
#define META_SETMAPPERFLAGS          0x0231
#define META_EXTTEXTOUT              0x0a32
#define META_SETDIBTODEV             0x0d33
#define META_SELECTPALETTE           0x0234
#define META_REALIZEPALETTE          0x0035
#define META_ANIMATEPALETTE          0x0436
#define META_SETPALENTRIES           0x0037
#define META_POLYPOLYGON             0x0538
#define META_RESIZEPALETTE           0x0139

#define META_DIBBITBLT               0x0940
#define META_DIBSTRETCHBLT           0x0b41
#define META_DIBCREATEPATTERNBRUSH   0x0142
#define META_STRETCHDIB              0x0f43

#define META_EXTFLOODFILL            0x0548

#define META_RESETDC                 0x014C
#define META_STARTDOC                0x014D
#define META_STARTPAGE               0x004F
#define META_ENDPAGE                 0x0050
#define META_ABORTDOC                0x0052
#define META_ENDDOC                  0x005E

#define META_DELETEOBJECT            0x01f0

#define META_CREATEPALETTE           0x00f7
#define META_CREATEBRUSH             0x00F8
#define META_CREATEPATTERNBRUSH      0x01F9
#define META_CREATEPENINDIRECT       0x02FA
#define META_CREATEFONTINDIRECT      0x02FB
#define META_CREATEBRUSHINDIRECT     0x02FC
#define META_CREATEBITMAPINDIRECT    0x02FD
#define META_CREATEBITMAP            0x06FE
#define META_CREATEREGION            0x06FF

void    WINAPI PlayMetaFileRecord(HDC, HANDLETABLE FAR*, METARECORD FAR*, UINT);

#ifdef STRICT
typedef int (CALLBACK* MFENUMPROC)(HDC, HANDLETABLE FAR*, METARECORD FAR*, int, LPARAM);
#else
typedef FARPROC MFENUMPROC;
#endif

BOOL    WINAPI EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM);

#endif  /* NOMETAFILE */

/****** Printing support ****************************************************/

#ifdef STRICT
typedef BOOL (CALLBACK* ABORTPROC)(HDC, int);
#else
typedef FARPROC ABORTPROC;
#endif

#if (WINVER >= 0x030a)

typedef struct
{
    int     cbSize;
    LPCSTR  lpszDocName;
    LPCSTR  lpszOutput;
}   DOCINFO;
typedef DOCINFO FAR* LPDOCINFO;

int     WINAPI StartDoc(HDC, DOCINFO FAR*);
int     WINAPI StartPage(HDC);
int     WINAPI EndPage(HDC);
int     WINAPI EndDoc(HDC);
int     WINAPI AbortDoc(HDC);

int     WINAPI SetAbortProc(HDC, ABORTPROC);
HANDLE  WINAPI SpoolFile(LPSTR, LPSTR, LPSTR, LPSTR);
BOOL    WINAPI QueryJob(HANDLE, int);           /* ;Internal */
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI QueryAbort(HDC, int);

/* Spooler Error Codes */
#define SP_NOTREPORTED               0x4000
#define SP_ERROR                     (-1)
#define SP_APPABORT                  (-2)
#define SP_USERABORT                 (-3)
#define SP_OUTOFDISK                 (-4)
#define SP_OUTOFMEMORY               (-5)

#define PR_JOBSTATUS                 0x0000

#endif  /* NOGDI  */

/* Spooler status notification message */
#define WM_SPOOLERSTATUS            0x002A

#ifndef NOGDI

/******* GDI Escape support *************************************************/

int     WINAPI Escape(HDC, int, int, LPCSTR, void FAR*);

/* GDI Escapes */
#define NEWFRAME                     1
#define ABORTDOC                     2
#define NEXTBAND                     3
#define SETCOLORTABLE                4
#define GETCOLORTABLE                5
#define FLUSHOUTPUT                  6
#define DRAFTMODE                    7
#define QUERYESCSUPPORT              8
#define SETABORTPROC                 9
#define STARTDOC                     10
#define ENDDOC                       11
#define GETPHYSPAGESIZE              12
#define GETPRINTINGOFFSET            13
#define GETSCALINGFACTOR             14
#define MFCOMMENT                    15
#define GETPENWIDTH                  16
#define SETCOPYCOUNT                 17
#define SELECTPAPERSOURCE            18
#define DEVICEDATA                   19
#define PASSTHROUGH                  19
#define GETTECHNOLGY                 20
#define GETTECHNOLOGY                20
#define SETLINECAP                   21
#define SETLINEJOIN                  22
#define SETMITERLIMIT                23
#define BANDINFO                     24
#define DRAWPATTERNRECT              25
#define GETVECTORPENSIZE             26
#define GETVECTORBRUSHSIZE           27
#define ENABLEDUPLEX                 28
#define GETSETPAPERBINS              29
#define GETSETPRINTORIENT            30
#define ENUMPAPERBINS                31
#define SETDIBSCALING                32
#define EPSPRINTING                  33
#define ENUMPAPERMETRICS             34
#define GETSETPAPERMETRICS           35
#define POSTSCRIPT_DATA              37
#define POSTSCRIPT_IGNORE            38
#define MOUSETRAILS                  39

#define GETEXTENDEDTEXTMETRICS       256
#define GETEXTENTTABLE               257
#define GETPAIRKERNTABLE             258
#define GETTRACKKERNTABLE            259
#define EXTTEXTOUT                   512
#define GETFACENAME                  513
#define ENABLERELATIVEWIDTHS         768
#define ENABLEPAIRKERNING            769
#define SETKERNTRACK                 770
#define SETALLJUSTVALUES             771
#define SETCHARSET                   772

#define STRETCHBLT                   2048

#define GETSETSCREENPARAMS           3072

#define BEGIN_PATH                   4096
#define CLIP_TO_PATH                 4097
#define END_PATH                     4098
#define EXT_DEVICE_CAPS              4099
#define RESTORE_CTM                  4100
#define SAVE_CTM                     4101
#define SET_ARC_DIRECTION            4102
#define SET_BACKGROUND_COLOR         4103
#define SET_POLY_MODE                4104
#define SET_SCREEN_ANGLE             4105
#define SET_SPREAD                   4106
#define TRANSFORM_CTM                4107
#define SET_CLIP_BOX                 4108
#define SET_BOUNDS                   4109

#endif  /* NOGDI */

/****** USER typedefs, structures, and functions *****************************/

#ifdef tagWND                       /* ;Internal */
typedef struct tagWND NEAR* HWND;   /* ;Internal */
#else                               /* ;Internal */
DECLARE_HANDLE(HWND);
#endif                              /* ;Internal */

#ifndef NOUSER

DECLARE_HANDLE(HMENU);

DECLARE_HANDLE(HICON);
typedef HICON HCURSOR;      /* HICONs & HCURSORs are polymorphic */

/****** System Metrics *******************************************************/

#ifndef NOSYSMETRICS

int WINAPI GetSystemMetrics(int);

/* GetSystemMetrics() codes */
#define SM_CXSCREEN          0
#define SM_CYSCREEN          1
#define SM_CXVSCROLL         2
#define SM_CYHSCROLL         3
#define SM_CYCAPTION         4
#define SM_CXBORDER          5
#define SM_CYBORDER          6
#define SM_CXDLGFRAME        7
#define SM_CYDLGFRAME        8
#define SM_CYVTHUMB          9
#define SM_CXHTHUMB          10
#define SM_CXICON            11
#define SM_CYICON            12
#define SM_CXCURSOR          13
#define SM_CYCURSOR          14
#define SM_CYMENU            15
#define SM_CXFULLSCREEN      16
#define SM_CYFULLSCREEN      17
#define SM_CYKANJIWINDOW     18
#define SM_MOUSEPRESENT      19
#define SM_CYVSCROLL         20
#define SM_CXHSCROLL         21
#define SM_DEBUG             22
#define SM_SWAPBUTTON        23
#define SM_RESERVED1         24
#define SM_RESERVED2         25
#define SM_RESERVED3         26
#define SM_RESERVED4         27
#define SM_CXMIN             28
#define SM_CYMIN             29
#define SM_CXSIZE            30
#define SM_CYSIZE            31
#define SM_CXFRAME           32
#define SM_CYFRAME           33
#define SM_CXMINTRACK        34
#define SM_CYMINTRACK        35

#if (WINVER >= 0x030a)
#define SM_CXDOUBLECLK       36
#define SM_CYDOUBLECLK       37
#define SM_CXICONSPACING     38
#define SM_CYICONSPACING     39
#define SM_MENUDROPALIGNMENT 40
#define SM_PENWINDOWS        41
#define SM_DBCSENABLED       42
#endif  /* WINVER >= 0x030a */

#define SM_MAX               42         /* ;Internal */
#define SM_CMETRICS          43

#endif  /* NOSYSMETRICS */

UINT    WINAPI GetDoubleClickTime(void);
void    WINAPI SetDoubleClickTime(UINT);

#define WM_DEVMODECHANGE    0x001B
#define WM_TIMECHANGE       0x001E
#define WM_FILESYSCHANGE    0x0034              /* ;Internal */

/****** System Parameters support ********************************************/

#if (WINVER >= 0x030a)
#ifndef NOSYSTEMPARAMSINFO

BOOL    WINAPI SystemParametersInfo(UINT, UINT, VOID FAR*, UINT);

#define SPI_GETBEEP                 1
#define SPI_SETBEEP                 2
#define SPI_GETMOUSE                3
#define SPI_SETMOUSE                4
#define SPI_GETBORDER               5
#define SPI_SETBORDER               6
#define SPI_TIMEOUTS                7   /* ;Internal */
#define SPI_KANJIMENU               8   /* ;Internal */
#define SPI_GETKEYBOARDSPEED        10
#define SPI_SETKEYBOARDSPEED        11
#define SPI_LANGDRIVER              12
#define SPI_ICONHORIZONTALSPACING   13
#define SPI_GETSCREENSAVETIMEOUT    14
#define SPI_SETSCREENSAVETIMEOUT    15
#define SPI_GETSCREENSAVEACTIVE     16
#define SPI_SETSCREENSAVEACTIVE     17
#define SPI_GETGRIDGRANULARITY      18
#define SPI_SETGRIDGRANULARITY      19
#define SPI_SETDESKWALLPAPER        20
#define SPI_SETDESKPATTERN          21
#define SPI_GETKEYBOARDDELAY        22
#define SPI_SETKEYBOARDDELAY        23
#define SPI_ICONVERTICALSPACING     24
#define SPI_GETICONTITLEWRAP        25
#define SPI_SETICONTITLEWRAP        26
#define SPI_GETMENUDROPALIGNMENT    27
#define SPI_SETMENUDROPALIGNMENT    28
#define SPI_SETDOUBLECLKWIDTH       29
#define SPI_SETDOUBLECLKHEIGHT      30
#define SPI_GETICONTITLELOGFONT     31
#define SPI_SETDOUBLECLICKTIME      32
#define SPI_SETMOUSEBUTTONSWAP      33
#define SPI_SETICONTITLELOGFONT     34
#define SPI_GETFASTTASKSWITCH       35
#define SPI_SETFASTTASKSWITCH       36
#define SPI_MAX                     36   /* ;Internal */

/* SystemParametersInfo flags */
#define SPIF_UPDATEINIFILE          0x0001
#define SPIF_SENDWININICHANGE       0x0002
#define SPIF_VALID                  0x0003  /* ;Internal */

#endif  /* NOSYSTEMPARAMSINFO  */
#endif  /* WINVER >= 0x030a */

/****** Rectangle support ****************************************************/

void    WINAPI SetRect(RECT FAR*, int, int, int, int);
void    WINAPI SetRectEmpty(RECT FAR*);

void    WINAPI CopyRect(RECT FAR*, const RECT FAR*);

BOOL    WINAPI IsRectEmpty(const RECT FAR*);

BOOL    WINAPI EqualRect(const RECT FAR*, const RECT FAR*);

BOOL    WINAPI IntersectRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI UnionRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI SubtractRect(RECT FAR*, const RECT FAR*, const RECT FAR*);

void    WINAPI OffsetRect(RECT FAR*, int, int);
void    WINAPI InflateRect(RECT FAR*, int, int);

BOOL    WINAPI PtInRect(const RECT FAR*, POINT);

/****** Window message support ***********************************************/

UINT WINAPI RegisterWindowMessage(LPCSTR);

#define WM_NULL             0x0000

/* NOTE: All messages below 0x0400 are RESERVED by Windows */
#define WM_USER             0x0400

#ifndef NOMSG

/* Queued message structure */
typedef struct tagMSG
{
    HWND        hwnd;
    UINT        message;
    WPARAM      wParam;
    LPARAM      lParam;
    DWORD       time;
    POINT       pt;
} MSG;
typedef MSG* PMSG;
typedef MSG NEAR* NPMSG;
typedef MSG FAR* LPMSG;

BOOL    WINAPI GetMessage(MSG FAR*, HWND, UINT, UINT);
BOOL    WINAPI PeekMessage(MSG FAR*, HWND, UINT, UINT, UINT);

/* PeekMessage() options */
#define PM_NOREMOVE     0x0000
#define PM_REMOVE       0x0001
#define PM_NOYIELD      0x0002
#define PM_VALID        0x0003       /* ;Internal */

void    WINAPI WaitMessage(void);

DWORD   WINAPI GetMessagePos(void);
LONG    WINAPI GetMessageTime(void);
#if (WINVER >= 0x030a)
LPARAM  WINAPI GetMessageExtraInfo(void);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI TranslateMessage(const MSG FAR*);
LONG    WINAPI DispatchMessage(const MSG FAR*);

BOOL    WINAPI SetMessageQueue(int);

BOOL    WINAPI GetInputState(void);

#if (WINVER >= 0x030a)
DWORD   WINAPI GetQueueStatus(UINT flags);

/* GetQueueStatus flags */
#define QS_KEY          0x0001
#define QS_MOUSEMOVE    0x0002
#define QS_MOUSEBUTTON  0x0004
#define QS_MOUSE        (QS_MOUSEMOVE | QS_MOUSEBUTTON)
#define QS_POSTMESSAGE  0x0008
#define QS_TIMER        0x0010
#define QS_PAINT        0x0020
#define QS_SENDMESSAGE  0x0040

#define QS_ALLINPUT     0x007f
#define QS_VALID        0x007f      /* ;Internal */
#endif  /* WINVER >= 0x030a */

#endif  /* NOMSG */

BOOL    WINAPI PostMessage(HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI SendMessage(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG

BOOL    WINAPI PostAppMessage(HTASK, UINT, WPARAM, LPARAM);

void    WINAPI ReplyMessage(LRESULT);
BOOL    WINAPI InSendMessage(void);

/* Special HWND value for use with PostMessage() and SendMessage() */
#define HWND_BROADCAST  ((HWND)0xffff)

BOOL WINAPI CallMsgFilter(MSG FAR*, int);

#define WH_GETMESSAGE       3

#define WH_CALLWNDPROC      4

#define WH_MSGFILTER        (-1)
#define WH_SYSMSGFILTER     6

/* CallMsgFilter() and WH_SYS/MSGFILTER context codes */
#define MSGF_DIALOGBOX           0
#define MSGF_MESSAGEBOX          1          /* ;Internal */
#define MSGF_MENU                2
#define MSGF_MOVE                3
#define MSGF_SIZE                4
#define MSGF_SCROLLBAR           5
#define MSGF_NEXTWINDOW          6
#define MSGF_CBTHOSEBAGSUSEDTHIS 7          /* ;Internal */
#define MSGF_MAINLOOP            8
#define MSGF_USER                4096
#endif  /* NOMSG */

/* Standard window messages */
/* PenWindows specific messages */
#define WM_PENWINFIRST      0x0380
#define WM_PENWINLAST       0x038F

/* Coalescing messages */
#define WM_COALESCE_FIRST   0x0390
#define WM_COALESCE_LAST    0x039F

/* Reserved message ranges */                   /* ;Internal */
#define WM_KANJIFIRST       0x0280  /* JAPAN */ /* ;Internal */
#define WM_KANJILAST        0x029F  /* JAPAN */ /* ;Internal */
#define WM_HANGEULFIRST     0x0280  /* KOREA */ /* ;Internal */
#define WM_HANGEULLAST      0x029F  /* KOREA */ /* ;Internal */
                                                /* ;Internal */
                                                /* ;Internal */
#define WM_INTERNAL_COALESCE_FIRST  0x0390      /* ;Internal */
                                                /* ;Internal */
                                                /* ;Internal */
/* The following message range reserved  */     /* ;Internal */
/* for multi-media                       */     /* ;Internal */
#define WM_MM_RESERVED_FIRST 0x03A0             /* ;Internal */
#define WM_MM_RESERVED_LAST  0x03DF             /* ;Internal */
#define WM_INTERNAL_COALESCE_LAST  0x03b0       /* ;Internal */
                                                /* ;Internal */
#define WM_INTERNAL_DDE_FIRST 0x03E0            /* ;Internal */
#define WM_INTERNAL_DDE_LAST  0x03EF            /* ;Internal */
                                                /* ;Internal */
/* The following message range reserved  */     /* ;Internal */
/* for CBT                               */     /* ;Internal */
#define WM_CBT_RESERVED_FIRST 0x03F0            /* ;Internal */
#define WM_CBT_RESERVED_LAST  0x03FF            /* ;Internal */

#if (WINVER >= 0x030a)
/****** Power management ****************************************************/
#define WM_POWER            0x0048

/* wParam for WM_POWER window message and DRV_POWER driver notification */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3
#endif  /* WINVER >= 0x030a */

/****** Application termination *********************************************/

#define WM_QUERYENDSESSION  0x0011
#define WM_ENDSESSION       0x0016

#define WM_QUIT             0x0012

void    WINAPI PostQuitMessage(int);

#define WM_SYSTEMERROR      0x0017

/****** Window class management *********************************************/

typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

typedef struct tagWNDCLASS
{
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
} WNDCLASS;
typedef WNDCLASS* PWNDCLASS;
typedef WNDCLASS NEAR* NPWNDCLASS;
typedef WNDCLASS FAR* LPWNDCLASS;

ATOM    WINAPI RegisterClass(const WNDCLASS FAR*);
BOOL    WINAPI UnregisterClass(LPCSTR, HINSTANCE);

BOOL    WINAPI GetClassInfo(HINSTANCE, LPCSTR, WNDCLASS FAR*);
int     WINAPI GetClassName(HWND, LPSTR, int);

#ifndef NOWINSTYLES

/* Class styles */
#define CS_VREDRAW          0x0001
#define CS_HREDRAW          0x0002

#define CS_OWNDC            0x0020
#define CS_CLASSDC          0x0040
#define CS_PARENTDC         0x0080

#define CS_SAVEBITS         0x0800

#define CS_DBLCLKS          0x0008

#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000

#define CS_NOCLOSE          0x0200

#define CS_KEYCVTWINDOW     0x0004
#define CS_NOKEYCVT         0x0100

#define CS_GLOBALCLASS      0x4000
#define CS_VALID            0x7fef  /* ;Internal */
#endif  /* NOWINSTYLES */

#ifndef NOWINOFFSETS

WORD    WINAPI GetClassWord(HWND, int);
WORD    WINAPI SetClassWord(HWND, int, WORD);
LONG    WINAPI GetClassLong(HWND, int);
LONG    WINAPI SetClassLong(HWND, int, LONG);

/* Class field offsets for GetClassLong() and GetClassWord() */
#define GCL_MENUNAME        (-8)
#define GCW_HBRBACKGROUND   (-10)
#define GCW_HCURSOR         (-12)
#define GCW_HICON           (-14)
#define GCW_HMODULE         (-16)
#define GCW_CBWNDEXTRA      (-18)
#define GCW_CBCLSEXTRA      (-20)
#define GCL_WNDPROC         (-24)
#define GCW_STYLE           (-26)

#if (WINVER >= 0x030a)
#define GCW_ATOM            (-32)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINOFFSETS */

/****** Window creation/destroy *********************************************/

/* Window Styles */
#ifndef NOWINSTYLES

/* Basic window types */
#define WS_OVERLAPPED       0x00000000L
#define WS_POPUP            0x80000000L
#define WS_CHILD            0x40000000L

/* Clipping styles */
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L

/* Generic window states */
#define WS_VISIBLE          0x10000000L
#define WS_DISABLED         0x08000000L

/* Main window states */
#define WS_MINIMIZE         0x20000000L
#define WS_MAXIMIZE         0x01000000L

/* Main window styles */
#define WS_CAPTION          0x00C00000L     /* WS_BORDER | WS_DLGFRAME  */
#define WS_BORDER           0x00800000L
#define WS_DLGFRAME         0x00400000L
#define WS_VSCROLL          0x00200000L
#define WS_HSCROLL          0x00100000L
#define WS_SYSMENU          0x00080000L
#define WS_THICKFRAME       0x00040000L
#define WS_MINIMIZEBOX      0x00020000L
#define WS_MAXIMIZEBOX      0x00010000L

/* Control window styles */
#define WS_GROUP            0x00020000L
#define WS_TABSTOP          0x00010000L

/* Common Window Styles */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW      (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW      (WS_CHILD)

/* Extended Window Styles */
#define WS_EX_DLGMODALFRAME  0x00000001L
#define WS_EX_DRAGOBJECT     0x00000002L                /* ;Internal */
#define WS_EX_NOPARENTNOTIFY 0x00000004L

#if (WINVER >= 0x030a)
#define WS_EX_TOPMOST        0x00000008L
#define WS_EX_ACCEPTFILES    0x00000010L
#define WS_EX_TRANSPARENT    0x00000020L
#define WS_EX_VALID          0x0000003fL    /* ;Internal */
#endif  /* WINVER >= 0x030a */

/* Obsolete style names */
#define WS_TILED            WS_OVERLAPPED
#define WS_ICONIC           WS_MINIMIZE
#define WS_SIZEBOX          WS_THICKFRAME
#define WS_TILEDWINDOW      WS_OVERLAPPEDWINDOW

#define WS_VALID            0xffff0000L     /* ;Internal */

#endif  /* NOWINSTYLES */

/* Special value for CreateWindow, et al. */
#define HWND_DESKTOP        ((HWND)0)

BOOL    WINAPI IsWindow(HWND);

HWND    WINAPI CreateWindowEx(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);
HWND    WINAPI CreateWindow(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);

#define WM_CREATE           0x0001
#define WM_NCCREATE         0x0081

/* WM_CREATE/WM_NCCREATE lParam struct */
typedef struct tagCREATESTRUCT
{
    void FAR* lpCreateParams;
    HINSTANCE hInstance;
    HMENU     hMenu;
    HWND      hwndParent;
    int       cy;
    int       cx;
    int       y;
    int       x;
    LONG      style;
    LPCSTR    lpszName;
    LPCSTR    lpszClass;
    DWORD     dwExStyle;
} CREATESTRUCT;
typedef CREATESTRUCT FAR* LPCREATESTRUCT;

BOOL    WINAPI DestroyWindow(HWND);

#define WM_DESTROY          0x0002
#define WM_NCDESTROY        0x0082

/* Basic window attributes */

HTASK   WINAPI GetWindowTask(HWND);

BOOL    WINAPI IsChild(HWND, HWND);

HWND    WINAPI GetParent(HWND);
HWND    WINAPI SetParent(HWND, HWND);

BOOL    WINAPI IsWindowVisible(HWND);

BOOL    WINAPI ShowWindow(HWND, int);

#define WM_SETVISIBLE       0x0009              /* ;Internal */

#ifndef NOSHOWWINDOW

#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9
#define SW_MAX              9   /* ;Internal */

/* Obsolete ShowWindow() command names */
#define HIDE_WINDOW         0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

#define WM_SHOWWINDOW       0x0018

/* WM_SHOWWINDOW wParam codes */
#define SW_PARENTCLOSING    1
#define SW_OTHERMAXIMIZED   2
#define SW_PARENTOPENING    3
#define SW_OTHERRESTORED    4

/* Obsolete constant names */
#define SW_OTHERZOOM        SW_OTHERMAXIMIZED
#define SW_OTHERUNZOOM      SW_OTHERRESTORED
#endif  /* NOSHOWWINDOW */

#define WM_SETREDRAW        0x000B

/* Enabled state */
BOOL    WINAPI EnableWindow(HWND,BOOL);
BOOL    WINAPI IsWindowEnabled(HWND);

#define WM_ENABLE           0x000A

/* Window text */
void    WINAPI SetWindowText(HWND, LPCSTR);
int     WINAPI GetWindowText(HWND, LPSTR, int);
int     WINAPI GetWindowTextLength(HWND);

#define WM_SETTEXT          0x000C
#define WM_GETTEXT          0x000D
#define WM_GETTEXTLENGTH    0x000E

/* Window words */
WORD    WINAPI GetWindowWord(HWND, int);
WORD    WINAPI SetWindowWord(HWND, int, WORD);
LONG    WINAPI GetWindowLong(HWND, int);
LONG    WINAPI SetWindowLong(HWND, int, LONG);

/* Window field offsets for GetWindowLong() and GetWindowWord() */
#ifndef NOWINOFFSETS
#define GWL_WNDPROC         (-4)
#define GWW_HINSTANCE       (-6)
#define GWW_HWNDPARENT      (-8)
#define GWW_ID              (-12)
#define GWL_STYLE           (-16)
#define GWL_EXSTYLE         (-20)
#endif  /* NOWINOFFSETS */

/****** Window size, position, Z-order, and visibility **********************/

#define CW_USEDEFAULT       ((int)0x8000)

void    WINAPI GetClientRect(HWND, RECT FAR*);
void    WINAPI GetWindowRect(HWND, RECT FAR*);


#if (WINVER >= 0x030a)
typedef struct tagWINDOWPLACEMENT
{
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT     *PWINDOWPLACEMENT;
typedef WINDOWPLACEMENT FAR* LPWINDOWPLACEMENT;

#define WPF_SETMINPOSITION      0x0001
#define WPF_RESTORETOMAXIMIZED  0x0002
#define WPF_VALID               0x0003  /* ;Internal */

BOOL    WINAPI GetWindowPlacement(HWND, WINDOWPLACEMENT FAR*);
BOOL    WINAPI SetWindowPlacement(HWND, const WINDOWPLACEMENT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI SetWindowPos(HWND, HWND, int, int, int, int, UINT);

/* SetWindowPos() and WINDOWPOS flags */
#define SWP_NOSIZE          0x0001
#define SWP_NOMOVE          0x0002
#define SWP_NOZORDER        0x0004
#define SWP_NOREDRAW        0x0008
#define SWP_NOACTIVATE      0x0010
#define SWP_FRAMECHANGED    0x0020  /* The frame changed: send WM_NCCALCSIZE */
#define SWP_SHOWWINDOW      0x0040
#define SWP_HIDEWINDOW      0x0080
#define SWP_NOCOPYBITS      0x0100
#define SWP_NOOWNERZORDER   0x0200  /* Don't do owner Z ordering */

#define SWP_DRAWFRAME       SWP_FRAMECHANGED
#define SWP_NOREPOSITION    SWP_NOOWNERZORDER

#define SWP_NOCLIENTSIZE    0x0800  /* Client didn't resize */  /* ;Internal */
#define SWP_NOCLIENTMOVE    0x1000  /* Client didn't move   */  /* ;Internal */
#define SWP_NOSENDCHANGING  0x0400
#define SWP_DEFERERASE      0x2000
#define SWP_DEFERDRAWING    SWP_DEFERERASE /* Don't do any drawing or erasing */ /* ;Internal */
                                                                      /* ;Internal */
#define SWP_CHANGEMASK      (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | /* ;Internal */ \
                            SWP_FRAMECHANGED |                        /* ;Internal */ \
                            SWP_SHOWWINDOW | SWP_HIDEWINDOW |         /* ;Internal */ \
                            SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)      /* ;Internal */
                                                                      /* ;Internal */
#define SWP_NOCHANGE        (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | /* ;Internal */ \
                            SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)      /* ;Internal */
#define SWP_VALID           0x27ff  /* ;Internal */

/* SetWindowPos() hwndInsertAfter field values */
#define HWND_TOP            ((HWND)0)
#define HWND_BOTTOM         ((HWND)1)
#define HWND_TOPMOST        ((HWND)-1)
#define HWND_NOTOPMOST      ((HWND)-2)
#define HWND_GROUPTOTOP     HWND_TOPMOST        /* ;Internal */

#ifndef NODEFERWINDOWPOS

DECLARE_HANDLE(HDWP);

HDWP    WINAPI BeginDeferWindowPos(int);
HDWP    WINAPI DeferWindowPos(HDWP, HWND, HWND, int, int, int, int, UINT);
BOOL    WINAPI EndDeferWindowPos(HDWP);

#endif  /* NODEFERWINDOWPOS */

BOOL    WINAPI MoveWindow(HWND, int, int, int, int, BOOL);
BOOL    WINAPI BringWindowToTop(HWND);

#if (WINVER >= 0x030a)

#define WM_WINDOWPOSCHANGING 0x0046
#define WM_WINDOWPOSCHANGED 0x0047

/* WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam */
typedef struct tagWINDOWPOS
{
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS;
typedef WINDOWPOS FAR* LPWINDOWPOS;
#endif  /* WINVER >= 0x030a */

#define WM_MOVE             0x0003
#define WM_SIZEWAIT         0x0004      /* ;Internal */
#define WM_SIZE             0x0005

/* WM_SIZE message wParam values */
#define SIZE_RESTORED       0
#define SIZE_MINIMIZED      1
#define SIZE_MAXIMIZED      2
#define SIZE_MAXSHOW        3
#define SIZE_MAXHIDE        4

/* Obsolete constant names */
#define SIZENORMAL          SIZE_RESTORED
#define SIZEICONIC          SIZE_MINIMIZED
#define SIZEFULLSCREEN      SIZE_MAXIMIZED
#define SIZEZOOMSHOW        SIZE_MAXSHOW
#define SIZEZOOMHIDE        SIZE_MAXHIDE

/****** Window proc implementation & subclassing support *********************/

LRESULT WINAPI DefWindowProc(HWND, UINT, WPARAM, LPARAM);

#ifdef STRICT
LRESULT WINAPI CallWindowProc(WNDPROC, HWND, UINT, WPARAM, LPARAM);
#else
LRESULT WINAPI CallWindowProc(FARPROC, HWND, UINT, WPARAM, LPARAM);
#endif

/****** Main window support **************************************************/

void    WINAPI AdjustWindowRect(RECT FAR*, DWORD, BOOL);
void    WINAPI AdjustWindowRectEx(RECT FAR*, DWORD, BOOL, DWORD);

#define WM_QUERYOPEN        0x0013
#define WM_CLOSE            0x0010

/* Struct pointed to by WM_GETMINMAXINFO lParam */
typedef struct tagMINMAXINFO
{
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO;
#define WM_GETMINMAXINFO    0x0024

#define WM_ENTERSIZEMOVE    0x0231              /* ;Internal */
#define WM_EXITSIZEMOVE     0x0232              /* ;Internal */
#define WM_ISACTIVEICON     0x0035              /* ;Internal */
#define WM_UNUSED0036       0x0036              /* ;Internal */
#define WM_TESTING          0x0040              /* ;Internal */

BOOL    WINAPI FlashWindow(HWND, BOOL);

void    WINAPI ShowOwnedPopups(HWND, BOOL);

/* Obsolete functions */
BOOL    WINAPI OpenIcon(HWND);
void    WINAPI CloseWindow(HWND);
BOOL    WINAPI AnyPopup(void);
BOOL    WINAPI IsIconic(HWND);
BOOL    WINAPI IsZoomed(HWND);

/****** Window coordinate mapping and hit-testing ***************************/

void    WINAPI ClientToScreen(HWND, POINT FAR*);
void    WINAPI ScreenToClient(HWND, POINT FAR*);

#if (WINVER >= 0x030a)
void    WINAPI MapWindowPoints(HWND hwndFrom, HWND hwndTo, POINT FAR* lppt, UINT cpt);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI WindowFromPoint(POINT);
HWND    WINAPI ChildWindowFromPoint(HWND, POINT);

/****** Window query and enumeration ****************************************/

HWND    WINAPI GetDesktopWindow(void);

HWND    WINAPI FindWindow(LPCSTR, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);
#else
typedef FARPROC WNDENUMPROC;
#endif

BOOL    WINAPI EnumWindows(WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumChildWindows(HWND, WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumTaskWindows(HTASK, WNDENUMPROC, LPARAM);

HWND    WINAPI GetTopWindow(HWND);

HWND    WINAPI GetWindow(HWND, UINT);
HWND    WINAPI GetNextWindow(HWND, UINT);

/* GetWindow() constants */
#define GW_HWNDFIRST    0
#define GW_HWNDLAST     1
#define GW_HWNDNEXT     2
#define GW_HWNDPREV     3
#define GW_OWNER        4
#define GW_CHILD        5
#define GW_MAX          5       /* ;Internal */

HWND    WINAPI GetNextQueueWindow(HWND, int); /* ;Internal */

/****** Window property support *********************************************/

BOOL    WINAPI SetProp(HWND, LPCSTR, HANDLE);
HANDLE  WINAPI GetProp(HWND, LPCSTR);
HANDLE  WINAPI RemoveProp(HWND, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* PROPENUMPROC)(HWND, LPCSTR, HANDLE);
#else
typedef FARPROC PROPENUMPROC;
#endif

int     WINAPI EnumProps(HWND, PROPENUMPROC);

/****** Window drawing support **********************************************/

HDC     WINAPI GetDC(HWND);
int     WINAPI ReleaseDC(HWND, HDC);

HDC     WINAPI GetWindowDC(HWND);

#if (WINVER >= 0x030a)
HDC     WINAPI GetDCEx(register HWND hwnd, HRGN hrgnClip, DWORD flags);

#define DCX_WINDOW          0x00000001L
#define DCX_CACHE           0x00000002L
#define DCX_NORESETATTRS    0x00000004L /* ;Internal */
#define DCX_CLIPCHILDREN    0x00000008L
#define DCX_CLIPSIBLINGS    0x00000010L
#define DCX_PARENTCLIP      0x00000020L

#define DCX_EXCLUDERGN      0x00000040L
#define DCX_INTERSECTRGN    0x00000080L

#define DCX_EXCLUDEUPDATE   0x00000100L /* ;Internal */
#define DCX_INTERSECTUPDATE 0x00000200L /* ;Internal */

#define DCX_LOCKWINDOWUPDATE 0x00000400L

#define DCX_INVALID         0x00000800L /* ;Internal */
#define DCX_INUSE           0x00001000L /* ;Internal */
#define DCX_SAVEDRGNINVALID 0x00002000L /* ;Internal */

#define DCX_USESTYLE        0x00010000L
#define DCX_NEEDFONT        0x00020000L /* ;Internal */
#define DCX_NODELETERGN     0x00040000L /* ;Internal */
#define DCX_NOCLIPCHILDREN  0x00080000L /* ;Internal */
#define DCX_NORECOMPUTE     0x00100000L /* ;Internal */
#define DCX_VALIDATE        0x00200000L /* ;Internal */

#define DCX_MATCHMASK           (DCX_WINDOW | DCX_CACHE |                 /* ;Internal */ \
                                 DCX_CLIPCHILDREN | DCX_CLIPSIBLINGS |    /* ;Internal */ \
                                 DCX_LOCKWINDOWUPDATE                     /* ;Internal */ \
                                )                                         /* ;Internal */
#define DCX_VALID           0x000104fbL /* ;Internal */
#endif  /* WINVER >= 0x030a */

/****** Window repainting ***************************************************/

#define WM_PAINT            0x000F
#define WM_ERASEBKGND       0x0014
#define WM_PAINTICON        0x0026              /* ;Internal */
#define WM_ICONERASEBKGND   0x0027
#define WM_SYNCPAINT        0x0088              /* ;Internal */
#define WM_SYNCTASK         0x0089              /* ;Internal */

/* BeginPaint() return structure */
typedef struct tagPAINTSTRUCT
{
    HDC         hdc;
    BOOL        fErase;
    RECT        rcPaint;
    BOOL        fRestore;
    BOOL        fIncUpdate;
    BYTE        rgbReserved[16];
} PAINTSTRUCT;
typedef PAINTSTRUCT* PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR* NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR* LPPAINTSTRUCT;

HDC     WINAPI BeginPaint(HWND, PAINTSTRUCT FAR*);
void    WINAPI EndPaint(HWND, const PAINTSTRUCT FAR*);

void    WINAPI UpdateWindow(HWND);

int     WINAPI ExcludeUpdateRgn(HDC, HWND);

#if (WINVER >= 0x030a)
BOOL    WINAPI LockWindowUpdate(HWND hwndLock);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetUpdateRect(HWND, RECT FAR*, BOOL);
int     WINAPI GetUpdateRgn(HWND, HRGN, BOOL);

void    WINAPI InvalidateRect(HWND, const RECT FAR*, BOOL);
void    WINAPI ValidateRect(HWND, const RECT FAR*);

void    WINAPI InvalidateRgn(HWND, HRGN, BOOL);
void    WINAPI ValidateRgn(HWND, HRGN);

#if (WINVER >= 0x030a)
BOOL    WINAPI RedrawWindow(HWND hwnd, const RECT FAR* lprcUpdate, HRGN hrgnUpdate, UINT flags);

#define RDW_INVALIDATE          0x0001
#define RDW_INTERNALPAINT       0x0002
#define RDW_ERASE               0x0004

#define RDW_VALIDATE            0x0008
#define RDW_NOINTERNALPAINT     0x0010
#define RDW_NOERASE             0x0020

#define RDW_NOCHILDREN          0x0040
#define RDW_ALLCHILDREN         0x0080

#define RDW_UPDATENOW           0x0100
#define RDW_ERASENOW            0x0200

#define RDW_FRAME               0x0400
#define RDW_NOFRAME             0x0800
                                                                        /* ;Internal */
#define RDW_REDRAWWINDOW        0x1000  /* Called from RedrawWindow()*/ /* ;Internal */
#define RDW_SUBTRACTSELF        0x2000  /* Subtract self from hrgn   */ /* ;Internal */
                                                                        /* ;Internal */
#define RDW_COPYRGN             0x4000  /* Copy the passed-in region */ /* ;Internal */
#define RDW_VALID               0x0fff                                  /* ;Internal */

#endif  /* WINVER >= 0x030a */

/****** Window scrolling ****************************************************/

void    WINAPI ScrollWindow(HWND, int, int, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI ScrollDC(HDC, int, int, const RECT FAR*, const RECT FAR*, HRGN, RECT FAR*);

#if (WINVER >= 0x030a)

int     WINAPI ScrollWindowEx(HWND hwnd, int dx, int dy,
                const RECT FAR* prcScroll, const RECT FAR* prcClip,
                HRGN hrgnUpdate, RECT FAR* prcUpdate, UINT flags);

#define SW_SCROLLCHILDREN   0x0001
#define SW_INVALIDATE       0x0002
#define SW_ERASE            0x0004

#define SW_SCROLLWINDOW     0x8000  /* ;Internal */
#define SW_VALID            0x8007  /* ;Internal */

#endif  /* WINVER >= 0x030a */

/****** Non-client window area management ************************************/

#define WM_NCPAINT          0x0085

#define WM_NCCALCSIZE       0x0083

#if (WINVER >= 0x030a)
/* WM_NCCALCSIZE return flags */
#define WVR_ALIGNTOP        0x0010
#define WVR_ALIGNLEFT       0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT      0x0080
#define WVR_HREDRAW         0x0100
#define WVR_VREDRAW         0x0200
#define WVR_REDRAW          (WVR_HREDRAW | WVR_VREDRAW)
#define WVR_VALIDRECTS      0x0400

#define WVR_MINVALID        WVR_ALIGNTOP        /* ;Internal */
#define WVR_MAXVALID        WVR_VALIDRECTS      /* ;Internal */

/* WM_NCCALCSIZE parameter structure */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT           rgrc[3];
    WINDOWPOS FAR* lppos;
} NCCALCSIZE_PARAMS;
#else   /* WINVER >= 0x030a */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[2];
} NCCALCSIZE_PARAMS;
#endif  /* WINVER >= 0x030a */
typedef NCCALCSIZE_PARAMS FAR* LPNCCALCSIZE_PARAMS;

#define WM_NCHITTEST        0x0084

/* WM_NCHITTEST return codes */
#define HTERROR             (-2)
#define HTTRANSPARENT       (-1)
#define HTNOWHERE           0
#define HTCLIENT            1
#define HTCAPTION           2
#define HTSYSMENU           3
#define HTSIZE              4
#define HTMENU              5
#define HTHSCROLL           6
#define HTVSCROLL           7
#define HTMINBUTTON         8
#define HTMAXBUTTON         9
#define HTLEFT              10
#define HTRIGHT             11
#define HTTOP               12
#define HTTOPLEFT           13
#define HTTOPRIGHT          14
#define HTBOTTOM            15
#define HTBOTTOMLEFT        16
#define HTBOTTOMRIGHT       17
#define HTBORDER            18
#define HTGROWBOX           HTSIZE
#define HTREDUCE            HTMINBUTTON
#define HTZOOM              HTMAXBUTTON
#define HTSIZEFIRST         HTLEFT              /* ;Internal */
#define HTSIZELAST          HTBOTTOMRIGHT       /* ;Internal */

/****** Drag-and-drop support ***********************************************/

#define WM_DROPOBJECT       0x022A              /* ;Internal */
#define WM_QUERYDROPOBJECT  0x022B              /* ;Internal */
#define WM_BEGINDRAG        0x022C              /* ;Internal */
#define WM_DRAGLOOP         0x022D              /* ;Internal */
#define WM_DRAGSELECT       0x022E              /* ;Internal */
#define WM_DRAGMOVE         0x022F              /* ;Internal */
#define WM_QUERYDRAGICON    0x0037
#define WM_DROPFILES        0x0233

/****** Window activation ***************************************************/

HWND    WINAPI SetActiveWindow(HWND);
HWND    WINAPI GetActiveWindow(void);

HWND    WINAPI GetLastActivePopup(HWND);

/* WM_ACTIVATE state values */
#define WA_INACTIVE         0
#define WA_ACTIVE           1
#define WA_CLICKACTIVE      2

#define WM_ACTIVATE         0x0006
#define WM_ACTIVATEAPP      0x001C
#define WM_NCACTIVATE       0x0086

/****** Keyboard input support **********************************************/

HWND    WINAPI SetFocus(HWND);
HWND    WINAPI GetFocus(void);

int     WINAPI GetKeyState(int);
int     WINAPI GetAsyncKeyState(int);

void    WINAPI GetKeyboardState(BYTE FAR* );
void    WINAPI SetKeyboardState(BYTE FAR* );

#define WM_SETFOCUS         0x0007
#define WM_KILLFOCUS        0x0008

#define WM_KEYDOWN          0x0100
#define WM_KEYUP            0x0101

#define WM_CHAR             0x0102
#define WM_DEADCHAR         0x0103

#define WM_SYSKEYDOWN       0x0104
#define WM_SYSKEYUP         0x0105

#define WM_SYSCHAR          0x0106
#define WM_SYSDEADCHAR      0x0107

#define WM_YOMICHAR         0x0108  /* JAPAN */ /* ;Internal */
#define WM_CONVERTREQUEST   0x010A  /* JAPAN */ /* ;Internal */
#define WM_CONVERTRESULT    0x010B  /* JAPAN */ /* ;Internal */
#define WM_INTERIM          0x010C  /* KOREA */ /* ;Internal */

/* Keyboard message range */
#define WM_KEYFIRST         0x0100
#define WM_KEYLAST          0x0108

/* WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags */
#define KF_EXTENDED         0x0100
#define KF_DLGMODE          0x0800
#define KF_MENUMODE         0x1000
#define KF_ALTDOWN          0x2000
#define KF_REPEAT           0x4000
#define KF_UP               0x8000

/* Virtual key codes */
#ifndef NOVIRTUALKEYCODES
#define VK_LBUTTON          0x01
#define VK_RBUTTON          0x02
#define VK_CANCEL           0x03
#define VK_MBUTTON          0x04
#define VK_BACK             0x08
#define VK_TAB              0x09
#define VK_CLEAR            0x0C
#define VK_RETURN           0x0D
#define VK_SHIFT            0x10
#define VK_CONTROL          0x11
#define VK_MENU             0x12
#define VK_PAUSE            0x13
#define VK_CAPITAL          0x14
#define VK_KANA             0x15    /* JAPAN */ /* ;Internal */
#define VK_KANJI            0x19    /* JAPAN */ /* ;Internal */
#define VK_HANGEUL          0x15    /* KOREA */ /* ;Internal */
#define VK_JUNJA            0x17    /* KOREA */ /* ;Internal */
#define VK_HANJA            0x19    /* KOREA */ /* ;Internal */
#define VK_ESCAPE           0x1B
#define VK_SPACE            0x20
#define VK_PRIOR            0x21
#define VK_NEXT             0x22
#define VK_END              0x23
#define VK_HOME             0x24
#define VK_LEFT             0x25
#define VK_UP               0x26
#define VK_RIGHT            0x27
#define VK_DOWN             0x28
#define VK_SELECT           0x29
#define VK_PRINT            0x2A
#define VK_EXECUTE          0x2B
#define VK_SNAPSHOT         0x2C
#define VK_INSERT           0x2D
#define VK_DELETE           0x2E
#define VK_HELP             0x2F
#define VK_NUMPAD0          0x60
#define VK_NUMPAD1          0x61
#define VK_NUMPAD2          0x62
#define VK_NUMPAD3          0x63
#define VK_NUMPAD4          0x64
#define VK_NUMPAD5          0x65
#define VK_NUMPAD6          0x66
#define VK_NUMPAD7          0x67
#define VK_NUMPAD8          0x68
#define VK_NUMPAD9          0x69
#define VK_MULTIPLY         0x6A
#define VK_ADD              0x6B
#define VK_SEPARATOR        0x6C
#define VK_SUBTRACT         0x6D
#define VK_DECIMAL          0x6E
#define VK_DIVIDE           0x6F
#define VK_F1               0x70
#define VK_F2               0x71
#define VK_F3               0x72
#define VK_F4               0x73
#define VK_F5               0x74
#define VK_F6               0x75
#define VK_F7               0x76
#define VK_F8               0x77
#define VK_F9               0x78
#define VK_F10              0x79
#define VK_F11              0x7A
#define VK_F12              0x7B
#define VK_F13              0x7C
#define VK_F14              0x7D
#define VK_F15              0x7E
#define VK_F16              0x7F
#define VK_F17              0x80
#define VK_F18              0x81
#define VK_F19              0x82
#define VK_F20              0x83
#define VK_F21              0x84
#define VK_F22              0x85
#define VK_F23              0x86
#define VK_F24              0x87
#define VK_NUMLOCK          0x90
#define VK_SCROLL           0x91

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' */

#endif  /* NOVIRTUALKEYCODES */

BOOL WINAPI IsTwoByteCharPrefix(char);      /* ;Internal */

/* SetWindowsHook() keyboard hook */
#define WH_KEYBOARD         2

/****** Mouse input support *************************************************/

HWND    WINAPI SetCapture(HWND);
void    WINAPI ReleaseCapture(void);
HWND    WINAPI GetCapture(void);

BOOL    WINAPI SwapMouseButton(BOOL);

/* Mouse input messages */
#define WM_MOUSEMOVE        0x0200
#define WM_LBUTTONDOWN      0x0201
#define WM_LBUTTONUP        0x0202
#define WM_LBUTTONDBLCLK    0x0203
#define WM_RBUTTONDOWN      0x0204
#define WM_RBUTTONUP        0x0205
#define WM_RBUTTONDBLCLK    0x0206
#define WM_MBUTTONDOWN      0x0207
#define WM_MBUTTONUP        0x0208
#define WM_MBUTTONDBLCLK    0x0209

/* Mouse input message range */
#define WM_MOUSEFIRST       0x0200
#define WM_MOUSELAST        0x0209

/* Mouse message wParam key states */
#ifndef NOKEYSTATES
#define MK_LBUTTON          0x0001
#define MK_RBUTTON          0x0002
#define MK_SHIFT            0x0004
#define MK_CONTROL          0x0008
#define MK_MBUTTON          0x0010
#endif  /* NOKEYSTATES */

/* Non-client mouse messages */
#define WM_NCMOUSEMOVE      0x00A0
#define WM_NCLBUTTONDOWN    0x00A1
#define WM_NCLBUTTONUP      0x00A2
#define WM_NCLBUTTONDBLCLK  0x00A3
#define WM_NCRBUTTONDOWN    0x00A4
#define WM_NCRBUTTONUP      0x00A5
#define WM_NCRBUTTONDBLCLK  0x00A6
#define WM_NCMBUTTONDOWN    0x00A7
#define WM_NCMBUTTONUP      0x00A8
#define WM_NCMBUTTONDBLCLK  0x00A9

/* Mouse click activation support */
#define WM_MOUSEACTIVATE    0x0021

/* WM_MOUSEACTIVATE return codes */
#define MA_ACTIVATE         1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE       3
#if (WINVER >= 0x030a)
#define MA_NOACTIVATEANDEAT 4
#endif  /* WINVER >= 0x030a */

/* SetWindowsHook() mouse hook */
#ifndef NOWH
#define WH_MOUSE            7

typedef struct tagMOUSEHOOKSTRUCT
{
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT;
typedef MOUSEHOOKSTRUCT  FAR* LPMOUSEHOOKSTRUCT;
#endif  /* NOWH */

/****** Mode control ********************************************************/

#define WM_CANCELMODE       0x001F

/****** System modal window support *****************************************/

HWND    WINAPI GetSysModalWindow(void);
HWND    WINAPI SetSysModalWindow(HWND);

/****** Timer support *******************************************************/

#ifdef STRICT
typedef void (CALLBACK* TIMERPROC)(HWND, UINT, UINT, DWORD);
#else
typedef FARPROC TIMERPROC;
#endif

UINT    WINAPI SetTimer(HWND, UINT, UINT, TIMERPROC);

BOOL    WINAPI KillTimer(HWND, UINT);

#define WM_TIMER            0x0113
#define WM_SYSTIMER         0x0118              /* ;Internal */

/****** Accelerator support *************************************************/

DECLARE_HANDLE(HACCEL);

HACCEL  WINAPI LoadAccelerators(HINSTANCE, LPCSTR);

#ifndef NOMSG
int     WINAPI TranslateAccelerator(HWND, HACCEL, MSG FAR*);
#endif

/****** Menu support ********************************************************/

#ifndef NOMENUS

/* Menu template header */
typedef struct
{
    UINT    versionNumber;
    UINT    offset;
} MENUITEMTEMPLATEHEADER;

/* Menu template item struct */
typedef struct
{
    UINT    mtOption;
    UINT    mtID;
    char    mtString[1];
} MENUITEMTEMPLATE;

#if (WINVER >= 0x030a)
BOOL    WINAPI IsMenu(HMENU);
#endif  /* WINVER >= 0x030a */

HMENU   WINAPI CreateMenu(void);
HMENU   WINAPI CreatePopupMenu(void);
HMENU   WINAPI LoadMenu(HINSTANCE, LPCSTR);
HMENU   WINAPI LoadMenuIndirect(const void FAR*);

BOOL    WINAPI DestroyMenu(HMENU);

HMENU   WINAPI GetMenu(HWND);
BOOL    WINAPI SetMenu(HWND, HMENU);

HMENU   WINAPI GetSystemMenu(HWND, BOOL);
BOOL    WINAPI SetSystemMenu(HWND, HMENU);    /* ;Internal */

void    WINAPI DrawMenuBar(HWND);

BOOL    WINAPI HiliteMenuItem(HWND, HMENU, UINT, UINT);

BOOL    WINAPI InsertMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI AppendMenu(HMENU, UINT, UINT, LPCSTR);
BOOL    WINAPI ModifyMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI RemoveMenu(HMENU, UINT, UINT);
BOOL    WINAPI DeleteMenu(HMENU, UINT, UINT);

BOOL    WINAPI ChangeMenu(HMENU, UINT, LPCSTR, UINT, UINT);

#define MF_INSERT           0x0000
#define MF_CHANGE           0x0080
#define MF_APPEND           0x0100
#define MF_DELETE           0x0200
#define MF_REMOVE           0x1000

/* Menu flags for Add/Check/EnableMenuItem() */
#define MF_BYCOMMAND        0x0000
#define MF_BYPOSITION       0x0400

#define MF_SEPARATOR        0x0800

#define MF_ENABLED          0x0000
#define MF_GRAYED           0x0001
#define MF_DISABLED         0x0002

#define MF_UNCHECKED        0x0000
#define MF_CHECKED          0x0008
#define MF_USECHECKBITMAPS  0x0200

#define MF_STRING           0x0000
#define MF_BITMAP           0x0004
#define MF_OWNERDRAW        0x0100

#define MF_POPUP            0x0010
#define MF_MENUBARBREAK     0x0020
#define MF_MENUBREAK        0x0040

#define MF_UNHILITE         0x0000
#define MF_HILITE           0x0080

#define MF_SYSMENU          0x2000
#define MF_HELP             0x4000
#define MF_MOUSESELECT      0x8000

#define MF_VALID            0x4fff  /* ;Internal */
#define MF_CHANGE_VALID     0x5fff  /* ;Internal */

#define MF_END              0x0080  /* Only valid in menu resource templates */

BOOL    WINAPI EnableMenuItem(HMENU, UINT, UINT);
BOOL    WINAPI CheckMenuItem(HMENU, UINT, UINT);

HMENU   WINAPI GetSubMenu(HMENU, int);

int     WINAPI GetMenuItemCount(HMENU);
UINT    WINAPI GetMenuItemID(HMENU, int);

int     WINAPI GetMenuString(HMENU, UINT, LPSTR, int, UINT);
UINT    WINAPI GetMenuState(HMENU, UINT, UINT);

BOOL    WINAPI SetMenuItemBitmaps(HMENU, UINT, UINT, HBITMAP, HBITMAP);
DWORD   WINAPI GetMenuCheckMarkDimensions(void);

BOOL    WINAPI TrackPopupMenu(HMENU, UINT, int, int, int, HWND, const RECT FAR*);

/* Flags for TrackPopupMenu */
#define TPM_LEFTBUTTON  0x0000
#if (WINVER >= 0x030a)
#define TPM_RIGHTBUTTON 0x0002
#define TPM_LEFTALIGN   0x0000
#define TPM_CENTERALIGN 0x0004
#define TPM_RIGHTALIGN  0x0008
#define TPM_VALID       0x000f  /* ;Internal */
#endif  /* WINVER >= 0x030a */

#endif  /* NOMENUS */

/* Menu messages */
#define WM_INITMENU         0x0116
#define WM_INITMENUPOPUP    0x0117

#ifndef NOMENUS

#define WM_MENUSELECT       0x011F
#define WM_MENUCHAR         0x0120
#define WM_ENTERMENULOOP    0x0211              /* ;Internal */
#define WM_EXITMENULOOP     0x0212              /* ;Internal */
#define WM_NEXTMENU         0x0213              /* ;Internal */

#endif  /* NOMENUS */

/* Menu and control command messages */
#define WM_COMMAND          0x0111

/****** Scroll bar support **************************************************/

#ifndef NOSCROLL

#define WM_HSCROLL          0x0114
#define WM_VSCROLL          0x0115

/* WM_H/VSCROLL commands */
#define SB_LINEUP           0
#define SB_LINELEFT         0
#define SB_LINEDOWN         1
#define SB_LINERIGHT        1
#define SB_PAGEUP           2
#define SB_PAGELEFT         2
#define SB_PAGEDOWN         3
#define SB_PAGERIGHT        3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK       5
#define SB_TOP              6
#define SB_LEFT             6
#define SB_BOTTOM           7
#define SB_RIGHT            7
#define SB_ENDSCROLL        8
#define SB_MSGCMD_MAX       8       /* ;Internal */

/* Scroll bar selection constants */
#define SB_HORZ             0
#define SB_VERT             1
#define SB_CTL              2
#define SB_BOTH             3
#define SB_MAX              3       /* ;Internal */

int     WINAPI SetScrollPos(HWND, int, int, BOOL);
int     WINAPI GetScrollPos(HWND, int);
void    WINAPI SetScrollRange(HWND, int, int, int, BOOL);
void    WINAPI GetScrollRange(HWND, int, int FAR*, int FAR*);
void    WINAPI ShowScrollBar(HWND, int, BOOL);
BOOL    WINAPI EnableScrollBar(HWND, int, UINT);

/* EnableScrollBar() flags */
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_BOTH    0x0003

#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISABLE_RIGHT   0x0002

#define ESB_DISABLE_UP      0x0001
#define ESB_DISABLE_DOWN    0x0002

#define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT

#define ESB_MAX             0x0003              /* ;Internal */
#define SB_DISABLE_MASK     ESB_DISABLE_BOTH    /* ;Internal */
#endif  /* NOSCROLL */

/******* Clipboard manager **************************************************/

#ifndef NOCLIPBOARD

/* Predefined Clipboard Formats */
#define CF_TEXT              1
#define CF_BITMAP            2
#define CF_METAFILEPICT      3
#define CF_SYLK              4
#define CF_DIF               5
#define CF_TIFF              6
#define CF_OEMTEXT           7
#define CF_DIB               8
#define CF_PALETTE           9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT          0x0081
#define CF_DSPBITMAP        0x0082
#define CF_DSPMETAFILEPICT  0x0083

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST      0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST      0x0300
#define CF_GDIOBJLAST       0x03FF

/* Clipboard Manager Functions */
BOOL    WINAPI OpenClipboard(HWND);
BOOL    WINAPI CloseClipboard(void);
BOOL    WINAPI EmptyClipboard(void);

#if (WINVER >= 0x030a)
HWND    WINAPI GetOpenClipboardWindow(void);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI GetClipboardOwner(void);

HWND    WINAPI SetClipboardViewer(HWND);
HWND    WINAPI GetClipboardViewer(void);

HANDLE  WINAPI SetClipboardData(UINT, HANDLE);
HANDLE  WINAPI GetClipboardData(UINT);

BOOL    WINAPI IsClipboardFormatAvailable(UINT);
int     WINAPI GetPriorityClipboardFormat(UINT FAR*, int);

UINT    WINAPI RegisterClipboardFormat(LPCSTR);
int     WINAPI CountClipboardFormats(void);
UINT    WINAPI EnumClipboardFormats(UINT);
int     WINAPI GetClipboardFormatName(UINT, LPSTR, int);

BOOL    WINAPI ChangeClipboardChain(HWND, HWND);

/* Clipboard command messages */
#define WM_CUT              0x0300
#define WM_COPY             0x0301
#define WM_PASTE            0x0302
#define WM_CLEAR            0x0303
#define WM_UNDO             0x0304

/* Clipboard owner messages */
#define WM_RENDERFORMAT     0x0305
#define WM_RENDERALLFORMATS 0x0306
#define WM_DESTROYCLIPBOARD 0x0307

/* Clipboard viewer messages */
#define WM_DRAWCLIPBOARD    0x0308
#define WM_PAINTCLIPBOARD   0x0309
#define WM_SIZECLIPBOARD    0x030B
#define WM_VSCROLLCLIPBOARD 0x030A
#define WM_HSCROLLCLIPBOARD 0x030E
#define WM_ASKCBFORMATNAME  0x030C
#define WM_CHANGECBCHAIN    0x030D

#endif  /* NOCLIPBOARD */

/****** Mouse cursor support *************************************************/

HCURSOR WINAPI LoadCursor(HINSTANCE, LPCSTR);
HCURSOR WINAPI CreateCursor(HINSTANCE, int, int, int, int, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI CopyCursor(HINSTANCE, HCURSOR);
#endif  /* WINVER >= 0x030a */

int     WINAPI ShowCursor(BOOL);

void    WINAPI SetCursorPos(int, int);
void    WINAPI GetCursorPos(POINT FAR*);

HCURSOR WINAPI SetCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI GetCursor(void);
#endif  /* WINVER >= 0x030a */

void    WINAPI ClipCursor(const RECT FAR*);
#if (WINVER >= 0x030a)
void    WINAPI GetClipCursor(RECT FAR*);
#endif  /* WINVER >= 0x030a */

/* Standard cursor resource IDs */
#define IDC_ARROW           MAKEINTRESOURCE(32512)
#define IDC_IBEAM           MAKEINTRESOURCE(32513)
#define IDC_WAIT            MAKEINTRESOURCE(32514)
#define IDC_CROSS           MAKEINTRESOURCE(32515)
#define IDC_UPARROW         MAKEINTRESOURCE(32516)
#define IDC_SIZE            MAKEINTRESOURCE(32640)
#define IDC_ICON            MAKEINTRESOURCE(32641)
#define IDC_SIZENWSE        MAKEINTRESOURCE(32642)
#define IDC_SIZENESW        MAKEINTRESOURCE(32643)
#define IDC_SIZEWE          MAKEINTRESOURCE(32644)
#define IDC_SIZENS          MAKEINTRESOURCE(32645)

#define WM_SETCURSOR        0x0020

/****** Icon support *********************************************************/

HICON   WINAPI LoadIcon(HINSTANCE, LPCSTR);
HICON   WINAPI CreateIcon(HINSTANCE, int, int, BYTE, BYTE, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyIcon(HICON);

#if (WINVER >= 0x030a)
HICON   WINAPI CopyIcon(HINSTANCE, HICON);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DrawIcon(HDC, int, int, HICON);

#ifndef NOICONS

/* Standard icon resource IDs */
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND            MAKEINTRESOURCE(32513)
#define IDI_QUESTION        MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK        MAKEINTRESOURCE(32516)

#endif  /* NOICONS */

/****** Message Box support *************************************************/

#ifndef NOMB

int     WINAPI MessageBox(HWND, LPCSTR, LPCSTR, UINT);
void    WINAPI MessageBeep(UINT);

#define MB_OK               0x0000
#define MB_OKCANCEL         0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL      0x0003
#define MB_YESNO            0x0004
#define MB_RETRYCANCEL      0x0005
#define MB_TYPEMASK         0x000F

#define MB_ICONHAND         0x0010
#define MB_ICONQUESTION     0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040
#define MB_ICONMASK         0x00F0

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP         MB_ICONHAND

#define MB_DEFBUTTON1       0x0000
#define MB_DEFBUTTON2       0x0100
#define MB_DEFBUTTON3       0x0200
#define MB_DEFMASK          0x0F00

#define MB_APPLMODAL        0x0000
#define MB_SYSTEMMODAL      0x1000
#define MB_TASKMODAL        0x2000

#define MB_NOFOCUS          0x8000

#define MB_TYPEMASK         0x000F      /* ;Internal */
#define MB_ICONMASK         0x00F0      /* ;Internal */
#define MB_DEFMASK          0x0F00      /* ;Internal */
#define MB_MODEMASK         0x3000      /* ;Internal */
#define MB_MISCMASK         0xC000      /* ;Internal */
#define MB_VALID            0xb377      /* ;Internal */


#endif  /* NOMB */

/****** Caret support ********************************************************/

void    WINAPI CreateCaret(HWND, HBITMAP, int, int);
void    WINAPI DestroyCaret(void);

void    WINAPI SetCaretPos(int, int);
void    WINAPI GetCaretPos(POINT FAR*);

void    WINAPI HideCaret(HWND);
void    WINAPI ShowCaret(HWND);

UINT    WINAPI GetCaretBlinkTime(void);
void    WINAPI SetCaretBlinkTime(UINT);

/****** WM_SYSCOMMAND support ***********************************************/

#define WM_SYSCOMMAND   0x0112

#ifndef NOSYSCOMMANDS

/* System Menu Command Values */
#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

/* Obsolete names */
#define SC_ICON         SC_MINIMIZE
#define SC_ZOOM         SC_MAXIMIZE

/* SC_HOTKEY support messages */ /* ;Internal */
#define WM_SETHOTKEY    0x0032   /* ;Internal */
#define WM_GETHOTKEY    0x0033   /* ;Internal */

#endif  /* NOSYSCOMMANDS */

/****** MDI Support *********************************************************/

#ifndef NOMDI

/* CreateWindow lpParams structure for creating MDI client */
typedef struct tagCLIENTCREATESTRUCT
{
    HMENU  hWindowMenu;
    UINT   idFirstChild;
} CLIENTCREATESTRUCT;
typedef CLIENTCREATESTRUCT FAR* LPCLIENTCREATESTRUCT;

/* MDI client style bits */
#if (WINVER >= 0x030a)
#define MDIS_ALLCHILDSTYLES 0x0001
#endif  /* WINVER >= 0x030a */

/* MDI messages */
#define WM_MDICREATE        0x0220
#define WM_MDIDESTROY       0x0221
#define WM_MDIACTIVATE      0x0222
#define WM_MDIRESTORE       0x0223
#define WM_MDINEXT          0x0224
#define WM_MDIMAXIMIZE      0x0225
#define WM_MDITILE          0x0226
#define WM_MDICASCADE       0x0227
#define WM_MDIICONARRANGE   0x0228
#define WM_MDIGETACTIVE     0x0229
#define WM_MDISETMENU       0x0230

/* WM_MDICREATE message structure */
typedef struct tagMDICREATESTRUCT
{
    LPCSTR  szClass;
    LPCSTR  szTitle;
    HINSTANCE hOwner;
    int     x;
    int     y;
    int     cx;
    int     cy;
    DWORD   style;
    LPARAM  lParam;
} MDICREATESTRUCT;
typedef MDICREATESTRUCT FAR*  LPMDICREATESTRUCT;

#if (WINVER >= 0x030a)
/* wParam values for WM_MDITILE and WM_MDICASCADE messages. */
#define MDITILE_VERTICAL        0x0000
#define MDITILE_HORIZONTAL      0x0001
#define MDITILE_SKIPDISABLED    0x0002
#endif  /* WINVER >= 0x030a */

#define WM_CHILDACTIVATE    0x0022

LRESULT WINAPI DefFrameProc(HWND, HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI DefMDIChildProc(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG
BOOL    WINAPI TranslateMDISysAccel(HWND, MSG FAR*);
#endif

UINT    WINAPI ArrangeIconicWindows(HWND);

#endif  /* NOMDI */

/****** Dialog and Control Management ***************************************/

#ifndef NOCTLMGR

/* Dialog window class */
#define WC_DIALOG       (MAKEINTATOM(0x8002))

/* cbWndExtra bytes needed by dialog manager for dialog classes */
#define DLGWINDOWEXTRA  30

/* Dialog styles */
#define DS_ABSALIGN         0x01L
#define DS_SYSMODAL         0x02L
#define DS_LOCALEDIT        0x20L
#define DS_SETFONT          0x40L
#define DS_MODALFRAME       0x80L
#define DS_NOIDLEMSG        0x100L

/* Dialog messages */
#define DM_GETDEFID         (WM_USER+0)
#define DM_SETDEFID         (WM_USER+1)

/* Returned in HIWORD() of DM_GETDEFID result if msg is supported */
#define DC_HASDEFID         0x534B

#endif  /* NOCTLMGR */

/* Dialog notification messages */
#define WM_INITDIALOG       0x0110
#define WM_NEXTDLGCTL       0x0028
#define WM_ALTTABACTIVE     0x0029              /* ;Internal */

#define WM_PARENTNOTIFY     0x0210

#define WM_ENTERIDLE        0x0121


#ifndef NOCTLMGR

#ifdef STRICT
typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
#else
typedef FARPROC DLGPROC;
#endif

/* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows */
#define DWL_MSGRESULT   0
#define DWL_DLGPROC     4
#define DWL_USER        8

#ifndef NOMSG
BOOL    WINAPI IsDialogMessage(HWND, MSG FAR*);
#endif

LRESULT WINAPI DefDlgProc(HWND, UINT, WPARAM, LPARAM);

HWND    WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);
HWND    WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);
HWND    WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
HWND    WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);

int     WINAPI DialogBox(HINSTANCE, LPCSTR, HWND, DLGPROC);
int     WINAPI DialogBoxIndirect(HINSTANCE, HGLOBAL, HWND, DLGPROC);
int     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
int     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);

void    WINAPI EndDialog(HWND, int);

int     WINAPI GetDlgCtrlID(HWND);
HWND    WINAPI GetDlgItem(HWND, int);
LRESULT WINAPI SendDlgItemMessage(HWND, int, UINT, WPARAM, LPARAM);

void    WINAPI SetDlgItemInt(HWND, int, UINT, BOOL);
UINT    WINAPI GetDlgItemInt(HWND, int, BOOL FAR* , BOOL);

void    WINAPI SetDlgItemText(HWND, int, LPCSTR);
int     WINAPI GetDlgItemText(HWND, int, LPSTR, int);

void    WINAPI CheckDlgButton(HWND, int, UINT);
void    WINAPI CheckRadioButton(HWND, int, int, int);
UINT    WINAPI IsDlgButtonChecked(HWND, int);

HWND    WINAPI GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND    WINAPI GetNextDlgTabItem(HWND, HWND, BOOL);

void    WINAPI MapDialogRect(HWND, RECT FAR*);
DWORD   WINAPI GetDialogBaseUnits(void);

#define WM_GETDLGCODE       0x0087

/* dialog codes */
#define DLGC_WANTARROWS     0x0001
#define DLGC_WANTTAB        0x0002
#define DLGC_WANTALLKEYS    0x0004
#define DLGC_WANTMESSAGE    0x0004
#define DLGC_HASSETSEL      0x0008
#define DLGC_DEFPUSHBUTTON  0x0010
#define DLGC_UNDEFPUSHBUTTON 0x0020
#define DLGC_RADIOBUTTON    0x0040
#define DLGC_WANTCHARS      0x0080
#define DLGC_STATIC         0x0100
#define DLGC_BUTTON         0x2000

#define WM_CTLCOLOR         0x0019

/* WM_CTLCOLOR control IDs */
#define CTLCOLOR_MSGBOX     0
#define CTLCOLOR_EDIT       1
#define CTLCOLOR_LISTBOX    2
#define CTLCOLOR_BTN        3
#define CTLCOLOR_DLG        4
#define CTLCOLOR_SCROLLBAR  5
#define CTLCOLOR_STATIC     6
#define CTLCOLOR_MAX        8       /* ;Internal */

#define WM_SETFONT          0x0030
#define WM_GETFONT          0x0031

#endif  /* NOCTLMGR */

/* Standard dialog button IDs */
#define IDOK                1
#define IDCANCEL            2
#define IDABORT             3
#define IDRETRY             4
#define IDIGNORE            5
#define IDYES               6
#define IDNO                7

/****** Owner draw control support ******************************************/

/* Owner draw control types */
#define ODT_MENU        1
#define ODT_LISTBOX     2
#define ODT_COMBOBOX    3
#define ODT_BUTTON      4

/* Owner draw actions */
#define ODA_DRAWENTIRE  0x0001
#define ODA_SELECT      0x0002
#define ODA_FOCUS       0x0004

/* Owner draw state */
#define ODS_SELECTED    0x0001
#define ODS_GRAYED      0x0002
#define ODS_DISABLED    0x0004
#define ODS_CHECKED     0x0008
#define ODS_FOCUS       0x0010

#define WM_DRAWITEM         0x002B

typedef struct tagDRAWITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND        hwndItem;
    HDC         hDC;
    RECT        rcItem;
    DWORD       itemData;
} DRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT NEAR* PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR* LPDRAWITEMSTRUCT;

#define WM_MEASUREITEM      0x002C

typedef struct tagMEASUREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemWidth;
    UINT        itemHeight;
    DWORD       itemData;
} MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT NEAR* PMEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT FAR* LPMEASUREITEMSTRUCT;

#define WM_DELETEITEM       0x002D

typedef struct tagDELETEITEMSTRUCT
{
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    DWORD      itemData;
} DELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT NEAR* PDELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT FAR* LPDELETEITEMSTRUCT;

#define WM_COMPAREITEM      0x0039

typedef struct tagCOMPAREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    HWND        hwndItem;
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
} COMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT NEAR* PCOMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT FAR* LPCOMPAREITEMSTRUCT;

/****** Static control ******************************************************/

#ifndef NOCTLMGR

/* Static Control Styles */
#define SS_LEFT             0x00000000L
#define SS_CENTER           0x00000001L
#define SS_RIGHT            0x00000002L
#define SS_ICON             0x00000003L
#define SS_BLACKRECT        0x00000004L
#define SS_GRAYRECT         0x00000005L
#define SS_WHITERECT        0x00000006L
#define SS_BLACKFRAME       0x00000007L
#define SS_GRAYFRAME        0x00000008L
#define SS_WHITEFRAME       0x00000009L
#define SS_USERITEM         0x0000000AL    /* ;Internal */
#define SS_SIMPLE           0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#define SS_NOPREFIX         0x00000080L

#if (WINVER >= 0x030a)
#ifndef NOWINMESSAGES
/* Static Control Mesages */
#define STM_SETICON         (WM_USER+0)
#define STM_GETICON         (WM_USER+1)
#define STM_MSGMAX          (WM_USER+2)    /* ;Internal */
#endif  /* NOWINMESSAGES */
#endif  /* WINVER >= 0x030a */

#endif  /* NOCTLMGR */

/****** Button control *****************************************************/

#ifndef NOCTLMGR

/* Button Control Styles */
#define BS_PUSHBUTTON       0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX         0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON      0x00000004L
#define BS_3STATE           0x00000005L
#define BS_AUTO3STATE       0x00000006L
#define BS_GROUPBOX         0x00000007L
#define BS_USERBUTTON       0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_PUSHBOX          0x0000000AL  /* ;Internal */
#define BS_OWNERDRAW        0x0000000BL
#define BS_LEFTTEXT         0x00000020L

/* Button Control Messages  */
#define BM_GETCHECK         (WM_USER+0)
#define BM_SETCHECK         (WM_USER+1)
#define BM_GETSTATE         (WM_USER+2)
#define BM_SETSTATE         (WM_USER+3)
#define BM_SETSTYLE         (WM_USER+4)

/* User Button Notification Codes */
#define BN_CLICKED          0
#define BN_PAINT            1
#define BN_HILITE           2
#define BN_UNHILITE         3
#define BN_DISABLE          4
#define BN_DOUBLECLICKED    5

#endif  /* NOCTLMGR */

/****** Edit control *******************************************************/

#ifndef NOCTLMGR

/* Edit control styles */
#ifndef NOWINSTYLES
#define ES_LEFT             0x00000000L
#define ES_CENTER           0x00000001L
#define ES_RIGHT            0x00000002L
#define ES_MULTILINE        0x00000004L
#define ES_UPPERCASE        0x00000008L
#define ES_LOWERCASE        0x00000010L
#define ES_PASSWORD         0x00000020L
#define ES_AUTOVSCROLL      0x00000040L
#define ES_AUTOHSCROLL      0x00000080L
#define ES_NOHIDESEL        0x00000100L
#define ES_OEMCONVERT       0x00000400L
#if (WINVER >= 0x030a)
#define ES_READONLY         0x00000800L
#define ES_WANTRETURN       0x00001000L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Edit control messages */
#ifndef NOWINMESSAGES
#define EM_GETSEL               (WM_USER+0)
#define EM_SETSEL               (WM_USER+1)
#define EM_GETRECT              (WM_USER+2)
#define EM_SETRECT              (WM_USER+3)
#define EM_SETRECTNP            (WM_USER+4)
#define EM_SCROLL               (WM_USER+5)     /* ;Internal */
#define EM_LINESCROLL           (WM_USER+6)
#define EM_GETMODIFY            (WM_USER+8)
#define EM_SETMODIFY            (WM_USER+9)
#define EM_GETLINECOUNT         (WM_USER+10)
#define EM_LINEINDEX            (WM_USER+11)
#define EM_SETHANDLE            (WM_USER+12)
#define EM_GETHANDLE            (WM_USER+13)
#define EM_GETTHUMB             (WM_USER+14)    /* ;Internal */
#define EM_LINELENGTH           (WM_USER+17)
#define EM_REPLACESEL           (WM_USER+18)
#define EM_SETFONT              (WM_USER+19)    /* NOT IMPLEMENTED: use WM_SETFONT */
#define EM_GETLINE              (WM_USER+20)
#define EM_LIMITTEXT            (WM_USER+21)
#define EM_CANUNDO              (WM_USER+22)
#define EM_UNDO                 (WM_USER+23)
#define EM_FMTLINES             (WM_USER+24)
#define EM_LINEFROMCHAR         (WM_USER+25)
#define EM_SETWORDBREAK         (WM_USER+26)    /* NOT IMPLEMENTED: use EM_SETWORDBREAK */
#define EM_SETTABSTOPS          (WM_USER+27)
#define EM_SETPASSWORDCHAR      (WM_USER+28)
#define EM_EMPTYUNDOBUFFER      (WM_USER+29)
#if (WINVER >= 0x030a)
#define EM_GETFIRSTVISIBLELINE  (WM_USER+30)
#define EM_SETREADONLY          (WM_USER+31)
#define EM_SETWORDBREAKPROC     (WM_USER+32)
#define EM_GETWORDBREAKPROC     (WM_USER+33)
#define EM_GETPASSWORDCHAR      (WM_USER+34)
#endif  /* WINVER >= 0x030a */
#define EM_MSGMAX               (WM_USER+35)    /* ;Internal */
#endif  /* NOWINMESSAGES */

#if (WINVER >= 0x030a)
typedef int   (CALLBACK* EDITWORDBREAKPROC)(LPSTR lpch, int ichCurrent, int cch, int code);

/* EDITWORDBREAKPROC code values */
#define WB_LEFT            0
#define WB_RIGHT           1
#define WB_ISDELIMITER     2
#endif  /* WINVER >= 0x030a */

/* Edit control notification codes */
#define EN_SETFOCUS         0x0100
#define EN_KILLFOCUS        0x0200
#define EN_CHANGE           0x0300
#define EN_UPDATE           0x0400
#define EN_ERRSPACE         0x0500
#define EN_MAXTEXT          0x0501
#define EN_HSCROLL          0x0601
#define EN_VSCROLL          0x0602

#endif  /* NOCTLMGR */

/****** Scroll bar control *************************************************/
/* Also see scrolling support */

#ifndef NOCTLMGR

#ifndef NOWINSTYLES

/* Scroll bar styles */
#define SBS_HORZ                    0x0000L
#define SBS_VERT                    0x0001L
#define SBS_TOPALIGN                0x0002L
#define SBS_LEFTALIGN               0x0002L
#define SBS_BOTTOMALIGN             0x0004L
#define SBS_RIGHTALIGN              0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN     0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX                 0x0008L

#endif  /* NOWINSTYLES */

#endif  /* NOCTLMGR */

/****** Listbox control ****************************************************/

#ifndef NOCTLMGR

/* Listbox styles */
#ifndef NOWINSTYLES
#define LBS_NOTIFY            0x0001L
#define LBS_SORT              0x0002L
#define LBS_NOREDRAW          0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL       0x0800L
#if (WINVER >= 0x030a)
#define LBS_DISABLENOSCROLL   0x1000L
#endif  /* WINVER >= 0x030a */
#define LBS_STANDARD          (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
#endif  /* NOWINSTYLES */

/* Listbox messages */
#ifndef NOWINMESSAGES
#define LB_ADDSTRING           (WM_USER+1)
#define LB_INSERTSTRING        (WM_USER+2)
#define LB_DELETESTRING        (WM_USER+3)
#define LB_RESETCONTENT        (WM_USER+5)
#define LB_SETSEL              (WM_USER+6)
#define LB_SETCURSEL           (WM_USER+7)
#define LB_GETSEL              (WM_USER+8)
#define LB_GETCURSEL           (WM_USER+9)
#define LB_GETTEXT             (WM_USER+10)
#define LB_GETTEXTLEN          (WM_USER+11)
#define LB_GETCOUNT            (WM_USER+12)
#define LB_SELECTSTRING        (WM_USER+13)
#define LB_DIR                 (WM_USER+14)
#define LB_GETTOPINDEX         (WM_USER+15)
#define LB_FINDSTRING          (WM_USER+16)
#define LB_GETSELCOUNT         (WM_USER+17)
#define LB_GETSELITEMS         (WM_USER+18)
#define LB_SETTABSTOPS         (WM_USER+19)
#define LB_GETHORIZONTALEXTENT (WM_USER+20)
#define LB_SETHORIZONTALEXTENT (WM_USER+21)
#define LB_SETCOLUMNWIDTH      (WM_USER+22)
#define LB_ADDFILE             (WM_USER+23)     /* ;Internal */
#define LB_SETTOPINDEX         (WM_USER+24)
#define LB_GETITEMRECT         (WM_USER+25)
#define LB_GETITEMDATA         (WM_USER+26)
#define LB_SETITEMDATA         (WM_USER+27)
#define LB_SELITEMRANGE        (WM_USER+28)
#define LB_SETANCHORINDEX      (WM_USER+29)     /* ;Internal */
#define LB_GETANCHORINDEX      (WM_USER+30)     /* ;Internal */
#define LB_SETCARETINDEX       (WM_USER+31)
#define LB_GETCARETINDEX       (WM_USER+32)

#if (WINVER >= 0x030a)
#define LB_SETITEMHEIGHT       (WM_USER+33)
#define LB_GETITEMHEIGHT       (WM_USER+34)
#define LB_FINDSTRINGEXACT     (WM_USER+35)
#endif  /* WINVER >= 0x030a */
#define LBCB_CARETON           (WM_USER+36)     /* ;Internal */
#define LBCB_CARETOFF          (WM_USER+37)     /* ;Internal */
#define LB_MSGMAX              (WM_USER+38)     /* ;Internal */

#endif  /* NOWINMESSAGES */

/* Listbox notification codes */
#define LBN_ERRSPACE        (-2)
#define LBN_SELCHANGE       1
#define LBN_DBLCLK          2
#define LBN_SELCANCEL       3
#define LBN_SETFOCUS        4
#define LBN_KILLFOCUS       5

/* Listbox notification messages */
#define WM_VKEYTOITEM       0x002E
#define WM_CHARTOITEM       0x002F
#define WM_LBTRACKPOINT     0x0131              /* ;Internal */

/* Listbox message return values */
#define LB_OKAY             0
#define LB_ERR              (-1)
#define LB_ERRSPACE         (-2)

#define LB_CTLCODE          0L

/****** Dialog directory support ********************************************/

int     WINAPI DlgDirList(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelect(HWND, LPSTR, int);

int     WINAPI DlgDirListComboBox(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelectComboBox(HWND, LPSTR, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI DlgDirSelectEx(HWND, LPSTR, int, int);
BOOL    WINAPI DlgDirSelectComboBoxEx(HWND, LPSTR, int, int);
#endif  /* WINVER >= 0x030a */

#define LBD_UPPERCASE   0x8001     /* ;Internal */
#define LBD_SIZE        0x8002     /* ;Internal */
#define LBD_DATE        0x8004     /* ;Internal */
#define LBD_TIME        0x8008     /* ;Internal */
#define LBD_ATTRIBUTE   0x8010     /* ;Internal */
#define LBD_FULLDETAILS 0x801E     /* ;Internal */
#define LBD_SENDDETAILS 0x8020     /* ;Internal */

/* DlgDirList, DlgDirListComboBox flags values */
#define DDL_READWRITE       0x0000
#define DDL_READONLY        0x0001
#define DDL_HIDDEN          0x0002
#define DDL_SYSTEM          0x0004
#define DDL_DIRECTORY       0x0010
#define DDL_ARCHIVE         0x0020

#define DDL_POSTMSGS        0x2000
#define DDL_DRIVES          0x4000
#define DDL_EXCLUSIVE       0x8000
#define DDL_VALID           0xe03f      /* ;Internal */

#endif  /* NOCTLMGR */

/****** Combo box control **************************************************/

#ifndef NOCTLMGR

/* Combo box styles */
#ifndef NOWINSTYLES
#define CBS_SIMPLE            0x0001L
#define CBS_DROPDOWN          0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#if (WINVER >= 0x030a)
#define CBS_DISABLENOSCROLL   0x0800L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Combo box messages */
#ifndef NOWINMESSAGES
#define CB_GETEDITSEL            (WM_USER+0)
#define CB_LIMITTEXT             (WM_USER+1)
#define CB_SETEDITSEL            (WM_USER+2)
#define CB_ADDSTRING             (WM_USER+3)
#define CB_DELETESTRING          (WM_USER+4)
#define CB_DIR                   (WM_USER+5)
#define CB_GETCOUNT              (WM_USER+6)
#define CB_GETCURSEL             (WM_USER+7)
#define CB_GETLBTEXT             (WM_USER+8)
#define CB_GETLBTEXTLEN          (WM_USER+9)
#define CB_INSERTSTRING          (WM_USER+10)
#define CB_RESETCONTENT          (WM_USER+11)
#define CB_FINDSTRING            (WM_USER+12)
#define CB_SELECTSTRING          (WM_USER+13)
#define CB_SETCURSEL             (WM_USER+14)
#define CB_SHOWDROPDOWN          (WM_USER+15)
#define CB_GETITEMDATA           (WM_USER+16)
#define CB_SETITEMDATA           (WM_USER+17)
#if (WINVER >= 0x030a)
#define CB_GETDROPPEDCONTROLRECT (WM_USER+18)
#define CB_SETITEMHEIGHT         (WM_USER+19)
#define CB_GETITEMHEIGHT         (WM_USER+20)
#define CB_SETEXTENDEDUI         (WM_USER+21)
#define CB_GETEXTENDEDUI         (WM_USER+22)
#define CB_GETDROPPEDSTATE       (WM_USER+23)
#define CB_FINDSTRINGEXACT       (WM_USER+24)
#endif  /* WINVER >= 0x030a */
#define CB_MSGMAX                (WM_USER+25)       /* ;Internal */

#endif  /* NOWINMESSAGES */

/* Combo box notification codes */
#define CBN_ERRSPACE        (-1)
#define CBN_SELCHANGE       1
#define CBN_DBLCLK          2
#define CBN_SETFOCUS        3
#define CBN_KILLFOCUS       4
#define CBN_EDITCHANGE      5
#define CBN_EDITUPDATE      6
#define CBN_DROPDOWN        7
#if (WINVER >= 0x030a)
#define CBN_CLOSEUP         8
#define CBN_SELENDOK        9
#define CBN_SELENDCANCEL    10
#endif  /* WINVER >= 0x030a */

/* Combo box message return values */
#define CB_OKAY             0
#define CB_ERR              (-1)
#define CB_ERRSPACE         (-2)

#endif  /* NOCTLMGR */

/******* Windows hook support **********************************************/

#ifndef NOWH

DECLARE_HANDLE32(HHOOK);

#ifdef STRICT
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
#else
typedef FARPROC HOOKPROC;
#endif

#ifdef STRICT
HHOOK   WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HHOOK FAR*);
#else
HOOKPROC WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HOOKPROC FAR*);
#endif
BOOL    WINAPI UnhookWindowsHook(int, HOOKPROC);

#if (WINVER >= 0x030a)

HHOOK   WINAPI SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hInstance, HTASK hTask);
BOOL    WINAPI UnhookWindowsHookEx(HHOOK hHook);
LRESULT WINAPI CallNextHookEx(HHOOK hHook, int code, WPARAM wParam, LPARAM lParam);

#endif  /* WINVER >= 0x030a */

#define WH_MIN              (-1)                            /* ;Internal */
#define WH_MAX              10                              /* ;Internal */
#define WH_MINHOOK          WH_MIN                          /* ;Internal */
#define WH_MAXHOOK          WH_MAX                          /* ;Internal */
#define WH_CHOOKS           (WH_MAXHOOK - WH_MINHOOK + 1)   /* ;Internal */

/* Standard hook code */
#define HC_ACTION           0

/* Obsolete hook codes (NO LONGER SUPPORTED) */
#define HC_GETLPLPFN        (-3)
#define HC_LPLPFNNEXT       (-2)
#define HC_LPFNNEXT         (-1)

#endif  /* NOWH */

/****** Computer-based-training (CBT) support *******************************/

#define WM_QUEUESYNC        0x0023

#ifndef NOWH

/* SetWindowsHook() code */
#define WH_CBT              5

#define HCBT_MOVESIZE       0
#define HCBT_MINMAX         1
#define HCBT_QS             2
#define HCBT_CREATEWND      3
#define HCBT_DESTROYWND     4
#define HCBT_ACTIVATE       5
#define HCBT_CLICKSKIPPED   6
#define HCBT_KEYSKIPPED     7
#define HCBT_SYSCOMMAND     8
#define HCBT_SETFOCUS       9

#if (WINVER >= 0x030a)
/* HCBT_CREATEWND parameters pointed to by lParam */
typedef struct tagCBT_CREATEWND
{
    CREATESTRUCT FAR* lpcs;
    HWND    hwndInsertAfter;
} CBT_CREATEWND;
typedef CBT_CREATEWND FAR* LPCBT_CREATEWND;

/* HCBT_ACTIVATE structure pointed to by lParam */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Hardware hook support ***********************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
#define WH_HARDWARE         8

typedef struct tagHARDWAREHOOKSTRUCT
{
    HWND    hWnd;
    UINT    wMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT;
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Shell support *******************************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
/* SetWindowsHook() Shell hook code */
#define WH_SHELL           10

#define HSHELL_WINDOWCREATED       1
#define HSHELL_WINDOWDESTROYED     2
#define HSHELL_ACTIVATESHELLWINDOW 3

#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Journalling support *************************************************/

#ifndef NOWH
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1

/* Journalling hook codes */
#define HC_GETNEXT          1
#define HC_SKIP             2
#define HC_NOREMOVE         3
#define HC_NOREM            HC_NOREMOVE
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF      5

/* Journalling message structure */
typedef struct tagEVENTMSG
{
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD   time;
} EVENTMSG;
typedef EVENTMSG *PEVENTMSG;
typedef EVENTMSG *PEVENTMSGMSG;                 /* ;Internal */
typedef EVENTMSG NEAR* NPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSGMSG;            /* ;Internal */

BOOL    WINAPI EnableHardwareInput(BOOL);

#endif  /* NOWH */


/****** Debugger support ****************************************************/

#if (WINVER >= 0x030a)
/* SetWindowsHook debug hook support */
#define WH_DEBUG            9

typedef struct tagDEBUGHOOKINFO
{
    HMODULE     hModuleHook;
    LPARAM      reserved;
    LPARAM      lParam;
    WPARAM      wParam;
    int         code;
} DEBUGHOOKINFO;
typedef DEBUGHOOKINFO FAR* LPDEBUGHOOKINFO;

#ifndef NOMSG
BOOL WINAPI QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg);
#endif  /* NOMSG */

BOOL WINAPI LockInput(HANDLE h1, HWND hwndInput, BOOL fLock);

LONG WINAPI GetSystemDebugState(void);
/* Flags returned by GetSystemDebugState.
 */
#define SDS_MENU        0x0001
#define SDS_SYSMODAL    0x0002
#define SDS_NOTASKQUEUE 0x0004
#define SDS_DIALOG      0x0008
#define SDS_TASKLOCKED  0x0010
#endif  /* WINVER >= 0x030a */

/****** Help support ********************************************************/

#ifndef NOHELP

BOOL WINAPI WinHelp(HWND hwndMain, LPCSTR lpszHelp, UINT usCommand, DWORD ulData);

/* WinHelp() commands */
#define HELP_CONTEXT      0x0001
#define HELP_QUIT         0x0002
#define HELP_INDEX        0x0003
#define HELP_CONTENTS     0x0003
#define HELP_HELPONHELP   0x0004
#define HELP_SETINDEX     0x0005
#define HELP_SETCONTENTS  0x0005
#define HELP_CONTEXTPOPUP 0x0008
#define HELP_FORCEFILE    0x0009
#define HELP_KEY          0x0101
#define HELP_COMMAND      0x0102
#define HELP_PARTIALKEY   0x0105
#define HELP_MULTIKEY     0x0201
#define HELP_SETWINPOS    0x0203

typedef struct tagMULTIKEYHELP
{
    UINT    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
} MULTIKEYHELP;


typedef struct
{
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    char rgchMember[2];
} HELPWININFO;
typedef HELPWININFO NEAR* PHELPWININFO;
typedef HELPWININFO FAR* LPHELPWININFO;

#endif  /* NOHELP */

/****** Sound support ******************************************************/

#ifndef NOSOUND

int     WINAPI OpenSound(void);
void    WINAPI CloseSound(void);

int     WINAPI StartSound(void);
int     WINAPI StopSound(void);

int     WINAPI SetVoiceQueueSize(int, int);
int     WINAPI SetVoiceNote(int, int, int, int);
int     WINAPI SetVoiceAccent(int, int, int, int, int);
int     WINAPI SetVoiceEnvelope(int, int, int);
int     WINAPI SetVoiceSound(int, DWORD, int);

int     WINAPI SetVoiceThreshold(int, int);
int FAR* WINAPI GetThresholdEvent(void);
int     WINAPI GetThresholdStatus(void);

int     WINAPI SetSoundNoise(int, int);

/* SetSoundNoise() Sources */
#define S_PERIOD512   0
#define S_PERIOD1024  1
#define S_PERIOD2048  2
#define S_PERIODVOICE 3
#define S_WHITE512    4
#define S_WHITE1024   5
#define S_WHITE2048   6
#define S_WHITEVOICE  7

int     WINAPI WaitSoundState(int);

/* WaitSoundState() constants */
#define S_QUEUEEMPTY        0
#define S_THRESHOLD         1
#define S_ALLTHRESHOLD      2

int     WINAPI SyncAllVoices(void);
int     WINAPI CountVoiceNotes(int);

/* Accent Modes */
#define S_NORMAL      0
#define S_LEGATO      1
#define S_STACCATO    2

/* Error return values */
#define S_SERDVNA     (-1)
#define S_SEROFM      (-2)
#define S_SERMACT     (-3)
#define S_SERQFUL     (-4)
#define S_SERBDNT     (-5)
#define S_SERDLN      (-6)
#define S_SERDCC      (-7)
#define S_SERDTP      (-8)
#define S_SERDVL      (-9)
#define S_SERDMD      (-10)
#define S_SERDSH      (-11)
#define S_SERDPT      (-12)
#define S_SERDFQ      (-13)
#define S_SERDDR      (-14)
#define S_SERDSR      (-15)
#define S_SERDST      (-16)

#endif  /* NOSOUND */

/****** Comm support ******************************************************/

#ifndef NOCOMM

#define NOPARITY            0
#define ODDPARITY           1
#define EVENPARITY          2
#define MARKPARITY          3
#define SPACEPARITY         4

#define ONESTOPBIT          0
#define ONE5STOPBITS        1
#define TWOSTOPBITS         2

#define IGNORE              0
#define INFINITE            0xFFFF

/* Error Flags */
#define CE_RXOVER           0x0001
#define CE_OVERRUN          0x0002
#define CE_RXPARITY         0x0004
#define CE_FRAME            0x0008
#define CE_BREAK            0x0010
#define CE_CTSTO            0x0020
#define CE_DSRTO            0x0040
#define CE_RLSDTO           0x0080
#define CE_TXFULL           0x0100
#define CE_PTO              0x0200
#define CE_IOE              0x0400
#define CE_DNS              0x0800
#define CE_OOP              0x1000
#define CE_MODE             0x8000

#define IE_BADID            (-1)
#define IE_OPEN             (-2)
#define IE_NOPEN            (-3)
#define IE_MEMORY           (-4)
#define IE_DEFAULT          (-5)
#define IE_HARDWARE         (-10)
#define IE_BYTESIZE         (-11)
#define IE_BAUDRATE         (-12)

/* Events */
#define EV_RXCHAR           0x0001
#define EV_RXFLAG           0x0002
#define EV_TXEMPTY          0x0004
#define EV_CTS              0x0008
#define EV_DSR              0x0010
#define EV_RLSD             0x0020
#define EV_BREAK            0x0040
#define EV_ERR              0x0080
#define EV_RING             0x0100
#define EV_PERR             0x0200
#define EV_CTSS             0x0400
#define EV_DSRS             0x0800
#define EV_RLSDS            0x1000
#define EV_RingTe           0x2000
#define EV_RINGTE           EV_RingTe
#define EV_VALID            0x3fff  /* ;Internal */

/* Escape Functions */
#define SETXOFF             1
#define SETXON              2
#define SETRTS              3
#define CLRRTS              4
#define SETDTR              5
#define CLRDTR              6
#define RESETDEV            7

#define LPTx                0x80

#if (WINVER >= 0x030a)

/* new escape functions */
#define GETMAXLPT           8
#define GETMAXCOM           9
#define GETBASEIRQ          10

/* Comm Baud Rate indices */
#define CBR_110      0xFF10
#define CBR_300      0xFF11
#define CBR_600      0xFF12
#define CBR_1200     0xFF13
#define CBR_2400     0xFF14
#define CBR_4800     0xFF15
#define CBR_9600     0xFF16
#define CBR_14400    0xFF17
#define CBR_19200    0xFF18
#define CBR_38400    0xFF1B
#define CBR_56000    0xFF1F
#define CBR_128000   0xFF23
#define CBR_256000   0xFF27

/* notifications passed in low word of lParam on WM_COMMNOTIFY messages */
#define CN_RECEIVE  0x0001
#define CN_TRANSMIT 0x0002
#define CN_EVENT    0x0004

#endif  /* WINVER >= 0x030a */

typedef struct tagDCB
{
    BYTE Id;
    UINT BaudRate;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    UINT RlsTimeout;
    UINT CtsTimeout;
    UINT DsrTimeout;

    UINT fBinary        :1;
    UINT fRtsDisable    :1;
    UINT fParity        :1;
    UINT fOutxCtsFlow   :1;
    UINT fOutxDsrFlow   :1;
    UINT fDummy         :2;
    UINT fDtrDisable    :1;

    UINT fOutX          :1;
    UINT fInX           :1;
    UINT fPeChar        :1;
    UINT fNull          :1;
    UINT fChEvt         :1;
    UINT fDtrflow       :1;
    UINT fRtsflow       :1;
    UINT fDummy2        :1;

    char XonChar;
    char XoffChar;
    UINT XonLim;
    UINT XoffLim;
    char PeChar;
    char EofChar;
    char EvtChar;
    UINT TxDelay;
} DCB;
typedef DCB FAR* LPDCB;

#if (defined(STRICT) | (WINVER >= 0x030a))

typedef struct tagCOMSTAT
{
    BYTE status;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#define CSTF_CTSHOLD    0x01
#define CSTF_DSRHOLD    0x02
#define CSTF_RLSDHOLD   0x04
#define CSTF_XOFFHOLD   0x08
#define CSTF_XOFFSENT   0x10
#define CSTF_EOF        0x20
#define CSTF_TXIM       0x40

#else   /* (STRICT | WINVER >= 0x030a) */

/* NOTE: This structure declaration is not ANSI compatible! */
typedef struct tagCOMSTAT
{
    BYTE fCtsHold  :1;
    BYTE fDsrHold  :1;
    BYTE fRlsdHold :1;
    BYTE fXoffHold :1;
    BYTE fXoffSent :1;
    BYTE fEof      :1;
    BYTE fTxim     :1;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#endif  /* !(STRICT | WINVER >= 0x030a */

int     WINAPI BuildCommDCB(LPCSTR, DCB FAR*);

int     WINAPI OpenComm(LPCSTR, UINT, UINT);
int     WINAPI CloseComm(int);

int     WINAPI ReadComm(int, void FAR*, int);
int     WINAPI WriteComm(int, const void FAR*, int);
int     WINAPI UngetCommChar(int, char);
int     WINAPI FlushComm(int, int);
int     WINAPI TransmitCommChar(int, char);

int     WINAPI SetCommState(const DCB FAR*);
int     WINAPI GetCommState(int, DCB FAR*);
int     WINAPI GetCommError(int, COMSTAT FAR* );

int     WINAPI SetCommBreak(int);
int     WINAPI ClearCommBreak(int);

UINT FAR* WINAPI SetCommEventMask(int, UINT);
UINT    WINAPI GetCommEventMask(int, int);

LONG    WINAPI EscapeCommFunction(int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI EnableCommNotification(int, HWND, int, int);

#define WM_COMMNOTIFY           0x0044
#endif  /* WINVER >= 0x030a */

#endif  /* NOCOMM */

/****** String formatting support *******************************************/

int     WINAPI wvsprintf(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams);

int     FAR CDECL wsprintf(LPSTR lpszOut, LPCSTR lpszFmt, ...);


/****** Driver support ******************************************************/

#if (WINVER >= 0x030a)

#ifndef NODRIVERS

DECLARE_HANDLE(HDRVR);

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

/* Driver messages */
#define DRV_LOAD                0x0001
#define DRV_ENABLE              0x0002
#define DRV_OPEN                0x0003
#define DRV_CLOSE               0x0004
#define DRV_DISABLE             0x0005
#define DRV_FREE                0x0006
#define DRV_CONFIGURE           0x0007
#define DRV_QUERYCONFIGURE      0x0008
#define DRV_INSTALL             0x0009
#define DRV_REMOVE              0x000A
#define DRV_EXITSESSION         0x000B
#define DRV_EXITAPPLICATION     0x000C
#define DRV_POWER               0x000F

#define DRV_RESERVED            0x0800
#define DRV_USER                0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO
{
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO NEAR* PDRVCONFIGINFO;
typedef DRVCONFIGINFO FAR* LPDRVCONFIGINFO;

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL           0x0000
#define DRVCNF_OK               0x0001
#define DRVCNF_RESTART          0x0002

/* Supported lParam1 of DRV_EXITAPPLICATION notification */
#define DRVEA_NORMALEXIT            0x0001
#define DRVEA_ABNORMALEXIT          0x0002

LRESULT WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID, UINT message, LPARAM lParam1, LPARAM lParam2);

HDRVR   WINAPI OpenDriver(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT WINAPI CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);

LRESULT WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);

HINSTANCE WINAPI GetDriverModuleHandle(HDRVR hDriver);

HDRVR   WINAPI GetNextDriver(HDRVR, DWORD);

/* GetNextDriver flags */
#define GND_FIRSTINSTANCEONLY   0x00000001

#define GND_FORWARD             0x00000000
#define GND_REVERSE             0x00000002
#define GND_VALID               0x00000003  /* ;Internal */

typedef struct tagDRIVERINFOSTRUCT
{
    UINT    length;
    HDRVR   hDriver;
    HINSTANCE hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT;
typedef DRIVERINFOSTRUCT FAR* LPDRIVERINFOSTRUCT;

BOOL    WINAPI GetDriverInfo(HDRVR, DRIVERINFOSTRUCT FAR*);

#endif  /* !NODRIVERS */
#endif  /* WINVER >= 0x030a */
#endif  /* NOUSER */

#ifndef NOWINDOWSX          /* ;Internal */
#ifndef RC_INVOKED          /* ;Internal */
#include "windowsx.h"       /* ;Internal */
#ifndef STRICT              /* ;Internal */
#undef  SelectFont          /* ;Internal */
#endif  /* STRICT */        /* ;Internal */
#endif  /* RC_INVOKED */    /* ;Internal */
#endif  /* NOWINDOWSX */    /* ;Internal */
#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifndef NODBCS
#ifdef DBCS
#if defined (JAPAN)
#define    NATIVE_CHARSET       SHIFTJIS_CHARSET
#elif defined (KOREA)
#define    NATIVE_CHARSET       HANGEUL_CHARSET
#elif defined (TAIWAN)
#define    NATIVE_CHARSET       CHINESEBIG5_CHARSET
#elif defined (PRC)
#define    NATIVE_CHARSET       GB2312_CHARSET
#else
#define    NATIVE_CHARSET       ANSI_CHARSET
#endif
#endif
#endif


#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_WINDOWS */


// WOW Section //

int  FAR PASCAL WowGetNextVdmCommand(LPVOID);
int  FAR PASCAL WOWRegisterShellWindowHandle(HWND,LPVOID, HWND);
int  FAR PASCAL WowFailedExec(void);
void FAR PASCAL ExitKernelThunk(WORD wExitCode);
WORD FAR PASCAL WowSetExitOnLastApp(WORD fExitOnLastApp);

// Pickup WOW Generic Thunk Interfaces from wownt16,h //

#include "wownt16.h"

// this is a prototype.  CallProc32W is a messed up vararg function
// however rasapi16.c uses it.

#ifndef NO_CALLPROC32_DECL
DWORD FAR PASCAL CallProc32W(LPVOID, DWORD, DWORD);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\addsect\addsect.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//
//  Copyright (C) Microsoft Corporation, 1996-2001.
//
//  File:       addsect.cpp
//
//  Contents:   Add a data section to a PE binary.
//
//  History:    01-Nov-2000     GalenH      Created from Detours setdll.cpp.
//
//////////////////////////////////////////////////////////////////////////////

#define UNICODE
#define _UNICODE

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define arrayof(a)      (sizeof(a)/sizeof(a[0]))

///////////////////////////////////////////////////////////////////////////////
//
class CImage
{
  public:
    CImage();
    ~CImage();

  public:                                                   // File Functions
    BOOL                    Read(HANDLE hFile);
    BOOL                    Check(PCSTR pszSection);
    BOOL                    Write(HANDLE hFile, PBYTE pbData, UINT cbData,
                                  PCSTR pszSection);
    BOOL                    Close();

  public:                                                   // Manipulation Functions
    PBYTE                   DataSet(PBYTE pbData, DWORD cbData);

  protected:
    BOOL                    CopyFileData(HANDLE hFile, DWORD nOldPos, DWORD cbData);
    BOOL                    ZeroFileData(HANDLE hFile, DWORD cbData);
    BOOL                    AlignFileData(HANDLE hFile);

    BOOL                    SizeOutputBuffer(DWORD cbData);
    PBYTE                   AllocateOutput(DWORD cbData, DWORD *pnVirtAddr);

    PVOID                   RvaToVa(DWORD nRva);
    DWORD                   RvaToFileOffset(DWORD nRva);

    DWORD                   FileAlign(DWORD nAddr);
    DWORD                   SectionAlign(DWORD nAddr);

  private:
    HANDLE                  m_hMap;                     // Read & Write
    PBYTE                   m_pMap;                     // Read & Write

    DWORD                   m_nNextFileAddr;            // Write
    DWORD                   m_nNextVirtAddr;            // Write

    BOOLEAN                 m_f64bit;

    IMAGE_FILE_HEADER       m_FileHeader;
    IMAGE_OPTIONAL_HEADER64 m_OptionalHeader;
    IMAGE_SECTION_HEADER    m_SectionHeaders[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];

    DWORD                   m_nFileHeaderOffset;
    DWORD                   m_nOptionalHeaderOffset;
    DWORD                   m_nSectionsOffset;
    DWORD                   m_nSectionsEndOffset;
    DWORD                   m_nSectionsMaxCount;
    DWORD                   m_nExtraOffset;
    DWORD                   m_nFileSize;

    PBYTE                   m_pbOutputBuffer;
    DWORD                   m_cbOutputBuffer;

    DWORD                   m_nOutputVirtAddr;
    DWORD                   m_nOutputVirtSize;
    DWORD                   m_nOutputFileAddr;
};

//////////////////////////////////////////////////////////////////////////////
//
static inline DWORD Max(DWORD a, DWORD b)
{
    return a > b ? a : b;
}

static inline DWORD Min(DWORD a, DWORD b)
{
    return a < b ? a : b;
}

static inline DWORD Align(DWORD a, DWORD size)
{
    size--;
    return (a + size) & ~size;
}

static inline DWORD QuadAlign(DWORD a)
{
    return Align(a, 8);
}

//////////////////////////////////////////////////////////////////////////////
//
CImage::CImage()
{
    m_hMap = NULL;
    m_pMap = NULL;

    m_nFileHeaderOffset = 0;
    m_nSectionsOffset = 0;

    m_pbOutputBuffer = NULL;
    m_cbOutputBuffer = 0;
}

CImage::~CImage()
{
    Close();
}

BOOL CImage::Close()
{
    if (m_pMap != NULL) {
        UnmapViewOfFile(m_pMap);
        m_pMap = NULL;
    }

    if (m_hMap) {
        CloseHandle(m_hMap);
        m_hMap = NULL;
    }

    if (m_pbOutputBuffer) {
        delete[] m_pbOutputBuffer;
        m_pbOutputBuffer = NULL;
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL CImage::SizeOutputBuffer(DWORD cbData)
{
    if (m_cbOutputBuffer < cbData) {
        if (cbData < 1024)  //65536
            cbData = 1024;
        cbData = FileAlign(cbData);

        PBYTE pOutput = new BYTE [cbData];
        if (pOutput == NULL) {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        if (m_pbOutputBuffer) {
            CopyMemory(pOutput, m_pbOutputBuffer, m_cbOutputBuffer);

            delete[] m_pbOutputBuffer;
            m_pbOutputBuffer = NULL;
        }

        ZeroMemory(pOutput + m_cbOutputBuffer, cbData - m_cbOutputBuffer),

        m_pbOutputBuffer = pOutput;
        m_cbOutputBuffer = cbData;
    }
    return TRUE;
}

PBYTE CImage::AllocateOutput(DWORD cbData, DWORD *pnVirtAddr)
{
    cbData = QuadAlign(cbData);

    PBYTE pbData = m_pbOutputBuffer + m_nOutputVirtSize;

    *pnVirtAddr = m_nOutputVirtAddr + m_nOutputVirtSize;
    m_nOutputVirtSize += cbData;

    if (m_nOutputVirtSize > m_cbOutputBuffer) {
        SetLastError(ERROR_OUTOFMEMORY);
        return NULL;
    }

    ZeroMemory(pbData, cbData);

    return pbData;
}

//////////////////////////////////////////////////////////////////////////////
//
DWORD CImage::FileAlign(DWORD nAddr)
{
    return Align(nAddr, m_OptionalHeader.FileAlignment);
}

DWORD CImage::SectionAlign(DWORD nAddr)
{
    return Align(nAddr, m_OptionalHeader.SectionAlignment);
}

//////////////////////////////////////////////////////////////////////////////
//
PVOID CImage::RvaToVa(DWORD nRva)
{
    if (nRva == 0) {
        return NULL;
    }

    for (DWORD n = 0; n < m_FileHeader.NumberOfSections; n++) {
        DWORD vaStart = m_SectionHeaders[n].VirtualAddress;
        DWORD vaEnd = vaStart + m_SectionHeaders[n].SizeOfRawData;

        if (nRva >= vaStart && nRva < vaEnd) {
            return (PBYTE)m_pMap
                + m_SectionHeaders[n].PointerToRawData
                + nRva - m_SectionHeaders[n].VirtualAddress;
        }
    }
    return NULL;
}

DWORD CImage::RvaToFileOffset(DWORD nRva)
{
    DWORD n;
    for (n = 0; n < m_FileHeader.NumberOfSections; n++) {
        DWORD vaStart = m_SectionHeaders[n].VirtualAddress;
        DWORD vaEnd = vaStart + m_SectionHeaders[n].SizeOfRawData;

        if (nRva >= vaStart && nRva < vaEnd) {
            return m_SectionHeaders[n].PointerToRawData
                + nRva - m_SectionHeaders[n].VirtualAddress;
        }
    }
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL CImage::CopyFileData(HANDLE hFile, DWORD nOldPos, DWORD cbData)
{
    DWORD cbDone = 0;
    return WriteFile(hFile, m_pMap + nOldPos, cbData, &cbDone, NULL);
}

BOOL CImage::ZeroFileData(HANDLE hFile, DWORD cbData)
{
    if (!SizeOutputBuffer(4096)) {
        return FALSE;
    }

    ZeroMemory(m_pbOutputBuffer, m_cbOutputBuffer);

    for (DWORD cbLeft = cbData; cbLeft > 0;) {
        DWORD cbStep = cbLeft > m_cbOutputBuffer ? m_cbOutputBuffer : cbLeft;
        DWORD cbDone = 0;

        if (!WriteFile(hFile, m_pbOutputBuffer, cbStep, &cbDone, NULL)) {
            return FALSE;
        }
        if (cbDone == 0)
            break;

        cbLeft -= cbDone;
    }
    return TRUE;
}

BOOL CImage::AlignFileData(HANDLE hFile)
{
    DWORD nLastFileAddr = m_nNextFileAddr;

    m_nNextFileAddr = FileAlign(m_nNextFileAddr);
    m_nNextVirtAddr = SectionAlign(m_nNextVirtAddr);

    if (hFile != INVALID_HANDLE_VALUE) {
        if (m_nNextFileAddr > nLastFileAddr) {
            if (SetFilePointer(hFile, nLastFileAddr, NULL, FILE_BEGIN) == ~0u) {
                return FALSE;
            }
            return ZeroFileData(hFile, m_nNextFileAddr - nLastFileAddr);
        }
    }
    return TRUE;
}

BOOL CImage::Read(HANDLE hFile)
{
    DWORD n;
    IMAGE_OPTIONAL_HEADER32 oh32;

    if (hFile == INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    ///////////////////////////////////////////////////////// Create mapping.
    //
    m_nFileSize = GetFileSize(hFile, NULL);
    if (m_nFileSize == ~0ul) {
        return FALSE;
    }

    m_hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (m_hMap == NULL) {
        return FALSE;
    }

    m_pMap = (PBYTE)MapViewOfFile(m_hMap, FILE_MAP_READ, 0, 0, 0);
    if (m_pMap == NULL) {
        return FALSE;
    }

    ////////////////////////////////////////////////////// Process DOS Header.
    //
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)m_pMap;
    if (pDosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
        m_nFileHeaderOffset = pDosHeader->e_lfanew + sizeof(DWORD);
        m_nOptionalHeaderOffset = m_nFileHeaderOffset + sizeof(m_FileHeader);

    }
    else {
        m_nFileHeaderOffset = 0;
        m_nOptionalHeaderOffset = m_nFileHeaderOffset + sizeof(m_FileHeader);
    }

    /////////////////////////////////////////////////////// Process PE Header.
    //
    CopyMemory(&m_FileHeader, m_pMap + m_nFileHeaderOffset, sizeof(m_FileHeader));
    if (m_FileHeader.SizeOfOptionalHeader == 0) {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return FALSE;
    }

    ///////////////////////////////////////////////// Process Optional Header.
    //
    CopyMemory(&oh32, m_pMap + m_nOptionalHeaderOffset, sizeof(oh32));

    if (oh32.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
    {
        // Convert 32-bit optional header to internal 64-bit optional header
        m_f64bit = FALSE;

        ZeroMemory(&m_OptionalHeader, sizeof(m_OptionalHeader));
        m_OptionalHeader.Magic = oh32.Magic;
        m_OptionalHeader.MajorLinkerVersion = oh32.MajorLinkerVersion;
        m_OptionalHeader.MinorLinkerVersion = oh32.MinorLinkerVersion;
        m_OptionalHeader.SizeOfCode = oh32.SizeOfCode;
        m_OptionalHeader.SizeOfInitializedData = oh32.SizeOfInitializedData;
        m_OptionalHeader.SizeOfUninitializedData = oh32.SizeOfUninitializedData;
        m_OptionalHeader.AddressOfEntryPoint = oh32.AddressOfEntryPoint;
        m_OptionalHeader.BaseOfCode = oh32.BaseOfCode;
        m_OptionalHeader.ImageBase = oh32.ImageBase;
        m_OptionalHeader.SectionAlignment = oh32.SectionAlignment;
        m_OptionalHeader.FileAlignment = oh32.FileAlignment;
        m_OptionalHeader.MajorOperatingSystemVersion = oh32.MajorOperatingSystemVersion;
        m_OptionalHeader.MinorOperatingSystemVersion = oh32.MinorOperatingSystemVersion;
        m_OptionalHeader.MajorImageVersion = oh32.MajorImageVersion;
        m_OptionalHeader.MinorImageVersion = oh32.MinorImageVersion;
        m_OptionalHeader.MajorSubsystemVersion = oh32.MajorSubsystemVersion;
        m_OptionalHeader.MinorSubsystemVersion = oh32.MinorSubsystemVersion;
        m_OptionalHeader.Win32VersionValue = oh32.Win32VersionValue;
        m_OptionalHeader.SizeOfImage = oh32.SizeOfImage;
        m_OptionalHeader.SizeOfHeaders = oh32.SizeOfHeaders;
        m_OptionalHeader.CheckSum = oh32.CheckSum;
        m_OptionalHeader.Subsystem = oh32.Subsystem;
        m_OptionalHeader.DllCharacteristics = oh32.DllCharacteristics;
        m_OptionalHeader.SizeOfStackReserve = oh32.SizeOfStackReserve;
        m_OptionalHeader.SizeOfStackCommit = oh32.SizeOfStackCommit;
        m_OptionalHeader.SizeOfHeapReserve = oh32.SizeOfHeapReserve;
        m_OptionalHeader.SizeOfHeapCommit = oh32.SizeOfHeapCommit;
        m_OptionalHeader.LoaderFlags = oh32.LoaderFlags;
        m_OptionalHeader.NumberOfRvaAndSizes = oh32.NumberOfRvaAndSizes;

        for (n = 0; n < oh32.NumberOfRvaAndSizes; n++)
        {
            m_OptionalHeader.DataDirectory[n] = oh32.DataDirectory[n];
        }
    }
    else if (oh32.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
    {
        m_f64bit = TRUE;
        CopyMemory(&m_OptionalHeader,
                   m_pMap + m_nOptionalHeaderOffset, sizeof(m_OptionalHeader));
    }
    else
    {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return FALSE;
    }
    m_nSectionsOffset = m_nOptionalHeaderOffset + m_FileHeader.SizeOfOptionalHeader;

    ///////////////////////////////////////////////// Process Section Headers.
    //
    if (m_FileHeader.NumberOfSections > arrayof(m_SectionHeaders)) {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return FALSE;
    }
    CopyMemory(&m_SectionHeaders,
               m_pMap + m_nSectionsOffset,
               sizeof(m_SectionHeaders[0]) * m_FileHeader.NumberOfSections);

    ////////////////////////////////////////////////////////// Parse Sections.
    //
    m_nSectionsEndOffset = m_nSectionsOffset + sizeof(m_SectionHeaders);
    m_nExtraOffset = 0;
    for (n = 0; n < m_FileHeader.NumberOfSections; n++) {
        m_nExtraOffset = Max(m_SectionHeaders[n].PointerToRawData +
                             m_SectionHeaders[n].SizeOfRawData,
                             m_nExtraOffset);

        if (m_SectionHeaders[n].PointerToRawData != 0) {
            m_nSectionsEndOffset = Min(m_SectionHeaders[n].PointerToRawData,
                                       m_nSectionsEndOffset);
        }
    }

    m_nSectionsMaxCount = (m_nSectionsEndOffset - m_nSectionsOffset)
        / sizeof(IMAGE_SECTION_HEADER);

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL CImage::Check(PCSTR pszSection)
{
    CHAR szName[IMAGE_SIZEOF_SHORT_NAME];

    ZeroMemory(szName, sizeof(szName));
    strncpy(szName, pszSection, sizeof(szName));

    if ((DWORD)(m_FileHeader.NumberOfSections + 1) > m_nSectionsMaxCount) {
        SetLastError(ERROR_EXE_MARKED_INVALID);
        return FALSE;
    }

    for (DWORD n = 0; n < m_FileHeader.NumberOfSections; n++) {
        if (memcmp(szName, m_SectionHeaders[n].Name, sizeof(szName)) == 0)
        {
            SetLastError(ERROR_DUPLICATE_TAG);
            return FALSE;
        }
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL CImage::Write(HANDLE hFile, PBYTE pbSectData, UINT cbSectData, PCSTR pszSection)
{
    if (hFile == INVALID_HANDLE_VALUE) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    m_nNextFileAddr = 0;
    m_nNextVirtAddr = 0;

    //////////////////////////////////////////////////////////// Copy Headers.
    //
    if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == ~0u) {
        return FALSE;
    }
    if (!CopyFileData(hFile, 0, m_OptionalHeader.SizeOfHeaders)) {
        return FALSE;
    }

    m_nNextFileAddr = m_OptionalHeader.SizeOfHeaders;
    m_nNextVirtAddr = 0;
    if (!AlignFileData(hFile)) {
        return FALSE;
    }

    /////////////////////////////////////////////////////////// Copy Sections.
    //
    for (DWORD n = 0; n < m_FileHeader.NumberOfSections; n++) {
        if (m_SectionHeaders[n].SizeOfRawData) {
            if (SetFilePointer(hFile,
                               m_SectionHeaders[n].PointerToRawData,
                               NULL, FILE_BEGIN) == ~0u) {
                return FALSE;
            }
            if (!CopyFileData(hFile,
                              m_SectionHeaders[n].PointerToRawData,
                              m_SectionHeaders[n].SizeOfRawData)) {
                return FALSE;
            }
        }
        m_nNextFileAddr = Max(m_SectionHeaders[n].PointerToRawData +
                              m_SectionHeaders[n].SizeOfRawData,
                              m_nNextFileAddr);
        m_nNextVirtAddr = Max(m_SectionHeaders[n].VirtualAddress +
                              m_SectionHeaders[n].Misc.VirtualSize,
                              m_nNextVirtAddr);
        m_nExtraOffset = Max(m_nNextFileAddr, m_nExtraOffset);

        if (!AlignFileData(hFile)) {
            return FALSE;
        }
    }

    /////////////////////////////////////////////////////////////// Old WriteSection
    DWORD cbDone;

    if (pbSectData) {

        /////////////////////////////////////////////////// Insert .detour Section.
        //
        DWORD nSection = m_FileHeader.NumberOfSections++;

        ZeroMemory(&m_SectionHeaders[nSection], sizeof(m_SectionHeaders[nSection]));

        strcpy((PCHAR)m_SectionHeaders[nSection].Name, pszSection);
        m_SectionHeaders[nSection].Characteristics
            = IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ;

        m_nOutputVirtAddr = m_nNextVirtAddr;
        m_nOutputVirtSize = 0;
        m_nOutputFileAddr = m_nNextFileAddr;

        //////////////////////////////////////////////////////////////////////////
        //
        if (!SizeOutputBuffer(QuadAlign(cbSectData))) {
            return FALSE;
        }

        DWORD vaData = 0;
        PBYTE pbData = NULL;

        if ((pbData = AllocateOutput(cbSectData, &vaData)) == NULL) {
            return FALSE;
        }

        CopyMemory(pbData, pbSectData, cbSectData);

        //////////////////////////////////////////////////////////////////////////
        //
        m_nNextVirtAddr += m_nOutputVirtSize;
        m_nNextFileAddr += FileAlign(m_nOutputVirtSize);

        if (!AlignFileData(hFile)) {
            return FALSE;
        }

        //////////////////////////////////////////////////////////////////////////
        //
        m_SectionHeaders[nSection].VirtualAddress = m_nOutputVirtAddr;
        m_SectionHeaders[nSection].Misc.VirtualSize = m_nOutputVirtSize;
        m_SectionHeaders[nSection].PointerToRawData = m_nOutputFileAddr;
        m_SectionHeaders[nSection].SizeOfRawData = FileAlign(m_nOutputVirtSize);

        m_OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = 0;
        m_OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = 0;

        //////////////////////////////////////////////////////////////////////////
        //
        if (SetFilePointer(hFile, m_SectionHeaders[nSection].PointerToRawData,
                           NULL, FILE_BEGIN) == ~0u) {
            return FALSE;
        }
        if (!WriteFile(hFile, pbData, m_SectionHeaders[nSection].SizeOfRawData,
                       &cbDone, NULL)) {
            return FALSE;
        }
    }

    ///////////////////////////////////////////////////// Adjust Extra Data.
    //
    LONG nExtraAdjust = m_nNextFileAddr - m_nExtraOffset;
    for (n = 0; n < m_FileHeader.NumberOfSections; n++) {
        if (m_SectionHeaders[n].PointerToRawData > m_nExtraOffset)
            m_SectionHeaders[n].PointerToRawData += nExtraAdjust;
        if (m_SectionHeaders[n].PointerToRelocations > m_nExtraOffset)
            m_SectionHeaders[n].PointerToRelocations += nExtraAdjust;
        if (m_SectionHeaders[n].PointerToLinenumbers > m_nExtraOffset)
            m_SectionHeaders[n].PointerToLinenumbers += nExtraAdjust;
    }
    if (m_FileHeader.PointerToSymbolTable > m_nExtraOffset)
        m_FileHeader.PointerToSymbolTable += nExtraAdjust;

    m_OptionalHeader.CheckSum = 0;
    m_OptionalHeader.SizeOfImage = m_nNextVirtAddr;

    ////////////////////////////////////////////////// Adjust Debug Directory.
    //
    DWORD debugAddr = m_OptionalHeader
        .DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
    DWORD debugSize = m_OptionalHeader
        .DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size;
    if (debugAddr && debugSize) {
        DWORD nFileOffset = RvaToFileOffset(debugAddr);
        if (SetFilePointer(hFile, nFileOffset, NULL, FILE_BEGIN) == ~0u) {
            return FALSE;
        }

        PIMAGE_DEBUG_DIRECTORY pDir = (PIMAGE_DEBUG_DIRECTORY)RvaToVa(debugAddr);
        if (pDir == NULL) {
            return FALSE;
        }

        DWORD nEntries = debugSize / sizeof(*pDir);
        for (DWORD n = 0; n < nEntries; n++) {
            IMAGE_DEBUG_DIRECTORY dir = pDir[n];

            if (dir.PointerToRawData > m_nExtraOffset) {
                dir.PointerToRawData += nExtraAdjust;
            }
            if (!WriteFile(hFile, &dir, sizeof(dir), &cbDone, NULL)) {
                return FALSE;
            }
        }
    }

    ///////////////////////////////////////////////// Copy Left-over Data.
    //
    if (m_nFileSize > m_nExtraOffset) {
        if (SetFilePointer(hFile, m_nNextFileAddr, NULL, FILE_BEGIN) == ~0u) {
            return FALSE;
        }
        if (!CopyFileData(hFile, m_nExtraOffset, m_nFileSize - m_nExtraOffset)) {
            return FALSE;
        }
    }

    //////////////////////////////////////////////////// Finalize Headers.
    //

    if (SetFilePointer(hFile, m_nFileHeaderOffset, NULL, FILE_BEGIN) == ~0u) {
        return FALSE;
    }
    if (!WriteFile(hFile, &m_FileHeader, sizeof(m_FileHeader), &cbDone, NULL)) {
        return FALSE;
    }
    if (SetFilePointer(hFile, m_nOptionalHeaderOffset, NULL, FILE_BEGIN) == ~0u) {
        return FALSE;
    }
    if (m_f64bit)
    {
        if (!WriteFile(hFile, &m_OptionalHeader, sizeof(m_OptionalHeader),
                       &cbDone, NULL)) {

            return FALSE;
        }
    }
    else
    {
        // Convert 32-bit optional header to internal 64-bit optional header
        IMAGE_OPTIONAL_HEADER32 oh32;

        ZeroMemory(&oh32, sizeof(oh32));
        oh32.Magic = m_OptionalHeader.Magic;
        oh32.MajorLinkerVersion = m_OptionalHeader.MajorLinkerVersion;
        oh32.MinorLinkerVersion = m_OptionalHeader.MinorLinkerVersion;
        oh32.SizeOfCode = m_OptionalHeader.SizeOfCode;
        oh32.SizeOfInitializedData = m_OptionalHeader.SizeOfInitializedData;
        oh32.SizeOfUninitializedData = m_OptionalHeader.SizeOfUninitializedData;
        oh32.AddressOfEntryPoint = m_OptionalHeader.AddressOfEntryPoint;
        oh32.BaseOfCode = m_OptionalHeader.BaseOfCode;
        oh32.ImageBase = (ULONG)m_OptionalHeader.ImageBase;
        oh32.SectionAlignment = m_OptionalHeader.SectionAlignment;
        oh32.FileAlignment = m_OptionalHeader.FileAlignment;
        oh32.MajorOperatingSystemVersion = m_OptionalHeader.MajorOperatingSystemVersion;
        oh32.MinorOperatingSystemVersion = m_OptionalHeader.MinorOperatingSystemVersion;
        oh32.MajorImageVersion = m_OptionalHeader.MajorImageVersion;
        oh32.MinorImageVersion = m_OptionalHeader.MinorImageVersion;
        oh32.MajorSubsystemVersion = m_OptionalHeader.MajorSubsystemVersion;
        oh32.MinorSubsystemVersion = m_OptionalHeader.MinorSubsystemVersion;
        oh32.Win32VersionValue = m_OptionalHeader.Win32VersionValue;
        oh32.SizeOfImage = m_OptionalHeader.SizeOfImage;
        oh32.SizeOfHeaders = m_OptionalHeader.SizeOfHeaders;
        oh32.CheckSum = m_OptionalHeader.CheckSum;
        oh32.Subsystem = m_OptionalHeader.Subsystem;
        oh32.DllCharacteristics = m_OptionalHeader.DllCharacteristics;
        oh32.SizeOfStackReserve = (ULONG)m_OptionalHeader.SizeOfStackReserve;
        oh32.SizeOfStackCommit = (ULONG)m_OptionalHeader.SizeOfStackCommit;
        oh32.SizeOfHeapReserve = (ULONG)m_OptionalHeader.SizeOfHeapReserve;
        oh32.SizeOfHeapCommit = (ULONG)m_OptionalHeader.SizeOfHeapCommit;
        oh32.LoaderFlags = m_OptionalHeader.LoaderFlags;
        oh32.NumberOfRvaAndSizes = m_OptionalHeader.NumberOfRvaAndSizes;

        for (int n = 0; n < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; n++)
        {
            oh32.DataDirectory[n] = m_OptionalHeader.DataDirectory[n];
        }

        if (!WriteFile(hFile, &oh32, sizeof(oh32), &cbDone, NULL)) {
            return FALSE;
        }
    }

    if (SetFilePointer(hFile, m_nSectionsOffset, NULL, FILE_BEGIN) == ~0u) {
        return FALSE;
    }
    if (!WriteFile(hFile, &m_SectionHeaders,
                   sizeof(m_SectionHeaders[0])
                   * m_FileHeader.NumberOfSections,
                   &cbDone, NULL)) {
        return FALSE;
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////// CFileMap.
//
class CFileMap
{
  public:
    CFileMap();
    ~CFileMap();

  public:
    BOOL    Load(PCWSTR pszFile);
    PBYTE   Seek(UINT32 cbPos);
    UINT32  Size();
    VOID    Close();

  protected:
    PBYTE   m_pbData;
    UINT32  m_cbData;
};

CFileMap::CFileMap()
{
    m_pbData = NULL;
    m_cbData = 0;
}

CFileMap::~CFileMap()
{
    Close();
}

VOID CFileMap::Close()
{
    if (m_pbData) {
        UnmapViewOfFile(m_pbData);
        m_pbData = NULL;
    }
    m_cbData = 0;
}

UINT32 CFileMap::Size()
{
    return m_cbData;
}

PBYTE CFileMap::Seek(UINT32 cbPos)
{
    if (m_pbData && cbPos <= m_cbData) {
        return m_pbData + cbPos;
    }
    return NULL;
}

BOOL CFileMap::Load(PCWSTR pszFile)
{
    Close();

    HANDLE hFile = CreateFile(pszFile,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    ULONG cbInFileData = GetFileSize(hFile, NULL);
    if (cbInFileData == ~0ul) {
        CloseHandle(hFile);
        return FALSE;
    }

    HANDLE hInFileMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    CloseHandle(hFile);
    if (hInFileMap == NULL) {
        return FALSE;
    }

    m_pbData = (PBYTE)MapViewOfFile(hInFileMap, FILE_MAP_COPY, 0, 0, 0);
    CloseHandle(hInFileMap);
    if (m_pbData == NULL) {
        return FALSE;
    }
    m_cbData = cbInFileData;
    return TRUE;
}

BOOL addsect_files(PCWSTR pszOutput, PCWSTR pszInput, PCWSTR pszData, PCSTR pszSection)
{
    HANDLE hInput = INVALID_HANDLE_VALUE;
    HANDLE hOutput = INVALID_HANDLE_VALUE;
    BOOL bGood = TRUE;
    CFileMap cfData;
    CImage image;

    if (!cfData.Load(pszData)) {
        fprintf(stderr, "ADDSECT: Could not open input data file: %ls\n", pszData);
        goto end;
    }

    hInput = CreateFile(pszInput,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hInput == INVALID_HANDLE_VALUE) {
        printf("ADDSECT: Couldn't open input file: %ls, error: %d\n",
               pszInput, GetLastError());
        bGood = FALSE;
        goto end;
    }

    hOutput = CreateFile(pszOutput,
                         GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hOutput == INVALID_HANDLE_VALUE) {
        printf("ADDSECT: Couldn't open output file: %ls, error: %d\n",
               pszOutput, GetLastError());
        bGood = FALSE;
        goto end;
    }

    if (!image.Read(hInput)) {
        fprintf(stderr, "ADDSECT: Image read failed: %d\n", GetLastError());
        bGood = FALSE;
        goto end;
    }

    if (!image.Check(pszSection)) {
        fprintf(stderr, "ADDSECT: Can't insert section `%hs' into image: %d\n",
                pszSection, GetLastError());
        bGood = FALSE;
        goto end;
    }

    if (!image.Write(hOutput, cfData.Seek(0), cfData.Size(), pszSection)) {
        fprintf(stderr, "ADDSECT: Image write failed: %d\n", GetLastError());
        bGood = FALSE;
    }

    image.Close();

    if (bGood)
    {
        printf("ADDSECT: Added new section `%hs' of %d bytes to `%ls'.\n",
               pszSection, cfData.Size(), pszOutput);
    }


  end:
    if (hOutput != INVALID_HANDLE_VALUE) {
        CloseHandle(hOutput);
        hOutput = INVALID_HANDLE_VALUE;
    }
    if (hInput != INVALID_HANDLE_VALUE) {
        CloseHandle(hInput);
        hInput = INVALID_HANDLE_VALUE;
    }
    if (!bGood)
    {
        DeleteFile(pszOutput);
    }

    return TRUE;
}

int __cdecl wmain(int argc, PWCHAR *argv)
{
    BOOL fNeedHelp = FALSE;
    PCWSTR pszData = NULL;
    PCWSTR pszInput = NULL;
    PCWSTR pszOutput = NULL;
    CHAR szSection[IMAGE_SIZEOF_SHORT_NAME + 1] = ".ramfs\0\0";

    for (int arg = 1; arg < argc; arg++) {
        if (argv[arg][0] == '-' || argv[arg][0] == '/') {
            PWCHAR argn = argv[arg]+1;                   // Argument name
            PWCHAR argp = argn;                          // Argument parameter

            while (*argp && *argp != ':' && *argp != '=') {
                argp++;
            }
            if (*argp == ':' || *argp == '=')
                *argp++ = '\0';

            switch (argn[0]) {

              case 'd':                                 // Input file.
              case 'D':
                pszData = argp;
                break;

              case 'i':                                 // Input file.
              case 'I':
                pszInput = argp;
                break;

              case 'o':                                 // Output file.
              case 'O':
                pszOutput = argp;
                break;

              case 's':                                 // Section Name.
              case 'S':
                _snprintf(szSection, arrayof(szSection)-1, "%ls", argp);
                szSection[arrayof(szSection)-1] = '\0';
                break;

              case 'h':                                 // Help
              case 'H':
              case '?':
                fNeedHelp = TRUE;
                break;

              default:
                fprintf(stderr, "ADDSECT: Unknown argument: %ls\n", argv[arg]);
                fNeedHelp = TRUE;
                break;
            }
        }
    }

    if (pszInput == NULL) {
        fNeedHelp = TRUE;
    }

    if (pszOutput == NULL) {
        fNeedHelp = TRUE;
    }

    if (pszData == NULL) {
        fNeedHelp = TRUE;
    }

    if (argc == 1) {
        fNeedHelp = TRUE;
    }

    if (fNeedHelp) {
        printf(
               "Usage:\n"
               "    ADDSECT [options] /I:input /O:output /D:data\n"
               "Options:\n"
               "    /O:output     Specify output file.\n"
               "    /I:input      Specify input file.\n"
               "    /D:data       Specify data file.\n"
               "    /S:section    Symbol (defaults to .ramfs).\n"
               "    /H or /?      Display this help screen.\n"
               "Summary:\n"
               "    Adds a new section to a PE binary.\n"
               );
        return 1;
    }

    if (!addsect_files(pszOutput, pszInput, pszData, szSection))
    {
        return 2;
    }
    return 0;
}
//
///////////////////////////////////////////////////////////////// End of File.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\adduser\adduser.c ===
#include <stdio.h>
#include <nt.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <ntrtl.h>
#include <string.h>

VOID AddUser(LPSTR, LPSTR);

VOID
__cdecl main(USHORT argc, PCHAR *argv)
{

    if (argc != 3) {
        printf("Usage: AddUser <username> <password>\n");
        return;
    }

    AddUser(argv[1], argv[2]);

    return;

}
VOID
AddUser(
    LPSTR UserName,
    LPSTR Password
    )
{

    HANDLE ServerHandle = NULL;
    HANDLE DomainHandle = NULL;
    HANDLE UserHandle = NULL;
    LSA_HANDLE LsaHandle = NULL;
    ACCESS_MASK ServerAccessMask, DomainAccessMask;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo = NULL;
    STRING AccountNameAnsi;
    STRING AnsiPassword;
    UNICODE_STRING AccountName;
    UNICODE_STRING UnicodePassword;
    USER_SET_PASSWORD_INFORMATION pi;
    ULONG UserRid;
    NTSTATUS NtStatus;
    USHORT ControlInformation = USER_NORMAL_ACCOUNT;


    //
    // Get the Account domain SID from LSA
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );
    NtStatus = LsaOpenPolicy(NULL,
                             &ObjectAttributes,
                             POLICY_ALL_ACCESS,
                             &LsaHandle);
    if (NtStatus == STATUS_ACCESS_DENIED) {
        printf("You must be logged on as admin to use this command\n");
        return;
    }
    else if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("Couldn't open Lsa Policy database, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

    NtStatus = LsaQueryInformationPolicy(LsaHandle,
                                         PolicyAccountDomainInformation,
                                         &PolicyAccountDomainInfo);
    if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("Couldn't query Lsa Policy database, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

    //
    // Connect to SAM
    //

    ServerAccessMask = SAM_SERVER_ALL_ACCESS;
    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );
    NtStatus = SamConnect(
                  NULL,                     // ServerName (Local machine)
                  &ServerHandle,
                  ServerAccessMask,
                  &ObjectAttributes
                  );
    if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("Couldn't connect to SAM, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

    //
    // Open the account domain
    //

    DomainAccessMask = DOMAIN_ALL_ACCESS;
    NtStatus = SamOpenDomain(
                   ServerHandle,
                   DomainAccessMask,
                   PolicyAccountDomainInfo->DomainSid,
                   &DomainHandle
                   );
    if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("Couldn't open account domain, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

    //
    // Create the User
    //

    RtlInitString( &AccountNameAnsi, UserName );
    NtStatus = RtlAnsiStringToUnicodeString( &AccountName, &AccountNameAnsi,
        TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("RtlAnsiStringToUnicodeString failed, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

    UserRid = 0;
    UserHandle = NULL;
    NtStatus = SamCreateUserInDomain(
                   DomainHandle,
                   &AccountName,
                   USER_ALL_ACCESS,
                   &UserHandle,
                   &UserRid
                   );
    RtlFreeUnicodeString( &AccountName );
    if (NtStatus == STATUS_USER_EXISTS) {
        printf("User %s already exists\n", UserName);
        goto cleanupandexit;
    }
    else if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("Couldn't create user, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

    //
    // Create the cleartext UNICODE password and write it out.
    //

    RtlInitString(&AnsiPassword, Password);
    NtStatus = RtlAnsiStringToUnicodeString( &UnicodePassword, &AnsiPassword,
        TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("RtlAnsiStringToUnicodeString failed, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

    pi.Password = UnicodePassword;
    pi.PasswordExpired = FALSE;

    NtStatus = SamSetInformationUser(
                   UserHandle,
                   UserSetPasswordInformation,
                   &pi
                   );

    RtlFreeUnicodeString(&UnicodePassword);

    if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("Couldn't set password for user, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

    //
    // Now make the user account active
    //

    NtStatus = SamSetInformationUser(
                   UserHandle,
                   UserControlInformation,
                   &ControlInformation
                   );

    if (!NT_SUCCESS(NtStatus)) {
        //cleanup and exit
        printf("Couldn't activate the user account, rc = 0x%x\n", NtStatus);
        goto cleanupandexit;
    }

cleanupandexit:

    if (PolicyAccountDomainInfo) {
        LsaFreeMemory(PolicyAccountDomainInfo);
    }
    if (UserHandle) {
        NtClose(UserHandle);
    }
    if (DomainHandle) {
        NtClose(DomainHandle);
    }
    if (ServerHandle) {
        NtClose(ServerHandle);
    }
    if (LsaHandle) {
        NtClose(LsaHandle);
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\alias\alias.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    alias.c

Abstract:

    alias utility

Author:

    Therese Stowell (thereses) 22-Mar-1990

Revision History:

--*/

#include <windows.h>
#include <conapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <cvtoem.h>

BOOL fVerbose;

DWORD
DisplayAliases(
    char *ExeName
    );

DWORD
DisplayAlias(
    LPSTR AliasName,
    LPSTR ExeName
    );

DWORD
DoAliasFile(
    char * FileName,
    char * ExeName,
    BOOL fDelete
    );

DWORD
DoAlias(
    char *Source,
    char *Target,
    char *ExeName
    );

void
usage( void )
{
    fprintf( stderr, "Usage: ALIAS [-v] [-p programName] [-f filespec] [<source> <target>]\n" );
    fprintf( stderr, "             [-v] means verbose output.\n" );
    fprintf( stderr, "             [-d] means delete aliases.\n" );
    fprintf( stderr, "             [-p programName] specifies which image file name these alias\n" );
    fprintf( stderr, "                              definitions are for.  Default is CMD.EXE\n" );
    fprintf( stderr, "             [-f filespec] specifies a file which contains the aliases.\n" );
    exit( 1 );
}

DWORD
DoAlias(
    char *Source,
    char *Target,
    char *ExeName
    )
{
    if (!AddConsoleAlias( Source, Target, ExeName )) {
        if (!Target) {
            fprintf( stderr,
                     "ALIAS: Unable to delete alias - %s\n",
                     Source
                   );
            }
        else {
            fprintf( stderr,
                     "ALIAS: Unable to add alias - %s = %s\n",
                     Source,
                     Target
                   );
            }

        return ERROR_NOT_ENOUGH_MEMORY;
        }
    else
    if (fVerbose) {
        if (!Target) {
            fprintf( stderr, "Deleted alias - %s\n", Source );
            }
        else {
            fprintf( stderr, "Added alias - %s = %s\n", Source, Target );
            }
        }

    return NO_ERROR;
}


DWORD
DoAliasFile(
    char * FileName,
    char * ExeName,
    BOOL fDelete
    )
{
    DWORD rc;
    FILE *fh;
    char LineBuffer[ 512 ], *Source, *Target, *s;

    if (!(fh = fopen( FileName, "rt" ))) {
        fprintf( stderr, "ALIAS: Unable to open file - %s\n", FileName );
        return ERROR_FILE_NOT_FOUND;
        }

    if (fVerbose) {
        fprintf( stderr,
                 "ALIAS: %s aliases defined in %s\n",
                 fDelete ? "Deleting" : "Loading",
                 FileName
               );
        }
    while (s = fgets( LineBuffer, sizeof( LineBuffer ), fh )) {
        while (*s <= ' ') {
            if (!*s) {
                break;
                }
            s++;
            }

        if (!*s || (*s == '/' && s[1] == '/')) {
            continue;
            }

        Source = s;
        while (*s > ' ') {
            s++;
            }
        *s++ = '\0';

        while (*s <= ' ') {
            if (!*s) {
                break;
                }
            s++;
            }

        Target = s;
        s += strlen( s );
        while (*s <= ' ') {
            *s-- = '\0';
            if (s < Target) {
                break;
                }
            }

        rc = DoAlias( Source, fDelete ? NULL : Target, ExeName );
        if (rc != NO_ERROR) {
            break;
            }
        }

    return rc;
}

DWORD
DisplayAlias(
    LPSTR AliasName,
    LPSTR ExeName
    )
{
    DWORD cb;
    CHAR AliasBuffer[512];

    if (cb = GetConsoleAlias( AliasName, AliasBuffer, sizeof( AliasBuffer ), ExeName )) {
        printf( "%-16s=%s\n", AliasName, AliasBuffer );
        return NO_ERROR;
        }
    else {
        printf( "%-16s *** Unable to read value of alias ***\n",
                AliasName
              );
        return ERROR_ENVVAR_NOT_FOUND;
        }
}

int __cdecl
CmpNamesRoutine(
    const VOID *Element1,
    const VOID *Element2
    )
{
    return( strcmp( *(LPSTR *)Element1, *(LPSTR *)Element2 ) );
}

DWORD
DisplayAliases(
    char *ExeName
    )
{
    DWORD cb, rc, nExeNames, nAliases, iExeName, iAlias;
    LPSTR FreeMem1, FreeMem2, AliasName, AliasValue, s, *SortedExeNames, *SortedAliasNames;

    if (ExeName == NULL) {
        cb = GetConsoleAliasExesLength();
        if (cb == 0) {
            return ERROR_ENVVAR_NOT_FOUND;
            }

        if (!(FreeMem1 = malloc( cb+2 ))) {
            fprintf( stderr, "ALIAS: Not enough memory for EXE names.\n" );
            return ERROR_NOT_ENOUGH_MEMORY;
            }

        ExeName = FreeMem1;
        if (!GetConsoleAliasExes( ExeName, cb )) {
            fprintf( stderr, "ALIAS: Unable to read alias EXE names.\n" );
            return ERROR_ENVVAR_NOT_FOUND;
            }

        ExeName[ cb ] = '\0';
        ExeName[ cb+1 ] = '\0';

        nExeNames = 0;
        s = ExeName;
        while (*s) {
            _strupr( s );
            nExeNames++;
            while (*s++) {
                }
            }

        SortedExeNames = malloc( nExeNames * sizeof( LPSTR ) );
        if (SortedExeNames == NULL) {
            fprintf( stderr, "ALIAS: Not enough memory to sort .EXE names.\n" );
            }
        else {
            iExeName = 0;
            s = ExeName;
            while (*s) {
                SortedExeNames[ iExeName++ ] = s;
                while (*s++) {
                    }
                }

            qsort( SortedExeNames,
                   nExeNames,
                   sizeof( LPSTR ),
                   CmpNamesRoutine
                 );

            iExeName = 0;
            }

        }
    else {
        SortedExeNames = NULL;
        FreeMem1 = NULL;
        }

    rc = NO_ERROR;
    while (rc == NO_ERROR && *ExeName) {
        if (SortedExeNames != NULL) {
            ExeName = SortedExeNames[ iExeName++ ];
            }

        cb = GetConsoleAliasesLength(ExeName);
        if (cb == 0) {
            printf( "No aliases defined for %s in current console.\n", ExeName );
            }
        else {
            if (!(FreeMem2 = malloc( cb+2 ))) {
                fprintf( stderr, "ALIAS: Not enough memory for alias names.\n" );
                rc = ERROR_NOT_ENOUGH_MEMORY;
                break;
                }

            SortedAliasNames = NULL;
            AliasName = FreeMem2;
            if (GetConsoleAliases( AliasName, cb, ExeName )) {
                AliasName[ cb ] = '\0';
                AliasName[ cb+1 ] = '\0';
                nAliases = 0;
                s = AliasName;
                while (*s) {
                    nAliases++;
                    while (*s++) {
                        }
                    }

                SortedAliasNames = malloc( nAliases * sizeof( LPSTR ) );
                if (SortedAliasNames == NULL) {
                    fprintf( stderr, "ALIAS: Not enough memory to sort alias names.\n" );
                    }
                else {
                    iAlias = 0;
                    s = AliasName;
                    while (*s) {
                        SortedAliasNames[ iAlias++ ] = s;
                        while (*s++) {
                            }
                        }

                    qsort( SortedAliasNames,
                           nAliases,
                           sizeof( LPSTR ),
                           CmpNamesRoutine
                         );

                    iAlias = 0;
                    }

                printf( "Dumping all defined aliases for %s.\n", ExeName );
                while (*AliasName) {
                    if (SortedAliasNames != NULL) {
                        AliasName = SortedAliasNames[ iAlias++ ];
                        }
                    AliasValue = AliasName;

                    while (*AliasValue) {
                        if (*AliasValue == '=') {
                            *AliasValue++ = '\0';
                            break;
                            }
                        else {
                            AliasValue++;
                            }
                        }

                    printf( "    %-16s=%s\n", AliasName, AliasValue );
                    if (SortedAliasNames != NULL) {
                        if (iAlias < nAliases) {
                            AliasName = " ";
                            }
                        else {
                            AliasName = "";
                            }
                        }
                    else {
                        AliasName = AliasValue;
                        while (*AliasName++) {
                            ;
                            }
                        }
                    }
                }
            else {
                fprintf( stderr, "ALIAS: unable to read aliases for %s.\n", ExeName );
                rc = ERROR_ENVVAR_NOT_FOUND;
                }

            free( FreeMem2 );
            if (SortedAliasNames != NULL) {
                free( SortedAliasNames );
                }
            }

        if (SortedExeNames != NULL) {
            if (iExeName < nExeNames) {
                ExeName = " ";
                }
            else {
                ExeName = "";
                }
            }
        else {
            while (*ExeName++) {
                ;
                }
            }
        }

    if (SortedExeNames != NULL) {
        free( SortedExeNames );
        }

    if (FreeMem1) {
        free( FreeMem1 );
        }

    return rc;
}

DWORD __cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD rc;
    char *s, *s1, *AliasName;
    char *ExeName;
    BOOL fDelete;
    BOOL DisplayAllAliases;

    ConvertAppToOem( argc,argv );
    AliasName = NULL;
    ExeName = NULL;
    fVerbose = FALSE;
    fDelete = FALSE;
    DisplayAllAliases = TRUE;
    rc = NO_ERROR;
    while (rc == NO_ERROR && --argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( *s ) {
                    case '?':
                    case 'h':
                    case 'H':
                        usage();
                        break;

                    case 'd':
                    case 'D':
                        fDelete = TRUE;
                        break;

                    case 'v':
                    case 'V':
                        fVerbose = TRUE;
                        break;

                    case 'p':
                    case 'P':
                        if (!--argc) {
                            fprintf( stderr, "ALIAS: Argument to -p switch missing.\n" );
                            usage();
                            }

                        if (ExeName != NULL) {
                            free( ExeName );
                            ExeName = NULL;
                            }
                        s1 = *++argv;
                        ExeName = calloc( 1, strlen( s1 )+2 );
                        if (ExeName) {
                            strcpy( ExeName, s1 );
                        }
                        break;

                    case 'f':
                    case 'F':
                        if (!--argc) {
                            fprintf( stderr, "ALIAS: Argument to -f switch missing.\n" );
                            usage();
                            }

                        DisplayAllAliases = FALSE;
                        rc = DoAliasFile( *++argv, ExeName ? ExeName : "CMD.EXE", fDelete );
                        break;

                    default:
                        fprintf( stderr, "ALIAS: invalid switch /%c\n", *s );
                        usage();
                        break;
                    }
                }
            }
        else {
            DisplayAllAliases = FALSE;
            if (AliasName == NULL) {
                if (fDelete) {
                    rc = DoAlias( s, NULL, ExeName ? ExeName : "CMD.EXE" );
                    }
                else {
                    AliasName = s;
                    }
                }
            else {
                if (fDelete) {
                    rc = DoAlias( AliasName, NULL, ExeName ? ExeName : "CMD.EXE" );
                    AliasName = s;
                    }
                else {
                    rc = DoAlias( AliasName, s, ExeName ? ExeName : "CMD.EXE" );
                    AliasName = NULL;
                    }
                }
            }
        }

    if (rc == NO_ERROR) {
        if (AliasName != NULL) {
            if (fDelete) {
                rc = DoAlias( AliasName, NULL, ExeName ? ExeName : "CMD.EXE" );
                }
            else {
                rc = DisplayAlias( AliasName, ExeName ? ExeName : "CMD.EXE" );
                }
            }
        else
        if (DisplayAllAliases) {
            rc = DisplayAliases( ExeName );
            }
        }

    if (ExeName != NULL) {
        free( ExeName );
        ExeName = NULL;
        }

    exit( rc );
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apidll\apidll.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apidll.cpp

Abstract:

    This file implements the non-architecture specific
    code for the api monitor trojan/support dll.

Author:

    Wesley Witt (wesw) 28-June-1995

Environment:

    User Mode

--*/
#include "apidllp.h"
#include <tchar.h>
#pragma hdrstop

typedef struct _BUF_INFO {
    LPSTR       BufferHead;
    LPSTR       Buffer;
} BUF_INFO, *PBUF_INFO;


PVOID                       MemPtr;
PDLL_INFO                   DllList;
HANDLE                      hLogFile;
PGETCURRENTTHREADID         pGetCurrentThreadId;
PUCHAR                      ThunksBase;
PUCHAR                      Thunks;
BOOL                        RunningOnNT;
BOOL                        StaticLink;
ULONG_PTR                   LoadLibraryA_Addr;
ULONG_PTR                   LoadLibraryW_Addr;
ULONG_PTR                   FreeLibrary_Addr;
ULONG_PTR                   GetProcAddress_Addr;
HANDLE                      ApiTraceMutex;
HANDLE                      ApiMemMutex;
PTRACE_BUFFER               TraceBuffer;
DWORD                       ThreadCnt;

DLL_INFO                    WndProcDllInfo;
BOOL                        printNow = 0;
extern "C" {
    LPDWORD                 ApiCounter;
    LPDWORD                 ApiTraceEnabled;
    LPDWORD                 ApiTimingEnabled;
    LPDWORD                 FastCounterAvail;
    LPDWORD                 ApiOffset;
    LPDWORD                 ApiStrings;
    LPDWORD                 ApiCount;
    LPDWORD                 WndProcEnabled;
    LPDWORD                 WndProcCount;
    LPDWORD                 WndProcOffset;
    DWORD                   TlsReEnter;
    DWORD                   TlsStack;
    DWORD                   ThunkOverhead;
    DWORD                   ThunkCallOverhead;
    PTLSGETVALUE            pTlsGetValue;
    PTLSSETVALUE            pTlsSetValue;
    PGETLASTERROR           pGetLastError;
    PSETLASTERROR           pSetLastError;
    PVIRTUALALLOC           pVirtualAlloc;
    PQUERYPERFORMANCECOUNTER pQueryPerformanceCounter;
}

extern API_MASTER_TABLE ApiTables[];
BOOL    ReDirectIat(VOID);
BOOL    ProcessDllLoad(VOID);
PUCHAR  CreateApiThunk(ULONG_PTR,PUCHAR,PDLL_INFO,PAPI_INFO);
BOOL    ProcessApiTable(PDLL_INFO DllInfo);
VOID    CreateWndProcApi(LPCSTR lpszClassName, WNDPROC *pWndProc);
VOID    CalibrateThunk();
VOID    Calib1Func(VOID);
VOID    Calib2Func(VOID);
VOID    (*Calib1Thunk)();
VOID    (*Calib2Thunk)();

extern "C" void
__cdecl
dprintf(
    char *format,
    ...
    )

/*++

Routine Description:

    Prints a debug string to the API monitor.

Arguments:

    format      - printf() format string
    ...         - Variable data

Return Value:

    None.

--*/

{
    char    buf[1024];
    va_list arg_ptr;
    va_start(arg_ptr, format);
    pTlsSetValue( TlsReEnter, (LPVOID) 1 );
    _vsnprintf(buf, sizeof(buf), format, arg_ptr);
    OutputDebugString( buf );
    pTlsSetValue( TlsReEnter, (LPVOID) 0 );
    return;
}

extern "C" {

DWORD
ApiDllEntry(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )

/*++

Routine Description:

    DLL initialization function.

Arguments:

    hInstance   - Instance handle
    Reason      - Reason for the entrypoint being called
    Context     - Context record

Return Value:

    TRUE        - Initialization succeeded
    FALSE       - Initialization failed

--*/

{
    if (Reason == DLL_PROCESS_ATTACH) {
        return ProcessDllLoad();
    }

    if (Reason == DLL_THREAD_ATTACH) {
        pTlsSetValue( TlsReEnter, (LPVOID) 1 );
        PTHREAD_STACK Stack = (PTHREAD_STACK) pVirtualAlloc( NULL, sizeof(THREAD_STACK), MEM_COMMIT, PAGE_READWRITE );

        if (!Stack) {
            return FALSE;
        }

        Stack->ThreadNum = ++ThreadCnt;

        // Start at 2nd entry so that there is always a parent frame
        Stack->Pointer = (DWORD_PTR)&Stack->Body[FRAME_SIZE];

        pTlsSetValue( TlsReEnter, (LPVOID) 0 );
        pTlsSetValue( TlsStack, Stack );

        return TRUE;
    }

    if (Reason == DLL_THREAD_DETACH) {
        return TRUE;
    }

    if (Reason == DLL_PROCESS_DETACH) {
        return TRUE;
    }

    return TRUE;
}

} //extern "C"

PDLL_INFO
AddDllToList(
    ULONG DllAddr,
    LPSTR DllName,
    ULONG DllSize
    )
{
    //
    // look for the dll entry in the list
    //
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress == DllAddr) {
            return &DllList[i];
        }
    }

    //
    // this check should be unnecessary
    // the debugger side (apimon.exe) takes
    // care of adding the dlls to the list when
    // it gets a module load from the debug
    // subsystem.  this code is here only so
    // a test program that is not a debugger
    // will work properly.
    //
    for (i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress == 0) {
            DllList[i].BaseAddress = DllAddr;
            strcpy( DllList[i].Name, DllName );
            DllList[i].Size = DllSize;
            return &DllList[i];
        }
    }

    //
    // we could not find a dll in the list that matched
    // and we could not add it because the list is
    // is full. we're hosed.
    //
    return NULL;
}

BOOL
ProcessDllLoad(
    VOID
    )

/*++

Routine Description:

    Sets up the API thunks for the process that this dll
    is loaded into.

Arguments:

    None.

Return Value:

    TRUE        - Success
    FALSE       - Failure

--*/

{
    ULONG i;
    ULONG cnt;
    HANDLE hMap;

    //
    // see if we are running on NT
    // this is necessary because APIMON implements some
    // features that are NOT available on WIN95
    //
    OSVERSIONINFO OsVersionInfo;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);
    GetVersionEx( &OsVersionInfo );
    RunningOnNT = OsVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT;

    TlsReEnter = TlsAlloc();
    if (TlsReEnter == TLS_OUT_OF_INDEXES) {
        return FALSE;
    }
    TlsStack = TlsAlloc();
    if (TlsStack == TLS_OUT_OF_INDEXES) {
        return FALSE;
    }

    HMODULE hMod = GetModuleHandle( KERNEL32 );
    if (!hMod) {
        return FALSE;
    }
    pGetCurrentThreadId = (PGETCURRENTTHREADID) GetProcAddress( hMod, "GetCurrentThreadId" );
    if (!pGetCurrentThreadId) {
        return FALSE;
    }
    pGetLastError = (PGETLASTERROR) GetProcAddress( hMod, "GetLastError" );
    if (!pGetLastError) {
        return FALSE;
    }
    pSetLastError = (PSETLASTERROR) GetProcAddress( hMod, "SetLastError" );
    if (!pSetLastError) {
        return FALSE;
    }
    pQueryPerformanceCounter = (PQUERYPERFORMANCECOUNTER) GetProcAddress( hMod, "QueryPerformanceCounter" );
    if (!pQueryPerformanceCounter) {
        return FALSE;
    }
    pTlsGetValue = (PTLSGETVALUE) GetProcAddress( hMod, "TlsGetValue" );
    if (!pTlsGetValue) {
        return FALSE;
    }
    pTlsSetValue = (PTLSSETVALUE) GetProcAddress( hMod, "TlsSetValue" );
    if (!pTlsSetValue) {
        return FALSE;
    }
    pVirtualAlloc = (PVIRTUALALLOC) GetProcAddress( hMod, "VirtualAlloc" );
    if (!pVirtualAlloc) {
        return FALSE;
    }

    Thunks = (PUCHAR)VirtualAlloc( NULL, THUNK_SIZE, MEM_COMMIT, PAGE_EXECUTE_READWRITE );
    if (!Thunks) {
        return FALSE;
    }
    ThunksBase = Thunks;

    PTHREAD_STACK Stack = (PTHREAD_STACK) pVirtualAlloc( NULL, sizeof(THREAD_STACK), MEM_COMMIT, PAGE_READWRITE );
    if (!Stack) {
        return FALSE;
    }

    Stack->ThreadNum = ++ThreadCnt;

    // Start at 2nd entry so that there is always a parent frame
    Stack->Pointer = (DWORD_PTR)&Stack->Body[FRAME_SIZE];

    pTlsSetValue( TlsReEnter, (LPVOID) 0 );
    pTlsSetValue( TlsStack, Stack );

    hMap = OpenFileMapping(
        FILE_MAP_WRITE,
        FALSE,
        "ApiWatch"
        );
    if (!hMap) {
        return FALSE;
    }

    MemPtr = (PUCHAR)MapViewOfFile(
        hMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (!MemPtr) {
        return FALSE;
    }

    ApiCounter       = (LPDWORD)   MemPtr + 0;
    ApiTraceEnabled  = (LPDWORD)   MemPtr + 1;
    ApiTimingEnabled = (LPDWORD)   MemPtr + 2;
    FastCounterAvail = (LPDWORD)   MemPtr + 3;
    ApiOffset        = (LPDWORD)   MemPtr + 4;
    ApiStrings       = (LPDWORD)   MemPtr + 5;
    ApiCount         = (LPDWORD)   MemPtr + 6;
    WndProcEnabled   = (LPDWORD)   MemPtr + 7;
    WndProcCount     = (LPDWORD)   MemPtr + 8;
    WndProcOffset    = (LPDWORD)   MemPtr + 9;
    DllList          = (PDLL_INFO) ((LPDWORD)MemPtr + 10);

    //
    // open the shared memory region for the api trace buffer
    //
    hMap = OpenFileMapping(
        FILE_MAP_WRITE,
        FALSE,
        "ApiTrace"
        );
    if (!hMap) {
        return FALSE;
    }

    TraceBuffer = (PTRACE_BUFFER)MapViewOfFile(
        hMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (!TraceBuffer) {
        return FALSE;
    }

    ApiTraceMutex = OpenMutex( SYNCHRONIZE, FALSE, "ApiTraceMutex" );
    if (!ApiTraceMutex) {
        return FALSE;
    }

    ApiMemMutex = OpenMutex( SYNCHRONIZE, FALSE, "ApiMemMutex" );
    if (!ApiMemMutex) {
        return FALSE;
    }

    // Initialize dummy window proc Dll
    // (Only need the fields accesed by thunk and thunk creation)
    strcpy(WndProcDllInfo.Name, WNDPROCDLL);
    WndProcDllInfo.Enabled = TRUE;

    CalibrateThunk();

    ReDirectIat();

    // Disable close handle exceptions
    if (RunningOnNT) {
        NtCurrentPeb()->NtGlobalFlag &= ~FLG_ENABLE_CLOSE_EXCEPTIONS;
    }

    return TRUE;
}


PUCHAR
ProcessThunk(
    ULONG_PTR   ThunkAddr,
    ULONG_PTR   IatAddr,
    PUCHAR      Text
    )
{
    PDLL_INFO DllInfo;
    for (ULONG k=0; k<MAX_DLLS; k++) {
        DllInfo = &DllList[k];
        if (ThunkAddr >= DllInfo->BaseAddress &&
            ThunkAddr <  DllInfo->BaseAddress+DllInfo->Size) {
                break;
        }
    }
    if (k == MAX_DLLS) {
        return Text;
    }

    PIMAGE_DOS_HEADER dh = (PIMAGE_DOS_HEADER)DllInfo->BaseAddress;
    PIMAGE_NT_HEADERS nh = (PIMAGE_NT_HEADERS)(dh->e_lfanew + DllInfo->BaseAddress);
    PIMAGE_SECTION_HEADER SectionHdrs = IMAGE_FIRST_SECTION( nh );
    BOOL IsCode = FALSE;
    for (ULONG l=0; l<nh->FileHeader.NumberOfSections; l++) {
        if (ThunkAddr-DllInfo->BaseAddress >= SectionHdrs[l].VirtualAddress &&
            ThunkAddr-DllInfo->BaseAddress < SectionHdrs[l].VirtualAddress+SectionHdrs[l].SizeOfRawData) {
                if (SectionHdrs[l].Characteristics & IMAGE_SCN_MEM_EXECUTE) {
                    IsCode = TRUE;
                    break;
                }
                break;
        }
    }
    if (!IsCode) {
        return Text;
    }
    PAPI_INFO ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (ULONG_PTR)DllList);
    for (l=0; l<DllInfo->ApiCount; l++) {
        if (ApiInfo[l].Address == ThunkAddr) {
            return CreateApiThunk( IatAddr, Text, DllInfo, &ApiInfo[l] );
        }
    }

    return Text;
}

PUCHAR
ProcessUnBoundImage(
    PDLL_INFO DllInfo,
    PUCHAR    Text
    )
{
    PIMAGE_DOS_HEADER dh = (PIMAGE_DOS_HEADER)DllInfo->BaseAddress;
    if (dh->e_magic != IMAGE_DOS_SIGNATURE) {
        return Text;
    }
    PIMAGE_NT_HEADERS nh = (PIMAGE_NT_HEADERS)(dh->e_lfanew + DllInfo->BaseAddress);

    PIMAGE_SECTION_HEADER SectionHdrs = IMAGE_FIRST_SECTION( nh );
    ULONG Address = nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    ULONG i;
    for (i=0; i<nh->FileHeader.NumberOfSections; i++) {
        if (Address >= SectionHdrs[i].VirtualAddress &&
            Address < SectionHdrs[i].VirtualAddress+SectionHdrs[i].SizeOfRawData) {
                break;
        }
    }
    if (i == nh->FileHeader.NumberOfSections) {
        return Text;
    }

    ULONG_PTR SeekPos = DllInfo->BaseAddress +
        nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

    ULONG PageProt;
    ULONG ThunkProt;
    ULONG_PTR ImportStart = SeekPos;
    PUCHAR TextStart = Text;

    VirtualProtect(
        (PVOID)ImportStart,
        nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size,
        PAGE_READWRITE,
        &PageProt
        );

    while( TRUE ) {
        PIMAGE_IMPORT_DESCRIPTOR desc = (PIMAGE_IMPORT_DESCRIPTOR)SeekPos;

        SeekPos += sizeof(IMAGE_IMPORT_DESCRIPTOR);

        if ((desc->Characteristics == 0) && (desc->Name == 0) && (desc->FirstThunk == 0)) {
            //
            // End of import descriptors
            //
            break;
        }
        ULONG_PTR *ThunkAddr = (ULONG_PTR *)((ULONG)desc->FirstThunk + DllInfo->BaseAddress);
        while( *ThunkAddr ) {

#ifdef _X86_
            if (RunningOnNT) {
                Text = ProcessThunk(*ThunkAddr, (ULONG_PTR)ThunkAddr, Text );
            } else {
                Text = ProcessThunk(*(PULONG)(*ThunkAddr + 1), (ULONG)ThunkAddr, Text );
            }
#else
            Text = ProcessThunk(*ThunkAddr, (ULONG_PTR)ThunkAddr, Text );
#endif
            ThunkAddr += 1;
        }
    }

    VirtualProtect(
        (PVOID)ImportStart,
        nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size,
        PageProt,
        &PageProt
        );

    FlushInstructionCache(
        GetCurrentProcess(),
        (PVOID)DllInfo->BaseAddress,
        DllInfo->Size
        );

    FlushInstructionCache(
        GetCurrentProcess(),
        (PVOID)TextStart,
        (DWORD)(Text-TextStart)
        );

    return Text;
}

PUCHAR
ProcessBoundImage(
    PDLL_INFO DllInfo,
    PUCHAR    Text,
    PULONG    IatBase,
    ULONG     IatCnt
    )
{
    ULONG j;
    ULONG PageProt;
    ULONG ThunkProt;
    PUCHAR TextStart = Text;

    VirtualProtect(
        IatBase,
        IatCnt*4,
        PAGE_READWRITE,
        &PageProt
        );

    //
    // process the iat entries
    //
    for (j=0; j<IatCnt; j++) {
        if (IatBase[j]) {
#ifdef _X86_
            if (RunningOnNT) {
                Text = ProcessThunk( IatBase[j], (ULONG_PTR)&IatBase[j], Text );
            } else {
                Text = ProcessThunk(*(PULONG)(IatBase[j] + 1), (ULONG)&IatBase[j], Text );
            }
#else
            Text = ProcessThunk( IatBase[j], (ULONG_PTR)&IatBase[j], Text );
#endif
        }
    }

    VirtualProtect(
        IatBase,
        IatCnt*4,
        PageProt,
        &PageProt
        );

    FlushInstructionCache(
        GetCurrentProcess(),
        (PVOID)DllInfo->BaseAddress,
        DllInfo->Size
        );

    FlushInstructionCache(
        GetCurrentProcess(),
        (PVOID)TextStart,
        (DWORD)(Text-TextStart)
        );


    return Text;
}

BOOL
ReDirectIat(
    VOID
    )
{
    ULONG i;
    PUCHAR Text = Thunks;

    for (i=0; i<MAX_DLLS; i++) {
        PDLL_INFO DllInfo = &DllList[i];
        if (!DllInfo->BaseAddress) {
            break;
        }
        if ((DllInfo->Snapped) || (DllInfo->Unloaded)) {
            continue;
        }
        PIMAGE_DOS_HEADER dh = (PIMAGE_DOS_HEADER)DllInfo->BaseAddress;
        PULONG IatBase = NULL;
        ULONG IatCnt = 0;
        if (dh->e_magic == IMAGE_DOS_SIGNATURE) {
            PIMAGE_NT_HEADERS nh = (PIMAGE_NT_HEADERS)(dh->e_lfanew + DllInfo->BaseAddress);
            if (nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress) {
                IatBase = (PULONG)(DllInfo->BaseAddress +
                    nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress);
                IatCnt = nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size / 4;
            }
        } else {
            continue;
        }

        if (!IatBase) {
            Text = ProcessUnBoundImage( DllInfo, Text );
        } else {
            Text = ProcessBoundImage( DllInfo, Text, IatBase, IatCnt );
        }
        DllInfo->Snapped = TRUE;

        ProcessApiTable( DllInfo );
    }

    Thunks = Text;

    return TRUE;
}

extern "C" {

VOID
HandleDynamicDllLoadA(
    ULONG_PTR DllAddress,
    LPSTR     DllName
    )
{
    if ( (!DllAddress) || (_stricmp(DllName,TROJANDLL)==0) ) {
        return;
    }

    ReDirectIat();
}

VOID
HandleDynamicDllLoadW(
    ULONG_PTR DllAddress,
    LPWSTR    DllName
    )
{
    CHAR AsciiBuf[512];
    ZeroMemory( AsciiBuf, sizeof(AsciiBuf) );
    WideCharToMultiByte(
        CP_ACP,
        0,
        DllName,
        wcslen(DllName),
        AsciiBuf,
        sizeof(AsciiBuf),
        NULL,
        NULL
        );
    if (!strlen(AsciiBuf)) {
        return;
    }
    HandleDynamicDllLoadA( DllAddress, AsciiBuf );
}


VOID
HandleRegisterClassA(
    WNDCLASSA   *pWndClass
    )
{
    if (!*WndProcEnabled)
        return;

    // Don't deal with call procedure handles or special addresses
#ifdef _WIN64
    if (HIWORD((((DWORD_PTR)pWndClass->lpfnWndProc) >> 32)) == 0xFFFF)
#else
    if (HIWORD(pWndClass->lpfnWndProc) == 0xFFFF)
#endif
        return;

    if ((ULONG_PTR)(pWndClass->lpfnWndProc) & 0x80000000) {
        return;
    }

    pTlsSetValue( TlsReEnter, (LPVOID) 1 );

    if ((ULONG_PTR)pWndClass->lpszClassName < 0x10000) {
        CreateWndProcApi("<Atom>", &pWndClass->lpfnWndProc);
    } else {
        CreateWndProcApi( pWndClass->lpszClassName, &pWndClass->lpfnWndProc );
    }

    pTlsSetValue( TlsReEnter, (LPVOID) 0 );

}


VOID HandleRegisterClassW(
    WNDCLASSW *pWndClass
    )
{
    CHAR AsciiBuf[128];

    if (!*WndProcEnabled)
        return;

    // Don't deal with call procedure handles or special addresses
#ifdef _WIN64
    if ((HIWORD((((DWORD_PTR)pWndClass->lpfnWndProc) >> 32)) == 0xFFFF) ||
#else
    if (( HIWORD(pWndClass->lpfnWndProc) == 0xFFFF) ||
#endif
        ((ULONG_PTR)(pWndClass->lpfnWndProc) & 0x80000000) ) {
        return;
    }

    if ((ULONG_PTR)pWndClass->lpszClassName < 0x10000) {
       CreateWndProcApi( "<Atom>", &pWndClass->lpfnWndProc );
       return;
    }

    pTlsSetValue( TlsReEnter, (LPVOID) 1 );

    ZeroMemory( AsciiBuf, sizeof(AsciiBuf) );
    WideCharToMultiByte(
        CP_ACP,
        0,
        pWndClass->lpszClassName,
        wcslen(pWndClass->lpszClassName),
        AsciiBuf,
        sizeof(AsciiBuf),
        NULL,
        NULL
        );

    pTlsSetValue( TlsReEnter, (LPVOID) 0 );

    if (!strlen(AsciiBuf)) {
        return;
    }

    CreateWndProcApi( AsciiBuf, &pWndClass->lpfnWndProc );
}

LONG_PTR
HandleSetWindowLong(
    HWND    hWindow,
    LONG    lOffset,
    LPARAM  lValue
    )
{
    if (!*WndProcEnabled || (lOffset != GWLP_WNDPROC))
        return lValue;

     // Don't handle special addresses
#ifdef _WIN64
     if ((HIWORD((lValue >> 32)) == 0xFFFF) ||
#else
     if ( (HIWORD(lValue) == 0xFFFF)  ||
#endif
          ((ULONG_PTR)lValue & 0x80000000) ) {
        return lValue;
    }

    CreateWndProcApi( "Subclass", (WNDPROC*)&lValue );

    return lValue;
}


VOID
HandleDynamicDllFree(
    ULONG_PTR   DllAddress
    )
{
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress == DllAddress) {
            DllList[i].Unloaded = TRUE;
            // DllList[i].Enabled  = FALSE; Leave enable in case it's reloaded
            DllList[i].Snapped  = FALSE;
            break;
        }
    }
}


ULONG_PTR
HandleGetProcAddress(
    ULONG_PTR ProcAddress
    )
{
    if (ProcAddress == NULL)
        return NULL;

    Thunks = ProcessThunk(ProcAddress, (ULONG_PTR)&ProcAddress, Thunks);

    return ProcAddress;
}

} // extern "C"


VOID
CreateWndProcApi(
    LPCSTR  lpszClassName,
    WNDPROC *pWndProc
    )
{
    PAPI_INFO   ApiInfo;
    DWORD       i;
    PUCHAR      NewThunks;
    CHAR debugBuf[256];

    // Don't re-thunk one of our own thunks
    if (ThunksBase <= (PUCHAR)*pWndProc && (PUCHAR)*pWndProc < Thunks)
        return;

    pTlsSetValue( TlsReEnter, (LPVOID) 1 );

    // Get exclusive access to API memory
    WaitForSingleObject( ApiMemMutex, INFINITE );


    // Check for existing thunk for this window proc
    ApiInfo = (PAPI_INFO)(*WndProcOffset + (ULONG_PTR)DllList);
    for (i=0; i<*WndProcCount; i++,ApiInfo++) {
        if (ApiInfo->Address == (ULONG_PTR)*pWndProc) {
            *pWndProc = (WNDPROC)ApiInfo->ThunkAddress;
            ReleaseMutex(ApiMemMutex);
            pTlsSetValue( TlsReEnter, (LPVOID) 0 );
            return;
        }
    }

    // Allocate an API Info slot
    if (*ApiCount < MAX_APIS) {
        *WndProcOffset -= sizeof(API_INFO);
        *WndProcCount += 1;
        *ApiCount += 1;
        ApiInfo = (PAPI_INFO)(*WndProcOffset + (ULONG_PTR)DllList);
        ApiInfo->Name = *ApiStrings;
        strcpy( (LPSTR)((LPSTR)MemPtr + *ApiStrings), lpszClassName );
        *ApiStrings += (strlen(lpszClassName) + 1);
    }
    else {
        ApiInfo = NULL;
    }


    if (ApiInfo != NULL) {

        ApiInfo->Count = 0;
        ApiInfo->NestCount = 0;
        ApiInfo->Time = 0;
        ApiInfo->CalleeTime = 0;
        ApiInfo->ThunkAddress = 0;
        ApiInfo->Address = (ULONG_PTR)*pWndProc;
        ApiInfo->DllOffset = 0;
        ApiInfo->HardFault  = 0;
        ApiInfo->SoftFault  = 0;
        ApiInfo->CodeFault  = 0;
        ApiInfo->DataFault  = 0;

        NewThunks = CreateMachApiThunk( (PULONG_PTR)pWndProc, Thunks, &WndProcDllInfo, ApiInfo );
        FlushInstructionCache( GetCurrentProcess(), (PVOID)Thunks, (DWORD)(NewThunks - Thunks));
        Thunks = NewThunks;
    }

    ReleaseMutex( ApiMemMutex );
    pTlsSetValue( TlsReEnter, (LPVOID) 0 );

}

BOOL
ProcessApiTable(
    PDLL_INFO DllInfo
    )
{
    ULONG i,j;
    PAPI_MASTER_TABLE ApiMaster = NULL;

    i = 0;
    while( ApiTables[i].Name ) {
        if (_stricmp( ApiTables[i].Name, DllInfo->Name ) == 0) {
            ApiMaster = &ApiTables[i];
            break;
        }
        i += 1;
    }
    if (!ApiMaster) {
        return FALSE;
    }
    if (ApiMaster->Processed) {
        return TRUE;
    }

    i = 0;
    PAPI_TABLE ApiTable = ApiMaster->ApiTable;
    PAPI_INFO ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (ULONG_PTR)DllList);
    while( ApiTable[i].Name ) {
        for (j=0; j<DllInfo->ApiCount; j++) {
            if (strcmp( ApiTable[i].Name, (LPSTR)MemPtr+ApiInfo[j].Name ) == 0) {
                ApiInfo[j].ApiTable = &ApiTable[i];
                ApiInfo[j].ApiTableIndex = i + 1;
                break;
            }
        }
        i += 1;
    }

    ApiMaster->Processed = TRUE;

    return TRUE;
}

PUCHAR
CreateApiThunk(
    ULONG_PTR   IatAddr,
    PUCHAR      Text,
    PDLL_INFO   DllInfo,
    PAPI_INFO   ApiInfo
    )
{
    CHAR debugBuf[256];
#if DBG
    _stprintf(debugBuf, "CreateApiThunk: %s:%s\n",DllInfo->Name, (LPSTR)MemPtr + ApiInfo->Name);
    OutputDebugString(debugBuf);
#endif

    LPSTR Name = (LPSTR)MemPtr+ApiInfo->Name;
    if ((strcmp(Name,"FlushInstructionCache")==0)      ||
        (strcmp(Name,"NtFlushInstructionCache")==0)    ||
        (strcmp(Name,"ZwFlushInstructionCache")==0)    ||
        (strcmp(Name,"VirtualProtect")==0)             ||
        (strcmp(Name,"VirtualProtectEx")==0)           ||
        (strcmp(Name,"NtProtectVirtualMemory")==0)     ||
        (strcmp(Name,"ZwProtectVirtualMemory")==0)     ||
        (strcmp(Name,"QueryPerformanceCounter")==0)    ||
        (strcmp(Name,"NtQueryPerformanceCounter")==0)  ||
        (strcmp(Name,"ZwQueryPerformanceCounter")==0)  ||
        (strcmp(Name,"NtCallbackReturn")==0)           ||
        (strcmp(Name,"ZwCallbackReturn")==0)           ||
        (strcmp(Name,"_chkstk")==0)                    ||
        (strcmp(Name,"_alloca_probe")==0)              ||
        (strcmp(Name,"GetLastError")==0)               ||
        (strcmp(Name,"SetLastError")==0)               ||
        (strcmp(Name,"_setjmp")==0)                    ||
        (strcmp(Name,"_setjmp3")==0)                   ||
        (strcmp(Name,"longjmp")==0)                    ||
        (strcmp(Name,"_longjmpex")==0)                 ||
        (strcmp(Name,"TlsGetValue")==0)                ||
        (strcmp(Name,"TlsSetValue")==0)                ||
        (strncmp(Name,"_Ots",4)==0)) {
            return Text;
    }


    PUCHAR stat = CreateMachApiThunk( (PULONG_PTR)IatAddr, Text, DllInfo, ApiInfo );

    return stat;
}

LPSTR
UnDname(
    LPSTR sym,
    LPSTR undecsym,
    DWORD bufsize
    )
{
    if (*sym != '?') {
        return sym;
    }

    if (UnDecorateSymbolName( sym,
                          undecsym,
                          bufsize,
                          UNDNAME_COMPLETE                |
                          UNDNAME_NO_LEADING_UNDERSCORES  |
                          UNDNAME_NO_MS_KEYWORDS          |
                          UNDNAME_NO_FUNCTION_RETURNS     |
                          UNDNAME_NO_ALLOCATION_MODEL     |
                          UNDNAME_NO_ALLOCATION_LANGUAGE  |
                          UNDNAME_NO_MS_THISTYPE          |
                          UNDNAME_NO_CV_THISTYPE          |
                          UNDNAME_NO_THISTYPE             |
                          UNDNAME_NO_ACCESS_SPECIFIERS    |
                          UNDNAME_NO_THROW_SIGNATURES     |
                          UNDNAME_NO_MEMBER_TYPE          |
                          UNDNAME_NO_RETURN_UDT_MODEL     |
                          UNDNAME_NO_ARGUMENTS            |
                          UNDNAME_NO_SPECIAL_SYMS         |
                          UNDNAME_NAME_ONLY )) {

        return undecsym;
    }

    return sym;
}

extern "C" ULONG
GetApiInfo(
    PAPI_INFO   *ApiInfo,
    PDLL_INFO   *DllInfo,
    PULONG      ApiFlag,
    ULONG       Address
    )
{
    ULONG       i;
    ULONG       rval;
    LONG        High;
    LONG        Low;
    LONG        Middle;
    PAPI_INFO   ai;


    *ApiInfo = NULL;
    *DllInfo = NULL;
    *ApiFlag = APITYPE_NORMAL;


#if defined(_M_IX86)

    //
    // the call instruction use to call penter
    // is 5 bytes long
    //
    Address -= 5;
    rval = 1;

#elif defined(_M_MRX000)

    //
    // search for the beginning of the prologue
    //
    PULONG Instr = (PULONG) (Address - 4);
    i = 0;
    rval = 0;
    while( i < 16 ) {
        //
        // the opcode for the addiu instruction is 9
        //
        if ((*Instr >> 16) == 0xafbf) {
            //
            // find the return address
            //
            rval = *Instr & 0xffff;
            break;
        }
        Instr -= 1;
        i += 1;
    }
    if (i == 16 || rval == 0) {
        return 0;
    }

#elif defined(_M_ALPHA)

    rval = 1;

#elif defined(_M_PPC)

    //
    // On PPC, the penter call sequence looks like this:
    //
    //      mflr    r0
    //      stwu    sp,-0x40(sp)
    //      bl      ..penter
    //
    // So the function entry point is the return address - 12.
    //
    // (We really should do a function table lookup here, so
    // we're not dependent on the sequence...)
    //

    Address -= 12;
    rval = 1;

#else
#error( "unknown target machine" );
#endif

    for (i=0; i<MAX_DLLS; i++) {
        if (Address >= DllList[i].BaseAddress &&
            Address <  DllList[i].BaseAddress + DllList[i].Size) {
                *DllInfo = &DllList[i];
                break;
        }
    }

    if (!*DllInfo) {
        return 0;
    }

    ai = (PAPI_INFO)((*DllInfo)->ApiOffset + (ULONG_PTR)DllList);

    Low = 0;
    High = (*DllInfo)->ApiCount - 1;

    while (High >= Low) {
        Middle = (Low + High) >> 1;
        if (Address < ai[Middle].Address) {

            High = Middle - 1;

        } else if (Address > ai[Middle].Address) {

            Low = Middle + 1;

        } else {

            *ApiInfo = &ai[Middle];
            break;

        }
    }

    if (!*ApiInfo) {
        return 0;
    }

    if (Address == LoadLibraryA_Addr) {
        *ApiFlag = APITYPE_LOADLIBRARYA;
    } else if (Address == LoadLibraryW_Addr) {
        *ApiFlag = APITYPE_LOADLIBRARYW;
    } else if (Address == FreeLibrary_Addr) {
        *ApiFlag = APITYPE_FREELIBRARY;
    } else if (Address == GetProcAddress_Addr) {
        *ApiFlag = APITYPE_GETPROCADDRESS;
    }
    return rval;
}


extern "C" VOID
ApiTrace(
    PAPI_INFO   ApiInfo,
    ULONG_PTR   Arg[MAX_TRACE_ARGS],
    ULONG       ReturnValue,
    ULONG       Caller,
    DWORDLONG   EnterTime,
    DWORDLONG   Duration,
    ULONG       LastError
    )
{
    PTRACE_ENTRY TraceEntry;
    ULONG        TraceEntryLen;
    PTHREAD_STACK ThreadStack;
    LPSTR        TraceString;
    LPSTR        TraceLimit;
    CHAR         debugBuf[128];
    ULONG_PTR    len;
    DWORD        *dwPtr;
    ULONG        i;
    ULONG        ArgCount;

    __try {

        pTlsSetValue( TlsReEnter, (LPVOID) 1 );
        WaitForSingleObject( ApiTraceMutex, INFINITE );

        // if trace buffer has room for another entry
        if ( TraceBuffer->Offset + sizeof(TRACE_ENTRY) < TraceBuffer->Size ) {

            TraceEntry = (PTRACE_ENTRY)((PCHAR)TraceBuffer->Entry + TraceBuffer->Offset);
            TraceEntry->Address       = ApiInfo->Address;
            TraceEntry->ReturnValue   = ReturnValue;
            TraceEntry->Caller        = Caller;
            TraceEntry->LastError     = LastError;
            TraceEntry->ApiTableIndex = ApiInfo->ApiTableIndex;
            TraceEntry->EnterTime     = EnterTime;
            TraceEntry->Duration      = Duration;

            ArgCount = (ApiInfo->ApiTable && ApiInfo->ApiTable->ArgCount) ?
                        ApiInfo->ApiTable->ArgCount : DFLT_TRACE_ARGS;

            for (i=0; i<ArgCount; i++)
                TraceEntry->Args[i] = Arg[i];

            ThreadStack = (PTHREAD_STACK)pTlsGetValue(TlsStack);
            TraceEntry->ThreadNum = ThreadStack->ThreadNum;
            TraceEntry->Level = (DWORD)((ThreadStack->Pointer - (DWORD_PTR)ThreadStack->Body))
                                  / FRAME_SIZE - 1;

            TraceEntryLen = sizeof(TRACE_ENTRY);

            if (ApiInfo->ApiTable && ApiInfo->ApiTable->ArgCount) {

                PAPI_TABLE ApiTable = ApiInfo->ApiTable;

                TraceString = (LPSTR)TraceEntry + sizeof(TRACE_ENTRY);
                TraceLimit = (LPSTR)TraceBuffer->Entry + TraceBuffer->Size;

                for (i=0; i<ApiTable->ArgCount; i++) {

                    switch( LOWORD(ApiTable->ArgType[i]) ) {
                        case T_DWORD:
                            break;

                        case T_DWORDPTR:
                            if (TraceEntry->Args[i]) {
                                TraceEntry->Args[i] = *(DWORD*)(TraceEntry->Args[i] + HIWORD(ApiTable->ArgType[i]));
                            }
                            break;

                        case T_DLONGPTR:
                            // Warning - this type wipes out the following arg to save a DWORDLONG
                            if (TraceEntry->Args[i]) {
                                dwPtr = (DWORD*) (TraceEntry->Args[i] + HIWORD(ApiTable->ArgType[i]));
                                TraceEntry->Args[i] = dwPtr[0];
                                TraceEntry->Args[i+1] = dwPtr[1];
                            }
                            break;


                        case T_LPSTRC:
                        case T_LPSTR:
                            //
                            // go read the string
                            //
                            {
                                if (HIWORD(TraceEntry->Args[i]) == 0)
                                    len = 0;
                                else if (ApiTable->ArgType[i] == T_LPSTRC)
                                    len = TraceEntry->Args[i+1];
                                else {
                                    TraceEntry->Args[i] += HIWORD(ApiTable->ArgType[i]);
                                    len = strlen( (LPSTR) TraceEntry->Args[i] );
                                }

                                if ( TraceString + len >= TraceLimit )
                                    len = 0;

                                if (len)
                                    memcpy(TraceString, (LPSTR)TraceEntry->Args[i], len);

                                TraceString[len] = 0;

                                TraceString += Align(sizeof(WCHAR), (len + 1));
                            }
                            break;

                        case T_LPWSTRC:
                        case T_LPWSTR:
                            //
                            // go read the string
                            //
                            {
                                if (HIWORD(TraceEntry->Args[i]) == 0)
                                    len = 0;
                                else if (ApiTable->ArgType[i] == T_LPSTRC)
                                    len = TraceEntry->Args[i+1];
                                else {
                                    TraceEntry->Args[i] += HIWORD(ApiTable->ArgType[i]);
                                    len = (wcslen( (LPWSTR) TraceEntry->Args[i] ));
                                }

                                if ( TraceString + len * sizeof(WCHAR) >= TraceLimit )
                                    len = 0;

                                if (len)
                                    memcpy( (LPWSTR)TraceString, (LPWSTR) TraceEntry->Args[i], len * sizeof(WCHAR) );

                                ((LPWSTR)TraceString)[len] = 0;

                                 TraceString += (len + 1) * sizeof(WCHAR);
                            }
                            break;

                        case T_UNISTR:
                        case T_OBJNAME:
                            //
                            // go read the string
                            //
                            {
                                PUNICODE_STRING pustr;

                                if (ApiTable->ArgType[i] == T_OBJNAME)
                                    pustr = ((POBJECT_ATTRIBUTES)TraceEntry->Args[i])->ObjectName;
                                else
                                    pustr = (PUNICODE_STRING)TraceEntry->Args[i];

                                len = pustr->Length + sizeof(WCHAR);
                                if (pustr != NULL && TraceString + len < TraceLimit) {
                                    wcsncpy( (LPWSTR)TraceString, pustr->Buffer, pustr->Length/sizeof(WCHAR));
                                    ((LPWSTR)TraceString)[pustr->Length/sizeof(WCHAR)] = 0;
                                    }
                                else {
                                    len = sizeof(WCHAR);
                                    ((LPWSTR)TraceString)[0] = 0;
                                }

                                TraceString += len;
                            }
                            break;
                    }
                }
                // align overall entry length to DWORDLONG
                TraceEntryLen = (DWORD)(Align(sizeof(DWORDLONG), TraceString - (LPSTR)TraceEntry));
            }
            TraceBuffer->Count += 1;
            TraceEntry->SizeOfStruct = TraceEntryLen;
            TraceBuffer->Offset += TraceEntryLen;
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        ;
    }

     ReleaseMutex( ApiTraceMutex );
     pTlsSetValue( TlsReEnter, (LPVOID) 0 );
}

VOID
CalibrateThunk(
    VOID
    )
{
    int         i;
    DLL_INFO    CalibDllInfo;
    API_INFO    Calib1ApiInfo,Calib2ApiInfo;
    PUCHAR      NewThunks;
    ULONGLONG   MinTime;
    CHAR        debugbuf[128];

    // Setup calibration Dll
    strcpy(CalibDllInfo.Name, "Calib");
    CalibDllInfo.Enabled = TRUE;

    // Setup calibration Api
    Calib1ApiInfo.Count = 0;
    Calib1ApiInfo.NestCount = 0;
    Calib1ApiInfo.Time = 0;
    Calib1ApiInfo.CalleeTime = 0;
    Calib1ApiInfo.ThunkAddress = 0;
    Calib1ApiInfo.TraceEnabled = 0;
    Calib1ApiInfo.Address = (ULONG_PTR)Calib1Func;

    Calib2ApiInfo.Count = 0;
    Calib2ApiInfo.NestCount = 0;
    Calib2ApiInfo.Time = 0;
    Calib2ApiInfo.CalleeTime = 0;
    Calib2ApiInfo.ThunkAddress = 0;
    Calib2ApiInfo.TraceEnabled = 0;
    Calib2ApiInfo.Address = (ULONG_PTR)Calib2Func;

    // Create thunks
    NewThunks = CreateMachApiThunk( (PULONG_PTR)&Calib1Thunk, Thunks, &CalibDllInfo, &Calib1ApiInfo );
    NewThunks = CreateMachApiThunk( (PULONG_PTR)&Calib2Thunk, NewThunks, &CalibDllInfo, &Calib2ApiInfo );
    FlushInstructionCache( GetCurrentProcess(), (PVOID)Thunks, (DWORD)(NewThunks - Thunks));
    Thunks = NewThunks;

    ThunkOverhead = 0;
    ThunkCallOverhead = 0;

    // Call the calibration function via the thunk
    MinTime = 1000000;
    for (i=0; i<1000; i++) {

        Calib1ApiInfo.Time = 0;

        (*Calib1Thunk)();

        if (Calib1ApiInfo.Time < MinTime)
            MinTime = Calib1ApiInfo.Time;
    }

    // Take min time as the overhead
    ThunkOverhead = (DWORD)MinTime;

    MinTime = 1000000;
    for (i=0; i<1000; i++) {

        Calib2ApiInfo.Time = 0;

        (*Calib2Thunk)();

        if (Calib2ApiInfo.Time < MinTime)
            MinTime = Calib1ApiInfo.Time;
    }

    ThunkCallOverhead = (DWORD)MinTime;
}

// Null function for measuring overhead
VOID
Calib1Func(
    VOID
    )
{
    return;
}

// Calling function for measuring overhead
VOID
Calib2Func(
    VOID
    )
{
    (*Calib1Thunk)();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\actools\qshimapp\qshimapp.c ===
/***************************************************************************
* Quick shim application tools
*
* Author: clupu (Feb 16, 2000)
* 
\**************************************************************************/

#include "windows.h"
#include "commctrl.h"
#include "commdlg.h"
#include "resource.h"
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>

#include "shimWin2000.h"
#include "shimWhistler.h"

#include "..\acFileAttr\acFileAttr.h"

/*
 * Global Variables
 */

HINSTANCE g_hInstance;
HWND      g_hDlg;

char      g_szBinary[MAX_PATH];         // the full path of the main binary being shimmed
char      g_szShortName[128];           // the short name of the main EXE
char*     g_pszShimDLL;

char      g_szBinaryOther[MAX_PATH];    // the full path of the optional EXE that will
                                        // be launched instead (setup case)

HWND      g_hwndShimTree;               // the handle to the tree view control
                                        // containing all the shims available

HWND      g_hwndFilesTree;              // the handle to the tree view control
                                        // containing the matching files selected

BOOL      g_bWin2k;                     // are we running on Win2k or Whistler

BOOL      g_bRunOther;                  // TRUE - run g_szBinaryOther instead 

BOOL      g_bSimpleEdition;             // simple or dev edition

RECT      g_rcDlgBig, g_rcDlgSmall;     // rectangle of the simple and the dev edition
                                        // of the dialog

#if DBG

/*********************************************************************
* LogMsgDbg
*
*********************************************************************/
void LogMsgDbg(
    LPSTR pszFmt,
    ... )
{
    CHAR gszT[1024];
    va_list arglist;

    va_start(arglist, pszFmt);
    _vsnprintf(gszT, 1023, pszFmt, arglist);
    gszT[1023] = 0;
    va_end(arglist);
    
    OutputDebugString(gszT);
}

#endif // DBG

/*******************************************************************************
* CenterWindow
*
*  This function must be called at the WM_INIDIALOG in order to
*  move the dialog window centered in the client area of the
*  parent or owner window.
*******************************************************************************/
BOOL CenterWindow(
    HWND hWnd)
{
    RECT    rectWindow, rectParent, rectScreen;
    int     nCX, nCY;
    HWND    hParent;
    POINT   ptPoint;

    hParent =  GetParent(hWnd);
    if (hParent == NULL)
        hParent = GetDesktopWindow();

    GetWindowRect(hParent,            (LPRECT)&rectParent);
    GetWindowRect(hWnd,               (LPRECT)&rectWindow);
    GetWindowRect(GetDesktopWindow(), (LPRECT)&rectScreen);

    nCX = rectWindow.right  - rectWindow.left;
    nCY = rectWindow.bottom - rectWindow.top;

    ptPoint.x = ((rectParent.right  + rectParent.left) / 2) - (nCX / 2);
    ptPoint.y = ((rectParent.bottom + rectParent.top ) / 2) - (nCY / 2);

    if (ptPoint.x < rectScreen.left)
        ptPoint.x = rectScreen.left;
    if (ptPoint.x > rectScreen.right  - nCX)
        ptPoint.x = rectScreen.right  - nCX;
    if (ptPoint.y < rectScreen.top)
        ptPoint.y = rectScreen.top;
    if (ptPoint.y > rectScreen.bottom - nCY)
        ptPoint.y = rectScreen.bottom - nCY;

    if (GetWindowLong(hWnd, GWL_STYLE) & WS_CHILD)
        ScreenToClient(hParent, (LPPOINT)&ptPoint);

    if (!MoveWindow(hWnd, ptPoint.x, ptPoint.y, nCX, nCY, TRUE))
        return FALSE;

    return TRUE;
}

/*********************************************************************
* AddMatchingFile
*
*  Adds a matching file and it's attributes to the tree
*
*********************************************************************/
VOID
AddMatchingFile(
    HWND  hdlg,
    char* pszFullPath,
    char* pszRelativePath,
    BOOL  bMainEXE)
{
    HANDLE         hMgr;
    TVINSERTSTRUCT is;
    HTREEITEM      hParent;
    int            i;
    int            nAttrCount;
    char           szItem[256];
    
    hMgr = ReadFileAttributes(pszFullPath, &nAttrCount);

    is.hParent      = TVI_ROOT;
    is.hInsertAfter = TVI_LAST;
    is.item.lParam  = (LONG)hMgr;
    is.item.mask    = TVIF_TEXT | TVIF_PARAM;
    is.item.pszText = pszRelativePath;

    hParent = TreeView_InsertItem(g_hwndFilesTree, &is);

    is.hParent = hParent;
    
    is.item.mask    = TVIF_TEXT;
    is.item.pszText = szItem;

    is.item.mask   |= TVIF_STATE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    is.item.iImage  = 0;
    
    is.item.iSelectedImage = 1;
    is.item.state          = INDEXTOSTATEIMAGEMASK(1);
    is.item.stateMask      = TVIS_STATEIMAGEMASK;

    for (i = 0; i < nAttrCount; i++) {
        
        PSTR      pszValue;
        DWORD     id;
        HTREEITEM hItem;

        if (!IsAttrAvailable(hMgr, i))
            continue;
        
        // filter the attributes for Whistler (temporary)

        if (!g_bWin2k) {
            id = GetAttrId(i);
            if (id != VTID_FILESIZE && id != VTID_CHECKSUM)
                continue;
        }

        pszValue = GetAttrValue(hMgr, i);
        
        if (pszValue == NULL)
            continue;
        
        wsprintf(szItem, "%s: %s", GetAttrName(i), pszValue);
        
        is.item.lParam = i;
        hItem = TreeView_InsertItem(g_hwndFilesTree, &is);
    }

    TreeView_Expand(g_hwndFilesTree, hParent, TVE_EXPAND);
}

/*********************************************************************
* AddNewMainBinary
*
*  Start with a new main executable
*
*********************************************************************/
VOID
AddNewMainBinary(
    HWND hdlg)
{
    char szMainEXE[128];

    TreeView_DeleteAllItems(g_hwndFilesTree);

    wsprintf(szMainEXE, "Main executable (%s)", g_szShortName);

    AddMatchingFile(hdlg, g_szBinary, szMainEXE, TRUE);
}

/*********************************************************************
* DoBrowseForApp
*
*  Browse for the main executable for which a shim will be applied
*
*********************************************************************/
VOID
DoBrowseForApp(
    HWND hdlg)
{
	OPENFILENAME ofn;
    
    g_szBinary[0] = 0;
    
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hdlg;
    ofn.hInstance         = 0;
    ofn.lpstrFilter       = NULL;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = g_szBinary;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = g_szShortName;
    ofn.nMaxFileTitle     = 128;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = "Choose an executable binary to shim";
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_NOTESTFILECREATE | 
                            OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt       = "EXE";
    
    if (GetOpenFileName(&ofn)) {
        
        SetDlgItemText(hdlg, IDC_BINARY, g_szBinary);

        EnableWindow(GetDlgItem(hdlg, IDC_ADD_MATCHING), TRUE);
        AddNewMainBinary(hdlg);
    }
}

/*********************************************************************
* DoBrowseOther
*
*  Browse for a different EXE that will be launched instead of the
*  main EXE selected. This is for the setup case where setup.exe
*  launches another process _INS0432._MP for example.
*
*********************************************************************/
VOID
DoBrowseOther(
    HWND hdlg)
{
	OPENFILENAME ofn;
    
    g_szBinaryOther[0] = 0;
    
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hdlg;
    ofn.hInstance         = 0;
    ofn.lpstrFilter       = NULL;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = g_szBinaryOther;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = NULL;
    ofn.nMaxFileTitle     = 0;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = "Choose the application to run";
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_NOTESTFILECREATE | 
                            OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt       = "EXE";
    
    if (GetOpenFileName(&ofn)) {
        SetDlgItemText(hdlg, IDC_RUN_OTHER, g_szBinaryOther);
    }
}

/*********************************************************************
* DoAddMatchingFile
*
*********************************************************************/
VOID
DoAddMatchingFile(
    HWND hdlg)
{
	char         szFullPath[MAX_PATH];
    char         szShortName[128];
    char         szRelativePath[MAX_PATH];
    OPENFILENAME ofn;
    
    szFullPath[0] = 0;
    
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hdlg;
    ofn.hInstance         = 0;
    ofn.lpstrFilter       = NULL;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = szFullPath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = szShortName;
    ofn.nMaxFileTitle     = 128;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = "Choose the application to run";
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_NOTESTFILECREATE | 
                            OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt       = "EXE";
    
    if (GetOpenFileName(&ofn)) {
        
        char* pszBin;
        char* pszNew;

        // need to modify the path to be a relative path to g_szBinary

        if (g_szBinary[0] != szFullPath[0]) {
            MessageBox(hdlg, "A matching file must be located on the same drive",
                       "Warning", MB_ICONEXCLAMATION | MB_OK);
            return;
        }

        // walk both strings untill they differ
        
        pszBin = g_szBinary;
        pszNew = szFullPath;

        szRelativePath[0] = 0;

        while (*pszBin == *pszNew) {
            pszBin++;
            pszNew++;
        }

        // go back to the last \
        
        while (*(pszBin - 1) != '\\') {
            pszBin--;
            pszNew--;
        }

        while (lstrcmp(pszBin, g_szShortName) != 0) {
            
            // add ..\ each time a subdir is identified (not the short name)
            
            lstrcat(szRelativePath, "..\\");

            while (*pszBin != '\\')
                pszBin++;
            
            pszBin++;
        }
        lstrcat(szRelativePath, pszNew);
        
        // finally add the maching file
        AddMatchingFile(hdlg, szFullPath, szRelativePath, FALSE);
    }
}

/*********************************************************************
* PopulateTree
*
*********************************************************************/
VOID
PopulateTree(
    HWND hTree)
{
    TVINSERTSTRUCT is;
    PFIX           pFix;

    TreeView_DeleteAllItems(hTree);

    if (g_bWin2k) {
        pFix = ReadFixes_Win2000();
        if (pFix == NULL) {
            MessageBox(NULL,
                       "You need to have a copy of the file Shim2000.txt"
                       " in the directory where you started QShimApp.exe",
                       "Error", MB_ICONEXCLAMATION | MB_OK);
            return;
        }
    } else {
        pFix = ReadFixes_Whistler();
        
        if (pFix == NULL) {
            MessageBox(NULL,
                       "The shim database doesn't exist or it is corrupted",
                       "Error", MB_ICONEXCLAMATION | MB_OK);
            return;
        }
    }

    is.hParent      = TVI_ROOT;
    is.hInsertAfter = TVI_SORT;
    is.item.mask    = TVIF_TEXT | TVIF_PARAM;
    
    // walk the list and add all the fixes to the tree view

    while (pFix != NULL) {
        is.item.lParam  = (LPARAM)pFix;
        is.item.pszText = pFix->pszName;
    
        TreeView_InsertItem(hTree, &is);

        pFix = pFix->pNext;
    }
}

/*********************************************************************
* RunShimmedApp
*
*********************************************************************/
DWORD WINAPI
RunShimmedApp(
    LPVOID lParam)
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    
    ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);

    // Try to run the app
    
    if (!CreateProcess(NULL,
                  (g_bRunOther ? g_szBinaryOther : g_szBinary),
                  NULL,
                  NULL,
                  FALSE,
                  NORMAL_PRIORITY_CLASS,
                  NULL,
                  NULL,
                  &si,
                  &pi)) {
        
        LogMsg("CreateProcess failed with status: 0x%X\n", GetLastError());
        return 0;
    }
    
    CloseHandle(pi.hThread);
    
    WaitForSingleObject(pi.hProcess, INFINITE);

    CloseHandle(pi.hProcess);
    
    if (g_bWin2k) {
        CleanupShimForApp_Win2000();
    } else {
        CleanupShimForApp_Whistler();
    }

    return 1;
}

/*********************************************************************
* DoRunApp
*
*********************************************************************/
VOID
DoRunApp(
    HWND hdlg)
{
    HANDLE hThread;
    DWORD  dwThreadId;
    BOOL   bCreateFile;
    
    // Make sure an app was selected first

    if (g_szBinary[0] == 0) {
        MessageBox(hdlg,
                   "You need to select the application first",
                   "Error", MB_ICONEXCLAMATION | MB_OK);
        return;
    }
    
    // check to see if another app was selected to run
    
    if (SendDlgItemMessage(hdlg, IDC_RUN_OTHER_CHECK, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        
        g_bRunOther = TRUE;
    
        // Make sure the other app is selected
        
        if (g_szBinaryOther[0] == 0) {
        
            GetDlgItemText(hdlg, IDC_RUN_OTHER, g_szBinaryOther, MAX_PATH);

            if (g_szBinaryOther[0] == 0) {
                MessageBox(hdlg,
                           "You need to select the other application first",
                           "Error", MB_ICONEXCLAMATION | MB_OK);
                return;
            }
        }
    } else {
        g_bRunOther = FALSE;
    }
    
    bCreateFile = (SendDlgItemMessage(hdlg, IDC_CREATEFILE, BM_GETCHECK, 0, 0) == BST_CHECKED);
    
    if (g_bWin2k) {
        if (!AddShimForApp_Win2000(g_hwndShimTree, g_hwndFilesTree, g_szShortName, bCreateFile)) {
            LogMsg("AddShimForApp_Win2000 failed...\n");
            return;
        }
    } else {
        if (!AddShimForApp_Whistler(g_hwndShimTree, g_hwndFilesTree, g_szShortName, bCreateFile)) {
            LogMsg("AddShimForApp_Whistler failed...\n");
            return;
        }
    }
    
    // Create a thread that will run the app and wait on it to end.
    // This will allow the app to still process messages and thus it
    // will not block apps that broadcast messages blocking
    // themselves.
    
    hThread = CreateThread(
                        NULL,
                        0,
                        RunShimmedApp,
                        NULL,
                        0,
                        &dwThreadId);
    
    if (hThread != NULL) {
        CloseHandle(hThread);
    }
}

/*********************************************************************
* HideStrictGroup
*
*********************************************************************/
VOID
HideStrictGroup(
    HWND hdlg,
    BOOL bHide)
{
static BOOL sbFirstTime = TRUE;

    int   i, nShow;
    DWORD arrId[] = {IDC_STRICT_GROUP,
                     IDC_COMMENT,
                     IDC_ADD_MATCHING,
                     IDC_FILE_ATTRIBUTES_STATIC,
                     IDC_ATTRIBUTES,
                     IDC_CREATEFILE,
                     IDC_CREATEFILE_STATIC,
                     0};

    if (!bHide) {
        SetWindowPos(hdlg, NULL, 0, 0,
                     g_rcDlgBig.right - g_rcDlgBig.left,
                     g_rcDlgBig.bottom - g_rcDlgBig.top,
                     SWP_NOMOVE | SWP_NOZORDER);
        nShow = SW_SHOW;
        g_bSimpleEdition = FALSE;
        SetDlgItemText(hdlg, IDC_DETAILS, "<< Simple");
        
        // The first time the user goes to the dev edition center
        // the big dialog on the screen

        if (sbFirstTime) {
            sbFirstTime = FALSE;
            CenterWindow(hdlg);
        }
    } else {
        nShow = SW_HIDE;
        g_bSimpleEdition = TRUE;
        SetDlgItemText(hdlg, IDC_DETAILS, "Advanced >>");
    }
    
    for (i = 0; arrId[i] != 0; i++) {
        ShowWindow(GetDlgItem(hdlg, arrId[i]), nShow);
    }

    if (bHide) {
        SetWindowPos(hdlg, NULL, 0, 0,
                     g_rcDlgSmall.right - g_rcDlgSmall.left,
                     g_rcDlgSmall.bottom - g_rcDlgSmall.top,
                     SWP_NOMOVE | SWP_NOZORDER);
    }

}

/*********************************************************************
* DoDetails
*
*********************************************************************/
VOID
DoDetails(
    HWND hdlg)
{
    HideStrictGroup(hdlg, !g_bSimpleEdition);
}

/*********************************************************************
* Restart
*
*********************************************************************/
VOID
Restart(
    HWND hdlg)
{
    PopulateTree(g_hwndShimTree);
}

/*********************************************************************
* DoInitDialog
*
*********************************************************************/
VOID
DoInitDialog(
    HWND hdlg)
{
    HICON hIcon;
    RECT  rcGroup, rcList;

    g_hDlg = hdlg;

    GetWindowRect(hdlg, &g_rcDlgBig);

    GetWindowRect(GetDlgItem(hdlg, IDC_STRICT_GROUP), &rcGroup);
    GetWindowRect(GetDlgItem(hdlg, IDC_ATTRIBUTES), &rcList);

    g_rcDlgSmall.left   = g_rcDlgBig.left;
    g_rcDlgSmall.top    = g_rcDlgBig.top;
    g_rcDlgSmall.bottom = g_rcDlgBig.bottom;
    g_rcDlgSmall.right  = g_rcDlgBig.right -
                            (rcGroup.right - rcGroup.left) -
                            (rcList.left - rcGroup.left);

    HideStrictGroup(hdlg, TRUE);

    CenterWindow(hdlg);

    EnableWindow(GetDlgItem(hdlg, IDC_ADD_MATCHING), FALSE);

    if (g_bWin2k) {
        SendDlgItemMessage(hdlg, IDC_WIN2K, BM_SETCHECK, BST_CHECKED, 0);
    } else {
        SendDlgItemMessage(hdlg, IDC_WHISTLER, BM_SETCHECK, BST_CHECKED, 0);
    }

    hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICON));

    SetClassLongPtr(hdlg, GCLP_HICON, (LONG_PTR)hIcon);

    g_hwndShimTree = GetDlgItem(hdlg, IDC_TREE);
    g_hwndFilesTree = GetDlgItem(hdlg, IDC_ATTRIBUTES);

    HIMAGELIST hImage = ImageList_Create(
    int cx, 	
    int cy, 	
    UINT flags, 	
    int cInitial, 	
    int cGrow	
   );	

    g_szBinary[0] = 0;

    PopulateTree(g_hwndShimTree);
}

/*********************************************************************
* QShimAppDlgProc
*
*********************************************************************/
INT_PTR CALLBACK
QShimAppDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
        DoInitDialog(hdlg);
        break;

    case WM_NOTIFY:
        
        if (wParam == IDC_TREE) {
            LPNMHDR pnm = (LPNMHDR)lParam;

            switch (pnm->code) {
            
            case TVN_SELCHANGED:
                {
                    LPNMTREEVIEW lpnmtv;
                    PFIX         pFix;

                    lpnmtv = (LPNMTREEVIEW)lParam;
                    pFix = (PFIX)lpnmtv->itemNew.lParam;
        
                    SetDlgItemText(hdlg, IDC_SHIM_DESCRIPTION, pFix->pszDesc);
                    break;
                }
            default:
                break;
            }
        }
        break;

    case WM_DESTROY:
        if (g_bWin2k) {
            CleanupShimForApp_Win2000();
        } else {
            CleanupShimForApp_Whistler();
        }
        
        break;

    case WM_COMMAND:
        switch (wCode) {
        
        case IDC_RUN:
            DoRunApp(hdlg);
            break;
        
        case IDC_WIN2K:
            g_bWin2k = TRUE;
            Restart(hdlg);
            break;
        
        case IDC_WHISTLER:
            g_bWin2k = FALSE;
            Restart(hdlg);
            break;
        
        case IDC_BROWSE:
            DoBrowseForApp(hdlg);
            break;
        
        case IDC_BROWSE_OTHER:
            DoBrowseOther(hdlg);
            break;
        
        case IDC_DETAILS:
            DoDetails(hdlg);
            break;

        case IDC_ADD_MATCHING:
            DoAddMatchingFile(hdlg);
            break;

        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/*********************************************************************
* WinMain
*
*********************************************************************/
int WINAPI
WinMain(
    HINSTANCE hInst,
    HINSTANCE hInstPrev,
    LPSTR     lpszCmd,
    int       swShow)
{
    char   szShimDB[MAX_PATH];
    HANDLE hFile;

    InitCommonControls();

    g_hInstance = hInst;

    // find out if we're on Whistler or not

    GetSystemWindowsDirectory(szShimDB, MAX_PATH);
    lstrcat(szShimDB, "\\AppPatch\\sysmain.sdb");
    
    hFile = CreateFile(
                szShimDB,
                GENERIC_READ,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        LogMsg("Running on Win2k\n");
        g_bWin2k = TRUE;
    } else {
        CloseHandle(hFile);
        LogMsg("Running on Whistler\n");
        g_bWin2k = FALSE;
    }

    DialogBox(hInst,
              MAKEINTRESOURCE(IDD_DIALOG),
              GetDesktopWindow(),
              QShimAppDlgProc);

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apidll\apidllp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apidllp.h

Abstract:

    Common header file for APIDLL data structures.

Author:

    Wesley Witt (wesw) 12-July-1995

Environment:

    User Mode

--*/
extern "C" {
#include <nt.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbghelp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "apimon.h"

#if defined(_M_ALPHA)
#define FRAME_SIZE          128
#else
#define FRAME_SIZE          96
#endif

#define MAX_FRAMES          512
#define MAX_STACK_SIZE      (MAX_FRAMES * FRAME_SIZE)

typedef struct _THREAD_STACK {
    DWORD_PTR Pointer;
    DWORD     ThreadNum;
    CHAR      Body[MAX_STACK_SIZE];
} THREAD_STACK, *PTHREAD_STACK;

extern "C" {
typedef DWORD  (__stdcall *PGETCURRENTTHREADID)(VOID);
typedef LPVOID (__stdcall *PTLSGETVALUE)(DWORD);
typedef BOOL   (__stdcall *PTLSSETVALUE)(DWORD,LPVOID);
typedef LPVOID (__stdcall *PVIRTUALALLOC)(LPVOID,DWORD,DWORD,DWORD);
typedef DWORD  (__stdcall *PGETLASTERROR)(VOID);
typedef VOID   (__stdcall *PSETLASTERROR)(DWORD);
typedef BOOL   (__stdcall *PQUERYPERFORMANCECOUNTER)(LARGE_INTEGER *);

extern PVOID                    MemPtr;
extern LPDWORD                  ApiCounter;
extern LPDWORD                  ApiTraceEnabled;
extern DWORD                    TlsReEnter;
extern DWORD                    TlsStack;
extern PTLSGETVALUE             pTlsGetValue;
extern PTLSSETVALUE             pTlsSetValue;
extern PGETLASTERROR            pGetLastError;
extern PSETLASTERROR            pSetLastError;
extern PQUERYPERFORMANCECOUNTER pQueryPerformanceCounter;
extern PVIRTUALALLOC            pVirtualAlloc;
extern DWORD                    ThunkOverhead;
extern DWORD                    ThunkCallOverhead;
}


enum {
    APITYPE_NORMAL,
    APITYPE_LOADLIBRARYA,
    APITYPE_LOADLIBRARYW,
    APITYPE_FREELIBRARY,
    APITYPE_REGISTERCLASSA,
    APITYPE_REGISTERCLASSW,
    APITYPE_GETPROCADDRESS,
    APITYPE_SETWINDOWLONG,
    APITYPE_WNDPROC
};


extern "C" void
ApiMonThunk(
    void
    );

extern "C" void
ApiMonThunkComplete(
    void
    );

extern "C" VOID
HandleDynamicDllLoadA(
    ULONG_PTR DllAddress,
    LPSTR     DllName
    );

extern "C" VOID
HandleDynamicDllLoadW(
    ULONG_PTR DllAddress,
    LPWSTR    DllName
    );

extern "C" VOID
HandleRegisterClassA(
    WNDCLASSA *pWndClassA
    );

extern "C" VOID
HandleRegisterClassW(
    WNDCLASSW *pWndClassW
    );

extern "C" LONG_PTR
HandleSetWindowLong(
    HWND    hWindow,
    LONG    lOffset,
    LPARAM  lValue
    );

extern "C" ULONG_PTR
HandleGetProcAddress(
    ULONG_PTR ProcAddress
    );

extern "C" void
__cdecl
dprintf(
    char *format,
    ...
    );

extern "C" BOOL
PentiumGetPerformanceCounter(
    PLARGE_INTEGER Counter
    );

LPSTR
UnDname(
    LPSTR sym,
    LPSTR undecsym,
    DWORD bufsize
    );

PUCHAR
CreateMachApiThunk(
    PULONG_PTR  IatAddress,
    PUCHAR      Text,
    PDLL_INFO   DllInfo,
    PAPI_INFO   ApiInfo
    );

extern "C" VOID
ApiTrace(
    PAPI_INFO   ApiInfo,
#ifdef _M_ALPHA
    DWORDLONG   Arg[MAX_TRACE_ARGS],
#else
    ULONG       Arg[MAX_TRACE_ARGS],
#endif
    ULONG       ReturnValue,
    ULONG       Caller,
    DWORDLONG   EnterTime,
    DWORDLONG   ExitTime,
    ULONG       LastError
    );

extern SYSTEM_INFO SystemInfo;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apidll\apitable.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apidll.cpp

Abstract:

    This file implements the non-architecture specific
    code for the api monitor trojan/support dll.

Author:

    Wesley Witt (wesw) 28-June-1995

Environment:

    User Mode

--*/

#include "apidllp.h"
#pragma hdrstop

//
// api tables
//

API_TABLE API_Kernel32[] =
{
    { "_hread", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "_hwrite", T_DWORD, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "_lclose", T_DWORD, 1, {T_DWORD} },
    { "_lcreat", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "_llseek", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "_lopen", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "_lread", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "_lwrite", T_DWORD, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "AddAtomA", T_DWORD, 1, {T_LPSTR} },
    { "AddAtomW", T_DWORD, 1, {T_LPWSTR} },
    { "AreFileApisANSI", T_DWORD, 1, {T_DWORD} },
    { "BackupRead", T_DWORD, 7, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "BackupSeek", T_DWORD, 6, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "BackupWrite", T_DWORD, 7, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "Beep", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "BeginUpdateResourceA", T_HANDLE, 2, {T_LPSTR, T_DWORD} },
    { "BeginUpdateResourceW", T_HANDLE, 2, {T_LPWSTR, T_DWORD} },
    { "BuildCommDCBA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "BuildCommDCBAndTimeoutsA", T_DWORD, 3, {T_LPSTR, T_DWORD, T_DWORD} },
    { "BuildCommDCBAndTimeoutsW", T_DWORD, 3, {T_LPWSTR, T_DWORD, T_DWORD} },
    { "BuildCommDCBW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "CallNamedPipeA", T_DWORD, 7, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CallNamedPipeW", T_DWORD, 7, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CancelIo", T_DWORD, 1, {T_HANDLE} },
    { "CancelWaitableTimer", T_DWORD, 1, {T_HANDLE} },
    { "ClearCommBreak", T_DWORD, 1, {T_HANDLE} },
    { "ClearCommError", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "CloseHandle", T_DWORD, 1, {T_HANDLE} },
    { "CommConfigDialogA", T_DWORD, 3, {T_LPSTR, T_HWND, T_DWORD} },
    { "CommConfigDialogW", T_DWORD, 3, {T_LPWSTR, T_HWND, T_DWORD} },
    { "CompareFileTime", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "ConnectNamedPipe", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "ContinueDebugEvent", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "ConvertThreadToFiber", T_DWORD, 1, {T_DWORD} },
    { "CopyFileA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "CopyFileExA", T_DWORD, 6, {T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CopyFileExW", T_DWORD, 6, {T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CopyFileW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "CreateDirectoryA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "CreateDirectoryExA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "CreateDirectoryExW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "CreateDirectoryW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "CreateEventA", T_HANDLE, 4, {T_DWORD, T_DWORD, T_DWORD, T_LPSTR} },
    { "CreateEventW", T_HANDLE, 4, {T_DWORD, T_DWORD, T_DWORD, T_LPWSTR} },
    { "CreateFiber", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "CreateFileA", T_HANDLE, 7, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HANDLE} },
    { "CreateFileMappingA", T_HANDLE, 6, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPSTR} },
    { "CreateFileMappingW", T_HANDLE, 6, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPWSTR} },
    { "CreateFileW", T_HANDLE, 7, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HANDLE} },
    { "CreateIoCompletionPort", T_HANDLE, 4, {T_HANDLE, T_HANDLE, T_DWORD, T_DWORD} },
    { "CreateMailslotA", T_HANDLE, 4, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateMailslotW", T_HANDLE, 4, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateMutexA", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPSTR} },
    { "CreateMutexW", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPWSTR} },
    { "CreateNamedPipeA", T_HANDLE, 8, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateNamedPipeW", T_HANDLE, 8, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreatePipe", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateProcessA", T_DWORD, 8, {T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPSTR} },
    { "CreateProcessW", T_DWORD, 8, {T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPWSTR} },
    { "CreateRemoteThread", T_HANDLE, 7, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateSemaphoreA", T_HANDLE, 4, {T_DWORD, T_DWORD, T_DWORD, T_LPSTR} },
    { "CreateSemaphoreW", T_HANDLE, 4, {T_DWORD, T_DWORD, T_DWORD, T_LPWSTR} },
    { "CreateTapePartition", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateThread", T_HANDLE, 6, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateWaitableTimerA", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPSTR} },
    { "CreateWaitableTimerW", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPWSTR} },
    { "DebugActiveProcess", T_DWORD, 1, {T_DWORD} },
    { "DebugBreak", T_DWORD, 1, {T_DWORD} },
    { "DefineDosDeviceA", T_DWORD, 3, {T_DWORD, T_LPSTR, T_LPSTR} },
    { "DefineDosDeviceW", T_DWORD, 3, {T_DWORD, T_LPWSTR, T_LPWSTR} },
    { "DeleteAtom", T_DWORD, 1, {T_DWORD} },
    { "DeleteCriticalSection", T_DWORD, 1, {T_DWORD} },
    { "DeleteFiber", T_DWORD, 1, {T_DWORD} },
    { "DeleteFileA", T_DWORD, 1, {T_LPSTR} },
    { "DeleteFileW", T_DWORD, 1, {T_LPWSTR} },
    { "DeviceIoControl", T_DWORD, 8, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DisableThreadLibraryCalls", T_DWORD, 1, {T_DWORD} },
    { "DisconnectNamedPipe", T_DWORD, 1, {T_HANDLE} },
    { "DosDateTimeToFileTime", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "DuplicateHandle", T_DWORD, 7, {T_HANDLE, T_HANDLE, T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "EndUpdateResourceA", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "EndUpdateResourceW", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "EnterCriticalSection", T_DWORD, 1, {T_DWORD} },
    { "EnumResourceLanguagesA", T_DWORD, 5, {T_DWORD, T_LPSTR, T_LPSTR, T_DWORD, T_DWORD} },
    { "EnumResourceLanguagesW", T_DWORD, 5, {T_DWORD, T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD} },
    { "EnumResourceNamesA", T_DWORD, 4, {T_DWORD, T_LPSTR, T_DWORD, T_DWORD} },
    { "EnumResourceNamesW", T_DWORD, 4, {T_DWORD, T_LPWSTR, T_DWORD, T_DWORD} },
    { "EnumResourceTypesA", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "EnumResourceTypesW", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "EraseTape", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "EscapeCommFunction", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "ExitProcess", T_DWORD, 1, {T_DWORD} },
    { "ExitThread", T_DWORD, 1, {T_DWORD} },
    { "ExpandEnvironmentStringsA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "ExpandEnvironmentStringsW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "FatalAppExitA", T_DWORD, 2, {T_DWORD, T_LPSTR} },
    { "FatalAppExitW", T_DWORD, 2, {T_DWORD, T_LPWSTR} },
    { "FatalExit", T_DWORD, 1, {T_DWORD} },
    { "FileTimeToDosDateTime", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "FileTimeToLocalFileTime", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "FileTimeToSystemTime", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "FindAtomA", T_DWORD, 1, {T_LPSTR} },
    { "FindAtomW", T_DWORD, 1, {T_LPWSTR} },
    { "FindClose", T_DWORD, 1, {T_HANDLE} },
    { "FindCloseChangeNotification", T_DWORD, 1, {T_HANDLE} },
    { "FindFirstChangeNotificationA", T_HANDLE, 3, {T_LPSTR, T_DWORD, T_DWORD} },
    { "FindFirstChangeNotificationW", T_HANDLE, 3, {T_LPWSTR, T_DWORD, T_DWORD} },
    { "FindFirstFileA", T_HANDLE, 2, {T_LPSTR, T_DWORD} },
    { "FindFirstFileExA", T_HANDLE, 6, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "FindFirstFileExW", T_HANDLE, 6, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "FindFirstFileW", T_HANDLE, 2, {T_LPWSTR, T_DWORD} },
    { "FindNextChangeNotification", T_DWORD, 1, {T_HANDLE} },
    { "FindNextFileA", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "FindNextFileW", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "FindResourceA", T_DWORD, 3, {T_DWORD, T_LPSTR, T_LPSTR} },
    { "FindResourceExA", T_DWORD, 4, {T_DWORD, T_LPSTR, T_LPSTR, T_DWORD} },
    { "FindResourceExW", T_DWORD, 4, {T_DWORD, T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "FindResourceW", T_DWORD, 3, {T_DWORD, T_LPWSTR, T_LPWSTR} },
    { "FlushFileBuffers", T_DWORD, 1, {T_HANDLE} },
    { "FlushInstructionCache", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "FlushViewOfFile", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "FormatMessageA", T_DWORD, 7, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPSTR, T_DWORD, T_DWORD} },
    { "FormatMessageW", T_DWORD, 7, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPWSTR, T_DWORD, T_DWORD} },
    { "FreeEnvironmentStringsA", T_DWORD, 1, {T_LPSTR} },
    { "FreeEnvironmentStringsW", T_DWORD, 1, {T_LPWSTR} },
    { "FreeLibrary", T_DWORD, 1, {T_DWORD} },
    { "FreeLibraryAndExitThread", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "FreeResource", T_DWORD, 1, {T_HGLOBAL} },
    { "GetAtomNameA", T_DWORD, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "GetAtomNameW", T_DWORD, 3, {T_DWORD, T_LPWSTR, T_DWORD} },
    { "GetBinaryTypeA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "GetBinaryTypeW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "GetCommandLineA", T_LPSTR, 1, {T_DWORD} },
    { "GetCommandLineW", T_LPWSTR, 1, {T_DWORD} },
    { "GetCommConfig", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "GetCommMask", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetCommModemStatus", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetCommProperties", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetCommState", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetCommTimeouts", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetCompressedFileSizeA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "GetCompressedFileSizeW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "GetCurrentDirectoryA", T_DWORD, 2, {T_DWORD, T_LPSTR} },
    { "GetCurrentDirectoryW", T_DWORD, 2, {T_DWORD, T_LPWSTR} },
    { "GetCurrentProcess", T_HANDLE, 1, {T_DWORD} },
    { "GetCurrentProcessId", T_DWORD, 1, {T_DWORD} },
    { "GetCurrentThread", T_HANDLE, 1, {T_DWORD} },
    { "GetCurrentThreadId", T_DWORD, 1, {T_DWORD} },
    { "GetDefaultCommConfigA", T_DWORD, 3, {T_LPSTR, T_DWORD, T_DWORD} },
    { "GetDefaultCommConfigW", T_DWORD, 3, {T_LPWSTR, T_DWORD, T_DWORD} },
    { "GetDiskFreeSpaceA", T_DWORD, 5, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetDiskFreeSpaceExA", T_DWORD, 4, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "GetDiskFreeSpaceExW", T_DWORD, 4, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "GetDiskFreeSpaceW", T_DWORD, 5, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetDriveTypeA", T_DWORD, 1, {T_LPSTR} },
    { "GetDriveTypeW", T_DWORD, 1, {T_LPWSTR} },
    { "GetEnvironmentStrings", T_LPSTR, 1, {T_DWORD} },
    { "GetEnvironmentStringsW", T_LPWSTR, 1, {T_DWORD} },
    { "GetEnvironmentVariableA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "GetEnvironmentVariableW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "GetExitCodeProcess", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetExitCodeThread", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetFileAttributesA", T_DWORD, 1, {T_LPSTR} },
    { "GetFileAttributesExA", T_DWORD, 3, {T_LPSTR, T_DWORD, T_DWORD} },
    { "GetFileAttributesExW", T_DWORD, 3, {T_LPWSTR, T_DWORD, T_DWORD} },
    { "GetFileAttributesW", T_DWORD, 1, {T_LPWSTR} },
    { "GetFileInformationByHandle", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetFileSize", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetFileTime", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "GetFileType", T_DWORD, 1, {T_HANDLE} },
    { "GetFullPathNameA", T_DWORD, 4, {T_LPSTR, T_DWORD, T_LPSTR, T_LPSTR} },
    { "GetFullPathNameW", T_DWORD, 4, {T_LPWSTR, T_DWORD, T_LPWSTR, T_LPWSTR} },
    { "GetHandleInformation", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetLastError", T_DWORD, 1, {T_DWORD} },
    { "GetLocalTime", T_DWORD, 1, {T_DWORD} },
    { "GetLogicalDrives", T_DWORD, 1, {T_DWORD} },
    { "GetLogicalDriveStringsA", T_DWORD, 2, {T_DWORD, T_LPSTR} },
    { "GetLogicalDriveStringsW", T_DWORD, 2, {T_DWORD, T_LPWSTR} },
    { "GetMailslotInfo", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetModuleFileNameA", T_DWORD, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "GetModuleFileNameW", T_DWORD, 3, {T_DWORD, T_LPWSTR, T_DWORD} },
    { "GetModuleHandleA", T_DWORD, 1, {T_LPSTR} },
    { "GetModuleHandleW", T_DWORD, 1, {T_LPWSTR} },
    { "GetNamedPipeHandleStateA", T_DWORD, 7, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPSTR, T_DWORD} },
    { "GetNamedPipeHandleStateW", T_DWORD, 7, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPWSTR, T_DWORD} },
    { "GetNamedPipeInfo", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetOverlappedResult", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "GetPriorityClass", T_DWORD, 1, {T_HANDLE} },
    { "GetPrivateProfileIntA", T_DWORD, 4, {T_LPSTR, T_LPSTR, T_DWORD, T_LPSTR} },
    { "GetPrivateProfileIntW", T_DWORD, 4, {T_LPWSTR, T_LPWSTR, T_DWORD, T_LPWSTR} },
    { "GetPrivateProfileSectionA", T_DWORD, 4, {T_LPSTR, T_LPSTR, T_DWORD, T_LPSTR} },
    { "GetPrivateProfileSectionNamesA", T_DWORD, 3, {T_LPSTR, T_DWORD, T_LPSTR} },
    { "GetPrivateProfileSectionNamesW", T_DWORD, 3, {T_LPWSTR, T_DWORD, T_LPWSTR} },
    { "GetPrivateProfileSectionW", T_DWORD, 4, {T_LPWSTR, T_LPWSTR, T_DWORD, T_LPWSTR} },
    { "GetPrivateProfileStringA", T_DWORD, 6, {T_LPSTR, T_LPSTR, T_LPSTR, T_LPSTR, T_DWORD, T_LPSTR} },
    { "GetPrivateProfileStringW", T_DWORD, 6, {T_LPWSTR, T_LPWSTR, T_LPWSTR, T_LPWSTR, T_DWORD, T_LPWSTR} },
    { "GetPrivateProfileStructA", T_DWORD, 5, {T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_LPSTR} },
    { "GetPrivateProfileStructW", T_DWORD, 5, {T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_LPWSTR} },
    { "GetProcAddress", T_DWORD, 2, {T_DWORD, T_LPSTR} },
    { "GetProcessAffinityMask", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "GetProcessHeap", T_HANDLE, 1, {T_DWORD} },
    { "GetProcessHeaps", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "GetProcessPriorityBoost", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetProcessShutdownParameters", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "GetProcessTimes", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetProcessVersion", T_DWORD, 1, {T_DWORD} },
    { "GetProcessWorkingSetSize", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "GetProfileIntA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "GetProfileIntW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "GetProfileSectionA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "GetProfileSectionW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "GetProfileStringA", T_DWORD, 5, {T_LPSTR, T_LPSTR, T_LPSTR, T_LPSTR, T_DWORD} },
    { "GetProfileStringW", T_DWORD, 5, {T_LPWSTR, T_LPWSTR, T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "GetQueuedCompletionStatus", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetShortPathNameA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "GetShortPathNameW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "GetStartupInfoA", T_DWORD, 1, {T_DWORD} },
    { "GetStartupInfoW", T_DWORD, 1, {T_DWORD} },
    { "GetStdHandle", T_HANDLE, 1, {T_DWORD} },
    { "GetSystemDirectoryA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "GetSystemDirectoryW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "GetSystemInfo", T_DWORD, 1, {T_DWORD} },
    { "GetSystemTime", T_DWORD, 1, {T_DWORD} },
    { "GetSystemTimeAdjustment", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "GetSystemTimeAsFileTime", T_DWORD, 1, {T_DWORD} },
    { "GetTapeParameters", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "GetTapePosition", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetTapeStatus", T_DWORD, 1, {T_HANDLE} },
    { "GetTempFileNameA", T_DWORD, 4, {T_LPSTR, T_LPSTR, T_DWORD, T_LPSTR} },
    { "GetTempFileNameW", T_DWORD, 4, {T_LPWSTR, T_LPWSTR, T_DWORD, T_LPWSTR} },
    { "GetTempPathA", T_DWORD, 2, {T_DWORD, T_LPSTR} },
    { "GetTempPathW", T_DWORD, 2, {T_DWORD, T_LPWSTR} },
    { "GetThreadContext", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetThreadPriority", T_DWORD, 1, {T_HANDLE} },
    { "GetThreadPriorityBoost", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "GetThreadSelectorEntry", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "GetThreadTimes", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetTickCount", T_DWORD, 1, {T_DWORD} },
    { "GetTimeZoneInformation", T_DWORD, 1, {T_DWORD} },
    { "GetVersion", T_DWORD, 1, {T_DWORD} },
    { "GetVersionExA", T_DWORD, 1, {T_DWORD} },
    { "GetVersionExW", T_DWORD, 1, {T_DWORD} },
    { "GetVolumeInformationA", T_DWORD, 8, {T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPSTR, T_DWORD} },
    { "GetVolumeInformationW", T_DWORD, 8, {T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_LPWSTR, T_DWORD} },
    { "GetWindowsDirectoryA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "GetWindowsDirectoryW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "GlobalAddAtomA", T_DWORD, 1, {T_LPSTR} },
    { "GlobalAddAtomW", T_DWORD, 1, {T_LPWSTR} },
    { "GlobalAlloc", T_HGLOBAL, 2, {T_DWORD, T_DWORD} },
    { "GlobalCompact", T_DWORD, 1, {T_DWORD} },
    { "GlobalDeleteAtom", T_DWORD, 1, {T_DWORD} },
    { "GlobalFindAtomA", T_DWORD, 1, {T_LPSTR} },
    { "GlobalFindAtomW", T_DWORD, 1, {T_LPWSTR} },
    { "GlobalFix", T_DWORD, 1, {T_HGLOBAL} },
    { "GlobalFlags", T_DWORD, 1, {T_HGLOBAL} },
    { "GlobalFree", T_HGLOBAL, 1, {T_HGLOBAL} },
    { "GlobalGetAtomNameA", T_DWORD, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "GlobalGetAtomNameW", T_DWORD, 3, {T_DWORD, T_LPWSTR, T_DWORD} },
    { "GlobalHandle", T_HGLOBAL, 1, {T_DWORD} },
    { "GlobalLock", T_DWORD, 1, {T_HGLOBAL} },
    { "GlobalMemoryStatus", T_DWORD, 1, {T_DWORD} },
    { "GlobalReAlloc", T_HGLOBAL, 3, {T_HGLOBAL, T_DWORD, T_DWORD} },
    { "GlobalSize", T_DWORD, 1, {T_HGLOBAL} },
    { "GlobalUnfix", T_DWORD, 1, {T_HGLOBAL} },
    { "GlobalUnlock", T_DWORD, 1, {T_HGLOBAL} },
    { "GlobalUnWire", T_DWORD, 1, {T_HGLOBAL} },
    { "GlobalWire", T_DWORD, 1, {T_HGLOBAL} },
    { "HeapAlloc", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "HeapCompact", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "HeapCreate", T_HANDLE, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "HeapDestroy", T_DWORD, 1, {T_HANDLE} },
    { "HeapFree", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "HeapLock", T_DWORD, 1, {T_HANDLE} },
    { "HeapReAlloc", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "HeapSize", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "HeapUnlock", T_DWORD, 1, {T_HANDLE} },
    { "HeapValidate", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "HeapWalk", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "InitAtomTable", T_DWORD, 1, {T_DWORD} },
    { "InitializeCriticalSection", T_DWORD, 1, {T_DWORD} },
    { "InterlockedDecrement", T_DWORD, 1, {T_DWORD} },
    { "InterlockedExchange", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "InterlockedExchangeAdd", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "InterlockedIncrement", T_DWORD, 1, {T_DWORD} },
    { "IsBadCodePtr", T_DWORD, 1, {T_DWORD} },
    { "IsBadHugeReadPtr", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "IsBadHugeWritePtr", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "IsBadReadPtr", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "IsBadStringPtrA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "IsBadStringPtrW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "IsBadWritePtr", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "IsProcessorFeaturePresent", T_DWORD, 1, {T_DWORD} },
    { "LeaveCriticalSection", T_DWORD, 1, {T_DWORD} },
    { "LoadLibraryA", T_DWORD, 1, {T_LPSTR} },
    { "LoadLibraryExA", T_DWORD, 3, {T_LPSTR, T_HANDLE, T_DWORD} },
    { "LoadLibraryExW", T_DWORD, 3, {T_LPWSTR, T_HANDLE, T_DWORD} },
    { "LoadLibraryW", T_DWORD, 1, {T_LPWSTR} },
    { "LoadModule", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "LoadResource", T_HGLOBAL, 2, {T_DWORD, T_DWORD} },
    { "LocalAlloc", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "LocalCompact", T_DWORD, 1, {T_DWORD} },
    { "LocalFileTimeToFileTime", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "LocalFlags", T_DWORD, 1, {T_DWORD} },
    { "LocalFree", T_DWORD, 1, {T_DWORD} },
    { "LocalHandle", T_DWORD, 1, {T_DWORD} },
    { "LocalLock", T_DWORD, 1, {T_DWORD} },
    { "LocalReAlloc", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "LocalShrink", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "LocalSize", T_DWORD, 1, {T_DWORD} },
    { "LocalUnlock", T_DWORD, 1, {T_DWORD} },
    { "LockFile", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "LockFileEx", T_DWORD, 6, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "LockResource", T_DWORD, 1, {T_HGLOBAL} },
    { "lstrcatA", T_LPSTR, 2, {T_LPSTR, T_LPSTR} },
    { "lstrcatW", T_LPWSTR, 2, {T_LPWSTR, T_LPWSTR} },
    { "lstrcmpA", T_DWORD, 2, {T_LPSTR, T_LPSTR} },
    { "lstrcmpiA", T_DWORD, 2, {T_LPSTR, T_LPSTR} },
    { "lstrcmpiW", T_DWORD, 2, {T_LPWSTR, T_LPWSTR} },
    { "lstrcmpW", T_DWORD, 2, {T_LPWSTR, T_LPWSTR} },
    { "lstrcpyA", T_LPSTR, 2, {T_LPSTR, T_LPSTR} },
    { "lstrcpynA", T_LPSTR, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "lstrcpynW", T_LPWSTR, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "lstrcpyW", T_LPWSTR, 2, {T_LPWSTR, T_LPWSTR} },
    { "lstrlenA", T_DWORD, 1, {T_LPSTR} },
    { "lstrlenW", T_DWORD, 1, {T_LPWSTR} },
    { "MapViewOfFile", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "MapViewOfFileEx", T_DWORD, 6, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "MoveFileA", T_DWORD, 2, {T_LPSTR, T_LPSTR} },
    { "MoveFileExA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "MoveFileExW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "MoveFileW", T_DWORD, 2, {T_LPWSTR, T_LPWSTR} },
    { "MulDiv", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "OpenEventA", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPSTR} },
    { "OpenEventW", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPWSTR} },
    { "OpenFile", T_DWORD, 3, {T_LPSTR, T_DWORD, T_DWORD} },
    { "OpenFileMappingA", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPSTR} },
    { "OpenFileMappingW", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPWSTR} },
    { "OpenMutexA", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPSTR} },
    { "OpenMutexW", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPWSTR} },
    { "OpenProcess", T_HANDLE, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "OpenSemaphoreA", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPSTR} },
    { "OpenSemaphoreW", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPWSTR} },
    { "OpenWaitableTimerA", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPSTR} },
    { "OpenWaitableTimerW", T_HANDLE, 3, {T_DWORD, T_DWORD, T_LPWSTR} },
    { "OutputDebugStringA", T_DWORD, 1, {T_LPSTR} },
    { "OutputDebugStringW", T_DWORD, 1, {T_LPWSTR} },
    { "PeekNamedPipe", T_DWORD, 6, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "PostQueuedCompletionStatus", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "PrepareTape", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "PulseEvent", T_DWORD, 1, {T_HANDLE} },
    { "PurgeComm", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "QueryDosDeviceA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "QueryDosDeviceW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "QueryPerformanceCounter", T_DWORD, 1, {T_DWORD} },
    { "QueryPerformanceFrequency", T_DWORD, 1, {T_DWORD} },
    { "QueueUserAPC", T_DWORD, 3, {T_DWORD, T_HANDLE, T_DWORD} },
    { "RaiseException", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ReadDirectoryChangesW", T_DWORD, 8, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ReadFile", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ReadFileEx", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ReadProcessMemory", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ReleaseMutex", T_DWORD, 1, {T_HANDLE} },
    { "ReleaseSemaphore", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "RemoveDirectoryA", T_DWORD, 1, {T_LPSTR} },
    { "RemoveDirectoryW", T_DWORD, 1, {T_LPWSTR} },
    { "ResetEvent", T_DWORD, 1, {T_HANDLE} },
    { "ResumeThread", T_DWORD, 1, {T_HANDLE} },
    { "SearchPathA", T_DWORD, 6, {T_LPSTR, T_LPSTR, T_LPSTR, T_DWORD, T_LPSTR, T_LPSTR} },
    { "SearchPathW", T_DWORD, 6, {T_LPWSTR, T_LPWSTR, T_LPWSTR, T_DWORD, T_LPWSTR, T_LPWSTR} },
    { "SetCommBreak", T_DWORD, 1, {T_HANDLE} },
    { "SetCommConfig", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "SetCommMask", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetCommState", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetCommTimeouts", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetCurrentDirectoryA", T_DWORD, 1, {T_LPSTR} },
    { "SetCurrentDirectoryW", T_DWORD, 1, {T_LPWSTR} },
    { "SetDefaultCommConfigA", T_DWORD, 3, {T_LPSTR, T_DWORD, T_DWORD} },
    { "SetDefaultCommConfigW", T_DWORD, 3, {T_LPWSTR, T_DWORD, T_DWORD} },
    { "SetEndOfFile", T_DWORD, 1, {T_HANDLE} },
    { "SetEnvironmentVariableA", T_DWORD, 2, {T_LPSTR, T_LPSTR} },
    { "SetEnvironmentVariableW", T_DWORD, 2, {T_LPWSTR, T_LPWSTR} },
    { "SetErrorMode", T_DWORD, 1, {T_DWORD} },
    { "SetEvent", T_DWORD, 1, {T_HANDLE} },
    { "SetFileApisToANSI", T_DWORD, 1, {T_DWORD} },
    { "SetFileApisToOEM", T_DWORD, 1, {T_DWORD} },
    { "SetFileAttributesA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "SetFileAttributesW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "SetFilePointer", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "SetFileTime", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "SetHandleCount", T_DWORD, 1, {T_DWORD} },
    { "SetHandleInformation", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "SetLastError", T_DWORD, 1, {T_DWORD} },
    { "SetLocalTime", T_DWORD, 1, {T_DWORD} },
    { "SetMailslotInfo", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetNamedPipeHandleState", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "SetPriorityClass", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetProcessAffinityMask", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetProcessPriorityBoost", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetProcessShutdownParameters", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SetProcessWorkingSetSize", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "SetStdHandle", T_DWORD, 2, {T_DWORD, T_HANDLE} },
    { "SetSystemTime", T_DWORD, 1, {T_DWORD} },
    { "SetSystemTimeAdjustment", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SetTapeParameters", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "SetTapePosition", T_DWORD, 6, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SetThreadAffinityMask", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetThreadContext", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetThreadIdealProcessor", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetThreadPriority", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetThreadPriorityBoost", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "SetTimeZoneInformation", T_DWORD, 1, {T_DWORD} },
    { "SetUnhandledExceptionFilter", T_DWORD, 1, {T_DWORD} },
    { "SetupComm", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "SetVolumeLabelA", T_DWORD, 2, {T_LPSTR, T_LPSTR} },
    { "SetVolumeLabelW", T_DWORD, 2, {T_LPWSTR, T_LPWSTR} },
    { "SetWaitableTimer", T_DWORD, 6, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SignalObjectAndWait", T_DWORD, 4, {T_HANDLE, T_HANDLE, T_DWORD, T_DWORD} },
    { "SizeofResource", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "Sleep", T_DWORD, 1, {T_DWORD} },
    { "SleepEx", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SuspendThread", T_DWORD, 1, {T_HANDLE} },
    { "SwitchToFiber", T_DWORD, 1, {T_DWORD} },
    { "SwitchToThread", T_DWORD, 1, {T_DWORD} },
    { "SystemTimeToFileTime", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SystemTimeToTzSpecificLocalTime", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "TerminateProcess", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "TerminateThread", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "TlsAlloc", T_DWORD, 1, {T_DWORD} },
    { "TlsFree", T_DWORD, 1, {T_DWORD} },
    { "TlsGetValue", T_DWORD, 1, {T_DWORD} },
    { "TlsSetValue", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "TransactNamedPipe", T_DWORD, 7, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "TransmitCommChar", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "TryEnterCriticalSection", T_DWORD, 1, {T_DWORD} },
    { "UnhandledExceptionFilter", T_DWORD, 1, {T_DWORD} },
    { "UnlockFile", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "UnlockFileEx", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "UnmapViewOfFile", T_DWORD, 1, {T_DWORD} },
    { "UpdateResourceA", T_DWORD, 6, {T_HANDLE, T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "UpdateResourceW", T_DWORD, 6, {T_HANDLE, T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualAlloc", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualAllocEx", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualFree", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualFreeEx", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualLock", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "VirtualProtect", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualProtectEx", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualQuery", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualQueryEx", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "VirtualUnlock", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "WaitCommEvent", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "WaitForDebugEvent", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "WaitForMultipleObjects", T_DWORD, 4, {T_DWORD, T_HANDLE, T_DWORD, T_DWORD} },
    { "WaitForMultipleObjectsEx", T_DWORD, 5, {T_DWORD, T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "WaitForSingleObject", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "WaitForSingleObjectEx", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "WaitNamedPipeA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "WaitNamedPipeW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "WinExec", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "WriteFile", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "WriteFileEx", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "WritePrivateProfileSectionA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_LPSTR} },
    { "WritePrivateProfileSectionW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_LPWSTR} },
    { "WritePrivateProfileStringA", T_DWORD, 4, {T_LPSTR, T_LPSTR, T_LPSTR, T_LPSTR} },
    { "WritePrivateProfileStringW", T_DWORD, 4, {T_LPWSTR, T_LPWSTR, T_LPWSTR, T_LPWSTR} },
    { "WritePrivateProfileStructA", T_DWORD, 5, {T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_LPSTR} },
    { "WritePrivateProfileStructW", T_DWORD, 5, {T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_LPWSTR} },
    { "WriteProcessMemory", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "WriteProfileSectionA", T_DWORD, 2, {T_LPSTR, T_LPSTR} },
    { "WriteProfileSectionW", T_DWORD, 2, {T_LPWSTR, T_LPWSTR} },
    { "WriteProfileStringA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_LPSTR} },
    { "WriteProfileStringW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_LPWSTR} },
    { "WriteTapemark", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { NULL,                                0,          0,   }
};

API_TABLE API_Gdi32[] =
{
    { "AbortDoc", T_DWORD, 1, {T_HDC} },
    { "AbortPath", T_DWORD, 1, {T_HDC} },
    { "AddFontResourceA", T_DWORD, 1, {T_LPSTR} },
    { "AddFontResourceW", T_DWORD, 1, {T_LPWSTR} },
    { "AngleArc", T_DWORD, 6, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "AnimatePalette", T_DWORD, 4, {T_HPALETTE, T_DWORD, T_DWORD, T_DWORD} },
    { "Arc", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ArcTo", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "BeginPath", T_DWORD, 1, {T_HDC} },
    { "BitBlt", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HDC, T_DWORD, T_DWORD} },
    { "CancelDC", T_DWORD, 1, {T_HDC} },
    { "ChoosePixelFormat", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "Chord", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CloseEnhMetaFile", T_HENHMETAFILE, 1, {T_HDC} },
    { "CloseFigure", T_DWORD, 1, {T_HDC} },
    { "CloseMetaFile", T_HMETAFILE, 1, {T_HDC} },
    { "CombineRgn", T_DWORD, 4, {T_HRGN, T_HRGN, T_HRGN, T_DWORD} },
    { "CombineTransform", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "CopyEnhMetaFileA", T_HENHMETAFILE, 2, {T_HENHMETAFILE, T_LPSTR} },
    { "CopyEnhMetaFileW", T_HENHMETAFILE, 2, {T_HENHMETAFILE, T_LPWSTR} },
    { "CopyMetaFileA", T_HMETAFILE, 2, {T_HMETAFILE, T_LPSTR} },
    { "CopyMetaFileW", T_HMETAFILE, 2, {T_HMETAFILE, T_LPWSTR} },
    { "CreateBitmap", T_HBITMAP, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateBitmapIndirect", T_HBITMAP, 1, {T_DWORD} },
    { "CreateBrushIndirect", T_HBRUSH, 1, {T_DWORD} },
    { "CreateCompatibleBitmap", T_HBITMAP, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "CreateCompatibleDC", T_HDC, 1, {T_HDC} },
    { "CreateDCA", T_HDC, 4, {T_LPSTR, T_LPSTR, T_LPSTR, T_DWORD} },
    { "CreateDCW", T_HDC, 4, {T_LPWSTR, T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "CreateDIBitmap", T_HBITMAP, 6, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateDIBPatternBrush", T_HBRUSH, 2, {T_HGLOBAL, T_DWORD} },
    { "CreateDIBPatternBrushPt", T_HBRUSH, 2, {T_DWORD, T_DWORD} },
    { "CreateDIBSection", T_HBITMAP, 6, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_HANDLE, T_DWORD} },
    { "CreateDiscardableBitmap", T_HBITMAP, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "CreateEllipticRgn", T_HRGN, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateEllipticRgnIndirect", T_HRGN, 1, {T_DWORD} },
    { "CreateEnhMetaFileA", T_HDC, 4, {T_HDC, T_LPSTR, T_DWORD, T_LPSTR} },
    { "CreateEnhMetaFileW", T_HDC, 4, {T_HDC, T_LPWSTR, T_DWORD, T_LPWSTR} },
    { "CreateFontA", T_HFONT, 8, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateFontIndirectA", T_HFONT, 1, {T_DWORD} },
    { "CreateFontIndirectW", T_HFONT, 1, {T_DWORD} },
    { "CreateFontW", T_HFONT, 8, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateHalftonePalette", T_HPALETTE, 1, {T_HDC} },
    { "CreateHatchBrush", T_HBRUSH, 2, {T_DWORD, T_DWORD} },
    { "CreateICA", T_HDC, 4, {T_LPSTR, T_LPSTR, T_LPSTR, T_DWORD} },
    { "CreateICW", T_HDC, 4, {T_LPWSTR, T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "CreateMetaFileA", T_HDC, 1, {T_LPSTR} },
    { "CreateMetaFileW", T_HDC, 1, {T_LPWSTR} },
    { "CreatePalette", T_HPALETTE, 1, {T_DWORD} },
    { "CreatePatternBrush", T_HBRUSH, 1, {T_HBITMAP} },
    { "CreatePen", T_HPEN, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "CreatePenIndirect", T_HPEN, 1, {T_DWORD} },
    { "CreatePolygonRgn", T_HRGN, 2, {T_DWORD, T_DWORD} },
    { "CreatePolyPolygonRgn", T_HRGN, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "CreateRectRgn", T_HRGN, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateRectRgnIndirect", T_HRGN, 1, {T_DWORD} },
    { "CreateRoundRectRgn", T_HRGN, 6, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateScalableFontResourceA", T_DWORD, 4, {T_DWORD, T_LPSTR, T_LPSTR, T_LPSTR} },
    { "CreateScalableFontResourceW", T_DWORD, 4, {T_DWORD, T_LPWSTR, T_LPWSTR, T_LPWSTR} },
    { "CreateSolidBrush", T_HBRUSH, 1, {T_DWORD} },
    { "DeleteDC", T_DWORD, 1, {T_HDC} },
    { "DeleteEnhMetaFile", T_DWORD, 1, {T_HENHMETAFILE} },
    { "DeleteMetaFile", T_DWORD, 1, {T_HMETAFILE} },
    { "DeleteObject", T_DWORD, 1, {T_HGDIOBJ} },
    { "DescribePixelFormat", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "DPtoLP", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "DrawEscape", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_LPSTR} },
    { "Ellipse", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "EndDoc", T_DWORD, 1, {T_HDC} },
    { "EndPage", T_DWORD, 1, {T_HDC} },
    { "EndPath", T_DWORD, 1, {T_HDC} },
    { "EnumEnhMetaFile", T_DWORD, 5, {T_HDC, T_HENHMETAFILE, T_DWORD, T_DWORD, T_DWORD} },
    { "EnumFontFamiliesA", T_DWORD, 4, {T_HDC, T_LPSTR, T_DWORD, T_DWORD} },
    { "EnumFontFamiliesExA", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "EnumFontFamiliesExW", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "EnumFontFamiliesW", T_DWORD, 4, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD} },
    { "EnumFontsA", T_DWORD, 4, {T_HDC, T_LPSTR, T_DWORD, T_DWORD} },
    { "EnumFontsW", T_DWORD, 4, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD} },
    { "EnumMetaFile", T_DWORD, 4, {T_HDC, T_HMETAFILE, T_DWORD, T_DWORD} },
    { "EnumObjects", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "EnumObjects", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "EqualRgn", T_DWORD, 2, {T_HRGN, T_HRGN} },
    { "Escape", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_LPSTR, T_DWORD} },
    { "ExcludeClipRect", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ExtCreatePen", T_HPEN, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ExtCreateRegion", T_HRGN, 2, {T_DWORD, T_DWORD} },
    { "ExtEscape", T_DWORD, 6, {T_HDC, T_DWORD, T_DWORD, T_LPSTR, T_DWORD, T_LPSTR} },
    { "ExtFloodFill", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ExtSelectClipRgn", T_DWORD, 3, {T_HDC, T_HRGN, T_DWORD} },
    { "ExtTextOutA", T_DWORD, 7, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ExtTextOutW", T_DWORD, 7, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "FillPath", T_DWORD, 1, {T_HDC} },
    { "FillRgn", T_DWORD, 3, {T_HDC, T_HRGN, T_HBRUSH} },
    { "FixBrushOrgEx", T_DWORD, 1, {T_DWORD} },
    { "FlattenPath", T_DWORD, 1, {T_HDC} },
    { "FloodFill", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "FrameRgn", T_DWORD, 5, {T_HDC, T_HRGN, T_HBRUSH, T_DWORD, T_DWORD} },
    { "GdiComment", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "GdiFlush", T_DWORD, 0, },
    { "GdiGetBatchLimit", T_DWORD, 0, },
    { "GdiSetBatchLimit", T_DWORD, 1, {T_DWORD} },
    { "GetArcDirection", T_DWORD, 1, {T_HDC} },
    { "GetAspectRatioFilterEx", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetBitmapBits", T_DWORD, 3, {T_HBITMAP, T_DWORD, T_DWORD} },
    { "GetBitmapDimensionEx", T_DWORD, 2, {T_HBITMAP, T_DWORD} },
    { "GetBkColor", T_DWORD, 1, {T_HDC} },
    { "GetBkMode", T_DWORD, 1, {T_HDC} },
    { "GetBoundsRect", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "GetBrushOrgEx", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetCharABCWidthsA", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharABCWidthsFloatA", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharABCWidthsFloatW", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharABCWidthsW", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharacterPlacementA", T_DWORD, 6, {T_HDC, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharacterPlacementW", T_DWORD, 6, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharWidth32A", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharWidth32W", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharWidthA", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharWidthFloatA", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharWidthFloatW", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetCharWidthW", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetClipBox", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetClipRgn", T_DWORD, 2, {T_HDC, T_HRGN} },
    { "GetColorAdjustment", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetCurrentObject", T_HGDIOBJ, 2, {T_HDC, T_DWORD} },
    { "GetCurrentPositionEx", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetDCOrgEx", T_DWORD, 1, {T_HDCLPPOINT} },
    { "GetDeviceCaps", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetDIBColorTable", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetDIBits", T_DWORD, 7, {T_HDC, T_HBITMAP, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetEnhMetaFileA", T_HENHMETAFILE, 1, {T_LPSTR} },
    { "GetEnhMetaFileBits", T_DWORD, 3, {T_HENHMETAFILE, T_DWORD, T_DWORD} },
    { "GetEnhMetaFileDescriptionA", T_DWORD, 3, {T_HENHMETAFILE, T_DWORD, T_LPSTR} },
    { "GetEnhMetaFileDescriptionW", T_DWORD, 3, {T_HENHMETAFILE, T_DWORD, T_LPWSTR} },
    { "GetEnhMetaFileHeader", T_DWORD, 3, {T_HENHMETAFILE, T_DWORD, T_DWORD} },
    { "GetEnhMetaFilePaletteEntries", T_DWORD, 3, {T_HENHMETAFILE, T_DWORD, T_DWORD} },
    { "GetEnhMetaFilePixelFormat", T_DWORD, 3, {T_HENHMETAFILE, T_DWORD, T_DWORD} },
    { "GetEnhMetaFileW", T_HENHMETAFILE, 1, {T_LPWSTR} },
    { "GetFontData", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetFontLanguageInfo", T_DWORD, 1, {T_HDC} },
    { "GetGlyphOutlineA", T_DWORD, 7, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetGlyphOutlineW", T_DWORD, 7, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetGraphicsMode", T_DWORD, 1, {T_HDC} },
    { "GetKerningPairsA", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "GetKerningPairsW", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "GetMapMode", T_DWORD, 1, {T_HDC} },
    { "GetMetaFileA", T_HMETAFILE, 1, {T_LPSTR} },
    { "GetMetaFileBitsEx", T_DWORD, 3, {T_HMETAFILE, T_DWORD, T_DWORD} },
    { "GetMetaFileW", T_HMETAFILE, 1, {T_LPWSTR} },
    { "GetMetaRgn", T_DWORD, 2, {T_HDC, T_HRGN} },
    { "GetMiterLimit", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetNearestColor", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetNearestPaletteIndex", T_DWORD, 2, {T_HPALETTE, T_DWORD} },
    { "GetObjectA", T_DWORD, 3, {T_HGDIOBJ, T_DWORD, T_DWORD} },
    { "GetObjectType", T_DWORD, 1, {T_HGDIOBJ} },
    { "GetObjectW", T_DWORD, 3, {T_HGDIOBJ, T_DWORD, T_DWORD} },
    { "GetOutlineTextMetricsA", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "GetOutlineTextMetricsW", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "GetPaletteEntries", T_DWORD, 4, {T_HPALETTE, T_DWORD, T_DWORD, T_DWORD} },
    { "GetPath", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetPixel", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "GetPixelFormat", T_DWORD, 1, {T_HDC} },
    { "GetPolyFillMode", T_DWORD, 1, {T_HDC} },
    { "GetRasterizerCaps", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "GetRegionData", T_DWORD, 3, {T_HRGN, T_DWORD, T_DWORD} },
    { "GetRgnBox", T_DWORD, 2, {T_HRGN, T_DWORD} },
    { "GetROP2", T_DWORD, 1, {T_HDC} },
    { "GetStockObject", T_HGDIOBJ, 1, {T_DWORD} },
    { "GetStretchBltMode", T_DWORD, 1, {T_HDC} },
    { "GetSystemPaletteEntries", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "GetSystemPaletteUse", T_DWORD, 1, {T_HDC} },
    { "GetTextAlign", T_DWORD, 1, {T_HDC} },
    { "GetTextCharacterExtra", T_DWORD, 1, {T_HDC} },
    { "GetTextCharset", T_DWORD, 1, {T_HDC} },
    { "GetTextCharsetInfo", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "GetTextColor", T_DWORD, 1, {T_HDC} },
    { "GetTextExtentExPointA", T_DWORD, 7, {T_HDC, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetTextExtentExPointW", T_DWORD, 7, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetTextExtentPoint32A", T_DWORD, 4, {T_HDC, T_LPSTR, T_DWORD, T_DWORD} },
    { "GetTextExtentPoint32W", T_DWORD, 4, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD} },
    { "GetTextExtentPointA", T_DWORD, 4, {T_HDC, T_LPSTR, T_DWORD, T_DWORD} },
    { "GetTextExtentPointW", T_DWORD, 4, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD} },
    { "GetTextFaceA", T_DWORD, 3, {T_HDC, T_DWORD, T_LPSTR} },
    { "GetTextFaceW", T_DWORD, 3, {T_HDC, T_DWORD, T_LPWSTR} },
    { "GetTextMetricsA", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetTextMetricsW", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetViewportExtEx", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetViewportOrgEx", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetWindowExtEx", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetWindowOrgEx", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "GetWinMetaFileBits", T_DWORD, 5, {T_HENHMETAFILE, T_DWORD, T_DWORD, T_DWORD, T_HDC} },
    { "GetWorldTransform", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "IntersectClipRect", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "InvertRgn", T_DWORD, 2, {T_HDC, T_HRGN} },
    { "LineDDA", T_DWORD, 6, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "LineTo", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "LPtoDP", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "MaskBlt", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HDC, T_DWORD, T_DWORD} },
    { "ModifyWorldTransform", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "MoveToEx", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "OffsetClipRgn", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "OffsetRgn", T_DWORD, 3, {T_HRGN, T_DWORD, T_DWORD} },
    { "OffsetViewportOrgEx", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "OffsetWindowOrgEx", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "PaintRgn", T_DWORD, 2, {T_HDC, T_HRGN} },
    { "PatBlt", T_DWORD, 6, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "PathToRegion", T_HRGN, 1, {T_HDC} },
    { "Pie", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "PlayEnhMetaFile", T_DWORD, 3, {T_HDC, T_HENHMETAFILE, T_DWORD} },
    { "PlayEnhMetaFileRecord", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "PlayMetaFile", T_DWORD, 2, {T_HDC, T_HMETAFILE} },
    { "PlayMetaFileRecord", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "PlgBlt", T_DWORD, 8, {T_HDC, T_DWORD, T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HBITMAP} },
    { "PolyBezier", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "PolyBezierTo", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "PolyDraw", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "Polygon", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "Polyline", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "PolylineTo", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "PolyPolygon", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "PolyPolyline", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "PolyTextOutA", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "PolyTextOutW", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "PtInRegion", T_DWORD, 3, {T_HRGN, T_DWORD, T_DWORD} },
    { "PtVisible", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "RealizePalette", T_DWORD, 1, {T_HDC} },
    { "Rectangle", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "RectInRegion", T_DWORD, 2, {T_HRGN, T_DWORD} },
    { "RectVisible", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "RemoveFontResourceA", T_DWORD, 1, {T_LPSTR} },
    { "RemoveFontResourceW", T_DWORD, 1, {T_LPWSTR} },
    { "ResetDCA", T_HDC, 2, {T_HDC, T_DWORD} },
    { "ResetDCW", T_HDC, 2, {T_HDC, T_DWORD} },
    { "ResizePalette", T_DWORD, 2, {T_HPALETTE, T_DWORD} },
    { "RestoreDC", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "RoundRect", T_DWORD, 7, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SaveDC", T_DWORD, 1, {T_HDC} },
    { "ScaleViewportExtEx", T_DWORD, 6, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ScaleWindowExtEx", T_DWORD, 6, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SelectClipPath", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SelectClipRgn", T_DWORD, 2, {T_HDC, T_HRGN} },
    { "SelectObject", T_HGDIOBJ, 2, {T_HDC, T_HGDIOBJ} },
    { "SelectPalette", T_HPALETTE, 3, {T_HDC, T_HPALETTE, T_DWORD} },
    { "SetAbortProc", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetArcDirection", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetBitmapBits", T_DWORD, 3, {T_HBITMAP, T_DWORD, T_DWORD} },
    { "SetBitmapDimensionEx", T_DWORD, 4, {T_HBITMAP, T_DWORD, T_DWORD, T_DWORD} },
    { "SetBkColor", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetBkMode", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetBoundsRect", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "SetBrushOrgEx", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "SetColorAdjustment", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetDIBColorTable", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "SetDIBits", T_DWORD, 7, {T_HDC, T_HBITMAP, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SetDIBitsToDevice", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SetEnhMetaFileBits", T_HENHMETAFILE, 2, {T_DWORD, T_DWORD} },
    { "SetGraphicsMode", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetMapMode", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetMapperFlags", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetMetaFileBitsEx", T_HMETAFILE, 2, {T_DWORD, T_DWORD} },
    { "SetMetaRgn", T_DWORD, 1, {T_HDC} },
    { "SetMiterLimit", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "SetPaletteEntries", T_DWORD, 4, {T_HPALETTE, T_DWORD, T_DWORD, T_DWORD} },
    { "SetPixel", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "SetPixelFormat", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "SetPixelV", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "SetPolyFillMode", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetRectRgn", T_DWORD, 5, {T_HRGN, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SetROP2", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetStretchBltMode", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetSystemPaletteUse", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetTextAlign", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetTextCharacterExtra", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetTextColor", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "SetTextJustification", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "SetViewportExtEx", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "SetViewportOrgEx", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "SetWindowExtEx", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "SetWindowOrgEx", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "SetWinMetaFileBits", T_HENHMETAFILE, 4, {T_DWORD, T_DWORD, T_HDC, T_DWORD} },
    { "SetWorldTransform", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "StartDocA", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "StartDocW", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "StartPage", T_DWORD, 1, {T_HDC} },
    { "StretchBlt", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HDC, T_DWORD, T_DWORD} },
    { "StretchDIBits", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "StrokeAndFillPath", T_DWORD, 1, {T_HDC} },
    { "StrokePath", T_DWORD, 1, {T_HDC} },
    { "SwapBuffers", T_DWORD, 1, {T_HDC} },
    { "TextOutA", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_LPSTR, T_DWORD} },
    { "TextOutW", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_LPWSTR, T_DWORD} },
    { "TranslateCharsetInfo", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "UnrealizeObject", T_DWORD, 1, {T_HGDIOBJ} },
    { "UpdateColors", T_DWORD, 1, {T_HDC} },
    { "wglCopyContext", T_DWORD, 3, {T_HGLRC, T_HGLRC, T_DWORD} },
    { "wglCreateContext", T_HGLRC, 1, {T_HDC} },
    { "wglCreateLayerContext", T_HGLRC, 2, {T_HDC, T_DWORD} },
    { "wglDeleteContext", T_DWORD, 1, {T_HGLRC} },
    { "wglDescribeLayerPlane", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "wglGetCurrentContext", T_HGLRC, 1, {T_DWORD} },
    { "wglGetCurrentDC", T_HDC, 1, {T_DWORD} },
    { "wglGetLayerPaletteEntries", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "wglGetProcAddress", T_DWORD, 1, {T_LPSTR} },
    { "wglMakeCurrent", T_DWORD, 2, {T_HDC, T_HGLRC} },
    { "wglRealizeLayerPalette", T_DWORD, 3, {T_HDC, T_DWORD, T_DWORD} },
    { "wglSetLayerPaletteEntries", T_DWORD, 5, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "wglShareLists", T_DWORD, 2, {T_HGLRC, T_HGLRC} },
    { "wglSwapLayerBuffers", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "wglUseFontBitmapsA", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "wglUseFontBitmapsW", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "wglUseFontOutlinesA", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "wglUseFontOutlinesW", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "WidenPath", T_DWORD, 1, {T_HDC} },
    { NULL, 0, 0, }
};

API_TABLE API_User32[] =
{
    { "ActivateKeyboardLayout", T_DWORD, 2, {T_HKL, T_DWORD} },
    { "ActivateKeyboardLayout", T_HKL, 2, {T_HKL, T_DWORD} },
    { "AdjustWindowRect", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "AdjustWindowRectEx", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "AnyPopup", T_DWORD, 1, {T_DWORD} },
    { "AppendMenuA", T_DWORD, 4, {T_HMENU, T_DWORD, T_DWORD, T_LPSTR} },
    { "AppendMenuW", T_DWORD, 4, {T_HMENU, T_DWORD, T_DWORD, T_LPWSTR} },
    { "ArrangeIconicWindows", T_DWORD, 1, {T_HWND} },
    { "AttachThreadInput", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "BeginDeferWindowPos", T_HDWP, 1, {T_DWORD} },
    { "BeginPaint", T_HDC, 2, {T_HWND, T_DWORD} },
    { "BringWindowToTop", T_DWORD, 1, {T_HWND} },
    { "BroadcastSystemMessageA", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "BroadcastSystemMessageW", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CallMsgFilterA", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "CallMsgFilterW", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "CallNextHookEx", T_DWORD, 4, {T_HHOOK, T_DWORD, T_DWORD, T_DWORD} },
    { "CallWindowProcA", T_DWORD, 5, {T_DWORD, T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "CallWindowProcA", T_DWORD, 5, {T_DWORD, T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "CallWindowProcW", T_DWORD, 5, {T_DWORD, T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "CallWindowProcW", T_DWORD, 5, {T_DWORD, T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "CascadeWindows", T_DWORD, 5, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ChangeClipboardChain", T_DWORD, 2, {T_HWND, T_HWND} },
    { "ChangeDisplaySettingsA", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "ChangeDisplaySettingsExA", T_DWORD, 5, {T_LPSTR, T_DWORD, T_HWND, T_DWORD, T_DWORD} },
    { "ChangeDisplaySettingsExW", T_DWORD, 5, {T_LPWSTR, T_DWORD, T_HWND, T_DWORD, T_DWORD} },
    { "ChangeDisplaySettingsW", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "ChangeMenuA", T_DWORD, 5, {T_HMENU, T_DWORD, T_LPSTR, T_DWORD, T_DWORD} },
    { "ChangeMenuW", T_DWORD, 5, {T_HMENU, T_DWORD, T_LPWSTR, T_DWORD, T_DWORD} },
    { "CharLowerA", T_LPSTR, 1, {T_LPSTR} },
    { "CharLowerBuffA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "CharLowerBuffW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "CharLowerW", T_LPWSTR, 1, {T_LPWSTR} },
    { "CharNextA", T_LPSTR, 1, {T_LPSTR} },
    { "CharNextExA", T_LPSTR, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "CharNextW", T_LPWSTR, 1, {T_LPWSTR} },
    { "CharPrevA", T_LPSTR, 2, {T_LPSTR, T_LPSTR} },
    { "CharPrevExA", T_LPSTR, 4, {T_DWORD, T_LPSTR, T_LPSTR, T_DWORD} },
    { "CharPrevW", T_LPWSTR, 2, {T_LPWSTR, T_LPWSTR} },
    { "CharToOemA", T_DWORD, 2, {T_LPSTR, T_LPSTR} },
    { "CharToOemBuffA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "CharToOemBuffW", T_DWORD, 3, {T_LPWSTR, T_LPSTR, T_DWORD} },
    { "CharToOemW", T_DWORD, 2, {T_LPWSTR, T_LPSTR} },
    { "CharUpperA", T_LPSTR, 1, {T_LPSTR} },
    { "CharUpperBuffA", T_DWORD, 2, {T_LPSTR, T_DWORD} },
    { "CharUpperBuffW", T_DWORD, 2, {T_LPWSTR, T_DWORD} },
    { "CharUpperW", T_LPWSTR, 1, {T_LPWSTR} },
    { "CheckDlgButton", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "CheckMenuItem", T_DWORD, 3, {T_HMENU, T_DWORD, T_DWORD} },
    { "CheckMenuRadioItem", T_DWORD, 5, {T_HMENU, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CheckRadioButton", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "ChildWindowFromPoint", T_HWND, 2, {T_HWND, T_DWORD} },
    { "ChildWindowFromPointEx", T_HWND, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "ClientToScreen", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "ClipCursor", T_DWORD, 1, {T_DWORD} },
    { "CloseClipboard", T_DWORD, 1, {T_DWORD} },
    { "CloseDesktop", T_DWORD, 1, {T_HDESK} },
    { "CloseWindow", T_DWORD, 1, {T_HWND} },
    { "CloseWindowStation", T_DWORD, 1, {T_HWINSTA} },
    { "CopyAcceleratorTableA", T_DWORD, 3, {T_HACCEL, T_DWORD, T_DWORD} },
    { "CopyAcceleratorTableW", T_DWORD, 3, {T_HACCEL, T_DWORD, T_DWORD} },
    { "CopyIcon", T_HICON, 1, {T_HICON} },
    { "CopyImage", T_HANDLE, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CopyRect", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "CountClipboardFormats", T_DWORD, 1, {T_DWORD} },
    { "CreateAcceleratorTableA", T_HACCEL, 2, {T_DWORD, T_DWORD} },
    { "CreateAcceleratorTableW", T_HACCEL, 2, {T_DWORD, T_DWORD} },
    { "CreateCaret", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateCursor", T_HCURSOR, 7, {T_HINSTANCE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateDesktopA", T_HDESK, 6, {T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateDesktopW", T_HDESK, 6, {T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateDialogIndirectParamA", T_HWND, 5, {T_HINSTANCE, T_DWORD, T_HWND, T_DWORD, T_DWORD} },
    { "CreateDialogIndirectParamW", T_HWND, 5, {T_HINSTANCE, T_DWORD, T_HWND, T_DWORD, T_DWORD} },
    { "CreateDialogParamA", T_HWND, 5, {T_HINSTANCE, T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateDialogParamW", T_HWND, 5, {T_HINSTANCE, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateIcon", T_HICON, 7, {T_HINSTANCE, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateIconFromResource", T_HICON, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateIconFromResourceEx", T_HICON, 7, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateIconIndirect", T_HICON, 1, {T_DWORD} },
    { "CreateMDIWindowA", T_HWND, 8, {T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HWND} },
    { "CreateMDIWindowW", T_HWND, 8, {T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HWND} },
    { "CreateMenu", T_HMENU, 1, {T_DWORD} },
    { "CreatePopupMenu", T_HMENU, 1, {T_DWORD} },
    { "CreateWindowExA", T_HWND, 8, {T_DWORD, T_LPSTR, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateWindowExW", T_HWND, 8, {T_DWORD, T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateWindowStationA", T_HWINSTA, 4, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "CreateWindowStationW", T_HWINSTA, 4, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "DefDlgProcA", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "DefDlgProcW", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "DeferWindowPos", T_HDWP, 8, {T_HDWP, T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DefFrameProcA", T_DWORD, 5, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DefFrameProcW", T_DWORD, 5, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DefMDIChildProcA", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "DefMDIChildProcW", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "DefWindowProcA", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "DefWindowProcW", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "DeleteMenu", T_DWORD, 3, {T_HMENU, T_DWORD, T_DWORD} },
    { "DestroyAcceleratorTable", T_DWORD, 1, {T_HACCEL} },
    { "DestroyCaret", T_DWORD, 1, {T_DWORD} },
    { "DestroyCursor", T_DWORD, 1, {T_HCURSOR} },
    { "DestroyIcon", T_DWORD, 1, {T_HICON} },
    { "DestroyMenu", T_DWORD, 1, {T_HMENU} },
    { "DestroyWindow", T_DWORD, 1, {T_HWND} },
    { "DialogBoxIndirectParamA", T_DWORD, 5, {T_HINSTANCE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DialogBoxIndirectParamW", T_DWORD, 5, {T_HINSTANCE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DialogBoxParamA", T_DWORD, 5, {T_HINSTANCE, T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "DialogBoxParamW", T_DWORD, 5, {T_HINSTANCE, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "DispatchMessageA", T_DWORD, 1, {T_DWORD} },
    { "DispatchMessageW", T_DWORD, 1, {T_DWORD} },
    { "DlgDirListA", T_DWORD, 5, {T_HWND, T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "DlgDirListComboBoxA", T_DWORD, 5, {T_HWND, T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "DlgDirListComboBoxW", T_DWORD, 5, {T_HWND, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "DlgDirListW", T_DWORD, 5, {T_HWND, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "DlgDirSelectComboBoxExA", T_DWORD, 4, {T_HWND, T_LPSTR, T_DWORD, T_DWORD} },
    { "DlgDirSelectComboBoxExW", T_DWORD, 4, {T_HWND, T_LPWSTR, T_DWORD, T_DWORD} },
    { "DlgDirSelectExA", T_DWORD, 4, {T_HWND, T_LPSTR, T_DWORD, T_DWORD} },
    { "DlgDirSelectExW", T_DWORD, 4, {T_HWND, T_LPWSTR, T_DWORD, T_DWORD} },
    { "DragDetect", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "DragObject", T_DWORD, 5, {T_HWND, T_HWND, T_DWORD, T_DWORD, T_HCURSOR} },
    { "DrawAnimatedRects", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "DrawCaption", T_DWORD, 4, {T_HWND, T_HDC, T_DWORD, T_DWORD} },
    { "DrawEdge", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "DrawFocusRect", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "DrawFrameControl", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_DWORD} },
    { "DrawIcon", T_DWORD, 4, {T_HDC, T_DWORD, T_DWORD, T_HICON} },
    { "DrawIconEx", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_HICON, T_DWORD, T_DWORD, T_DWORD, T_HBRUSH} },
    { "DrawMenuBar", T_DWORD, 1, {T_HWND} },
    { "DrawStateA", T_DWORD, 8, {T_HDC, T_HBRUSH, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DrawStateW", T_DWORD, 8, {T_HDC, T_HBRUSH, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DrawTextA", T_DWORD, 5, {T_HDC, T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "DrawTextExA", T_DWORD, 6, {T_HDC, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DrawTextExW", T_DWORD, 6, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "DrawTextW", T_DWORD, 5, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "EmptyClipboard", T_DWORD, 1, {T_DWORD} },
    { "EnableMenuItem", T_DWORD, 3, {T_HMENU, T_DWORD, T_DWORD} },
    { "EnableScrollBar", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "EnableWindow", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "EndDeferWindowPos", T_DWORD, 1, {T_HDWP} },
    { "EndDialog", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "EndPaint", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "EnumChildWindows", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "EnumClipboardFormats", T_DWORD, 1, {T_DWORD} },
    { "EnumDesktopsA", T_DWORD, 3, {T_HWINSTA, T_DWORD, T_DWORD} },
    { "EnumDesktopsW", T_DWORD, 3, {T_HWINSTA, T_DWORD, T_DWORD} },
    { "EnumDesktopWindows", T_DWORD, 3, {T_HDESK, T_DWORD, T_DWORD} },
    { "EnumDisplaySettingsA", T_DWORD, 3, {T_LPSTR, T_DWORD, T_DWORD} },
    { "EnumDisplaySettingsW", T_DWORD, 3, {T_LPWSTR, T_DWORD, T_DWORD} },
    { "EnumPropsA", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "EnumPropsExA", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "EnumPropsExW", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "EnumPropsW", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "EnumThreadWindows", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "EnumWindows", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "EnumWindowStationsA", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "EnumWindowStationsW", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "EqualRect", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "ExcludeUpdateRgn", T_DWORD, 2, {T_HDC, T_HWND} },
    { "ExitWindowsEx", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "FillRect", T_DWORD, 3, {T_HDC, T_DWORD, T_HBRUSH} },
    { "FindWindowA", T_HWND, 2, {T_DWORD, T_LPSTR} },
    { "FindWindowExA", T_HWND, 4, {T_HWND, T_HWND, T_LPSTR, T_LPSTR} },
    { "FindWindowExW", T_HWND, 4, {T_HWND, T_HWND, T_LPWSTR, T_LPWSTR} },
    { "FindWindowW", T_HWND, 2, {T_DWORD, T_LPWSTR} },
    { "FlashWindow", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "FrameRect", T_DWORD, 3, {T_HDC, T_DWORD, T_HBRUSH} },
    { "GetActiveWindow", T_HWND, 1, {T_DWORD} },
    { "GetAsyncKeyState", T_DWORD, 1, {T_DWORD} },
    { "GetCapture", T_HWND, 1, {T_DWORD} },
    { "GetCaretBlinkTime", T_DWORD, 1, {T_DWORD} },
    { "GetCaretPos", T_DWORD, 1, {T_DWORD} },
    { "GetClassInfoA", T_DWORD, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "GetClassInfoExA", T_DWORD, 3, {T_HINSTANCE, T_LPSTR, T_DWORD} },
    { "GetClassInfoExW", T_DWORD, 3, {T_HINSTANCE, T_LPWSTR, T_DWORD} },
    { "GetClassInfoW", T_DWORD, 3, {T_DWORD, T_LPWSTR, T_DWORD} },
    { "GetClassLongA", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetClassLongW", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetClassNameA", T_DWORD, 3, {T_HWND, T_LPSTR, T_DWORD} },
    { "GetClassNameW", T_DWORD, 3, {T_HWND, T_LPWSTR, T_DWORD} },
    { "GetClassWord", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetClientRect", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetClipboardData", T_HANDLE, 1, {T_DWORD} },
    { "GetClipboardFormatNameA", T_DWORD, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "GetClipboardFormatNameW", T_DWORD, 3, {T_DWORD, T_LPWSTR, T_DWORD} },
    { "GetClipboardOwner", T_HWND, 1, {T_DWORD} },
    { "GetClipboardViewer", T_HWND, 1, {T_DWORD} },
    { "GetClipCursor", T_DWORD, 1, {T_DWORD} },
    { "GetCursor", T_HCURSOR, 1, {T_DWORD} },
    { "GetCursorPos", T_DWORD, 1, {T_DWORD} },
    { "GetDC", T_HDC, 1, {T_HWND} },
    { "GetDCEx", T_HDC, 3, {T_DWORD, T_HRGN, T_DWORD} },
    { "GetDesktopWindow", T_HWND, 1, {T_DWORD} },
    { "GetDialogBaseUnits", T_DWORD, 1, {T_DWORD} },
    { "GetDlgCtrlID", T_DWORD, 1, {T_HWND} },
    { "GetDlgItem", T_HWND, 2, {T_HWND, T_DWORD} },
    { "GetDlgItemInt", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "GetDlgItemTextA", T_DWORD, 4, {T_HWND, T_DWORD, T_LPSTR, T_DWORD} },
    { "GetDlgItemTextW", T_DWORD, 4, {T_HWND, T_DWORD, T_LPWSTR, T_DWORD} },
    { "GetDoubleClickTime", T_DWORD, 1, {T_DWORD} },
    { "GetFocus", T_HWND, 1, {T_DWORD} },
    { "GetForegroundWindow", T_HWND, 1, {T_DWORD} },
    { "GetIconInfo", T_DWORD, 2, {T_HICON, T_DWORD} },
    { "GetInputState", T_DWORD, 1, {T_DWORD} },
    { "GetKBCodePage", T_DWORD, 1, {T_DWORD} },
    { "GetKeyboardLayout", T_HKL, 1, {T_DWORD} },
    { "GetKeyboardLayoutList", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "GetKeyboardLayoutNameA", T_DWORD, 1, {T_LPSTR} },
    { "GetKeyboardLayoutNameW", T_DWORD, 1, {T_LPWSTR} },
    { "GetKeyboardState", T_DWORD, 1, {T_DWORD} },
    { "GetKeyboardType", T_DWORD, 1, {T_DWORD} },
    { "GetKeyNameTextA", T_DWORD, 3, {T_DWORD, T_LPSTR, T_DWORD} },
    { "GetKeyNameTextW", T_DWORD, 3, {T_DWORD, T_LPWSTR, T_DWORD} },
    { "GetKeyState", T_DWORD, 1, {T_DWORD} },
    { "GetLastActivePopup", T_HWND, 1, {T_HWND} },
    { "GetMenu", T_HMENU, 1, {T_HWND} },
    { "GetMenuCheckMarkDimensions", T_DWORD, 1, {T_DWORD} },
    { "GetMenuContextHelpId", T_DWORD, 1, {T_HMENU} },
    { "GetMenuDefaultItem", T_DWORD, 3, {T_HMENU, T_DWORD, T_DWORD} },
    { "GetMenuItemCount", T_DWORD, 1, {T_HMENU} },
    { "GetMenuItemID", T_DWORD, 2, {T_HMENU, T_DWORD} },
    { "GetMenuItemInfoA", T_DWORD, 4, {T_HMENU, T_DWORD, T_DWORD, T_DWORD} },
    { "GetMenuItemInfoW", T_DWORD, 4, {T_HMENU, T_DWORD, T_DWORD, T_DWORD} },
    { "GetMenuItemRect", T_DWORD, 4, {T_HWND, T_HMENU, T_DWORD, T_DWORD} },
    { "GetMenuState", T_DWORD, 3, {T_HMENU, T_DWORD, T_DWORD} },
    { "GetMenuStringA", T_DWORD, 5, {T_HMENU, T_DWORD, T_LPSTR, T_DWORD, T_DWORD} },
    { "GetMenuStringW", T_DWORD, 5, {T_HMENU, T_DWORD, T_LPWSTR, T_DWORD, T_DWORD} },
    { "GetMessageA", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetMessageExtraInfo", T_DWORD, 1, {T_DWORD} },
    { "GetMessagePos", T_DWORD, 1, {T_DWORD} },
    { "GetMessageTime", T_DWORD, 1, {T_DWORD} },
    { "GetMessageW", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetNextDlgGroupItem", T_HWND, 3, {T_HWND, T_HWND, T_DWORD} },
    { "GetNextDlgTabItem", T_HWND, 3, {T_HWND, T_HWND, T_DWORD} },
    { "GetOpenClipboardWindow", T_HWND, 1, {T_DWORD} },
    { "GetParent", T_HWND, 1, {T_HWND} },
    { "GetPriorityClipboardFormat", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "GetProcessWindowStation", T_HWINSTA, 1, {T_DWORD} },
    { "GetPropA", T_HANDLE, 2, {T_HWND, T_LPSTR} },
    { "GetPropW", T_HANDLE, 2, {T_HWND, T_LPWSTR} },
    { "GetQueueStatus", T_DWORD, 1, {T_DWORD} },
    { "GetScrollInfo", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "GetScrollPos", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetScrollRange", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "GetSubMenu", T_HMENU, 2, {T_HMENU, T_DWORD} },
    { "GetSysColor", T_DWORD, 1, {T_DWORD} },
    { "GetSysColorBrush", T_HBRUSH, 1, {T_DWORD} },
    { "GetSystemMenu", T_HMENU, 2, {T_HWND, T_DWORD} },
    { "GetSystemMetrics", T_DWORD, 1, {T_DWORD} },
    { "GetTabbedTextExtentA", T_DWORD, 5, {T_HDC, T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "GetTabbedTextExtentW", T_DWORD, 5, {T_HDC, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "GetThreadDesktop", T_HDESK, 1, {T_DWORD} },
    { "GetTopWindow", T_HWND, 1, {T_HWND} },
    { "GetUpdateRect", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "GetUpdateRgn", T_DWORD, 3, {T_HWND, T_HRGN, T_DWORD} },
    { "GetUserObjectInformationA", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetUserObjectInformationW", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetUserObjectSecurity", T_DWORD, 5, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GetWindow", T_HWND, 2, {T_HWND, T_DWORD} },
    { "GetWindowContextHelpId", T_DWORD, 1, {T_HWND} },
    { "GetWindowDC", T_HDC, 1, {T_HWND} },
    { "GetWindowLongA", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetWindowLongW", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetWindowPlacement", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetWindowRect", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetWindowRgn", T_DWORD, 2, {T_HWND, T_HRGN} },
    { "GetWindowTextA", T_DWORD, 3, {T_HWND, T_LPSTR, T_DWORD} },
    { "GetWindowTextLengthA", T_DWORD, 1, {T_HWND} },
    { "GetWindowTextLengthW", T_DWORD, 1, {T_HWND} },
    { "GetWindowTextW", T_DWORD, 3, {T_HWND, T_LPWSTR, T_DWORD} },
    { "GetWindowThreadProcessId", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GetWindowWord", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "GrayStringA", T_DWORD, 8, {T_HDC, T_HBRUSH, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "GrayStringW", T_DWORD, 8, {T_HDC, T_HBRUSH, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "HideCaret", T_DWORD, 1, {T_HWND} },
    { "HiliteMenuItem", T_DWORD, 4, {T_HWND, T_HMENU, T_DWORD, T_DWORD} },
    { "InflateRect", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "InSendMessage", T_DWORD, 1, {T_DWORD} },
    { "InsertMenuA", T_DWORD, 5, {T_HMENU, T_DWORD, T_DWORD, T_DWORD, T_LPSTR} },
    { "InsertMenuItemA", T_DWORD, 4, {T_HMENU, T_DWORD, T_DWORD, T_DWORD} },
    { "InsertMenuItemW", T_DWORD, 4, {T_HMENU, T_DWORD, T_DWORD, T_DWORD} },
    { "InsertMenuW", T_DWORD, 5, {T_HMENU, T_DWORD, T_DWORD, T_DWORD, T_LPWSTR} },
    { "IntersectRect", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "InvalidateRect", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "InvalidateRgn", T_DWORD, 3, {T_HWND, T_HRGN, T_DWORD} },
    { "InvertRect", T_DWORD, 2, {T_HDC, T_DWORD} },
    { "IsCharAlphaA", T_DWORD, 1, {T_DWORD} },
    { "IsCharAlphaNumericA", T_DWORD, 1, {T_DWORD} },
    { "IsCharAlphaNumericW", T_DWORD, 1, {T_DWORD} },
    { "IsCharAlphaW", T_DWORD, 1, {T_DWORD} },
    { "IsCharLowerA", T_DWORD, 1, {T_DWORD} },
    { "IsCharLowerW", T_DWORD, 1, {T_DWORD} },
    { "IsCharUpperA", T_DWORD, 1, {T_DWORD} },
    { "IsCharUpperW", T_DWORD, 1, {T_DWORD} },
    { "IsChild", T_DWORD, 2, {T_HWND, T_HWND} },
    { "IsClipboardFormatAvailable", T_DWORD, 1, {T_DWORD} },
    { "IsDialogMessageA", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "IsDialogMessageW", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "IsDlgButtonChecked", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "IsIconic", T_DWORD, 1, {T_HWND} },
    { "IsMenu", T_DWORD, 1, {T_HMENU} },
    { "IsRectEmpty", T_DWORD, 1, {T_DWORD} },
    { "IsWindow", T_DWORD, 1, {T_HWND} },
    { "IsWindowEnabled", T_DWORD, 1, {T_HWND} },
    { "IsWindowUnicode", T_DWORD, 1, {T_HWND} },
    { "IsWindowVisible", T_DWORD, 1, {T_HWND} },
    { "IsZoomed", T_DWORD, 1, {T_HWND} },
    { "keybd_event", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "KillTimer", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "LoadAcceleratorsA", T_HACCEL, 2, {T_HINSTANCE, T_LPSTR} },
    { "LoadAcceleratorsW", T_HACCEL, 2, {T_HINSTANCE, T_LPWSTR} },
    { "LoadBitmapA", T_HBITMAP, 2, {T_HINSTANCE, T_LPSTR} },
    { "LoadBitmapW", T_HBITMAP, 2, {T_HINSTANCE, T_LPWSTR} },
    { "LoadCursorA", T_HCURSOR, 2, {T_HINSTANCE, T_LPSTR} },
    { "LoadCursorFromFileA", T_HCURSOR, 1, {T_LPSTR} },
    { "LoadCursorFromFileW", T_HCURSOR, 1, {T_LPWSTR} },
    { "LoadCursorW", T_HCURSOR, 2, {T_HINSTANCE, T_LPWSTR} },
    { "LoadIconA", T_HICON, 2, {T_HINSTANCE, T_LPSTR} },
    { "LoadIconW", T_HICON, 2, {T_HINSTANCE, T_LPWSTR} },
    { "LoadImageA", T_HANDLE, 6, {T_HINSTANCE, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "LoadImageW", T_HANDLE, 6, {T_HINSTANCE, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "LoadKeyboardLayoutA", T_HKL, 2, {T_LPSTR, T_DWORD} },
    { "LoadKeyboardLayoutW", T_HKL, 2, {T_LPWSTR, T_DWORD} },
    { "LoadMenuA", T_HMENU, 2, {T_HINSTANCE, T_LPSTR} },
    { "LoadMenuIndirectA", T_HMENU, 1, {T_DWORD} },
    { "LoadMenuIndirectW", T_HMENU, 1, {T_DWORD} },
    { "LoadMenuW", T_HMENU, 2, {T_HINSTANCE, T_LPWSTR} },
    { "LoadStringA", T_DWORD, 4, {T_HINSTANCE, T_DWORD, T_LPSTR, T_DWORD} },
    { "LoadStringW", T_DWORD, 4, {T_HINSTANCE, T_DWORD, T_LPWSTR, T_DWORD} },
    { "LockWindowUpdate", T_DWORD, 1, {T_HWND} },
    { "LookupIconIdFromDirectory", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "LookupIconIdFromDirectoryEx", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "MapDialogRect", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "MapVirtualKeyA", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "MapVirtualKeyExA", T_DWORD, 3, {T_DWORD, T_DWORD, T_HKL} },
    { "MapVirtualKeyExW", T_DWORD, 3, {T_DWORD, T_DWORD, T_HKL} },
    { "MapVirtualKeyW", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "MapWindowPoints", T_DWORD, 4, {T_HWND, T_HWND, T_DWORD, T_DWORD} },
    { "MenuItemFromPoint", T_DWORD, 3, {T_HWND, T_HMENU, T_DWORD} },
    { "MessageBeep", T_DWORD, 1, {T_DWORD} },
    { "MessageBoxA", T_DWORD, 4, {T_DWORD, T_LPSTR, T_LPSTR, T_DWORD} },
    { "MessageBoxExA", T_DWORD, 5, {T_DWORD, T_LPSTR, T_LPSTR, T_DWORD, T_DWORD} },
    { "MessageBoxExW", T_DWORD, 5, {T_DWORD, T_LPWSTR, T_LPWSTR, T_DWORD, T_DWORD} },
    { "MessageBoxIndirectA", T_DWORD, 1, {T_DWORD} },
    { "MessageBoxIndirectW", T_DWORD, 1, {T_DWORD} },
    { "MessageBoxW", T_DWORD, 4, {T_DWORD, T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "ModifyMenuA", T_DWORD, 5, {T_HMENU, T_DWORD, T_DWORD, T_DWORD, T_LPSTR} },
    { "ModifyMenuW", T_DWORD, 5, {T_HMENU, T_DWORD, T_DWORD, T_DWORD, T_LPWSTR} },
    { "mouse_event", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "MoveWindow", T_DWORD, 6, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "MsgWaitForMultipleObjects", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "MsgWaitForMultipleObjectsEx", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "OemKeyScan", T_DWORD, 1, {T_DWORD} },
    { "OemToCharA", T_DWORD, 2, {T_LPSTR, T_LPSTR} },
    { "OemToCharBuffA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "OemToCharBuffW", T_DWORD, 3, {T_LPSTR, T_LPWSTR, T_DWORD} },
    { "OemToCharW", T_DWORD, 2, {T_LPSTR, T_LPWSTR} },
    { "OffsetRect", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "OpenClipboard", T_DWORD, 1, {T_HWND} },
    { "OpenDesktopA", T_HDESK, 4, {T_LPSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "OpenDesktopW", T_HDESK, 4, {T_LPWSTR, T_DWORD, T_DWORD, T_DWORD} },
    { "OpenIcon", T_DWORD, 1, {T_HWND} },
    { "OpenInputDesktop", T_HDESK, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "OpenWindowStationA", T_HWINSTA, 3, {T_LPSTR, T_DWORD, T_DWORD} },
    { "OpenWindowStationW", T_HWINSTA, 3, {T_LPWSTR, T_DWORD, T_DWORD} },
    { "PaintDesktop", T_DWORD, 1, {T_HDC} },
    { "PeekMessageA", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "PeekMessageW", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "PostMessageA", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "PostMessageW", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "PostQuitMessage", T_DWORD, 1, {T_DWORD} },
    { "PostThreadMessageA", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "PostThreadMessageW", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "PtInRect", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "RedrawWindow", T_DWORD, 4, {T_HWND, T_DWORD, T_HRGN, T_DWORD} },
    { "RegisterClassA", T_DWORD, 1, {T_DWORD} },
    { "RegisterClassExA", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "RegisterClassExW", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "RegisterClassW", T_DWORD, 1, {T_DWORD} },
    { "RegisterClipboardFormatA", T_DWORD, 1, {T_LPSTR} },
    { "RegisterClipboardFormatW", T_DWORD, 1, {T_LPWSTR} },
    { "RegisterHotKey", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "RegisterWindowMessageA", T_DWORD, 1, {T_LPSTR} },
    { "RegisterWindowMessageW", T_DWORD, 1, {T_LPWSTR} },
    { "ReleaseCapture", T_DWORD, 1, {T_DWORD} },
    { "ReleaseDC", T_DWORD, 2, {T_HWND, T_HDC} },
    { "RemoveMenu", T_DWORD, 3, {T_HMENU, T_DWORD, T_DWORD} },
    { "RemovePropA", T_HANDLE, 2, {T_HWND, T_LPSTR} },
    { "RemovePropW", T_HANDLE, 2, {T_HWND, T_LPWSTR} },
    { "ReplyMessage", T_DWORD, 1, {T_DWORD} },
    { "ScreenToClient", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "ScrollDC", T_DWORD, 7, {T_HDC, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HRGN, T_DWORD} },
    { "ScrollWindow", T_DWORD, 5, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ScrollWindowEx", T_DWORD, 8, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HRGN, T_DWORD, T_DWORD} },
    { "SendDlgItemMessageA", T_DWORD, 5, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SendDlgItemMessageW", T_DWORD, 5, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SendMessageA", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "SendMessageCallbackA", T_DWORD, 6, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SendMessageCallbackW", T_DWORD, 6, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SendMessageTimeoutA", T_DWORD, 7, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SendMessageTimeoutW", T_DWORD, 7, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SendMessageW", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "SendNotifyMessageA", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "SendNotifyMessageW", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "SetActiveWindow", T_HWND, 1, {T_HWND} },
    { "SetCapture", T_HWND, 1, {T_HWND} },
    { "SetCaretBlinkTime", T_DWORD, 1, {T_DWORD} },
    { "SetCaretPos", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SetClassLongA", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "SetClassLongW", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "SetClassWord", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "SetClipboardData", T_HANDLE, 2, {T_DWORD, T_HANDLE} },
    { "SetClipboardViewer", T_HWND, 1, {T_HWND} },
    { "SetCursor", T_HCURSOR, 1, {T_HCURSOR} },
    { "SetCursorPos", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SetDebugErrorLevel", T_DWORD, 1, {T_DWORD} },
    { "SetDlgItemInt", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "SetDlgItemTextA", T_DWORD, 3, {T_HWND, T_DWORD, T_LPSTR} },
    { "SetDlgItemTextW", T_DWORD, 3, {T_HWND, T_DWORD, T_LPWSTR} },
    { "SetDoubleClickTime", T_DWORD, 1, {T_DWORD} },
    { "SetFocus", T_HWND, 1, {T_HWND} },
    { "SetForegroundWindow", T_DWORD, 1, {T_HWND} },
    { "SetKeyboardState", T_DWORD, 1, {T_DWORD} },
    { "SetLastErrorEx", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SetMenu", T_DWORD, 2, {T_HWND, T_HMENU} },
    { "SetMenuContextHelpId", T_DWORD, 2, {T_HMENU, T_DWORD} },
    { "SetMenuDefaultItem", T_DWORD, 3, {T_HMENU, T_DWORD, T_DWORD} },
    { "SetMenuItemBitmaps", T_DWORD, 5, {T_HMENU, T_DWORD, T_DWORD, T_HBITMAP, T_HBITMAP} },
    { "SetMenuItemInfoA", T_DWORD, 4, {T_HMENU, T_DWORD, T_DWORD, T_DWORD} },
    { "SetMenuItemInfoW", T_DWORD, 4, {T_HMENU, T_DWORD, T_DWORD, T_DWORD} },
    { "SetMessageExtraInfo", T_DWORD, 1, {T_DWORD} },
    { "SetMessageQueue", T_DWORD, 1, {T_DWORD} },
    { "SetParent", T_HWND, 2, {T_HWND, T_HWND} },
    { "SetProcessWindowStation", T_DWORD, 1, {T_HWINSTA} },
    { "SetPropA", T_DWORD, 3, {T_HWND, T_LPSTR, T_HANDLE} },
    { "SetPropW", T_DWORD, 3, {T_HWND, T_LPWSTR, T_HANDLE} },
    { "SetRect", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SetRectEmpty", T_DWORD, 1, {T_DWORD} },
    { "SetScrollInfo", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "SetScrollPos", T_DWORD, 4, {T_HWND, T_DWORD, T_DWORD, T_DWORD} },
    { "SetScrollRange", T_DWORD, 5, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SetSysColors", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "SetSystemCursor", T_DWORD, 2, {T_HCURSOR, T_DWORD} },
    { "SetThreadDesktop", T_DWORD, 1, {T_HDESK} },
    { "SetTimer", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SetUserObjectInformationA", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "SetUserObjectInformationW", T_DWORD, 4, {T_HANDLE, T_DWORD, T_DWORD, T_DWORD} },
    { "SetUserObjectSecurity", T_DWORD, 3, {T_HANDLE, T_DWORD, T_DWORD} },
    { "SetWindowContextHelpId", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "SetWindowLongA", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "SetWindowLongW", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "SetWindowPlacement", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "SetWindowPos", T_DWORD, 7, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SetWindowRgn", T_DWORD, 3, {T_HWND, T_HRGN, T_DWORD} },
    { "SetWindowsHookA", T_HHOOK, 2, {T_DWORD, T_DWORD} },
    { "SetWindowsHookA", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SetWindowsHookExA", T_HHOOK, 4, {T_DWORD, T_DWORD, T_HINSTANCE, T_DWORD} },
    { "SetWindowsHookExW", T_HHOOK, 4, {T_DWORD, T_DWORD, T_HINSTANCE, T_DWORD} },
    { "SetWindowsHookW", T_HHOOK, 2, {T_DWORD, T_DWORD} },
    { "SetWindowsHookW", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "SetWindowTextA", T_DWORD, 2, {T_HWND, T_LPSTR} },
    { "SetWindowTextW", T_DWORD, 2, {T_HWND, T_LPWSTR} },
    { "SetWindowWord", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "ShowCaret", T_DWORD, 1, {T_HWND} },
    { "ShowCursor", T_DWORD, 1, {T_DWORD} },
    { "ShowOwnedPopups", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "ShowScrollBar", T_DWORD, 3, {T_HWND, T_DWORD, T_DWORD} },
    { "ShowWindow", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "ShowWindowAsync", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "SubtractRect", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "SwapMouseButton", T_DWORD, 1, {T_DWORD} },
    { "SwitchDesktop", T_DWORD, 1, {T_HDESK} },
    { "SystemParametersInfoA", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "SystemParametersInfoW", T_DWORD, 4, {T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "TabbedTextOutA", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_LPSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "TabbedTextOutW", T_DWORD, 8, {T_HDC, T_DWORD, T_DWORD, T_LPWSTR, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "TileWindows", T_DWORD, 5, {T_HWND, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ToAscii", T_DWORD, 5, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD} },
    { "ToAsciiEx", T_DWORD, 6, {T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HKL} },
    { "ToUnicode", T_DWORD, 6, {T_DWORD, T_DWORD, T_DWORD, T_LPWSTR, T_DWORD, T_DWORD} },
    { "ToUnicodeEx", T_DWORD, 7, {T_DWORD, T_DWORD, T_DWORD, T_LPWSTR, T_DWORD, T_DWORD, T_HKL} },
    { "TrackMouseEvent", T_DWORD, 1, {T_DWORD} },
    { "TrackPopupMenu", T_DWORD, 7, {T_HMENU, T_DWORD, T_DWORD, T_DWORD, T_DWORD, T_HWND, T_DWORD} },
    { "TrackPopupMenuEx", T_DWORD, 6, {T_HMENU, T_DWORD, T_DWORD, T_DWORD, T_HWND, T_DWORD} },
    { "TranslateAcceleratorA", T_DWORD, 3, {T_HWND, T_HACCEL, T_DWORD} },
    { "TranslateAcceleratorW", T_DWORD, 3, {T_HWND, T_HACCEL, T_DWORD} },
    { "TranslateMDISysAccel", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "TranslateMessage", T_DWORD, 1, {T_DWORD} },
    { "UnhookWindowsHook", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "UnhookWindowsHookEx", T_DWORD, 1, {T_HHOOK} },
    { "UnionRect", T_DWORD, 3, {T_DWORD, T_DWORD, T_DWORD} },
    { "UnloadKeyboardLayout", T_DWORD, 1, {T_HKL} },
    { "UnregisterClassA", T_DWORD, 2, {T_LPSTR, T_HINSTANCE} },
    { "UnregisterClassW", T_DWORD, 2, {T_LPWSTR, T_HINSTANCE} },
    { "UnregisterHotKey", T_DWORD, 2, {T_HWND, T_DWORD} },
    { "UpdateWindow", T_DWORD, 1, {T_HWND} },
    { "ValidateRect", T_DWORD, 2, {T_DWORD, T_DWORD} },
    { "ValidateRgn", T_DWORD, 2, {T_HWND, T_HRGN} },
    { "VkKeyScanA", T_DWORD, 1, {T_DWORD} },
    { "VkKeyScanExA", T_DWORD, 2, {T_DWORD, T_HKL} },
    { "VkKeyScanExW", T_DWORD, 2, {T_DWORD, T_HKL} },
    { "VkKeyScanW", T_DWORD, 1, {T_DWORD} },
    { "WaitForInputIdle", T_DWORD, 2, {T_HANDLE, T_DWORD} },
    { "WaitMessage", T_DWORD, 1, {T_DWORD} },
    { "WindowFromDC", T_HWND, 1, {T_HDC} },
    { "WindowFromPoint", T_HWND, 1, {T_DWORD} },
    { "WinHelpA", T_DWORD, 4, {T_HWND, T_LPSTR, T_DWORD, T_DWORD} },
    { "WinHelpW", T_DWORD, 4, {T_HWND, T_LPWSTR, T_DWORD, T_DWORD} },
    { "wsprintfA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "wsprintfW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { "wvsprintfA", T_DWORD, 3, {T_LPSTR, T_LPSTR, T_DWORD} },
    { "wvsprintfW", T_DWORD, 3, {T_LPWSTR, T_LPWSTR, T_DWORD} },
    { NULL, 0, 0, }
};


API_MASTER_TABLE ApiTables[] =
{
    { "kernel32.dll", FALSE, API_Kernel32 },
    { "user32.dll",   FALSE, API_User32   },
    { "gdi32.dll",    FALSE, API_Gdi32    },
    { NULL,           FALSE, NULL         }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apidll\i386\machine.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    machine.cpp

Abstract:

    This file implements the CreateMachApiThunk() function.  This
    function is responsible for emitting the individual API thunks
    for the i386 architecture.

Author:

    Wesley Witt (wesw) 28-June-1995

Environment:

    User Mode

--*/

#include "apidllp.h"
#pragma hdrstop

PUCHAR
CreateMachApiThunk(
    PULONG      IatAddress,
    PUCHAR      Text,
    PDLL_INFO   DllInfo,
    PAPI_INFO   ApiInfo
    )

/*++

Routine Description:

    Emits the machine specific code for the API thunks.

Arguments:

    IatAddress  - Pointer to the IAT fir this API
    Text        - Pointer to a buffer to place the generated code
    DllInfo     - Pointer to the DLL_INFO structure
    ApiInfo     - Pointer to the API_INFO structure

Return Value:

    Pointer to the next byte to place more generated code.

--*/

{
    if (ApiInfo->ThunkAddress) {
        *IatAddress = ApiInfo->ThunkAddress;
        return Text;
    }

    *IatAddress = (ULONG)Text;
    ApiInfo->ThunkAddress = *IatAddress;
    PUCHAR Code = (PUCHAR)Text;

    Code[0] = 0x68;
    Code += 1;
    *(LPDWORD)Code = (ULONG)ApiInfo;
    Code += sizeof(DWORD);
    Code[0] = 0x68;
    Code += 1;
    *(LPDWORD)Code = (ULONG)DllInfo;
    Code += sizeof(DWORD);
    Code[0] = 0x68;
    Code += 1;

    if (_stricmp(DllInfo->Name,KERNEL32)==0) {
        if (strcmp((LPSTR)(ApiInfo->Name+(LPSTR)MemPtr),LOADLIBRARYA)==0) {
            *(LPDWORD)Code = APITYPE_LOADLIBRARYA;
        } else
        if (strcmp((LPSTR)(ApiInfo->Name+(LPSTR)MemPtr),LOADLIBRARYW)==0) {
            *(LPDWORD)Code = APITYPE_LOADLIBRARYW;
        } else
        if (strcmp((LPSTR)(ApiInfo->Name+(LPSTR)MemPtr),FREELIBRARY)==0) {
            *(LPDWORD)Code = APITYPE_FREELIBRARY;
        } else 
        if (strcmp((LPSTR)(ApiInfo->Name+(LPSTR)MemPtr),GETPROCADDRESS)==0) {
            *(LPDWORD)Code = APITYPE_GETPROCADDRESS;
        } else {
            *(LPDWORD)Code = APITYPE_NORMAL;
        }
    } else if (_stricmp(DllInfo->Name,USER32)==0) {
         if (strcmp((LPSTR)(ApiInfo->Name+(LPSTR)MemPtr),REGISTERCLASSA)==0) {
             *(LPDWORD)Code = APITYPE_REGISTERCLASSA;                         
         } else                                                               
         if (strcmp((LPSTR)(ApiInfo->Name+(LPSTR)MemPtr),REGISTERCLASSW)==0) {
             *(LPDWORD)Code = APITYPE_REGISTERCLASSW;                        
         } else                                                                
         if (strcmp((LPSTR)(ApiInfo->Name+(LPSTR)MemPtr),SETWINDOWLONGA)==0) { 
              *(LPDWORD)Code = APITYPE_SETWINDOWLONG;                           
         } else                                                                
         if (strcmp((LPSTR)(ApiInfo->Name+(LPSTR)MemPtr),SETWINDOWLONGW)==0) {
              *(LPDWORD)Code = APITYPE_SETWINDOWLONG;
         } else {
              *(LPDWORD)Code = APITYPE_NORMAL;
         }                             
    } else if (_stricmp(DllInfo->Name,WNDPROCDLL)==0) {
        *(LPDWORD)Code = APITYPE_WNDPROC;
    } else {
        *(LPDWORD)Code = APITYPE_NORMAL;
    }


    Code += sizeof(DWORD);

    Code[0] = 0xe9;
    Code += 1;
    *(LPDWORD)Code = (ULONG)((ULONG)ApiMonThunk-(((ULONG)Code-(ULONG)Text)+(ULONG)Text+4));
    Code += sizeof(DWORD);

    return Code;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\alias.cpp ===
/****************************** Module Header ******************************\
* Module Name: alias.cpp
*
* This module implements ApiMon aliasing.
*
* History:
* 06-11-96 vadimg         created
\***************************************************************************/

#include "apimonp.h"
#include "alias.h"

char *grgpsz[] = {"HACCEL", "HANDLE", "HBITMA", "HBRUSH", "HCURSO", "HDC",
        "HDCLP", "HDESK", "HDWP", "HENHME", "HFONT", "HGDIOB", "HGLOBA",
        "HGLRC", "HHOOK", "HICON", "HINSTA", "HKL", "HMENU", "HMETAF",
        "HPALET", "HPEN", "HRGN", "HWINST", "HWND"};

/*
    The hashing function.
*/

inline long Hash(ULONG_PTR ulHandle)
{
    return (long)(ulHandle % kulTableSize);
}

/*
   CAliasNode::CAliasNode
   Initialize the node.
*/

inline CAliasNode::CAliasNode(ULONG_PTR ulHandle, long nAlias)
{
    m_panodNext = NULL;
    m_ulHandle = ulHandle;
    m_nAlias = nAlias;
}

/*
   CAliasNode::CAliasNode
   An empty constructor for array declaration.
*/

inline CAliasNode::CAliasNode()
{
}

ULONG CAliasTable::s_ulAlias = 0;

/*
   CAliasTable::CAliasTable
   Initialize the hash table.
*/

CAliasTable::CAliasTable()
{
    memset(m_rgpanod, 0, sizeof(CAliasNode*)*kulTableSize);
}

/*
   CAliasTable::~CAliasTable
   Free the hash table.
*/

CAliasTable::~CAliasTable()
{
    for (int i = kulTableSize - 1; i >= 0; i--) {
        if (m_rgpanod[i] != NULL) {
            CAliasNode *panodT = m_rgpanod[i], *panodNext;
            while (panodT != NULL) {
                panodNext = panodT->m_panodNext;
                delete panodT;
                panodT = panodNext;
            }
        }
    }
}

/*
   CAliasTable::~CAliasTable
   Insert a new handle into the hash table.
*/

long CAliasTable::Insert(ULONG_PTR ulHandle)
{
    ULONG iHash = Hash(ulHandle), ulAlias = s_ulAlias++;
    CAliasNode *panod;

    if ((panod = new CAliasNode(ulHandle, ulAlias)) == NULL)
        return -1;

    if (m_rgpanod[iHash] == NULL) {
        m_rgpanod[iHash] = panod;
    } else {
        CAliasNode *panodT = m_rgpanod[iHash];
        m_rgpanod[iHash] = panod;
        panod->m_panodNext = panodT;
    }
    return ulAlias;
}

/*
   CAliasTable::Lookup
   Find an alias corresponding to the given handle.
*/

long CAliasTable::Lookup(ULONG_PTR ulHandle)
{
    CAliasNode *panodT = m_rgpanod[Hash(ulHandle)];
    while (panodT != NULL) {
        if (panodT->m_ulHandle == ulHandle) {
            return panodT->m_nAlias;
        }
        panodT = panodT->m_panodNext;
    }
    return -1;
}

/*
   CAliasTable::Alias
   Alias by the given type and handle.
*/

void CAliasTable::Alias(ULONG ulType, ULONG_PTR ulHandle, char szAlias[])
{
    if (ulHandle == 0) {
        strcpy(szAlias, "NULL");
        return;
    }

    long nAlias = Lookup(ulHandle);
    if (nAlias == -1) {
        if ((nAlias = Insert(ulHandle)) == -1) {
            strcpy(szAlias, "FAILED");
            return;
        }
    }

    sprintf(szAlias, "%6s%04x", grgpsz[ulType], nAlias);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apidll\i386\thunk.asm ===
; Copyright (c) 1995  Microsoft Corporation
;
; Module Name:
;
;     thunk.s
;
; Abstract:
;
;     Implements the API thunk that gets executed for all
;     re-directed APIS.
;
; Author:
;
;     Wesley Witt (wesw) 28-June-1995
;
; Environment:
;
;     User Mode
;

.386p
include ks386.inc
include callconv.inc

TRACE   equ  0

EXTRNP  _HandleDynamicDllLoadA,2
EXTRNP  _HandleDynamicDllLoadW,2
EXTRNP  _HandleDynamicDllFree,1
EXTRNP  _HandleGetProcAddress,1
EXTRNP  _HandleRegisterClassA,1
EXTRNP  _HandleRegisterClassW,1
EXTRNP  _HandleSetWindowLong,3
EXTRNP  _QueryPerformanceCounter,1
EXTRNP  _ApiTrace,9
EXTRNP  _GetApiInfo,4


extrn   _FastCounterAvail:DWORD
extrn   _ApiCounter:DWORD
extrn   _ApiTimingEnabled:DWORD
extrn   _ApiTraceEnabled:DWORD
extrn   _pTlsGetValue:DWORD
extrn   _pTlsSetValue:DWORD
extrn   _pGetLastError:DWORD
extrn   _pSetLastError:DWORD
extrn   _TlsReEnter:DWORD
extrn   _TlsStack:DWORD
extrn   _ThunkOverhead:DWORD
extrn   _ThunkCallOverhead:DWORD

if TRACE
extrn   _dprintf:NEAR
endif

APITYPE_NORMAL          equ      0
APITYPE_LOADLIBRARYA    equ      1
APITYPE_LOADLIBRARYW    equ      2
APITYPE_FREELIBRARY     equ      3
APITYPE_REGISTERCLASSA  equ      4
APITYPE_REGISTERCLASSW  equ      5
APITYPE_GETPROCADDRESS  equ      6
APITYPE_SETWINDOWLONG   equ      7
APITYPE_WNDPROC         equ      8
APITYPE_INVALID         equ      9

DllEnabledOffset          equ     52

ApiInfoAddressOffset      equ      4
ApiInfoCountOffset        equ     12
ApiInfoTimeOffset         equ     16
ApiInfoCalleeTimeOffset   equ     24
ApiInfoNestCountOffset    equ     32
ApiInfoTraceEnabled       equ     36
ApiInfoTableOffset        equ     40

ApiTableCountOffset       equ     8

API_TRACE                 equ     1
API_FULLTRACE             equ     2

LastErrorSave             equ      0
EdiSave                   equ      4
EsiSave                   equ      8
EdxSave                   equ     12
EcxSave                   equ     16
EbxSave                   equ     20
EaxSave                   equ     24
ApiFlagSave               equ     28
DllInfoSave               equ     32
ApiInfoSave               equ     36
RetAddrSave               equ     40

StackSize                 equ     44

EbpFrm                    equ      0
DllInfoFrm                equ      4
ApiInfoFrm                equ      8
ApiFlagFrm                equ     12
ApiBiasFrm                equ     16
RetAddrFrm                equ     20
LastErrorFrm              equ     24
Arg0Frm                   equ     28
Arg1Frm                   equ     32
Arg2Frm                   equ     36
Arg3Frm                   equ     40
Arg4Frm                   equ     44
Arg5Frm                   equ     48
Arg6Frm                   equ     52
Arg7Frm                   equ     56
OverheadTimeFrm           equ     64
FuncTimeFrm               equ     72
CalleeTimeFrm             equ     80
TempTimeFrm               equ     88

FrameSize                 equ     96

;
; Routine Description:
;
;     This MACRO gets a performance counter value.
;     If we are running on a uni-processor pentium
;     then we can use the rdtsc instruction.  Otherwise
;     we must use the QueryPerformanceCounter API.
;
; Arguments:
;
;     CounterOffset     - the offset from ebp where the
;                         counter data is to be stored.
;
; Return Value:
;
;     None.
;
GET_PERFORMANCE_COUNTER macro CounterOffset
local   DoPentium,PentiumExit
        mov     eax,[_FastCounterAvail]
        mov     eax,[eax]
        or      eax,eax
        jnz     DoPentium
        mov     eax,ebp
        add     eax,CounterOffset
        push    eax
        call    _QueryPerformanceCounter@4
        jmp     PentiumExit
DoPentium:
        db      0fh,31h                 ; RDTSC instruction
        mov     [ebp+CounterOffset],eax
        mov     [ebp+CounterOffset+4],edx
PentiumExit:
        endm


_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

if TRACE
Msg1 db 'ApiMonThunk()         0x%08x',0ah,00
Msg2 db 'ApiMonThunkComplete() 0x%08x',0ah,00
endif


;
; Routine Description:
;
;     This function is jumped to after a monitored
;     API has completed.  Here we do our cleanup
;     and then branch to the caller's return address.
;
; Arguments:
;
;     ebp - points to the api's frame on our parallel stack
;     eax - return value
;     edx - return value
;
; Return Value:
;
;     None.
;
cPublicProc _ApiMonThunkComplete,0

        ;
        ; save registers
        ;
        push    eax
        push    ebx
        push    ecx
        push    edx
        push    esi
        push    edi
        ;
        ; save the last error value
        ;
        call    _pGetLastError
        push    eax

if TRACE
        ;
        ; trace the call
        ;
        mov     eax,[ebp+ApiInfoFrm]
        mov     eax,[eax+ApiInfoAddressOffset]
        push    eax
        push    offset FLAT:Msg2
        call    _dprintf
        add     esp,8
endif
        ;
        ; check for counting enabled
        ;
        mov    edx,[ebp+DllInfoFrm]
        mov    eax,[edx+DllEnabledOffset]
        or     eax,eax
        jz     NoCounting

        ;
        ; decrement nesting count for this api
        ;
        mov     eax,[ebp+ApiInfoFrm]
        dec     dword ptr [eax+ApiInfoNestCountOffset]

        ;
        ; Compute total function time
        ;
        GET_PERFORMANCE_COUNTER TempTimeFrm

        mov     eax,[ebp+TempTimeFrm]
        mov     edx,[ebp+TempTimeFrm+4]

        sub     eax,[ebp+FuncTimeFrm]
        sbb     edx,[ebp+FuncTimeFrm+4]

        sub     eax,_ThunkOverhead
        sbb     edx,0

        mov     [ebp+FuncTimeFrm],eax
        mov     [ebp+FuncTimeFrm+4],edx

        ;
        ; Remove function time from our overhead time
        ; by adding advancing the overhead start time
        ;
        add     [ebp+OverheadTimeFrm],eax
        adc     [ebp+OverheadTimeFrm+4],edx

        ;
        ; accumulate function time for the API
        ;
        mov     edi,[ebp+ApiInfoFrm]
        add     [edi+ApiInfoTimeOffset],eax
        adc     [edi+ApiInfoTimeOffset+4],edx
        
        ;
        ; add time to callee time of parent frame
        ;
        add     [ebp - FrameSize + CalleeTimeFrm],eax
        adc     [ebp - FrameSize + CalleeTimeFrm+4],edx

        ;
        ; accumulate own callee time for the API
        ;
        mov     eax, [ebp+CalleeTimeFrm]
        mov     edx, [ebp+CalleeTimeFrm+4]
        add     [edi+ApiInfoCalleeTimeOffset],eax
        adc     [edi+ApiInfoCalleeTimeOffset+4],edx

NoCounting:
        ;
        ; handle load library and get process address specialy
        ;
        mov     ecx,[ebp+ApiFlagFrm]
        or      ecx,ecx
        jz      ThunkNormal

        ;
        ; branch to the correct handler
        ;
        cmp     ecx,APITYPE_LOADLIBRARYA
        jz      DoLoadLibraryA
        cmp     ecx,APITYPE_LOADLIBRARYW
        jz      DoLoadLibraryW
        cmp     ecx,APITYPE_FREELIBRARY
        jz      DoFreeLibrary
        cmp     ecx,APITYPE_GETPROCADDRESS
        jz      DoGetProcAddress
        cmp     ecx,APITYPE_WNDPROC     ; no tracing for wnd procs yet
        jz      NoTracing
        jmp     ThunkNormal

DoFreeLibrary:
        push    [ebp+Arg0Frm]
        call    _HandleDynamicDllFree@4
        jmp     ThunkNormal

DoLoadLibraryW:
        push    [ebp+Arg0Frm]
        push    [esp+EaxSave+4]
        call    _HandleDynamicDllLoadW@8
        jmp     ThunkNormal

DoLoadLibraryA:
        push    [ebp+Arg0Frm]
        push    [esp+EaxSave+4]
        call    _HandleDynamicDllLoadA@8
        jmp     ThunkNormal

DoGetProcAddress:
        push    [esp+EaxSave]
        call    _HandleGetProcAddress@4
        mov     [esp+EaxSave],eax
        jmp     ThunkNormal

ThunkNormal:

        ;
        ; do the api tracing?
        ;
        mov     eax,[_ApiTraceEnabled]
        mov     eax,[eax]
        or      eax, eax
        jz      NoTracing

        mov     eax,[ebp+DllInfoFrm]
        mov     eax,[eax+DllEnabledOffset]
        or      eax,eax
        jz      NoTracing

        mov     eax,[ebp+ApiInfoFrm]
        mov     eax,[eax+ApiInfoTraceEnabled]
        or      eax,eax
        jz      NoTracing

        ;
        ; trace the api
        ;
        mov     eax,[esp+EaxSave]    ; get ret value
        push    [esp+LastErrorSave]  ; last error value
        push    [ebp+FuncTimeFrm+4]  ; function duration
        push    [ebp+FuncTimeFrm]

        push    [ebp+TempTimeFrm+4]  ; exit time
        push    [ebp+TempTimeFrm]

        push    [ebp+RetAddrFrm]     ; caller's address
        push    eax                  ; return value
        lea     eax,[ebp+Arg0Frm]    ; parameter array
        push    eax
        push    [ebp+ApiInfoFrm]     ; apiinfo pointer
        call    _ApiTrace@36

NoTracing:

        ;
        ; Compute our overhead time
        ;
        GET_PERFORMANCE_COUNTER TempTimeFrm

        mov     eax,[ebp+TempTimeFrm]
        mov     edx,[ebp+TempTimeFrm+4]

        sub     eax,[ebp+OverheadTimeFrm]
        sbb     edx,[ebp+OverheadTimeFrm+4]

        add     eax,_ThunkCallOverhead
        adc     edx,0

        ;
        ; Subtract from parent's function time
        ; by advancing the function start time
        ;
        add     [ebp - FrameSize + FuncTimeFrm],eax
        adc     [ebp - FrameSize + FuncTimeFrm+4],edx

        ;
        ; destroy the frame on the stack
        ;
        push    _TlsStack
        call    _pTlsGetValue
        mov     [eax],ebp

        ;
        ; reset the last error value (already on the stack)
        ;
        call    _pSetLastError
             
        ;
        ; restore the registers
        ;
        pop     edi
        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax

        push    [ebp+RetAddrFrm]
        mov     ebp,[ebp]

        ;
        ; finally branch back to the caller
        ;
        ret

stdENDP _ApiMonThunkComplete


;
; Routine Description:
;
;     This function is the entry point for the api
;     monitor thunk.
;
; Arguments:
;
;     [esp+0]  - API flag
;     [esp+4]  - DLLINFO pointer
;     [esp+8]  - APIINFO pointer
;
; Return Value:
;
;     None.
;
cPublicProc _ApiMonThunk,0

        ;
        ; save regs
        ;
        push    eax
        push    ebx
        push    ecx
        push    edx
        push    esi
        push    edi
        ;
        ; save the last error value
        ;
        call    _pGetLastError
        push    eax

        ;
        ; get the reentry flag
        ;
        push    _TlsReEnter
        call    _pTlsGetValue

        ;
        ; don't enter if disallow flag is set
        ;
        or      eax,eax
        jz      ThunkOk

BadStack:
        ;
        ; replace ApiInfo pointer with Api address
        ; so we can ret to it
        ;
        mov     ebx,[esp+ApiInfoSave]
        mov     eax,dword ptr [ebx+ApiInfoAddressOffset]
        mov     [esp+ApiInfoSave],eax

        ;
        ; reset the last error value
        ;
        call    _pSetLastError

        ;
        ; restore the registers
        ;
        pop     edi
        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax

        add     sp,8        ; dump ApiFlag & DllInfo space
        ret                 ; jmp to real Api 

ThunkOk:

        ;
        ; get the parallel stack pointer
        ;
        push    _TlsStack
        call    _pTlsGetValue
        or      eax,eax
        jz      BadStack

        ;
        ; setup the frame pointer
        ;
        mov     edx,[eax]
        mov     [edx],ebp
        mov     ebp,edx

        ;
        ; create a frame on the stack by advancing the pointer
        ;
        add     edx,FrameSize
        mov     [eax],edx

        ;
        ; clear ApiBias, entry from _penter uses bias
        ;
        mov     [ebp+ApiBiasFrm],0

Thunk_Middle:

        ;
        ; get the arguments from the mini-thunk
        ;
        mov     eax,[esp+ApiFlagSave]
        mov     [ebp+ApiFlagFrm],eax

        mov     eax,[esp+DllInfoSave]
        mov     [ebp+DllInfoFrm],eax

        mov     eax,[esp+RetAddrSave]     
        mov     [ebp+RetAddrFrm],eax

        mov     eax,[esp+ApiInfoSave]
        mov     [ebp+ApiInfoFrm],eax

        ;
        ; save the real arguments
        ;
        mov     eax,[esp+StackSize]
        mov     [ebp+Arg0Frm],eax

        mov     eax,[esp+StackSize+4]
        mov     [ebp+Arg1Frm],eax

        mov     eax,[esp+StackSize+8]
        mov     [ebp+Arg2Frm],eax

        mov     eax,[esp+StackSize+12]
        mov     [ebp+Arg3Frm],eax

        mov     eax,[esp+StackSize+16]
        mov     [ebp+Arg4Frm],eax

        mov     eax,[esp+StackSize+20]
        mov     [ebp+Arg5Frm],eax

        mov     eax,[esp+StackSize+24]
        mov     [ebp+Arg6Frm],eax

        mov     eax,[esp+StackSize+28]
        mov     [ebp+Arg7Frm],eax

        ;   
        ; zero the callee time
        ;
        mov     [ebp+CalleeTimeFrm],0
        mov     [ebp+CalleeTimeFrm+4],0

        ;
        ; start the overhead timer, because it is variable from here on
        ;
        GET_PERFORMANCE_COUNTER OverheadTimeFrm

        ;
        ; Do special API processing
        ;
        mov     eax,[ebp+ApiFlagFrm]
        or      eax,eax
        jz      ThunkNotSpecial

        cmp     eax,APITYPE_REGISTERCLASSA
        jz      DoRegisterClassA
        cmp     eax,APITYPE_REGISTERCLASSW
        jz      DoRegisterClassW
        cmp     eax,APITYPE_SETWINDOWLONG
        jz      DoSetWindowLong
        jmp     ThunkNotSpecial

DoRegisterClassA:
        push    [ebp+Arg0Frm]  
        call    _HandleRegisterClassA@4
        jmp     ThunkNotSpecial
        
DoRegisterClassW:
        push    [ebp+Arg0Frm]
        call    _HandleRegisterClassW@4
        jmp     ThunkNotSpecial

DoSetWindowLong:
        push    [ebp+Arg2Frm]
        push    [ebp+Arg1Frm]
        push    [ebp+Arg0Frm]
        call    _HandleSetWindowLong@12
        mov     [esp+StackSize+8],eax    ; Replace new long value parameter

ThunkNotSpecial:
        ;      
        ; change the return address to point to completion routine
        ;
        mov     [esp+RetAddrSave],_ApiMonThunkComplete

if TRACE
        ;
        ; trace the call
        ;
        mov     eax,[ebp+ApiInfoFrm]
        mov     eax,[eax+ApiInfoAddressOffset]
        push    eax
        push    offset FLAT:Msg1
        call    _dprintf
        add     esp,8
endif

        ;
        ; check to see if api counting is enabled
        ; if not then bypass the counting code
        ;
        mov     eax,[ebp+DllInfoFrm]
        mov     eax,[eax+DllEnabledOffset]
        or      eax, eax
        jz      ThunkBypass

        ;
        ; increment the api's counters
        ;
        mov     eax,[ebp+ApiInfoFrm]
        inc     dword ptr [eax+ApiInfoCountOffset]
        inc     dword ptr [eax+ApiInfoNestCountOffset]

        ;
        ; increment the global api counter
        ;
        mov     eax,_ApiCounter
        inc     dword ptr [eax]

ThunkBypass:

        ;
        ; Replace ApiInfo pointer with ApiAddr (+bias)
        ;
        mov     ebx,[ebp+ApiInfoFrm]
        mov     eax,dword ptr [ebx+ApiInfoAddressOffset]
        mov     ecx,[ebp+ApiBiasFrm]
        add     eax,ecx
        mov     [esp+ApiInfoSave],eax

        ;
        ; start the function timer here
        ;
        GET_PERFORMANCE_COUNTER FuncTimeFrm

        ;
        ; reset the last error value (already on stack)
        ;
        call    _pSetLastError

        ;
        ; restore the registers
        ;
        pop     edi
        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax

        add     sp,8        ; dump ApiFlag & DllInfo from stack
        ret                 ; jump to Api 

stdENDP _ApiMonThunk


;
; Routine Description:
;
;     This function is called when an application
;     is compiled with -Gh.  It performs the same
;     function as ApiMonThunk does for non-instrumented
;     code.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
align           dword
public          __penter
__penter        proc

        ;
        ; allot space on stack for two api thunk parameters
        ; the third will replace the return address
        ;
        sub     sp,8

        ;
        ; save regs
        ;
        push    eax
        push    ebx
        push    ecx
        push    edx
        push    esi
        push    edi

        ;
        ; save the last error value
        ;
        call    _pGetLastError
        push    eax

        ;
        ; get the parallel stack pointer
        ;
        push    _TlsStack
        call    _pTlsGetValue
        or      eax,eax
        jnz     Good_Stack

        ;
        ; reset the last error value
        ;
        call    _pSetLastError

        ;
        ; restore the stack
        ;
        pop     edi
        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax

        add     sp,8

        ;
        ; jump to the real api
        ;
        ret

Good_Stack:
        ;
        ; setup the frame pointer
        ;
        mov     edx,[eax]
        mov     [edx],ebp
        mov     ebp,edx

        ;
        ; create a frame on the stack
        ;
        add     edx,FrameSize
        mov     [eax],edx

        ;
        ; get Api info from the return address, which is really
        ; the address of the function that is being profiled
        ;
        mov     eax,[esp+ApiInfoSave]   ; this is really the return to the Api
        mov     [ebp+RetAddrFrm],eax    ; save for exit in case Api not found
        lea     ecx,[esp+ApiFlagSave]
        push    eax
        push    ecx
        add     ecx,4
        push    ecx
        add     ecx,4
        push    ecx
        call    _GetApiInfo@16

        or      eax,eax
        jz      Api_NotFound

        mov     [ebp+ApiBiasFrm],5
        jmp     Thunk_Middle

Api_NotFound:

        ;
        ; put back saved return address
        ;
        mov     eax,[ebp+RetAddrFrm]
        mov     [esp+ApiInfoSave],eax

        ;
        ; tear down this frame
        ;
        push    _TlsStack
        call    _pTlsGetValue
        mov     [eax],ebp
        ;
        ; reset the last error value (already on the stack)
        ;
        call    _pSetLastError

        ;
        ; restore the registers
        ;
        pop     edi
        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
        mov     ebp,[ebp]

        ;
        ; discard unused api thunk space
        ;
        add     esp,8

        ;
        ; jump to the real api
        ;
        ret

__penter        endp


_TEXT   ENDS
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\apimon.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apimon.cpp

Abstract:

    Main entrypoint code for APIMON.

Author:

    Wesley Witt (wesw) July-11-1993

Environment:

    User Mode

--*/

#include "apimonp.h"
#include "alias.h"
#pragma hdrstop

extern HWND                 hwndDlg;
extern DWORD                BaseTime;
extern DWORD                StartingTick;
extern DWORD                EndingTick;
extern SYSTEMTIME           StartingLocalTime;
extern API_MASTER_TABLE     ApiTables[];

HANDLE                      ReleaseDebugeeEvent;
HANDLE                      hMap;
HANDLE                      ApiTraceMutex;
HANDLE                      ApiMemMutex;
PVOID                       MemPtr;
PTRACE_BUFFER               TraceBuffer;
ULONG                       TraceBufSize = MAX_MEM_ALLOC;
LPSTR                       CmdParamBuffer;
PDLL_INFO                   DllList;
HANDLE                      ApiMonMutex;
DWORDLONG                   PerfFreq;
OPTIONS                     ApiMonOptions;
DWORD                       UiRefreshRate = 1000;
BOOL                        BreakInNow;
BOOL                        StopOnFirstChance;
BOOL                        CallTreeTrace;
BOOL                        PatchWndProcs;
HMODULE                     hModulePsApi;
INITIALIZEPROCESSFORWSWATCH pInitializeProcessForWsWatch;
RECORDPROCESSINFO           pRecordProcessInfo;
GETWSCHANGES                pGetWsChanges;
CHAR                        KnownApis[2048];
FILE                        *fThunkLog;
double                      MSecConv;


#define MAX_SYMNAME_SIZE  1024
CHAR symBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL sym = (PIMAGEHLP_SYMBOL) symBuffer;


extern "C" {
    LPDWORD                 ApiCounter;
    LPDWORD                 ApiTraceEnabled;
    LPDWORD                 ApiTimingEnabled;
    LPDWORD                 FastCounterAvail;
    LPDWORD                 ApiOffset;
    LPDWORD                 ApiStrings;
    LPDWORD                 ApiCount;
    LPDWORD                 WndProcEnabled;
    LPDWORD                 WndProcCount;
    LPDWORD                 WndProcOffset;
    BOOL                    RunningOnNT;
}

INT_PTR CALLBACK
HelpDialogProc(
    HWND    hdlg,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    if (uMessage == WM_INITDIALOG) {
        CenterWindow( hdlg, NULL );
    }
    if (uMessage == WM_COMMAND) {
        EndDialog( hdlg, 0 );
    }
    return FALSE;
}

int
WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nShowCmd
    )
{
    CHAR            ProgName[MAX_PATH];
    CHAR            Arguments[MAX_PATH*2];
    DWORD           i;
    LPSTR           pchApi;
    OSVERSIONINFO   OsVersionInfo;


    //
    // see if we are running on NT
    // this is necessary because APIMON implements some
    // features that are NOT available on WIN95
    //
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);
    GetVersionEx( &OsVersionInfo );
    RunningOnNT = OsVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT;

    sym->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
    sym->MaxNameLength = MAX_SYMNAME_SIZE;

    //
    // jack up our priority class
    //
    SetPriorityClass(
        GetCurrentProcess(),
        HIGH_PRIORITY_CLASS
        );

    //
    // process the command line
    //
    LPSTR p = NULL;
    DWORD GoImmediate = 0;
    ProgName[0] = 0;
    Arguments[0] = 0;
    // skip any white space
    //
    while( *lpCmdLine && *lpCmdLine == ' ' ) {
        lpCmdLine += 1;
    }
    //
    // get the command line options
    //
    while( *lpCmdLine && (*lpCmdLine == '-' || *lpCmdLine == '/') ) {
        lpCmdLine += 1;
        CHAR ch = (CHAR)tolower(*lpCmdLine);
        lpCmdLine += 1;
        switch( ch ) {

            case 'a':
                // Find the end of KnownApis multistring
                // (2nd zero of terminating double zero)
                pchApi = KnownApis;
                if (*pchApi) {
                    while (*pchApi++ || *pchApi);
                }

                do {
                    ch = *lpCmdLine++;
                } while (ch == ' ' || ch == '\t');


                while (ch != ' ' && ch != '\t' && ch != 0) {
                    *pchApi++ = ch;
                    ch = *lpCmdLine++;
                }
                *pchApi++ = 0;
                *pchApi = 0;

                break;

            case 'b':
                BreakInNow = TRUE;
                break;

            case 'c':
                CallTreeTrace = TRUE;
                break;

            case 'g':
                GoImmediate = TRUE;
                break;


            case 'f':
                StopOnFirstChance = TRUE;
                break;

            case 'm':
                do {
                    ch = *lpCmdLine++;
                } while (ch == ' ' || ch == '\t');
                i=0;
                while (ch >= '0' && ch <= '9') {
                    i = i * 10 + ch - '0';
                    ch = *lpCmdLine++;
                }
                TraceBufSize = i * 1024 * 1024;
                break;

            case 't':
                do {
                    ch = *lpCmdLine++;
                } while (ch == ' ' || ch == '\t');
                i=0;
                while (ch >= '0' && ch <= '9') {
                    i = i * 10 + ch - '0';
                    ch = *lpCmdLine++;
                }
                UiRefreshRate = i;
                break;

            case 'w':
                PatchWndProcs = TRUE;
                break;

            case '?':
                DialogBox( hInstance, MAKEINTRESOURCE( IDD_HELP ), NULL, HelpDialogProc );
                ExitProcess(0);
                break;

            default:
                printf( "unknown option\n" );
                return 1;
        }
        while( *lpCmdLine == ' ' ) {
            lpCmdLine += 1;
        }
    }

    if (*lpCmdLine) {
        //
        // skip any white space
        //
        while( *lpCmdLine && *lpCmdLine == ' ' ) {
            lpCmdLine += 1;
        }
        //
        // get the program name
        //
        p = ProgName;
        while( *lpCmdLine && *lpCmdLine != ' ' ) {
            *p++ = *lpCmdLine;
            lpCmdLine += 1;
        }
        *p = 0;
        if (*lpCmdLine) {
            //
            // skip any white space
            //
            while( *lpCmdLine && *lpCmdLine == ' ' ) {
                lpCmdLine += 1;
            }
            if (*lpCmdLine) {
                //
                // get the program arguments
                //
                p = Arguments;
                while( *lpCmdLine ) {
                    *p++ = *lpCmdLine;
                    lpCmdLine += 1;
                }
                *p = 0;
            }
        }
    }

    ReleaseDebugeeEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (!ReleaseDebugeeEvent) {
        Fail(ERR_RESOURCE);
        return FALSE;
    }

    ApiMonMutex = CreateMutex( NULL, FALSE, "ApiMonMutex" );
    if (!ApiMonMutex) {
        Fail(ERR_RESOURCE);
        return FALSE;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        Fail(ERR_RESOURCE);
        return FALSE;
    }

    ApiMemMutex = CreateMutex( NULL, FALSE, "ApiMemMutex" );
    if (!ApiMemMutex) {
        Fail(ERR_RESOURCE);
        return FALSE;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        Fail(ERR_RESOURCE);
        return FALSE;
    }

    //
    // create the shared memory region for the api counters
    //
    hMap = CreateFileMapping(
        INVALID_HANDLE_VALUE,
        NULL,
        PAGE_READWRITE | SEC_COMMIT,
        0,
        MAX_MEM_ALLOC,
        "ApiWatch"
        );
    if (!hMap) {
        Fail(ERR_PAGEFILE);
        return FALSE;
    }

    MemPtr = (PUCHAR)MapViewOfFile(
        hMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (!MemPtr) {
        Fail(ERR_PAGEFILE);
        return FALSE;
    }

    ApiCounter       = (LPDWORD)   MemPtr + 0;
    ApiTraceEnabled  = (LPDWORD)   MemPtr + 1;
    ApiTimingEnabled = (LPDWORD)   MemPtr + 2;
    FastCounterAvail = (LPDWORD)   MemPtr + 3;
    ApiOffset        = (LPDWORD)   MemPtr + 4;
    ApiStrings       = (LPDWORD)   MemPtr + 5;
    ApiCount         = (LPDWORD)   MemPtr + 6;
    WndProcEnabled   = (LPDWORD)   MemPtr + 7;
    WndProcCount     = (LPDWORD)   MemPtr + 8;
    WndProcOffset    = (LPDWORD)   MemPtr + 9;
    DllList          = (PDLL_INFO) ((LPDWORD)MemPtr + 10);

    *ApiOffset       = (MAX_DLLS * sizeof(DLL_INFO));
    *WndProcOffset   = (MAX_APIS * sizeof(API_INFO)) + *ApiOffset;
    *ApiStrings      = (DWORD)(*WndProcOffset + ((ULONG_PTR)DllList - (ULONG_PTR)MemPtr));
    *WndProcEnabled  = PatchWndProcs;

    //
    // create the shared memory region for the api trace buffer
    //
    hMap = CreateFileMapping(
        INVALID_HANDLE_VALUE,
        NULL,
        PAGE_READWRITE | SEC_COMMIT,
        0,
        TraceBufSize,
        "ApiTrace"
        );
    if (!hMap) {
        Fail(ERR_PAGEFILE);
        return FALSE;
    }

    TraceBuffer = (PTRACE_BUFFER)MapViewOfFile(
        hMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (!TraceBuffer) {
        Fail(ERR_PAGEFILE);
        return FALSE;
    }

    TraceBuffer->Size = TraceBufSize - sizeof(TRACE_BUFFER);
    TraceBuffer->Offset = 0;
    TraceBuffer->Count = 0;

    ApiTraceMutex = CreateMutex( NULL, FALSE, "ApiTraceMutex" );
    if (!ApiTraceMutex) {
        Fail(ERR_RESOURCE);
        return FALSE;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        Fail(ERR_RESOURCE);
        return FALSE;
    }

    //
    // create the shared memory region for remote commands
    //
    hMap = CreateFileMapping(
         INVALID_HANDLE_VALUE,
         NULL,
         PAGE_READWRITE | SEC_COMMIT,
         0,
         CMD_PARAM_BUFFER_SIZE,
         CMD_PARAM_BUFFER_NAME
         );
    if (!hMap) {
        Fail(ERR_PAGEFILE);
        return FALSE;
    }

    CmdParamBuffer = (LPSTR)MapViewOfFile(
        hMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );

    if (!CmdParamBuffer) {
        Fail(ERR_RESOURCE);
        return FALSE;
    }

    InitCommonControls();

    QueryPerformanceFrequency( (LARGE_INTEGER*)&PerfFreq );
    MSecConv = 1000.0 / (double)(LONGLONG)PerfFreq;

    hModulePsApi = LoadLibrary( "psapi.dll" );
    if (hModulePsApi) {
        pInitializeProcessForWsWatch = (INITIALIZEPROCESSFORWSWATCH) GetProcAddress(
            hModulePsApi,
            "InitializeProcessForWsWatch"
            );
        pRecordProcessInfo = (RECORDPROCESSINFO) GetProcAddress(
            hModulePsApi,
            "RecordProcessInfo"
            );
        pGetWsChanges = (GETWSCHANGES) GetProcAddress(
            hModulePsApi,
            "GetWsChanges"
            );
    } else {
        PopUpMsg( "Page fault profiling is not available.\nPSAPI.DLL is missing." );
    }

#if CREATE_THUNK_LOG
    fThunkLog = fopen( "thunk.log", "w" );
    if (!fThunkLog) {
        PopUpMsg( "Could not open thunk log file" );
        return FALSE;
    }
#endif //CREATE_THUNK_LOG

    WinApp(
        hInstance,
        nShowCmd,
        ProgName,
        Arguments,
        GoImmediate
        );

    if (ProgName[0]) {
        SaveOptions();
    }

#if CREATE_THUNK_LOG
    fclose(fThunkLog);
#endif //CREATE_THUNK_LOG

    return 0;
}

VOID
PrintLogTimes(
    FILE *fout
    )
{
    DWORD EndTime = EndingTick ? EndingTick : GetTickCount();
    SYSTEMTIME EndingLocalTime;

    GetLocalTime( &EndingLocalTime );
    fprintf( fout, "Starting Time: %02d:%02d:%02d.%03d\n",
        StartingLocalTime.wHour,
        StartingLocalTime.wMinute,
        StartingLocalTime.wSecond,
        StartingLocalTime.wMilliseconds
        );
    fprintf( fout, "Ending Time:   %02d:%02d:%02d.%03d\n",
        EndingLocalTime.wHour,
        EndingLocalTime.wMinute,
        EndingLocalTime.wSecond,
        EndingLocalTime.wMilliseconds
        );
    DWORD ElapsedTime         = EndTime - StartingTick;
    DWORD ElapsedHours        = ElapsedTime / (1000 * 60 * 60);
    ElapsedTime               = ElapsedTime % (1000 * 60 * 60);
    DWORD ElapsedMinutes      = ElapsedTime / (1000 * 60);
    ElapsedTime               = ElapsedTime % (1000 * 60);
    DWORD ElapsedSeconds      = ElapsedTime / 1000;
    DWORD ElapsedMilliseconds = ElapsedTime % 1000;
    fprintf(
        fout, "Elapsed Time:  %02d:%02d:%02d.%03d\n",
        ElapsedHours,
        ElapsedMinutes,
        ElapsedSeconds,
        ElapsedMilliseconds
        );
    fprintf( fout, "\n" );
}


void PrintLogType(FILE *fout, CAliasTable *pals, ULONG ulType, ULONG_PTR ulHandle, PUCHAR *pp)
{
    char szAlias[kcchAliasNameMax];
    ULONG len;

    switch(ulType) {
    case T_LPSTR:
        __try {
            len = strlen((LPSTR) *pp);
            if (len != 0) {
                fprintf( fout, "%10.10s ", *pp );
            } else {
                fprintf( fout, "%10.10s ", "NULL");
            }
            *pp += Align (sizeof(WCHAR), (len + 1));
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            fprintf( fout, "%10.10s ", "***GPF***");
            return;
        }
        break;
    case T_LPWSTR:
        __try {
            len = wcslen((LPWSTR) *pp );
            if (len != 0) {
                fprintf( fout, "%10.10ws ", (LPWSTR)*pp );
            } else {
                fprintf( fout, "%10.10s ", "NULL");
            }
            *pp += (len + 1) * sizeof(WCHAR);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            fprintf( fout, "%10.10s ", "***GPF***");
            return;
        }
        break;
    case T_HACCEL:
    case T_HANDLE:
    case T_HBITMAP:
    case T_HBRUSH:
    case T_HCURSOR:
    case T_HDC:
    case T_HDCLPPOINT:
    case T_HDESK:
    case T_HDWP:
    case T_HENHMETAFILE:
    case T_HFONT:
    case T_HGDIOBJ:
    case T_HGLOBAL:
    case T_HGLRC:
    case T_HHOOK:
    case T_HICON:
    case T_HINSTANCE:
    case T_HKL:
    case T_HMENU:
    case T_HMETAFILE:
    case T_HPALETTE:
    case T_HPEN:
    case T_HRGN:
    case T_HWINSTA:
    case T_HWND:
        pals->Alias(ulType, ulHandle, szAlias);
        fprintf( fout, "%10.10s ", szAlias);
        break;
    case T_DWORD:
    case T_DWORDPTR:
    case T_DLONGPTR:
        fprintf( fout, "0x%08x ", ulHandle);
        break;
    }
}

BOOL
LogApiCounts(
    PCHAR  FileName
    )
{
    FILE *fout;
    ULONG i,j,k,len;
    LPSTR Name;
    DWORDLONG Time;
    double NewTime;
    double NewCalleeTime;
    CHAR LogFileName[MAX_PATH];
    PTRACE_ENTRY TraceEntry;
    PAPI_INFO ApiInfo;
    PDLL_INFO DllInfo;
    PAPI_MASTER_TABLE ApiMaster;
    PAPI_TABLE ApiTable;
    PUCHAR p;

    ExpandEnvironmentStrings(
        FileName,
        LogFileName,
        MAX_PATH
        );
    fout = fopen( LogFileName, "w" );
    if (!fout) {
        PopUpMsg( "Could not open log file" );
        return FALSE;
    }

    fprintf( fout, "-------------------------------------------\n" );
    fprintf( fout, "-API Monitor Report\n" );
    fprintf( fout, "-\n" );
    if (*FastCounterAvail) {
        fprintf( fout, "-Times are in raw processor clock cycles\n" );
    } else {
        fprintf( fout, "-Times are in milliseconds\n" );
    }
    fprintf( fout, "-\n" );
    fprintf( fout, "-------------------------------------------\n" );
    fprintf( fout, "\n" );

    PrintLogTimes( fout );

    for (i=0; i<MAX_DLLS; i++) {
        DllInfo = &DllList[i];
        if (!DllInfo->BaseAddress) {
            break;
        }
        ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (ULONG_PTR)DllList);
        if (!DllList[i].ApiCount) {
            continue;
        }
#if DEBUG_DUMP
        k = DllList[i].ApiCount;
        fprintf( fout, "---------------------------------------------------------------\n" );
        fprintf( fout, "%s\n", DllInfo->Name );
        fprintf( fout, "---------------------------------------------------------------\n" );
        fprintf( fout, "       Address  ThunkAddr    Count             Time   Name\n" );
        fprintf( fout, "---------------------------------------------------------------\n" );
#else
        ULONG_PTR *ApiAry = NULL;
        ApiInfo = (PAPI_INFO)(DllList[i].ApiOffset + (PUCHAR)DllList);
        for (j=0,k=0; j<DllList[i].ApiCount; j++) {
            if (ApiInfo[j].Count) {
                k += 1;
            }
        }
        if (!k) {
            continue;
        }
        ApiAry = (ULONG_PTR *) MemAlloc( (k+64) * sizeof(ULONG_PTR) );
        if (!ApiAry) {
            continue;
        }
        for (j=0,k=0; j<DllList[i].ApiCount; j++) {
            if (ApiInfo[j].Count) {
                ApiAry[k++] = (ULONG_PTR)&ApiInfo[j];
            }
        }
        fprintf( fout, "-----------------------------------------------------------\n" );

        if (DllInfo->LoadCount > 1)
            fprintf( fout, "%s (Loaded %d times)\n", DllInfo->Name, DllInfo->LoadCount);
        else
            fprintf( fout, "%s\n", DllInfo->Name );

        fprintf( fout, "-----------------------------------------------------------\n" );
        fprintf( fout, "         Count              Time    Time - Callees   Name\n" );
        fprintf( fout, "-----------------------------------------------------------\n" );


#endif
        for (j=0; j<k; j++) {
#if DEBUG_DUMP
            PAPI_INFO ApiData = &ApiInfo[j];
#else
            PAPI_INFO ApiData = (PAPI_INFO)ApiAry[j];
#endif
            Name = (LPSTR)(ApiData->Name + (LPSTR)MemPtr);
            NewTime = (double)(LONGLONG)ApiData->Time;
            NewCalleeTime = (double)(LONGLONG)ApiData->CalleeTime;

            if (!*FastCounterAvail) {
                NewTime = NewTime * MSecConv;
                NewCalleeTime = NewCalleeTime * MSecConv;
            }

#if DEBUG_DUMP
            fprintf(
                fout,
                "      %08x   %08x %8d %16.4f   %s\n",
                ApiData->Address,
                ApiData->ThunkAddress,
                ApiData->Count,
                NewTime,
                Name
                );
#else
            fprintf(
                fout,
                "      %8d %16.4f %16.4f   %s",
                ApiData->Count,
                NewTime,
                NewTime - NewCalleeTime,
                Name
                );

            if (ApiData->NestCount != 0)
                fprintf(fout,"*\n");
            else
                fprintf(fout,"\n");
#endif
        }
#ifndef DEBUG_DUMP
        MemFree( ApiAry );
#endif
    }

    if (*WndProcCount) {

        fprintf( fout, "---------------------------------------------------------------\n" );
        fprintf( fout, "Window Procedures\n");
        fprintf( fout, "---------------------------------------------------------------\n" );
        fprintf( fout, "         Count              Time    Time - Callees   Class Name\n" );
        fprintf( fout, "---------------------------------------------------------------\n" );


        ApiInfo = (PAPI_INFO)(*WndProcOffset + (ULONG_PTR)DllList);
        for (i=0; i<*WndProcCount; i++,ApiInfo++) {

            if (ApiInfo->Count != 0) {
                Name = (LPSTR)(ApiInfo->Name + (LPSTR)MemPtr);

                NewTime = (double)(LONGLONG) ApiInfo->Time;
                NewCalleeTime = (double)(LONGLONG) ApiInfo->CalleeTime;

                if (!*FastCounterAvail) {
                    NewTime = NewTime * MSecConv;
                    NewCalleeTime = NewCalleeTime * MSecConv;
                }

                fprintf(
                    fout,
                    "      %8d %16.4f %16.4f   %s",
                    ApiInfo->Count,
                    NewTime,
                    NewTime - NewCalleeTime,
                    Name
                    );

                if (ApiInfo->NestCount != 0)
                    fprintf(fout,"*\n");
                else
                    fprintf(fout,"\n");
            }
        }
    }

    fclose( fout );
    return TRUE;
}


BOOL
LogApiTrace(
    PCHAR  FileName
    )
{
    FILE *fout;
    ULONG i,j,k,len, ArgCount;
    LPSTR Name;
    DWORDLONG Time;
    DWORDLONG _BaseTime;
    double EnterTime;
    double Duration;
    CHAR LogFileName[MAX_PATH];
    PTRACE_ENTRY TraceEntry;
    PAPI_INFO ApiInfo;
    PDLL_INFO DllInfo;
    PDLL_INFO CallerDllInfo;
    LPSTR     DllName;
    PAPI_MASTER_TABLE ApiMaster;
    PAPI_TABLE ApiTable;
    PUCHAR p;

    ExpandEnvironmentStrings(
        FileName,
        LogFileName,
        MAX_PATH
        );
    fout = fopen( LogFileName, "w" );
    if (!fout) {
        PopUpMsg( "Could not open trace file" );
        return FALSE;
    }

    WaitForSingleObject( ApiTraceMutex, INFINITE );

    if (ApiMonOptions.Aliasing) {
        fprintf(
            fout,
            "LastError  ReturnVal  Name\n"
            );
    }
    else {
        fprintf(
            fout,
            "Thd Lev    Start Time        Duration      ReturnVal  LastError           Caller           Name       Arguments\n"
        );
    }

    CAliasTable als;

    TraceEntry = TraceBuffer->Entry;
    _BaseTime = TraceEntry->EnterTime;

    for (i=0; i<TraceBuffer->Count; i++) {
        ApiInfo = GetApiInfoByAddress( TraceEntry->Address, &DllInfo );

        if (ApiInfo) {
            EnterTime = (double)(LONGLONG)(TraceEntry->EnterTime - _BaseTime);
            Duration = (double)(LONGLONG)TraceEntry->Duration;

            if (!*FastCounterAvail) {
                EnterTime = EnterTime * MSecConv;
                Duration = Duration * MSecConv;
            }

            CallerDllInfo = GetModuleForAddr(TraceEntry->Caller);
            if (CallerDllInfo)
                DllName = CallerDllInfo->Name;
            else
                DllName = "???";

            ApiTable = NULL;
            if (TraceEntry->ApiTableIndex) {
                p = (PUCHAR) ((PUCHAR)TraceEntry + sizeof(TRACE_ENTRY));
                j = 0;
                while( ApiTables[j].Name ) {
                    if (_stricmp( ApiTables[j].Name, DllInfo->Name ) == 0) {
                        ApiTable = &ApiTables[j].ApiTable[TraceEntry->ApiTableIndex-1];
                        break;
                    }
                    j += 1;
                }
            }

            if (ApiMonOptions.Aliasing) {
                if (ApiTable) {
                    p = (PUCHAR) ((PUCHAR)TraceEntry + sizeof(TRACE_ENTRY));
                    fprintf( fout, "0x%08x ", TraceEntry->LastError);
                    PrintLogType(fout, &als, ApiTable->RetType, TraceEntry->ReturnValue, &p);
                    fprintf( fout, "%-25.25s ", (LPSTR)(ApiInfo->Name + (LPSTR)MemPtr));
                    for (k=0; k<ApiTable->ArgCount; k++) {
                        PrintLogType(fout, &als, LOWORD(ApiTable->ArgType[k]), TraceEntry->Args[k], &p);
                    }
                    fprintf( fout, "\n");
                }
            }
            else {
                fprintf(
                    fout,
                    "%3d %3d %16.4f %16.4f 0x%08x 0x%08x %-12s 0x%08x %-24s",
                    TraceEntry->ThreadNum,
                    TraceEntry->Level,
                    EnterTime,
                    Duration,
                    TraceEntry->ReturnValue,
                    TraceEntry->LastError,
                    DllName,
                    TraceEntry->Caller,
                    (LPSTR)(ApiInfo->Name + (LPSTR)MemPtr));

                ArgCount = (ApiTable && ApiTable->ArgCount) ? ApiTable->ArgCount : DFLT_TRACE_ARGS;
                for (k=0; k<ArgCount; k++)
                    fprintf(fout, " 0x%08x",TraceEntry->Args[k]);

                fprintf(fout, "\n");

                if (ApiTable) {
                    for (k=0; k<ApiTable->ArgCount; k++) {
                        switch( LOWORD(ApiTable->ArgType[k]) ) {

                            case T_LPSTR:
                            case T_LPSTRC:
                                fprintf( fout, "%s\n", p );
                                len = strlen( (LPSTR) p ) + 1;
                                len = Align( sizeof(WCHAR), len );
                                p += len;
                                break;

                            case T_LPWSTR:
                            case T_LPWSTRC:
                            case T_UNISTR:
                            case T_OBJNAME:
                                fwprintf( fout, L"%s\n", (LPWSTR)p );
                                len = (wcslen( (LPWSTR) p ) + 1) * sizeof(WCHAR);
                                p += len;
                                break;
                        }
                    }
                }
            }

            TraceEntry = (PTRACE_ENTRY) ((PUCHAR)TraceEntry + TraceEntry->SizeOfStruct);
        }
    }

    ReleaseMutex( ApiTraceMutex );

    fclose( fout );

    return TRUE;
}

PDLL_INFO
GetDllInfoByName(
    LPSTR DllName
    )
{
    ULONG i;


    if (!DllName) {
        return NULL;
    }

    for (i=0; i<MAX_DLLS; i++) {
        PDLL_INFO DllInfo = &DllList[i];
        if (!DllInfo->BaseAddress) {
            break;
        }
        if (_stricmp(DllName, DllInfo->Name) == 0) {
            return DllInfo;
        }
    }

    return NULL;
}


PAPI_INFO
GetApiInfoByAddress(
    ULONG_PTR   Address,
    PDLL_INFO   *DllInfo
    )
{
    ULONG     i;
    PAPI_INFO ApiInfo;
    LONG      High;
    LONG      Low;
    LONG      Middle;


    for (i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress &&
            Address >= DllList[i].BaseAddress &&
            Address < DllList[i].BaseAddress + DllList[i].Size) {
                //
                // find the api in the dll
                //
                ApiInfo = (PAPI_INFO)(DllList[i].ApiOffset + (PUCHAR)DllList);

                Low = 0;
                High = DllList[i].ApiCount - 1;

                while (High >= Low) {
                    Middle = (Low + High) >> 1;
                    if (Address < ApiInfo[Middle].Address) {

                        High = Middle - 1;

                    } else if (Address > ApiInfo[Middle].Address) {

                        Low = Middle + 1;

                    } else {

                        *DllInfo = &DllList[i];
                        return &ApiInfo[Middle];

                    }
                }
        }
    }
    return NULL;
}


VOID
SetApiCounterEnabledFlag(
    BOOL  Flag,
    LPSTR DllName
    )
{
    ULONG i;

    if (DllName) {
        PDLL_INFO DllInfo = GetDllInfoByName( DllName );
        if (DllInfo) {
            DllInfo->Enabled = Flag;
        }
        return;
    }

    for (i=0; i<MAX_DLLS; i++) {
        PDLL_INFO DllInfo = &DllList[i];
        if (!DllInfo->BaseAddress) {
            break;
        }
        DllInfo->Enabled = Flag;
    }
}

VOID
ClearApiCounters(
    VOID
    )
{
    ULONG i,j;

    *ApiCounter = 0;

    PAPI_INFO ApiInfo;
    for (i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress) {
            ApiInfo = (PAPI_INFO)(DllList[i].ApiOffset + (PUCHAR)DllList);
            for (j=0; j<DllList[i].ApiCount; j++) {
                ApiInfo[j].Count      = 0;
                ApiInfo[j].Time       = 0;
                ApiInfo[j].CalleeTime = 0;
                ApiInfo[j].HardFault  = 0;
                ApiInfo[j].SoftFault  = 0;
                ApiInfo[j].CodeFault  = 0;
                ApiInfo[j].DataFault  = 0;
            }
        }
    }

    ApiInfo = (PAPI_INFO)(*WndProcOffset + (PUCHAR)DllList);
    for (i=0; i<*WndProcCount; i++) {
        ApiInfo[i].Count      = 0;
        ApiInfo[i].Time       = 0;
        ApiInfo[i].CalleeTime = 0;
        ApiInfo[i].HardFault  = 0;
        ApiInfo[i].SoftFault  = 0;
        ApiInfo[i].CodeFault  = 0;
        ApiInfo[i].DataFault  = 0;
    }

    StartingTick = GetTickCount();
    GetLocalTime(&StartingLocalTime);
}

VOID
ClearApiTrace(
    VOID
    )
{
    WaitForSingleObject( ApiTraceMutex, INFINITE );
    TraceBuffer->Offset = 0;
    TraceBuffer->Count = 0;
    ReleaseMutex(ApiTraceMutex);
}

void
__cdecl
dprintf(char *format, ...)
{
    char    buf[1024];
    va_list arg_ptr;
    va_start(arg_ptr, format);
    _vsnprintf(buf, sizeof(buf), format, arg_ptr);
    OutputDebugString( buf );
    return;
}

LPVOID
MemAlloc(
    ULONG Size
    )
{
    PVOID _MemPtr = malloc( Size );
    if (_MemPtr) {
        ZeroMemory( _MemPtr, Size );
    }
    return _MemPtr;
}

VOID
MemFree(
    LPVOID _MemPtr
    )
{
    free( _MemPtr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\alias.h ===
/****************************** Module Header ******************************\
* Module Name: alias.h
*
* Declarations necessary for ApiMon aliasing.
*
* History:
* 06-11-96 vadimg         created
\***************************************************************************/

#ifndef __ALIAS_H__
#define __ALIAS_H__

const ULONG kcchAliasNameMax = 20;
const ULONG kulTableSize = 257;

class CAliasNode;  /* forward declaration */

class CAliasNode {  /* anod -- node in the hash table */
public:
    CAliasNode();
    CAliasNode(ULONG_PTR ulHandle, long nAlias);

    ULONG_PTR m_ulHandle;  /* handle type */
    long m_nAlias;  /* alias value */

    CAliasNode *m_panodNext;
};

class CAliasTable {  /* als -- open hash table */
public:
    CAliasTable();
    ~CAliasTable();

    void Alias(ULONG ulType, ULONG_PTR ulHandle, char szAlias[]);

private:
    long Lookup(ULONG_PTR ulHandle);
    long Insert(ULONG_PTR ulHandle);

    static ULONG s_ulAlias;
    CAliasNode* m_rgpanod[kulTableSize];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\apimonp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apimonp.h

Abstract:

    Common header file for APIMON data structures.

Author:

    Wesley Witt (wesw) 12-July-1995

Environment:

    User Mode

--*/

#include <windows.h>
#include <windowsx.h>
#include <dbghelp.h>
#include <commctrl.h>
#include <commdlg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <crt\io.h>
#include <fcntl.h>
#include <psapi.h>
#include "resource.h"
#include "apimon.h"
#include "apictrl.h"

#if defined(_M_IX86)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_I386
#elif defined(_M_ALPHA)
#define MACHINE_TYPE  IMAGE_FILE_MACHINE_ALPHA
#else
#error( "unknown target machine" );
#endif

#define LVIS_GCNOCHECK              0x1000
#define LVIS_GCCHECK                0x2000

#define SKIP_NONWHITE(p)                while( *p && *p != ' ') p++
#define SKIP_WHITE(p)                   while( *p && *p == ' ') p++

#define DISBUF_SIZE                     256
#define MAX_LINES                       20
#define BYTES_INSTR                     16
#define CODE_SIZE                       (MAX_LINES*BYTES_INSTR)

#define MAX_BREAKPOINTS                 256
#undef PAGE_ALIGN
#define PAGE_ALIGN(Va)                  ((ULONG_PTR)((ULONG_PTR)(Va) & ~(PAGE_SIZE - 1)))

#define WM_TROJAN_COMPLETE              (WM_USER + 100)
#define WM_UPDATE_COUNTERS              (WM_USER + 101)
#define WM_INIT_PROGRAM                 (WM_USER + 102)
#define WM_REFRESH_LIST                 (WM_USER + 103)
#define WM_UPDATE_PAGE                  (WM_USER + 104)
#define WM_CREATE_GRAPH                 (WM_USER + 105)
#define WM_POPUP_TEXT                   (WM_USER + 106)
#define WM_FONT_CHANGE                  (WM_USER + 107)
#define WM_COLOR_CHANGE                 (WM_USER + 108)
#define WM_TOGGLE_LEGEND                (WM_USER + 109)


#define UBLACK                          RGB(000, 000, 000)
#define DARK_RED                        RGB(128, 000, 000)
#define DARK_GREEN                      RGB(000, 128, 000)
#define DARK_YELLOW                     RGB(128, 128, 000)
#define DARK_BLUE                       RGB(000, 000, 128)
#define DARK_MAGENTA                    RGB(128, 000, 128)
#define DARK_CYAN                       RGB(000, 128, 128)
#define DARK_GRAY                       RGB(128, 128, 128)
#define LIGHT_GRAY                      RGB(192, 192, 192)
#define LIGHT_RED                       RGB(255, 000, 000)
#define LIGHT_GREEN                     RGB(000, 255, 000)
#define LIGHT_YELLOW                    RGB(255, 255, 000)
#define LIGHT_BLUE                      RGB(000, 000, 255)
#define LIGHT_MAGENTA                   RGB(255, 000, 255)
#define LIGHT_CYAN                      RGB(000, 255, 255)
#define UWHITE                          RGB(255, 255, 255)

#ifdef _M_IX86

#define BP_INSTR                        0xcc
#define BP_SIZE                         1
#define PC_REG                          Eip
#define RV_REG                          Eax
#define STK_REG                         Esp
#undef PAGE_SIZE
#define PAGE_SIZE                       4096
#define IsBreakpoint(I) (*(PUCHAR)(I) == BP_INSTR)

#elif defined(_M_ALPHA)

#include <alphaops.h>

#define BP_INSTR                        0x00000080
#define BP_SIZE                         4
#define PC_REG                          Fir
#define RV_REG                          IntV0
#define STK_REG                         IntSp
#undef PAGE_SIZE
#define PAGE_SIZE                       8192
#define IsBreakpoint(I) \
    (*(PULONG)(I) == (CALLPAL_OP | CALLKD_FUNC)) || \
    (*(PULONG)(I) == (CALLPAL_OP |    BPT_FUNC)) || \
    (*(PULONG)(I) == (CALLPAL_OP |   KBPT_FUNC))

#else

#pragma error( "unknown machine type" )

#endif

typedef enum _SORT_TYPE {
    SortByName,
    SortByCounter,
    SortByTime
} SORT_TYPE;

#define IS_ICONIC   0x00000001
#define IS_ZOOMED   0x00000002
#define IS_FOCUS    0x00000004

#define NUMBER_OF_CUSTOM_COLORS 16

#define CHILD_DLL           1
#define CHILD_COUNTER       2
#define CHILD_PAGE          3
#define CHILD_GRAPH         4

typedef struct _POSITION {
    RECT        Rect;
    ULONG       Flags;
} POSITION, *PPOSITION;

typedef struct _OPTIONS {
    CHAR        ProgName[MAX_PATH];
    CHAR        ProgDir[MAX_PATH];
    CHAR        Arguments[MAX_PATH];
    CHAR        LogFileName[MAX_PATH];
    CHAR        TraceFileName[MAX_PATH];
    CHAR        SymbolPath[MAX_PATH*10];
    CHAR        LastDir[MAX_PATH];
    DWORD       Tracing;
    DWORD       Aliasing;
    DWORD       HeapChecking;
    DWORD       PreLoadSymbols;
    DWORD       ApiCounters;
    DWORD       GoImmediate;
    DWORD       FastCounters;
    DWORD       UseKnownDlls;
    DWORD       ExcludeKnownDlls;
    DWORD       MonitorPageFaults;
    INT         GraphFilterValue;
    BOOL        DisplayLegends;
    BOOL        FilterGraphs;
    BOOL        AutoRefresh;
    SORT_TYPE   DefaultSort;
    POSITION    FramePosition;
    POSITION    DllPosition;
    POSITION    CounterPosition;
    POSITION    PagePosition;
    LOGFONT     LogFont;
    COLORREF    Color;
    COLORREF    CustColors[16];
    CHAR        KnownDlls[2048];
} OPTIONS, *POPTIONS;

typedef struct _PROCESS_INFO    *PPROCESS_INFO;
typedef struct _THREAD_INFO     *PTHREAD_INFO;
typedef struct _BREAKPOINT_INFO *PBREAKPOINT_INFO;

typedef DWORD (*PBP_HANDLER)(PPROCESS_INFO,PTHREAD_INFO,PEXCEPTION_RECORD,PBREAKPOINT_INFO);

#define BPF_UNINSTANCIATED      0x00000001
#define BPF_DISABLED            0x00000002
#define BPF_TRACE               0x00000004
#define BPF_WATCH               0x00000008

typedef struct _BREAKPOINT_INFO {
    ULONG_PTR               Address;
    ULONG                   OriginalInstr;
    ULONG                   Flags;
    ULONG                   Number;
    LPSTR                   SymName;
    PBP_HANDLER             Handler;
    PVOID                   Text;
    ULONG                   TextSize;
    CONTEXT                 Context;
    LPSTR                   Command;
    struct _BREAKPOINT_INFO *LastBp;
} BREAKPOINT_INFO, *PBREAKPOINT_INFO;

typedef struct _THREAD_INFO {
    struct _THREAD_INFO     *Next;
    HANDLE                  hProcess;
    HANDLE                  hThread;
    ULONG                   ThreadId;
} THREAD_INFO, *PTHREAD_INFO;

typedef struct _PROCESS_INFO {
    struct _PROCESS_INFO    *Next;
    HANDLE                  hProcess;
    DWORD                   ProcessId;
    BOOL                    SeenLdrBp;
    BOOL                    FirstProcess;
    DWORD_PTR               LoadAddress;
    DWORD_PTR               EntryPoint;
    DWORD_PTR               TrojanAddress;
    THREAD_INFO             ThreadInfo;
    BREAKPOINT_INFO         Breakpoints[MAX_BREAKPOINTS];
    ULONG                   UserBpCount;
    BOOL                    StaticLink;
} PROCESS_INFO, *PPROCESS_INFO;

typedef struct _SYMBOL_ENUM_CXT {
    PAPI_INFO               ApiInfo;
    PDLL_INFO               DllInfo;
    DWORD                   Cnt;
} SYMBOL_ENUM_CXT, *PSYMBOL_ENUM_CXT;

typedef struct _REG {
    char    *psz;
    ULONG   value;
} REG, *LPREG;

typedef struct _SUBREG {
    ULONG   regindex;
    ULONG   shift;
    ULONG   mask;
} SUBREG, *LPSUBREG;

typedef union _CONVERTED_DOUBLE {
    double d;
    ULONG ul[2];
    LARGE_INTEGER li;
} CONVERTED_DOUBLE, *PCONVERTED_DOUBLE;

typedef struct _TOOLBAR_STATE {
    ULONG   Id;
    BOOL    State;
    LPSTR   Msg;
} TOOLBAR_STATE, *PTOOLBAR_STATE;


//
// function pointer types for PSAPI.DLL
//
typedef BOOL  (WINAPI *INITIALIZEPROCESSFORWSWATCH)(HANDLE);
typedef BOOL  (WINAPI *RECORDPROCESSINFO)(HANDLE,ULONG);
typedef BOOL  (WINAPI *GETWSCHANGES)(HANDLE,PPSAPI_WS_WATCH_INFORMATION,DWORD);


//
// externs
//
extern PIMAGEHLP_SYMBOL sym;
extern DWORDLONG        PerfFreq;
extern double           MSecConv;
extern PDLL_INFO        DllList;
extern PVOID            MemPtr;
extern OPTIONS          ApiMonOptions;
extern BOOL             DebugeeActive;
extern HANDLE           ReleaseDebugeeEvent;
extern HANDLE           CurrProcess;
extern DWORD            UiRefreshRate;
extern HWND             hwndFrame;
extern HFONT            hFont;
extern DWORD            ChildFocus;
extern HANDLE           CurrProcess;
extern COLORREF         CustomColors[];
extern HWND             hwndMDIClient;
extern HANDLE           hProcessWs;
extern HANDLE           ApiTraceMutex;
extern PTRACE_BUFFER    TraceBuffer;
extern LPSTR            CmdParamBuffer;
extern CHAR             KnownApis[2048];

extern HMODULE                      hModulePsApi;
extern INITIALIZEPROCESSFORWSWATCH  pInitializeProcessForWsWatch;
extern RECORDPROCESSINFO            pRecordProcessInfo;
extern GETWSCHANGES                 pGetWsChanges;

#ifdef __cplusplus
extern "C" {
#endif
    extern LPDWORD      ApiCounter;
    extern LPDWORD      FastCounterAvail;
    extern LPDWORD      ApiTraceEnabled;
    extern BOOL         RunningOnNT;
#ifdef __cplusplus
}
#endif


typedef int (__cdecl *PCOMPARE_ROUTINE)(const void*,const void*);

//
// prototypes
//
BOOL
RegInitialize(
    POPTIONS o
    );

BOOL
RegSave(
    POPTIONS o
    );

void
__cdecl
dprintf(
    char *format,
    ...
    );

VOID
__cdecl
PopUpMsg(
    char *format,
    ...
    );

VOID
Fail(
    UINT Error
    );

VOID
CenterWindow(
    HWND hwnd,
    HWND hwndToCenterOver
    );

BOOL
BrowseForFileName(
    LPSTR FileName,
    LPSTR Extension,
    LPSTR FileDesc
    );

BOOL
WinApp(
    HINSTANCE   hInstance,
    INT         nShowCmd,
    LPSTR       ProgName,
    LPSTR       Arguments,
    BOOL        GoImmediate
    );

DWORD
DebuggerThread(
    LPSTR CmdLine
    );

BOOL
LogApiCounts(
    PCHAR   FileName
    );

BOOL
LogApiTrace(
    PCHAR   FileName
    );

VOID
SaveOptions(
    VOID
    );

CLINKAGE ULONG
ReadMemory(
    HANDLE  hProcess,
    PVOID   Address,
    PVOID   Buffer,
    ULONG   Length
    );

CLINKAGE BOOL
WriteMemory(
    HANDLE  hProcess,
    PVOID   Address,
    PVOID   Buffer,
    ULONG   Length
    );

CLINKAGE VOID
DisableHeapChecking(
    HANDLE  hProcess,
    PVOID   HeapHandle
    );

LPSTR
UnDname(
    LPSTR sym
    );

PDLL_INFO
GetModuleForAddr(
    ULONG_PTR Addr
    );

PAPI_INFO
GetApiForAddr(
    ULONG_PTR Addr
    );

VOID
PrintRegisters(
    VOID
    );

PPROCESS_INFO
GetProcessInfo(
    HANDLE hProcess
    );

PTHREAD_INFO
GetThreadInfo(
    HANDLE hProcess,
    HANDLE hThread
    );

PBREAKPOINT_INFO
SetBreakpoint(
    PPROCESS_INFO   ThisProcess,
    DWORD_PTR       Address,
    DWORD           Flags,
    LPSTR           SymName,
    PBP_HANDLER     Handler
    );

LPSTR
GetAddress(
    LPSTR   CmdBuf,
    DWORD_PTR *Address
    );

BOOL
InstanciateBreakpoint(
    PPROCESS_INFO       ThisProcess,
    PBREAKPOINT_INFO    bp
    );

BOOL
ResumeAllThreads(
    PPROCESS_INFO   ThisProcess,
    PTHREAD_INFO    ExceptionThread
    );

BOOL
SuspendAllThreads(
    PPROCESS_INFO   ThisProcess,
    PTHREAD_INFO    ExceptionThread
    );

DWORD
ConsoleDebugger(
    HANDLE              hProcess,
    HANDLE              hThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    BOOL                FirstChance,
    BOOL                UnexpectedException,
    LPSTR               InitialCommand
    );

ULONG_PTR
GetNextOffset(
    HANDLE    hProcess,
    ULONG_PTR Address,
    BOOL      Step
    );

BOOL
ClearBreakpoint(
    PPROCESS_INFO       ThisProcess,
    PBREAKPOINT_INFO    bp
    );

PBREAKPOINT_INFO
GetAvailBreakpoint(
    PPROCESS_INFO   ThisProcess
    );

LPVOID
MemAlloc(
    ULONG Size
    );

VOID
MemFree(
    LPVOID MemPtr
    );

BOOL
CreateDebuggerConsole(
    VOID
    );

BOOL
PrintOneInstruction(
    HANDLE  hProcess,
    ULONG_PTR   Address
    );

ULONG
GetIntRegNumber(
    ULONG index
    );

DWORDLONG
GetRegFlagValue(
    ULONG RegNum
    );

DWORDLONG
GetRegValue(
    ULONG RegNum
    );

VOID
GetFloatingPointRegValue(
    ULONG               regnum,
    PCONVERTED_DOUBLE   dv
    );

DWORDLONG
GetRegPCValue(
    ULONG_PTR * Address
    );

LONG
GetRegString(
    LPSTR RegString
    );

BOOL
LoadSymbols(
    PPROCESS_INFO       ThisProcess,
    PDLL_INFO           DllInfo,
    HANDLE              hFile
    );

BOOL
IsDelayInstruction(
    HANDLE  hProcess
    );

ULONG_PTR
GetExpression(
    LPSTR CommandString
    );

BOOL
GetRegContext(
    HANDLE      hThread,
    PCONTEXT    Context
    );

BOOL
SetRegContext(
    HANDLE      hThread,
    PCONTEXT    Context
    );

BOOL
disasm(
    HANDLE     hProcess,
    ULONG_PTR *poffset,
    LPSTR      bufptr,
    BOOL       fEAout
    );

DWORD
TraceBpHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    );

HWND
ChildCreate(
    HWND    hwnd
    );

VOID
SetMenuState(
    DWORD id,
    DWORD st
    );

VOID
SaveWindowPos(
    HWND        hwnd,
    PPOSITION   Pos,
    BOOL        ChildWindow
    );

VOID
ProcessHelpRequest(
    HWND hwnd,
    INT  DlgCtrl
    );

BOOL
CreateOptionsPropertySheet(
    HINSTANCE   hInstance,
    HWND        hwnd
    );

VOID
SetApiCounterEnabledFlag(
    BOOL  Flag,
    LPSTR DllName
    );

VOID
ClearApiCounters(
    VOID
    );

VOID
ClearApiTrace(
    VOID
    );

LRESULT CALLBACK
MDIChildWndProcCounters(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT CALLBACK
MDIChildWndProcPage(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT CALLBACK
MDIChildWndProcDlls(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT CALLBACK
MDIChildWndProcGraph(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT CALLBACK
MDIChildWndProcTrace(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
SetWindowPosition(
    HWND        hwnd,
    PPOSITION   Pos
    );

BOOL
GetOffsetFromSym(
    LPSTR   pString,
    PULONG_PTR pOffset
    );

PAPI_INFO
GetApiInfoByAddress(
    ULONG_PTR    Address,
    PDLL_INFO   *DllInfo
    );

VOID
EnableToolbarState(
    DWORD   Id
    );

VOID
DisableToolbarState(
    DWORD   Id
    );

VOID
ReallyDisableToolbarState(
    DWORD   Id
    );

PDLL_INFO
AddDllToList(
    PTHREAD_INFO    ThisThread,
    ULONG_PTR       DllAddr,
    LPSTR           DllName,
    ULONG           DllSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\apitable.cpp ===
#include "..\apidll\apitable.cpp"

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\apimonwn.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apimonwin.h

Abstract:

    Class definition for all ApiMon child windows.

Author:

    Wesley Witt (wesw) Dec-9-1995

Environment:

    User Mode

--*/

class ApiMonWindow
{
public:

    //
    // constructor & destructor
    //
    ApiMonWindow();
    ~ApiMonWindow();

    //
    // create a new instance of the window
    //
    BOOL
    Create(
        LPSTR   ClassName,
        LPSTR   Title
        );

    //
    // class registration (only done once)
    //
    BOOL
    Register(
        LPSTR   ClassName,
        ULONG   ChildIconId,
        WNDPROC WindowProc
        );

    //
    // allow the window to use a new font selection
    //
    void ChangeFont(HFONT);

    //
    // allow the window to use a new background color
    //
    void ChangeColor(COLORREF);

    //
    // change the current position of the window
    //
    void ChangePosition(PPOSITION);

    //
    // give focus to the window
    //
    void SetFocus();

    //
    // clears the list
    //
    void DeleteAllItems();

    //
    // update the contents of the window with new data
    //
    BOOL Update(BOOL);


    //
    // data items
    //
    HINSTANCE           hInstance;
    HWND                hwndWin;
    HWND                hwndList;
    PCOMPARE_ROUTINE    SortRoutine;
    HFONT               hFont;
    COLORREF            Color;
    POSITION            Position;

};


class DllListWindow : public ApiMonWindow
{
public:

    //
    // constructor & destructor
    //
    DllListWindow();
    ~DllListWindow();

    //
    // create a new instance of the window
    //
    BOOL Create();

    //
    // class registration (only done once)
    //
    BOOL Register();

    //
    // update the contents of the window with new data
    //
    BOOL Update(BOOL);

    //
    // create the the column headers, etc
    //
    void InitializeList();

    //
    // adds a new item the list
    //
    void
    AddItemToList(
        LPSTR     DllName,
        ULONG_PTR Address,
        BOOL      Enabled
        );

    //
    // handles WM_NOTIFY
    //
    void Notify( LPNMHDR  NmHdr );
};

// Counter window list items
enum {
    CNTR_ITEM_NAME,
    CNTR_ITEM_DLL,
    CNTR_ITEM_COUNT,
    CNTR_ITEM_TIME,
    CNTR_ITEM_CALLEES
    };

class CountersWindow : public ApiMonWindow
{
public:

    // Enable primary sort by Dll
    BOOL    DllSort;

    //
    // constructor & destructor
    //
    CountersWindow();
    ~CountersWindow();

    //
    // create a new instance of the window
    //
    BOOL Create();

    //
    // class registration (only done once)
    //
    BOOL Register();

    //
    // update the contents of the window with new data
    //
    BOOL Update(BOOL);

    //
    // create the the column headers, etc
    //
    void InitializeList();

    //
    // adds a new item the list
    //
    void
    AddItemToList(
        ULONG       Counter,
        DWORDLONG   Time,
        DWORDLONG   CalleeTime,
        LPSTR       ApiName,
        LPSTR       DllName
        );

    //
    // handles WM_NOTIFY
    //
    void Notify( LPNMHDR  NmHdr );
};


#define WORKING_SET_BUFFER_ENTRYS   4096

class PageFaultWindow : public ApiMonWindow
{
public:

    //
    // constructor & destructor
    //
    PageFaultWindow();
    ~PageFaultWindow();

    //
    // create a new instance of the window
    //
    BOOL Create();

    //
    // class registration (only done once)
    //
    BOOL Register();

    //
    // update the contents of the window with new data
    //
    BOOL Update(BOOL);

    //
    // create the the column headers, etc
    //
    void InitializeList();

    //
    // adds a new item the list
    //
    void
    PageFaultWindow::AddItemToList(
        LPSTR     ApiName,
        ULONG_PTR Hard,
        ULONG_PTR Soft,
        ULONG_PTR Data,
        ULONG_PTR Code
        );

    //
    // handles WM_NOTIFY
    //
    void Notify( LPNMHDR  NmHdr );

    //
    // data
    //
    PSAPI_WS_WATCH_INFORMATION  WorkingSetBuffer[WORKING_SET_BUFFER_ENTRYS];
};


#define BAR_SEP                 5
#define LEGEND_LINE_HEIGHT      7
#define LEGEND_COLOR_WIDTH      50
#define LEGEND_BORDER           5
#define LEGEND_SEP              1
#define LEGEND_ITEM_HEIGHT(f)   ((f)+(LEGEND_SEP*2))
#define LEGEND_HEIGHT(f,n)      (LEGEND_ITEM_HEIGHT(f)*(n))
#define LEGEND_DEFAULT_LINES    3


typedef struct _GRAPH_VALUE {
    CHAR            Name[64];
    ULONG_PTR       Address;
    BOOL            Used;
    COLORREF        Color;
    RECT            Rect;
    DWORD           Hits;
    LONGLONG        Value;
    float           Pct;
} GRAPH_VALUE, *PGRAPH_VALUE;


typedef struct _GRAPH_DATA {
    ULONG           NumberOfBars;
    RECT            SplitRect;
    RECT            LegendRect;
    BOOL            DrawLegend;
    GRAPH_VALUE     Bar[1];
} GRAPH_DATA, *PGRAPH_DATA;


typedef struct _FONT_COLOR_CHANGE {
    HWND            hwndGraph;
    COLORREF        GraphColor;
    HFONT           GraphFont;
} FONT_COLOR_CHANGE, *PFONT_COLOR_CHANGE;


class GraphWindow : public ApiMonWindow
{
public:

    //
    // constructor & destructor
    //
    GraphWindow();
    ~GraphWindow();

    //
    // create a new instance of the window
    //
    BOOL Create(BOOL IsBase);

    //
    // class registration (only done once)
    //
    BOOL Register();

    //
    // update the contents of the window with new data
    //
    BOOL Update(BOOL);

    //
    // allow the window to use a new font selection
    //
    void ChangeFont(HFONT);

    //
    // allow the window to use a new background color
    //
    void ChangeColor(COLORREF);

    //
    // create the the column headers, etc
    //
    void InitializeList();

    //
    // adds a new item the list
    //
    void
    AddItemToList(
        ULONG       Counter,
        DWORDLONG   Time,
        LPSTR       ApiName
        );

    //
    // handles WM_NOTIFY
    //
    void Notify( LPNMHDR  NmHdr );


    PGRAPH_DATA CreateGraphData();

    PGRAPH_DATA CreateGraphDataApi( ULONG_PTR BaseAddress );

    BOOL DrawBarGraph( PGRAPH_DATA GraphData );

    void ChangeToolTipsRect( PGRAPH_DATA GraphData );

    void CreateToolTips( PGRAPH_DATA GraphData );

    void GraphWindow::DeleteToolTips( PGRAPH_DATA GraphData );


    //
    // data
    //
    HWND            hwndToolTip;
    HCURSOR         GraphCursor;
    HCURSOR         ArrowCursor;
    HCURSOR         HorizSplitCursor;
    PGRAPH_VALUE    Bar;
    PGRAPH_DATA     GraphData;
    HCURSOR         hCursor;
    HWND            hwndLegend;
    TEXTMETRIC      tm;
    BOOL            ApiGraph;
    BOOL            MouseDown;
    POINT           LastPos;
    BOOL            Base;
};


class TraceWindow : public ApiMonWindow
{
public:

    //
    // constructor & destructor
    //
    TraceWindow();
    ~TraceWindow();

    //
    // create a new instance of the window
    //
    BOOL Create();

    //
    // class registration (only done once)
    //
    BOOL Register();

    //
    // update the contents of the window with new data
    //
    BOOL Update(BOOL);

    //
    // create the the column headers, etc
    //
    void InitializeList();

    //
    // adds a new item the list
    //
    void AddItemToList(PTRACE_ENTRY);

    void FillList();

    //
    // handles WM_NOTIFY
    //
    void Notify( LPNMHDR  NmHdr );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\apimonwn.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apimonwin.h

Abstract:

    Implemenation for the base ApiMon child window class.

Author:

    Wesley Witt (wesw) Dec-9-1995

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

#include "apimonwn.h"


ApiMonWindow::ApiMonWindow()
{
    hInstance    = GetModuleHandle( NULL );
    hwndWin      = NULL;
    hwndList     = NULL;
    SortRoutine  = NULL;
    hFont        = NULL;
    Color        = 0;
    ZeroMemory( &Position, sizeof(POSITION) );
}


ApiMonWindow::~ApiMonWindow()
{
}


BOOL
ApiMonWindow::Create(
    LPSTR   ClassName,
    LPSTR   Title
    )
{
    hwndWin = CreateMDIWindow(
        ClassName,
        Title,
        0,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        hwndMDIClient,
        hInstance,
        (LPARAM) this
        );

    if (!hwndWin) {
        return FALSE;
    }

    ShowWindow(
        hwndWin,
        SW_SHOW
        );

    return TRUE;
}


BOOL
ApiMonWindow::Register(
    LPSTR   ClassName,
    ULONG   ChildIconId,
    WNDPROC WindowProc
    )
{
    WNDCLASSEX  wc;

    wc.cbSize        = sizeof(WNDCLASSEX);
    wc.style         = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(ChildIconId));
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)COLOR_APPWORKSPACE;
    wc.lpszMenuName  = NULL;
    wc.hIconSm       = (HICON)LoadImage(
                           hInstance,
                           MAKEINTRESOURCE(ChildIconId),
                           IMAGE_ICON,
                           16,
                           16,
                           0
                           );

    wc.lpfnWndProc   = WindowProc;
    wc.lpszClassName = ClassName;

    return RegisterClassEx( &wc );
}


void
ApiMonWindow::ChangeFont(
    HFONT hFont
    )
{
    if (hwndList) {
        ApiMonWindow::hFont = hFont;
        SendMessage(
            hwndList,
            WM_SETFONT,
            (WPARAM)hFont,
            MAKELPARAM( TRUE, 0 )
            );
    }
}


void
ApiMonWindow::ChangeColor(
    COLORREF Color
    )
{
    if (hwndList) {
        ApiMonWindow::Color = Color;
        ListView_SetBkColor( hwndList, Color );
        ListView_SetTextBkColor( hwndList, Color );

        InvalidateRect( hwndList, NULL, TRUE );
        UpdateWindow( hwndList );
    }
}


void
ApiMonWindow::ChangePosition(
    PPOSITION Position
    )
{
    ApiMonWindow::Position = *Position;
    SetWindowPosition( hwndWin, Position );
}


void
ApiMonWindow::SetFocus()
{
    BringWindowToTop( hwndWin );
    SetForegroundWindow( hwndWin );
}


BOOL
ApiMonWindow::Update(
    BOOL ForceUpdate
    )
{
    if ((!hwndWin) || (!hwndList)) {
        return FALSE;
    }
    return TRUE;
}

void
ApiMonWindow::DeleteAllItems()
{
    ListView_DeleteAllItems( hwndList );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\browse.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    browse.c

Abstract:
    This file implements the functions that make use of the common
    file _open dialogs for browsing for files/directories.

Author:

    Wesley Witt (wesw) 20-June-1995

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop


UINT_PTR APIENTRY
BrowseHookProc(
    HWND   hwnd,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Hook procedure to cause the window to be the foreground
    window and centered.

Arguments:

    hwnd       - window handle to the dialog box
    message    - message number
    wParam     - first message parameter
    lParam     - second message parameter

Return Value:

    TRUE       - did not process the message
    FALSE      - did process the message

--*/

{
    if (message == WM_INITDIALOG) {
        SetForegroundWindow( hwnd );
        CenterWindow( hwnd, hwndFrame );
    }

    return FALSE;
}

BOOL
BrowseForFileName(
    LPSTR FileName,
    LPSTR Extension,
    LPSTR FileDesc
    )

/*++

Routine Description:

    Presents a common file open dialog for the purpose of selecting a
    file name;

Arguments:

    FileName - name of the selected file

Return Value:

    TRUE       - got a good wave file name (user pressed the OK button)
    FALSE      - got nothing (user pressed the CANCEL button)

    the FileName is changed to have the selected file name.

--*/

{
    OPENFILENAME   of;
    char           ftitle[MAX_PATH];
    char           title[MAX_PATH];
    char           fname[MAX_PATH];
    char           filter[1024];
    char           szDrive    [_MAX_DRIVE];
    char           szDir      [_MAX_DIR];
    char           szFname    [_MAX_FNAME];
    char           szExt      [_MAX_EXT];


    ftitle[0] = 0;
    sprintf( fname, "*.%s", Extension );
    of.lStructSize = sizeof( OPENFILENAME );
    of.hwndOwner = NULL;
    of.hInstance = GetModuleHandle( NULL );
    ZeroMemory(filter, sizeof(filter)/sizeof(filter[0]));
    sprintf( filter, "%s(*.%s)%c*.%s", FileDesc, Extension, 0, Extension );
    of.lpstrFilter = filter;
    of.lpstrCustomFilter = NULL;
    of.nMaxCustFilter = 0;
    of.nFilterIndex = 0;
    of.lpstrFile = fname;
    of.nMaxFile = MAX_PATH;
    of.lpstrFileTitle = ftitle;
    of.nMaxFileTitle = MAX_PATH;
    of.lpstrInitialDir = ApiMonOptions.LastDir;
    strcpy( title, "File Selection" );
    of.lpstrTitle = title;
    of.Flags = OFN_ENABLEHOOK;
    of.nFileOffset = 0;
    of.nFileExtension = 0;
    of.lpstrDefExt = Extension;
    of.lCustData = 0;
    of.lpfnHook = BrowseHookProc;
    of.lpTemplateName = NULL;
    if (GetOpenFileName( &of )) {
        strcpy( FileName, fname );
        _splitpath( fname, szDrive, szDir, szFname, szExt );
        strcpy( ApiMonOptions.LastDir, szDrive );
        strcat( ApiMonOptions.LastDir, szDir );
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\condebug.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    condebug.cpp

Abstract:

    This module contains a simple console mode debugger.

Author:

    Wesley Witt (wesw) July-11-1993

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

extern HANDLE       CurrProcess;
extern PDLL_INFO    DllList;
extern BOOL         BreakInNow;
extern ULONG        BpSize;
extern ULONG        BpInstr;
extern HANDLE       BreakinEvent;
extern BOOL         ExprError;
extern PUCHAR       pchCommand;


BOOL                ConsoleCreated;
CONTEXT             CurrContext;
BOOL                Stepped;
BOOL                PrintRegistersFlag = TRUE;


BOOL
GetOffsetFromSym(
    LPSTR   pString,
    ULONG_PTR *pOffset
    )
{
    CHAR   SuffixedString[256+64];
    CHAR   Suffix[4];

    //
    // Nobody should be referencing a 1 character symbol!  It causes the
    // rest of us to pay a huge penalty whenever we make a typo.  Please
    // change to 2 character instead of removing this hack!
    //

    if ( strlen(pString) == 1 || strlen(pString) == 0 ) {
        return FALSE;
    }

    if (SymGetSymFromName( CurrProcess, pString, sym )) {
        *pOffset = sym->Address;
        return TRUE;
    }

    return FALSE;
}

LPSTR
GetAddress(
    LPSTR   CmdBuf,
    PDWORD_PTR Address
    )
{
    *Address = GetExpression( CmdBuf );
    return (LPSTR) pchCommand;
}

BOOL
CmdStackTrace(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    CONTEXT     Context;
    STACKFRAME  StackFrame = {0};
    BOOL        rVal = FALSE;



    CopyMemory( &Context, &CurrContext, sizeof(CONTEXT) );

#if defined(_M_IX86)
    StackFrame.AddrPC.Offset       = Context.Eip;
    StackFrame.AddrPC.Mode         = AddrModeFlat;
    StackFrame.AddrFrame.Offset    = Context.Ebp;
    StackFrame.AddrFrame.Mode      = AddrModeFlat;
    StackFrame.AddrStack.Offset    = Context.Esp;
    StackFrame.AddrStack.Mode      = AddrModeFlat;
#endif

    printf( "\n" );
    do {
        rVal = StackWalk(
            MACHINE_TYPE,
            hProcess,
            0,
            &StackFrame,
            &Context,
            (PREAD_PROCESS_MEMORY_ROUTINE)ReadProcessMemory,
            SymFunctionTableAccess,
            SymGetModuleBase,
            NULL
            );
        if (rVal) {
            ULONG_PTR Displacement;
            printf( "%08x %08x ",
                StackFrame.AddrFrame.Offset,
                StackFrame.AddrReturn.Offset
                );
            if (SymGetSymFromAddr( hProcess, StackFrame.AddrPC.Offset, &Displacement, sym )) {
                printf( "%s\n", sym->Name );
            } else {
                printf( "0x%08x\n", StackFrame.AddrPC.Offset );
            }
        }
    } while( rVal );

    printf( "\n" );

    return TRUE;
}

BOOL
CmdDisplayMemory(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    static ULONG_PTR Address = 0;

    //
    // skip any command modifiers & white space that may follow
    //
    SKIP_NONWHITE( CmdBuf );
    SKIP_WHITE( CmdBuf );

    ULONG_PTR ThisAddress;
    GetAddress( CmdBuf, &ThisAddress );
    if (ThisAddress) {
        Address = ThisAddress;
    }

    ULONG DataSize = 20*16;  // 20 lines @ 16 bytes per line
    LPSTR DataBuf = (LPSTR) MemAlloc( DataSize );
    if (!DataBuf) {
        return FALSE;
    }

    ULONG cb;
    if (!ReadMemory( hProcess, (PVOID)Address, DataBuf, DataSize )) {
        printf( "could not read memory\n" );
        MemFree( DataBuf );
        return FALSE;
    }

    ULONG i,j;
    printf( "\n" );
    for( i = 0; i < DataSize/16; i++ ) {
        j = i * 16;
        printf( "%08x  %08x %08x %08x %08x   %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n",
                  j + Address,
                  *(LPDWORD)&DataBuf[ j + 0 ],
                  *(LPDWORD)&DataBuf[ j + 4 ],
                  *(LPDWORD)&DataBuf[ j + 8 ],
                  *(LPDWORD)&DataBuf[ j + 12 ],
                  isprint( DataBuf[ j +  0 ]) ? DataBuf[ j +  0 ] : '.',
                  isprint( DataBuf[ j +  1 ]) ? DataBuf[ j +  1 ] : '.',
                  isprint( DataBuf[ j +  2 ]) ? DataBuf[ j +  2 ] : '.',
                  isprint( DataBuf[ j +  3 ]) ? DataBuf[ j +  3 ] : '.',
                  isprint( DataBuf[ j +  4 ]) ? DataBuf[ j +  4 ] : '.',
                  isprint( DataBuf[ j +  5 ]) ? DataBuf[ j +  5 ] : '.',
                  isprint( DataBuf[ j +  6 ]) ? DataBuf[ j +  6 ] : '.',
                  isprint( DataBuf[ j +  7 ]) ? DataBuf[ j +  7 ] : '.',
                  isprint( DataBuf[ j +  8 ]) ? DataBuf[ j +  8 ] : '.',
                  isprint( DataBuf[ j +  9 ]) ? DataBuf[ j +  9 ] : '.',
                  isprint( DataBuf[ j + 10 ]) ? DataBuf[ j + 10 ] : '.',
                  isprint( DataBuf[ j + 11 ]) ? DataBuf[ j + 11 ] : '.',
                  isprint( DataBuf[ j + 12 ]) ? DataBuf[ j + 12 ] : '.',
                  isprint( DataBuf[ j + 13 ]) ? DataBuf[ j + 13 ] : '.',
                  isprint( DataBuf[ j + 14 ]) ? DataBuf[ j + 14 ] : '.',
                  isprint( DataBuf[ j + 15 ]) ? DataBuf[ j + 15 ] : '.'
                );
    }
    printf( "\n" );

    Address += DataSize;
    MemFree( DataBuf );

    return TRUE;
}

size_t
DisAddrToSymbol(
    struct DIS *pdis,
    ULONG_PTR   addr,
    char       *buf,
    size_t      bufsize,
    DWORD_PTR  *displacement
    )
{
    if (SymGetSymFromAddr( CurrProcess, addr, displacement, sym )) {
        strncpy( buf, sym->Name, bufsize );
    } else {
        *displacement = 0;
        buf[0] = 0;
    }

    return strlen(buf);
}

size_t
DisFixupToSymbol(
    struct DIS  *pdis,
    ULONG_PTR   addr,
    size_t      fixup,
    char        *buf,
    size_t      bufsize,
    DWORD_PTR  *displacement
    )
{
    if (!ReadMemory( CurrProcess, (PVOID)addr, &addr, 4 )) {
        *displacement = 0;
        return 0;
    }

    if (SymGetSymFromAddr( CurrProcess, addr, displacement, sym )) {
        strncpy( buf, sym->Name, bufsize );
    } else {
        *displacement = 0;
        buf[0] = 0;
    }

    return strlen(buf);
}

BOOL
CmdDisplayCode(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    static ULONG_PTR Address = 0;
    ULONG_PTR ThisAddress;
    CHAR    DisBuf[512];
    ULONG   i;

    //
    // skip any command modifiers & white space that may follow
    //
    SKIP_NONWHITE( CmdBuf );
    SKIP_WHITE( CmdBuf );

    GetAddress( CmdBuf, &ThisAddress );
    if (ThisAddress) {
        Address = ThisAddress;
    }

    printf( "\n" );

    for (i=0; i<20; i++) {
        if (!disasm( hProcess, &Address, DisBuf, TRUE )) {
            break;
        }
        printf( "%s\n", DisBuf );
    }

    printf( "\n" );

    return TRUE;
}

BOOL
CmdDisplayRegisters(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    PrintRegisters();
    return TRUE;
}

DWORD
UserBpStepHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    )
{
    WriteMemory(
        ThisProcess->hProcess,
        (PVOID) BreakpointInfo->LastBp->Address,
        &BpInstr,
        BpSize
        );
    BreakpointInfo->LastBp = NULL;
    ResumeAllThreads( ThisProcess, ThisThread );
    ZeroMemory( BreakpointInfo, sizeof(BREAKPOINT_INFO) );
    return DBG_CONTINUE;
}

DWORD
UserBpHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    )
{
    if (BreakpointInfo->Number) {
        printf( "Breakpoint #%d hit\n", BreakpointInfo->Number );
    } else {
        printf( "Hardcoded breakpoint hit\n" );
    }

    if (PrintRegistersFlag) PrintRegisters();
    PrintOneInstruction( ThisProcess->hProcess, (ULONG_PTR)ExceptionRecord->ExceptionAddress );

    ULONG ContinueStatus = ConsoleDebugger(
        ThisThread->hProcess,
        ThisThread->hThread,
        ExceptionRecord,
        TRUE,
        FALSE,
        BreakpointInfo->Command
        );

    if (BreakpointInfo->Address && (!Stepped)) {
        //
        // the bp is still present so we must step off it
        //
        SuspendAllThreads( ThisProcess, ThisThread );
        ULONG_PTR Address = GetNextOffset(
            ThisProcess->hProcess,
            (ULONG_PTR)ExceptionRecord->ExceptionAddress,
            TRUE
            );
        if (Address != (ULONG)-1) {
            PBREAKPOINT_INFO bp = SetBreakpoint(
                ThisProcess,
                Address,
                0,
                NULL,
                UserBpStepHandler
                );
            if (bp) {
                bp->LastBp = BreakpointInfo;
            } else {
                printf( "could not set off of the breakpoint\n" );
            }
        } else {
#ifdef _M_IX86
            CurrContext.EFlags |= 0x100;
            SetRegContext( ThisThread->hThread, &CurrContext );
            PBREAKPOINT_INFO bp = GetAvailBreakpoint( ThisProcess );
            if (bp) {
                bp->Flags   |= BPF_TRACE;
                bp->Address  = (ULONG)ExceptionRecord->ExceptionAddress;
                bp->Handler  = TraceBpHandler;
                bp->LastBp   = BreakpointInfo;
            } else {
                printf( "could not step off of the breakpoint\n" );
            }
#else
            printf( "could not step off of the breakpoint\n" );
#endif
        }
    }

    return ContinueStatus;
}

BOOL
PrintOneInstruction(
    HANDLE  hProcess,
    ULONG_PTR   Address
    )
{
    CHAR    DisBuf[512];

    if (disasm( hProcess, &Address, DisBuf, TRUE )) {
        printf( "%s\n", DisBuf );
    } else {
        printf( "*** error in disassembly\n" );
    }

    return TRUE;
}

DWORD
TraceBpHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    )
{
    CONTEXT Context;
#ifdef _M_IX86
    if (BreakpointInfo->Flags & BPF_TRACE) {
        CurrContext.EFlags &= ~0x100;
        SetRegContext( ThisThread->hThread, &CurrContext );
    }
#endif

    if (BreakpointInfo->LastBp) {
        WriteMemory(
            ThisProcess->hProcess,
            (PVOID) BreakpointInfo->LastBp->Address,
            &BpInstr,
            BpSize
            );
        BreakpointInfo->LastBp = NULL;
    }

    //
    // clear the trace breakpoint
    //
    ClearBreakpoint( ThisProcess, BreakpointInfo );

    //
    // print the registers
    //
    if (PrintRegistersFlag) {
        PrintRegisters();
    }

    //
    // print the code
    //
    PrintOneInstruction( ThisProcess->hProcess, (ULONG_PTR)ExceptionRecord->ExceptionAddress );

    //
    // enter the debugger
    //
    ULONG ContinueStatus = ConsoleDebugger(
        ThisThread->hProcess,
        ThisThread->hThread,
        ExceptionRecord,
        TRUE,
        FALSE,
        BreakpointInfo->Command
        );

    //
    // continue the debuggee
    //
    return ContinueStatus;
}

BOOL
CmdTrace(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    PPROCESS_INFO ThisProcess = GetProcessInfo( hProcess );
    if (!ThisProcess) {
        printf( "could not get process information\n" );
        return FALSE;
    }

    PTHREAD_INFO ThisThread = GetThreadInfo( hProcess, hThread );
    if (!ThisThread) {
        printf( "could not get thread information\n" );
        return FALSE;
    }

    SuspendAllThreads( ThisProcess, ThisThread );

#ifdef _M_IX86
    CurrContext.EFlags |= 0x100;
    SetRegContext( ThisThread->hThread, &CurrContext );
    PBREAKPOINT_INFO bp = GetAvailBreakpoint( ThisProcess );
    if (bp) {
        bp->Flags   |= BPF_TRACE;
        bp->Address  = (ULONG)ExceptionRecord->ExceptionAddress;
        bp->Handler  = TraceBpHandler;
    }
#else
    ULONG_PTR Address = GetNextOffset(
        ThisProcess->hProcess,
        (ULONG_PTR)ExceptionRecord->ExceptionAddress,
        FALSE
        );
    if (Address == (ULONG_PTR)ExceptionRecord->ExceptionAddress) {
        printf( "could not trace the instruction\n" );
        return FALSE;
    }
    PBREAKPOINT_INFO bp = SetBreakpoint(
        ThisProcess,
        Address,
        0,
        NULL,
        TraceBpHandler
        );
    if (!bp) {
        printf( "could not trace the instruction\n" );
        return FALSE;
    }
#endif

    return TRUE;
}

BOOL
CmdStep(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    PPROCESS_INFO ThisProcess = GetProcessInfo( hProcess );
    if (!ThisProcess) {
        printf( "could not get process information\n" );
        return FALSE;
    }

    PTHREAD_INFO ThisThread = GetThreadInfo( hProcess, hThread );
    if (!ThisThread) {
        printf( "could not get thread information\n" );
        return FALSE;
    }

    SuspendAllThreads( ThisProcess, ThisThread );

    ULONG_PTR Address = GetNextOffset(
        ThisProcess->hProcess,
        (ULONG_PTR)ExceptionRecord->ExceptionAddress,
        TRUE
        );

    if (Address == (ULONG_PTR)-1) {
#ifdef _M_IX86
        CurrContext.EFlags |= 0x100;
        SetRegContext( ThisThread->hThread, &CurrContext );
        PBREAKPOINT_INFO bp = GetAvailBreakpoint( ThisProcess );
        if (bp) {
            bp->Flags   |= BPF_TRACE;
            bp->Address  = (ULONG)ExceptionRecord->ExceptionAddress;
            bp->Handler  = TraceBpHandler;
        }
#else
        printf( "could not trace the instruction\n" );
#endif
    } else {
        PBREAKPOINT_INFO bp = SetBreakpoint(
            ThisProcess,
            Address,
            0,
            NULL,
            TraceBpHandler
            );
        if (!bp) {
            printf( "could not trace the instruction\n" );
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
CmdBreakPoint(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    CHAR BpCmd = (CHAR)tolower(CmdBuf[1]);
    ULONG_PTR Address = 0;
    PBREAKPOINT_INFO bp;
    PPROCESS_INFO ThisProcess;
    ULONG Flags;
    LPSTR p;
    LPSTR SymName;
    ULONG i;
    IMAGEHLP_MODULE mi;


    ThisProcess = GetProcessInfo( hProcess );
    if (!ThisProcess) {
        printf( "could not get process information\n" );
        return FALSE;
    }

    PTHREAD_INFO ThisThread = GetThreadInfo( hProcess, hThread );
    if (!ThisThread) {
        printf( "could not get thread information\n" );
        return FALSE;
    }

    SKIP_NONWHITE( CmdBuf );
    SKIP_WHITE( CmdBuf );
    p = CmdBuf;

    switch ( BpCmd ) {
        case 'p':
            Flags = 0;
            CmdBuf = GetAddress( CmdBuf, &Address );
            SymName = (LPSTR) MemAlloc( (ULONG)(CmdBuf - p + 16) );
            if (!SymName) {
                printf( "could not allocate memory for bp command\n" );
                break;
            }
            strncpy( SymName, p, (size_t)(CmdBuf - p) );
            if (!Address) {
                Flags = BPF_UNINSTANCIATED;
                printf( "breakpoint not instanciated\n" );
            }
            bp = SetBreakpoint(
                ThisProcess,
                Address,
                Flags,
                SymName,
                UserBpHandler
                );
            MemFree( SymName );
            if (!bp) {
                printf( "could not set breakpoint\n" );
            }
            ThisProcess->UserBpCount += 1;
            bp->Number = ThisProcess->UserBpCount;
            SKIP_WHITE( CmdBuf );
            if (CmdBuf[0]) {
                if (CmdBuf[0] == '/') {
                    switch (tolower(CmdBuf[1])) {
                        case 'c':
                            CmdBuf += 3;
                            if (CmdBuf[0] != '\"') {
                                printf( "invalid syntax\n" );
                                return FALSE;
                            }
                            CmdBuf += 1;
                            p = strchr( CmdBuf, '\"' );
                            if (!p) {
                                printf( "invalid syntax\n" );
                                return FALSE;
                            }
                            p[0] = 0;
                            bp->Command = _strdup( CmdBuf );
                            break;

                        default:
                            break;
                    }
                }
            }
            break;

        case 'l':
            for (i=0; i<MAX_BREAKPOINTS; i++) {
                if (ThisProcess->Breakpoints[i].Number) {
                    ULONG_PTR disp = 0;
                    if (ThisProcess->Breakpoints[i].Flags & BPF_WATCH) {
                        printf( "#%d %c%c\t          \tWatch\n",
                            ThisProcess->Breakpoints[i].Number,
                            ThisProcess->Breakpoints[i].Flags & BPF_UNINSTANCIATED ? 'U' : 'I',
                            ThisProcess->Breakpoints[i].Flags & BPF_DISABLED       ? 'D' : 'E'
                            );
                    } else if ((ThisProcess->Breakpoints[i].Address != 0) &&
                        (ThisProcess->Breakpoints[i].Address != 0xffffffff)) {
                        SymGetModuleInfo(
                            ThisProcess->hProcess,
                            ThisProcess->Breakpoints[i].Address,
                            &mi
                            );
                        if (SymGetSymFromAddr(
                            ThisProcess->hProcess,
                            ThisProcess->Breakpoints[i].Address,
                            &disp,
                            sym
                            )) {
                                printf( "#%d %c%c\t0x%08x\t%s!%s\n",
                                    ThisProcess->Breakpoints[i].Number,
                                    ThisProcess->Breakpoints[i].Flags & BPF_UNINSTANCIATED ? 'U' : 'I',
                                    ThisProcess->Breakpoints[i].Flags & BPF_DISABLED       ? 'D' : 'E',
                                    ThisProcess->Breakpoints[i].Address,
                                    mi.ModuleName,
                                    sym ? sym->Name : ""
                                    );
                        }
                    } else {
                        printf( "#%d %c%c\t          \t%s\n",
                            ThisProcess->Breakpoints[i].Number,
                            ThisProcess->Breakpoints[i].Flags & BPF_UNINSTANCIATED ? 'U' : 'I',
                            ThisProcess->Breakpoints[i].Flags & BPF_DISABLED       ? 'D' : 'E',
                            ThisProcess->Breakpoints[i].SymName
                            );
                    }
                }
            }
            break;

        case 'c':
            if (!CmdBuf[0]) {
                printf( "missing breakpoint number\n" );
                return FALSE;
            }
            if (CmdBuf[0] == '*') {
                for (i=0; i<MAX_BREAKPOINTS; i++) {
                    if (ThisProcess->Breakpoints[i].Number) {
                        ClearBreakpoint( ThisProcess, &ThisProcess->Breakpoints[i] );
                    }
                }
                return TRUE;
            }
            if (isdigit(CmdBuf[0])) {
                ULONG BpNum = atoi( CmdBuf );
                for (i=0; i<MAX_BREAKPOINTS; i++) {
                    if (ThisProcess->Breakpoints[i].Number == BpNum) {
                        ClearBreakpoint( ThisProcess, &ThisProcess->Breakpoints[i] );
                        return TRUE;
                    }
                }
            }
            printf( "invalid breakpoint number\n" );
            return FALSE;

        case 'd':
            break;

        case 'e':
            break;

        case 'a':
#if defined(_M_IX86)
            CmdBuf = GetAddress( CmdBuf, &Address );

            bp = GetAvailBreakpoint( ThisProcess );
            if (!bp) {
                printf( "could not set breakpoint\n" );
                return FALSE;
            }

            bp->Address = Address;
            bp->Handler = UserBpHandler;
            bp->Flags   = BPF_WATCH;

            ThisProcess->UserBpCount += 1;
            bp->Number = ThisProcess->UserBpCount;

            CurrContext.Dr0 = Address;
            CurrContext.Dr6 = 0x000d0002;
            SetRegContext( ThisThread->hThread, &CurrContext );
#else
            printf( "only available on x86\n" );
#endif
            break;

        default:
            break;
    }

    return TRUE;
}

BOOL
CmdListNear(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    SKIP_NONWHITE( CmdBuf );
    SKIP_WHITE( CmdBuf );

    ULONG_PTR Address;
    GetAddress( CmdBuf, &Address );
    if (Address) {
        ULONG_PTR Displacement;
        if (SymGetSymFromAddr( hProcess, Address, &Displacement, sym )) {
            printf( "0x%p %s\n", (PVOID)sym->Address, sym->Name );
        }
    }
    return TRUE;
}

BOOL
CmdDisplayModules(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    IMAGEHLP_MODULE ModuleInfo;


    printf( "\n" );
    printf( "Address    Size                   Name  Symbol Status\n" );
    printf( "------------------------------------------------------------------\n" );
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress && !DllList[i].Unloaded) {
            printf( "0x%08x 0x%08x %16s\t",
                DllList[i].BaseAddress,
                DllList[i].Size,
                DllList[i].Name
                );
            if (SymGetModuleInfo( hProcess, DllList[i].BaseAddress, &ModuleInfo )) {
                if (ModuleInfo.SymType != SymNone) {
                    printf( "(symbols loaded)\t" );
                } else {
                    printf( "(symbols *NOT* loaded)\t" );
                }
                printf( "%s\t", ModuleInfo.LoadedImageName );
            } else {
                printf( "(symbols *NOT* loaded)\t" );
            }
            printf( "\n" );
        }
    }
    printf( "\n" );

    return TRUE;
}

BOOL
CmdDisplayHelp(
    LPSTR             CmdBuf,
    HANDLE            hProcess,
    HANDLE            hThread,
    PEXCEPTION_RECORD ExceptionRecord
    )
{
    printf( "\n" );
    printf( "  ?            - display this screen\n" );
    printf( "  g            - continue the process\n" );
    printf( "  q            - quit the debugger\n" );
    printf( "  bp <address> - set a new breakpoint\n" );
    printf( "  r            - display registers\n" );
    printf( "  k            - stack trace\n" );
    printf( "  d <address>  - display memory\n" );
    printf( "  u <address>  - display disassembled code\n" );
    printf( "\n" );
    printf( "  all addresses are represented in hexadecimal\n" );
    printf( "  and all addressed input to the debugger must\n" );
    printf( "  be in hexadecimal radix\n" );
    printf( "\n" );

    return TRUE;
}

CLINKAGE DWORD
ReadMemory(
    HANDLE  hProcess,
    PVOID   Address,
    PVOID   Buffer,
    ULONG   Length
    )
{
    ULONG cbRead;
    SIZE_T cb;
    BOOL rVal = ReadProcessMemory(
        hProcess,
        Address,
        Buffer,
        Length,
        &cbRead
        );
    if (!rVal) {
        return 0;
    }

    PPROCESS_INFO ThisProcess = GetProcessInfo( hProcess );
    if (!ThisProcess) {
        return 0;
    }

    //
    // make sure that the view of the va is correct
    // and does NOT show bp instructions where
    // breakpoints have been set
    //
    for (ULONG i=0; i<MAX_BREAKPOINTS; i++) {
        if (((ULONG_PTR)Address >= ThisProcess->Breakpoints[i].Address &&
            (ULONG_PTR)Address <  ThisProcess->Breakpoints[i].Address+BpSize) && (!ThisProcess->Breakpoints[i].Text)) {

                cb = ThisProcess->Breakpoints[i].Address - (ULONG_PTR)Address;
                CopyMemory(
                    (LPSTR)Buffer + cb,
                    &ThisProcess->Breakpoints[i].OriginalInstr,
                    BpSize
                    );
                break;

        }
    }

    return cbRead;
}

CLINKAGE BOOL
WriteMemory(
    HANDLE  hProcess,
    PVOID   Address,
    PVOID   Buffer,
    ULONG   Length
    )
{
    ULONG cb;
    BOOL rVal = WriteProcessMemory(
        hProcess,
        Address,
        Buffer,
        Length,
        &cb
        );
    if (!rVal || cb != Length) {
        return FALSE;
    }
    return TRUE;
}

BOOL
ConsoleHandler(
    DWORD   CtrlType
    )
{
    if (CtrlType == CTRL_C_EVENT) {
        printf( "^C pressed\n" );
        SetEvent( BreakinEvent );
        return TRUE;
    }
    return FALSE;
}

BOOL
CreateDebuggerConsole(
    VOID
    )
{
    if (!AllocConsole()) {
        return FALSE;
    }

    SetConsoleCtrlHandler( ConsoleHandler, TRUE );

    int hCrt;
    FILE *hf;
    hCrt = _open_osfhandle( (LONG_PTR) GetStdHandle(STD_OUTPUT_HANDLE), _O_TEXT );
    hf = _fdopen( hCrt, "w" );
    if (hf)
        *stdout = *hf;
    setvbuf( stdout, NULL, _IONBF, 0 );

    hCrt = _open_osfhandle( (LONG_PTR) GetStdHandle(STD_INPUT_HANDLE), _O_TEXT );
    hf = _fdopen( hCrt, "r" );
    if (hf)
        *stdin = *hf;
    setvbuf( stdin, NULL, _IONBF, 0 );
    ConsoleCreated = TRUE;
    puts( "*----------------------------------------------------------\n"
          "Microsoft(R) Windows NT APIMON Version 4.0\n"
          "(C) 1989-2000 Microsoft Corp. All rights reserved\n"
          "\n"
          "APIMON Console Debugger Interface\n"
          "\n"
          "Use the ? command for help\n"
          "*----------------------------------------------------------\n"
          "\n" );

    return TRUE;
}

DWORD
ConsoleDebugger(
    HANDLE              hProcess,
    HANDLE              hThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    BOOL                FirstChance,
    BOOL                UnexpectedException,
    LPSTR               InitialCommand
    )
{
    PPROCESS_INFO ThisProcess;
    DWORD ContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
    static CHAR CmdBuf[512];

    Stepped = FALSE;

    if (!ConsoleCreated) {
        CmdBuf[0] = 0;
        if (!CreateDebuggerConsole()) {
            return ContinueStatus;
        }
    }

    ThisProcess = GetProcessInfo( hProcess );
    if (!ThisProcess) {
        printf( "could not get process information\n" );
    }

    if (UnexpectedException) {
        printf( "\n" );
        printf( "*---------------------------------------\n" );
        printf( "An unexpected error has occurred\n" );
        printf( "Address:     0x%p\n", ExceptionRecord->ExceptionAddress );
        printf( "Error code:  0x%08x\n", ExceptionRecord->ExceptionCode );
        if (!FirstChance) {
            printf( "Second chance!\n");
        }
        printf( "*---------------------------------------\n" );
        PrintRegisters();
        PrintOneInstruction( hProcess, (ULONG_PTR)ExceptionRecord->ExceptionAddress );
    }

    if (BreakInNow) {
        BreakInNow = FALSE;
        printf( "*** Initial breakpoint\n\n" );
    }

    //
    // check to see if any modules need symbols loading
    //
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress && !DllList[i].Unloaded) {
            IMAGEHLP_MODULE ModuleInfo;
            if (!SymGetModuleInfo( hProcess, DllList[i].BaseAddress, &ModuleInfo )) {
                if (ThisProcess) {
                    printf( "loading 0x%08x %s\n",
                        DllList[i].BaseAddress,
                        DllList[i].Name
                        );
                    LoadSymbols(
                        ThisProcess,
                        &DllList[i],
                        NULL
                        );
                }
            }
        }
    }

    CurrProcess = hProcess;
    if (InitialCommand) {
        strcpy( CmdBuf, InitialCommand );
    }
    while( TRUE ) {
retry:
        if (!InitialCommand) {
            printf( "ApiMon> " );
            if (scanf( "%[^\n]", CmdBuf ) != 1) {
                printf( "****>>> invalid command\n" );
                goto retry;
            }
            getchar();
        }

        LPSTR p = CmdBuf;

        while (p[0]) {
            LPSTR s = p;
            while (*s) {
                if (*s == '\"') {
                    s += 1;
                    while (*s && *s != '\"') {
                        s += 1;
                    }
                    if (*s == '\"') {
                        s += 1;
                    }
                }
                if (*s == ';') {
                    break;
                }
                s += 1;
            }
            if (*s == ';') {
                s[0] = 0;
            } else {
                s = NULL;
            }

            switch( tolower(p[0]) ) {
                case 'q':
                    ExitProcess( 0 );
                    break;

                case 'g':
                    ContinueStatus = DBG_CONTINUE;
                    goto exit;

                case 'k':
                    CmdStackTrace( p, hProcess, hThread, ExceptionRecord );
                    break;

                case 'd':
                    CmdDisplayMemory( p, hProcess, hThread, ExceptionRecord );
                    break;

                case 'r':
                    if (p[1] == 't') {
                        PrintRegistersFlag = !PrintRegistersFlag;
                    }
                    CmdDisplayRegisters( p, hProcess, hThread, ExceptionRecord );
                    break;

                case 'u':
                    CmdDisplayCode( p, hProcess, hThread, ExceptionRecord );
                    break;

                case 'b':
                    CmdBreakPoint( p, hProcess, hThread, ExceptionRecord );
                    break;

                case 'l':
                    if (tolower(p[1]) == 'm') {
                        CmdDisplayModules( p, hProcess, hThread, ExceptionRecord );
                    } else if (tolower(p[1]) == 'n') {
                        CmdListNear( p, hProcess, hThread, ExceptionRecord );
                    } else {
                        goto invalid_command;
                    }
                    break;

                case 't':
                    if (p[1] == 'r') {
                        PrintRegistersFlag = !PrintRegistersFlag;
                    }
                    if (CmdTrace( p, hProcess, hThread, ExceptionRecord )) {
                        ContinueStatus = DBG_CONTINUE;
                        Stepped = TRUE;
                        goto exit;
                    }
                    break;

                case 'p':
                    if (p[1] == 'r') {
                        PrintRegistersFlag = !PrintRegistersFlag;
                    }
                    if (CmdStep( p, hProcess, hThread, ExceptionRecord )) {
                        ContinueStatus = DBG_CONTINUE;
                        Stepped = TRUE;
                        goto exit;
                    }
                    break;

                case 'h':
                    if (tolower(p[1]) == 'e' && tolower(p[2]) == 'l' && tolower(p[3]) == 'p') {
                        CmdDisplayHelp( p, hProcess, hThread, ExceptionRecord );
                    }
                    break;

                case '?':
                    {
                        ULONG_PTR val = GetExpression( p+1 );
                        if (!ExprError) {
                            printf( "Evaluate expression: %d = %p\n", val, (PVOID)val );
                        }
                    }
                    break;

                default:
invalid_command:
                    printf( "****>>> invalid command\n" );
                    break;
            }
            if (s) {
                p = s + 1;
            } else {
                p += strlen(p);
            }
        }
    }

exit:

    return ContinueStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\debug.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debug.cpp

Abstract:

    This module contains all debug interfaces.

Author:

    Wesley Witt (wesw) July-11-1993

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop


extern HANDLE       ReleaseDebugeeEvent;
extern PDLL_INFO    DllList;
extern PVOID        MemPtr;
extern HANDLE       BreakinEvent;
extern HWND         hwndFrame;
extern BOOL         BreakInNow;
extern BOOL         StopOnFirstChance;
extern CONTEXT      CurrContext;

extern "C" {
    extern LPDWORD  ApiOffset;
    extern LPDWORD  ApiStrings;
    extern LPDWORD  ApiCount;
    extern BOOL     RunningOnNT;
}


PROCESS_INFO        ProcessHead;
ULONG               BpSize = BP_SIZE;
ULONG               BpInstr = BP_INSTR;
HANDLE              CurrProcess;
BOOL                DebugeeActive;
ULONG_PTR           CreateHeapAddr;
ULONG               ReDirectIat;
HANDLE              hProcessWs;



HANDLE
StartDebuggee(
    LPSTR ProgName
    );

ULONG_PTR
CreateTrojanHorse(
    PUCHAR  Text,
    ULONG_PTR   ExceptionAddress
    );

DWORD
HandleBreakpoint(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord
    );

DWORD
HandleSingleStep(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord
    );

DWORD
BreakinBpHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    );

DWORD
CreateHeapHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    );

DWORD
UserBpHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    );

BOOL
GetImageName(
    PPROCESS_INFO   ThisProcess,
    ULONG_PTR       ImageBase,
    PVOID           ImageNamePtr,
    LPSTR           ImageName,
    DWORD           ImageNameLength
    );

BOOL
SymEnumFunction(
    LPSTR               SymName,
    DWORD_PTR           Address,
    DWORD               Size,
    PSYMBOL_ENUM_CXT    Cxt
    );

ULONG
AddApisForDll(
    PPROCESS_INFO       ThisProcess,
    PDLL_INFO           DllInfo
    );

BOOL
InstanciateAllBreakpoints(
    PPROCESS_INFO   ThisProcess
    );


BOOL __inline
IsKnownApi(
    LPSTR ApiName
    )
{
    // If none are known then all are traced
    if (KnownApis[0] == 0)
        return TRUE;

    LPSTR p = KnownApis;
    while( *p ) {
        if (_stricmp( ApiName, p ) == 0) {
            return TRUE;
        }
        p += (strlen(p) + 1);
    }

    return FALSE;
}


BOOL __inline
IsKnownDll(
    LPSTR DllName
    )
{
    LPSTR p = ApiMonOptions.KnownDlls;
    while( *p ) {
        if (_stricmp( DllName, p ) == 0) {
            return TRUE;
        }
        p += (strlen(p) + 1);
    }
    return FALSE;
}

int __cdecl
ApiInfoSortRoutine(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1 = (PAPI_INFO) e1;
    PAPI_INFO p2 = (PAPI_INFO) e2;

    if ( p1 && p2 ) {
        if (p1->Address < p2->Address) {
            return -1;
        } else if (p1->Address == p2->Address) {
            return 0;
        } else {
            return 1;
        }
    } else {
        return 1;
    }
}


DWORD
DebuggerThread(
    LPSTR  CmdLine
    )
{
    DEBUG_EVENT         de;
    ULONG               ContinueStatus;
    ULONG               i;
    BOOL                FirstProcess = TRUE;
    PPROCESS_INFO       ThisProcess = NULL;
    PTHREAD_INFO        ThisThread = NULL;
    WCHAR               UnicodeBuf[256];
    CHAR                AsciiBuf[256];
    CHAR                DllName[_MAX_PATH];
    CHAR                Ext[_MAX_EXT];
    ULONG               cb;
    PDLL_INFO           DllInfo;
    IMAGE_DOS_HEADER    dh;
    IMAGE_NT_HEADERS    nh;
    DWORD               DllSize;
    HANDLE              hProcess;
    ULONG_PTR           ImageBase;
    BOOL                SymsLoaded;
    PAPI_INFO           ApiInfo;

    hProcess = StartDebuggee( CmdLine );
    if (!hProcess) {
        goto exit;
    }
    hProcessWs = hProcess;

    DebugeeActive = TRUE;

    CreateHeapAddr = (ULONG_PTR)GetProcAddress( GetModuleHandle( NTDLL ), CREATEHEAP );

    if (BreakInNow) {
        CreateDebuggerConsole();
    }

    while (TRUE) {
        if (!WaitForDebugEvent( &de, 100 )) {
            if (WaitForSingleObject( BreakinEvent, 0 ) == WAIT_OBJECT_0) {
                ResetEvent( BreakinEvent );
                SuspendAllThreads( ThisProcess, NULL );
                CONTEXT Context;
                if (ThisThread && ThisThread->hThread) {
                    GetRegContext( ThisThread->hThread, &Context );
                    PBREAKPOINT_INFO bp = SetBreakpoint(
                        ThisProcess,
                        (DWORD_PTR)Context.PC_REG,
                        0,
                        NULL,
                        BreakinBpHandler
                        );
                    if (!bp) {
                        PopUpMsg( "could not break into process" );
                    }
                }
                ResumeAllThreads( ThisProcess, NULL );
            }
            continue;
        }

        ThisProcess = &ProcessHead;
        while (ThisProcess->Next) {
            if (ThisProcess->ProcessId == de.dwProcessId) {
                break;
            }
            ThisProcess = ThisProcess->Next;
        }
        if (ThisProcess->ProcessId != de.dwProcessId) {
            ThisProcess->Next = (PPROCESS_INFO) MemAlloc( sizeof(PROCESS_INFO) );
            ThisProcess = ThisProcess->Next;
            ThisProcess->ProcessId = de.dwProcessId;
        }
        ThisThread = &ThisProcess->ThreadInfo;
        while( ThisThread->Next ) {
            if (ThisThread->ThreadId == de.dwThreadId) {
                break;
            }
            ThisThread = ThisThread->Next;
        }
        if (ThisThread->ThreadId != de.dwThreadId) {
            ThisThread->Next = (PTHREAD_INFO) MemAlloc( sizeof(THREAD_INFO) );
            ThisThread = ThisThread->Next;
            ThisThread->ThreadId = de.dwThreadId;
        }

        CurrProcess = ThisProcess->hProcess;

        if (ThisThread->hThread) {
            GetRegContext( ThisThread->hThread, &CurrContext );
        }

        ContinueStatus = DBG_CONTINUE;
        switch (de.dwDebugEventCode) {
            case EXCEPTION_DEBUG_EVENT:
                if ((!ThisProcess->SeenLdrBp) && (BreakInNow)) {
                    ContinueStatus = ConsoleDebugger(
                        ThisThread->hProcess,
                        ThisThread->hThread,
                        &de.u.Exception.ExceptionRecord,
                        de.u.Exception.dwFirstChance,
                        FALSE,
                        NULL
                        );
                }
                if (de.u.Exception.ExceptionRecord.ExceptionCode == STATUS_BREAKPOINT) {
                    ContinueStatus = HandleBreakpoint(
                        ThisProcess,
                        ThisThread,
                        &de.u.Exception.ExceptionRecord
                        );
                    if (!ContinueStatus) {
                        ContinueStatus = ConsoleDebugger(
                            ThisThread->hProcess,
                            ThisThread->hThread,
                            &de.u.Exception.ExceptionRecord,
                            de.u.Exception.dwFirstChance,
                            TRUE,
                            NULL
                            );
                    }
                } else if (de.u.Exception.ExceptionRecord.ExceptionCode == STATUS_SINGLE_STEP) {
                    ContinueStatus = HandleSingleStep(
                        ThisProcess,
                        ThisThread,
                        &de.u.Exception.ExceptionRecord
                        );
                } else {
                    if (de.u.Exception.dwFirstChance && (!StopOnFirstChance)) {
                        ContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
                        break;
                    }
                    ContinueStatus = ConsoleDebugger(
                        ThisThread->hProcess,
                        ThisThread->hThread,
                        &de.u.Exception.ExceptionRecord,
                        de.u.Exception.dwFirstChance,
                        TRUE,
                        NULL
                        );
                }
                if (!ThisProcess->SeenLdrBp) {
                    ThisProcess->SeenLdrBp = TRUE;
                    SetEvent( ReleaseDebugeeEvent );
                }
                break;

            case CREATE_THREAD_DEBUG_EVENT:
                ThisThread->hProcess    = ThisProcess->hProcess;
                ThisThread->hThread     = de.u.CreateThread.hThread;
                ThisThread->ThreadId    = de.dwThreadId;
                printf( "thread create %x\n", de.dwThreadId );
                OutputDebugString("ThreadCreate\n");
                break;

            case CREATE_PROCESS_DEBUG_EVENT:
                //
                // setup the process structure
                //
                ThisProcess->hProcess     = de.u.CreateProcessInfo.hProcess;
                ThisProcess->SeenLdrBp    = FALSE;
                ThisProcess->FirstProcess = FirstProcess;
                ThisProcess->LoadAddress  = (DWORD_PTR)de.u.CreateProcessInfo.lpBaseOfImage;
                ThisThread->hProcess      = ThisProcess->hProcess;
                ThisThread->hThread       = de.u.CreateProcessInfo.hThread;
                ThisThread->ThreadId      = de.dwThreadId;
                OutputDebugString("ProcessCreate\n");
                FirstProcess = FALSE;

                //
                // initialize the symbol handler
                //
                SymSetOptions( SYMOPT_UNDNAME | SYMOPT_CASE_INSENSITIVE );
                SymInitialize( ThisProcess->hProcess, ApiMonOptions.SymbolPath, FALSE );
                if (ApiMonOptions.MonitorPageFaults) {
                    //
                    // for WIN95 only, we need to call the hack-o-ramma
                    // api in psapi.dll so the the working set apis function properly
                    //
                    if (!RunningOnNT) {
                        if (pRecordProcessInfo) {
                            pRecordProcessInfo( hProcessWs, ThisProcess->ProcessId );
                        }
                    }
                    if (pInitializeProcessForWsWatch) {
                        pInitializeProcessForWsWatch( hProcessWs );
                    }
                }

                CurrProcess = ThisProcess->hProcess;
                //
                // load the image
                //
                ImageBase = ThisProcess->LoadAddress;
                DllName[0] = '\0';
                strncat( DllName, ApiMonOptions.ProgName, sizeof(DllName)/sizeof(DllName[0]) - 1);
                printf( "process create %x\n", de.dwProcessId );
                printf( "thread create %x\n", de.dwThreadId );
                goto LoadImage;

            case EXIT_THREAD_DEBUG_EVENT:
                break;

            case EXIT_PROCESS_DEBUG_EVENT:
                PopUpMsg(
                    "The monitored process has exited\nExit code = %d",
                    de.u.ExitProcess.dwExitCode
                    );
                if (!ThisProcess->FirstProcess) {
                    ZeroMemory( ThisProcess, sizeof(PROCESS_INFO) );
                    break;
                }
                ZeroMemory( ThisProcess, sizeof(PROCESS_INFO) );
                goto exit;

            case LOAD_DLL_DEBUG_EVENT:
                ImageBase = (ULONG_PTR)de.u.LoadDll.lpBaseOfDll;

                GetImageName(
                    ThisProcess,
                    ImageBase,
                    de.u.LoadDll.lpImageName,
                    AsciiBuf,
                    sizeof(AsciiBuf)
                    );

                _splitpath( AsciiBuf, NULL, NULL, DllName, Ext );
                strncat( DllName, Ext, (sizeof(DllName)/sizeof(DllName[0])) - strlen(DllName) );

LoadImage:
                DllInfo = AddDllToList( ThisThread, ImageBase, DllName, 0 );
                if (DllInfo) {
                    if (_stricmp(DllName,TROJANDLL)==0) {
                        DllInfo->Snapped = TRUE;
                        if (!ThisProcess->SeenLdrBp) {
                            //
                            // the debuggee is compiled with -Gh
                            // and has linked APIDLL statically
                            //
                            HMODULE hMod = LoadLibraryEx(
                                TROJANDLL,
                                NULL,
                                DONT_RESOLVE_DLL_REFERENCES
                                );
                            LPVOID StaticLink = (LPVOID) GetProcAddress(
                                hMod,
                                "StaticLink"
                                );
                            FreeLibrary( hMod );
                            if (StaticLink) {
                                ThisProcess->StaticLink = TRUE;
                                WriteMemory(
                                    ThisProcess->hProcess,
                                    StaticLink,
                                    &ThisProcess->StaticLink,
                                    sizeof(ThisProcess->StaticLink)
                                    );
                            }
                        }
                    } else if (DllInfo->Enabled) {
                        AddApisForDll( ThisProcess, DllInfo );
                    }
                }

                if (DllInfo && ApiMonOptions.PreLoadSymbols) {
                    SymsLoaded = LoadSymbols( ThisProcess, DllInfo, de.u.LoadDll.hFile );
                } else {
                    SymsLoaded = FALSE;
                }

                //
                // now sort the api table by address
                //
                ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (ULONG_PTR)DllList);
                qsort( ApiInfo, DllInfo->ApiCount, sizeof(API_INFO), ApiInfoSortRoutine );

                //
                // print a notification to the console debugger
                //
                printf( "Module load: 0x%08x %s\t%s\n",
                    DllInfo->BaseAddress,
                    DllInfo->Name,
                    SymsLoaded ? "(Symbols Loaded)" : "(Symbols NOT Loaded)"
                    );

                InstanciateAllBreakpoints( ThisProcess );

                break;

            case UNLOAD_DLL_DEBUG_EVENT:
                for (i=0; i<MAX_DLLS; i++) {
                    if (DllList[i].BaseAddress == (ULONG_PTR)de.u.UnloadDll.lpBaseOfDll) {
                        DllList[i].Unloaded = TRUE;
                        DllList[i].Enabled  = FALSE;
                        DllList[i].Snapped  = FALSE;
                        break;
                    }
                }
                break;

            case OUTPUT_DEBUG_STRING_EVENT:
                {
                LPSTR String = (LPSTR) MemAlloc( de.u.DebugString.nDebugStringLength+32 );
                ReadMemory(
                    ThisThread->hProcess,
                    de.u.DebugString.lpDebugStringData,
                    String,
                    de.u.DebugString.nDebugStringLength
                    );
                OutputDebugString( String );
                printf( "%s", String );
                MemFree( String );
                }
                break;

            case RIP_EVENT:
                break;

            default:
                PopUpMsg( "invalid debug event" );
                break;
        }
        ContinueDebugEvent( de.dwProcessId, de.dwThreadId, ContinueStatus );
    }

exit:
    DebugeeActive = FALSE;
    return 0;
}


PDLL_INFO
FindDllByAddress(
    ULONG_PTR DllAddr
    )
{
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress == DllAddr) {
            return &DllList[i];
        }
    }
    return NULL;
}


PDLL_INFO
FindDllByName(
    LPSTR DllName
    )
{
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if (DllList[i].Name[0] &&
            _stricmp( DllList[i].Name, DllName ) == 0) {
                return &DllList[i];
        }
    }
    return NULL;
}


PDLL_INFO
FindAvailDll(
    VOID
    )
{
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if (!DllList[i].BaseAddress) {
            return &DllList[i];
        }
    }
    return NULL;
}


PDLL_INFO
AddDllToList(
    PTHREAD_INFO        ThisThread,
    ULONG_PTR           DllAddr,
    LPSTR               DllName,
    ULONG               DllSize
    )
{
    IMAGE_DOS_HEADER        dh;
    IMAGE_NT_HEADERS        nh;
    ULONG                   i;
    PDLL_INFO               DllInfo;


    //
    // first look to see if the dll is already in the list
    //
    DllInfo = FindDllByAddress( DllAddr );
    if (DllInfo) {
        return DllInfo;
    }

    if (!DllSize) {
        //
        // read the pe image headers to get the image size
        //
        if (!ReadMemory(
            ThisThread->hProcess,
            (PVOID) DllAddr,
            &dh,
            sizeof(dh)
            )) {
                return NULL;
        }

        if (dh.e_magic == IMAGE_DOS_SIGNATURE) {
            if (!ReadMemory(
                ThisThread->hProcess,
                (PVOID)(DllAddr + dh.e_lfanew),
                &nh,
                sizeof(nh)
                )) {
                    return NULL;
            }
            DllSize = nh.OptionalHeader.SizeOfImage;
        } else {
            DllSize = 0;
        }
    }

    DllInfo = FindAvailDll();
    if (!DllInfo) {
        return NULL;
    }

    DllInfo->Size = DllSize;
    strncat( DllInfo->Name, DllName, MAX_NAME_SZ-1 );
    DllInfo->BaseAddress = DllAddr;
    DllInfo->InList = FALSE;
    BOOL KnownDll = IsKnownDll( DllName );
    if (ApiMonOptions.UseKnownDlls) {
        DllInfo->Enabled = KnownDll;
    } else if (ApiMonOptions.ExcludeKnownDlls) {
        if (KnownDll) {
            DllInfo->Enabled = FALSE;
        } else {
            DllInfo->Enabled = TRUE;
        }
    } else {
        DllInfo->Enabled = TRUE;
    }

    return DllInfo;
}

BOOL
LoadSymbols(
    PPROCESS_INFO       ThisProcess,
    PDLL_INFO           DllInfo,
    HANDLE              hFile
    )
{
    if (!DllInfo) {
        return FALSE;
    }

    //
    // load the symbols
    //
    DWORD_PTR SymAddr = SymLoadModule(
        ThisProcess->hProcess,
        hFile,
        DllInfo->Name,
        NULL,
        DllInfo->BaseAddress,
        DllInfo->Size
        );

    if (!SymAddr) {
        //
        // imagehlp does not look along the exe path
        // for the symbols.  we really need to do this
        // because the symbola may still be in the exe
        // and the dir may not be on the symbol search
        // path.  so lets try.
        //
        ULONG cb;
        CHAR buf[MAX_PATH*2];
        if (ApiMonOptions.ProgDir[0]) {
            cb = SearchPath(
                ApiMonOptions.ProgDir,
                DllInfo->Name,
                NULL,
                sizeof(buf),
                buf,
                (LPSTR*)&cb
                );
        } else {
            cb = 0;
        }
        if (!cb) {
            cb = SearchPath(
                NULL,
                DllInfo->Name,
                NULL,
                sizeof(buf),
                buf,
                (LPSTR*)&cb
                );
        }
        if (cb) {
            SymAddr = SymLoadModule(
                ThisProcess->hProcess,
                NULL,
                buf,
                NULL,
                DllInfo->BaseAddress,
                DllInfo->Size
                );
        }
    }

    if (!SymAddr) {
        return FALSE;
    }

    if (ApiMonOptions.MonitorPageFaults || DllInfo->StaticProfile) {
        //
        // add the symbols to the apiinfo table
        //
        DllInfo->ApiCount = 0;
        DllInfo->ApiOffset = *ApiOffset;
        PAPI_INFO ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (ULONG_PTR)DllList);
        SYMBOL_ENUM_CXT Cxt;
        Cxt.ApiInfo = ApiInfo;
        Cxt.DllInfo = DllInfo;
        Cxt.Cnt = 0;

        SymEnumerateSymbols(
            ThisProcess->hProcess,
            DllInfo->BaseAddress,
            (PSYM_ENUMSYMBOLS_CALLBACK)SymEnumFunction,
            &Cxt
            );

        DllInfo->ApiCount = Cxt.Cnt;
        *ApiOffset += (DllInfo->ApiCount * sizeof(API_INFO));
    }

    return TRUE;
}

DWORD
GetApisFromExportsDir(
    PPROCESS_INFO       ThisProcess,
    PDLL_INFO           DllInfo,
    PIMAGE_DOS_HEADER   dh,
    PIMAGE_NT_HEADERS   nh
    )
{
    PIMAGE_SECTION_HEADER   sh       = NULL;
    PULONG                  names    = NULL;
    PULONG                  addrs    = NULL;
    PUSHORT                 ordinals = NULL;
    PUSHORT                 ordidx   = NULL;
    PAPI_INFO               ApiInfo  = NULL;
    LPSTR                   Strings  = NULL;
    ULONG                   cnt      = 0;
    ULONG                   idx      = 0;
    ULONG_PTR               DllOffset;
    IMAGE_EXPORT_DIRECTORY  expdir;
    ULONG                   i;
    ULONG                   j;
    ULONG                   k;
    LPSTR                   p;

    if (!ReadMemory(
        ThisProcess->hProcess,
        (PVOID)(DllInfo->BaseAddress +
            nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress),
        &expdir,
        sizeof(expdir)
        )) {
            goto exit;
    }

    names = (PULONG) MemAlloc( expdir.NumberOfNames * sizeof(ULONG) );
    addrs = (PULONG) MemAlloc( expdir.NumberOfFunctions * sizeof(ULONG) );
    ordinals = (PUSHORT) MemAlloc( expdir.NumberOfNames * sizeof(USHORT) );
    ordidx = (PUSHORT) MemAlloc( expdir.NumberOfFunctions * sizeof(USHORT) );

    if ((!names) || (!addrs) || (!ordinals) || (!ordidx)) {
        goto exit;
    }

    if (!ReadMemory(
        ThisProcess->hProcess,
        (PVOID)(DllInfo->BaseAddress + (ULONG)expdir.AddressOfNames),
        names,
        expdir.NumberOfNames * sizeof(ULONG)
        )) {
            goto exit;
    }

    if (!ReadMemory(
        ThisProcess->hProcess,
        (PVOID)(DllInfo->BaseAddress + (ULONG)expdir.AddressOfFunctions),
        addrs,
        expdir.NumberOfFunctions * sizeof(ULONG)
        )) {
            goto exit;
    }

    if (!ReadMemory(
        ThisProcess->hProcess,
        (PVOID)(DllInfo->BaseAddress + (ULONG)expdir.AddressOfNameOrdinals),
        ordinals,
        expdir.NumberOfNames * sizeof(USHORT)
        )) {
            goto exit;
    }

    //
    // read in the section headers
    //
    sh = (PIMAGE_SECTION_HEADER) MemAlloc(
        nh->FileHeader.NumberOfSections * IMAGE_SIZEOF_SECTION_HEADER
        );
    if (!sh) {
        goto exit;
    }

    if (!ReadMemory(
        ThisProcess->hProcess,
        (PVOID) (DllInfo->BaseAddress +
            dh->e_lfanew +
            FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +
            nh->FileHeader.SizeOfOptionalHeader),
        sh,
        nh->FileHeader.NumberOfSections * IMAGE_SIZEOF_SECTION_HEADER
        )) {
            goto exit;
    }

    //
    // look for the section that the export name strings are in
    //
    for (i=0,k=(DWORD)-1; i<nh->FileHeader.NumberOfSections; i++) {
        if (names[0] >= sh[i].VirtualAddress &&
            names[0] < sh[i].VirtualAddress + sh[i].SizeOfRawData) {
                //
                // found it
                //
                k = i;
                break;
        }
    }
    if (k == (DWORD)-1) {
        //
        // count not find the section
        //
        goto exit;
    }

    Strings = (LPSTR) MemAlloc( sh[k].SizeOfRawData );
    if (!Strings) {
        goto exit;
    }

    //
    // read in the strings
    //
    if (!ReadMemory(
        ThisProcess->hProcess,
        (PVOID)(DllInfo->BaseAddress + sh[k].VirtualAddress),
        Strings,
        sh[k].SizeOfRawData
        )) {
            goto exit;
    }

    DllOffset = (PCHAR)DllInfo - (PCHAR)DllList;

    DllInfo->ApiCount = expdir.NumberOfFunctions;
    DllInfo->ApiOffset = *ApiOffset;
    *ApiOffset += (DllInfo->ApiCount * sizeof(API_INFO));
    ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (ULONG_PTR)DllList);

    if (*ApiCount < MAX_APIS) {
        for (i=0; i<expdir.NumberOfNames; i++) {
            idx = ordinals[i];
            ordidx[idx] = TRUE;
            ApiInfo[i].Count = 0;
            ApiInfo[i].ThunkAddress = 0;
            ApiInfo[i].Address = addrs[idx] + DllInfo->BaseAddress;
            strcpy(
                (LPSTR)((LPSTR)MemPtr+*ApiStrings),
                Strings + names[i] - sh[k].VirtualAddress
                );
            ApiInfo[i].Name = *ApiStrings;
            ApiInfo[i].DllOffset = DllOffset;
            ApiInfo[i].TraceEnabled = IsKnownApi((LPSTR)MemPtr+*ApiStrings);

            *ApiStrings += (strlen((LPSTR)((LPSTR)MemPtr+*ApiStrings)) + 1);
            *ApiCount += 1;
            if (*ApiCount == MAX_APIS) {
                break;
            }
        }
    }
    if (*ApiCount < MAX_APIS) {
        for (i=0,idx=expdir.NumberOfNames; i<expdir.NumberOfFunctions; i++) {
            if (!ordidx[i]) {
                ApiInfo[idx].Count = 0;
                ApiInfo[idx].ThunkAddress = 0;
                ApiInfo[idx].Address = addrs[i] + DllInfo->BaseAddress;
                sprintf(
                    (LPSTR)((LPSTR)MemPtr+*ApiStrings),
                    "Ordinal%d",
                    i
                    );
                ApiInfo[idx].Name = *ApiStrings;
                ApiInfo[idx].DllOffset = DllOffset;
                ApiInfo[idx].TraceEnabled = IsKnownApi((LPSTR)MemPtr+*ApiStrings);

                *ApiStrings += (strlen((LPSTR)((LPSTR)MemPtr+*ApiStrings)) + 1);
                *ApiCount += 1;
                if (*ApiCount == MAX_APIS) {
                    break;
                }
                idx += 1;
            }
        }
    }
    cnt = DllInfo->ApiCount;

exit:
    MemFree( sh );
    MemFree( Strings );
    MemFree( names );
    MemFree( addrs );
    MemFree( ordinals );
    MemFree( ordidx );

    return cnt;
}

DWORD
GetApisFromImportsDir(
    PPROCESS_INFO       ThisProcess,
    PDLL_INFO           DllInfo,
    PIMAGE_DOS_HEADER   dh,
    PIMAGE_NT_HEADERS   nh
    )
{
    ULONG_PTR               SeekPos;
    IMAGE_IMPORT_DESCRIPTOR desc;
    CHAR                    DllName[MAX_PATH];

    //
    // check to see if this dll imports from apidll.dll
    // if it does then we know that this dll was compiled
    // with the -Gh switch turned on.  if this is the case
    // then we must enumerate the symbols from the public
    // symbol table instead of the exports directory.
    //

    if (!nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress)
        return 0;

    SeekPos = DllInfo->BaseAddress +
        nh->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

    while( TRUE ) {
        if (!ReadMemory(
            ThisProcess->hProcess,
            (PVOID)(SeekPos),
            &desc,
            sizeof(desc)
            )) {
                return 0;
        }

        SeekPos += sizeof(IMAGE_IMPORT_DESCRIPTOR);

        if ((desc.Characteristics == 0) && (desc.Name == 0) && (desc.FirstThunk == 0)) {
            break;
        }

        if (!ReadMemory(
            ThisProcess->hProcess,
            (PVOID)(DllInfo->BaseAddress + desc.Name),
            DllName,
            sizeof(DllName)
            )) {
                return 0;
        }

        if (_stricmp( DllName, TROJANDLL ) == 0) {
            DllInfo->StaticProfile = TRUE;
            return 0;
        }
    }

    return 0;
}

ULONG
AddApisForDll(
    PPROCESS_INFO       ThisProcess,
    PDLL_INFO           DllInfo
    )
{
    IMAGE_DOS_HEADER        dh;
    IMAGE_NT_HEADERS        nh;
    ULONG                   cnt = 0;


    if (*ApiCount == MAX_APIS) {
        return 0;
    }

    if (!ReadMemory(
        ThisProcess->hProcess,
        (PVOID)DllInfo->BaseAddress,
        &dh,
        sizeof(dh)
        )) {
            return 0;
    }

    if (dh.e_magic != IMAGE_DOS_SIGNATURE) {
        return 0;
    }

    if (!ReadMemory(
        ThisProcess->hProcess,
        (PVOID)(DllInfo->BaseAddress + dh.e_lfanew),
        &nh,
        sizeof(nh)
        )) {
            return 0;
    }

    if (!nh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) {
        cnt = GetApisFromImportsDir(
            ThisProcess,
            DllInfo,
            &dh,
            &nh
            );
        return cnt;
    }

    cnt = GetApisFromImportsDir(
        ThisProcess,
        DllInfo,
        &dh,
        &nh
        );
    if (cnt) {
        return cnt;
    }

    cnt = GetApisFromExportsDir(
        ThisProcess,
        DllInfo,
        &dh,
        &nh
        );
    return cnt;
}

BOOL
SymEnumFunction(
    LPSTR               SymName,
    DWORD_PTR           Address,
    DWORD               Size,
    PSYMBOL_ENUM_CXT    Cxt
    )
{
    if (*ApiCount == MAX_APIS) {
        return FALSE;
    }

    PAPI_INFO ApiInfo = &Cxt->ApiInfo[Cxt->Cnt];

    ApiInfo->Count = 0;
    ApiInfo->ThunkAddress = 0;
    ApiInfo->Address = Address;
    ApiInfo->Size = Size;
    strcpy( (LPSTR)((LPSTR)MemPtr+*ApiStrings), SymName );
    ApiInfo->Name = *ApiStrings;
    *ApiStrings += (strlen(SymName) + 1);
    Cxt->Cnt += 1;
    *ApiCount += 1;

    return TRUE;
}

BOOL
GetImageName(
    PPROCESS_INFO   ThisProcess,
    ULONG_PTR       ImageBase,
    PVOID           ImageNamePtr,
    LPSTR           ImageName,
    DWORD           ImageNameLength
    )
{
    DWORD_PTR           i;
    WCHAR               UnicodeBuf[256];
    CHAR                DllName[32];
    CHAR                Ext[_MAX_EXT];
    ULONG               cb;

    if (!ReadMemory(
        ThisProcess->hProcess,
        ImageNamePtr,
        &i,
        sizeof(i)
        )) {
            goto GetFromExports;
    }
    if (!ReadMemory(
        ThisProcess->hProcess,
        (LPVOID)i,
        UnicodeBuf,
        sizeof(UnicodeBuf)
        )) {
            goto GetFromExports;
    }
    ZeroMemory( ImageName, ImageNameLength );
    if (RunningOnNT) {
        WideCharToMultiByte(
            CP_ACP,
            0,
            UnicodeBuf,
            wcslen(UnicodeBuf),
            ImageName,
            ImageNameLength,
            NULL,
            NULL
            );
        if (!strlen(ImageName)) {
            goto GetFromExports;
        }
    } else {
        strcpy( ImageName, (LPSTR)UnicodeBuf );
    }

    return TRUE;

GetFromExports:

    IMAGE_DOS_HEADER dh;

    if (!ReadMemory(
        ThisProcess->hProcess,
        (LPVOID)ImageBase,
        &dh,
        sizeof(IMAGE_DOS_HEADER)
        )) {
            return FALSE;
    }

    if (dh.e_magic != IMAGE_DOS_SIGNATURE) {
        return FALSE;
    }

    IMAGE_NT_HEADERS nh;

    if (!ReadMemory(
        ThisProcess->hProcess,
        (LPVOID)(ImageBase + dh.e_lfanew),
        &nh,
        sizeof(IMAGE_NT_HEADERS)
        )) {
            return FALSE;
    }

    if (!nh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) {
        return FALSE;
    }

    IMAGE_EXPORT_DIRECTORY expdir;

    if (!ReadMemory(
        ThisProcess->hProcess,
        (LPVOID)(ImageBase +
                 nh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress),
        &expdir,
        sizeof(IMAGE_EXPORT_DIRECTORY)
        )) {
            return FALSE;
    }

    if (!ReadMemory(
        ThisProcess->hProcess,
        (LPVOID)(ImageBase + expdir.Name),
        ImageName,
        ImageNameLength
        )) {
            return FALSE;
    }

    return TRUE;
}

HANDLE
StartDebuggee(
    LPSTR ProgName
    )
{
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION ProcessInformation;


    ZeroMemory( &StartupInfo, sizeof(StartupInfo) );
    StartupInfo.cb = sizeof(StartupInfo);

    BOOL rval = CreateProcess(
        NULL,
        ProgName,
        NULL,
        NULL,
        FALSE,
        DEBUG_ONLY_THIS_PROCESS | CREATE_SEPARATE_WOW_VDM,
        NULL,
        NULL,
        &StartupInfo,
        &ProcessInformation
        );
    if (!rval) {
        return NULL;
    }

    return ProcessInformation.hProcess;
}

BOOL
ResumeAllThreads(
    PPROCESS_INFO   ThisProcess,
    PTHREAD_INFO    ExceptionThread
    )
{
    PTHREAD_INFO ThisThread = &ThisProcess->ThreadInfo;
    while( ThisThread->Next ) {
        if (ExceptionThread && ExceptionThread->hThread == ThisThread->hThread) {
            ThisThread = ThisThread->Next;
            continue;
        }
        ResumeThread( ThisThread->hThread );
        ThisThread = ThisThread->Next;
    }
    return TRUE;
}

BOOL
SuspendAllThreads(
    PPROCESS_INFO   ThisProcess,
    PTHREAD_INFO    ExceptionThread
    )
{
    PTHREAD_INFO ThisThread = &ThisProcess->ThreadInfo;
    while( ThisThread->Next ) {
        if (ExceptionThread && ExceptionThread->hThread == ThisThread->hThread) {
            ThisThread = ThisThread->Next;
            continue;
        }
        SuspendThread( ThisThread->hThread );
        ThisThread = ThisThread->Next;
    }
    return TRUE;
}

PBREAKPOINT_INFO
GetAvailBreakpoint(
    PPROCESS_INFO   ThisProcess
    )
{
    for (ULONG i=0; i<MAX_BREAKPOINTS; i++) {
        if (ThisProcess->Breakpoints[i].Address == 0) {
            ZeroMemory( &ThisProcess->Breakpoints[i], sizeof(BREAKPOINT_INFO) );
            return &ThisProcess->Breakpoints[i];
        }
    }
    return NULL;
}

PBREAKPOINT_INFO
SetBreakpoint(
    PPROCESS_INFO   ThisProcess,
    DWORD_PTR       Address,
    DWORD           Flags,
    LPSTR           SymName,
    PBP_HANDLER     Handler
    )
{
    if (Address) {
        for (ULONG i=0; i<MAX_BREAKPOINTS; i++) {
            if (ThisProcess->Breakpoints[i].Address == Address) {
                return &ThisProcess->Breakpoints[i];
            }
        }
    }

    PBREAKPOINT_INFO bp = GetAvailBreakpoint( ThisProcess );
    if (!bp) {
        return NULL;
    }

    bp->Address = Address;
    bp->Handler = Handler;
    bp->Flags   = Flags;

    if (Flags & BPF_UNINSTANCIATED) {
        if (SymName) {
            bp->SymName = _strdup( SymName );
        }
        bp->Address = 0xffffffff;
    } else {
        ReadMemory(
            ThisProcess->hProcess,
            (PVOID)Address,
            &bp->OriginalInstr,
            BpSize
            );
        WriteMemory(
            ThisProcess->hProcess,
            (PVOID)Address,
            &BpInstr,
            BpSize
            );
    }

    return bp;
}

BOOL
ClearBreakpoint(
    PPROCESS_INFO       ThisProcess,
    PBREAKPOINT_INFO    bp
    )
{
    if ((!(bp->Flags & BPF_UNINSTANCIATED)) && (!(bp->Flags & BPF_TRACE))) {
        WriteMemory(
            ThisProcess->hProcess,
            (PVOID) bp->Address,
            &bp->OriginalInstr,
            BpSize
            );
    }

    ZeroMemory( bp, sizeof(BREAKPOINT_INFO) );

    return TRUE;
}

BOOL
InstanciateBreakpoint(
    PPROCESS_INFO       ThisProcess,
    PBREAKPOINT_INFO    bp
    )
{
    if ((!bp) || (!bp->SymName) || (!(bp->Flags&BPF_UNINSTANCIATED))) {
        return FALSE;
    }

    ULONG_PTR Address;
    GetAddress( bp->SymName, &Address );
    if (!Address) {
        return FALSE;
    }

    bp->Address = Address;
    bp->Flags &= ~BPF_UNINSTANCIATED;
    free( bp->SymName );
    bp->SymName = NULL;

    ReadMemory(
        ThisProcess->hProcess,
        (PVOID)Address,
        &bp->OriginalInstr,
        BpSize
        );
    WriteMemory(
        ThisProcess->hProcess,
        (PVOID)Address,
        &BpInstr,
        BpSize
        );

    if (bp->Number) {
        printf( "Breakpoint #%d instanciated\n", bp->Number );
    }

    return TRUE;
}

BOOL
InstanciateAllBreakpoints(
    PPROCESS_INFO   ThisProcess
    )
{
    BOOL rval = FALSE;
    for (ULONG i=0; i<MAX_BREAKPOINTS; i++) {
        if (ThisProcess->Breakpoints[i].Flags & BPF_UNINSTANCIATED) {
            InstanciateBreakpoint( ThisProcess, &ThisProcess->Breakpoints[i] );
            rval = TRUE;
        }
    }
    return rval;
}

DWORD
BreakinBpHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    )
{
    ULONG ContinueStatus = ConsoleDebugger(
        ThisThread->hProcess,
        ThisThread->hThread,
        ExceptionRecord,
        TRUE,
        FALSE,
        NULL
        );
    ZeroMemory( BreakpointInfo, sizeof(BREAKPOINT_INFO) );
    return ContinueStatus;
}

DWORD
TrojanHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    )
{
    WriteMemory(
        ThisThread->hProcess,
        (PVOID)ThisProcess->TrojanAddress,
        (PVOID)BreakpointInfo->Text,
        BreakpointInfo->TextSize
        );
    MemFree( BreakpointInfo->Text );

    CONTEXT Context;
    GetRegContext( ThisThread->hThread, &Context );

    if (Context.RV_REG == 0) {
        PopUpMsg( "Could not load dll into program" );
        return 0;
    }

    SetRegContext( ThisThread->hThread, &BreakpointInfo->Context );

    PostMessage( hwndFrame, WM_TROJAN_COMPLETE, 0, 0 );

    ZeroMemory( BreakpointInfo, sizeof(BREAKPOINT_INFO) );

    return DBG_CONTINUE;
}

DWORD
DisableHeapHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    )
{
    CONTEXT Context;
    GetRegContext( ThisThread->hThread, &Context );

    DisableHeapChecking( ThisProcess->hProcess, (PVOID)Context.RV_REG );

    ResumeAllThreads( ThisProcess, ThisThread );

    if (CreateHeapAddr) {
        if (!SetBreakpoint( ThisProcess, CreateHeapAddr, 0, NULL, CreateHeapHandler )) {
            PopUpMsg( "Could not set breakpoint @ RtlCreateHeap" );
        }
    }

    ZeroMemory( BreakpointInfo, sizeof(BREAKPOINT_INFO) );
    return DBG_CONTINUE;
}

DWORD
CreateHeapHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    )
{
    CONTEXT Context;
    GetRegContext( ThisThread->hThread, &Context );

    ULONG_PTR RetAddr;

    ReadMemory(
        ThisThread->hProcess,
        (PVOID)Context.STK_REG,
        &RetAddr,
        sizeof(RetAddr)
        );

    SetBreakpoint(
        ThisProcess,
        RetAddr,
        0,
        NULL,
        DisableHeapHandler
        );

    ResumeAllThreads( ThisProcess, ThisThread );

    ZeroMemory( BreakpointInfo, sizeof(BREAKPOINT_INFO) );
    return DBG_CONTINUE;
}

DWORD
EntryPointHandler(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord,
    PBREAKPOINT_INFO    BreakpointInfo
    )
{
    PBREAKPOINT_INFO bp = GetAvailBreakpoint( ThisProcess );
    if (!bp) {
        return DBG_EXCEPTION_NOT_HANDLED;
    }

    bp->Handler = TrojanHandler;

    bp->TextSize = PAGE_SIZE;
    bp->Text = MemAlloc( bp->TextSize );
    if (!bp->Text)
        return DBG_EXCEPTION_NOT_HANDLED;

    //
    // save the process memory
    //
    DWORD_PTR TrojanAddress = PAGE_ALIGN( ExceptionRecord->ExceptionAddress );
    ThisProcess->TrojanAddress = TrojanAddress;

    ReadMemory(
        ThisThread->hProcess,
        (PVOID)TrojanAddress,
        bp->Text,
        bp->TextSize
        );

    PUCHAR Text = (PUCHAR) MemAlloc( bp->TextSize );
    if (!Text)
        return DBG_EXCEPTION_NOT_HANDLED;

    ZeroMemory( Text, bp->TextSize );

    bp->Address = CreateTrojanHorse(Text, TrojanAddress );

    GetRegContext( ThisThread->hThread, &bp->Context );
    DWORD_PTR savedPC = (DWORD_PTR)bp->Context.PC_REG;
    bp->Context.PC_REG = TrojanAddress;
    SetRegContext( ThisThread->hThread, &bp->Context );
    bp->Context.PC_REG = savedPC;

    WriteMemory(
        ThisThread->hProcess,
        (PVOID)TrojanAddress,
        (PVOID)Text,
        bp->TextSize
        );
    //printf( "*** trojan written at 0x%08x\n", TrojanAddress );

    FlushInstructionCache( ThisThread->hProcess, (PVOID)TrojanAddress, bp->TextSize );

    MemFree( Text );

    if (ApiMonOptions.HeapChecking && CreateHeapAddr) {
        PBREAKPOINT_INFO bp2 = SetBreakpoint(
            ThisProcess,
            CreateHeapAddr,
            0,
            NULL,
            CreateHeapHandler
            );
        if (!bp2) {
            PopUpMsg( "Could not set breakpoint @ RtlCreateHeap" );
        }
    }

    ZeroMemory( BreakpointInfo, sizeof(BREAKPOINT_INFO) );

    return DBG_CONTINUE;
}

DWORD
HandleSingleStep(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord
    )
{
    ULONG ContinueStatus = DBG_CONTINUE;

    for (ULONG i=0; i<MAX_BREAKPOINTS; i++) {
        if (ThisProcess->Breakpoints[i].Flags & BPF_TRACE) {
            if (ThisProcess->Breakpoints[i].Handler) {
                ContinueStatus = ThisProcess->Breakpoints[i].Handler(
                    ThisProcess,
                    ThisThread,
                    ExceptionRecord,
                    &ThisProcess->Breakpoints[i]
                    );
                break;
            }
        }
    }

    return ContinueStatus;
}

DWORD
HandleBreakpoint(
    PPROCESS_INFO       ThisProcess,
    PTHREAD_INFO        ThisThread,
    PEXCEPTION_RECORD   ExceptionRecord
    )
{
    ULONG ContinueStatus = DBG_CONTINUE;
    ULONG Instr = 0;
    ULONG cb;
    PUCHAR Text;

    if (!ThisProcess->SeenLdrBp) {
        //
        // this is the loader breakpoint
        //
        if (ThisProcess->StaticLink) {
            PostMessage( hwndFrame, WM_TROJAN_COMPLETE, 0, 0 );
        } else {
            IMAGE_DOS_HEADER dh;
            IMAGE_NT_HEADERS nh;
            DWORD_PTR address = ThisProcess->LoadAddress;
            ReadMemory(
                ThisThread->hProcess,
                (PVOID)address,
                &dh,
                sizeof(dh)
                );
            if (dh.e_magic != IMAGE_DOS_SIGNATURE) {
                ContinueStatus = DBG_EXCEPTION_NOT_HANDLED;
                goto exit;
            }
            address += dh.e_lfanew;
            ReadMemory(
                ThisThread->hProcess,
                (PVOID)address,
                &nh,
                sizeof(nh)
                );

            ThisProcess->EntryPoint =
                ThisProcess->LoadAddress + nh.OptionalHeader.AddressOfEntryPoint;

#ifndef _M_IX86
            ThisProcess->EntryPoint += BP_SIZE;
#endif

            SetBreakpoint(
                ThisProcess,
                ThisProcess->EntryPoint,
                0,
                NULL,
                EntryPointHandler
                );
        }
    } else {
        for (ULONG i=0; i<MAX_BREAKPOINTS; i++) {
            if (ThisProcess->Breakpoints[i].Address == (ULONG_PTR)ExceptionRecord->ExceptionAddress) {
#ifdef _M_IX86
                //
                // reset the pc to re-execute the code - ONLY ON X86!
                //
                CONTEXT Context;
                GetRegContext( ThisThread->hThread, &Context );
                Context.PC_REG -= BP_SIZE;
                CurrContext.PC_REG -= BP_SIZE;
                SetRegContext( ThisThread->hThread, &Context );
#endif
                //
                // restore the original instruction
                //
                WriteMemory(
                    ThisThread->hProcess,
                    (PVOID)ExceptionRecord->ExceptionAddress,
                    &ThisProcess->Breakpoints[i].OriginalInstr,
                    BpSize
                    );
                //
                // call the assigned handler
                //
                if (ThisProcess->Breakpoints[i].Handler) {
                    ContinueStatus = ThisProcess->Breakpoints[i].Handler(
                        ThisProcess,
                        ThisThread,
                        ExceptionRecord,
                        &ThisProcess->Breakpoints[i]
                        );
                }
                //
                // continue the debug event
                //
                goto exit;
            }
        }
        ConsoleDebugger(
            ThisThread->hProcess,
            ThisThread->hThread,
            ExceptionRecord,
            TRUE,
            TRUE,
            NULL
            );
    }

    ReadMemory(
        ThisThread->hProcess,
        (PVOID)ExceptionRecord->ExceptionAddress,
        &Instr,
        BP_SIZE
        );
    if (IsBreakpoint(&Instr)) {
        //
        // skip over the hard coded bp
        //
#ifndef _M_IX86
        CONTEXT Context;
        GetRegContext( ThisThread->hThread, &Context );
        Context.PC_REG += BpSize;
        SetRegContext( ThisThread->hThread, &Context );
#endif
    } else {
        ContinueStatus = 0;
    }

exit:
    return ContinueStatus;
}

PDLL_INFO
GetModuleForAddr(
    ULONG_PTR Addr
    )
{
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if (Addr >= DllList[i].BaseAddress &&
            Addr <  DllList[i].BaseAddress+DllList[i].Size) {
                return &DllList[i];
        }
    }
    return NULL;
}

PAPI_INFO
GetApiForAddr(
    ULONG_PTR Addr
    )
{
    PDLL_INFO DllInfo = GetModuleForAddr( Addr );
    if (!DllInfo) {
        return NULL;
    }

    PAPI_INFO ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (ULONG_PTR)DllList);
    for (ULONG i=0; i<DllInfo->ApiCount; i++) {
        if (Addr == ApiInfo[i].Address) {
            return &ApiInfo[i];
        }
    }

    return NULL;
}

PPROCESS_INFO
GetProcessInfo(
    HANDLE hProcess
    )
{
    PPROCESS_INFO ThisProcess = &ProcessHead;
    do {
        if (ThisProcess->hProcess == hProcess) {
            return ThisProcess;
        }
        ThisProcess = ThisProcess->Next;
    } while (ThisProcess);
    return NULL;
}

PTHREAD_INFO
GetThreadInfo(
    HANDLE hProcess,
    HANDLE hThread
    )
{
    PPROCESS_INFO ThisProcess = GetProcessInfo( hProcess );
    if (!ThisProcess) {
        return NULL;
    }
    PTHREAD_INFO ThisThread = &ThisProcess->ThreadInfo;
    do {
        if (ThisThread->hThread == hThread) {
            return ThisThread;
        }
        ThisThread = ThisThread->Next;
    } while (ThisThread);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\cntrs.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cntrs.cpp

Abstract:

    All user interface code for the api counters monitor window.

Author:

    Wesley Witt (wesw) Nov-20-1995

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

#include "apimonwn.h"



int __cdecl
CounterCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        return (p2->Count - p1->Count);
    } else {
        return 1;
    }
}


int __cdecl
TimeCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        if (p2->Time > p1->Time) {
            return 1;
        } else if (p2->Time < p1->Time) {
            return -1;
        } else {
            return 0;
        }
    } else {
        return 1;
    }
}

int __cdecl
CalleeTimeCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        if (p2->Time - p2->CalleeTime > p1-> Time - p1->CalleeTime) {
            return 1;
        } else if (p2->Time - p2->CalleeTime < p1->Time - p1->CalleeTime) {
            return -1;
        } else {
            return 0;
        }
    } else {
        return 1;
    }
}

int __cdecl
NameCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        return _stricmp( (LPSTR)(p1->Name+(LPSTR)MemPtr), (LPSTR)(p2->Name+(LPSTR)MemPtr) );
    } else {
        return 1;
    }
}

int __cdecl
DllCompare(
    const void *e1,
    const void *e2
    )
{
    PDLL_INFO p1;
    PDLL_INFO p2;

    p1 = (*(PDLL_INFO *)e1);
    p2 = (*(PDLL_INFO *)e2);

    if ( p1 && p2 ) {
        return _stricmp( p1->Name, p2->Name );
    } else {
        return 1;
    }
}

CountersWindow::CountersWindow()
{
}


CountersWindow::~CountersWindow()
{
}


BOOL
CountersWindow::Create()
{
    switch (ApiMonOptions.DefaultSort) {
        case SortByName:
            SortRoutine = NameCompare;
            break;

        case SortByCounter:
            SortRoutine = CounterCompare;
            break;

        case SortByTime:
            SortRoutine = TimeCompare;
            break;

        default:
            SortRoutine = CounterCompare;
            break;
    }

    DllSort = FALSE;

    return ApiMonWindow::Create(
        "ApiMonCounters",
        "Api Counters"
        );
}


BOOL
CountersWindow::Register()
{
    return ApiMonWindow::Register(
        "ApiMonCounters",
        IDI_CHILDICON,
        MDIChildWndProcCounters
        );
}


BOOL
CountersWindow::Update(
    BOOL ForceUpdate
    )
{
    static ULONG LastApiCounter = 0;
    CHAR OutputBuffer[ 512 ];
    ULONG i,j,k;
    ULONG kStart;
    ULONG DllCnt;
    BOOL  DllUsed;
    PDLL_INFO DllAry[MAX_DLLS];

    if (!hwndList) {
        return FALSE;
    }

    if ((!ForceUpdate) && (LastApiCounter == *ApiCounter)) {
        return FALSE;
    }

    LastApiCounter = *ApiCounter;

    SendMessage( hwndList, WM_SETREDRAW, FALSE, 0 );

    DeleteAllItems();

    PAPI_INFO ApiInfo = NULL;
    DllCnt = 0;
    ULONG_PTR *ApiAry = NULL;
    for (i=0,k=0; i<MAX_DLLS; i++) {
        DllUsed = FALSE;
        if (DllList[i].ApiCount) {
            ApiInfo = (PAPI_INFO)(DllList[i].ApiOffset + (PUCHAR)DllList);
            for (j=0; j<DllList[i].ApiCount; j++) {
                if (ApiInfo[j].Count) {
                    k += 1;
                    DllUsed = TRUE;
                }
            }
        }

        if (DllUsed) {
            DllAry[DllCnt++] = &DllList[i];
        }
    }

    if (DllSort) {
       qsort( DllAry, DllCnt, sizeof(PDLL_INFO), DllCompare);
    }

    if (k) {
        ApiAry = (ULONG_PTR *) MemAlloc( (k+64) * sizeof(ULONG_PTR) );
        if (ApiAry) {

            for (i=0,k=0; i<DllCnt; i++) {
                if (DllAry[i]->ApiCount) {
                    ApiInfo = (PAPI_INFO)(DllAry[i]->ApiOffset + (PUCHAR)DllList);
                    kStart = k;
                    for (j=0; j<DllAry[i]->ApiCount; j++) {
                        if (ApiInfo[j].Count) {
                            ApiAry[k++] = (ULONG_PTR)&ApiInfo[j];
                        }
                    }

                    if (DllSort) {
                        qsort(&ApiAry[kStart], k - kStart, sizeof(ULONG_PTR), SortRoutine);
                    }
                }
            }

            if (!DllSort) {
                qsort( ApiAry, k, sizeof(ULONG_PTR), SortRoutine );
            }

            for (i=0; i<k; i++) {
               ApiInfo = (PAPI_INFO)ApiAry[i];
               AddItemToList(
                    ApiInfo->Count,
                    ApiInfo->Time,
                    ApiInfo->CalleeTime,
                    (LPSTR)(ApiInfo->Name + (LPSTR)MemPtr),
                    ((PDLL_INFO)(ApiInfo->DllOffset + (PUCHAR)DllList))->Name
                    );
            }
            MemFree( ApiAry );
        }
    }

    SendMessage( hwndList, WM_SETREDRAW, TRUE, 0 );

    return TRUE;
}


void
CountersWindow::InitializeList()
{
    LV_COLUMN lvc = {0};
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

    lvc.pszText = "API Name";
    lvc.iSubItem = CNTR_ITEM_NAME;
    lvc.cx = 200;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, CNTR_ITEM_NAME, &lvc );

    lvc.pszText = "DLL";
    lvc.iSubItem = CNTR_ITEM_DLL;
    lvc.cx = 20;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, CNTR_ITEM_DLL, &lvc );

    lvc.pszText = "Count";
    lvc.iSubItem = CNTR_ITEM_COUNT;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_RIGHT;
    ListView_InsertColumn( hwndList, CNTR_ITEM_COUNT, &lvc );

    lvc.pszText = "Time";
    lvc.iSubItem = CNTR_ITEM_TIME;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_RIGHT;
    ListView_InsertColumn( hwndList, CNTR_ITEM_TIME, &lvc );

    lvc.pszText = "Time - Callees";
    lvc.iSubItem = CNTR_ITEM_CALLEES;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_RIGHT;
    ListView_InsertColumn( hwndList, CNTR_ITEM_CALLEES, &lvc );
}


void
CountersWindow::AddItemToList(
    ULONG       Counter,
    DWORDLONG   Time,
    DWORDLONG   CalleeTime,
    LPSTR       ApiName,
    LPSTR       DllName
    )
{
    LV_ITEM             lvi = {0};
    CHAR                NumText[32];
    int                 iItem;
    double              NewTime;
    double              NewCalleeTime;


    if (!hwndList) {
        return;
    }

    lvi.pszText = ApiName;
    lvi.iItem = ListView_GetItemCount( hwndList );
    lvi.iSubItem = CNTR_ITEM_NAME;
    lvi.mask = LVIF_TEXT;
    iItem = ListView_InsertItem( hwndList, &lvi );

    if (iItem == -1) {
        return;
    }

    lvi.pszText = DllName;
    lvi.iItem = iItem;
    lvi.iSubItem = CNTR_ITEM_DLL;
    lvi.mask = LVIF_TEXT;
    ListView_SetItem( hwndList, &lvi );

    sprintf( NumText, "%5d", Counter );
    lvi.pszText = NumText;
    lvi.iItem = iItem;
    lvi.iSubItem = CNTR_ITEM_COUNT;
    lvi.mask = LVIF_TEXT;
    ListView_SetItem( hwndList, &lvi );

    NewTime = (double)(LONGLONG) Time;
    NewCalleeTime = (double)(LONGLONG) CalleeTime;

    if (!*FastCounterAvail) {
        NewTime = NewTime * MSecConv;
        NewCalleeTime = NewCalleeTime * MSecConv;
    }

    lvi.iItem = iItem;
    lvi.iSubItem = CNTR_ITEM_TIME;
    lvi.mask = LVIF_TEXT;
    sprintf( NumText, "%7.3f", NewTime );
    lvi.pszText = NumText;
    ListView_SetItem( hwndList, &lvi );

    lvi.iItem = iItem;
    lvi.iSubItem = CNTR_ITEM_CALLEES;
    lvi.mask = LVIF_TEXT;
    sprintf( NumText, "%7.3f", NewTime - NewCalleeTime );
    lvi.pszText = NumText;
    ListView_SetItem( hwndList, &lvi );

}


void
CountersWindow::Notify(
   LPNMHDR  NmHdr
   )
{
    if (NmHdr->code == LVN_COLUMNCLICK) {
        switch( ((LPNM_LISTVIEW)NmHdr)->iSubItem ) {

            case CNTR_ITEM_NAME:
                //
                // sort by name
                //
                SortRoutine = NameCompare;
                break;

            case CNTR_ITEM_COUNT:
                //
                // sort by count
                //
                SortRoutine = CounterCompare;
                break;

            case CNTR_ITEM_TIME:
                //
                // sort by time
                //
                SortRoutine = TimeCompare;
                break;

            case CNTR_ITEM_CALLEES:
                //
                // sort by time
                //
                SortRoutine = CalleeTimeCompare;
                break;

            case CNTR_ITEM_DLL:
                //
                // Toggle sort by DLL
                //
                DllSort = !DllSort;
                break;

        }
        PostMessage( hwndFrame, WM_UPDATE_COUNTERS, 0, 0 );
    }
}


LRESULT CALLBACK
MDIChildWndProcCounters(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD Width;
    CountersWindow *cw = (CountersWindow*) GetWindowLongPtr( hwnd, GWLP_USERDATA );

    switch (uMessage) {
        case WM_CREATE:
            cw = (CountersWindow*) ((LPMDICREATESTRUCT)(((LPCREATESTRUCT)lParam)->lpCreateParams))->lParam;
            SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR) cw );
            cw->hwndList = ChildCreate( hwnd );
            cw->InitializeList();
            SetMenuState( IDM_NEW_COUNTER, MF_GRAYED );
            break;

        case WM_SETFOCUS:
            ChildFocus = CHILD_COUNTER;
            break;

        case WM_MOVE:
            SaveWindowPos( hwnd, &ApiMonOptions.CounterPosition, TRUE );
            return 0;

        case WM_SIZE:
            SaveWindowPos( hwnd, &ApiMonOptions.CounterPosition, TRUE );
            MoveWindow( cw->hwndList, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE );
            Width = LOWORD(lParam) - GetSystemMetrics( SM_CXVSCROLL );
            ListView_SetColumnWidth( cw->hwndList, CNTR_ITEM_NAME, Width * .30 );
            ListView_SetColumnWidth( cw->hwndList, CNTR_ITEM_DLL, Width * .10 );
            ListView_SetColumnWidth( cw->hwndList, CNTR_ITEM_COUNT, Width * .20 );
            ListView_SetColumnWidth( cw->hwndList, CNTR_ITEM_TIME, Width * .20 );
            ListView_SetColumnWidth( cw->hwndList, CNTR_ITEM_CALLEES, Width * .20 );
            break;

        case WM_NOTIFY:
            cw->Notify( (LPNMHDR)lParam );
            break;

        case WM_DESTROY:
            SetMenuState( IDM_NEW_COUNTER, MF_ENABLED );
            return 0;
    }
    return DefMDIChildProc( hwnd, uMessage, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\dlllist.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dlllist.cpp

Abstract:

    All user interface code for the DLL list window.

Author:

    Wesley Witt (wesw) Nov-20-1995

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

#include "apimonwn.h"


DllListWindow::DllListWindow()
{
}


DllListWindow::~DllListWindow()
{
}


BOOL
DllListWindow::Create()
{
    return ApiMonWindow::Create(
        "ApiMonDlls",
        "DLLs In Use"
        );
}


BOOL
DllListWindow::Register()
{
    return ApiMonWindow::Register(
        "ApiMonDlls",
        IDI_CHILDICON,
        MDIChildWndProcDlls
        );
}


BOOL
DllListWindow::Update(
    BOOL ForceUpdate
    )
{
    for (ULONG i=0; i<MAX_DLLS; i++) {
        if ((DllList[i].BaseAddress) && (!DllList[i].InList)) {
            AddItemToList(
                DllList[i].Name,
                DllList[i].BaseAddress,
                DllList[i].Enabled
                );
            DllList[i].InList = TRUE;
        }
    }

    return TRUE;
}


void
DllListWindow::InitializeList()
{
    //
    // set/initialize the image list(s)
    //
    HIMAGELIST himlState = ImageList_Create( 16, 16, TRUE, 2, 0 );

    ImageList_AddMasked(
        himlState,
        LoadBitmap( hInstance, MAKEINTRESOURCE(IDB_CHECKSTATES) ),
        RGB (255,0,0)
        );

    ListView_SetImageList( hwndList, himlState, LVSIL_STATE );

    //
    // set/initialize the columns
    //
    LV_COLUMN lvc = {0};
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = 198;
    lvc.pszText = "DLL Name";
    lvc.iSubItem = 0;
    ListView_InsertColumn( hwndList, lvc.iSubItem, &lvc );
    lvc.pszText = "Address";
    lvc.iSubItem = 1;
    lvc.cx = 75;
    ListView_InsertColumn( hwndList, lvc.iSubItem, &lvc );
}


void
DllListWindow::AddItemToList(
    LPSTR     DllName,
    ULONG_PTR Address,
    BOOL      Enabled
    )
{
    if (!hwndList) {
        return;
    }

    int iItem = 0;
    LV_ITEM lvi;
    lvi.pszText = _strlwr( DllName );
    lvi.iItem = 0;
    lvi.iSubItem = 0;
    lvi.iImage = 0;
    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvi.state = Enabled ? LVIS_GCCHECK : LVIS_GCNOCHECK;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    iItem = ListView_InsertItem( hwndList, &lvi );
    if (iItem != -1) {
        lvi.iItem = iItem;
        lvi.iSubItem = 1;
        lvi.mask = LVIF_TEXT;
        lvi.state = 0;
        CHAR AddrText[16];
        sprintf( AddrText, "0x%08x", Address );
        lvi.pszText = AddrText;
        ListView_SetItem( hwndList, &lvi );
    }
}


void
DllListWindow::Notify(
   LPNMHDR  NmHdr
   )
{
    DWORD           dwpos;
    LV_HITTESTINFO  lvhti;
    int             iItemClicked;
    UINT            state;
    CHAR            DllName[64];


    if (NmHdr->code != NM_CLICK) {
        return;
    }

    //
    // Find out where the cursor was
    //
    dwpos = GetMessagePos();
    lvhti.pt.x = LOWORD(dwpos);
    lvhti.pt.y = HIWORD(dwpos);

    MapWindowPoints( HWND_DESKTOP, hwndList, &lvhti.pt, 1 );

    //
    // Now do a hittest with this point.
    //
    iItemClicked = ListView_HitTest( hwndList, &lvhti );

    if (lvhti.flags & LVHT_ONITEMSTATEICON) {
        //
        // Now lets get the state from the item and toggle it.
        //
        state = ListView_GetItemState(
            hwndList,
            iItemClicked,
            LVIS_STATEIMAGEMASK
            );

        state = (state == LVIS_GCNOCHECK) ? LVIS_GCCHECK : LVIS_GCNOCHECK;

        ListView_SetItemState(
            hwndList,
            iItemClicked,
            state,
            LVIS_STATEIMAGEMASK
            );

        ListView_GetItemText( hwndList, iItemClicked, 0, DllName, sizeof(DllName) );
        SetApiCounterEnabledFlag( state == LVIS_GCCHECK, DllName );
    }
}

LRESULT CALLBACK
MDIChildWndProcDlls(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD Width, i;
    DllListWindow *dlw = (DllListWindow*) GetWindowLongPtr( hwnd, GWLP_USERDATA );


    switch (uMessage) {
        case WM_CREATE:
            dlw = (DllListWindow*) ((LPMDICREATESTRUCT)(((LPCREATESTRUCT)lParam)->lpCreateParams))->lParam;
            SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR) dlw );
            dlw->hwndList = ChildCreate( hwnd );
            dlw->InitializeList();
            SetMenuState( IDM_NEW_DLL, MF_GRAYED );
            break;

        case WM_SETFOCUS:
            ChildFocus = CHILD_DLL;
            break;

        case WM_MOVE:
            SaveWindowPos( hwnd, &ApiMonOptions.DllPosition, TRUE );
            return 0;

        case WM_SIZE:
            SaveWindowPos( hwnd, &ApiMonOptions.DllPosition, TRUE );
            MoveWindow( dlw->hwndList, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE );
            Width = LOWORD(lParam) - GetSystemMetrics( SM_CXVSCROLL );
            ListView_SetColumnWidth( dlw->hwndList, 0, Width * .60 );
            ListView_SetColumnWidth( dlw->hwndList, 1, Width * .40 );
            break;

        case WM_NOTIFY:
            dlw->Notify( (LPNMHDR)lParam );
            break;

        case WM_DESTROY:
            SetMenuState( IDM_NEW_DLL, MF_ENABLED );
            for (i=0; i<MAX_DLLS; i++) {
                if (DllList[i].BaseAddress) {
                    DllList[i].InList = FALSE;
                }
            }
            return 0;
    }

    return DefMDIChildProc( hwnd, uMessage, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\help.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    help.cpp

Abstract:

    All user interface code for APIMON.

Author:

    Wesley Witt (wesw) July-11-1993

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop


extern HWND     hwndFrame;
extern BOOL     InMenu;
extern DWORD    MenuId;
extern CHAR     HelpFileName[];


typedef struct _HELP_IDS {
    DWORD   Context;
    DWORD   HelpId;
} HELP_IDS, *PHELP_IDS;

HELP_IDS HelpTable[] =
    {
    IDC_LOG_FILE_NAME,              IDH_LOG_FILE_NAME,
    IDC_TRACE_FILE_NAME,            IDH_TRACE_FILE_NAME,
    IDC_ENABLE_TRACING,             IDH_ENABLE_TRACING,
    IDC_SYMBOL_PATH,                IDH_SYMBOL_PATH,
    IDC_DISABLE_HEAP,               IDH_DISABLE_HEAP,
    IDC_PRELOAD_SYMBOLS,            IDH_PRELOAD_SYMBOLS,
    IDC_ENABLE_COUNTERS,            IDH_ENABLE_COUNTERS,
    IDC_GO_IMMEDIATE,               IDH_GO_IMMEDIATE,
    IDC_DISABLE_FAST_COUNTERS,      IDH_DISABLE_FAST_COUNTERS,
    IDC_DEFSORT_NAME,               IDH_DEFSORT_NAME,
    IDC_DEFSORT_COUNTER,            IDH_DEFSORT_COUNTER,
    IDC_DEFSORT_TIME,               IDH_DEFSORT_TIME,
    IDC_USE_KNOWN_DLLS,             IDH_USE_KNOWN_DLLS,
    IDC_EXCLUDE_KNOWN_DLLS,         IDH_EXCLUDE_KNOWN_DLLS,
    IDC_KNOWN_DLLS,                 IDH_KNOWN_DLLS,
    IDC_PAGE_FAULTS,                IDH_PAGE_FAULTS,
    IDM_EXIT,                       IDH_EXIT,
    IDM_WINDOWTILE,                 IDH_WINDOWTILE,
    IDM_WINDOWCASCADE,              IDH_WINDOWCASCADE,
    IDM_WINDOWICONS,                IDH_WINDOWICONS,
    IDM_ABOUT,                      IDH_ABOUT,
    IDM_STATUSBAR,                  IDH_STATUSBAR,
    IDM_START,                      IDH_START,
    IDM_STOP,                       IDH_STOP,
    IDM_TOOLBAR,                    IDH_TOOLBAR,
    IDM_OPTIONS,                    IDH_OPTIONS,
    IDM_SAVE_OPTIONS,               IDH_SAVE_OPTIONS,
    IDM_FILEOPEN,                   IDH_FILEOPEN,
    IDM_WRITE_LOG,                  IDH_WRITE_LOG,
    IDM_FONT,                       IDH_FONT,
    IDM_COLOR,                      IDH_COLOR,
    IDM_NEW_DLL,                    IDH_NEW_DLL,
    IDM_NEW_COUNTER,                IDH_NEW_COUNTER,
    IDM_CLEAR_COUNTERS,             IDH_CLEAR_COUNTERS,
    IDM_NEW_PAGE,                   IDH_NEW_PAGE,
    IDM_WINDOWTILE_HORIZ,           IDH_WINDOWTILE_HORIZ
    };

#define MAX_HELP_IDS (sizeof(HelpTable)/sizeof(HELP_IDS))


DWORD __inline
GetHelpId(
    DWORD Context
    )
{
    for (DWORD i=0; i<MAX_HELP_IDS; i++) {
        if (HelpTable[i].Context == Context) {
            return HelpTable[i].HelpId;
        }
    }
    return 0;
}

VOID
ProcessHelpRequest(
    HWND hwnd,
    INT  DlgCtrl
    )
{
    DWORD HelpId = 0;
    DWORD HelpType = HELP_CONTEXT;
    if (DlgCtrl) {
        HelpId = GetHelpId( DlgCtrl );
    } else if (hwnd == hwndFrame) {
        if (InMenu && MenuId) {
            HelpId = GetHelpId( MenuId );
        } else {
            HelpType = HELP_CONTENTS;
        }
    } else {
        HelpId = GetWindowContextHelpId( hwnd );
    }

    if (!HelpId) {
        HelpType = HELP_CONTENTS;
    }

    if (!WinHelp( hwnd, HelpFileName, HelpType, HelpId )) {
        PopUpMsg( "Could not start WinHelp" );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\expr.cpp ===
#include "apimonp.h"
#pragma hdrstop

#include <setjmp.h>

#define SYMBOLSIZE      256

extern HANDLE CurrProcess;

PUCHAR          pchCommand = NULL;
ULONG           baseDefault = 16;
BOOL            addrExpression = FALSE;
BOOL            ExprError;


ULONG   PeekToken(LONG_PTR *);
ULONG   GetTokenSym(LONG_PTR *);
ULONG   NextToken(LONG_PTR *);
void    AcceptToken(void);
UCHAR   PeekChar(void);

void    GetLowerString(PUCHAR, ULONG);
LONG_PTR GetExpr(void);
LONG_PTR GetLRterm(void);
LONG_PTR GetLterm(void);
LONG_PTR GetAterm(void);
LONG_PTR GetMterm(void);
LONG_PTR GetTerm(void);
ULONG_PTR tempAddr;
BOOLEAN SymbolOnlyExpr(void);
BOOL    GetMemByte(ULONG_PTR,PUCHAR);
BOOL    GetMemWord(ULONG_PTR,PUSHORT);
BOOL    GetMemDword(ULONG_PTR,PULONG);
ULONG   GetMemString(ULONG_PTR,PUCHAR,ULONG);


//  token classes (< 100) and types (>= 100)

#define EOL_CLASS       0
#define ADDOP_CLASS     1
#define ADDOP_PLUS      100
#define ADDOP_MINUS     101
#define MULOP_CLASS     2
#define MULOP_MULT      200
#define MULOP_DIVIDE    201
#define MULOP_MOD       202
#define MULOP_SEG       203
#define LOGOP_CLASS     3
#define LOGOP_AND       300
#define LOGOP_OR        301
#define LOGOP_XOR       302
#define LRELOP_CLASS    4
#define LRELOP_EQ       400
#define LRELOP_NE       401
#define LRELOP_LT       402
#define LRELOP_GT       403
#define UNOP_CLASS      5
#define UNOP_NOT        500
#define UNOP_BY         501
#define UNOP_WO         502
#define UNOP_DW         503
#define UNOP_POI        504
#define UNOP_LOW        505
#define UNOP_HI         506
#define LPAREN_CLASS    6
#define RPAREN_CLASS    7
#define LBRACK_CLASS    8
#define RBRACK_CLASS    9
#define REG_CLASS       10
#define NUMBER_CLASS    11
#define SYMBOL_CLASS    12
#define ERROR_CLASS     99              //only used for PeekToken

//  error codes

#define OVERFLOW        0x1000
#define SYNTAX          0x1001
#define BADRANGE        0x1002
#define VARDEF          0x1003
#define EXTRACHARS      0x1004
#define LISTSIZE        0x1005
#define STRINGSIZE      0x1006
#define MEMORY          0x1007
#define BADREG          0x1008
#define BADOPCODE       0x1009
#define SUFFIX          0x100a
#define OPERAND         0x100b
#define ALIGNMENT       0x100c
#define PREFIX          0x100d
#define DISPLACEMENT    0x100e
#define BPLISTFULL      0x100f
#define BPDUPLICATE     0x1010
#define BADTHREAD       0x1011
#define DIVIDE          0x1012
#define TOOFEW          0x1013
#define TOOMANY         0x1014
#define SIZE            0x1015
#define BADSEG          0x1016
#define RELOC           0x1017
#define BADPROCESS      0x1018
#define AMBIGUOUS       0x1019
#define FILEREAD        0x101a
#define LINENUMBER      0x101b
#define BADSEL          0x101c
#define SYMTOOSMALL     0x101d
#define BPIONOTSUP      0x101e
#define UNIMPLEMENT     0x1099

struct Res {
    UCHAR    chRes[3];
    ULONG    classRes;
    ULONG    valueRes;
    } Reserved[] = {
        { 'o', 'r', '\0', LOGOP_CLASS, LOGOP_OR  },
        { 'b', 'y', '\0', UNOP_CLASS,  UNOP_BY   },
        { 'w', 'o', '\0', UNOP_CLASS,  UNOP_WO   },
        { 'd', 'w', '\0', UNOP_CLASS,  UNOP_DW   },
        { 'h', 'i', '\0', UNOP_CLASS,  UNOP_HI   },
        { 'm', 'o', 'd',  MULOP_CLASS, MULOP_MOD },
        { 'x', 'o', 'r',  LOGOP_CLASS, LOGOP_XOR },
        { 'a', 'n', 'd',  LOGOP_CLASS, LOGOP_AND },
        { 'p', 'o', 'i',  UNOP_CLASS,  UNOP_POI  },
        { 'n', 'o', 't',  UNOP_CLASS,  UNOP_NOT  },
        { 'l', 'o', 'w',  UNOP_CLASS,  UNOP_LOW  }
#ifdef i386xx
       ,{ 'e', 'a', 'x',  REG_CLASS,   REGEAX   },
        { 'e', 'b', 'x',  REG_CLASS,   REGEBX   },
        { 'e', 'c', 'x',  REG_CLASS,   REGECX   },
        { 'e', 'd', 'x',  REG_CLASS,   REGEDX   },
        { 'e', 'b', 'p',  REG_CLASS,   REGEBP   },
        { 'e', 's', 'p',  REG_CLASS,   REGESP   },
        { 'e', 'i', 'p',  REG_CLASS,   REGEIP   },
        { 'e', 's', 'i',  REG_CLASS,   REGESI   },
        { 'e', 'd', 'i',  REG_CLASS,   REGEDI   },
        { 'e', 'f', 'l',  REG_CLASS,   REGEFL   }
#endif
        };

#define RESERVESIZE (sizeof(Reserved) / sizeof(struct Res))

ULONG   savedClass;
LONG_PTR savedValue;
UCHAR   *savedpchCmd;

ULONG   cbPrompt = 8;
PUCHAR  pchStart;
jmp_buf cmd_return;

static char szBlanks[] =
                  "                                                  "
                  "                                                  "
                  "                                                  "
                  "                                                ^ ";

ULONG_PTR EXPRLastExpression = 0;
extern  BOOLEAN fPhysicalAddress;


extern BOOL cdecl cmdHandler(ULONG);
extern BOOL cdecl waitHandler(ULONG);



void
error(
    ULONG errcode
    )
{
    ULONG count = cbPrompt;
    UCHAR *pchtemp = pchStart;

    while (pchtemp < pchCommand) {
        if (*pchtemp++ == '\t') {
            count = (count + 7) & ~7;
        } else {
            count++;
        }
    }

    fputs( &szBlanks[sizeof(szBlanks) - (count + 1)], stdout );

    switch (errcode) {
        case OVERFLOW:
            printf("Overflow");
            break;

        case SYNTAX:
            printf("Syntax");
            break;

        case BADRANGE:
            printf("Range");
            break;

        case VARDEF:
            printf("Variable definition");
            break;

        case EXTRACHARS:
            printf("Extra character");
            break;

        case LISTSIZE:
            printf("List size");
            break;

        case STRINGSIZE:
            printf("String size");
            break;

        case MEMORY:
            printf("Memory access");
            break;

        case BADREG:
            printf("Bad register");
            break;

        case BADOPCODE:
            printf("Bad opcode");
            break;

        case SUFFIX:
            printf("Opcode suffix");
            break;

        case OPERAND:
            printf("Operand");
            break;

        case ALIGNMENT:
            printf("Alignment");
            break;

        case PREFIX:
            printf("Opcode prefix");
            break;

        case DISPLACEMENT:
            printf("Displacement");
            break;

        case BPLISTFULL:
            printf("No breakpoint available");
            break;

        case BPDUPLICATE:
            printf("Duplicate breakpoint");
            break;

        case UNIMPLEMENT:
            printf("Unimplemented");
            break;

        case AMBIGUOUS:
            printf("Ambiguous symbol");
            break;

        case FILEREAD:
            printf("File read");
            break;

        case LINENUMBER:
            printf("Line number");
            break;

        case BADSEL:
            printf("Bad selector");
            break;

        case BADSEG:
            printf("Bad segment");
            break;

        case SYMTOOSMALL:
            printf("Symbol only 1 character");
            break;

        default:
            printf("Unknown");
            break;
    }

    printf(" error in '%s'\n", pchStart);

    ExprError = TRUE;

    longjmp( cmd_return, 1 );
}


/*** GetAddrExpression - read and evaluate address expression
*
*   Purpose:
*       Used to get an address expression.
*
*   Returns:
*       Pointer to address packet
*
*   Exceptions:
*       error exit: SYNTAX - empty expression or premature end-of-line
*
*
*************************************************************************/
ULONG_PTR GetAddrExpression (LPSTR CommandString, ULONG_PTR *Address)
{
    ULONG_PTR value;

    //  Do a normal GetExpression call

    value = GetExpression(CommandString);
    *Address = tempAddr;

    return *Address;
}



/*** GetExpression - read and evaluate expression (top-level)
*
*   Purpose:
*       From the current command line position at pchCommand,
*       read and evaluate the next possible expression and
*       return its value.  The expression is parsed and evaluated
*       using a recursive descent method.
*
*   Input:
*       pchCommand - command line position
*
*   Returns:
*       unsigned long value of expression.
*
*   Exceptions:
*       error exit: SYNTAX - empty expression or premature end-of-line
*
*   Notes:
*       the routine will attempt to parse the longest expression
*       possible.
*
*************************************************************************/


ULONG_PTR
GetExpression(
    LPSTR CommandString
    )
{
    PUCHAR            pchCommandSaved;
    UCHAR             chModule[40];
    UCHAR             chFilename[40];
    UCHAR             ch;
    ULONG_PTR         value;
    ULONG             baseSaved;
    PUCHAR            pchFilename;


    ExprError = FALSE;
    pchCommand = (PUCHAR)CommandString;
    pchStart = (PUCHAR)CommandString;
    savedClass = (ULONG)-1;
    pchCommandSaved = pchCommand;

    if (PeekChar() == '!') {
        pchCommand++;
    }

    GetLowerString(chModule, 40);
    ch = PeekChar();

    if (ch == '!') {
        pchCommand++;
        GetLowerString(chFilename, 40);
        ch = PeekChar();
    } else {
        strcpy( (LPSTR)chFilename, (LPSTR)chModule );
        chModule[0] = '\0';
    }

    pchCommand = pchCommandSaved;
    if (setjmp(cmd_return) == 0) {
        value = (ULONG_PTR)GetExpr();
    } else {
        value = 0;
    }

    EXPRLastExpression = value;

    return value;
}

void GetLowerString (PUCHAR pchBuffer, ULONG cbBuffer)
{
    UCHAR   ch;

    ch = PeekChar();
    ch = (UCHAR)tolower(ch);
    while ((ch == '_' || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9')) && --cbBuffer) {
        *pchBuffer++ = ch;
        ch = *++pchCommand;
    }
    *pchBuffer = '\0';
}

/*** GetExpr - Get expression
*
*   Purpose:
*       Parse logical-terms separated by logical operators into
*       expression value.
*
*   Input:
*       pchCommand - present command line position
*
*   Returns:
*       long value of logical result.
*
*   Exceptions:
*       error exit: SYNTAX - bad expression or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <expr> = <lterm> [<logic-op> <lterm>]*
*       <logic-op> = AND (&), OR (|), XOR (^)
*
*************************************************************************/

LONG_PTR GetExpr ()
{
    LONG_PTR value1;
    LONG_PTR value2;
    ULONG   opclass;
    LONG_PTR opvalue;


    value1 = GetLRterm();
    while ((opclass = PeekToken(&opvalue)) == LOGOP_CLASS) {
        AcceptToken();
        value2 = GetLRterm();
        switch (opvalue) {
            case LOGOP_AND:
                value1 &= value2;
                break;
            case LOGOP_OR:
                value1 |= value2;
                break;
            case LOGOP_XOR:
                value1 ^= value2;
                break;
            default:
                error(SYNTAX);
            }
        }
    return value1;
}

/*** GetLRterm - get logical relational term
*
*   Purpose:
*       Parse logical-terms separated by logical relational
*       operators into the expression value.
*
*   Input:
*       pchCommand - present command line position
*
*   Returns:
*       long value of logical result.
*
*   Exceptions:
*       error exit: SYNTAX - bad expression or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <expr> = <lterm> [<rel-logic-op> <lterm>]*
*       <logic-op> = '==' or '=', '!=', '>', '<'
*
*************************************************************************/

LONG_PTR GetLRterm ()
{
    LONG_PTR    value1;
    LONG_PTR    value2;
    ULONG   opclass;
    LONG_PTR    opvalue;


    value1 = GetLterm();
    while ((opclass = PeekToken(&opvalue)) == LRELOP_CLASS) {
        AcceptToken();
        value2 = GetLterm();
        switch (opvalue) {
            case LRELOP_EQ:
                value1 = (value1 == value2);
                break;
            case LRELOP_NE:
                value1 = (value1 != value2);
                break;
            case LRELOP_LT:
                value1 = (value1 < value2);
                break;
            case LRELOP_GT:
                value1 = (value1 > value2);
                break;
            default:
                error(SYNTAX);
            }
        }
    return value1;
}

/*** GetLterm - get logical term
*
*   Purpose:
*       Parse additive-terms separated by additive operators into
*       logical term value.
*
*   Input:
*       pchCommand - present command line position
*
*   Returns:
*       long value of sum.
*
*   Exceptions:
*       error exit: SYNTAX - bad logical term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <lterm> = <aterm> [<add-op> <aterm>]*
*       <add-op> = +, -
*
*************************************************************************/

LONG_PTR
GetLterm(
    VOID
    )
{
    LONG_PTR  value1;
    LONG_PTR  value2;
    ULONG   opclass;
    LONG_PTR  opvalue;


    value1 = GetAterm();
    while ((opclass = PeekToken(&opvalue)) == ADDOP_CLASS) {
        AcceptToken();
        value2 = GetAterm();
        if (addrExpression) {
                switch (opvalue) {
                        case ADDOP_PLUS:
                                value1 += tempAddr;
                                break;
                        case ADDOP_MINUS:
                                value1 -= tempAddr;
                                break;
                        default:
                                error(SYNTAX);
                }
        }
        else
        switch (opvalue) {
            case ADDOP_PLUS:
                value1 += value2;
                break;
            case ADDOP_MINUS:
                value1 -= value2;
                break;
            default:
                error(SYNTAX);
            }
    }
    return value1;
}

/*** GetAterm - get additive term
*
*   Purpose:
*       Parse multiplicative-terms separated by multipicative operators
*       into additive term value.
*
*   Input:
*       pchCommand - present command line position
*
*   Returns:
*       long value of product.
*
*   Exceptions:
*       error exit: SYNTAX - bad additive term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <aterm> = <mterm> [<mult-op> <mterm>]*
*       <mult-op> = *, /, MOD (%)
*
*************************************************************************/

LONG_PTR GetAterm ()
{
    LONG_PTR value1;
    LONG_PTR value2;
    ULONG   opclass;
    LONG_PTR opvalue;


    value1 = GetMterm();
    while ((opclass = PeekToken(&opvalue)) == MULOP_CLASS) {
        AcceptToken();
        value2 = GetAterm();
        switch (opvalue) {
            case MULOP_MULT:
                value1 *= value2;
                break;
            case MULOP_DIVIDE:
                value1 /= value2;
                break;
            case MULOP_MOD:
                value1 %= value2;
                break;
            default:
                error(SYNTAX);
            }
        }
    return value1;
}

/*** GetMterm - get multiplicative term
*
*   Purpose:
*       Parse basic-terms optionally prefaced by one or more
*       unary operators into a multiplicative term.
*
*   Input:
*       pchCommand - present command line position
*
*   Returns:
*       long value of multiplicative term.
*
*   Exceptions:
*       error exit: SYNTAX - bad multiplicative term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <mterm> = [<unary-op>] <term> | <unary-op> <mterm>
*       <unary-op> = <add-op>, ~ (NOT), BY, WO, DW, HI, LOW
*
*************************************************************************/

LONG_PTR
GetMterm(
    VOID
    )
{
    LONG_PTR value;
    USHORT  wvalue;
    UCHAR   bvalue;
    ULONG   opclass;
    LONG_PTR opvalue;


    if ((opclass = PeekToken(&opvalue)) == UNOP_CLASS || opclass == ADDOP_CLASS) {
        AcceptToken();
        value = GetMterm();
        switch (opvalue) {
            case UNOP_NOT:
                value = !value;
                break;
            case UNOP_BY:
            case UNOP_WO:
            case UNOP_DW:
            case UNOP_POI:
                tempAddr = value;
                switch (opvalue) {
                    case UNOP_BY:
                        if (!GetMemByte(tempAddr, &bvalue)) {
                            error(MEMORY);
                        }
                        value = (LONG)bvalue;
                        break;
                    case UNOP_WO:
                        if (!GetMemWord(tempAddr, &wvalue)) {
                            error(MEMORY);
                        }
                        value = (LONG)wvalue;
                        break;
                    case UNOP_DW:
                        if (!GetMemDword(tempAddr, (PULONG)&value)) {
                            error(MEMORY);
                        }
                        break;
                    case UNOP_POI:
                        //
                        // There should be some special processing for
                        // 16:16 or 16:32 addresses (i.e. take the DWORD)
                        // and make it back into a value with a possible
                        // segment, but I've left this for others who might
                        // know more of what they want.
                        //
                        if (!GetMemDword(tempAddr, (PULONG)&value)) {
                            error(MEMORY);
                        }
                        break;
                    }
                break;

            case UNOP_LOW:
                value &= 0xffff;
                break;
            case UNOP_HI:
                value >>= 16;
                break;
            case ADDOP_PLUS:
                break;
            case ADDOP_MINUS:
                value = -value;
                break;
            default:
                error(SYNTAX);
            }
        }
    else {
        value = GetTerm();
    }
    return value;
}

/*** GetTerm - get basic term
*
*   Purpose:
*       Parse numeric, variable, or register name into a basic
*       term value.
*
*   Input:
*       pchCommand - present command line position
*
*   Returns:
*       long value of basic term.
*
*   Exceptions:
*       error exit: SYNTAX - empty basic term or premature end-of-line
*
*   Notes:
*       may be called recursively.
*       <term> = ( <expr> ) | <register-value> | <number> | <variable>
*       <register-value> = @<register-name>
*
*************************************************************************/

LONG_PTR
GetTerm(
    VOID
    )
{
    LONG_PTR    value = 0;
    ULONG   opclass;
    LONG_PTR    opvalue;

    opclass = GetTokenSym(&opvalue);
    if (opclass == LPAREN_CLASS) {
        value = GetExpr();
        if (GetTokenSym(&opvalue) != RPAREN_CLASS)
            error(SYNTAX);
    }
    else if (opclass == REG_CLASS) {
        value = (ULONG)GetRegFlagValue((DWORD)opvalue);
    }
    else if (opclass == NUMBER_CLASS || opclass == SYMBOL_CLASS) {
        value = opvalue;
    } else {
        error(SYNTAX);
    }

    return value;
}

/*** GetRange - parse address range specification
*
*   Purpose:
*       With the current command line position, parse an
*       address range specification.  Forms accepted are:
*       <start-addr>            - starting address with default length
*       <start-addr> <end-addr> - inclusive address range
*       <start-addr> l<count>   - starting address with item count
*
*   Input:
*       pchCommand - present command line location
*       size - nonzero - (for data) size in bytes of items to list
*                        specification will be "length" type with
*                        *fLength forced to TRUE.
*              zero - (for instructions) specification either "length"
*                     or "range" type, no size assumption made.
*
*   Output:
*       *addr - starting address of range
*       *value - if *fLength = TRUE, count of items (forced if size != 0)
*                              FALSE, ending address of range
*       (*addr and *value unchanged if no second argument in command)
*
*   Exceptions:
*       error exit:
*               SYNTAX - expression error
*               BADRANGE - if ending address before starting address
*
*************************************************************************/

void
GetRange(
    LPSTR       CommandString,
    ULONG_PTR * addr,
    ULONG_PTR * value,
    PBOOLEAN    fLength,
    ULONG       size
    )

{
    static ULONG_PTR EndRange;
    UCHAR    ch;
    PUCHAR   psz;
    BOOLEAN  fSpace = FALSE;
    BOOLEAN  fL = FALSE;

    PeekChar();          //  skip leading whitespace first

    //  Pre-parse the line, look for a " L"

    for (psz = pchCommand; *psz; psz++) {
        if ((*psz == 'L' || *psz == 'l') && fSpace) {
            fL = TRUE;
            *psz = '\0';
            break;
        }
        fSpace = (BOOLEAN)(*psz == ' ');
    }

    if ((ch = PeekChar()) != '\0' && ch != ';') {
        GetAddrExpression(CommandString,addr);
        if (((ch = PeekChar()) != '\0' && ch != ';') || fL) {
            if (!fL) {
                GetAddrExpression(CommandString,&EndRange);
                *value = (ULONG_PTR)&EndRange;
                if (*addr > EndRange) {
                    error(BADRANGE);
                }
                if (size) {
                    *value = (EndRange - *addr) / size + 1;
                    *fLength = TRUE;
                } else {
                    *fLength = FALSE;
                }
                return;
            } else {
                *fLength = TRUE;
                pchCommand = psz + 1;
                *value = GetExpression(CommandString);
                *psz = 'l';
            }
        }
    }
}

/*** PeekChar - peek the next non-white-space character
*
*   Purpose:
*       Return the next non-white-space character and update
*       pchCommand to point to it.
*
*   Input:
*       pchCommand - present command line position.
*
*   Returns:
*       next non-white-space character
*
*************************************************************************/

UCHAR PeekChar (void)
{
    UCHAR    ch;

    do
        ch = *pchCommand++;
    while (ch == ' ' || ch == '\t');
    pchCommand--;
    return ch;
}

/*** PeekToken - peek the next command line token
*
*   Purpose:
*       Return the next command line token, but do not advance
*       the pchCommand pointer.
*
*   Input:
*       pchCommand - present command line position.
*
*   Output:
*       *pvalue - optional value of token
*   Returns:
*       class of token
*
*   Notes:
*       savedClass, savedValue, and savedpchCmd saves the token getting
*       state for future peeks.  To get the next token, a GetToken or
*       AcceptToken call must first be made.
*
*************************************************************************/

ULONG PeekToken (LONG_PTR * pvalue)
{
    UCHAR    *pchTemp;

    //  Get next class and value, but do not
    //  move pchCommand, but save it in savedpchCmd.
    //  Do not report any error condition.

    if (savedClass == -1) {
        pchTemp = pchCommand;
        savedClass = NextToken(&savedValue);
        savedpchCmd = pchCommand;
        pchCommand = pchTemp;
        }
    *pvalue = savedValue;
    return savedClass;
}

/*** AcceptToken - accept any peeked token
*
*   Purpose:
*       To reset the PeekToken saved variables so the next PeekToken
*       will get the next token in the command line.
*
*   Input:
*       None.
*
*   Output:
*       None.
*
*************************************************************************/

void AcceptToken (void)
{
    savedClass = (ULONG)-1;
    pchCommand = savedpchCmd;
}

/*** GetToken - peek and accept the next token
*
*   Purpose:
*       Combines the functionality of PeekToken and AcceptToken
*       to return the class and optional value of the next token
*       as well as updating the command pointer pchCommand.
*
*   Input:
*       pchCommand - present command string pointer
*
*   Output:
*       *pvalue - pointer to the token value optionally set.
*   Returns:
*       class of the token read.
*
*   Notes:
*       An illegal token returns the value of ERROR_CLASS with *pvalue
*       being the error number, but produces no actual error.
*
*************************************************************************/

ULONG
GetTokenSym(
    LONG_PTR *pvalue
    )
{
    ULONG   opclass;

    if (savedClass != (ULONG)-1) {
        opclass = savedClass;
        savedClass = (ULONG)-1;
        *pvalue = savedValue;
        pchCommand = savedpchCmd;
        }
    else
        opclass = NextToken(pvalue);

    if (opclass == ERROR_CLASS)
        error((DWORD)*pvalue);

    return opclass;
}

/*** NextToken - process the next token
*
*   Purpose:
*       Parse the next token from the present command string.
*       After skipping any leading white space, first check for
*       any single character tokens or register variables.  If
*       no match, then parse for a number or variable.  If a
*       possible variable, check the reserved word list for operators.
*
*   Input:
*       pchCommand - pointer to present command string
*
*   Output:
*       *pvalue - optional value of token returned
*       pchCommand - updated to point past processed token
*   Returns:
*       class of token returned
*
*   Notes:
*       An illegal token returns the value of ERROR_CLASS with *pvalue
*       being the error number, but produces no actual error.
*
*************************************************************************/

ULONG
NextToken(
    LONG_PTR * pvalue
    )
{
    ULONG           base;
    UCHAR           chSymbol[SYMBOLSIZE];
    UCHAR           chSymbolString[SYMBOLSIZE];
    UCHAR           chPreSym[9];
    ULONG           cbSymbol = 0;
    BOOLEAN         fNumber = TRUE;
    BOOLEAN         fSymbol = TRUE;
    BOOLEAN         fForceReg = FALSE;
    BOOLEAN         fForceSym = FALSE;
    ULONG           errNumber = 0;
    UCHAR           ch;
    UCHAR           chlow;
    UCHAR           chtemp;
    UCHAR           limit1 = '9';
    UCHAR           limit2 = '9';
    BOOLEAN         fDigit = FALSE;
    ULONG           value = 0;
    ULONG           tmpvalue;
    ULONG           index;
    //PMODULE_ENTRY   Module;
    PUCHAR          pchCmdSave;
    int             loaded = 0;
    int             instance = 0;
    ULONG           insValue = 0;


    base = baseDefault;

    //  skip leading white space.

    do {
        ch = *pchCommand++;
    } while (ch == ' ' || ch == '\t');

    chlow = (UCHAR)tolower(ch);

    //  test for special character operators and register variable

    switch (chlow) {
        case '\0':
        case ';':
            pchCommand--;
            return EOL_CLASS;
        case '+':
            *pvalue = ADDOP_PLUS;
            return ADDOP_CLASS;
        case '-':
            *pvalue = ADDOP_MINUS;
            return ADDOP_CLASS;
        case '*':
            *pvalue = MULOP_MULT;
            return MULOP_CLASS;
        case '/':
            *pvalue = MULOP_DIVIDE;
            return MULOP_CLASS;
        case '%':
            *pvalue = MULOP_MOD;
            return MULOP_CLASS;
        case '&':
            *pvalue = LOGOP_AND;
            return LOGOP_CLASS;
        case '|':
            *pvalue = LOGOP_OR;
            return LOGOP_CLASS;
        case '^':
            *pvalue = LOGOP_XOR;
            return LOGOP_CLASS;
        case '=':
            if (*pchCommand == '=')
                pchCommand++;
            *pvalue = LRELOP_EQ;
            return LRELOP_CLASS;
        case '>':
            *pvalue = LRELOP_GT;
            return LRELOP_CLASS;
        case '<':
            *pvalue = LRELOP_LT;
            return LRELOP_CLASS;
        case '!':
            if (*pchCommand != '=')
                break;
            pchCommand++;
            *pvalue = LRELOP_NE;
            return LRELOP_CLASS;
        case '~':
            *pvalue = UNOP_NOT;
            return UNOP_CLASS;
        case '(':
            return LPAREN_CLASS;
        case ')':
            return RPAREN_CLASS;
        case '[':
            return LBRACK_CLASS;
        case ']':
            return RBRACK_CLASS;
        case '.':
               GetRegPCValue(&tempAddr);
               *pvalue = tempAddr;
               return NUMBER_CLASS;
        case ':':
            *pvalue = MULOP_SEG;
            return MULOP_CLASS;
        }

    //  special prefixes - '@' for register - '!' for symbol

    if (chlow == '@' || chlow == '!') {
        fForceReg = (BOOLEAN)(chlow == '@');
        fForceSym = (BOOLEAN)!fForceReg;
        fNumber = FALSE;
        ch = *pchCommand++;
        chlow = (UCHAR)tolower(ch);
        }

    //  if string is followed by '!', but not '!=',
    //      then it is a module name and treat as text

    pchCmdSave = pchCommand;

    while ((chlow >= 'a' && chlow <= 'z') ||
           (chlow >= '0' && chlow <= '9') ||
           (chlow == '_') || (chlow == '$')) {
        chlow = (UCHAR)tolower(*pchCommand); pchCommand++;
    }

    //  treat as symbol if a nonnull string is followed by '!',
    //      but not '!='

    if (chlow == '!' && *pchCommand != '=' && pchCmdSave != pchCommand)
        fNumber = FALSE;

    pchCommand = pchCmdSave;
    chlow = (UCHAR)tolower(ch);       //  ch was NOT modified


    if (fNumber) {
        if (chlow == '\'') {
            *pvalue = 0;
            while (TRUE) {
                ch = *pchCommand++;
                if (ch == '\'') {
                    if (*pchCommand != '\'') {
                        break;
                        }
                    ch = *pchCommand++;
                    }
                else
                if (ch == '\\') {
                    ch = *pchCommand++;
                    }
                *pvalue = (*pvalue << 8) | ch;
                }

            return NUMBER_CLASS;
            }

        //  if first character is a decimal digit, it cannot
        //  be a symbol.  leading '0' implies octal, except
        //  a leading '0x' implies hexadecimal.

        if (chlow >= '0' && chlow <= '9') {
            if (fForceReg) {
                *pvalue = SYNTAX;
                return ERROR_CLASS;
                }
            fSymbol = FALSE;
            if (chlow == '0') {
                ch = *pchCommand++;
                chlow = (UCHAR)tolower(ch);
                if (chlow == 'x') {
                    base = 16;
                    ch = *pchCommand++;
                    chlow = (UCHAR)tolower(ch);
                    fDigit = TRUE;
                    }
                else if (chlow == 'n') {
                    base = 10;
                    ch = *pchCommand++;
                    chlow = (UCHAR)tolower(ch);
                    }
                else {
                    base = 8;
                    fDigit = TRUE;
                    }
                }
            }

        //  a number can start with a letter only if base is
        //  hexadecimal and it is a hexadecimal digit 'a'-'f'.

        else if ((chlow < 'a' || chlow > 'f') || base != 16)
            fNumber = FALSE;

        //  set limit characters for the appropriate base.

        if (base == 8)
            limit1 = '7';
        if (base == 16)
            limit2 = 'f';
        }

    //  perform processing while character is a letter,
    //  digit, underscore, or dollar-sign.

    while ((chlow >= 'a' && chlow <= 'z') ||
           (chlow >= '0' && chlow <= '9') ||
           (chlow == '_') || (chlow == '$')) {

        //  if possible number, test if within proper range,
        //  and if so, accumulate sum.

        if (fNumber) {
            if ((chlow >= '0' && chlow <= limit1) ||
                    (chlow >= 'a' && chlow <= limit2)) {
                fDigit = TRUE;
                tmpvalue = value * base;
                if (tmpvalue < value)
                    errNumber = OVERFLOW;
                chtemp = (UCHAR)(chlow - '0');
                if (chtemp > 9)
                    chtemp -= 'a' - '0' - 10;
                value = tmpvalue + (ULONG)chtemp;
                if (value < tmpvalue)
                    errNumber = OVERFLOW;
                }
            else {
                fNumber = FALSE;
                errNumber = SYNTAX;
                }
            }
        if (fSymbol) {
            if (cbSymbol < 9)
                chPreSym[cbSymbol] = chlow;
            if (cbSymbol < SYMBOLSIZE - 1)
                chSymbol[cbSymbol++] = ch;
            }
        ch = *pchCommand++;
        chlow = (UCHAR)tolower(ch);
        }

    //  back up pointer to first character after token.

    pchCommand--;

    if (cbSymbol < 9)
        chPreSym[cbSymbol] = '\0';

    //  if fForceReg, check for register name and return
    //      success or failure

    if (fForceReg) {
        if ((*pvalue = GetRegString((LPSTR)chPreSym)) != -1)
            return REG_CLASS;
        else {
            *pvalue = BADREG;
            return ERROR_CLASS;
            }
        }

    //  test if number

    if (fNumber && !errNumber && fDigit) {
        *pvalue = value;
        return NUMBER_CLASS;
        }

    //  next test for reserved word and symbol string

    if (fSymbol && !fForceReg) {

        //  check lowercase string in chPreSym for text operator
        //  or register name.
        //  otherwise, return symbol value from name in chSymbol.

        if (!fForceSym && (cbSymbol == 2 || cbSymbol == 3))
            for (index = 0; index < RESERVESIZE; index++)
                if (!strncmp((LPSTR)chPreSym, (LPSTR)Reserved[index].chRes, 3)) {
                    *pvalue = Reserved[index].valueRes;
                    return Reserved[index].classRes;
                    }

        //  start processing string as symbol

        chSymbol[cbSymbol] = '\0';

        //  test if symbol is a module name (followed by '!')
        //  if so, get next token and treat as symbol

        if (PeekChar() == '!') {
            // chSymbolString holds the name of the symbol to be searched.
            // chSymbol holds the symbol image file name.

            pchCommand++;
            ch = PeekChar();
            pchCommand++;
            cbSymbol = 0;
            while ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') ||
                   (ch >= '0' && ch <= '9') || (ch == '_') || (ch == '$') || (ch == '.')) {
                chSymbolString[cbSymbol++] = ch;
                ch = *pchCommand++;
            }
            chSymbolString[cbSymbol] = '\0';
            pchCommand--;

            LPSTR SymName = (LPSTR) MemAlloc( strlen((LPSTR)chSymbol) + strlen((LPSTR)chSymbolString) + 32 );
            if (SymName) {
                strcpy( SymName, (LPSTR) chSymbol );
                strcat( SymName, "!" );
                strcat( SymName, (LPSTR) chSymbolString );

                if (GetOffsetFromSym( SymName, (PULONG_PTR) pvalue )) {
                    MemFree( SymName );
                    tempAddr = *pvalue;
                    return SYMBOL_CLASS;
                }

                MemFree( SymName );
            }

        } else {

            if (GetOffsetFromSym( (LPSTR) chSymbol, (PULONG_PTR) pvalue )) {
                tempAddr = *pvalue;
                return SYMBOL_CLASS;
            }
        }

        //  symbol is undefined.
        //  if a possible hex number, do not set the error type

        if (!fNumber) {
            errNumber = VARDEF;
        }
    }

    //  last chance, undefined symbol and illegal number,
    //      so test for register, will handle old format

    if (!fForceSym && (*pvalue = GetRegString((LPSTR)chPreSym)) != -1)
        return REG_CLASS;

    //  no success, so set error message and return

    *pvalue = (ULONG)errNumber;
    return ERROR_CLASS;
}

BOOLEAN
SymbolOnlyExpr(
    VOID
    )
{
    PUCHAR  pchComSaved = pchCommand;
    LONG_PTR pvalue;
    ULONG   cclass;
    BOOLEAN fResult;

    fResult = (BOOLEAN)(NextToken(&pvalue) == SYMBOL_CLASS &&
                (cclass = NextToken(&pvalue)) != ADDOP_CLASS &&
                cclass != MULOP_CLASS && cclass != LOGOP_CLASS);
    pchCommand = pchComSaved;
    return fResult;
}

/*** LookupSymbolInDll - Find the numeric value for a symbol from a
*                        specific DLL
*
*   Input:
*       symName - string with the symbol name to lookup
*       dllName - string with dll name in which to look
*
*   Output:
*       none
*
*   Returns:
*       returns value of symbol, or 0 if no symbol found in this dll.
*
*************************************************************************/

ULONG
LookupSymbolInDll (
    PCHAR symName,
    PCHAR dllName
    )
{
    ULONG           retValue;
    //PMODULE_ENTRY   Module;
    char            *imageStr;
    char            *dllStr;


    // skip over whitespace
    while (*symName == ' ' || *symName == '\t') {
        symName++;
    }

    dllStr = _strdup(dllName);
    _strlwr(dllStr);

    //  First check all the exported symbols, if none found on
    //      first pass, force symbol load on second.

// should call module.c
#if 0
    for (pImage = pProcessCurrent->pImageHead;
         pImage;
         pImage = pImage->pImageNext) {
        imageStr = _strdup(pImage->szModuleName);
        _strlwr(imageStr);
        if (!strcmp(imageStr,dllStr)) {
            GetOffsetFromSym(symName, &retValue, pImage->index);
            free(imageStr);
            free(dllStr);
            return(retValue);
        }
        free(imageStr);
    }
#endif
    free(dllStr);
    return(0);
}


BOOL
GetMemByte(
    ULONG_PTR Address,
    PUCHAR  Value
    )
{
    ULONG cb = ReadMemory(
        CurrProcess,
        (PVOID) Address,
        (PVOID) Value,
        sizeof(UCHAR)
        );
    return cb > 0;
}

BOOL
GetMemWord(
    ULONG_PTR   Address,
    PUSHORT Value
    )
{
    ULONG cb = ReadMemory(
        CurrProcess,
        (PVOID) Address,
        (PVOID) Value,
        sizeof(USHORT)
        );
    return cb > 0;
}

BOOL
GetMemDword(
    ULONG_PTR   Address,
    PULONG  Value
    )
{
    ULONG cb = ReadMemory(
        CurrProcess,
        (PVOID) Address,
        (PVOID) Value,
        sizeof(DWORD)
        );
    return cb > 0;
}

ULONG
GetMemString(
    ULONG_PTR   Address,
    PUCHAR  Value,
    ULONG   Length
    )
{
    ULONG cb = ReadMemory(
        CurrProcess,
        (PVOID) Address,
        (PVOID) Value,
        Length
        );
    return Length;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\ntheap.c ===
#pragma warning(4:4005)

#include <nt.h>
#include <ntrtl.h>
//#include <ntrtlp.h>
#undef LOBYTE
#undef HIBYTE
#include <nturtl.h>
//#include <heap.h>
#include <windows.h>

typedef __int64 LONGLONG;
typedef unsigned __int64 DWORDLONG;

#include "apimonp.h"

extern CLINKAGE BOOL RunningOnNT;


typedef NTSTATUS (NTAPI *PNTQUERYINFORMATIONPROCESS)(HANDLE,PROCESSINFOCLASS,PVOID,ULONG,PULONG);
typedef NTSTATUS (NTAPI *PNTSETINFORMATIONPROCESS)(HANDLE,PROCESSINFOCLASS,PVOID,ULONG);

PNTQUERYINFORMATIONPROCESS  pNtQueryInformationProcess;
PNTSETINFORMATIONPROCESS    pNtSetInformationProcess;


CLINKAGE VOID
DisableHeapChecking(
    HANDLE  hProcess,
    PVOID   HeapHandle
    )
{
#if 0

    the heap package should export an entrypoint to disable heap checking globally in a process\
    until that happens, this functionality is just plain disabled. The heap structures are not accessible
    outside of the base project


    HEAP Heap;


    if (!RunningOnNT) {
        return;
    }

    if (!ReadMemory( hProcess, HeapHandle, &Heap, sizeof(HEAP) )) {
        return;
    }

    if (Heap.Signature != HEAP_SIGNATURE) {
        return;
    }

    Heap.Flags &= ~(HEAP_VALIDATE_PARAMETERS_ENABLED |
                    HEAP_VALIDATE_ALL_ENABLED        |
                    HEAP_TAIL_CHECKING_ENABLED       |
                    HEAP_FREE_CHECKING_ENABLED
                   );

    if (!WriteMemory( hProcess, HeapHandle, &Heap, sizeof(HEAP) )) {
        return;
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\graph.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    graph.cpp

Abstract:

    All user interface code for the bar graph window.

Author:

    Wesley Witt (wesw) Nov-20-1995

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

#include "apimonwn.h"



GraphWindow::GraphWindow()
{
    GraphCursor      = LoadCursor( hInstance, MAKEINTRESOURCE( IDC_HAND_INTERNAL) );
    HorizSplitCursor = LoadCursor( hInstance, MAKEINTRESOURCE( IDC_HSPLIT) );
    ArrowCursor      = LoadCursor( NULL, IDC_ARROW );
    hwndToolTip      = NULL;
    Bar              = NULL;
    GraphData        = NULL;
    hCursor          = NULL;
    hwndLegend       = NULL;
    ApiGraph         = FALSE;
    MouseDown        = FALSE;
    ZeroMemory( &tm, sizeof(TEXTMETRIC) );
    ZeroMemory( &LastPos, sizeof(POINT) );
}


GraphWindow::~GraphWindow()
{
    DeleteObject( GraphCursor );
    DeleteObject( HorizSplitCursor );
    DeleteObject( ArrowCursor );
}


BOOL
GraphWindow::Create(BOOL isbase)
{
    Base = isbase;
    return ApiMonWindow::Create(
        "ApiMonGraph",
        "Graph"
        );
}

BOOL
GraphWindow::Register()
{
    return ApiMonWindow::Register(
        "ApiMonGraph",
        IDI_CHILDICON,
        MDIChildWndProcGraph
        );
}


BOOL
GraphWindow::Update(
    BOOL    ForceUpdate
    )
{
    return FALSE;
}


void
GraphWindow::ChangeFont(
    HFONT hFont
    )
{
    ApiMonWindow::hFont = hFont;
    PostMessage( hwndWin, WM_FONT_CHANGE, 0, (LPARAM) hFont );
}


void
GraphWindow::ChangeColor(
    COLORREF    Color
    )
{
    ApiMonWindow::Color = Color;
    PostMessage( hwndWin, WM_COLOR_CHANGE, 0, (LPARAM) Color );
}


PGRAPH_DATA
GraphWindow::CreateGraphData()
{
    ULONG       i;
    ULONG       j;
    ULONG       Cnt;
    PAPI_INFO   ApiInfo;
    PGRAPH_DATA GraphData;


    for (Cnt=0,i=0; i<MAX_DLLS; i++) {
        DllList[i].Hits = 0;
        if (DllList[i].BaseAddress && DllList[i].ApiCount) {
            ApiInfo = (PAPI_INFO)(DllList[i].ApiOffset + (PUCHAR)DllList);
            for (j=0; j<DllList[i].ApiCount; j++) {
                if (ApiInfo[j].Time) {
                    DllList[i].Hits += 1;
                }
            }
            if (DllList[i].Hits) {
                Cnt += 1;
            }
        }
    }
    if (!Cnt) {
        return NULL;
    }

    i = sizeof(GRAPH_DATA) + (sizeof(GRAPH_VALUE) * Cnt);
    GraphData = (PGRAPH_DATA) LocalAlloc( LPTR, i );
    if (!GraphData) {
        return NULL;
    }
    ZeroMemory( GraphData, i );

    GraphData->NumberOfBars = Cnt;
    for (Cnt=0,i=0; i<MAX_DLLS; i++) {
        if (DllList[i].Hits) {
            GraphData->Bar[Cnt].Value = 0;
            GraphData->Bar[Cnt].Address = DllList[i].BaseAddress;
            strcpy( GraphData->Bar[Cnt].Name, DllList[i].Name );
            ApiInfo = (PAPI_INFO)(DllList[i].ApiOffset + (PUCHAR)DllList);
            for (j=0; j<DllList[i].ApiCount; j++) {
                if (ApiInfo[j].Time) {
                    GraphData->Bar[Cnt].Value += ApiInfo[j].Time;
                    GraphData->Bar[Cnt].Hits  += ApiInfo[j].Count;
                }
            }
            Cnt += 1;
        }
    }

    return GraphData;
}

PGRAPH_DATA
GraphWindow::CreateGraphDataApi(
    ULONG_PTR   BaseAddress
    )
{
    ULONG i;
    ULONG Cnt = 0;
    PAPI_INFO ApiInfo;
    PGRAPH_DATA GraphData;
    PDLL_INFO DllInfo = NULL;


    for (i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress == BaseAddress) {
            DllInfo = &DllList[i];
            ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (PUCHAR)DllList);
            break;
        }
    }
    if (!DllInfo) {
        return NULL;
    }

    for (i=0; i<DllInfo->ApiCount; i++) {
        if (ApiInfo[i].Time) {
            Cnt += 1;
        }
    }

    i = sizeof(GRAPH_DATA) * (sizeof(GRAPH_VALUE) * Cnt);
    GraphData = (PGRAPH_DATA) LocalAlloc( LPTR, i );
    if (!GraphData) {
        return NULL;
    }
    ZeroMemory( GraphData, i );

    GraphData->NumberOfBars = Cnt;
    for (Cnt=0,i=0; i<DllInfo->ApiCount; i++) {
        if (ApiInfo[i].Time) {
            GraphData->Bar[Cnt].Value = ApiInfo[i].Time;
            GraphData->Bar[Cnt].Address = ApiInfo[i].Address;
            GraphData->Bar[Cnt].Hits = ApiInfo[i].Count;
            strcpy( GraphData->Bar[Cnt].Name, (LPSTR)(ApiInfo[i].Name+(LPSTR)MemPtr) );
            Cnt += 1;
        }
    }

    return GraphData;
}

BOOL
GraphWindow::DrawBarGraph(
    PGRAPH_DATA GraphData
    )
{
    if (!GraphData) {
        return FALSE;
    }

    PAINTSTRUCT ps;
    HDC hdc = BeginPaint( hwndWin, &ps );
    if (!hdc) {
        return FALSE;
    }

    ULONG i,j;
    ULONG LongestName = 0;
    ULONG Cnt;
    RECT rc;
    HBRUSH hBrush;
    ULONG LegendHeight = 0;
    TEXTMETRIC tm;
    GetClientRect( hwndWin, &rc );

    LONGLONG HighValue = 0;

    //
    // first iterate thru the values and
    // determine if it has a count.  if there is
    // a count then assign a color
    //
    for (i=0; i<GraphData->NumberOfBars; i++) {
        if (GraphData->Bar[i].Value > HighValue) {
            HighValue = GraphData->Bar[i].Value;
        }
        if (strlen(GraphData->Bar[i].Name) > LongestName) {
            LongestName = strlen(GraphData->Bar[i].Name);
        }
    }

    if (!HighValue) {
        HighValue = 1;
    }

    for (i=0,Cnt=0; i<GraphData->NumberOfBars; i++) {
        GraphData->Bar[i].Pct = (float) ((float)GraphData->Bar[i].Value / (float)HighValue);
        if (GraphData->Bar[i].Pct < .01) {
            GraphData->Bar[i].Pct = (float) .01;
        }
        if (ApiMonOptions.FilterGraphs) {
            j = (ULONG) (GraphData->Bar[i].Pct * 100.0);
            if (j < (ULONG)ApiMonOptions.GraphFilterValue) {
                continue;
            }
        }
        if (GraphData->Bar[i].Value) {
            GraphData->Bar[i].Color = CustomColors[Cnt%NUMBER_OF_CUSTOM_COLORS];
            Cnt += 1;
        }
    }

    if (GraphData->DrawLegend) {
        //
        // next, draw the legend at the bottom of the window
        //
        SetBkColor( hdc, GetSysColor( COLOR_3DFACE ) );
        SelectObject( hdc, hFont );
        GetTextMetrics( hdc, &tm );
        GetClientRect( hwndWin, &rc );
        LegendHeight = GraphData->LegendRect.bottom - GraphData->LegendRect.top;
        rc.top = rc.bottom - LegendHeight - LEGEND_LINE_HEIGHT;
        rc.bottom = rc.top + LEGEND_LINE_HEIGHT;
        GraphData->SplitRect = rc;
        GraphData->SplitRect.top += (LEGEND_LINE_HEIGHT / 2);
        GraphData->SplitRect.bottom -= ((LEGEND_LINE_HEIGHT / 2) - 1);
        DrawEdge( hdc, &rc, EDGE_RAISED, BF_TOP | BF_BOTTOM | BF_MIDDLE );
        SendMessage( hwndLegend, WM_SETREDRAW, FALSE, 0 );
        SendMessage( hwndLegend, LB_RESETCONTENT, 0, 0 );
        for (i=0,j=0; i<GraphData->NumberOfBars; i++) {
            if (ApiMonOptions.FilterGraphs) {
                j = (ULONG) (GraphData->Bar[i].Pct * 100.0);
                if (j < (ULONG)ApiMonOptions.GraphFilterValue) {
                    continue;
                }
            }
            if (GraphData->Bar[i].Value) {
                SendMessage( hwndLegend, LB_ADDSTRING, 0, (LPARAM) &GraphData->Bar[i] );
            }
        }
        SendMessage( hwndLegend, WM_SETREDRAW, TRUE, 0 );
        LegendHeight += (LEGEND_LINE_HEIGHT + BAR_SEP);
    }

    //
    // now draw the bars
    //

    GetClientRect( hwndWin, &rc );
    rc.bottom -= LegendHeight;
    rc.top += BAR_SEP;

    ULONG BarWidth = (rc.right - rc.left - BAR_SEP - (Cnt * BAR_SEP)) / Cnt;
    ULONG BarLeft = rc.left + BAR_SEP;
    ULONG BarTop = 0;
    ULONG BarBottom = rc.bottom - BAR_SEP;


    for (i=0; i<GraphData->NumberOfBars; i++) {
        if (!GraphData->Bar[i].Value) {
            continue;
        }

        if (ApiMonOptions.FilterGraphs) {
            j = (ULONG) (GraphData->Bar[i].Pct * 100.0);
            if (j < (ULONG)ApiMonOptions.GraphFilterValue) {
                continue;
            }
        }

        BarTop = (ULONG) (GraphData->Bar[i].Pct * (float)(BarBottom-BAR_SEP));
        BarTop = BarBottom - BarTop;

        SetRect(
            &GraphData->Bar[i].Rect,
            BarLeft,
            BarTop,
            BarLeft + BarWidth,
            BarBottom
            );

        hBrush = CreateSolidBrush( GraphData->Bar[i].Color );
        if (hBrush) {
            SelectObject( hdc, hBrush );

            Rectangle(
                hdc,
                BarLeft,
                BarTop,
                BarLeft + BarWidth,
                BarBottom
                );

            DeleteObject( hBrush );
        }

        BarLeft += (BarWidth + BAR_SEP);

    }

    EndPaint( hwndWin, &ps );

    return TRUE;
}


void
GraphWindow::ChangeToolTipsRect(
    PGRAPH_DATA GraphData
    )
{
    for (ULONG i=0; i<GraphData->NumberOfBars; i++) {
        TOOLINFO ti;

        ti.cbSize    = sizeof(TOOLINFO);
        ti.uFlags    = 0;
        ti.hwnd      = hwndWin;
        ti.uId       = i;
        ti.rect      = GraphData->Bar[i].Rect;
        ti.hinst     = NULL;
        ti.lpszText  = GraphData->Bar[i].Name;

        SendMessage( hwndToolTip, TTM_NEWTOOLRECT, 0, (LPARAM) &ti );
    }
}


void
GraphWindow::CreateToolTips(
    PGRAPH_DATA GraphData
    )
{
    for (ULONG i=0; i<GraphData->NumberOfBars; i++) {
        TOOLINFO ti;

        ti.cbSize    = sizeof(TOOLINFO);
        ti.uFlags    = 0;
        ti.hwnd      = hwndWin;
        ti.uId       = i;
        ti.rect      = GraphData->Bar[i].Rect;
        ti.hinst     = NULL;
        ti.lpszText  = GraphData->Bar[i].Name;

        SendMessage( hwndToolTip, TTM_ADDTOOL, 0, (LPARAM) &ti );
    }
}


void
GraphWindow::DeleteToolTips(
    PGRAPH_DATA GraphData
    )
{
    for (ULONG i=0; i<GraphData->NumberOfBars; i++) {
        TOOLINFO ti;

        ti.cbSize    = sizeof(TOOLINFO);
        ti.uFlags    = 0;
        ti.hwnd      = hwndWin;
        ti.uId       = i;
        ti.rect      = GraphData->Bar[i].Rect;
        ti.hinst     = NULL;
        ti.lpszText  = GraphData->Bar[i].Name;

        SendMessage( hwndToolTip, TTM_DELTOOL, 0, (LPARAM) &ti );
    }
}


BOOL CALLBACK
ChildWindowEnumerator(
    HWND    hwnd,
    LPARAM  lParam
    )
{
    PFONT_COLOR_CHANGE FontColor = (PFONT_COLOR_CHANGE) lParam;
    CHAR ClassName[64];
    if (hwnd == FontColor->hwndGraph) {
        return TRUE;
    }
    if (!GetClassName( hwnd, ClassName, sizeof(ClassName)-1 )) {
        return TRUE;
    }
    if (strcmp(ClassName, "ApiMonGraph") == 0) {
        if (FontColor->GraphFont) {
            SendMessage(
                hwnd,
                WM_FONT_CHANGE,
                1,
                (LPARAM) FontColor->GraphFont
                );
        } else {
            SendMessage(
                hwnd,
                WM_COLOR_CHANGE,
                1,
                (LPARAM) FontColor->GraphColor
                );
        }
    }

    return TRUE;
}

LRESULT CALLBACK
MDIChildWndProcGraph(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    GraphWindow         *gw = (GraphWindow*) GetWindowLongPtr( hwnd, GWLP_USERDATA );
    PGRAPH_VALUE        Bar;
    ULONG               i;
    BOOL                IsInRect;
    POINT               pt;
    MSG                 msg;
    LPMEASUREITEMSTRUCT mis;
    LPDRAWITEMSTRUCT    dis;
    HDC                 hdc;
    RECT                rc;
    HBRUSH              hBrush;
    CHAR                buf[1024];
    CHAR                tmp1[32];
    CHAR                tmp2[32];
    int                 hdcSave;
    FONT_COLOR_CHANGE   FontColor;
    double              dTime;


    switch (uMessage) {
        case WM_CREATE:
            gw = (GraphWindow*) ((LPMDICREATESTRUCT)(((LPCREATESTRUCT)lParam)->lpCreateParams))->lParam;
            SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR) gw );
            if (gw->Base) {
                ReallyDisableToolbarState(IDM_GRAPH);
            }
            gw->hCursor = gw->ArrowCursor;
            hdc = GetDC( hwnd );
            if (!hdc)
                return 1;
            SelectObject( hdc, gw->hFont );
            GetTextMetrics( hdc, &gw->tm );
            ReleaseDC( hwnd, hdc );
            gw->hwndToolTip = CreateWindow(
                TOOLTIPS_CLASS,
                NULL,
                TTS_ALWAYSTIP,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                hwnd,
                NULL,
                gw->hInstance,
                NULL
                );
            PostMessage( hwnd, WM_CREATE_GRAPH, 0, 0 );
            break;

        case WM_CREATE_GRAPH:
            if (gw->ApiGraph) {
                gw->GraphData = gw->CreateGraphDataApi( gw->Bar->Address );
                SetWindowText( hwnd, gw->Bar->Name );
            } else {
                gw->GraphData = gw->CreateGraphData();
                SetWindowText( hwnd, ApiMonOptions.ProgName );
            }
            if (gw->GraphData) {
                gw->GraphData->DrawLegend = ApiMonOptions.DisplayLegends;
                GetClientRect( hwnd, &rc );
                gw->GraphData->LegendRect.left   = rc.left;
                gw->GraphData->LegendRect.top    = rc.bottom - LEGEND_HEIGHT(gw->tm.tmHeight,LEGEND_DEFAULT_LINES);
                gw->GraphData->LegendRect.right  = rc.right;
                gw->GraphData->LegendRect.bottom = rc.bottom;
                gw->CreateToolTips( gw->GraphData );
            }
            return 0;

        case WM_SIZE:
            if (gw->GraphData) {
                GetClientRect( hwnd, &rc );
                gw->GraphData->LegendRect.top     = rc.bottom -
                    (gw->GraphData->LegendRect.bottom - gw->GraphData->LegendRect.top);
                gw->GraphData->LegendRect.left    = rc.left;
                gw->GraphData->LegendRect.bottom  = rc.bottom;
                gw->GraphData->LegendRect.right   = rc.right;
                MoveWindow(
                    gw->hwndLegend,
                    gw->GraphData->LegendRect.left,
                    gw->GraphData->LegendRect.top,
                    gw->GraphData->LegendRect.right - gw->GraphData->LegendRect.left,
                    gw->GraphData->LegendRect.bottom - gw->GraphData->LegendRect.top,
                    TRUE
                    );
                InvalidateRect( hwnd, NULL, TRUE );
                UpdateWindow( hwnd );
            }
            return 0;

        case WM_SETFOCUS:
            ChildFocus = CHILD_GRAPH;
            break;

        case WM_KILLFOCUS:
            break;

        case WM_PAINT:
            if ((!gw->GraphData->DrawLegend) && gw->hwndLegend) {
                DestroyWindow( gw->hwndLegend );
                gw->hwndLegend = NULL;
            } else if (gw->GraphData->DrawLegend && (!gw->hwndLegend)) {
                gw->hwndLegend = CreateWindow(
                    "LISTBOX",
                    NULL,
                    WS_VSCROLL                 |
                        WS_HSCROLL             |
                        WS_CHILD               |
                        WS_VISIBLE             |
                        LBS_NOSEL              |
                        LBS_NOINTEGRALHEIGHT   |
                        LBS_OWNERDRAWFIXED,
                    gw->GraphData->LegendRect.left,
                    gw->GraphData->LegendRect.top,
                    gw->GraphData->LegendRect.right - gw->GraphData->LegendRect.left,
                    gw->GraphData->LegendRect.bottom - gw->GraphData->LegendRect.top,
                    hwnd,
                    NULL,
                    GetModuleHandle( NULL ),
                    NULL
                    );
            }
            gw->DrawBarGraph( gw->GraphData );
            if (gw->hwndToolTip) {
                gw->ChangeToolTipsRect( gw->GraphData );
            }
            return 0;

        case WM_FONT_CHANGE:
            gw->hFont = (HFONT) lParam;
            hdc = GetDC( hwnd );
            if (!hdc)
                return 1;
            SelectObject( hdc, gw->hFont );
            GetTextMetrics( hdc, &gw->tm );
            ReleaseDC( hwnd, hdc );
            SendMessage( gw->hwndLegend, LB_SETITEMHEIGHT, 0, MAKELPARAM( LEGEND_ITEM_HEIGHT(gw->tm.tmHeight), 0 ) );
            InvalidateRect( hwnd, NULL, TRUE );
            UpdateWindow( hwnd );
            if (!wParam && !gw->ApiGraph) {
                FontColor.GraphFont = gw->hFont;
                FontColor.GraphColor = 0;
                FontColor.hwndGraph = hwnd;
                EnumChildWindows( hwndMDIClient, ChildWindowEnumerator, (LPARAM) &FontColor );
            }
            return 0;

        case WM_COLOR_CHANGE:
            gw->Color = (COLORREF) lParam;
            InvalidateRect( hwnd, NULL, TRUE );
            UpdateWindow( hwnd );
            if (!wParam && !gw->ApiGraph) {
                FontColor.GraphColor = gw->Color;
                FontColor.GraphFont = NULL;
                FontColor.hwndGraph = hwnd;
                EnumChildWindows( hwndMDIClient, ChildWindowEnumerator, (LPARAM) &FontColor );
            }
            return 0;

        case WM_TOGGLE_LEGEND:
            if (gw->GraphData->DrawLegend) {
                gw->GraphData->DrawLegend = FALSE;
            } else {
                gw->GraphData->DrawLegend = TRUE;
            }
            InvalidateRect( hwnd, NULL, TRUE );
            UpdateWindow( hwnd );
            return 0;

        case WM_CTLCOLORLISTBOX:
            if ((HWND)lParam == gw->hwndLegend) {
                SetBkColor( (HDC)wParam, gw->Color );
                return (LPARAM)CreateSolidBrush( gw->Color );
            }
            break;

        case WM_MOUSEMOVE:
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);
            IsInRect = FALSE;
            if (gw->MouseDown) {
                //
                // the slider bar is being dragged
                //
                if (!(wParam & MK_LBUTTON)) {
                    gw->MouseDown = FALSE;
                    ReleaseCapture();
                    return 0;
                }

                if (pt.y < gw->GraphData->SplitRect.top) {
                    //
                    // going up
                    //
                    gw->GraphData->LegendRect.top += (pt.y - gw->LastPos.y);
                } else if (pt.y > gw->GraphData->SplitRect.bottom) {
                    //
                    // going down
                    //
                    gw->GraphData->LegendRect.top -= (gw->LastPos.y - pt.y);
                }
                MoveWindow(
                    gw->hwndLegend,
                    gw->GraphData->LegendRect.left,
                    gw->GraphData->LegendRect.top,
                    gw->GraphData->LegendRect.right - gw->GraphData->LegendRect.left,
                    gw->GraphData->LegendRect.bottom - gw->GraphData->LegendRect.top,
                    TRUE
                    );
                IsInRect = TRUE;
                InvalidateRect( hwnd, NULL, TRUE );
                UpdateWindow( hwnd );
            } else {
                for (i=0; i<gw->GraphData->NumberOfBars; i++) {
                    if (gw->GraphData->Bar[i].Value) {
                        if (PtInRect( &gw->GraphData->Bar[i].Rect, pt )) {
                            gw->hCursor = gw->GraphCursor;
                            IsInRect = TRUE;
                            break;
                        }
                    }
                }
            }
            if (!IsInRect) {
                gw->hCursor = gw->ArrowCursor;
            }
            if (PtInRect( &gw->GraphData->SplitRect, pt )) {
                gw->hCursor = gw->HorizSplitCursor;
                IsInRect = TRUE;
            }
            SetCursor( gw->hCursor );
            msg.hwnd     = hwnd;
            msg.message  = uMessage;
            msg.wParam   = wParam;
            msg.lParam   = lParam;
            msg.time     = 0;
            msg.pt.x     = 0;
            msg.pt.y     = 0;
            SendMessage( gw->hwndToolTip, TTM_RELAYEVENT, 0, (LPARAM)&msg );
            gw->LastPos = pt;
            return 0;

        case WM_LBUTTONDOWN:
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);
            if (PtInRect( &gw->GraphData->SplitRect, pt )) {
                gw->MouseDown = TRUE;
                SetCapture( hwnd );
            }
            return 0;

        case WM_LBUTTONUP:
            gw->MouseDown = FALSE;
            ReleaseCapture();
            return 0;

        case WM_LBUTTONDBLCLK:
            if (gw->ApiGraph) {
                MessageBeep( MB_ICONEXCLAMATION );
                return 0;
            }
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);
            for (i=0; i<gw->GraphData->NumberOfBars; i++) {
                if (gw->GraphData->Bar[i].Value) {
                    if (PtInRect( &gw->GraphData->Bar[i].Rect, pt )) {
                        if (gw->GraphData->Bar[i].Used) {
                            MessageBeep( MB_ICONEXCLAMATION );
                            break;
                        }
                        GraphWindow *agw = new GraphWindow;
                        agw->ApiGraph = TRUE;
                        agw->Bar = &gw->GraphData->Bar[i];
                        agw->Create( FALSE );
                        agw->ChangeFont( gw->hFont );
                        agw->ChangeColor( gw->Color );
                        gw->GraphData->Bar[i].Used = TRUE;
                        break;
                    }
                }
            }
            return 0;

        case WM_MEASUREITEM:
            mis = (LPMEASUREITEMSTRUCT) lParam;
            mis->CtlType      = ODT_LISTBOX;
            mis->CtlID        = 0;
            mis->itemID       = 0;
            mis->itemWidth    = 0;
            mis->itemHeight   = LEGEND_ITEM_HEIGHT(gw->tm.tmHeight);
            mis->itemData     = 0;
            return 0;

        case WM_DRAWITEM:
            dis = (LPDRAWITEMSTRUCT) lParam;
            Bar = (PGRAPH_VALUE) dis->itemData;
            hdcSave = SaveDC( dis->hDC );
            SelectObject( dis->hDC, gw->hFont );
            hBrush = CreateSolidBrush( Bar->Color );
            if (!hBrush)
                return 1;
            SelectObject( dis->hDC, hBrush );
            Rectangle(
                dis->hDC,
                dis->rcItem.left+LEGEND_BORDER,
                dis->rcItem.top+LEGEND_SEP,
                dis->rcItem.left+LEGEND_COLOR_WIDTH,
                dis->rcItem.top+gw->tm.tmHeight
                );
            DeleteObject( hBrush );
            sprintf( tmp1, "Hits(%d)", Bar->Hits );

            dTime = (double)Bar->Value;
            if (!*FastCounterAvail)
                dTime *= MSecConv;
            sprintf( tmp2, "Time(%.4f)", dTime );

            sprintf( buf, "%-16s  %-12s %-24s", Bar->Name, tmp1, tmp2 );
            TextOut( dis->hDC, dis->rcItem.left+LEGEND_COLOR_WIDTH+LEGEND_BORDER, dis->rcItem.top, buf, strlen(buf) );
            RestoreDC( dis->hDC, hdcSave );
            return 0;

        case WM_DESTROY:
            if (gw->Bar) {
                gw->Bar->Used = FALSE;
            }
            if (gw->Base) {
                EnableToolbarState(IDM_GRAPH);
            }
            gw->DeleteToolTips( gw->GraphData );
            DeleteObject( gw->ArrowCursor );
            DeleteObject( gw->GraphCursor );
            DeleteObject( gw->HorizSplitCursor );
            DestroyWindow( gw->hwndToolTip );
            DestroyWindow( gw->hwndLegend );
            LocalFree( gw->GraphData );
            gw->ArrowCursor       = NULL;
            gw->GraphCursor       = NULL;
            gw->HorizSplitCursor  = NULL;
            gw->hwndToolTip       = NULL;
            gw->hwndLegend        = NULL;
            gw->GraphData         = NULL;
            gw->Bar               = NULL;
            return 0;
    }
    return DefMDIChildProc( hwnd, uMessage, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\optdlgs.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    optdlgs.cpp

Abstract:

    All user interface code for the options proprty sheet dialogs.

Author:

    Wesley Witt (wesw) Nov-20-1995

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop


BOOL
ValidateFileName(
    HWND    hdlg,
    UINT    id
    )
{
    CHAR buf[MAX_PATH*2];
    CHAR buf2[MAX_PATH*2];
    CHAR Drive[_MAX_DRIVE];
    CHAR Dir[_MAX_DIR];
    CHAR Fname[_MAX_FNAME];
    CHAR Ext[_MAX_EXT];



    GetDlgItemText( hdlg, id, buf, sizeof(buf) );
    ExpandEnvironmentStrings( buf, buf2, sizeof(buf2) );
    _splitpath( buf2, Drive, Dir, Fname, Ext );
    strcpy( buf, Drive );
    strcat( buf, Dir );
    if (GetFileAttributes( buf ) == 0xffffffff) {
        return FALSE;
    }
    return TRUE;
}


BOOL
ValidatePathName(
    HWND    hdlg,
    UINT    id
    )
{
    CHAR buf[MAX_PATH*10];
    CHAR buf2[MAX_PATH*10];
    LPSTR p,p1;


    GetDlgItemText( hdlg, id, buf, sizeof(buf) );
    ExpandEnvironmentStrings( buf, buf2, sizeof(buf2) );
    p = buf2;
    while( p && *p ) {
        p1 = strchr( p, ';' );
        if (p1 ) {
            *p1 = 0;
        }
        if (GetFileAttributes( p ) == 0xffffffff) {
            return FALSE;
        }
        p += strlen(p);
        if (p1 ) {
            *p1 = ';';
            p += 1;
        }
    }
    return TRUE;
}

INT_PTR
CALLBACK
FileNamesDialogProc(
    HWND    hdlg,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    static BOOL IgnoreChange = FALSE;

    switch (uMessage) {
        case WM_INITDIALOG:
            CenterWindow( GetParent( hdlg ), hwndFrame );
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == EN_CHANGE && (!IgnoreChange)) {
                SendMessage( GetParent(hdlg), PSM_CHANGED, (LPARAM)hdlg, 0 );
            }
            break;

        case WM_NOTIFY:
            switch (((LPNMHDR)lParam)->code) {
                case PSN_SETACTIVE:
                    IgnoreChange = TRUE;
                    SetDlgItemText( hdlg, IDC_LOG_FILE_NAME,   ApiMonOptions.LogFileName   );
                    SetDlgItemText( hdlg, IDC_TRACE_FILE_NAME, ApiMonOptions.TraceFileName );
                    SetDlgItemText( hdlg, IDC_SYMBOL_PATH,     ApiMonOptions.SymbolPath    );
                    IgnoreChange = FALSE;
                    break;

                case PSN_KILLACTIVE:
                    {
                        DWORD rslt = 0;
                        if (!ValidateFileName( hdlg, IDC_LOG_FILE_NAME )) {
                            PopUpMsg( "Invalid log file name" );
                            rslt = 1;
                        }
                        if (!ValidateFileName( hdlg, IDC_TRACE_FILE_NAME )) {
                            PopUpMsg( "Invalid trace file name" );
                            rslt = 1;
                        }
                        if (!ValidatePathName( hdlg, IDC_SYMBOL_PATH )) {
                            PopUpMsg( "Invalid symbol path" );
                            rslt = 1;
                        }
                        SetWindowLongPtr( hdlg, DWLP_MSGRESULT, rslt );
                    }
                    break;

                case PSN_APPLY:
                    GetDlgItemText( hdlg, IDC_LOG_FILE_NAME,   ApiMonOptions.LogFileName,   sizeof(ApiMonOptions.LogFileName)   );
                    GetDlgItemText( hdlg, IDC_TRACE_FILE_NAME, ApiMonOptions.TraceFileName, sizeof(ApiMonOptions.TraceFileName) );
                    GetDlgItemText( hdlg, IDC_SYMBOL_PATH,     ApiMonOptions.SymbolPath,    sizeof(ApiMonOptions.SymbolPath)    );
                    SaveOptions();
                    SendMessage( GetParent(hdlg), PSM_UNCHANGED, (LPARAM)hdlg, 0 );
                    SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
                    break;
            }
            break;

        case WM_HELP:
            {
                LPHELPINFO hi = (LPHELPINFO)lParam;
                ProcessHelpRequest( hdlg, hi->iCtrlId );
            }
            break;
    }
    return FALSE;
}

INT_PTR
CALLBACK
MiscDialogProc(
    HWND    hdlg,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch (uMessage) {
        case WM_INITDIALOG:
            CenterWindow( GetParent( hdlg ), hwndFrame );
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED) {
                SendMessage( GetParent(hdlg), PSM_CHANGED, (LPARAM)hdlg, 0 );
            }
            break;

        case WM_NOTIFY:
            switch (((LPNMHDR)lParam)->code) {
                case PSN_SETACTIVE:
                    CheckDlgButton( hdlg, IDC_ENABLE_TRACING,        ApiMonOptions.Tracing                      );
                    CheckDlgButton( hdlg, IDC_ENABLE_ALIASING,       ApiMonOptions.Aliasing                     );
                    CheckDlgButton( hdlg, IDC_DISABLE_HEAP,          ApiMonOptions.HeapChecking                 );
                    CheckDlgButton( hdlg, IDC_PRELOAD_SYMBOLS,       ApiMonOptions.PreLoadSymbols               );
                    CheckDlgButton( hdlg, IDC_ENABLE_COUNTERS,       ApiMonOptions.ApiCounters                  );
                    CheckDlgButton( hdlg, IDC_GO_IMMEDIATE,          ApiMonOptions.GoImmediate                  );
                    CheckDlgButton( hdlg, IDC_DISABLE_FAST_COUNTERS, ApiMonOptions.FastCounters                 );
                    CheckDlgButton( hdlg, IDC_USE_KNOWN_DLLS,        ApiMonOptions.UseKnownDlls                 );
                    CheckDlgButton( hdlg, IDC_EXCLUDE_KNOWN_DLLS,    ApiMonOptions.ExcludeKnownDlls             );
                    CheckDlgButton( hdlg, IDC_PAGE_FAULTS,           ApiMonOptions.MonitorPageFaults            );
                    CheckDlgButton( hdlg, IDC_AUTO_REFRESH,          ApiMonOptions.AutoRefresh            );
                    CheckDlgButton( hdlg, IDC_DEFSORT_NAME,          ApiMonOptions.DefaultSort == SortByName    );
                    CheckDlgButton( hdlg, IDC_DEFSORT_COUNTER,       ApiMonOptions.DefaultSort == SortByCounter );
                    CheckDlgButton( hdlg, IDC_DEFSORT_TIME,          ApiMonOptions.DefaultSort == SortByTime    );
                    break;

                case PSN_KILLACTIVE:
                    SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
                    break;

                case PSN_APPLY:
                    ApiMonOptions.Tracing           = IsDlgButtonChecked( hdlg, IDC_ENABLE_TRACING        );
                    ApiMonOptions.Aliasing          = IsDlgButtonChecked( hdlg, IDC_ENABLE_ALIASING       );
                    ApiMonOptions.HeapChecking      = IsDlgButtonChecked( hdlg, IDC_DISABLE_HEAP          );
                    ApiMonOptions.PreLoadSymbols    = IsDlgButtonChecked( hdlg, IDC_PRELOAD_SYMBOLS       );
                    ApiMonOptions.ApiCounters       = IsDlgButtonChecked( hdlg, IDC_ENABLE_COUNTERS       );
                    ApiMonOptions.GoImmediate       = IsDlgButtonChecked( hdlg, IDC_GO_IMMEDIATE          );
                    ApiMonOptions.FastCounters      = IsDlgButtonChecked( hdlg, IDC_DISABLE_FAST_COUNTERS );
                    ApiMonOptions.UseKnownDlls      = IsDlgButtonChecked( hdlg, IDC_USE_KNOWN_DLLS        );
                    ApiMonOptions.ExcludeKnownDlls  = IsDlgButtonChecked( hdlg, IDC_EXCLUDE_KNOWN_DLLS    );
                    ApiMonOptions.MonitorPageFaults = IsDlgButtonChecked( hdlg, IDC_PAGE_FAULTS           );
                    ApiMonOptions.AutoRefresh       = IsDlgButtonChecked( hdlg, IDC_AUTO_REFRESH          );
                    if (ApiMonOptions.MonitorPageFaults) {
                        ApiMonOptions.PreLoadSymbols = TRUE;
                    }
                    if (IsDlgButtonChecked( hdlg, IDC_DEFSORT_NAME )) {
                        ApiMonOptions.DefaultSort = SortByName;
                    }
                    if (IsDlgButtonChecked( hdlg, IDC_DEFSORT_COUNTER )) {
                        ApiMonOptions.DefaultSort = SortByCounter;
                    }
                    if (IsDlgButtonChecked( hdlg, IDC_DEFSORT_TIME )) {
                        ApiMonOptions.DefaultSort = SortByTime;
                    }
                    SaveOptions();

                    *ApiTraceEnabled = ApiMonOptions.Tracing || (KnownApis[0] != 0);

                    if (ApiMonOptions.FastCounters) {
                        *FastCounterAvail = FALSE;
                    } else {
                        SYSTEM_INFO SystemInfo;
                        GetSystemInfo( &SystemInfo );
                        *FastCounterAvail = (SystemInfo.dwProcessorType == PROCESSOR_INTEL_PENTIUM &&
                                            SystemInfo.dwNumberOfProcessors == 1);
                    }

                    SendMessage( GetParent(hdlg), PSM_UNCHANGED, (LPARAM)hdlg, 0 );
                    SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
                    break;
            }
            break;

        case WM_HELP:
            {
                LPHELPINFO hi = (LPHELPINFO)lParam;
                ProcessHelpRequest( hdlg, hi->iCtrlId );
            }
            break;
    }
    return FALSE;
}

INT_PTR
CALLBACK
KnownDllsDialogProc(
    HWND    hdlg,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    static HWND hwndDlls;

    switch (uMessage) {
        case WM_INITDIALOG:
            {
                hwndDlls = GetDlgItem( hdlg, IDC_KNOWN_DLLS );
                SetWindowContextHelpId( hwndDlls, IDH_DLLS_OPTIONS );
                CenterWindow( GetParent( hdlg ), hwndFrame );
                //
                // set/initialize the image list(s)
                //
                HIMAGELIST himlState = ImageList_Create( 16, 16, TRUE, 2, 0 );
                ImageList_AddMasked(
                    himlState,
                    LoadBitmap (GetModuleHandle(NULL),MAKEINTRESOURCE(IDB_CHECKSTATES)),
                    RGB (255,0,0)
                    );
                ListView_SetImageList( hwndDlls, himlState, LVSIL_STATE );
                //
                // set/initialize the columns
                //
                LV_COLUMN lvc = {0};
                lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                lvc.pszText = "DLL Name";
                lvc.iSubItem = 0;
                lvc.cx = 260;
                lvc.fmt = LVCFMT_LEFT;
                ListView_InsertColumn( hwndDlls, 0, &lvc );
            }
            // Fall into refresh case for initial list loading

        case WM_REFRESH_LIST:
            {
                LPSTR p = ApiMonOptions.KnownDlls;
                LV_ITEM lvi = {0};
                int iItem = 0;

                ListView_DeleteAllItems( hwndDlls );

                while( p && *p ) {
                    lvi.pszText = p;
                    lvi.iItem = iItem;
                    iItem += 1;
                    lvi.iSubItem = 0;
                    lvi.iImage = 0;
                    lvi.mask = LVIF_TEXT;
                    lvi.state = 0;
                    lvi.stateMask = 0;
                    ListView_InsertItem( hwndDlls, &lvi );
                    p += (strlen(p) + 1);
                }
            }
            break;

        case WM_NOTIFY:
            switch (((LPNMHDR)lParam)->code) {
                case PSN_KILLACTIVE:
                    SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
                    break;

                case PSN_APPLY:
                    SaveOptions();
                    SendMessage( GetParent(hdlg), PSM_UNCHANGED, (LPARAM)hdlg, 0 );
                    SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
                    break;

                case NM_CLICK:
                    {
                        DWORD dwpos = GetMessagePos();
                        LV_HITTESTINFO lvhti = {0};
                        lvhti.pt.x = LOWORD(dwpos);
                        lvhti.pt.y = HIWORD(dwpos);
                        MapWindowPoints( HWND_DESKTOP, hwndDlls, &lvhti.pt, 1 );
                        int iItemClicked = ListView_HitTest( hwndDlls, &lvhti );
                        if (iItemClicked == -1) {
                            //
                            // add a new item
                            //
                            LV_ITEM lvi = {0};
                            lvi.pszText = "";
                            lvi.iItem = ListView_GetItemCount( hwndDlls );
                            lvi.iSubItem = 0;
                            lvi.iImage = 0;
                            lvi.mask = LVIF_TEXT;
                            lvi.state = 0;
                            lvi.stateMask = 0;
                            iItemClicked = ListView_InsertItem( hwndDlls, &lvi );
                        }
                        ListView_EditLabel( hwndDlls, iItemClicked );
                    }
                    break;

                case LVN_ENDLABELEDIT:
                    {
                        LPSTR nk;
                        LPSTR p1;
                        LV_DISPINFO *DispInfo = (LV_DISPINFO*)lParam;
                        LPSTR p = ApiMonOptions.KnownDlls;
                        ULONG i = 0;

                        if (DispInfo->item.pszText == NULL || DispInfo->item.iItem == -1)
                            break;

                        nk = (LPSTR) MemAlloc( 2048 );
                        if (!nk) {
                            break;
                        }
                        p1 = nk;

                        while( i != (ULONG)DispInfo->item.iItem ) {
                            strcpy( p1, p );
                            p1 += (strlen(p) + 1);
                            p  += (strlen(p) + 1);
                            i += 1;
                        }
                        p  += (strlen(p) + 1);
                        if (DispInfo->item.pszText[0]) {
                            strcpy( p1, DispInfo->item.pszText );
                            p1 += (strlen(DispInfo->item.pszText) + 1);
                        }
                        while( p && *p ) {
                            strcpy( p1, p );
                            p1 += (strlen(p) + 1);
                            p  += (strlen(p) + 1);
                        }
                        *p1 = 0;
                        memcpy( ApiMonOptions.KnownDlls, nk, 2048 );
                        MemFree( nk );
                        PostMessage( hdlg, WM_REFRESH_LIST, 0, 0 );
                    }
                    break;
            }
            break;

        case WM_HELP:
            {
                LPHELPINFO hi = (LPHELPINFO)lParam;
                ProcessHelpRequest( hdlg, hi->iCtrlId );
            }
            break;
    }
    return FALSE;
}

INT_PTR
CALLBACK
GraphDialogProc(
    HWND    hdlg,
    UINT    uMessage,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    CHAR buf[64];
    switch (uMessage) {
        case WM_INITDIALOG:
            CenterWindow( GetParent( hdlg ), hwndFrame );
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED) {
                SendMessage( GetParent(hdlg), PSM_CHANGED, (LPARAM)hdlg, 0 );
            }
            break;


        case WM_HSCROLL:
            if ((HWND)lParam != GetDlgItem( hdlg, IDC_FILTER_SLIDER)) {
                return FALSE;
            }
            dprintf( "%d %d\n", LOWORD(wParam), HIWORD(wParam) );
            switch( LOWORD(wParam) ) {
                case TB_BOTTOM:
                    ApiMonOptions.GraphFilterValue = 100;
                    break;

                case TB_ENDTRACK:
                    break;

                case TB_LINEDOWN:
                    ApiMonOptions.GraphFilterValue += 1;
                    break;

                case TB_LINEUP:
                    ApiMonOptions.GraphFilterValue -= 1;
                    break;

                case TB_PAGEDOWN:
                    ApiMonOptions.GraphFilterValue += 10;
                    break;

                case TB_PAGEUP:
                    ApiMonOptions.GraphFilterValue -= 10;
                    break;

                case TB_THUMBPOSITION:
                    break;

                case TB_THUMBTRACK:
                    ApiMonOptions.GraphFilterValue = HIWORD(wParam);
                    break;

                case TB_TOP:
                    ApiMonOptions.GraphFilterValue = 1;
                    break;
            }
            if (ApiMonOptions.GraphFilterValue < 1) {
                MessageBeep( MB_ICONEXCLAMATION );
                ApiMonOptions.GraphFilterValue = 1;
            }
            if (ApiMonOptions.GraphFilterValue > 100) {
                MessageBeep( MB_ICONEXCLAMATION );
                ApiMonOptions.GraphFilterValue = 100;
            }
            _itoa( ApiMonOptions.GraphFilterValue, buf, 10 );
            SetDlgItemText( hdlg, IDC_FILTER_NUMBER, buf );
            break;

        case WM_NOTIFY:
            switch (((LPNMHDR)lParam)->code) {
                case PSN_SETACTIVE:
                    SendMessage( GetDlgItem( hdlg, IDC_FILTER_SLIDER), TBM_SETTICFREQ, 10, 1 );
                    SendMessage( GetDlgItem( hdlg, IDC_FILTER_SLIDER), TBM_SETRANGE, TRUE, (LPARAM) MAKELONG(1,100) );
                    SendMessage( GetDlgItem( hdlg, IDC_FILTER_SLIDER), TBM_SETPAGESIZE, 0, 10 );
                    SendMessage( GetDlgItem( hdlg, IDC_FILTER_SLIDER), TBM_SETLINESIZE, 0, 1 );
                    SendMessage( GetDlgItem( hdlg, IDC_FILTER_SLIDER), TBM_SETTHUMBLENGTH, 3, 0 );
                    SendMessage( GetDlgItem( hdlg, IDC_FILTER_SLIDER), TBM_SETPOS, TRUE, ApiMonOptions.GraphFilterValue );
                    _itoa( ApiMonOptions.GraphFilterValue, buf, 10 );
                    SetDlgItemText( hdlg, IDC_FILTER_NUMBER, buf );
                    CheckDlgButton( hdlg, IDC_DISPLAY_LEGENDS, ApiMonOptions.DisplayLegends );
                    CheckDlgButton( hdlg, IDC_FILTER_BAR, ApiMonOptions.FilterGraphs );

                    break;

                case PSN_KILLACTIVE:
                    SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
                    break;

                case PSN_APPLY:
                    ApiMonOptions.DisplayLegends = IsDlgButtonChecked( hdlg, IDC_DISPLAY_LEGENDS  );
                    ApiMonOptions.FilterGraphs   = IsDlgButtonChecked( hdlg, IDC_FILTER_BAR       );
                    break;
            }
            break;

        case WM_HELP:
            {
                LPHELPINFO hi = (LPHELPINFO)lParam;
                ProcessHelpRequest( hdlg, hi->iCtrlId );
            }
            break;
    }
    return FALSE;
}

BOOL
CreateOptionsPropertySheet(
    HINSTANCE   hInstance,
    HWND        hwnd
    )
{
    PROPSHEETPAGE   psp[4];
    PROPSHEETHEADER psh;


    psp[0].dwSize      = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags     = PSP_USEICONID | PSP_USETITLE;
    psp[0].hInstance   = hInstance;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_MISC);
    psp[0].pszIcon     = NULL;
    psp[0].pfnDlgProc  = MiscDialogProc;
    psp[0].pszTitle    = "Miscellaneous Options";
    psp[0].lParam      = 0;

    psp[1].dwSize      = sizeof(PROPSHEETPAGE);
    psp[1].dwFlags     = PSP_USEICONID | PSP_USETITLE;
    psp[1].hInstance   = hInstance;
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_FILE_NAMES);
    psp[1].pszIcon     = NULL;
    psp[1].pfnDlgProc  = FileNamesDialogProc;
    psp[1].pszTitle    = "File Names";
    psp[1].lParam      = 0;

    psp[2].dwSize      = sizeof(PROPSHEETPAGE);
    psp[2].dwFlags     = PSP_USEICONID | PSP_USETITLE;
    psp[2].hInstance   = hInstance;
    psp[2].pszTemplate = MAKEINTRESOURCE(IDD_KNOWN_DLLS);
    psp[2].pszIcon     = NULL;
    psp[2].pfnDlgProc  = KnownDllsDialogProc;
    psp[2].pszTitle    = "Known DLLs";
    psp[2].lParam      = 0;

    psp[3].dwSize      = sizeof(PROPSHEETPAGE);
    psp[3].dwFlags     = PSP_USEICONID | PSP_USETITLE;
    psp[3].hInstance   = hInstance;
    psp[3].pszTemplate = MAKEINTRESOURCE(IDD_GRAPH);
    psp[3].pszIcon     = NULL;
    psp[3].pfnDlgProc  = GraphDialogProc;
    psp[3].pszTitle    = "Graphing";
    psp[3].lParam      = 0;

    psh.dwSize         = sizeof(PROPSHEETHEADER);
    psh.dwFlags        = PSH_USEICONID | PSH_PROPSHEETPAGE;
    psh.hwndParent     = hwnd;
    psh.hInstance      = hInstance;
    psh.pszIcon        = "";
    psh.pszCaption     = (LPSTR)"ApiMon Options";
    psh.nPages         = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp           = (LPCPROPSHEETPAGE) psp;
    psh.nStartPage     = 0;

    INT_PTR stat = PropertySheet(&psh);

    if (stat > 0) {
        SaveOptions();
        return TRUE;
    }
    else if (stat < 0)
    {
        DWORD dwErr = GetLastError();
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\pageflt.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pageflt.cpp

Abstract:

    All user interface code for the page fault monitor window.

Author:

    Wesley Witt (wesw) Nov-20-1995

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

#include "apimonwn.h"


int __cdecl
PageHardCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        if (p2->HardFault < p1->HardFault) {
            return -1;
        } else if (p2->HardFault == p1->HardFault) {
            return 0;
        } else {
            return 1;
        }
    } else {
        return 1;
    }
}

int __cdecl
PageSoftCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        if (p2->SoftFault < p1->SoftFault) {
            return -1;
        } else if (p2->SoftFault == p1->SoftFault) {
            return 0;
        } else {
            return 1;
        }
    } else {
        return 1;
    }
}

int __cdecl
PageCodeCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        if (p2->CodeFault < p1->CodeFault) {
            return -1;
        } else if (p2->CodeFault == p1->CodeFault) {
            return 0;
        } else {
            return 1;
        }
    } else {
        return 1;
    }
}

int __cdecl
PageDataCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        if (p2->DataFault < p1->DataFault) {
            return -1;
        } else if (p2->DataFault == p1->DataFault) {
            return 0;
        } else {
            return 1;
        }
    } else {
        return 1;
    }
}

int __cdecl
PageNameCompare(
    const void *e1,
    const void *e2
    )
{
    PAPI_INFO p1;
    PAPI_INFO p2;

    p1 = (*(PAPI_INFO *)e1);
    p2 = (*(PAPI_INFO *)e2);

    if ( p1 && p2 ) {
        return _stricmp( (LPSTR)(p1->Name+(LPSTR)MemPtr), (LPSTR)(p2->Name+(LPSTR)MemPtr) );
    } else {
        return 1;
    }
}

PageFaultWindow::PageFaultWindow()
{
}


PageFaultWindow::~PageFaultWindow()
{
}


BOOL
PageFaultWindow::Create()
{
    if ((!ApiMonOptions.MonitorPageFaults) || (!pGetWsChanges)) {
        return FALSE;
    }

    SortRoutine = PageSoftCompare;

    return ApiMonWindow::Create(
        "ApiMonPage",
        "Page Faults"
        );
}


BOOL
PageFaultWindow::Register()
{
    return ApiMonWindow::Register(
        "ApiMonPage",
        IDI_CHILDICON,
        MDIChildWndProcPage
        );
}


BOOL
PageFaultWindow::Update(
    BOOL    ForceUpdate
    )
{
    PAPI_INFO           PcSymbol;
    PAPI_INFO           VaSymbol;
    ULONG_PTR           Pc;
    ULONG_PTR           Va;
    ULONG               i,j,k;
    ULONG_PTR           Offset;

    if ((!hwndList) || (!ApiMonOptions.MonitorPageFaults) || (!pGetWsChanges)) {
        return FALSE;
    }

    if (!pGetWsChanges( hProcessWs, &WorkingSetBuffer[0], sizeof(WorkingSetBuffer ))) {
        return FALSE;
    }

    SendMessage( hwndList, WM_SETREDRAW, FALSE, 0 );

    ListView_DeleteAllItems( hwndList );

    for (i=0; i<WORKING_SET_BUFFER_ENTRYS; i++) {

        if ((!WorkingSetBuffer[i].FaultingPc) ||
            (!WorkingSetBuffer[i].FaultingVa)) {
            continue;
        }

        Pc = (ULONG_PTR)WorkingSetBuffer[i].FaultingPc;
        Va = (ULONG_PTR)WorkingSetBuffer[i].FaultingVa;

        if (!SymGetSymFromAddr( CurrProcess, Pc, &Offset, sym )) {
            continue;
        }
        PcSymbol = GetApiForAddr( sym->Address );
        if (!PcSymbol) {
            continue;
        }

        if (!SymGetSymFromAddr( CurrProcess, Va, &Offset, sym )) {
            continue;
        }
        VaSymbol = GetApiForAddr( sym->Address );
        if (!VaSymbol) {
            continue;
        }

        if (Va & 1) {

            //
            // soft fault
            //
            if (PcSymbol) {
                PcSymbol->SoftFault += 1;
            }
            if (VaSymbol) {
                VaSymbol->SoftFault += 1;
            }

        } else {

            //
            // hard fault
            //
            if (PcSymbol) {
                PcSymbol->HardFault += 1;
            }
            if (VaSymbol) {
                VaSymbol->HardFault += 1;
            }

        }
        Va = Va & 0xfffffffe;
        if ((Pc & 0xfffffffe) == Va) {

            //
            // code fault
            //
            if (PcSymbol) {
                PcSymbol->CodeFault += 1;
            }
            if (VaSymbol) {
                VaSymbol->CodeFault += 1;
            }

        } else {

            //
            // data fault
            //
            if (PcSymbol) {
                PcSymbol->DataFault += 1;
            }
            if (VaSymbol) {
                VaSymbol->DataFault += 1;
            }

        }
    }

    PAPI_INFO ApiInfo = NULL;
    ULONG_PTR *ApiAry = NULL;
    for (i=0,k=0; i<MAX_DLLS; i++) {
        if (DllList[i].ApiCount && DllList[i].Enabled) {
            ApiInfo = (PAPI_INFO)(DllList[i].ApiOffset + (PUCHAR)DllList);
            for (j=0; j<DllList[i].ApiCount; j++) {
                if (ApiInfo[j].SoftFault || ApiInfo[j].HardFault ||
                    ApiInfo[j].CodeFault || ApiInfo[j].DataFault) {
                    k += 1;
                }
            }
        }
    }

    if (k) {
        ApiAry = (ULONG_PTR *) MemAlloc( (k+64) * sizeof(ULONG_PTR) );
        if (ApiAry) {
            for (i=0,k=0; i<MAX_DLLS; i++) {
                if (DllList[i].ApiCount && DllList[i].Enabled) {
                    ApiInfo = (PAPI_INFO)(DllList[i].ApiOffset + (PUCHAR)DllList);
                    for (j=0; j<DllList[i].ApiCount; j++) {
                        if (ApiInfo[j].SoftFault || ApiInfo[j].HardFault ||
                            ApiInfo[j].CodeFault || ApiInfo[j].DataFault) {
                            ApiAry[k++] = (ULONG_PTR)&ApiInfo[j];
                        }
                    }
                }
            }
            qsort( ApiAry, k, sizeof(ULONG_PTR), SortRoutine );
            for (i=0; i<k; i++) {
                AddItemToList(
                    (LPSTR)(((PAPI_INFO)ApiAry[i])->Name + (LPSTR)MemPtr),
                    ((PAPI_INFO)ApiAry[i])->HardFault,
                    ((PAPI_INFO)ApiAry[i])->SoftFault,
                    ((PAPI_INFO)ApiAry[i])->DataFault,
                    ((PAPI_INFO)ApiAry[i])->CodeFault
                    );
            }
            MemFree( ApiAry );
        }
    }

    SendMessage( hwndList, WM_SETREDRAW, TRUE, 0 );

    return TRUE;
}


void
PageFaultWindow::InitializeList()
{
    LV_COLUMN lvc = {0};
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

    lvc.pszText = "API Name";
    lvc.iSubItem = 0;
    lvc.cx = 204;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, 0, &lvc );

    lvc.pszText = "Soft";
    lvc.iSubItem = 1;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_RIGHT;
    ListView_InsertColumn( hwndList, 1, &lvc );

    lvc.pszText = "Hard";
    lvc.iSubItem = 2;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_RIGHT;
    ListView_InsertColumn( hwndList, 2, &lvc );

    lvc.pszText = "Code";
    lvc.iSubItem = 3;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_RIGHT;
    ListView_InsertColumn( hwndList, 3, &lvc );

    lvc.pszText = "Data";
    lvc.iSubItem = 4;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_RIGHT;
    ListView_InsertColumn( hwndList, 4, &lvc );
}


void
PageFaultWindow::AddItemToList(
    LPSTR   ApiName,
    ULONG_PTR   Hard,
    ULONG_PTR   Soft,
    ULONG_PTR   Data,
    ULONG_PTR   Code
    )
{
    LV_ITEM             lvi = {0};
    CHAR                NumText[32];
    int                 iItem;

    if (!hwndList) {
        return;
    }

    lvi.pszText = ApiName;
    lvi.iItem = ListView_GetItemCount( hwndList );
    lvi.iSubItem = 0;
    lvi.mask = LVIF_TEXT;
    iItem = ListView_InsertItem( hwndList, &lvi );

    if (iItem == -1) {
        return;
    }

    if (Hard) {
        sprintf( NumText, "%5d", Hard );
    } else {
        NumText[0] = 0;
    }
    lvi.pszText = NumText;
    lvi.iItem = iItem;
    lvi.iSubItem = 1;
    lvi.mask = LVIF_TEXT;
    ListView_SetItem( hwndList, &lvi );

    if (Soft) {
        sprintf( NumText, "%5d", Soft );
    } else {
        NumText[0] = 0;
    }
    lvi.iSubItem = 2;
    ListView_SetItem( hwndList, &lvi );

    if (Data) {
        sprintf( NumText, "%5d", Data );
    } else {
        NumText[0] = 0;
    }
    lvi.iSubItem = 3;
    ListView_SetItem( hwndList, &lvi );

    if (Code) {
        sprintf( NumText, "%5d", Code );
    } else {
        NumText[0] = 0;
    }
    lvi.iSubItem = 4;
    ListView_SetItem( hwndList, &lvi );
}


void
PageFaultWindow::Notify(
   LPNMHDR  NmHdr
   )
{
    if (NmHdr->code == LVN_COLUMNCLICK) {
        switch( ((LPNM_LISTVIEW)NmHdr)->iSubItem ) {
            case 0:
                //
                // sort by name
                //
                SortRoutine = PageNameCompare;
                break;

            case 1:
                //
                // sort by soft
                //
                SortRoutine = PageSoftCompare;
                break;

            case 2:
                //
                // sort by hard
                //
                SortRoutine = PageHardCompare;
                break;

            case 3:
                //
                // sort by code
                //
                SortRoutine = PageCodeCompare;
                break;

            case 4:
                //
                // sort by data
                //
                SortRoutine = PageDataCompare;
                break;
        }
        PostMessage( hwndFrame, WM_UPDATE_PAGE, 0, 0 );
    }
}



LRESULT CALLBACK
MDIChildWndProcPage(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD Width;
    PageFaultWindow *pw = (PageFaultWindow*) GetWindowLongPtr( hwnd, GWLP_USERDATA );


    switch (uMessage) {
        case WM_CREATE:
            pw = (PageFaultWindow*) ((LPMDICREATESTRUCT)(((LPCREATESTRUCT)lParam)->lpCreateParams))->lParam;
            SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR) pw );
            pw->hwndList = ChildCreate( hwnd );
            pw->InitializeList();
            SetMenuState( IDM_NEW_PAGE, MF_GRAYED );
            break;

        case WM_SETFOCUS:
            ChildFocus = CHILD_PAGE;
            break;

        case WM_MOVE:
            SaveWindowPos( hwnd, &ApiMonOptions.PagePosition, TRUE );
            return 0;

        case WM_SIZE:
            SaveWindowPos( hwnd, &ApiMonOptions.PagePosition, TRUE );
            MoveWindow( pw->hwndList, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE );
            Width = LOWORD(lParam) - GetSystemMetrics( SM_CXVSCROLL );
            ListView_SetColumnWidth( pw->hwndList, 0, Width * .40 );
            ListView_SetColumnWidth( pw->hwndList, 1, Width * .15 );
            ListView_SetColumnWidth( pw->hwndList, 2, Width * .15 );
            ListView_SetColumnWidth( pw->hwndList, 3, Width * .15 );
            ListView_SetColumnWidth( pw->hwndList, 4, Width * .15 );
            break;

        case WM_NOTIFY:
            pw->Notify( (LPNMHDR)lParam );
            break;

        case WM_DESTROY:
            SetMenuState( IDM_NEW_PAGE, MF_ENABLED );
            return 0;
    }
    return DefMDIChildProc( hwnd, uMessage, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\registry.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    This file implements the apis for APIMON to _access the registry.
    All _access to the registry are done in this file.  If additional
    registry control is needed then a function should be added in this file
    and exposed to the other files in APIMON.

Author:

    Wesley Witt (wesw) July-11-1993

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop


//
// string constants for accessing the registry
// there is a string constant here for each key and each value
// that is accessed in the registry.
//
#define REGKEY_SOFTWARE             "software\\microsoft\\ApiMon"

#define REGKEY_LOGFILENAME          "LogFileName"
#define REGKEY_TRACEFILENAME        "TraceFileName"
#define REGKEY_SYMBOL_PATH          "SymbolPath"
#define REGKEY_LAST_DIR             "LastDir"
#define REGKEY_PROG_DIR             "ProgDir"
#define REGKEY_ARGUMENTS            "Arguments"
#define REGKEY_TRACING              "Tracing"
#define REGKEY_ALIASING             "Aliasing"
#define REGKEY_HEAP_CHECKING        "HeapChecking"
#define REGKEY_PRELOAD_SYMBOLS      "PreLoadSymbols"
#define REGKEY_API_COUNTERS         "ApiCounters"
#define REGKEY_GO_IMMEDIATE         "GoImmediate"
#define REGKEY_FAST_COUNTERS        "FastCounters"
#define REGKEY_DEFAULT_SORT         "DefaultSort"
#define REGKEY_FRAME_POSITION       "FramePosition"
#define REGKEY_DLL_POSITION         "DllPosition"
#define REGKEY_COUNTER_POSITION     "CounterPosition"
#define REGKEY_PAGE_POSITION        "PagePosition"
#define REGKEY_LOGFONT              "LogFont"
#define REGKEY_COLOR                "Color"
#define REGKEY_CUSTCOLORS           "CustColors"
#define REGKEY_USE_KNOWN_DLLS       "UseKnownDlls"
#define REGKEY_EXCLUDE_KNOWN_DLLS   "ExcludeKnownDlls"
#define REGKEY_KNOWN_DLLS           "KnownDlls"
#define REGKEY_PAGE_FAULTS          "PageFaults"
#define REGKEY_AUTO_REFRESH         "AutoRefresh"
#define REGKEY_GRAPH_FILTER_VALUE   "GraphFilterValue"
#define REGKEY_GRAPH_FILTER         "GraphFilter"
#define REGKEY_GRAPH_DISPLAY_LEGEND "GraphDisplayLegend"


LPSTR SystemDlls[] =
    {
        "ntdll.dll",
        "kernel32.dll"
    };

#define MAX_SYSTEM_DLLS (sizeof(SystemDlls)/sizeof(LPSTR))


//
// local prototypes
//
void  RegSetDWORD( HKEY hkey, LPSTR szSubKey, DWORD dwValue );
void  RegSetBOOL( HKEY hkey, LPSTR szSubKey, BOOL dwValue );
void  RegSetSZ( HKEY hkey, LPSTR szSubKey, LPSTR szValue );
void  RegSetMULTISZ( HKEY hkey, LPSTR szSubKey, LPSTR szValue );
void  RegSetBINARY( HKEY hkey, LPSTR szSubKey, LPVOID ValueData, DWORD Length );
void  RegSetEXPANDSZ( HKEY hkey, LPSTR szSubKey, LPSTR szValue );
void  RegSetPOS(HKEY hkey, LPSTR szSubKey, PPOSITION Pos );
BOOL  RegQueryBOOL( HKEY hkey, LPSTR szSubKey );
DWORD RegQueryDWORD( HKEY hkey, LPSTR szSubKey );
void  RegQuerySZ( HKEY hkey, LPSTR szSubKey, LPSTR szValue );
void  RegQueryMULTISZ( HKEY hkey, LPSTR szSubKey, LPSTR szValue );
void  RegQueryBINARY( HKEY hkey, LPSTR szSubKey, LPVOID ValueData, DWORD Length );
void  RegQueryPOS(HKEY hkey, LPSTR szSubKey, PPOSITION Pos );
BOOL  RegSaveAllValues( HKEY hKey, POPTIONS o );
BOOL  RegGetAllValues( POPTIONS o, HKEY hKey );
BOOL  RegInitializeDefaults( HKEY hKey );
HKEY  RegGetAppKey( void );

extern "C" BOOL RunningOnNT;



BOOL
RegGetAllValues(
    POPTIONS o,
    HKEY     hKey
    )

/*++

Routine Description:

    This functions retrieves all registry data for APIMON and puts
    the data in the OPTIONS structure passed in.

Arguments:

    o          - pointer to an OPTIONS structure
    hKey       - handle to a registry key for APIMON registry data

Return Value:

    TRUE       - retrieved all data without error
    FALSE      - errors occurred and did not get all data

--*/

{
    RegQuerySZ( hKey, REGKEY_LOGFILENAME,   o->LogFileName   );
    RegQuerySZ( hKey, REGKEY_TRACEFILENAME, o->TraceFileName );
    RegQuerySZ( hKey, REGKEY_SYMBOL_PATH,   o->SymbolPath    );
    RegQuerySZ( hKey, REGKEY_LAST_DIR,      o->LastDir       );
    RegQuerySZ( hKey, REGKEY_PROG_DIR,      o->ProgDir       );
    RegQuerySZ( hKey, REGKEY_ARGUMENTS,     o->Arguments     );

    RegQueryMULTISZ( hKey, REGKEY_KNOWN_DLLS, o->KnownDlls   );

    o->Tracing             = RegQueryBOOL(  hKey, REGKEY_TRACING         );
    o->Aliasing            = RegQueryBOOL(  hKey, REGKEY_ALIASING        );
    o->HeapChecking        = RegQueryBOOL(  hKey, REGKEY_HEAP_CHECKING   );
    o->PreLoadSymbols      = RegQueryBOOL(  hKey, REGKEY_PRELOAD_SYMBOLS );
    o->ApiCounters         = RegQueryBOOL(  hKey, REGKEY_API_COUNTERS    );
    o->GoImmediate         = RegQueryBOOL(  hKey, REGKEY_GO_IMMEDIATE    );
    o->FastCounters        = RegQueryBOOL(  hKey, REGKEY_FAST_COUNTERS   );
    o->UseKnownDlls        = RegQueryBOOL(  hKey, REGKEY_USE_KNOWN_DLLS  );
    o->ExcludeKnownDlls    = RegQueryBOOL(  hKey, REGKEY_EXCLUDE_KNOWN_DLLS  );
    o->MonitorPageFaults   = RegQueryBOOL(  hKey, REGKEY_PAGE_FAULTS     );
    o->AutoRefresh         = RegQueryBOOL(  hKey, REGKEY_AUTO_REFRESH    );
    o->DefaultSort         = (SORT_TYPE)RegQueryDWORD( hKey, REGKEY_DEFAULT_SORT    );
    o->Color               = RegQueryDWORD( hKey, REGKEY_COLOR           );
    o->DisplayLegends      = RegQueryBOOL(  hKey, REGKEY_GRAPH_DISPLAY_LEGEND );
    o->FilterGraphs        = RegQueryBOOL(  hKey, REGKEY_GRAPH_FILTER         );
    o->GraphFilterValue    = RegQueryDWORD( hKey, REGKEY_GRAPH_FILTER_VALUE   );

    RegQueryPOS( hKey, REGKEY_FRAME_POSITION,   &o->FramePosition   );
    RegQueryPOS( hKey, REGKEY_DLL_POSITION,     &o->DllPosition     );
    RegQueryPOS( hKey, REGKEY_COUNTER_POSITION, &o->CounterPosition );
    RegQueryPOS( hKey, REGKEY_PAGE_POSITION,    &o->PagePosition    );

    RegQueryBINARY( hKey, REGKEY_LOGFONT,    &o->LogFont,   sizeof(o->LogFont)    );
    RegQueryBINARY( hKey, REGKEY_CUSTCOLORS, o->CustColors, sizeof(o->CustColors) );

    return TRUE;
}

BOOL
RegSaveAllValues(
    HKEY     hKey,
    POPTIONS o
    )

/*++

Routine Description:

    This functions saves all registry data for APIMON that is passed
    in via the OPTIONS structure.

Arguments:

    hKey   - handle to a registry key for APIMON registry data
    o      - pointer to an OPTIONS structure

Return Value:

    TRUE   - saved all data without error
    FALSE  - errors occurred and did not save all data

--*/

{
    RegSetSZ(    hKey, REGKEY_LOGFILENAME,        o->LogFileName        );
    RegSetSZ(    hKey, REGKEY_TRACEFILENAME,      o->TraceFileName      );
    RegSetSZ(    hKey, REGKEY_SYMBOL_PATH,        o->SymbolPath         );
    RegSetSZ(    hKey, REGKEY_LAST_DIR,           o->LastDir            );
    RegSetSZ(    hKey, REGKEY_PROG_DIR,           o->ProgDir            );
    RegSetSZ(    hKey, REGKEY_ARGUMENTS,          o->Arguments          );

    RegSetMULTISZ( hKey, REGKEY_KNOWN_DLLS,       o->KnownDlls          );

    RegSetBOOL(  hKey, REGKEY_TRACING,            o->Tracing            );
    RegSetBOOL(  hKey, REGKEY_ALIASING,           o->Aliasing           );
    RegSetBOOL(  hKey, REGKEY_HEAP_CHECKING,      o->HeapChecking       );
    RegSetBOOL(  hKey, REGKEY_PRELOAD_SYMBOLS,    o->PreLoadSymbols     );
    RegSetBOOL(  hKey, REGKEY_API_COUNTERS,       o->ApiCounters        );
    RegSetBOOL(  hKey, REGKEY_GO_IMMEDIATE,       o->GoImmediate        );
    RegSetBOOL(  hKey, REGKEY_FAST_COUNTERS,      o->FastCounters       );
    RegSetBOOL(  hKey, REGKEY_USE_KNOWN_DLLS,     o->UseKnownDlls       );
    RegSetBOOL(  hKey, REGKEY_EXCLUDE_KNOWN_DLLS, o->ExcludeKnownDlls   );
    RegSetBOOL(  hKey, REGKEY_PAGE_FAULTS,        o->MonitorPageFaults  );
    RegSetBOOL(  hKey, REGKEY_AUTO_REFRESH,       o->AutoRefresh        );
    RegSetDWORD( hKey, REGKEY_DEFAULT_SORT,       o->DefaultSort        );
    RegSetDWORD( hKey, REGKEY_COLOR,              o->Color              );

    RegSetBOOL(  hKey, REGKEY_GRAPH_DISPLAY_LEGEND, o->DisplayLegends   );
    RegSetBOOL(  hKey, REGKEY_GRAPH_FILTER,         o->FilterGraphs     );
    RegSetDWORD( hKey, REGKEY_GRAPH_FILTER_VALUE,   o->GraphFilterValue );

    RegSetPOS(  hKey, REGKEY_FRAME_POSITION,     &o->FramePosition      );
    RegSetPOS(  hKey, REGKEY_DLL_POSITION,       &o->DllPosition        );
    RegSetPOS(  hKey, REGKEY_COUNTER_POSITION,   &o->CounterPosition    );
    RegSetPOS(  hKey, REGKEY_PAGE_POSITION,      &o->PagePosition       );

    RegSetBINARY( hKey, REGKEY_LOGFONT, &o->LogFont,   sizeof(o->LogFont)    );
    RegSetBINARY( hKey, REGKEY_CUSTCOLORS, o->CustColors, sizeof(o->CustColors) );

    return TRUE;
}

BOOL
RegInitializeDefaults(
    HKEY  hKey,
    LPSTR ProgName
    )

/*++

Routine Description:

    This functions initializes the registry with the default values.

Arguments:

    hKey   - handle to a registry key for APIMON registry data

Return Value:

    TRUE       - saved all data without error
    FALSE      - errors occurred and did not save all data

--*/

{
    OPTIONS o;

    ZeroMemory( &o, sizeof(o) );

    strcpy( o.ProgName,      ProgName                 );
    strcpy( o.LogFileName,   "%windir%\\apimon.log"   );
    strcpy( o.TraceFileName, "%windir%\\apitrace.log" );
    if (RunningOnNT) {
        strcpy( o.SymbolPath,    "%windir%\\symbols"  );
    } else {
        strcpy( o.SymbolPath,    "%windir%"  );
    }

    o.Tracing           = FALSE;
    o.Aliasing          = FALSE;
    o.HeapChecking      = FALSE;
    o.PreLoadSymbols    = FALSE;
    o.ApiCounters       = TRUE;
    o.GoImmediate       = FALSE;
    o.FastCounters      = TRUE;
    o.UseKnownDlls      = FALSE;
    o.ExcludeKnownDlls  = FALSE;
    o.DefaultSort       = SortByCounter;
    o.Color             = RGB(255,255,255);
    o.GraphFilterValue  = 1;
    o.DisplayLegends    = TRUE;
    o.FilterGraphs      = TRUE;
    o.AutoRefresh       = TRUE;

    ULONG i;
    LPSTR p = o.KnownDlls;
    for (i=0; i<MAX_SYSTEM_DLLS; i++) {
        strcpy( p, SystemDlls[i] );
        p += (strlen(p) + 1);
    }
    *p = 0;

    RegSaveAllValues( hKey, &o );

    return TRUE;
}

HKEY
RegGetAppKey(
    LPSTR ProgName
    )

/*++

Routine Description:

    This function gets a handle to the APIMON registry key.

Arguments:

    None.

Return Value:

    Valid handle   - handle opened ok
    NULL           - could not open the handle

--*/

{
    DWORD   rc;
    DWORD   dwDisp;
    HKEY    hKey;
    CHAR    SubKey[128];


    if ((!ProgName) || (!ProgName[0])) {
        return NULL;
    }

    strcpy( SubKey, REGKEY_SOFTWARE );
    strcat( SubKey, "\\"            );
    strcat( SubKey, ProgName        );

    rc = RegCreateKeyEx(
        HKEY_CURRENT_USER,
        SubKey,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_READ | KEY_WRITE,
        NULL,
        &hKey,
        &dwDisp
        );

    if (rc != ERROR_SUCCESS) {
        return NULL;
    }

    if (dwDisp == REG_CREATED_NEW_KEY) {
        RegInitializeDefaults( hKey, ProgName );
    }

    return hKey;
}

BOOL
RegInitialize(
    POPTIONS o
    )

/*++

Routine Description:

    This function is used to initialize the OPTIONS structure passed in
    with the current values in the registry.  Note that if the registry
    is empty then the defaults are stored in the registry and also
    returned in the OPTIONS structure.

Arguments:

    None.

Return Value:

    TRUE           - all data was retrieved ok
    NULL           - could not get all data

--*/

{
    HKEY hKey = RegGetAppKey( o->ProgName );
    if (!hKey) {
        return FALSE;
    }

    if (!RegGetAllValues( o, hKey )) {
        return FALSE;
    }

    RegCloseKey( hKey );

    return TRUE;
}

BOOL
RegSave(
    POPTIONS o
    )

/*++

Routine Description:

    This function is used to save the data in the OPTIONS structure
    to the registry.

Arguments:

    o              - pointer to an OPTIONS structure

Return Value:

    TRUE           - all data was saved ok
    NULL           - could not save all data

--*/

{
    HKEY    hKey;

    hKey = RegGetAppKey( o->ProgName );
    if (!hKey) {
        return FALSE;
    }
    RegSaveAllValues( hKey, o );
    RegCloseKey( hKey );

    return TRUE;
}

void
RegSetDWORD(
    HKEY hkey,
    LPSTR szSubKey,
    DWORD dwValue
    )

/*++

Routine Description:

    This function changes a DWORD value in the registry using the
    hkey and szSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string
    dwValue       - new registry value

Return Value:

    None.

--*/

{
    RegSetValueEx( hkey, szSubKey, 0, REG_DWORD, (LPBYTE)&dwValue, 4 );
}

void
RegSetBOOL(
    HKEY hkey,
    LPSTR szSubKey,
    BOOL dwValue
    )

/*++

Routine Description:

    This function changes a BOOL value in the registry using the
    hkey and szSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string
    dwValue       - new registry value

Return Value:

    None.

--*/

{
    RegSetValueEx( hkey, szSubKey, 0, REG_DWORD, (LPBYTE)&dwValue, 4 );
}

void
RegSetSZ(
    HKEY hkey,
    LPSTR szSubKey,
    LPSTR szValue
    )

/*++

Routine Description:

    This function changes a SZ value in the registry using the
    hkey and szSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string
    szValue       - new registry value

Return Value:

    None.

--*/

{
    RegSetValueEx( hkey, szSubKey, 0, REG_SZ, (PUCHAR)szValue, strlen(szValue)+1 );
}

void
RegSetMULTISZ(
    HKEY hkey,
    LPSTR szSubKey,
    LPSTR szValue
    )

/*++

Routine Description:

    This function changes a SZ value in the registry using the
    hkey and szSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string
    szValue       - new registry value

Return Value:

    None.

--*/

{
    ULONG i = 1;
    ULONG j = 0;
    LPSTR p = szValue;
    while( TRUE ) {
        j = strlen( p ) + 1;
        i += j;
        p += j;
        if (!*p) {
            break;
        }
    }
    RegSetValueEx( hkey, szSubKey, 0, REG_MULTI_SZ, (PUCHAR)szValue, i );
}

void
RegSetBINARY(
    HKEY    hkey,
    LPSTR   szSubKey,
    LPVOID  ValueData,
    DWORD   Length
    )

/*++

Routine Description:

    This function changes a SZ value in the registry using the
    hkey and szSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string
    szValue       - new registry value

Return Value:

    None.

--*/

{
    RegSetValueEx( hkey, szSubKey, 0, REG_BINARY, (PUCHAR)ValueData, Length );
}

void
RegSetPOS(
    HKEY        hkey,
    LPSTR       szSubKey,
    PPOSITION   Pos
    )
{
    CHAR buf[64];
    sprintf(
        buf,
        "%d,%d,%d,%d,%d",
        Pos->Flags,
        Pos->Rect.top,
        Pos->Rect.left,
        Pos->Rect.right,
        Pos->Rect.bottom
        );
    RegSetSZ( hkey, szSubKey, buf );
}

void
RegSetEXPANDSZ(
    HKEY hkey,
    LPSTR szSubKey,
    LPSTR szValue
    )

/*++

Routine Description:

    This function changes a SZ value in the registry using the
    hkey and szSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string
    szValue       - new registry value

Return Value:

    None.

--*/

{
    RegSetValueEx( hkey, szSubKey, 0, REG_EXPAND_SZ, (PUCHAR)szValue, strlen(szValue)+1 );
}

BOOL
RegQueryBOOL(
    HKEY hkey,
    LPSTR szSubKey
    )

/*++

Routine Description:

    This function queries BOOL value in the registry using the
    hkey and szSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a FALSE value.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string

Return Value:

    TRUE or FALSE.

--*/

{
    DWORD   rc;
    DWORD   len;
    DWORD   dwType;
    BOOL    fValue = FALSE;

    len = 4;
    rc = RegQueryValueEx( hkey, szSubKey, 0, &dwType, (LPBYTE)&fValue, &len );
    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            fValue = FALSE;
            RegSetBOOL( hkey, szSubKey, fValue );
        }
    }

    return fValue;
}

DWORD
RegQueryDWORD(
    HKEY hkey,
    LPSTR szSubKey
    )

/*++

Routine Description:

    This function queries BOOL value in the registry using the
    hkey and szSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a zero value.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string

Return Value:

    registry value

--*/

{
    DWORD   rc;
    DWORD   len;
    DWORD   dwType;
    DWORD   fValue = 0;

    len = 4;
    rc = RegQueryValueEx( hkey, szSubKey, 0, &dwType, (LPBYTE)&fValue, &len );
    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            fValue = 0;
            RegSetDWORD( hkey, szSubKey, fValue );
        }
    }

    return fValue;
}

void
RegQuerySZ(
    HKEY  hkey,
    LPSTR szSubKey,
    LPSTR szValue
    )

/*++

Routine Description:

    This function queries BOOL value in the registry using the
    hkey and szSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a zero value.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string

Return Value:

    registry value

--*/

{
    DWORD   rc;
    DWORD   len;
    DWORD   dwType;
    char    buf[1024] = {0};

    len = sizeof(buf);
    rc = RegQueryValueEx( hkey, szSubKey, 0, &dwType, (LPBYTE)buf, &len );
    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            buf[0] = 0;
            RegSetSZ( hkey, szSubKey, buf );
        }
    }

    strcpy( szValue, buf );
}

void
RegQueryMULTISZ(
    HKEY  hkey,
    LPSTR szSubKey,
    LPSTR szValue
    )

/*++

Routine Description:

    This function queries BOOL value in the registry using the
    hkey and szSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a zero value.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string

Return Value:

    registry value

--*/

{
    DWORD   rc;
    DWORD   len;
    DWORD   dwType;
    char    buf[1024];

    len = sizeof(buf);
    rc = RegQueryValueEx( hkey, szSubKey, 0, &dwType, (LPBYTE)buf, &len );
    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            buf[0] = 0;
            buf[1] = 0;
            len = 2;
            RegSetMULTISZ( hkey, szSubKey, buf );
        }
    }

    memcpy( szValue, buf, len );
}

void
RegQueryBINARY(
    HKEY    hkey,
    LPSTR   szSubKey,
    LPVOID  ValueData,
    DWORD   Length
    )

/*++

Routine Description:

    This function queries BOOL value in the registry using the
    hkey and szSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a zero value.

Arguments:

    hkey          - handle to a registry key
    szSubKey      - pointer to a subkey string

Return Value:

    registry value

--*/

{
    DWORD   rc;
    DWORD   len;
    DWORD   dwType;

    len = Length;
    rc = RegQueryValueEx( hkey, szSubKey, 0, &dwType, (LPBYTE)ValueData, &len );
    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            ZeroMemory( ValueData, Length );
            RegSetBINARY( hkey, szSubKey, ValueData, Length );
        }
    }
}

void
RegQueryPOS(
    HKEY        hkey,
    LPSTR       szSubKey,
    PPOSITION   Pos
    )
{
    CHAR buf[64];
    RegQuerySZ( hkey, szSubKey, buf );
    LPSTR p = buf;
    LPSTR p1 = strchr( p, ',' );
    if (!p1) {
        return;
    }
    *p1 = 0;
    Pos->Flags = atoi( p );
    p = p1 + 1;
    p1 = strchr( p, ',' );
    if (!p1) {
        return;
    }
    Pos->Rect.top = atoi( p );
    p = p1 + 1;
    p1 = strchr( p, ',' );
    if (!p1) {
        return;
    }
    *p1 = 0;
    Pos->Rect.left = atoi( p );
    p = p1 + 1;
    p1 = strchr( p, ',' );
    if (!p1) {
        return;
    }
    *p1 = 0;
    Pos->Rect.right = atoi( p );
    p = p1 + 1;
    Pos->Rect.bottom = atoi( p );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\resource.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    This file contains all manafest contants for APIMON's resources.

Author:

    Wesley Witt (wesw) 27-June-1995

Environment:

    User Mode

--*/


//
// general
//
#define WINDOWMENU                      2
#define IDC_STATIC                     -1

//
// dialogs
//
#define IDD_FILE_NAMES                  101
#define IDD_MISC                        102
#define IDD_KNOWN_DLLS                  103
#define IDD_GRAPH                       104
#define IDD_HELP                        105

//
// strings
//
#define IDS_DESCRIPTION                 201
#define IDS_SYSMENU                     202
#define IDS_MDISYSMENU                  203
#define IDS_FILEMENU                    204
#define IDS_WINDOWMENU                  205
#define IDS_HELPMENU                    206
#define IDS_SCSIZE                      SC_SIZE
#define IDS_SCMOVE                      SC_MOVE
#define IDS_SCMINIMIZE                  SC_MINIMIZE
#define IDS_SCMAXIMIZE                  SC_MAXIMIZE
#define IDS_SCNEXTWINDOW                SC_NEXTWINDOW
#define IDS_SCPREVWINDOW                SC_PREVWINDOW
#define IDS_SCCLOSE                     SC_CLOSE
#define IDS_SCRESTORE                   SC_RESTORE
#define IDS_SCTASKLIST                  SC_TASKLIST

//
// menu items
//
#define IDM_EXIT                        301
#define IDM_WINDOWTILE                  302
#define IDM_WINDOWCASCADE               303
#define IDM_WINDOWICONS                 304
#define IDM_ABOUT                       305
#define IDM_STATUSBAR                   306
#define IDM_START                       307
#define IDM_STOP                        308
#define IDM_TOOLBAR                     309
#define IDM_OPTIONS                     310
#define IDM_SAVE_OPTIONS                311
#define IDM_FILEOPEN                    312
#define IDM_WRITE_LOG                   313
#define IDM_FONT                        314
#define IDM_COLOR                       315
#define IDM_NEW_DLL                     316
#define IDM_NEW_COUNTER                 317
#define IDM_CLEAR_COUNTERS              318
#define IDM_NEW_PAGE                    319
#define IDM_WINDOWTILE_HORIZ            320
#define IDM_GRAPH                       321
#define IDM_NEW_GRAPH                   322
#define IDM_REFRESH                     323
#define IDM_LEGEND                      324
#define IDM_HELP                        325
#define IDM_VIEW_TRACE                  326
#define IDM_WINDOWCHILD                 327   // MUST be the last IDM constant

//
// bitmaps
//
#define IDB_TOOLBAR                     401
#define IDB_CHECKSTATES                 402

//
// icons
//
#define IDI_APPICON                     501
#define IDI_CHILDICON                   502

//
// controls
//
#define IDC_LOG_FILE_NAME               600
#define IDC_TRACE_FILE_NAME             601
#define IDC_ENABLE_TRACING              602
#define IDC_SYMBOL_PATH                 603
#define IDC_DISABLE_HEAP                604
#define IDC_PRELOAD_SYMBOLS             605
#define IDC_ENABLE_COUNTERS             606
#define IDC_GO_IMMEDIATE                607
#define IDC_DISABLE_FAST_COUNTERS       608
#define IDC_DEFSORT_NAME                609
#define IDC_DEFSORT_COUNTER             610
#define IDC_DEFSORT_TIME                611
#define IDC_USE_KNOWN_DLLS              612
#define IDC_KNOWN_DLLS                  613
#define IDC_PAGE_FAULTS                 614
#define IDC_EXCLUDE_KNOWN_DLLS          615
#define IDC_DISPLAY_LEGENDS             616
#define IDC_FILTER_BAR                  617
#define IDC_FILTER_NUMBER               618
#define IDC_FILTER_SLIDER               619
#define IDC_AUTO_REFRESH                620
#define IDC_ENABLE_ALIASING             621
#define IDC_DLL_SORTING                 622

//
// help ids
//
#define IDH_ABOUT                       700
#define IDH_CLEAR_COUNTERS              701
#define IDH_COLOR                       702
#define IDH_COMMAND_LINE                703
#define IDH_CONTENTS                    704
#define IDH_DEFSORT_COUNTER             705
#define IDH_DEFSORT_NAME                706
#define IDH_DEFSORT_TIME                707
#define IDH_DISABLE_FAST_COUNTERS       708
#define IDH_DISABLE_HEAP                709
#define IDH_DLLS_OPTIONS                710
#define IDH_ENABLE_COUNTERS             711
#define IDH_ENABLE_TRACING              712
#define IDH_EXIT                        713
#define IDH_FILEOPEN                    714
#define IDH_FNAME_OPTIONS               715
#define IDH_FONT                        716
#define IDH_GO_IMMEDIATE                717
#define IDH_HOW_TO_USE                  718
#define IDH_KNOWN_DLLS                  719
#define IDH_LOG_FILE_NAME               720
#define IDH_MISC_OPTIONS                721
#define IDH_NEW_COUNTER                 722
#define IDH_NEW_DLL                     723
#define IDH_NEW_PAGE                    724
#define IDH_OPTIONS                     725
#define IDH_PAGE_FAULTS                 726
#define IDH_PRELOAD_SYMBOLS             727
#define IDH_SAVE_OPTIONS                728
#define IDH_START                       729
#define IDH_STATUSBAR                   730
#define IDH_STOP                        731
#define IDH_SYMBOL_PATH                 732
#define IDH_TOOLBAR                     733
#define IDH_TRACE_FILE_NAME             734
#define IDH_USE_KNOWN_DLLS              735
#define IDH_WHAT_IS                     736
#define IDH_WINDOWCASCADE               737
#define IDH_WINDOWICONS                 738
#define IDH_WINDOWTILE                  739
#define IDH_WINDOWTILE_HORIZ            740
#define IDH_WRITE_LOG                   741
#define IDH_EXCLUDE_KNOWN_DLLS          742

//
// cursors
//
#define IDC_HAND_INTERNAL               801
#define IDC_HSPLIT                      802


//
// Error IDs
//
#define ERR_UNKNOWN                             901
#define ERR_RESOURCE                            902
#define ERR_PAGEFILE                            903
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\tracevw.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tracevw.cpp

Abstract:

    All user interface code for the trace view window.

Author:

    Wesley Witt (wesw) Dec-9-1995

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

#include "apimonwn.h"



TraceWindow::TraceWindow()
{
}


TraceWindow::~TraceWindow()
{
}


BOOL
TraceWindow::Create()
{
    return ApiMonWindow::Create(
        "ApiMonTrace",
        "Api Trace"
        );
}


BOOL
TraceWindow::Register()
{
    return ApiMonWindow::Register(
        "ApiMonTrace",
        IDI_CHILDICON,
        MDIChildWndProcTrace
        );
}


BOOL
TraceWindow::Update(
    BOOL ForceUpdate
    )
{
    return TRUE;
}


void
TraceWindow::InitializeList()
{
    LV_COLUMN lvc = {0};
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

    lvc.pszText = "Return";
    lvc.iSubItem = 0;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, 0, &lvc );

    lvc.pszText = "Arg1";
    lvc.iSubItem = 1;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, 1, &lvc );

    lvc.pszText = "Arg2";
    lvc.iSubItem = 2;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, 2, &lvc );

    lvc.pszText = "Arg3";
    lvc.iSubItem = 3;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, 3, &lvc );

    lvc.pszText = "Arg4";
    lvc.iSubItem = 4;
    lvc.cx = 50;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, 4, &lvc );

    lvc.pszText = "Name";
    lvc.iSubItem = 5;
    lvc.cx = 100;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( hwndList, 5, &lvc );
}


void
TraceWindow::AddItemToList(
    PTRACE_ENTRY TraceEntry
    )
{
    LV_ITEM             lvi = {0};
    CHAR                buf[16];
    int                 iItem;
    ULONG               i;
    ULONG               j;
    PAPI_INFO           ApiInfo;
    PDLL_INFO           DllInfo;



    if (!hwndList) {
        return;
    }

    sprintf( buf, "%08x", TraceEntry->ReturnValue );
    lvi.pszText = buf;
    lvi.iItem = ListView_GetItemCount( hwndList );
    lvi.iSubItem = 0;
    lvi.mask = LVIF_TEXT;
    iItem = ListView_InsertItem( hwndList, &lvi );

    if (iItem == -1) {
        return;
    }

    sprintf( buf, "%08x", TraceEntry->Args[0] );
    lvi.pszText = buf;
    lvi.iItem = iItem;
    lvi.iSubItem = 1;
    lvi.mask = LVIF_TEXT;
    ListView_SetItem( hwndList, &lvi );

    sprintf( buf, "%08x", TraceEntry->Args[1] );
    lvi.pszText = buf;
    lvi.iItem = iItem;
    lvi.iSubItem = 2;
    lvi.mask = LVIF_TEXT;
    ListView_SetItem( hwndList, &lvi );

    sprintf( buf, "%08x", TraceEntry->Args[2] );
    lvi.pszText = buf;
    lvi.iItem = iItem;
    lvi.iSubItem = 3;
    lvi.mask = LVIF_TEXT;
    ListView_SetItem( hwndList, &lvi );

    sprintf( buf, "%08x", TraceEntry->Args[3] );
    lvi.pszText = buf;
    lvi.iItem = iItem;
    lvi.iSubItem = 4;
    lvi.mask = LVIF_TEXT;
    ListView_SetItem( hwndList, &lvi );

    ApiInfo = GetApiInfoByAddress( TraceEntry->Address, &DllInfo );
    if (ApiInfo) {
        lvi.pszText = (LPSTR)(ApiInfo->Name + (LPSTR)MemPtr);
        lvi.iItem = iItem;
        lvi.iSubItem = 5;
        lvi.mask = LVIF_TEXT;
        ListView_SetItem( hwndList, &lvi );
    }
}


void
TraceWindow::FillList()
{
    ULONG i;
    PTRACE_ENTRY TraceEntry;


    //
    // while we hold the trace mutex the monitored application
    // is effectivly stopped.  lets get the data displayed
    // as quickly as possible.
    //
    WaitForSingleObject( ApiTraceMutex, INFINITE );

    for (i=0,TraceEntry=TraceBuffer->Entry; i<TraceBuffer->Count; i++) {
        AddItemToList( TraceEntry );
        TraceEntry = (PTRACE_ENTRY) ((PUCHAR)TraceEntry + TraceEntry->SizeOfStruct);
    }

    ReleaseMutex( ApiTraceMutex );
}


void
TraceWindow::Notify(
   LPNMHDR  NmHdr
   )
{
}


LRESULT CALLBACK
MDIChildWndProcTrace(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD Width;
    TraceWindow *tw = (TraceWindow*) GetWindowLongPtr( hwnd, GWLP_USERDATA );

    switch (uMessage) {
        case WM_CREATE:
            tw = (TraceWindow*) ((LPMDICREATESTRUCT)(((LPCREATESTRUCT)lParam)->lpCreateParams))->lParam;
            SetWindowLongPtr( hwnd, GWLP_USERDATA, (LONG_PTR) tw );
            tw->hwndList = ChildCreate( hwnd );
            tw->InitializeList();
            tw->FillList();
            break;

        case WM_SETFOCUS:
            ChildFocus = CHILD_COUNTER;
            break;

        case WM_SIZE:
            MoveWindow( tw->hwndList, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE );
            Width = LOWORD(lParam) - GetSystemMetrics( SM_CXVSCROLL );
            ListView_SetColumnWidth( tw->hwndList, 0, Width * .12 );
            ListView_SetColumnWidth( tw->hwndList, 1, Width * .12 );
            ListView_SetColumnWidth( tw->hwndList, 2, Width * .12 );
            ListView_SetColumnWidth( tw->hwndList, 3, Width * .12 );
            ListView_SetColumnWidth( tw->hwndList, 4, Width * .12 );
            ListView_SetColumnWidth( tw->hwndList, 5, Width * .40 );
            break;

        case WM_NOTIFY:
            tw->Notify( (LPNMHDR)lParam );
            break;

        case WM_DESTROY:
            SetMenuState( IDM_NEW_COUNTER, MF_ENABLED );
            return 0;
    }
    return DefMDIChildProc( hwnd, uMessage, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\i386\disasm.h ===
/********************************** module *********************************/
/*                                                                         */
/*                                 disasmtb                                */
/*                           disassembler for CodeView                     */
/*                                                                         */
/***************************************************************************/
/*                                                                         */
/*    @ Purpose:                                                           */
/*                                                                         */
/*    @ Functions included:                                                */
/*                                                                         */
/*                                                                         */
/*    @ Author: Gerd Immeyer              @ Version:                       */
/*                                                                         */
/*    @ Creation Date: 10.19.89           @ Modification Date:             */
/*                                                                         */
/***************************************************************************/



/* Strings: Operand mnemonics, Segment overrides, etc. for disasm          */

char dszAAA[]       = "aaa";
char dszAAD[]       = "aad";
char dszAAM[]       = "aam";
char dszAAS[]       = "aas";
char dszADC[]       = "adc";
char dszADD[]       = "add";
char dszADDRPRFX[]  = "";
char dszAND[]       = "and";
char dszARPL[]      = "arpl";
char dszBOUND[]     = "bound";
char dszBSF[]       = "bsf";
char dszBSR[]       = "bsr";
char dszBST[]       = "bst";
char dszBSWAP[]     = "bswap";
char dszBT[]        = "bt";
char dszBTC[]       = "btc";
char dszBTR[]       = "btr";
char dszBTS[]       = "bts";
char dszCALL[]      = "call";
char dszCBW[]       = "cbw";
char dszCDQ[]       = "cdq";
char dszCLC[]       = "clc";
char dszCLD[]       = "cld";
char dszCLI[]       = "cli";
char dszCLTS[]      = "clts";
char dszCMC[]       = "cmc";
char dszCMP[]       = "cmp";
char dszCMPS[]      = "cmps";
char dszCMPSB[]     = "cmpsb";
char dszCMPSD[]     = "cmpsd";
char dszCMPSW[]     = "cmpsw";
char dszCMPXCHG[]   = "cmpxchg";
char dszCS_[]       = "cs:";
char dszCWD[]       = "cwd";
char dszCWDE[]      = "cwde";
char dszDAA[]       = "daa";
char dszDAS[]       = "das";
char dszDEC[]       = "dec";
char dszDIV[]       = "div";
char dszDS_[]       = "ds:";
char dszENTER[]     = "enter";
char dszES_[]       = "es:";
char dszF2XM1[]     = "f2xm1";
char dszFABS[]      = "fabs";
char dszFADD[]      = "fadd";
char dszFADDP[]     = "faddp";
char dszFBLD[]      = "fbld";
char dszFBSTP[]     = "fbstp";
char dszFCHS[]      = "fchs";
char dszFCLEX[]     = "fclex";
char dszFCOM[]      = "fcom";
char dszFCOMP[]     = "fcomp";
char dszFCOMPP[]    = "fcompp";
char dszFCOS[]      = "fcos";
char dszFDECSTP[]   = "fdecstp";
char dszFDISI[]     = "fdisi";
char dszFDIV[]      = "fdiv";
char dszFDIVP[]     = "fdivp";
char dszFDIVR[]     = "fdivr";
char dszFDIVRP[]    = "fdivrp";
char dszFENI[]      = "feni";
char dszFFREE[]     = "ffree";
char dszFIADD[]     = "fiadd";
char dszFICOM[]     = "ficom";
char dszFICOMP[]    = "ficomp";
char dszFIDIV[]     = "fidiv";
char dszFIDIVR[]    = "fidivr";
char dszFILD[]      = "fild";
char dszFIMUL[]     = "fimul";
char dszFINCSTP[]   = "fincstp";
char dszFINIT[]     = "finit";
char dszFIST[]      = "fist";
char dszFISTP[]     = "fistp";
char dszFISUB[]     = "fisub";
char dszFISUBR[]    = "fisubr";
char dszFLD[]       = "fld";
char dszFLD1[]      = "fld1";
char dszFLDCW[]     = "fldcw";
char dszFLDENV[]    = "fldenv";
char dszFLDL2E[]    = "fldl2e";
char dszFLDL2T[]    = "fldl2t";
char dszFLDLG2[]    = "fldlg2";
char dszFLDLN2[]    = "fldln2";
char dszFLDPI[]     = "fldpi";
char dszFLDZ[]      = "fldz";
char dszFMUL[]      = "fmul";
char dszFMULP[]     = "fmulp";
char dszFNCLEX[]    = "fnclex";
char dszFNDISI[]    = "fndisi";
char dszFNENI[]     = "fneni";
char dszFNINIT[]    = "fninit";
char dszFNOP[]      = "fnop";
char dszFNSAVE[]    = "fnsave";
char dszFNSTCW[]    = "fnstcw";
char dszFNSTENV[]   = "fnstenv";
char dszFNSTSW[]    = "fnstsw";
char dszFNSTSWAX[]  = "fnstswax";
char dszFPATAN[]    = "fpatan";
char dszFPREM[]     = "fprem";
char dszFPREM1[]    = "fprem1";
char dszFPTAN[]     = "fptan";
char dszFRNDINT[]   = "frndint";
char dszFRSTOR[]    = "frstor";
char dszFSAVE[]     = "fsave";
char dszFSCALE[]    = "fscale";
char dszFSETPM[]    = "fsetpm";
char dszFSIN[]      = "fsin";
char dszFSINCOS[]   = "fsincos";
char dszFSQRT[]     = "fsqrt";
char dszFST[]       = "fst";
char dszFSTCW[]     = "fstcw";
char dszFSTENV[]    = "fstenv";
char dszFSTP[]      = "fstp";
char dszFSTSW[]     = "fstsw";
char dszFSTSWAX[]   = "fstswax";
char dszFSUB[]      = "fsub";
char dszFSUBP[]     = "fsubp";
char dszFSUBR[]     = "fsubr";
char dszFSUBRP[]    = "fsubrp";
char dszFS_[]       = "fs:";
char dszFTST[]      = "ftst";
char dszFUCOM[]     = "fucom";
char dszFUCOMP[]    = "fucomp";
char dszFUCOMPP[]   = "fucompp";
char dszFWAIT[]     = "fwait";
char dszFXAM[]      = "fxam";
char dszFXCH[]      = "fxch";
char dszFXTRACT[]   = "fxtract";
char dszFYL2X[]     = "fyl2x";
char dszFYL2XP1[]   = "fyl2xp1";
char dszGS_[]       = "gs:";
char dszHLT[]       = "hlt";
char dszIBTS[]      = "ibts";
char dszIDIV[]      = "idiv";
char dszIMUL[]      = "imul";
char dszIN[]        = "in";
char dszINC[]       = "inc";
char dszINS[]       = "ins";
char dszINSB[]      = "insb";
char dszINSD[]      = "insd";
char dszINSW[]      = "insw";
char dszINT[]       = "int";
char dszINTO[]      = "into";
char dszIRET[]      = "iret";
char dszIRETD[]     = "iretd";
char dszJA[]        = "ja";
char dszJAE[]       = "jae";
char dszJB[]        = "jb";
char dszJBE[]       = "jbe";
char dszJC[]        = "jc";
char dszJCXZ[]      = "jcxz";
char dszJE[]        = "je";
char dszJECXZ[]     = "jecxz";
char dszJG[]        = "jg";
char dszJGE[]       = "jge";
char dszJL[]        = "jl";
char dszJLE[]       = "jle";
char dszJMP[]       = "jmp";
char dszJNA[]       = "jna";
char dszJNAE[]      = "jnae";
char dszJNB[]       = "jnb";
char dszJNBE[]      = "jnbe";
char dszJNC[]       = "jnc";
char dszJNE[]       = "jne";
char dszJNG[]       = "jng";
char dszJNGE[]      = "jnge";
char dszJNL[]       = "jnl";
char dszJNLE[]      = "jnle";
char dszJNO[]       = "jno";
char dszJNP[]       = "jnp";
char dszJNS[]       = "jns";
char dszJNZ[]       = "jnz";
char dszJO[]        = "jo";
char dszJP[]        = "jp";
char dszJPE[]       = "jpe";
char dszJPO[]       = "jpo";
char dszJS[]        = "js";
char dszJZ[]        = "jz";
char dszLAHF[]      = "lahf";
char dszLAR[]       = "lar";
char dszLDS[]       = "lds";
char dszLEA[]       = "lea";
char dszLEAVE[]     = "leave";
char dszLES[]       = "les";
char dszLFS[]       = "lfs";
char dszLGDT[]      = "lgdt";
char dszLGS[]       = "lgs";
char dszLIDT[]      = "lidt";
char dszLLDT[]      = "lldt";
char dszLMSW[]      = "lmsw";
char dszLOADALL[]   = "loadall";
char dszLOCK[]      = "lock";
char dszLODS[]      = "lods";
char dszLODSB[]     = "lodsb";
char dszLODSD[]     = "lodsd";
char dszLODSW[]     = "lodsw";
char dszLOOP[]      = "loop";
char dszLOOPE[]     = "loope";
char dszLOOPNE[]    = "loopne";
char dszLOOPNZ[]    = "loopnz";
char dszLOOPZ[]     = "loopz";
char dszLSL[]       = "lsl";
char dszLSS[]       = "lss";
char dszLTR[]       = "ltr";
char dszMOV[]       = "mov";
char dszMOVS[]      = "movs";
char dszMOVSB[]     = "movsb";
char dszMOVSD[]     = "movsd";
char dszMOVSW[]     = "movsw";
char dszMOVSX[]     = "movsx";
char dszMOVZX[]     = "movzx";
char dszMUL[]       = "mul";
char dszNEG[]       = "neg";
char dszNOP[]       = "nop";
char dszNOT[]       = "not";
char dszOPPRFX[]    = "";
char dszOR[]        = "or";
char dszOUT[]       = "out";
char dszOUTS[]      = "outs";
char dszOUTSB[]     = "outsb";
char dszOUTSD[]     = "outsd";
char dszOUTSW[]     = "outsw";
char dszPOP[]       = "pop";
char dszPOPA[]      = "popa";
char dszPOPAD[]     = "popad";
char dszPOPF[]      = "popf";
char dszPOPFD[]     = "popfd";
char dszPUSH[]      = "push";
char dszPUSHA[]     = "pusha";
char dszPUSHAD[]    = "pushad";
char dszPUSHF[]     = "pushf";
char dszPUSHFD[]    = "pushfd";
char dszRCL[]       = "rcl";
char dszRCR[]       = "rcr";
char dszRDTSC[]     = "rdtsc";
char dszREP[]       = "rep ";
char dszREPE[]      = "repe";
char dszREPNE[]     = "repne ";
char dszREPNZ[]     = "repnz";
char dszREPZ[]      = "repz";
char dszRET[]       = "ret";
char dszRETF[]      = "retf";
char dszRETN[]      = "retn";
char dszROL[]       = "rol";
char dszROR[]       = "ror";
char dszSAHF[]      = "sahf";
char dszSAL[]       = "sal";
char dszSAR[]       = "sar";
char dszSBB[]       = "sbb";
char dszSCAS[]      = "scas";
char dszSCASB[]     = "scasb";
char dszSCASD[]     = "scasd";
char dszSCASW[]     = "scasw";
char dszSETA[]      = "seta";
char dszSETAE[]     = "setae";
char dszSETB[]      = "setb";
char dszSETBE[]     = "setbe";
char dszSETC[]      = "setc";
char dszSETE[]      = "sete";
char dszSETG[]      = "setg";
char dszSETGE[]     = "setge";
char dszSETL[]      = "setl";
char dszSETLE[]     = "setle";
char dszSETNA[]     = "setna";
char dszSETNAE[]    = "setnae";
char dszSETNB[]     = "setnb";
char dszSETNBE[]    = "setnbe";
char dszSETNC[]     = "setnc";
char dszSETNE[]     = "setne";
char dszSETNG[]     = "setng";
char dszSETNGE[]    = "setnge";
char dszSETNL[]     = "setnl";
char dszSETNLE[]    = "setnle";
char dszSETNO[]     = "setno";
char dszSETNP[]     = "setnp";
char dszSETNS[]     = "setns";
char dszSETNZ[]     = "setnz";
char dszSETO[]      = "seto";
char dszSETP[]      = "setp";
char dszSETPE[]     = "setpe";
char dszSETPO[]     = "setpo";
char dszSETS[]      = "sets";
char dszSETZ[]      = "setz";
char dszSGDT[]      = "sgdt";
char dszSHL[]       = "shl";
char dszSHLD[]      = "shld";
char dszSHR[]       = "shr";
char dszSHRD[]      = "shrd";
char dszSIDT[]      = "sidt";
char dszSLDT[]      = "sldt";
char dszSMSW[]      = "smsw";
char dszSS_[]       = "ss:";
char dszSTC[]       = "stc";
char dszSTD[]       = "std";
char dszSTI[]       = "sti";
char dszSTOS[]      = "stos";
char dszSTOSB[]     = "stosb";
char dszSTOSD[]     = "stosd";
char dszSTOSW[]     = "stosw";
char dszSTR[]       = "str";
char dszSUB[]       = "sub";
char dszTEST[]      = "test";
char dszVERR[]      = "verr";
char dszVERW[]      = "verw";
char dszWAIT[]      = "wait";
char dszXADD[]      = "xadd";
char dszXBTS[]      = "xbts";
char dszXCHG[]      = "xchg";
char dszXLAT[]      = "xlat";
char dszXOR[]       = "xor";
char dszRESERVED[]  = "???";
char dszMULTI[]     = "";
char dszDB[]        = "db";

#define MRM        0x40
#define COM        0x80
#define END        0xc0

/* Enumeration of valid actions that can be included in the action table */

enum oprtyp { ADDRP,  ADR_OVR, ALSTR,   ALT,     AXSTR,  BOREG,
              BREG,   BRSTR,   xBYTE,   CHR,     CREG,   xDWORD,
              EDWORD, EGROUPT, FARPTR,  GROUP,   GROUPT, IB,
              IST,    IST_ST,  IV,      IW,      LMODRM, MODRM,
              NOP,    OFFS,    OPC0F,   OPR_OVR, QWORD,  REL16,
              REL8,   REP,     SEG_OVR, SREG2,   SREG3,  ST_IST,
              STROP,  TTBYTE,   UBYTE,   VAR,     VOREG,  VREG,
              xWORD,  WREG,    WRSTR
            };

/* Enumeration of indices into the action table for instruction classes */

#define O_DoDB          0
#define O_NoOperands    0
#define O_NoOpAlt5      O_NoOperands+1
#define O_NoOpAlt4      O_NoOpAlt5+2
#define O_NoOpAlt3      O_NoOpAlt4+2
#define O_NoOpAlt1      O_NoOpAlt3+2
#define O_NoOpAlt0      O_NoOpAlt1+2
#define O_NoOpStrSI     O_NoOpAlt0+2
#define O_NoOpStrDI     O_NoOpStrSI+2
#define O_NoOpStrSIDI   O_NoOpStrDI+2
#define O_bModrm_Reg    O_NoOpStrSIDI+2
#define O_vModrm_Reg    O_bModrm_Reg+3
#define O_Modrm_Reg     O_vModrm_Reg+3
#define O_bReg_Modrm    O_Modrm_Reg+3
#define O_fReg_Modrm    O_bReg_Modrm+3
#define O_Reg_Modrm     O_fReg_Modrm+3
#define O_AL_Ib         O_Reg_Modrm+3
#define O_AX_Iv         O_AL_Ib+2
#define O_sReg2         O_AX_Iv+2
#define O_oReg          O_sReg2+1
#define O_DoBound       O_oReg+1
#define O_Iv            O_DoBound+3
#define O_wModrm_Reg    O_Iv+1
#define O_Ib            O_wModrm_Reg+3
#define O_Imulb         O_Ib+1
#define O_Imul          O_Imulb+4
#define O_Rel8          O_Imul+4
#define O_bModrm_Ib     O_Rel8+1
#define O_Modrm_Ib      O_bModrm_Ib+3
#define O_Modrm_Iv      O_Modrm_Ib+3
#define O_Modrm_sReg3   O_Modrm_Iv+3
#define O_sReg3_Modrm   O_Modrm_sReg3+3
#define O_Modrm         O_sReg3_Modrm+3
#define O_FarPtr        O_Modrm+2
#define O_AL_Offs       O_FarPtr+1
#define O_Offs_AL       O_AL_Offs+2
#define O_AX_Offs       O_Offs_AL+2
#define O_Offs_AX       O_AX_Offs+2
#define O_oReg_Ib       O_Offs_AX+2
#define O_oReg_Iv       O_oReg_Ib+2
#define O_Iw            O_oReg_Iv+2
#define O_Enter         O_Iw+1
#define O_Ubyte_AL      O_Enter+2
#define O_Ubyte_AX      O_Ubyte_AL+2
#define O_AL_Ubyte      O_Ubyte_AX+2
#define O_AX_Ubyte      O_AL_Ubyte+2
#define O_DoInAL        O_AX_Ubyte+2
#define O_DoInAX        O_DoInAL+3
#define O_DoOutAL       O_DoInAX+3
#define O_DoOutAX       O_DoOutAL+3
#define O_Rel16         O_DoOutAX+3
#define O_ADR_OVERRIDE  O_Rel16+1
#define O_OPR_OVERRIDE  O_ADR_OVERRIDE+1
#define O_SEG_OVERRIDE  O_OPR_OVERRIDE+1
#define O_DoInt3        O_SEG_OVERRIDE+1

#if (O_DoInt3 != 115)
#error "operand table has been modified!"
#endif
/* #define O_DoInt      O_DoInt3+2 */

#define O_DoInt         117
#define O_OPC0F         O_DoInt+1
#define O_GROUP11       O_OPC0F+1
#define O_GROUP13       O_GROUP11+5
#define O_GROUP12       O_GROUP13+5
#define O_GROUP21       O_GROUP12+5
#define O_GROUP22       O_GROUP21+5
#define O_GROUP23       O_GROUP22+5
#define O_GROUP24       O_GROUP23+6
#define O_GROUP25       O_GROUP24+6
#define O_GROUP26       O_GROUP25+6
#define O_GROUP4        O_GROUP26+6
#define O_GROUP6        O_GROUP4+4
#define O_GROUP8        O_GROUP6+4
#define O_GROUP31       O_GROUP8+5
#define O_GROUP32       O_GROUP31+3
#define O_GROUP5        O_GROUP32+3
#define O_GROUP7        O_GROUP5+3
#define O_x87_ESC       O_GROUP7+3
#define O_bModrm        O_x87_ESC+2
#define O_wModrm        O_bModrm+2
#define O_dModrm        O_wModrm+2
#define O_fModrm        O_dModrm+2
#define O_vModrm        O_fModrm+2
#define O_vModrm_Iv     O_vModrm+2
#define O_Reg_bModrm    O_vModrm_Iv+3
#define O_Reg_wModrm    O_Reg_bModrm+3
#define O_Modrm_Reg_Ib  O_Reg_wModrm+3
#define O_Modrm_Reg_CL  O_Modrm_Reg_Ib+4
#define O_ST_iST        O_Modrm_Reg_CL+5
#define O_iST           O_ST_iST+2
#define O_iST_ST        O_iST+2
#define O_qModrm        O_iST_ST+2
#define O_tModrm        O_qModrm+2
#define O_DoRep         O_tModrm+2
#define O_Modrm_CReg    O_DoRep+1
#define O_CReg_Modrm    O_Modrm_CReg+3
#define O_AX_oReg       O_CReg_Modrm+3
#define O_length        O_AX_oReg+3

#if( O_length > 255 )
#error "operand table too large!"
#endif


/* The action table: range of lists of actions to be taken for each possible */
/*   instruction class.                                                      */

static UCHAR actiontbl[] = {
/* NoOperands  */ NOP+END,
/* NoOpAlt5    */ ALT+END,   5,
/* NoOpAlt4    */ ALT+END,   4,
/* NoOpAlt3    */ ALT+END,   3,
/* NoOpAlt1    */ ALT+END,   1,
/* NoOpAlt0    */ ALT+END,   0,
/* NoOpStrSI   */ STROP+END, 1,
/* NoOpStrDI   */ STROP+END, 2,
/* NoOpStrSIDI */ STROP+END, 3,
/* bModrm_Reg  */ xBYTE+MRM, MODRM+COM,  BREG+END,
/* vModrm_Reg  */ VAR+MRM,   LMODRM+COM, BREG+END,
/* Modrm_Reg   */ VAR+MRM,   MODRM+COM,  VREG+END,
/* bReg_Modrm  */ xBYTE+MRM, BREG+COM,   MODRM+END,
/* fReg_Modrm  */ FARPTR+MRM,VREG+COM,   MODRM+END,
/* Reg_Modrm   */ VAR+MRM,   VREG+COM,   MODRM+END,
/* AL_Ib       */ ALSTR+COM, IB+END,
/* AX_Iv       */ AXSTR+COM, IV+END,
/* sReg2       */ SREG2+END,
/* oReg        */ VOREG+END,
/* DoBound     */ VAR+MRM,   VREG+COM,   MODRM+END,
/* Iv          */ IV+END,
/* wModrm_Reg  */ xWORD+MRM, LMODRM+COM, WREG+END,
/* Ib          */ IB+END,
/* Imulb       */ VAR+MRM,   VREG+COM,   MODRM+COM, IB+END,
/* Imul        */ VAR+MRM,   VREG+COM,   MODRM+COM, IV+END,
/* REL8        */ REL8+END,
/* bModrm_Ib   */ xBYTE+MRM, LMODRM+COM, IB+END,
/* Modrm_Ib    */ VAR+MRM,   LMODRM+COM, IB+END,
/* Modrm_Iv    */ VAR+MRM,   LMODRM+COM, IV+END,
/* Modrm_sReg3 */ xWORD+MRM, MODRM+COM,  SREG3+END,
/* sReg3_Modrm */ xWORD+MRM, SREG3+COM,  MODRM+END,
/* Modrm       */ VAR+MRM,   MODRM+END,
/* FarPtr      */ ADDRP+END,
/* AL_Offs     */ ALSTR+COM, OFFS+END,
/* Offs_AL     */ OFFS+COM,  ALSTR+END,
/* AX_Offs     */ AXSTR+COM, OFFS+END,
/* Offs_AX     */ OFFS+COM,  AXSTR+END,
/* oReg_Ib     */ BOREG+COM, IB+END,
/* oReg_Iv     */ VOREG+COM, IV+END,
/* Iw          */ IW+END,
/* enter       */ IW+COM,    IB+END,
/* Ubyte_AL    */ UBYTE+COM, ALSTR+END,
/* Ubyte_AX    */ UBYTE+COM, AXSTR+END,
/* AL_Ubyte    */ ALSTR+COM, UBYTE+END,
/* AX_Ubyte    */ AXSTR+COM, UBYTE+END,
/* DoInAL      */ ALSTR+COM, WRSTR+END,  2,
/* DoInAX      */ AXSTR+COM, WRSTR+END,  2,
/* DoOutAL     */ WRSTR+COM, 2,          ALSTR+END,
/* DoOutAX     */ WRSTR+COM, 2,          AXSTR+END,
/* REL16       */ REL16+END,
/* ADR_OVERRIDE*/ ADR_OVR,
/* OPR_OVERRIDE*/ OPR_OVR,
/* SEG_OVERRIDE*/ SEG_OVR,
/* DoInt3      */ CHR+END,   '3',
/* DoInt       */ UBYTE+END,
/* Opcode0F    */ OPC0F,
/* group1_1    */ xBYTE+MRM, GROUP,      0,         LMODRM+COM, IB+END,
/* group1_3    */ VAR+MRM,   GROUP,      0,         LMODRM+COM, IB+END,
/* group1_2    */ VAR+MRM,   GROUP,      0,         LMODRM+COM, IV+END,
/* group2_1    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, IB+END,
/* group2_2    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, IB+END,
/* group2_3    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, CHR+END, '1',
/* group2_4    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, CHR+END, '1',
/* group2_5    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, BRSTR+END, 1,
/* group2_6    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, BRSTR+END, 1,
/* group4      */ xBYTE+MRM, GROUP,      2,         LMODRM+END,
/* group6      */ xWORD+MRM, GROUP,      3,         LMODRM+END,
/* group8      */ xWORD+MRM, GROUP,      4,         LMODRM+COM, IB+END,
/* group3_1    */ xBYTE+MRM, GROUPT,     20,
/* group3_2    */ VAR+MRM,   GROUPT,     21,
/* group5      */ VAR+MRM,   GROUPT,     22,
/* group7      */ NOP+MRM,   GROUPT,     23,
/* x87_ESC     */ NOP+MRM,   EGROUPT,
/* bModrm      */ xBYTE+MRM, LMODRM+END,
/* wModrm      */ xWORD+MRM, LMODRM+END,
/* dModrm      */ xDWORD+MRM,LMODRM+END,
/* fModrm      */ FARPTR+MRM,LMODRM+END,
/* vModrm      */ VAR+MRM,   LMODRM+END,
/* vModrm_Iv   */ VAR+MRM,   LMODRM+COM, IV+END,
/* reg_bModrm  */ xBYTE+MRM, VREG+COM,   LMODRM+END,
/* reg_wModrm  */ xWORD+MRM, VREG+COM,   LMODRM+END,
/* Modrm_Reg_Ib*/ VAR+MRM,   MODRM+COM,  VREG+COM,   IB+END,
/* Modrm_Reg_CL*/ VAR+MRM,   MODRM+COM,  VREG+COM,   BRSTR+END, 1,
/* ST_iST      */ NOP+MRM,   ST_IST+END,
/* iST         */ NOP+MRM,   IST+END,
/* iST_ST      */ NOP+MRM,   IST_ST+END,
/* qModrm      */ QWORD+MRM, LMODRM+END,
/* tModrm      */ TTBYTE+MRM, LMODRM+END,
/* REP         */ REP,
/* Modrm_CReg  */ EDWORD+MRM,MODRM+COM,  CREG+END,
/* CReg_Modrm  */ EDWORD+MRM,CREG+COM,   MODRM+END,
/* AX_oReg     */ AXSTR+COM, VOREG+END
                  };
#ifdef _M_IX86
#pragma pack(1)
#endif

typedef struct Tdistbl{
    char *instruct;
    unsigned char opr;
    } Tdistbl;

/* List of ordered pairs for each instruction:                           */
/*    (pointer to string literal mnemonic,                               */
/*     instruction class index for action table)                         */

static Tdistbl distbl[] = {
    dszADD,   O_bModrm_Reg,             /* 00 ADD mem/reg, reg (byte)    */
    dszADD,   O_Modrm_Reg,              /* 01 ADD mem/reg, reg (word)    */
    dszADD,   O_bReg_Modrm,             /* 02 ADD reg, mem/reg (byte)    */
    dszADD,   O_Reg_Modrm,              /* 03 ADD reg, mem/reg (word)    */
    dszADD,   O_AL_Ib,                  /* 04 ADD AL, I                  */
    dszADD,   O_AX_Iv,                  /* 05 ADD AX, I                  */
    dszPUSH,  O_sReg2,                  /* 06 PUSH ES                    */
    dszPOP,   O_sReg2,                  /* 07 POP ES                     */
    dszOR,    O_bModrm_Reg,             /* 08 OR mem/reg, reg (byte)     */
    dszOR,    O_Modrm_Reg,              /* 09 OR mem/reg, reg (word)     */
    dszOR,    O_bReg_Modrm,             /* 0A OR reg, mem/reg (byte)     */
    dszOR,    O_Reg_Modrm,              /* 0B OR reg, mem/reg (word)     */
    dszOR,    O_AL_Ib,                  /* 0C OR AL, I                   */
    dszOR,    O_AX_Iv,                  /* 0D OR AX, I                   */
    dszPUSH,  O_sReg2,                  /* 0E PUSH CS                    */
    dszMULTI, O_OPC0F,                  /* 0F CLTS & protection ctl(286) */
    dszADC,   O_bModrm_Reg,             /* 10 ADC mem/reg, reg (byte)    */
    dszADC,   O_Modrm_Reg,              /* 11 ADC mem/reg, reg (word)    */
    dszADC,   O_bReg_Modrm,             /* 12 ADC reg, mem/reg (byte)    */
    dszADC,   O_Reg_Modrm,              /* 13 ADC reg, mem/reg (word)    */
    dszADC,   O_AL_Ib,                  /* 14 ADC AL, I                  */
    dszADC,   O_AX_Iv,                  /* 15 ADC AX, I                  */
    dszPUSH,  O_sReg2,                  /* 16 PUSH SS                    */
    dszPOP,   O_sReg2,                  /* 17 POP SS                     */
    dszSBB,   O_bModrm_Reg,             /* 18 SBB mem/reg, reg (byte)    */
    dszSBB,   O_Modrm_Reg,              /* 19 SBB mem/reg, reg (word)    */
    dszSBB,   O_bReg_Modrm,             /* 1A SBB reg, mem/reg (byte)    */
    dszSBB,   O_Reg_Modrm,              /* 1B SBB reg, mem/reg (word)    */
    dszSBB,   O_AL_Ib,                  /* 1C SBB AL, I                  */
    dszSBB,   O_AX_Iv,                  /* 1D SBB AX, I                  */
    dszPUSH,  O_sReg2,                  /* 1E PUSH DS                    */
    dszPOP,   O_sReg2,                  /* 1F POP DS                     */
    dszAND,   O_bModrm_Reg,             /* 20 AND mem/reg, reg (byte)    */
    dszAND,   O_Modrm_Reg,              /* 21 AND mem/reg, reg (word)    */
    dszAND,   O_bReg_Modrm,             /* 22 AND reg, mem/reg (byte)    */
    dszAND,   O_Reg_Modrm,              /* 23 AND reg, mem/reg (word)    */
    dszAND,   O_AL_Ib,                  /* 24 AND AL, I                  */
    dszAND,   O_AX_Iv,                  /* 25 AND AX, I                  */
    dszES_,   O_SEG_OVERRIDE,           /* 26 SEG ES:                    */
    dszDAA,   O_NoOperands,             /* 27 DAA                        */
    dszSUB,   O_bModrm_Reg,             /* 28 SUB mem/reg, reg (byte)    */
    dszSUB,   O_Modrm_Reg,              /* 29 SUB mem/reg, reg (word)    */
    dszSUB,   O_bReg_Modrm,             /* 2A SUB reg, mem/reg (byte)    */
    dszSUB,   O_Reg_Modrm,              /* 2B SUB reg, mem/reg (word)    */
    dszSUB,   O_AL_Ib,                  /* 2C SUB AL, I                  */
    dszSUB,   O_AX_Iv,                  /* 2D SUB AX, I                  */
    dszCS_,   O_SEG_OVERRIDE,           /* 2E SEG CS:                    */
    dszDAS,   O_NoOperands,             /* 2F DAS                        */
    dszXOR,   O_bModrm_Reg,             /* 30 XOR mem/reg, reg (byte)    */
    dszXOR,   O_Modrm_Reg,              /* 31 XOR mem/reg, reg (word)    */
    dszXOR,   O_bReg_Modrm,             /* 32 XOR reg, mem/reg (byte)    */
    dszXOR,   O_Reg_Modrm,              /* 33 XOR reg, mem/reg (word)    */
    dszXOR,   O_AL_Ib,                  /* 34 XOR AL, I                  */
    dszXOR,   O_AX_Iv,                  /* 35 XOR AX, I                  */
    dszSS_,   O_SEG_OVERRIDE,           /* 36 SEG SS:                    */
    dszAAA,   O_NoOperands,             /* 37 AAA                        */
    dszCMP,   O_bModrm_Reg,             /* 38 CMP mem/reg, reg (byte)    */
    dszCMP,   O_Modrm_Reg,              /* 39 CMP mem/reg, reg (word)    */
    dszCMP,   O_bReg_Modrm,             /* 3A CMP reg, mem/reg (byte)    */
    dszCMP,   O_Reg_Modrm,              /* 3B CMP reg, mem/reg (word)    */
    dszCMP,   O_AL_Ib,                  /* 3C CMP AL, I                  */
    dszCMP,   O_AX_Iv,                  /* 3D CMP AX, I                  */
    dszDS_,   O_SEG_OVERRIDE,           /* 3E SEG DS:                    */
    dszAAS,   O_NoOperands,             /* 3F AAS                        */
    dszINC,   O_oReg,                   /* 40 INC AX                     */
    dszINC,   O_oReg,                   /* 41 INC CX                     */
    dszINC,   O_oReg,                   /* 42 INC DX                     */
    dszINC,   O_oReg,                   /* 43 INC BX                     */
    dszINC,   O_oReg,                   /* 44 INC SP                     */
    dszINC,   O_oReg,                   /* 45 INC BP                     */
    dszINC,   O_oReg,                   /* 46 INC SI                     */
    dszINC,   O_oReg,                   /* 47 INC DI                     */
    dszDEC,   O_oReg,                   /* 48 DEC AX                     */
    dszDEC,   O_oReg,                   /* 49 DEC CX                     */
    dszDEC,   O_oReg,                   /* 4A DEC DX                     */
    dszDEC,   O_oReg,                   /* 4B DEC BX                     */
    dszDEC,   O_oReg,                   /* 4C DEC SP                     */
    dszDEC,   O_oReg,                   /* 4D DEC BP                     */
    dszDEC,   O_oReg,                   /* 4E DEC SI                     */
    dszDEC,   O_oReg,                   /* 4F DEC DI                     */
    dszPUSH,  O_oReg,                   /* 50 PUSH AX                    */
    dszPUSH,  O_oReg,                   /* 51 PUSH CX                    */
    dszPUSH,  O_oReg,                   /* 52 PUSH DX                    */
    dszPUSH,  O_oReg,                   /* 53 PUSH BX                    */
    dszPUSH,  O_oReg,                   /* 54 PUSH SP                    */
    dszPUSH,  O_oReg,                   /* 55 PUSH BP                    */
    dszPUSH,  O_oReg,                   /* 56 PUSH SI                    */
    dszPUSH,  O_oReg,                   /* 57 PUSH DI                    */
    dszPOP,   O_oReg,                   /* 58 POP AX                     */
    dszPOP,   O_oReg,                   /* 59 POP CX                     */
    dszPOP,   O_oReg,                   /* 5A POP DX                     */
    dszPOP,   O_oReg,                   /* 5B POP BX                     */
    dszPOP,   O_oReg,                   /* 5C POP SP                     */
    dszPOP,   O_oReg,                   /* 5D POP BP                     */
    dszPOP,   O_oReg,                   /* 5E POP SI                     */
    dszPOP,   O_oReg,                   /* 5F POP DI                     */
    dszPUSHA, O_NoOpAlt5,               /* 60 PUSHA (286) / PUSHAD (386) */
    dszPOPA,  O_NoOpAlt4,               /* 61 POPA (286) / POPAD (286)   */
    dszBOUND, O_DoBound,                /* 62 BOUND reg, Modrm (286)     */
    dszARPL,  O_Modrm_Reg,              /* 63 ARPL Modrm, reg (286)      */
    dszFS_,   O_SEG_OVERRIDE,           /* 64                            */
    dszGS_,   O_SEG_OVERRIDE,           /* 65                            */
    dszOPPRFX,O_OPR_OVERRIDE,           /* 66                            */
    dszADDRPRFX,O_ADR_OVERRIDE,         /* 67                            */
    dszPUSH,  O_Iv,                     /* 68 PUSH word (286)            */
    dszIMUL,  O_Imul,                   /* 69 IMUL (286)                 */
    dszPUSH,  O_Ib,                     /* 6A PUSH byte (286)            */
    dszIMUL,  O_Imulb,                  /* 6B IMUL (286)                 */
    dszINSB,  O_NoOperands,             /* 6C INSB (286)                 */
    dszINSW,  O_NoOpAlt3,               /* 6D INSW (286) / INSD (386)    */
    dszOUTSB, O_NoOperands,             /* 6E OUTSB (286)                */
    dszOUTSW, O_NoOpAlt4,               /* 6F OUTSW (286) / OUTSD (386)  */
    dszJO,    O_Rel8,                   /* 70 JO                         */
    dszJNO,   O_Rel8,                   /* 71 JNO                        */
    dszJB,    O_Rel8,                   /* 72 JB or JNAE or JC           */
    dszJNB,   O_Rel8,                   /* 73 JNB or JAE or JNC          */
    dszJZ,    O_Rel8,                   /* 74 JE or JZ                   */
    dszJNZ,   O_Rel8,                   /* 75 JNE or JNZ                 */
    dszJBE,   O_Rel8,                   /* 76 JBE or JNA                 */
    dszJA,    O_Rel8,                   /* 77 JNBE or JA                 */
    dszJS,    O_Rel8,                   /* 78 JS                         */
    dszJNS,   O_Rel8,                   /* 79 JNS                        */
    dszJPE,   O_Rel8,                   /* 7A JP or JPE                  */
    dszJPO,   O_Rel8,                   /* 7B JNP or JPO                 */
    dszJL,    O_Rel8,                   /* 7C JL or JNGE                 */
    dszJGE,   O_Rel8,                   /* 7D JNL or JGE                 */
    dszJLE,   O_Rel8,                   /* 7E JLE or JNG                 */
    dszJG,    O_Rel8,                   /* 7F JNLE or JG                 */
    dszMULTI, O_GROUP11,                /* 80                            */
    dszMULTI, O_GROUP12,                /* 81                            */
    dszRESERVED, O_DoDB,                /* 82                            */
    dszMULTI, O_GROUP13,                /* 83                            */
    dszTEST,  O_bModrm_Reg,             /* 84 TEST reg, mem/reg (byte)   */
    dszTEST,  O_Modrm_Reg,              /* 85 TEST reg, mem/reg (word)   */
    dszXCHG,  O_bModrm_Reg,             /* 86 XCHG reg, mem/reg (byte)   */
    dszXCHG,  O_Modrm_Reg,              /* 87 XCHG reg, mem/reg (word)   */
    dszMOV,   O_bModrm_Reg,             /* 88 MOV mem/reg, reg (byte)    */
    dszMOV,   O_Modrm_Reg,              /* 89 MOV mem/reg, reg (word)    */
    dszMOV,   O_bReg_Modrm,             /* 8A MOV reg, mem/reg (byte)    */
    dszMOV,   O_Reg_Modrm,              /* 8B MOV reg, mem/reg (word)    */
    dszMOV,   O_Modrm_sReg3,            /* 8C MOV mem/reg, segreg        */
    dszLEA,   O_Reg_Modrm,              /* 8D LEA reg, mem               */
    dszMOV,   O_sReg3_Modrm,            /* 8E MOV segreg, mem/reg        */
    dszPOP,   O_Modrm,                  /* 8F POP mem/reg                */
    dszNOP,   O_NoOperands,             /* 90 NOP                        */
    dszXCHG,  O_AX_oReg,                /* 91 XCHG AX,CX                 */
    dszXCHG,  O_AX_oReg,                /* 92 XCHG AX,DX                 */
    dszXCHG,  O_AX_oReg,                /* 93 XCHG AX,BX                 */
    dszXCHG,  O_AX_oReg,                /* 94 XCHG AX,SP                 */
    dszXCHG,  O_AX_oReg,                /* 95 XCHG AX,BP                 */
    dszXCHG,  O_AX_oReg,                /* 96 XCHG AX,SI                 */
    dszXCHG,  O_AX_oReg,                /* 97 XCHG AX,DI                 */
    dszCBW,   O_NoOpAlt0,               /* 98 CBW / CWDE (386)           */
    dszCWD,   O_NoOpAlt1,               /* 99 CWD / CDQ (386)            */
    dszCALL,  O_FarPtr,                 /* 9A CALL seg:off               */
    dszWAIT,  O_NoOperands,             /* 9B WAIT                       */
    dszPUSHF, O_NoOpAlt5,               /* 9C PUSHF / PUSHFD (386)       */
    dszPOPF,  O_NoOpAlt4,               /* 9D POPF / POPFD (386)         */
    dszSAHF,  O_NoOperands,             /* 9E SAHF                       */
    dszLAHF,  O_NoOperands,             /* 9F LAHF                       */
    dszMOV,   O_AL_Offs,                /* A0 MOV AL, mem                */
    dszMOV,   O_AX_Offs,                /* A1 MOV AX, mem                */
    dszMOV,   O_Offs_AL,                /* A2 MOV mem, AL                */
    dszMOV,   O_Offs_AX,                /* A3 MOV mem, AX                */
    dszMOVSB, O_NoOpStrSIDI,            /* A4 MOVSB                      */
    dszMOVSW, O_NoOpStrSIDI,            /* A5 MOVSW / MOVSD (386)        */
    dszCMPSB, O_NoOpStrSIDI,            /* A6 CMPSB                      */
    dszCMPSW, O_NoOpStrSIDI,            /* A7 CMPSW / CMPSD (386)        */
    dszTEST,  O_AL_Ib,                  /* A8 TEST AL, I                 */
    dszTEST,  O_AX_Iv,                  /* A9 TEST AX, I                 */
    dszSTOSB, O_NoOpStrDI,              /* AA STOSB                      */
    dszSTOSW, O_NoOpStrDI,              /* AB STOSW / STOSD (386)        */
    dszLODSB, O_NoOpStrSI,              /* AC LODSB                      */
    dszLODSW, O_NoOpStrSI,              /* AD LODSW / LODSD (386)        */
    dszSCASB, O_NoOpStrDI,              /* AE SCASB                      */
    dszSCASW, O_NoOpStrDI,              /* AF SCASW / SCASD (386)        */
    dszMOV,   O_oReg_Ib,                /* B0 MOV AL, I                  */
    dszMOV,   O_oReg_Ib,                /* B1 MOV CL, I                  */
    dszMOV,   O_oReg_Ib,                /* B2 MOV DL, I                  */
    dszMOV,   O_oReg_Ib,                /* B3 MOV BL, I                  */
    dszMOV,   O_oReg_Ib,                /* B4 MOV AH, I                  */
    dszMOV,   O_oReg_Ib,                /* B5 MOV CH, I                  */
    dszMOV,   O_oReg_Ib,                /* B6 MOV DH, I                  */
    dszMOV,   O_oReg_Ib,                /* B7 MOV BH, I                  */
    dszMOV,   O_oReg_Iv,                /* B8 MOV AX, I                  */
    dszMOV,   O_oReg_Iv,                /* B9 MOV CX, I                  */
    dszMOV,   O_oReg_Iv,                /* BA MOV DX, I                  */
    dszMOV,   O_oReg_Iv,                /* BB MOV BX, I                  */
    dszMOV,   O_oReg_Iv,                /* BC MOV SP, I                  */
    dszMOV,   O_oReg_Iv,                /* BD MOV BP, I                  */
    dszMOV,   O_oReg_Iv,                /* BE MOV SI, I                  */
    dszMOV,   O_oReg_Iv,                /* BF MOV DI, I                  */
    dszMULTI, O_GROUP21,                /* C0 shifts & rotates (286)     */
    dszMULTI, O_GROUP22,                /* C1 shifts & rotates (286)     */
    dszRET,   O_Iw,                     /* C2 RET Rel16                  */
    dszRET,   O_NoOperands,             /* C3 RET                        */
    dszLES,   O_fReg_Modrm,             /* C4 LES reg, mem               */
    dszLDS,   O_fReg_Modrm,             /* C5 LDS reg, mem               */
    dszMOV,   O_bModrm_Ib,              /* C6 MOV mem/reg, I(byte)       */
    dszMOV,   O_Modrm_Iv,               /* C7 MOV mem/reg, I(word)       */
    dszENTER, O_Enter,                  /* C8 ENTER (286)                */
    dszLEAVE, O_NoOperands,             /* C9 LEAVE (286)                */
    dszRETF,  O_Iw,                     /* CA RETF I(word)               */
    dszRETF,  O_NoOperands,             /* CB RETF                       */
    dszINT,   O_DoInt3,                 /* CC INT 3                      */
    dszINT,   O_DoInt,                  /* CD INT                        */
    dszINTO,  O_NoOperands,             /* CE INTO                       */
    dszIRET,  O_NoOpAlt4,               /* CF IRET / IRETD (386)         */
    dszMULTI, O_GROUP23,                /* D0 shifts & rotates,1 (byte)  */
    dszMULTI, O_GROUP24,                /* D1 shifts & rotates,1 (word)  */
    dszMULTI, O_GROUP25,                /* D2 shifts & rotates,CL (byte) */
    dszMULTI, O_GROUP26,                /* D3 shifts & rotates,CL (word) */
    dszAAM,   O_Ib,                     /* D4 AAM                        */
    dszAAD,   O_Ib,                     /* D5 AAD                        */
    dszRESERVED, O_DoDB,                /* D6                            */
    dszXLAT,  O_NoOperands,             /* D7 XLAT                       */
    dszMULTI, O_x87_ESC,                /* D8 ESC                        */
    dszMULTI, O_x87_ESC,                /* D9 ESC                        */
    dszMULTI, O_x87_ESC,                /* DA ESC                        */
    dszMULTI, O_x87_ESC,                /* DB ESC                        */
    dszMULTI, O_x87_ESC,                /* DC ESC                        */
    dszMULTI, O_x87_ESC,                /* DD ESC                        */
    dszMULTI, O_x87_ESC,                /* DE ESC                        */
    dszMULTI, O_x87_ESC,                /* DF ESC                        */
    dszLOOPNE,O_Rel8,                   /* E0 LOOPNE or LOOPNZ           */
    dszLOOPE, O_Rel8,                   /* E1 LOOPE or LOOPZ             */
    dszLOOP,  O_Rel8,                   /* E2 LOOP                       */
    dszJCXZ,  O_Rel8,                   /* E3 JCXZ / JECXZ (386)         */
    dszIN,    O_AL_Ubyte,               /* E4 IN AL, I                   */
    dszIN,    O_AX_Ubyte,               /* E5 IN AX, I                   */
    dszOUT,   O_Ubyte_AL,               /* E6 OUT I, AL                  */
    dszOUT,   O_Ubyte_AX,               /* E7 OUT I, AX                  */
    dszCALL,  O_Rel16,                  /* E8 CALL Rel16                 */
    dszJMP,   O_Rel16,                  /* E9 JMP Rel16                  */
    dszJMP,   O_FarPtr,                 /* EA JMP seg:off                */
    dszJMP,   O_Rel8,                   /* EB JMP Rel8                   */
    dszIN,    O_DoInAL,                 /* EC IN AL, DX                  */
    dszIN,    O_DoInAX,                 /* ED IN AX, DX                  */
    dszOUT,   O_DoOutAL,                /* EE OUT DX, AL                 */
    dszOUT,   O_DoOutAX,                /* EF OUT DX, AX                 */
    dszLOCK,  O_DoRep,                  /* F0 LOCK                       */
    dszRESERVED, O_DoDB,                /* F1                            */
    dszREPNE, O_DoRep,                  /* F2 REPNE or REPNZ             */
    dszREP,   O_DoRep,                  /* F3 REP or REPE or REPZ        */
    dszHLT,   O_NoOperands,             /* F4 HLT                        */
    dszCMC,   O_NoOperands,             /* F5 CMC                        */
    dszMULTI, O_GROUP31,                /* F6 TEST, NOT, NEG, MUL, IMUL, */
    dszMULTI, O_GROUP32,                /* F7 DIv, IDIv F6=Byte F7=Word  */
    dszCLC,   O_NoOperands,             /* F8 CLC                        */
    dszSTC,   O_NoOperands,             /* F9 STC                        */
    dszCLI,   O_NoOperands,             /* FA CLI                        */
    dszSTI,   O_NoOperands,             /* FB STI                        */
    dszCLD,   O_NoOperands,             /* FC CLD                        */
    dszSTD,   O_NoOperands,             /* FD STD                        */
    dszMULTI, O_GROUP4,                 /* FE INC, DEC mem/reg (byte)    */
    dszMULTI, O_GROUP5,                 /* FF INC, DEC, CALL, JMP, PUSH  */

    dszMULTI, O_GROUP6,                 /* 0 MULTI                       */
    dszMULTI, O_GROUP7,                 /* 1 MULTI                       */
    dszLAR,   O_Reg_Modrm,              /* 2 LAR                         */
    dszLSL,   O_Reg_Modrm,              /* 3 LSL                         */
    dszRESERVED, O_DoDB,                /* 4                             */
    dszLOADALL, O_NoOperands,           /* 5 LOADALL                     */
    dszCLTS,  O_NoOperands,             /* 6 CLTS                        */
    dszMOV,   O_Modrm_CReg,             /* 20 MOV Rd,Cd                  */
    dszMOV,   O_Modrm_CReg,             /* 21 MOV Rd,Dd                  */
    dszMOV,   O_CReg_Modrm,             /* 22 MOV Cd,Rd                  */
    dszMOV,   O_CReg_Modrm,             /* 23 MOV Dd,Rd                  */
    dszMOV,   O_Modrm_CReg,             /* 24 MOV Rd,Td                  */
    dszRESERVED, O_DoDB,                /* 25                            */
    dszMOV,   O_CReg_Modrm,             /* 26 MOV Td,Rd                  */
    dszRESERVED, O_DoDB,                /* 27                            */
    dszRESERVED, O_DoDB,                /* 28                            */
    dszRESERVED, O_DoDB,                /* 29                            */
    dszRESERVED, O_DoDB,                /* 2A                            */
    dszRESERVED, O_DoDB,                /* 2B                            */
    dszRESERVED, O_DoDB,                /* 2C                            */
    dszRESERVED, O_DoDB,                /* 2D                            */
    dszRESERVED, O_DoDB,                /* 2E                            */
    dszRESERVED, O_DoDB,                /* 2F                            */
    dszRESERVED, O_DoDB,                /* 30                            */
    dszRDTSC, O_NoOperands,             /* 31 RDTSC                      */

    dszSETNL, O_bModrm,                 /* 7D SETNL                      */
    dszRESERVED, O_DoDB,                /* 7E                            */
    dszRESERVED, O_DoDB,                /* 7F                            */
    dszJO,    O_Rel16,                  /* 80 JO                         */
    dszJNO,   O_Rel16,                  /* 81 JNO                        */
    dszJB,    O_Rel16,                  /* 82 JB                         */
    dszJNB,   O_Rel16,                  /* 83 JNB                        */
    dszJE,    O_Rel16,                  /* 84 JE                         */
    dszJNE,   O_Rel16,                  /* 85 JNE                        */
    dszJBE,   O_Rel16,                  /* 86 JBE                        */
    dszJNBE,  O_Rel16,                  /* 87 JNBE                       */
    dszJS,    O_Rel16,                  /* 88 JS                         */
    dszJNS,   O_Rel16,                  /* 89 JNS                        */
    dszJP,    O_Rel16,                  /* 8A JP                         */
    dszJNP,   O_Rel16,                  /* 8B JNP                        */
    dszJL,    O_Rel16,                  /* 8C JL                         */
    dszJNL,   O_Rel16,                  /* 8D JNL                        */
    dszJLE,   O_Rel16,                  /* 8E JLE                        */
    dszJNLE,  O_Rel16,                  /* 8F JNLE                       */
    dszSETO,  O_bModrm,                 /* 90 SETO                       */
    dszSETNO, O_bModrm,                 /* 91 SETNO                      */
    dszSETB,  O_bModrm,                 /* 92 SETB                       */
    dszSETNB, O_bModrm,                 /* 93 SETNB                      */
    dszSETE,  O_bModrm,                 /* 94 SETE                       */
    dszSETNE, O_bModrm,                 /* 95 SETNE                      */
    dszSETBE, O_bModrm,                 /* 96 SETBE                      */
    dszSETA,  O_bModrm,                 /* 97 SETNBE                     */
    dszSETS,  O_bModrm,                 /* 98 SETS                       */
    dszSETNS, O_bModrm,                 /* 99 SETNS                      */
    dszSETP,  O_bModrm,                 /* 9A SETP                       */
    dszSETNP, O_bModrm,                 /* 9B SETNP                      */
    dszSETL,  O_bModrm,                 /* 9C SETL                       */
    dszSETGE, O_bModrm,                 /* 9D SETGE                      */
    dszSETLE, O_bModrm,                 /* 9E SETLE                      */
    dszSETNLE,O_bModrm,                 /* 9F SETNLE                     */
    dszPUSH,  O_sReg2,                  /* A0 PUSH FS                    */
    dszPOP,   O_sReg2,                  /* A1 POP FS                     */
    dszRESERVED, O_DoDB,                /* A2                            */
    dszBT,    O_Modrm_Reg,              /* A3 BT                         */
    dszSHLD,  O_Modrm_Reg_Ib,           /* A4 SHLD                       */
    dszSHLD,  O_Modrm_Reg_CL,           /* A5 SHLD                       */
    dszCMPXCHG,O_bModrm_Reg,            /* A6 XBTS                       */
    dszCMPXCHG,O_Modrm_Reg,             /* A7 IBTS                       */
    dszPUSH,  O_sReg2,                  /* A8 PUSH GS                    */
    dszPOP,   O_sReg2,                  /* A9 POP GS                     */
    dszRESERVED, O_DoDB,                /* AA                            */
    dszBTS,   O_vModrm_Reg,             /* AB BTS                        */
    dszSHRD,  O_Modrm_Reg_Ib,           /* AC SHRD                       */
    dszSHRD,  O_Modrm_Reg_CL,           /* AD SHRD                       */
    dszRESERVED, O_DoDB,                /* AE                            */
    dszIMUL,  O_Reg_Modrm,              /* AF IMUL                       */
    dszRESERVED, O_DoDB,                /* B0                            */
    dszRESERVED, O_DoDB,                /* B1                            */
    dszLSS,   O_fReg_Modrm,             /* B2 LSS                        */
    dszBTR,   O_Modrm_Reg,              /* B3 BTR                        */
    dszLFS,   O_fReg_Modrm,             /* B4 LFS                        */
    dszLGS,   O_fReg_Modrm,             /* B5 LGS                        */
    dszMOVZX, O_Reg_bModrm,             /* B6 MOVZX                      */
    dszMOVZX, O_Reg_wModrm,             /* B7 MOVZX                      */
    dszRESERVED, O_DoDB,                /* B8                            */
    dszRESERVED, O_DoDB,                /* B9                            */
    dszMULTI, O_GROUP8,                 /* BA MULTI                      */
    dszBTC,   O_Modrm_Reg,              /* BB BTC                        */
    dszBSF,   O_Reg_Modrm,              /* BC BSF                        */
    dszBSR,   O_Reg_Modrm,              /* BD BSR                        */
    dszMOVSX, O_Reg_bModrm,             /* BE MOVSX                      */
    dszMOVSX, O_Reg_wModrm,             /* BF MOVSX                      */
    dszXADD,  O_bModrm_Reg,             /* C0 XADD                       */
    dszXADD,  O_Modrm_Reg,              /* C1 XADD                       */
    dszRESERVED, O_DoDB,                /* C2                            */
    dszRESERVED, O_DoDB,                /* C3                            */
    dszRESERVED, O_DoDB,                /* C4                            */
    dszRESERVED, O_DoDB,                /* C5                            */
    dszRESERVED, O_DoDB,                /* C6                            */
    dszRESERVED, O_DoDB,                /* C7                            */
    dszBSWAP, O_oReg,                   /* C8 BSWAP                      */
    dszBSWAP, O_oReg,                   /* C9 BSWAP                      */
    dszBSWAP, O_oReg,                   /* CA BSWAP                      */
    dszBSWAP, O_oReg,                   /* CB BSWAP                      */
    dszBSWAP, O_oReg,                   /* CC BSWAP                      */
    dszBSWAP, O_oReg,                   /* CD BSWAP                      */
    dszBSWAP, O_oReg,                   /* CE BSWAP                      */
    dszBSWAP, O_oReg                    /* CF BSWAP                      */
};

/* Auxilary lists of mnemonics for groups of two byte instructions:      */
/*   All of the instructions within each of these groups are of the same */
/*   class, so only the mnemonic string is needed, the index into the    */
/*   action table is implicit.                                           */

static char *group[][8] = {

/* 00 */    {dszADD,  dszOR,    dszADC,  dszSBB,    /* group 1 */
             dszAND,  dszSUB,   dszXOR,  dszCMP},

/* 01 */    {dszROL,  dszROR,   dszRCL,      dszRCR,    /* group 2 */
             dszSHL,  dszSHR,   dszRESERVED, dszSAR},

/* 02 */    {dszINC,      dszDEC,      dszRESERVED, dszRESERVED, /* group 4 */
             dszRESERVED, dszRESERVED, dszRESERVED, dszRESERVED},

/* 03 */    {dszSLDT, dszSTR,   dszLLDT,     dszLTR,    /* group 6 */
             dszVERR, dszVERW,  dszRESERVED, dszRESERVED},

/* 04 */    {dszRESERVED, dszRESERVED, dszRESERVED, dszRESERVED, /* group 8 */
             dszBT,       dszBTS,      dszBTR,      dszBTC}

            };

/* Auxilary orderd pairs for groups of two byte instructions structured  */
/*   the same was as distbl above.                                       */

static Tdistbl groupt[][8] = {

/* 00  00                     x87-D8-1                   */
            { dszFADD,     O_dModrm,     /* D8-0 FADD    */
              dszFMUL,     O_dModrm,     /* D8-1 FMUL    */
              dszFCOM,     O_dModrm,     /* D8-2 FCOM    */
              dszFCOMP,    O_dModrm,     /* D8-3 FCOMP   */
              dszFSUB,     O_dModrm,     /* D8-4 FSUB    */
              dszFSUBR,    O_dModrm,     /* D8-5 FSUBR   */
              dszFDIV,     O_dModrm,     /* D8-6 FDIV    */
              dszFDIVR,    O_dModrm },   /* D8-7 FDIVR   */

/* 01                         x87-D8-2                   */
            { dszFADD,     O_ST_iST,     /* D8-0 FADD    */
              dszFMUL,     O_ST_iST,     /* D8-1 FMUL    */
              dszFCOM,     O_iST,        /* D8-2 FCOM    */
              dszFCOMP,    O_iST,        /* D8-3 FCOMP   */
              dszFSUB,     O_ST_iST,     /* D8-4 FSUB    */
              dszFSUBR,    O_ST_iST,     /* D8-5 FSUBR   */
              dszFDIV,     O_ST_iST,     /* D8-6 FDIV    */
              dszFDIVR,    O_ST_iST },   /* D8-7 FDIVR   */

/* 02   01                    x87-D9-1                   */
            { dszFLD,      O_dModrm,     /* D9-0 FLD     */
              dszRESERVED, O_DoDB,       /* D9-1         */
              dszFST,      O_dModrm,     /* D9-2 FST     */
              dszFSTP,     O_dModrm,     /* D9-3 FSTP    */
              dszFLDENV,   O_Modrm,      /* D9-4 FLDENV  */
              dszFLDCW,    O_Modrm,      /* D9-5 FLDCW   */
              dszFSTENV,   O_Modrm,      /* D9-6 FSTENV  */
              dszFSTCW,    O_Modrm },    /* D9-7 FSTCW   */

/* 03   01                    x87-D9-2 TTT=0,1,2,3       */
            { dszFLD,      O_iST,        /* D9-0 FLD     */
              dszFXCH,     O_iST,        /* D9-1 FXCH    */
              dszFNOP,     O_NoOperands, /* D9-2 FNOP    */
              dszFSTP,     O_iST,        /* D9-3 FSTP    */
              dszRESERVED, O_DoDB,       /* D9-4         */
              dszRESERVED, O_DoDB,       /* D9-5         */
              dszRESERVED, O_DoDB,       /* D9-6         */
              dszRESERVED, O_DoDB   },   /* D9-7         */

/* 04  02                     x89-DA-1                   */
            { dszFIADD,    O_dModrm,     /* DA-0 FIADD   */
              dszFIMUL,    O_dModrm,     /* DA-1 FIMUL   */
              dszFICOM,    O_dModrm,     /* DA-2 FICOM   */
              dszFICOMP,   O_dModrm,     /* DA-3 FICOMP  */
              dszFISUB,    O_dModrm,     /* DA-4 FISUB   */
              dszFISUBR,   O_dModrm,     /* DA-5 FISUBR  */
              dszFIDIV,    O_dModrm,     /* DA-6 FIDIV   */
              dszFIDIVR,   O_dModrm },   /* DA-7 FIDIVR  */

/* 05                         x87-DA-2                   */
            { dszRESERVED, O_DoDB,       /* DA-0         */
              dszRESERVED, O_DoDB,       /* DA-1         */
              dszRESERVED, O_DoDB,       /* DA-2         */
              dszRESERVED, O_DoDB,       /* DA-3         */
              dszRESERVED, O_DoDB,       /* DA-4         */
              dszFUCOMPP,  O_NoOperands, /* DA-5         */
              dszRESERVED, O_DoDB,       /* DA-6         */
              dszRESERVED, O_DoDB },     /* DA-7         */

/* 06  03                     x87-DB-1                   */
            { dszFILD,     O_dModrm,     /* DB-0 FILD    */
              dszRESERVED, O_DoDB,       /* DB-1         */
              dszFIST,     O_dModrm,     /* DB-2 FIST    */
              dszFISTP,    O_dModrm,     /* DB-3 FISTP   */
              dszRESERVED, O_DoDB,       /* DB-4         */
              dszFLD,      O_tModrm,     /* DB-5 FLD     */
              dszRESERVED, O_DoDB,       /* DB-6         */
              dszFSTP,     O_tModrm },   /* DB-7 FSTP    */

/* 07                      x87-DB-2 ttt=4        */
            { dszFENI,     O_NoOperands, /* DB-0 FENI    */
              dszFDISI,    O_NoOperands, /* DB-1 FDISI   */
              dszFCLEX,    O_NoOperands, /* DB-2 FCLEX   */
              dszFINIT,    O_NoOperands, /* DB-3 FINIT   */
              dszFSETPM,   O_DoDB,       /* DB-4 FSETPM  */
              dszRESERVED, O_DoDB,       /* DB-5         */
              dszRESERVED, O_DoDB,       /* DB-6         */
              dszRESERVED, O_DoDB },     /* DB-7         */

/* 08 04                      x87-DC-1                   */
            { dszFADD,     O_qModrm,     /* DC-0 FADD    */
              dszFMUL,     O_qModrm,     /* DC-1 FMUL    */
              dszFCOM,     O_qModrm,     /* DC-2 FCOM    */
              dszFCOMP,    O_qModrm,     /* DC-3 FCOMP   */
              dszFSUB,     O_qModrm,     /* DC-4 FSUB    */
              dszFSUBR,    O_qModrm,     /* DC-5 FSUBR   */
              dszFDIV,     O_qModrm,     /* DC-6 FDIV    */
              dszFDIVR,    O_qModrm },   /* DC-7 FDIVR   */

/* 09                         x87-DC-2                   */
            { dszFADD,     O_iST_ST,     /* DC-0 FADD    */
              dszFMUL,     O_iST_ST,     /* DC-1 FMUL    */
              dszFCOM,     O_iST,        /* DC-2 FCOM    */
              dszFCOMP,    O_iST,        /* DC-3 FCOMP   */
              dszFSUB,     O_iST_ST,     /* DC-4 FSUB    */
              dszFSUBR,    O_iST_ST,     /* DC-5 FSUBR   */
              dszFDIV,     O_iST_ST,     /* DC-6 FDIVR   */
              dszFDIVR,    O_iST_ST },   /* DC-7 FDIV    */

/* 10  05                     x87-DD-1                   */
            { dszFLD,      O_qModrm,     /* DD-0 FLD     */
              dszRESERVED, O_DoDB,       /* DD-1         */
              dszFST,      O_qModrm,     /* DD-2 FST     */
              dszFSTP,     O_qModrm,     /* DD-3 FSTP    */
              dszFRSTOR,   O_Modrm,      /* DD-4 FRSTOR  */
              dszRESERVED, O_DoDB,       /* DD-5         */
              dszFSAVE,    O_Modrm,      /* DD-6 FSAVE   */
              dszFSTSW,    O_Modrm },    /* DD-7 FSTSW   */

/* 11                         x87-DD-2                   */
            { dszFFREE,    O_iST,        /* DD-0 FFREE   */
              dszFXCH,     O_iST,        /* DD-1 FXCH    */
              dszFST,      O_iST,        /* DD-2 FST     */
              dszFSTP,     O_iST,        /* DD-3 FSTP    */
              dszFUCOM,    O_iST,        /* DD-4 FUCOM   */
              dszFUCOMP,   O_iST,        /* DD-5 FUCOMP  */
              dszRESERVED, O_DoDB,       /* DD-6         */
              dszRESERVED, O_DoDB },     /* DD-7         */

/* 12  06                     x87-DE-1                   */
            { dszFIADD,    O_wModrm,     /* DE-0 FIADD   */
              dszFIMUL,    O_wModrm,     /* DE-1 FIMUL   */
              dszFICOM,    O_wModrm,     /* DE-2 FICOM   */
              dszFICOMP,   O_wModrm,     /* DE-3 FICOMP  */
              dszFISUB,    O_wModrm,     /* DE-4 FISUB   */
              dszFISUBR,   O_wModrm,     /* DE-5 FISUBR  */
              dszFIDIV,    O_wModrm,     /* DE-6 FIDIV   */
              dszFIDIVR,   O_wModrm },   /* DE-7 FIDIVR  */

/* 13                         x87-DE-2                   */
            { dszFADDP,    O_iST_ST,     /* DE-0 FADDP   */
              dszFMULP,    O_iST_ST,     /* DE-1 FMULP   */
              dszFCOMP,    O_iST,        /* DE-2 FCOMP   */
              dszFCOMPP,   O_NoOperands, /* DE-3 FCOMPP  */
              dszFSUBP,    O_iST_ST,     /* DE-4 FSUBP   */
              dszFSUBRP,   O_iST_ST,     /* DE-5 FSUBRP  */
              dszFDIVP,    O_iST_ST,     /* DE-6 FDIVP   */
              dszFDIVRP,   O_iST_ST },   /* DE-7 FDIVRP  */

/* 14  07                     x87-DF-1                   */
            { dszFILD,     O_wModrm,     /* DF-0 FILD    */
              dszRESERVED, O_DoDB,       /* DF-1         */
              dszFIST,     O_wModrm,     /* DF-2 FIST    */
              dszFISTP,    O_wModrm,     /* DF-3 FISTP   */
              dszFBLD,     O_tModrm,     /* DF-4 FBLD    */
              dszFILD,     O_qModrm,     /* DF-5 FILD    */
              dszFBSTP,    O_tModrm,     /* DF-6 FBSTP   */
              dszFISTP,    O_qModrm },   /* DF-7 FISTP   */

/* 15                         x87-DF-2                   */
            { dszFFREE,    O_iST,        /* DF-0 FFREE   */
              dszFXCH,     O_iST,        /* DF-1 FXCH    */
              dszFST,      O_iST,        /* DF-2 FST     */
              dszFSTP,     O_iST,        /* DF-3 FSTP    */
              dszFSTSW,    O_NoOperands, /* DF-4 FSTSW   */
              dszRESERVED, O_DoDB,       /* DF-5         */
              dszRESERVED, O_DoDB,       /* DF-6         */
              dszRESERVED, O_DoDB },     /* DF-7         */

/* 16   01            x87-D9 Mod=3 TTT=4                 */
            { dszFCHS,     O_NoOperands, /* D9-0 FCHS    */
              dszFABS,     O_NoOperands,  /* D9-1 FABS   */
              dszRESERVED, O_DoDB,       /* D9-2         */
              dszRESERVED, O_DoDB,       /* D9-3         */
              dszFTST,     O_NoOperands, /* D9-4 FTST    */
              dszFXAM,     O_NoOperands, /* D9-5 FXAM    */
              dszRESERVED, O_DoDB,       /* D9-6         */
              dszRESERVED, O_DoDB },     /* D9-7         */

/* 17   01            x87-D9 Mod=3 TTT=5                 */
            { dszFLD1,     O_NoOperands, /* D9-0 FLD1    */
              dszFLDL2T,   O_NoOperands, /* D9-1 FLDL2T  */
              dszFLDL2E,   O_NoOperands, /* D9-2 FLDL2E  */
              dszFLDPI,    O_NoOperands, /* D9-3 FLDPI   */
              dszFLDLG2,   O_NoOperands, /* D9-4 FLDLG2  */
              dszFLDLN2,   O_NoOperands, /* D9-5 FLDLN2  */
              dszFLDZ,     O_NoOperands, /* D9-6 FLDZ    */
              dszRESERVED, O_DoDB },     /* D9-7         */

/* 18   01            x87-D9 Mod=3 TTT=6                   */
            { dszF2XM1,    O_NoOperands,   /* D9-0 F2XM1   */
              dszFYL2X,    O_NoOperands,   /* D9-1 FYL2X   */
              dszFPTAN,    O_NoOperands,   /* D9-2 FPTAN   */
              dszFPATAN,   O_NoOperands,   /* D9-3 FPATAN  */
              dszFXTRACT,  O_NoOperands,   /* D9-4 FXTRACT */
              dszFPREM1,   O_NoOperands,   /* D9-5 FPREM1  */
              dszFDECSTP,  O_NoOperands,   /* D9-6 FDECSTP */
              dszFINCSTP,  O_NoOperands }, /* D9-7 FINCSTP */

/* 19   01            x87-D9 Mod=3 TTT=7                   */
            { dszFPREM,    O_NoOperands,   /* D9-0 FPREM   */
              dszFYL2XP1,  O_NoOperands,   /* D9-1 FYL2XP1 */
              dszFSQRT,    O_NoOperands,   /* D9-2 FSQRT   */
              dszFSINCOS,  O_NoOperands,   /* D9-3 FSINCOS */
              dszFRNDINT,  O_NoOperands,   /* D9-4 FRNDINT */
              dszFSCALE,   O_NoOperands,   /* D9-5 FSCALE  */
              dszFSIN,     O_NoOperands,   /* D9-6 FSIN    */
              dszFCOS,     O_NoOperands }, /* D9-7 FCOS    */

/* 20                  group 3                             */
            { dszTEST,     O_bModrm_Ib,    /* F6-0 TEST    */
              dszRESERVED, O_DoDB,         /* F6-1         */
              dszNOT,      O_bModrm,       /* F6-2 NOT     */
              dszNEG,      O_bModrm,       /* F6-3 NEG     */
              dszMUL,      O_bModrm,       /* F6-4 MUL     */
              dszIMUL,     O_bModrm,       /* F6-5 IMUL    */
              dszDIV,      O_bModrm,       /* F6-6 DIV     */
              dszIDIV,     O_bModrm },     /* F6-7 IDIV    */

/* 21                  group 3                             */
            { dszTEST,     O_vModrm_Iv,    /* F7-0 TEST    */
              dszRESERVED, O_DoDB,         /* F7-1         */
              dszNOT,      O_vModrm,       /* F7-2 NOT     */
              dszNEG,      O_vModrm,       /* F7-3 NEG     */
              dszMUL,      O_vModrm,       /* F7-4 MUL     */
              dszIMUL,     O_vModrm,       /* F7-5 IMUL    */
              dszDIV,      O_vModrm,       /* F7-6 DIV     */
              dszIDIV,     O_vModrm },     /* F7-7 IDIV    */

/* 22                  group 5                             */
            { dszINC,      O_vModrm,     /* FF-0 INC       */
              dszDEC,      O_vModrm,     /* FF-1 DEC       */
              dszCALL,     O_vModrm,     /* FF-2 CALL      */
              dszCALL,     O_fModrm,     /* FF-3 CALL      */
              dszJMP,      O_vModrm,     /* FF-4 JMP       */
              dszJMP,      O_fModrm,     /* FF-5 JMP       */
              dszPUSH,     O_vModrm,     /* FF-6 PUSH      */
              dszRESERVED, O_DoDB },     /* FF-7           */

/* 23                  group 7                             */
            { dszSGDT,     O_Modrm,      /* 0F-0 SGDT      */
              dszSIDT,     O_Modrm,      /* 0F-1 SIDT      */
              dszLGDT,     O_Modrm,      /* 0F-2 LGDT      */
              dszLIDT,     O_Modrm,      /* 0F-3 LIDT      */
              dszSMSW,     O_wModrm,     /* 0F-4 MSW       */
              dszRESERVED, O_DoDB,       /* 0F-5           */
              dszLMSW,     O_wModrm,     /* 0F-6 LMSW      */
              dszRESERVED, O_DoDB }      /* 0F-7           */

            };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\i386\disasm.cpp ===
#include "apimonp.h"
#pragma hdrstop

#include "disasm.h"
#include "reg.h"

/*****                     macros and defines                          *****/

#define BIT20(b) (b & 0x07)
#define BIT53(b) (b >> 3 & 0x07)
#define BIT76(b) (b >> 6 & 0x03)
#define MAXL     16
#define MAXOPLEN 10

#define OBOFFSET 26
#define OBOPERAND 34
#define OBLINEEND 77

/*****                     static tables and variables                 *****/

static char regtab[] = "alcldlblahchdhbhaxcxdxbxspbpsidi";  /* reg table */
static char *mrmtb16[] = { "bx+si",  /* modRM string table (16-bit) */
                           "bx+di",
                           "bp+si",
                           "bp+di",
                           "si",
                           "di",
                           "bp",
                           "bx"
                         };

static char *mrmtb32[] = { "eax",       /* modRM string table (32-bit) */
                           "ecx",
                           "edx",
                           "ebx",
                           "esp",
                           "ebp",
                           "esi",
                           "edi"
                         };

static char seg16[8]   = { REGDS,  REGDS,  REGSS,  REGSS,
                           REGDS,  REGDS,  REGSS,  REGDS };
static char reg16[8]   = { REGEBX, REGEBX, REGEBP, REGEBP,
                           REGESI, REGEDI, REGEBP, REGEBX };
static char reg16_2[4] = { REGESI, REGEDI, REGESI, REGEDI };

static char seg32[8]   = { REGDS,  REGDS,  REGDS,  REGDS,
                           REGSS,  REGSS,  REGDS,  REGDS };
static char reg32[8]   = { REGEAX, REGECX, REGEDX, REGEBX,
                           REGESP, REGEBP, REGESI, REGEDI };

static char sregtab[] = "ecsdfg";  // first letter of ES, CS, SS, DS, FS, GS

char    hexdigit[] = { '0', '1', '2', '3', '4', '5', '6', '7',
                       '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

static int              mod;            /* mod of mod/rm byte */
static int              rm;             /* rm of mod/rm byte */
static int              ttt;            /* return reg value (of mod/rm) */
static LPSTR            pMem;           /* current position in instruction */
static int              mode_32;        /* local addressing mode indicator */
static int              opsize_32;      /* operand size flag */

ULONG                   EAaddr[2];      //  offset of effective address
static int              EAsize[2];      //  size of effective address item
static char             *pchEAseg[2];   //  normal segment for operand

int                     G_mode_32 = 1;  /* global address mode indicator */

static BOOL          fMovX;          // indicates a MOVSX or MOVZX

//      internal function definitions

void DIdoModrm(HANDLE hProcess,char **, int, BOOL);

void OutputHexString(char **, char *, int);
void OutputHexValue(char **, char *, int, int);
void OutputHexCode(char **, char *, int);
void OutputString(char **, char *);
void OutputSymbol(HANDLE, char **, char *, int, int);

void OutputHexAddr(LPSTR*, ULONG);
USHORT GetSegRegValue(int);


/**** disasm - disassemble an 80x86/80x87 instruction
*
*  Input:
*       pOffset = pointer to offset to start disassembly
*       fEAout = if set, include EA (effective address)
*
*  Output:
*       pOffset = pointer to offset of next instruction
*       pchDst = pointer to result string
*
***************************************************************************/

BOOL
disasm(
    HANDLE hProcess,
    PULONG pOffset,
    LPSTR  pchDst,
    BOOL   fEAout
    )
{
    int     opcode;                     /* current opcode */
    int     olen = 2;                   /* operand length */
    int     alen = 2;                   /* address length */
    int     end = FALSE;                /* end of instruction flag */
    int     mrm = FALSE;                /* indicator that modrm is generated*/
    unsigned char *action;              /* action for operand interpretation*/
    long    tmp;                        /* temporary storage field */
    int     indx;                       /* temporary index */
    int     action2;                    /* secondary action */
    int     instlen;                    /* instruction length */
    int     cBytes=MAXL;                //  bytes read into instr buffer
    int     segOvr = 0;                 /* segment override opcode */
    char    membuf[MAXL];               /* current instruction buffer */
    char    *pEAlabel = "";             //  optional label for operand

    char    *pchResultBuf = pchDst;     //  working copy of pchDst pointer
    char    RepPrefixBuffer[32];        //  rep prefix buffer
    char    *pchRepPrefixBuf = RepPrefixBuffer; //  pointer to prefix buffer
    char    OpcodeBuffer[8];            //  opcode buffer
    char    *pchOpcodeBuf = OpcodeBuffer; //  pointer to opcode buffer
    char    OperandBuffer[80];          //  operand buffer
    char    *pchOperandBuf = OperandBuffer; //  pointer to operand buffer
    char    ModrmBuffer[80];            //  modRM buffer
    char    *pchModrmBuf = ModrmBuffer; //  pointer to modRM buffer
    char    EABuffer[42];               //  effective address buffer
    char    *pchEABuf = EABuffer;       //  pointer to EA buffer

    int     obOpcode = OBOFFSET;
    int     obOpcodeMin;
    int     obOpcodeMax;

    int     obOperand = OBOPERAND;
    int     obOperandMin;
    int     obOperandMax;

    int     cbOpcode;
    int     cbOperand;
    int     cbOffset;
    int     cbEAddr;

    int     fTwoLines = FALSE;

    fMovX = FALSE;
    EAsize[0] = EAsize[1] = 0;          //  no effective address
    pchEAseg[0] = dszDS_;
    pchEAseg[1] = dszES_;

    mode_32 = opsize_32 = (G_mode_32 == 1); /* local addressing mode */
    olen = alen = (1 + mode_32) << 1;   //  set operand/address lengths
                                        //  2 for 16-bit and 4 for 32-bit

    OutputHexAddr(&pchResultBuf, *pOffset);

    *pchResultBuf++ = ' ';

    if (!ReadMemory( hProcess, (PVOID) *pOffset, membuf, MAXL )) {
        return FALSE;
    }

                                        /* move full inst to local buffer */
    pMem = membuf;                      /* point to begin of instruction */
    opcode = (int)(UCHAR)*pMem++;             /* get opcode */
    OutputString(&pchOpcodeBuf, distbl[opcode].instruct);
    action = actiontbl + distbl[opcode].opr; /* get operand action */

/*****          loop through all operand actions               *****/

    do {
        action2 = (*action) & 0xc0;
        switch((*action++) & 0x3f) {
            case ALT:                   /* alter the opcode if 32-bit */
                if (opsize_32) {
                    indx = *action++;
                    pchOpcodeBuf = &OpcodeBuffer[indx];
                    if (indx == 0)
                        OutputString(&pchOpcodeBuf, dszCWDE);
                    else {
                        *pchOpcodeBuf++ = 'd';
                        if (indx == 1)
                            *pchOpcodeBuf++ = 'q';
                        }
                    }
                break;

            case STROP:
                //  compute size of operands in indx
                //  also if dword operands, change fifth
                //  opcode letter from 'w' to 'd'.

                if (opcode & 1) {
                    if (opsize_32) {
                        indx = 4;
                        OpcodeBuffer[4] = 'd';
                        }
                    else
                        indx = 2;
                    }
                else
                    indx = 1;

                if (*action & 1) {
                    if (fEAout) {
                        EAaddr[0] = (ULONG)GetRegValue(REGESI);
                        EAsize[0] = indx;
                        }
                    }
                if (*action++ & 2) {
                    if (fEAout) {
                        EAaddr[1] = (ULONG)GetRegValue(REGEDI);
                        EAsize[1] = indx;
                        }
                    }
                break;

            case CHR:                   /* insert a character */
                *pchOperandBuf++ = *action++;
                break;

            case CREG:                  /* set debug, test or control reg */
                if ((opcode - 231) & 0x04)      //  remove bias from opcode
                    *pchOperandBuf++ = 't';
                else if ((opcode - 231) & 0x01)
                    *pchOperandBuf++ = 'd';
                else
                    *pchOperandBuf++ = 'c';
                *pchOperandBuf++ = 'r';
                *pchOperandBuf++ = (char)('0' + ttt);
                break;

            case SREG2:                 /* segment register */
                ttt = BIT53(opcode);    //  set value to fall through

            case SREG3:                 /* segment register */
                *pchOperandBuf++ = sregtab[ttt];  // reg is part of modrm
                *pchOperandBuf++ = 's';
                break;

            case BRSTR:                 /* get index to register string */
                ttt = *action++;        /*    from action table */
                goto BREGlabel;

            case BOREG:                 /* byte register (in opcode) */
                ttt = BIT20(opcode);    /* register is part of opcode */
                goto BREGlabel;

            case ALSTR:
                ttt = 0;                /* point to AL register */
BREGlabel:
            case BREG:                  /* general register */
                *pchOperandBuf++ = regtab[ttt * 2];
                *pchOperandBuf++ = regtab[ttt * 2 + 1];
                break;

            case WRSTR:                 /* get index to register string */
                ttt = *action++;        /*    from action table */
                goto WREGlabel;

            case VOREG:                 /* register is part of opcode */
                ttt = BIT20(opcode);
                goto VREGlabel;

            case AXSTR:
                ttt = 0;                /* point to eAX register */
VREGlabel:
            case VREG:                  /* general register */
                if (opsize_32)          /* test for 32bit mode */
                    *pchOperandBuf++ = 'e';
WREGlabel:
            case WREG:                  /* register is word size */
                *pchOperandBuf++ = regtab[ttt * 2 + 16];
                *pchOperandBuf++ = regtab[ttt * 2 + 17];
                break;

            case IST_ST:
                OutputString(&pchOperandBuf, "st(0),st");
                *(pchOperandBuf - 5) += (char)rm;
                break;

            case ST_IST:
                OutputString(&pchOperandBuf, "st,");
            case IST:
                OutputString(&pchOperandBuf, "st(0)");
                *(pchOperandBuf - 2) += (char)rm;
                break;

            case xBYTE:                 /* set instruction to byte only */
                EAsize[0] = 1;
                pEAlabel = "byte ptr ";
                break;

            case VAR:
                if (opsize_32)
                    goto DWORDlabel;

            case xWORD:
                EAsize[0] = 2;
                pEAlabel = "word ptr ";
                break;

            case EDWORD:
                opsize_32 = 1;    //  for control reg move, use eRegs
            case xDWORD:
DWORDlabel:
                EAsize[0] = 4;
                pEAlabel = "dword ptr ";
                break;

            case QWORD:
                EAsize[0] = 8;
                pEAlabel = "qword ptr ";
                break;

            case TTBYTE:
                EAsize[0] = 10;
                pEAlabel = "tbyte ptr ";
                break;

            case FARPTR:
                if (opsize_32) {
                    EAsize[0] = 6;
                    pEAlabel = "fword ptr ";
                    }
                else {
                    EAsize[0] = 4;
                    pEAlabel = "dword ptr ";
                    }
                break;

            case LMODRM:                //  output modRM data type
                if (mod != 3)
                    OutputString(&pchOperandBuf, pEAlabel);
                else
                    EAsize[0] = 0;

            case MODRM:                 /* output modrm string */
                if (segOvr)             /* in case of segment override */
                    OutputString(&pchOperandBuf, distbl[segOvr].instruct);
                *pchModrmBuf = '\0';
                OutputString(&pchOperandBuf, ModrmBuffer);
                break;

            case ADDRP:                 /* address pointer */
                OutputHexString(&pchOperandBuf, pMem + olen, 2); // segment
                *pchOperandBuf++ = ':';
                OutputSymbol(hProcess, &pchOperandBuf, pMem, olen, segOvr);
                pMem += olen + 2;
                break;

            case REL8:                  /* relative address 8-bit */
                if (opcode == 0xe3 && mode_32) {
                    pchOpcodeBuf = OpcodeBuffer;
                    OutputString(&pchOpcodeBuf, dszJECXZ);
                    }
                tmp = (long)*(char *)pMem++; /* get the 8-bit rel offset */
                goto DoRelDispl;

            case REL16:                 /* relative address 16-/32-bit */
                tmp = 0;
                memmove(&tmp,pMem,sizeof(long));
                pMem += alen;           /* skip over offset */
DoRelDispl:
                tmp += *pOffset + (pMem - membuf); /* calculate address */
                OutputSymbol(hProcess, &pchOperandBuf, (char *) &tmp, alen, segOvr);
                                                   // address
                break;

            case UBYTE:                 //  unsigned byte for int/in/out
                OutputHexString(&pchOperandBuf, pMem, 1);  //  ubyte
                pMem++;
                break;

            case IB:                    /* operand is immediate byte */
                if ((opcode & ~1) == 0xd4) {  // postop for AAD/AAM is 0x0a
                    if (*pMem++ != 0x0a) // test post-opcode byte
                        OutputString(&pchOperandBuf, dszRESERVED);
                    break;
                    }
                olen = 1;               /* set operand length */
                goto DoImmed;

            case IW:                    /* operand is immediate word */
                olen = 2;               /* set operand length */

            case IV:                    /* operand is word or dword */
DoImmed:
                OutputHexValue(&pchOperandBuf, pMem, olen, FALSE);
                pMem += olen;
                break;

            case OFFS:                  /* operand is offset */
                EAsize[0] = (opcode & 1) ? olen : 1;

                if (segOvr)             /* in case of segment override */
                    OutputString(&pchOperandBuf, distbl[segOvr].instruct);

                *pchOperandBuf++ = '[';
                OutputSymbol(hProcess,&pchOperandBuf, pMem, alen, segOvr);  //  offset
                pMem += alen;
                *pchOperandBuf++ = ']';
                break;

            case GROUP:                 /* operand is of group 1,2,4,6 or 8 */
                                        /* output opcode symbol */
                OutputString(&pchOpcodeBuf, group[*action++][ttt]);
                break;

            case GROUPT:                /* operand is of group 3,5 or 7 */
                indx = *action;         /* get indx into group from action */
                goto doGroupT;

            case EGROUPT:               /* x87 ESC (D8-DF) group index */
                indx = BIT20(opcode) * 2; /* get group index from opcode */
                if (mod == 3) {         /* some operand variations exists */
                                        /*   for x87 and mod == 3 */
                    ++indx;             /* take the next group table entry */
                    if (indx == 3) {    /* for x87 ESC==D9 and mod==3 */
                        if (ttt > 3) {  /* for those D9 instructions */
                            indx = 12 + ttt; /* offset index to table by 12 */
                            ttt = rm;   /* set secondary index to rm */
                            }
                        }
                    else if (indx == 7) { /* for x87 ESC==DB and mod==3 */
                        if (ttt == 4)   /* only valid if ttt==4 */
                            ttt = rm;   /* set secondary group table index */
                        else
                            ttt = 7;    /* no an x87 instruction */
                        }
                    }
doGroupT:
                /* handle group with different types of operands */

                OutputString(&pchOpcodeBuf, groupt[indx][ttt].instruct);
                action = actiontbl + groupt[indx][ttt].opr;
                                                        /* get new action */
                break;

            case OPC0F:                 /* secondary opcode table (opcode 0F) */
                opcode = *pMem++;       /* get real opcode */
                fMovX  = (BOOL)(opcode == 0xBF || opcode == 0xB7);
                if (opcode < 7) /* for the first 7 opcodes */
                    opcode += 256;      /* point begin of secondary opcode tab. */
                else if (opcode > 0x1f && opcode < 0x32)
                    opcode += 231;      /* adjust for non-existing opcodes */
                else if (opcode > 0x2f && opcode < 0x33)
                    opcode += 222;      /* adjust for non-existing opcodes */
                else if (opcode > 0x7e && opcode < 0xd0)
                    opcode += 148;      /* adjust for non-existing opcodes */
                else
                    opcode = 260;       /* all non-existing opcodes */
                goto getNxtByte1;

            case ADR_OVR:               /* address override */
                mode_32 = !G_mode_32;   /* override addressing mode */
                alen = (mode_32 + 1) << 1; /* toggle address length */
                goto getNxtByte;

            case OPR_OVR:               /* operand size override */
                opsize_32 = !G_mode_32; /* override operand size */
                olen = (opsize_32 + 1) << 1; /* toggle operand length */
                goto getNxtByte;

            case SEG_OVR:               /* handle segment override */
                segOvr = opcode;        /* save segment override opcode */
                pchOpcodeBuf = OpcodeBuffer;  // restart the opcode string
                goto getNxtByte;

            case REP:                   /* handle rep/lock prefixes */
                *pchOpcodeBuf = '\0';
                if (pchRepPrefixBuf != RepPrefixBuffer)
                    *pchRepPrefixBuf++ = ' ';
                OutputString(&pchRepPrefixBuf, OpcodeBuffer);
                pchOpcodeBuf = OpcodeBuffer;
getNxtByte:
                opcode = (int)(UCHAR)*pMem++;        /* next byte is opcode */
getNxtByte1:
                action = actiontbl + distbl[opcode].opr;
                OutputString(&pchOpcodeBuf, distbl[opcode].instruct);

            default:                    /* opcode has no operand */
                break;
            }
        switch (action2) {              /* secondary action */
            case MRM:                   /* generate modrm for later use */
                if (!mrm) {             /* ignore if it has been generated */
                    DIdoModrm(hProcess, &pchModrmBuf, segOvr, fEAout);
                                        /* generate modrm */
                    mrm = TRUE;         /* remember its generation */
                    }
                break;

            case COM:                   /* insert a comma after operand */
                *pchOperandBuf++ = ',';
                break;

            case END:                   /* end of instruction */
                end = TRUE;
                break;
            }
 } while (!end);                        /* loop til end of instruction */

/*****       prepare disassembled instruction for output              *****/

    instlen = pMem - membuf;

    if (instlen < cBytes)
        cBytes = instlen;

    OutputHexCode(&pchResultBuf, membuf, cBytes);

    if (instlen > cBytes) {
        *pchResultBuf++ = '?';
        *pchResultBuf++ = '?';
        (*pOffset)++;                   //  point past unread byte
        }

    *pOffset += instlen;                /* set instruction length */

    if (instlen > cBytes) {
        do
            *pchResultBuf++ = ' ';
        while (pchResultBuf < pchDst + OBOFFSET);
        OutputString(&pchResultBuf, "???");
        *pchResultBuf++ = '\0';
        return FALSE;
        }

    //  if fEAout is set, build each EA with trailing space in EABuf
    //  point back over final trailing space if buffer nonnull

    if (fEAout) {

        for (indx = 0; indx < 2; indx++)
            if (EAsize[indx]) {
                OutputString(&pchEABuf, segOvr ? distbl[segOvr].instruct
                                               : pchEAseg[indx]);
                OutputHexAddr(&pchEABuf, EAaddr[indx]);
                *pchEABuf++ = '=';

                tmp = ReadMemory( hProcess, (PVOID) EAaddr[indx], membuf, EAsize[indx] );
                if (tmp == EAsize[indx])
                    OutputHexString(&pchEABuf, (char *)membuf, EAsize[indx]);
                else
                    while (EAsize[indx]--) {
                        *pchEABuf++ = '?';
                        *pchEABuf++ = '?';
                        }
                *pchEABuf++ = ' ';
                }
        if (pchEABuf != EABuffer)
            pchEABuf--;
        }

    //  compute lengths of component strings.
    //  if the rep string is nonnull,
    //      add the opcode string length to the operand
    //      make the rep string the opcode string

    cbOffset = pchResultBuf - pchDst;
    cbOperand = pchOperandBuf - OperandBuffer;
    cbOpcode = pchOpcodeBuf - OpcodeBuffer;
    if (pchRepPrefixBuf != RepPrefixBuffer) {
        cbOperand += cbOpcode + (cbOperand != 0);
        cbOpcode = pchRepPrefixBuf - RepPrefixBuffer;
        }
    cbEAddr = pchEABuf - EABuffer;

    //  for really long strings, where the opcode and operand
    //      will not fit on a 77-character line, make two lines
    //      with the opcode on offset 0 on the second line with
    //      the operand following after one space

    if (cbOpcode + cbOperand > OBLINEEND - 1) {
        fTwoLines = TRUE;
        obOpcode = 0;
        obOperand = cbOpcode + 1;
        }
    else {

        //  compute the minimum and maximum offset values for
        //      opcode and operand strings.
        //  if strings are nonnull, add extra for separating space

        obOpcodeMin = cbOffset + 1;
        obOperandMin = obOpcodeMin + cbOpcode + 1;
        obOperandMax = OBLINEEND - cbEAddr - (cbEAddr != 0) - cbOperand;
        obOpcodeMax = obOperandMax - (cbOperand != 0) - cbOpcode;

        //  if minimum offset is more than the maximum, the strings
        //      will not fit on one line.  recompute the min/max
        //      values with no offset and EA strings.

        if (obOpcodeMin > obOpcodeMax) {
            fTwoLines = TRUE;
            obOpcodeMin = 0;
            obOperandMin = cbOpcode + 1;
            obOperandMax = OBLINEEND - cbOperand;
            obOpcodeMax = obOperandMax - (cbOperand != 0) - cbOpcode;
            }

        //  compute the opcode and operand offsets.  set offset as
        //      close to the default values as possible.

        if (obOpcodeMin > OBOFFSET)
            obOpcode = obOpcodeMin;
        else if (obOpcodeMax < OBOFFSET)
            obOpcode = obOpcodeMax;

        obOperandMin = obOpcode + cbOpcode + 1;

        if (obOperandMin > OBOPERAND)
            obOperand = obOperandMin;
        else if (obOperandMax < OBOPERAND)
            obOperand = obOperandMax;
        }

    //  build the resultant string with the offsets computed

    //  if two lines are to be output,
    //      append the EAddr string
    //      output a new line and reset the pointer

    if (fTwoLines) {
        if (pchEABuf != EABuffer) {
            do
                *pchResultBuf++ = ' ';
            while (pchResultBuf < pchDst + OBLINEEND - cbEAddr);
            *pchEABuf = '\0';
            OutputString(&pchResultBuf, EABuffer);
            OutputString(&pchResultBuf, "\n        ");
            }
        pchDst = pchResultBuf;
        }

    //  output rep, opcode, and operand strings

    do
        *pchResultBuf++ = ' ';
    while (pchResultBuf < pchDst + obOpcode);

    if (pchRepPrefixBuf != RepPrefixBuffer) {
        *pchRepPrefixBuf = '\0';
        OutputString(&pchResultBuf, RepPrefixBuffer);
        do
            *pchResultBuf++ = ' ';
        while (pchResultBuf < pchDst + obOperand);
        }

    *pchOpcodeBuf = '\0';
    OutputString(&pchResultBuf, OpcodeBuffer);

    if (pchOperandBuf != OperandBuffer) {
        do
            *pchResultBuf++ = ' ';
        while (pchResultBuf < pchDst + obOperand);
        *pchOperandBuf = '\0';
        OutputString(&pchResultBuf, OperandBuffer);
        }

    //  if one line is to be output, append the EAddr string

    if (!fTwoLines && pchEABuf != EABuffer) {
        *pchEABuf = '\0';
        do
            *pchResultBuf++ = ' ';
        while (pchResultBuf < pchDst + OBLINEEND - cbEAddr);
        OutputString(&pchResultBuf, EABuffer);
        }

    *pchResultBuf = '\0';
    return TRUE;
}

/*...........................internal function..............................*/
/*                                                                          */
/*                       generate a mod/rm string                           */
/*                                                                          */

void
DIdoModrm (HANDLE hProcess, char **ppchBuf, int segOvr, BOOL fEAout)
{
    int     mrm;                        /* modrm byte */
    char    *src;                       /* source string */
    int     sib;
    int     ss;
    int     ind;
    int     oldrm;

    mrm = *pMem++;                      /* get the mrm byte from instruction */
    mod = BIT76(mrm);                   /* get mod */
    ttt = BIT53(mrm);                   /* get reg - used outside routine */
