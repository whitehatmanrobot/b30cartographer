
            //
            // The medium must be a stream
            //
            if (TYMED_ISTREAM != pSTM->tymed) {
                hr = DATA_E_FORMATETC;
                break;
            }

            hr = m_pObj->m_pCtrl->LoadFromStream(pSTM->pstm);
        } while (0);

        if (fRelease)
            ReleaseStgMedium(pSTM);

    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


/*
 * CImpIDataObject::EnumFormatEtc
 *
 * Purpose:
 *  Returns an IEnumFORMATETC object through which the caller can
 *  iterate to learn about all the data formats this object can
 *  provide through either GetData[Here] or SetData.
 *
 * Parameters:
 *  dwDir           DWORD describing a data direction, either
 *                  DATADIR_SET or DATADIR_GET.
 *  ppEnum          LPENUMFORMATETC * in which to return the
 *                  pointer to the enumerator.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP 
CImpIDataObject::EnumFormatEtc(
    DWORD dwDir, 
    LPENUMFORMATETC *ppEnum
    )
{
    HRESULT hr = S_OK;

    if (ppEnum == NULL) {
        return E_POINTER;
    }

    try {
        hr = m_pObj->m_pDefIDataObject->EnumFormatEtc(dwDir, ppEnum);
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}




/*
 * CImpIDataObject::DAdvise
 * CImpIDataObject::DUnadvise
 * CImpIDataObject::EnumDAdvise
 */

STDMETHODIMP 
CImpIDataObject::DAdvise(
    LPFORMATETC pFE, 
    DWORD dwFlags, 
    LPADVISESINK pIAdviseSink, 
    LPDWORD pdwConn
    )
{
    HRESULT  hr = S_OK;

    try {
        do {
            // Check if requested format is supported
            hr = QueryGetData(pFE);
            if (FAILED(hr)) {
                break;
            }

            if (NULL == m_pObj->m_pIDataAdviseHolder) {
                hr = CreateDataAdviseHolder(&m_pObj->m_pIDataAdviseHolder);
        
                if (FAILED(hr)) {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }

            hr = m_pObj->m_pIDataAdviseHolder->Advise(this, 
                                                      pFE, 
                                                      dwFlags, 
                                                      pIAdviseSink, 
                                                      pdwConn);
        } while (0);

    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP 
CImpIDataObject::DUnadvise(
    IN DWORD dwConn
    )
{
    HRESULT  hr;

    if (NULL == m_pObj->m_pIDataAdviseHolder) {
        return E_FAIL;
    }

    hr = m_pObj->m_pIDataAdviseHolder->Unadvise(dwConn);

    return hr;
}



STDMETHODIMP 
CImpIDataObject::EnumDAdvise(
    OUT LPENUMSTATDATA *ppEnum
    )
{
    HRESULT  hr = S_OK;

    if (ppEnum == NULL) {
        return E_POINTER;
    }

    try {
        *ppEnum = NULL;

        if (m_pObj->m_pIDataAdviseHolder != NULL) {
            hr = m_pObj->m_pIDataAdviseHolder->EnumAdvise(ppEnum);
        } 
        else {
            hr = E_FAIL;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\iipaobj.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    iipaobj.cpp

Abstract:

    IOleInPlaceActiveObject interface implementation for Polyline

--*/

#include "polyline.h"
#include "unkhlpr.h"
#include "unihelpr.h"

/*
 * CImpIOleInPlaceActiveObject::CImpIOleInPlaceActiveObject
 * CImpIOleInPlaceActiveObject::~CImpIOleInPlaceActiveObject
 *
 * Parameters (Constructor):
 *  pObj            PCPolyline of the object we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */
IMPLEMENT_CONTAINED_CONSTRUCTOR(CPolyline, CImpIOleInPlaceActiveObject)
IMPLEMENT_CONTAINED_DESTRUCTOR(CImpIOleInPlaceActiveObject)

IMPLEMENT_CONTAINED_ADDREF(CImpIOleInPlaceActiveObject)
IMPLEMENT_CONTAINED_RELEASE(CImpIOleInPlaceActiveObject)


STDMETHODIMP 
CImpIOleInPlaceActiveObject::QueryInterface(
    REFIID riid, 
    PPVOID ppv
    )
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        return E_POINTER;
    }

    /*
     * This interface should be stand-alone on an object such that a
     * container cannot QueryInterface for it through any other
     * object interface, relying instead of calls to SetActiveObject
     * for it.  By implementing QueryInterface here ourselves, we
     * prevent such abuses.  Note that reference counting still uses
     * CFigure.
     */

    try {
        *ppv=NULL;

        if (IID_IUnknown==riid || 
            IID_IOleWindow==riid || 
            IID_IOleInPlaceActiveObject==riid) {

            *ppv = this;
            AddRef();
        }
        else {
            hr = E_NOINTERFACE;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}




/*
 * CImpIOleInPlaceActiveObject::GetWindow
 *
 * Purpose:
 *  Retrieves the handle of the window associated with the object on
 *  which this interface is implemented.
 *
 * Parameters:
 *  phWnd           HWND * in which to store the window handle.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, E_FAIL if there is no
 *                  window.
 */

STDMETHODIMP 
CImpIOleInPlaceActiveObject::GetWindow(
    OUT HWND *phWnd
    )
{
    HRESULT hr = S_OK;

    if (phWnd == NULL) {
        return E_POINTER;
    }

    try {
        *phWnd=m_pObj->m_pHW->Window();;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}




/*
 * CImpIOleInPlaceActiveObject::ContextSensitiveHelp
 *
 * Purpose:
 *  Instructs the object on which this interface is implemented to
 *  enter or leave a context-sensitive help mode.
 *
 * Parameters:
 *  fEnterMode      BOOL TRUE to enter the mode, FALSE otherwise.
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code.
 */

STDMETHODIMP 
CImpIOleInPlaceActiveObject::ContextSensitiveHelp(
    BOOL /* fEnterMode */ 
    )
{
    return (E_NOTIMPL);
}




/*
 * CImpIOleInPlaceActiveObject::TranslateAccelerator
 *
 * Purpose:
 *  Requests that the active in-place object translate the message
 *  given in pMSG if appropriate.  This is only called for DLL
 *  servers where the container's message loop is running.  EXE
 *  servers have control of the message loop so this will not be
 *  called in such cases.
 *
 * Parameters:
 *  pMSG            LPMSG to the message to translate.
 *
 * Return Value:
 *  HRESULT         NOERROR if translates, S_FALSE if not.
 */

STDMETHODIMP 
CImpIOleInPlaceActiveObject::TranslateAccelerator(
    IN LPMSG pMSG
    )
{
    HRESULT hr = S_OK;

    //
    // Don't handle keys unless we are UI active
    //
    if (!m_pObj->m_fUIActive) {
        return S_FALSE;
    }

    try {
        // Delegate to the control class
        hr = m_pObj->m_pCtrl->TranslateAccelerators(pMSG);
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}




/*
 * CImpIOleInPlaceActiveObject::OnFrameWindowActivate
 *
 * Purpose:
 *  Informs the in-place object that the container's frame window
 *  was either activated or deactivated.  Not currently used.
 *
 * Parameters:
 *  fActivate       BOOL TRUE if the frame is active,
 *                  FALSE otherwise
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code.
 */

STDMETHODIMP 
CImpIOleInPlaceActiveObject::OnFrameWindowActivate (
    BOOL /* fActivate */
    )
{
    return E_NOTIMPL;
}




/*
 * CImpIOleInPlaceActiveObject::OnDocWindowActivate
 *
 * Purpose:
 *  Informs the in-place object that the document window in the
 *  container is either becoming active or deactive.  On this call
 *  the object must either add or remove frame-level tools,
 *  including the mixed menu, depending on fActivate.
 *
 * Parameters:
 *  fActivate       BOOL TRUE if the document is active,
 *                  FALSE otherwise
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code.
 */

STDMETHODIMP 
CImpIOleInPlaceActiveObject::OnDocWindowActivate (
    BOOL fActivate
    )
{
    HRESULT hr;

    if (NULL==m_pObj->m_pIOleIPFrame) {
        return S_OK;
    }

    if (fActivate) {
        hr = m_pObj->m_pIOleIPFrame->SetActiveObject(this, ResourceString(IDS_USERTYPE));

        hr = m_pObj->m_pIOleIPFrame->SetMenu(m_pObj->m_hMenuShared, 
                                        m_pObj->m_hOLEMenu, 
                                        m_pObj->m_pCtrl->Window());

    } 
    else {
        hr = m_pObj->m_pIOleIPFrame->SetActiveObject(NULL, NULL);
    }

    return hr;
}




/*
 * CImpIOleInPlaceActiveObject::ResizeBorder
 *
 * Purpose:
 *  Informs the object that the frame or document size changed in
 *  which case the object may need to resize any of its frame or
 *  document-level tools to match.
 *
 * Parameters:
 *  pRect           LPCRECT indicating the new size of the window
 *                  of interest.
 *  pIUIWindow      LPOLEINPLACEUIWINDOW pointing to an
 *                  IOleInPlaceUIWindow interface on the container
 *                  object of interest.  We use this to do
 *                  border-space negotiation.
 *
 *  fFrame          BOOL indicating if the frame was resized (TRUE)
 *                  or the document (FALSE)
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code.
 */

STDMETHODIMP 
CImpIOleInPlaceActiveObject::ResizeBorder (
    LPCRECT,  /* pRect */
    LPOLEINPLACEUIWINDOW,  /* pIUIWindow */
    BOOL /* fFrame */ 
    )
{
    return (E_NOTIMPL);
}




/*
 * CImpIOleInPlaceActiveObject::EnableModeless
 *
 * Purpose:
 *  Instructs the object to show or hide any modeless popup windows
 *  that it may be using when activated in-place.
 *
 * Parameters:
 *  fEnable         BOOL indicating to enable/show the windows
 *                  (TRUE) or to hide them (FALSE).
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code.
 */

STDMETHODIMP 
CImpIOleInPlaceActiveObject::EnableModeless ( 
    BOOL /* fActivate */ 
    )
{
    return (E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\iextconn.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    iextconn.cpp

Abstract:

    Implementation of IExternalConnection as required for an
    in-process object that supports linking to embedding.
    Specifically, this will call IOleObject::Close when there
    are no more strong locks on the object.

--*/

#include "polyline.h"
#include "unkhlpr.h"

// CImpIExternalConnection interface implementation
CImpIExternalConnection::CImpIExternalConnection(
    PCPolyline pObj, 
    LPUNKNOWN pUnkOuter
    )
{
    m_cRef=0;
    m_pObj=pObj;
    m_pUnkOuter=pUnkOuter;
    m_cLockStrong=0L;
}

IMPLEMENT_CONTAINED_DESTRUCTOR(CImpIExternalConnection)
IMPLEMENT_CONTAINED_IUNKNOWN(CImpIExternalConnection)


/*
 * CImpIExternalConnection::AddConnection
 *
 * Purpose:
 *  Informs the object that a strong connection has been made to it.
 *
 * Parameters:
 *  dwConn          DWORD identifying the type of connection, taken
 *                  from the EXTCONN enumeration.
 *  dwReserved      DWORD reserved.  This is used inside OLE and
 *                  should not be validated.
 *
 * Return Value:
 *  DWORD           The number of connection counts on the
 *                  object, used for debugging purposes only.
 */

STDMETHODIMP_(DWORD) CImpIExternalConnection::AddConnection(
    DWORD dwConn, 
    DWORD /* dwReserved */
    )
{
    if (EXTCONN_STRONG & dwConn)
        return ++m_cLockStrong;

    return 0;
}

/*
 * CImpIExternalConnection::ReleaseConnection
 *
 * Purpose:
 *  Informs an object that a connection has been taken away from
 *  it in which case the object may need to shut down.
 *
 * Parameters:
 *  dwConn              DWORD identifying the type of connection,
 *                      taken from the EXTCONN enumeration.
 *  dwReserved          DWORD reserved.  This is used inside OLE and
 *                      should not be validated.
 *  dwRerved            DWORD reserved
 *  fLastReleaseCloses  BOOL indicating if the last call to this
 *                      function should close the object.
 *
 * Return Value:
 *  DWORD           The number of remaining connection counts on
 *                  the object, used for debugging purposes only.
 */

STDMETHODIMP_(DWORD) CImpIExternalConnection::ReleaseConnection(
    DWORD dwConn, 
    DWORD /* dwReserved */, 
    BOOL fLastReleaseCloses
    )
{
    if (EXTCONN_STRONG==dwConn)
    {
        if (0==--m_cLockStrong && fLastReleaseCloses)
            m_pObj->m_pImpIOleObject->Close(OLECLOSE_SAVEIFDIRTY);

        return m_cLockStrong;
    }

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\iipobj.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    iipobj.cpp

Abstract:

    IOleInPlaceObject interface implementation for Polyline

--*/

#include "polyline.h"
#include "unkhlpr.h"

/*
 *  CImpIOleInPlaceObject interface implementation
 */

IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIOleInPlaceObject)


/*
 * CImpIOleInPlaceObject::GetWindow
 *
 * Purpose:
 *  Retrieves the handle of the window associated with the object
 *  on which this interface is implemented.
 *
 * Parameters:
 *  phWnd           HWND * in which to store the window handle.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, E_FAIL if there is no
 *                  window.
 */

STDMETHODIMP 
CImpIOleInPlaceObject::GetWindow(
    OUT HWND *phWnd
    )
{
    HRESULT hr = S_OK;

    if (phWnd == NULL) {
        return E_POINTER;
    }

    try {
        if (NULL != m_pObj->m_pHW) {
            *phWnd = m_pObj->m_pHW->Window();
        }
        else {
            *phWnd = m_pObj->m_pCtrl->Window();
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return NOERROR;
}




/*
 * CImpIOleInPlaceObject::ContextSensitiveHelp
 *
 * Purpose:
 *  Instructs the object on which this interface is implemented to
 *  enter or leave a context-sensitive help mode.
 *
 * Parameters:
 *  fEnterMode      BOOL TRUE to enter the mode, FALSE otherwise.
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code
 */

STDMETHODIMP 
CImpIOleInPlaceObject::ContextSensitiveHelp (
    BOOL /* fEnterMode */
    )
{
    return (E_NOTIMPL);
}




/*
 * CImpIOleInPlaceObject::InPlaceDeactivate
 *
 * Purpose:
 *  Instructs the object to deactivate itself from an in-place state
 *  and to discard any Undo state.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code
 */

STDMETHODIMP 
CImpIOleInPlaceObject::InPlaceDeactivate(void)
{
    m_pObj->InPlaceDeactivate();
    return NOERROR;
}




/*
 * CImpIOleInPlaceObject::UIDeactivate
 *
 * Purpose:
 *  Instructs the object to just remove any in-place user interface
 *  but to do no other deactivation.  The object should just hide
 *  the UI components but not destroy them until InPlaceDeactivate
 *  is called.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code
 */

STDMETHODIMP 
CImpIOleInPlaceObject::UIDeactivate(void)
{
    m_pObj->UIDeactivate();
    return NOERROR;
}




/*
 * CImpIOleInPlaceObject::SetObjectRects
 *
 * Purpose:
 *  Provides the object with rectangles describing the position of
 *  the object in the container window as well as its visible area.
 *
 * Parameters:
 *  prcPos          LPCRECT providing the object's full rectangle
 *                  relative to the continer's document.  The object
 *                  should scale to this rectangle.
 *  prcClip         LPCRECT describing the visible area of the object
 *                  which should not draw outside these areas.
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code
 */

STDMETHODIMP 
CImpIOleInPlaceObject::SetObjectRects(
    LPCRECT prcPos, 
    LPCRECT prcClip
    )
{
    HRESULT hr = S_OK;

    if (NULL != m_pObj->m_pHW) {
        try {
            m_pObj->m_pHW->RectsSet((LPRECT)prcPos, (LPRECT)prcClip);
        } catch (...) {
            hr = E_POINTER;
        }
    }

    return hr;
}




/*
 * CImpIOleInPlaceObject::ReactivateAndUndo
 *
 * Purpose:
 *  Instructs the object to reactivate itself in-place and perform
 *  whatever Undo means for it.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code
 */

STDMETHODIMP 
CImpIOleInPlaceObject::ReactivateAndUndo(void)
{
    return m_pObj->InPlaceActivate(m_pObj->m_pIOleClientSite, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\inole.h ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    inole.h

Abstract:

    Master header file for all Inside OLE samples.

--*/

#ifndef _INOLE_H_
#define _INOLE_H_

#define INC_OLE2
#include <windows.h>
#include <ole2.h>
#include <ole2ver.h>

#ifdef INITGUIDS
#include <initguid.h>
#endif

#include <oleauto.h>
#include <olectl.h>



//Types that OLE2.H et. al. leave out

#ifndef PPVOID
typedef LPVOID * PPVOID;
#endif  //PPVOID


#ifdef _OLE2_H_   //May not include ole2.h at all times.

#ifndef PPOINTL
typedef POINTL * PPOINTL;
#endif  //PPOINTL


#ifndef _WIN32
#ifndef OLECHAR
typedef char OLECHAR;
typedef OLECHAR FAR* LPOLESTR;
typedef const OLECHAR FAR* LPCOLESTR;
#endif //OLECHAR
#endif //_WIN32

#include <tchar.h>

//Useful macros.
#define SETFormatEtc(fe, cf, asp, td, med, li)   \
    {\
    (fe).cfFormat=cf;\
    (fe).dwAspect=asp;\
    (fe).ptd=td;\
    (fe).tymed=med;\
    (fe).lindex=li;\
    }

#define SETDefFormatEtc(fe, cf, med)   \
    {\
    (fe).cfFormat=cf;\
    (fe).dwAspect=DVASPECT_CONTENT;\
    (fe).ptd=NULL;\
    (fe).tymed=med;\
    (fe).lindex=-1;\
    }


#define SETRECTL(rcl, l, t, r, b) \
    {\
    (rcl).left=l;\
    (rcl).top=t;\
    (rcl).right=r;\
    (rcl).bottom=b;\
    }

#define SETSIZEL(szl, h, v) \
    {\
    (szl).cx=h;\
    (szl).cy=v;\
    }


#define RECTLFROMRECT(rcl, rc)\
    {\
    (rcl).left=(long)(rc).left;\
    (rcl).top=(long)(rc).top;\
    (rcl).right=(long)(rc).right;\
    (rcl).bottom=(long)(rc).bottom;\
    }


#define RECTFROMRECTL(rc, rcl)\
    {\
    (rc).left=(int)(rcl).left;\
    (rc).top=(int)(rcl).top;\
    (rc).right=(int)(rcl).right;\
    (rc).bottom=(int)(rcl).bottom;\
    }


#define POINTLFROMPOINT(ptl, pt) \
    { \
    (ptl).x=(long)(pt).x; \
    (ptl).y=(long)(pt).y; \
    }


#define POINTFROMPOINTL(pt, ptl) \
    { \
    (pt).x=(int)(ptl).x; \
    (pt).y=(int)(ptl).y; \
    }

//Here's one that should be in windows.h
#define SETPOINT(pt, h, v) \
    {\
    (pt).x=h;\
    (pt).y=v;\
    }

#define SETPOINTL(ptl, h, v) \
    {\
    (ptl).x=h;\
    (ptl).y=v;\
    }

#endif  //_OLE2_H_

//Macros for setting DISPPARAMS structures
#define SETDISPPARAMS(dp, numArgs, pvArgs, numNamed, pNamed) \
    {\
    (dp).cArgs=numArgs;\
    (dp).rgvarg=pvArgs;\
    (dp).cNamedArgs=numNamed;\
    (dp).rgdispidNamedArgs=pNamed;\
    }

#define SETNOPARAMS(dp) SETDISPPARAMS(dp, 0, NULL, 0, NULL)

//Macros for setting EXCEPINFO structures
#define SETEXCEPINFO(ei, excode, src, desc, file, ctx, func, scd) \
    {\
    (ei).wCode=excode;\
    (ei).wReserved=0;\
    (ei).bstrSource=src;\
    (ei).bstrDescription=desc;\
    (ei).bstrHelpFile=file;\
    (ei).dwHelpContext=ctx;\
    (ei).pvReserved=NULL;\
    (ei).pfnDeferredFillIn=func;\
    (ei).scode=scd;\
    }


#define INITEXCEPINFO(ei) \
        SETEXCEPINFO(ei,0,NULL,NULL,NULL,0L,NULL,S_OK)


/*
 * State flags for IPersistStorage implementations.  These
 * are kept here to avoid repeating the code in all samples.
 */

typedef enum
    {
    PSSTATE_UNINIT,     //Uninitialized
    PSSTATE_SCRIBBLE,   //Scribble
    PSSTATE_ZOMBIE,     //No scribble
    PSSTATE_HANDSOFF    //Hand-off
    } PSSTATE;


/*
 * Identifers to describe which persistence model an object
 * is using, along with a union type that holds on the the
 * appropriate pointers that a client may need.
 */
typedef enum
    {
    PERSIST_UNKNOWN=0,
    PERSIST_STORAGE,
    PERSIST_STREAM,
    PERSIST_STREAMINIT,
    PERSIST_FILE
    } PERSIST_MODEL;

typedef struct
    {
    PERSIST_MODEL   psModel;
    union
        {
        IPersistStorage    *pIPersistStorage;
        IPersistStream     *pIPersistStream;
        IPersistStreamInit *pIPersistStreamInit;
        IPersistFile       *pIPersistFile;
        } pIP;

    } PERSISTPOINTER, *PPERSISTPOINTER;


//To identify a storage in which to save, load, or create.
typedef struct
    {
    PERSIST_MODEL   psModel;
    union
        {
        IStorage    *pIStorage;
        IStream     *pIStream;
        } pIS;

    } STGPOINTER, *PSTGPOINTER;



//Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);


//DeleteInterfaceImp calls 'delete' and NULLs the pointer
#define DeleteInterfaceImp(p)\
            {\
            if (NULL!=p)\
                {\
                delete p;\
                p=NULL;\
                }\
            }


//ReleaseInterface calls 'Release' and NULLs the pointer
#define ReleaseInterface(p)\
            {\
            if (NULL!=p)\
                {\
                p->Release();\
                p=NULL;\
                }\
            }


//OLE Documents Clipboard Formats

#define CFSTR_EMBEDSOURCE       TEXT("Embed Source")
#define CFSTR_EMBEDDEDOBJECT    TEXT("Embedded Object")
#define CFSTR_LINKSOURCE        TEXT("Link Source")
#define CFSTR_CUSTOMLINKSOURCE  TEXT("Custom Link Source")
#define CFSTR_OBJECTDESCRIPTOR  TEXT("Object Descriptor")
#define CFSTR_LINKSRCDESCRIPTOR TEXT("Link Source Descriptor")


#endif //_INOLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\intrvbar.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    intrvbar.h

Abstract:

    Definition of the interval bar class used by the CTimeRange class.

--*/

#ifndef _INTRVBAR_H_
#define _INTRVBAR_H_

class CIntervalBar {

    friend LRESULT APIENTRY IntervalBarWndProc (
        HWND hWnd,
        UINT uiMsg,
        WPARAM wParam,
        LPARAM lParam
        );

    private:
        enum {
        ModeNone,
        ModeLeft,
        ModeRight,
        ModeCenter
        };

       HWND           m_hWnd ;
       INT            m_iBeginValue ;        // user-supplied lowest range
       INT            m_iEndValue ;          // user-supplied highest range
       INT            m_iStartValue ;        // current start of selected interval
       INT            m_iStopValue ;         // current end of selected interval

       RECT           m_rectBorder ;
       RECT           m_rectLeftBk ;
       RECT           m_rectLeftGrab ;
       RECT           m_rectCenterGrab ;
       RECT           m_rectRightGrab ;
       RECT           m_rectRightBk ;

       HBRUSH         m_hBrushBk ;

       POINTS         m_ptsMouse ;
       INT            m_iMode ;              // who is being tracked?

       void NotifyChange ( void );
       BOOL GrabRect ( LPRECT lpRect );
       void DrawGrab (HDC hDC, LPRECT lprectGrab, BOOL bDown );
       INT  ValueToPixel ( INT iValue );
       INT  PixelToValue ( INT xPixel );
       void CalcPositions ( void );
       void Draw ( HDC hDC, LPRECT lprectUpdate );
       void MoveLeftRight ( BOOL bStart, BOOL bLeft, INT iMoveAmt );
       void StartGrab ( void );
       void EndGrab ( void );
       void Update ( void );

       BOOL OnKeyDown ( WPARAM wParam );
       void OnLButtonDown ( POINTS ptsMouse );
       void OnLButtonUp ( void );
       void OnMouseMove ( POINTS ptsMouse );

       
    public:
        CIntervalBar ( void );
        ~CIntervalBar ( void );
        BOOL Init ( HWND hWndParent );
        HWND Window ( void ) { return m_hWnd; }

        void SetRange ( INT iBegin, INT iEnd );
        void SetStart ( INT iStart );
        void SetStop  ( INT iStop );

        INT  Start ( void ) { return m_iStartValue; }
        INT  Stop  ( void ) { return m_iStopValue; }
        INT  XStart ( void ) { return m_rectLeftGrab.left; }
        INT  XStop  ( void ) { return m_rectRightGrab.right; }

};

typedef CIntervalBar *PCIntervalBar ;


//==========================================================================//
//                                  Constants                               //
//==========================================================================//

#define ILN_SELCHANGED        (WM_USER + 0x200)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\intrvbar.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    intrvbar.cpp

Abstract:

    Implementation of the interval bar control.

--*/


//==========================================================================//
//                                  Includes                                //
//==========================================================================//
#include <windows.h>
#include <assert.h>
#include <limits.h>
#include "globals.h"
#include "winhelpr.h"
#include "utils.h"
#include "intrvbar.h"


//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define dwILineClassStyle     (CS_HREDRAW | CS_VREDRAW)
#define dwILineWindowStyle    (WS_CHILD | WS_VISIBLE) 

#define TO_THE_END            0x7FFFFFFFL


//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


// Width of the start and stob grab bars
#define ILGrabWidth()      \
   (10)

#define ILGrabMinimumWidth()      \
   (6)

// A rectangle is "drawable" if it has both nonzero height and minimum width
#define PRectDrawable(lpRect)           \
   ((lpRect->right - lpRect->left) >= ILGrabMinimumWidth()) &&  \
    (lpRect->bottom - lpRect->top)

#define RectDrawable(Rect)           \
   ((Rect.right - Rect.left) >= ILGrabMinimumWidth()) &&  \
    (Rect.bottom - Rect.top)

//==========================================================================//
//                              Local Functions                             //
//==========================================================================//
void 
CIntervalBar::NotifyChange (
    void
    )
{
   HWND     hWndParent ;

   hWndParent = WindowParent (m_hWnd) ;

   if (hWndParent)
      SendMessage (hWndParent, WM_COMMAND, 
                   (WPARAM) WindowID (m_hWnd),
                   (LPARAM) m_hWnd) ;
}


BOOL
CIntervalBar::GrabRect (
    OUT LPRECT lpRect
    )
{
   switch (m_iMode) {
       
      case ModeLeft:
         *lpRect = m_rectLeftGrab ;
         return (TRUE) ;
         break ;

      case ModeRight:
         *lpRect = m_rectRightGrab ;
         return (TRUE) ;
         break ;

      case ModeCenter:
         *lpRect = m_rectCenterGrab ;
         return (TRUE) ;
         break ;

      case ModeNone:
         lpRect->left = 0 ;
         lpRect->top = 0 ;
         lpRect->right = 0 ;
         lpRect->bottom = 0 ;
         return (FALSE) ;
         break ;

      default:
          return (FALSE);
    }
}




void
CIntervalBar::DrawGrab (
    HDC hDC,
    LPRECT lpRectGrab,
    BOOL bDown
    )
{
   if (!PRectDrawable(lpRectGrab))
      return ;

   Fill(hDC, GetSysColor(COLOR_3DFACE), lpRectGrab);
   DrawEdge (hDC, lpRectGrab, (bDown ? EDGE_SUNKEN:EDGE_RAISED), BF_RECT);
}


INT 
CIntervalBar::ValueToPixel (
    INT iValue
    )
{
   INT  xPixel ;

   if (m_iEndValue > m_iBeginValue)
      xPixel = MulDiv (iValue, m_rectBorder.right, (m_iEndValue - m_iBeginValue)) ;
   else
      xPixel = 0 ;

   return (PinExclusive (xPixel, 0, m_rectBorder.right)) ;
}


INT 
CIntervalBar::PixelToValue (
    INT xPixel
    )
{
   INT  iValue ;

   if (m_rectBorder.right)
      iValue = MulDiv (xPixel, (m_iEndValue - m_iBeginValue), m_rectBorder.right) ;
   else
      iValue = 0 ;

   return (PinInclusive (iValue, m_iBeginValue, m_iEndValue)) ;
}


void 
CIntervalBar::CalcPositions (
    void
    )

/*
   Effect:        Determine and set all of the physical rectangles of ILine,
                  based on the current size of the ILine window and the 
                  current logical Start, Stop, Begin, and End values.
*/
{
    INT   xStart, xStop ;
    INT   yHeight ;

    GetClientRect (m_hWnd, &m_rectBorder) ;
    yHeight = m_rectBorder.bottom ;

    xStart = ValueToPixel (m_iStartValue) ;
    xStop = ValueToPixel (m_iStopValue) ;

    m_rectLeftBk.left = 1 ;
    m_rectLeftBk.top = 1 ;
    m_rectLeftBk.right = xStart ;
    m_rectLeftBk.bottom = yHeight - 1 ;

    m_rectLeftGrab.left = xStart ;
    m_rectLeftGrab.top = 1 ;
    m_rectLeftGrab.right = xStart + ILGrabWidth () ;
    m_rectLeftGrab.bottom = yHeight - 1 ;

    m_rectRightBk.left = xStop ;
    m_rectRightBk.top = 1 ;
    m_rectRightBk.right = m_rectBorder.right - 1 ;
    m_rectRightBk.bottom = yHeight - 1 ;

    m_rectRightGrab.left = xStop - ILGrabWidth () ;
    m_rectRightGrab.top = 1 ;
    m_rectRightGrab.right = xStop ;
    m_rectRightGrab.bottom = yHeight - 1 ;

    m_rectCenterGrab.left = m_rectLeftGrab.right ;
    m_rectCenterGrab.top = 1 ;
    m_rectCenterGrab.right = m_rectRightGrab.left ;
    m_rectCenterGrab.bottom = yHeight - 1 ;

    if (m_rectLeftGrab.right > m_rectRightGrab.left) {
        m_rectLeftGrab.right = m_rectLeftGrab.left + (xStop - xStart) / 2 ;
        m_rectRightGrab.left = m_rectLeftGrab.right ;
        m_rectCenterGrab.left = 0 ;
        m_rectCenterGrab.right = 0 ;

        // Ensure that at least one grab bar is visible when End > Begin and the total is 
        // wide enough.  ILGrabMinimumWidth + 2 is the minimum.
        // If on the left edge, make the Right grab visible. 
        // If on the right edge, make the Left grab visible.  
        // If in the middle, make them both visible.
        if ( !RectDrawable(m_rectLeftGrab) 
           || !RectDrawable(m_rectRightGrab) ) {
            
            INT iWidth = ILGrabMinimumWidth();

            if ( !RectDrawable(m_rectRightBk) ) {
                // Make the Left grab visible.
                m_rectRightGrab.left = m_rectRightGrab.right;
                m_rectLeftGrab.right = m_rectRightGrab.right;
                m_rectLeftGrab.left = m_rectLeftGrab.right - iWidth;
            } else if (!RectDrawable(m_rectLeftBk) ) {
                // Make the Right grab visible.
                m_rectLeftGrab.right = m_rectLeftGrab.left;
                m_rectRightGrab.left = m_rectLeftGrab.left;
                m_rectRightGrab.right = m_rectRightGrab.left + iWidth;
            } else {
                // Make them both visible.
                m_rectLeftGrab.left -= iWidth;
                m_rectRightGrab.right += iWidth;
            }
        }
   }
}


void
CIntervalBar::Draw (
    HDC hDC,     
    LPRECT // lpRectUpdate
    )
/*
   Effect:        Draw the image of pILine on hDC.  Draw at least the 
                  portions within rectUpdate.

   Called By:     OnPaint, OnMouseMove.
*/
{
    if (IsWindowEnabled(m_hWnd)) {
       FillRect (hDC, &m_rectLeftBk, m_hBrushBk) ;
       FillRect (hDC, &m_rectRightBk, m_hBrushBk) ;
   
       //DrawEdge (hDC, &m_rectBorder, BDR_SUNKENINNER, BF_RECT) ;
       DrawEdge (hDC, &m_rectBorder, EDGE_SUNKEN, BF_RECT) ;

       DrawGrab (hDC, &m_rectLeftGrab, m_iMode == ModeLeft) ;
       DrawGrab (hDC, &m_rectRightGrab, m_iMode == ModeRight) ;
       DrawGrab (hDC, &m_rectCenterGrab, m_iMode == ModeCenter) ;
    }
    else {
        Fill(hDC, GetSysColor(COLOR_3DFACE), &m_rectBorder);
        DrawEdge (hDC, &m_rectBorder, EDGE_SUNKEN, BF_RECT) ;
    }
}


void
CIntervalBar::MoveLeftRight (
    BOOL bStart,
    BOOL bLeft,
    INT  iMoveAmt
    )
{
   INT      iStart, iStop, iMove ;

   iStart = m_iStartValue;
   iStop = m_iStopValue;
   iMove = iMoveAmt ;

   if (bLeft)
      iMove = -iMove ;

   if (bStart)
      {
      if (iMoveAmt == TO_THE_END) {
         iStart = m_iBeginValue ;
      }
      else {
         iStart += iMove ;
         if (iStart >= iStop) {
            return;
         }
      }

      SetStart (iStart) ;
   }
   else {
      if (iMoveAmt == TO_THE_END) {
         iStop = m_iEndValue ;
      }
      else {
         iStop += iMove ;
         if (iStart >= iStop) {
            return;
         }
      }

      SetStop (iStop) ;
   }

   NotifyChange () ;
}


BOOL 
CIntervalBar::OnKeyDown (
    WPARAM wParam
    )
{
   BOOL bHandle = TRUE ;
   BOOL bStart ;
   BOOL bLeftDirection ;
   BOOL bShiftKeyDown ;

   if (wParam == VK_LEFT || wParam == VK_RIGHT) {
      bShiftKeyDown = (GetKeyState (VK_SHIFT) < 0) ;

      if (!bShiftKeyDown) {
         if (wParam == VK_LEFT) {
            // Left Arrow --> move Start Edge Left
            bStart = TRUE ;
            bLeftDirection = TRUE ;
         }
         else {
            // Right Arrow --> move Stop Edge Right
            bStart = FALSE ;
            bLeftDirection = FALSE ;
         }
      }
      else {
         if (wParam == VK_LEFT) {
            // Shift Left Arrow --> move Stop Edge Left
            bStart = FALSE ;
            bLeftDirection = TRUE ;
         }
         else {
            // Shift Right Arrow --> move Start Edge Right
            bStart = TRUE ;
            bLeftDirection = FALSE ;
         }
      }

      MoveLeftRight (bStart, bLeftDirection, 1) ;
   }
   else if (wParam == VK_HOME) {
      // move iStart all the way the Left
      MoveLeftRight (TRUE, TRUE, TO_THE_END) ;
   }
   else if (wParam == VK_END) {
      // move iStop all the way the right
      MoveLeftRight (FALSE, FALSE, TO_THE_END) ;
   }
   else {
      bHandle = FALSE ;
   }

   return (bHandle) ;
}


void 
CIntervalBar::StartGrab (
    void
    )
{
   RECT           rectUpdate ;

   SetCapture (m_hWnd) ;
   GrabRect (&rectUpdate) ;

   Update();
}


void 
CIntervalBar::EndGrab (
    void
    )
/*
   Internals:     Set the mode to null after getting the grab rectangle
                  so ILGrabRect knows which grab bar to get.
*/
{
   RECT           rectUpdate ;

   ReleaseCapture () ;

   GrabRect (&rectUpdate) ;
   m_iMode = ModeNone ;

   Update();
}

   
//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


CIntervalBar::CIntervalBar (
    void
    )
{

   m_hWnd = NULL;
   m_iBeginValue = 0;
   m_iEndValue = 100;
   m_iStartValue = 0;
   m_iStopValue = 100;
   m_iMode = ModeNone;
   m_hBrushBk = NULL;

}


CIntervalBar::~CIntervalBar (
    void
    )
{
    if (m_hWnd)
        DestroyWindow(m_hWnd);

    if (m_hBrushBk)
        DeleteBrush (m_hBrushBk);
}


BOOL
CIntervalBar::Init (
    HWND   hWndParent
    )
{

#define dwIntervalBarClassStyle     (CS_HREDRAW | CS_VREDRAW)
#define dwIntervalBarStyle          (WS_CHILD | WS_VISIBLE) 
#define szIntervalBarClass          TEXT("IntervalBar")

    // Register window class once
    if (pstrRegisteredClasses[INTRVBAR_WNDCLASS] == NULL) {

       WNDCLASS  wc ;

       wc.style =           dwILineClassStyle ;
       wc.lpfnWndProc =     IntervalBarWndProc ;
       wc.cbClsExtra =      0 ;
       wc.cbWndExtra =      sizeof(PCIntervalBar) ;
       wc.hInstance =       g_hInstance ;
       wc.hIcon =           NULL ;
       wc.hCursor =         LoadCursor (NULL, IDC_ARROW) ;
       wc.hbrBackground =   NULL ;
       wc.lpszMenuName =    NULL ;
       wc.lpszClassName =   szIntervalBarClass ;
    
        if (RegisterClass (&wc)) {
            pstrRegisteredClasses[INTRVBAR_WNDCLASS] = szIntervalBarClass;
        }
        else {
            return FALSE;
        }
    }

    // Create our window
    m_hWnd = CreateWindow (szIntervalBarClass,      // class
                         NULL,                     // caption
                         dwIntervalBarStyle,       // window style
                         0, 0,                     // position
                         0, 0,                     // size
                         hWndParent,               // parent window
                         NULL,                     // menu
                         g_hInstance,              // program instance
                         (LPVOID) this );          // user-supplied data

    if (m_hWnd == NULL) {
       return FALSE;
    }

   m_hBrushBk = CreateSolidBrush (GetSysColor(COLOR_SCROLLBAR)) ;
   CalcPositions () ;

   return TRUE;
}





void
CIntervalBar::OnLButtonUp (
    void
    )
{
   if (m_iMode == ModeNone)
      return ;

   EndGrab () ;
}


void
CIntervalBar::OnMouseMove (
    POINTS ptsMouse
    )
/*
   Effect:        Handle any actions needed when the mouse moves in the
                  ILine hWnd's client area or while the mouse is captured.
                  In particular, if we are tracking one of the grab bars, 
                  determine if the mouse movement represents a logical value 
                  change and move the grab bar accordingly.

   Called By:     ILineWndProc, in response to a WM_MOUSEMOVE message.

   See Also:      OnLButtonDown, OnLButtonUp.

   Note:          This function has multiple return points.

   Note:          Since we have captured the mouse, we receive mouse msgs
                  even when the mouse is outside our client area, but still
                  in client coordinates. Thus we can have negative mouse
                  coordinates. That is why we convert the lParam of the
                  mouse msg into a POINTS structure rather than 2 WORDS.
                  
                   
   Internals:     Remember that an IntervalLine can only take on integral
                  values in the user-supplied range. Therefore we do our
                  movement calculation in user values, not pixels. We
                  determine what the logical value would be for the previous
                  (last mouse move) and current mouse position. If these
                  LOGICAL values differ, we attempt an adjustment of the
                  grab bar by that logical amount.  This way the grab 
                  values assume on integral positions and the calculations
                  are simplified. 

                  If we calculated by pixel movement, and then shifted the 
                  bar into the nearest integal position, we would encounter 
                  rounding problems. In particular, when tracking the center 
                  grab bar, if we moved both start and stop by the same 
                  amount of PIXELS, then converted to LOGICAL values, we 
                  might find our center bar shrinking and growing while
                  the bar moves.
*/
{
    INT     iMousePrevious, iMouseCurrent ;
    INT     iMouseMove ;


   // Are we tracking?
   if (m_iMode == ModeNone)
      return ;


   // Calc LOGICAL mouse movement
   assert ( USHRT_MAX >= m_rectBorder.left );
   assert ( USHRT_MAX >= m_rectBorder.right );

   ptsMouse.x = PinInclusive (ptsMouse.x, 
                              (SHORT)m_rectBorder.left, 
                              (SHORT)m_rectBorder.right) ;

   iMousePrevious = PixelToValue (m_ptsMouse.x) ;
   iMouseCurrent = PixelToValue (ptsMouse.x) ;

   iMouseMove = iMouseCurrent - iMousePrevious ;
   if (!iMouseMove)   
      return ;


   // Move grab bar positions
   switch (m_iMode) {
       
      case ModeLeft:
         m_iStartValue += iMouseMove ;
         m_iStartValue = min (m_iStartValue, m_iStopValue - 1) ;
         break ;

      case ModeCenter:
         // Before we slide the center grab bar we need to see if the 
         // desired movement amount would send either end out of bounds,
         // and reduce the movement accordingly.

         if (m_iStartValue + iMouseMove < m_iBeginValue)
            iMouseMove = m_iBeginValue - m_iStartValue ;

         if (m_iStopValue + iMouseMove > m_iEndValue)
            iMouseMove = m_iEndValue - m_iStopValue ;

         m_iStartValue += iMouseMove ;
         m_iStopValue += iMouseMove ;
         break ;

      case ModeRight:
         m_iStopValue += iMouseMove ;
         m_iStopValue = max (m_iStartValue + 1, m_iStopValue) ;
         break ;
   }


   m_iStartValue = PinInclusive (m_iStartValue, m_iBeginValue, m_iEndValue) ;
   m_iStopValue = PinInclusive (m_iStopValue, m_iBeginValue, m_iEndValue) ;

   Update();

   m_ptsMouse = ptsMouse ;
   NotifyChange () ;
 }


void
CIntervalBar::OnLButtonDown (
    POINTS ptsMouse
    )
{
   POINT ptMouse ;

   m_ptsMouse = ptsMouse ;
   ptMouse.x = ptsMouse.x ;
   ptMouse.y = ptsMouse.y ;

   if (PtInRect (&m_rectLeftGrab, ptMouse) ||
       PtInRect (&m_rectLeftBk, ptMouse)) {
      m_iMode = ModeLeft ;
   }
   else if (PtInRect (&m_rectRightGrab, ptMouse) ||
            PtInRect (&m_rectRightBk, ptMouse)) {
      m_iMode = ModeRight ;
   }
   else if (PtInRect (&m_rectCenterGrab, ptMouse)) {
      m_iMode = ModeCenter ;
   }

   if (m_iMode != ModeNone)
       StartGrab();
}

void
CIntervalBar::Update (
    void
    )
{
    HDC hDC;
    // Determine pixel pos, draw
    CalcPositions () ;

    hDC = GetDC (m_hWnd) ;
    if ( NULL != hDC ) {
        Draw (hDC, &m_rectBorder) ;
        ReleaseDC (m_hWnd, hDC) ;
    }
}

//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


LRESULT APIENTRY IntervalBarWndProc (
    HWND hWnd,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*
   Note:          This function must be declared in the application's
                  linker-definition file, perfmon.def file.
*/
{
   PCIntervalBar  pIntrvBar;
   BOOL           bCallDefWindowProc ;
   POINTS         ptsMouse ;
   LRESULT        lrsltReturnValue ;

   bCallDefWindowProc = FALSE ;
   lrsltReturnValue = 0L ;

   if (uiMsg == WM_CREATE) {
       pIntrvBar = (PCIntervalBar)((CREATESTRUCT*)lParam)->lpCreateParams;
   } else {
       pIntrvBar = (PCIntervalBar)GetWindowLongPtr (hWnd, 0);
   }

   switch (uiMsg) {

      case WM_CREATE:
         SetWindowLongPtr(hWnd, 0, (INT_PTR)pIntrvBar);
         break ;

      case WM_LBUTTONDOWN:
         // See the note in OnMouseMove for why we are using POINTS
         SetFocus (hWnd) ;
         ptsMouse = MAKEPOINTS (lParam) ;
         pIntrvBar->OnLButtonDown (ptsMouse) ;
         break ;

      case WM_LBUTTONUP:
         pIntrvBar->OnLButtonUp () ;
         break ;

      case WM_SETFOCUS:
      case WM_KILLFOCUS:

         pIntrvBar->NotifyChange () ;
         return 0 ;

      case WM_ENABLE:
          pIntrvBar->Update();
          break;

      case WM_MOUSEMOVE:
         // See the note in OnMouseMove for why we are using POINTS
         ptsMouse = MAKEPOINTS (lParam) ;
         pIntrvBar->OnMouseMove (ptsMouse) ;
         break ;

      case WM_KEYDOWN:
         if (!pIntrvBar->OnKeyDown (wParam)) {
            bCallDefWindowProc = TRUE ;
         }
         break ;
  
      case WM_GETDLGCODE:
         // We want to handle Arrow keys input.  If we don't specify this
         // the dialog will not pass arrow keys to us.
         return (DLGC_WANTARROWS) ;
         break ;

      case WM_PAINT:
         {
            PAINTSTRUCT    ps ;
            HDC hDC;
            
            hDC = BeginPaint (hWnd, &ps) ;
            pIntrvBar->Draw (hDC, &ps.rcPaint) ;
            EndPaint (hWnd, &ps) ;
         }
         break ;

      case WM_SIZE:
         pIntrvBar->CalcPositions () ;
         break;

      default:
         bCallDefWindowProc = TRUE ;
      }

   if (bCallDefWindowProc)
      lrsltReturnValue = DefWindowProc (hWnd, uiMsg, wParam, lParam) ;

   return (lrsltReturnValue) ;
}


void 
CIntervalBar::SetRange (
    INT iBegin, 
    INT iEnd
    )
{ 

   m_iBeginValue = iBegin;
   m_iEndValue = iEnd;

    Update();
}


void
CIntervalBar::SetStart (
    INT iStart
    )
{
   m_iStartValue = PinInclusive (iStart, m_iBeginValue, m_iEndValue) ;

   Update();
}


void
CIntervalBar::SetStop (
    INT iStop
    )
{
   m_iStopValue = PinInclusive (iStop, m_iBeginValue, m_iEndValue) ;

   Update();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\ioleobj.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    ioleobj.cpp

Abstract:

    Implementation of the IOleObject interface for Polyline.  Some of
    these just pass through to the default handler which does default
    implementations.

--*/

#include "polyline.h"
#include "unkhlpr.h"
#include "utils.h"
#include "unihelpr.h"

void RegisterAsRunning(IUnknown *pUnk, IMoniker *pmk, 
                    DWORD dwFlags, LPDWORD pdwReg);

/*
 * CImpIOleObject interface implementation
 */

IMPLEMENT_CONTAINED_CONSTRUCTOR(CPolyline, CImpIOleObject)
IMPLEMENT_CONTAINED_DESTRUCTOR(CImpIOleObject)

IMPLEMENT_CONTAINED_QUERYINTERFACE(CImpIOleObject)
IMPLEMENT_CONTAINED_ADDREF(CImpIOleObject)


STDMETHODIMP_(ULONG) CImpIOleObject::Release(
    void
    )
{
    --m_cRef;

    // Release cached site related interfaces
#if 0
    if (m_cRef == 0) {
        ReleaseInterface(m_pObj->m_pIOleClientSite);
        ReleaseInterface(m_pObj->m_pIOleControlSite);
        ReleaseInterface(m_pObj->m_pIDispatchAmbients);
    }
#endif

    return m_pUnkOuter->Release();
}

/*
 * CImpIOleObject::SetClientSite
 * CImpIOleObject::GetClientSite
 *
 * Purpose:
 *  Manages the IOleClientSite pointer of our container.
 */

STDMETHODIMP 
CImpIOleObject::SetClientSite(
    IN LPOLECLIENTSITE pIOleClientSite
    )
{
    HRESULT hr = S_OK;

    if (pIOleClientSite == NULL) {
        return E_POINTER;
    }

    //
    // This is the only place where we change those cached pointers
    //
    ClearInterface(m_pObj->m_pIOleClientSite);
    ClearInterface(m_pObj->m_pIOleControlSite);
    ClearInterface(m_pObj->m_pIDispatchAmbients);

    m_pObj->m_pIOleClientSite = pIOleClientSite;

    try {
        if (NULL != m_pObj->m_pIOleClientSite) {
            LPMONIKER       pmk;
            LPOLECONTAINER  pIOleCont;
    
            m_pObj->m_pIOleClientSite->AddRef();
    
            /*
             * Within IRunnableObject::Run we're supposed to register
             * ourselves as running...however, the moniker has to come
             * from the container's IOleClientSite::GetMoniker.  But
             * Run is called before SetClientSite here, so we have to
             * register now that we do have the client site as well
             * as lock the container.
             */
    
            hr = m_pObj->m_pIOleClientSite->GetMoniker(OLEGETMONIKER_ONLYIFTHERE, 
                                                       OLEWHICHMK_OBJFULL, 
                                                       &pmk);

            if (SUCCEEDED(hr)) {
                RegisterAsRunning(m_pUnkOuter, pmk, 0, &m_pObj->m_dwRegROT);
                if ( NULL != pmk ) {
                    pmk->Release();
                }
            }

            hr = m_pObj->m_pIOleClientSite->GetContainer(&pIOleCont);
    
            if (SUCCEEDED(hr)) {
                m_pObj->m_fLockContainer = TRUE;
                pIOleCont->LockContainer(TRUE);
                pIOleCont->Release();
            }

            /*
             * Go get the container's IDispatch for ambient
             * properties if it has one, and initilize ourself
             * with those properties.
             */
            hr = m_pObj->m_pIOleClientSite->QueryInterface(IID_IDispatch, 
                                            (void **)&m_pObj->m_pIDispatchAmbients);

            if (SUCCEEDED(hr)) {
                m_pObj->AmbientsInitialize((ULONG)INITAMBIENT_ALL);
            }

            /*
             * Get the control site
             */
            hr = m_pObj->m_pIOleClientSite->QueryInterface(IID_IOleControlSite, 
                                                      (void **)&m_pObj->m_pIOleControlSite);

        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP 
CImpIOleObject::GetClientSite(
    OUT LPOLECLIENTSITE *ppSite
    )
{
    HRESULT hr = S_OK;

    if (ppSite == NULL) {
        return E_POINTER;
    }

    //Be sure to AddRef the new pointer you are giving away.
    try {
        *ppSite=m_pObj->m_pIOleClientSite;
        m_pObj->m_pIOleClientSite->AddRef();
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}





/*
 * CImpIOleObject::SetHostNames
 *
 * Purpose:
 *  Provides the object with names of the container application and
 *  the object in the container to use in object user interface.
 *
 * Parameters:
 *  pszApp          LPCOLESTR of the container application.
 *  pszObj          LPCOLESTR of some name that is useful in window
 *                  titles.
 *
 * Return Value:
 *  HRESULT         NOERROR
 */

STDMETHODIMP 
CImpIOleObject::SetHostNames(
    LPCOLESTR /* pszApp */, 
    LPCOLESTR /* pszObj */
    )
{
    return S_OK;
}





/*
 * CImpIOleObject::Close
 *
 * Purpose:
 *  Forces the object to close down its user interface and unload.
 *
 * Parameters:
 *  dwSaveOption    DWORD describing the circumstances under which
 *                  the object is being saved and closed.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP 
CImpIOleObject::Close(
    IN DWORD dwSaveOption
    )
{
    BOOL fSave=FALSE;

    //If object is dirty and we're asked to save, save it and close.
    if (OLECLOSE_SAVEIFDIRTY==dwSaveOption && m_pObj->m_fDirty)
        fSave=TRUE;

    /*
     * If asked to prompt, only do so if dirty, then if we get a
     * YES, save as usual and close.  On NO, just close.  On
     * CANCEL return OLE_E_PROMPTSAVECANCELLED.
     */
    if (OLECLOSE_PROMPTSAVE==dwSaveOption && m_pObj->m_fDirty) {
        UINT uRet;

        uRet = MessageBox(NULL, ResourceString(IDS_CLOSEPROMPT),
                          ResourceString(IDS_CLOSECAPTION), MB_YESNOCANCEL);

        if (IDCANCEL==uRet)
            return (OLE_E_PROMPTSAVECANCELLED);

        if (IDYES==uRet)
            fSave=TRUE;
    }

    if (fSave) {
        m_pObj->SendAdvise(OBJECTCODE_SAVEOBJECT);
        m_pObj->SendAdvise(OBJECTCODE_SAVED);
    }

    //We get directly here on OLECLOSE_NOSAVE.
    if ( m_pObj->m_fLockContainer && ( NULL != m_pObj->m_pIOleClientSite ) ) {

        //Match LockContainer call from SetClientSite
        LPOLECONTAINER  pIOleCont;

        if (SUCCEEDED(m_pObj->m_pIOleClientSite->GetContainer(&pIOleCont))) {
            pIOleCont->LockContainer(FALSE);
            pIOleCont->Release();
        }
    }
    
    // Deactivate
    m_pObj->InPlaceDeactivate();

    // Revoke registration in ROT
    if (m_pObj->m_dwRegROT != 0) {

        IRunningObjectTable    *pROT;

        if (!FAILED(GetRunningObjectTable(0, &pROT))) {
            pROT->Revoke(m_pObj->m_dwRegROT);   
            pROT->Release();
            m_pObj->m_dwRegROT = 0;
        }
    }

    return NOERROR;
}




/*
 * CImpIOleObject::DoVerb
 *
 * Purpose:
 *  Executes an object-defined action.
 *
 * Parameters:
 *  iVerb           LONG index of the verb to execute.
 *  pMSG            LPMSG describing the event causing the
 *                  activation.
 *  pActiveSite     LPOLECLIENTSITE to the site involved.
 *  lIndex          LONG the piece on which execution is happening.
 *  hWndParent      HWND of the window in which the object can play
 *                  in-place.
 *  pRectPos        LPRECT of the object in hWndParent where the
 *                  object can play in-place if desired.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP 
CImpIOleObject::DoVerb(
    LONG iVerb, 
    LPMSG /* pMSG */, 
    LPOLECLIENTSITE pActiveSite, 
    LONG /* lIndex */, 
    HWND /* hWndParent */, 
    LPCRECT /* pRectPos */
    )
{
    HRESULT  hr;
    CAUUID   caGUID;

    switch (iVerb)
    {
        case OLEIVERB_HIDE:
            if (NULL != m_pObj->m_pIOleIPSite) {
                m_pObj->UIDeactivate();
                ShowWindow(m_pObj->m_pHW->Window(), SW_HIDE);
            }
            else {

                ShowWindow(m_pObj->m_pHW->Window(), SW_HIDE);
                m_pObj->SendAdvise(OBJECTCODE_HIDEWINDOW);
            }
            break;

        case OLEIVERB_PRIMARY:
        case OLEIVERB_SHOW:
            if (NULL != m_pObj->m_pIOleIPSite) {
                ShowWindow(m_pObj->m_pHW->Window(), SW_SHOW);
                return NOERROR; //Already active
            }

            if (m_pObj->m_fAllowInPlace) {
                return m_pObj->InPlaceActivate(pActiveSite ,TRUE);
            }

            return (OLEOBJ_S_INVALIDVERB); 
            break;

        case OLEIVERB_INPLACEACTIVATE:
            if (NULL != m_pObj->m_pHW) {
                HWND hWndHW=m_pObj->m_pHW->Window();

                ShowWindow(hWndHW, SW_SHOW);
                SetFocus(hWndHW);

                return NOERROR;
            }

            /*
             * Only inside-out supporting containers will use
             * this verb.
             */
            m_pObj->m_fContainerKnowsInsideOut=TRUE;
            m_pObj->InPlaceActivate(pActiveSite, FALSE);
            break;

        case OLEIVERB_UIACTIVATE:
            m_pObj->InPlaceActivate(pActiveSite, TRUE);
            break;

        case OLEIVERB_PROPERTIES:
        case POLYLINEVERB_PROPERTIES:

            /*
             * Let the container try first if there are
             * extended controls.  Otherwise we'll display
             * our own pages.
             */
            if (NULL!=m_pObj->m_pIOleControlSite) {
                hr=m_pObj->m_pIOleControlSite->ShowPropertyFrame();

                if (NOERROR==hr)
                    break;      //All done
            }


            //Put up our property pages.
            hr=m_pObj->m_pImpISpecifyPP->GetPages(&caGUID);

            if (FAILED(hr))
                return FALSE;

            hr = OleCreatePropertyFrame(m_pObj->m_pCtrl->Window(), 
                                       10, 
                                       10, 
                                       ResourceString(IDS_PROPFRM_TITLE), 
                                       1, 
                                       (IUnknown **)&m_pObj, 
                                       caGUID.cElems, 
                                       caGUID.pElems, 
                                       LOCALE_USER_DEFAULT, 
                                       0L, 
                                       NULL);

            //Free the GUIDs
            CoTaskMemFree((void *)caGUID.pElems);
            break;

        default:
            return (OLEOBJ_S_INVALIDVERB);
    }

    return NOERROR;
}






/*
 * CImpIOleObject::GetUserClassID
 *
 * Purpose:
 *  Used for linked objects, this returns the class ID of what end
 *  users think they are editing.
 *
 * Parameters:
 *  pClsID          LPCLSID in which to store the CLSID.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP 
CImpIOleObject::GetUserClassID(
    OUT LPCLSID pClsID
    )
{
    HRESULT hr = S_OK;

    if (pClsID == NULL) {
        return E_POINTER;
    }

    /*
     * If you are not registered to handle data other than yourself,
     * then you can just return your class ID here.  If you are
     * registered as usable from Treat-As dialogs, then you need to
     * return the CLSID of what you are really editing.
     */

    try {
        *pClsID=CLSID_SystemMonitor;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}





/*
 * CImpIOleObject::SetExtent
 *
 * Purpose:
 *  Sets the size of the object in HIMETRIC units.
 *
 * Parameters:
 *  dwAspect        DWORD of the aspect affected.
 *  pSize           LPSIZEL containing the new size.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP 
CImpIOleObject::SetExtent( 
    IN DWORD dwAspect,
    IN LPSIZEL pSize 
    )
{
    HRESULT hr = S_OK;
    RECT rectExt;

    if (pSize == NULL) {
        return E_POINTER;
    }

    try {
        SetRect(&rectExt, 0, 0, pSize->cx, pSize->cy);

        if (dwAspect == DVASPECT_CONTENT) {
            //
            // convert from HIMETRIC to device coord
            //
            m_pObj->RectConvertMappings(&rectExt,TRUE);

            // If changed and non-zero, store as new extent

            if ( !EqualRect ( &m_pObj->m_RectExt, &rectExt) && 
                 !IsRectEmpty( &rectExt ) ) {

                m_pObj->m_RectExt = rectExt;

#ifdef USE_SAMPLE_IPOLYLIN10
                m_pObj->m_pImpIPolyline->SizeSet(&rectExt, TRUE);
#else
                hWnd = m_pObj->m_pCtrl->Window();

                if (hWnd) {
                    SetWindowPos(hWnd, 
                                 NULL, 
                                 0, 
                                 0, 
                                 rectExt.right - rectExt.left,
                                 rectExt.bottom - rectExt.top,
                                 SWP_NOMOVE | SWP_NOZORDER);
                    InvalidateRect(hWnd, NULL, TRUE);
                }

                m_pObj->m_fDirty=TRUE;
#endif

                // Notify container of change to force metafile update
                // HONG:: Why do we turn off this statement???
                //
                //m_pObj->SendAdvise(OBJECTCODE_DATACHANGED);
            }
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

/*
 * CImpIOleObject::GetExtent
 *
 * Purpose:
 *  Retrieves the size of the object in HIMETRIC units.
 *
 * Parameters:
 *  dwAspect        DWORD of the aspect requested
 *  pSize           LPSIZEL into which to store the size.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP 
CImpIOleObject::GetExtent(
    IN DWORD dwAspect, 
    OUT LPSIZEL pSize
    )
{
    HRESULT hr = S_OK;

    if (pSize == NULL) {
        return E_POINTER;
    }

    try {
        //Delegate directly to IViewObject2::GetExtent
        hr = m_pObj->m_pImpIViewObject->GetExtent( dwAspect, -1, NULL, pSize);
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}



/*
 * CImpIOleObject::Advise
 * CImpIOleObject::Unadvise
 * CImpIOleObject::EnumAdvise
 *
 * Purpose:
 *  Advisory connection functions.
 */

STDMETHODIMP 
CImpIOleObject::Advise(
    LPADVISESINK pIAdviseSink, 
    LPDWORD pdwConn
    )
{
    HRESULT hr = S_OK;

    if (NULL == m_pObj->m_pIOleAdviseHolder)
    {
        hr = CreateOleAdviseHolder(&m_pObj->m_pIOleAdviseHolder);

        if (FAILED(hr))
            return hr;
    }

    try {
        hr = m_pObj->m_pIOleAdviseHolder->Advise(pIAdviseSink, pdwConn);
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP 
CImpIOleObject::Unadvise(DWORD dwConn)
{
    if (NULL != m_pObj->m_pIOleAdviseHolder)
        return m_pObj->m_pIOleAdviseHolder->Unadvise(dwConn);

    return (E_FAIL);
}


STDMETHODIMP 
CImpIOleObject::EnumAdvise(
    LPENUMSTATDATA *ppEnum
    )
{
    HRESULT hr = S_OK;

    if (ppEnum == NULL) {
        return E_POINTER;
    }

    try {
        * ppEnum = NULL;

        if (NULL != m_pObj->m_pIOleAdviseHolder) {
            hr = m_pObj->m_pIOleAdviseHolder->EnumAdvise(ppEnum);
        }
        else {
            hr = E_FAIL;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}



/*
 * CImpIOleObject::SetMoniker
 *
 * Purpose:
 *  Informs the object of its moniker or its container's moniker
 *  depending on dwWhich.
 *
 * Parameters:
 *  dwWhich         DWORD describing whether the moniker is the
 *                  object's or the container's.
 *  pmk             LPMONIKER with the name.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP 
CImpIOleObject::SetMoniker(
    DWORD /* dwWhich */, 
    LPMONIKER /* pmk */
    )
{
    LPMONIKER  pmkFull;
    HRESULT    hr = E_FAIL;
    HRESULT    hrTmp;
    LPBC       pbc;

    if (NULL != m_pObj->m_pIOleClientSite) {
        hr = m_pObj->m_pIOleClientSite->GetMoniker (
                                                OLEGETMONIKER_ONLYIFTHERE, 
                                                OLEWHICHMK_OBJFULL, 
                                                &pmkFull);

        if (SUCCEEDED(hr)) {
            hrTmp = CreateBindCtx(0, &pbc);

            if (SUCCEEDED(hrTmp)) {
                hrTmp = pmkFull->IsRunning(pbc, NULL, NULL);
                pbc->Release();

                if (SUCCEEDED(hrTmp)) {
                    pmkFull->Release();
                    return NOERROR;
                }
            }

            //This will revoke the old one if m_dwRegROT is nonzero.
            RegisterAsRunning(m_pUnkOuter, pmkFull, 0, &m_pObj->m_dwRegROT);

            //Inform clients of the new moniker
            if (NULL != m_pObj->m_pIOleAdviseHolder) {
                m_pObj->m_pIOleAdviseHolder->SendOnRename(pmkFull);
            }

            pmkFull->Release();
        }
    }   
    return hr;
}



/*
 * CImpIOleObject::GetMoniker
 *
 * Purpose:
 *  Asks the object for a moniker that can later be used to
 *  reconnect to it.
 *
 * Parameters:
 *  dwAssign        DWORD determining how to assign the moniker to
 *                  to the object.
 *  dwWhich         DWORD describing which moniker the caller wants.
 *  ppmk            LPMONIKER * into which to store the moniker.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP 
CImpIOleObject::GetMoniker(
    IN DWORD /* dwAssign */, 
    IN DWORD /* dwWhich */, 
    OUT LPMONIKER *ppmk
    )
{
    HRESULT  hr = E_FAIL;

    if (ppmk == NULL) {
        return E_POINTER;
    }

    try {
        *ppmk = NULL;

        /*
         * Since we only support embedded objects, our moniker
         * is always the full moniker from the contianer.
         */

        if (NULL != m_pObj->m_pIOleClientSite)
        {
            hr = m_pObj->m_pIOleClientSite->GetMoniker(
                                                      OLEGETMONIKER_ONLYIFTHERE, 
                                                      OLEWHICHMK_OBJFULL, 
                                                      ppmk);
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}



STDMETHODIMP 
CImpIOleObject::InitFromData(
    LPDATAOBJECT /* pIDataObject */, 
    BOOL /* fCreation */, 
    DWORD /* dw */
    )
{
    return (E_NOTIMPL);
}

STDMETHODIMP 
CImpIOleObject::GetClipboardData(
    DWORD /* dwReserved */, 
    LPDATAOBJECT * /* ppIDataObj */
    )
{
    return (E_NOTIMPL);
}

STDMETHODIMP CImpIOleObject::Update(void)
{
    return NOERROR;
}

STDMETHODIMP CImpIOleObject::IsUpToDate(void)
{
    return NOERROR;
}

STDMETHODIMP CImpIOleObject::SetColorScheme(LPLOGPALETTE /* pLP */)
{
    return (E_NOTIMPL);
}



//Methods implemented using registry helper functions in OLE.

STDMETHODIMP CImpIOleObject::EnumVerbs(LPENUMOLEVERB *ppEnum)
{
    HRESULT hr = S_OK;

    if (ppEnum == NULL) {
        return E_POINTER;
    }

    try {
        hr = OleRegEnumVerbs(m_pObj->m_clsID, ppEnum);
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP CImpIOleObject::GetUserType(
    DWORD dwForm, 
    LPOLESTR *ppszType
    )
{
    HRESULT hr = S_OK;

    if (ppszType == NULL) {
        return E_POINTER;
    }

    try {
        hr = OleRegGetUserType(m_pObj->m_clsID, dwForm, ppszType);
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP CImpIOleObject::GetMiscStatus(
    DWORD dwAspect, 
    LPDWORD pdwStatus
    )
{
    HRESULT hr = S_OK;

    if (pdwStatus == NULL) {
        return E_POINTER;
    }

    try {
        hr = OleRegGetMiscStatus(m_pObj->m_clsID, dwAspect, pdwStatus);
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


void RegisterAsRunning(
    IUnknown *pUnk, 
    IMoniker *pmk, 
    DWORD dwFlags, 
    LPDWORD pdwReg
    )
{
    IRunningObjectTable  *pROT;
    HRESULT hr = S_OK;
    DWORD dwReg;


    if (FAILED(GetRunningObjectTable(0, &pROT))) {
        return;
    }

    dwReg = *pdwReg;

    hr = pROT->Register(dwFlags, pUnk, pmk, pdwReg);

    if (MK_S_MONIKERALREADYREGISTERED == GetScode(hr))
    {
        if (0 != dwReg)
            pROT->Revoke(dwReg);
    }

    pROT->Release();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\iperpbag.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    iperpbag.cpp

Abstract:

    Implementation of the IPersistPropertyBag interface exposed on the
    Polyline object.

--*/

#include "polyline.h"
#include "unkhlpr.h"

/*
 * CImpIPersistPropertyBag interface implementation
 */

IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIPersistPropertyBag)

/*
 * CImpIPersistPropertyBag::GetClassID
 *
 * Purpose:
 *  Returns the CLSID of the object represented by this interface.
 *
 * Parameters:
 *  pClsID          LPCLSID in which to store our CLSID.
 */

STDMETHODIMP 
CImpIPersistPropertyBag::GetClassID(
    OUT LPCLSID pClsID
    )
{
    HRESULT hr = S_OK;

    if (pClsID == NULL) {
        return E_POINTER;
    }

    try {
        *pClsID = m_pObj->m_clsID;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

/*
 * CImpIPersistPropertyBag::InitNew
 *
 * Purpose:
 *  Informs the object that it is being created new instead of
 *  loaded from a persistent state.  This will be called in lieu
 *  of IPersistStreamInit::Load.
 *
 * Parameters:
 *  None
 */

STDMETHODIMP 
CImpIPersistPropertyBag::InitNew(void)
{
    //Nothing for us to do
    return NOERROR;
}

/*
 * CImpIPersistPropertyBag::Load
 *
 * Purpose:
 *  Instructs the object to load itself from a previously saved
 *  IPropertyBag that was handled by Save in another object lifetime.
 *  This function should not hold on to pIPropertyBag.
 *
 *  This function is called in lieu of IPersistStreamInit::InitNew
 *  when the object already has a persistent state.
 *
 * Parameters:
 *  pIPropBag   IPropertyBag* from which to load our data.
 *  pIError     IErrorLog* for storing errors.  NULL if caller not interested in errors.
 */

STDMETHODIMP CImpIPersistPropertyBag::Load (
    IPropertyBag* pIPropBag,
    IErrorLog*    pIError 
    )
{
    HRESULT  hr = S_OK;

    if (NULL == pIPropBag) {
        return (E_POINTER);
    }

    try {
        //Read all the data into the control structure.
        hr = m_pObj->m_pCtrl->LoadFromPropertyBag ( pIPropBag, pIError );
    } catch (...) {
        hr = E_POINTER;
    }
    
    return hr;
}

/*
 * CImpIPersistPropertyBag::Save
 *
 * Purpose:
 *  Saves the data for this object to an IPropertyBag.  
 *
 * Parameters:
 *  pIPropBag       IPropertyBag* in which to save our data.
 *  fClearDirty     BOOL indicating if this call should clear
 *                  the object's dirty flag (TRUE) or leave it
 *                  unchanged (FALSE).
 *  fSaveAllProps   BOOL indicating if this call should save all properties.
 */

STDMETHODIMP 
CImpIPersistPropertyBag::Save (
    IN IPropertyBag*  pIPropBag,
    IN BOOL fClearDirty,
    IN BOOL fSaveAllProps 
    )
{
    HRESULT  hr = S_OK;

    if (NULL == pIPropBag) {
        return (E_POINTER);
    }

    try {
        hr = m_pObj->m_pCtrl->SaveToPropertyBag ( pIPropBag, fSaveAllProps );
    } catch (...) {
        hr = E_POINTER;
    }

    if (SUCCEEDED(hr)) {
        if (fClearDirty) {
            m_pObj->m_fDirty=FALSE;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\iperstor.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    iperstor.cpp

Abstract:

    Implementation of the IPersistStorage interface exposed on the
    Polyline object.

--*/

#include "polyline.h"
#include "unkhlpr.h"
#include "unihelpr.h"
#include "utils.h"

/*
 * CImpIPersistStorage interface implementation
 */

CImpIPersistStorage::CImpIPersistStorage(
    PCPolyline pObj, 
    LPUNKNOWN pUnkOuter
    )
{
    m_cRef=0;
    m_pObj=pObj;
    m_pUnkOuter=pUnkOuter;
    m_psState=PSSTATE_UNINIT;
}

CImpIPersistStorage::~CImpIPersistStorage(void)
{
}

IMPLEMENT_CONTAINED_IUNKNOWN(CImpIPersistStorage)

/*
 * CImpIPersistStorage::GetClassID
 *
 * Purpose:
 *  Returns the CLSID of the object represented by this interface.
 *
 * Parameters:
 *  pClsID          LPCLSID in which to store our CLSID.
 *
 * Return Value:
 *  HRESULT         NOERROR on success, error code otherwise.
 */

STDMETHODIMP CImpIPersistStorage::GetClassID(LPCLSID pClsID)
{
    HRESULT hr = S_OK;

    if (pClsID == NULL) {
        return E_POINTER;
    }

    try {
        *pClsID=m_pObj->m_clsID;
    } catch (...) {
        hr = E_POINTER;
    }
 
    return hr;
}





/*
 * CImpIPersistStorage::IsDirty
 *
 * Purpose:
 *  Tells the caller if we have made changes to this object since
 *  it was loaded or initialized new.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         Contains S_OK if we ARE dirty, S_FALSE if
 *                  NOT dirty.
 *
 */

STDMETHODIMP CImpIPersistStorage::IsDirty(void)
{
    if (PSSTATE_UNINIT==m_psState)
        return (E_UNEXPECTED);

    return (m_pObj->m_fDirty ? S_OK : S_FALSE);
}



/*
 * CImpIPersistStorage::InitNew
 *
 * Purpose:
 *  Provides the object with the IStorage to hold on to while the
 *  object is running.  Here we initialize the structure of the
 *  storage and AddRef it for incremental access. This function will
 *  only be called once in the object's lifetime in lieu of Load.
 *
 * Parameters:
 *  pIStorage       LPSTORAGE for the object.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIPersistStorage::InitNew(
    LPSTORAGE pIStorage
    )
{
    HRESULT  hr = S_OK;

    if (PSSTATE_UNINIT != m_psState) {
        return E_UNEXPECTED;
    }

    if (NULL == pIStorage) {
        return E_POINTER;
    }

    /*
     * The rules of IPersistStorage mean we hold onto the IStorage
     * and pre-create anything we'd need in Save(...,TRUE) for
     * low-memory situations.  For us this means creating our
     * "CONTENTS" stream and holding onto that IStream as
     * well as the IStorage here (requiring an AddRef call).
     */

    try {
        hr = pIStorage->CreateStream(SZSTREAM, 
                          STGM_DIRECT | STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                          0, 
                          0, 
                          &m_pObj->m_pIStream);

        if (SUCCEEDED(hr)) {

            //We expect that the client has called WriteClassStg    
            hr = WriteFmtUserTypeStg(pIStorage, m_pObj->m_cf, ResourceString(IDS_USERTYPE));

            if (SUCCEEDED(hr)) {
                m_pObj->m_pIStorage=pIStorage;
                pIStorage->AddRef();
                m_psState = PSSTATE_SCRIBBLE;

                //Initialize the cache as needed.
                m_pObj->m_pDefIPersistStorage->InitNew(pIStorage);
            }
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

/*
 * CImpIPersistStorage::Load
 *
 * Purpose:
 *  Instructs the object to load itself from a previously saved
 *  IStorage that was handled by Save in another object lifetime.
 *  This function will only be called once in the object's lifetime
 *  in lieu of InitNew. The object should hold on to pIStorage here
 *  for incremental access and low-memory saves in Save.
 *
 * Parameters:
 *  pIStorage       LPSTORAGE from which to load.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIPersistStorage::Load(LPSTORAGE pIStorage)
{
    LPSTREAM  pIStream;
    HRESULT   hr = S_OK;

    if (PSSTATE_UNINIT != m_psState) {
        return (E_UNEXPECTED);
    }

    if (NULL == pIStorage) {
        return (E_POINTER);
    }

    //We don't check CLSID to remain compatible with other chapters.

    try {
        //
        // use do{} while(0) to act like switch statement.
        //
        do {
            hr=pIStorage->OpenStream(SZSTREAM, 
                                     0, 
                                     STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                                     0, 
                                     &pIStream);

            if (FAILED(hr)) {
                hr = STG_E_READFAULT;
                break;
            }

            // Load graph data from stream
            hr = m_pObj->m_pCtrl->LoadFromStream(pIStream);
    
            if (FAILED(hr)) {
                pIStream->Release();
                break;
            }

            /*
             * We don't call pIStream->Release here because we may need
             * it for a low-memory save in Save.  We also need to
             * hold onto a copy of pIStorage, meaning AddRef.
             */
            m_pObj->m_pIStream = pIStream;
    
            m_pObj->m_pIStorage = pIStorage;
            pIStorage->AddRef();
    
            m_psState=PSSTATE_SCRIBBLE;

            //We also need to tell the cache to load cached graphics
            m_pObj->m_pDefIPersistStorage->Load(pIStorage);
        } while (0);

    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}



/*
 * CImpIPersistStorage::Save
 *
 * Purpose:
 *  Saves the data for this object to an IStorage which may
 *  or may not be the same as the one previously passed to
 *  Load, indicated with fSameAsLoad.  After this call we may
 *  not write into the storage again until SaveCompleted is
 *  called, although we may still read.
 *
 * Parameters:
 *  pIStorage       LPSTORAGE in which to save our data.
 *  fSameAsLoad     BOOL indicating if this is the same pIStorage
 *                  that was passed to Load.  If TRUE, then the
 *                  object should write whatever it has *without
 *                  *using any extra memory* as this may be a low
 *                  memory save attempt.  That means that you must
 *                  not try to open or create streams.  If FALSE
 *                  you need to regenerate your whole storage
 *                  structure, being sure to also release any
 *                  pointers held from InitNew and Load.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIPersistStorage::Save(
    IN LPSTORAGE pIStorage, 
    IN BOOL fSameAsLoad
    )
{
    LPSTREAM pIStream;
    HRESULT  hr;

    // Permit call in UNINIT state, if not SameAsLoad
    if (PSSTATE_UNINIT == m_psState && fSameAsLoad) {
        return (E_POINTER);
    }

    //Must have an IStorage if we're not in SameAsLoad
    if (NULL == pIStorage && !fSameAsLoad) {
        return (E_POINTER);
    }

    /*
     * If we're saving to a new storage, create a new stream.
     * If fSameAsLoad it TRUE, then we write to the
     * stream we already allocated.  We should NOT depends on
     * pIStorage with fSameAsLoad is TRUE.
     */
    if (fSameAsLoad && NULL != m_pObj->m_pIStream ) {
        LARGE_INTEGER   li;

        /*
         * Use pre-allocated streams to avoid failures due
         * to low-memory conditions.  Be sure to reset the
         * stream pointer if you used this stream before!!
         */
        pIStream=m_pObj->m_pIStream;
        LISet32(li, 0);
        pIStream->Seek(li, STREAM_SEEK_SET, NULL);

        //This matches the Release below.
        pIStream->AddRef();
    } 
    else {
        try {
            hr = pIStorage->CreateStream(SZSTREAM, 
                                   STGM_DIRECT | STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE, 
                                   0, 
                                   0, 
                                   &pIStream);

            if (SUCCEEDED(hr)) {
                //Only do this with new storages.
                WriteFmtUserTypeStg(pIStorage, m_pObj->m_cf, ResourceString(IDS_USERTYPE));
            }
        } catch (...) {
            hr = E_POINTER;
        }

        if (!SUCCEEDED(hr)) {
            return hr;
        }
    }

    // Write graph info to stream
    hr = m_pObj->m_pCtrl->SaveToStream(pIStream);
    pIStream->Release();

    if (FAILED(hr))
        return hr;

    m_psState=PSSTATE_ZOMBIE;

    // Clear the dirty flag if storage is the same.
    if (fSameAsLoad)
        m_pObj->m_fDirty = FALSE;

    try {
        //We also need to tell the cache to save cached graphics
        m_pObj->m_pDefIPersistStorage->Save(pIStorage, fSameAsLoad);
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

/*
 * CImpIPersistStorage::SaveCompleted
 *
 * Purpose:
 *  Notifies the object that the storage in pIStorage has been
 *  completely saved now.  This is called when the user of this
 *  object wants to save us in a completely new storage, and if
 *  we normally hang on to the storage we have to reinitialize
 *  ourselves here for this new one that is now complete.
 *
 * Parameters:
 *  pIStorage       LPSTORAGE of the new storage in which we live.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIPersistStorage::SaveCompleted(LPSTORAGE pIStorage)
{
    HRESULT     hr = S_OK;
    LPSTREAM    pIStream;

    //Must be called in no-scribble or hands-off state
    if (!(PSSTATE_ZOMBIE == m_psState || PSSTATE_HANDSOFF == m_psState)) {
        return (E_UNEXPECTED);
    }

    //If we're coming from Hands-Off, we'd better get a storage
    if (NULL == pIStorage && PSSTATE_HANDSOFF == m_psState) {
        return (E_UNEXPECTED);
    }

    /*
     * If pIStorage is NULL, then we don't need to do anything
     * since we already have all the pointers we need for Save.
     * Otherwise we have to release any held pointers and
     * reinitialize them from pIStorage.
     */

    if (NULL!=pIStorage)
    {
        try {
            hr=pIStorage->OpenStream(SZSTREAM, 
                                     0, 
                                     STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                                     0, 
                                     &pIStream);

            if (SUCCEEDED(hr)) {

                if (NULL!=m_pObj->m_pIStream)
                    m_pObj->m_pIStream->Release();
    
                m_pObj->m_pIStream=pIStream;
    
                if (NULL!=m_pObj->m_pIStorage)
                    m_pObj->m_pIStorage->Release();
    
                m_pObj->m_pIStorage=pIStorage;
                m_pObj->m_pIStorage->AddRef();
            }
        } catch (...) {
            hr = E_POINTER;
        }
    }

    if (SUCCEEDED(hr)) {
        //Change state back to scribble.
        m_psState = PSSTATE_SCRIBBLE;

        hr = m_pObj->m_pDefIPersistStorage->SaveCompleted(pIStorage);
    }

    return hr;
}





/*
 * CImpIPersistStorage::HandsOffStorage
 *
 * Purpose:
 *  Instructs the object that another agent is interested in having
 *  total access to the storage we might be hanging on to from
 *  InitNew or SaveCompleted.  In this case we must release our hold
 *  and await another call to SaveCompleted before we have a hold
 *  again.  Therefore we cannot read or write after this call until
 *  SaveCompleted.
 *
 *  Situations where this might happen arise in compound document
 *  scenarios where this object might be in-place active but the
 *  application wants to rename and commit the root storage.
 *  Therefore we are asked to close our hold, let the container
 *  party on the storage, then call us again later to tell us the
 *  new storage we can hold.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIPersistStorage::HandsOffStorage(void)
{
    /*
     * Must come from scribble or no-scribble.  A repeated call
     * to HandsOffStorage is an unexpected error (bug in client).
     */
    if (PSSTATE_UNINIT==m_psState || PSSTATE_HANDSOFF==m_psState) {
        return (E_UNEXPECTED);
    }


    //Release held pointers
    if (NULL!=m_pObj->m_pIStream)
    {
        m_pObj->m_pIStream->Release();
        m_pObj->m_pIStream=NULL;
    }

    if (NULL!=m_pObj->m_pIStorage)
    {
        m_pObj->m_pIStorage->Release();
        m_pObj->m_pIStorage=NULL;
    }

    m_psState=PSSTATE_HANDSOFF;

    m_pObj->m_pDefIPersistStorage->HandsOffStorage();
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\iperstmi.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    iperstmi.cpp

Abstract:

    Implementation of the IPersistStreamInit interface exposed on the
    Polyline object.

--*/

#include "polyline.h"
#include "unkhlpr.h"

/*
 * CImpIPersistStreamInit interface implementation
 */

IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIPersistStreamInit)

/*
 * CImpIPersistStreamInit::GetClassID
 *
 * Purpose:
 *  Returns the CLSID of the object represented by this interface.
 *
 * Parameters:
 *  pClsID          LPCLSID in which to store our CLSID.
 */

STDMETHODIMP CImpIPersistStreamInit::GetClassID(
    OUT LPCLSID pClsID
    )
{
    HRESULT hr = S_OK;

    if (pClsID == NULL) {
        return E_POINTER;
    }

    try {
        *pClsID=m_pObj->m_clsID;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


/*
 * CImpIPersistStreamInit::IsDirty
 *
 * Purpose:
 *  Tells the caller if we have made changes to this object since
 *  it was loaded or initialized new.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         Contains S_OK if we ARE dirty, S_FALSE if
 *                  NOT dirty.
 */

STDMETHODIMP CImpIPersistStreamInit::IsDirty(void)
{
    return (m_pObj->m_fDirty ? S_OK : S_FALSE);
}


/*
 * CImpIPersistStreamInit::Load
 *
 * Purpose:
 *  Instructs the object to load itself from a previously saved
 *  IStreamInit that was handled by Save in another object lifetime.
 *  The seek pointer in this stream will be exactly the same as
 *  it was when Save was called, and this function must leave
 *  the seek pointer the same as it was on exit from Save, regardless
 *  of success or failure.  This function should not hold on to
 *  pIStream.
 *
 *  This function is called in lieu of IPersistStreamInit::InitNew
 *  when the object already has a persistent state.
 *
 * Parameters:
 *  pIStream        LPSTREAM from which to load.
 */

STDMETHODIMP CImpIPersistStreamInit::Load(
    IN LPSTREAM pIStream
    )
{
    HRESULT  hr = S_OK;

    if (NULL == pIStream) {
        return (E_POINTER);
    }

    try {
        //Read all the data into the control structure.
        hr = m_pObj->m_pCtrl->LoadFromStream(pIStream);
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


/*
 * CImpIPersistStreamInit::Save
 *
 * Purpose:
 *  Saves the data for this object to an IStreamInit.  Be sure not
 *  to change the position of the seek pointer on entry to this
 *  function: the caller will assume that you write from the
 *  current offset.  Leave the stream's seek pointer at the end
 *  of the data written on exit.
 *
 * Parameters:
 *  pIStream        LPSTREAM in which to save our data.
 *  fClearDirty     BOOL indicating if this call should clear
 *                  the object's dirty flag (TRUE) or leave it
 *                  unchanged (FALSE).
 */

STDMETHODIMP CImpIPersistStreamInit::Save(
    IN LPSTREAM pIStream, 
    IN BOOL fClearDirty
    )
{
    HRESULT  hr = S_OK;

    if (NULL == pIStream) {
        return (E_POINTER);
    }

    try {
        hr = m_pObj->m_pCtrl->SaveToStream(pIStream);
    } catch (...) {
        hr = E_POINTER;
    }

    if (SUCCEEDED(hr)) {
        if (fClearDirty)
            m_pObj->m_fDirty=FALSE;
    }

    return hr;
}



/*
 * CImpIPersistStreamInit::GetSizeMax
 *
 * Purpose:
 *  Returns the size of the data we would write if Save was
 *  called right now.
 *
 * Parameters:
 *  pcbSize         ULARGE_INTEGER * in which to save the size
 *                  of the stream an immediate call to Save would
 *                  write.
 */

STDMETHODIMP CImpIPersistStreamInit::GetSizeMax(
    ULARGE_INTEGER *pcbSize
    )
{
    if (NULL==pcbSize)
        return (E_POINTER);

    return (E_NOTIMPL);
}


/*
 * CImpIPersistStreamInit::InitNew
 *
 * Purpose:
 *  Informs the object that it is being created new instead of
 *  loaded from a persistent state.  This will be called in lieu
 *  of IPersistStreamInit::Load.
 *
 * Parameters:
 *  None
 */

STDMETHODIMP CImpIPersistStreamInit::InitNew(void)
{
    //Nothing for us to do
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\ipoly10.h ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    ipoly10.h

Abstract:

    Definition of an IPolyline interface for a Polyline object.

--*/

#ifndef _IPOLY10_H_
#define _IPOLY10_H_

#define SZSYSMONCLIPFORMAT  TEXT("SYSTEM_MONITOR_CONFIGURATION")

#ifndef OMIT_POLYLINESINK

#undef  INTERFACE
#define INTERFACE IPolylineAdviseSink10


/*
 * When someone initializes a polyline and is interested in receiving
 * notifications on events, then they provide one of these objects.
 */

DECLARE_INTERFACE_(IPolylineAdviseSink10, IUnknown)
    {
    //IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID, PPVOID) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    //Advise members.
    STDMETHOD_(void,OnPointChange)     (THIS) PURE;
    STDMETHOD_(void,OnSizeChange)      (THIS) PURE;
    STDMETHOD_(void,OnColorChange)     (THIS) PURE;
    STDMETHOD_(void,OnLineStyleChange) (THIS) PURE;
    //OnDataChange replaced with IAdviseSink
    };

typedef IPolylineAdviseSink10 *PPOLYLINEADVISESINK;

#endif //OMIT_POLYLINESINK


#undef  INTERFACE
#define INTERFACE IPolyline10

DECLARE_INTERFACE_(IPolyline10, IUnknown)
    {
    //IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID, PPVOID) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    //IPolyline members

    //File-related members use IPersistStorage, IPersistStreamInit
    //Data transfer members use IDataObject

    //Manipulation members:
    STDMETHOD(Init)   (THIS_ HWND, LPRECT, DWORD, UINT) PURE;
    STDMETHOD(New)    (THIS) PURE;
    STDMETHOD(Undo)   (THIS) PURE;
    STDMETHOD(Window) (THIS_ HWND *) PURE;

    STDMETHOD(RectGet) (THIS_ LPRECT) PURE;
    STDMETHOD(SizeGet) (THIS_ LPRECT) PURE;
    STDMETHOD(RectSet) (THIS_ LPRECT, BOOL) PURE;
    STDMETHOD(SizeSet) (THIS_ LPRECT, BOOL) PURE;

    };

typedef IPolyline10 *PPOLYLINE;


//Error values for data transfer functions
#define POLYLINE_E_INVALIDPOINTER   \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 1)
#define POLYLINE_E_READFAILURE      \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 2)
#define POLYLINE_E_WRITEFAILURE     \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 3)

#endif //_IPOLY10_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\ipolylin.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    ipolylin.cpp

Abstract:

    Implementation of the IPolyline10 interface exposed on the
    CPolyline object.

--*/

#include "polyline.h"
#include "unkhlpr.h"

#ifdef USE_SAMPLE_IPOLYLIN10
/*
 * CImpIPolyline interface implementation
 */

IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIPolyline)


/*
 * CImpIPolyline::Init
 *
 * Purpose:
 *  Instantiates a polyline window within a given parent.  The
 *  parent may be a main application window, could be an MDI child
 *  window. We really do not care.
 *
 * Parameters:
 *  hWndParent      HWND of the parent of this window
 *  pRect           LPRECT that this window should occupy
 *  dwStyle         DWORD containing the window's style flags
 *  uID             UINT ID to associate with this window
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, otherwise E_OUTOFMEMORY
 */

STDMETHODIMP CImpIPolyline::Init(
    HWND hWndParent, 
    LPRECT /* pRect */, 
    DWORD /* dwStyle */, 
    UINT /* uID */)
{
    HRESULT hr = S_OK;

    if (! m_pObj->m_pCtrl->Init(hWndParent) ) {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


/*
 * CImpIPolyline::New
 *
 * Purpose:
 *  Cleans out and reinitializes the data to defaults.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR always
 */

STDMETHODIMP CImpIPolyline::New(void)
{
    RECT rc;
    HWND hWnd;

    hWnd = m_pObj->m_pCtrl->Window();

    //Our rectangle is the size of our window's client area.
    if (hWnd)
    {
        GetClientRect(hWnd, &rc);
        //RECTTORECTS(rc, ppl->rc);
    }
    else {
        SetRect(&rc, 0, 0, 300, 200);       //Something reasonable
        //RECTTORECTS(rc, ppl->rc);
    }

    //This is now conditional since we may not yet have a window.
    if (hWnd) {
        InvalidateRect(hWnd, NULL, TRUE);
        UpdateWindow(hWnd);
        m_pObj->m_fDirty=TRUE;
    }

    m_pObj->SendAdvise(OBJECTCODE_DATACHANGED);
    return NOERROR;
}


/*
 * CImpIPolyline::Undo
 *
 * Purpose:
 *  Reverses previous actions in a Polyline.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         S_OK if we can Undo more, S_FALSE otherwise.
 */

STDMETHODIMP CImpIPolyline::Undo(void)
{
    return (S_FALSE);
}


/*
 * CImpIPolyline::Window
 *
 * Purpose:
 *  Returns the window handle associated with this polyline.
 *
 * Parameters:
 *  phWnd           HWND * in which to return the window handle.
 *
 * Return Value:
 *  HRESULT         NOERROR always.
 */

STDMETHODIMP CImpIPolyline::Window(HWND *phWnd)
{
    HRESULT hr = S_OK;

    try {
        *phWnd = m_pObj->m_pCtrl->Window();
    } catch (...) {
        hr = E_POINTER;
    }
   
    return hr;
}


/*
 * CImpIPolyline::RectGet
 *
 * Purpose:
 *  Returns the rectangle of the Polyline in parent coordinates.
 *
 * Parameters:
 *  pRect           LPRECT in which to return the rectangle.
 *
 * Return Value:
 *  HRESULT         NOERROR always
 */

STDMETHODIMP CImpIPolyline::RectGet(LPRECT pRect)
{
    HRESULT hr = S_OK;

    // I know this seems wrong, but it works. 
    // Always return the last extent that the container gave us.
    // Then it will set our window to the correct size.

    try {
        *pRect = m_pObj->m_RectExt; // Return extent rect
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


/*
 * CImpIPolyline::SizeGet
 *
 * Purpose:
 *  Retrieves the size of the Polyline in parent coordinates.
 *
 * Parameters:
 *  pRect           LPRECT in which to return the size.  The right
 *                  and bottom fields will contain the dimensions.
 *
 * Return Value:
 *  HRESULT         NOERROR always
 */

STDMETHODIMP CImpIPolyline::SizeGet(LPRECT pRect)
{
    RectGet(pRect);
    return NOERROR;
}


/*
 * CImpIPolyline::RectSet
 *
 * Purpose:
 *  Sets a new rectangle for the Polyline which sizes to fit.
 *
 * Parameters:
 *  pRect           LPRECT containing the new rectangle.
 *  fNotify         BOOL indicating if we're to notify anyone of
 *                  the change.
 *
 * Return Value:
 *  HRESULT         NOERROR always
 */

STDMETHODIMP CImpIPolyline::RectSet(LPRECT pRect, BOOL fNotify)
{
    UINT  cx, cy;
    RECT  rc;
    HWND  hWnd;
    HRESULT hr = S_OK;

    try {
        //Scale the points from our current size to the new size
        cx = pRect->right - pRect->left;
        cy = pRect->bottom - pRect->top;

        SetRect(&rc, 0, 0, cx, cy);

        hWnd = m_pObj->m_pCtrl->Window();
        if ( NULL != hWnd ) {

            SetWindowPos(hWnd, NULL, pRect->left, pRect->top, cx, cy, SWP_NOZORDER);
            InvalidateRect(hWnd, NULL, TRUE);
        }
    } catch (...) {
        hr = E_POINTER;
    }

    if (SUCCEEDED(hr)) {
        if (fNotify)
            m_pObj->m_fDirty = TRUE;
    }

    return hr;
}



/*
 * CImpIPolyline::SizeSet
 *
 * Purpose:
 *  Sets a new size for the Polyline which sizes to fit.
 *
 * Parameters:
 *  pRect           LPRECT containing the new rectangle.
 *  fNotify         BOOL indicating if we're to notify anyone of
 *                  the change.
 *
 * Return Value:
 *  HRESULT         NOERROR always
 */

STDMETHODIMP CImpIPolyline::SizeSet(LPRECT pRect, BOOL fNotify)
{
    UINT  cx, cy;
    HWND  hWnd;

    try {
        //Scale the points from our current size to the new size
        cx=pRect->right-pRect->left;
        cy=pRect->bottom-pRect->top;
    } catch (...) {
        return E_POINTER;
    }

    hWnd = m_pObj->m_pCtrl->Window();

    if ( NULL != hWnd ) {

        SetWindowPos(hWnd, NULL, 0, 0, (UINT)cx, (UINT)cy, SWP_NOMOVE | SWP_NOZORDER);
        InvalidateRect(hWnd, NULL, TRUE);
    }

    if (fNotify)
        m_pObj->m_fDirty=TRUE;

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\ipropbag.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    IPropBag.cpp

Abstract:

    Implementation of the private IPropertyBag interface used by
    the System Monitor control.

--*/

#include <assert.h>
#include "polyline.h"
#include "unkhlpr.h"
#include "unihelpr.h"
#include "globals.h"
#include "smonmsg.h"
#include "strnoloc.h"
#include "ipropbag.h"

#define MAX_GUID_STRING_LENGTH 39

/*
 * CImpIPropertyBag interface implementation
 */

IMPLEMENT_CONTAINED_IUNKNOWN(CImpIPropertyBag)

/*
 * CImpIPropertyBag::CImpIPropertyBag
 *
 * Purpose:
 *  Constructor.
 *
 * Return Value:
 */

CImpIPropertyBag::CImpIPropertyBag ( LPUNKNOWN pUnkOuter)
:   m_cRef ( 0 ),
    m_pUnkOuter ( pUnkOuter ),
    m_pszData ( NULL ),
    m_dwCurrentDataLength ( 0 ),
    m_plistData ( NULL )
{
    return; 
}

/*
 * CImpIPropertyBag::~CImpIPropertyBag
 *
 * Purpose:
 *  Destructor.
 *
 * Return Value:
 */

CImpIPropertyBag::~CImpIPropertyBag ( void ) 
{   
    if ( NULL != m_pszData ) {
        delete [] m_pszData;
    }

    while ( NULL != m_plistData ) {
        PPARAM_DATA pData;

        pData = DataListRemoveHead();
        VariantClear ( &pData->vValue ); 
        delete [] pData;
    }
}


/*
 * CImpIPropertyBag::Read
 *
 * Purpose:
 *
 *  This function is called to read a property from the property bag.
 *
 * Parameters:
 *  pszPropName     Pointer to name of property to be read
 *  pVar            Pointer to the VARIANT to receive the property value
 *  pIErrorLog      Pointer to the caller's error log
 */

STDMETHODIMP 
CImpIPropertyBag::Read (
    LPCOLESTR pszPropName,  //Pointer to the property to be read
    VARIANT* pVar,          //Pointer to the VARIANT to receive the 
                            //property value
    IErrorLog* pIErrorLog ) //Pointer to the caller's error log    // can be null
{
    HRESULT     hr = S_OK;
    PPARAM_DATA pData;

    if (NULL == pszPropName || NULL == pVar) {
        return (E_POINTER);
    }

    // Currently don't handle error log.
    assert ( NULL == pIErrorLog );
    pIErrorLog;                         // Eliminate compiler warning.

    try {
        //Read the specified data into the passed variant.
        pData = FindProperty ( pszPropName );
    
        if ( NULL != pData ) {
            if ( pVar->vt != VT_BSTR ) {
                hr = VariantChangeTypeEx( pVar, 
                                          &pData->vValue, 
                                          LCID_SCRIPT, 
                                          VARIANT_NOUSEROVERRIDE, 
                                          pVar->vt );
            } 
            else {
                hr = VariantChangeType ( pVar, 
                                         &pData->vValue, 
                                         NULL, 
                                         pVar->vt );    
            }
        } else {
            hr = E_INVALIDARG;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

/*
 * CImpIPropertyBag::Write
 *
 * Purpose:
 *
 *  This function is called to write a property to the property bag.
 *
 * Parameters:
 *  pszPropName     Pointer to name of property to be written
 *  pVar            Pointer to the VARIANT containing the property value
 */

STDMETHODIMP 
CImpIPropertyBag::Write (
    LPCOLESTR pszPropName,  //Pointer to the property to be written
    VARIANT* pVar )         //Pointer to the VARIANT containing the  
                            //property value and type
{
    HRESULT     hr = S_OK;
    VARIANT     vValueBstr;
    DWORD       dwNameLength;
    DWORD       dwDataLength;
    //
    // Special purpost to use static instead of dynamic
    //
    static DWORD dwDelimiterLength = 0;
    static DWORD dwParamNameLength = 0;
    static DWORD dwEolTagLength = 0;
    static DWORD dwValueTagLength = 0;
    LPWSTR      pszNextField = m_pszData;
    DWORD       dwCurrentDataUsedLength;

    if (NULL==pszPropName || NULL==pVar) {
        return (E_POINTER);
    }

    VariantInit ( &vValueBstr );

    try {
        //
        // Use do{}while(0) here to act like a switch statement
        //
        do {
            if( pVar->vt != VT_BSTR ){
                hr = VariantChangeTypeEx( &vValueBstr, 
                                          pVar, 
                                          LCID_SCRIPT, 
                                          VARIANT_NOUSEROVERRIDE, 
                                          VT_BSTR);
            } else {
                hr = VariantChangeType ( &vValueBstr, 
                                         pVar, 
                                         NULL, 
                                         VT_BSTR);
            }

            if (!SUCCEEDED(hr)) {
                break;
            }

            //
            // All length values calculated number of WCHARs.
            //
            if ( 0 == dwDelimiterLength ) {
                // Initialize static values
        
                dwParamNameLength = lstrlen ( CGlobalString::m_cszHtmlParamTag );
                dwValueTagLength = lstrlen ( CGlobalString::m_cszHtmlValueTag );
                dwEolTagLength = lstrlen ( CGlobalString::m_cszHtmlValueEolTag );

                dwDelimiterLength = dwParamNameLength + dwValueTagLength + dwEolTagLength;
            }

            dwNameLength = lstrlen ( pszPropName );
            dwDataLength = lstrlen ( vValueBstr.bstrVal );
            dwCurrentDataUsedLength = lstrlen ( m_pszData );

            // Add 1 to size calculation for NULL buffer terminator.
            if ( m_dwCurrentDataLength 
                < dwCurrentDataUsedLength + dwNameLength + dwDataLength + dwDelimiterLength + 1 ) { 

                LPWSTR pszNewBuffer;
        
                if ( 0 == m_dwCurrentDataLength ) {
                    m_dwCurrentDataLength += eDefaultBufferLength;
                } else {
                    m_dwCurrentDataLength *= 2;
                }
                pszNewBuffer = new WCHAR[m_dwCurrentDataLength];

                if ( NULL == pszNewBuffer) {
                    hr = E_OUTOFMEMORY;
                    break;
                }

                if ( NULL != m_pszData ) {
                    memcpy ( pszNewBuffer, m_pszData, dwCurrentDataUsedLength * sizeof(WCHAR) );
                    delete [] m_pszData;
                }
                m_pszData = pszNewBuffer;
            }

            // Build the new string and add it to the current data.

            pszNextField = m_pszData + dwCurrentDataUsedLength;
            memcpy ( pszNextField, CGlobalString::m_cszHtmlParamTag, dwParamNameLength * sizeof(WCHAR) );

            pszNextField += dwParamNameLength;
            memcpy ( pszNextField, pszPropName, dwNameLength * sizeof(WCHAR) );

            pszNextField += dwNameLength;
            memcpy ( pszNextField, CGlobalString::m_cszHtmlValueTag, dwValueTagLength * sizeof(WCHAR) );

            pszNextField += dwValueTagLength;
            memcpy ( pszNextField, vValueBstr.bstrVal, dwDataLength * sizeof(WCHAR) );

            pszNextField += dwDataLength;
            memcpy ( pszNextField, CGlobalString::m_cszHtmlValueEolTag, dwEolTagLength * sizeof(WCHAR) );

            pszNextField += dwEolTagLength;
            *pszNextField = L'\0';
        } while (0);

    } catch (...) {
        hr = E_POINTER;
    }

    VariantClear(&vValueBstr);

    return hr;
}

/*
 * CImpIPropertyBag::GetData
 *
 * Purpose:
 *  Return pointer to the data buffer.
 *
 * Return Value:
 *  Pointer to the data buffer.
 */

LPWSTR
CImpIPropertyBag::GetData ( void ) 
{   
    return m_pszData;
}

/*
 * CImpIPropertyBag::LoadData
 *
 * Purpose:
 *  Load data from the supplied buffer into internal data structures.
 *
 * Return Value:
 *  Status.
 */

HRESULT
CImpIPropertyBag::LoadData ( 
    LPWSTR pszData 
    )
{   
    HRESULT hr = S_OK;
    LPWSTR  pszDataAllocW = NULL;
    LPWSTR  pszCurrentPos = NULL;

    LPSTR   pszGuidA = NULL;
    LPSTR   pszCurrentPosA = NULL;
    LPSTR   pszDataA = NULL;
    OLECHAR szGuidW[MAX_GUID_STRING_LENGTH];
    LPWSTR  pszGuidW = NULL;
    INT     iStatus;
    INT     iBufLen;

    USES_CONVERSION

    if ( NULL == pszData ) {
        assert ( FALSE );
        hr = E_POINTER;
    } else {

        // Unicode search:  Begin the search after the first instance 
        // of the System Monitor class id.
        iStatus = StringFromGUID2(CLSID_SystemMonitor, szGuidW, sizeof(szGuidW)/sizeof(OLECHAR));
    
        if ( 0 < iStatus ) {
            pszGuidW = wcstok ( szGuidW, L"{} " );

            if ( NULL != pszGuidW ) {
                pszCurrentPos = wcsstr(pszData, pszGuidW );

                // Handle wide vs ansi.
                if ( NULL == pszCurrentPos ) {
                    // Check for ANSI version:             
                    pszDataA = (CHAR*) pszData;
                    try {
                        pszGuidA = W2A( pszGuidW );
                    } catch (...) {
                        pszGuidA = NULL;
                        hr = E_OUTOFMEMORY;
                    }

                    if ( NULL != pszGuidA ) {
                        pszCurrentPosA = strstr ( pszDataA, pszGuidA );

                        if ( NULL != pszCurrentPosA ) {

                            iBufLen = lstrlenA (pszDataA) + 1;

                            pszDataAllocW = new WCHAR [iBufLen * sizeof(WCHAR)];
                            if ( NULL != pszDataAllocW ) {
                                _MbToWide ( pszDataAllocW, pszDataA, iBufLen ); 
                                pszCurrentPos = wcsstr(pszDataAllocW, pszGuidW );
                            } else {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                    }
                }
            }
        } else {
            hr = E_UNEXPECTED;
        }

        if ( NULL != pszCurrentPos ) {
            WCHAR   szQuote[2];
            LPWSTR  pszEoo;

            szQuote[0] = L'\"';
            szQuote[1] = L'\0';

            
            // End of object is the first object footer tag after the first sysmon
            // class id found. If multiple objects in the data block, only parse the first sysmon.
            pszEoo = wcsstr(pszCurrentPos, CGlobalString::m_cszHtmlObjectFooter );

            if ( NULL != pszEoo ) {

                // Find first parameter tag.
                pszCurrentPos = wcsstr(pszCurrentPos, CGlobalString::m_cszHtmlParamSearchTag );

                while ( NULL != pszCurrentPos && pszCurrentPos < pszEoo ) {
    
                    LPWSTR      pszNextPos;
                    INT         lStrLength;
                    PPARAM_DATA pParamData;
                    LPWSTR      pszTemp;
                    LONG        lCopyLen;

                    // Store parameter/property name.
                    // Find one past first quote.
                    pszCurrentPos = wcsstr(pszCurrentPos, szQuote ) + 1;

                    // The param name is between first and second quote.
                    pszNextPos = wcsstr(pszCurrentPos, szQuote );

                    lStrLength = ( (INT)((UINT_PTR)pszNextPos - (UINT_PTR)pszCurrentPos) ) / sizeof ( WCHAR ) ;

                    pParamData = new PARAM_DATA;

                    if ( NULL != pParamData ) {
                        pParamData->pNextParam = NULL;
                        VariantInit ( &pParamData->vValue );
                        pParamData->vValue.vt = VT_BSTR;
                    } else {
                        hr = E_OUTOFMEMORY;
                        break;
                    }

                    
                    lCopyLen = min(lStrLength, MAX_PATH);
                    wcsncpy(pParamData->pszPropertyName, pszCurrentPos, lCopyLen);
                    pParamData->pszPropertyName[lCopyLen] = L'\0';

                    // Find value tag and store parameter/property value.
                    // Find value tag and store parameter/property value.
                    // Find value tag
                    pszCurrentPos = wcsstr ( pszCurrentPos, CGlobalString::m_cszHtmlValueSearchTag );
                    // Find one past first quote
                    pszCurrentPos = wcsstr ( pszCurrentPos, szQuote ) + 1;
                    // The value is between first and second quote.
                    pszNextPos = wcsstr ( pszCurrentPos, szQuote );
            
                    lStrLength = ( (INT)((UINT_PTR)pszNextPos - (UINT_PTR)pszCurrentPos) ) / sizeof ( WCHAR );

                    pszTemp = new WCHAR[lStrLength+1];
                    if (pszTemp != NULL) {
                        wcsncpy ( pszTemp, pszCurrentPos, lStrLength );
                        pszTemp[lStrLength] = L'\0';

                        pParamData->vValue.bstrVal = SysAllocString ( pszTemp );

                        delete [] pszTemp;
                        DataListAddHead ( pParamData );
                        // Find next parameter/property tag.
                        pszCurrentPos = wcsstr(pszCurrentPos, CGlobalString::m_cszHtmlParamSearchTag );
                    } else {
                        delete pParamData;
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                } // While parameter tags exist for a single object.
            } else {
                hr = SMON_STATUS_NO_SYSMON_OBJECT;
            }
        } else {
            hr = SMON_STATUS_NO_SYSMON_OBJECT;
        }
    }

    if ( NULL != pszDataAllocW ) {
        delete [] pszDataAllocW;
    }

    return hr;
}

void
CImpIPropertyBag::DataListAddHead ( PPARAM_DATA pData ) 
{
    pData->pNextParam = m_plistData;
    m_plistData = pData;
    return;
}

CImpIPropertyBag::PPARAM_DATA
CImpIPropertyBag::DataListRemoveHead ( ) 
{
    PPARAM_DATA pReturnData;

    pReturnData = m_plistData;
    
    if ( NULL != m_plistData )
        m_plistData = m_plistData->pNextParam;
    
    return pReturnData;
}


CImpIPropertyBag::PPARAM_DATA
CImpIPropertyBag::FindProperty ( LPCWSTR pszPropName ) 
{
    PPARAM_DATA pReturnData;

    pReturnData = m_plistData;
    
    while ( NULL != pReturnData ) {
        if ( 0 == lstrcmpi ( pszPropName, pReturnData->pszPropertyName ) )
            break;
        pReturnData = pReturnData->pNextParam;
    }

    return pReturnData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\ipropbag.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ipropbag.h

Abstract:

    <abstract>

--*/

#ifndef _IPROPBAG_H_
#define _IPROPBAG_H_

// Property Bag Class
class CImpIPropertyBag : public IPropertyBag {

    public:
                CImpIPropertyBag( LPUNKNOWN = NULL );
        virtual ~CImpIPropertyBag(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IConnectionPoint members
        STDMETHODIMP Read(LPCOLESTR, VARIANT*, IErrorLog* );
        STDMETHODIMP Write(LPCOLESTR, VARIANT* );

        //Members not exposed by IPropertyBag
        LPWSTR  GetData ( void );
        HRESULT LoadData ( LPWSTR pszData );

    private:

        typedef struct _param_data {
            _param_data*    pNextParam; 
            WCHAR           pszPropertyName[MAX_PATH];
            VARIANT         vValue;
        } PARAM_DATA, *PPARAM_DATA;

        enum eConstants {
            eDefaultBufferLength = 0x010000      // 64K
        };

        PPARAM_DATA FindProperty ( LPCWSTR pszPropName );
        void        DataListAddHead ( PPARAM_DATA );
        PPARAM_DATA DataListRemoveHead ( void );

        ULONG           m_cRef;        //Object reference count
        LPUNKNOWN       m_pUnkOuter;   //Controlling unknown
//        PCPolyline      m_pObj;        //Containing object - assume NULL for this object
        LPWSTR          m_pszData;
        DWORD           m_dwCurrentDataLength;
        PPARAM_DATA     m_plistData;
};

typedef CImpIPropertyBag *PCImpIPropertyBag;

#endif // _IPROPBAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\iprpbrws.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    iprpbrws.cpp

Abstract:

    Implementation of the IPerPropertyBrowsingg interface exposed on the
	Polyline object.

--*/

#include "polyline.h"
#include "unkhlpr.h"
#include "smonid.h"
#include "ctrprop.h"
#include "srcprop.h"
#include "genprop.h"

/*
 * CImpIPerPropertyBrowsing interface implementation
 */

IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIPerPropertyBrowsing)

/*
 * CImpIPerPropertyBrowsing::GetClassID
 *
 * Purpose:
 *  Returns the CLSID of the object represented by this interface.
 *
 * Parameters:
 *  pClsID          LPCLSID in which to store our CLSID.
 */

STDMETHODIMP 
CImpIPerPropertyBrowsing::GetClassID(LPCLSID pClsID)
{
    HRESULT hr = S_OK;

    if (pClsID == NULL) {
        return E_POINTER;
    }

    try {
        *pClsID=m_pObj->m_clsID;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

/*
 * CImpIPerPropertyBrowsing::GetDisplayString
 *
 * Purpose:
 *  Returns a text string describing the property identified with DispID.
 *
 * Parameters:
 *  dispID      Dispatch identifier for the property.
 *  pBstr       Receives a pointer to the display string describing the property
*/

STDMETHODIMP CImpIPerPropertyBrowsing::GetDisplayString (
    DISPID  /* dispID */,
    BSTR*   /* pBstr */ )
{
/*
    HRESULT     hr = S_OK;
    
    VARIANT     vValue;

    if (NULL==pIPropBag)
        return ResultFromScode(E_POINTER);

    //Read all the data into the control structure.
	hr = m_pObj->m_pCtrl->LoadFromPropertyBag ( pIPropBag, pIError );
    return hr;
*/
    return E_NOTIMPL;
}

/*
 * CImpIPerPropertyBrowsing::GetPredefinedStrings
 *
 * Purpose:
 *  Returns a counted array of strings, each corresponding to a value that the
 *  property specified by dispID can accept.
 *
 * Parameters:
 *  dispID          Dispatch identifier for the property.
 *  pcaStringsOut   Receives a pointer to an array of strings
 *  pcaCookiesOut   Receives a pointer to an array of DWORDs
 */

STDMETHODIMP CImpIPerPropertyBrowsing::GetPredefinedStrings (
    DISPID  /* dispID */,
    CALPOLESTR* /* pcaStringsOut */,
    CADWORD*    /* pcaCookiesOut */ )
{
    return E_NOTIMPL;
}

/*
 * CImpIPerPropertyBrowsing::GetPredefinedValue
 *
 * Purpose:
 *  Returns a variant containing the value of the property specified by dispID.
 *
 * Parameters:
 *  dispID      Dispatch identifier for the property.
 *  dwCookie    Token returned by GetPredefinedStrings
 *  pVarOut     Receives a pointer to a VARIANT value for the property.
 */

STDMETHODIMP CImpIPerPropertyBrowsing::GetPredefinedValue (
    DISPID  /* dispID */,
    DWORD   /* dwCookie */,
    VARIANT*    /* pVarOut */ )
{
    return E_NOTIMPL;
}

/*
 * CImpIPerPropertyBrowsing::MapPropertyToPage
 *
 * Purpose:
 *  Returns the CLSID of the property page associated with 
 *  the property specified by dispID.
 *
 * Parameters:
 *  dispID  Dispatch identifier for the property.
 *  pClsid  Receives a pointer to the CLSID of the property page.
 */

STDMETHODIMP CImpIPerPropertyBrowsing::MapPropertyToPage (
    DISPID  dispID,
    LPCLSID pClsID  
    )
{
    HRESULT hr = S_OK;

    if (pClsID == NULL) {
        return E_POINTER;
    }

    try {
        if ( DISPID_VALUE == dispID ) {
            // Data page
            *pClsID = CLSID_CounterPropPage;
        } else if ( DISPID_SYSMON_DATASOURCETYPE == dispID ) {
            // Source page
            *pClsID = CLSID_SourcePropPage;
        } else {
            // General page is default
            *pClsID = CLSID_GeneralPropPage;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\legend.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    legend.h

Abstract:

    Header file for the legend control.

--*/

#ifndef _LEGEND_H_
#define _LEGEND_H_

#include <commctrl.h>
#include "toolbar.h"    // include here to define _WIN32_IE

#define iLabelLen       30
#define iLegendNumCols  7   

#define LEGEND_DATA_VERSION     2

class CSysmonControl;

 
typedef struct LEGENDCOLSTRUCT {
    INT32   xWidth ;
    INT32   xPos ;
    INT32   iOrientation ;
} LEGENDCOL ;

typedef LEGENDCOL *PLEGENDCOL ;

typedef struct {
    INT32   xColWidth[iLegendNumCols]; 
    INT32   iSortCol;
    INT32   iSortDir;
} LEGEND_DATA;


class CLegend
{
friend LRESULT APIENTRY GraphLegendWndProc (HWND hWnd,
                                     UINT uiMsg,
                                     WPARAM wParam,
                                     LPARAM lParam);
friend LRESULT APIENTRY HdrWndProc (HWND hWnd,
                                     UINT uiMsg,
                                     WPARAM wParam,
                                     LPARAM lParam);
private:
    CSysmonControl *m_pCtrl;
    HWND            m_hWnd;
    RECT            m_Rect;
    HWND            m_hWndItems ;
    HWND            m_hWndHeader ;
    WNDPROC         m_DefaultWndProc;
    HFONT           m_hFontItems ;
    HFONT           m_hFontLabels ;
    INT             m_xMinWidth ;
    INT             m_yHeaderHeight ;
    INT             m_yItemHeight ;
    INT             m_iNumItemsVisible ;
    INT             m_xEllipses;
    INT             m_iSortCol;
    INT             m_iSortDir;
    BOOL            m_fLoaded;
    LEGENDCOL       m_aCols [iLegendNumCols] ;
    DOUBLE*         m_parrColWidthFraction ;
    class CGraphItem    *m_pCurrentItem ;

    BOOL            m_fMetafile;  

    void DrawLabels ( HDC hDC ) ;
    void DrawColorCol ( PCGraphItem pItem, INT iCol, HDC hDC, HDC hAttribDC, INT yPos) ;
    void DrawCol ( INT iCol, HDC hDC, HDC hAttribDC, INT yPos, LPCWSTR lpszValue) ;
    void DrawItem ( PCGraphItem pItem, INT yPos, HDC hDC, HDC hAttribDC) ;
    void DrawColHeader ( 
            INT iCol, 
            HDC hDC, 
            HDC hAttribDC, 
            RECT& rRect, 
            BOOL bItemState ) ;

    void DrawHeader ( HDC hDC, HDC hAttribDC, RECT& rRect ) ;

    void OnPaint        ( void );
    void OnDrawItem     ( LPDRAWITEMSTRUCT lpDI ) ;
    void OnDrawHeader   ( LPDRAWITEMSTRUCT lpDI ) ;
    void OnMeasureItem  ( LPMEASUREITEMSTRUCT lpMI ) ;
    void OnDblClick     ( void ) ;
    void OnSelectionChanged ( void ) ;
    void OnColumnWidthChanged ( HD_NOTIFY *phdn );
    void OnColumnClicked( HD_NOTIFY *phdn );

    void AdjustColumnWidths ( INT iCol = 0 );

    INT GetItemIndex    ( PCGraphItem pItem ) ;
    LPCWSTR GetSortKey  ( PCGraphItem pItem ) ;
    HRESULT GetNextValue ( WCHAR*& pszNext, DOUBLE& rdValue );

public:
    CLegend         ( void );
    ~CLegend        ( void );

    HRESULT LoadFromStream  ( LPSTREAM pIStream ); 
    HRESULT SaveToStream    ( LPSTREAM pIStream );
	HRESULT	SaveToPropertyBag ( IPropertyBag*, BOOL fClearDirty, BOOL fSaveAllProps );
	HRESULT	LoadFromPropertyBag ( IPropertyBag*, IErrorLog* );

    void Render             ( HDC hDC, HDC hAttribDC, BOOL fMetafile, BOOL fEntire, LPRECT pRect );

    void ChangeFont ( HDC hDC );
    BOOL Init       ( CSysmonControl *pCtrl, HWND hWndParent ) ;
    INT MinHeight   ( INT yMaxHeight ) ;
    INT Height      ( INT yMaxHeight ) ;
    INT MinWidth    ( void ) ;
    void SizeComponents ( LPRECT pRect);

    BOOL AddItem    ( PCGraphItem pItem ) ;
    void DeleteItem ( PCGraphItem pItem ) ;
    BOOL SelectItem ( PCGraphItem pItem );
    void Clear      ( void ) ;

    PCGraphItem CurrentItem ( void ) ;
    HWND  Window    ( void ) ;

};

typedef CLegend *PLEGEND;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\iviewobj.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    iviewobj.cpp

Abstract:

    Implementation of the IViewObject interface.

--*/

#include "polyline.h"
#include "unihelpr.h"
#include "unkhlpr.h"

/*
 * CImpIViewObject interface implementation
 */

IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIViewObject)

/*
 * CImpIViewObject::Draw
 *
 * Purpose:
 *  Draws the object on the given hDC specifically for the requested
 *  aspect, device, and within the appropriate bounds.
 *
 * Parameters:
 *  dwAspect        DWORD aspect to draw.
 *  lindex          LONG index of the piece to draw.
 *  pvAspect        LPVOID for extra information, always NULL.
 *  ptd             DVTARGETDEVICE * containing device
 *                  information.
 *  hICDev          HDC containing the IC for the device.
 *  hDC             HDC on which to draw.
 *  pRectBounds     LPCRECTL describing the rectangle in which
 *                  to draw.
 *  pRectWBounds    LPCRECTL describing the placement rectangle
 *                  if part of what you draw is another metafile.
 *  pfnContinue     Function to call periodically during
 *                  long repaints.
 *  dwContinue      DWORD extra information to pass to the
 *                  pfnContinue.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIViewObject::Draw(
    DWORD dwAspect, 
    LONG lindex, 
    LPVOID pvAspect, 
    DVTARGETDEVICE *ptd, 
    HDC hICDev, 
    HDC hDC, 
    LPCRECTL pRectBounds, 
    LPCRECTL pRectWBounds, 
    BOOL (CALLBACK *pfnContinue) (DWORD_PTR), 
    DWORD_PTR dwContinue )
{
    HRESULT hr = S_OK;
    RECT    rc;
    RECTL   rectBoundsDP;
    BOOL    bMetafile = FALSE;
    BOOL    bDeleteDC = FALSE;
    HDC     hLocalICDev = NULL;

    //
    //Delegate iconic and printed representations.
    //
    if (!((DVASPECT_CONTENT | DVASPECT_THUMBNAIL) & dwAspect)) {
        try {
            hr = m_pObj->m_pDefIViewObject->Draw(dwAspect, 
                                                 lindex, 
                                                 pvAspect, 
                                                 ptd, 
                                                 hICDev, 
                                                 hDC, 
                                                 pRectBounds, 
                                                 pRectWBounds, 
                                                 pfnContinue, 
                                                 dwContinue);
        } catch (...) {
            hr = E_POINTER;
        }
    } 
    else {
        if ( NULL == hDC ) {
            hr = E_INVALIDARG;
        } 
        else if ( NULL == pRectBounds ) {
            hr = E_POINTER;
        } 
        else {
            try {
                if (hICDev == NULL) {
                    hLocalICDev = CreateTargetDC(hDC, ptd);
                    bDeleteDC = (hLocalICDev != hDC );
                } 
                else {
                    hLocalICDev = hICDev;
                }

                if ( NULL == hLocalICDev ) {
                    hr = E_UNEXPECTED;
                } 
                else {
    
                    rectBoundsDP = *pRectBounds;
                    bMetafile = GetDeviceCaps(hDC, TECHNOLOGY) == DT_METAFILE;
        
                    if (!bMetafile) {
                        ::LPtoDP ( hLocalICDev, (LPPOINT)&rectBoundsDP, 2);
                        SaveDC ( hDC );
                    }

                    rc.top = rectBoundsDP.top;
                    rc.left = rectBoundsDP.left;
                    rc.bottom = rectBoundsDP.bottom;
                    rc.right = rectBoundsDP.right;
        
                    m_pObj->Draw(hDC, hLocalICDev, FALSE, TRUE, &rc);
        
                    hr = S_OK;
                }
            } catch (...) {
                hr = E_POINTER;
            }
        }
    }

    if (bDeleteDC)
        ::DeleteDC(hLocalICDev);
    if (!bMetafile)
        RestoreDC(hDC, -1);
    
    return hr;
}




/*
 * CImpIViewObject::GetColorSet
 *
 * Purpose:
 *  Retrieves the color palette used by the object.
 *
 * Parameters:
 *  dwAspect        DWORD aspect of interest.
 *  lindex          LONG piece of interest.
 *  pvAspect        LPVOID with extra information, always NULL.
 *  ptd             DVTARGETDEVICE * containing device info.
 *  hICDev          HDC containing the IC for the device.
 *  ppColorSet      LPLOGPALETTE * into which to return the
 *                  pointer to the palette in this color set.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIViewObject::GetColorSet(
    DWORD, // dwDrawAspect
    LONG, // lindex 
    LPVOID, // pvAspect, 
    DVTARGETDEVICE *, // ptd
    HDC,  // hICDev, 
    LPLOGPALETTE * /* ppColorSet */
    ) 
{
    return E_NOTIMPL;
}


/*
 * CImpIViewObject::Freeze
 *
 * Purpose:
 *  Freezes the view of a particular aspect such that data
 *  changes do not affect the view.
 *
 * Parameters:
 *  dwAspect        DWORD aspect to freeze.
 *  lindex          LONG piece index under consideration.
 *  pvAspect        LPVOID for further information, always NULL.
 *  pdwFreeze       LPDWORD in which to return the key.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIViewObject::Freeze(
    DWORD dwAspect, 
    LONG lindex, 
    LPVOID pvAspect, 
    LPDWORD pdwFreeze
    )
{
    HRESULT hr = S_OK;

    //Delegate anything for ICON or DOCPRINT aspects
    if (!((DVASPECT_CONTENT | DVASPECT_THUMBNAIL) & dwAspect))
    {
        try {
            hr = m_pObj->m_pDefIViewObject->Freeze(dwAspect, lindex, pvAspect, pdwFreeze);
        } catch (...) {
            hr = E_POINTER;
        }

        return hr;
    }

    if (dwAspect & m_pObj->m_dwFrozenAspects)
    {
        hr = VIEW_S_ALREADY_FROZEN;
        try {
            *pdwFreeze = dwAspect + FREEZE_KEY_OFFSET;
        } catch (...) {
            hr = E_POINTER;
        }

        return hr;
    }

    m_pObj->m_dwFrozenAspects |= dwAspect;

    hr = S_OK;

    if (NULL != pdwFreeze) {
        try {
            *pdwFreeze=dwAspect + FREEZE_KEY_OFFSET;
        } catch (...) {
            hr = E_POINTER;
        }
    }

    return hr;
}



/*
 * CImpIViewObject::Unfreeze
 *
 * Purpose:
 *  Thaws an aspect frozen in ::Freeze.  We expect that a container
 *  will redraw us after freezing if necessary, so we don't send
 *  any sort of notification here.
 *
 * Parameters:
 *  dwFreeze        DWORD key returned from ::Freeze.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIViewObject::Unfreeze(DWORD dwFreeze)
{
    DWORD  dwAspect = dwFreeze - FREEZE_KEY_OFFSET;

    //Delegate anything for ICON or DOCPRINT aspects
    if (!((DVASPECT_CONTENT | DVASPECT_THUMBNAIL) & dwAspect))
        m_pObj->m_pDefIViewObject->Unfreeze(dwFreeze);

    //The aspect to unfreeze is in the key.
    m_pObj->m_dwFrozenAspects &= ~(dwAspect);

    /*
     * Since we always kept our current data up to date, we don't
     * have to do anything thing here like requesting data again.
     * Because we removed dwAspect from m_dwFrozenAspects, Draw
     * will again use the current data.
     */

    return NOERROR;
}


    
/*
 * CImpIViewObject::SetAdvise
 *
 * Purpose:
 *  Provides an advise sink to the view object enabling
 *  notifications for a specific aspect.
 *
 * Parameters:
 *  dwAspects       DWORD describing the aspects of interest.
 *  dwAdvf          DWORD containing advise flags.
 *  pIAdviseSink    LPADVISESINK to notify.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIViewObject::SetAdvise(
    DWORD dwAspects, 
    DWORD dwAdvf, 
    LPADVISESINK pIAdviseSink
    )
{
    HRESULT hr = S_OK;

    try {
        //Pass anything with DVASPECT_ICON or _DOCPRINT to the handler.
        if (!((DVASPECT_CONTENT | DVASPECT_THUMBNAIL) & dwAspects))
        {
            hr = m_pObj->m_pDefIViewObject->SetAdvise(dwAspects, dwAdvf, pIAdviseSink);
        }
    } catch (...) {
        return E_POINTER;
    }

    //We continue because dwAspects may have more than one in it.
    if (NULL != m_pObj->m_pIAdviseSink) {
        m_pObj->m_pIAdviseSink->Release();
        m_pObj->m_pIAdviseSink = NULL;
    }

    hr = S_OK;
    try {

        if (NULL != pIAdviseSink) {
            pIAdviseSink->AddRef();
        }
    } catch (...) {
        hr = E_POINTER;
    }

    if (SUCCEEDED(hr)) {
        m_pObj->m_pIAdviseSink = pIAdviseSink;
        m_pObj->m_dwAdviseAspects = dwAspects;
        m_pObj->m_dwAdviseFlags = dwAdvf;
    }

    return hr;
}




/*
 * CImpIViewObject::GetAdvise
 *
 * Purpose:
 *  Returns the last known IAdviseSink seen by ::SetAdvise.
 *
 * Parameters:
 *  pdwAspects      LPDWORD in which to store the last
 *                  requested aspects.
 *  pdwAdvf         LPDWORD in which to store the last
 *                  requested flags.
 *  ppIAdvSink      LPADVISESINK * in which to store the
 *                  IAdviseSink.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIViewObject::GetAdvise(
    LPDWORD pdwAspects, 
    LPDWORD pdwAdvf, 
    LPADVISESINK *ppAdvSink
    )
{
    HRESULT hr = S_OK;
    BOOL    fRefAdded = FALSE;

    try {
        if (NULL != ppAdvSink) {
            *ppAdvSink = m_pObj->m_pIAdviseSink;

            if (m_pObj->m_pIAdviseSink != NULL) {
                m_pObj->m_pIAdviseSink->AddRef();
                fRefAdded = TRUE;
            }
        }
        if (NULL != pdwAspects) { 
            *pdwAspects = m_pObj->m_dwAdviseAspects;
        }

        if (NULL != pdwAdvf) {
            *pdwAdvf = m_pObj->m_dwAdviseFlags;
        }

    } catch (...) {
        hr = E_POINTER;
    }

    if (FAILED(hr)) {
        if (fRefAdded) {
            m_pObj->m_pIAdviseSink->Release();
        }
    }

    return hr;
}




/*
 * CImpIViewObject::GetExtent
 *
 * Purpose:
 *  Retrieves the extents of the object's display.
 *
 * Parameters:
 *  dwAspect        DWORD of the aspect of interest.
 *  lindex          LONG index of the piece of interest.
 *  ptd             DVTARGETDEVICE * with device information.
 *  pszl            LPSIZEL to the structure in which to return
 *                  the extents.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIViewObject::GetExtent(
    DWORD dwAspect, 
    LONG lindex, 
    DVTARGETDEVICE *ptd, 
    LPSIZEL pszl
    )
{
    RECT rc;
    HRESULT hr = S_OK;

    if (!(DVASPECT_CONTENT & dwAspect))
    {
        try {
            hr = m_pObj->m_pDefIViewObject->GetExtent(dwAspect, lindex, ptd, pszl);
        } catch (...) {
            hr = E_POINTER;
        }

        return hr;
    }


#ifdef USE_SAMPLE_IPOLYLIN10
    m_pObj->m_pImpIPolyline->RectGet(&rc);
#else 
    CopyRect(&rc, &m_pObj->m_RectExt);
#endif

    m_pObj->RectConvertMappings(&rc, FALSE);

    hr = S_OK;

    try {
        pszl->cx = rc.right-rc.left;
        pszl->cy = rc.bottom-rc.top;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\irunobj.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    irunobj.cpp

Abstract:

    Implementation of the IRunnableObject interface which allows
    the control to enter the "running" state which means Sysmon's 
    dialog box is created, but not visible.  This is necessary so 
    that containers can ask for our extents before calling DoVerb.

--*/

#include "polyline.h"
#include "unkhlpr.h"

/*
 * CImpIRunnableObject interface implementation
 */

IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIRunnableObject)

/*
 * CImpIRunnableObject::GetRunningClass
 *
 * Purpose:
 *  Returns the CLSID of the object.
 *
 * Parameters:
 *  pClsID          LPCLSID in which to store the CLSID.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIRunnableObject::GetRunningClass(LPCLSID pClsID)
{
    HRESULT hr = S_OK;

    if (pClsID == NULL) {
        return E_POINTER;
    }

    try {
        *pClsID = m_pObj->m_clsID;
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


/*
 * CImpIRunnableObject::Run
 *
 * Purpose:
 *  Run an object in the given bind context, that is, put the object
 *  into the running state.
 *
 * Parameters:
 *  pBindCtx        LPBINDCTX of the bind context to use.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIRunnableObject::Run(LPBINDCTX /* pBindCtx */)
{
    /*
     * Registration of the object as running happens in
     * IOleObject::SetClientSite since we need a moniker from
     * the container and we don't have a client site pointer yet.
     */

    RECT rc;
    HRESULT hr = NOERROR;


    if (!m_pObj->m_bIsRunning) {
        SetRect(&rc,0,0,150,150);
#ifdef USE_SAMPLE_IPOLYLIN10
        hr = m_pObj->m_pImpIPolyline->Init(g_hWndFoster, 
                                           &rc, 
                                           WS_CHILD | WS_VISIBLE,
                                           ID_POLYLINE);
#else
        hr = m_pObj->m_pCtrl->Init(g_hWndFoster);
#endif
        if ( SUCCEEDED ( hr ) ) {
            m_pObj->m_bIsRunning = TRUE;
        } 
    }

    return hr;
}


/*
 * CImpIRunnableObject::IsRunning
 *
 * Purpose:
 *  Answers whether an object is currently in the running state.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  BOOL            Indicates the running state of the object.
 */

STDMETHODIMP_(BOOL) CImpIRunnableObject::IsRunning(void)
{
    return m_pObj->m_bIsRunning;
}






/*
 * CImpIRunnableObject::LockRunning
 *
 * Purpose:
 *  Locks an already running object into the running state or unlocks
 *  it from such a state.
 *
 * Parameters:
 *  fLock               BOOL indicating lock (TRUE) or unlock
 *                      (FALSE)
 *  fLastUnlockCloses   BOOL indicating if the last call to this
 *                      function with fLock==FALSE closes the
 *                      object.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIRunnableObject::LockRunning(
    BOOL fLock, 
    BOOL fLastUnlockCloses
    )
{
    //Calling CoLockObjectExternal is all we have to do here.
    return CoLockObjectExternal(this, fLock, fLastUnlockCloses);
}






/*
 * CImpIRunnableObject::SetContainedObject
 *
 * Purpose:
 *  Informs the object (embedded object) that it is inside a
 *  compound document container.
 *
 * Parameters:
 *  fContained      BOOL indicating if the object is now contained.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIRunnableObject::SetContainedObject(BOOL /* fContained */)
{
    //We can ignore this.
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\legend.cpp ===
/*++

Copyright (C) 1992-1999 Microsoft Corporation

Module Name:

    legend.cpp

Abstract:

    This file contains code creating the legend window, which is
    a child of the graph windows. The legend window displays a
    legend line for each line in the associated graph. It also 
    includes an area called the label, which are headers for those
    lines.

--*/

//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include "polyline.h"
#include <uxtheme.h>
#include <strsafe.h>
#include "grphitem.h"
#include "legend.h"
#include "winhelpr.h"
#include "owndraw.h"
#include "unihelpr.h"

#define eScaleValueSpace     L">9999999999.0"
#define szGraphLegendClass   L"PerfLegend"
#define szGraphLegendClassA  "PerfLegend"


LRESULT APIENTRY HdrWndProc (HWND, UINT, WPARAM, LPARAM);
 
//==========================================================================//
//                                  Constants                               //
//==========================================================================//
enum Orientation 
    {
    LEFTORIENTATION = TA_LEFT,
    CENTERORIENTATION = TA_CENTER,
    RIGHTORIENTATION = TA_RIGHT
    };

enum ColumnType 
    {
    eLegendColorCol = 0,
    eLegendScaleCol = 1,
    eLegendCounterCol = 2,
    eLegendInstanceCol = 3,
    eLegendParentCol = 4,
    eLegendObjectCol = 5,
    eLegendSystemCol = 6,
    eLegendExtraCol = 7     // If control wider than combined columns
    };

enum SortType
    {
    NO_SORT,
    INCREASING_SORT,
    DECREASING_SORT
    };

enum WindowType
    {
    LIST_WND = 1000,
    HDR_WND
    };

#define NULL_WIDTH      -1

#define dwGraphLegendClassStyle     (CS_HREDRAW | CS_VREDRAW)
#define iGraphLegendClassExtra      (0)
#define iGraphLegendWindowExtra     (sizeof (PLEGEND))
#define dwGraphLegendWindowStyle    (WS_CHILD | WS_VISIBLE) 

#define ThreeDPad           2
#define iMaxVisibleItems    8

#define dwGraphLegendItemsWindowClass  L"ListBox"
#define dwGraphLegendItemsWindowStyle           \
   (LBS_NOTIFY | LBS_NOINTEGRALHEIGHT | LBS_OWNERDRAWFIXED | \
    WS_VISIBLE | WS_CHILD | WS_VSCROLL)

#define WM_DELAYED_SELECT   WM_USER + 100

#define LegendBottomMargin()  (ThreeDPad)
#define LegendLeftMargin()    (ThreeDPad)
#define LegendHorzMargin()    (10)

typedef struct {
    PCGraphItem pGItem;
    LPCWSTR  pszKey;
} SORT_ITEM, *PSORT_ITEM;

//==========================================================================//
//                              Local Variables                             //
//==========================================================================//
static INT  xBorderWidth = GetSystemMetrics(SM_CXBORDER);
static INT  yBorderHeight = GetSystemMetrics(SM_CYBORDER);

#define MAX_COL_HEADER_LEN  32
#define MAX_COL_CHARS       64

static WCHAR aszColHeader[iLegendNumCols][MAX_COL_HEADER_LEN];

//
// Sorting function
//
INT __cdecl 
LegendSortFunc(
    const void *elem1, 
    const void *elem2 
    )
{
    return lstrcmp(((PSORT_ITEM)elem1)->pszKey, ((PSORT_ITEM)elem2)->pszKey);
}


//
// Constructor
//
CLegend::CLegend ( void )
:   m_pCtrl ( NULL ),
    m_hWnd ( NULL ),
    m_hWndHeader ( NULL ),
    m_DefaultWndProc ( NULL ),
    m_hWndItems ( NULL ),
    m_hFontItems ( NULL ),
    m_hFontLabels ( NULL ),
    m_iNumItemsVisible ( 0 ),
    m_pCurrentItem ( NULL ),
    m_iSortDir ( NO_SORT ),
    m_parrColWidthFraction( NULL )
{

    m_fMetafile = FALSE; 

    m_aCols[0].xWidth = -1;
}

//
// Destructor
//
CLegend::~CLegend (void )
{
    // Restore default window proc
    // so we don't get called post-mortum
    if (m_hWndHeader != NULL) {
        SetWindowLongPtr(m_hWndHeader, GWLP_WNDPROC, (INT_PTR)m_DefaultWndProc);
    }

    if (m_hWnd != NULL) {
        DestroyWindow(m_hWnd);
    }

    if ( NULL != m_parrColWidthFraction ) {
        delete m_parrColWidthFraction;
    }
}

//
// Initialization
//
BOOL CLegend::Init ( PSYSMONCTRL pCtrl, HWND hWndParent )
   {
   INT     iCol ;
   HD_ITEM hdi;
   HDC      hDC;
   BOOL     fComputeWidths;
   WNDCLASS wc ;
   LONG     lExStyles;
    // Save pointer to parent control
    m_pCtrl = pCtrl;

    BEGIN_CRITICAL_SECTION

    // Register window class once
    if (pstrRegisteredClasses[LEGEND_WNDCLASS] == NULL) {
    
        wc.style          = dwGraphLegendClassStyle ;
        wc.lpfnWndProc    = GraphLegendWndProc ;
        wc.hInstance      = g_hInstance ;
        wc.cbClsExtra     = iGraphLegendClassExtra ;
        wc.cbWndExtra     = iGraphLegendWindowExtra ;
        wc.hIcon          = NULL ;
        wc.hCursor        = LoadCursor (NULL, IDC_ARROW) ;
        wc.hbrBackground  = NULL ;
        wc.lpszMenuName   = NULL ;
        wc.lpszClassName  = szGraphLegendClass ;

        if (RegisterClass (&wc)) {
            pstrRegisteredClasses[LEGEND_WNDCLASS] = szGraphLegendClass;
        }

        // Ensure controls are initialized 
        InitCommonControls(); 

        // Load the column header strings just once also
        for (iCol=0; iCol<iLegendNumCols; iCol++) {

            LoadString(g_hInstance, (IDS_LEGEND_BASE + iCol), aszColHeader[iCol], MAX_COL_HEADER_LEN);
        }
    }

    END_CRITICAL_SECTION

    if (pstrRegisteredClasses[LEGEND_WNDCLASS] == NULL)
        return FALSE;

    // Create our window
    m_hWnd = CreateWindow (szGraphLegendClass,      // class
                         NULL,                     // caption
                         dwGraphLegendWindowStyle, // window style
                         0, 0,                     // position
                         0, 0,                     // size
                         hWndParent,               // parent window
                         NULL,                     // menu
                         g_hInstance,              // program instance
                         (LPVOID) this );          // user-supplied data

    if (m_hWnd == NULL)
        return FALSE;

    // Turn off layout mirroring if it is enabled
    lExStyles = GetWindowLong(m_hWnd, GWL_EXSTYLE); 

    if ( 0 != ( lExStyles & WS_EX_LAYOUTRTL ) ) {
        lExStyles &= ~WS_EX_LAYOUTRTL;
        SetWindowLong(m_hWnd, GWL_EXSTYLE, lExStyles);
    }
    
    // Turn off XP window theme for the owner drawn list header and cells.
    SetWindowTheme (m_hWnd, L" ", L" ");

    m_hWndHeader = CreateWindow(WC_HEADER,
                        NULL, 
                        WS_CHILD | WS_BORDER | HDS_BUTTONS | HDS_HORZ, 
                        0, 0, 0, 0, 
                        m_hWnd, 
                        (HMENU)HDR_WND, 
                        g_hInstance, 
                        (LPVOID) NULL);
        
    if (m_hWndHeader == NULL)
        return FALSE;

    // Turn off XP window theme for the owner drawn list header and cells.
    SetWindowTheme (m_hWndHeader, L" ", L" ");

    // Insert our own window procedure for special processing                
    m_DefaultWndProc = (WNDPROC)SetWindowLongPtr(m_hWndHeader, GWLP_WNDPROC, (INT_PTR)HdrWndProc);

    // Create Legend Items Listbox
    m_hWndItems = CreateWindow (L"ListBox",   // window class
                    NULL,                          // window caption
                    dwGraphLegendItemsWindowStyle, // window style
                    0, 0, 0, 0,                    // window size and pos
                    m_hWnd,                        // parent window
                    (HMENU)LIST_WND,               // child ID
                    g_hInstance,                   // program instance
                    (LPVOID) TRUE) ;               // user-supplied data

    if (m_hWndItems == NULL)
      return FALSE;

    // Turn off XP window theme for the owner drawn list header and cells.
    SetWindowTheme (m_hWndItems, L" ", L" ");

    // Set up DC for text measurements
    hDC = GetDC (m_hWndHeader);
    if ( NULL != hDC ) {
        // Compute initial sizes based on font
        ChangeFont(hDC);
    }

    // Set column widths and header labels
    m_aCols[0].xPos = 0;

    fComputeWidths = (m_aCols[0].xWidth == -1);

    for (iCol = 0; iCol < iLegendNumCols; iCol++)
      {
        // If width not loaded, calculate one based on label
        if ( fComputeWidths && NULL != hDC ) {
            m_aCols[iCol].xWidth = TextWidth (hDC, aszColHeader[iCol]) +  2 * LegendHorzMargin () ;
        }

        m_aCols[iCol].iOrientation = LEFTORIENTATION;

        if (iCol > 0) {
            m_aCols[iCol].xPos = m_aCols[iCol-1].xPos + m_aCols[iCol-1].xWidth;
        }

        hdi.mask = HDI_FORMAT | HDI_WIDTH; 
        hdi.pszText = NULL;
        hdi.cxy = m_aCols[iCol].xWidth;
        hdi.fmt = HDF_OWNERDRAW | HDF_LEFT; 
 
        Header_InsertItem(m_hWndHeader, iCol, &hdi); 
    } 

    if ( NULL != hDC ) {
        ReleaseDC ( m_hWndHeader, hDC );
    }

    return TRUE;
}  
 
  
HRESULT CLegend::LoadFromStream(LPSTREAM pIStream)
{
    HRESULT hr;
    ULONG   bc;
    INT     iCol;
    LEGEND_DATA  LegendData;
    HD_ITEM hdi;


    hr = pIStream->Read(&LegendData, sizeof(LegendData), &bc);
    if (FAILED(hr))
        return hr;
        
    if (bc != sizeof(LegendData))
        return E_FAIL;

    hdi.mask = HDI_WIDTH; 

    for (iCol=0; iCol<iLegendNumCols; iCol++) {
        m_aCols[iCol].xWidth = LegendData.xColWidth[iCol];

        if (iCol > 0) {
            m_aCols[iCol].xPos = m_aCols[iCol-1].xPos + m_aCols[iCol-1].xWidth;
        }

        hdi.cxy = m_aCols[iCol].xWidth;
        Header_SetItem(m_hWndHeader, iCol, &hdi);                
    }

    m_iSortCol = LegendData.iSortCol;
    m_iSortDir = LegendData.iSortDir;

    return NOERROR;
}


HRESULT 
CLegend::SaveToStream(LPSTREAM pIStream)
{
    HRESULT hr;
    INT     iCol;
    LEGEND_DATA  LegendData;

    for (iCol=0; iCol<iLegendNumCols; iCol++) {
        LegendData.xColWidth[iCol] = m_aCols[iCol].xWidth;
    }

    LegendData.iSortCol = m_iSortCol;
    LegendData.iSortDir = m_iSortDir;

    hr = pIStream->Write(&LegendData, sizeof(LegendData), NULL);
    if (FAILED(hr))
        return hr;

    return NOERROR;
}

HRESULT 
CLegend::LoadFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog* pIErrorLog )
{
    HRESULT hr = S_OK;
    LPWSTR pszData = NULL;
    INT iBufSizeCurrent = 0;
    INT iBufSize;
    INT iDataIndex;  
    DOUBLE  dValue = 0;
    WCHAR* pNextData;
    WCHAR* pDataEnd;

    
    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, L"LegendSortDirection", m_iSortDir );
    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, L"LegendSortColumn", m_iSortCol );

    iBufSize = iBufSizeCurrent;

    hr = StringFromPropertyBag (
            pIPropBag,
            pIErrorLog,
            L"LegendColumnWidths",
            pszData,
            iBufSize );

    if ( SUCCEEDED(hr) && 
            iBufSize > iBufSizeCurrent ) {
        // Width data exists.
        if ( NULL != pszData ) {
            delete [] pszData;
            pszData = NULL;
        }

        pszData = new WCHAR[ iBufSize ]; 
        
        if ( NULL == pszData ) {
            hr = E_OUTOFMEMORY;
        } else {
            *pszData = L'\0';
            
            iBufSizeCurrent = iBufSize;

            hr = StringFromPropertyBag (
                    pIPropBag,
                    pIErrorLog,
                    L"LegendColumnWidths",
                    pszData,
                    iBufSize );
        }

        if ( SUCCEEDED(hr) ) {
            m_parrColWidthFraction = new DOUBLE[iLegendNumCols];

            if ( NULL != m_parrColWidthFraction ) {

                pNextData = pszData;
                pDataEnd = pszData + lstrlen(pszData);

                for ( iDataIndex = 0; SUCCEEDED(hr) && iDataIndex < iLegendNumCols; iDataIndex++ ) { 
                    if ( pNextData < pDataEnd ) {
                        hr = GetNextValue ( pNextData, dValue );
                        if ( SUCCEEDED(hr) ) {
                            m_parrColWidthFraction[iDataIndex] = dValue;                    
                        }
                    } else {
                        hr = E_FAIL;
                    }
                }
                if ( FAILED(hr) ) {
                    //
                    // If failed to get at least one column value, then use default values.
                    //
                    delete [] m_parrColWidthFraction;
                    m_parrColWidthFraction = NULL;
                }
            } else {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    if (pszData != NULL) {
        delete [] pszData;
    }

    return NOERROR;
}

HRESULT 
CLegend::SaveToPropertyBag (
    IPropertyBag* pIPropBag,
    BOOL /* fClearDirty */,
    BOOL /* fSaveAllProps */ )
{
    HRESULT hr = NOERROR;
    WCHAR   szData[MAX_COL_CHARS*iLegendNumCols];
    WCHAR*  pszTemp;
    INT iIndex;
    VARIANT vValue;
    INT   xWidth;

    xWidth = m_Rect.right - m_Rect.left - 2 * LegendLeftMargin();

    // Continue even if error, using defaults in those cases.
    szData[0] = L'\0';

    for ( iIndex = 0; SUCCEEDED(hr) && iIndex < iLegendNumCols; iIndex++ ) { 
        DOUBLE  dFractionWidth;

        dFractionWidth = ( (DOUBLE)m_aCols[iIndex].xWidth ) / xWidth;
        
        if ( iIndex > 0 ) {
            StringCchCat (szData, MAX_COL_CHARS * iLegendNumCols, L"\t" );
        }
        
        VariantInit( &vValue );
        vValue.vt = VT_R8;
        vValue.dblVal = dFractionWidth;
        hr = VariantChangeTypeEx( &vValue, &vValue, LCID_SCRIPT, VARIANT_NOUSEROVERRIDE, VT_BSTR );
        
        pszTemp = vValue.bstrVal;
    
        StringCchCat(szData, MAX_COL_CHARS * iLegendNumCols, pszTemp );
        
        VariantClear( &vValue );
    }

    if ( SUCCEEDED( hr ) ){
        hr = StringToPropertyBag ( pIPropBag, L"LegendColumnWidths", szData );
    }

    hr = IntegerToPropertyBag ( pIPropBag, L"LegendSortDirection", m_iSortCol );

    hr = IntegerToPropertyBag ( pIPropBag, L"LegendSortColumn", m_iSortDir );

    return NOERROR;
}


//
// Get list index of item
//
INT CLegend::GetItemIndex(PCGraphItem pGItem)
{
    INT nItems;
    INT i;

    nItems = LBNumItems(m_hWndItems);

    for (i=0; i<nItems; i++)
        {
          if (pGItem == (PCGraphItem)LBData(m_hWndItems, i))
            return i;
        }

    return LB_ERR;
}

//
// Select list item
//          
BOOL CLegend::SelectItem(PCGraphItem pGItem) 
{
    INT iIndex;

    // Don't reselect the current selection
    // This is our parent echoing the change
    if (pGItem == m_pCurrentItem)
        return TRUE;

    iIndex = GetItemIndex(pGItem);

    if (iIndex == LB_ERR)
        return FALSE;

    LBSetSelection (m_hWndItems, iIndex) ;
    m_pCurrentItem = pGItem;

    return TRUE;
}

//
// Add new item to legend
//
BOOL CLegend::AddItem (PCGraphItem pItem)
{
    INT     iHigh,iLow,iMid = 0;
    INT     iComp;
    LPCWSTR pszItemKey = NULL;
    LPCWSTR pszItemKey2 = NULL;
    PCGraphItem pListItem;
    BOOL    bSorted = TRUE;
    
    if (m_iSortDir == NO_SORT) {
        bSorted = FALSE;
    }
    else {

        //
        // If we need to sort, we must sort based upon a sortable
        // column. So check to make sure we have a sortable column.
        // If we don't have a sortable column, just add the item 
        //
        pszItemKey = GetSortKey(pItem);

        if (pszItemKey == NULL) {
            bSorted = FALSE;
        }
    }

    if (bSorted == TRUE) {
        //
        // Binary search search for insertion point
        //
        iLow = 0;
        iHigh = LBNumItems(m_hWndItems);
        iMid = (iHigh + iLow) / 2;

        while (iLow < iHigh) {

            pListItem = (PCGraphItem)LBData(m_hWndItems, iMid);

            pszItemKey2 = GetSortKey(pListItem);
            //
            // pszItemKey2 should not be NULL if we come this point.
            // But if somehow it is NULL, then add the item
            //
            if (pszItemKey2 == NULL) {
                bSorted = FALSE;
                break;
            }

            iComp = lstrcmp(pszItemKey, pszItemKey2);
            if (m_iSortDir == DECREASING_SORT) {
                iComp = -iComp;
            }

            if (iComp > 0) {
                iLow = iMid + 1;
            }
            else {
                iHigh = iMid;
            }

            iMid = (iHigh + iLow) / 2;
        }
    }

    if (bSorted == TRUE) {
        LBInsert (m_hWndItems, iMid, pItem) ;
    }
    else {
        LBAdd(m_hWndItems, pItem);
    }

    return TRUE;
}


//
// Delete item from legend
//
void CLegend::DeleteItem (PCGraphItem pItem)
{
    INT iIndex ;        

    // Calling procedure checks for NULL pItem
    assert ( NULL != pItem );
    iIndex = GetItemIndex (pItem) ;

    if (iIndex != LB_ERR) {

        LBDelete (m_hWndItems, iIndex) ;

        // If deleted the current item
        // select the next one (or prev if no next)
        if (pItem == m_pCurrentItem) {

            if (iIndex == LBNumItems(m_hWndItems))
                iIndex--;

            if (iIndex >= 0)
                m_pCurrentItem = (PCGraphItem)LBData(m_hWndItems, iIndex);
            else
                m_pCurrentItem = NULL;

            LBSetSelection (m_hWndItems, iIndex) ;
            m_pCtrl->SelectCounter(m_pCurrentItem);
        }
    }
}


//
// Clear all items from legend
//
void CLegend::Clear ( void )
{
   LBReset (m_hWndItems) ;
   m_pCurrentItem = NULL ;
}

//
// Get currently selected item
//
PCGraphItem CLegend::CurrentItem ( void )
{
   return (m_pCurrentItem) ;
}

//
// Get legend window
//
HWND CLegend::Window ( void )
{
    return m_hWnd;
}

//
// Draw the header for a column
//

void 
CLegend::DrawColHeader(
    INT iCol, 
    HDC hDC, 
    HDC hAttribDC, 
    RECT& rRect, 
    BOOL bItemState )
{
    HFONT   hFontPrev;
    RECT    rc = rRect;
    
    if ( m_fMetafile ) {
        if ( eAppear3D == m_pCtrl->Appearance() ) {
            DrawEdge(hDC, &rc, EDGE_RAISED, BF_RECT);
        } else {
            Rectangle (hDC, rc.left, rc.top, 
               rc.right, rc.bottom );
        }
    }


    if ( iCol < iLegendNumCols ) {

        rc.top += yBorderHeight + 1;    // Extra pixel so that tops of letters don't get clipped.
        rc.bottom -= yBorderHeight;
        rc.left += 6 * xBorderWidth;
        rc.right -= 6 * xBorderWidth;

        if ( bItemState )
           OffsetRect(&rc, xBorderWidth, yBorderHeight);

        SetTextColor (hDC, m_pCtrl->clrFgnd()) ;
        SetBkColor(hDC, m_pCtrl->clrBackCtl()) ;
        SetTextAlign (hDC, m_aCols[iCol].iOrientation) ;
        hFontPrev = (HFONT)SelectFont(hDC, m_pCtrl->Font());

        FitTextOut (
            hDC, 
            hAttribDC, 
            0, 
            &rc, 
            aszColHeader[iCol], 
            lstrlen(aszColHeader[iCol]),
            m_aCols[iCol].iOrientation, FALSE );

        SelectFont (hDC, hFontPrev);
    }
}


//
// Draw the headers for all columns
//
void 
CLegend::DrawHeader(
    HDC hDC, 
    HDC hAttribDC, 
    RECT& /* rUpdateRect */ )
{
    INT iCol;
    RECT rectCol;
    INT iSumColWidths;     

    iSumColWidths = 0;

    for ( iCol = 0; iCol < iLegendNumCols; iCol++ ) {
        INT iColWidth;

        Header_GetItemRect( m_hWndHeader, iCol, &rectCol );
        
        iColWidth = rectCol.right - rectCol.left;
        
        if ( 0 < iColWidth ) {

            iSumColWidths += iColWidth;

            OffsetRect ( &rectCol, m_Rect.left, m_Rect.top );
        
            // Don't draw past the legend bounds.
            if ( rectCol.bottom > m_Rect.bottom ) {
                break;
            } else if ( rectCol.left >= m_Rect.right ) {
                break;
            } else if ( m_Rect.right < rectCol.right ) {
                rectCol.right = m_Rect.right;
            }

            DrawColHeader( iCol, hDC, hAttribDC, rectCol, FALSE );
        }
    }

    // Handle extra width past last column

    if ( iSumColWidths < ( m_Rect.right - m_Rect.left ) ) {
        rectCol.left = m_Rect.left + iSumColWidths;
        rectCol.right = m_Rect.right;

        DrawColHeader( iLegendNumCols, hDC, hAttribDC, rectCol, FALSE );    
    }
}


//
// Draw the color column for a legend item
//
void 
CLegend::DrawColorCol ( 
    PCGraphItem pItem, 
    INT iCol, 
    HDC hDC, 
    HDC hAttribDC, 
    INT yPos)
{   
    RECT    rect ;
    HRGN    hRgnOld;
    INT     iRgn;
    INT     yMiddle;

    if ( 0 < m_aCols[iCol].xWidth ) {

        rect.left = m_aCols[iCol].xPos + LegendLeftMargin () ;
        rect.top = yPos + 1 ;
        rect.right = rect.left + m_aCols[iCol].xWidth - 2 * LegendLeftMargin () ;
        rect.bottom = yPos + m_yItemHeight - 1 ;

        if( m_fMetafile ) {
            OffsetRect ( &rect, m_Rect.left, m_Rect.top );

            // Handle clipping.
            if ( rect.bottom > m_Rect.bottom ) {
                return;
            } else if ( rect.left >= m_Rect.right ) {
                return;
            } else if ( m_Rect.right < rect.right ) {
                rect.right = m_Rect.right;
            }
        }

        yMiddle = (rect.top + rect.bottom) / 2;

        if ( m_fMetafile ) {
            Line (hDC, pItem->Pen(), 
                   rect.left + 1, yMiddle, rect.right - 1, yMiddle) ;
        } else {
            if ( NULL != hAttribDC && NULL != hDC ) {
                hRgnOld = CreateRectRgn(0,0,0,0);    
                if ( NULL != hRgnOld ) {
                    iRgn = GetClipRgn(hAttribDC, hRgnOld);
                    if ( -1 != iRgn ) {
                        if ( ERROR != IntersectClipRect (hDC, rect.left + 1, rect.top + 1,
                                rect.right - 1, rect.bottom - 1) ) {
                            Line (hDC, pItem->Pen(), 
                               rect.left + 1, yMiddle, rect.right - 1, yMiddle) ;
                        }
                        // Old clip region is for the ListBox item window, so can't
                        // use this for printing.
                        if ( 1 == iRgn ) {
                            SelectClipRgn(hDC, hRgnOld);
                        }
                    }
                    DeleteObject(hRgnOld);
                }
            }
        }
    }
}


void 
CLegend::DrawCol (
    INT iCol, 
    HDC hDC, 
    HDC hAttribDC,
    INT yPos, 
    LPCWSTR lpszValue)
/*
   Effect:        Draw the value lpszValue for the column iCol on hDC.

   Assert:        The foreground and background text colors of hDC are
                  properly set.
*/
{
    static WCHAR    szMissing[4] = L"---";
    
    RECT    rect ;
    INT     xPos ;
    BOOL    bNeedEllipses = FALSE;
    INT     cChars = 0;
    WCHAR   achBuf[MAX_COL_CHARS + sizeof(ELLIPSES)/sizeof(WCHAR) + 1];

    if ( 0 < m_aCols[iCol].xWidth ) {
        rect.left = m_aCols[iCol].xPos + LegendLeftMargin() ;
        rect.top = yPos ;
        rect.right = rect.left + m_aCols[iCol].xWidth - 3 * LegendLeftMargin() ;
        rect.bottom = yPos + m_yItemHeight ;
  
        if( m_fMetafile ) {
            OffsetRect ( &rect, m_Rect.left, m_Rect.top );

            // Don't draw past the legend bounds.

            if ( rect.bottom > m_Rect.bottom ) {
                return;
            } else if ( rect.left >= m_Rect.right ) {
                return;
            } else if ( m_Rect.right < rect.right ) {
                rect.right = m_Rect.right;
            }

            DrawEdge(hDC, &rect, BDR_SUNKENOUTER, BF_RECT);
        }

        switch (m_aCols[iCol].iOrientation)
        {  // switch
            case LEFTORIENTATION:
                SetTextAlign (hDC, TA_LEFT) ;
                xPos = rect.left ;
                break ;

            case CENTERORIENTATION:
                SetTextAlign (hDC, TA_CENTER) ;
                xPos = (rect.left + rect.right) / 2 ;
                break ;

            case RIGHTORIENTATION:
                SetTextAlign (hDC, TA_RIGHT) ;
                xPos = rect.right ;
                break ;

            default:
                xPos = rect.left ;
                break ;
        }  // switch

        if (lpszValue[0] == 0)
            lpszValue = szMissing;

        bNeedEllipses = NeedEllipses (
                            hAttribDC, 
                            lpszValue, 
                            lstrlen(lpszValue), 
                            rect.right - rect.left, 
                            m_xEllipses, 
                            &cChars ); 
        

        if ( bNeedEllipses ) {
            cChars = min(cChars,MAX_COL_CHARS);
            wcsncpy(achBuf, lpszValue, cChars);
            achBuf[cChars] = L'\0';

            StringCchCat(achBuf, 
                         MAX_COL_CHARS + sizeof(ELLIPSES)/sizeof(WCHAR) + 1,
                         ELLIPSES);

            lpszValue = achBuf;
            cChars = lstrlen(lpszValue);
        }

        ExtTextOut (hDC, xPos, rect.top + yBorderHeight, ETO_OPAQUE | ETO_CLIPPED,
                   &rect, lpszValue, cChars, NULL) ;
    }
}

//
// Draw one legend line
//
void 
CLegend::DrawItem (
    PCGraphItem pItem, 
    INT yPos, 
    HDC hDC, 
    HDC hAttribDC)
{

    LPWSTR  pszName = NULL;
    WCHAR   szBuf[MAX_PATH + 1];
    INT     iMinWidth = 3;
    INT     iPrecision = 3;

    szBuf[0] = L'\0';

    // Draw Color
    DrawColorCol (pItem, eLegendColorCol, hDC, hAttribDC, yPos) ;

    // Draw Scale

#if PDH_MIN_SCALE != -7
// display a message if the scale format string gets out of sync with
// the PDH limits
#pragma message ("\nLEGEND.CPP: the scale format statement does not match the PDH\n")
#endif        

    if ( pItem->Scale() < (FLOAT) 1.0 ) {
        iMinWidth = 7; 
        iPrecision = 7;
    } else {
        iMinWidth = 3;
        iPrecision = 3;
    }


    FormatNumber ( pItem->Scale(), szBuf, MAX_PATH, iMinWidth, iPrecision );

    SetTextAlign (hDC, TA_TOP) ;   
    DrawCol ( eLegendScaleCol, hDC, hAttribDC, yPos, szBuf) ;

    // Draw Counter
    DrawCol ( eLegendCounterCol, hDC, hAttribDC, yPos, pItem->Counter()->Name()) ;
 
    // Draw Instance
    pszName = pItem->Instance()->GetInstanceName();
    DrawCol ( eLegendInstanceCol, hDC, hAttribDC, yPos, pszName) ;

    // Draw Parent
    pszName = pItem->Instance()->GetParentName();
    DrawCol (eLegendParentCol, hDC, hAttribDC, yPos, pszName) ;

    // Draw Object
    DrawCol (eLegendObjectCol, hDC, hAttribDC, yPos, pItem->Object()->Name()) ;

    // Draw System
    DrawCol (eLegendSystemCol, hDC, hAttribDC, yPos, pItem->Machine()->Name()) ;
}

//
// Resize parts of legend
//
void CLegend::SizeComponents (LPRECT pRect)
{
    INT xWidth;
    INT yHeight;

    m_Rect = *pRect;

    xWidth = pRect->right - pRect->left;
    yHeight = pRect->bottom - pRect->top;

    // If no space, hide window and leave
    if (xWidth == 0 || yHeight == 0) {
        WindowShow(m_hWnd, FALSE);
        return;
    }
    
    // If loaded from property bag, set column sizes.
    if ( NULL != m_parrColWidthFraction ) {
        INT iColTotalWidth;
        INT iCol;
        HD_ITEM hdi;

        hdi.mask = HDI_WIDTH; 

        iColTotalWidth = xWidth - 2 * LegendLeftMargin();

        for ( iCol = 0; iCol < iLegendNumCols; iCol++ ) { 
            m_aCols[iCol].xWidth = (INT)(m_parrColWidthFraction[iCol] * iColTotalWidth);
            hdi.cxy = m_aCols[iCol].xWidth;
            Header_SetItem(m_hWndHeader, iCol, &hdi);                
        }

        AdjustColumnWidths ();

        delete m_parrColWidthFraction;
        m_parrColWidthFraction = NULL;
    }

    // Show window to assigned position
    MoveWindow(m_hWnd, pRect->left, pRect->top, xWidth, yHeight, FALSE);
    WindowShow(m_hWnd, TRUE);
 
    // Set the size, position, and visibility of the header control. 
    SetWindowPos(m_hWndHeader, HWND_TOP, 0, 0, xWidth, m_yHeaderHeight, SWP_SHOWWINDOW); 

    // Resize legend items window
    MoveWindow (m_hWndItems, 
               LegendLeftMargin (), m_yHeaderHeight + ThreeDPad,
               xWidth - 2 * LegendLeftMargin (),
               yHeight - m_yHeaderHeight - ThreeDPad - LegendBottomMargin(),
               TRUE) ;
}

//
// Repaint legend area
//

void CLegend::OnPaint ( void )
   {  // OnPaint
    HDC             hDC ;
    RECT            rectFrame;
    PAINTSTRUCT     ps ;

    hDC = BeginPaint (m_hWnd, &ps) ;

    if ( eAppear3D == m_pCtrl->Appearance() ) {
        // Draw 3D border
        GetClientRect(m_hWnd, &rectFrame);
        //rectFrame.bottom -= ThreeDPad;
        //rectFrame.right -= ThreeDPad;
        DrawEdge(hDC, &rectFrame, BDR_SUNKENOUTER, BF_RECT);
    }

    if (LBNumItems (m_hWndItems) == 0) {
        WindowInvalidate(m_hWndItems) ;
    }


   EndPaint (m_hWnd, &ps) ;
   }  // OnPaint

//
// Handle user drawn header
//

void CLegend::OnDrawHeader(LPDRAWITEMSTRUCT lpDI)
{
    INT iCol = DIIndex(lpDI);
    HDC hDC = lpDI->hDC;
    RECT    rc = lpDI->rcItem;
    BOOL    bItemState = lpDI->itemState;

    // The screen DC is used for the attribute DC.
    DrawColHeader( iCol, hDC, hDC, rc, bItemState );
}

//
// Handle user drawn item message
//
void CLegend::OnDrawItem (LPDRAWITEMSTRUCT lpDI)
{
    HFONT          hFontPrevious ;
    HDC            hDC ;
    PCGraphItem    pItem ;
    INT            iLBIndex ;
    COLORREF       preBkColor = m_pCtrl->clrBackCtl();
    COLORREF       preTextColor = m_pCtrl->clrFgnd();
    BOOL           ResetColor = FALSE ;

    hDC = lpDI->hDC ;
    iLBIndex = DIIndex (lpDI) ;

    if (iLBIndex == -1)
        pItem = NULL ;
    else
        pItem = (PCGraphItem) LBData (m_hWndItems, iLBIndex) ;

    // If only a focus change, flip focus rect and leave
    if (lpDI->itemAction == ODA_FOCUS) {
        DrawFocusRect (hDC, &(lpDI->rcItem)) ;
        return;
    }
       
    // If item is selected use highlight colors
    if (DISelected (lpDI) || pItem == NULL) {      
        preTextColor = SetTextColor (hDC, GetSysColor (COLOR_HIGHLIGHTTEXT)) ;
        preBkColor = SetBkColor (hDC, GetSysColor (COLOR_HIGHLIGHT)) ;
        ResetColor = TRUE;
    } // Else set BkColor to BackColorLegend selected by the user.

    // Clear area
    ExtTextOut (hDC, lpDI->rcItem.left, lpDI->rcItem.top,
    ETO_OPAQUE, &(lpDI->rcItem), NULL, 0, NULL ) ;
   
    // Draw Legend Item
    if (pItem) {
        hFontPrevious = SelectFont (hDC, m_pCtrl->Font()) ;
        // The screen DC is used as the attribute DC
        DrawItem (pItem, lpDI->rcItem.top, hDC, hDC) ;
        SelectFont (hDC, hFontPrevious) ;
    }

    // Draw Focus rect
    if (DIFocus (lpDI))
        DrawFocusRect (hDC, &(lpDI->rcItem)) ;

    // Restore original colors
    if (ResetColor == TRUE) {
        SetTextColor (hDC, preTextColor) ;
        SetBkColor (hDC, preBkColor) ;
    }
}

void CLegend::OnMeasureItem (LPMEASUREITEMSTRUCT lpMI) {  
    lpMI->itemHeight = m_yItemHeight ;
}  // OnMeasureItem



void CLegend::OnDblClick ( void )
{
    m_pCtrl->DblClickCounter ( m_pCurrentItem );
}


//
// Handle selection change message
//

void CLegend::OnSelectionChanged ( void )
{
    INT             iIndex ;
    PCGraphItem     pGItem;

    // Get the new selection
    iIndex = LBSelection (m_hWndItems) ;
    pGItem = (PCGraphItem) LBData (m_hWndItems, iIndex) ;

    // if it's bad, reselect the current one
    // else request parent control to select new item
    if (pGItem == (PCGraphItem)LB_ERR) {
        SelectItem(m_pCurrentItem);
    }
    else {
        m_pCurrentItem = pGItem;
        m_pCtrl->SelectCounter(pGItem);
    }
}

void CLegend::AdjustColumnWidths (
    INT iCol
    )
{
    INT i;

    // Adjust positions of following columns
    for (i=iCol+1; i < iLegendNumCols; i++) {
        m_aCols[i].xPos = m_aCols[i - 1].xPos + m_aCols[i - 1].xWidth ;
    }
}

void CLegend::OnColumnWidthChanged (
    HD_NOTIFY *phdn
    )
{
    INT iCol = phdn->iItem;
    INT xWidth = phdn->pitem->cxy;

    // Update column width
    m_aCols[iCol].xWidth = xWidth;

    AdjustColumnWidths ( iCol );
    
    // Force update
    WindowInvalidate(m_hWndItems) ;
}


LPCWSTR CLegend::GetSortKey (
    PCGraphItem  pItem
    )
{
static  WCHAR   chNullName = 0;

    switch (m_iSortCol) {

    case eLegendCounterCol: 
        return pItem->Counter()->Name(); 

    case eLegendInstanceCol:
        if (pItem->Instance()->HasParent()) 
            return wcschr(pItem->Instance()->Name(), L'/') + 1;
        else
            return pItem->Instance()->Name(); 

    case eLegendParentCol:
        if (pItem->Instance()->HasParent())
            return pItem->Instance()->Name(); 
        else
            return &chNullName;

    case eLegendObjectCol:
        return pItem->Object()->Name(); 

    case eLegendSystemCol:
        return pItem->Machine()->Name(); 
    }

    return NULL;
}


void 
CLegend::OnColumnClicked (
    HD_NOTIFY *phdn
    )
{
    INT         i;
    INT         iCol = phdn->iItem;
    INT         nItems = LBNumItems (m_hWndItems);
    PSORT_ITEM  pSortItem;
    PSORT_ITEM  pSortItems;
    BOOL        bResort = FALSE;

    if (nItems <= 0)
        return;

    // Can't sort on color or scale factor
    if (iCol == eLegendColorCol || iCol == eLegendScaleCol) {
        m_iSortDir = NO_SORT;
        return;
    }

    // If repeat click, reverse sort direction
    if (iCol == m_iSortCol) {
        bResort = TRUE;
        m_iSortDir = (m_iSortDir == INCREASING_SORT) ?
                        DECREASING_SORT : INCREASING_SORT;
    } else {
        m_iSortCol = iCol;
        m_iSortDir = INCREASING_SORT;
    }

    // Allocate array for sorting
    pSortItems = new SORT_ITEM [nItems];
    if (pSortItems == NULL) {
        return;     
    }

    // Build array of GraphItem/Key pairs
    pSortItem = pSortItems;
    for (i=0; i<nItems; i++,pSortItem++) {
        
        pSortItem->pGItem = (PCGraphItem)LBData(m_hWndItems, i);
        pSortItem->pszKey = GetSortKey(pSortItem->pGItem);
    }

    // For resort, just reload in reverse order.
    if ( !bResort ) {
        // Sort by key value
        qsort( (PVOID)pSortItems, nItems, sizeof(SORT_ITEM), &LegendSortFunc );
    }

    // Disable drawing while rebuilding list
    LBSetRedraw(m_hWndItems, FALSE);

    // Clear list box
    LBReset (m_hWndItems) ;

    // Reload in sorted order
    if ( !bResort && m_iSortDir == INCREASING_SORT) {
        for (i=0; i<nItems; i++) {
            LBAdd (m_hWndItems, pSortItems[i].pGItem);
        }
    } else {
        for (i=nItems - 1; i>=0; i--) {
            LBAdd (m_hWndItems, pSortItems[i].pGItem);
        }
    }

    LBSetRedraw(m_hWndItems, TRUE);

    delete [] pSortItems;
}

//
// Window procedure
//
LRESULT APIENTRY GraphLegendWndProc (HWND hWnd, UINT uiMsg, WPARAM wParam,
                                     LPARAM lParam)
{
   CLegend        *pLegend;
   BOOL           bCallDefProc ;
   LRESULT        lReturnValue ;
   RECT           rect;

   pLegend = (PLEGEND)GetWindowLongPtr(hWnd,0);

   bCallDefProc = FALSE ;
   lReturnValue = 0L ;

   switch (uiMsg)
      {
      case WM_CREATE:
            pLegend = (PLEGEND)((CREATESTRUCT*)lParam)->lpCreateParams;
            SetWindowLongPtr(hWnd,0,(INT_PTR)pLegend);
            break;

      case WM_DESTROY:
    pLegend->m_hWnd = NULL;
         break ;

      case WM_LBUTTONDBLCLK:
      case WM_LBUTTONDOWN:
            SendMessage(GetParent(hWnd), uiMsg, wParam, lParam);
            break;

      case WM_COMMAND:
         switch (HIWORD (wParam))
            {  // switch
            case LBN_DBLCLK:
               pLegend->OnDblClick () ;
               break ;

            case LBN_SELCHANGE:
               pLegend->OnSelectionChanged () ;
               break ;

            case LBN_SETFOCUS:
                pLegend->m_pCtrl->Activate();
                break;

            default:
               bCallDefProc = TRUE ;
            }  // switch
         break ;
                                          
      case WM_NOTIFY:
          switch (((LPNMHDR)lParam)->code)
            {
            case HDN_ENDTRACK:
                pLegend->OnColumnWidthChanged((HD_NOTIFY*) lParam);
                break;

            case HDN_ITEMCLICK:
                pLegend->OnColumnClicked((HD_NOTIFY*) lParam);
                pLegend->m_pCtrl->Activate();
                break;
            }

            return FALSE;
            break;

      case WM_DRAWITEM:
          switch (((LPDRAWITEMSTRUCT)lParam)->CtlID) {

          case LIST_WND:
                pLegend->OnDrawItem((LPDRAWITEMSTRUCT) lParam) ;
                break;

          case HDR_WND:
                pLegend->OnDrawHeader((LPDRAWITEMSTRUCT) lParam) ;
                break;
          }

         break ;

      case WM_MEASUREITEM:
         pLegend->OnMeasureItem ((LPMEASUREITEMSTRUCT) lParam) ;
         break ;

      case WM_DELETEITEM:
         break ;

      case WM_ERASEBKGND:
        GetClientRect(hWnd, &rect);
        Fill((HDC)wParam, pLegend->m_pCtrl->clrBackCtl(), &rect);
        return TRUE; 

      case WM_PAINT:
         pLegend->OnPaint () ;
         break ;

      case WM_SETFOCUS:
         SetFocus(pLegend->m_hWndItems);
         break ;

      default:
         bCallDefProc = TRUE ;
      }


   if (bCallDefProc)
      lReturnValue = DefWindowProc (hWnd, uiMsg, wParam, lParam) ;

   return (lReturnValue);
}

LRESULT APIENTRY 
HdrWndProc (
    HWND hWnd,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    RECT    rect;
    CLegend *pLegend;
    
    // Parent window carries the Legend object pointer
    pLegend = (PLEGEND)GetWindowLongPtr(GetParent(hWnd),0);

    if (uiMsg == WM_ERASEBKGND) {
        GetClientRect(hWnd, &rect);
        Fill((HDC)wParam, pLegend->m_pCtrl->clrBackCtl(), &rect);
        return TRUE;
    }

    // Do the default processing
#ifdef STRICT
    return CallWindowProc(pLegend->m_DefaultWndProc, hWnd, uiMsg, wParam, lParam);
#else
    return CallWindowProc((FARPROC)pLegend->m_DefaultWndProc, hWnd, uiMsg, wParam, lParam);
#endif
}


//
// Compute minimum width of legend
//
INT CLegend::MinWidth ( void )
{
    return 0 ;
}

//
// Compute minimum height of legend
//
INT CLegend::MinHeight ( INT yMaxHeight )
{
    INT yHeight = m_yHeaderHeight + m_yItemHeight + 2*ThreeDPad 
                    + LegendBottomMargin();

    return (yMaxHeight >= yHeight) ? yHeight : 0;
}


//
// Compute prefered height of legend
//
INT CLegend::Height (INT yMaxHeight)
{
    INT nItems;
    INT nPrefItems;
    
    // Determine preferred number of items to show
    nPrefItems = PinInclusive(LBNumItems(m_hWndItems), 1, iMaxVisibleItems);

    // Determine number of items that will fit
    nItems = (yMaxHeight - m_yHeaderHeight - 2*ThreeDPad - LegendBottomMargin())
                 / m_yItemHeight;
    
    // Use smaller number
    nItems = min(nItems, nPrefItems);

    // If no items will fit, return zero
    if (nItems == 0)
        return 0;

    // Return height of legend with nItems
    return m_yHeaderHeight + 2*ThreeDPad + nItems * m_yItemHeight 
                + LegendBottomMargin();
}



#ifdef KEEP_PRINT

void CLegend::Print (HDC hDC, RECT rectLegend)
   {
   INT            yItemHeight ;
   HFONT          hFontItems ;
   PCGraphItem    pItem ;
   INT            iIndex ;
   INT            iIndexNum ;

   yItemHeight = m_yItemHeight ;
   hFontItems = m_hFontItems ;

   m_hFontItems = hFontPrinterScales ;
   SelectFont (hDC, m_hFontItems) ;

   m_yItemHeight = FontHeight (hDC, TRUE) ;

   iIndexNum = LBNumItems (m_hWndItems);
   for (iIndex = 0; iIndex < iIndexNum; iIndex++)
      {
      pItem = (PCGraphItem) LBData (m_hWndItems, iIndex) ;
      DrawItem (pItem, iIndex * m_yItemHeight, hDC) ;
      }

   m_hFontItems = hFontItems ;
   m_yItemHeight = yItemHeight ;

   SelectBrush (hDC, GetStockObject (HOLLOW_BRUSH)) ;
   SelectPen (hDC, GetStockObject (BLACK_PEN)) ;
   Rectangle (hDC, 0, 0, 
              rectLegend.right - rectLegend.left,
              rectLegend.bottom - rectLegend.top) ;
   }
#endif


void 
CLegend::ChangeFont( 
    HDC hDC 
    )
{   
    HD_LAYOUT   hdl;
    WINDOWPOS   wp;
    RECT        rectLayout;

    // Assign font to header
    SetFont(m_hWndHeader, m_pCtrl->Font());

    // Get prefered height of header control
    // (use arbitrary rect for allowed area)
    rectLayout.left = 0;
    rectLayout.top = 0;
    rectLayout.right = 32000;
    rectLayout.bottom = 32000;

    wp.cy = 0;
    hdl.prc = &rectLayout; 
    hdl.pwpos = &wp; 
    Header_Layout(m_hWndHeader, &hdl);
    m_yHeaderHeight = wp.cy + 2 * yBorderHeight;   

    // Set up DC for font measurements
    SelectFont (hDC, m_pCtrl->Font()) ;
    
    // Compute height of legend line 
    SelectFont (hDC, m_hFontItems) ;
    m_yItemHeight = FontHeight (hDC, TRUE) + 2 * yBorderHeight;

    LBSetItemHeight(m_hWndItems, m_yItemHeight);

    // Compute width of "..."
    m_xEllipses = TextWidth (hDC, ELLIPSES) ;
}



void 
CLegend::Render(
    HDC hDC,
    HDC hAttribDC, 
    BOOL /*fMetafile*/,
    BOOL /*fEntire*/,
    LPRECT prcUpdate )
{
    PCGraphItem pItem ;
    INT         iIndex ;
    INT         iIndexNum ;
    RECT        rectPaint;
    HFONT       hFontPrevious;

    // if no space assigned, return
    if (m_Rect.top == m_Rect.bottom)
        return;

    // if no painting needed, return
    if (!IntersectRect(&rectPaint, &m_Rect, prcUpdate))
        return;

    m_fMetafile = TRUE;

    hFontPrevious = SelectFont (hDC, m_pCtrl->Font()) ;

    DrawHeader ( hDC, hAttribDC, rectPaint );

    SelectFont (hDC, hFontPrevious) ;    

    iIndexNum = LBNumItems (m_hWndItems);

    hFontPrevious = SelectFont (hDC, m_pCtrl->Font()) ;

    for (iIndex = 0; iIndex < iIndexNum; iIndex++) {
      pItem = (PCGraphItem) LBData (m_hWndItems, iIndex) ;
      DrawItem (
          pItem, 
          m_yHeaderHeight + ( iIndex * m_yItemHeight ), 
          hDC,
          hAttribDC) ;
    }

    SelectFont (hDC, hFontPrevious) ;    

    m_fMetafile = FALSE;


    SelectBrush (hDC, GetStockObject (HOLLOW_BRUSH)) ;
    SelectPen (hDC, GetStockObject (BLACK_PEN)) ;

    if ( eAppear3D == m_pCtrl->Appearance() ) {
        // Draw 3D border
        DrawEdge(hDC, &m_Rect, BDR_SUNKENOUTER, BF_RECT);
    }
}

HRESULT
CLegend::GetNextValue (
    WCHAR*& pszNext,
    DOUBLE& rdValue )
{
    HRESULT hr = NOERROR;
    WCHAR   szValue[MAX_COL_CHARS + 1];
    INT     iLen;

    VARIANT vValue;
    
    rdValue = -1.0;

    iLen = wcscspn (pszNext, L"\t");

    //
    // Change tab character to null.
    //
    pszNext[iLen] = L'\0';

    hr = StringCchCopy ( szValue, MAX_COL_CHARS + 1, pszNext );

    if ( SUCCEEDED ( hr ) ) {

        VariantInit( &vValue );
        vValue.vt = VT_BSTR;

        vValue.bstrVal = SysAllocString ( szValue );
        hr = VariantChangeTypeEx( &vValue, &vValue, LCID_SCRIPT, VARIANT_NOUSEROVERRIDE, VT_R8 );

        if ( SUCCEEDED(hr) ) {
            rdValue = vValue.dblVal;
        }

        VariantClear( &vValue );
    }
    pszNext += iLen + 1  ;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\logfiles.h ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    logfiles.h

Abstract:

    Header file for the implementation of the CImpILogFiles 
    and CImpIEnumLogFile objects.

--*/

#ifndef _LOGFILES_H_
#define _LOGFILES_H_

class CPolyline;
class CLogFileItem;

class CImpILogFiles : public ILogFiles
{
  public:

	CImpILogFiles(CPolyline*, LPUNKNOWN);
	~CImpILogFiles();

    /* IUnknown methods */
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)	(UINT *pctinfo);

    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);

    STDMETHOD(GetIDsOfNames) (REFIID riid, OLECHAR **rgszNames,
     						  UINT cNames, LCID lcid, DISPID *rgdispid);

    STDMETHOD(Invoke) (DISPID dispidMember, REFIID riid, LCID lcid,WORD wFlags,
      				   DISPPARAMS *pdispparams, VARIANT *pvarResult,
      				   EXCEPINFO *pexcepinfo, UINT *puArgErr);

    /* LogFiles methods */
    STDMETHOD(get_Count) (long *pLong);
    STDMETHOD(get__NewEnum)	(IUnknown **ppIunk);
    STDMETHOD(get_Item) (VARIANT index, DILogFileItem **ppI);
    STDMETHOD(Add) (BSTR bstrLogFilePath, DILogFileItem **ppI);
    STDMETHOD(Remove) (VARIANT index);

protected:
	ULONG		m_cRef;
	CPolyline*	m_pObj;
    LPUNKNOWN   m_pUnkOuter;
    ULONG       m_uiItemCount;			
};

typedef CImpILogFiles *PCImpILogFiles;

// LogFile enumerator
class CImpIEnumLogFile : public IEnumVARIANT
{
public:
	CImpIEnumLogFile (VOID);
	HRESULT Init (CLogFileItem* pItem, INT cItems);

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

	// Enum methods
	STDMETHOD(Next) (ULONG cItems, VARIANT *varItems, ULONG *pcReturned);
	STDMETHOD(Skip) (ULONG cSkip);
	STDMETHOD(Reset) (VOID);
	STDMETHOD(Clone) (IEnumVARIANT **pIEnum);

private:
	DWORD		    m_cRef;
	CLogFileItem**  m_paLogFileItem;
	ULONG		    m_cItems;
	ULONG		    m_uCurrent;	
};

#endif //_LOGFILES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\logfiles.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    logfiles.cpp

Abstract:

    Implementation of the ILogFiles interface

--*/

#include "polyline.h"
#include "unkhlpr.h"
#include "unihelpr.h"
#include "smonmsg.h"
#include "logsrc.h"
#include "logfiles.h"


//Standard IUnknown implementation for contained interface
IMPLEMENT_CONTAINED_CONSTRUCTOR(CPolyline, CImpILogFiles)
IMPLEMENT_CONTAINED_DESTRUCTOR(CImpILogFiles)
IMPLEMENT_CONTAINED_ADDREF(CImpILogFiles)
IMPLEMENT_CONTAINED_RELEASE(CImpILogFiles)

STDMETHODIMP 
CImpILogFiles::QueryInterface (
    IN  REFIID riid, 
    OUT PPVOID ppv
    )
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        return E_POINTER;
    }

    try {
        *ppv=NULL;

        if (IID_IUnknown == riid || IID_ILogFiles == riid) {
            *ppv = (LPVOID)this;
            AddRef();
        } else {
            hr = E_NOINTERFACE;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}



STDMETHODIMP 
CImpILogFiles::GetTypeInfoCount (
    OUT UINT *pctInfo
    )
{
    HRESULT hr = S_OK;

    if (pctInfo == NULL) {
        return E_POINTER;
    }

    try {
        *pctInfo = 1;
    } catch (...) {
        hr = E_POINTER;
    } 

    return hr;
}


STDMETHODIMP 
CImpILogFiles::GetTypeInfo (
    IN  UINT itInfo, 
    IN  LCID /* lcid */, 
    OUT ITypeInfo** ppITypeInfo
    )
{
    HRESULT hr = S_OK;

    if (ppITypeInfo == NULL) {
        return E_POINTER;
    }

    //
    // We have only one type information
    //
    if (0 != itInfo) {
        return TYPE_E_ELEMENTNOTFOUND;
    }
    else {
        try {
            *ppITypeInfo = NULL;

            //We ignore the LCID
            hr = m_pObj->m_pITypeLib->GetTypeInfoOfGuid(IID_ILogFiles, ppITypeInfo);
        } catch (...) {
            hr = E_POINTER;
        }
    }

    return hr;
}


STDMETHODIMP 
CImpILogFiles::GetIDsOfNames (
    IN  REFIID riid,
    IN  OLECHAR **rgszNames, 
    IN  UINT cNames,
    IN  LCID /* lcid */,
    OUT DISPID *rgDispID
    )
{
    HRESULT     hr = DISP_E_UNKNOWNINTERFACE;
    ITypeInfo  *pTI = NULL;

    if (rgDispID == NULL || rgszNames == NULL) {
        return E_POINTER;
    }

    if (IID_NULL == riid) {
        try {
            *rgDispID = NULL;

            hr = m_pObj->m_pITypeLib->GetTypeInfoOfGuid(IID_ILogFiles, &pTI);

            if (SUCCEEDED(hr)) {
                hr = DispGetIDsOfNames(pTI, rgszNames, cNames, rgDispID);
                pTI->Release();
            }
        } catch (...) {
            hr = E_POINTER;
        }
    }

    return hr;
}



/*
 * CImpIDispatch::Invoke
 *
 * Purpose:
 *  Calls a method in the dispatch interface or manipulates a
 *  property.
 *
 * Parameters:
 *  dispID          DISPID of the method or property of interest.
 *  riid            REFIID reserved, must be IID_NULL.
 *  lcid            LCID of the locale.
 *  wFlags          USHORT describing the context of the invocation.
 *  pDispParams     DISPPARAMS * to the array of arguments.
 *  pVarResult      VARIANT * in which to store the result.  Is
 *                  NULL if the caller is not interested.
 *  pExcepInfo      EXCEPINFO * to exception information.
 *  puArgErr        UINT * in which to store the index of an
 *                  invalid parameter if DISP_E_TYPEMISMATCH
 *                  is returned.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */

STDMETHODIMP 
CImpILogFiles::Invoke ( 
    IN  DISPID dispID, 
    IN  REFIID riid,
    IN  LCID /* lcid */, 
    IN  USHORT wFlags, 
    IN  DISPPARAMS *pDispParams,
    OUT VARIANT *pVarResult, 
    OUT EXCEPINFO *pExcepInfo, 
    OUT UINT *puArgErr
    )
{
    HRESULT     hr = DISP_E_UNKNOWNINTERFACE;
    ITypeInfo  *pTI = NULL;

    if ( IID_NULL == riid ) {
        try {
            hr = m_pObj->m_pITypeLib->GetTypeInfoOfGuid(IID_ILogFiles, &pTI);

            if (SUCCEEDED(hr)) {
    
                hr = pTI->Invoke(this, 
                                 dispID, 
                                 wFlags,
                                 pDispParams, 
                                 pVarResult, 
                                 pExcepInfo, 
                                 puArgErr);
                pTI->Release();
            }
        } catch (...) {
            hr = E_POINTER;
        }
    }

    return hr;
}


STDMETHODIMP
CImpILogFiles::get_Count (
    OUT LONG*   pLong )
{
    HRESULT hr = S_OK;

    if (pLong == NULL) {
        return E_POINTER;
    }

    try {
        *pLong = m_pObj->m_pCtrl->NumLogFiles();
    } catch (...) {
        hr = E_POINTER;
    } 

    return hr;
}


STDMETHODIMP
CImpILogFiles::get__NewEnum (
    IUnknown **ppIunk
    )
{
    HRESULT hr = S_OK;
    CImpIEnumLogFile *pEnum = NULL;

    if (ppIunk == NULL) {
        return E_POINTER;
    }

    try {
        *ppIunk = NULL;

        pEnum = new CImpIEnumLogFile;
        if ( NULL != pEnum ) {
            hr = pEnum->Init ( m_pObj->m_pCtrl->FirstLogFile(),
                               m_pObj->m_pCtrl->NumLogFiles() );
            if ( SUCCEEDED ( hr ) ) {
                *ppIunk = pEnum;
                pEnum->AddRef();    
                //
                // Up to here, everything works well
                //
            } 
        } 
        else {
            hr = E_OUTOFMEMORY;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    if (FAILED(hr) && pEnum != NULL) {
        delete pEnum;
    }

    return hr;
}


STDMETHODIMP
CImpILogFiles::get_Item (
    IN  VARIANT varIndex, 
    OUT DILogFileItem **ppI
    )
{
    HRESULT hr = S_OK;
    VARIANT varLoc;
    INT iIndex = 0;
    INT i;
    CLogFileItem *pItem = NULL;

    if (ppI == NULL) {
        return E_POINTER;
    }

    //
    // Try coercing index to I4
    //
    VariantInit(&varLoc);

    try {
        *ppI = NULL;

#pragma warning(push)
#pragma warning ( disable : 4127 )
        //
        // We use do {} while (0) here to act like a switch statement
        //
        do {
            hr = VariantChangeType(&varLoc, &varIndex, 0, VT_I4);
            if ( !SUCCEEDED (hr) ) {
                break;
            }

            //
            // Verify index is in range
            //
            iIndex = V_I4(&varLoc);
            if ( iIndex < 1 || iIndex > m_pObj->m_pCtrl->NumLogFiles() ) {
                hr = DISP_E_BADINDEX;
                break;
            }

            //
            // Traverse log file linked list to indexed item
            //
            pItem = m_pObj->m_pCtrl->FirstLogFile ();
            i = 1;
            while (i++ < iIndex && NULL != pItem ) {
                pItem = pItem->Next();
            }

            //
            // Something wrong with linked list!!
            //
            if ( NULL == pItem ) {
                hr = E_FAIL;
                break;
            }

            //
            // Return counter's dispatch interface
            //
            hr = pItem->QueryInterface(DIID_DILogFileItem, (PVOID*)ppI);

        } while (0);
#pragma warning(pop)
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpILogFiles::Add (
    IN  BSTR bstrPath,
    OUT DILogFileItem **ppI
    )
{
    HRESULT hr = S_OK;
    eDataSourceTypeConstant eDataSourceType = sysmonCurrentActivity;
    PCLogFileItem pItem = NULL;

    if (ppI == NULL) {
        return E_POINTER;
    }

    //
    // Check data source type.  Only add log files 
    // when the data source is not sysmonLogFiles
    //
    hr = m_pObj->m_pCtrl->get_DataSourceType ( eDataSourceType );
    
    if ( SUCCEEDED ( hr ) ) {
        if ( sysmonLogFiles != eDataSourceType ) {
            try {
                *ppI = NULL;

                // If non-null log file path
                if ( NULL != bstrPath && 0 != bstrPath[0] ) {
                    hr = m_pObj->m_pCtrl->AddSingleLogFile((LPWSTR)bstrPath, &pItem);
                    if ( SUCCEEDED ( hr ) ) {
                        hr = pItem->QueryInterface(DIID_DILogFileItem, (PVOID*)ppI);
                        pItem->Release();
                    }
                } else {
                    hr = E_INVALIDARG;
                }
            } catch (...) {
                hr = E_POINTER;
            }
        } else {
            hr = SMON_STATUS_LOG_FILE_DATA_SOURCE;
        }
    }

    return hr;
}


STDMETHODIMP
CImpILogFiles::Remove (
    IN  VARIANT varIndex
    )
{
    HRESULT hr;
    eDataSourceTypeConstant eDataSourceType = sysmonCurrentActivity;
    DILogFileItem*  pDI = NULL;
    PCLogFileItem   pItem = NULL;

    // Check data source type.  Only remove log files 
    // when the data source is not sysmonLogFiles
    hr = m_pObj->m_pCtrl->get_DataSourceType ( eDataSourceType );
    
    if ( SUCCEEDED ( hr ) ) {
        if ( sysmonLogFiles != eDataSourceType ) {
            // Get interface to indexed item
            hr = get_Item(varIndex, &pDI);

            if ( SUCCEEDED ( hr ) ) {

                // Exchange Dispatch interface for direct one
                hr = pDI->QueryInterface(IID_ILogFileItem, (PVOID*)&pItem);
                pDI->Release();
                if ( SUCCEEDED ( hr ) ) {
                    assert ( NULL != pItem );

                    // Remove the item from the control's list.
                    m_pObj->m_pCtrl->RemoveSingleLogFile ( pItem );
            
                    // Release the temp interface
                    pItem->Release();
                }        
            } else {
                hr = SMON_STATUS_LOG_FILE_DATA_SOURCE;
            }
        }
    }
    return hr;
}


CImpIEnumLogFile::CImpIEnumLogFile (
    void )
    :   m_cItems ( 0 ),
        m_uCurrent ( 0 ),
        m_cRef ( 0 ),
        m_paLogFileItem ( NULL )
{
    return;
}


HRESULT
CImpIEnumLogFile::Init (    
    PCLogFileItem  pLogFileItem,
    INT            cItems )
{
    HRESULT hr = NOERROR;
    INT i;

    if ( cItems > 0 ) {
        m_paLogFileItem = (PCLogFileItem*)malloc(sizeof(PCLogFileItem) * cItems);

        if ( NULL != m_paLogFileItem  ) {
            ZeroMemory(m_paLogFileItem, sizeof(PCLogFileItem) * cItems);
            m_cItems = cItems;

            for (i = 0; i < cItems; i++) {
                m_paLogFileItem[i] = pLogFileItem;
                pLogFileItem = pLogFileItem->Next();
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    } // No error if cItems <= 0

    return hr;
}

    

STDMETHODIMP
CImpIEnumLogFile::QueryInterface (
    IN  REFIID riid, 
    OUT PVOID *ppv
    )
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        return E_POINTER;
    }

    try {
        *ppv = NULL;

        if ((riid == IID_IUnknown) || (riid == IID_IEnumVARIANT)) {
            *ppv = this;
            AddRef();
        } else {
            hr = E_NOINTERFACE;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP_(ULONG)
CImpIEnumLogFile::AddRef (
    VOID
    )
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG)
CImpIEnumLogFile::Release(
    VOID
    )
{
    if (--m_cRef == 0) {

        if (m_paLogFileItem != NULL)
            free(m_paLogFileItem);

        delete this;
        return 0;
    }

    return m_cRef;
}


STDMETHODIMP
CImpIEnumLogFile::Next(
    IN  ULONG cItems,
    OUT VARIANT *varItem,
    OUT ULONG *pcReturned)
{
    HRESULT hr = S_OK;
    ULONG i;
    ULONG cRet;

    if (varItem == NULL) {
        return E_POINTER;
    }

    try {
        //
        // Clear the return variants
        //
        for (i = 0; i < cItems; i++) {
            VariantInit(&varItem[i]);
        }

        //
        // Try to fill the caller's array
        //
        for (cRet = 0; cRet < cItems; cRet++) {

            // No more, return success with false
            if (m_uCurrent == m_cItems) {
                hr = S_FALSE;
                break;
            }

            // Get a dispatch interface for the item
            hr = m_paLogFileItem[m_uCurrent]->QueryInterface(DIID_DILogFileItem,
                                             (PVOID*)&V_DISPATCH(&varItem[cRet]));
            if (FAILED(hr))
                break;

            V_VT(&varItem[cRet]) = VT_DISPATCH;

            m_uCurrent++;
        }

        // If failed, clear out the variants
        if (FAILED(hr)) {
            for (i = 0; i < cItems; i++) {
                if (V_VT(&varItem[i]) == VT_DISPATCH) {
                    V_DISPATCH(&varItem[i])->Release();
                }
                VariantClear(&varItem[i]);
            }
            cRet = 0;
        }

        // If desired, return number of items fetched
        if (pcReturned) {
            *pcReturned = cRet;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP
CImpIEnumLogFile::Skip(
    IN  ULONG   cItems
    )
/*++
 Purpose:
   Attempt to skip over the next 'cItems' elements in the enumeration
   sequence.

 Entry:
   cItems = the count of elements to skip

 Exit:
   return value = HRESULT
     S_OK
     S_FALSE -  the end of the sequence was reached

--*/
{
    m_uCurrent += cItems;

    if (m_uCurrent > m_cItems) {
        m_uCurrent = m_cItems;
        return S_FALSE;
    }

    return S_OK;
}


/***
*HRESULT CEnumPoint::Reset(void)
*Purpose:
*  Reset the enumeration sequence back to the beginning.
*
*Entry:
*  None
*
*Exit:
*  return value = SHRESULT CODE
*    S_OK
*
***********************************************************************/
STDMETHODIMP
CImpIEnumLogFile::Reset(
    VOID
    )
{
    m_uCurrent = 0;

    return S_OK; 
}


/***
*HRESULT CEnumPoint::Clone(IEnumVARIANT**)
*Purpose:
*  Retrun a CPoint enumerator with exactly the same state as the
*  current one.
*
*Entry:
*  None
*
*Exit:
*  return value = HRESULT
*    S_OK
*    E_OUTOFMEMORY
*
***********************************************************************/
STDMETHODIMP
CImpIEnumLogFile::Clone (
    OUT IEnumVARIANT **ppEnum
    )
{
    HRESULT hr = S_OK;
    ULONG   i;
    CImpIEnumLogFile *pNewEnum = NULL;

    if (ppEnum == NULL) {
        return E_POINTER;
    }

    try {
        *ppEnum = NULL;

        // Create new enumerator
        pNewEnum = new CImpIEnumLogFile;
        if ( NULL != pNewEnum ) {
            // Init, copy item list and current position
            pNewEnum->m_cItems = m_cItems;
            pNewEnum->m_uCurrent = m_uCurrent;
            pNewEnum->m_paLogFileItem = (PCLogFileItem*)malloc(sizeof(PCLogFileItem) * m_cItems);

            if ( NULL != pNewEnum->m_paLogFileItem ) {
                for (i=0; i<m_cItems; i++) {
                    pNewEnum->m_paLogFileItem[i] = m_paLogFileItem[i];
                }

                *ppEnum = pNewEnum;
            } else {
                hr = E_OUTOFMEMORY;
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    if (FAILED(hr) && pNewEnum != NULL) {
        if (pNewEnum->m_paLogFileItem != NULL) {
            free(pNewEnum->m_paLogFileItem);
        }

        delete pNewEnum;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\logsrc.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    logsrc.cpp

Abstract:

    <abstract>

--*/

#include "polyline.h"
#include <strsafe.h>
#include "unihelpr.h"
#include "logsrc.h"
#include "utils.h"

// Construction/Destruction
CLogFileItem::CLogFileItem (
    CSysmonControl  *pCtrl )
:   m_cRef ( 0 ),
    m_pCtrl ( pCtrl ),
    m_pImpIDispatch ( NULL ),
    m_pNextItem ( NULL ),
    m_szPath ( NULL )
/*++

Routine Description:

    Constructor for the CLogFileItem class. It initializes the member variables.

Arguments:

    None.

Return Value:

    None.

--*/
{
    return;
}


CLogFileItem::~CLogFileItem (
    VOID
)
/*++

Routine Description:

    Destructor for the CLogFileItem class. It frees any objects, storage, and
    interfaces that were created. If the item is part of a query it is removed
    from the query.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( NULL != m_szPath ) 
        delete [] m_szPath;
    
    if ( NULL != m_pImpIDispatch )
        delete m_pImpIDispatch;
}


HRESULT
CLogFileItem::Initialize (
    LPCWSTR pszPath,
    CLogFileItem** pListHead 
    )
{
    HRESULT hr = E_POINTER;
    WCHAR*  pszNewPath = NULL;
    ULONG   ulPathLen;

    if ( NULL != pszPath ) {
        if ( L'\0' != *pszPath ) {
            ulPathLen = lstrlen(pszPath) + 1;
            pszNewPath = new WCHAR [ulPathLen];

            if ( NULL != pszNewPath ) {
                StringCchCopy(pszNewPath, ulPathLen, pszPath);
                m_szPath = pszNewPath;
                hr = S_OK;
            } else {
                hr =  E_OUTOFMEMORY;
            }
        } else {
            hr = E_INVALIDARG;
        }
    } 

    if ( SUCCEEDED ( hr ) ) {
        m_pNextItem = *pListHead;
        *pListHead = this;
    }
    return hr;
}


/*
 * CLogFileItem::QueryInterface
 * CLogFileItem::AddRef
 * CLogFileItem::Release
 */

STDMETHODIMP CLogFileItem::QueryInterface(
    IN  REFIID riid,
    OUT LPVOID *ppv
    )
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        return E_POINTER;
    }

    try {
        *ppv = NULL;

        if (riid == IID_ILogFileItem || riid == IID_IUnknown) {
            *ppv = this;
        } else if (riid == DIID_DILogFileItem) {
            if (m_pImpIDispatch == NULL) {
                m_pImpIDispatch = new CImpIDispatch(this, this);
                if ( NULL != m_pImpIDispatch ) {
                    m_pImpIDispatch->SetInterface(DIID_DILogFileItem, this);
                    *ppv = m_pImpIDispatch;
                } else {
                    hr = E_OUTOFMEMORY;
                }
            } else {
                *ppv = m_pImpIDispatch;
            }
        } else {
            hr = E_NOINTERFACE;
        }

        if ( SUCCEEDED ( hr ) ) {
            ((LPUNKNOWN)*ppv)->AddRef();
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

STDMETHODIMP_(ULONG) CLogFileItem::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CLogFileItem::Release(void)
{
    if ( 0 == --m_cRef ) {
        delete this;
        return 0;
    }

    return m_cRef;
}



STDMETHODIMP CLogFileItem::get_Path (
    OUT BSTR* pstrPath
    )
{
    HRESULT hr = S_OK;

    if (pstrPath == NULL) {
        return E_POINTER;
    }

    try {
        *pstrPath = NULL;

        *pstrPath = SysAllocString ( m_szPath );

        if ( NULL == *pstrPath ) {
            hr = E_OUTOFMEMORY;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}

CLogFileItem*
CLogFileItem::Next (
    void )
{
    return m_pNextItem;
}

void 
CLogFileItem::SetNext (
    CLogFileItem* pNext )
{
    m_pNextItem = pNext;
}

LPCWSTR 
CLogFileItem::GetPath (
    void )
{
    return m_szPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\namenode.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    namenode.h

Abstract:

    <abstract>

--*/

#ifndef _NAMENODE_H_
#define _NAMENODE_H_

class CNamedNode
{
	friend class CNamedNodeList;

	protected:
		CNamedNode	*m_pnodeNext;

	public:
		CNamedNode() { m_pnodeNext = NULL; }
};

typedef CNamedNode *PCNamedNode;


//
// Class CNamedNodeList
//
class CNamedNodeList
{
	private:
		PCNamedNode	m_pnodeFirst;
		PCNamedNode m_pnodeLast;

	public:

		CNamedNodeList( void ) { m_pnodeFirst = m_pnodeLast = NULL; }

		BOOL FindByName ( LPCWSTR pszName, INT iNameOffset, PCNamedNode *ppnodeRet );
		void Add ( PCNamedNode pnodeNew, PCNamedNode pnodePos );
		void Remove ( PCNamedNode pnode );
		BOOL IsEmpty( void ) { return m_pnodeFirst == NULL; }
		CNamedNode *First ( void ) { return m_pnodeFirst; }
};

#endif //_NAMENODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\logsrc.h ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    logsrc.h

Abstract:

    <abstract>

--*/

#ifndef _LOGSRC_H_
#define _LOGSRC_H_

//
// Persistant data structure
//

typedef struct {
    INT   m_nPathLength;
} LOGFILE_DATA;

class CSysmonControl;
class CImpIDispatch;

//
// LogFileItem Class
// 
class CLogFileItem : public ILogFileItem
{

public:
                CLogFileItem ( CSysmonControl *pCtrl );
        virtual ~CLogFileItem ( void );

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // ILogFileItem methods
        STDMETHODIMP    get_Path ( BSTR* ) ;


        HRESULT Initialize ( LPCWSTR pszPath, CLogFileItem** ppListHead );
        
        CLogFileItem*   Next ( void );
        void            SetNext ( CLogFileItem* );

        LPCWSTR         GetPath ( void );

    private:
        
        class  CLogFileItem*    m_pNextItem;
        CSysmonControl* m_pCtrl;
        ULONG           m_cRef;
        CImpIDispatch*  m_pImpIDispatch;

        LPWSTR          m_szPath; 

};

typedef CLogFileItem* PCLogFileItem;

#endif // _LOGSRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\owndraw.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    owndraw.h

Abstract:

    Helper macros for owner draw controls.

--*/

#define DIWindow(lpDI)              \
   (lpDI->hwndItem)

#define DIIndex(lpDI)               \
   (lpDI->itemID)

#define DIEntire(lpDI)              \
   (lpDI->itemAction & ODA_DRAWENTIRE)

#define DIFocusChanged(lpDI)        \
   (lpDI->itemAction & ODA_FOCUS)

#define DISelectionChanged(lpDI)    \
   (lpDI->itemAction & ODA_SELECT)

#define DISelected(lpDI)            \
   (lpDI->itemState & ODS_SELECTED)

#define DIDisabled(lpDI)            \
   (lpDI->itemState & ODS_DISABLED)

#define DIFocus(lpDI)               \
   (lpDI->itemState & ODS_FOCUS)




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\namenode.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    namenode.cpp

Abstract:

    Implements the named data node list.

--*/

#include "wtypes.h"
#include "namenode.h"

BOOL
CNamedNodeList::FindByName (
    IN  LPCWSTR      pszName,
    IN  INT          iNameOffset,
    OUT PCNamedNode *ppnodeRet 
    )
{
    PCNamedNode pnodePrev = NULL;
    PCNamedNode pnode = m_pnodeFirst;
    INT iStat = 1;

    // search til match or insertion position found
    while (pnode != NULL && (iStat = lstrcmpi(pszName, (LPCWSTR)((CHAR*)pnode + iNameOffset))) > 0) {
        pnodePrev = pnode;
        pnode = pnode->m_pnodeNext;
    }

    // if match, return matched node
    if (iStat == 0) {
        *ppnodeRet = pnode;
        return TRUE;
    }
    // else return insertion point
    else {
        *ppnodeRet = pnodePrev;
        return FALSE;
    }
}

void
CNamedNodeList::Add (
    IN PCNamedNode pnodeNew,
    IN PCNamedNode pnodePos
    )
{
    // if position specified, insert after it
    if (pnodePos != NULL) {
        pnodeNew->m_pnodeNext = pnodePos->m_pnodeNext;
        pnodePos->m_pnodeNext = pnodeNew;
        if (pnodePos == m_pnodeLast)
            m_pnodeLast = pnodeNew;
    }
    // else place first in list
    else if (m_pnodeFirst != NULL) {
        pnodeNew->m_pnodeNext = m_pnodeFirst;
        m_pnodeFirst = pnodeNew;
    }
    else {
        m_pnodeFirst = pnodeNew;
        m_pnodeLast = pnodeNew;
    }
}


void
CNamedNodeList::Remove (
    IN PCNamedNode pnode
    )
{
    PCNamedNode pnodePrev = NULL;
    PCNamedNode pnodeTemp = m_pnodeFirst;

    while (pnodeTemp != NULL && pnodeTemp != pnode) {
        pnodePrev = pnodeTemp;
        pnodeTemp = pnodeTemp->m_pnodeNext;
    }

    if (pnodeTemp == NULL)
        return;

    if (pnodePrev)
        pnodePrev->m_pnodeNext  = pnode->m_pnodeNext;
    else
        m_pnodeFirst = pnode->m_pnodeNext;

    if (pnode == m_pnodeLast)
        m_pnodeLast = pnodePrev;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\polyline.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    polyline.cpp

Abstract:

    Implementation of the CPolyline class that is exposed as a
    component object.

--*/

#include "polyline.h"
#include "smonctrl.h"
#include "unihelpr.h"
#include "utils.h"

extern ITypeLib *g_pITypeLib;

/*
 * CPolyline:CPolyline
 * CPolyline::~CPolyline
 *
 * Constructor Parameters:
 *  pUnkOuter       LPUNKNOWN of the controlling unknown.
 *  pfnDestroy      PFNDESTROYED to call when an object is
 *                  destroyed.
 *  hInst           HINSTANCE of the application we're in.
 */

CPolyline::CPolyline (
    LPUNKNOWN pUnkOuter, 
    PFNDESTROYED pfnDestroy )
    :   m_cRef ( 0 ),
        m_pUnkOuter ( pUnkOuter ),
        m_pfnDestroy ( pfnDestroy ),
        m_fDirty ( FALSE ),
#ifdef  USE_SAMPLE_IPOLYLIN10
        m_pImpIPolyline ( NULL ),
#endif
        m_pImpIConnPtCont ( NULL ),
        m_cf    ( 0 ),
        m_clsID ( CLSID_SystemMonitor ),
        m_pIStorage ( NULL ),
        m_pIStream  ( NULL ),
        m_pImpIPersistStorage ( NULL ),
        m_pImpIPersistStreamInit ( NULL ),
        m_pImpIPersistPropertyBag ( NULL ),
        m_pImpIPerPropertyBrowsing ( NULL ),
        m_pImpIDataObject    ( NULL ),
        m_pImpIObjectSafety ( NULL ),
        m_pIDataAdviseHolder ( NULL ),
        m_pDefIUnknown        ( NULL ),
        m_pDefIDataObject     ( NULL ),
        m_pDefIViewObject     ( NULL ),
        m_pDefIPersistStorage ( NULL ),
        m_pIOleAdviseHolder  ( NULL ),
        m_pImpIOleObject     ( NULL ),
        m_pIOleClientSite    ( NULL ),
        m_pImpIViewObject    ( NULL ),
        m_pIAdviseSink       ( NULL ),
        m_dwFrozenAspects    ( 0 ),
        m_dwAdviseAspects    ( 0 ),
        m_dwAdviseFlags      ( 0 ),
        m_pImpIRunnableObject ( NULL ),
        m_bIsRunning  (  FALSE ),
//        m_pImpIExternalConnection ( NULL ),
        m_fLockContainer ( FALSE ),
        m_dwRegROT ( 0L ),
        m_pIOleIPSite ( NULL ),
        m_pIOleIPFrame ( NULL ),
        m_pIOleIPUIWindow ( NULL ),
        m_pImpIOleIPObject ( NULL ),
        m_pImpIOleIPActiveObject ( NULL ),
        m_hMenuShared ( NULL ),
        m_hOLEMenu ( NULL ),
        m_pHW ( NULL ),
        m_fAllowInPlace ( TRUE ),
        m_fUIActive ( FALSE ),
        m_fContainerKnowsInsideOut ( FALSE ),
        m_pImpISpecifyPP ( NULL ),
        m_pImpIProvideClassInfo ( NULL ),
        m_pImpIDispatch ( NULL ),
        m_pImpISystemMonitor ( NULL ),
        m_pImpIOleControl ( NULL ),
        m_pImpICounters ( NULL ),
        m_pImpILogFiles ( NULL ),
        m_pITypeLib ( NULL ),
        m_pIOleControlSite ( NULL ),
        m_pIDispatchAmbients ( NULL ),
        m_fFreezeEvents ( FALSE ),
        m_fHatch ( TRUE ),
        m_pCtrl ( NULL )
{
    // Set default extents
    SetRect(&m_RectExt, 0, 0, 300, 200);
    
    return;
}


CPolyline::~CPolyline(void)
{
    LPUNKNOWN  pIUnknown=this;

    if (NULL!=m_pUnkOuter)
        pIUnknown=m_pUnkOuter;

    if (NULL!=m_pHW) {
        delete m_pHW;
        m_pHW = NULL;
    }

    if (NULL != m_pCtrl) {
        delete m_pCtrl;
        m_pCtrl = NULL;
    }
    /*
     * In aggregation, release cached pointers but
     * AddRef the controlling unknown first.
     */

    pIUnknown->AddRef();
    pIUnknown->AddRef();
    pIUnknown->AddRef();

    ReleaseInterface(m_pDefIViewObject);
    ReleaseInterface(m_pDefIDataObject);
    ReleaseInterface(m_pDefIPersistStorage);

    //Cached pointer rules do not apply to IUnknown
    ReleaseInterface(m_pDefIUnknown);

    ReleaseInterface(m_pIAdviseSink);
    ReleaseInterface(m_pIOleClientSite);
    ReleaseInterface(m_pIOleAdviseHolder);

    DeleteInterfaceImp(m_pImpIOleObject);
    DeleteInterfaceImp(m_pImpIViewObject);
    DeleteInterfaceImp(m_pImpIRunnableObject);

    //Other in-place interfaces released in deactivation.
    DeleteInterfaceImp(m_pImpIOleIPObject);
    DeleteInterfaceImp(m_pImpIOleIPActiveObject);

    ReleaseInterface(m_pIDispatchAmbients);
    ReleaseInterface(m_pIOleControlSite);

    DeleteInterfaceImp(m_pImpISpecifyPP);
    DeleteInterfaceImp(m_pImpIProvideClassInfo);
    DeleteInterfaceImp(m_pImpIDispatch);
    DeleteInterfaceImp(m_pImpISystemMonitor);
    DeleteInterfaceImp(m_pImpIOleControl);
    DeleteInterfaceImp(m_pImpICounters);
    DeleteInterfaceImp(m_pImpILogFiles);

    //Anything we might have registered in IRunnableObject::Run
    if (m_dwRegROT != 0)
    {
        IRunningObjectTable    *pROT;

        if (!FAILED(GetRunningObjectTable(0, &pROT)))
        {
            pROT->Revoke(m_dwRegROT);   
            pROT->Release();
        }
    }

//    DeleteInterfaceImp(m_pImpIExternalConnection);
    ReleaseInterface(m_pIDataAdviseHolder);
    DeleteInterfaceImp(m_pImpIDataObject);
    DeleteInterfaceImp(m_pImpIObjectSafety);

    DeleteInterfaceImp(m_pImpIPersistStreamInit);
    DeleteInterfaceImp(m_pImpIPersistStorage);
    DeleteInterfaceImp(m_pImpIPersistPropertyBag);
    DeleteInterfaceImp(m_pImpIPerPropertyBrowsing);
    ReleaseInterface(m_pIStream);
    ReleaseInterface(m_pIStorage);

    DeleteInterfaceImp(m_pImpIConnPtCont);
#ifdef USE_SAMPLE_IPOLYLIN10
    DeleteInterfaceImp(m_pImpIPolyline);
#endif

    return;
}




/*
 * CPolyline::Init
 *
 * Purpose:
 *  Performs any intiailization of a CPolyline that's prone to
 *  failure that we also use internally before exposing the
 *  object outside this DLL.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  BOOL            TRUE if the function is successful,
 *                  FALSE otherwise.
 */

BOOL CPolyline::Init(void)
{
    LPUNKNOWN  pIUnknown=this;
    HRESULT    hr;
    INT        i;

    if (NULL!=m_pUnkOuter)
        pIUnknown=m_pUnkOuter;

    m_cf=(CLIPFORMAT)RegisterClipboardFormat(SZSYSMONCLIPFORMAT);

    m_pImpIPersistStorage=new CImpIPersistStorage(this, pIUnknown);

    if (NULL==m_pImpIPersistStorage)
        return FALSE;

    m_pImpIPersistStreamInit=new CImpIPersistStreamInit(this, pIUnknown);

    if (NULL==m_pImpIPersistStreamInit)
        return FALSE;

    m_pImpIPersistPropertyBag=new CImpIPersistPropertyBag(this, pIUnknown);

    if (NULL==m_pImpIPersistPropertyBag)
        return FALSE;

    m_pImpIPerPropertyBrowsing=new CImpIPerPropertyBrowsing(this, pIUnknown);

    if (NULL==m_pImpIPerPropertyBrowsing)
        return FALSE;

#ifdef USE_SAMPLE_IPOLYLIN10
    m_pImpIPolyline=new CImpIPolyline(this, pIUnknown);

    if (NULL==m_pImpIPolyline)
        return FALSE;
#endif

    m_pImpIConnPtCont=new CImpIConnPtCont(this, pIUnknown);

    if (NULL==m_pImpIConnPtCont)
        return FALSE;

    for (i=0; i<CONNECTION_POINT_CNT; i++) {
        if (!m_ConnectionPoint[i].Init(this, pIUnknown, i)) {
            return FALSE;
        }
    }

    m_pImpIDataObject=new CImpIDataObject(this, pIUnknown);

    if (NULL==m_pImpIDataObject)
        return FALSE;

    m_pImpIOleObject=new CImpIOleObject(this, pIUnknown);

    if (NULL==m_pImpIOleObject)
        return FALSE;

    m_pImpIViewObject=new CImpIViewObject(this, pIUnknown);

    if (NULL==m_pImpIViewObject)
        return FALSE;

    m_pImpIRunnableObject=new CImpIRunnableObject(this, pIUnknown);

    if (NULL==m_pImpIRunnableObject)
        return FALSE;

/***********************************
    m_pImpIExternalConnection=new CImpIExternalConnection(this
        , pIUnknown);

    if (NULL==m_pImpIExternalConnection)
        return FALSE;
************************************/

    m_pImpIOleIPObject=new CImpIOleInPlaceObject(this, pIUnknown);

    if (NULL==m_pImpIOleIPObject)
        return FALSE;

    m_pImpIOleIPActiveObject=new CImpIOleInPlaceActiveObject(this
        , pIUnknown);

    if (NULL==m_pImpIOleIPActiveObject)
        return FALSE;

    m_pImpISpecifyPP=new CImpISpecifyPP(this, pIUnknown);

    if (NULL==m_pImpISpecifyPP)
        return FALSE;

    m_pImpIProvideClassInfo=new CImpIProvideClassInfo(this, pIUnknown);

    if (NULL==m_pImpIProvideClassInfo)
        return FALSE;

    m_pImpISystemMonitor=new CImpISystemMonitor(this, pIUnknown);

    if (NULL==m_pImpISystemMonitor)
        return FALSE;

    m_pImpICounters = new CImpICounters(this, pIUnknown);

    if (NULL==m_pImpICounters)
        return FALSE;

    m_pImpILogFiles = new CImpILogFiles(this, pIUnknown);

    if (NULL==m_pImpILogFiles)
        return FALSE;

    m_pImpIDispatch=new CImpIDispatch(this, pIUnknown);

    if (NULL==m_pImpIDispatch)
        return FALSE;

    m_pImpIDispatch->SetInterface(DIID_DISystemMonitor, m_pImpISystemMonitor);

    m_pImpIOleControl=new CImpIOleControl(this, pIUnknown);

    if (NULL==m_pImpIOleControl)
        return FALSE;
 
    m_pImpIObjectSafety = new CImpIObjectSafety(this, pIUnknown);
    if (NULL == m_pImpIObjectSafety) {
        return FALSE;
    }

    m_pCtrl = new CSysmonControl(this);
    if (NULL==m_pCtrl)
        return FALSE;
    if ( !m_pCtrl->AllocateSubcomponents() )
        return FALSE;

    /*
     * We're sitting at ref count 0 and the next call will AddRef a
     * few times and Release a few times.  This insures we don't
     * delete ourselves prematurely.
     */
    m_cRef++;

    //
    // Aggregate OLE's cache for IOleCache* interfaces.
    //
    hr = CreateDataCache(pIUnknown, 
                      CLSID_SystemMonitor , 
                      IID_IUnknown, 
                      (PPVOID)&m_pDefIUnknown);

    if (FAILED(hr))
        return FALSE;

    /*
     * NOTE:  The spec specifically states that any interfaces
     * besides IUnknown that we obtain on an aggregated object
     * should be Released immediately after we QueryInterface for
     * them because the QueryInterface will AddRef us, and since
     * we would not release these interfaces until we were
     * destroyed, we'd never go away because we'd never get a zero
     * ref count.
     */

    //Now try to get other interfaces to which we delegate
    hr=m_pDefIUnknown->QueryInterface(IID_IViewObject2 , (PPVOID)&m_pDefIViewObject);

    if (FAILED(hr))
        return FALSE;

    pIUnknown->Release();

    hr=m_pDefIUnknown->QueryInterface(IID_IDataObject , (PPVOID)&m_pDefIDataObject);

    if (FAILED(hr))
        return FALSE;

    pIUnknown->Release();

    hr=m_pDefIUnknown->QueryInterface(IID_IPersistStorage , (PPVOID)&m_pDefIPersistStorage);

    if (FAILED(hr))
        return FALSE;

    pIUnknown->Release();

    m_cRef--;

#ifdef  USE_SAMPLE_IPOLYLIN10
    m_pImpIPolyline->New();
#endif

  
    /*
     * The type information lib already loaded in DllAttach
     * just use it.(AddRef on it is called in DllAttach)
     *
     */
    m_pITypeLib = g_pITypeLib;

    //Set up our CONTROLINFO structure (we have two mnemonics)
    m_ctrlInfo.cb=sizeof(CONTROLINFO);
    m_ctrlInfo.dwFlags=0;
    m_ctrlInfo.hAccel=NULL;
    m_ctrlInfo.cAccel=0;

    /*
     * Note:  we cannot initialize ambients until we get
     * a container interface pointer in IOleObject::SetClientSite.
     */

    return TRUE;
}



/*
 * CPolyline::QueryInterface
 * CPolyline::AddRef
 * CPolyline::Release
 *
 * Purpose:
 *  IUnknown members for CPolyline object.
 */

STDMETHODIMP CPolyline::QueryInterface(
    REFIID riid, 
    PPVOID ppv
    )
{
    HRESULT hr = S_OK;

    try {
        *ppv=NULL;

        if (IID_IUnknown==riid)
            *ppv=this;

        else if (IID_IConnectionPointContainer==riid)
            *ppv=m_pImpIConnPtCont;

        else if (IID_IPersistStorage==riid)
            *ppv=m_pImpIPersistStorage;

        else if (IID_IPersist==riid || IID_IPersistStream==riid
            || IID_IPersistStreamInit==riid)
            *ppv=m_pImpIPersistStreamInit;

        else if (IID_IPersistPropertyBag==riid )
            *ppv=m_pImpIPersistPropertyBag;

        else if (IID_IPerPropertyBrowsing==riid )
            *ppv=m_pImpIPerPropertyBrowsing;
    
        else if (IID_IDataObject==riid)
            *ppv=m_pImpIDataObject;

        else if (IID_IOleObject==riid)
            *ppv=m_pImpIOleObject;

        else if (IID_IViewObject==riid || IID_IViewObject2==riid)
            *ppv=m_pImpIViewObject;

        else if (IID_IRunnableObject==riid)
        //  *ppv=m_pImpIRunnableObject;
             return E_NOINTERFACE;

        else if (IID_IExternalConnection==riid)
//           *ppv=m_pImpIExternalConnection;
           return E_NOINTERFACE;

        //IOleWindow will be the InPlaceObject
        else if (IID_IOleWindow==riid || IID_IOleInPlaceObject==riid)
            *ppv=m_pImpIOleIPObject;

        // The OLE rule state that InPlaceActiveObject should not be
        // provided in response to a query, but the current MFC (4.0)
        // won't work if we don't do it.
        else if (IID_IOleInPlaceActiveObject==riid)
            *ppv=m_pImpIOleIPActiveObject;

        else if (IID_ISpecifyPropertyPages==riid)
            *ppv=m_pImpISpecifyPP;

        else if (IID_IProvideClassInfo==riid)
            *ppv=m_pImpIProvideClassInfo;

        else if (IID_IDispatch==riid || DIID_DISystemMonitor==riid) 
            *ppv=m_pImpIDispatch;

        else if (IID_ISystemMonitor==riid)
            *ppv=m_pImpISystemMonitor;

        else if (IID_IOleControl==riid)
            *ppv=m_pImpIOleControl;

        //Use the default handler's cache.
        else if (IID_IOleCache==riid || IID_IOleCache2==riid)
            return m_pDefIUnknown->QueryInterface(riid, ppv);
        else if (IID_IObjectSafety == riid) {
             *ppv = m_pImpIObjectSafety;
        }
        else {
            hr = E_NOINTERFACE;
        }

    } catch (...) {
        hr = E_POINTER;
    }

    assert ( NULL != *ppv );
    if (SUCCEEDED(hr) && NULL != *ppv ) {
        ((LPUNKNOWN)*ppv)->AddRef();
    }

    return hr;
}


STDMETHODIMP_(ULONG) CPolyline::AddRef(void)
    {
    return ++m_cRef;
    
    }


STDMETHODIMP_(ULONG) CPolyline::Release(void)
{
    if (0L!=--m_cRef)
        return m_cRef;

    // Prevent reentrant call
    m_cRef++;

    if (NULL!=m_pfnDestroy)
        (*m_pfnDestroy)();

    delete this;
    return 0L;
}

/*
 * CPolyline::RectConvertMappings
 *
 * Purpose:
 *  Converts the contents of a rectangle from device (MM_TEXT) or
 *  HIMETRIC to the other.
 *
 * Parameters:
 *  pRect           LPRECT containing the rectangle to convert.
 *  fToDevice       BOOL TRUE to convert from HIMETRIC to device,
 *                  FALSE to convert device to HIMETRIC.
 *
 * Return Value:
 *  None
 */

void
CPolyline::RectConvertMappings(
     LPRECT pRect, 
     BOOL fToDevice
     )
{
    HDC      hDC = NULL;
    INT      iLpx, iLpy;

    if ( NULL != pRect ) {

        hDC=GetDC(NULL);

        if ( NULL != hDC ) {
            iLpx=GetDeviceCaps(hDC, LOGPIXELSX);
            iLpy=GetDeviceCaps(hDC, LOGPIXELSY);
            
            ReleaseDC(NULL, hDC);

            if (fToDevice) {
                pRect->left=MulDiv(iLpx, pRect->left, HIMETRIC_PER_INCH);
                pRect->top =MulDiv(iLpy, pRect->top , HIMETRIC_PER_INCH);

                pRect->right =MulDiv(iLpx, pRect->right, HIMETRIC_PER_INCH);
                pRect->bottom=MulDiv(iLpy, pRect->bottom,HIMETRIC_PER_INCH);
            } else {
                if ( 0 != iLpx && 0 != iLpy ) {
                    pRect->left=MulDiv(pRect->left, HIMETRIC_PER_INCH, iLpx);
                    pRect->top =MulDiv(pRect->top , HIMETRIC_PER_INCH, iLpy);

                    pRect->right =MulDiv(pRect->right, HIMETRIC_PER_INCH, iLpx);
                    pRect->bottom=MulDiv(pRect->bottom,HIMETRIC_PER_INCH, iLpy);
                }
            }
        }
    }
    return;
}


/*
 * CPolyline::RenderBitmap
 *
 * Purpose:
 *  Creates a bitmap image of the current Polyline.
 *
 * Parameters:
 *  phBmp           HBITMAP * in which to return the bitmap.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, otherwise a
 *                  POLYLINE_E_ value.
 */

STDMETHODIMP 
CPolyline::RenderBitmap(
    HBITMAP *phBmp,
    HDC     hAttribDC 
    )
{
    //HDC             hDC;
    HRESULT         hr = NOERROR;
    HDC             hMemDC;
    HBITMAP         hBmp = NULL;
    RECT            rc;
    HGDIOBJ         hObj;
    HWND            hWnd;

    if (NULL==phBmp) {
        hr = E_POINTER;
    } else if ( NULL == hAttribDC ) {
        hr = E_INVALIDARG;
    } else {
        hWnd = m_pCtrl->Window();

        if ( NULL != hWnd ) {

            //Render a bitmap the size of the current rectangle.
        
            hMemDC = CreateCompatibleDC(hAttribDC);

            if ( NULL != hMemDC ) {
                GetClientRect(hWnd, &rc);
                hBmp = CreateCompatibleBitmap(hAttribDC, rc.right, rc.bottom);

                if (NULL!=hBmp) {
                    //Draw the control into the bitmap.
                    hObj = SelectObject(hMemDC, hBmp);
                    Draw(hMemDC, hAttribDC, FALSE, TRUE, &rc);
                    SelectObject(hMemDC, hObj);
                }

                DeleteDC(hMemDC);
                // ReleaseDC(hWnd, hDC);
            }
            *phBmp=hBmp;
            hr = NOERROR;
        } else {
            hr =  E_UNEXPECTED;
        }
    }
    return hr;
}



/*
 * CPolyline::RenderMetafilePict
 *
 * Purpose:
 *  Renders the current Polyline into a METAFILEPICT structure in
 *  global memory.
 *
 * Parameters:
 *  phMem           HGLOBAL * in which to return the
 *                  METAFILEPICT.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, otherwise a
 *                  POLYLINE_E_ value.
 */

STDMETHODIMP 
CPolyline::RenderMetafilePict(
    HGLOBAL *phMem,
    HDC hAttribDC 
    )
{
    HGLOBAL         hMem;
    HMETAFILE       hMF;
    LPMETAFILEPICT  pMF;
    RECT            rc;
    HDC             hDC;

    if (NULL==phMem)
        return E_POINTER;

    //Create a memory metafile and return its handle.
    hDC=(HDC)CreateMetaFile(NULL);

    if (NULL==hDC)
        return STG_E_MEDIUMFULL;

    SetMapMode(hDC, MM_ANISOTROPIC);

    //
    // Always set up the window extents to the real window size
    // so the drawing routines can work in their normal dev coords
    //
    /********* Use the extent rect, not the window rect *********/
    rc = m_RectExt;
    // GetClientRect(m_pCtrl->Window(), &rc);
    /************************************************************/

    Draw( hDC, hAttribDC, TRUE, TRUE, &rc );
  
    hMF=CloseMetaFile(hDC);

    if (NULL==hMF)
        return STG_E_MEDIUMFULL;

    //Allocate the METAFILEPICT structure.
    hMem=GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE
        , sizeof(METAFILEPICT));

    if (NULL==hMem)
        {
        DeleteMetaFile(hMF);
        return E_FAIL;
        }

    /*
     * Global lock only fails in PMODE if the selector is invalid
     * (like it was discarded) or references a 0 length segment,
     * neither of which can happen here.
     */
    pMF=(LPMETAFILEPICT)GlobalLock(hMem);

    pMF->hMF=hMF;
    pMF->mm=MM_ANISOTROPIC;

    //Insert the extents in MM_HIMETRIC units.

    /********* Use the extent rect, not the window rect *********/
    rc = m_RectExt;
    // GetClientRect(m_pCtrl->Window(), &rc);
    /************************************************************/

    RectConvertMappings(&rc, FALSE);
    pMF->xExt=rc.right;
    pMF->yExt=rc.bottom;

    GlobalUnlock(hMem);

    *phMem=hMem;
    return NOERROR;
    }


/*
 * CPolyline::SendAdvise
 *
 * Purpose:
 *  Calls the appropriate IOleClientSite or IAdviseSink member
 *  function for various events such as closure, renaming, etc.
 *
 * Parameters:
 *  uCode           UINT OBJECTCODE_* identifying the notification.
 *
 * Return Value:
 *  None
 */

void CPolyline::SendAdvise(UINT uCode)
{
    DWORD  dwAspect=DVASPECT_CONTENT | DVASPECT_THUMBNAIL;

    switch (uCode)
        {
        case OBJECTCODE_SAVED:
            if (NULL!=m_pIOleAdviseHolder)
                m_pIOleAdviseHolder->SendOnSave();
            break;

        case OBJECTCODE_CLOSED:
            if (NULL!=m_pIOleAdviseHolder)
                m_pIOleAdviseHolder->SendOnClose();

            break;

        case OBJECTCODE_RENAMED:
            //Call IOleAdviseHolder::SendOnRename (later)
            break;

        case OBJECTCODE_SAVEOBJECT:
            if (m_fDirty && NULL!=m_pIOleClientSite)
                m_pIOleClientSite->SaveObject();

            m_fDirty=FALSE;
            break;

        case OBJECTCODE_DATACHANGED:
            m_fDirty=TRUE;

            //No flags are necessary here.
            if (NULL!=m_pIDataAdviseHolder) {
                m_pIDataAdviseHolder->SendOnDataChange(m_pImpIDataObject, 0, 0);
            }

            if ( ( NULL!=m_pIAdviseSink ) & (dwAspect & m_dwAdviseAspects)) {
                m_pIAdviseSink->OnViewChange(dwAspect & m_dwAdviseAspects, 0);
            }

            break;

        case OBJECTCODE_SHOWWINDOW:
            if (NULL!=m_pIOleClientSite)
                m_pIOleClientSite->OnShowWindow(TRUE);

            break;

        case OBJECTCODE_HIDEWINDOW:
            if (NULL!=m_pIOleClientSite)
                m_pIOleClientSite->OnShowWindow(FALSE);

            break;

        case OBJECTCODE_SHOWOBJECT:
            if (NULL!=m_pIOleClientSite)
                m_pIOleClientSite->ShowObject();

            break;
        }

    return;
    }


/*
 * CPolyline::SendEvent
 *
 * Purpose:
 *  Send an event to all connection points.
 * 
 *
 * Parameters:
 *  uEventType      Event Type
 *  dwParam         Parameter to send with event.
 *
 * Return Value:
 *  None
 */

void CPolyline::SendEvent (
    IN UINT uEventType, 
    IN DWORD dwParam
    )
{
    INT i;

    // Don't send if container has frozen events
    if (m_fFreezeEvents)
        return;

    // Pass event to each connection point
    for (i=0; i<CONNECTION_POINT_CNT; i++) {
        m_ConnectionPoint[i].SendEvent(uEventType, dwParam);
    }
}


/*
 * CPolyline::InPlaceActivate
 *
 * Purpose:
 *  Goes through all the steps of activating the Polyline as an
 *  in-place object.
 *
 * Parameters:
 *  pActiveSite     LPOLECLIENTSITE of the active site we show in.
 *  fIncludeUI      BOOL controls whether we call UIActivate too.
 *
 * Return Value:
 *  HRESULT         Whatever error code is appropriate.
 */

HRESULT CPolyline::InPlaceActivate(
    LPOLECLIENTSITE pActiveSite, 
    BOOL fIncludeUI
    )
{
    HRESULT                 hr;
    HWND                    hWndSite;
    HWND                    hWndHW;
    HWND                    hWndCtrl;
    RECT                    rcPos;
    RECT                    rcClip;
    OLEINPLACEFRAMEINFO     frameInfo;

    if (NULL==pActiveSite)
        return E_POINTER;

    // If we already have a site, just handle UI 
    if (NULL != m_pIOleIPSite) {
        if (fIncludeUI) {
            UIActivate();
            SetFocus(m_pCtrl->Window());
        }

        return NOERROR;
    }


    // Initialization, obtaining interfaces, OnInPlaceActivate.
    hr=pActiveSite->QueryInterface(IID_IOleInPlaceSite, 
                                  (PPVOID)&m_pIOleIPSite);

    if (FAILED(hr))
        return hr;

    hr=m_pIOleIPSite->CanInPlaceActivate();

    if (NOERROR!=hr) {
        m_pIOleIPSite->Release();
        m_pIOleIPSite=NULL;
        return E_FAIL;
    }

    m_pIOleIPSite->OnInPlaceActivate();


    // Get the window context and create a window.
    m_pIOleIPSite->GetWindow(&hWndSite);
    frameInfo.cb=sizeof(OLEINPLACEFRAMEINFO);

    m_pIOleIPSite->GetWindowContext(&m_pIOleIPFrame, 
                                    &m_pIOleIPUIWindow, 
                                    &rcPos, 
                                    &rcClip, 
                                    &frameInfo);


    /*
     * Create the hatch window after we get a parent window.  We
     * could not create the hatch window sooner because had nothing
     * to use for the parent.
     */
    m_pHW=new CHatchWin();

    if (NULL==m_pHW) {
        InPlaceDeactivate();
        return E_OUTOFMEMORY;
    }

    if (!m_pHW->Init(hWndSite, ID_HATCHWINDOW, NULL)) {
        InPlaceDeactivate();
        return E_OUTOFMEMORY;
    }

    hr=m_pImpIRunnableObject->Run(NULL);

    // Move the hatch window to the container window.
    hWndHW = m_pHW->Window();
    SetParent(hWndHW, hWndSite);


    // Move the Polyline window from the hidden dialog to hatch window
    hWndCtrl = m_pCtrl->Window();

    m_pHW->HwndAssociateSet(hWndCtrl);
    m_pHW->ChildSet(hWndCtrl);
    m_pHW->RectsSet(&rcPos, &rcClip);   //Positions polyline

    ShowWindow(hWndHW, SW_SHOW);
    SendAdvise(OBJECTCODE_SHOWOBJECT);

    // Critical for accelerators to work initially.
    SetFocus(hWndCtrl);

    if (fIncludeUI)
        hr =  UIActivate();
    else
        hr = NOERROR;

    /*
     * Since we don't have an Undo while in-place, tell the continer
     * to free it's undo state immediately.
     */
    m_pIOleIPSite->DiscardUndoState();

    return hr;

    }


/*
 * CPolyline::InPlaceDeactivate
 *
 * Purpose:
 *  Reverses all the activation steps from InPlaceActivate.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  None
 */

void CPolyline::InPlaceDeactivate(void)
{
    UIDeactivate();

    if (NULL!=m_pHW)
    {
        ShowWindow(m_pHW->Window(), SW_HIDE);

        // Move the window to its foster home
        if (m_pCtrl->Window()) {
            SetParent(m_pCtrl->Window(), g_hWndFoster);
        }

        m_pHW->ChildSet(NULL);

        delete m_pHW;
        m_pHW=NULL;
    }

    ReleaseInterface(m_pIOleIPFrame);
    ReleaseInterface(m_pIOleIPUIWindow)

    if (NULL!=m_pIOleIPSite)
    {
        m_pIOleIPSite->OnInPlaceDeactivate();
        ReleaseInterface(m_pIOleIPSite);
    }

    return;
}


/*
 * CPolyline::UIActivate
 *
 * Purpose:
 *  Goes through all the steps of activating the user interface of
 *  Polyline as an in-place object.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or error code.
 */

HRESULT CPolyline::UIActivate(void)
{
    LPWSTR  szUserType;

    // If already UI active, just return
    if (m_fUIActive)
        return NOERROR;

    m_fUIActive = TRUE;

    // Show hatched border only if enabled
    if (m_fHatch)
        m_pHW->ShowHatch(TRUE);

    // Call IOleInPlaceSite::UIActivate
    if (NULL!=m_pIOleIPSite)
        m_pIOleIPSite->OnUIActivate();

    // Set the active object
    szUserType = ResourceString(IDS_USERTYPE);

    if (NULL != m_pIOleIPFrame)
        m_pIOleIPFrame->SetActiveObject(m_pImpIOleIPActiveObject, szUserType);

    if (NULL != m_pIOleIPUIWindow)
        m_pIOleIPUIWindow->SetActiveObject(m_pImpIOleIPActiveObject, szUserType);

    // Negotiate border space.  None needed.
    if (NULL != m_pIOleIPFrame)
        m_pIOleIPFrame->SetBorderSpace(NULL);

    if (NULL != m_pIOleIPUIWindow)
        m_pIOleIPUIWindow->SetBorderSpace(NULL);

    // Create the shared menu.  No items added.
    if (NULL != m_pIOleIPFrame)
        m_pIOleIPFrame->SetMenu(NULL, NULL, m_pCtrl->Window());

    return NOERROR;
}


/*
 * CPolyline::UIDeactivate
 *
 * Purpose:
 *  Reverses all the user interface activation steps from
 *  UIActivate.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  None
 */

void CPolyline::UIDeactivate(void)
{
    if (!m_fUIActive){
        return;
    }

    m_fUIActive=FALSE;

    // Hide hatched border if enabled
    if (m_fHatch && NULL != m_pHW ){
        m_pHW->ShowHatch(FALSE);
    }

    // Tell frame and UI Window we aren't active
    if (NULL!=m_pIOleIPFrame){
        m_pIOleIPFrame->SetActiveObject(NULL, NULL);
    }

    if (NULL!=m_pIOleIPUIWindow){
        m_pIOleIPUIWindow->SetActiveObject(NULL, NULL);
    }

    //We don't have any shared menu or tools to clean up.
    if (NULL!=m_pIOleIPSite){
        m_pIOleIPSite->OnUIDeactivate(FALSE);
    }
}


/*
 * AmbientGet
 *
 * Purpose:
 *  Retrieves a specific ambient property into a VARIANT.
 *
 * Parameters:
 *  dispID          DISPID of the property to retrieve.
 *  pva             VARIANT * to fill with the new value.
 *
 * Return value
 *  BOOL            TRUE if the ambient was retrieved, FALSE
 *                  otherwise.
 */

BOOL CPolyline::AmbientGet(DISPID dispID, VARIANT *pva)
{
    HRESULT         hr;
    DISPPARAMS      dp;

    if (NULL==pva)
        return FALSE;

    if (NULL==m_pIDispatchAmbients)
        return FALSE;

    SETNOPARAMS(dp);
    hr=m_pIDispatchAmbients->Invoke(dispID, 
                                   IID_NULL, 
                                   LOCALE_USER_DEFAULT, 
                                   DISPATCH_PROPERTYGET, 
                                   &dp, 
                                   pva, 
                                   NULL, 
                                   NULL);

    return SUCCEEDED(hr);
}


/*
 * AmbientsInitialize
 *
 * Purpose:
 *  Attempts to retrieve the container's ambient properties
 *  and initialize (or reinitialize) Polyline accordingly.
 *
 * Parameters:
 *  dwWhich         DWORD containing INITAMBIENT_... flags
 *                  describing which ambients to initialize.
 *                  This can be any combination.
 *
 * Return Value:
 *  None
 */

void CPolyline::AmbientsInitialize(DWORD dwWhich)
{
    VARIANT     va;
    LPFONT      pIFont,pIFontClone;
    LPFONTDISP  pIFontDisp;

    if (NULL == m_pIDispatchAmbients) {
        return;
    }

    /*
     * We need to retrieve these ambients into these variables:
     *
     *  Ambient Property:               Variable:
     *  -----------------------------------------------
     *  DISPID_AMBIENT_SHOWHATCHING     m_fHatch
     *  DISPID_AMBIENT_UIDEAD           m_fUIDead
     *  DISPID_AMBIENT_BACKCOLOR        m_pCtrl...
     *  DISPID_AMBIENT_FONT .....       m_pCtrl...
     *  DISPID_AMBIENT_FORECOLOR        m_pCtrl...
     *  DISPID_AMBIENT_APPEARANCE       m_pCtrl...
     *  DISPID_AMBIENT_USERMODE         m_pCtrl...
     */

    VariantInit(&va);

    if ((INITAMBIENT_SHOWHATCHING & dwWhich)
         &&AmbientGet(DISPID_AMBIENT_SHOWHATCHING, &va)) {

        m_fHatch=V_BOOL(&va);

        if (NULL != m_pHW)
            m_pHW->ShowHatch(m_fHatch && m_fUIActive);
    }

    if ((INITAMBIENT_UIDEAD & dwWhich)
         && AmbientGet(DISPID_AMBIENT_UIDEAD, &va)) {

        m_pCtrl->m_fUIDead = (BOOLEAN)V_BOOL(&va);
    }

    if ((INITAMBIENT_USERMODE & dwWhich)
         && AmbientGet(DISPID_AMBIENT_USERMODE, &va))   {

        m_pCtrl->m_fUserMode = (BOOLEAN)V_BOOL(&va);
    }

    if ((INITAMBIENT_APPEARANCE & dwWhich)
        && AmbientGet(DISPID_AMBIENT_APPEARANCE, &va)) {

        m_pCtrl->put_Appearance(V_I4(&va), TRUE);   
    }

    if ((INITAMBIENT_BACKCOLOR & dwWhich)
        && AmbientGet(DISPID_AMBIENT_BACKCOLOR, &va)) {

        m_pCtrl->put_BackPlotColor(V_I4(&va), TRUE);    
    }

    if ((INITAMBIENT_FORECOLOR & dwWhich)
        && AmbientGet(DISPID_AMBIENT_FORECOLOR, &va)) {

        m_pCtrl->put_FgndColor(V_I4(&va), TRUE);
    }

    if ((INITAMBIENT_FONT & dwWhich)
        && AmbientGet(DISPID_AMBIENT_FONT, &va)) {

        pIFontDisp = (LPFONTDISP)V_DISPATCH(&va);

        if (pIFontDisp != NULL) {

            if (SUCCEEDED(pIFontDisp->QueryInterface(IID_IFont, (PPVOID)&pIFont))) {

                if (SUCCEEDED(pIFont->Clone(&pIFontClone))) {
                    m_pCtrl->put_Font(pIFontClone, TRUE);
                    pIFontClone->Release();
                }
                pIFont->Release();
            }

            pIFontDisp->Release();
        }
    }

    if ((INITAMBIENT_RTL & dwWhich) 
        && AmbientGet( DISPID_AMBIENT_RIGHTTOLEFT, &va)) {
        m_pCtrl->m_fRTL = (BOOLEAN)V_BOOL(&va);
    }
}

void
CPolyline::Draw(
    HDC hDC,
    HDC hAttribDC,
    BOOL fMetafile,
    BOOL fEntire,
    LPRECT pRect)
{

    RECT rc;

    if (!fMetafile && !RectVisible(hDC, pRect))
        return;

    SetMapMode(hDC, MM_ANISOTROPIC);

    //
    // Always set up the window extents to the natural window size
    // so the drawing routines can work in their normal dev coords
    //

    // Use client rect vs. extent rect for Zoom calculation.
    // Zoom factor = prcPos / Extent, so pRect/ClientRect.


    /********* Use the extent rect, not the window rect *********/
    // Using rectExt makes Word printing correct at all zoom levels.
    rc = m_RectExt;
    // GetClientRect(m_pCtrl->Window(), &rc);
    /************************************************************/

    SetWindowOrgEx(hDC, 0, 0, NULL);
    SetWindowExtEx(hDC, rc.right, rc.bottom, NULL);

    SetViewportOrgEx(hDC, pRect->left, pRect->top, NULL);
    SetViewportExtEx(hDC, pRect->right - pRect->left,
                    pRect->bottom - pRect->top, NULL);

    m_pCtrl->InitView( g_hWndFoster);
    m_pCtrl->Render(hDC, hAttribDC, fMetafile, fEntire, &rc);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\polyline.h ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    polyline.h

Abstract:

    Definitions and function prototypes

--*/

#ifndef _POLYLINE_H_
#define _POLYLINE_H_


#define USE_SAMPLE_IPOLYLIN10

#define GUIDS_FROM_TYPELIB

//
// Define the macro so that we don't include StringCbXXXX functions
//
#define STRSAFE_NO_CB_FUNCTIONS

#include <windows.h>
#include <ole2.h>
#include <olectl.h>
#include <objsafe.h>
#include <tchar.h>
#include <assert.h>
#include <strsafe.h>

#ifdef INITGUIDS
#include <initguid.h>
#endif

#ifndef PPVOID
typedef LPVOID * PPVOID;
#endif

//
// ??? Why use this
//
#define CFSTR_EMBEDSOURCE       L"Embed Source"

//Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);

typedef enum {
    PSSTATE_UNINIT,     //Uninitialized
    PSSTATE_SCRIBBLE,   //Scribble
    PSSTATE_ZOMBIE,     //No scribble
    PSSTATE_HANDSOFF    //Hand-off
} PSSTATE;

//
//DeleteInterfaceImp calls 'delete' and NULLs the pointer
//
#define DeleteInterfaceImp(p)   \
{                               \
    if (NULL != p) {            \
        delete p;               \
        p = NULL;               \
    }                           \
}


//
// ReleaseInterface calls 'Release' method 
//
// TODO: Hong investigate all the places where ReleaseInterface is used.
//       And remove the "p = NULL" code.
//
#define ReleaseInterface(p)     \
{                               \
    if (NULL!=p) {              \
        p->Release();           \
        p = NULL;               \
    }                           \
}

//
// ClearInterface calls 'Release' method and NULLs the pointer
//
#define ClearInterface(p)       \
{                               \
    if (NULL != p) {            \
        p->Release();           \
        p = NULL;               \
    }                           \
}

#define SETNOPARAMS(dp) SETDISPPARAMS(dp, 0, NULL, 0, NULL)

//
//Macros for setting DISPPARAMS structures
//
#define SETDISPPARAMS(dp, numArgs, pvArgs, numNamed, pNamed) \
{                                    \
    (dp).cArgs  =numArgs;            \
    (dp).rgvarg = pvArgs;            \
    (dp).cNamedArgs = numNamed;      \
    (dp).rgdispidNamedArgs = pNamed; \
}


#include "isysmon.h"  //From MKTYPLIB

//
// Forward class declaration
//
class CPolyline;
class CImpIObjectSafety;
class CImpIPersistStorage;
class CImpIPersistStreamInit;
class CImpIPersistPropertyBag;
class CImpIPerPropertyBrowsing;
class CImpIDataObject;
class CImpIOleObject;
class CImpIViewObject;
class CImpIRunnableObject;
class CImpIExternalConnection;
class CImpIOleInPlaceObject;
class CImpIOleInPlaceActiveObject;
class CImpISpecifyPP;
class CImpIProvideClassInfo;
class CImpIDispatch;
class CImpISystemMonitor;
class CImpIOleControl;
class CAdviseRouter;
class CGraphItem;

#ifdef USE_SAMPLE_IPOLYLIN10
#include "ipoly10.h"
class CImpIPolyline;
typedef CImpIPolyline* PCImpIPolyline;
#endif


typedef class CPolyline *PCPolyline;
typedef class CImpIObjectSafety* PCImpIObjectSafety;
typedef class CImpIPersistStorage* PCImpIPersistStorage;
typedef class CImpIPersistStreamInit* PCImpIPersistStreamInit;
typedef class CImpIPersistPropertyBag* PCImpIPersistPropertyBag;
typedef class CImpIPerPropertyBrowsing* PCImpIPerPropertyBrowsing;
typedef class CImpIDataObject* PCImpIDataObject;
typedef class CEnumFormatEtc* PCEnumFormatEtc;
typedef class CImpIOleObject* PCImpIOleObject;
typedef class CImpIViewObject* PCImpIViewObject;
typedef class CImpIRunnableObject* PCImpIRunnableObject;
typedef class CImpIExternalConnection* PCImpIExternalConnection;
typedef class CImpIOleInPlaceObject* PCImpIOleInPlaceObject;
typedef class CImpIOleInPlaceActiveObject* PCImpIOleInPlaceActiveObject;
typedef class CImpISpecifyPP* PCImpISpecifyPP;
typedef class CImpIProvideClassInfo* PCImpIProvideClassInfo;
typedef class CImpIDispatch* PCImpIDispatch;
typedef class CImpISystemMonitor* PCImpISystemMonitor;
typedef class CImpIOleControl* PCImpIOleControl;
typedef class CGraphItem* PCGraphItem;

#include "resource.h"
#include "strids.h"
#include "iconnpt.h"
#include "graph.h"
#include "smonctrl.h"
#include "globals.h"
#include "utils.h"
#include "hatchwnd.h"
#include "logfiles.h"
#include "counters.h"

//
// SYSMON clipboard format
//
#define SZSYSMONCLIPFORMAT  TEXT("SYSTEM_MONITOR_CONFIGURATION")

//
//
//
#define LCID_SCRIPT         0x0409

//
// Stream Name that holds the data
//
#define SZSTREAM                    OLESTR("CONTENTS")

//
// Magic number to add to aspects returned from IViewObject::Freeze
//
#define FREEZE_KEY_OFFSET           0x0723

#define HIMETRIC_PER_INCH           2540
#define ID_HATCHWINDOW              2000


//
//This class factory object creates Polyline objects.
//
class CPolylineClassFactory : public IClassFactory
{
    protected:
        ULONG           m_cRef;

    public:
        CPolylineClassFactory(void);
        virtual ~CPolylineClassFactory(void);

        //IUnknown members
        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP  CreateInstance(LPUNKNOWN, REFIID, PPVOID);
        STDMETHODIMP  LockServer(BOOL);
};

typedef CPolylineClassFactory *PCPolylineClassFactory;



// Polyline Class
class CPolyline : public IUnknown
{
    friend LRESULT APIENTRY SysmonCtrlWndProc (HWND, UINT, WPARAM, LPARAM);

    friend class CImpIObjectSafety;
    friend class CImpIConnPtCont;
    friend class CImpIConnectionPoint;
    friend class CImpIPersistStorage;
    friend class CImpIPersistStreamInit;
    friend class CImpIPersistPropertyBag;
    friend class CImpIPerPropertyBrowsing;
    friend class CImpIDataObject;

    friend class CImpIOleObject;
    friend class CImpIViewObject;
    friend class CImpIRunnableObject;
    friend class CImpIExternalConnection;
    friend class CImpIOleInPlaceObject;
    friend class CImpIOleInPlaceActiveObject;
    friend class CSysmonControl;
    friend class CSysmonToolbar;
    friend class CGraphDisp;
    friend class CImpICounters;
    friend class CImpILogFiles;
    friend class CImpISpecifyPP;
    friend class CImpIProvideClassInfo;
    friend class CImpIDispatch;
    friend class CImpISystemMonitor;
    friend class CImpIOleControl;
    friend class CAdviseRouter;
#ifdef USE_SAMPLE_IPOLYLIN10
    friend class CImpIPolyline;
#endif

    protected:
        ULONG           m_cRef;         //Object reference count
        LPUNKNOWN       m_pUnkOuter;    //Controlling Unknown
        PFNDESTROYED    m_pfnDestroy;   //Function called on closure
        BOOL            m_fDirty;       //Have we changed?
        GRAPHDATA       m_Graph;        //Graph data
        PSYSMONCTRL     m_pCtrl;        //Sysmon Control object
        RECT            m_RectExt;      //Extent rectangle
        

        //Contained interfaces
#ifdef USE_SAMPLE_IPOLYLIN10
        PCImpIPolyline              m_pImpIPolyline;
#endif
        PCImpIConnPtCont            m_pImpIConnPtCont;
        PCImpIPersistStorage        m_pImpIPersistStorage;
        PCImpIPersistStreamInit     m_pImpIPersistStreamInit;
        PCImpIPersistPropertyBag    m_pImpIPersistPropertyBag;
        PCImpIPerPropertyBrowsing   m_pImpIPerPropertyBrowsing;
        PCImpIDataObject            m_pImpIDataObject;

        // Connection point holders (direct & dispatch)
        CImpIConnectionPoint    m_ConnectionPoint[CONNECTION_POINT_CNT]; 

        CLIPFORMAT      m_cf;           //Object clipboard format
        CLSID           m_clsID;        //Current CLSID

        //We have to hold these for IPersistStorage::Save
        LPSTORAGE       m_pIStorage;
        LPSTREAM        m_pIStream;

        LPDATAADVISEHOLDER  m_pIDataAdviseHolder;

        //These are default handler interfaces we use
        LPUNKNOWN           m_pDefIUnknown;
        LPVIEWOBJECT2       m_pDefIViewObject;
        LPPERSISTSTORAGE    m_pDefIPersistStorage;
        LPDATAOBJECT        m_pDefIDataObject;

        //Implemented and used interfaces
        PCImpIObjectSafety  m_pImpIObjectSafety;

        PCImpIOleObject     m_pImpIOleObject;       //Implemented
        LPOLEADVISEHOLDER   m_pIOleAdviseHolder;    //Used

        LPOLECLIENTSITE     m_pIOleClientSite;      //Used

        PCImpIViewObject    m_pImpIViewObject;      //Implemented
        LPADVISESINK        m_pIAdviseSink;         //Used
        DWORD               m_dwFrozenAspects;      //Freeze
        DWORD               m_dwAdviseAspects;      //SetAdvise
        DWORD               m_dwAdviseFlags;        //SetAdvise

        PCImpIRunnableObject m_pImpIRunnableObject; //Implemented
        BOOL                m_bIsRunning;           // Running?
        HWND                m_hDlg;                 //Editing window

//        PCImpIExternalConnection m_pImpIExternalConnection; //Implemented
        BOOL                     m_fLockContainer;
        DWORD                    m_dwRegROT;


        LPOLEINPLACESITE            m_pIOleIPSite;
        LPOLEINPLACEFRAME           m_pIOleIPFrame;
        LPOLEINPLACEUIWINDOW        m_pIOleIPUIWindow;

        PCImpIOleInPlaceObject       m_pImpIOleIPObject;
        PCImpIOleInPlaceActiveObject m_pImpIOleIPActiveObject;

        HMENU                       m_hMenuShared;
        HOLEMENU                    m_hOLEMenu;

        PCHatchWin                  m_pHW;
        BOOL                        m_fAllowInPlace;
        BOOL                        m_fUIActive;
        BOOL                        m_fContainerKnowsInsideOut;

        PCImpISpecifyPP             m_pImpISpecifyPP;
        PCImpIProvideClassInfo      m_pImpIProvideClassInfo;
        PCImpIDispatch              m_pImpIDispatch;
        PCImpISystemMonitor         m_pImpISystemMonitor;
        PCImpIOleControl            m_pImpIOleControl;
        PCImpICounters              m_pImpICounters;
        PCImpILogFiles              m_pImpILogFiles;

        //Our own type lib for the object
        ITypeLib                   *m_pITypeLib;

        //From the container;
        IOleControlSite            *m_pIOleControlSite;
        IDispatch                  *m_pIDispatchAmbients;
        BOOL                        m_fFreezeEvents;
        CONTROLINFO                 m_ctrlInfo;

        //Other ambients
        BOOL                        m_fHatch;

    protected:
        void      PointScale(LPRECT, LPPOINTS, BOOL);
        void      Draw(HDC, HDC, BOOL, BOOL, LPRECT);
        void      SendAdvise(UINT);
        void      SendEvent(UINT, DWORD);
        void      RectConvertMappings(LPRECT, BOOL);

        /*
         * These members pulled from IPolyline now serve as a
         * central store for this functionality to be used from
         * other interfaces like IPersistStorage and IDataObject.
         * Other interfaces later may also use them.
         */
        STDMETHODIMP RenderBitmap(HBITMAP *, HDC hAttribDC);
        STDMETHODIMP RenderMetafilePict(HGLOBAL *, HDC hAttribDC);


    public:
        static RegisterWndClass(HINSTANCE hInst);

        CPolyline(LPUNKNOWN, PFNDESTROYED);
        virtual ~CPolyline(void);

        BOOL      Init(void);

        //Non-delegating object IUnknown
        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        HRESULT  InPlaceActivate(LPOLECLIENTSITE, BOOL);
        void     InPlaceDeactivate(void);
        HRESULT  UIActivate(void);
        void     UIDeactivate(void);


        BOOL     AmbientGet(DISPID, VARIANT *);
        void     AmbientsInitialize(DWORD);
};



//Codes for CPolyline::SendAdvise
//......Code.....................Method called in CPolyline::SendAdvise
#define OBJECTCODE_SAVED       0 //IOleAdviseHolder::SendOnSave
#define OBJECTCODE_CLOSED      1 //IOleAdviseHolder::SendOnClose
#define OBJECTCODE_RENAMED     2 //IOleAdviseHolder::SendOnRename
#define OBJECTCODE_SAVEOBJECT  3 //IOleClientSite::SaveObject
#define OBJECTCODE_DATACHANGED 4 //IDataAdviseHolder::SendOnDataChange
#define OBJECTCODE_SHOWWINDOW  5 //IOleClientSite::OnShowWindow(TRUE)
#define OBJECTCODE_HIDEWINDOW  6 //IOleClientSite::OnShowWindow(FALSE)
#define OBJECTCODE_SHOWOBJECT  7 //IOleClientSite::ShowObject


//Flags for AmbientsInitialize
enum
    {
    INITAMBIENT_SHOWHATCHING = 0x00000001,
    INITAMBIENT_UIDEAD       = 0x00000002,
    INITAMBIENT_BACKCOLOR    = 0x00000004,
    INITAMBIENT_FORECOLOR    = 0x00000008,
    INITAMBIENT_FONT         = 0x00000010,
    INITAMBIENT_APPEARANCE   = 0x00000020,
    INITAMBIENT_USERMODE     = 0x00000040,
    INITAMBIENT_RTL          = 0x00000080,
    INITAMBIENT_ALL          = 0xFFFFFFFF
    };



#ifdef USE_SAMPLE_IPOLYLIN10
//
// Hong
//
//Interface implementation contained in the Polyline.

class CImpIPolyline : public IPolyline10
{
    protected:
        ULONG               m_cRef;      //Interface reference count
        PCPolyline          m_pObj;      //Back pointer to object
        LPUNKNOWN           m_pUnkOuter; //Controlling unknown

    public:
        CImpIPolyline(PCPolyline, LPUNKNOWN);
        virtual ~CImpIPolyline(void);

        //IUnknown members.
        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //Manipulation members:
        STDMETHODIMP Init(HWND, LPRECT, DWORD, UINT);
        STDMETHODIMP New(void);
        STDMETHODIMP Undo(void);
        STDMETHODIMP Window(HWND *);

        STDMETHODIMP RectGet(LPRECT);
        STDMETHODIMP SizeGet(LPRECT);
        STDMETHODIMP RectSet(LPRECT, BOOL);
        STDMETHODIMP SizeSet(LPRECT, BOOL);
};
typedef class CImpIPolyline* PCImpIPolyline;
#endif


class CImpIObjectSafety : public IObjectSafety
{
protected:
    ULONG        m_cRef;      //Interface reference count
    PCPolyline   m_pObj;      //Back pointer to object
    LPUNKNOWN    m_pUnkOuter; //Controlling unknown

private:
    BOOL         m_fMessageDisplayed;

    VOID SetupSecurityPolicy();
public:
    CImpIObjectSafety(PCPolyline, LPUNKNOWN);
    virtual ~CImpIObjectSafety(void);
    
    STDMETHODIMP QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP GetInterfaceSafetyOptions(REFIID riid, 
                                           DWORD* pdwSupportedOptions,
                                           DWORD* pdwEnabledOptions);
    STDMETHODIMP SetInterfaceSafetyOptions(REFIID riid,
                                      DWORD dwOptionSetMask,
                                      DWORD dwEnabledOptions);
};

class CImpIPersistStorage : public IPersistStorage
{
    protected:
        ULONG               m_cRef;      //Interface reference count
        PCPolyline          m_pObj;      //Back pointer to object
        LPUNKNOWN           m_pUnkOuter; //Controlling unknown
        PSSTATE             m_psState;   //Storage state

    public:
        CImpIPersistStorage(PCPolyline, LPUNKNOWN);
        virtual ~CImpIPersistStorage(void);

        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetClassID(LPCLSID);

        STDMETHODIMP IsDirty(void);
        STDMETHODIMP InitNew(LPSTORAGE);
        STDMETHODIMP Load(LPSTORAGE);
        STDMETHODIMP Save(LPSTORAGE, BOOL);
        STDMETHODIMP SaveCompleted(LPSTORAGE);
        STDMETHODIMP HandsOffStorage(void);
};


//IPERSTMI.CPP
class CImpIPersistStreamInit : public IPersistStreamInit
{
    protected:
        ULONG               m_cRef;      //Interface reference count
        PCPolyline          m_pObj;      //Back pointer to object
        LPUNKNOWN           m_pUnkOuter; //Controlling unknown

    public:
        CImpIPersistStreamInit(PCPolyline, LPUNKNOWN);
        virtual ~CImpIPersistStreamInit(void);

        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetClassID(LPCLSID);

        STDMETHODIMP IsDirty(void);
        STDMETHODIMP Load(LPSTREAM);
        STDMETHODIMP Save(LPSTREAM, BOOL);
        STDMETHODIMP GetSizeMax(ULARGE_INTEGER *);
        STDMETHODIMP InitNew(void);
};


//IPERPBAG.CPP
class CImpIPersistPropertyBag : public IPersistPropertyBag
{
    protected:
        ULONG               m_cRef;      //Interface reference count
        PCPolyline          m_pObj;      //Back pointer to object
        LPUNKNOWN           m_pUnkOuter; //Controlling unknown

    public:
        CImpIPersistPropertyBag(PCPolyline, LPUNKNOWN);
        virtual ~CImpIPersistPropertyBag(void);

        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetClassID(LPCLSID);

        STDMETHODIMP InitNew(void);
        STDMETHODIMP Load(IPropertyBag*, IErrorLog*);
        STDMETHODIMP Save(IPropertyBag*, BOOL, BOOL);
};

//IPRPBRWS.CPP
class CImpIPerPropertyBrowsing : public IPerPropertyBrowsing
{
    protected:
        ULONG               m_cRef;      //Interface reference count
        PCPolyline          m_pObj;      //Back pointer to object
        LPUNKNOWN           m_pUnkOuter; //Controlling unknown

    public:
        CImpIPerPropertyBrowsing(PCPolyline, LPUNKNOWN);
        virtual ~CImpIPerPropertyBrowsing(void);

        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetClassID(LPCLSID);

        STDMETHODIMP GetDisplayString( DISPID, BSTR* );
        STDMETHODIMP GetPredefinedStrings( DISPID, CALPOLESTR*, CADWORD* );
        STDMETHODIMP GetPredefinedValue( DISPID, DWORD, VARIANT* );
        STDMETHODIMP MapPropertyToPage( DISPID, CLSID* );
};

//IDATAOBJ.CPP
class CImpIDataObject : public IDataObject
{
    private:
        ULONG               m_cRef;      //Interface reference count
        PCPolyline          m_pObj;      //Back pointer to object
        LPUNKNOWN           m_pUnkOuter; //Controlling unknown

    public:
        CImpIDataObject(PCPolyline, LPUNKNOWN);
        virtual ~CImpIDataObject(void);

        //IUnknown members that delegate to m_pUnkOuter.
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IDataObject members
        STDMETHODIMP GetData(LPFORMATETC, LPSTGMEDIUM);
        STDMETHODIMP GetDataHere(LPFORMATETC, LPSTGMEDIUM);
        STDMETHODIMP QueryGetData(LPFORMATETC);
        STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC,LPFORMATETC);
        STDMETHODIMP SetData(LPFORMATETC, LPSTGMEDIUM, BOOL);
        STDMETHODIMP EnumFormatEtc(DWORD, LPENUMFORMATETC *);
        STDMETHODIMP DAdvise(LPFORMATETC, DWORD, LPADVISESINK
            , DWORD *);
        STDMETHODIMP DUnadvise(DWORD);
        STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *);
};



//IENUMFE.CPP
class CEnumFormatEtc : public IEnumFORMATETC
{
    private:
        ULONG           m_cRef;
        LPUNKNOWN       m_pUnkRef;
        ULONG           m_iCur;
        ULONG           m_cfe;
        LPFORMATETC     m_prgfe;

    public:
        CEnumFormatEtc(LPUNKNOWN, ULONG, LPFORMATETC);
        virtual ~CEnumFormatEtc(void);

        //IUnknown members that delegate to m_pUnkRef.
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IEnumFORMATETC members
        STDMETHODIMP Next(ULONG, LPFORMATETC, ULONG *);
        STDMETHODIMP Skip(ULONG);
        STDMETHODIMP Reset(void);
        STDMETHODIMP Clone(IEnumFORMATETC **);
};

//Our own properties verb
#define POLYLINEVERB_PROPERTIES     1

class CImpIOleObject : public IOleObject
{
    private:
        ULONG           m_cRef;
        PCPolyline      m_pObj;
        LPUNKNOWN       m_pUnkOuter;

        BOOL SafeForScripting();

    public:
        CImpIOleObject(PCPolyline, LPUNKNOWN);
        virtual ~CImpIOleObject(void);

        //IUnknown members that delegate to m_pUnkOuter.
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IOleObject members
        STDMETHODIMP SetClientSite(LPOLECLIENTSITE);
        STDMETHODIMP GetClientSite(LPOLECLIENTSITE *);
        STDMETHODIMP SetHostNames(LPCOLESTR, LPCOLESTR);
        STDMETHODIMP Close(DWORD);
        STDMETHODIMP SetMoniker(DWORD, LPMONIKER);
        STDMETHODIMP GetMoniker(DWORD, DWORD, LPMONIKER *);
        STDMETHODIMP InitFromData(LPDATAOBJECT, BOOL, DWORD);
        STDMETHODIMP GetClipboardData(DWORD, LPDATAOBJECT *);
        STDMETHODIMP DoVerb(LONG, LPMSG, LPOLECLIENTSITE, LONG
                         , HWND, LPCRECT);
        STDMETHODIMP EnumVerbs(LPENUMOLEVERB *);
        STDMETHODIMP Update(void);
        STDMETHODIMP IsUpToDate(void);
        STDMETHODIMP GetUserClassID(CLSID *);
        STDMETHODIMP GetUserType(DWORD, LPOLESTR *);
        STDMETHODIMP SetExtent(DWORD, LPSIZEL);
        STDMETHODIMP GetExtent(DWORD, LPSIZEL);
        STDMETHODIMP Advise(LPADVISESINK, DWORD *);
        STDMETHODIMP Unadvise(DWORD);
        STDMETHODIMP EnumAdvise(LPENUMSTATDATA *);
        STDMETHODIMP GetMiscStatus(DWORD, DWORD *);
        STDMETHODIMP SetColorScheme(LPLOGPALETTE);
};

//IVIEWOBJ.CPP
class CImpIViewObject : public IViewObject2
{
    private:
        ULONG       m_cRef;
        PCPolyline  m_pObj;
        LPUNKNOWN   m_pUnkOuter;

    public:
        CImpIViewObject(PCPolyline, LPUNKNOWN);
        virtual ~CImpIViewObject(void);

        //IUnknown members that delegate to m_pUnkOuter.
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IViewObject members
        STDMETHODIMP Draw(
            DWORD, 
            LONG, 
            LPVOID, 
            DVTARGETDEVICE *, 
            HDC, 
            HDC, 
            LPCRECTL, 
            LPCRECTL, 
            BOOL (CALLBACK *)(DWORD_PTR), 
            DWORD_PTR );

        STDMETHODIMP GetColorSet(DWORD, LONG, LPVOID
            , DVTARGETDEVICE *, HDC, LPLOGPALETTE *);
        STDMETHODIMP Freeze(DWORD, LONG, LPVOID, LPDWORD);
        STDMETHODIMP Unfreeze(DWORD);
        STDMETHODIMP SetAdvise(DWORD, DWORD, LPADVISESINK);
        STDMETHODIMP GetAdvise(LPDWORD, LPDWORD, LPADVISESINK *);
        STDMETHODIMP GetExtent(DWORD, LONG, DVTARGETDEVICE *, LPSIZEL);
};


class CImpIRunnableObject : public IRunnableObject
{
    protected:
        ULONG           m_cRef;
        PCPolyline      m_pObj;
        LPUNKNOWN       m_pUnkOuter;

    public:
        CImpIRunnableObject(PCPolyline, LPUNKNOWN);
        virtual ~CImpIRunnableObject(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetRunningClass(LPCLSID);
        STDMETHODIMP Run(LPBINDCTX);
        STDMETHODIMP_(BOOL) IsRunning(void);
        STDMETHODIMP LockRunning(BOOL, BOOL);
        STDMETHODIMP SetContainedObject(BOOL);
};


class CImpIExternalConnection : public IExternalConnection
{
    protected:
        ULONG           m_cRef;
        PCPolyline      m_pObj;
        LPUNKNOWN       m_pUnkOuter;
        DWORD           m_cLockStrong;

    public:
        CImpIExternalConnection(PCPolyline, LPUNKNOWN);
        virtual ~CImpIExternalConnection(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP_(DWORD) AddConnection(DWORD, DWORD);
        STDMETHODIMP_(DWORD) ReleaseConnection(DWORD, DWORD, BOOL);
};



class CImpIOleInPlaceObject : public IOleInPlaceObject
{
    protected:
        ULONG               m_cRef;
        PCPolyline          m_pObj;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIOleInPlaceObject(PCPolyline, LPUNKNOWN);
        virtual ~CImpIOleInPlaceObject(void);

        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetWindow(HWND *);
        STDMETHODIMP ContextSensitiveHelp(BOOL);
        STDMETHODIMP InPlaceDeactivate(void);
        STDMETHODIMP UIDeactivate(void);
        STDMETHODIMP SetObjectRects(LPCRECT, LPCRECT);
        STDMETHODIMP ReactivateAndUndo(void);
};



class CImpIOleInPlaceActiveObject
    : public IOleInPlaceActiveObject
{
    protected:
        ULONG               m_cRef;
        PCPolyline          m_pObj;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIOleInPlaceActiveObject(PCPolyline, LPUNKNOWN);
        virtual ~CImpIOleInPlaceActiveObject(void);

        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetWindow(HWND *);
        STDMETHODIMP ContextSensitiveHelp(BOOL);
        STDMETHODIMP TranslateAccelerator(LPMSG);
        STDMETHODIMP OnFrameWindowActivate(BOOL);
        STDMETHODIMP OnDocWindowActivate(BOOL);
        STDMETHODIMP ResizeBorder(LPCRECT, LPOLEINPLACEUIWINDOW
                         , BOOL);
        STDMETHODIMP EnableModeless(BOOL);
};



class CImpISpecifyPP : public ISpecifyPropertyPages
{
    protected:
        ULONG           m_cRef;      //Interface reference count
        PCPolyline      m_pObj;      //Backpointer to the object
        LPUNKNOWN       m_pUnkOuter; //For delegation

    public:
        CImpISpecifyPP(PCPolyline, LPUNKNOWN);
        virtual ~CImpISpecifyPP(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetPages(CAUUID *);
};



class CImpIProvideClassInfo : public IProvideClassInfo
{
    protected:
        ULONG           m_cRef;      //Interface reference count
        PCPolyline      m_pObj;      //Backpointer to the object
        LPUNKNOWN       m_pUnkOuter; //For delegation

    public:
        CImpIProvideClassInfo(PCPolyline, LPUNKNOWN);
        virtual ~CImpIProvideClassInfo(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetClassInfo(LPTYPEINFO *);
};



class CImpIDispatch : public IDispatch
{
    public:

    private:
        ULONG           m_cRef;     //For debugging
        LPUNKNOWN       m_pObj;
        LPUNKNOWN       m_pUnkOuter;
        LPUNKNOWN       m_pInterface;
        IID             m_DIID;
        ITypeInfo      *m_pITI;     //Type information

    public:
        CImpIDispatch(LPUNKNOWN, LPUNKNOWN);
        virtual ~CImpIDispatch(void);

        void SetInterface(REFIID, LPUNKNOWN);

        //IUnknown members that delegate to m_pUnkOuter.
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IDispatch members
        STDMETHODIMP GetTypeInfoCount(UINT *);
        STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
        STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID
            , DISPID *);
        STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD
            , DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);
};


class CImpISystemMonitor : public ISystemMonitor
{
    protected:
        ULONG               m_cRef;      //Interface reference count
        PCPolyline          m_pObj;      //Back pointer to object
        LPUNKNOWN           m_pUnkOuter; //Controlling unknown

    public:
        CImpISystemMonitor(PCPolyline, LPUNKNOWN);
        virtual ~CImpISystemMonitor(void);

        //IUnknown members.
        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //Manipulation members:
        STDMETHODIMP        put_Appearance(INT);
        STDMETHODIMP        get_Appearance(INT*);

        STDMETHODIMP        put_BackColor(OLE_COLOR);
        STDMETHODIMP        get_BackColor(OLE_COLOR*);

        STDMETHODIMP        put_BorderStyle(INT);
        STDMETHODIMP        get_BorderStyle(INT*);

        STDMETHODIMP        put_ForeColor(OLE_COLOR);
        STDMETHODIMP        get_ForeColor(OLE_COLOR*);

        STDMETHODIMP        put_BackColorCtl(OLE_COLOR);
        STDMETHODIMP        get_BackColorCtl(OLE_COLOR*);

        STDMETHODIMP        put_GridColor(OLE_COLOR);
        STDMETHODIMP        get_GridColor(OLE_COLOR*);

        STDMETHODIMP        put_TimeBarColor(OLE_COLOR);
        STDMETHODIMP        get_TimeBarColor(OLE_COLOR*);

        STDMETHODIMP        putref_Font(IFontDisp *pFont);
        STDMETHODIMP        get_Font(IFontDisp **ppFont);

        STDMETHODIMP        put_ShowVerticalGrid(VARIANT_BOOL);
        STDMETHODIMP        get_ShowVerticalGrid(VARIANT_BOOL*);

        STDMETHODIMP        put_ShowHorizontalGrid(VARIANT_BOOL);
        STDMETHODIMP        get_ShowHorizontalGrid(VARIANT_BOOL*);

        STDMETHODIMP        put_ShowLegend(VARIANT_BOOL);
        STDMETHODIMP        get_ShowLegend(VARIANT_BOOL*);

        STDMETHODIMP        put_ShowToolbar(VARIANT_BOOL);
        STDMETHODIMP        get_ShowToolbar(VARIANT_BOOL*);

        STDMETHODIMP        put_ShowValueBar(VARIANT_BOOL);
        STDMETHODIMP        get_ShowValueBar(VARIANT_BOOL*);

        STDMETHODIMP        put_ShowScaleLabels(VARIANT_BOOL);
        STDMETHODIMP        get_ShowScaleLabels(VARIANT_BOOL*);

        STDMETHODIMP        put_MaximumScale(INT);
        STDMETHODIMP        get_MaximumScale(INT*);

        STDMETHODIMP        put_MinimumScale(INT);
        STDMETHODIMP        get_MinimumScale(INT*);

        STDMETHODIMP        put_UpdateInterval(FLOAT);
        STDMETHODIMP        get_UpdateInterval(FLOAT*);

        STDMETHODIMP        put_DisplayFilter(INT);
        STDMETHODIMP        get_DisplayFilter(INT*);

        STDMETHODIMP        put_DisplayType(DisplayTypeConstants);
        STDMETHODIMP        get_DisplayType(DisplayTypeConstants*);

        STDMETHODIMP        put_ManualUpdate(VARIANT_BOOL);
        STDMETHODIMP        get_ManualUpdate(VARIANT_BOOL*);

        STDMETHODIMP        put_YAxisLabel(BSTR);
        STDMETHODIMP        get_YAxisLabel(BSTR*);

        STDMETHODIMP        put_GraphTitle(BSTR);
        STDMETHODIMP        get_GraphTitle(BSTR*);

        STDMETHODIMP        put_SqlDsnName(BSTR);
        STDMETHODIMP        get_SqlDsnName(BSTR*);
        STDMETHODIMP        put_SqlLogSetName(BSTR);
        STDMETHODIMP        get_SqlLogSetName(BSTR*);

        STDMETHODIMP        put_LogFileName(BSTR);
        STDMETHODIMP        get_LogFileName(BSTR*);

        STDMETHODIMP        get_LogFiles(ILogFiles**);

        STDMETHODIMP        put_DataSourceType(DataSourceTypeConstants);
        STDMETHODIMP        get_DataSourceType(DataSourceTypeConstants*);

        STDMETHODIMP        put_LogViewStart(DATE);
        STDMETHODIMP        get_LogViewStart(DATE*);

        STDMETHODIMP        put_LogViewStop(DATE);
        STDMETHODIMP        get_LogViewStop(DATE*);
        
        STDMETHODIMP        put_Highlight(VARIANT_BOOL);
        STDMETHODIMP        get_Highlight(VARIANT_BOOL*);

        STDMETHODIMP        put_ReadOnly(VARIANT_BOOL);
        STDMETHODIMP        get_ReadOnly(VARIANT_BOOL*);

        STDMETHODIMP        put_ReportValueType(ReportValueTypeConstants);
        STDMETHODIMP        get_ReportValueType(ReportValueTypeConstants*);

        STDMETHODIMP        put_MonitorDuplicateInstances(VARIANT_BOOL);
        STDMETHODIMP        get_MonitorDuplicateInstances(VARIANT_BOOL*);

        STDMETHODIMP        get_Counters(ICounters**);

        STDMETHODIMP        CollectSample(void);
        STDMETHODIMP        BrowseCounters(void);
        STDMETHODIMP        DisplayProperties(void);

        STDMETHODIMP        Counter(INT iIndex, ICounterItem**);
        STDMETHODIMP        AddCounter(BSTR bsPath, ICounterItem**);
        STDMETHODIMP        DeleteCounter(ICounterItem *pItem);

        STDMETHODIMP        LogFile ( INT iIndex, ILogFileItem** );
        STDMETHODIMP        AddLogFile ( BSTR bsPath, ILogFileItem** );
        STDMETHODIMP        DeleteLogFile ( ILogFileItem *pItem );

        STDMETHODIMP        UpdateGraph(void);
        STDMETHODIMP        Paste(void);
        STDMETHODIMP        Copy(void);
        STDMETHODIMP        Reset(void);

        // methods not exposed by ISystemMonitor
        HRESULT             SetLogFileRange(LONGLONG llBegin, LONGLONG LLEnd);
        HRESULT             GetLogFileRange(LONGLONG *pllBegin, LONGLONG *pLLEnd);

        HRESULT             SetLogViewTempRange(LONGLONG llStart, LONGLONG llStop);
        
        HRESULT             GetVisuals(
                                OLE_COLOR   *prgbColor,
                                INT         *piColorIndex, 
                                INT         *piWidthIndex, 
                                INT         *piStyleIndex);
        HRESULT             SetVisuals(
                                OLE_COLOR   rgbColor,
                                INT         iColorIndex, 
                                INT         iWidthIndex, 
                                INT         iStyleIndex);

        STDMETHODIMP        GetSelectedCounter(ICounterItem**);

        HLOG    GetDataSourceHandle ( void );
};


class CImpIOleControl : public IOleControl
{
    protected:
        ULONG           m_cRef;      //Interface reference count
        PCPolyline      m_pObj;      //Backpointer to the object
        LPUNKNOWN       m_pUnkOuter; //For delegation

    public:
        CImpIOleControl(PCPolyline, LPUNKNOWN);
        virtual ~CImpIOleControl(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetControlInfo(LPCONTROLINFO);
        STDMETHODIMP OnMnemonic(LPMSG);
        STDMETHODIMP OnAmbientPropertyChange(DISPID);
        STDMETHODIMP FreezeEvents(BOOL);
};


/*****************************************
class CAdviseRouter : public ISystemMonitorEvents
{
    private:
        ULONG       m_cRef;
        PCPolyline  m_pObj;
        IDispatch  *m_pIDispatch;

    public:
        CAdviseRouter(IDispatch *, PCPolyline);
        virtual ~CAdviseRouter(void);

        void Invoke(DISPID dispId, INT iParam);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //Advise members.
        STDMETHODIMP_(void) OnCounterSelected(INT iIndex);
        STDMETHODIMP_(void) OnCounterAdded(INT iIndex);
        STDMETHODIMP_(void) OnCounterDeleted(INT iIndex);
};

//These values match the ID's in smonctrl.odl
enum
    {
    EVENT_ONCOUNTERSELECTED=1,
    EVENT_ONCOUNTERADDED=2,
    EVENT_ONCOUNTERDELETED=3,
    };
***************************************/

#endif  //_POLYLINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\register.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    register.cpp

Abstract:

    Routines for registering and unregistering control

--*/

#include "polyline.h"
#include <strsafe.h>
#include "genprop.h"
#include "ctrprop.h"
#include "grphprop.h"
#include "srcprop.h"
#include "appearprop.h"
#include "unihelpr.h"
#include "cathelp.h"
#include "smonctrl.h"   // Version information

#define SYSMON_CONTROL_NAME    L"System Monitor Control"

#define MAX_KEY_LENGTH         256
#define MAX_GUID_STRING_LENGTH 39
#define VERSION_STRING_LENGTH  22
#define MISC_STATUS_VALUE L"131473"    // 131473 = 0x20191 = RECOMPOSEONRESIZE | CANTLINKINSIDE | INSIDEOUT
                                       //                     | ACTIVEWHENVISIBLE | SETCLIENTSITEFIRST

BOOL RegisterPropPage(const CLSID &clsid, LPWSTR szName, LPWSTR szModule);
void UnregisterPropPage(const CLSID &clsid);
BOOL CreateKeyAndValue(HKEY hKeyParent, LPWSTR pszKey, LPWSTR pszValue, HKEY* phKeyReturn, DWORD dwRegType);
LONG RegDeleteKeyTree(HKEY hStartKey, LPWSTR pKeyName);

/*
 * DllRegisterServer
 *
 * Purpose:
 *  Entry point to register the controls and prop pages
 *
 * NB. The module can only be registered iff it is in %SystemRoot%\system32 directory
 *
 */
STDAPI DllRegisterServer( VOID )
{
    HRESULT   hr = S_OK;
    OLECHAR   szGUID[MAX_GUID_STRING_LENGTH];
    WCHAR     szCLSID[MAX_KEY_LENGTH];
    WCHAR     szSysmonVer[64];
    HKEY      hKey,hSubkey;
    WCHAR     szVersion[VERSION_STRING_LENGTH + 1];
    LPWSTR    szModule = NULL;
    UINT      iModuleLen = 0;
    LPWSTR    szSystemPath = NULL;
    UINT      iSystemPathLen = 0;
    DWORD     dwReturn;
    BOOL      bResult;
    int       iRetry;
#ifdef _X86_
    BOOL      bWow64Process;
#endif

    //
    // Get system directory
    //
    iSystemPathLen = MAX_PATH + 12;
    iRetry = 4;
    do {
        // 
        // We also need to append "\sysmon.ocx" to the system path
        // So allocate an extra 12 characters for it.
        //
        szSystemPath = (LPWSTR)malloc(iSystemPathLen * sizeof(WCHAR));
        if (szSystemPath == NULL) {
            hr = E_OUTOFMEMORY;
            break;
        }

        dwReturn = GetSystemDirectory(szSystemPath, iSystemPathLen);
        if (dwReturn == 0) {
            hr = E_UNEXPECTED;
            break;
        }

        //
        // The buffer is not big enough, try to allocate a biggers one
        // and retry
        //
        if (dwReturn >= iSystemPathLen - 12) {
            iSystemPathLen = dwReturn + 12;
            free(szSystemPath);
            szSystemPath = NULL;
            hr = E_UNEXPECTED;
        }
        else {
            hr = S_OK;
            break;
        }
    } while (iRetry--);

    //
    // Get module file name
    //
    if (SUCCEEDED(hr)) {
        iRetry = 4;

        //
        // The length initialized to iModuleLen must be longer
        // than the length of "%systemroot%\\system32\\sysmon.ocx"
        //
        iModuleLen = MAX_PATH + 1;
        
        do {
            szModule = (LPWSTR) malloc(iModuleLen * sizeof(WCHAR));
            if (szModule == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            dwReturn = GetModuleFileName(g_hInstance, szModule, iModuleLen);
            if (dwReturn == 0) {
                hr = E_UNEXPECTED;
                break;
            }
            
            //
            // The buffer is not big enough, try to allocate a biggers one
            // and retry
            //
            if (dwReturn >= iModuleLen) {
                iModuleLen *= 2;
                free(szModule);
                szModule = NULL;
                hr = E_UNEXPECTED;
            }
            else {
                hr = S_OK;
                break;
            }

        } while (iRetry--);
    }

    if (FAILED(hr)) {
        goto CleanUp;
    }

    //
    // Check if we are in system directory, the control can be 
    // registered iff when it is system directory
    //
    StringCchCat(szSystemPath, iSystemPathLen, L"\\Sysmon.ocx");

    if (lstrcmpi(szSystemPath, szModule) != 0) {
#ifdef _X86_

        //
        // Lets try to see if this is a Wow64 process
        //

        if ((IsWow64Process (GetCurrentProcess(), &bWow64Process) == TRUE) &&
            (bWow64Process == TRUE))
        {

            int iLength = GetSystemWow64Directory (szSystemPath, iSystemPathLen);

            if (iLength > 0) {
                
                szSystemPath [iLength] = L'\\';
                if (lstrcmpi(szSystemPath, szModule) == 0) {
                    goto done;
                }
            }
        }
#endif
        hr = E_UNEXPECTED;
        goto CleanUp;
    }

#ifdef _X86_
done:
#endif
    //
    // We use REG_EXPAND_SZ type for module file name
    //
    StringCchCopy(szModule, iModuleLen, L"%systemroot%\\system32\\sysmon.ocx");

    //
    // Create Control CLSID string
    //
    StringFromGUID2(CLSID_SystemMonitor, 
                   szGUID, 
                   sizeof(szGUID)/sizeof(szGUID[0]));
    //
    // Create ProgID keys
    //
    StringCchPrintf( szSysmonVer, 
                      sizeof(szSysmonVer) / sizeof(szSysmonVer[0]),
                      L"Sysmon.%d", 
                      SMONCTRL_MAJ_VERSION );    

    bResult = TRUE;

    if (CreateKeyAndValue(HKEY_CLASSES_ROOT, szSysmonVer, SYSMON_CONTROL_NAME, &hKey, REG_SZ)) {
        if (!CreateKeyAndValue(hKey, L"CLSID", szGUID, NULL, REG_SZ)) {
            bResult = FALSE;
        }

        if (!CreateKeyAndValue(hKey, L"Insertable", NULL, NULL, REG_SZ)) {
            bResult = FALSE;
        }

        RegCloseKey(hKey);
    }
    else {
        bResult = FALSE;
    }
    
    //
    // Create VersionIndependentProgID keys
    //
    if (CreateKeyAndValue(HKEY_CLASSES_ROOT, L"Sysmon", SYSMON_CONTROL_NAME, &hKey, REG_SZ)) {

        if (!CreateKeyAndValue(hKey, L"CurVer", szSysmonVer, NULL, REG_SZ)) {
            bResult = FALSE;
        }

        if (!CreateKeyAndValue(hKey, L"CLSID",  szGUID, NULL, REG_SZ)) {
            bResult = FALSE;
        }
       
        RegCloseKey(hKey);
    }
    else {
        bResult = FALSE;
    }

    //
    // Create entries under CLSID
    //
    StringCchPrintf( szVersion, 
                      VERSION_STRING_LENGTH,
                      L"%d.%d", 
                      SMONCTRL_MAJ_VERSION, 
                      SMONCTRL_MIN_VERSION );    

    StringCchCopy(szCLSID, MAX_KEY_LENGTH, L"CLSID\\");
    StringCchCat(szCLSID, MAX_KEY_LENGTH, szGUID);

    if (CreateKeyAndValue(HKEY_CLASSES_ROOT, szCLSID, SYSMON_CONTROL_NAME, &hKey, REG_SZ)) {

        if (!CreateKeyAndValue(hKey, L"ProgID", szSysmonVer,   NULL, REG_SZ)) {
            bResult = FALSE;
        }
        if (!CreateKeyAndValue(hKey, L"VersionIndependentProgID", L"Sysmon", NULL, REG_SZ)) {
            bResult = FALSE;
        }
        if (!CreateKeyAndValue(hKey, L"Insertable", NULL, NULL, REG_SZ)) {
            bResult = FALSE;
        }
        if (!CreateKeyAndValue(hKey, L"Control", NULL, NULL, REG_SZ)) {
            bResult = FALSE;
        }
        if (!CreateKeyAndValue(hKey, L"MiscStatus\\1",  MISC_STATUS_VALUE,  NULL, REG_SZ)) {
            bResult = FALSE;
        }
        if (!CreateKeyAndValue(hKey, L"Version", szVersion, NULL, REG_SZ)) {
            bResult = FALSE;
        }

        //
        // Create InprocServer32 key and add ThreadingModel value
        //
        if (CreateKeyAndValue(hKey, L"InprocServer32", szModule, &hSubkey, REG_EXPAND_SZ)) {
            if (RegSetValueEx(hSubkey, 
                              L"ThreadingModel", 
                              0, 
                              REG_SZ, 
                              (BYTE *)L"Apartment", 
                              (DWORD)(lstrlenW(L"Apartment") + 1)*sizeof(WCHAR) ) != ERROR_SUCCESS) {
               bResult = FALSE;
            }

            RegCloseKey(hSubkey);
        }       
        else {
            bResult = FALSE;
        }

        //
        // Create AuxUserType key and add short display name (2) value 
        //
        if (!CreateKeyAndValue(hKey, L"AuxUserType\\2", L"System Monitor", NULL, REG_SZ)) {
            bResult = FALSE;
        }

        //
        // Create Typelib entry
        //
        StringFromGUID2(LIBID_SystemMonitor, szGUID, sizeof(szGUID)/sizeof(szGUID[0]));
        if (!CreateKeyAndValue(hKey, L"TypeLib", szGUID, NULL, REG_SZ)) {
            bResult = FALSE;
        }

        RegCloseKey(hKey);
    }

    //
    // Create type library entries under Typelib
    //
    StringCchCopy(szCLSID, MAX_KEY_LENGTH, L"TypeLib\\");
    StringCchCat(szCLSID, MAX_KEY_LENGTH, szGUID);
    StringCchCat(szCLSID, MAX_KEY_LENGTH, L"\\");
    StringCchCat(szCLSID, MAX_KEY_LENGTH, szVersion);

    if (CreateKeyAndValue(HKEY_CLASSES_ROOT, szCLSID, SYSMON_CONTROL_NAME, &hKey, REG_SZ)) {

        if (!CreateKeyAndValue(hKey, L"0\\win32", szModule, NULL, REG_EXPAND_SZ)) {
            bResult = FALSE;
        }

        RegCloseKey(hKey);
    }
    else {
        bResult = FALSE;
    }

    //
    // Register property pages
    //
    if (!RegisterPropPage(CLSID_CounterPropPage,
                         L"System Monitor Data Properties", szModule)) {
        bResult = FALSE;
    }
                     
    if (!RegisterPropPage(CLSID_GeneralPropPage,
                          L"System Monitor General Properties", szModule)) {
        bResult = FALSE;
    }

    if (!RegisterPropPage(CLSID_AppearPropPage,
                          L"System Monitor Appearance Properties", szModule)) {
        bResult = FALSE;
    }

    if (!RegisterPropPage(CLSID_GraphPropPage,
                          L"System Monitor Graph Properties", szModule)) {
        bResult = FALSE;
    }

    if (!RegisterPropPage(CLSID_SourcePropPage,
                          L"System Monitor Source Properties", szModule)) {
        bResult = FALSE;
    }

    //
    // Delete component categories if they are there
    //
    UnRegisterCLSIDInCategory(CLSID_SystemMonitor, CATID_SafeForScripting);
    UnRegisterCLSIDInCategory(CLSID_SystemMonitor, CATID_SafeForInitializing);


    if (!bResult) {
        hr = E_UNEXPECTED;
    }

CleanUp:
    if (szSystemPath) {
        free(szSystemPath);
    }
    if (szModule) {
        free(szModule);
    }

    return hr;
}



/* 
 *     RegisterPropPage - Create registry entries for property page 
 */
BOOL
RegisterPropPage(
    const CLSID &clsid, 
    LPWSTR szName, 
    LPWSTR szModule
    )
{
    OLECHAR   szGUID[MAX_GUID_STRING_LENGTH];
    WCHAR     szKey[MAX_KEY_LENGTH];
    HKEY      hKey,hSubkey;
    BOOL      bReturn = FALSE;

    //Create Counter Property page CLSID string
    StringFromGUID2(clsid, szGUID, sizeof(szGUID)/sizeof(szGUID[0]));

    StringCchCopy(szKey, MAX_KEY_LENGTH, L"CLSID\\");
    StringCchCat(szKey, MAX_KEY_LENGTH, szGUID);

    // Create entries under CLSID
    if (CreateKeyAndValue(HKEY_CLASSES_ROOT, szKey, szName, &hKey, REG_SZ)) {

        // Create InprocServer32 key and add ThreadingModel value
        if (CreateKeyAndValue(hKey, L"InprocServer32", szModule, &hSubkey, REG_EXPAND_SZ)) {
            if (RegSetValueEx(hSubkey, 
                              L"ThreadingModel", 
                              0, 
                              REG_SZ, 
                              (BYTE *)L"Apartment", 
                              (DWORD)(lstrlenW(L"Apartment") + 1)*sizeof(WCHAR) ) == ERROR_SUCCESS) {
                bReturn = TRUE;
            }

            RegCloseKey(hSubkey);
        }
        
        RegCloseKey(hKey);
    }

    return bReturn;
}


/*
 * DllUnregisterServer
 *
 * Purpose:
 *  Entry point to unregister controls and prop pages 
 */
STDAPI DllUnregisterServer(VOID)
{
    OLECHAR  szGUID[MAX_GUID_STRING_LENGTH];
    WCHAR    szCLSID[MAX_KEY_LENGTH];
    WCHAR    szSysmonVer[64];

    // Create graph CLSID
    StringFromGUID2(CLSID_SystemMonitor, szGUID, sizeof(szGUID)/sizeof(szGUID[0]));
    StringCchCopy(szCLSID, MAX_KEY_LENGTH, L"CLSID\\");
    StringCchCat(szCLSID, MAX_KEY_LENGTH, szGUID);

    // Delete component categories 
    UnRegisterCLSIDInCategory(CLSID_SystemMonitor, CATID_SafeForScripting);
    UnRegisterCLSIDInCategory(CLSID_SystemMonitor, CATID_SafeForInitializing);

    // Delete ProgID and VersionIndependentProgID keys and subkeys
    StringCchPrintf( szSysmonVer, 
                     sizeof(szSysmonVer) / sizeof(szSysmonVer[0]),
                     L"Sysmon.%d", 
                     SMONCTRL_MAJ_VERSION );    

    RegDeleteKeyTree(HKEY_CLASSES_ROOT, L"Sysmon");
    RegDeleteKeyTree(HKEY_CLASSES_ROOT, szSysmonVer);

    // Delete Program ID of Beta 3 control.
    RegDeleteKeyTree(HKEY_CLASSES_ROOT, L"Sysmon.2");

    // Delete entries under CLSID
    RegDeleteKeyTree(HKEY_CLASSES_ROOT, szCLSID);

    // Delete entries under TypeLib
    StringFromGUID2(LIBID_SystemMonitor, szGUID, sizeof(szGUID)/sizeof(szGUID[0]));
    StringCchCopy(szCLSID, MAX_KEY_LENGTH, L"TypeLib\\");
    StringCchCat(szCLSID, MAX_KEY_LENGTH, szGUID);

    RegDeleteKeyTree(HKEY_CLASSES_ROOT, szCLSID);
    
    // Delete property page entries
    UnregisterPropPage(CLSID_CounterPropPage);
    UnregisterPropPage(CLSID_GraphPropPage);
    UnregisterPropPage(CLSID_AppearPropPage);
    UnregisterPropPage(CLSID_GeneralPropPage);
    UnregisterPropPage(CLSID_SourcePropPage);

    return S_OK;
}


/* 
    UnregisterPropPage - Delete registry entries for property page 
*/
void UnregisterPropPage(const CLSID &clsid)
{
    OLECHAR  szGUID[MAX_GUID_STRING_LENGTH];
    WCHAR    szCLSID[MAX_KEY_LENGTH];

     // Create Counter Property page CLSID string
    StringFromGUID2(clsid, szGUID, sizeof(szGUID)/sizeof(szGUID[0]));

    StringCchCopy(szCLSID, MAX_KEY_LENGTH, L"CLSID\\");

    StringCchCat(szCLSID, MAX_KEY_LENGTH, szGUID);

    // Delete entries under CLSID
    RegDeleteKeyTree(HKEY_CLASSES_ROOT, szCLSID);
}


/*
 * CreateKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates a key
 *  and optionally sets a value. The caller may request the return of
 *  the key handle, or have it automatically closed
 *
 * Parameters:
 *  hKeyParent      HKEY of parent for the new key
 *  pszSubkey       LPWSTR to the name of the key
 *  pszValue        LPWSTR to the value to store (or NULL)
 *  hKeyReturn      Pointer to returned key handle (or NULL to close key)
 *  dwRegType       The type of value
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 */

BOOL 
CreateKeyAndValue(
    HKEY hKeyParent, 
    LPWSTR pszKey, 
    LPWSTR pszValue, 
    HKEY *phKeyReturn,
    DWORD dwRegType
    )
{
    HKEY  hKey;
    LONG  lReturn;

    lReturn = RegCreateKeyEx(hKeyParent, 
                             pszKey, 
                             0, 
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS, 
                             NULL, 
                             &hKey, 
                             NULL);
    if (lReturn != ERROR_SUCCESS) {
        return FALSE;
    }

    if (NULL != pszValue) {
        lReturn = RegSetValueEx(hKey, 
                                NULL, 
                                0, 
                                dwRegType, 
                                (BYTE *)pszValue , 
                                (lstrlen(pszValue)+1) * sizeof(WCHAR));
        if (lReturn != ERROR_SUCCESS) {
            RegCloseKey(hKey);
            return FALSE;
        }
    }

    if (phKeyReturn == NULL) {
        RegCloseKey(hKey);
    }
    else {
        *phKeyReturn = hKey;
    }

    return TRUE;
}


/*
 * RegDeleteKeyTree
 *
 * Purpose:
 *  This function recursively deletes all the subkeys of a registry key
 *  then deletes the key itself.
 *
 * Parameters:
 *  hStartKey       Handle to key containing key to delete
 *  pszSubkey       Name of root of key tree to delete
 *
 * Return Value:
 *  DWORD            Error code
 *
 *
 *  BUGBUG: The recursive function should be encouraged here.
 *          It is even worse when you have a huge local variable.
 *          Probably a DSP is encouraged here.
 */

LONG 
RegDeleteKeyTree( 
    HKEY hStartKey, 
    LPWSTR pKeyName 
    )
{
    DWORD   lReturn, dwSubKeyLength;
    WCHAR   szSubKey[MAX_KEY_LENGTH];
    HKEY    hKey;
 
    if (pKeyName != NULL && pKeyName[0] != 0) {
        lReturn = RegOpenKeyEx(hStartKey, 
                               pKeyName,
                               0, 
                               KEY_ENUMERATE_SUB_KEYS | DELETE, 
                               &hKey );
 
        if (lReturn == ERROR_SUCCESS) {
            while (lReturn == ERROR_SUCCESS) {
 
                 dwSubKeyLength = MAX_KEY_LENGTH;
                 lReturn = RegEnumKeyEx(
                                hKey,
                                0,       // always index zero
                                szSubKey,
                                &dwSubKeyLength,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                              );
  
                 if (lReturn == ERROR_NO_MORE_ITEMS) {
                    lReturn = RegDeleteKey(hStartKey, pKeyName);
                    break;
                 }
                 else if (lReturn == ERROR_SUCCESS) {
                    lReturn = RegDeleteKeyTree(hKey, szSubKey);
                 }
             }
 
             RegCloseKey(hKey);
        }
    }
    else {
        lReturn = ERROR_BADKEY;
    }

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\report.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    report.cpp

Abstract:

    Implements the report view.

--*/

//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include "polyline.h"
#include <strsafe.h>
#include <commctrl.h>
#include <pdhmsg.h>
#include "report.h"
#include "grphitem.h"
#include "winhelpr.h"

#define eScaleValueSpace        L">9999999999.0"
#define szReportClass           L"SysmonReport"
#define szReportClassA          "SysmonReport"
#define HEXMASK                 (0x00030C00)
static INT  xBorderWidth = GetSystemMetrics(SM_CXBORDER);
static INT  yBorderHeight = GetSystemMetrics(SM_CYBORDER);
static INT  xColumnMargin = 10;
static INT  xCounterMargin = 50;
static INT  xObjectMargin = 25;

static WCHAR   LineEndStr[] = L"\n" ;
static WCHAR   TabStr[] = L"\t";

LRESULT APIENTRY HdrWndProc (HWND, WORD, WPARAM, LONG);
 
//==========================================================================//
//                                  Constants                               //
//==========================================================================//

#define dwReportClassStyle     (CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS)
#define iReportWindowExtra     (sizeof (PREPORT))
#define dwReportWindowStyle    (WS_CHILD | WS_HSCROLL | WS_VSCROLL) 

#define szValuePlaceholder          L"-999,999,999.999"
#define szValueLargeHexPlaceholder  L" xBBBBBBBBDDDDDDDD"

#define dLargeValueMax              ((double) 999999999.0)
#define szDashLine                  L"---"

CReport::CReport (
    void
    )
{
    m_pCtrl = NULL;
    m_hWnd = NULL;
    m_yLineHeight = 0;
    m_xReportWidth = 0;
    m_yReportHeight = 0;
    m_pSelect = NULL;
}

//
// Destructor
//
CReport::~CReport (void )
{
    if (m_hWnd != NULL && IsWindow(m_hWnd))
        DestroyWindow(m_hWnd);
}

//
// Initialization
//
BOOL CReport::Init ( PSYSMONCTRL pCtrl, HWND hWndParent )
   {
   WNDCLASS       wc ;
   LONG     lExStyles;

    // Save pointer to parent control
    m_pCtrl = pCtrl;

    BEGIN_CRITICAL_SECTION

    // Register window class once
    if (pstrRegisteredClasses[REPORT_WNDCLASS] == NULL) {
    
        wc.style          = dwReportClassStyle ;
        wc.lpfnWndProc    = ReportWndProc ;
        wc.hInstance      = g_hInstance ;
        wc.cbClsExtra     = 0;
        wc.cbWndExtra     = iReportWindowExtra ;
        wc.hIcon          = NULL ;
        wc.hCursor        = LoadCursor (NULL, IDC_ARROW) ;
        wc.hbrBackground  = NULL ;
        wc.lpszMenuName   = NULL ;
        wc.lpszClassName  = szReportClass ;

        if (RegisterClass (&wc)) {
            pstrRegisteredClasses[REPORT_WNDCLASS] = szReportClass;
        }

        // Ensure controls are initialized 
        InitCommonControls(); 
    }

    END_CRITICAL_SECTION

    if (pstrRegisteredClasses[REPORT_WNDCLASS] == NULL)
        return FALSE;

    // Create our window
    m_hWnd = CreateWindow (szReportClass,          // class
                         NULL,                     // caption
                         dwReportWindowStyle,      // window style
                         0, 0,                     // position
                         0, 0,                     // size
                         hWndParent,               // parent window
                         NULL,                     // menu
                         g_hInstance,              // program instance
                         (LPVOID) this );          // user-supplied data

    if (m_hWnd == NULL)
        return FALSE;

    // Turn off layout mirroring if it is enabled
    lExStyles = GetWindowLong(m_hWnd, GWL_EXSTYLE); 

    if ( 0 != ( lExStyles & WS_EX_LAYOUTRTL ) ) {
        lExStyles &= ~WS_EX_LAYOUTRTL;
        SetWindowLong(m_hWnd, GWL_EXSTYLE, lExStyles);
    }

    return TRUE;
}  


void CReport::ChangeFont (
    void
    )
{
    if (!m_bFontChange) {

        m_bFontChange = TRUE;

        if (!m_bConfigChange) {
            m_bConfigChange = TRUE;
            WindowInvalidate(m_hWnd);
        }
    }
}


void 
CReport::SizeComponents (
    LPRECT pRect )
{
   INT            xWidth;
   INT            yHeight;

    m_rect = *pRect;

    xWidth = pRect->right - pRect->left;
    yHeight = pRect->bottom - pRect->top;

    // If no space, hide window and leave
    if (xWidth == 0 || yHeight == 0) {
        WindowShow(m_hWnd, FALSE);
        return;
    }

    // Show window to assigned position
    MoveWindow(m_hWnd, pRect->left, pRect->top, xWidth, yHeight, FALSE);
    WindowShow(m_hWnd, TRUE);
    WindowInvalidate(m_hWnd);

    SetScrollRanges();
}

INT 
CReport::SetCounterPositions (
    PCObjectNode pObject,
    HDC hDC )
{
   PCCounterNode  pCounter;
   INT            yPos;

   yPos = pObject->m_yPos + m_yLineHeight;

   for (pCounter = pObject->FirstCounter();
        pCounter;
        pCounter = pCounter->Next()) {
   
      if (m_bFontChange || pCounter->m_xWidth == -1) {
          pCounter->m_xWidth = TextWidth(hDC, pCounter->Name());
      }

      if (pCounter->m_xWidth > m_xMaxCounterWidth)
          m_xMaxCounterWidth = pCounter->m_xWidth;

      pCounter->m_yPos = yPos;
      yPos += m_yLineHeight;
   }

   return yPos;
}


INT
CReport::SetInstancePositions (
    PCObjectNode  pObject,
    HDC hDC )
{
    INT   xPos ;
    PCInstanceNode   pInstance;
    LPWSTR szParent;
    LPWSTR szInstance;

    xPos = 0;

    for (pInstance = pObject->FirstInstance();
        pInstance;
        pInstance = pInstance->Next()) {

        if (m_bFontChange || pInstance->m_xWidth == -1) {

            if (pInstance->HasParent()) {
                szParent = pInstance->GetParentName();

                szInstance = pInstance->GetInstanceName();

                pInstance->m_xWidth = max(TextWidth(hDC, szParent), TextWidth(hDC, szInstance));
            } else {
              pInstance->m_xWidth = TextWidth(hDC, pInstance->Name());
            }
        }

        pInstance->m_xPos = xPos + max(pInstance->m_xWidth, m_xValueWidth);
        xPos = pInstance->m_xPos + xColumnMargin;
    }

    if (xPos > m_xMaxInstancePos)
         m_xMaxInstancePos = xPos;

    return xPos;
}

INT
CReport::SetObjectPositions (
    PCMachineNode pMachine,
    HDC  hDC
    )
{
   PCObjectNode  pObject;
   INT yPos;
   INT xPos;

   yPos = pMachine->m_yPos + m_yLineHeight;

   for (pObject = pMachine->FirstObject();
        pObject ;
        pObject = pObject->Next()) {
 
      if (m_bFontChange || pObject->m_xWidth == -1) {
          pObject->m_xWidth = TextWidth(hDC, pObject->Name());
      }

      if (!pObject->FirstInstance()->HasParent())
        pObject->m_yPos = yPos;
      else
        pObject->m_yPos = yPos + m_yLineHeight;

      yPos = SetCounterPositions (pObject, hDC) ;

      xPos = SetInstancePositions(pObject, hDC);

      yPos += m_yLineHeight;
   }

   return yPos;
}


INT 
CReport::SetMachinePositions (
    PCCounterTree pTree,
    HDC hDC
    )
{
   PCMachineNode   pMachine ;
   INT            yPos ;

   yPos = m_yLineHeight;

   for (pMachine = pTree->FirstMachine() ;
        pMachine ;
        pMachine = pMachine->Next())  {
   
      if (m_bFontChange || pMachine->m_xWidth == -1) {
          pMachine->m_xWidth = TextWidth(hDC, pMachine->Name());
      }

      pMachine->m_yPos = yPos;   
      yPos = SetObjectPositions (pMachine, hDC);
   }

   m_yReportHeight = yPos + yBorderHeight;

   return yPos;
}


void
CReport::DrawSelectRect (
    HDC     hDC,
    BOOL    bState
    )
{
    BOOL    bSuccess = TRUE;
    RECT    rect = {0,0,0,0};
    HBRUSH  hbrush;

    if ( NULL != m_pSelect && NULL != hDC ) {

        switch ( m_nSelectType ) {

            case MACHINE_NODE:
                rect.left = xColumnMargin;
                rect.top = ((PCMachineNode)m_pSelect)->m_yPos;
                rect.right = rect.left + ((PCMachineNode)m_pSelect)->m_xWidth;
                rect.bottom = rect.top + m_yLineHeight;
                break;

            case OBJECT_NODE:
                rect.left = xObjectMargin;
                rect.top = ((PCObjectNode)m_pSelect)->m_yPos;
                rect.right = rect.left + ((PCObjectNode)m_pSelect)->m_xWidth;
                rect.bottom = rect.top + m_yLineHeight;
                break;

            case INSTANCE_NODE:
                rect.right = m_xInstanceMargin + ((PCInstanceNode)m_pSelect)->m_xPos;
                rect.bottom = ((PCInstanceNode)m_pSelect)->m_pObject->m_yPos + m_yLineHeight;
                rect.left = rect.right - ((PCInstanceNode)m_pSelect)->m_xWidth;
                rect.top = rect.bottom - 
                             (((PCInstanceNode)m_pSelect)->HasParent() ? (2*m_yLineHeight) : m_yLineHeight);
                break;

            case COUNTER_NODE:
                rect.left = xCounterMargin;
                rect.top = ((PCCounterNode)m_pSelect)->m_yPos;
                rect.right = rect.left + ((PCCounterNode)m_pSelect)->m_xWidth;
                rect.bottom = rect.top + m_yLineHeight;
                break;

            case ITEM_NODE:
                rect.right = m_xInstanceMargin + ((PCGraphItem)m_pSelect)->m_pInstance->m_xPos;
                rect.top = ((PCGraphItem)m_pSelect)->m_pCounter->m_yPos;
                rect.left = rect.right - m_xValueWidth;
                rect.bottom = rect.top + m_yLineHeight;
                break;

            default:
                bSuccess = FALSE;
        }

        if ( bSuccess ) {
            rect.left -= 1;
            rect.right += 1;

            hbrush = CreateSolidBrush(bState ? m_pCtrl->clrFgnd() : m_pCtrl->clrBackPlot());
            if ( NULL != hbrush ) {
                FrameRect(hDC, &rect, hbrush);
                DeleteObject(hbrush);
            }
        }
    }
    return;
}

BOOL         
CReport::LargeHexValueExists ( void )
{
    PCMachineNode   pMachine = NULL;
    PCObjectNode    pObject = NULL;
    PCInstanceNode  pInstance = NULL;
    PCCounterNode   pCounter = NULL;
    PCGraphItem     pItem = NULL;
    BOOL            bLargeHexValueExists = FALSE;
            
    for (pMachine = m_pCtrl->CounterTree()->FirstMachine();
         pMachine && !bLargeHexValueExists;
         pMachine = pMachine->Next()) {

        for (pObject = pMachine->FirstObject();
             pObject && !bLargeHexValueExists;
             pObject = pObject->Next()) {
            
            for (pInstance = pObject->FirstInstance();
                 pInstance && !bLargeHexValueExists;
                 pInstance = pInstance->Next()) {
                
                pItem = pInstance->FirstItem();
    
                for (pCounter = pObject->FirstCounter();
                     pCounter && !bLargeHexValueExists;
                     pCounter = pCounter->Next()) {
                     
                    PCGraphItem pCheckItem = NULL;

                    if (pItem && pItem->m_pCounter == pCounter) {
                        pCheckItem = pItem;
                        pItem = pItem->m_pNextItem;
                    }

                    if ( pCheckItem ) {
                        if ( !( pCheckItem->m_CounterInfo.dwType & HEXMASK ) ) {
                            bLargeHexValueExists = pCheckItem->m_CounterInfo.dwType & PERF_SIZE_LARGE;
                            if ( bLargeHexValueExists ) {
                                break;
                            }
                        }
                    }
                }
            }        
        }
    }

    return bLargeHexValueExists;
}

void
CReport::DrawReportValue (
    HDC hDC,
    PCGraphItem pItem, 
    INT xPos, 
    INT yPos )
{

    double      dMax;
    double      dMin;
    double      dValue = -1.0;
    WCHAR       szValue [MAX_VALUE_LEN] = L"_" ;
    HRESULT     hr;
    long        lCtrStat;
    RECT        rect ;
    INT         iPrecision;

    if ( NULL != pItem && NULL != hDC ) {

        eReportValueTypeConstant eValueType;            
        eValueType = m_pCtrl->ReportValueType();

        if ( sysmonDefaultValue == eValueType  ) {
            // if log source display the average value
            // else display the current value
            if (m_pCtrl->IsLogSource()) {
                hr = pItem->GetStatistics(&dMax, &dMin, &dValue, &lCtrStat);
            } else {               
                hr = pItem->GetValue(&dValue, &lCtrStat);
            }               
        } else {

            if ( sysmonCurrentValue == eValueType  ) {

                hr = pItem->GetValue(&dValue, &lCtrStat);
            } else {
                double      dAvg;

                hr = pItem->GetStatistics(&dMax, &dMin, &dAvg, &lCtrStat);

                switch ( eValueType ) {
                
                    case sysmonAverage:
                        dValue = dAvg;
                        break;
                    
                    case sysmonMinimum:
                        dValue = dMin;
                        break;
                    
                    case sysmonMaximum:
                        dValue = dMax;
                        break;

                    default:
                        assert (FALSE);
                }
            }
        }

        if (SUCCEEDED(hr) && IsSuccessSeverity(lCtrStat)) {

            assert ( 0 <= dValue );

            if ( ( pItem->m_CounterInfo.dwType & ( PERF_TYPE_COUNTER | PERF_TYPE_TEXT ) ) ) {
                (dValue > dLargeValueMax) ? iPrecision = 0 : iPrecision = 3;
            } else {
                // for Numbers, no decimal places
                iPrecision = 0;
            }

            if(PDH_CSTATUS_INVALID_DATA != pItem->m_CounterInfo.CStatus ) {
                // Check for Hex values
                if ( !(pItem->m_CounterInfo.dwType & HEXMASK) ) {   
                    BOOL bLarge = pItem->m_CounterInfo.dwType & PERF_SIZE_LARGE;
                
                    FormatHex ( dValue, szValue, bLarge);
                    
                } else {
                    FormatNumber ( dValue, szValue, MAX_VALUE_LEN, 12, iPrecision );                   
                }   
            }
        }
        else {
            StringCchCopy(szValue, MAX_VALUE_LEN, szDashLine);
        }
    }
    else {
        StringCchCopy(szValue, MAX_VALUE_LEN, szDashLine);
    }

    rect.right = xPos - 1;
    rect.left = xPos - m_xValueWidth + 1;
    rect.top = yPos;
    rect.bottom = yPos + m_yLineHeight;

    ExtTextOut (hDC, rect.right, rect.top, ETO_CLIPPED | ETO_OPAQUE,
               &rect, szValue, lstrlen (szValue), NULL) ;
}


void 
CReport::DrawReportValues (
    HDC hDC )
{
    PCMachineNode   pMachine;
    PCObjectNode    pObject;
    PCInstanceNode  pInstance;
    PCCounterNode   pCounter;
    PCGraphItem     pItem;
    PCGraphItem     pDrawItem;

    if ( NULL != hDC ) {    

        SelectFont (hDC, m_pCtrl->Font());
        SetTextAlign (hDC, TA_RIGHT|TA_TOP);

        for (pMachine = m_pCtrl->CounterTree()->FirstMachine();
            pMachine;
            pMachine = pMachine->Next()) {

            for (pObject = pMachine->FirstObject();
                pObject;
                pObject = pObject->Next()) {

                for (pInstance = pObject->FirstInstance();
                    pInstance;
                    pInstance = pInstance->Next()) {

                    pItem = pInstance->FirstItem();
                    
                    for ( pCounter = pObject->FirstCounter();
                          pCounter;
                          pCounter = pCounter->Next()) {

                        if (pItem && pItem->m_pCounter == pCounter) {
                            pDrawItem = pItem;
                            pItem = pItem->m_pNextItem;
                        } else {
                            pDrawItem = NULL;
                        }
                        
                        DrawReportValue (
                            hDC, 
                            pDrawItem, 
                            m_xInstanceMargin + pInstance->m_xPos, 
                            pCounter->m_yPos);
                    }
                }
            }  
        }
    }
}

LPWSTR GetBuffer(LPWSTR pBuffer, LONG* lBufSize, LONG lSize)
{
    LPWSTR pNew;

    if (lSize < *(lBufSize)) {
        return pBuffer;
    }
    if (pBuffer) {
        delete [] pBuffer;
        *(lBufSize) = 0;
    }

    pNew =  new WCHAR [lSize];
    if (pNew == NULL) {
        return NULL;
    }
    *(lBufSize) = lSize;
    return pNew;
}
    
BOOL 
CReport::WriteFileReport ( HANDLE hFile ) 
{
    PCMachineNode   pMachine;
    PCObjectNode    pObject;
    PCInstanceNode  pInstance;
    PCCounterNode   pCounter;
    LPWSTR          pszTemp = NULL;
    LONG            lSize = 0;
    LONG            lBufSize = 0;
    PCGraphItem     pItem;
    BOOL            bStatus = TRUE;
    WCHAR           szValue[MAX_VALUE_LEN];

    lBufSize = MAX_PATH;
    pszTemp = new WCHAR [lBufSize];
    if (pszTemp == NULL) {
        return FALSE;
    } 

    for (pMachine = m_pCtrl->CounterTree()->FirstMachine() ;
            pMachine && TRUE == bStatus;
            pMachine = pMachine->Next()) {

        lSize = 3 * lstrlen(LineEndStr) +
                lstrlen(ResourceString(IDS_COMPUTER)) +
                lstrlen(pMachine->Name()) + 1;
        pszTemp = GetBuffer(pszTemp, &lBufSize, lSize);
        if (pszTemp == NULL) {
            goto ErrorOut;
        }

        StringCchCopy(pszTemp, lBufSize, LineEndStr);
        StringCchCat(pszTemp, lBufSize, LineEndStr);
        StringCchCat(pszTemp, lBufSize, ResourceString(IDS_COMPUTER));
        StringCchCat(pszTemp, lBufSize, pMachine->Name());
        StringCchCat(pszTemp, lBufSize, LineEndStr);

        bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(WCHAR) ); 

        for (pObject = pMachine->FirstObject() ;
                pObject && TRUE == bStatus;
                pObject = pObject->Next()) {

            // Write the object name line.
            lSize = 2 * lstrlen(LineEndStr) +
                    lstrlen(TabStr) +
                    lstrlen(ResourceString(IDS_OBJECT_NAME)) +
                    lstrlen(pObject->Name()) + 1;
            pszTemp = GetBuffer(pszTemp, &lBufSize, lSize);
            if (pszTemp == NULL) {
                goto ErrorOut;
            }

            StringCchCopy(pszTemp, lBufSize, LineEndStr);
            StringCchCat(pszTemp, lBufSize, ResourceString(IDS_OBJECT_NAME));
            StringCchCat(pszTemp, lBufSize, pObject->Name());
            StringCchCat(pszTemp, lBufSize, LineEndStr);

            // Add first tab char for instance names.
            StringCchCat(pszTemp, lBufSize, TabStr);
            
       
            bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(WCHAR) );
            if (!bStatus) 
                break;
            
            // Write the first line of instance (parent) names.
            for (pInstance = pObject->FirstInstance();
                    pInstance && TRUE == bStatus;
                    pInstance = pInstance->Next()) {
                    
                // If instance has no parent, then the parent name is null, so a tab is written.
                lSize = lstrlen(TabStr) +
                        lstrlen(LineEndStr) + 
                        lstrlen(pInstance->GetParentName()) + 1;
                pszTemp = GetBuffer(pszTemp, &lBufSize, lSize);
                if (pszTemp == NULL) {
                    goto ErrorOut;
                }
                StringCchCopy(pszTemp, lBufSize, TabStr);
                StringCchCat(pszTemp, lBufSize, pInstance->GetParentName());
                bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(WCHAR) );
            }
            
            if ( !bStatus )
                break;
            
            StringCchCopy(pszTemp, lBufSize, LineEndStr);

            // Include first tab of second instance line.
            StringCchCat(pszTemp, lBufSize, TabStr);
                
            bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(WCHAR) );

            // Write the second line of instance names.
            for (pInstance = pObject->FirstInstance();
                    pInstance && TRUE == bStatus;
                    pInstance = pInstance->Next()) {

                lSize = lstrlen(TabStr) +
                        lstrlen(LineEndStr)+
                        lstrlen(pInstance->GetInstanceName()) + 1;
                pszTemp = GetBuffer(pszTemp, &lBufSize, lSize);
                if (pszTemp == NULL) {
                    goto ErrorOut;
                }

                StringCchCopy(pszTemp, lBufSize, TabStr);
                StringCchCat(pszTemp, lBufSize, pInstance->GetInstanceName());

                bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(WCHAR) );
            }
            
            if (!bStatus) 
                break;

            StringCchCopy(pszTemp, lBufSize, LineEndStr);

            bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(WCHAR) );

            for (pCounter = pObject->FirstCounter();
                    pCounter && TRUE == bStatus;
                    pCounter = pCounter->Next()) {

                lSize = lstrlen(TabStr) +
                        lstrlen(LineEndStr)+
                        lstrlen(pCounter->Name()) + 1;
                pszTemp = GetBuffer(pszTemp, &lBufSize, lSize);
                if (pszTemp == NULL) {
                    goto ErrorOut;
                }

                // Write counter name
                StringCchCopy(pszTemp, lBufSize, TabStr);
                StringCchCat(pszTemp, lBufSize, pCounter->Name());

                bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(WCHAR) );

                // Write values, looping on instances                
                for ( pInstance = pObject->FirstInstance();
                        pInstance && TRUE == bStatus;
                        pInstance = pInstance->Next()) {
                    // Loop on items to find the item that matches the counter.
                    for ( pItem = pInstance->FirstItem();
                            pItem && TRUE == bStatus;
                            pItem = pItem->m_pNextItem) {
                        if ( pItem->m_pCounter == pCounter && pInstance) {
                            GetReportItemValue(pItem,szValue );

                            lSize = lstrlen(TabStr) +
                                    lstrlen(LineEndStr)+
                                    lstrlen(szValue) + 1;
                            pszTemp = GetBuffer(pszTemp, &lBufSize, lSize);
                            if (pszTemp == NULL) {
                                goto ErrorOut;
                            }

                            StringCchCopy(pszTemp, lBufSize, TabStr);
                            StringCchCat(pszTemp, lBufSize, szValue);

                            bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(WCHAR) );
                        }
                    }
                }
                if (!bStatus) 
                    break;
                StringCchCopy(pszTemp, lBufSize, LineEndStr);

                bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(WCHAR) );
            }
        }
    }

    if (pszTemp) {
        delete [] pszTemp;
    }

    return bStatus;    

ErrorOut:
    if (pszTemp) {
        delete [] pszTemp;
    }
    return FALSE;
}

void 
CReport::GetReportItemValue(PCGraphItem pItem, LPWSTR szValue)
{

    double      dMax;
    double      dMin;
    double      dValue = -1.0;
    HRESULT     hr;
    long        lCtrStat;
    INT         iPrecision;

    if (pItem) {

        eReportValueTypeConstant eValueType;            
        eValueType = m_pCtrl->ReportValueType();

        if ( sysmonDefaultValue == eValueType  ) {
            // if log source display the average value
            // else display the current value
            if (m_pCtrl->IsLogSource()) {
                hr = pItem->GetStatistics(&dMax, &dMin, &dValue, &lCtrStat);
            } else {               
                hr = pItem->GetValue(&dValue, &lCtrStat);
            }               
        } else {

            if ( sysmonCurrentValue == eValueType  ) {

                hr = pItem->GetValue(&dValue, &lCtrStat);
            } else {
                double      dAvg;

                hr = pItem->GetStatistics(&dMax, &dMin, &dAvg, &lCtrStat);

                switch ( eValueType ) {
                
                    case sysmonAverage:
                        dValue = dAvg;
                        break;
                    
                    case sysmonMinimum:
                        dValue = dMin;
                        break;
                    
                    case sysmonMaximum:
                        dValue = dMax;
                        break;

                    default:
                        assert (FALSE);
                }
            }
        }

        if (SUCCEEDED(hr) && IsSuccessSeverity(lCtrStat)) {

            assert ( 0 <= dValue );
            (dValue > dLargeValueMax) ? iPrecision = 0 : iPrecision = 3;
            if(PDH_CSTATUS_INVALID_DATA != pItem->m_CounterInfo.CStatus ) {
                // Check for Hex values
                if ( !(pItem->m_CounterInfo.dwType & HEXMASK) ) {   
                    BOOL bLarge = pItem->m_CounterInfo.dwType & PERF_SIZE_LARGE;
                
                    FormatHex (
                        dValue,
                        szValue,
                        bLarge);
                    
                } else {
                    FormatNumber (
                            dValue,
                            szValue,
                            MAX_VALUE_LEN,
                            12,
                            iPrecision );                   
                }   
            }
        } else {
            StringCchCopy(szValue, MAX_VALUE_LEN, szDashLine);
        }
       
    } else {
        StringCchCopy(szValue, MAX_VALUE_LEN, szDashLine);
    }
    return;
}

void 
CReport::DrawReportHeaders (
    HDC hDC )
{
    PCMachineNode   pMachine;
    PCObjectNode    pObject;
    PCInstanceNode  pInstance;
    PCCounterNode   pCounter;
    INT             cName;
    RECT            rectMachine;
    RECT            rectObject;
    RECT            rectInstance;
    RECT            rectCounter;

    if ( NULL != hDC ) {

        SetTextAlign(hDC, TA_LEFT|TA_TOP) ;

        rectMachine.left = xColumnMargin;
        rectObject.left = xObjectMargin;
        rectCounter.left = xCounterMargin;

        for ( pMachine = m_pCtrl->CounterTree()->FirstMachine() ;
                pMachine;
                pMachine = pMachine->Next()) {
    
            rectMachine.right = rectMachine.left + pMachine->m_xWidth;
            rectMachine.top = pMachine->m_yPos;
            rectMachine.bottom = pMachine->m_yPos + m_yLineHeight;

            ExtTextOut (
                hDC, 
                xColumnMargin,
                pMachine->m_yPos, 
                ETO_OPAQUE,
                &rectMachine,
                pMachine->Name(), 
                lstrlen(pMachine->Name()),
                NULL );

            for ( pObject = pMachine->FirstObject() ;
                    pObject ;
                    pObject = pObject->Next()) {

                rectObject.right = rectObject.left + pObject->m_xWidth;
                rectObject.top = pObject->m_yPos;
                rectObject.bottom = pObject->m_yPos + m_yLineHeight;

                ExtTextOut (
                    hDC, 
                    xObjectMargin, 
                    pObject->m_yPos, 
                    ETO_OPAQUE,
                    &rectObject,
                    pObject->Name(), 
                    lstrlen (pObject->Name()),
                    NULL);

                SetTextAlign (hDC, TA_RIGHT) ;

                for ( pInstance = pObject->FirstInstance();
                        pInstance;
                        pInstance = pInstance->Next()) {
        
                    rectInstance.left = m_xInstanceMargin + pInstance->m_xPos;
                    rectInstance.right = rectInstance.left + max(pInstance->m_xWidth, m_xValueWidth);

                    if ( pInstance->HasParent() ) {

                        cName = lstrlen(pInstance->GetParentName());
                        rectInstance.top = pObject->m_yPos - m_yLineHeight;
                        rectInstance.bottom = rectInstance.top + m_yLineHeight;
                    
                        ExtTextOut (
                            hDC, 
                            m_xInstanceMargin + pInstance->m_xPos, 
                            pObject->m_yPos - m_yLineHeight, 
                            ETO_OPAQUE,
                            &rectInstance,
                            pInstance->GetParentName(), 
                            cName,
                            NULL);

                        rectInstance.top = pObject->m_yPos;
                        rectInstance.bottom = rectInstance.top + m_yLineHeight;

                        cName = lstrlen(pInstance->GetInstanceName());
                        ExtTextOut (
                            hDC, 
                            m_xInstanceMargin + pInstance->m_xPos, 
                            pObject->m_yPos,
                            ETO_OPAQUE,
                            &rectInstance,
                            pInstance->GetInstanceName(), 
                            cName,
                            NULL );
                    } else {
                    
                        rectInstance.top = pObject->m_yPos;
                        rectInstance.bottom = rectInstance.top + m_yLineHeight;

                        ExtTextOut (
                            hDC, 
                            m_xInstanceMargin + pInstance->m_xPos, 
                            pObject->m_yPos, 
                            ETO_OPAQUE,
                            &rectInstance,
                            pInstance->Name(),
                            lstrlen(pInstance->Name()),
                            NULL );
                    }
                }

                SetTextAlign (hDC, TA_LEFT) ;

                for (pCounter = pObject->FirstCounter();
                        pCounter ;
                        pCounter = pCounter->Next()) {

                    rectCounter.right = rectCounter.left + pCounter->m_xWidth;
                    rectCounter.top = pCounter->m_yPos;
                    rectCounter.bottom = pCounter->m_yPos + m_yLineHeight;
                
                    ExtTextOut (
                        hDC, 
                        xCounterMargin, 
                        pCounter->m_yPos, 
                        ETO_OPAQUE,
                        &rectCounter,
                        pCounter->Name(), 
                        lstrlen (pCounter->Name()),
                        NULL);
                }
            }
        }
        
        DrawSelectRect(hDC, TRUE);
    }
}


void
CReport::ApplyChanges (
    HDC hDC )
{
    if (m_bConfigChange && NULL != hDC ) {

        // Selected the Bold font for font change , counter add, and counter delete.
        // This is used for recalculating text width.
        SelectFont (hDC, m_pCtrl->BoldFont());
        m_yLineHeight = FontHeight (hDC, TRUE);  

        if ( LargeHexValueExists ( ) ) {
            m_xValueWidth = TextWidth(hDC, szValueLargeHexPlaceholder);
        } else {
            m_xValueWidth = TextWidth(hDC, szValuePlaceholder);
        }

        m_xMaxCounterWidth = 0;
        m_xMaxInstancePos = 0;

        SetMachinePositions (m_pCtrl->CounterTree(), hDC);

        m_xInstanceMargin = xCounterMargin + m_xMaxCounterWidth + xColumnMargin;
        m_xReportWidth = m_xInstanceMargin + m_xMaxInstancePos;

        SetScrollRanges();

        m_bConfigChange = FALSE;
        m_bFontChange = FALSE;
    }
}

void 
CReport::Render (
    HDC hDC,
    HDC hAttribDC,
    BOOL /*fMetafile*/,
    BOOL /*fEntire*/,
    LPRECT prcUpdate )
{
    ApplyChanges(hAttribDC);

    if ( NULL != hDC ) {
        SetBkColor(hDC, m_pCtrl->clrBackPlot());
        ClearRect(hDC, prcUpdate);
    
        Draw( hDC );
    }
}


void 
CReport::Draw (
    HDC hDC )
{
    // if no space assigned, return
    if (m_rect.top != m_rect.bottom) {

        if ( NULL != hDC ) {
            SetTextColor (hDC, m_pCtrl->clrFgnd());
            SetBkColor(hDC, m_pCtrl->clrBackPlot());

            SelectFont(hDC, m_pCtrl->BoldFont());
            DrawReportHeaders (hDC);

            SelectFont (hDC, m_pCtrl->Font());
            DrawReportValues (hDC);

            m_pCtrl->DrawBorder ( hDC );
        }
    }
}

void 
CReport::AddItem (
    PCGraphItem /* pItem */ )
{
    if (!m_bConfigChange) {
        m_bConfigChange = TRUE;
        WindowInvalidate(m_hWnd);
    }
}


void
CReport::DeleteItem (
    PCGraphItem pItem )
{
    // Calling procedure checks for NULL pItem
    assert ( NULL != pItem );
    if ( NULL != m_pSelect ) {
        if ( SelectionDeleted ( pItem ) ) {
            m_pSelect = NULL;
        }
    }

    if (!m_bConfigChange) {
        m_bConfigChange = TRUE;
        WindowInvalidate(m_hWnd);
    }
}


void
CReport::DeleteSelection (
    VOID )
{
    if (m_pSelect == NULL)
        return;

    switch (m_nSelectType) {

    case MACHINE_NODE:
        ((PCMachineNode)m_pSelect)->DeleteNode(TRUE);
        break;

    case OBJECT_NODE:
        ((PCObjectNode)m_pSelect)->DeleteNode(TRUE);
        break;

    case INSTANCE_NODE:
        ((PCInstanceNode)m_pSelect)->DeleteNode(TRUE);  
        break;

    case COUNTER_NODE:
        ((PCCounterNode)m_pSelect)->DeleteNode(TRUE);
        break;

    case ITEM_NODE:
        ((PCGraphItem)m_pSelect)->Delete(TRUE);
        break;

    default:
        return;
    }

    // DeleteItem sets m_pSelect to NULL and invalidates the window.
    assert ( NULL == m_pSelect );
}


BOOL
CReport::OnContextMenu (
    INT x,
    INT y )
{
    HMENU   hMenu;
    HMENU   hMenuPopup;
    RECT    clntRect;
    int     xPos=0,yPos=0;

    GetWindowRect(m_hWnd,&clntRect);
    if (x==0){
        xPos = ((clntRect.right - clntRect.left)/2) ;
    }else{
        xPos = x - clntRect.left;
    }
    if (y==0){
        yPos = ((clntRect.bottom - clntRect.top)/2) ;
    }else{
        yPos = y - clntRect.top;
    }

    x = clntRect.left + xPos ;
    y = clntRect.top  + yPos ;

    // if nothing is selected, let main window handle the menu
    if (m_pSelect == NULL)
        return FALSE;

    if ( m_pCtrl->ConfirmSampleDataOverwrite() ) {
        if ( !m_pCtrl->IsReadOnly() ) {
            // Get the menu for the pop-up menu from the resource file.
            hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_CONTEXT));
            if (!hMenu)
            return TRUE;

            // Get the first submenu in it for TrackPopupMenu. 
            hMenuPopup = GetSubMenu(hMenu, 0);

            // Draw and track the "floating" pop-up menu. 
            TrackPopupMenu(hMenuPopup, TPM_RIGHTBUTTON, x, y, 0, m_hWnd, NULL);

            // Destroy the menu.
            DestroyMenu(hMenu);
        }
    }
    return TRUE;
}


void 
CReport::Update (
    void )
{
    HDC     hDC;

    hDC = GetDC(m_hWnd);

    if ( NULL != hDC ) {

        ApplyChanges(hDC);

        SetWindowOrgEx (hDC, 
                       GetScrollPos (m_hWnd, SB_HORZ), 
                       GetScrollPos (m_hWnd, SB_VERT),
                       NULL) ;

        if ( m_rect.bottom != m_rect.top ) {
            SelectFont (hDC, m_pCtrl->Font());
            SetTextColor (hDC, m_pCtrl->clrFgnd());
            SetBkColor(hDC, m_pCtrl->clrBackPlot());

            DrawReportValues(hDC);
        }

        ReleaseDC(m_hWnd,hDC);
    }
}


void
CReport::OnPaint (
    void
)
{
    HDC             hDC ;
    PAINTSTRUCT     ps ;

    hDC = BeginPaint (m_hWnd, &ps) ;

    if ( NULL != hDC ) {
        SelectFont (hDC, m_pCtrl->Font()) ;

        SetWindowOrgEx (
            hDC, 
            GetScrollPos (m_hWnd, SB_HORZ), 
            GetScrollPos (m_hWnd, SB_VERT),
            NULL );


        SetTextColor (hDC, m_pCtrl->clrFgnd());
        SetBkColor(hDC, m_pCtrl->clrBackPlot());

        ApplyChanges(hDC);

        Draw(hDC);

        EndPaint (m_hWnd, &ps) ;
    }
}


void
CReport::SetScrollRanges (
    void )
{
   RECT           rectClient ;
   INT            xWidth, yHeight ;

   GetClientRect (m_hWnd, &rectClient) ;
   xWidth = rectClient.right - rectClient.left ;
   yHeight = rectClient.bottom - rectClient.top ;

   SetScrollRange (m_hWnd, SB_VERT, 0, max (0, m_yReportHeight - yHeight), TRUE) ;
   SetScrollRange (m_hWnd, SB_HORZ,0, max (0, m_xReportWidth - xWidth), TRUE) ;
}

BOOL
CReport::SelectName (
    INT     xPos,
    INT     yPos,
    void**  ppSelected,
    INT*    piSelectType )
{
    POINT           pt;
    PCMachineNode   pMachine;
    PCObjectNode    pObject;
    PCCounterNode   pCounter;
    PCInstanceNode  pInstance;
    PCGraphItem     pItem;

    // Programming error if either of these two pointers is NULL.
    assert ( NULL != ppSelected );
    assert ( NULL != piSelectType );

    // Adjust coordinates by scroll offset  
    pt.x = xPos + GetScrollPos(m_hWnd, SB_HORZ);
    pt.y = yPos + GetScrollPos(m_hWnd, SB_VERT);

    for (pMachine = m_pCtrl->CounterTree()->FirstMachine() ;
        pMachine;
        pMachine = pMachine->Next()) {
            
        if (PtInName(pt, xColumnMargin, pMachine->m_yPos, pMachine->m_xWidth)) {
            *ppSelected = pMachine;
            *piSelectType = MACHINE_NODE; 
            return TRUE;
        }

        for (pObject = pMachine->FirstObject() ;
             pObject ;
             pObject = pObject->Next()) {

             if (PtInName(pt, xObjectMargin, pObject->m_yPos, pObject->m_xWidth)) {
                *ppSelected = pObject;
                *piSelectType = OBJECT_NODE; 
                return TRUE;
            }

            for (pCounter = pObject->FirstCounter();
                 pCounter ;
                 pCounter = pCounter->Next()) {

                 if (PtInName(pt, xCounterMargin, pCounter->m_yPos, pCounter->m_xWidth)) {
                    *ppSelected = pCounter;
                    *piSelectType = COUNTER_NODE; 
                    return TRUE;
                 }
            }

            for (pInstance = pObject->FirstInstance();
                 pInstance ;
                 pInstance = pInstance->Next()) {

                INT xInstancePos = m_xInstanceMargin + pInstance->m_xPos;

                if (PtInName(pt, xInstancePos - pInstance->m_xWidth, pObject->m_yPos, pInstance->m_xWidth) ||
                    (pInstance->HasParent() &&
                     PtInName(pt, xInstancePos - pInstance->m_xWidth, pObject->m_yPos - m_yLineHeight, pInstance->m_xWidth))) {
                    *ppSelected = pInstance;
                    *piSelectType = INSTANCE_NODE; 
                    return TRUE;
                 }

                if (pt.x > xInstancePos || pt.x < xInstancePos - m_xValueWidth)
                    continue;

                for (pItem = pInstance->FirstItem();
                     pItem;
                     pItem = pItem->m_pNextItem) {

                     if (pt.y > pItem->m_pCounter->m_yPos && pt.y < pItem->m_pCounter->m_yPos + m_yLineHeight) {
                         *ppSelected = pItem;
                         *piSelectType = ITEM_NODE;
                         return TRUE;
                     }
                }
             }
        }           
    }

    *ppSelected = NULL;
    return FALSE;
 }         

PCGraphItem
CReport::GetItem (
    void  *pSelected,
    INT   nSelectType ) 
{
    PCMachineNode   pMachine;
    PCObjectNode    pObject;
    PCCounterNode   pCounter;
    PCInstanceNode  pInstance;
    PCGraphItem pItem;
    PCGraphItem pReturn = NULL;
    
    if ( NULL != pSelected ) {

        switch (nSelectType) {

            case MACHINE_NODE:
                pMachine = (PCMachineNode)pSelected;
                pObject = pMachine->FirstObject();
                if ( NULL != pObject ) {
                    pInstance = pObject->FirstInstance();
                    if ( NULL != pInstance ) {
                        pReturn = pInstance->FirstItem();
                    }
                }
                break;

            case OBJECT_NODE:
                pObject = (PCObjectNode)pSelected;
                pInstance = pObject->FirstInstance();
                if ( NULL != pInstance ) {
                    pReturn = pInstance->FirstItem();
                }
                break;

            case INSTANCE_NODE:
                pInstance = (PCInstanceNode)pSelected;
                pReturn = pInstance->FirstItem();
                break;

            case COUNTER_NODE:
                pCounter = (PCCounterNode)pSelected;
                pObject = pCounter->m_pObject;
            
                for (pInstance = pObject->FirstInstance();
                     ((NULL != pInstance) && (NULL == pReturn));
                     pInstance = pInstance->Next()) {

                    for (pItem = pInstance->FirstItem();
                         ((NULL != pItem) && (NULL == pReturn));
                         pItem = pItem->m_pNextItem) {
                   
                        if (pItem && pItem->m_pCounter == pCounter) {                         
                            pReturn = pItem;
                        }
                    }
                }
                break;

            case ITEM_NODE:
                pReturn = (PCGraphItem)pSelected;
                break;

            default:
                break;
        }
    }
    return pReturn;
}
    
BOOL
CReport::SelectionDeleted (
    PCGraphItem pDeletedItem )
{
    BOOL            bSelectionDeleted = FALSE;
    INT             iItemCount = 0;
    PCMachineNode   pMachine;
    PCObjectNode    pObject;
    PCCounterNode   pCounter;
    PCInstanceNode  pInstance;
    PCGraphItem     pItem;

    if ( NULL == m_pSelect ) 
        return FALSE;

    // Delete the selection if this is the last remaining
    // item for the selection object.
    
    switch (m_nSelectType) {

        case MACHINE_NODE:
            // Check for  multiple items for this machine.            
            pMachine = (PCMachineNode)m_pSelect;

            for ( pObject = pMachine->FirstObject();
                  ( NULL != pObject ) && ( 2 > iItemCount );
                  pObject = pObject->Next()) {

                for ( pInstance = pObject->FirstInstance();
                      ( NULL != pInstance ) && ( 2 > iItemCount );
                      pInstance = pInstance->Next()) {
                    
                    for ( pItem = pInstance->FirstItem();
                          ( NULL != pItem ) && ( 2 > iItemCount );
                          pItem = pItem->m_pNextItem) {
           
                        iItemCount++;
                    }
                }
            }
            bSelectionDeleted = ( iItemCount < 2 );
            break;

        case OBJECT_NODE:
            // Check for  multiple items for this object.
            pObject = (PCObjectNode)m_pSelect;

            for ( pInstance = pObject->FirstInstance();
                  ( NULL != pInstance ) && ( 2 > iItemCount );
                  pInstance = pInstance->Next()) {
                for ( pItem = pInstance->FirstItem();
                     ( NULL != pItem ) && ( 2 > iItemCount );
                     pItem = pItem->m_pNextItem) {
           
                    iItemCount++;
                }
            }
            bSelectionDeleted = ( iItemCount < 2 );
            break;

        case INSTANCE_NODE:
            // Check for  multiple items (counters) for this instance.
            pInstance = (PCInstanceNode)m_pSelect;
            iItemCount = 0;

            for ( pItem = pInstance->FirstItem();
                  ( NULL != pItem ) && ( 2 > iItemCount );
                  pItem = pItem->m_pNextItem) {
           
                iItemCount++;
            }
            bSelectionDeleted = ( iItemCount < 2 );
            break;

        case COUNTER_NODE:

            // Check for multiple items (instances) for this counter.
            pCounter = (PCCounterNode)m_pSelect;
            pObject = pCounter->m_pObject;

            for ( pInstance = pObject->FirstInstance();
                  ( NULL != pInstance ) && ( 2 > iItemCount );
                  pInstance = pInstance->Next()) {

                for ( pItem = pInstance->FirstItem();
                      ( NULL != pItem ) && ( 2 > iItemCount );
                      pItem = pItem->m_pNextItem) {
               
                    if (pItem && pItem->m_pCounter == pCounter) {                         
                        iItemCount++;
                        break;
                    }
                }
            }
            bSelectionDeleted = ( iItemCount < 2 );
            break;

        case ITEM_NODE:
            // Selection matches the deleted item.
            bSelectionDeleted = ( pDeletedItem == (PCGraphItem)m_pSelect );
            break;

        default:
            break;
    }

    return bSelectionDeleted;
}         

void 
CReport::OnLButtonDown (
    INT xPos,
    INT yPos )
{
    PCGraphItem pItem;
    HDC hDC = GetDC(m_hWnd);

    if ( NULL != hDC ) {
        SetWindowOrgEx (
            hDC, 
            GetScrollPos (m_hWnd, SB_HORZ), 
            GetScrollPos (m_hWnd, SB_VERT),
            NULL) ;

        DrawSelectRect(hDC, FALSE);

        if ( SelectName(xPos, yPos, &m_pSelect, &m_nSelectType) )
            DrawSelectRect(hDC, TRUE);

        ReleaseDC(m_hWnd, hDC);

        pItem = GetItem(m_pSelect, m_nSelectType);
        m_pCtrl->SelectCounter(pItem);
    }
    return;
}

void 
CReport:: OnDblClick (
    INT, // xPos,
    INT // yPos
    )
{
    PCGraphItem pItem;

    pItem = GetItem ( m_pSelect, m_nSelectType );

    m_pCtrl->DblClickCounter ( pItem );
}

void
CReport::OnHScroll (
    INT iScrollCode,
    INT iScrollNewPos )
{
   INT            iScrollAmt, iScrollPos, iScrollRange ;
   INT            iScrollLo ;
   RECT           rectClient ;
   INT            xWidth ;

   GetClientRect (m_hWnd, &rectClient) ;
   xWidth = rectClient.right - rectClient.left ;

   if (m_xReportWidth <= xWidth)
      return ;

   iScrollPos = GetScrollPos (m_hWnd, SB_HORZ) ;
   GetScrollRange (m_hWnd, SB_HORZ, &iScrollLo, &iScrollRange) ;

   switch (iScrollCode)
      {
      case SB_LINEUP:
           iScrollAmt = - m_yLineHeight ;
           break ;

      case SB_LINEDOWN:
           iScrollAmt = m_yLineHeight ;
           break ;

      case SB_PAGEUP:
           iScrollAmt = - (rectClient.right - rectClient.left) / 2 ;
           break ;

      case SB_PAGEDOWN:
           iScrollAmt = (rectClient.right - rectClient.left) / 2 ;
           break ;

      case SB_THUMBPOSITION:
           iScrollAmt = iScrollNewPos - iScrollPos ;
           break ;

      default:
           iScrollAmt = 0 ;
      }

     iScrollAmt = PinInclusive (iScrollAmt,
                                -iScrollPos,
                                iScrollRange - iScrollPos) ;
     if (iScrollAmt) {
        iScrollPos += iScrollAmt ;
        ScrollWindow (m_hWnd, -iScrollAmt, 0, NULL, NULL) ;
        SetScrollPos (m_hWnd, SB_HORZ, iScrollPos, TRUE) ;
        UpdateWindow (m_hWnd) ;
       }
}

void
CReport::OnVScroll (
    INT iScrollCode,
    INT iScrollNewPos
    )
{
   INT            iScrollAmt, iScrollPos, iScrollRange ;
   INT            iScrollLo ;
   RECT           rectClient ;

   iScrollPos = GetScrollPos (m_hWnd, SB_VERT) ;
   GetScrollRange (m_hWnd, SB_VERT, &iScrollLo, &iScrollRange) ;
   GetClientRect (m_hWnd, &rectClient) ;

   switch (iScrollCode) {
      case SB_LINEUP:
           iScrollAmt = - m_yLineHeight ;
           break ;

      case SB_LINEDOWN:
           iScrollAmt = m_yLineHeight ;
           break ;

      case SB_PAGEUP:
           iScrollAmt = - (rectClient.bottom - rectClient.top) / 2 ;
           break ;

      case SB_PAGEDOWN:
           iScrollAmt = (rectClient.bottom - rectClient.top) / 2 ;
           break ;

      case SB_THUMBPOSITION:
           iScrollAmt = iScrollNewPos - iScrollPos ;
           break ;

      default:
           iScrollAmt = 0 ;
  }

  iScrollAmt = PinInclusive (iScrollAmt, -iScrollPos, iScrollRange - iScrollPos) ;
  if (iScrollAmt) {
        iScrollPos += iScrollAmt ;
        ScrollWindow (m_hWnd, 0, -iScrollAmt, NULL, NULL) ;
        SetScrollPos (m_hWnd, SB_VERT, iScrollPos, TRUE) ;

        UpdateWindow (m_hWnd) ;
   }
}

 
//
// Window procedure
//
LRESULT APIENTRY 
ReportWndProc (
    HWND hWnd, 
    UINT uiMsg, 
    WPARAM wParam,
    LPARAM lParam )
{
    PREPORT pReport = NULL;
    BOOL    bCallDefProc = TRUE;
    LRESULT lReturnValue = 0L;
    RECT    rect;
    
    // hWnd is used to dispatch to window procedure, so major error if it is NULL.
    assert ( NULL != hWnd );

    pReport = (PREPORT)GetWindowLongPtr(hWnd,0);

    if ( NULL == pReport ) {
        if ( WM_CREATE == uiMsg && NULL != lParam ) {
            pReport = (PREPORT)((CREATESTRUCT*)lParam)->lpCreateParams;
            SetWindowLongPtr(hWnd,0,(INT_PTR)pReport);
        } else {
            // Programming error
            assert ( FALSE );
        }

    } else {
    
        bCallDefProc = FALSE ;

        switch (uiMsg) {

            case WM_DESTROY:
                break ;

            case WM_LBUTTONDOWN:
                if (!pReport->m_pCtrl->IsUIDead()) { 

    //                pReport->m_pCtrl->Activate();
    //                pReport->m_pCtrl->AssignFocus();

                    pReport->OnLButtonDown(LOWORD (lParam), HIWORD (lParam));
                }
                break;

            case WM_CONTEXTMENU:
                if (!pReport->m_pCtrl->IsUIDead()) {

    //                pReport->m_pCtrl->Activate();
    //                pReport->m_pCtrl->AssignFocus();

                      // *** DefWindowProc is not Smonctrl, so context menu not happening.              
                    if (LOWORD(lParam)!= 0xffff || HIWORD(lParam) != 0xffff){
                        // Always call the default procedure, to handle the case where the
                        // context menu is activated from within a select rectangle.
                        bCallDefProc = TRUE;
                    }else {
                        if (!pReport->OnContextMenu(0,0))
                            bCallDefProc = TRUE;
                    }
                }
                break;

            case WM_LBUTTONDBLCLK:

                if (!pReport->m_pCtrl->IsUIDead()) { 

    //                pReport->m_pCtrl->Activate();
    //                pReport->m_pCtrl->AssignFocus();

                    pReport->OnDblClick(LOWORD (lParam), HIWORD (lParam));            
                }
        
                break;

            case WM_ERASEBKGND:
                GetClientRect(hWnd, &rect);
                SetBkColor((HDC)wParam, pReport->m_pCtrl->clrBackPlot());
                ClearRect((HDC)wParam, &rect);
                lReturnValue = TRUE; 
                break;

            case WM_PAINT:
                pReport->OnPaint () ;
                break ;

            case WM_HSCROLL:
                pReport->OnHScroll (LOWORD (wParam), HIWORD (wParam)) ;
                break ;

            case WM_VSCROLL:
                pReport->OnVScroll (LOWORD (wParam), HIWORD (wParam)) ;
                break ;

            case WM_COMMAND:
                if (pReport->m_pCtrl->IsUIDead())
                    break;

                switch (LOWORD(wParam)) {

                    case IDM_REPORT_COPY:
                    case IDM_REPORT_COPYALL:
                        break;

                    case IDM_REPORT_DELETE:
                        pReport->DeleteSelection();
                        break;

                    case IDM_PROPERTIES:
                        pReport->m_pCtrl->DisplayProperties();
                        break;

                    case IDM_ADDCOUNTERS:
                        pReport->m_pCtrl->AddCounters();
                        break;

                    case IDM_SAVEAS:
                        pReport->m_pCtrl->SaveAs();
                        break;

                    default:
                        bCallDefProc = TRUE;
               }
               break;

            default:
                bCallDefProc = TRUE ;
        }
    }

    if (bCallDefProc)
        lReturnValue = DefWindowProc (hWnd, uiMsg, wParam, lParam) ;

    return (lReturnValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\scale.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    scale.h

Abstract:

    <abstract>

--*/

#ifndef _GRAPHSCALE_H_
#define _GRAPHSCALE_H_

#define MAX_SCALE_TICS  25

class CGraphScale
{
    RECT    m_Rect;             // Scale boundary rect
    INT     m_iMaxValue;        // Upper scale limit
    INT     m_iMinValue;        // Lower scale limit
    INT     m_iTextHeight;      // Height of font
    INT     m_nTics;            // Number of tic marks
    INT     m_aiTicPos[MAX_SCALE_TICS + 1];  // Tic positions

    void SetTicPositions( void );

    enum eScaleFormat {
        eMinimumWidth = 1,
        eFloatPrecision = 1,
        eIntegerPrecision = 0
    };


public:
            CGraphScale( void );
    virtual ~CGraphScale( void );
    
    void SetMaxValue( INT iMaxValue );
    void SetMinValue( INT iMinValue );
    void SetRect( PRECT pRect );

    void Draw( HDC hDC );
    INT  GetWidth( HDC hDC );
    INT  GetTicPositions( INT **piTicPos );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\report.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    report.h

Abstract:

    Header file for the report view.

--*/

#ifndef _REPORT_H_
#define _REPORT_H_

#include "commctrl.h"

class CSysmonControl;
 
class CReport
{
friend LRESULT APIENTRY ReportWndProc (HWND hWnd,
                                       UINT uiMsg,
                                       WPARAM wParam,
                                       LPARAM lParam);

private:

    CSysmonControl *m_pCtrl;
    HWND             m_hWnd;
    RECT             m_rect;
    INT              m_xValueWidth;
    INT              m_xReportWidth;
    INT              m_yReportHeight;
    INT              m_yLineHeight;
    INT              m_xMaxCounterWidth;
    INT              m_xMaxInstancePos;
    INT              m_xInstanceMargin;
    void             *m_pSelect;
    INT              m_nSelectType;
    BOOL             m_bConfigChange;
    BOOL             m_bFontChange;

    void OnPaint        ( void );
    void SetScrollRanges ( void );
    void OnHScroll ( INT iScrollCode, INT iScrollNewPos );
    void OnVScroll ( INT iScrollCode, INT iScrollNewPos );
    void OnLButtonDown ( INT xPos, INT yPos );
    BOOL OnContextMenu ( INT xPos, INT yPos );
    void OnDblClick ( INT xPos, INT yPos );

    INT SetCounterPositions ( PCObjectNode pObject, HDC hDC );
    INT SetInstancePositions ( PCObjectNode pObject, HDC hDC );
    INT SetObjectPositions ( PCMachineNode pMachine, HDC hDC );
    INT SetMachinePositions ( PCCounterTree pTree, HDC hDC );
    
    void DrawReportHeaders ( HDC hDC );
    void DrawReportValues ( HDC hDC );
    void DrawReportValue ( HDC hDC, PCGraphItem pItem, INT xPos, INT yPos );
    void DrawSelectRect ( HDC hDC, BOOL bState );
    void Draw ( HDC hDC );
    void ApplyChanges ( HDC hDC );

    BOOL SelectName ( INT xPos, INT yPos, void **ppSelected, INT *nSelectType );
    BOOL PtInName ( POINT pt, INT x, INT y, INT xWidth )
        { return (pt.x > x && pt.x < (x + xWidth) && pt.y > y && pt.y < (y + m_yLineHeight)); } 
    PCGraphItem GetItem ( void *pSelected, INT nSelectType );
    BOOL        SelectionDeleted ( PCGraphItem pItem );
    BOOL        LargeHexValueExists ( void );
    void        GetReportItemValue(PCGraphItem pItem, LPWSTR szValue);
public:
    CReport         ( void );
    ~CReport        ( void );

    BOOL  Init ( CSysmonControl *pCtrl, HWND hWndParent ) ;
    void  AddItem ( PCGraphItem pItem );
    void  DeleteItem ( PCGraphItem pItem );
    void  DeleteSelection ( VOID );
    void  SizeComponents ( LPRECT pRect );
    void  ChangeFont ( void );
    HWND  Window ( void ) { return m_hWnd; }
    void  Update ( void );
    void  Render ( HDC hDC, HDC hAttribDC, BOOL fMetafile, BOOL fEntire, LPRECT pRect );
    BOOL  WriteFileReport(HANDLE hFile);
};

typedef CReport *PREPORT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\scale.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    scale.cpp

Abstract:

    Implements display of the scale numbers on the graph y-axis.

--*/

#include "polyline.h"
#include <strsafe.h>

#define SCALE_MARGIN 10

CGraphScale::CGraphScale( void )
:   m_iMaxValue(100),
    m_iMinValue(0),
    m_nTics(0),
    m_iTextHeight(0)
{
}

CGraphScale::~CGraphScale( void )
{
}

void CGraphScale::SetRect( PRECT pRect )
 {
    m_Rect = *pRect;
    SetTicPositions();
 }

 void CGraphScale::SetMaxValue( INT iMaxValue )
 {
    m_iMaxValue = iMaxValue;
    SetTicPositions();
}

 void CGraphScale::SetMinValue( INT iMinValue )
 {
    m_iMinValue = iMinValue;
    SetTicPositions();
}

  void CGraphScale::SetTicPositions( void )
 {
    INT iHeight;
    INT nMaxTics;
    INT i;
    CStepper  stepper;
    static INT aiTicTable[] = {25,20,10,5,4,2,1,0};

    iHeight = m_Rect.bottom - m_Rect.top;

    if (!(iHeight > 0 && m_iTextHeight > 0)) {
        m_nTics = 0;
        return;
    }

    // Determine number of labels that will fit
    nMaxTics = iHeight / (m_iTextHeight + m_iTextHeight/2);
    for (i=0; nMaxTics < aiTicTable[i]; i++) {};
    m_nTics = aiTicTable[i];

    // Don't have more labels than values
    if (m_iMaxValue - m_iMinValue < m_nTics)
        m_nTics = m_iMaxValue - m_iMinValue;

    // Locate equally spaced tic marks
    if (m_nTics > 0)
        {
        m_aiTicPos[0] = 0;
        stepper.Init(iHeight,m_nTics);

        for (i = 1; i <= m_nTics; i++)
            {
            m_aiTicPos[i] = stepper.NextPosition();
            }
        }
   }

INT CGraphScale::GetTicPositions( INT **piTics )
{
    *piTics = m_aiTicPos;
    return m_nTics;
}

INT CGraphScale::GetWidth (HDC hDC)
{
    WCHAR   szMaxValue [MAX_VALUE_LEN] ;
    SIZE    Size;
    INT     iWidth;

    // compute size of largest possible numerical label plus space
    if ( 0 != FormatNumber ( 
                (double)m_iMaxValue, 
                szMaxValue, 
                MAX_VALUE_LEN, 
                eMinimumWidth, 
                eFloatPrecision) ) {
   
        GetTextExtentPoint32(hDC, szMaxValue, lstrlen(szMaxValue), &Size);

        // Save Text height for tic calculations
        m_iTextHeight = Size.cy;

        iWidth = Size.cx + SCALE_MARGIN;
    } else {
        iWidth = 0;
    }

    return iWidth;
}


void CGraphScale::Draw (HDC hDC)
{
    WCHAR   szScale [MAX_VALUE_LEN] ;

    INT     iRetChars,
            i,
            iUnitsPerLine ;
    INT    iRange;

    FLOAT   ePercentOfTotal  ;
    FLOAT   eDiff ;
    BOOL    bUseFloatingPt = FALSE ;
    RECT    rectClip;

    // nTicks may be zero if the screen size if getting too small
    if (m_nTics < 1 || m_iMaxValue <= m_iMinValue)
        return;

    iRange = m_iMaxValue - m_iMinValue;

    // Calculate what percentage of the total each line represents.
    ePercentOfTotal = ((FLOAT) 1.0) / ((FLOAT) m_nTics)  ;

    // Calculate the amount (number of units) of the Vertical max each
    // each line in the graph represents.
    iUnitsPerLine = (INT) ((FLOAT) iRange * ePercentOfTotal) ;
    ePercentOfTotal *= (FLOAT) iRange;
    eDiff = (FLOAT)iUnitsPerLine - ePercentOfTotal ;
    if (eDiff < (FLOAT) 0.0)
        eDiff = -eDiff ;

    if ( (iUnitsPerLine < 100)  && (eDiff > (FLOAT) 0.1) ) {
        bUseFloatingPt = TRUE ;
    }

    SetTextAlign (hDC, TA_TOP | TA_RIGHT) ;

    rectClip.left = m_Rect.left;
    rectClip.right = m_Rect.right - SCALE_MARGIN;

    // Now Output each string.
    for (i = 0; i < m_nTics; i++) {
        if (bUseFloatingPt) {

            FLOAT fValue = (FLOAT)m_iMaxValue - ((FLOAT)i * ePercentOfTotal);

            iRetChars = FormatNumber ( 
                            (double)fValue, 
                            szScale, 
                            MAX_VALUE_LEN, 
                            eMinimumWidth, 
                            eFloatPrecision); 

        } else {
            iRetChars = StringCchPrintf (szScale, MAX_VALUE_LEN, L"%d", m_iMaxValue - (i * iUnitsPerLine)) ;
        }

        rectClip.top = m_aiTicPos[i] + m_Rect.top - m_iTextHeight/2;
        rectClip.bottom = rectClip.top + m_iTextHeight;
        
        ExtTextOut (
            hDC,
            rectClip.right,
            rectClip.top,
            0,
            &rectClip,
            szScale,
            lstrlen(szScale),
            NULL );
    }

    // Make sure the last value is the specified Minimum.
    if (bUseFloatingPt) {

        iRetChars = FormatNumber ( 
                        (double)m_iMinValue, 
                        szScale, 
                        MAX_VALUE_LEN, 
                        eMinimumWidth, 
                        eFloatPrecision);

    } else {
        iRetChars = StringCchPrintf (szScale, MAX_VALUE_LEN, L"%d", m_iMinValue) ;
    }

    rectClip.top = m_aiTicPos[i] + m_Rect.top - m_iTextHeight/2;
    rectClip.bottom = rectClip.top + m_iTextHeight;

    ExtTextOut (
        hDC,
        rectClip.right,
        rectClip.top,
        0,
        &rectClip,
        szScale,
        lstrlen(szScale),
        NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\resource.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Resource ID definitions.

--*/

#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#define IDR_ICON            1
#define IDR_PERFMON_ICON    2
#define IDD_EDITDIALOG      1

#define ID_UNDO             100
#define ID_COLORBACK        101
#define ID_COLORLINE        102
#define ID_GROUPCOLORS      103
#define ID_GROUPPREVIEW     104
#define ID_GROUPSTYLES      105
#define ID_GROUPFIGURE      106
#define ID_POLYLINERECT     107
#define ID_POLYLINE         108

#define ID_LINEMIN          200
#define ID_LINESOLID        200     //(ID_LINEMIN+PS_SOLID)
#define ID_LINEDASH         201     //(ID_LINEMIN+PS_DASH)
#define ID_LINEDOT          202     //(ID_LINEMIN+PS_DOT)
#define ID_LINEDASHDOT      203     //(ID_LINEMIN+PS_DASHDOT)
#define ID_LINEDASHDOTDOT   204     //(ID_LINEMIN+PS_DASHDOTDOT)

#define ID_SMONACCEL        1
#define IDM_CONTEXT         1       // Context menu items
#define IDM_PROPERTIES      2
#define IDM_ADDCOUNTERS     3
#define IDM_SAVEAS          4
#define IDM_SAVEDATA        5

#define IDM_REPORT_COPY     5       // Report context menu items
#define IDM_REPORT_COPYALL  6
#define IDM_REPORT_DELETE   7

#define IDM_HIGHLITE        10      // Accelerator Keys
#define IDM_UPDATE          11
#define IDM_DELETE          12

#define IDC_SNAPBTN         1       // Snapshot button 
#define IDB_SNAPBTN         1       // SnapShot button bitmap
#define IDB_TOOLBAR         2       // toolbar bitmap
 
#define IDC_CURS_NS         1000
#define IDC_CURS_WE         1001
#define IDC_CURS_NWSE       1002
#define IDC_CURS_NESW       1003        
#define IDC_CURS_MOVE       1004

#define IDC_CURS_MIN        1000
#define IDC_CURS_MAX        1004
#define IDC_STATIC          1005        

//Message to close the dialog
#define POLYM_CLOSE         (WM_USER+1000)

// toolbar id's
#define IDM_TOOLBAR         20
#define IDM_TB_NEW          21
#define IDM_TB_CLEAR        22
#define IDM_TB_REALTIME     23
#define IDM_TB_LOGFILE      24
#define IDM_TB_CHART        25
#define IDM_TB_HISTOGRAM    26
#define IDM_TB_REPORT       27
#define IDM_TB_ADD          28
#define IDM_TB_DELETE       29
#define IDM_TB_HIGHLIGHT    30
#define IDM_TB_COPY         31
#define IDM_TB_PASTE        32
#define IDM_TB_PROPERTIES   33
#define IDM_TB_FREEZE       34
#define IDM_TB_UPDATE       35
#define IDM_TB_HELP         36

#define IDD_SAVEDATA_DLG    8000
#define IDC_SAVEDATA_EDIT   8001

#define TB_NUM_BITMAPS      (DWORD)((IDM_TB_HELP - IDM_TB_NEW) + 1)

#include "strids.h"

#endif //_RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\smonctrl.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    smonctrl.h

Abstract:

    <abstract>

--*/

#ifndef _SMONCTRL_H_
#define _SMONCTRL_H_

#pragma warning ( disable : 4201)

#include <pdh.h>
#include "colefont.h"
#include "graph.h"

#define SMONCTRL_MAJ_VERSION    3
#define SMONCTRL_MIN_VERSION    6

#define WM_GRAPH_UPDATE     (WM_USER + 1)
#define WM_VALUES_UPDATED   (WM_USER + 2)

#define UPDGRPH_COLOR    1
#define UPDGRPH_FONT     2
#define UPDGRPH_LAYOUT   3
#define UPDGRPH_ADDCNTR  4
#define UPDGRPH_DELCNTR  5
#define UPDGRPH_PLOT     6
#define UPDGRPH_VIEW     7
#define UPDGRPH_LOGVIEW  8

#define SLQ_COUNTER_LOG     0
#define SLQ_TRACE_LOG       1
#define SLQ_ALERT_LOG       2
#define SMON_CTRL_LOG       3

#define LODWORD(ll) ((DWORD)((LONGLONG)ll & 0x00000000FFFFFFFF))
#define HIDWORD(ll) ((DWORD)(((LONGLONG)ll >> 32) & 0x00000000FFFFFFFF))
#define MAKELONGLONG(low, high) \
        ((LONGLONG) (((DWORD) (low)) | ((LONGLONG) ((DWORD) (high))) << 32))

typedef union {                        
    struct {
        SHORT      iMajor;     
        SHORT      iMinor;     
    }; 
    DWORD          dwVersion;      
} SMONCTRL_VERSION_DATA;
    
typedef struct
{
    INT32       iWidth;
    INT32       iHeight;
    INT32       nSamples;
    INT32       iScaleMax;
    INT32       iScaleMin;
    BOOL        bLegend;            // Each BOOL is 4 bytes
    BOOL        bLabels;
    BOOL        bHorzGrid;
    BOOL        bVertGrid;
    BOOL        bValueBar;
    BOOL        bManualUpdate;
    FLOAT       fUpdateInterval;
    INT32       iDisplayType;
    INT32       nGraphTitleLen;
    INT32       nYaxisTitleLen;
    OLE_COLOR   clrBackCtl;
    OLE_COLOR   clrFore;
    OLE_COLOR   clrBackPlot;
    INT32       nFileNameLen;
    INT32       iReserved1;         // Spare for future use
    LONGLONG    llStartDisp;        // On 8-byte boundary
    LONGLONG    llStopDisp;
    INT32       iAppearance;
    INT32       iBorderStyle;
    OLE_COLOR   clrGrid;    
    OLE_COLOR   clrTimeBar;    
    BOOL        bHighlight;
    BOOL        bToolbar;
    INT32       iReportValueType;
    BOOL        bReadOnly;
    BOOL        bMonitorDuplicateInstances;
    BOOL        bAmbientFont;
    INT32       iDisplayFilter;
    INT32       iDataSourceType;
    INT32       iSqlDsnLen;
    INT32       iSqlLogSetNameLen;
    INT32       iColorIndex;
    INT32       iWidthIndex;
    INT32       iStyleIndex;
    LONG32      arrlReserved[22];   // Spare, fill out to 256 bytes
} GRAPHCTRL_DATA3;


enum COLLECT_MODE {
    COLLECT_ACTIVE = 1,
    COLLECT_SUSPEND,
    COLLECT_QUIT
};

enum eBorderStyle {
    eBorderFirst = 0,
    eBorderNone = eBorderFirst,
    eBorderSingle = 1,
    eBorderCount
};

enum eAppearance {
    eAppearFirst = 0,
    eAppearFlat = eAppearFirst,
    eAppear3D = 1,
    eAppearCount
};

typedef struct {
    HANDLE      hEvent;
    HANDLE      hThread;
    DWORD       dwInterval;
    DWORD       dwSampleTime;
    COLLECT_MODE iMode;
} COLLECT_PROC_INFO;

class CLogFileItem;
class CGraphItem;
class CCounterTree;
class CStatsBar;
class CSnapBar;
class CSysmonToolbar;
class CReport;
class CLegend;
class CGraphDisp;

typedef struct {
    LPWSTR      pszFileName;
} LOG_FILE_INFO;

typedef struct {
    HLOG           hDataSource;
    LPWSTR         szSqlDsnName;
    LPWSTR         szSqlLogSetName;
    CLogFileItem * pFirstLogFile;
    INT32          nSamples;       
    LONGLONG       llBeginTime;
    LONGLONG       llEndTime;
    LONGLONG       llStartDisp;
    LONGLONG       llStopDisp;
    LONGLONG       llInterval;         
    LONG           lLogFileCount;
} DATA_SOURCE_INFO;


class CSysmonControl
{

friend class CPolyline;
friend class CImpISystemMonitor;
friend class CSysmonToolbar;
friend LRESULT APIENTRY SysmonCtrlWndProc (HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
friend  DWORD WINAPI CollectProc(CSysmonControl *pCtrl);

public:

            CSysmonControl          ( CPolyline *pObj );
    virtual ~CSysmonControl         ( void );

    void    put_BackCtlColor ( OLE_COLOR color );
    void    put_FgndColor ( OLE_COLOR color, BOOL fAmbient );
    void    put_BackPlotColor ( OLE_COLOR color, BOOL fAmbient );
    void    put_GridColor ( OLE_COLOR color );
    void    put_TimeBarColor ( OLE_COLOR color );

    HRESULT put_Font( LPFONT pIFont, BOOL fAmbient );
    HRESULT get_DataSourceType( eDataSourceTypeConstant& eDataSourceType );
    HRESULT put_DataSourceType( INT iDataSourceType );

    HRESULT AddSingleLogFile ( LPCWSTR pPath, CLogFileItem** ppLogFile = NULL );
    HRESULT RemoveSingleLogFile ( CLogFileItem* pLogFile );
    // TodoLogFiles:  Move FirstLogFile, NumLogFiles, to Graph.h?
    CLogFileItem* FirstLogFile ( void ) { return m_DataSourceInfo.pFirstLogFile; };
    INT           NumLogFiles ( void ){ return m_DataSourceInfo.lLogFileCount; };

    void    put_Appearance( INT iApp, BOOL fAmbient );
    void    put_BorderStyle( INT iStyle, BOOL fAmbient );  
    void    put_Highlight ( BOOL bState );

    void    put_ManualUpdate ( BOOL bManual );

    static BOOL RegisterWndClass( void );

    COLORREF clrBackCtl ( void ) { return m_clrBackCtl; }
    COLORREF clrFgnd ( void ) { return m_clrFgnd; }
    COLORREF clrBackPlot ( void ) { return m_clrBackPlot; }
    COLORREF clrGrid ( void ) { return m_clrGrid; }
    COLORREF clrTimeBar ( void ) { return m_clrTimeBar; }

    INT Appearance( void ) { return m_iAppearance; } 
    INT BorderStyle( void ) { return m_iBorderStyle; } 

    eReportValueTypeConstant ReportValueType ( void );

    HFONT    Font    ( void ) { HFONT hFont; m_OleFont.GetHFont(&hFont); return hFont; }
    HFONT    BoldFont( void ) { HFONT hFont; m_OleFont.GetHFontBold(&hFont); return hFont; }
    void     FontChanged ( void );
    void     IncrementVisuals ( void );

    BOOL Init               ( HWND hWndParent );
    void DeInit             ( void );
    BOOL AllocateSubcomponents  ( void );       
    void UpdateNonAmbientSysColors ( void );
    HRESULT LoadFromStream  ( LPSTREAM pIStream );
    HRESULT SaveToStream    ( LPSTREAM pIStream );

    HRESULT LoadFromPropertyBag ( IPropertyBag*, IErrorLog* );
    HRESULT SaveToPropertyBag   ( IPropertyBag*, BOOL fSaveAllProps );
    HRESULT LoadCountersFromPropertyBag ( IPropertyBag*, IErrorLog*, BOOL bLoadData=TRUE );
    HRESULT LoadLogFilesFromPropertyBag ( IPropertyBag*, IErrorLog* );
    HRESULT LoadLogFilesFromMultiSz ( LPCWSTR  szLogFileList );


    void Render             ( HDC hDC, HDC hAttribDC, BOOL fMetafile, BOOL fEntire, LPRECT pRect );

    void UpdateGraph        ( INT nUpdateType );
    void SetIntervalTimer   ( void );
    PDH_STATUS UpdateCounterValues( BOOL bManual );

    HRESULT AddCounter      ( LPWSTR pPath, CGraphItem* *ppCtr );
    HRESULT AddSingleCounter ( LPWSTR pPath, CGraphItem* *ppCtr );
    HRESULT DeleteCounter   ( CGraphItem* pCtr, BOOL bPropagate );
    HRESULT Paste           ( void );
    HRESULT Copy            ( void );
    HRESULT Reset           ( void );

    void    SelectCounter   ( CGraphItem* pCtr );
    void    DblClickCounter ( CGraphItem* pCtr );

    CGraphItem* FirstCounter ( void );
    CGraphItem* LastCounter  ( void );
    CCounterTree* CounterTree ( void );
    INT CounterIndex ( CGraphItem* pCtr );

    HWND Window             ( void );
    HRESULT TranslateAccelerators( LPMSG pMsg );

    INT     ConfirmSampleDataOverwrite ( void );
    HRESULT DisplayProperties   ( DISPID dispID = DISPID_UNKNOWN );
    HRESULT AddCounters ( void );
    HRESULT SaveAs ( void );
    HRESULT SaveData ( void );
    void    Activate ( void );
    BOOL    IsUIDead ( void ) { return m_fUIDead; }
    BOOL    IsUserMode ( void ) { return m_fUserMode; }
    BOOL    IsReadOnly ( void );
    BOOL    DisplayHelp ( HWND hWndSelf );

    void LockCounterData ( void ) { EnterCriticalSection(&m_CounterDataLock); }
    void UnlockCounterData ( void ) { LeaveCriticalSection(&m_CounterDataLock); }

    BOOL IsLogSource ( void );
    PHIST_CONTROL   HistoryControl( void ) { return m_pHistCtrl; }

    void    SetLogViewTempTimeRange(LONGLONG llStart, LONGLONG LLStop);
    void    ResetLogViewTempTimeRange( void );

    double  GetZoomFactor ( void ) { return m_dZoomFactor; };
    void    CalcZoomFactor ( void );

    LONG    GetSaveDataFilter ( void ) { return m_lSaveDataToLogFilterValue; };
    BOOL    SetSaveDataFilter ( long lFilter ) 
    { 
        if (lFilter) {
            m_lSaveDataToLogFilterValue = lFilter; 
            return TRUE; 
        }
        return FALSE;
    };

    void DrawBorder ( HDC hDC );
    BOOL WriteFileReportHeader(HANDLE hFile);

    // *** TodoMultiLogHandle:  Temporary method.  Remove when trace file post-processing supports multiple
    // open files.
    HQUERY  TempGetQueryHandle ( void ){ return m_hQuery; };

private:

    void ApplyChanges ( HDC hDC );
    void Paint ( void );
    void OnDblClick ( INT xPos, INT yPos );
    void OnDropFile ( WPARAM wParam );
    void DisplayContextMenu ( short x, short y );
    void UpdateGraphData ( void );
    void OnValuesUpdated ( void );
    void SizeComponents  ( HDC hDC );
    void AssignFocus( VOID );
    BOOL InitView ( HWND hWndParent );
    
    PRECT   GetNewClientRect ( void );
    PRECT   GetCurrentClientRect ( void );
    void    SetCurrentClientRect ( PRECT );    

    HRESULT ProcessDataSourceType( LPCWSTR pszDataSourceName, INT iDataSourceType );
    LPCWSTR GetDataSourceName ( void );
    HLOG    GetDataSourceHandle(void) { return m_DataSourceInfo.hDataSource; }

    HRESULT CopyToBuffer ( LPWSTR& rpszData, DWORD& rdwBufferSize );
    HRESULT PasteFromBuffer ( LPWSTR pszData, BOOL bAllSettings = FALSE );

    DWORD   InitializeQuery ( void );
    DWORD   ActivateQuery ( void );
    void    CloseQuery ( void );

    HRESULT InitLogFileIntervals( void );
    void    SampleLogFile ( BOOL bViewChange );

    void  Clear( void );

    void  FindNextValidStepNum(
            BOOL bDecrease, 
            CGraphItem* pItem, 
            LONGLONG llNewTime, 
            INT& riNewStepNum, 
            DWORD& rdwStatus );

    void  GetNewLogViewStepNum(LONGLONG llNewTime, INT& riNewStepNum);

    DWORD ProcessCommandLine( void );

    HRESULT LoadFromFile( LPWSTR szFileName, BOOL bAllData );

    DWORD   RelogLogData ( 
        LPCWSTR szOutputFile,
        DWORD   dwOutputLogType,
        PDH_TIME_INFO   pdhTimeInfo,
        DWORD   dwFilterCount);

    HRESULT GetSelectedCounter ( CGraphItem** ppCtr );

    DWORD   BuildLogFileList (
                LPWSTR  szLogFileList,
                BOOL    bIsCommaDelimited,
                ULONG*  pulBufLen );

    DWORD   AddToErrorPathList ( LPCWSTR szPath );
    LPCWSTR GetErrorPathList ( DWORD* pdwListLen );
    void    ClearErrorPathList ( void );
    
    DWORD   AddToErrorLogFileList ( LPCWSTR szPath );
    LPCWSTR GetErrorLogFileList ( DWORD* pdwListLen );
    void    ClearErrorLogFileList ( void );
    
    SMONCTRL_VERSION_DATA m_LoadedVersion;
    BOOL        m_fInitialized;
    BOOL        m_fViewInitialized;
    HWND        m_hWnd;
    CLegend*    m_pLegend;
    CGraphDisp* m_pGraphDisp;
    CStatsBar*  m_pStatsBar;
    CSnapBar*   m_pSnapBar;
    CReport*    m_pReport;
    CSysmonToolbar*  m_pToolbar;
    CPolyline  *m_pObj;
    PHIST_CONTROL m_pHistCtrl;
    HQUERY      m_hQuery;
    UINT        m_TimerID;
    BOOLEAN     m_fPendingUpdate;
    BOOLEAN     m_fPendingSizeChg;
    BOOLEAN     m_fPendingFontChg;
    BOOLEAN     m_fPendingLogViewChg;
    BOOLEAN     m_fPendingLogCntrChg;
    BOOLEAN     m_fUIDead;
    BOOLEAN     m_fUserMode;
    BOOLEAN     m_fDuplicate;
    BOOLEAN     m_fRTL;
    COLORREF    m_clrBackCtl;
    COLORREF    m_clrFgnd;
    COLORREF    m_clrBackPlot;
    COLORREF    m_clrGrid;
    COLORREF    m_clrTimeBar;
    INT         m_iAppearance;
    INT         m_iBorderStyle;
    eDisplayTypeConstant    m_eDisplayType;
    BOOL        m_bLogFileSource;
    BOOL        m_bSampleDataLoaded;
    double      m_dZoomFactor;
    BOOL        m_bLoadingCounters;
    BOOL        m_bSettingsLoaded;
    LONG        m_lSaveDataToLogFilterValue;
    LCID        m_lcidCurrent;

    // Item properties, for saving and loading counters.
    COLORREF    m_clrCounter;
    INT         m_iColorIndex;
    INT         m_iWidthIndex;
    INT         m_iStyleIndex;
    INT         m_iScaleFactor;

    HFONT       m_hFont;
    COleFont    m_OleFont;
    PDH_BROWSE_DLG_CONFIG   m_BrowseInfo;
    CGraphItem* m_pSelectedItem;
    HACCEL      m_hAccel;
    DATA_SOURCE_INFO    m_DataSourceInfo;
    COLLECT_PROC_INFO   m_CollectInfo;
    CRITICAL_SECTION    m_CounterDataLock;
    RECT        m_rectCurrentClient;

    LPWSTR      m_szErrorPathList;
    DWORD       m_dwErrorPathListLen;
    DWORD       m_dwErrorPathBufLen;

};

typedef CSysmonControl *PSYSMONCTRL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\smonhelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    smonhelp.h

Abstract:

    Help IDs for the System Monitor control.

--*/

//Property pages
#define IDH_PG_SYSMON_GENERAL   1000100
#define IDH_PG_SYSMON_GRAPH     1000101
#define IDH_PG_SYSMON_DATA      1000102
#define IDH_PG_SYSMON_SOURCE    1000103

//General
#define IDH_GALLERY_GRAPH       1000001 
#define IDH_GALLERY_HISTOGRAM   1000002
#define IDH_GALLERY_REPORT      1000003
#define IDH_LEGEND              1000004
#define IDH_VALUEBAR            1000005
#define IDH_TOOLBAR             1000006
#define IDH_COMBOAPPEARANCE     1000007     // new name for IDH_APPEARANCE
#define IDH_COMBOBORDERSTYLE    1000008     // new name for IDH_BORDERSTYLE
#define IDH_PERIODIC_UPDATE     1000009
#define IDH_DISPLAY_INTERVAL	2000001     // added for Whistler
//#define IDH_MANUAL_UPDATE       1000010   // remove
#define IDH_UPDATE_INTERVAL     1000011
#define IDH_RPT_VALUE_DEFAULT   1000012
#define IDH_RPT_VALUE_CURRENT   1000013
#define IDH_RPT_VALUE_AVERAGE   1000014
#define IDH_RPT_VALUE_MINIMUM   1000015
#define IDH_RPT_VALUE_MAXIMUM   1000016
#define IDH_DUPLICATE_INSTANCE  1000017

//Graph
#define IDH_GRAPH_TITLE         1000020
#define IDH_YAXIS_TITLE         1000021
#define IDH_VERTICAL_GRID       1000022
#define IDH_HORIZONTAL_GRID     1000023
#define IDH_VERTICAL_MAX        1000024
#define IDH_VERTICAL_MIN        1000025
#define IDH_VERTICAL_LABELS     1000026

//Data
#define IDH_CTRLIST             1000030
#define IDH_LINECOLOR           1000031
#define IDH_LINESCALE           1000032
#define IDH_LINEWIDTH           1000033
#define IDH_LINESTYLE           1000034 
#define IDH_ADDCTR              1000035
#define IDH_DELCTR              1000036

//Source
#define IDH_LOGFILENAME         1000041
#define IDH_SRC_LOGFILE         1000044
#define IDH_SRC_REALTIME	    2000002     // added for Whistler
#define IDH_LIST_LOGFILENAME	2000003     // added for Whistler
#define IDH_ADDFILE             2000004     // added for Whistler
#define IDH_REMOVEFILE          2000005     // added for Whistler
#define IDH_SRC_SQL             2000006     // added for Whistler
#define IDH_DSN_COMBO           2000007     // added for Whistler
#define IDH_LOGSET_COMBO        2000008     // added for Whistler
#define IDH_TIMESELECTBTN       2000009     // added for Whistler
#define IDH_TIMERANGE           2000010     // added for Whistler
#define IDH_BROWSEFILE          1000045

// Appearance
#define IDH_COLOROBJECTS        2000011
#define IDH_COLORBUTTON         2000012
#define IDH_FONTBUTTON          2000013
#define IDH_FONTSAMPLE          2000014
#define IDH_COLORSAMPLE         2000015

//Browse Dialog
#define IDH_USE_LOCAL_MACHINE   1000090
#define IDH_SELECT_MACHINE      1000091
#define IDH_MACHINE_COMBO       1000092
#define IDH_OBJECT_COMBO        1000093
#define IDH_COUNTER_LIST        1000094
#define IDH_ALL_INSTANCES       1000095
#define IDH_USE_INSTANCE_LIST   1000096
#define IDH_INSTANCE_LIST       1000097
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\smonid.h ===
// Copyright (C) Microsoft Corporation, 2000-20001
//
// DISPID values for Sysmon.ocx
//
// Just follow the template when adding either DISPIDs or new interfaces.
//

#ifndef __SYSMONDISPID_H__
#define __SYSMONDISPID_H__

#define DISPID_COUNTERITEM_COLOR                                0x0001
#define DISPID_COUNTERITEM_WIDTH                                0x0002
#define DISPID_COUNTERITEM_LINESTYLE                            0x0003
#define DISPID_COUNTERITEM_SCALEFACTOR                          0x0004
#define DISPID_COUNTERITEM_PATH                                 0x0005

#define DISPID_SYSMON_VERTICALGRID                              0x0001
#define DISPID_SYSMON_HORIZONTALGRID                            0x0002
#define DISPID_SYSMON_LEGEND                                    0x0003
#define DISPID_SYSMON_SCALELABELS                               0x0004
#define DISPID_SYSMON_VALUEBAR                                  0x0005
#define DISPID_SYSMON_MAXIMUMSCALE                              0x0006
#define DISPID_SYSMON_MINIMUMSCALE                              0x0007
#define DISPID_SYSMON_UPDATEINTERVAL                            0x0008
#define DISPID_SYSMON_DISPLAYTYPE                               0x0009
#define DISPID_SYSMON_MANUALUPDATE                              0x0010
#define DISPID_SYSMON_GRAPHTITLE                                0x0011
#define DISPID_SYSMON_YAXISLABEL                                0x0012
// Win2K Beta 1: Counter collection = 13
#define DISPID_SYSMON_COLLECTSAMPLE                             0x0014
#define DISPID_SYSMON_UPDATEGRAPH                               0x0015
#define DISPID_SYSMON_BROWSECOUNTERS                            0x0016
#define DISPID_SYSMON_DISPLAYPROPERTIES                         0x0017
#define DISPID_SYSMON_COUNTER                                   0x0018
#define DISPID_SYSMON_ADDCOUNTER                                0x0019
#define DISPID_SYSMON_DELETECOUNTER                             0x0020
#define DISPID_SYSMON_BACKCOLORCTL                              0x0021
#define DISPID_SYSMON_LOGFILENAME                               0x0022
#define DISPID_SYSMON_LOGVIEWSTART                              0x0023
#define DISPID_SYSMON_LOGVIEWSTOP                               0x0024
#define DISPID_SYSMON_GRIDCOLOR                                 0x0025
#define DISPID_SYSMON_TIMEBARCOLOR                              0x0026
#define DISPID_SYSMON_HIGHLIGHT                                 0x0027
#define DISPID_SYSMON_TOOLBAR                                   0x0028
#define DISPID_SYSMON_PASTE                                     0x0029
#define DISPID_SYSMON_COPY                                      0x0030
#define DISPID_SYSMON_RESET                                     0x0031
#define DISPID_SYSMON_READONLY                                  0x0032
#define DISPID_SYSMON_REPORTVALUETUPE                           0x0033
#define DISPID_SYSMON_MONITORDUPLICATEINSTANCES                 0x0034
#define DISPID_SYSMON_DISPLAYFILTER                             0x0035
#define DISPID_SYSMON_LOGFILES                                  0x0036
#define DISPID_SYSMON_DATASOURCETYPE                            0x0037
#define DISPID_SYSMON_SQLDSNNAME                                0x0038
#define DISPID_SYSMON_SQLLOGSETNAME                             0x0039

#define DISPID_SMONEVENT_COUNTERSELECTED                        0x0001
#define DISPID_SMONEVENT_COUNTERADDED                           0x0002
#define DISPID_SMONEVENT_COUNTERDELETED                         0x0003
#define DISPID_SMONEVENT_SAMPLECOLLECTED                        0x0004
#define DISPID_SMONEVENT_DBLCLICK                               0x0005

#endif  //__SYSMONDISPID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\smonctrl.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    smonctrl.cpp

Abstract:

    This module handles the graphing window.

--*/

#pragma warning ( disable : 4127 )

#ifndef _LOG_INCLUDE_DATA 
#define _LOG_INCLUDE_DATA 0
#endif

//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include "polyline.h"

#include <limits.h>     // for INT_MAX
#include <strsafe.h>
#include <cderr.h>

#ifdef _WIN32_IE
#if      _WIN32_IE < 0x0400
#undef     _WIN32_IE
#define    _WIN32_IE 0x0400 // for NMTBCUSTOMDRAW 
#endif // < 0x0400
#endif // defined
#include <commctrl.h>
#include <htmlhelp.h>
#include <shellapi.h>
#include <pdhp.h>
#include "cntrtree.h"
#include "commdlg.h"
#include "unihelpr.h"
#include "winperf.h"
#include "pdhmsg.h"
#include "smonmsg.h"
#include "visuals.h"
#include "statbar.h"
#include "snapbar.h"
#include "legend.h"
#include "toolbar.h"    
#include "grphdsp.h"
#include "report.h"
#include "browser.h"
#include "appmema.h"
#include "ipropbag.h"
#include "logsrc.h"
#include "smonmsg.h"
#include "smonid.h"
#include "smonctrl.h"
#include "strnoloc.h"
#include "grphitem.h"
#include "winhelpr.h"


//==========================================================================//
//                                  Constants                               //
//==========================================================================//
extern CCounterTree g_tree;
extern DWORD        g_dwScriptPolicy;

#define     DBG_SHOW_STATUS_PRINTS  1

//=============================//
// Graph Class                 //
//=============================//

static DWORD   dwDbgPrintLevel = 0;

static WCHAR   szSysmonCtrlWndClass[] = L"SysmonCtrl";

static WCHAR   LineEndStr[] = TEXT("\n") ;
static WCHAR   SpaceStr[] = TEXT(" ");

typedef struct {
    CSysmonControl  *pCtrl;
    PCGraphItem     pFirstItem;
} ENUM_ADD_COUNTER_CALLBACK_INFO;


BOOL
APIENTRY
SaveDataDlgHookProc (
    HWND hDlg,
    UINT iMessage,
    WPARAM wParam,
    LPARAM lParam
)
{
    BOOL           bHandled;
    CSysmonControl *pCtrl;
    LONG           lFilterValue;
    BOOL           bGoodNumber = FALSE;

    UNREFERENCED_PARAMETER (wParam);
    // lparam = CSysmonControl class pointer

    bHandled = FALSE ;

    switch (iMessage) {
        case WM_INITDIALOG:
            // initialize the filter edit control with the current value
            OPENFILENAME    *pOfn;

            pOfn= (OPENFILENAME *)lParam;

            if ( NULL != pOfn ) {
                // get the control class pointer from the OPENFILENAME struct
                pCtrl = (CSysmonControl  *)pOfn->lCustData;
            
                // save the pointer to the control class as a DLG data word
                SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR)pCtrl);
                lFilterValue = pCtrl->GetSaveDataFilter();
                SetDlgItemInt (hDlg, IDC_SAVEDATA_EDIT, (UINT)lFilterValue, FALSE);
                // limit reduction to 1/9999  records
                SendDlgItemMessage (hDlg, IDC_SAVEDATA_EDIT, EM_LIMITTEXT, (WPARAM)4, (LPARAM)0);
            
                bHandled = TRUE ;
            }
            break ;

        case WM_DESTROY:
            // the user has closed the dialog box so get the relog filter value
            // (note: this should be ignored if the user cancels the dialog)
            pCtrl = (CSysmonControl *)GetWindowLongPtr (hDlg, DWLP_USER);
            lFilterValue = GetDlgItemInt (hDlg, IDC_SAVEDATA_EDIT, &bGoodNumber, FALSE);
            if (bGoodNumber) {
                pCtrl->SetSaveDataFilter( lFilterValue );
            }
            bHandled = TRUE ;
            break ;


        case WM_NOTIFY:
        { 
            LPOFNOTIFY pOFNotify;
            
            pOFNotify = (LPOFNOTIFY) lParam;
            if (pOFNotify) {
                if (pOFNotify->hdr.code == CDN_FILEOK) {
                    lFilterValue = GetDlgItemInt (hDlg, IDC_SAVEDATA_EDIT, &bGoodNumber, FALSE);
                    if (!bGoodNumber || lFilterValue == 0) {

                        MessageBox(hDlg,
                                  ResourceString(IDS_FILTER_VALUE_ERR),
                                  ResourceString(IDS_APP_NAME),
                                  MB_OK | MB_ICONSTOP);
                        ::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
    
                        bHandled = TRUE;
                    }
                }
            }
           
            break;
        }

        default:
            break;
    }
    return bHandled;
}

HRESULT
AddCounterCallback (
    LPWSTR      pszPathName,
    DWORD_PTR   lpUserData,          
    DWORD       dwFlags
    )
{
    ENUM_ADD_COUNTER_CALLBACK_INFO *pInfo = (ENUM_ADD_COUNTER_CALLBACK_INFO*)lpUserData;                        
    CSysmonControl *pCtrl = pInfo->pCtrl;                       
    PCGraphItem pGraphItem = NULL;
    HRESULT hr;

    hr = pCtrl->AddSingleCounter(pszPathName, &pGraphItem);

    if (SUCCEEDED(hr)) {

        if (dwFlags & BROWSE_WILDCARD) 
            pGraphItem->m_fGenerated = TRUE;

        if ( NULL == pInfo->pFirstItem ) {
            // Keep the reference count if returning the pointer.
           pInfo->pFirstItem = pGraphItem;
        } else {
            pGraphItem->Release();
        }
    }

    return hr;
}


#pragma warning( disable : 4355 ) // "this" use in initializer list

CSysmonControl::CSysmonControl( 
    PCPolyline pObj )
    :   m_OleFont(this),
        m_pObj(pObj),               // Pointer back to owner.
        m_fInitialized(FALSE),
        m_fViewInitialized(FALSE),
        m_hWnd(NULL),
        m_pLegend(NULL),
        m_pGraphDisp(NULL),
        m_pStatsBar(NULL),
        m_pSnapBar(NULL),
        m_pReport(NULL),
        m_pToolbar(NULL),        
        m_hQuery(NULL),
        m_TimerID(0),
        m_fPendingUpdate(FALSE),
        m_fPendingSizeChg(FALSE),   
        m_fPendingFontChg(FALSE),
        m_fPendingLogViewChg(FALSE),
        m_fPendingLogCntrChg(FALSE),
        m_pSelectedItem(NULL),
        m_fUIDead(FALSE),
        m_fRTL(FALSE),
        m_fUserMode(FALSE),
        m_hAccel(NULL),
        m_bLogFileSource(FALSE),
        m_bSampleDataLoaded(FALSE),
        m_bLoadingCounters(FALSE),
        m_bSettingsLoaded(FALSE),
        m_szErrorPathList ( NULL ),
        m_dwErrorPathListLen ( 0 ),
        m_dwErrorPathBufLen ( 0 ),
        // Default attributes
        m_iColorIndex(0),
        m_iWidthIndex(0),
        m_iStyleIndex(0),
        m_iScaleFactor(INT_MAX),
        m_iAppearance(eAppear3D),
        m_iBorderStyle(eBorderNone),
        m_dZoomFactor(1.0),
        m_lcidCurrent ( LOCALE_USER_DEFAULT ) 
{
    PGRAPH_OPTIONS  pOptions;

    m_LoadedVersion.iMajor = SMONCTRL_MAJ_VERSION;
    m_LoadedVersion.iMinor = SMONCTRL_MIN_VERSION;

    m_clrBackCtl = GetSysColor(COLOR_BTNFACE);
    m_clrFgnd = GetSysColor(COLOR_BTNTEXT);
    m_clrBackPlot = GetSysColor(COLOR_WINDOW);

    m_clrGrid = RGB(128,128,128);   // Medium gray
    m_clrTimeBar = RGB(255,0,0);    // Red

    m_lSaveDataToLogFilterValue = 1;    // default save data to log filter is 1
    // Init graph parameters
    pOptions = &pObj->m_Graph.Options;

    pOptions->bLegendChecked = TRUE;
    pOptions->bToolbarChecked = TRUE;
    pOptions->bLabelsChecked = TRUE;
    pOptions->bVertGridChecked = FALSE;
    pOptions->bHorzGridChecked = FALSE;
    pOptions->bValueBarChecked = TRUE;
    pOptions->bManualUpdate = FALSE;
    pOptions->bHighlight = FALSE;    
    pOptions->bReadOnly = FALSE;
    pOptions->bMonitorDuplicateInstances = TRUE;
    pOptions->bAmbientFont = TRUE;
    pOptions->iVertMax = 100;
    pOptions->iVertMin = 0;
    pOptions->fUpdateInterval = (float)1.0;
    pOptions->iDisplayFilter = 1;
    pOptions->iDisplayType = sysmonLineGraph;
    pOptions->iReportValueType = sysmonDefaultValue;
    pOptions->pszGraphTitle = NULL;
    pOptions->pszYaxisTitle = NULL;
    pOptions->clrBackCtl = ( 0x80000000 | COLOR_BTNFACE );
    pOptions->clrGrid = m_clrGrid;
    pOptions->clrTimeBar = m_clrTimeBar;
    pOptions->clrFore = NULL_COLOR; 
    pOptions->clrBackPlot = NULL_COLOR; 
    pOptions->iAppearance = NULL_APPEARANCE;    
    pOptions->iBorderStyle = eBorderNone;
    pOptions->iDataSourceType = sysmonCurrentActivity;

    // Init data source info
    memset ( &m_DataSourceInfo, 0, sizeof ( m_DataSourceInfo ) );
    m_DataSourceInfo.llStartDisp = MIN_TIME_VALUE;
    m_DataSourceInfo.llStopDisp = MAX_TIME_VALUE;

    // Init collection thread info
    m_CollectInfo.hThread = NULL;
    m_CollectInfo.hEvent = NULL;
    m_CollectInfo.iMode = COLLECT_SUSPEND;

    // Cache pointer to object's history control
    m_pHistCtrl = &pObj->m_Graph.History;

    assert ( NULL != pObj );

    pObj->m_Graph.LogViewTempStart = MIN_TIME_VALUE;
    pObj->m_Graph.LogViewTempStop = MAX_TIME_VALUE;

    // Init the log view and time steppers.  They might be used before
    // SizeComponents is called, for example when a property bag is loaded.  
    // The width has not been calculated yet, is initialized here 
    // to an arbitrary number.

    pObj->m_Graph.TimeStepper.Init( MAX_GRAPH_SAMPLES, MAX_GRAPH_SAMPLES - 2 );
    pObj->m_Graph.LogViewStartStepper.Init( MAX_GRAPH_SAMPLES, MAX_GRAPH_SAMPLES - 2 );
    pObj->m_Graph.LogViewStopStepper.Init( MAX_GRAPH_SAMPLES, MAX_GRAPH_SAMPLES - 2 );        
    
    m_pHistCtrl->bLogSource = FALSE;
    m_pHistCtrl->nMaxSamples = MAX_GRAPH_SAMPLES;
    m_pHistCtrl->iCurrent = 0;
    m_pHistCtrl->nSamples = 0;
    m_pHistCtrl->nBacklog = 0;

    // Keep record of current size to avoide unnecessary calls to SizeComponents
    SetRect ( &m_rectCurrentClient,0,0,0,0 );
}

BOOL
CSysmonControl::AllocateSubcomponents( void )
{
    BOOL bResult = TRUE;

    //
    // Initialize the critical section here rather than in 
    // the constructor because it can throw an exception.
    //

    try {
         InitializeCriticalSection(&m_CounterDataLock);
    } catch (...) {
        bResult = FALSE;
    }

    if ( bResult ) {
        m_pLegend = new CLegend;
        m_pGraphDisp = new CGraphDisp;
        m_pStatsBar = new CStatsBar;
        m_pSnapBar = new CSnapBar;
        m_pReport = new CReport;
        m_pToolbar = new CSysmonToolbar;
    }

    if (m_pLegend == NULL ||
        m_pGraphDisp == NULL ||
        m_pStatsBar == NULL ||
        m_pSnapBar == NULL ||
        m_pReport == NULL ||
        m_pToolbar == NULL) {

        bResult = FALSE;
    }

    if (!bResult) {
        DeInit();
        return bResult;
    }

    if ( FAILED(m_OleFont.Init()) )
        bResult = FALSE;

    return bResult;

}



CSysmonControl::~CSysmonControl( void )
{
    PCGraphItem     pItem; 
    PCGraphItem     pNext;
    PCLogFileItem   pLogFile; 
    PCLogFileItem   pNextLogFile;

    CloseQuery();

    DeInit();

    DeleteCriticalSection(&m_CounterDataLock);

    // Release all graph items
    pItem = FirstCounter();
    while ( NULL != pItem ) {
        pNext = pItem->Next();
        pItem->Release();
        pItem = pNext;
    }

    // Release all log file items
    pLogFile = FirstLogFile();
    while ( NULL != pLogFile ) {
        pNextLogFile = pLogFile->Next();
        pLogFile->Release();
        pLogFile = pNextLogFile;
    }

    if (m_DataSourceInfo.szSqlDsnName != NULL) {
        delete [] m_DataSourceInfo.szSqlDsnName;
        m_DataSourceInfo.szSqlDsnName = NULL;
    }

    if (m_DataSourceInfo.szSqlLogSetName != NULL) {
        delete [] m_DataSourceInfo.szSqlLogSetName;
        m_DataSourceInfo.szSqlLogSetName = NULL;
    }

    if (m_hWnd != NULL)
         DestroyWindow(m_hWnd);

    if (m_pObj->m_Graph.Options.pszGraphTitle != NULL)
        delete [] m_pObj->m_Graph.Options.pszGraphTitle;

    if (m_pObj->m_Graph.Options.pszYaxisTitle != NULL)
        delete [] m_pObj->m_Graph.Options.pszYaxisTitle;

    ClearErrorPathList();
}

void CSysmonControl::DeInit( void )
{
    if (m_pLegend) {
        delete m_pLegend;
        m_pLegend = NULL;
    }
    if (m_pGraphDisp) {
        delete m_pGraphDisp;
        m_pGraphDisp = NULL;
    }
    if (m_pStatsBar) {
        delete m_pStatsBar;
        m_pStatsBar = NULL;
    }
    if (m_pSnapBar) {
        delete m_pSnapBar;
        m_pSnapBar = NULL;
    }
    if (m_pReport) {
        delete m_pReport;
        m_pReport = NULL;
    }
    if (m_pToolbar) {
        delete m_pToolbar;
        m_pToolbar = NULL;
    }
    ClearErrorPathList();
}

void CSysmonControl::ApplyChanges( HDC hAttribDC )
{
    if ( m_fPendingUpdate ) {

        // Clear the master update flag
        m_fPendingUpdate = FALSE;

        // set the toolbar state
        m_pToolbar->ShowToolbar(m_pObj->m_Graph.Options.bToolbarChecked);

        // If log view changed or counters added
        // we need to resample the log file
        if (m_fPendingLogViewChg || m_fPendingLogCntrChg) {

             SampleLogFile(m_fPendingLogViewChg);
             // Must init time steppers before calling ResetLogViewTempTimeRange
             ResetLogViewTempTimeRange ( );
             m_fPendingLogViewChg = FALSE;
             m_fPendingLogCntrChg = FALSE;
        }

        if (m_fPendingFontChg || m_fPendingSizeChg) {

            if (NULL != hAttribDC ) {
                if (m_fPendingFontChg) {
                    m_pLegend->ChangeFont(hAttribDC);
                    m_pStatsBar->ChangeFont(hAttribDC);
                    m_pGraphDisp->ChangeFont(hAttribDC);
                    m_fPendingFontChg = FALSE;
                }

                SizeComponents( hAttribDC );
                m_fPendingSizeChg = FALSE;
            }
        }
    
        m_pToolbar->SyncToolbar();
    }
}

void 
CSysmonControl::DrawBorder ( HDC hDC )
{
    if ( eBorderSingle == m_iBorderStyle ) {
        RECT rectClient;
        //
        // Get dimensions of window
        //
        GetClientRect (m_hWnd, &rectClient) ;

        if ( eAppear3D == m_iAppearance ) {
            DrawEdge(hDC, &rectClient, EDGE_RAISED, BF_RECT);
        } else {
            SelectBrush (hDC, GetStockObject (HOLLOW_BRUSH)) ;
            SelectPen (hDC, GetStockObject (BLACK_PEN)) ;
            Rectangle (hDC, rectClient.left, rectClient.top, rectClient.right, rectClient.bottom );
        }
    }
}

void CSysmonControl::Paint ( void )
{
    HDC            hDC ;
    PAINTSTRUCT    ps ;

    hDC = BeginPaint (m_hWnd, &ps) ;

    //
    // ApplyChanges does some work even if hDC is NULL.
    //
    ApplyChanges( hDC ) ;

    if ( m_fViewInitialized && NULL != hDC ) {

        m_pStatsBar->Draw(hDC, hDC, &ps.rcPaint);
        m_pGraphDisp->Draw(hDC, hDC, FALSE, FALSE, &ps.rcPaint);

        DrawBorder( hDC );

    }

    EndPaint (m_hWnd, &ps) ;
}

void 
CSysmonControl::OnDblClick(INT x, INT y)
{
    if ( REPORT_GRAPH != m_pObj->m_Graph.Options.iDisplayType ) {
        PCGraphItem pItem = m_pGraphDisp->GetItem ( x,y );      
        if ( NULL != pItem ) {
            SelectCounter( pItem );
            DblClickCounter ( pItem );
        }
    } else {
        assert ( FALSE );
    }
}

DWORD
CSysmonControl::ProcessCommandLine ( )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    LPCWSTR pszNext;
    LPWSTR  pszWmi = NULL;
    LPWSTR  pszSettings = NULL;
    LPWSTR* pszArgList = NULL;
    INT     iNumArgs;
    INT     iArgIndex;
    LPWSTR  pszNextArg = NULL;
    LPWSTR  pszThisArg = NULL;
    LPWSTR  szFileName = NULL;
    LPWSTR  szTemp = NULL;
    LPWSTR  pszToken = NULL;
    size_t  sizeArgLen = 0;
    BOOL    bDisplayMessage = FALSE;
    LPWSTR  szSystemMessage = NULL;
    static const size_t ciArgMaxLen = MAX_PATH + 1;

    //
    // Maximum argument length is for file path, which is restricted to MAX_PATH.
    //

    pszWmi = ResourceString ( IDS_CMDARG_WMI );
    pszSettings = ResourceString ( IDS_CMDARG_SETTINGS );

    pszNext = GetCommandLineW();
    pszArgList = CommandLineToArgvW ( pszNext, &iNumArgs );

    if ( NULL != pszArgList ) {
 
        for ( iArgIndex = 0; SUCCEEDED(hr) && (iArgIndex < iNumArgs); iArgIndex++ ) {

            pszNextArg = (LPWSTR)pszArgList[iArgIndex];
            pszThisArg = pszNextArg;

            while ( 0 != *pszThisArg ) {
                if ( *pszThisArg++ == L'/' ) {  // argument found
                
                    hr = StringCchLength ( pszThisArg, ciArgMaxLen, &sizeArgLen );

                    if ( SUCCEEDED(hr) ) {

                        szTemp = new WCHAR [sizeArgLen + 1];

                        if ( NULL != szTemp ) {           
                            
                            // No StringCchCopy failure because StringCchLen calculated above.
                            StringCchCopy (
                                szTemp,
                                (sizeArgLen + 1),
                                pszThisArg );
                
                            pszToken = wcstok ( szTemp, L"/ =\"" );                                                                           
                            
                            if ( 0 == lstrcmpiW ( pszToken, pszWmi ) ) {
                                //
                                // Ignore PDH errors.  The only possible error is that the default data source has
                                // already been set for this process.
                                //
                                PdhSetDefaultRealTimeDataSource ( DATA_SOURCE_WBEM );
                                pszThisArg += sizeArgLen;

                            } else if ( 0 == lstrcmpiW ( pszToken, pszSettings ) ) {
                                //
                                // Strip the initial non-token characters for string comparison.
                                //
                                pszThisArg = _wcsspnp ( pszNextArg, L"/ =\"" );
                        
                                if ( 0 == lstrcmpiW ( pszThisArg, pszSettings ) ) {
                                    //
                                    // Get the next argument (the file name)
                                    //
                                    iArgIndex++;
                                    pszNextArg = (LPWSTR)pszArgList[iArgIndex];
                                    pszThisArg = pszNextArg;                                                
                                } else {

                                    //
                                    // File was created by Windows 2000 perfmon5.exe, 
                                    // so file name is part of the arg.
                                    //
                                    pszThisArg += lstrlen ( pszSettings );
                                    hr = StringCchLength ( pszThisArg, ciArgMaxLen, &sizeArgLen );
                                    if ( SUCCEEDED ( hr ) ) {
                                        szFileName = new WCHAR[sizeArgLen + 1];
                                        if ( NULL != szFileName ) {
                                            //
                                            // No StringCchCopy failure because StringCchLen calculated above.
                                            //
                                            StringCchCopy (
                                                szFileName,
                                                (sizeArgLen + 1),
                                                pszThisArg );

                                            pszThisArg = wcstok ( szFileName, L"=\"" );
                                        } else {
                                            hr = E_OUTOFMEMORY;
                                            bDisplayMessage = TRUE;
                                        }
                                    } else {
                                        bDisplayMessage = TRUE;
                                    }
                                }

                                
                                if ( SUCCEEDED (hr) ) {

                                    hr = LoadFromFile( pszThisArg, TRUE );

                                    if ( SMON_STATUS_NO_SYSMON_OBJECT != (DWORD)hr ) {
                                        if ( SUCCEEDED ( hr ) ) {
                                            m_bSettingsLoaded = TRUE;  
                                        } //  else LoadFromFile displays messages for other errors 
                                    } else {
                                        // SMON_STATUS_NO_SYSMON_OBJECT == hr 
                                        MessageBox(
                                            m_hWnd, 
                                            ResourceString(IDS_NOSYSMONOBJECT_ERR ), 
                                            ResourceString(IDS_APP_NAME),
                                            MB_OK | MB_ICONERROR);
                                    }
                                    pszThisArg += lstrlen ( pszThisArg );
                                }
                            }
                        }
                        if ( NULL != szTemp ) {
                            delete [] szTemp;
                            szTemp = NULL;
                        }
                        if ( NULL != szFileName ) {
                            delete [] szFileName;
                            szFileName = NULL;
                        }
                    } else {
                        bDisplayMessage = TRUE;
                    }                             
                }
            }
        }
    }
    if ( FAILED(hr) && bDisplayMessage ) {
        
        if ( STRSAFE_E_INVALID_PARAMETER == hr ) {
            dwStatus = ERROR_INVALID_PARAMETER;
        } else if ( E_OUTOFMEMORY == hr ) {
            dwStatus = ERROR_OUTOFMEMORY;
        } else {
            dwStatus = HRESULT_CODE (hr);
        }
        
        szSystemMessage = new WCHAR[MAX_MESSAGE_LEN];

        if ( NULL != szSystemMessage ) {

            if ( FormatSystemMessage ( 
                    dwStatus, 
                    szSystemMessage, 
                    MAX_MESSAGE_LEN ) )
            {
                MessageBox(
                    m_hWnd, 
                    szSystemMessage, 
                    ResourceString(IDS_APP_NAME),
                    MB_OK | MB_ICONERROR);
            }

            delete [] szSystemMessage;
        }
    }
    if ( NULL != pszArgList ) {
        GlobalFree ( pszArgList );
    }

    return dwStatus;
}

HRESULT
CSysmonControl::LoadFromFile ( LPWSTR  szFileName, BOOL bAllData )
{
    HRESULT         hr = E_OUTOFMEMORY;
    LPWSTR          szLocalName = NULL;
    LPWSTR          pFileNameStart;
    HANDLE          hFindFile = NULL;
    WIN32_FIND_DATA FindFileInfo;
    INT             iNameOffset;
    DWORD           dwMsgStatus = ERROR_SUCCESS;
    HANDLE          hOpenFile = NULL;
    size_t          sizeCharCount;

    szLocalName = new WCHAR [MAX_PATH + 1];

    if ( NULL != szLocalName ) {

        hr = StringCchCopy ( szLocalName, MAX_PATH, szFileName  );

        if ( SUCCEEDED ( hr ) ) {
            //
            //  Find the filename offset within the path buffer.
            //
            pFileNameStart = ExtractFileName (szLocalName) ;
            iNameOffset = (INT)(pFileNameStart - szLocalName);
            
            //
            // Convert short filename to long NTFS filename if necessary.
            //
            hFindFile = FindFirstFile ( szLocalName, &FindFileInfo) ;
            if (hFindFile && hFindFile != INVALID_HANDLE_VALUE) {
                if ( ConfirmSampleDataOverwrite ( ) ) {

                    //
                    // Append the NTFS file name back to the path name, if different.
                    //
                    if ( 0 != lstrcmpiW ( FindFileInfo.cFileName, pFileNameStart ) ) {
                    
                        hr = StringCchLength ( FindFileInfo.cFileName, MAX_PATH, &sizeCharCount );
                        if ( SUCCEEDED ( hr ) ) {
                            //
                            //  No StringCchCopy failure, because truncation found by StringCchLength
                            //
                            StringCchCopy ( 
                                &szLocalName[iNameOffset], 
                                (MAX_PATH+1) - iNameOffset, 
                                FindFileInfo.cFileName );
                        } else {
                            //
                            // STRSAFE_E_INSUFFICIENT_BUFFER indicates filename truncation.
                            //
                            dwMsgStatus = ERROR_BUFFER_OVERFLOW;
                            hr = HRESULT_FROM_WIN32(dwMsgStatus);
                        }
                    } 
                    
                    if ( SUCCEEDED( hr ) ) {

                        //
                        // Open the file
                        //
                        hOpenFile = CreateFile (
                                        szLocalName, 
                                        GENERIC_READ,
                                        0,                  // Not shared
                                        NULL,               // Security attributes
                                        OPEN_EXISTING,     
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL );

                        if ( hOpenFile && hOpenFile != INVALID_HANDLE_VALUE ) {
                            DWORD dwFileSize;
                            DWORD dwFileSizeHigh;
                            DWORD dwFileSizeRead;
                            LPWSTR pszData = NULL;
                            //
                            // Read the file contents into a memory buffer.
                            //
                            dwFileSize = GetFileSize ( hOpenFile, &dwFileSizeHigh );

                            assert ( 0 == dwFileSizeHigh );

                            if ( 0 == dwFileSizeHigh ) {

                                //
                                // Restrict file size to DWORD length.
                                //
                                pszData = new WCHAR[(dwFileSize + sizeof(WCHAR))/sizeof(WCHAR)];
                                if ( NULL != pszData ) {
                                    if ( ReadFile ( hOpenFile, pszData, dwFileSize, &dwFileSizeRead, NULL ) ) {

                                        // Paste all settings from the memory buffer.
                                        hr = PasteFromBuffer ( pszData, bAllData );
                                        if ( E_OUTOFMEMORY == hr ) {
                                            dwMsgStatus = ERROR_NOT_ENOUGH_MEMORY;
                                        }
                                    } else {
                                        dwMsgStatus = GetLastError();
                                        hr = HRESULT_FROM_WIN32(dwMsgStatus);
                                    }
                                    delete [] pszData;
                                } else {
                                    dwMsgStatus = ERROR_NOT_ENOUGH_MEMORY;
                                    hr = E_OUTOFMEMORY;
                                }
                            } else {
                                // Todo: Sysmon-specific message re: file too large.
                                dwMsgStatus = ERROR_DS_OBJ_TOO_LARGE;
                                hr = HRESULT_FROM_WIN32(ERROR_DS_OBJ_TOO_LARGE);
                            }
                            CloseHandle ( hOpenFile );
                        } else {
                            //
                            // Return file system error.
                            //
                            assert (FALSE);
                            dwMsgStatus = GetLastError();
                            hr = HRESULT_FROM_WIN32(dwMsgStatus);
                        }
                    }
                }
                FindClose (hFindFile) ;
            } else {
                dwMsgStatus = GetLastError();
                HRESULT_FROM_WIN32(dwMsgStatus);
            }
        } else {
            //
            // STRSAFE_E_INSUFFICIENT_BUFFER indicates filename truncation.
            //
            dwMsgStatus = ERROR_BUFFER_OVERFLOW;
            hr = HRESULT_FROM_WIN32(dwMsgStatus);
        }
    } else {
        hr = E_OUTOFMEMORY;
        dwMsgStatus = ERROR_OUTOFMEMORY;
    }

    if ( ERROR_SUCCESS != dwMsgStatus ) {
        LPWSTR szMessage = NULL;
        LPWSTR szSystemMessage = NULL;
        INT   cchBufLen;

        cchBufLen = lstrlen(szLocalName) + MAX_MESSAGE_LEN + RESOURCE_STRING_BUF_LEN + 1;

        szMessage = new WCHAR [cchBufLen];

        szSystemMessage = new WCHAR [MAX_MESSAGE_LEN + 1];
        
        if ( NULL != szMessage && NULL != szSystemMessage ) {

            StringCchPrintf ( 
                szMessage, 
                cchBufLen,
                ResourceString(IDS_READFILE_ERR), 
                szLocalName );

            FormatSystemMessage ( dwMsgStatus, szSystemMessage, MAX_MESSAGE_LEN + 1 );

            StringCchCat(szMessage, cchBufLen, szSystemMessage );

            MessageBox(Window(), szMessage, ResourceString(IDS_APP_NAME),  MB_OK | MB_ICONSTOP);
        }                    
        if ( NULL != szMessage ) {
            delete [] szMessage;
        }
        if ( NULL != szSystemMessage ) {
            delete [] szSystemMessage;
        }        
    }

    if ( NULL != szLocalName ) {
        delete [] szLocalName;
    }
    return hr;
}


void 
CSysmonControl::OnDropFile ( WPARAM wParam )
{
    LPWSTR   szFileName = NULL;
    INT      iFileCount = 0;
    HRESULT  hr = S_OK;
    UINT     uiCchFileName;

    iFileCount = DragQueryFile ((HDROP) wParam, 0xffffffff, NULL, 0) ;

    if ( iFileCount > 0 ) {

        //
        // Open only the first file.
        //
        uiCchFileName = DragQueryFile((HDROP) wParam, 0, NULL,0 );

        szFileName = new WCHAR[uiCchFileName + 1];

        if ( NULL != szFileName ) {

            uiCchFileName = DragQueryFile((HDROP) wParam, 0, szFileName, uiCchFileName + 1 );
                    
            //
            // LoadFromFile handles file name errors.
            //
            hr = LoadFromFile ( szFileName, FALSE );
        
            if ( SMON_STATUS_NO_SYSMON_OBJECT == (DWORD)hr ) {
                MessageBox(
                    m_hWnd, 
                    ResourceString(IDS_NOSYSMONOBJECT_ERR ), 
                    ResourceString(IDS_APP_NAME),
                    MB_OK | MB_ICONERROR);
            } //  else LoadFromFile displays messages for other errors 
            delete [] szFileName;
        }
    }

    DragFinish ((HDROP) wParam) ;
}

void 
CSysmonControl::DisplayContextMenu(short x, short y)
{
    HMENU   hMenu;
    HMENU   hMenuPopup;

    RECT    clntRect;
    int     iPosx=0;
    int     iPosy=0;
    int     iLocalx;
    int     iLocaly;

    GetWindowRect(m_hWnd,&clntRect);
    if (x==0){
        iPosx = ((clntRect.right - clntRect.left)/2) ;
    }else{
        iPosx = x - clntRect.left;
    }
    if (y==0){
        iPosy = ((clntRect.bottom - clntRect.top)/2) ;
    }else{
        iPosy = y - clntRect.top;
    }

    iLocalx = clntRect.left + iPosx ;
    iLocaly = clntRect.top  + iPosy ;

    if ( ConfirmSampleDataOverwrite () ) {
        if ( !IsReadOnly() ) {
            UINT    uEnable;
            // Get the menu for the pop-up menu from the resource file.
            hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_CONTEXT));
            if (!hMenu) {
                return;
            }

            // enable/disable SaveData option depending on data source
            uEnable = (IsLogSource() ? MF_ENABLED : MF_GRAYED);
            uEnable |= MF_BYCOMMAND;
            EnableMenuItem (hMenu, IDM_SAVEDATA, uEnable);

            // Get the first submenu in it for TrackPopupMenu. 
            hMenuPopup = GetSubMenu(hMenu, 0);

            // Draw and track the "floating" pop-up menu. 
            TrackPopupMenu(hMenuPopup, TPM_RIGHTBUTTON,
                        iLocalx, iLocaly, 0, m_hWnd, NULL);

            // Destroy the menu.
            DestroyMenu(hMenu);
        }
    }
}


HRESULT CSysmonControl::DisplayProperties ( DISPID dispID )
{
    HRESULT hr;
    CAUUID  caGUID;
    OCPFIPARAMS params;

    // Give container a chance to show properties
    if (NULL!=m_pObj->m_pIOleControlSite) {
        hr=m_pObj->m_pIOleControlSite->ShowPropertyFrame();

        if (NOERROR == hr)
            return hr;
    }

    //Put up our property pages.

    ZeroMemory ( &params, sizeof ( OCPFIPARAMS ) );

    hr = m_pObj->m_pImpISpecifyPP->GetPages(&caGUID);

    if (FAILED(hr)) {
        return hr;
    }

    params.cbStructSize = sizeof ( OCPFIPARAMS );
    params.hWndOwner = m_hWnd;
    params.x = 10;
    params.y = 10;
    params.lpszCaption = ResourceString(IDS_PROPFRM_TITLE);
    params.cObjects = 1;
    params.lplpUnk = (IUnknown **)&m_pObj,
    params.cPages = caGUID.cElems;
    params.lpPages = caGUID.pElems;
    params.lcid = m_lcidCurrent;
    params.dispidInitialProperty = dispID;

    hr = OleCreatePropertyFrameIndirect ( &params );

    //Free the GUIDs
    CoTaskMemFree((void *)caGUID.pElems);

    // Make sure correct window has the focus
    AssignFocus();

    return hr;
}


HRESULT
CSysmonControl::AddCounter(
    LPWSTR pszPath, 
    PCGraphItem *pGItem)
/*++

Routine Description:

    AddCounter returns a pointer to the created counter item, or
    to the first created counter item if multiple created for a wildcard
    path.   
    EnumExpandedPath calls the AddCallback function for each new counter.
    AddCallback passes the counter path on to the AddSingleCounter method.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HRESULT hr;
    ENUM_ADD_COUNTER_CALLBACK_INFO CallbackInfo;
  
    if (pszPath == NULL || lstrlen(pszPath) > PDH_MAX_COUNTER_PATH) { 
        return E_INVALIDARG;
    }

    CallbackInfo.pCtrl = this;
    CallbackInfo.pFirstItem = NULL;
    
    *pGItem = NULL;

    hr = EnumExpandedPath(GetDataSourceHandle(), pszPath, AddCounterCallback, &CallbackInfo); 

    *pGItem = CallbackInfo.pFirstItem;

    return hr;    
}


HRESULT
CSysmonControl::AddCounters (
    VOID
    )
/*++

Routine Description:

    AddCounters invokes the counter browser to select new counters.
    The browser calls the AddCallback function for each new counter.
    AddCallback passes the counter path on to the AddCounter method.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ENUM_ADD_COUNTER_CALLBACK_INFO CallbackInfo;
    HRESULT hr;

    CallbackInfo.pCtrl = this;
    CallbackInfo.pFirstItem = NULL;

    //
    // Browse counters, calling AddCallback for each selected counter.
    //  
    hr = BrowseCounters(
            GetDataSourceHandle(), 
            PERF_DETAIL_WIZARD, 
            m_hWnd, 
            AddCounterCallback, 
            &CallbackInfo,
            m_pObj->m_Graph.Options.bMonitorDuplicateInstances);

    // Make sure correct window has the focus
    AssignFocus();

    return hr;
}

HRESULT
CSysmonControl::SaveAs (
    VOID
    )
/*++

Routine Description:

    SaveAs writes the current configuration to an HTML file.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HRESULT         hr = S_OK;
    INT             iReturn = IDCANCEL;
    INT             i;
    OPENFILENAME    ofn;
    WCHAR           szFileName[MAX_PATH+1];
    WCHAR           szExt[MAX_PATH+1];
    WCHAR           szFileFilter[RESOURCE_STRING_BUF_LEN];
    WCHAR           szDefExtension[RESOURCE_STRING_BUF_LEN];
    HANDLE          hFile = NULL;
    DWORD           dwMsgStatus = ERROR_SUCCESS;
    DWORD           dwCreateError;
    INT             iOverwrite = IDNO;
    LPWSTR          szMessage = NULL;
    size_t          cchMessageBuf;
    LPWSTR          pszTemp = NULL;
    WCHAR           szByteOrderMark[2];
    BOOL            bStatus;
    DWORD           dwByteCount;

    //
    // Initial directory is the current directory
    //
    szFileName[0] = L'\0';
    ZeroMemory(szFileFilter, sizeof ( szFileFilter ) );
    ZeroMemory(&ofn, sizeof(ofn));
    StringCchCopy(szFileFilter,
                  RESOURCE_STRING_BUF_LEN,
                  ResourceString (IDS_HTML_FILE));

    StringCchCopy(szDefExtension,
                  RESOURCE_STRING_BUF_LEN,
                  ResourceString (IDS_DEF_EXT));

    for( i = 0; szFileFilter[i]; i++ ){
       if( szFileFilter[i] == L'|' ){
          szFileFilter[i] = L'\0';
       }
    }

    for( i = 0; szDefExtension[i]; i++ ){
       if( szDefExtension[i] == L'|' ){
          szDefExtension[i] = L'\0';
       }
    }

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = Window();
    ofn.hInstance = NULL ;       // Ignored if no template argument
    ofn.lpstrFilter =  szFileFilter; 
    ofn.lpstrDefExt =  szDefExtension;
    ofn.nFilterIndex = 1; // nFilterIndex is 1-based
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.nMaxFileTitle = 0;
    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    
    iReturn = GetSaveFileName (&ofn);
    //
    // Differentiate between *.htm and *.tsv
    //
    _wsplitpath(szFileName,NULL,NULL,NULL,szExt);

    if ( IDOK == iReturn ) {
        //
        // Create a file.
        //        
        hFile =  CreateFile (
                    szFileName, 
                    GENERIC_READ | GENERIC_WRITE,
                    0,              // Not shared
                    NULL,           // Security attributes
                    CREATE_NEW,     // Query the user if file already exists.
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );

        if ( INVALID_HANDLE_VALUE == hFile ) {
            
            dwCreateError = GetLastError();
          
            if ( ERROR_SUCCESS != dwCreateError ) {
                //
                // Confirm file overwrite.
                //
                cchMessageBuf = lstrlen(szFileName) + RESOURCE_STRING_BUF_LEN + 1;

                szMessage = new WCHAR [cchMessageBuf];

                if ( NULL != szMessage ) {

                    StringCchPrintf(
                        szMessage, 
                        cchMessageBuf,
                        ResourceString(IDS_HTML_FILE_OVERWRITE), 
                        szFileName );

                    iOverwrite = MessageBox(
                                        Window(), 
                                        szMessage, 
                                        ResourceString(IDS_APP_NAME),
                                        MB_YESNO );

                    delete [] szMessage;

                    if ( IDYES == iOverwrite ) {
                        hFile = CreateFile (
                                    szFileName, 
                                    GENERIC_READ | GENERIC_WRITE,
                                    0,              // Not shared
                                    NULL,           // Security attributes
                                    CREATE_ALWAYS,  // Overwrite any existing file.
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL );

                    }
                }
            } 
        }
        
        if ( INVALID_HANDLE_VALUE != hFile ) {
            
            CWaitCursor cursorWait;
            
            // Save the current configuration to the file.
            if( (!_wcsicmp(szExt,ResourceString(IDS_HTM_EXTENSION)))
                || (!_wcsicmp(szExt,ResourceString(IDS_HTML_EXTENSION))) ) {
                
                // Html file

                szByteOrderMark[0] = 0xFEFF;
                szByteOrderMark[1] = L'\0';

                bStatus = FileWrite ( hFile, szByteOrderMark, sizeof(WCHAR) );

                if ( bStatus ) {
                    if (m_fRTL || (GetWindowLongPtr(Window(), GWL_EXSTYLE) & WS_EX_LAYOUTRTL) ) {
                        bStatus = FileWrite ( hFile, (PVOID)CGlobalString::m_cszHtmlFileHeaderRTL , lstrlen (CGlobalString::m_cszHtmlFileHeaderRTL ) * sizeof(WCHAR) );
                    }
                    else {
                        bStatus = FileWrite ( hFile, (PVOID)CGlobalString::m_cszHtmlFileHeader , lstrlen (CGlobalString::m_cszHtmlFileHeader ) * sizeof(WCHAR) );
                    }
                }

                if ( bStatus ) {

                    hr = CopyToBuffer ( pszTemp, dwByteCount );
                    
                    if ( SUCCEEDED ( hr ) ) {
                        assert ( NULL != pszTemp );
                        assert ( 0 != dwByteCount );
                        bStatus = FileWrite ( hFile, pszTemp, dwByteCount );
                        delete [] pszTemp;
                    } else {
                        bStatus = FALSE;
                        SetLastError ( ERROR_OUTOFMEMORY );
                    }
                }

                if ( bStatus ) {
                    bStatus = FileWrite ( hFile, (PVOID)CGlobalString::m_cszHtmlFileFooter, lstrlen (CGlobalString::m_cszHtmlFileFooter) * sizeof(WCHAR) );
                }

                if ( !bStatus ) {
                    dwMsgStatus = GetLastError();                
                }

                
            } else if (!_wcsicmp(szExt,ResourceString(IDS_TSV_EXTENSION))){

                // Tsv file
                bStatus = WriteFileReportHeader(hFile);
                
                if  (bStatus){
                    bStatus = m_pReport->WriteFileReport(hFile);
                }

                if (!bStatus){
                    dwMsgStatus = GetLastError();
                }
            }            

            bStatus = CloseHandle ( hFile );
        } else {
            dwMsgStatus = GetLastError();        
        }
        
        if ( ERROR_SUCCESS != dwMsgStatus ) {
            LPWSTR szSystemMessage = NULL;

            cchMessageBuf = lstrlen(szFileName) + MAX_MESSAGE_LEN + RESOURCE_STRING_BUF_LEN + 1;

            szSystemMessage = new WCHAR[MAX_MESSAGE_LEN + 1];
            szMessage = new WCHAR [ cchMessageBuf ];

            if ( NULL != szMessage && NULL != szSystemMessage ) {
                StringCchPrintf(
                    szMessage, 
                    cchMessageBuf,
                    ResourceString(IDS_SAVEAS_ERR), 
                    szFileName );

                FormatSystemMessage ( dwMsgStatus, szSystemMessage, MAX_MESSAGE_LEN );

                StringCchCat(szMessage, cchMessageBuf, szSystemMessage );

                MessageBox(Window(), szMessage, ResourceString(IDS_APP_NAME), MB_OK | MB_ICONSTOP);
                    
            }
            if ( NULL != szMessage ) {
                delete [] szMessage;
            }
            if ( NULL != szSystemMessage ) {
                delete [] szSystemMessage;
            }
        }
    } // else ignore if they canceled out

    // Make sure correct window has the focus
    AssignFocus();

    return hr;
}

HRESULT
CSysmonControl::SaveData (
    VOID
    )
/*++

Routine Description:

    SaveData writes the data from the display to a binary log file for 
    later input as a data source.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HRESULT         hr = S_OK;
    DWORD           dwStatus = ERROR_SUCCESS;
    INT             iReturn = IDCANCEL;
    INT             i;
    OPENFILENAME    ofn;
    WCHAR           szFileName[MAX_PATH+1];
    WCHAR           szFileFilter[RESOURCE_STRING_BUF_LEN];
    WCHAR           szDefExtension[RESOURCE_STRING_BUF_LEN];
    WCHAR           szDialogCaption[RESOURCE_STRING_BUF_LEN];
    LONG            lOrigFilterValue;
    LPWSTR          szSystemMessage = NULL;

    //
    // Initial directory is the current directory
    //    
    szFileName[0] = TEXT('\0');
    ZeroMemory(szFileFilter, sizeof ( szFileFilter ) );
    ZeroMemory(&ofn, sizeof(ofn));

    StringCchCopy(szFileFilter,
                 RESOURCE_STRING_BUF_LEN,
                 ResourceString (IDS_LOG_FILE));

    StringCchCopy (szDefExtension,
                   RESOURCE_STRING_BUF_LEN,
                   ResourceString (IDS_LOG_FILE_EXTENSION));

    StringCchCopy (szDialogCaption, 
                   RESOURCE_STRING_BUF_LEN, 
                   ResourceString (IDS_SAVE_DATA_CAPTION));

    for( i = 0; szFileFilter[i]; i++ ){
       if( szFileFilter[i] == TEXT('|') ){
          szFileFilter[i] = 0;
       }
    }

    for( i = 0; szDefExtension[i]; i++ ){
       if( szDefExtension[i] == TEXT('|') ){
          szDefExtension[i] = 0;
       }
    }

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = Window();
    ofn.hInstance = GetModuleHandle((LPCWSTR)TEXT("sysmon.ocx")) ;       // Ignored if no template argument
    ofn.lpstrFilter =  szFileFilter; 
    ofn.lpstrDefExt =  szDefExtension;
    ofn.nFilterIndex = 1; // nFilterIndex is 1-based
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.nMaxFileTitle = 0;
    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY | 
                OFN_OVERWRITEPROMPT | OFN_ENABLETEMPLATE | OFN_ENABLEHOOK;
    ofn.lpstrTitle = szDialogCaption;
    ofn.lCustData = (DWORD_PTR)this;
    ofn.lpfnHook = (LPOFNHOOKPROC) SaveDataDlgHookProc ;
    ofn.lpTemplateName = MAKEINTRESOURCE(IDD_SAVEDATA_DLG) ;

    lOrigFilterValue = GetSaveDataFilter ();
    
    iReturn = GetSaveFileName (&ofn);

    if ( IDOK == iReturn ) {
        DWORD   dwOutputLogType = PDH_LOG_TYPE_BINARY;
        DWORD   dwFilterCount;  // copy all records within the timerange
        PDH_TIME_INFO   TimeInfo;

        // get log type from file name
        if (ofn.nFileExtension > 0) {
            if (ofn.lpstrFile[ofn.nFileExtension] != 0) {
                if (lstrcmpi (&ofn.lpstrFile[ofn.nFileExtension-1], ResourceString (IDS_CSV_EXTENSION)) == 0) {
                    dwOutputLogType = PDH_LOG_TYPE_CSV;
                } else if (lstrcmpi (&ofn.lpstrFile[ofn.nFileExtension-1], ResourceString (IDS_TSV_EXTENSION)) == 0) { 
                    dwOutputLogType = PDH_LOG_TYPE_TSV;
                } // else use binary log format as default
            } // else use binary log format as default
        } // else use binary log format as default

        // get timerange for this log
        TimeInfo.StartTime = m_DataSourceInfo.llStartDisp;
        TimeInfo.EndTime = m_DataSourceInfo.llStopDisp;

        dwFilterCount = GetSaveDataFilter();

        //
        // Double check the filter count is not 0
        //
        if (dwFilterCount == 0) {
            dwFilterCount = 1;
        }

        // now relog the data
        dwStatus = RelogLogData ( ofn.lpstrFile, dwOutputLogType, TimeInfo, dwFilterCount);

    } else {
        dwStatus = CommDlgExtendedError();

        if ( ERROR_SUCCESS != dwStatus ) {
            if ( FNERR_BUFFERTOOSMALL == dwStatus ) {
                dwStatus = ERROR_BUFFER_OVERFLOW;
            } else {
                dwStatus = ERROR_OUTOFMEMORY;
            }

            szSystemMessage = new WCHAR[MAX_MESSAGE_LEN];

            if ( NULL != szSystemMessage ) {

                if ( FormatSystemMessage ( 
                        dwStatus, 
                        szSystemMessage, 
                        MAX_MESSAGE_LEN ) )
                {
                    MessageBox(
                        m_hWnd, 
                        szSystemMessage, 
                        ResourceString(IDS_APP_NAME),
                        MB_OK | MB_ICONERROR);
                }

                delete [] szSystemMessage;
            }
        }
        //
        // They canceled out or error occurred, so restore filter value
        //
        SetSaveDataFilter (lOrigFilterValue);
    }

    // Make sure correct window has the focus
    AssignFocus();

    return hr;
}

DWORD
CSysmonControl::RelogLogData (
    LPCWSTR  szOutputFile,
    DWORD  dwOutputLogType,
    PDH_TIME_INFO  pdhTimeInfo,
    DWORD  dwFilterCount
)
{
    PDH_STATUS     pdhStatus;
    PDH_RELOG_INFO RelogInfo;
    HLOG           hLogIn;

    //
    // Initialize the relog information structure
    //
    ZeroMemory( &RelogInfo, sizeof(PDH_RELOG_INFO) );

    RelogInfo.TimeInfo.StartTime = pdhTimeInfo.StartTime;
    RelogInfo.TimeInfo.EndTime = pdhTimeInfo.EndTime;;
    RelogInfo.TimeInfo.SampleCount = dwFilterCount;
    RelogInfo.dwFileFormat = dwOutputLogType;
    RelogInfo.dwFlags = PDH_LOG_WRITE_ACCESS | PDH_LOG_CREATE_ALWAYS;
    RelogInfo.strLog = (LPWSTR)szOutputFile;
   
    //
    // Set query time range
    //
    PdhSetQueryTimeRange(m_hQuery, &pdhTimeInfo);

    //
    // Get the input data source
    //
    hLogIn = GetDataSourceHandle();

    //
    // Collect the performance data and write them into output file
    //
    pdhStatus = PdhRelog( hLogIn, &RelogInfo );

    return pdhStatus;
}

BOOL 
CSysmonControl::WriteFileReportHeader(HANDLE hFile){

    BOOL        bStatus = FALSE;
    HRESULT     hr = S_OK;
    DWORD       dwStatus = ERROR_SUCCESS;
    SYSTEMTIME  SysTime;
    DWORD       dwSize  = MAX_COMPUTERNAME_LENGTH + 1 ;
    WCHAR       szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    LPWSTR      szHeader = NULL;
    LPWSTR      szDateTime = NULL;
    LPWSTR      szDataSource = NULL;
    LPWSTR      szTime = NULL;
    LPWSTR      szDate = NULL;
    LPWSTR      szValue = NULL;
    LPWSTR      szMiscBuf = NULL;
    DWORD       dwValueId = IDS_DEFAULT;
    WCHAR       szByteOrderMark[2];
    ULONG       ulLogListBufLen = 0;
    INT         cchTimeBufLen = 0;
    INT         cchDateBufLen = 0;
    INT         cchHeaderBufLen = 0;
    INT         cchMiscBufLen = 0;

    //
    // Computer name 
    //
    if (!GetComputerName(szComputerName,&dwSize)){
        szComputerName[0] = L'\0';
    }

    //
    // Current date and time 
    //
    GetLocalTime(&SysTime);

    cchTimeBufLen = GetTimeFormat (m_lcidCurrent, 0, &SysTime, NULL, NULL, 0 ) ;

    if ( 0 != cchTimeBufLen ) {
        szTime = new WCHAR[cchTimeBufLen];
        if ( NULL != szTime ) {
            if ( 0 != GetTimeFormat (m_lcidCurrent, 0, &SysTime, NULL, szTime, cchTimeBufLen) ) {
                bStatus = TRUE;
            }
        }
    } 

    if ( bStatus ) {
        bStatus = FALSE;

        cchDateBufLen = GetDateFormat (m_lcidCurrent, DATE_SHORTDATE, &SysTime, NULL, NULL, 0 ) ;

        if ( 0 != cchDateBufLen ) {
            szDate = new WCHAR[cchDateBufLen];
            if ( NULL != szTime ) {
                if ( 0 != GetDateFormat (m_lcidCurrent, DATE_SHORTDATE, &SysTime, NULL, szDate, cchDateBufLen) ) {
                    bStatus = TRUE;
                }
            }
        } 
    }                                                                               
    
    if ( bStatus ) {
        bStatus = FALSE;

        //
        // Subtract 1 for extra null.
        //
        cchMiscBufLen = RESOURCE_STRING_BUF_LEN + cchDateBufLen + cchTimeBufLen - 1;

        szDateTime = new WCHAR [cchMiscBufLen];

        if ( NULL != szDateTime ) {
            hr = StringCchPrintf( 
                    szDateTime,
                    cchMiscBufLen,
                    ResourceString( IDS_REPORT_DATE_TIME ),
                    szDate,
                    szTime );

            if ( SUCCEEDED ( hr ) ) {
                bStatus = TRUE;
            }
        }
    }

    //
    // Report value type
    //

    if ( bStatus ) {
        bStatus = FALSE;

        switch ( m_pObj->m_Graph.Options.iReportValueType ) {
            case sysmonCurrentValue:
                dwValueId = IDS_LAST;
                break;
            case sysmonAverage:
                dwValueId = IDS_AVERAGE;
                break;
            case sysmonMinimum:
                dwValueId = IDS_MINIMUM;
                break;
            case sysmonMaximum:
                dwValueId = IDS_MAXIMUM;
                break;
            default:
                dwValueId = IDS_DEFAULT;
        }

        //
        // Add 1 for null.
        //
        cchMiscBufLen = ( RESOURCE_STRING_BUF_LEN * 2 ) + 1;

        szValue = new WCHAR [cchMiscBufLen];

        if ( NULL != szValue ) {

            hr = StringCchPrintf(
                    szValue,
                    cchMiscBufLen,
                    ResourceString ( IDS_REPORT_VALUE_TYPE ),
                    ResourceString ( dwValueId ) );

            if ( SUCCEEDED ( hr ) ) {
                bStatus = TRUE;
            }
        }
    }

    //
    // Data source
    //
    if ( bStatus ) {
        bStatus = FALSE;

        cchMiscBufLen = RESOURCE_STRING_BUF_LEN + 1;


        if ( sysmonCurrentActivity == m_pObj->m_Graph.Options.iDataSourceType ) {
            szDataSource = new WCHAR [cchMiscBufLen];
            if ( NULL != szDataSource ) {
                hr = StringCchCopy(
                    szDataSource, 
                    cchMiscBufLen, 
                    ResourceString(IDS_REPORT_REAL_TIME));

                if ( SUCCEEDED ( hr ) ) {
                    bStatus = TRUE;
                }
            }
        } else if ( sysmonLogFiles == m_pObj->m_Graph.Options.iDataSourceType ) {
            dwStatus = BuildLogFileList ( 
                        NULL,
                        TRUE,
                        &ulLogListBufLen );

            szDataSource =  new WCHAR [ulLogListBufLen];
            if ( NULL != szDataSource ) {
                dwStatus = BuildLogFileList ( 
                            szDataSource,
                            TRUE,
                            &ulLogListBufLen );
                if ( ERROR_SUCCESS == dwStatus ) {
                    bStatus = TRUE;
                }
            }
        } else if ( sysmonSqlLog == m_pObj->m_Graph.Options.iDataSourceType ) {
            dwStatus = FormatSqlDataSourceName ( 
                        m_DataSourceInfo.szSqlDsnName,
                        m_DataSourceInfo.szSqlLogSetName,
                        NULL,
                        &ulLogListBufLen );

            if ( ERROR_SUCCESS == dwStatus ) {
                szDataSource = new WCHAR [ulLogListBufLen];
                if ( NULL != szDataSource ) {
                    dwStatus = FormatSqlDataSourceName ( 
                                m_DataSourceInfo.szSqlDsnName,
                                m_DataSourceInfo.szSqlLogSetName,
                                szDataSource,
                                &ulLogListBufLen );
                    if ( ERROR_SUCCESS == dwStatus ) {
                        bStatus = TRUE;
                    }
                }
            }
        }
    }
    
    //
    // Header
    //
    if ( bStatus ) {
        bStatus = FALSE;

        cchHeaderBufLen = lstrlenW(szComputerName)
                    + lstrlenW(szDateTime) 
                    + lstrlenW(szValue)
                    + lstrlenW(szDataSource);

        cchHeaderBufLen += RESOURCE_STRING_BUF_LEN;      // IDS_REPORT_HEADER;
        cchHeaderBufLen += RESOURCE_STRING_BUF_LEN;      // IDS_REPORT_INTERVAL

        cchHeaderBufLen += 10;                        // Max interval text length

        cchHeaderBufLen += RESOURCE_STRING_BUF_LEN;      // IDS_REPORT_LOG_START
        cchHeaderBufLen += (cchDateBufLen + cchTimeBufLen);   // Includes space, line end
        cchHeaderBufLen += RESOURCE_STRING_BUF_LEN;      // IDS_REPORT_LOG_STOP
        cchHeaderBufLen += (cchDateBufLen + cchTimeBufLen);   // Includes space
        cchHeaderBufLen += (1 + 1);                      // Line end, NULL

        szHeader = new WCHAR [cchHeaderBufLen];
    
        if ( NULL != szHeader ) {
            hr = StringCchPrintf(
                    szHeader, 
                    cchHeaderBufLen,
                    ResourceString(IDS_REPORT_HEADER),
                    szComputerName,
                    szDateTime,
                    szValue,
                    szDataSource );

            if ( SUCCEEDED ( hr ) ) {
                bStatus = TRUE;
            }
        }
    }

    if ( bStatus ) {
        bStatus = FALSE;
        if ( sysmonCurrentActivity == m_pObj->m_Graph.Options.iDataSourceType ) {

            //
            // Sample interval, only for realtime data source.
            //
            cchMiscBufLen = RESOURCE_STRING_BUF_LEN + 10 + 1,

            szMiscBuf = new WCHAR [cchMiscBufLen];

            if ( NULL != szMiscBuf ) {
                StringCchPrintf( 
                    szMiscBuf,
                    cchMiscBufLen,
                    ResourceString(IDS_REPORT_INTERVAL),
                    m_pObj->m_Graph.Options.fUpdateInterval );

                StringCchCat(szHeader, cchHeaderBufLen, szMiscBuf);
            }

            bStatus = TRUE;

        } else if ( sysmonLogFiles == m_pObj->m_Graph.Options.iDataSourceType 
                || sysmonSqlLog == m_pObj->m_Graph.Options.iDataSourceType ) 
        {

            //
            // Add start and stop string for log files or Sql logs.
            //
            cchMiscBufLen = RESOURCE_STRING_BUF_LEN * 2
                            + cchDateBufLen * 2
                            + cchTimeBufLen * 2
                            + 1 + 1;
            
            szMiscBuf = new WCHAR [ cchMiscBufLen ];  
        
            if ( NULL != szMiscBuf ) {

                FormatDateTime(m_DataSourceInfo.llStartDisp,szDate,szTime);

                StringCchPrintf( 
                    szMiscBuf,
                    cchMiscBufLen,
                    TEXT("%s%s %s\n"),
                    ResourceString(IDS_REPORT_LOG_START),
                    szDate,
                    szTime );

                FormatDateTime(m_DataSourceInfo.llStopDisp,szDate,szTime);
                StringCchCat(szMiscBuf, cchMiscBufLen, ResourceString(IDS_REPORT_LOG_STOP));
        
                FormatDateTime(m_DataSourceInfo.llStopDisp,szDate,szTime);

                StringCchCat(szMiscBuf, cchMiscBufLen, szDate);
                StringCchCat(szMiscBuf, cchMiscBufLen, SpaceStr);
                StringCchCat(szMiscBuf, cchMiscBufLen, szTime);
                StringCchCat(szMiscBuf, cchMiscBufLen, LineEndStr);
        
                StringCchCat(szHeader, cchHeaderBufLen, szMiscBuf);

                bStatus = TRUE;
            }
        }
    }

    if ( bStatus ) {
        szByteOrderMark[0] = 0xFEFF;
        szByteOrderMark[1] = L'\0';
        bStatus = FileWrite ( hFile, szByteOrderMark, sizeof(WCHAR) );
        bStatus = FileWrite ( hFile, szHeader, lstrlen (szHeader) * sizeof(WCHAR) );
    }

    if ( NULL != szTime ) {
        delete [] szTime;
    }
    if ( NULL != szDate ) {
        delete [] szDate;
    }
    if ( NULL != szDateTime ) {
        delete [] szDateTime;
    }
    if ( NULL != szValue ) {
        delete [] szValue;
    }
    if ( NULL != szDataSource ) {
        delete [] szDataSource;
    }
    if ( NULL != szHeader ) {
        delete [] szHeader;
    }
    if ( NULL != szMiscBuf ) {
        delete [] szMiscBuf;
    }

    return bStatus;
}

BOOL CSysmonControl::InitView (HWND hWndParent)
/*
   Effect:  Create the graph window. This window is a child of 
            hWndMain and is a container for the graph data,
            graph label, graph legend, and graph status windows.

   Note:    We don't worry about the size here, as this window
            will be resized whenever the main window is resized.

   Note:    This method initializes the control for rendering. 
*/
{
    PCGraphItem pItem;
    WNDCLASS    wc ;

    // Protect against multiple initializations
    if (m_fViewInitialized)
       return TRUE;

    BEGIN_CRITICAL_SECTION

    // Register the window class once
    if (pstrRegisteredClasses[SYSMONCTRL_WNDCLASS] == NULL) {
       
        wc.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
        wc.lpfnWndProc   = SysmonCtrlWndProc ;
        wc.hInstance     = g_hInstance ;
        wc.cbClsExtra    = 0 ;
        wc.cbWndExtra    = sizeof (PSYSMONCTRL) ;
        wc.hIcon         = NULL ;
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
        wc.hbrBackground = NULL ;
        wc.lpszMenuName  = NULL ;
        wc.lpszClassName = szSysmonCtrlWndClass ;

        if (RegisterClass (&wc)) {
            pstrRegisteredClasses[SYSMONCTRL_WNDCLASS] = szSysmonCtrlWndClass;
        }

   }

   END_CRITICAL_SECTION

   if (pstrRegisteredClasses[SYSMONCTRL_WNDCLASS] == NULL)
        return FALSE;

   // Create our control window
   m_hWnd = CreateWindow (szSysmonCtrlWndClass,    // window class
                         NULL,                     // caption
                         WS_CHILD | WS_VISIBLE,    // style for window
                         0, 0,                     // initial position
                         m_pObj->m_RectExt.right,  // width
                         m_pObj->m_RectExt.bottom, // height
                         hWndParent,               // parent
                         NULL,                     // menu
                         g_hInstance,              // program instance
                         (LPVOID)this) ;          // user-supplied data

    if (m_hWnd == NULL) {
    //    DWORD err = GetLastError();
        return FALSE;
    }

    DragAcceptFiles (m_hWnd, TRUE) ;

    // Subcomponents are allocated in AllocateSubcomponents

    // Init the legend

    if ( !m_pLegend 
        || !m_pGraphDisp
        || !m_pStatsBar
        || !m_pSnapBar
        || !m_pToolbar
        || !m_pReport ) 
    {
        return FALSE;
    }

    if (!m_pLegend->Init(this, m_hWnd))
        return FALSE;

    // Init the graph display
    if (!m_pGraphDisp->Init(this, &m_pObj->m_Graph))
        return FALSE;

    // Init the statistics bar
    if (!m_pStatsBar->Init(this, m_hWnd))
        return FALSE;

    // Init the snapshot bar
    if (!m_pSnapBar->Init(this, m_hWnd))
        return FALSE;

    if (!m_pToolbar->Init(this, m_hWnd))
        return FALSE;

    // Init the report view
    if (!m_pReport->Init(this, m_hWnd))
        return FALSE;
    
    m_fViewInitialized = TRUE;
    // If counters are present
    if ((pItem = FirstCounter()) != NULL) {
        // Add counters to the legend and report view
        while (pItem != NULL) {
            m_pLegend->AddItem(pItem);
            m_pReport->AddItem(pItem);
            pItem = pItem->Next();
        }
        if ( NULL != m_pSelectedItem ) {
            SelectCounter(m_pSelectedItem);
        } else {
            SelectCounter(FirstCounter());
        }
        if ( !m_bLogFileSource ) {
            // Pass new time span to statistics bar.  This must
            // be done after initializing the stats bar.
            m_pStatsBar->SetTimeSpan (
                            m_pObj->m_Graph.Options.fUpdateInterval
                            * m_pObj->m_Graph.Options.iDisplayFilter
                            * m_pHistCtrl->nMaxSamples );
        }
    }

    // Processing the command line can add counters from the property bag.  
    // Add the counters after the counter addition and selection code above 
    // so that counters do not get added twice.

    //
    // Continue on failure of ProcessCommandLine.  Error messages are displayed in that method.
    //
    ProcessCommandLine ( );

    return TRUE;                                              
}


BOOL CSysmonControl::Init (HWND hWndParent)
/*
   Effect:        Create the graph window. This window is a child of 
                  hWndMain and is a container for the graph data,
                  graph label, graph legend, and graph status windows.

   Note:          We don't worry about the size here, as this window
                  will be resized whenever the main window is resized.

*/
{
    PCGraphItem  pItem;
    BOOL bResult = TRUE;

    // Protect against multiple initializations
    if (!m_fInitialized) {

        bResult = InitView( hWndParent );

        if ( !m_bSampleDataLoaded ) {
        
            if ( bResult ) {
                m_fInitialized = TRUE;

                // When loaded from property bag or stream, the log file name is 
                // already set.  If realtime query, the Pdh query might
                // not have been opened.
                if ( sysmonCurrentActivity == m_pObj->m_Graph.Options.iDataSourceType ) {
                    put_DataSourceType ( sysmonCurrentActivity );
                }
                // Load the accelerator table
                m_hAccel = LoadAccelerators(g_hInstance, MAKEINTRESOURCE(ID_SMONACCEL));

                // If counters are present
                if ((pItem = FirstCounter()) != NULL) {
            
                    if ( ERROR_SUCCESS != ActivateQuery() ) {
                        m_fInitialized = FALSE;
                        return FALSE;
                    }
                }
            }
        }
    }

    //sync the toolbar last
    if ( bResult ) {
        m_pToolbar->SyncToolbar();
    }

    return bResult;                                              
}


HRESULT CSysmonControl::LoadFromStream(LPSTREAM pIStream)
{
    typedef struct _DATA_LIST_ELEM
    {
        GRAPHITEM_DATA3     itemData;
        LPWSTR              szCounterPath;
        struct _DATA_LIST_ELEM*    pNext;
    } DATA_LIST_ELEM, *PDATA_LIST_ELEM;
    HRESULT         hr = S_OK;
    ULONG           bc;
    GRAPH_OPTIONS   *pOptions = &m_pObj->m_Graph.Options;
    RECT            RectExt;
    SMONCTRL_VERSION_DATA   VersionData;
    LPWSTR          szLogFilePath = NULL;
    INT32           iLocalDataSourceType = (INT32)sysmonNullDataSource;
    GRAPHCTRL_DATA3 CtrlData3;
    ENUM_ADD_COUNTER_CALLBACK_INFO CallbackInfo;
    PDATA_LIST_ELEM pFirstElem = NULL;
    PDATA_LIST_ELEM pLastElem = NULL;
    PDATA_LIST_ELEM pNewElem = NULL;
    LPWSTR          pszCounterPath = NULL;
    LPWSTR          szLocaleBuf = NULL;
    DWORD           dwLocaleBufSize = 0;
    LPWSTR          pszPath = NULL;

    USES_CONVERSION

    if (g_dwScriptPolicy == URLPOLICY_DISALLOW) {
        return E_ACCESSDENIED;
    }
    if ( !m_bSettingsLoaded ) {
        // Read in parameters
        hr = pIStream->Read(&VersionData, sizeof(VersionData), &bc);
        if (FAILED(hr))
            return hr;

        if (bc != sizeof(VersionData))
            return E_FAIL;

        // 
        // Windows2000 shipped as 3.3.
        // XP shipped as 3.6.
        //
        // The code below assumes that Sysmon version is 3.6.
        //
        assert ( 3 == SMONCTRL_MAJ_VERSION );
        assert ( 6 == SMONCTRL_MIN_VERSION );

        // Read version 3 streams only.  
        if ( VersionData.iMajor < SMONCTRL_MAJ_VERSION )
            return E_FAIL;

        // Update the current loaded version number in order
        // to warn the user appropriately when saving to stream.
        m_LoadedVersion.iMajor = VersionData.iMajor;
        m_LoadedVersion.iMinor = VersionData.iMinor;

        assert( 256 == sizeof(CtrlData3) );
        
        ZeroMemory ( &CtrlData3, sizeof ( CtrlData3 ) );

        hr = pIStream->Read(&CtrlData3, sizeof(CtrlData3), &bc);
        if (FAILED(hr))
            return hr;
        
        if (bc != sizeof(CtrlData3))
            return E_FAIL;

        // Setup extent info
        SetRect(&RectExt, 0, 0, CtrlData3.iWidth, CtrlData3.iHeight);
        m_pObj->RectConvertMappings(&RectExt, TRUE);    // Convert from HIMETRIC
        m_pObj->m_RectExt = RectExt;
        SetCurrentClientRect( &RectExt );

        // Load options settings in graph structure
        pOptions->iVertMax          = CtrlData3.iScaleMax;
        pOptions->iVertMin          = CtrlData3.iScaleMin;
        pOptions->bLegendChecked    = CtrlData3.bLegend;
        pOptions->bToolbarChecked   = CtrlData3.bToolbar;
        pOptions->bLabelsChecked    = CtrlData3.bLabels;
        pOptions->bHorzGridChecked  = CtrlData3.bHorzGrid;
        pOptions->bVertGridChecked  = CtrlData3.bVertGrid;
        pOptions->bValueBarChecked  = CtrlData3.bValueBar;
        pOptions->bManualUpdate     = CtrlData3.bManualUpdate;
        pOptions->bHighlight        = CtrlData3.bHighlight;     // New for 3.1,  default = 0
        pOptions->bReadOnly         = CtrlData3.bReadOnly;      // New for 3.1+, default = 0
        pOptions->bAmbientFont      = CtrlData3.bAmbientFont;   // New for 3.3+, new default = 1, but 0 for old files.
        pOptions->bMonitorDuplicateInstances = CtrlData3.bMonitorDuplicateInstances; 
        pOptions->fUpdateInterval   = CtrlData3.fUpdateInterval;
        pOptions->iDisplayType      = CtrlData3.iDisplayType;
        pOptions->clrBackCtl        = CtrlData3.clrBackCtl;
        pOptions->clrFore           = CtrlData3.clrFore;    
        pOptions->clrBackPlot       = CtrlData3.clrBackPlot;
        pOptions->iAppearance       = CtrlData3.iAppearance;
        pOptions->iBorderStyle      = CtrlData3.iBorderStyle;
        pOptions->iReportValueType  = CtrlData3.iReportValueType;   // New for 3.1+, default = 0
        pOptions->iDisplayFilter    = CtrlData3.iDisplayFilter;     // New for 3.4, default = 1, 0 is invalid
        iLocalDataSourceType        = CtrlData3.iDataSourceType;    // New for 3.4, default = 1, 0 is invalid
                                                                    // Pre-3.4, set based on presence of log file name                                                              // Set pOptions->iDataSourceType below
      
        if ( 0 == pOptions->iDisplayFilter ) {
            // New for 3.4
            assert ( ( SMONCTRL_MIN_VERSION - 2 ) > VersionData.iMinor );
            pOptions->iDisplayFilter = 1;
        }

        // Grid and TimeBar saved to file as of version 3.1.
        pOptions->clrGrid           = CtrlData3.clrGrid;
        pOptions->clrTimeBar        = CtrlData3.clrTimeBar;
    
        // Load font info if not using ambient font
        if ( !pOptions->bAmbientFont ) {
            hr = m_OleFont.LoadFromStream(pIStream);
            if (FAILED(hr))
                return hr;
        }
    
        // Read titles and log file name
        // As of Version 3.2, title and log file name strings stored as Wide characters
    
        // Log file name
        hr = WideStringFromStream(pIStream, &szLogFilePath, CtrlData3.nFileNameLen);
        if (FAILED(hr))
            return hr;

        // Graph title
        hr = WideStringFromStream(pIStream, &pOptions->pszGraphTitle, CtrlData3.nGraphTitleLen);
        if (FAILED(hr))
            return hr;

        // Y axis label
        hr = WideStringFromStream(pIStream, &pOptions->pszYaxisTitle, CtrlData3.nYaxisTitleLen);
        if (FAILED(hr))
            return hr;
               
        // Read display range
        m_DataSourceInfo.llStartDisp = CtrlData3.llStartDisp;
        m_DataSourceInfo.llStopDisp = CtrlData3.llStopDisp;

        // Must put actual data source type after loading display range, before adding counters.
        // Always set data source to null data source before adding data source names.
        hr = put_DataSourceType ( sysmonNullDataSource );

        if ( SUCCEEDED ( hr ) && NULL != szLogFilePath ) {
            assert ( 0 == NumLogFiles() );
            if ( L'\0' != szLogFilePath[0] ) {
                if ( ( SMONCTRL_MIN_VERSION - 1 ) > VersionData.iMinor ) {
                    // 3.4 writes a single log file.
                    hr = AddSingleLogFile ( szLogFilePath );
                } else {
                    // 3.5+ writes a multi_sz
                    hr = LoadLogFilesFromMultiSz ( szLogFilePath );
                }
            }
        }

        if ( NULL != szLogFilePath ) {
            delete [] szLogFilePath;
        }

        // If version < 3.4, set data source type based on presence of log files.
        if ( ( SMONCTRL_MIN_VERSION - 2 ) > VersionData.iMinor ) {
            // DataSourceType is new for 3.4
            if ( 0 == NumLogFiles() ) {
                iLocalDataSourceType = sysmonCurrentActivity;
            } else {
                iLocalDataSourceType = sysmonLogFiles;
            }
        }

        // Set scale max and min
        m_pObj->m_Graph.Scale.SetMaxValue(pOptions->iVertMax);
        m_pObj->m_Graph.Scale.SetMinValue(pOptions->iVertMin);

        // Convert non-null OLE colors to real colors
        if (pOptions->clrFore != NULL_COLOR)
            OleTranslateColor(pOptions->clrFore, NULL, &m_clrFgnd);
    
        if (pOptions->clrBackPlot != NULL_COLOR)
            OleTranslateColor(pOptions->clrBackPlot, NULL, &m_clrBackPlot);

        // NT 5 Beta 1 BackCtlColor can be NULL.
        if (pOptions->clrBackCtl != NULL_COLOR) 
            OleTranslateColor(pOptions->clrBackCtl, NULL, &m_clrBackCtl);
 
        OleTranslateColor(pOptions->clrGrid, NULL, &m_clrGrid);

        OleTranslateColor(pOptions->clrTimeBar, NULL, &m_clrTimeBar);

        // Handle other ambient properties

        if ( NULL_APPEARANCE != pOptions->iAppearance )
            put_Appearance( pOptions->iAppearance, FALSE );

        if ( NULL_BORDERSTYLE != pOptions->iBorderStyle )
            put_BorderStyle( pOptions->iBorderStyle, FALSE );

        // Read legend data
        hr = m_pLegend->LoadFromStream(pIStream);
        if (FAILED(hr))
            return hr;
                               
        //Load the counters
        hr = S_OK;

        // Load the counters into temporary storage, so that they can be added after the 
        // SQL name and future items are loaded 

        while (TRUE) {
        
            pNewElem = new ( DATA_LIST_ELEM );

            if ( NULL != pNewElem ) {
                
                ZeroMemory ( pNewElem, sizeof ( DATA_LIST_ELEM ) );

                // Add to end of list
                pNewElem->pNext = NULL;

                if ( NULL == pFirstElem ) {
                    pFirstElem = pNewElem;
                    pLastElem = pFirstElem;
                } else if ( NULL == pLastElem ) {
                    pLastElem = pNewElem;
                } else {
                    pLastElem->pNext = pNewElem;
                    pLastElem = pNewElem;
                }
            
                // Read in parameters
                hr = pIStream->Read(&pNewElem->itemData, sizeof(GRAPHITEM_DATA3), &bc);
                if ( SUCCEEDED ( hr ) ) {
                    if (bc == sizeof(GRAPHITEM_DATA3)) {

                        // Stop on null item (indicated by no path name)
                        if (pNewElem->itemData.m_nPathLength == 0) {
                            break;
                        }
                    } else {
                        hr = E_FAIL;
                    }
                }
            } else {
                hr = E_OUTOFMEMORY;
            }
        
            if ( SUCCEEDED ( hr ) ) {

                // As of Version 3.2, title and log file name strings stored as Wide characters
                // Read in path name
                hr = WideStringFromStream(pIStream, &pszCounterPath, pNewElem->itemData.m_nPathLength);
            }
        
            if ( SUCCEEDED ( hr ) ) {
                pNewElem->szCounterPath = pszCounterPath;
                pszCounterPath = NULL;
            }

        }

        if ( NULL != pszCounterPath ) {
            delete [] pszCounterPath;
            pszCounterPath = NULL;
        }

        if ( FAILED ( hr ) ) {
            while ( NULL != pFirstElem ) {
                pNewElem = pFirstElem->pNext;
                if ( NULL != pFirstElem->szCounterPath ) {
                    delete [] pFirstElem->szCounterPath;
                }
            
                delete pFirstElem;
                pFirstElem = pNewElem;
            }
            return hr;
        }
        
        // Load SQL names from the stream
        hr = WideStringFromStream(pIStream, &m_DataSourceInfo.szSqlDsnName, CtrlData3.iSqlDsnLen);
        if ( FAILED ( hr ) ) 
            return hr;

        hr = WideStringFromStream(pIStream, &m_DataSourceInfo.szSqlLogSetName, CtrlData3.iSqlLogSetNameLen);
        if (FAILED(hr))
            return hr;

        // Set the data source
        hr = put_DataSourceType ( iLocalDataSourceType );

        if (FAILED(hr)) {

            if ( SMON_STATUS_LOG_FILE_SIZE_LIMIT == (DWORD)hr ) {
                // TodoLogFiles:  Check log file type.  Only perfmon and circular
                // binary logs are still limited to 1 GB.
                // TodoLogFiles:  Current query is already closed,
                // so what can be done here?
            } else {
                DWORD   dwStatus;
                LPWSTR  szLogFileList = NULL;
                ULONG   ulLogListBufLen= 0;

                if ( sysmonLogFiles == iLocalDataSourceType ) {
                    dwStatus = BuildLogFileList (  NULL, TRUE, &ulLogListBufLen );
                    szLogFileList = new WCHAR[ulLogListBufLen];
                    if ( NULL != szLogFileList ) {
                        dwStatus = BuildLogFileList (  szLogFileList, TRUE, &ulLogListBufLen );
                    }
                }

                dwStatus = DisplayDataSourceError (
                                m_hWnd,
                                (DWORD)hr,
                                iLocalDataSourceType,
                                szLogFileList,
                                m_DataSourceInfo.szSqlDsnName,
                                m_DataSourceInfo.szSqlLogSetName );

                if ( NULL != szLogFileList ) {
                    delete [] szLogFileList;
                }
            }                
        }      
        
       
        m_bLogFileSource = ( sysmonCurrentActivity != m_pObj->m_Graph.Options.iDataSourceType ); 

        hr = S_OK;

        // Load the counters from the temporary data storage.
        m_bLoadingCounters = TRUE;

        for ( pNewElem = pFirstElem; NULL != pNewElem; pNewElem = pNewElem->pNext ) {

            DWORD  dwBufSize;
            LPWSTR pNewBuf;
            PDH_STATUS pdhStatus;

            CallbackInfo.pCtrl = this;
            CallbackInfo.pFirstItem = NULL;

            // Stop on null item (indicated by no path name)
            if ( 0 == pNewElem->itemData.m_nPathLength ) {
                break;
            }

            // Set up properties so AddCounter can use them
            m_clrCounter = pNewElem->itemData.m_rgbColor;
            m_iColorIndex = ColorToIndex (pNewElem->itemData.m_rgbColor);
            m_iWidthIndex = WidthToIndex (pNewElem->itemData.m_iWidth);
            m_iStyleIndex = StyleToIndex (pNewElem->itemData.m_iStyle);
            m_iScaleFactor = pNewElem->itemData.m_iScaleFactor;

            pszPath = pNewElem->szCounterPath;
            //
            // Initialize the locale path buffer
            //
            if (dwLocaleBufSize == 0) {
                dwLocaleBufSize = PDH_MAX_COUNTER_PATH + 1;

                szLocaleBuf = (LPWSTR) malloc(dwLocaleBufSize * sizeof(WCHAR));
                if (szLocaleBuf == NULL) {
                    dwLocaleBufSize = 0;
                }
            }

            if (szLocaleBuf != NULL) {
                //
                // Translate counter name from English to Localization
                //
                dwBufSize = dwLocaleBufSize;

                pdhStatus = PdhTranslateLocaleCounter(
                                pNewElem->szCounterPath,
                                szLocaleBuf,
                                &dwBufSize);

                if (pdhStatus == PDH_MORE_DATA) {
                    pNewBuf = (LPWSTR) realloc(szLocaleBuf, dwBufSize * sizeof(WCHAR));
                    if (pNewBuf != NULL) {
                        szLocaleBuf = pNewBuf;
                        dwLocaleBufSize = dwBufSize;

                        pdhStatus = PdhTranslateLocaleCounter(
                                        pNewElem->szCounterPath,
                                        szLocaleBuf,
                                        &dwBufSize);
                    }
                }

                if (pdhStatus == ERROR_SUCCESS) {
                    pszPath = szLocaleBuf;
                }
            }

            // Add new counter to control
            EnumExpandedPath (GetDataSourceHandle(), 
                              pszPath, 
                              AddCounterCallback, 
                              &CallbackInfo ); 
        }
        
        if (szLocaleBuf != NULL) {
            free(szLocaleBuf);
        }

        m_bLoadingCounters = FALSE;

        while ( NULL != pFirstElem ) {
            pNewElem = pFirstElem->pNext;
            if ( NULL != pFirstElem->szCounterPath ) {
                delete [] pFirstElem->szCounterPath;
            }
            delete pFirstElem;
            pFirstElem = pNewElem;
        }

        if ( SMONCTRL_MAJ_VERSION == VersionData.iMajor 
                && SMONCTRL_MIN_VERSION == VersionData.iMinor ) {
            m_pObj->m_fDirty=FALSE;
        } else {
            m_pObj->m_fDirty=TRUE;
        }

        if ( SMONCTRL_MIN_VERSION == VersionData.iMinor ) {
            // New for 3.6:  Save visuals to the stream
            // These must be loaded after the counters are loaded.
            m_iColorIndex = CtrlData3.iColorIndex;
            m_iWidthIndex = CtrlData3.iWidthIndex;
            m_iStyleIndex = CtrlData3.iStyleIndex;
        }

    } // Settings not loaded yet.    

    return hr;
}

HRESULT 
CSysmonControl::SaveToStream(LPSTREAM pIStream)
{
    HRESULT         hr = NOERROR;
    DWORD           dwStatus = ERROR_SUCCESS;
    GRAPH_OPTIONS   *pOptions = &m_pObj->m_Graph.Options;
    RECT            RectExt;
    SMONCTRL_VERSION_DATA   VersionData;
    LPWSTR          pszWideGraphTitle;
    LPWSTR          pszWideYaxisTitle;
    PCMachineNode   pMachine;
    PCObjectNode    pObject;
    PCInstanceNode  pInstance;
    PCGraphItem     pItem;
    PCCounterNode   pCounter;
    ULONG           ulLogFileListLen = 0;
    LPWSTR          szLogFileList = NULL;
    GRAPHCTRL_DATA3 CtrlData3;

    USES_CONVERSION
    assert( 256 == sizeof(CtrlData3) );

    ZeroMemory( &CtrlData3, 256 );

    //Store extent data in HIMETRIC format
    RectExt = m_pObj->m_RectExt;
    m_pObj->RectConvertMappings(&RectExt, FALSE); 
    CtrlData3.iWidth = RectExt.right - RectExt.left;
    CtrlData3.iHeight = RectExt.bottom - RectExt.top;

    // Store options settings in   structure
    CtrlData3.iScaleMax         = pOptions->iVertMax; 
    CtrlData3.iScaleMin         = pOptions->iVertMin; 
    CtrlData3.bLegend           = pOptions->bLegendChecked; 
    CtrlData3.bToolbar          = pOptions->bToolbarChecked; 
    CtrlData3.bLabels           = pOptions->bLabelsChecked; 
    CtrlData3.bHorzGrid         = pOptions->bHorzGridChecked; 
    CtrlData3.bVertGrid         = pOptions->bVertGridChecked; 
    CtrlData3.bValueBar         = pOptions->bValueBarChecked; 
    CtrlData3.bManualUpdate     = pOptions->bManualUpdate; 
    CtrlData3.bHighlight        = pOptions->bHighlight; 
    CtrlData3.bReadOnly         = pOptions->bReadOnly; 
    CtrlData3.bMonitorDuplicateInstances = pOptions->bMonitorDuplicateInstances; 
    CtrlData3.bAmbientFont      = pOptions->bAmbientFont; 
    CtrlData3.fUpdateInterval   = pOptions->fUpdateInterval; 
    CtrlData3.iDisplayType      = pOptions->iDisplayType; 
    CtrlData3.iReportValueType  = pOptions->iReportValueType; 
    CtrlData3.clrBackCtl        = pOptions->clrBackCtl;
    CtrlData3.clrFore           = pOptions->clrFore;
    CtrlData3.clrBackPlot       = pOptions->clrBackPlot;
    CtrlData3.iAppearance       = pOptions->iAppearance;
    CtrlData3.iBorderStyle      = pOptions->iBorderStyle;
    CtrlData3.clrGrid           = pOptions->clrGrid;
    CtrlData3.clrTimeBar        = pOptions->clrTimeBar;
    CtrlData3.iDisplayFilter    = pOptions->iDisplayFilter; 
    CtrlData3.iDataSourceType   = pOptions->iDataSourceType; 

    // Store the visuals in pOptions if they become visible 
    // via the programming interface.
    CtrlData3.iColorIndex       = m_iColorIndex;
    CtrlData3.iWidthIndex       = m_iWidthIndex;
    CtrlData3.iStyleIndex       = m_iStyleIndex;

    // NT 5 Beta 1 BackColorCtl can be NULL.
    if ( NULL_COLOR == pOptions->clrBackCtl ) 
        CtrlData3.clrBackCtl    = m_clrBackCtl;

    // Save number of samples to keep
    CtrlData3.nSamples = m_pHistCtrl->nMaxSamples;

    // Store Wide string lengths
    pszWideGraphTitle = pOptions->pszGraphTitle;
    CtrlData3.nGraphTitleLen = (pszWideGraphTitle == NULL) ? 
                                0 : lstrlen(pszWideGraphTitle);

    pszWideYaxisTitle = pOptions->pszYaxisTitle;
    CtrlData3.nYaxisTitleLen = (pszWideYaxisTitle == NULL) ? 
                                0 : lstrlen(pszWideYaxisTitle);
    
    BuildLogFileList ( NULL, FALSE, &ulLogFileListLen );
    CtrlData3.nFileNameLen = (INT32) ulLogFileListLen;

    CtrlData3.iSqlDsnLen = 0;
    if ( NULL != m_DataSourceInfo.szSqlDsnName ) {
        CtrlData3.iSqlDsnLen = lstrlen ( m_DataSourceInfo.szSqlDsnName );
    }

    CtrlData3.iSqlLogSetNameLen = 0;
    if ( NULL != m_DataSourceInfo.szSqlLogSetName ) {
        CtrlData3.iSqlLogSetNameLen = lstrlen ( m_DataSourceInfo.szSqlLogSetName );
    }

    // Store other file info
    CtrlData3.llStartDisp = m_DataSourceInfo.llStartDisp;
    CtrlData3.llStopDisp = m_DataSourceInfo.llStopDisp;

    // Write version info
    VersionData.iMajor = SMONCTRL_MAJ_VERSION;
    VersionData.iMinor = SMONCTRL_MIN_VERSION;

    hr = pIStream->Write(&VersionData, sizeof(VersionData), NULL);
    if (FAILED(hr))
        return hr;

    // Write control data
    hr = pIStream->Write(&CtrlData3, sizeof(CtrlData3), NULL);
    if (FAILED(hr))
       return hr;

    // Write font info if not using ambient font
    if ( !pOptions->bAmbientFont ) {
        hr = m_OleFont.SaveToStream(pIStream, TRUE);
        if (FAILED(hr))
            return hr;
    }

    // Write log file name
    if (CtrlData3.nFileNameLen != 0) {

        szLogFileList = new WCHAR[ulLogFileListLen];
        if ( NULL != szLogFileList ) {
            dwStatus = BuildLogFileList ( 
                        szLogFileList,
                        FALSE,
                        &ulLogFileListLen );
            if ( ERROR_SUCCESS != dwStatus ) {
                hr = E_FAIL;
            }
        } else {
            hr = E_OUTOFMEMORY;
        }

        if ( SUCCEEDED ( hr ) ) {
            hr = pIStream->Write(szLogFileList, CtrlData3.nFileNameLen*sizeof(WCHAR), NULL);
        }
        if ( NULL != szLogFileList ) {
            delete [] szLogFileList;
            szLogFileList = NULL;
        }
        if (FAILED(hr))
            return hr;
    }

    // Write titles
    if (CtrlData3.nGraphTitleLen != 0) {
        hr = pIStream->Write(pszWideGraphTitle, CtrlData3.nGraphTitleLen*sizeof(WCHAR), NULL);
        if (FAILED(hr))
            return hr;
    }

    if (CtrlData3.nYaxisTitleLen != 0) {
        hr = pIStream->Write(pszWideYaxisTitle, CtrlData3.nYaxisTitleLen*sizeof(WCHAR), NULL);
        if (FAILED(hr))
            return hr;
    }

    // Write legend data
    hr = m_pLegend->SaveToStream(pIStream);
    if (FAILED(hr))
        return hr;
    
    // Save all counter info
    // Explicit counters first, followed by "All Instance" groups
    for ( pMachine = CounterTree()->FirstMachine();
          pMachine;
          pMachine = pMachine->Next()) {

      for ( pObject = pMachine->FirstObject();
            pObject;
            pObject = pObject->Next()) {

            // Clear generated pointer for all object's counters
            for ( pCounter = pObject->FirstCounter();
                  pCounter;
                  pCounter = pCounter->Next()) {
                     pCounter->m_pFirstGenerated = NULL;
                 }

            for ( pInstance = pObject->FirstInstance();
                  pInstance;
                  pInstance = pInstance->Next()) {

                for ( pItem = pInstance->FirstItem();
                      pItem;
                      pItem = pItem->m_pNextItem) {
                    
                    // If item is the first generated one for this counter
                    // then save it as the wild card model for this counter
                    if (pItem->m_fGenerated) {
                        if (pItem->Counter()->m_pFirstGenerated == NULL)
                            pItem->Counter()->m_pFirstGenerated = pItem;
                    }
                    else {
                        // else save it explictly
                        hr = pItem->SaveToStream(pIStream, FALSE, VersionData.iMajor, VersionData.iMinor);
                        if (FAILED(hr))
                            return hr;
                    }
                }
            }

            // Now go through counters again and store a wildcard path
            // for any that have genererated counters
            for (pCounter = pObject->FirstCounter();
                 pCounter;
                 pCounter = pCounter->Next()) {
                if (pCounter->m_pFirstGenerated) {
                    hr = pCounter->m_pFirstGenerated->SaveToStream(pIStream, TRUE, VersionData.iMajor, VersionData.iMinor);
                    if (FAILED(hr))
                        return hr;
                }
            }
        }
    }

    // Write null item to mark end of counter items
    hr = CGraphItem::NullItemToStream(pIStream, VersionData.iMajor, VersionData.iMinor);

    // Write Sql data source names
    if (CtrlData3.iSqlDsnLen != 0) {
        hr = pIStream->Write(m_DataSourceInfo.szSqlDsnName, CtrlData3.iSqlDsnLen*sizeof(WCHAR), NULL);
    }
    if (CtrlData3.iSqlLogSetNameLen != 0) {
        hr = pIStream->Write(m_DataSourceInfo.szSqlLogSetName, CtrlData3.iSqlLogSetNameLen*sizeof(WCHAR), NULL);
    }
    return hr;
}

HRESULT 
CSysmonControl::LoadLogFilesFromPropertyBag (
    IPropertyBag*   pIPropBag,
    IErrorLog*      pIErrorLog )
{
    HRESULT     hr = S_OK;
    HRESULT     hrErr = S_OK;
    INT         iLogFileCount = 0;
    INT         iIndex;
    INT         iBufSize = 0;
    INT         iPrevBufSize  = 0;
    LPWSTR      pszLogFilePath = NULL;
    INT         iLogFilePathBufSize = 0;
    WCHAR       szLogFilePropName[32];
    eDataSourceTypeConstant ePrevDataSourceType;
    DWORD       dwErrorPathListLen;
    LPCWSTR     szErrorPathList = NULL;
    LPWSTR      szMessage = NULL;

    get_DataSourceType ( ePrevDataSourceType );

    ClearErrorPathList();

    hr = StringFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszLogFileName, NULL, iBufSize );
    if ( SUCCEEDED(hr) && 
         iBufSize > 0 ) {
        
        pszLogFilePath = new WCHAR[iBufSize + 1];
        
        if ( NULL != pszLogFilePath ) {
            hr = StringFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszLogFileName, pszLogFilePath, iBufSize );
        } else {
            hr = E_OUTOFMEMORY;
        }
        
        if ( SUCCEEDED ( hr ) ) {
            // Always set the log source to null data source before modifying the log file list.
            // TodoLogFiles:  This can leave the user with state different than before, in the
            // case of log file load failure.
    
            hr = put_DataSourceType ( sysmonNullDataSource );
            if ( SUCCEEDED ( hr ) ) {
                assert ( 0 == NumLogFiles() );
                hr = AddSingleLogFile ( pszLogFilePath );
            }
        }

        if ( FAILED ( hr ) && NULL != pszLogFilePath ) {
            hrErr = hr;
            AddToErrorPathList ( pszLogFilePath );
        }

        if ( NULL != pszLogFilePath ) {
            delete [] pszLogFilePath;
            pszLogFilePath = NULL;
        }
    } else {
        hr = IntegerFromPropertyBag (pIPropBag, pIErrorLog, CGlobalString::m_cszLogFileCount, iLogFileCount );
        if ( SUCCEEDED( hr ) && 0 < iLogFileCount ) {
            assert ( 0 == NumLogFiles() );
            for ( iIndex = 1; iIndex <= iLogFileCount; iIndex++ ) {
                // Todo: log file list error message, as for counters
                // If one of the log files fails to load, continue loading others.
                hr = NOERROR;
                StringCchPrintf(szLogFilePropName, 
                                32,
                                CGlobalString::m_cszLogNameFormat, 
                                CGlobalString::m_cszLogFileName, 
                                iIndex );

                iPrevBufSize = iBufSize;
                hr = StringFromPropertyBag (
                        pIPropBag,
                        pIErrorLog,
                        szLogFilePropName,
                        pszLogFilePath,
                        iBufSize );
                if ( iBufSize > iPrevBufSize ) {
                    if ( NULL == pszLogFilePath || (iBufSize > iLogFilePathBufSize) ) {
                        if ( NULL != pszLogFilePath ) {
                            delete [] pszLogFilePath;
                            pszLogFilePath = 0;
                        }
                        pszLogFilePath = new WCHAR[iBufSize];
                        if ( NULL != pszLogFilePath ) {
                            iLogFilePathBufSize = iBufSize;
                        }
                    }
                    if ( NULL != pszLogFilePath ) {
                        hr = StringFromPropertyBag (
                                pIPropBag,
                                pIErrorLog,
                                szLogFilePropName,
                                pszLogFilePath,
                                iBufSize );
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                }

                if ( SUCCEEDED(hr) 
                      && MAX_PATH >= lstrlen(pszLogFilePath) ) {
                    hr = put_DataSourceType ( sysmonNullDataSource );
                    if ( SUCCEEDED ( hr ) ) {
                        hr = AddSingleLogFile ( pszLogFilePath );
                    }
                }

                if ( FAILED (hr) && SMON_STATUS_DUPL_LOG_FILE_PATH != (DWORD)hr ) 
                {
                    if ( S_OK == hrErr ) {
                        hrErr = hr;
                    }
                    AddToErrorPathList ( pszLogFilePath );
                }
            }
        }
    }

    if ( NULL != pszLogFilePath ) {
        delete [] pszLogFilePath;
        pszLogFilePath = NULL;
    }
    
    if ( SMON_STATUS_DUPL_LOG_FILE_PATH != (DWORD)hr ) {
        szErrorPathList = GetErrorPathList ( &dwErrorPathListLen );
        if ( NULL != szErrorPathList ) {

            // Report error, but continue.
            szMessage = new WCHAR [dwErrorPathListLen + RESOURCE_STRING_BUF_LEN + 1];
    
            if ( NULL != szMessage ) {
                StringCchPrintf(szMessage, 
                                 dwErrorPathListLen + MAX_PATH,
                                 ResourceString(IDS_ADD_LOG_FILE_ERR), 
                                 szErrorPathList );    
                MessageBox (
                    m_hWnd, 
                    szMessage, 
                    ResourceString(IDS_APP_NAME), 
                    MB_OK | MB_ICONEXCLAMATION );

                delete [] szMessage;
            }
        }
    }
    ClearErrorPathList();

    return hrErr;
}
    
HRESULT 
CSysmonControl::LoadCountersFromPropertyBag (
    IPropertyBag*   pIPropBag,
    IErrorLog*      pIErrorLog,
    BOOL            bLoadData )
{
    HRESULT     hr = S_OK;
    HRESULT     hrErr = S_OK;
    INT         iCounterCount = 0;
    INT         iSampleCount = 0;
    INT         intValue;
    INT         iIndex;
    INT         iBufSize = 0;
    INT         iPrevBufSize  = 0;
    LPWSTR      pszCounterPath = NULL;
    INT         iCounterPathBufSize = 0;
    LPWSTR      szSelected = NULL;
    INT         nBufferSize = 0;
    WCHAR       szPathPropName[32];
    LPWSTR      szEnglishBuf = NULL;
    DWORD       dwEnglishBufSize = 0;
    LPWSTR      pszPath = NULL;
    DWORD       dwBufSize;
    LPWSTR      pNewBuf;
    PDH_STATUS  pdhStatus;
    PCGraphItem pItem = NULL;
    DWORD       dwCounterListLen = 0;
    LPCWSTR     szCounterList = NULL;
    
    hr = IntegerFromPropertyBag (pIPropBag, pIErrorLog, CGlobalString::m_cszCounterCount, iCounterCount );
    if ( SUCCEEDED( hr ) && 0 < iCounterCount ) {
        szSelected = NULL;
        do {
            if (szSelected) {
                delete [] szSelected;
                szSelected = NULL;
                nBufferSize = iBufSize;
            }
            else {
                nBufferSize = PDH_MAX_COUNTER_PATH + 1;
                iBufSize = nBufferSize;
            }

            szSelected =  new WCHAR [nBufferSize];
    
            if (szSelected == NULL) {
                return E_OUTOFMEMORY;
            }

            hr = StringFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszSelected, szSelected, iBufSize );

        } while (SUCCEEDED(hr) && iBufSize > nBufferSize);
 
        if( SUCCEEDED( hr ) ){
            //
            // Initialize the locale path buffer
            //
            if (dwEnglishBufSize == 0) {
                dwEnglishBufSize = PDH_MAX_COUNTER_PATH + 1;
                szEnglishBuf = (LPWSTR) malloc(dwEnglishBufSize * sizeof(WCHAR));
                if (szEnglishBuf == NULL) {
                    dwEnglishBufSize = 0;
                }
            }

            if (szEnglishBuf != NULL) {
                //
                // Translate counter name from Localization into English
                //
                dwBufSize = dwEnglishBufSize;

                pdhStatus = PdhTranslate009Counter(
                                szSelected,
                                szEnglishBuf,
                                &dwBufSize);

                if (pdhStatus == PDH_MORE_DATA) {
                    pNewBuf = (LPWSTR)realloc(szEnglishBuf, dwBufSize * sizeof(WCHAR));
                    if (pNewBuf != NULL) {
                        szEnglishBuf = pNewBuf;
                        dwEnglishBufSize = dwBufSize;

                        pdhStatus = PdhTranslate009Counter(
                                        szSelected,
                                        szEnglishBuf,
                                        &dwBufSize);
                    }
                }

                if (pdhStatus == ERROR_SUCCESS && (LONG)dwBufSize < lstrlen(szSelected) ) {
                    StringCchCopy(szSelected, nBufferSize, szEnglishBuf);
                }
            }
        }
    }


    if ( bLoadData ) {
        hr = IntegerFromPropertyBag (pIPropBag, pIErrorLog, CGlobalString::m_cszSampleCount, iSampleCount );        
        if ( SUCCEEDED(hr) && ( 0 < iSampleCount ) ) {
            intValue = 0;
            hr = IntegerFromPropertyBag (pIPropBag, pIErrorLog, CGlobalString::m_cszSampleIndex, intValue ); 
    
            if ( SUCCEEDED(hr) && intValue > 0 && intValue <= iSampleCount ) {
                INT iStepNum;
                hr = IntegerFromPropertyBag (
                        pIPropBag, 
                        pIErrorLog, 
                        CGlobalString::m_cszStepNumber, iStepNum ); 

                if ( SUCCEEDED(hr) ) {
                    // If data has been passed, freeze the view.
                    // These values are set only if all three values are present in the property bag.
                    put_ManualUpdate( TRUE );
                    // MaxSamples hardcoded for NT5
                    m_pHistCtrl->nSamples = iSampleCount;
                    m_pHistCtrl->iCurrent = intValue;
                    m_pObj->m_Graph.TimeStepper.StepTo(iStepNum);
                    m_bSampleDataLoaded = TRUE;
                }
            }
        }
    } else {
        iSampleCount = 0;
    }

    iBufSize = 0;
    ClearErrorPathList();
    
    for ( iIndex = 1; iIndex <= iCounterCount; iIndex++ ) {
    
        // If one of the counters fails to load, continue loading others.

        hr = NOERROR;
        StringCchPrintf(szPathPropName, 32, L"%s%05d.Path", CGlobalString::m_cszCounter, iIndex );

        iPrevBufSize = iBufSize;
        hr = StringFromPropertyBag (
                pIPropBag,
                pIErrorLog,
                szPathPropName,
                pszCounterPath,
                iBufSize );


        if ( iBufSize > iPrevBufSize ) {
            if ( NULL == pszCounterPath || (iBufSize > iCounterPathBufSize) ) {
                if ( NULL != pszCounterPath ) {
                    delete [] pszCounterPath;
                    iCounterPathBufSize = 0;
                }
                pszCounterPath = new WCHAR[iBufSize];
                if ( NULL != pszCounterPath ) {
                    iCounterPathBufSize = iBufSize;
                }
            }
            if ( NULL != pszCounterPath ) {
                hr = StringFromPropertyBag (
                        pIPropBag,
                        pIErrorLog,
                        szPathPropName,
                        pszCounterPath,
                        iBufSize );
            } else {
                hr = E_OUTOFMEMORY;
            }
        }
    
        pszPath = pszCounterPath;

        if ( SUCCEEDED(hr) ) {
            
            //
            // Translate English counter name into localized counter name
            //

            if (dwEnglishBufSize == 0) {
                dwEnglishBufSize = PDH_MAX_COUNTER_PATH + 1;

                szEnglishBuf = (LPWSTR) malloc(dwEnglishBufSize * sizeof(WCHAR));
                if (szEnglishBuf == NULL) {
                    dwEnglishBufSize = 0;
                }
            }

            if (szEnglishBuf != NULL) {
                //
                // Translate counter name from English to Localization
                //
                dwBufSize = dwEnglishBufSize;
 
                pdhStatus = PdhTranslateLocaleCounter(
                               pszCounterPath,
                                szEnglishBuf,
                                &dwBufSize);
 
                if (pdhStatus == PDH_MORE_DATA) {
                    pNewBuf = (LPWSTR) realloc(szEnglishBuf, dwBufSize * sizeof(WCHAR));
                    if (pNewBuf != NULL) {
                        szEnglishBuf = pNewBuf;
                        dwEnglishBufSize = dwBufSize;
 
                        pdhStatus = PdhTranslateLocaleCounter(
                                        pszCounterPath,
                                        szEnglishBuf,
                                        &dwBufSize);
                    }
                }
 
                if (pdhStatus == ERROR_SUCCESS) {   
                    pszPath = szEnglishBuf;
                }
            }
 
            hr = AddCounter ( pszPath, &pItem );
            
            // Return status of the first failed counter.
            if ( FAILED ( hr ) && SMON_STATUS_DUPL_COUNTER_PATH != (DWORD)hr ) {
                if ( S_OK == hrErr ) {
                    hrErr = hr;
                }
            }
        } else {
            hr = E_FAIL;
            if ( S_OK == hrErr ) {
                hrErr = E_FAIL;
            }
        }


        if ( SUCCEEDED(hr) ) {
            assert ( NULL != pItem );
            if ( 0 == lstrcmpi ( pszPath, szSelected ) ) {
                SelectCounter( pItem );
            }
            if ( SUCCEEDED(hr) ) {
                assert ( NULL != pItem );
                // Only pass sample count if all sample properties exist
                // in the property bag.
                hr = pItem->LoadFromPropertyBag ( 
                                pIPropBag, 
                                pIErrorLog, 
                                iIndex,
                                SMONCTRL_MAJ_VERSION,
                                SMONCTRL_MIN_VERSION,
                                m_bSampleDataLoaded ? iSampleCount : 0 ); 
                                                           
            }
        } else {
            if ( SMON_STATUS_DUPL_COUNTER_PATH != (DWORD)hr ) {
                AddToErrorPathList ( pszPath );
            }
        }
    }

    if (szSelected  != NULL){
        delete [] szSelected;
    }

    if (szEnglishBuf != NULL) {
        free(szEnglishBuf);
    }
    
    if ( NULL != pszCounterPath ) {
        delete [] pszCounterPath;
    }
    
    szCounterList = GetErrorPathList ( &dwCounterListLen );
    if ( NULL != szCounterList ) {

        LPWSTR szMessage = NULL;

        // Report error, but continue.
        szMessage = new WCHAR [dwCounterListLen + RESOURCE_STRING_BUF_LEN + 1];
    
        if ( NULL != szMessage ) {
            StringCchPrintf(szMessage, 
                            dwCounterListLen + RESOURCE_STRING_BUF_LEN + 1,
                            ResourceString(IDS_ADD_COUNTER_ERR), 
                            szCounterList );    
            MessageBox (
                m_hWnd, 
                szMessage, 
                ResourceString(IDS_APP_NAME), 
                MB_OK | MB_ICONEXCLAMATION);

            delete [] szMessage;
        }
        ClearErrorPathList();
    }

    return hrErr;
}


HRESULT 
CSysmonControl::LoadFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog* pIErrorLog )
{
    HRESULT     hr = S_OK;
    GRAPH_OPTIONS   *pOptions = &m_pObj->m_Graph.Options;
    ISystemMonitor  *pObj = m_pObj->m_pImpISystemMonitor;
    INT         iExtentX;
    INT         iExtentY;
    INT         intValue;
    BOOL        bValue;
    FLOAT       fValue;
    OLE_COLOR   clrValue;
    INT         iBufSize;
    SMONCTRL_VERSION_DATA VersionData;
    INT         nLogType = SMON_CTRL_LOG;

    // Version info

    if (g_dwScriptPolicy == URLPOLICY_DISALLOW) {
        return E_ACCESSDENIED;
    }

    VersionData.dwVersion = 0;
    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszVersion, (INT&)VersionData.dwVersion );
    
    assert ( SMONCTRL_MAJ_VERSION >= VersionData.iMajor );

    m_LoadedVersion.dwVersion = VersionData.dwVersion;

    hr = IntegerFromPropertyBag (pIPropBag, pIErrorLog, CGlobalString::m_cszLogType, nLogType);
    if(SUCCEEDED(hr) && (nLogType == SLQ_TRACE_LOG)) {
        // This is a WMI/WDM event trace log files, bail out immediately.
        //
        MessageBox(m_hWnd,
                   ResourceString(IDS_TRACE_LOG_ERR_MSG),
                   ResourceString(IDS_APP_NAME),
                   MB_OK);
        return NOERROR;
    }

    // When loading properties, continue even if errors. On error, the value will 
    // remain default value.
    // Extent data
    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszExtentX, iExtentX );

    if ( SUCCEEDED( hr ) ){
        hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszExtentY, iExtentY );
        if ( SUCCEEDED( hr ) ) {
            RECT RectExt;

            SetRect(&RectExt, 0, 0, iExtentX, iExtentY);
            m_pObj->RectConvertMappings(&RectExt, TRUE);    // Convert from HIMETRIC
            m_pObj->m_RectExt = RectExt;
        }
    }

    // Options settings.  Where possible, options are added through the vtable
    // interface, for validation.    

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszDisplayType, intValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_DisplayType ( (eDisplayTypeConstant)intValue );
    }

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszReportValueType, intValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ReportValueType ( (eReportValueTypeConstant)intValue );
    }

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszMaximumScale, intValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_MaximumScale ( intValue );
    }

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszMinimumScale, intValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_MinimumScale ( intValue );
    }

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszAppearance, intValue );
    if ( SUCCEEDED(hr) ) {
        if ( NULL_COLOR == intValue ) {
            pOptions->iAppearance = intValue;
        } else {
            hr = pObj->put_Appearance ( intValue );
        }
    }

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszBorderStyle, intValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_BorderStyle ( intValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszShowLegend, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ShowLegend ( (SHORT)bValue );
    }
                
    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszShowToolBar, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ShowToolbar ( (SHORT)bValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszShowValueBar, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ShowValueBar ( (SHORT)bValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszShowScaleLabels, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ShowScaleLabels ( (SHORT)bValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszShowHorizontalGrid, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ShowHorizontalGrid ( (SHORT)bValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszShowVerticalGrid, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ShowVerticalGrid ( (SHORT)bValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszHighLight, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_Highlight ( (SHORT)bValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszManualUpdate, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ManualUpdate ( (SHORT)bValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszReadOnly, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ReadOnly ( (SHORT)bValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszMonitorDuplicateInstance, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_MonitorDuplicateInstances ( (SHORT)bValue );
    }

    hr = FloatFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszUpdateInterval, fValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_UpdateInterval ( fValue );
    }
    
    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszDisplayFilter, intValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_DisplayFilter ( intValue );
    }

    hr = OleColorFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszBackColorCtl, clrValue );
    if ( SUCCEEDED(hr) ) {
        if ( NULL_COLOR == clrValue ) {
            pOptions->clrBackCtl = clrValue;
        } else {
            hr = pObj->put_BackColorCtl ( clrValue );
        }
    }

    hr = OleColorFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszBackColor, clrValue );
    if ( SUCCEEDED(hr) ) {
        if ( NULL_COLOR == clrValue ) {
            pOptions->clrBackPlot = clrValue;
        } else {
            hr = pObj->put_BackColor ( clrValue );
        }
    }
    
    hr = OleColorFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszForeColor, clrValue );
    if ( SUCCEEDED(hr) ) {
        if ( NULL_COLOR == clrValue ) {
            pOptions->clrFore = clrValue;
        } else {
            hr = pObj->put_ForeColor ( clrValue );
        }
    }
    
    hr = OleColorFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszGridColor, clrValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_GridColor ( clrValue );
    }

    hr = OleColorFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszTimeBarColor, clrValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_TimeBarColor ( clrValue );
    }

    // Titles
    
    hr = StringFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszGraphTitle, NULL, iBufSize );
    if ( SUCCEEDED(hr) && 
        iBufSize > 0 ) {
        pOptions->pszGraphTitle = new WCHAR[iBufSize];
        if ( NULL != pOptions->pszGraphTitle ) {
            hr = StringFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszGraphTitle, pOptions->pszGraphTitle, iBufSize );
        }
    }

    hr = StringFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszYAxisLabel, NULL, iBufSize );
    if ( SUCCEEDED(hr) && 
         iBufSize > 0 ) {
        pOptions->pszYaxisTitle = new WCHAR[iBufSize];
        if ( NULL != pOptions->pszYaxisTitle ) {
            hr = StringFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszYAxisLabel, pOptions->pszYaxisTitle, iBufSize );
        }
    }

    // SQL DSN and logset info
    // 
    hr = StringFromPropertyBag(
            pIPropBag, pIErrorLog, CGlobalString::m_cszSqlDsnName, NULL, iBufSize);
    if (SUCCEEDED(hr) &&  iBufSize > 0) {
        if (m_DataSourceInfo.szSqlDsnName) {
            delete [] m_DataSourceInfo.szSqlDsnName;
            m_DataSourceInfo.szSqlDsnName = NULL;
        }
        m_DataSourceInfo.szSqlDsnName = new WCHAR[iBufSize + 1];
        if (m_DataSourceInfo.szSqlDsnName) {
            hr = StringFromPropertyBag(pIPropBag,
                                       pIErrorLog,
                                       CGlobalString::m_cszSqlDsnName,
                                       m_DataSourceInfo.szSqlDsnName,
                                       iBufSize);
        }
        if (SUCCEEDED(hr)) {
            hr = StringFromPropertyBag(
                    pIPropBag, pIErrorLog, CGlobalString::m_cszSqlLogSetName, NULL, iBufSize);
            if (SUCCEEDED(hr) &&  iBufSize > 0) {
                if (m_DataSourceInfo.szSqlLogSetName) {
                    delete [] m_DataSourceInfo.szSqlLogSetName;
                    m_DataSourceInfo.szSqlLogSetName = NULL;
                }
                m_DataSourceInfo.szSqlLogSetName = new WCHAR[iBufSize + 1];
                if (m_DataSourceInfo.szSqlLogSetName) {
                    hr = StringFromPropertyBag(pIPropBag,
                                               pIErrorLog,
                                               CGlobalString::m_cszSqlLogSetName,
                                               m_DataSourceInfo.szSqlLogSetName,
                                               iBufSize);
                }
            }
        }
        if (SUCCEEDED(hr)) {
            hr = LLTimeFromPropertyBag(pIPropBag,
                                       pIErrorLog,
                                       CGlobalString::m_cszLogViewStart,
                                       m_DataSourceInfo.llStartDisp);
        }
        if (SUCCEEDED(hr)) {
            hr = LLTimeFromPropertyBag(pIPropBag,
                                       pIErrorLog,
                                       CGlobalString::m_cszLogViewStop,
                                       m_DataSourceInfo.llStopDisp);
        }
    }

    // Log file info

    hr = LoadLogFilesFromPropertyBag ( pIPropBag, pIErrorLog );

    // Must put log file name after display range, before adding counters.

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszDataSourceType, intValue );
    if (FAILED (hr)) {
        //
        // If DataSourceType flag is missing, set data source type based on 
        // presence of log files.
        //
        intValue = sysmonCurrentActivity;

        if (NumLogFiles() > 0) {
            intValue = sysmonLogFiles;
        }
        else if ( m_DataSourceInfo.szSqlDsnName && m_DataSourceInfo.szSqlLogSetName ) {
            if ( m_DataSourceInfo.szSqlDsnName[0] != L'\0' && m_DataSourceInfo.szSqlLogSetName[0] != L'\0') {
                intValue = sysmonSqlLog;
            }
        }
    }

    // Load log view start and stop times if the data source is not realtime.
    if ( sysmonSqlLog == intValue || sysmonLogFiles == intValue ) {
        hr = LLTimeFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszLogViewStart, m_DataSourceInfo.llStartDisp );
        hr = LLTimeFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszLogViewStop, m_DataSourceInfo.llStopDisp );
    }

    hr = pObj->put_DataSourceType ( (eDataSourceTypeConstant)intValue );

    if( FAILED(hr) ) {

        if ( SMON_STATUS_LOG_FILE_SIZE_LIMIT == (DWORD)hr ) {
            // TodoLogFiles:  Check log file type.  Only perfmon and circular
            // binary logs are still limited to 1 GB.
            // TodoLogFiles:  Current query is already closed,
            // so what can be done here?
        } else {
            DWORD   dwStatus;
            LPWSTR  szLogFileList = NULL;
            ULONG   ulLogListBufLen= 0;

            if ( sysmonLogFiles == intValue ) {
                dwStatus = BuildLogFileList ( NULL, TRUE, &ulLogListBufLen );
                szLogFileList =  new WCHAR[ulLogListBufLen];
                if ( NULL != szLogFileList ) {
                    dwStatus = BuildLogFileList ( 
                                szLogFileList,
                                TRUE,
                                &ulLogListBufLen );
                }
            }
            dwStatus = DisplayDataSourceError (
                            m_hWnd,
                            (DWORD)hr,
                            intValue,
                            szLogFileList,
                            m_DataSourceInfo.szSqlDsnName,
                            m_DataSourceInfo.szSqlLogSetName );

            if ( NULL != szLogFileList ) {
                delete [] szLogFileList;
                szLogFileList = NULL;
            }
        }
    } 

    // Font info
    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszAmbientFont, bValue );
    if (SUCCEEDED(hr)) {
        pOptions->bAmbientFont = bValue;
    }

    // Load property bag values if they exist, overriding any specified aspect of ambient font.
    hr = m_OleFont.LoadFromPropertyBag ( pIPropBag, pIErrorLog );

    // Legend
    hr = m_pLegend->LoadFromPropertyBag ( pIPropBag, pIErrorLog );

    // Counters
        
    m_bLoadingCounters = TRUE;

    hr = LoadCountersFromPropertyBag ( pIPropBag, pIErrorLog, TRUE );

    m_bLoadingCounters = FALSE;

    // Load the Visuals after loading all counters.

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszNextCounterColor, intValue );
    if ( SUCCEEDED(hr) && ( intValue < NumStandardColorIndices() ) ) {
        m_iColorIndex = intValue;
    }

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszNextCounterWidth, intValue );
    if ( SUCCEEDED(hr) && ( intValue < NumWidthIndices() ) ) {
        m_iWidthIndex = intValue;
    }

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszNextCounterLineStyle, intValue );
    if ( SUCCEEDED(hr) && ( intValue < NumStyleIndices() ) ) {
        m_iStyleIndex = intValue;
    }

    return NOERROR;
}


HRESULT 
CSysmonControl::SaveToPropertyBag (
    IPropertyBag* pIPropBag,
    BOOL fSaveAllProps )
{
    HRESULT         hr = NOERROR;
    GRAPH_OPTIONS   *pOptions = &m_pObj->m_Graph.Options;
    PCMachineNode   pMachine;
    PCObjectNode    pObject;
    PCInstanceNode  pInstance;
    PCGraphItem     pItem;
    PCLogFileItem   pLogFile = NULL;
    INT             iCounterIndex = 0;
    INT             iLogFileIndex = 0;
    RECT            RectExt;
    SMONCTRL_VERSION_DATA VersionData;
    WCHAR           szLogFileName[16];
    LPWSTR          szEnglishBuf = NULL;
    DWORD           dwEnglishBufSize = 0;
    LPWSTR          pszPath = NULL;
    PDH_STATUS      pdhStatus;

    // Version info
    VersionData.iMajor = SMONCTRL_MAJ_VERSION;
    VersionData.iMinor = SMONCTRL_MIN_VERSION;
    
    hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszVersion, VersionData.dwVersion );

    // Extent data in HIMETRIC format
    if ( SUCCEEDED( hr ) ){
        RectExt = m_pObj->m_RectExt;
        m_pObj->RectConvertMappings(&RectExt, FALSE); 
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszExtentX, RectExt.right - RectExt.left );

        if ( SUCCEEDED( hr ) ){
            hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszExtentY, RectExt.bottom - RectExt.top );
        }
    }

    // Options settings

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszDisplayType, pOptions->iDisplayType );
    }

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszReportValueType, pOptions->iReportValueType );
    }

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszMaximumScale, pOptions->iVertMax );
    }

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszMinimumScale, pOptions->iVertMin );
    }

    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszShowLegend, pOptions->bLegendChecked );
    }
                
    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszShowToolBar, pOptions->bToolbarChecked );
    }

    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszShowScaleLabels, pOptions->bLabelsChecked );
    }

    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszShowHorizontalGrid, pOptions->bHorzGridChecked );
    }
    
    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszShowVerticalGrid, pOptions->bVertGridChecked );
    }

    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszShowValueBar, pOptions->bValueBarChecked );
    }

    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszManualUpdate, pOptions->bManualUpdate );
    }

    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszHighLight, pOptions->bHighlight );
    }

    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszReadOnly, pOptions->bReadOnly );
    }
    
    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszMonitorDuplicateInstance, pOptions->bMonitorDuplicateInstances );
    }
    
    if ( SUCCEEDED( hr ) ){
        hr = FloatToPropertyBag ( pIPropBag, CGlobalString::m_cszUpdateInterval, pOptions->fUpdateInterval );
    }
    
    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszDisplayFilter, pOptions->iDisplayFilter );
    }

    if ( SUCCEEDED( hr ) ){
        hr = OleColorToPropertyBag ( pIPropBag, CGlobalString::m_cszBackColorCtl, pOptions->clrBackCtl );
    }

    if ( SUCCEEDED( hr ) ){
        hr = OleColorToPropertyBag ( pIPropBag, CGlobalString::m_cszForeColor, pOptions->clrFore );
    }

    if ( SUCCEEDED( hr ) ){
        hr = OleColorToPropertyBag ( pIPropBag, CGlobalString::m_cszBackColor, pOptions->clrBackPlot );
    }

    if ( SUCCEEDED( hr ) ){
        hr = OleColorToPropertyBag ( pIPropBag, CGlobalString::m_cszGridColor, pOptions->clrGrid );
    }
        
    if ( SUCCEEDED( hr ) ){
        hr = OleColorToPropertyBag ( pIPropBag, CGlobalString::m_cszTimeBarColor, pOptions->clrTimeBar );
    }

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszAppearance, pOptions->iAppearance );
    }

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszBorderStyle, pOptions->iBorderStyle );
    }

    // Visuals are stored directly in the control.  Move to pOptions if made part
    // of the programming interface.
    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszNextCounterColor, m_iColorIndex );
    }

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszNextCounterWidth, m_iWidthIndex );
    }

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszNextCounterLineStyle, m_iStyleIndex );
    }

    // Titles
    
    if ( SUCCEEDED( hr ) ){
        hr = StringToPropertyBag ( pIPropBag, CGlobalString::m_cszGraphTitle, pOptions->pszGraphTitle );
    }

    if ( SUCCEEDED( hr ) ){
        hr = StringToPropertyBag ( pIPropBag, CGlobalString::m_cszYAxisLabel, pOptions->pszYaxisTitle );
    }

    // Data source info

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszDataSourceType, pOptions->iDataSourceType );
    }

    if ( SUCCEEDED( hr ) && 
        ( sysmonLogFiles == pOptions->iDataSourceType 
            || sysmonSqlLog == pOptions->iDataSourceType ) ) 
    {
        hr = LLTimeToPropertyBag ( pIPropBag, CGlobalString::m_cszLogViewStart, m_DataSourceInfo.llStartDisp );

        if ( SUCCEEDED( hr ) ){
            hr = LLTimeToPropertyBag ( pIPropBag, CGlobalString::m_cszLogViewStop, m_DataSourceInfo.llStopDisp );
        }
    }

    // SQL data source

    if (SUCCEEDED(hr)) {
        hr = StringToPropertyBag(pIPropBag,
                                 CGlobalString::m_cszSqlDsnName,
                                 m_DataSourceInfo.szSqlDsnName);
    }

    if (SUCCEEDED(hr)) {
        hr = StringToPropertyBag(pIPropBag,
                                 CGlobalString::m_cszSqlLogSetName,
                                 m_DataSourceInfo.szSqlLogSetName);
    }

    // Log files

    if ( SUCCEEDED( hr ) ){
        iLogFileIndex = 0;
        for (pLogFile = FirstLogFile();  NULL != pLogFile; pLogFile = pLogFile->Next() ) {
            StringCchPrintf ( szLogFileName, 
                               16,
                               CGlobalString::m_cszLogNameFormat, 
                               CGlobalString::m_cszLogFileName, 
                               ++iLogFileIndex );
            hr = StringToPropertyBag ( pIPropBag, szLogFileName, pLogFile->GetPath() );
        }
        if ( SUCCEEDED( hr ) ){
            hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszLogFileCount, iLogFileIndex );
        }
    }

    // Font info

    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszAmbientFont, pOptions->bAmbientFont );

        if ( FAILED( hr ) || !pOptions->bAmbientFont ){
            hr = m_OleFont.SaveToPropertyBag ( pIPropBag, TRUE, fSaveAllProps );
        }
    }

    // Legend

    if ( SUCCEEDED( hr ) ){
        hr = m_pLegend->SaveToPropertyBag ( pIPropBag, TRUE, fSaveAllProps );
    }

    // Save counter count and sample data

    LockCounterData();

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszCounterCount, CounterTree()->NumCounters() );
    }

    if ( SUCCEEDED(hr) ) {
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszMaximumSamples, m_pHistCtrl->nMaxSamples );
    }

    if ( SUCCEEDED(hr) ) {
        INT iSampleCount;

        if ( !m_fUserMode ) {
            iSampleCount = 0;
#if !_LOG_INCLUDE_DATA
        } else if ( m_bLogFileSource ) {
            iSampleCount = 0;
#endif 
        } else {
            iSampleCount = m_pHistCtrl->nSamples;
        }  

        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszSampleCount, iSampleCount );

        if ( SUCCEEDED(hr) && ( 0 < iSampleCount )) {
#if _LOG_INCLUDE_DATA
            INT iTemp;
            iTemp = ( 0 < m_pHistCtrl->iCurrent ?  m_pHistCtrl->iCurrent : 1 );
            hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszSampleIndex, iTemp );            
            if ( SUCCEEDED(hr) ) {
                iTemp = ( 0 < m_pObj->m_Graph.TimeStepper.StepNum() ?  m_pObj->m_Graph.TimeStepper.StepNum() : 1 );
                hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszStepNumber, iTemp );
            }
#else
            hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszSampleIndex, m_pHistCtrl->iCurrent );            
            if ( SUCCEEDED(hr) ) {
                hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszStepNumber, m_pObj->m_Graph.TimeStepper.StepNum() );
            }
#endif 
        }
    }

    for ( pMachine = CounterTree()->FirstMachine();
          pMachine;
          pMachine = pMachine->Next()) {

      for ( pObject = pMachine->FirstObject();
            pObject;
            pObject = pObject->Next()) {

            for ( pInstance = pObject->FirstInstance();
                  pInstance;
                  pInstance = pInstance->Next()) {

                for ( pItem = pInstance->FirstItem();
                      pItem;
                      pItem = pItem->m_pNextItem) {

                    // Save all counters explicitly, even if wildcard
                    iCounterIndex++;
                    hr = pItem->SaveToPropertyBag (
                                    pIPropBag, 
                                    iCounterIndex,
                                    m_fUserMode,
                                    SMONCTRL_MAJ_VERSION, 
                                    SMONCTRL_MIN_VERSION);
                    if (FAILED(hr))
                        return hr;

                }
            }
        }
    }
    
    assert ( iCounterIndex == CounterTree()->NumCounters() );

    // Selection
    if ( NULL != m_pSelectedItem ) {
        VARIANT vValue;
        DWORD   dwBufSize;
        LPWSTR  pNewBuf;

        VariantInit( &vValue );
        vValue.vt = VT_BSTR;
        // get this counter path
        hr = m_pSelectedItem->get_Path( &vValue.bstrVal );
        
        if( SUCCEEDED(hr) ){

            pszPath = vValue.bstrVal;

            //
            // Initialize the locale path buffer
            //
            if (dwEnglishBufSize == 0) {
                dwEnglishBufSize = PDH_MAX_COUNTER_PATH + 1;
                szEnglishBuf = (LPWSTR) malloc(dwEnglishBufSize * sizeof(WCHAR));
                if (szEnglishBuf == NULL) {
                    dwEnglishBufSize = 0;
                }
            }

            if (szEnglishBuf != NULL) {
                //
                // Translate counter name from Localization into English
                //
                dwBufSize = dwEnglishBufSize;

                pdhStatus = PdhTranslate009Counter(
                                vValue.bstrVal,
                                szEnglishBuf,
                                &dwBufSize);

                if (pdhStatus == PDH_MORE_DATA) {
                    pNewBuf = (LPWSTR)realloc(szEnglishBuf, dwBufSize * sizeof(WCHAR));

                    if (pNewBuf != NULL) {
                        szEnglishBuf = pNewBuf;
                        dwEnglishBufSize = dwBufSize;
    
                        pdhStatus = PdhTranslate009Counter(
                                            vValue.bstrVal,
                                            szEnglishBuf,
                                            &dwBufSize);
                    }
                }

                if (pdhStatus == ERROR_SUCCESS) {
                    pszPath = szEnglishBuf;
                }
            }

            if( SUCCEEDED(hr) ) {
                VariantClear( &vValue );
                vValue.bstrVal = SysAllocString( pszPath );
                if( vValue.bstrVal != NULL ){
                    vValue.vt = VT_BSTR;
                }
            }else{
                //translation failed, write current value
                hr = ERROR_SUCCESS;
            }
        }

        
        if ( SUCCEEDED ( hr ) ) {
            hr = pIPropBag->Write(CGlobalString::m_cszSelected, &vValue );    
            VariantClear ( &vValue );
        }
    }

    if (szEnglishBuf != NULL) {
        free(szEnglishBuf);
    }

    UnlockCounterData();
    return hr;
}

DWORD 
CSysmonControl::InitializeQuery (
    void )
{
    DWORD dwStat = ERROR_SUCCESS;
    PCGraphItem pItem;

    // Query must be opened before this method is called.
    if ( NULL != m_hQuery ) {
        m_pHistCtrl->nMaxSamples = MAX_GRAPH_SAMPLES;
        m_pHistCtrl->iCurrent = 0;
        m_pHistCtrl->nSamples = 0;
        m_pHistCtrl->nBacklog = 0;
        m_pObj->m_Graph.TimeStepper.Reset();
        m_pObj->m_Graph.LogViewStartStepper.Reset();
        m_pObj->m_Graph.LogViewStopStepper.Reset();
        m_pHistCtrl->bLogSource = m_bLogFileSource;
    
    } else { 
        dwStat = PDH_INVALID_HANDLE;
    }

    if ( ERROR_SUCCESS == dwStat ) {
        // Add counters to the query, to initialize scale factors
        if ((pItem = FirstCounter()) != NULL) {
            while (pItem != NULL) {
                pItem->AddToQuery(m_hQuery);
                pItem = pItem->Next();
            }
        }
    }

    return dwStat;
}

DWORD 
CSysmonControl::ActivateQuery (
    void )
{
    DWORD dwStat = ERROR_SUCCESS;
    DWORD   dwThreadID;

    // if real-time source
    if (!IsLogSource() 
        && m_fInitialized
        && IsUserMode() ) {

        if ( NULL == m_CollectInfo.hEvent ) {
            // Create a collection event
            if ((m_CollectInfo.hEvent = CreateEvent(NULL, FALSE, 0, NULL)) == NULL) {
                dwStat = GetLastError();
            } else 
            // Create the collection thread
            if ( ( m_CollectInfo.hThread 
                    = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)CollectProc, this, 0, &dwThreadID)) == NULL) {
                dwStat = GetLastError();
            }
            if ( ERROR_SUCCESS == dwStat ) {
                SetThreadPriority ( m_CollectInfo.hThread, THREAD_PRIORITY_TIME_CRITICAL );
            }
        }
        if ( ERROR_SUCCESS == dwStat ) {
            // Start the data collection
            if ( FirstCounter() != NULL) {
                SetIntervalTimer();
            }
        }
    }

    if ( ERROR_SUCCESS != dwStat ) {
        // If failure, close query to clean up then exit
        CloseQuery();
    }

    return dwStat;
}
void 
CSysmonControl::CloseQuery (
    void )
{
    PCGraphItem pItem;

    // Terminate the collection thread
    if ( NULL != m_CollectInfo.hThread ) {
        m_CollectInfo.iMode = COLLECT_QUIT;
        SetEvent(m_CollectInfo.hEvent);

        WaitForSingleObject(m_CollectInfo.hThread, INFINITE);
        CloseHandle(m_CollectInfo.hThread);
        m_CollectInfo.hThread = NULL;
    }

    // Release the collection event
    if ( NULL != m_CollectInfo.hEvent ) {
        CloseHandle(m_CollectInfo.hEvent);
        m_CollectInfo.hEvent = NULL;
    }

    LockCounterData();

    // Remove counters from the query
    pItem = FirstCounter();
    while ( NULL != pItem ) {
        pItem->RemoveFromQuery();
        pItem = pItem->Next();
    }

    UnlockCounterData();

    // Delete the query
    if ( NULL != m_hQuery ) {
        PdhCloseQuery ( m_hQuery );
        if (   (m_DataSourceInfo.hDataSource != H_REALTIME_DATASOURCE)
                && (m_DataSourceInfo.hDataSource != H_WBEM_DATASOURCE)) {
            PdhCloseLog(m_DataSourceInfo.hDataSource, 0);
            m_DataSourceInfo.hDataSource = H_REALTIME_DATASOURCE;
        }
        m_hQuery = NULL;
    }
}


 void CSysmonControl::SizeComponents ( HDC hDC )
/*
   Effect:        Move and show the various components of the graph to
                  fill the size (xWidth x yHeight). Take into account
                  whether the user wants to show the legend or status
                  bars. Also take into account if we have room for these
                  items.

   Internals:     If the user doesn't want the status or legend windows,
                  they aren't shown. Also, if the user wanted the status
                  window but not the legend window, the status window is
                  not shown.

                  We may disregard the user's desire for the legend or
                  status bar if there is not room. In particular, a legend
                  window has a minimum width (LegendMinWidth ()) and a
                  minimum height (LegendMinHeight ()). These values are
                  fixed for a given session of perfmon. It also has a 
                  preferred height, which takes into consideration the 
                  size of the graph window and the number of items in
                  the legend. This value is returned by LegendHeight().
      
                  We don't show the legend if its minimum height would
                  take up more than half the graph height.

                  If we feel we don't have room for the legend, we don't
                  show the status window either.

   See Also:      LegendMinWidth, LegendMinHeight, LegendHeight, 
                  ValuebarHeight.

   Called By:     OnSize, any other function that may remove or add one
                  of the graph components.
*/
{
   RECT rectClient;
   RECT rectComponent;
   RECT rectToolbar;
   INT  xWidth;
   INT  yHeight;

   INT  yGraphHeight = 0;
   INT  ySnapHeight = 0;
   INT  yStatsHeight = 0;
   INT  yLegendHeight = 0;
   INT  yToolbarHeight = 0;

#define CTRL_BORDER 10

    // If not inited, there's noting to size
    if (!m_fViewInitialized)
        return;

    // Get dimensions of window
    //  GetClientRect (m_hWnd, &rectClient) ;

    // *** - Use extent.  It is the 'natural' size of the control.
    // This draws the control correctly when zoom = 100%
    // It also makes print size correct at all zoom levels.
    
    
    SetCurrentClientRect ( GetNewClientRect() );
    
    rectClient = *GetCurrentClientRect();

    switch (m_pObj->m_Graph.Options.iDisplayType) {

    case REPORT_GRAPH:

        // Toolbar 
        // Toolbar not available through IViewObect, so leave it out.
        if (m_pObj->m_Graph.Options.bToolbarChecked
            && m_fViewInitialized ) {
            rectToolbar = rectClient;            
            // Determine height of toolbar after sizing it, to handle Wrap.
            m_pToolbar->SizeComponents(&rectToolbar);
            yToolbarHeight = m_pToolbar->Height(); 
        } else {
            memset (&rectToolbar, 0, sizeof(RECT));
            yToolbarHeight = 0;
        }

        if (yToolbarHeight > 0) {
            rectClient.top += yToolbarHeight;
            rectToolbar.bottom = rectToolbar.top + yToolbarHeight;
        }

        // Give report the entire client area except for toolbar
        m_pReport->SizeComponents(&rectClient);

        // Hide the other view components
        SetRect(&rectClient,0,0,0,0);
        m_pGraphDisp->SizeComponents(hDC, &rectClient);
        m_pSnapBar->SizeComponents(&rectClient);
        m_pStatsBar->SizeComponents(&rectClient);
        m_pLegend->SizeComponents(&rectClient);
        break;

    case LINE_GRAPH:
    case BAR_GRAPH:
    
        // Subtract border area
        rectComponent = rectClient;
        InflateRect(&rectComponent, -CTRL_BORDER, -CTRL_BORDER);

        xWidth = rectComponent.right - rectComponent.left ;
        yHeight = rectComponent.bottom - rectComponent.top ;

        // if the window has no area, forget it
        if (xWidth == 0 || yHeight == 0)
            return ;

        // Reserve top fourth of window for graph
        yGraphHeight = yHeight / 4;
        yHeight -= yGraphHeight;

        // Allocate space to each enabled component
        // Toolbar 
        if (m_pObj->m_Graph.Options.bToolbarChecked
            && m_fViewInitialized ) {
            rectToolbar = rectComponent;            
            m_pToolbar->SizeComponents(&rectToolbar);
            yToolbarHeight = m_pToolbar->Height();
        } else {
            memset (&rectToolbar, 0, sizeof(RECT));
            yToolbarHeight = 0;
        }

        if (yToolbarHeight > 0) {
            yHeight -= yToolbarHeight;
            rectToolbar.bottom = rectToolbar.top + yToolbarHeight;
            rectComponent.top += yToolbarHeight;
        }

        // Legend (Start with minimum size)
        if (m_pObj->m_Graph.Options.bLegendChecked) {
            yLegendHeight = m_pLegend->MinHeight(yHeight - CTRL_BORDER);
            if (yLegendHeight > 0)          
                yHeight -= yLegendHeight + CTRL_BORDER;
        }

        // Statistics bar
        if (m_pObj->m_Graph.Options.bValueBarChecked) {
            yStatsHeight = m_pStatsBar->Height(yHeight - CTRL_BORDER, xWidth);
            if (yStatsHeight > 0)
                yHeight -= yStatsHeight + CTRL_BORDER;
        }

        // Snap bar 
        // only if tool bar is not displayed
        if ((m_pObj->m_Graph.Options.bManualUpdate) && 
            (!m_pObj->m_Graph.Options.bToolbarChecked)) {
            ySnapHeight = m_pSnapBar->Height(yHeight - CTRL_BORDER);
            if (ySnapHeight > 0)
                yHeight -= ySnapHeight + CTRL_BORDER;
        }

        // If legend is visible give it a chance to use remaining space
        // Rest goes to graph
        if (yLegendHeight != 0) {
            yHeight += yLegendHeight;
            yLegendHeight = m_pLegend->Height(yHeight);
            yGraphHeight += yHeight - yLegendHeight;
            }
        else
            yGraphHeight += yHeight;

        // Assign rectangle to each component
        // Toolbar assigned earlier, to handle wrap.
        
        // Graph display
        rectComponent.bottom = rectComponent.top + yGraphHeight;
        m_pGraphDisp->SizeComponents(hDC, &rectComponent);
        rectComponent.top += yGraphHeight + CTRL_BORDER;

        // Snap bar
        rectComponent.bottom = rectComponent.top + ySnapHeight;
        m_pSnapBar->SizeComponents(&rectComponent);
        if (ySnapHeight != 0)
            rectComponent.top += ySnapHeight + CTRL_BORDER;

        // Statistics bar 
        rectComponent.bottom = rectComponent.top + yStatsHeight;
        m_pStatsBar->SizeComponents(&rectComponent);
        if (yStatsHeight != 0)
            rectComponent.top += yStatsHeight + CTRL_BORDER;

        // Legend window
        rectComponent.bottom = rectComponent.top + yLegendHeight;
        m_pLegend->SizeComponents(&rectComponent);
        rectComponent.top += yLegendHeight;

        // Force redraw of window
        // Optimize:  SizeComponents only called within Paint or Render,
        // so remove this extra window invalidation.        
        WindowInvalidate(m_hWnd);

        // Hide report window
        SetRect(&rectClient,0,0,0,0);
        m_pReport->SizeComponents(&rectComponent);

        break;
    }  
}

void CSysmonControl::put_Highlight(BOOL bState)
{
    // If no change, just return
    if ( m_pObj->m_Graph.Options.bHighlight == bState )
        return;

    m_pObj->m_Graph.Options.bHighlight = bState;

    // if no selected item, state doesn't matter
    if (m_pSelectedItem == NULL)
        return;

    // Update graph display's highlighted item 
    if ( m_pObj->m_Graph.Options.bHighlight )
        m_pGraphDisp->HiliteItem(m_pSelectedItem);
    else
        m_pGraphDisp->HiliteItem(NULL);

    // Cause redraw
    UpdateGraph(UPDGRPH_PLOT);
}


void 
CSysmonControl::put_ManualUpdate(BOOL bManual)
{
    m_pObj->m_Graph.Options.bManualUpdate = bManual;

    if ( m_bSampleDataLoaded ) {
        UpdateCounterValues(FALSE);
    } else {    
        SetIntervalTimer();
        UpdateGraph(UPDGRPH_LAYOUT);
    }
}

VOID CSysmonControl::AssignFocus (
    VOID
    )
{
    if (m_pObj->m_Graph.Options.iDisplayType == REPORT_GRAPH)
        SetFocus(m_pReport->Window());
    else
        SetFocus(m_pLegend->Window());
}


HRESULT CSysmonControl::TranslateAccelerators( LPMSG pMsg )
{
    INT iStat;

    if (m_hWnd == NULL || m_hAccel == NULL)
        return S_FALSE;

    // If this is a cursor key down event, process it here, or the container may grab it first 
    // I need to be sure that it reaches the legend listbox 
    if (pMsg->message == WM_KEYDOWN && 
        ( pMsg->wParam == VK_UP || pMsg->wParam == VK_DOWN || 
          pMsg->wParam == VK_HOME || pMsg->wParam == VK_END ) ) {
        ::TranslateMessage(pMsg);
        ::DispatchMessage(pMsg);
        return S_OK;
    }

    iStat = ::TranslateAccelerator(m_hWnd, m_hAccel, pMsg);
    return iStat ? S_OK : S_FALSE;
}
        
//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//

BOOL 
CSysmonControl::DisplayHelp ( HWND hwndSelf )
{
    WCHAR pszHelpFilePath[2*MAX_PATH + 1];
    UINT  nLen;

    if ( NULL != hwndSelf ) {
        nLen = ::GetWindowsDirectory(pszHelpFilePath, 2*MAX_PATH + 1);
        if ( nLen == 0 ) {
            // Report error.
            return FALSE;
        }

        StringCchCat(pszHelpFilePath, 2*MAX_PATH + 1, L"\\help\\sysmon.chm");

        HtmlHelp ( hwndSelf, pszHelpFilePath, HH_DISPLAY_TOPIC, 0 );
    }    
    return TRUE;
}


LRESULT APIENTRY SysmonCtrlWndProc (HWND hWnd,
                               UINT uiMsg,
                               WPARAM wParam,
                               LPARAM lParam)
{
    RECT        rect;
    PSYSMONCTRL pCtrl = (PSYSMONCTRL)GetWindowLongPtr(hWnd ,0);
    INT         iUpdate;

    switch (uiMsg) {

        case WM_NOTIFY:
            {
                NMHDR           *pnmHdr;
                NMTTDISPINFO    *pnmInfo;
                LONG_PTR        lStrId;
                pnmHdr = (NMHDR *)lParam;

                switch (pnmHdr->code) {
                    case TTN_NEEDTEXT:
                        pnmInfo = (NMTTDISPINFO *)lParam;
                        // cast ID as a string for this arg
                        lStrId = (LONG_PTR)(wParam - IDM_TOOLBAR);
                        lStrId += IDS_TB_BASE;
                        pnmInfo->lpszText = (LPWSTR)lStrId;
                        pnmInfo->hinst = g_hInstance;
                        break;
                    default:
                        return DefWindowProc (hWnd, uiMsg, wParam, lParam);
                }
            }
            break;

        case WM_CREATE:
            pCtrl = (PSYSMONCTRL)((CREATESTRUCT*)lParam)->lpCreateParams;
            SetWindowLongPtr(hWnd,0,(INT_PTR)pCtrl);
            break;

        case WM_DESTROY:
            pCtrl->m_hWnd = NULL;
            break;

        case WM_CONTEXTMENU:     
        case WM_LBUTTONDOWN:
        case WM_LBUTTONDBLCLK:

            //We become UI Active with mouse action
            if (!pCtrl->m_fUIDead) { 
                 pCtrl->m_pObj->UIActivate();

                pCtrl->AssignFocus();

                if (uiMsg == WM_CONTEXTMENU) {
                    if (LOWORD(lParam)!= 0xffff || HIWORD(lParam) != 0xffff){
                        pCtrl->DisplayContextMenu(LOWORD(lParam), HIWORD(lParam));
                    }else{
                        pCtrl->DisplayContextMenu(0,0);
                    }
                } else if (uiMsg == WM_LBUTTONDBLCLK) {
                    pCtrl->OnDblClick(LOWORD(lParam), HIWORD(lParam));
                }
            }
            break;

        case WM_COMMAND:

            if (pCtrl->m_fUIDead)
                break;

            switch (LOWORD(wParam)) {

                case IDM_TB_PROPERTIES:
                    pCtrl->DisplayProperties();
                    break;

                case IDM_PROPERTIES:
                    pCtrl->DisplayProperties ( DISPID_VALUE );
                    break;

                case IDM_TB_ADD:
                case IDM_ADDCOUNTERS:
                    pCtrl->AddCounters();
                    break;

                case IDM_TB_DELETE:
                case IDM_DELETE:
                    {
                        CWaitCursor cursorWait;
                        if (pCtrl->m_pObj->m_Graph.Options.iDisplayType == REPORT_GRAPH) {
                            pCtrl->m_pReport->DeleteSelection();
                        } else {
                            if ( SUCCEEDED(pCtrl->DeleteCounter ( pCtrl->m_pSelectedItem, TRUE )) ) {
                                pCtrl->UpdateGraph(UPDGRPH_DELCNTR);
                            }
                        }
                    }
                    break;

                case IDM_TB_REALTIME:
                    if ( sysmonCurrentActivity != pCtrl->m_pObj->m_Graph.Options.iDataSourceType ) {
                        CWaitCursor cursorWait;
                        pCtrl->put_DataSourceType ( sysmonCurrentActivity );
                        pCtrl->Clear();
                    } else {
                        // Nothing changed, so resync the toolbar to 
                        // handle state of realtime button.
                        pCtrl->m_pToolbar->SyncToolbar();
                    }
                    break;
                case IDM_TB_LOGFILE:
                    {
                        pCtrl->DisplayProperties( DISPID_SYSMON_DATASOURCETYPE );
                        // Resync the toolbar in case the log file is invalid.
                        pCtrl->m_pToolbar->SyncToolbar();
                    }
                    break;

                case IDM_SAVEAS:
                    pCtrl->SaveAs();
                    break;

                case IDM_SAVEDATA:
                    pCtrl->SaveData();
                    break;

                case IDC_SNAPBTN:
                case IDM_TB_UPDATE:
                case IDM_UPDATE:
                    {
                        CWaitCursor cursorWait;
                        pCtrl->UpdateCounterValues(TRUE);
                    }
                    break;

                case IDM_TB_CLEAR:
                    {
                        CWaitCursor cursorWait;
                        pCtrl->Clear();
                    }
                    break;

                case IDM_TB_FREEZE:
                    // Confirm the data overwrite before changing the state of the freeze button.
                    if ( pCtrl->ConfirmSampleDataOverwrite() ) {
                        pCtrl->put_ManualUpdate ( !pCtrl->m_pObj->m_Graph.Options.bManualUpdate );
                    } else {
                        // Nothing changed, so resync the toolbar to 
                        // handle state of the freeze button.
                        pCtrl->m_pToolbar->SyncToolbar();
                    }
                    break;

                case IDM_TB_HIGHLIGHT:
                case IDM_HIGHLITE:
                    pCtrl->put_Highlight(!pCtrl->m_pObj->m_Graph.Options.bHighlight );
                    break;

                case ID_HATCHWINDOW:
                    if (HIWORD(wParam) == HWN_RESIZEREQUESTED)
                        pCtrl->m_pObj->m_pIOleIPSite->OnPosRectChange((LPRECT)lParam);
                    break;

                case IDM_TB_CHART:
                    if (pCtrl->m_pObj->m_Graph.Options.iDisplayType != sysmonLineGraph) {
                        CWaitCursor cursorWait;
                        if (pCtrl->m_pObj->m_Graph.Options.iDisplayType == REPORT_GRAPH)
                            iUpdate = UPDGRPH_VIEW;
                        else
                            iUpdate = UPDGRPH_PLOT;
                        pCtrl->m_pObj->m_Graph.Options.iDisplayType = LINE_GRAPH;
                        InvalidateRect(pCtrl->m_hWnd, NULL, TRUE);
                        pCtrl->UpdateGraph(iUpdate);
                    }
                    break;
                
                case IDM_TB_HISTOGRAM:
                    if (pCtrl->m_pObj->m_Graph.Options.iDisplayType != sysmonHistogram) {
                        CWaitCursor cursorWait;
                        if (pCtrl->m_pObj->m_Graph.Options.iDisplayType == REPORT_GRAPH)
                            iUpdate = UPDGRPH_VIEW;
                        else
                            iUpdate = UPDGRPH_PLOT;
                        pCtrl->m_pObj->m_Graph.Options.iDisplayType = BAR_GRAPH;
                        InvalidateRect(pCtrl->m_hWnd, NULL, TRUE);
                        pCtrl->UpdateGraph(iUpdate);
                    }
                    break;
                
                case IDM_TB_REPORT:
                    if (pCtrl->m_pObj->m_Graph.Options.iDisplayType != sysmonReport) {
                        CWaitCursor cursorWait;
                        pCtrl->m_pObj->m_Graph.Options.iDisplayType = REPORT_GRAPH;
                        InvalidateRect(pCtrl->m_hWnd, NULL, TRUE);
                        pCtrl->UpdateGraph(UPDGRPH_VIEW);
                    }
                    break;
                
                case IDM_TB_PASTE:
                    {
                        HRESULT hr = S_OK;
                        {
                            CWaitCursor cursorWait;
                            hr = pCtrl->Paste();
                        }
                        if ( SMON_STATUS_NO_SYSMON_OBJECT == (DWORD)hr ) {
                            MessageBox(
                                pCtrl->m_hWnd, 
                                ResourceString(IDS_NOSYSMONOBJECT_ERR ), 
                                ResourceString(IDS_APP_NAME),
                                MB_OK | MB_ICONERROR);
                        }
                    }
                    break;

                case IDM_TB_COPY:
                    {
                        CWaitCursor cursorWait;
                        pCtrl->Copy();
                    }
                    break;

                case IDM_TB_NEW:
                    {
                        CWaitCursor cursorWait;
                        pCtrl->Reset();
                    }
                    break;

                case IDM_TB_HELP:
                {
                    return pCtrl->DisplayHelp ( hWnd );
                }      

                default:
                    return DefWindowProc (hWnd, uiMsg, wParam, lParam);
            }
            break;
        
        case WM_DROPFILES:
            {
                CWaitCursor cursorWait;
                pCtrl->OnDropFile (wParam) ;
            }
            return (0) ;

        case WM_ERASEBKGND:
            GetClientRect(hWnd, &rect);
            Fill((HDC)wParam, pCtrl->clrBackCtl(), &rect);
            return TRUE; 

        case WM_SYSCOLORCHANGE:
            pCtrl->UpdateNonAmbientSysColors();

        case WM_PAINT:
            pCtrl->Paint();
            break ;

        case WM_SIZE:
            if (pCtrl != NULL) {
                // Avoid extra cases of (SetDirty()) if size has not changed.
                if ( !EqualRect ( pCtrl->GetCurrentClientRect(), pCtrl->GetNewClientRect() ) ) {
                    pCtrl->UpdateGraph(UPDGRPH_LAYOUT);
                }
            }
            break ;

        case WM_TIMER:
            pCtrl->UpdateCounterValues(FALSE);
            break;
    
        case WM_SETFOCUS:
            pCtrl->AssignFocus();
            break;

        case WM_VALUES_UPDATED:
            pCtrl->OnValuesUpdated();
            break;
        
        case WM_GRAPH_UPDATE:
            pCtrl->UpdateGraphData();
            break;
        
        case WM_HELP:
            {
                return pCtrl->DisplayHelp ( hWnd );
            }      

        default:
            return  DefWindowProc (hWnd, uiMsg, wParam, lParam) ;
    }

    return (0);
}


HWND CSysmonControl::Window( VOID )
{
    return m_hWnd;
}


void CSysmonControl::UpdateGraph( INT nUpdateType )
{
    RECT  rectStats;
    RECT  rectGraph;
    PRECT prectUpdate = NULL;
    RECT rectClient;

    // Based on type of change either force redraw or resize components
    switch (nUpdateType) {

    case UPDGRPH_ADDCNTR:
    case UPDGRPH_DELCNTR:
        if ( m_bLogFileSource )
            m_fPendingLogCntrChg = TRUE;

        m_fPendingSizeChg = TRUE;
        break;

    case UPDGRPH_FONT:
        m_fPendingFontChg = TRUE;
        break;

    case UPDGRPH_LOGVIEW:
        m_fPendingLogViewChg = TRUE;
        if (m_hWnd && m_pStatsBar ) {
            m_pStatsBar->GetUpdateRect(&rectStats);
            prectUpdate = &rectStats;
        }
        // Fall into plot area case

    case UPDGRPH_PLOT:

        if ( REPORT_GRAPH != m_pObj->m_Graph.Options.iDisplayType ) {
            if (m_hWnd && m_pGraphDisp) {
                m_pGraphDisp->GetPlotRect(&rectGraph);
                if ( NULL == prectUpdate ) {
                    prectUpdate = &rectGraph;
                } else {
                    ::UnionRect( prectUpdate, &rectStats, &rectGraph);
                }
            }
        } else {
            GetClientRect (m_hWnd, &rectClient);
            prectUpdate = &rectClient;
        }
        break;
            
    case UPDGRPH_COLOR:
        //update the toolbar color
        m_pToolbar->SetBackgroundColor ( clrBackCtl() );
        m_fPendingSizeChg = TRUE;
        break;

    case UPDGRPH_LAYOUT:
    case UPDGRPH_VIEW:
        m_fPendingSizeChg = TRUE;
        break;
    }

    // Set change pending flag to enable ApplyChanges
    m_fPendingUpdate = TRUE;

    // If we're ready to do updates
    if (m_fViewInitialized) {

        // Invalidate window to force redraw
        InvalidateRect(m_hWnd, prectUpdate, TRUE);

        // Notify container of change
        m_pObj->SendAdvise(OBJECTCODE_DATACHANGED);
    }
}

void 
CSysmonControl::OnValuesUpdated ( VOID )
{
    // If event sync present, send notification from the 
    // main thread, outside of lock.
    m_pObj->SendEvent(eEventOnSampleCollected, 0);
}
    
void 
CSysmonControl::UpdateGraphData( VOID )
{
    HDC hDC = NULL;
    PGRAPHDATA  pGraph = &m_pObj->m_Graph;

    OnValuesUpdated();

    if (m_fViewInitialized) {

        UpdateAppPerfTimeData (TD_UPDATE_TIME, TD_BEGIN);

        hDC = GetDC(m_hWnd);

        // Update statistics if active
        // Statistics are updated before the graph display in case the
        // graph display selects a clipping region.  
        if (pGraph->Options.bValueBarChecked &&m_pSelectedItem != NULL) {
            // The stats bar doesn't always use the hDC, so passing NULL
            // hDC is okay.
            m_pStatsBar->Update(hDC, m_pSelectedItem);
        }

        if ( NULL != hDC ) {

            // Update graph display
            m_pGraphDisp->Update(hDC);

            m_pReport->Update();

            ReleaseDC(m_hWnd, hDC);
        }

        UpdateAppPerfTimeData (TD_UPDATE_TIME, TD_END);
    }   
}


void CSysmonControl::Render( 
    HDC hDC, 
    HDC hAttribDC,
    BOOL fMetafile, 
    BOOL fEntire, 
    LPRECT pRect )
{
    HDC hLocalAttribDC = NULL;
    
    // If not inited, return.
    if ( m_fViewInitialized ) {

        if ( NULL == hAttribDC ) {
            hLocalAttribDC = GetDC(m_hWnd);
        } else {
            hLocalAttribDC = hAttribDC;
        }

        // Make sure layout is up to date.

        ApplyChanges( hLocalAttribDC );

        if ( NULL != hDC && NULL != hLocalAttribDC ) {

            if ( REPORT_GRAPH == m_pObj->m_Graph.Options.iDisplayType ) {
                m_pReport->Render( hDC, hLocalAttribDC, fMetafile, fEntire, pRect );
            } else {

                // Fill with background color
                SetBkColor(hDC, clrBackCtl());
                ClearRect(hDC, pRect);

                m_pStatsBar->Draw(hDC, hLocalAttribDC, pRect);
                m_pGraphDisp->Draw(hDC, hLocalAttribDC, fMetafile, fEntire, pRect );
                m_pLegend->Render(hDC, hLocalAttribDC, fMetafile, fEntire, pRect);
            }
    
            if ( eBorderSingle == m_iBorderStyle ) {
                if ( eAppear3D == m_iAppearance ) {
                    DrawEdge(hDC, pRect, EDGE_RAISED, BF_RECT);
                } else {
                    SelectBrush (hDC, GetStockObject (HOLLOW_BRUSH)) ;
                    SelectPen (hDC, GetStockObject (BLACK_PEN)) ;
                    Rectangle (hDC, pRect->left, pRect->top, pRect->right, pRect->bottom );
                }
            }
        }
        if ( NULL != hLocalAttribDC && hAttribDC != hLocalAttribDC ) {
            ReleaseDC ( m_hWnd, hLocalAttribDC );
        }
    }
}



void CSysmonControl::SetIntervalTimer()
{
    HDC         hDC = NULL;
    PGRAPHDATA  pGraph = &m_pObj->m_Graph;

    // if not initialized or counter source is a log file, nothing to do
    if (!m_fInitialized || IsLogSource() || !IsUserMode() )
        return;

    // Update statistics bar
    m_pStatsBar->SetTimeSpan(
                    m_pObj->m_Graph.Options.fUpdateInterval 
                    * m_pObj->m_Graph.Options.iDisplayFilter
                    * m_pHistCtrl->nMaxSamples );

    hDC = GetDC(m_hWnd);
    if ( NULL != hDC ) {
        m_pStatsBar->Update(hDC, m_pSelectedItem);
        ReleaseDC(m_hWnd,hDC);
    }

    // If conditions right for sampling, start new time interval.
    // Otherwise, suspend the collection.
    if (!pGraph->Options.bManualUpdate 
        && pGraph->Options.fUpdateInterval >= 0.001 // ??
        && pGraph->CounterTree.NumCounters() != 0
        && IsUserMode() ) {

        m_CollectInfo.dwInterval= (DWORD)(pGraph->Options.fUpdateInterval * 1000);
        m_CollectInfo.dwSampleTime = GetTickCount();
        m_CollectInfo.iMode = COLLECT_ACTIVE;
    }
    else {
        m_CollectInfo.iMode = COLLECT_SUSPEND;
    }

    assert ( NULL != m_CollectInfo.hEvent );
        
    // Signal the collection thread
    SetEvent(m_CollectInfo.hEvent);

    // If no counters, reset sample time to start 
    if (pGraph->CounterTree.NumCounters() == 0) {
        m_pHistCtrl->iCurrent = 0;
        m_pHistCtrl->nSamples = 0;
        pGraph->TimeStepper.Reset();
    }

}

HRESULT CSysmonControl::AddSingleCounter(LPWSTR pszPath, PCGraphItem *pGItem)
{
    PCGraphItem pGraphItem;
    PGRAPHDATA  pGraph = &m_pObj->m_Graph;
    HRESULT hr;
    BOOL    bAddSuccessful = FALSE;
    INT     iCounterIndex = 0;

    *pGItem = NULL;

    // Create graph item
    pGraphItem = new CGraphItem(this); 
    if (pGraphItem == NULL)
        return E_OUTOFMEMORY;

    LockCounterData();

    // Add it to the counter tree
    hr = pGraph->CounterTree.AddCounterItem(
            pszPath, 
            pGraphItem, 
            pGraph->Options.bMonitorDuplicateInstances);

    if (SUCCEEDED(hr)) {

        // AddRef once for ourself
        pGraphItem->AddRef();

        // Set default attributes
        pGraphItem->put_Color(IndexToStandardColor(m_iColorIndex));
        pGraphItem->put_Width(IndexToWidth(m_iWidthIndex));
        pGraphItem->put_LineStyle(IndexToStyle(m_iStyleIndex));
        pGraphItem->put_ScaleFactor(m_iScaleFactor);

        // Increment and reset for next counter
        IncrementVisuals();
        m_iScaleFactor = INT_MAX;

        // Add item to graph's query

        if ( NULL != m_hQuery ) {
            hr = pGraphItem->AddToQuery(m_hQuery);
        } else {
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr)) {

            hr = pGraph->CounterTree.IndexFromCounter( pGraphItem, &iCounterIndex );
            
            if ( SUCCEEDED ( hr ) ) {
                bAddSuccessful = TRUE;
                    
                // If control is initialized
                if (m_fViewInitialized) {

                    // Add item to chart legend
                    m_pLegend->AddItem(pGraphItem);
                    m_pReport->AddItem(pGraphItem);
                }
            }
            else {
                // remove the item from the tree 
                pGraphItem->Instance()->RemoveItem(pGraphItem);
            }
        } else {
            // remove the item from the tree 
            pGraphItem->Instance()->RemoveItem(pGraphItem);
        }

        // If OK, Addref the returned interface
        if (SUCCEEDED(hr)) {
            pGraphItem->AddRef();
            *pGItem = pGraphItem;
        } // else released by RemoveItem above.

        // Update messages seem to be combined, so histogram sometimes updates instead of
        // repainting each entire bar.  This forces total repaint.
        if ( m_pGraphDisp) {
            m_pGraphDisp->SetBarConfigChanged();
        }

    } else {
        // AddCounterItem failed
        delete pGraphItem;
    }

    UnlockCounterData();

    // Send events outside of locks.
    if ( bAddSuccessful ) {
        // If first counter
        if (pGraph->CounterTree.NumCounters() == 1) {

            // Make it the selected counter and send event.
            SelectCounter(pGraphItem);

            // Start data collection
            if ( ERROR_SUCCESS != ActivateQuery() ) {
                hr = E_FAIL;
            }
        }

        // Redraw the graph
        UpdateGraph(UPDGRPH_ADDCNTR);

        m_pObj->SendEvent(eEventOnCounterAdded, iCounterIndex );
    }
    return hr;
}


PCCounterTree 
CSysmonControl::CounterTree(
    VOID
    )
{
    return &(m_pObj->m_Graph.CounterTree);
}                                 


PCGraphItem 
CSysmonControl::FirstCounter(
    VOID
    )
{
    return m_pObj->m_Graph.CounterTree.FirstCounter();
}


PCGraphItem 
CSysmonControl::LastCounter(
    VOID
    )
{
    PCGraphItem pItem;
    PCGraphItem pItemNext;

    if (FirstCounter() == NULL)
        return NULL;

    // Locate last graph item
    pItem = FirstCounter();
    while ((pItemNext = pItem->Next()) != NULL)
        pItem = pItemNext;

    return pItem;
}

BOOL
CSysmonControl::IsLogSource(
    VOID
    )
{
    return m_pHistCtrl->bLogSource; 
}

BOOL
CSysmonControl::IsReadOnly(
    VOID
    )
{
    BOOL bReturn = TRUE;

    if (m_fInitialized ) {
        bReturn = m_pObj->m_Graph.Options.bReadOnly;
    }
    return bReturn; 
}

eReportValueTypeConstant
CSysmonControl::ReportValueType(
    VOID
    )
{    
    return ( (eReportValueTypeConstant) m_pObj->m_Graph.Options.iReportValueType );
}

INT CSysmonControl::CounterIndex(PCGraphItem pItem)
{
    PCGraphItem pItemLoc;
    INT iIndex;

    // Traverse linked list until item matched  
    pItemLoc = FirstCounter();
    iIndex = 1;
    while (pItemLoc != pItem && pItemLoc != NULL) {
        pItemLoc = pItemLoc->Next();
        iIndex++;
    }

    return (pItemLoc == NULL) ? -1 : iIndex;
} 


HRESULT CSysmonControl::DeleteCounter(PCGraphItem pItem, BOOL bPropagateUp)
{
    PGRAPHDATA  pGraph = &m_pObj->m_Graph;

    if (pItem == NULL)
        return E_INVALIDARG;

    // Send event
    m_pObj->SendEvent(eEventOnCounterDeleted, CounterIndex(pItem));

    LockCounterData();

    // If this is the selected counter, change selection to NULL
    if (pItem == m_pSelectedItem)
        m_pSelectedItem = NULL;

    if (m_fViewInitialized) {
        // Remove from legend and report
        m_pLegend->DeleteItem(pItem);
        m_pReport->DeleteItem(pItem);

        // Remove from query
        pItem->RemoveFromQuery();
    }

    // Proagate deletion up the tree if requested
    if (bPropagateUp) {
        pItem->Instance()->RemoveItem(pItem);
    }

    // If last counter, stop interval timer
    if (pGraph->CounterTree.NumCounters() == 0)
        SetIntervalTimer();

    // Update messages seem to be combined, so histogram sometimes updates instead of
    // repainting each entire bar.  This forces total repaint.
    if ( m_pGraphDisp) {
        m_pGraphDisp->SetBarConfigChanged();
    }

    UnlockCounterData();

    if ( m_fViewInitialized ) {
        UpdateGraph(UPDGRPH_DELCNTR);
    }

    return NOERROR;
}


void CSysmonControl::SelectCounter(PCGraphItem pItem)
{
    HDC hDC = NULL;
    INT iIndex;

    // Selection in the graph view is maintained independently
    // of the selection in the report view.
    if ( REPORT_GRAPH != m_pObj->m_Graph.Options.iDisplayType ) {
        // Save as current item
        m_pSelectedItem = pItem;

        if (m_fViewInitialized) {
            // Inform Legend
            m_pLegend->SelectItem(pItem);

            // Highlight selected item in graph display
            if (m_pObj->m_Graph.Options.bHighlight) {
                m_pGraphDisp->HiliteItem(pItem);
                UpdateGraph(UPDGRPH_PLOT);
            }

            // Update statistics bar
            if ( m_fViewInitialized )
                hDC = GetDC(m_hWnd);
            
            m_pStatsBar->Update(hDC, pItem);
            
            if ( NULL != hDC )
                ReleaseDC(m_hWnd,hDC);
        }
    }

    // Send event
    iIndex = (pItem == NULL) ? 0 : CounterIndex(pItem);
    m_pObj->SendEvent(eEventOnCounterSelected, iIndex);
}

HRESULT 
CSysmonControl::PasteFromBuffer( LPWSTR pszData, BOOL bAllData )
{
    HRESULT hr = NOERROR;
    CImpIPropertyBag IPropBag;

    hr = IPropBag.LoadData( pszData );

    if ( SUCCEEDED ( hr ) ) {
        INT   nLogType = SMON_CTRL_LOG;

        //get the log type from the  pPropBag and compare it with service(cookie) type
        //Determine log type from property bag. Default to -1  SMON_CTRL_LOG
                          
        hr = IntegerFromPropertyBag (
            &IPropBag,      
            NULL,
            CGlobalString::m_cszLogType,
            nLogType);

        if(nLogType == SLQ_TRACE_LOG){
            MessageBox(
                    m_hWnd,
                    ResourceString(IDS_TRACE_LOG_ERR_MSG),
                    ResourceString(IDS_APP_NAME),
                    MB_OK
                                );
        } else {
            if ( bAllData ) {            
                hr = LoadFromPropertyBag( &IPropBag, NULL );
            } else {
                // Do not load sample data for Paste or Drop File.
                hr = LoadCountersFromPropertyBag (&IPropBag, NULL, FALSE );
            }
        }
    }

    return hr;
}

HRESULT CSysmonControl::Paste()
{
    HRESULT hResReturn = NOERROR;
    HANDLE  hMemClipboard;

    // get the clipboard
    if (OpenClipboard (Window())) {
        // read the CF_TEXT or CF_UNICODE data from the clipboard to the local buffer
        hMemClipboard = GetClipboardData (
#if UNICODE
                    CF_UNICODETEXT);     // UNICODE text in the clipboard
#else
                    CF_TEXT);            // ANSI text in the clipboard
#endif
        if (hMemClipboard != NULL) {
            
            LPWSTR pszData;

            if ( ConfirmSampleDataOverwrite ( ) ) {
                pszData = (LPWSTR)GlobalLock (hMemClipboard);// (LPWSTR)hMemClipboard;

                if ( NULL != pszData ) {
                    hResReturn = PasteFromBuffer ( pszData, FALSE );
                    GlobalUnlock ( hMemClipboard );
                }
            }
        }
        // release the clipboard
        CloseClipboard();
    } else {
        // unable to open the clipboard
        hResReturn = HRESULT_FROM_WIN32(GetLastError());
    }

    return hResReturn;
}

HRESULT
CSysmonControl::CopyToBuffer ( LPWSTR& rpszData, DWORD& rdwBufferSize )
{
    HRESULT hr = S_OK;
    CImpIPropertyBag    IPropBag;

    assert ( NULL == rpszData );
    rdwBufferSize = 0;

    if (NULL!=m_pObj->m_pImpIPersistPropertyBag) {
        hr = m_pObj->m_pImpIPersistPropertyBag->Save (&IPropBag, FALSE, TRUE );
    }
   
    if ( SUCCEEDED ( hr ) ) {
        DWORD   dwBufferLength;
        LPWSTR  pszConfig;

        pszConfig = IPropBag.GetData();

        if ( NULL != pszConfig ) {
            //
            // Buffer length includes 1 for NULL terminator.
            //
            dwBufferLength = lstrlen ( CGlobalString::m_cszHtmlObjectHeader ) + lstrlen ( CGlobalString::m_cszHtmlObjectFooter ) + lstrlen ( pszConfig ) + 1;

            rpszData = new WCHAR[dwBufferLength];

            if ( NULL == rpszData ) {
                hr = E_OUTOFMEMORY; 
            } else {

                rdwBufferSize = dwBufferLength * sizeof(WCHAR);

                rpszData[0] = L'\0';

                StringCchCopy(rpszData, dwBufferLength, CGlobalString::m_cszHtmlObjectHeader );
                StringCchCat(rpszData, dwBufferLength, pszConfig );
                StringCchCat(rpszData, dwBufferLength, CGlobalString::m_cszHtmlObjectFooter );
            }
        } else {
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}

HRESULT CSysmonControl::Copy()
{
    HGLOBAL hBuffer = NULL;
    HRESULT hResReturn = S_OK;
    LPWSTR  pszBuffer = NULL;
    DWORD   dwBufferSize;
    HANDLE  hMemClipboard;
    LPWSTR  pszGlobalBuffer = NULL;

    hResReturn = CopyToBuffer( pszBuffer, dwBufferSize);

    if ( SUCCEEDED ( hResReturn ) && ( NULL != pszBuffer ) ) {
        
        hBuffer = GlobalAlloc ((GMEM_MOVEABLE | GMEM_DDESHARE), dwBufferSize);
        
        if ( NULL != hBuffer ) {
            pszGlobalBuffer = (LPWSTR)GlobalLock (hBuffer);
            if ( NULL != pszGlobalBuffer ) {
                StringCchCopy (pszGlobalBuffer, dwBufferSize,  pszBuffer );
                GlobalUnlock (hBuffer);
            } else {
                // allocation or lock failed so bail out
                hResReturn = E_OUTOFMEMORY;
            }
        }
    }

    if ( NULL != pszBuffer ) {
        delete [] pszBuffer;
    }

    if ( NULL != hBuffer && SUCCEEDED ( hResReturn ) ) {
        // then there's something to copy so...
        // get the clipboard
        if (OpenClipboard (m_hWnd)) {
            // copy the counter list to the clipboard
            if (EmptyClipboard()) {
                hMemClipboard = SetClipboardData (
#if UNICODE
                    CF_UNICODETEXT,     // UNICODE text in the clipboard
#else
                    CF_TEXT,            // ANSI text in the clipboard
#endif
                    hBuffer);
                if (hMemClipboard == NULL) {
                    // unable to set data in the clipboard
                    hResReturn = HRESULT_FROM_WIN32(GetLastError());
                }

            } else {
                // unable to empty the clipboard
                hResReturn = HRESULT_FROM_WIN32(GetLastError());
            }

            // release the clipboard
            CloseClipboard();
        } else {
            // unable to open the clipboard
            hResReturn = HRESULT_FROM_WIN32(GetLastError());
        }
    } 

    if ( NULL != hBuffer ) {
        GlobalFree ( hBuffer ) ;
    }

    return hResReturn;
}

HRESULT CSysmonControl::Reset()
{
    PCGraphItem pItem; 
 
    // Request each counter from the control, to compute 
    // required buffer size

    while ((pItem = FirstCounter())!= NULL) {
        // delete this counter 
        DeleteCounter (pItem, TRUE);
    }

    m_iColorIndex = 0;
    m_iWidthIndex = 0;
    m_iStyleIndex = 0;

    return NOERROR;
}

void CSysmonControl::DblClickCounter(PCGraphItem pItem)
{
    INT iIndex;

    // Send event
    iIndex = (pItem == NULL) ? 0 : CounterIndex(pItem);
    m_pObj->SendEvent(eEventOnDblClick, iIndex);

}

BOOL 
CSysmonControl::ConfirmSampleDataOverwrite ( )
{
    BOOL bOverwrite = TRUE;

    if ( m_bSampleDataLoaded ) {
        // Confirm overwrite of view-only data.
        INT iOverwrite = IDNO;
        assert ( FALSE == m_fInitialized );

        iOverwrite = MessageBox(
                            Window(), 
                            ResourceString(IDS_SAMPLE_DATA_OVERWRITE), 
                            ResourceString(IDS_APP_NAME),
                            MB_YESNO );

        if ( IDYES == iOverwrite ) {
            m_bSampleDataLoaded = FALSE;
            bOverwrite = Init ( g_hWndFoster );
            UpdateGraph(UPDGRPH_LAYOUT);        // If toolbar enabled, must resize
                                                // Also clears the graph
        } else {
            bOverwrite = FALSE;
        }
    }    
    return bOverwrite;
}

void 
CSysmonControl::Clear ( void )
{
    if ( ConfirmSampleDataOverwrite() ) {
        PCGraphItem  pItem;

        m_pHistCtrl->nMaxSamples = MAX_GRAPH_SAMPLES;
        m_pHistCtrl->iCurrent = 0;
        m_pHistCtrl->nSamples = 0;
        m_pHistCtrl->nBacklog = 0;
        m_pObj->m_Graph.TimeStepper.Reset();

        m_pStatsBar->Clear();

        // Reset history for all counters
        for (pItem = FirstCounter(); pItem != NULL; pItem = pItem->Next()) {
                pItem->ClearHistory();
        }

        // Repaint the graph and value bar
        UpdateGraph(UPDGRPH_VIEW);
    }
}

PDH_STATUS 
CSysmonControl::UpdateCounterValues ( BOOL fValidSample )
{
    PDH_STATUS  stat = ERROR_SUCCESS;
    PCGraphItem  pItem;
    PGRAPHDATA  pGraph = &m_pObj->m_Graph;

    // If no query or no counters assign, nothing to do
    if ( NULL == m_hQuery
            || pGraph->CounterTree.NumCounters() == 0
            || !IsUserMode() ) {
        stat = ERROR_SUCCESS;
    } else {
        if ( ConfirmSampleDataOverwrite () ) {
            // If valid sample, collect the data
            if (fValidSample) {
                UpdateAppPerfTimeData (TD_P_QUERY_TIME, TD_BEGIN);
                stat = PdhCollectQueryData(m_hQuery);
                UpdateAppPerfTimeData (TD_P_QUERY_TIME, TD_END);
            }

            if ( ERROR_SUCCESS == stat ) { 

                UpdateAppPerfTimeData (TD_S_QUERY_TIME, TD_BEGIN);
    
                LockCounterData();

                // Update history control and all counter history arrays
                m_pHistCtrl->iCurrent++;

                if (m_pHistCtrl->iCurrent == m_pHistCtrl->nMaxSamples)
                    m_pHistCtrl->iCurrent = 0;

                if (m_pHistCtrl->nSamples < m_pHistCtrl->nMaxSamples)
                    m_pHistCtrl->nSamples++;
      
                // Update history for all counters
                for (pItem = FirstCounter(); pItem != NULL; pItem = pItem->Next()) {
                        pItem->UpdateHistory(fValidSample);
                }

                // If we're initialized and have at least two samples
                if (m_fInitialized && m_pHistCtrl->nSamples >= 2) {

                    // If no backlogged updates, post an update message
                    // Ensure that OnSampleCollected event is triggered in any case.
                    if (m_pHistCtrl->nBacklog == 0) {
                        PostMessage(m_hWnd, WM_GRAPH_UPDATE, 0, 0);
                    } else {
                        PostMessage(m_hWnd, WM_VALUES_UPDATED, 0, 0);
                    }

                    m_pHistCtrl->nBacklog++;
                }

                UnlockCounterData();

                UpdateAppPerfTimeData (TD_S_QUERY_TIME, TD_END);
            }
        }
    }
    return ERROR_SUCCESS;
}

void CSysmonControl::Activate( VOID )
{
    if (!m_fUIDead) { 
        m_pObj->UIActivate();
    }
}

void CSysmonControl::put_Appearance(INT iAppearance, BOOL fAmbient)
{
    INT iLocalAppearance;

    if (fAmbient && m_pObj->m_Graph.Options.iAppearance != NULL_APPEARANCE)
        return;
    
    if (!fAmbient) {
        m_pObj->m_Graph.Options.iAppearance = iAppearance;
    }

    // Any non-zero value translates to 3D.  In ambient case, the high bits are sometimes set.

    if ( iAppearance ) {
        iLocalAppearance = eAppear3D;
    } else {
        iLocalAppearance = eAppearFlat;
    }

    m_iAppearance = iLocalAppearance;
    UpdateGraph(UPDGRPH_COLOR);
}

void CSysmonControl::put_BorderStyle(INT iBorderStyle, BOOL fAmbient)
{
    if (fAmbient && m_pObj->m_Graph.Options.iBorderStyle != NULL_BORDERSTYLE)
        return;
    
    if (!fAmbient) {
        m_pObj->m_Graph.Options.iBorderStyle = iBorderStyle;
    }

    m_iBorderStyle = iBorderStyle;
    
    UpdateGraph(UPDGRPH_COLOR);
}

void CSysmonControl::put_BackCtlColor(OLE_COLOR Color)
{
    m_pObj->m_Graph.Options.clrBackCtl = Color;

    OleTranslateColor(Color, NULL, &m_clrBackCtl);  
    UpdateGraph(UPDGRPH_COLOR);
}


void CSysmonControl::put_FgndColor (
    OLE_COLOR Color, 
    BOOL fAmbient
    )
{
    if (fAmbient && m_pObj->m_Graph.Options.clrFore != NULL_COLOR)
        return;
    
    if (!fAmbient)
         m_pObj->m_Graph.Options.clrFore = Color;

    OleTranslateColor(Color, NULL, &m_clrFgnd);  
    UpdateGraph(UPDGRPH_COLOR);
}

void CSysmonControl::put_BackPlotColor (
    OLE_COLOR Color, 
    BOOL fAmbient
    )
{
    if (fAmbient && m_pObj->m_Graph.Options.clrBackPlot != NULL_COLOR)
        return;
    
    if (!fAmbient)
         m_pObj->m_Graph.Options.clrBackPlot = Color;

    OleTranslateColor(Color, NULL, &m_clrBackPlot); 
    UpdateGraph(UPDGRPH_PLOT);
}

void CSysmonControl::put_GridColor (
    OLE_COLOR Color
    )
{
    // Options color is the OLE_COLOR.
    // Color in control is translated from OLE_COLOR.
    m_pObj->m_Graph.Options.clrGrid = Color;

    OleTranslateColor(Color, NULL, &m_clrGrid); 
    UpdateGraph(UPDGRPH_PLOT);
}

void CSysmonControl::put_TimeBarColor (
    OLE_COLOR Color
    )
{
    // Options color is the OLE_COLOR.
    // Color in control is translated from OLE_COLOR.
    m_pObj->m_Graph.Options.clrTimeBar = Color;

    OleTranslateColor(Color, NULL, &m_clrTimeBar); 
    UpdateGraph(UPDGRPH_PLOT);
}

HRESULT CSysmonControl::put_Font (
    LPFONT pIFont,
    BOOL fAmbient
    )
{
    HRESULT hr = NOERROR;
    if ( NULL == pIFont ) {
        hr = E_INVALIDARG;
    } else {
        if ( fAmbient && FALSE == m_pObj->m_Graph.Options.bAmbientFont ) {
            hr =  NOERROR;
        } else {
            if (!fAmbient) {
                m_pObj->m_Graph.Options.bAmbientFont = FALSE;
            }
            hr =  m_OleFont.SetIFont(pIFont);
        }
    }

    return hr;
}


void CSysmonControl::FontChanged(
    void
    )
{
    m_pReport->ChangeFont();
    UpdateGraph(UPDGRPH_FONT);
}

DWORD WINAPI
CollectProc (
    IN  PSYSMONCTRL pCtrl
    )
{

    DWORD       dwElapsedTime;
    DWORD       dwTimeout = INFINITE;
    COLLECT_PROC_INFO   *pCollectInfo = &pCtrl->m_CollectInfo;

    while (TRUE) {

        // Wait for event or next sample period
        WaitForSingleObject(pCollectInfo->hEvent, dwTimeout);

        // If quit request, exit loop
        if (pCollectInfo->iMode == COLLECT_QUIT)
            break;

        // If suspended, wait for an event
        if (pCollectInfo->iMode == COLLECT_SUSPEND) {
            dwTimeout = INFINITE;
            continue;
        }

        // Take a sample
        pCtrl->UpdateCounterValues(TRUE);

        // Get elapsed time from last sample time
        dwElapsedTime = GetTickCount() - pCollectInfo->dwSampleTime;
        if (dwElapsedTime > 100000)
            dwElapsedTime = 0;

        // Have we missed any sample times? 
        while (dwElapsedTime > pCollectInfo->dwInterval) {

            // By how much?
            dwElapsedTime -= pCollectInfo->dwInterval;

            // If less than 1/2 an interval, take the sample now
            // otherwise record a missed one
            if (dwElapsedTime < pCollectInfo->dwInterval/2) {
                pCtrl->UpdateCounterValues(TRUE);
            } else {
                pCtrl->UpdateCounterValues(FALSE);
            }

            // Advance to next sample time 
            pCollectInfo->dwSampleTime += pCollectInfo->dwInterval;
        }

        // Set timeout to wait until next sample time 
        dwTimeout = pCollectInfo->dwInterval - dwElapsedTime;
        pCollectInfo->dwSampleTime += pCollectInfo->dwInterval;
    }

    return 0;
}

HRESULT
CSysmonControl::InitLogFileIntervals ( void )
{
    HRESULT hr = S_OK;
    PDH_STATUS  pdhstat;
    DWORD   nLogEntries = 0;
    DWORD   nBufSize;
    PDH_TIME_INFO   TimeInfo;

    if ( m_bLogFileSource ) {

        // Get time and sample count info
        nBufSize = sizeof(TimeInfo);
        pdhstat = PdhGetDataSourceTimeRangeH(GetDataSourceHandle(),
                                             & nLogEntries,
                                             & TimeInfo,
                                             & nBufSize );
        if ( ERROR_SUCCESS != pdhstat ) {
            if ( ERROR_NOT_ENOUGH_MEMORY == pdhstat ) {
                pdhstat = SMON_STATUS_LOG_FILE_SIZE_LIMIT;
            }
            hr = (HRESULT)pdhstat;
        } else if ( 2 > TimeInfo.SampleCount ) {
            hr = (HRESULT)SMON_STATUS_TOO_FEW_SAMPLES;
            m_DataSourceInfo.llInterval = 1;
        } else {
            // Setup time range info
            m_DataSourceInfo.llBeginTime = TimeInfo.StartTime;
            m_DataSourceInfo.llEndTime = TimeInfo.EndTime;

            // The start or stop time might no longer be valid, so check for
            // relationship between the them as well as for start/begin, stop/end.
            if ( (m_DataSourceInfo.llStartDisp < m_DataSourceInfo.llBeginTime)
                    || (m_DataSourceInfo.llStartDisp > m_DataSourceInfo.llEndTime) )
                m_DataSourceInfo.llStartDisp = m_DataSourceInfo.llBeginTime;

            if ( (m_DataSourceInfo.llStopDisp > m_DataSourceInfo.llEndTime)
                    || (m_DataSourceInfo.llStopDisp < m_DataSourceInfo.llStartDisp) )
                m_DataSourceInfo.llStopDisp = m_DataSourceInfo.llEndTime;

            m_DataSourceInfo.nSamples = TimeInfo.SampleCount;

            m_DataSourceInfo.llInterval = (m_DataSourceInfo.llEndTime - m_DataSourceInfo.llBeginTime + m_DataSourceInfo.nSamples/2) / (m_DataSourceInfo.nSamples - 1);

            UpdateGraph(UPDGRPH_LOGVIEW);
        }
    } else {
        assert ( FALSE );
        hr = E_FAIL;
    }
    return hr;
}

HRESULT 
CSysmonControl::AddSingleLogFile(
    LPCWSTR         pszPath, 
    CLogFileItem**  ppLogFile )
{
    HRESULT         hr = NOERROR;
    CLogFileItem*   pLogFile = NULL;
    CLogFileItem*   pLocalLogFileItem = NULL;

    if ( NULL != pszPath ) {
        //
        // Check whether the file name is too long
        //
        if (lstrlen(pszPath) > MAX_PATH) {
            return E_INVALIDARG;
        }

        if ( NULL != ppLogFile ) {
            *ppLogFile = NULL;
        }

        // Check to ensure that current data source is NOT log files.
        if ( sysmonLogFiles == m_pObj->m_Graph.Options.iDataSourceType ) {
            hr = SMON_STATUS_LOG_FILE_DATA_SOURCE;
        } else {
            // Check for duplicate log file name.
            pLogFile = FirstLogFile();
            while ( NULL != pLogFile ) {
                if ( 0 == lstrcmpi ( pszPath, pLogFile->GetPath() ) ) {
                    hr = SMON_STATUS_DUPL_LOG_FILE_PATH;
                    break;
                }
                pLogFile = pLogFile->Next();
            }

            if (SUCCEEDED(hr)) {
                // Create log file item
                pLocalLogFileItem = new CLogFileItem ( this ); 
                if ( NULL == pLocalLogFileItem ) {  
                    hr = E_OUTOFMEMORY;
                } else {
                    hr = pLocalLogFileItem->Initialize ( pszPath, &m_DataSourceInfo.pFirstLogFile );
                }
                // TodoLogFiles: ??? Test log file type?  Or leave that up to the "SetDataSource" time?
                // TodoLogFiles: Add log file type to the data source info structure

                // TodoLogFiles:  If allow the user to add files while data source set to log files,
                // then check that condition here.  If log file data source, then resample with
                // new log file.

                // If OK, Addref the returned interface
                if (SUCCEEDED(hr)) {
                    // AddRef once for ourselves
                    pLocalLogFileItem->AddRef();
                    m_DataSourceInfo.lLogFileCount++;
                    if ( NULL != ppLogFile ) {
                        // AddRef the returned interface
                        pLocalLogFileItem->AddRef();
                        *ppLogFile = pLocalLogFileItem;   
                    }
                }
                else {
                    if (pLocalLogFileItem != NULL) {
                        delete pLocalLogFileItem;
                        pLocalLogFileItem = NULL;
                    }
                }
            }
        }
    } else {
        hr = E_INVALIDARG; 
    }
    return hr;
}

HRESULT 
CSysmonControl::RemoveSingleLogFile (
    CLogFileItem*  pLogFile )
{
    HRESULT         hr = ERROR_SUCCESS;
    CLogFileItem*   pNext;
    CLogFileItem*   pPrevious;
    
    // Check to ensure that current data source is NOT log files.
    if ( sysmonLogFiles == m_pObj->m_Graph.Options.iDataSourceType ) {
        hr = SMON_STATUS_LOG_FILE_DATA_SOURCE;
    } else {
        pNext = FirstLogFile();

        if ( pNext == pLogFile ) {
            m_DataSourceInfo.pFirstLogFile = pNext->Next();
        } else {
            do {
                pPrevious = pNext;
                pNext = pNext->Next();
                if ( pNext == pLogFile ) {
                    break;
                }
            } while ( NULL != pNext );

            if ( NULL != pNext ) {
                pPrevious->SetNext ( pNext->Next() );
            } else {
                // Something is wrong with the list.
                assert ( FALSE );
                hr = E_FAIL;
            }
        }
    
        m_DataSourceInfo.lLogFileCount--;

        pLogFile->Release();
    }
    return hr;
}
    
HRESULT 
CSysmonControl::ProcessDataSourceType ( 
    LPCWSTR szDataSourceName,
    INT iDataSourceType )
{
    HRESULT     hr = NOERROR;
    HQUERY      hTestQuery = NULL;
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    HLOG        hTestLog  = H_REALTIME_DATASOURCE;

    if ( sysmonNullDataSource != iDataSourceType ) {
        // Open the new query

        if (iDataSourceType == sysmonLogFiles ||
            iDataSourceType == sysmonSqlLog) {
            pdhStatus = PdhBindInputDataSource(& hTestLog, szDataSourceName);
        }
        else if (iDataSourceType == sysmonCurrentActivity) {
            m_DataSourceInfo.hDataSource = H_REALTIME_DATASOURCE;
        }
        else {
            pdhStatus = PDH_INVALID_HANDLE;
        }
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhOpenQueryH (hTestLog, 1, & hTestQuery );
        }
    }

    if ( ERROR_SUCCESS != pdhStatus ) {
        if ( ERROR_NOT_ENOUGH_MEMORY == pdhStatus ) {
            hr = (HRESULT)SMON_STATUS_LOG_FILE_SIZE_LIMIT;        
        } else {
            hr = (HRESULT)pdhStatus;
        }
    } else {
        // Close the current query
        CloseQuery();

        // At this point, the previous query no longer exists.  
        // If any problems with the new query, close it and
        // reset the data source to realtime.

        // Set the data source type
        // The previous log file name is deleted in CloseQuery()

        // For sysmonNullDataSource, the current query is closed, 
        // and the query handle is set to NULL.
    
        m_pObj->m_Graph.Options.iDataSourceType = iDataSourceType;
    
        // TodoLogFiles:  Eliminate use of m_bLogFileSource,
        // using m_pObj->m_Graph.Options.iDataSourceType instead.
        m_bLogFileSource = (   sysmonLogFiles == iDataSourceType
                            || sysmonSqlLog   == iDataSourceType); 

        m_hQuery                     = hTestQuery;
        m_DataSourceInfo.hDataSource = hTestLog;

        if ( m_bLogFileSource ) {
            hr = InitLogFileIntervals();
        }

        if ( SUCCEEDED ( hr ) && sysmonNullDataSource != iDataSourceType ) {
            // Initialize the new query.  For log files, this can be done after 
            // InitLogFileIntervals because the methods operate on different fields.
            if ( ERROR_SUCCESS != InitializeQuery() ) {
                hr =  E_FAIL;
            } else {
                if ( m_fInitialized ) {
                    if ( ERROR_SUCCESS != ActivateQuery() ) 
                        hr = E_FAIL;              
                }
            }

            if ( SUCCEEDED ( hr ) && !m_bLogFileSource ) {
                // If note log file data source, pass new time span to statistics bar.
                m_pStatsBar->SetTimeSpan (
                                m_pObj->m_Graph.Options.fUpdateInterval 
                                * m_pObj->m_Graph.Options.iDisplayFilter
                                * m_pHistCtrl->nMaxSamples);
            }
        }
    }

    if ( FAILED ( hr ) ) {

        if ( sysmonLogFiles == iDataSourceType
            || sysmonSqlLog   == iDataSourceType ) 
        {
            // If failed with log file query, retry with realtime query.
            assert ( m_bLogFileSource );
            // Status returned is for the original query, not the realtime query.
            // TodoLogFiles:  Need to activate query?
            put_DataSourceType ( sysmonCurrentActivity );
        } else {
            // This leaves the control in an odd state with no active query.
            // TodoLogFiles:  At least message to user
            CloseQuery();
            put_DataSourceType ( sysmonNullDataSource );
        }
    }
    return hr;
}

HRESULT 
CSysmonControl::get_DataSourceType ( 
    eDataSourceTypeConstant& reDataSourceType )
{
    HRESULT         hr = NOERROR;

    reDataSourceType = (eDataSourceTypeConstant)m_pObj->m_Graph.Options.iDataSourceType;

    return hr;
}

HRESULT 
CSysmonControl::put_DataSourceType ( 
    INT iDataSourceType )
{
    HRESULT hr       = NOERROR;
    DWORD   dwStatus = ERROR_SUCCESS;
    LPWSTR  szDataSourceName = NULL;

    // TodoLogFiles:  Implement multi-file.
    // TodoLogFiles:  Use single data source name?
    //
    if (sysmonLogFiles == iDataSourceType) {
        CLogFileItem * pLogFile  = FirstLogFile();
        ULONG ulListLen = 0;
        
        if (pLogFile == NULL) {
            hr = E_INVALIDARG;
        }
        else {
            dwStatus = BuildLogFileList ( NULL, FALSE, &ulListLen );
            szDataSourceName =  (LPWSTR) malloc(ulListLen * sizeof(WCHAR));
            if ( NULL != szDataSourceName ) {
                dwStatus = BuildLogFileList ( szDataSourceName, FALSE, &ulListLen );
            } else {
                hr = E_OUTOFMEMORY;
            }
            
        }
    }
    else if (sysmonSqlLog == iDataSourceType) {
        if ( m_DataSourceInfo.szSqlDsnName && m_DataSourceInfo.szSqlLogSetName ) {
            if ( m_DataSourceInfo.szSqlDsnName[0] != _T('\0') && m_DataSourceInfo.szSqlLogSetName[0] != _T('\0')) {

                ULONG ulLogFileNameLen = 0;

                dwStatus = FormatSqlDataSourceName ( 
                                    m_DataSourceInfo.szSqlDsnName,
                                    m_DataSourceInfo.szSqlLogSetName,
                                    NULL,
                                    &ulLogFileNameLen );

                if ( ERROR_SUCCESS == dwStatus ) {
                    szDataSourceName = (LPWSTR) malloc(ulLogFileNameLen * sizeof(WCHAR));
                    if (szDataSourceName == NULL) {
                        hr = E_OUTOFMEMORY;
                    } else {
                        dwStatus = FormatSqlDataSourceName ( 
                                    m_DataSourceInfo.szSqlDsnName,
                                    m_DataSourceInfo.szSqlLogSetName,
                                    szDataSourceName,
                                    &ulLogFileNameLen );
                    }
                }
            }
        }
        else {
            hr = E_INVALIDARG;
        }
    }

    if (SUCCEEDED(hr)) {
        hr = ProcessDataSourceType((LPCWSTR) szDataSourceName, iDataSourceType);
    }
    if (szDataSourceName) {
        free(szDataSourceName);
    }

    return hr;
}

void 
CSysmonControl::IncrementVisuals (
    void
    )
{
    // Increment the visual indices in color, width, style order
    if (++m_iColorIndex >= NumStandardColorIndices()) {
        m_iColorIndex = 0;

        if (++m_iWidthIndex >= NumWidthIndices()) {
            m_iWidthIndex = 0;

            if (++m_iStyleIndex < NumStyleIndices()) {
                m_iStyleIndex = 0;
            }
        }
    }
}


void
CSysmonControl::SampleLogFile (
    BOOL bViewChange
    )
{
    typedef struct {
        PCGraphItem pItem;
        double  dMin;
        double  dMax;
        double  dAvg;
        INT     nAvgCnt;
        BOOL    bFirstSample;
        PDH_RAW_COUNTER rawValue[1];
    } LogWorkBuf, *PLogWorkBuf;

    INT nCounters;
    INT nLogSamples;
    INT nDispSamples;
    INT iNonDisp;
    INT iFinalValidSample = 0;

    PCGraphItem pItem;

    #define LLTIME_TICS_PER_SECOND (10000000)

    if ( NULL != m_hQuery ) {
    
        // Determine number of counters to update
        nCounters = 0;

        // If log view change, we have to update all counters
        if (bViewChange) {
            for (pItem = FirstCounter(); pItem; pItem = pItem->Next()) {
                pItem->m_bUpdateLog = TRUE;
                nCounters++;
            }
        }
        // otherwise, just any new counters
        else {
            for (pItem = FirstCounter(); pItem; pItem = pItem->Next()) {
                if (pItem->m_bUpdateLog)
                    nCounters++;
            }
        }

        // If none, nothing to do
        if ( nCounters > 0) {

            // Number of log samples in displayed interval
            // Add 1 extra at the beginning.  PdhSetQueryTimeRange returns one sample
            // before the specified start time, if it exists.
            // Add extra 1 because ?
            if (m_DataSourceInfo.nSamples > 1) {
                assert ( 0 != m_DataSourceInfo.llInterval );
                nLogSamples = (INT)((m_DataSourceInfo.llStopDisp - m_DataSourceInfo.llStartDisp) / m_DataSourceInfo.llInterval) + 2;
            } else {
                nLogSamples = m_DataSourceInfo.nSamples;
            }

            // Number of display samples
            nDispSamples = min(nLogSamples, m_pHistCtrl->nMaxSamples);

            // Setup history control
            m_pHistCtrl->nSamples = nDispSamples;
            m_pHistCtrl->iCurrent = 0;
            m_pHistCtrl->nBacklog = 0;

            if ( nDispSamples > 1 ) {
                INT         nCompSamples;
                INT         nPasses = 0;
                INT         iComp;
                INT         iCtr;
                INT         iDisp;
                DOUBLE      dSamplesPerInterval = 0.0;
                INT         iTotalSamplesProcessed = 0; 
                DOUBLE      dTotalSamplesCalc = 0;
                BOOL        bRemainder;


                PLogWorkBuf pWorkBuffers;
                PLogWorkBuf pWorkBuf;
                INT         nWorkBufSize;
    
                PDH_TIME_INFO   TimeInfo;
                PDH_STATISTICS  Statistics;
                DWORD           dwCtrType;
                PDH_STATUS      stat;

                // Number of log samples to compress to one display values
                // Add an extra 1 for rate counters becuase it takes 2 raw sample to get one formatted value.
                // The first sample of each buffer is ignored for non-rate counters.
                //
                // If nLogsamples / nDispSamples has a remainder, then an extra 1 is needed because some 
                // intervals will include one more sample to make the total come out even at the end 
                // (e.g. 10 samples divided among 3 intervals = (3, 4, 3))
                //
	            nCompSamples =  (nLogSamples + m_pHistCtrl->nMaxSamples  - 1)  / m_pHistCtrl->nMaxSamples;
	            nCompSamples += 1;
                        
                // Length of one work buffer

                nWorkBufSize = sizeof(LogWorkBuf) + (( nCompSamples ) * sizeof(PDH_RAW_COUNTER));

                // Allocate work buffers of nCompSamples samples for each counter
                pWorkBuffers = (PLogWorkBuf)malloc( nCounters * nWorkBufSize);
                if (pWorkBuffers == NULL)
                    return;

                // Place selected counter item pointers in work buffers
                // and init statistics
                pWorkBuf = pWorkBuffers;
                for (pItem = FirstCounter(); pItem; pItem = pItem->Next()) {

                    if (pItem->m_bUpdateLog) {
                        pWorkBuf->pItem = pItem;
                        pWorkBuf->dMin = (double)10e8;
                        pWorkBuf->dMax = (double)-10e8;
                        pWorkBuf->dAvg = 0.0;
                        pWorkBuf->nAvgCnt = 0;
                        pWorkBuf->bFirstSample = TRUE;
                        pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                    }
                }

                // Set time range for pdh
                TimeInfo.StartTime = m_DataSourceInfo.llStartDisp;
                TimeInfo.EndTime = m_DataSourceInfo.llStopDisp;
                PdhSetQueryTimeRange(m_hQuery, &TimeInfo);

                bRemainder = ( 0 < ( nLogSamples % nDispSamples ) );
                if ( bRemainder ) {
                    // Initialize the differential calc variables
                    dSamplesPerInterval = (double)nLogSamples / (double)nDispSamples;
                    iTotalSamplesProcessed = 0; 
                    dTotalSamplesCalc = 0;
                } else {
                    nPasses = nCompSamples;
                }

                for (iDisp = 0; iDisp<nDispSamples; iDisp++) {

                    if ( bRemainder ) {
                        // Do the differential calc to see if it's time for an extra sample
                        dTotalSamplesCalc += dSamplesPerInterval;
                        nPasses = (int)(dTotalSamplesCalc - iTotalSamplesProcessed);
                        iTotalSamplesProcessed += nPasses;
                        // Add 1 to nPasses because the first buffer is blank or from the previous interval.
                        nPasses ++;
                    }

                    // Fill the work buffers with a set of samples
                    // Set bad status for sample zero first time through.
                    // Sample zero is only used for rate counters.
                    // Other passes will reuse last sample of previous pass.

                    iComp = 0;

                    if ( 0 == iDisp ) {
                        // Special handling for the first sample.
                        // Set bad status for each 
                        pWorkBuf = pWorkBuffers;
                        for (iCtr=0; iCtr < nCounters; iCtr++) {
                            pWorkBuf->rawValue[0].CStatus = PDH_CSTATUS_INVALID_DATA;
                            pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                        }
                        // If iDisp == 0, Query the data and check the timestamp for the first raw data value.
                        // If that timestamp is before the official Start time, store it in buffer 0 
                        // Otherwise, put that data in buffer 1 and skip the first sample collection of the
                        // regular loop below.

                        stat = PdhCollectQueryData(m_hQuery);
                        if (stat == 0) {

                            PDH_RAW_COUNTER rawSingleValue;
                            // Get a raw sample for each counter.  Check the timestamp of the first counter to 
                            // determine which buffer to use.
                            pWorkBuf = pWorkBuffers;
                            iCtr = 0;

                            PdhGetRawCounterValue(pWorkBuf->pItem->Handle(), &dwCtrType, &rawSingleValue);
                    
                            // Increment the buffer index to 1 if the time stamp is after Start time.
                            // Otherwise, write the data to buffer 0, which is only used to process rate counters.
                            if ( *((LONGLONG*)&rawSingleValue.TimeStamp) >= m_DataSourceInfo.llStartDisp ) {
                                iComp = 1;
                            }


                            pWorkBuf->rawValue[iComp] = rawSingleValue;
                
                            // Increment to the next counter, and continue normal processing for the first sample,
                            // using iComp buffer index.
                            iCtr++;
                            pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                            for ( ; iCtr < nCounters; iCtr++) {
                                PdhGetRawCounterValue(pWorkBuf->pItem->Handle(), &dwCtrType, &pWorkBuf->rawValue[iComp]);

                                pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                            }
                        } // else bad status already set in 0 buffer for each counter.        
                    }        

                    // Only rate counter values use work buffer 0
                    // Buffer 0 is set to value from previous sample, except when iDisp 0, in which case it might have
                    // been filled in the (if 0 == iDisp) clause above.

                    // Skip past any special handling for the first iDisp pass above.  If buffer 1 is not filled by that 
                    // special handling, then iComp is set to 1.
                    iComp++;

                    for ( ; iComp < nPasses; iComp++) {
                        stat = PdhCollectQueryData(m_hQuery);
                        if (stat == 0) {
                            // Get a raw sample for each counter
                            pWorkBuf = pWorkBuffers;

                            for (iCtr = 0; iCtr < nCounters; iCtr++) {
                                PdhGetRawCounterValue(pWorkBuf->pItem->Handle(), &dwCtrType, &pWorkBuf->rawValue[iComp]);
                                pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                            }
                        }
                        else {
                            // Set bad status for each 
                            pWorkBuf = pWorkBuffers;
                            for (iCtr=0; iCtr < nCounters; iCtr++) {
                                pWorkBuf->rawValue[iComp].CStatus = PDH_CSTATUS_INVALID_DATA;
                                pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                            }
                        }
                    }

                    // generate one display sample by averaging each compression buffer
                    pWorkBuf = pWorkBuffers;
                    for (iCtr=0; iCtr < nCounters; iCtr++) {
                        INT iPassesThisCounter;
                        INT iWorkBufIndex;

                        if ( pWorkBuf->pItem->CalcRequiresMultipleSamples() ) {
                            iPassesThisCounter = nPasses;
                            iWorkBufIndex = 0;
                        } else {
                            // Non-rate counters do not use the first sample buffer.
                            iPassesThisCounter = nPasses - 1;
                            iWorkBufIndex = 1;
                        }

                        stat = PdhComputeCounterStatistics (pWorkBuf->pItem->Handle(), PDH_FMT_DOUBLE | PDH_FMT_NOCAP100,
                                            0, iPassesThisCounter, &pWorkBuf->rawValue[iWorkBufIndex], &Statistics );

                        if (stat == 0 && Statistics.mean.CStatus == PDH_CSTATUS_VALID_DATA) {
                            LONGLONG llTruncatedTimeStamp = 0;
                            LONGLONG llTmpTimeStamp = 0;
                            pWorkBuf->pItem->SetLogEntry(iDisp, Statistics.min.doubleValue,
                                                          Statistics.max.doubleValue,
                                                          Statistics.mean.doubleValue);
                
                            // Use the final sample timestamp.  It is valid for both rates and numbers.

                            llTmpTimeStamp = MAKELONGLONG(
                                pWorkBuf->rawValue[nPasses - 1].TimeStamp.dwLowDateTime,
                                pWorkBuf->rawValue[nPasses - 1].TimeStamp.dwHighDateTime);
                            TruncateLLTime(llTmpTimeStamp, & llTruncatedTimeStamp);
                            pWorkBuf->pItem->SetLogEntryTimeStamp ( iDisp, *((FILETIME*)&llTruncatedTimeStamp) );

                            //
                            // Set the minimum and maximum values correctly the first time through.
                            //

                            if ( pWorkBuf->bFirstSample ) {
                                pWorkBuf->dMin = Statistics.min.doubleValue;
                                pWorkBuf->dMax = Statistics.max.doubleValue;
                                pWorkBuf->bFirstSample = FALSE;
                            } else {
                                if (Statistics.min.doubleValue < pWorkBuf->dMin) {
                                    pWorkBuf->dMin = Statistics.min.doubleValue;
                                }

                                if (Statistics.max.doubleValue > pWorkBuf->dMax) {
                                    pWorkBuf->dMax = Statistics.max.doubleValue;
                                } 
                            }
                            pWorkBuf->dAvg += Statistics.mean.doubleValue;
                            pWorkBuf->nAvgCnt++;
                            iFinalValidSample = iDisp;
                        }
                        else {
                            pWorkBuf->pItem->SetLogEntry(iDisp, -1.0, -1.0, -1.0);
                        }

                        pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                    }

                    // If a rate counter, move last sample to first sample 
                    // for next compress interval
                    pWorkBuf = pWorkBuffers;
                    for (iCtr=0; iCtr < nCounters; iCtr++) {
                        if ( pWorkBuf->pItem->CalcRequiresMultipleSamples() ) {
                            pWorkBuf->rawValue[0] = pWorkBuf->rawValue[nPasses-1];
                        }
                        pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                    }
                }

                // Reset the history control to point to the last valid sample.
                m_pHistCtrl->nSamples = iFinalValidSample;

                // Set the log statistics for empty samples.
                for (iNonDisp = nDispSamples; iNonDisp<m_pHistCtrl->nMaxSamples; iNonDisp++) {
                    pWorkBuf = pWorkBuffers;
                    for (iCtr=0; iCtr < nCounters; iCtr++) {
                        pWorkBuf->pItem->SetLogEntry(iNonDisp, -1.0, -1.0, -1.0);
                        pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                    }
                }

                // Store the final statistics and clear the update flags
                pWorkBuf = pWorkBuffers;
                for (iCtr=0; iCtr < nCounters; iCtr++) {

                    pWorkBuf->pItem->m_bUpdateLog = FALSE;

                    if (pWorkBuf->nAvgCnt) {
                        pWorkBuf->dAvg /= pWorkBuf->nAvgCnt;
                        pWorkBuf->pItem->SetLogStats(pWorkBuf->dMin, pWorkBuf->dMax, pWorkBuf->dAvg, PDH_CSTATUS_VALID_DATA);
                    }

                    pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                }
    
                // Free the work buffers
                free(pWorkBuffers);
            } else {
                // No data to display. Clear the history buffers by setting all status to Invalid.
                for (pItem = FirstCounter(); pItem; pItem = pItem->Next()) {
                    for (iNonDisp = 0; iNonDisp < m_pHistCtrl->nMaxSamples; iNonDisp++) {
                        pItem->SetLogEntry(iNonDisp, -1.0, -1.0, -1.0);
                    }
                }
            }
            // Update statistics bar
            m_pStatsBar->SetTimeSpan((double)(m_DataSourceInfo.llStopDisp - m_DataSourceInfo.llStartDisp) / LLTIME_TICS_PER_SECOND);
            m_pStatsBar->Update(NULL, m_pSelectedItem);
        }
    }
}

void
CSysmonControl::CalcZoomFactor ( void )
{
    RECT rectPos;
    RECT rectExtent;

    double dHeightPos;
    double dHeightExtent;
    // Calculate zoom factor based on height.
    // The Zoom calculation is prcPos (set by container) divided by the extent.
    // See technical note 40 - TN040.
    rectExtent = m_pObj->m_RectExt;
    GetClientRect ( m_hWnd, &rectPos );

    dHeightPos = rectPos.bottom - rectPos.top;
    dHeightExtent = rectExtent.bottom - rectExtent.top;
    m_dZoomFactor = ( dHeightPos ) / ( dHeightExtent );
}

void
CSysmonControl::ResetLogViewTempTimeRange ()

/*++

Routine Description:

    Reset the log view temporary time range steppers to the ends of the visible 
    part of the log file. 

Arguments:


Return Value:


--*/

{
    assert ( IsLogSource() );

    if ( IsLogSource() ) {
        INT iNewStopStepNum = 0;
        m_pObj->m_Graph.LogViewStartStepper.Reset();
        m_pObj->m_Graph.LogViewStopStepper.Reset();

        if ( FirstCounter() ) {
            GetNewLogViewStepNum( m_DataSourceInfo.llStopDisp, iNewStopStepNum );
            m_pObj->m_Graph.LogViewStopStepper.StepTo( iNewStopStepNum );
        }
    }   
}

void
CSysmonControl::FindNextValidStepNum (
    BOOL        bDecrease,
    PCGraphItem pItem,
    LONGLONG    llNewTime,
    INT&        riNewStepNum,
    DWORD&      rdwStatus )
{
    DWORD       dwPdhStatus = ERROR_SUCCESS;
    DWORD       dwLocalStatus = ERROR_SUCCESS;
    LONGLONG    llNextTimeStamp = 0;
    INT         iLocalStepNum;
    INT         iTempLocalStepNum;

    assert ( NULL != pItem );

    if ( NULL != pItem ) {

        iLocalStepNum = riNewStepNum;
        iTempLocalStepNum = iLocalStepNum;
        dwLocalStatus = rdwStatus;

        if ( bDecrease ) {
            // Start by decreasing steps to find first valid step.
            while ( ( ERROR_SUCCESS == dwPdhStatus ) 
                    && ( ERROR_SUCCESS != dwLocalStatus )
                    && ( iLocalStepNum > 0 ) ) {
                iTempLocalStepNum = iLocalStepNum;
                iTempLocalStepNum--;
                dwPdhStatus = pItem->GetLogEntryTimeStamp( iTempLocalStepNum, llNextTimeStamp, &dwLocalStatus );
                iLocalStepNum = iTempLocalStepNum;
            }
            // Subtract 1 from nSamples because stepper is 0-based, 
            while ( ( ERROR_SUCCESS == dwPdhStatus ) 
                    && ( ERROR_SUCCESS != dwLocalStatus )
                    && ( iLocalStepNum < m_pHistCtrl->nSamples - 1 ) ) {
                iTempLocalStepNum++;
                dwPdhStatus = pItem->GetLogEntryTimeStamp( iTempLocalStepNum, llNextTimeStamp, &dwLocalStatus );
                iLocalStepNum = iTempLocalStepNum;
            }
    
        } else {
            // Start by increasing steps to find first valid step.

            // Subtract 1 from nSamples because stepper is 0-based, 
            while ( ( ERROR_SUCCESS == dwPdhStatus ) 
                    && ( ERROR_SUCCESS != dwLocalStatus )
                    && ( iLocalStepNum < m_pHistCtrl->nSamples - 1 ) ) {
                iTempLocalStepNum++;
                dwPdhStatus = pItem->GetLogEntryTimeStamp( iTempLocalStepNum, llNextTimeStamp, &dwLocalStatus );
                iLocalStepNum = iTempLocalStepNum;
            }
    
            while ( ( ERROR_SUCCESS == dwPdhStatus ) 
                    && ( ERROR_SUCCESS != dwLocalStatus )
                    && ( iLocalStepNum > 0 ) ) {
                iTempLocalStepNum = iLocalStepNum;
                iTempLocalStepNum--;
                dwPdhStatus = pItem->GetLogEntryTimeStamp( iTempLocalStepNum, llNextTimeStamp, &dwLocalStatus );
                iLocalStepNum = iTempLocalStepNum;
            }
        }
        if ( ERROR_SUCCESS == dwLocalStatus ) {
            riNewStepNum = iLocalStepNum;
            llNewTime = llNextTimeStamp;
            rdwStatus = dwLocalStatus;
        }
    }
    return;
}

void
CSysmonControl::GetNewLogViewStepNum (
    LONGLONG llNewTime,
    INT& riNewStepNum )

/*++

Routine Description:

    Given the new time and original stepnum, find the stepnum that matches
    the new time.

Arguments:

    llNewTime       New time stamp to match
    riNewStepNum    (IN) Current step num
                    (OUT) Step num that matches the new time stamp.

Return Value:


--*/

{
    PCGraphItem pItem = NULL;
    LONGLONG    llNextTimeStamp = 0;
    PDH_STATUS  dwPdhStatus = ERROR_SUCCESS;
    DWORD       dwStatus = ERROR_SUCCESS;
    INT         iLocalStepNum = 0;

    assert ( IsLogSource() );

    iLocalStepNum = riNewStepNum;

    // Check only the first counter for log file time stamp data.
    pItem = FirstCounter();

    if ( NULL != pItem ) {
        dwPdhStatus = pItem->GetLogEntryTimeStamp( iLocalStepNum, llNextTimeStamp, &dwStatus );

        // If the stepper is positioned on a sample with bad status,
        // move n steps in either direction to find a valid sample to start with.
        if ( ( ERROR_SUCCESS == dwPdhStatus ) && ( ERROR_SUCCESS != dwStatus ) ) {
            FindNextValidStepNum ( FALSE, pItem, llNextTimeStamp, iLocalStepNum, dwStatus );
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            if ( ( llNewTime < llNextTimeStamp ) || ( MAX_TIME_VALUE == llNextTimeStamp ) ) {
                while ( iLocalStepNum > 0 ) {
                    iLocalStepNum--;
                    pItem->GetLogEntryTimeStamp( iLocalStepNum, llNextTimeStamp, &dwStatus );
                    if ( ERROR_SUCCESS == dwStatus ) {
                        if ( llNewTime == llNextTimeStamp ) {
                            break;
                        } else if ( llNewTime > llNextTimeStamp ) {
                            iLocalStepNum++;
                            break;
                        }
                    }
                }
            } else if ( llNewTime > llNextTimeStamp ) {
                // Subtract 1 from nSamples because stepper is 0-based, 
                while ( iLocalStepNum < m_pHistCtrl->nSamples - 1 ) {
                    iLocalStepNum++; 
                    pItem->GetLogEntryTimeStamp( iLocalStepNum, llNextTimeStamp, &dwStatus );
                    if ( ERROR_SUCCESS == dwStatus ) {
                        if ( llNewTime <= llNextTimeStamp ) {
                            break;
                        }                 
                    }
                }
            }
            riNewStepNum = iLocalStepNum;
        } // else if NO valid samples, leave the start/stop time stepper where it is.
    } // Non-null FirstCounter()

    return;
}

void
CSysmonControl::SetLogViewTempTimeRange (
    LONGLONG llStart,
    LONGLONG llStop
    )

/*++

Routine Description:

    Set the log view temporary time range. This routine provides the Source
    property page a way to give range to the control, so that the control
    can draw temporary timeline guides on the line graph.


Arguments:

    llStart     Temporary log view start time (FILETIME format)
    llEnd       Temporary log view end time (FILETIME format)

Return Value:


--*/

{
    assert ( llStart <= llStop );
    
    if ( IsLogSource() && ( llStart <= llStop ) ) {
        INT         iNewStepNum;

        // No time range to modify if no counters selected.
        if ( NULL != FirstCounter() ) {
        
            // Start/Stop time range bars are turned off if llStart and llStop are set
            // to MIN and MAX values, so no need to update steppers.
            if ( MIN_TIME_VALUE != llStart ) {

                // Search through sample values to find the appropriate step for the start bar.
                if ( llStart != m_pObj->m_Graph.LogViewTempStart ) {

                    // Start with current position.
                    iNewStepNum = m_pObj->m_Graph.LogViewStartStepper.StepNum();

                    GetNewLogViewStepNum ( llStart, iNewStepNum );

                    if ( iNewStepNum != m_pObj->m_Graph.LogViewStartStepper.StepNum() ) {
                        m_pObj->m_Graph.LogViewStartStepper.StepTo ( iNewStepNum );
                    }
                }
            }
            if ( MAX_TIME_VALUE != llStop ) {

                // Search through sample values to find the appropriate step for the stop bar.
                if ( llStop != m_pObj->m_Graph.LogViewTempStop ) {

                    // Start with current position.
                    iNewStepNum = m_pObj->m_Graph.LogViewStopStepper.StepNum();

                    GetNewLogViewStepNum ( llStop, iNewStepNum );

                    if ( iNewStepNum != m_pObj->m_Graph.LogViewStopStepper.StepNum() ) {
                        m_pObj->m_Graph.LogViewStopStepper.StepTo ( iNewStepNum );
                    }                
                }
            }
        }
    }

    if ( ( m_pObj->m_Graph.LogViewTempStart != llStart )
        || ( m_pObj->m_Graph.LogViewTempStop != llStop ) ) {
    
        m_pObj->m_Graph.LogViewTempStart = llStart;
        m_pObj->m_Graph.LogViewTempStop = llStop;

        if ( sysmonLineGraph == m_pObj->m_Graph.Options.iDisplayType ) {
            // Cause redraw
            UpdateGraph(UPDGRPH_PLOT);
        }
    }
}

PRECT
CSysmonControl::GetNewClientRect ( void )
{
    return &m_pObj->m_RectExt;
}

PRECT
CSysmonControl::GetCurrentClientRect ( void )
{
    return &m_rectCurrentClient;
}

void
CSysmonControl::SetCurrentClientRect ( PRECT prectNew )
{
    m_rectCurrentClient = *prectNew;
}

void
CSysmonControl::UpdateNonAmbientSysColors ( void )
{
    HRESULT hr;
    COLORREF newColor;
    PGRAPH_OPTIONS pOptions = &m_pObj->m_Graph.Options;

    hr = OleTranslateColor(pOptions->clrBackCtl, NULL, &newColor);
    if ( SUCCEEDED( hr ) ) {
        m_clrBackCtl = newColor;
    }

    if (pOptions->clrBackPlot != NULL_COLOR) {
        hr = OleTranslateColor(pOptions->clrBackPlot, NULL, &newColor);
        if ( SUCCEEDED( hr ) ) {
            m_clrBackPlot = newColor;
        }
    }

    if (pOptions->clrFore != NULL_COLOR) {
        hr = OleTranslateColor(pOptions->clrFore, NULL, &newColor);
        if ( SUCCEEDED( hr ) ) {
            m_clrFgnd = newColor;
        }
    }

    hr = OleTranslateColor(pOptions->clrGrid, NULL, &newColor);
    if ( SUCCEEDED( hr ) ) {
        m_clrGrid = newColor;
    }

    hr = OleTranslateColor(pOptions->clrTimeBar, NULL, &newColor);
    if ( SUCCEEDED( hr ) ) {
        m_clrTimeBar = newColor;
    }
}

LPCWSTR 
CSysmonControl::GetDataSourceName ( void )
{
    LPWSTR  szReturn = NULL;
    CLogFileItem* pLogFile = NULL;

    if ( sysmonLogFiles == m_pObj->m_Graph.Options.iDataSourceType ) {

        pLogFile = FirstLogFile();
    
        if ( NULL != pLogFile ) {
            szReturn = const_cast<LPWSTR>((LPCWSTR)pLogFile->GetPath());
        }
    }
    // TodoLogFiles:  Use  the m_DataSourceInfo.szDataSourceName field?  When multi-file?
    return szReturn;
}


HRESULT 
CSysmonControl::GetSelectedCounter ( CGraphItem** ppItem )
{
    HRESULT hr = E_POINTER;

    if ( NULL != ppItem ) {
        *ppItem = m_pSelectedItem;
        hr = NOERROR;
    }

    return hr;
}

DWORD
CSysmonControl::BuildLogFileList ( 
    LPWSTR  szLogFileList,
    BOOL    bIsCommaDelimiter,
    ULONG*  pulBufLen )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    ULONG           ulListLen;
    CLogFileItem*   pLogFile = FirstLogFile();
    LPCWSTR         szThisLogFile = NULL;
    LPWSTR          szLogFileCurrent = NULL;

    const WCHAR     cwComma = L',';

    if ( NULL != pulBufLen ) {
        ulListLen = 0;
        while (pLogFile != NULL) {
            szThisLogFile= pLogFile->GetPath();
            ulListLen += (lstrlen(szThisLogFile) + 1);
            pLogFile = pLogFile->Next();
        }
        ulListLen ++; // for the single final NULL character.
    
        if ( ulListLen <= *pulBufLen ) {
            if ( NULL != szLogFileList ) {
                ZeroMemory(szLogFileList, (ulListLen * sizeof(WCHAR)));
                pLogFile = FirstLogFile();
                szLogFileCurrent = (LPWSTR) szLogFileList;
                while (pLogFile != NULL) {
                    szThisLogFile      = pLogFile->GetPath();
                    //
                    // Here we are sure we have enough space to hold string
                    //
                    StringCchCopy(szLogFileCurrent, lstrlen(szThisLogFile) + 1, szThisLogFile);
                    szLogFileCurrent  += lstrlen(szThisLogFile);
                    *szLogFileCurrent = L'\0';
                    pLogFile     = pLogFile->Next();
                    if ( bIsCommaDelimiter && NULL != pLogFile ) {
                        // If comma delimited, replace the NULL char with a comma
                        *szLogFileCurrent = cwComma;
                    }
                    szLogFileCurrent ++;
                }
                if ( !bIsCommaDelimiter ) {
                    *szLogFileCurrent = L'\0';
                }
            }
        } else if ( NULL != szLogFileList ) {
            dwStatus = ERROR_MORE_DATA;
        }    
        *pulBufLen = ulListLen;
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
        assert ( FALSE );
    }

    return dwStatus;
}

HRESULT   
CSysmonControl::LoadLogFilesFromMultiSz (
    LPCWSTR  szLogFileList )
{
    HRESULT hr = NOERROR;
    LPWSTR  szNext = NULL;

    szNext = const_cast<LPWSTR>(szLogFileList);

    while ( NULL != szNext ) {
        hr = AddSingleLogFile ( szNext );
        if ( FAILED ( hr ) ) {
            break;
        }
        szNext += lstrlen (szNext) + 1;
    }

    return hr;
}


void
CSysmonControl::ClearErrorPathList ( void )
{
    if ( NULL != m_szErrorPathList ) {
        delete [] m_szErrorPathList;
    }    
    m_szErrorPathList = NULL;
    m_dwErrorPathListLen = 0;
    m_dwErrorPathBufLen = 0;
}

LPCWSTR
CSysmonControl::GetErrorPathList ( DWORD* pdwListLen )
{
    if ( NULL != pdwListLen ) {
        *pdwListLen = m_dwErrorPathListLen;
    }
    return m_szErrorPathList;
}

DWORD
CSysmonControl::AddToErrorPathList ( LPCWSTR  szPath )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwPathLen = 0;
    LPWSTR  szNewBuffer = NULL;
    LPWSTR  szNextCounter = NULL;

    //
    // cdwAddLen is an arbitrary number, larger than most counter strings.
    // Longer counter paths are handled dwPathLen below.
    //
    const DWORD     cdwAddLen = 2048;
    const LPCWSTR   cszNewLine = L"\n";

    if ( NULL != szPath ) {
        //
        // Include 1 for the possible newline character or null.
        //
        dwPathLen = lstrlen ( szPath ) + 1;
        //
        // If not enough space, allocate a bigger buffer.
        //
        if ( m_dwErrorPathBufLen < m_dwErrorPathListLen + dwPathLen ) {
            
            m_dwErrorPathBufLen += max ( cdwAddLen, dwPathLen );

            szNewBuffer = new WCHAR[m_dwErrorPathBufLen];

            if ( NULL != szNewBuffer ) {
                if ( NULL != m_szErrorPathList ) {
                    memcpy ( szNewBuffer, m_szErrorPathList, m_dwErrorPathListLen * sizeof(WCHAR) );
                    delete [] m_szErrorPathList;
                }
                m_szErrorPathList = szNewBuffer;
            } else {
                dwStatus = ERROR_OUTOFMEMORY;
            }
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            //
            // Point to current ending null character.
            //
            szNextCounter = m_szErrorPathList;
            if ( 0 < m_dwErrorPathListLen ) {
                szNextCounter += m_dwErrorPathListLen - 1;
                memcpy ( szNextCounter, cszNewLine, sizeof(cszNewLine) );
                szNextCounter++;
                //
                // No need to increment m_dwErrorPathListLen because the newline 
                // replaces the ending null of the previous string.
                //
            }
            //
            // We are sure we have enough space to hold the string
            //
            StringCchCopy(szNextCounter, dwPathLen, szPath);
            m_dwErrorPathListLen += dwPathLen; 
        }
    } else { 
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\snapbar.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    snapbar.h

Abstract:

    <abstract>

--*/

#ifndef _SNAPBAR_H_
#define _SNAPBAR_H_

class CSysmonControl;
 
class CSnapBar
{
    friend LRESULT CALLBACK SnapBarWndProc (HWND, UINT, WPARAM, LPARAM);

    private:
        CSysmonControl *m_pCtrl;
        HBITMAP     m_hBitmap;
        HWND        m_hWnd;
        WNDPROC     m_WndProc;

    public:
        CSnapBar (void);
        ~CSnapBar (void);

     BOOL Init(CSysmonControl *pCtrl, HWND hWndParent);
     VOID SizeComponents(LPRECT pRect);
     INT  Height (INT iMaxHeight);
};

typedef CSnapBar *PSNAPBAR;

#endif // _SNAPBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\smonprop.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    smonprop.h

Abstract:

    Header file for the sysmon property page base class.

--*/

#ifndef _SMONPROP_H_
#define _SMONPROP_H_

#define GUIDS_FROM_TYPELIB
#define WM_SETPAGEFOCUS     (WM_USER+1000)

// Property page indices
enum {
    GENERAL_PROPPAGE,
    SOURCE_PROPPAGE,
    COUNTER_PROPPAGE,
    GRAPH_PROPPAGE,
    APPEAR_PROPPAGE,       
    CPROPPAGES
};

#define CCHSTRINGMAX        40
                
// Class factory for all property pages
class CSysmonPropPageFactory : public IClassFactory
    {
    protected:
        ULONG       m_cRef;
        INT         m_nPageID;

    public:
        CSysmonPropPageFactory(INT nPageID);
        ~CSysmonPropPageFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassPPFactory members
        STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, PPVOID);
        STDMETHODIMP     LockServer(BOOL);
    };

typedef CSysmonPropPageFactory *PCSysmonPropPageFactory;


// Dialog proc for proprty pages
INT_PTR APIENTRY CALLBACK SysmonPropPageProc(HWND, UINT, WPARAM, LPARAM);

// Base property page class
class CSysmonPropPage : public IPropertyPage2
{
    friend INT_PTR APIENTRY CALLBACK SysmonPropPageProc(HWND, UINT, WPARAM, LPARAM);
    protected:
        ULONG           m_cRef;         //Reference count
        UINT            m_uIDDialog;    //Dialog ID
        UINT            m_uIDTitle;     //Page Title ID
        HWND            m_hDlg;         //Dialog handle

        ULONG           m_cx;           //Dialog size
        ULONG           m_cy;
        UINT            m_cObjects;     //Number of objects
        LCID            m_lcid;         //Current locale
        BOOL            m_fActive;      //Page is fully active
        BOOL            m_fDirty;       //Page dirty?

        INT             m_dwEditControl; // Focus if specified by EditProperty

        ISystemMonitor **m_ppISysmon;    //Objects to notify
        IPropertyPageSite *m_pIPropertyPageSite;  //Frame's site

        void SetChange(void);                   //Mark page changed
        virtual BOOL GetProperties(void) = 0;   //Get object properties
        virtual BOOL SetProperties(void) = 0;   //Put object properties

        virtual void DialogItemChange(WORD wId, WORD wMsg) = 0; // Handle item change
        virtual void MeasureItem(PMEASUREITEMSTRUCT) {}; // Handle user measure req
        virtual void DrawItem(PDRAWITEMSTRUCT) {};  // Handle user draw req
        virtual BOOL InitControls(void)        // Initialize dialog controls
                        { return TRUE; }
        virtual void DeinitControls(void) {};       // Deinitialize dialog controls
        virtual HRESULT EditPropertyImpl( DISPID ) { return E_NOTIMPL; }; // Set focus control      

        virtual BOOL WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam); // Special msg processing 
         
    public:
                CSysmonPropPage(void);
        virtual ~CSysmonPropPage(void);

        virtual BOOL Init(void);
        void FreeAllObjects(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP SetPageSite(LPPROPERTYPAGESITE);
        STDMETHODIMP Activate(HWND, LPCRECT, BOOL);
        STDMETHODIMP Deactivate(void);
        STDMETHODIMP GetPageInfo(LPPROPPAGEINFO);
        STDMETHODIMP SetObjects(ULONG, LPUNKNOWN *);
        STDMETHODIMP Show(UINT);
        STDMETHODIMP Move(LPCRECT);
        STDMETHODIMP IsPageDirty(void);
        STDMETHODIMP Apply(void);
        STDMETHODIMP Help(LPCOLESTR);
        STDMETHODIMP TranslateAccelerator(LPMSG);
        STDMETHODIMP EditProperty(DISPID);
    };
typedef CSysmonPropPage *PCSysmonPropPage;

#endif //_SMONPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\smonprop.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    smonprop.cpp

Abstract:

    Sysmon property page base class.

--*/

#include "polyline.h"
#include <strsafe.h>
#include "smonprop.h"
#include "genprop.h"
#include "ctrprop.h"
#include "grphprop.h"
#include "srcprop.h"
#include "appearprop.h"
#include "unihelpr.h"
#include "utils.h"
#include "smonhelp.h"
#include "globals.h"

static ULONG
aulControlIdToHelpIdMap[] =
{
    IDC_CTRLIST,            IDH_CTRLIST,                // Data
    IDC_ADDCTR,             IDH_ADDCTR,
    IDC_DELCTR,             IDH_DELCTR,
    IDC_LINECOLOR,          IDH_LINECOLOR,
    IDC_LINEWIDTH,          IDH_LINEWIDTH,
    IDC_LINESTYLE,          IDH_LINESTYLE,
    IDC_LINESCALE,          IDH_LINESCALE,
    IDC_GALLERY_REPORT,     IDH_GALLERY_REPORT,         // General
    IDC_GALLERY_GRAPH,      IDH_GALLERY_GRAPH,
    IDC_GALLERY_HISTOGRAM,  IDH_GALLERY_HISTOGRAM,
    IDC_VALUEBAR,           IDH_VALUEBAR,
    IDC_TOOLBAR,            IDH_TOOLBAR,
    IDC_LEGEND,             IDH_LEGEND,
    IDC_RPT_VALUE_DEFAULT,  IDH_RPT_VALUE_DEFAULT,
    IDC_RPT_VALUE_MINIMUM,  IDH_RPT_VALUE_MINIMUM,
    IDC_RPT_VALUE_MAXIMUM,  IDH_RPT_VALUE_MAXIMUM,
    IDC_RPT_VALUE_AVERAGE,  IDH_RPT_VALUE_AVERAGE,
    IDC_RPT_VALUE_CURRENT,  IDH_RPT_VALUE_CURRENT,
    IDC_COMBOAPPEARANCE,    IDH_COMBOAPPEARANCE,
    IDC_COMBOBORDERSTYLE,   IDH_COMBOBORDERSTYLE,
    IDC_PERIODIC_UPDATE,    IDH_PERIODIC_UPDATE,
    IDC_DISPLAY_INTERVAL,   IDH_DISPLAY_INTERVAL,
    IDC_UPDATE_INTERVAL,    IDH_UPDATE_INTERVAL,
    IDC_DUPLICATE_INSTANCE, IDH_DUPLICATE_INSTANCE,
    IDC_GRAPH_TITLE,        IDH_GRAPH_TITLE,            // Graph
    IDC_YAXIS_TITLE,        IDH_YAXIS_TITLE,
    IDC_VERTICAL_GRID,      IDH_VERTICAL_GRID,
    IDC_HORIZONTAL_GRID,    IDH_HORIZONTAL_GRID,
    IDC_VERTICAL_LABELS,    IDH_VERTICAL_LABELS,
    IDC_VERTICAL_MAX,       IDH_VERTICAL_MAX,
    IDC_VERTICAL_MIN,       IDH_VERTICAL_MIN,
    IDC_SRC_REALTIME,       IDH_SRC_REALTIME,           // Source
    IDC_SRC_LOGFILE,        IDH_SRC_LOGFILE,
    IDC_SRC_SQL,            IDH_SRC_SQL,
    IDC_LIST_LOGFILENAME,   IDH_LIST_LOGFILENAME,  
    IDC_ADDFILE,            IDH_ADDFILE,
    IDC_REMOVEFILE,         IDH_REMOVEFILE,
    IDC_LOGSET_COMBO,       IDH_LOGSET_COMBO,
    IDC_DSN_COMBO,          IDH_DSN_COMBO,
    IDC_TIMESELECTBTN,      IDH_TIMESELECTBTN,
    IDC_TIMERANGE,          IDH_TIMERANGE,
    IDC_COLOROBJECTS,       IDH_COLOROBJECTS,
    IDC_FONTBUTTON,         IDH_FONTBUTTON,
    IDC_COLORBUTTON,        IDH_COLORBUTTON,
    IDC_COLORSAMPLE,        IDH_COLORSAMPLE,
    IDC_FONTSAMPLE,         IDH_FONTSAMPLE,
    0,0
};

/*
 * CSysmonPropPageFactory::CSysmonPropPageFactory
 * CSysmonPropPageFactory::~CSysmonPropPageFactory
 * CSysmonPropPageFactory::QueryInterface
 * CSysmonPropPageFactory::AddRef
 * CSysmonPropPageFactory::Release
 */

CSysmonPropPageFactory::CSysmonPropPageFactory(INT nPageID)
{
    m_cRef=0L;
    m_nPageID = nPageID;
    return;
}

CSysmonPropPageFactory::~CSysmonPropPageFactory(void)
{
    return;
}

STDMETHODIMP CSysmonPropPageFactory::QueryInterface(REFIID riid, PPVOID ppv)
{
    HRESULT hr = S_OK;

    try {
        *ppv=NULL;

        if (IID_IUnknown==riid || IID_IClassFactory==riid) {
            *ppv=this;
            AddRef();
        }
        else {
            hr = E_NOINTERFACE;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP_(ULONG) CSysmonPropPageFactory::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CSysmonPropPageFactory::Release(void)
{
    if (0!=--m_cRef)
        return m_cRef;

    delete this;
    return 0;
}



/*
 * CSysmonPropPageFactory::CreateInstance
 * CSysmonPropPageFactory::LockServer
 */

STDMETHODIMP CSysmonPropPageFactory::CreateInstance(
    IN  LPUNKNOWN pUnkOuter, 
    IN  REFIID riid, 
    OUT PPVOID ppvObj
    )
{
    PCSysmonPropPage pObj;
    HRESULT          hr = NOERROR;

    //
    // No aggregation supported
    //
    if (NULL != pUnkOuter) {
        return (CLASS_E_NOAGGREGATION);
    }

    switch (m_nPageID) {
        case GENERAL_PROPPAGE:
            pObj = new CGeneralPropPage();
            break;
        case SOURCE_PROPPAGE:
            pObj = new CSourcePropPage();
            break;
        case COUNTER_PROPPAGE:
            pObj = new CCounterPropPage();
            break;
        case GRAPH_PROPPAGE:
            pObj = new CGraphPropPage();
            break;
        case APPEAR_PROPPAGE:
            pObj = new CAppearPropPage();
            break;
        default:
            pObj = NULL;
    }

    if (NULL == pObj)
        return E_OUTOFMEMORY;


    if (pObj->Init()) {
        try {
            *ppvObj = NULL;
            hr = pObj->QueryInterface(riid, ppvObj);
        } catch (...) {
            hr = E_POINTER;
        }
    } else {
        hr = E_UNEXPECTED;
    }

    //Kill the object if initial creation or Init failed.
    if (FAILED(hr)) {
        delete pObj;
    }
    else {
        InterlockedIncrement(&g_cObj);
    }

    return hr;
}


STDMETHODIMP CSysmonPropPageFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        InterlockedIncrement(&g_cLock);
    }
    else {
        InterlockedDecrement(&g_cLock);
    }

    return NOERROR;
}



/*
 * CSysmonPropPage implementation
 */

CSysmonPropPage::CSysmonPropPage(void)
:   m_cRef ( 0 ),
    m_hDlg ( NULL ),
    m_pIPropertyPageSite ( NULL ),
    m_ppISysmon ( NULL ),
    m_cObjects ( 0 ),
    m_cx ( 300 ),   // Default width
    m_cy ( 100 ),   // Default height
    m_fDirty ( FALSE ),
    m_fActive ( FALSE ),
    m_lcid ( LOCALE_USER_DEFAULT ),
    m_dwEditControl ( 0 )
{
    return;
}

CSysmonPropPage::~CSysmonPropPage(void)
{
    if (NULL != m_hDlg)
        DestroyWindow(m_hDlg);

    FreeAllObjects();
    ReleaseInterface(m_pIPropertyPageSite);
    return;
}


/*
 * CSysmonPropPage::QueryInterface
 * CSysmonPropPage::AddRef
 * CSysmonPropPage::Release
 */

STDMETHODIMP CSysmonPropPage::QueryInterface(REFIID riid, PPVOID ppv)
{
    HRESULT hr = S_OK;

    try {
        *ppv=NULL;

        if (IID_IUnknown==riid || IID_IPropertyPage==riid) {
            *ppv=this;
            AddRef();
        }
        else {
            hr = E_NOINTERFACE;
        }
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}


STDMETHODIMP_(ULONG) CSysmonPropPage::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CSysmonPropPage::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;

    InterlockedDecrement(&g_cObj);
    delete this;
    return 0;
}


/*
 * CSysmonPropPage::Init
 *
 * Purpose:
 *  Performs initialization operations that might fail.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  BOOL            TRUE if initialization successful, FALSE
 *                  otherwise.
 */

BOOL CSysmonPropPage::Init(void)
{
    //Nothing to do
    return TRUE;
}


/*
 * CSysmonPropPage::FreeAllObjects
 *
 * Purpose:
 *  Releases all the objects from IPropertyPage::SetObjects
 *
 * Parameters:
 *  None
 */

void CSysmonPropPage::FreeAllObjects(void)
{
    UINT i;

    if (NULL==m_ppISysmon)
        return;

    for (i=0; i < m_cObjects; i++)
        ReleaseInterface(m_ppISysmon[i]);

    delete [] m_ppISysmon;
    m_ppISysmon  =NULL;
    m_cObjects = 0;
}

/*
 * CSysmonPropPage::SetChange
 *
 * Purpose:
 *  Set the page dirty flag to indicate a change
 *  If page site is active, send status change to it.
 *
 * Parameters:
 *  None
 */

void CSysmonPropPage::SetChange(void)
{
    if (m_fActive)
    {
        m_fDirty=TRUE;

        if (NULL != m_pIPropertyPageSite)
        {
            m_pIPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
        }
    }
}


/*
 * CSysmonPropPage::SetPageSite
 *
 * Purpose:
 *  Provides the property page with the IPropertyPageSite
 *  that contains it.  SetPageSite(NULL) will be called as
 *  part of the close sequence.
 *
 * Parameters:
 *  pPageSite       LPPROPERTYPAGESITE pointer to the site.
 */

STDMETHODIMP CSysmonPropPage::SetPageSite(
    LPPROPERTYPAGESITE pPageSite
    )
{
    HRESULT hr = S_OK;

    if (NULL==pPageSite)
        ReleaseInterface(m_pIPropertyPageSite)
    else
    {
        HWND  hDlg;
        RECT  rc;
        LCID  lcid;

        try {
            m_pIPropertyPageSite=pPageSite;
            m_pIPropertyPageSite->AddRef();

            if (SUCCEEDED(m_pIPropertyPageSite->GetLocaleID(&lcid)))
                m_lcid=lcid;

            /*
             * Load the dialog and determine the size it will be to
             * return through GetPageSize.  We just create the dialog
             * here and destroy it again to retrieve the size,
             * leaving Activate to create it for real.
             */

            hDlg=CreateDialogParam(g_hInstance, 
                                   MAKEINTRESOURCE(m_uIDDialog), 
                                   GetDesktopWindow(), 
                                   SysmonPropPageProc, 
                                   0L);

            //
            // If creation fails, use default values set in constructor
            // and return success status.

            if (NULL!=hDlg)
            {
                GetWindowRect(hDlg, &rc);
                m_cx=rc.right-rc.left;
                m_cy=rc.bottom-rc.top;
    
                DestroyWindow(hDlg);
            }
        } catch (...) {
            hr = E_POINTER;
        }
    }

    return hr;
}



/*
 * CSysmonPropPage::Activate
 *
 * Purpose:
 *  Instructs the property page to create a window in which to
 *  display its contents, using the given parent window and
 *  rectangle.  The window should be initially visible.
 *
 * Parameters:
 *  hWndParent      HWND of the parent window.
 *  prc             LPCRECT of the rectangle to use.
 *  fModal          BOOL indicating whether the frame is modal.
 */

STDMETHODIMP CSysmonPropPage::Activate(
    HWND hWndParent, 
    LPCRECT prc, 
    BOOL /* fModal */
    )
{
    if (NULL!=m_hDlg)
        return (E_UNEXPECTED);

    m_hDlg=CreateDialogParam(g_hInstance, 
                             MAKEINTRESOURCE(m_uIDDialog), 
                             hWndParent, 
                             SysmonPropPageProc, 
                             (LPARAM)this);

    if (NULL==m_hDlg) {
        //
        // Return E_OUTOFMEMORY because caller of Activate might not 
        // handle HRESULT_FROM_WIN32(GetLastError());
        //
        return E_OUTOFMEMORY;
    }

    if (!InitControls()) {
        return E_OUTOFMEMORY;
    }

    if (!GetProperties()) {
        return E_OUTOFMEMORY;
    }

    //
    //Move the page into position and show it.
    //
    try {
        SetWindowPos(m_hDlg, NULL, prc->left, prc->top, 0, 0, SWP_NOSIZE );
    } catch (...) {
        return E_POINTER;
    }

    m_fActive = TRUE;
    return NOERROR;
}

/*
 * CSysmonPropPage::Deactivate
 *
 * Purpose:
 *  Instructs the property page to destroy its window that was
 *  created in Activate.
 *
 * Parameters:
 *  None
 */

STDMETHODIMP CSysmonPropPage::Deactivate(void)
{
    if (NULL==m_hDlg)
        return (E_UNEXPECTED);

    DeinitControls();

    DestroyWindow(m_hDlg);
    m_hDlg=NULL;
    m_fActive = FALSE;
    return NOERROR;
}



/*
 * CSysmonPropPage::GetPageInfo
 *
 * Purpose:
 *  Fills a PROPPAGEINFO structure describing the page's size,
 *  contents, and help information.
 *
 * Parameters:
 *  pPageInfo       LPPROPPAGEINFO to the structure to fill.
 */

STDMETHODIMP CSysmonPropPage::GetPageInfo(
    LPPROPPAGEINFO pPageInfo
    )
{
    IMalloc * pIMalloc;
    LPWSTR pTitle = NULL;
    ULONG  ulTitleLen = 0;
    LPWSTR pBuf = NULL;

    pTitle = ResourceString(m_uIDTitle);

    if (pTitle) {
        ulTitleLen = wcslen(pTitle) + 1;

        if (FAILED(CoGetMalloc(MEMCTX_TASK, &pIMalloc))) {
            return (E_FAIL);
        }

        pBuf = (LPWSTR)pIMalloc->Alloc(ulTitleLen * sizeof(WCHAR));

        if (NULL != pBuf) {
            //
            // We already reserved an extra position for the null character
            //
            StringCchCopy(pBuf, ulTitleLen, pTitle);
        }

        pIMalloc->Release();
    }

    try {
        pPageInfo->size.cx      = m_cx;
        pPageInfo->size.cy      = m_cy;
        pPageInfo->pszDocString = NULL;
        pPageInfo->pszHelpFile  = NULL;
        pPageInfo->dwHelpContext= 0;
        pPageInfo->pszTitle = pBuf;
    } catch (...) {
        return E_POINTER;
    }

    return S_OK;
}



/*
 * CSysmonPropPage::SetObjects
 *
 * Purpose:
 *  Identifies the objects that are being affected by this property
 *  page (and all other pages in the frame).  These are the object
 *  to which to send new property values in the Apply member.
 *
 * Parameters:
 *  cObjects        ULONG number of objects
 *  ppUnk           IUnknown ** to the array of objects being
 *                  passed to the page.
 */

STDMETHODIMP CSysmonPropPage::SetObjects(
    IN ULONG cObjects, 
    IN IUnknown **ppUnk
    )
{
    HRESULT hr = S_OK;

    FreeAllObjects();

    if (0 != cObjects) {
        UINT i;

        m_ppISysmon = new ISystemMonitor * [(UINT)cObjects];
        if (m_ppISysmon == NULL)
            return E_OUTOFMEMORY;

        try {
            for (i=0; i < cObjects; i++)
            {
                hr=ppUnk[i]->QueryInterface(IID_ISystemMonitor, 
                                            (void **)&m_ppISysmon[i]);

                if (FAILED(hr)) {
                    break;
                }
            }
        } catch (...) {
            hr = E_POINTER;
        }
    }

    if ( FAILED ( hr ) && NULL != m_ppISysmon ) {
        //
        // Ref count never incremented, so delete the array.
        //
        delete [] m_ppISysmon;
        m_ppISysmon = NULL;
    }

    
    if ( SUCCEEDED ( hr ) ) {
        m_cObjects=cObjects;
    }

    return hr;
}



/*
 * CSysmonPropPage::Show
 *
 * Purpose:
 *  Instructs the page to show or hide its window created in
 *  Activate.
 *
 * Parameters:
 *  nCmdShow        UINT to pass to ShowWindow.
 */

STDMETHODIMP CSysmonPropPage::Show(UINT nCmdShow)
{
    if (NULL==m_hDlg)
        (E_UNEXPECTED);

    ShowWindow(m_hDlg, nCmdShow);

    // If showing page
    if (SW_SHOWNORMAL==nCmdShow || SW_SHOW==nCmdShow) {

        // Take the focus
        // (Have to delay so it isn't taken back)
        PostMessage(m_hDlg,WM_SETPAGEFOCUS,0,0);
    }
    
    return NOERROR;
}

/*
 * CSysmonPropPage::Move
 *
 * Purpose:
 *  Instructs the property page to change its position.
 *
 * Parameters:
 *  prc             LPCRECT containing the new position.
 */

STDMETHODIMP CSysmonPropPage::Move(
    LPCRECT prc
    )
{
    HRESULT hr = S_OK;

    try {
        SetWindowPos(m_hDlg, NULL, prc->left, prc->top, 0, 0, SWP_NOSIZE );
    } catch (...) {
        hr = E_POINTER;
    }

    return hr;
}



/*
 * CSysmonPropPage::IsPageDirty
 *
 * Purpose:
 *  Asks the page if anything's changed in it, that is, if the
 *  property values in the page are out of sync with the objects
 *  under consideration.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if dirty, S_FALSE if not.
 */

STDMETHODIMP CSysmonPropPage::IsPageDirty(void)
{
    return (m_fDirty ? S_OK : S_FALSE);
}


/*
 * CSysmonPropPage::Apply
 *
 * Purpose:
 *  Instructs the page to send changes in its page to whatever
 *  objects it knows about through SetObjects.  This is the only
 *  time the page should change the objects' properties, and not
 *  when the value is changed on the page.
 *
 * Parameters:
 *  None
 */

STDMETHODIMP CSysmonPropPage::Apply(void)
{
    HRESULT hr = NOERROR;

    if ( 0 != m_cObjects ) {

        // Kill the focus in case a text field has it. This will trigger
        // the entry processing code.
        SetFocus(NULL);

        { 
            CWaitCursor cursorWait;

            if (SetProperties()) {
                m_fDirty = FALSE;
            } else {
                hr = E_FAIL;
            }
        }
    }
    return hr;
}

/*
 * CSysmonPropPage::Help
 *
 * Purpose:
 *  Invokes help for this property page when the user presses
 *  the Help button.  If you return NULLs for the help file
 *  in GetPageInfo, the button will be grayed.  Otherwise the
 *  page can perform its own help here.
 *
 * Parameters:
 *  pszHelpDir      LPCOLESTR identifying the default location of
 *                  the help information
 *
 * Return Value:
 *  HRESULT         NOERROR to tell the frame that we've done our
 *                  own help.  Returning an error code or S_FALSE
 *                  causes the frame to use any help information
 *                  in PROPPAGEINFO.
 */

STDMETHODIMP CSysmonPropPage::Help(LPCOLESTR /* pszHelpDir */ )
{
    /*
     * We can either provide help ourselves, or rely on the
     * information in PROPPAGEINFO.
     */
    return (S_FALSE);
}


/*
 * CSysmonPropPage::TranslateAccelerator
 *
 * Purpose:
 *  Provides the page with the messages that occur in the frame.
 *  This gives the page to do whatever it wants with the message,
 *  such as handle keyboard mnemonics.
 *
 * Parameters:
 *  pMsg            LPMSG containing the keyboard message.
 */

STDMETHODIMP CSysmonPropPage::TranslateAccelerator(LPMSG lpMsg)
{
    BOOL fTakeIt = TRUE;
    BOOL fHandled = FALSE;
    HRESULT hr;

    HWND hwnd;
    
    if (lpMsg == NULL)
        return E_POINTER;    
    
    // If TAB key
    if (lpMsg->message == WM_KEYDOWN ) {
        if ( lpMsg->wParam == VK_TAB 
            && GetKeyState(VK_CONTROL) >= 0) {

            UINT uDir = GetKeyState(VK_SHIFT) >= 0 ? GW_HWNDNEXT : GW_HWNDPREV;

            hwnd = GetFocus();

            if (IsChild(m_hDlg, hwnd)) {

                // Get top level child for controls with children, like combo.
                while (GetParent(hwnd) != m_hDlg) hwnd = GetParent(hwnd);

                // If this control is the last enabled tab stop, don't steal the TAB key
                do {
                    hwnd = GetWindow(hwnd, uDir);
                    if ( NULL == hwnd ) {
                        fTakeIt = FALSE;
                        break;
                    }
                }
                while ((GetWindowLong(hwnd, GWL_STYLE) & (WS_DISABLED | WS_TABSTOP)) != WS_TABSTOP);
            }
        }

/*
    fTakeIt is already TRUE.
    // else if Arrow key
    else if ( lpMsg->message == WM_KEYDOWN && 
             ( lpMsg->wParam == VK_LEFT || lpMsg->wParam == VK_UP
                || lpMsg->wParam == VK_RIGHT || lpMsg->wParam == VK_DOWN ) ) {
        
        fTakeIt = TRUE;
    }
*/        

        // else if Return or Escape key
        else if ( lpMsg->wParam == VK_RETURN || lpMsg->wParam == VK_ESCAPE ) {

            fTakeIt = (lpMsg->wParam == VK_RETURN);             

            if ( fTakeIt ) {

                hwnd = GetFocus(); 

                if ( NULL == hwnd ) {
                    fTakeIt = FALSE;
                } else {
                    fTakeIt = IsChild(m_hDlg, hwnd);
                
                    if ( fTakeIt ) {
                        fTakeIt = (BOOL) SendMessage(hwnd, WM_GETDLGCODE, 0, 0) & DLGC_DEFPUSHBUTTON;
                    }
                } 
            }
        }
    } else if ( ( WM_KEYUP == lpMsg->message ) ) {
        fTakeIt = FALSE;
    }

    // if we should process the key
    if (fTakeIt) {

        // if the target is not one of our controls, change it so IsDialogMessage works
        if (!IsChild(m_hDlg, lpMsg->hwnd)) {
            hwnd = lpMsg->hwnd;
            lpMsg->hwnd = GetWindow(m_hDlg, GW_CHILD);
            fHandled = IsDialogMessage(m_hDlg, lpMsg);
            lpMsg->hwnd = hwnd;
        }
        else {
            fHandled = IsDialogMessage(m_hDlg, lpMsg);
        }
    }

    if (fHandled){
        return S_OK;
    } else{
        hr = m_pIPropertyPageSite->TranslateAccelerator(lpMsg);
    }

    return hr;
}

/*
 * CSysmonPropPage::EditProperty
 *
 * Purpose:
 *  Sets focus to the control corresponding to the supplied DISPID.
 *
 * Parameters:
 *  dispID            DISPID of the property
 */

STDMETHODIMP CSysmonPropPage::EditProperty(DISPID dispID)
{
    HRESULT hr;

    hr = EditPropertyImpl ( dispID );

    if ( SUCCEEDED(hr)) {
        SetFocus ( GetDlgItem ( m_hDlg, m_dwEditControl ) );
        m_dwEditControl = 0;
    }
    
    return hr;
}

/*
 * CSysmonPropPage::WndProc
 *
 * Purpose:
 *  This is a default message processor that can be overriden by 
 *  a subclass to provide special message handling.
 *
 * Parameters:
 *  pMsg            LPMSG containing the keyboard message.
 */
BOOL 
CSysmonPropPage::WndProc (
    UINT, // uMsg, 
    WPARAM, // wParam,
    LPARAM // lParam
    )
{
    return FALSE;
}


/*
 * SysmonPropPageProc
 *
 * Purpose:
 *  Dialog procedure for the Sysmon Property Page.
 */
INT_PTR APIENTRY CALLBACK
SysmonPropPageProc(
    HWND hDlg, 
    UINT iMsg,
    WPARAM wParam, 
    LPARAM lParam
    )
{
    static WCHAR  szObj[] = L"Object";

    PCSysmonPropPage    pObj = NULL;
    PMEASUREITEMSTRUCT  pMI;
    HWND hwndTabCtrl;
    HWND hwndPropSheet;
    INT  iCtrlID;
    WCHAR pszHelpFilePath[MAX_PATH * 2];
    LPHELPINFO pInfo;
    UINT nLen;
    BOOL bReturn = FALSE;

    if ( NULL != hDlg ) {
        pObj = (PCSysmonPropPage)GetProp(hDlg, szObj);
    }

    switch (iMsg) {
        case WM_INITDIALOG:

            pObj=(PCSysmonPropPage)lParam;

            if ( NULL != pObj && NULL != hDlg ) {
                SetProp(hDlg, szObj, (HANDLE)lParam);
                hwndTabCtrl = ::GetParent(hDlg);
                hwndPropSheet = ::GetParent(hwndTabCtrl);
                SetWindowLongPtr(hwndPropSheet,
                                 GWL_EXSTYLE,
                                 GetWindowLongPtr(hwndPropSheet,GWL_EXSTYLE)|WS_EX_CONTEXTHELP);    
            }
            bReturn = TRUE;
            break;

        case WM_DESTROY:
            if ( NULL != hDlg ) {
                RemoveProp(hDlg, szObj);
            }
            bReturn = TRUE;
            break;

        case WM_MEASUREITEM:
            pMI = (PMEASUREITEMSTRUCT)lParam;
            if ( NULL != pMI ) {
                pMI->itemWidth  = 0 ;
                pMI->itemHeight = 16;
            }
            bReturn = TRUE;
            break;
 
        case WM_DRAWITEM:
            if ( NULL != pObj ) {
                pObj->DrawItem ((PDRAWITEMSTRUCT) lParam) ;
            }
            bReturn = TRUE;
            break;

        case WM_COMMAND:
            if ( NULL != pObj ) {
                pObj->DialogItemChange(LOWORD(wParam), HIWORD(wParam));
            }
            bReturn = FALSE;
            break;
        
        case WM_SETPAGEFOCUS:
            if ( NULL != hDlg ) {
                SetFocus(hDlg);            
                bReturn = TRUE;
            }
            break;

        case WM_CONTEXTMENU:

            if ( NULL != (HWND) wParam ) {
                iCtrlID = GetDlgCtrlID ( (HWND) wParam );

                if ( 0 != iCtrlID ) {

                    nLen = ::GetWindowsDirectory(pszHelpFilePath, 2*MAX_PATH);
                
                    if ( 0 < nLen ) {
                        StringCchCat(pszHelpFilePath, 2* MAX_PATH, L"\\help\\sysmon.hlp" );


                        bReturn = WinHelp(
                                    (HWND) wParam,
                                    pszHelpFilePath,
                                    HELP_CONTEXTMENU,
                                    (DWORD_PTR) aulControlIdToHelpIdMap);
                    }
                }
            }
            // bReturn is FALSE by default
            break;

        case WM_HELP:
                  
            if ( NULL != hDlg ) {
                pInfo = (LPHELPINFO)lParam;

                if ( NULL != pInfo ) {
                    // Only display help for known context IDs.
                    if ( 0 != pInfo->dwContextId ) {

                        nLen = ::GetWindowsDirectory(pszHelpFilePath, 2*MAX_PATH);
                        if ( 0 < nLen ) {
                            StringCchCat(pszHelpFilePath, 2* MAX_PATH, L"\\help\\sysmon.hlp" );
                            bReturn = WinHelp ( 
                                        hDlg, 
                                        pszHelpFilePath, 
                                        HELP_CONTEXTPOPUP, 
                                        pInfo->dwContextId );
                        }
                    }
                }
            }
            // bReturn is FALSE by default
            break;

        default:
            if ( NULL != pObj ) {
                bReturn = pObj->WndProc(iMsg, wParam, lParam);
            }
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\snapbar.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    snapbar.cpp

Abstract:

    Implementation of the snapshot icon.

--*/

#include <windows.h>
#include "snapbar.h"
#include "resource.h"

#define SNAPBTN_HEIGHT 24
#define SNAPBTN_WIDTH  32
#define SNAPBTN_VMARGIN 1
#define SNAPBTN_HMARGIN 8

#define SNAPBAR_HEIGHT (SNAPBTN_HEIGHT + 2 * SNAPBTN_VMARGIN)
#define SNAPBAR_WIDTH (SNAPBTN_WIDTH + SNAPBTN_HMARGIN)

CSnapBar::CSnapBar (
    VOID
    )
{
    m_hWnd = NULL;
    m_hBitmap = NULL;
}

CSnapBar::~CSnapBar (
    VOID
    )
{
    if (m_hWnd != NULL && IsWindow(m_hWnd))
        DestroyWindow(m_hWnd);

    if (m_hBitmap != NULL)
        DeleteObject(m_hBitmap);
}

BOOL
CSnapBar::Init (
    IN CSysmonControl *pCtrl,
    IN HWND hWndParent
    )
{
    HINSTANCE hInst;
    
    m_pCtrl = pCtrl;

    hInst = (HINSTANCE) GetWindowLongPtr(hWndParent, GWLP_HINSTANCE);

    // Create the button window
    m_hWnd = CreateWindow(L"BUTTON", NULL,
                          WS_VISIBLE| WS_CHILD| BS_BITMAP| BS_PUSHBUTTON,
                          0, 0, SNAPBTN_WIDTH, SNAPBTN_HEIGHT,
                          hWndParent,
                          (HMENU)IDC_SNAPBTN,
                          hInst,
                          NULL);
    if (m_hWnd == NULL)
        return FALSE;

    // Point back to object
    //SetWindowLongPtr(m_hWnd, 0, (INT_PTR)this);

    // Insert our own window procedure for special processing
    //m_WndProc = (WNDPROC)SetWindowLongPtr(hWndParent, GWLP_WNDPROC, (INT_PTR)SnapBarWndProc);
     
    // Load the bitmap
    m_hBitmap = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_SNAPBTN));

    if (m_hBitmap == NULL)
        return FALSE;
    
    // Assign it to the button
    SendMessage(m_hWnd, BM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)m_hBitmap);

    return TRUE;
}


INT
CSnapBar::Height (
    IN INT iMaxHeight
    )
{
    return (iMaxHeight >= SNAPBAR_HEIGHT) ? SNAPBAR_HEIGHT : 0;
}


VOID
CSnapBar::SizeComponents (
    IN LPRECT pRect
    )
{
    // If room for the button
    if ((pRect->bottom - pRect->top) >= SNAPBAR_HEIGHT &&
        (pRect->right - pRect->left) >= SNAPBAR_WIDTH ) {

        // Position it in top right corner of space
        MoveWindow(m_hWnd, pRect->right - SNAPBAR_WIDTH, 
                    pRect->top + SNAPBTN_VMARGIN, SNAPBTN_WIDTH, SNAPBTN_HEIGHT, 
                    FALSE); 
        ShowWindow(m_hWnd, TRUE);
    }
    else {
        ShowWindow(m_hWnd, FALSE);
    }
}


LRESULT CALLBACK 
SnapBarWndProc (
    HWND hWnd,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PSNAPBAR pObj = (PSNAPBAR)GetWindowLongPtr(hWnd,0);

    // Give up focus after mouse activation
    if (uiMsg == WM_CAPTURECHANGED)
        SetFocus(GetParent(hWnd));

    // Do normal processing
#ifdef STRICT
    return CallWindowProc(pObj->m_WndProc, hWnd, uiMsg, wParam, lParam);
#else
    return CallWindowProc((FARPROC)pObj->m_WndProc, hWnd, uiMsg, wParam, lParam);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\statbar.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    statbar.cpp

Abstract:

    Implementation of the value bar class.

--*/

#include "polyline.h"
#include <strsafe.h>
#include "winhelpr.h"
#include "grphitem.h"
#include "statbar.h"

#define MAX_STAT_LABEL_LEN 32
#define INVALID_VALUE (-1.0)
#define szDashLine L"--------- "

//
// ??? Why do we put these outside of the class ???
//
static WCHAR    aszItemLabel[STAT_ITEM_CNT][MAX_STAT_LABEL_LEN];

static BOOLEAN  fInitDone = FALSE;

CStatsBar::CStatsBar(void)
:   m_pCtrl ( NULL ),
    m_iFontHeight ( 0 ),
    m_iValueWidth ( 0 ),
    m_pGraphItemToInit ( NULL )
{
    memset (&m_Rect, 0, sizeof(m_Rect));
}

CStatsBar::~CStatsBar(void)
{
}

BOOL CStatsBar::Init (
    PSYSMONCTRL pCtrl, 
    HWND /* hWnd */ 
    )
{
    INT i;

    // save pointer to primary object
    m_pCtrl = pCtrl;

    // First time through, load the item labels
    if (!fInitDone) {
        fInitDone = TRUE;

        for (i = 0; i < STAT_ITEM_CNT; i++) {
            LoadString(g_hInstance, (IDS_STAT_BASE + i), aszItemLabel[i], MAX_STAT_LABEL_LEN);
        }
    }

    // Initialze the stat values
    Clear();

    return TRUE;
}

        
void CStatsBar::SizeComponents(LPRECT pRect)
{
    // Just save the rectangle
    m_Rect = *pRect;
}

void CStatsBar::SetTimeSpan(double dSeconds)
{
    m_StatItem[STAT_TIME].dNewValue = dSeconds;
}

    
void CStatsBar::Update(HDC hDC, PCGraphItem pGraphItem)
{
    double dMin, dMax, dAvg, dVal;
    PSTAT_ITEM  pItem;
    HRESULT hr;
    PDH_STATUS  stat;
    LONG  lCtrStat;
    INT   i;

    // if no space assigned, return
    if (m_Rect.top == m_Rect.bottom) {
        m_pGraphItemToInit = pGraphItem;
        m_StatItem[0].iInitialized = 0;
        return;
    }

    if (pGraphItem == NULL) {
        m_pGraphItemToInit = NULL;
        pItem = &m_StatItem[0];
        for (i=0; i<STAT_ITEM_CNT-1; i++, pItem++) {
            pItem->dNewValue = INVALID_VALUE;
            pItem->iInitialized = 0;
        }
    } else {

        stat = pGraphItem->GetValue(&dVal, &lCtrStat);
        if (stat == 0 && IsSuccessSeverity(lCtrStat))
            m_StatItem[STAT_LAST].dNewValue = dVal;
        else
            m_StatItem[STAT_LAST].dNewValue = INVALID_VALUE;
            
        hr = pGraphItem->GetStatistics(&dMax, &dMin, &dAvg, &lCtrStat);
        if (SUCCEEDED(hr) && IsSuccessSeverity(lCtrStat)) {
            m_StatItem[STAT_MIN].dNewValue = dMin;
            m_StatItem[STAT_MAX].dNewValue = dMax;
            m_StatItem[STAT_AVG].dNewValue = dAvg;
        } else {
            m_StatItem[STAT_MIN].dNewValue = INVALID_VALUE;
            m_StatItem[STAT_MAX].dNewValue = INVALID_VALUE;
            m_StatItem[STAT_AVG].dNewValue = INVALID_VALUE;
        }
        m_StatItem[0].dwCounterType = pGraphItem->m_CounterInfo.dwType;
        m_StatItem[0].iInitialized = 1;
    }

    // hDC is null if updating only values.
    if (hDC != NULL) {
        SetBkColor(hDC, m_pCtrl->clrBackCtl());
        SetTextColor(hDC, m_pCtrl->clrFgnd());
        DrawValues(hDC,FALSE);
    }
}       

void CStatsBar::Clear( void )
{
    INT i;

    for (i = 0; i < STAT_ITEM_CNT-1; i++) {
        m_StatItem[i].dValue = INVALID_VALUE;
        m_StatItem[i].dNewValue = INVALID_VALUE;
        m_StatItem[i].iInitialized = 0;
    }
}       

void CStatsBar::Draw (HDC hDC, HDC /* hAttribDC */, PRECT prcUpdate)
{
    RECT    rectFrame;
    PSTAT_ITEM  pItem;
    HFONT   hFontOld;
    INT     i;
    RECT    rectPaint;
    RECT    rectClip;

    // if no space assigned, return
    if (m_Rect.top == m_Rect.bottom)
        return;

    // if no painting needed, return
    if (!IntersectRect(&rectPaint, &m_Rect, prcUpdate))
        return;

    SetBkMode(hDC, TRANSPARENT);
    SetTextColor(hDC, m_pCtrl->clrFgnd());
    SetTextAlign(hDC, TA_LEFT|TA_TOP);

    hFontOld = SelectFont(hDC, m_pCtrl->Font());

    pItem = &m_StatItem[0];

    // If the stat bar was hidden on Update, for example if 
    // the control was loaded from a property bag, or if a 
    // counter was selected while the stat bar was hidden,
    // initialize it here.
    if ( 0 == pItem->iInitialized ) {
        Update ( NULL, m_pGraphItemToInit );
    }

    // Draw Label and 3D box for each item
    for (i=0; i<STAT_ITEM_CNT; i++, pItem++) {

        rectClip.top = m_Rect.top + pItem->yPos + RECT_BORDER;
        rectClip.bottom = rectClip.top + m_iFontHeight;
        rectClip.left = m_Rect.left + pItem->xPos;
        rectClip.right = rectClip.left + pItem->xLabelWidth;

        ExtTextOut(
            hDC, 
            m_Rect.left + pItem->xPos, 
            m_Rect.top + pItem->yPos + RECT_BORDER,
            0,
            &rectClip,
            aszItemLabel[i], 
            lstrlen(aszItemLabel[i]),
            NULL );
                 
        if ( eAppear3D == m_pCtrl->Appearance() ) {
            rectFrame.left = m_Rect.left + pItem->xPos + pItem->xLabelWidth + VALUE_MARGIN;
            rectFrame.right = rectFrame.left + m_iValueWidth + 2 * RECT_BORDER;
            rectFrame.top = m_Rect.top + pItem->yPos;
            rectFrame.bottom = rectFrame.top + m_iFontHeight + 2 * RECT_BORDER;
            DrawEdge(hDC, &rectFrame, BDR_SUNKENOUTER, BF_RECT);
        }
    }

    SelectFont(hDC, hFontOld);

    SetBkMode(hDC, OPAQUE);
    SetBkColor(hDC, m_pCtrl->clrBackCtl());
    DrawValues(hDC, TRUE);
}


void CStatsBar::DrawValues(HDC hDC, BOOL bForce)
{
    RECT    rectValue ;
    WCHAR   szValue [MAX_VALUE_LEN] ;
    HFONT   hFontOld;
    PSTAT_ITEM  pItem = NULL;
    INT     i;
    INT     nSecs, nMins, nHours, nDays;

    SetTextAlign(hDC, TA_RIGHT | TA_TOP);
    hFontOld = SelectFont(hDC, m_pCtrl->Font());

    pItem = &m_StatItem[0];

    for (i=0; i<STAT_ITEM_CNT; i++,pItem++) {

        if ( NULL == pItem ) 
            continue;
        
        if ((pItem->dValue == pItem->dNewValue) && !bForce)
            continue;

        pItem->dValue = pItem->dNewValue;

        rectValue.top = m_Rect.top + pItem->yPos + RECT_BORDER;
        rectValue.bottom = rectValue.top + m_iFontHeight;
        rectValue.left = m_Rect.left + pItem->xPos + pItem->xLabelWidth + VALUE_MARGIN + RECT_BORDER;
        rectValue.right = rectValue.left + m_iValueWidth - 1;

        if (i == STAT_TIME) {
            LPWSTR  pszTimeSep = NULL;

            pszTimeSep = GetTimeSeparator ( );

            nSecs = (INT)pItem->dValue;

            nMins = nSecs / 60;
            nSecs -= nMins * 60;

            nHours = nMins / 60;
            nMins -= nHours * 60;

            nDays = nHours / 24;
            nHours -= nDays * 24;

            if (nDays != 0) {
                StringCchPrintf(szValue, MAX_VALUE_LEN, SZ_DAYTIME_FORMAT, nDays, nHours, pszTimeSep, nMins);
            } else {
                if (nHours != 0)
                    StringCchPrintf(szValue, MAX_VALUE_LEN, SZ_HRTIME_FORMAT, nHours, pszTimeSep, nMins, pszTimeSep, nSecs);
                else
                    StringCchPrintf(szValue, MAX_VALUE_LEN, SZ_MINTIME_FORMAT, nMins, pszTimeSep, nSecs);
            }
        } else {

            if ( INVALID_VALUE == pItem->dValue ) { 
                StringCchCopy ( szValue, MAX_VALUE_LEN, szDashLine );
            } else if (pItem->dValue > E_MEDIUM_VALUE) {
                if (pItem->dValue > E_TOO_LARGE_VALUE) {
                    StringCchCopy(szValue, MAX_VALUE_LEN, SZ_VALUE_TOO_HIGH) ;
                } else {

                    if ( pItem->dValue <= E_LARGE_VALUE ) {

                        FormatNumber (
                            pItem->dValue,
                            szValue,
                            MAX_VALUE_LEN,
                            eMinimumWidth,
                            eMediumPrecision );

                    } else {

                        FormatScientific (
                            pItem->dValue,
                            szValue,
                            MAX_VALUE_LEN,
                            eMinimumWidth,
                            eLargePrecision );
                    }
                }

            } else if (pItem->dValue < -E_MEDIUM_VALUE) {
                if (pItem->dValue < -E_TOO_LARGE_VALUE) {
                    StringCchCopy(szValue, MAX_VALUE_LEN, SZ_VALUE_TOO_LOW) ;
                } else {
                    if ( pItem->dValue >= -E_LARGE_VALUE ) {
                        FormatNumber (
                            pItem->dValue,
                            szValue,
                            MAX_VALUE_LEN,
                            eMinimumWidth,
                            eMediumPrecision );
                    } else {
                        FormatScientific (
                            pItem->dValue,
                            szValue,
                            MAX_VALUE_LEN,
                            eMinimumWidth,
                            eLargePrecision );
                    }
                }
            } else {
                if ( ( m_StatItem[0].dwCounterType & 
                        ( PERF_TYPE_COUNTER | PERF_TYPE_TEXT ) ) ) {
                    FormatNumber (
                        pItem->dValue,
                        szValue,
                        MAX_VALUE_LEN,
                        eMinimumWidth,
                        eSmallPrecision );
                } else {
                    FormatNumber (
                        pItem->dValue,
                        szValue,
                        MAX_VALUE_LEN,
                        eMinimumWidth,
                        eIntegerPrecision );
                }
            }
        }

        //          TextOut (hDC, rectValue.right, rectValue.top, szValue, lstrlen (szValue)) ;

        ExtTextOut (hDC, rectValue.right, rectValue.top, ETO_OPAQUE, &rectValue,
                     szValue, lstrlen (szValue), NULL) ;
    }

    SelectFont(hDC, hFontOld);
}



INT  CStatsBar::Height (INT iMaxHeight, INT iMaxWidth)
{
    INT iHeight;
    INT xPos,yPos;
    PSTAT_ITEM  pItem;
    INT  i,j;
    INT  iItemWidth;
    INT  iFirst;
    INT  iRemainder;

    iMaxWidth -= 2 * RECT_BORDER;
    xPos = 0;
    yPos = 0;
    iFirst = 0;
    pItem = &m_StatItem[0];

    for (i=0; i<STAT_ITEM_CNT; i++,pItem++) {

        iItemWidth = pItem->xLabelWidth + VALUE_MARGIN + m_iValueWidth;
        if (iItemWidth > iMaxWidth)
            return 0;

        if (xPos + iItemWidth > iMaxWidth) {
            iRemainder = iMaxWidth - xPos + LABEL_MARGIN;
            xPos = 0;
            yPos += m_iFontHeight + LINE_SPACING;

            for (j=iFirst; j<i; j++) {
                m_StatItem[j].xPos += iRemainder;
            }
            iFirst = i;
        }

        pItem->xPos = xPos;
        pItem->yPos = yPos;
        xPos += (iItemWidth + LABEL_MARGIN);
    }

    iRemainder = (iMaxWidth - xPos) + LABEL_MARGIN;
    for (j=iFirst; j<STAT_ITEM_CNT; j++) {
        m_StatItem[j].xPos += iRemainder;
    }

    // if allowed height is not enough, return zero
    iHeight = yPos + m_iFontHeight + 2 * RECT_BORDER;

    return (iHeight <= iMaxHeight) ? iHeight : 0;
}



void CStatsBar::ChangeFont(
    HDC hDC
    )
{
    INT         xPos,yPos;
    WCHAR       szValue[MAX_VALUE_LEN];
    HFONT       hFontOld;
    PSTAT_ITEM  pItem;
    INT         i;
    SIZE        size;

    hFontOld = (HFONT)SelectFont(hDC, m_pCtrl->Font());

    // Get width/height of longest value string
    FormatNumber (
        E_LARGE_VALUE,
        szValue,
        MAX_VALUE_LEN,
        eMinimumWidth,
        eLargePrecision );

    GetTextExtentPoint32(hDC, szValue, lstrlen(szValue), &size);  
    m_iValueWidth = size.cx;
    m_iFontHeight = size.cy;

    // Do for all stat items
    xPos = 0;
    yPos = 0;
    pItem = &m_StatItem[0];

    for (i=0; i<STAT_ITEM_CNT; i++,pItem++) {
        if ( NULL != pItem ) {
            pItem->xLabelWidth = TextWidth(hDC, aszItemLabel[i]);
        }
    }

    SelectFont(hDC, hFontOld);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\srcprop.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    srcprop.cpp

Abstract:

    Implementation of the source property page.

--*/

#include "polyline.h"
#include <limits.h>
#include <strsafe.h>
#include <assert.h>
#include <sql.h>
#include <pdhmsg.h>
#include <pdhp.h>
#include "utils.h"
#include "smonmsg.h"
#include "unihelpr.h"
#include "winhelpr.h"
#include "odbcinst.h"
#include "smonid.h"
#include "srcprop.h"



CSourcePropPage::CSourcePropPage()
:   m_pTimeRange ( NULL ),
    m_eDataSourceType ( sysmonCurrentActivity ),
    m_hDataSource(H_REALTIME_DATASOURCE),
    m_pInfoDeleted ( NULL ),
    m_bLogFileChg ( FALSE ),
    m_bSqlDsnChg ( FALSE ),
    m_bSqlLogSetChg ( FALSE ),
    m_bRangeChg ( FALSE ),
    m_bDataSourceChg ( FALSE )
{
    m_uIDDialog = IDD_SRC_PROPP_DLG;
    m_uIDTitle = IDS_SRC_PROPP_TITLE;
    m_szSqlDsnName[0] = L'\0';
    m_szSqlLogSetName[0] = L'\0';
}

CSourcePropPage::~CSourcePropPage(
    void
    )
{
    return;
}

/*
 * CSourcePropPage::Init
 *
 * Purpose:
 *  Performs initialization operations that might fail.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  BOOL            TRUE if initialization successful, FALSE
 *                  otherwise.
 */

BOOL 
CSourcePropPage::Init(void)
{
    BOOL bResult;

    bResult = RegisterTimeRangeClass();

    return bResult;
}

BOOL
CSourcePropPage::InitControls ( void )
{
    BOOL    bResult = FALSE;
    HWND    hwndTimeRange;
    
    // create time range object attached to dialog control
    
    hwndTimeRange = GetDlgItem(m_hDlg, IDC_TIMERANGE);

    if ( NULL != hwndTimeRange ) {

        m_pTimeRange = new CTimeRange(hwndTimeRange);
        if (m_pTimeRange) {
            bResult = m_pTimeRange->Init();
            if ( FALSE == bResult ) {
                delete m_pTimeRange;
                m_pTimeRange = NULL;
            }
        }
    }
    return bResult;
}

void
CSourcePropPage::DeinitControls ( void )
{
    HWND    hwndLogFileList = NULL;
    INT     iIndex;
    INT     iLogFileCnt = 0;;
    PLogItemInfo    pInfo = NULL;

    ISystemMonitor  *pObj;
    CImpISystemMonitor *pPrivObj;

    pObj = m_ppISysmon[0];  
    pPrivObj = (CImpISystemMonitor*)pObj;
    // Hide the log view start and stop bars on the graph
    pPrivObj->SetLogViewTempRange( MIN_TIME_VALUE, MAX_TIME_VALUE );

    // delete time range object attached to dialog control
    if (m_pTimeRange != NULL) {
        delete m_pTimeRange;
        m_pTimeRange = NULL;
    }

    hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
    if ( NULL != hwndLogFileList ) {
        iLogFileCnt = LBNumItems(hwndLogFileList);
        for (iIndex = 0; iIndex < iLogFileCnt; iIndex++ ) {
            pInfo = (PLogItemInfo)LBData(hwndLogFileList,iIndex);
            if ( NULL != pInfo ) {
                if ( NULL != pInfo->pItem ) {
                    pInfo->pItem->Release();
                }
                if (NULL != pInfo->pszPath ) {
                    delete [] pInfo->pszPath;
                }
                delete pInfo;
            }
        }
    }
    return;
}

/*
 * CSourcePropPage::GetProperties
 * 
 */

BOOL CSourcePropPage::GetProperties(void)
{
    BOOL    bReturn = TRUE;
    DWORD   dwStatus = ERROR_SUCCESS;
    ISystemMonitor  *pObj = NULL;
    CImpISystemMonitor *pPrivObj = NULL;
    BSTR    bstrPath;
    DATE    date;

    LPWSTR  szLogFileList   = NULL;
    ULONG   ulLogListBufLen = 0;
    BOOL    bIsValidLogFile = FALSE;
    BOOL    bIsValidLogFileRange = TRUE;
    ILogFileItem    *pItem = NULL;
    PLogItemInfo    pInfo = NULL;
    BSTR            bstrTemp     = NULL;
    INT     iLogFile = 0;
    INT     iIndex = 0;
    INT     nChar = 0;

    if (m_cObjects == 0) {
        bReturn = FALSE;
    } else {
        pObj = m_ppISysmon[0];

        // Get pointer to actual object for internal methods
        pPrivObj = (CImpISystemMonitor*)pObj;
    }

    if ( NULL == pObj || NULL == pPrivObj ) {
        bReturn = FALSE;
    } else {
        
        // Set the data source type
        pObj->get_DataSourceType (&m_eDataSourceType);

        CheckRadioButton(
                m_hDlg, IDC_SRC_REALTIME, IDC_SRC_SQL,
                IDC_SRC_REALTIME + m_eDataSourceType - 1);

        SetSourceControlStates();

        while (SUCCEEDED(pPrivObj->LogFile(iLogFile, &pItem))) {

            // Create LogItemInfo to hold the log file item and path
            pInfo = new LogItemInfo;

            if ( NULL == pInfo ) {
                bReturn = FALSE;
                break;
            }

            ZeroMemory ( pInfo, sizeof(LogItemInfo) );
            
            pInfo->pItem = pItem;
            if ( FAILED ( pItem->get_Path( &bstrPath ) ) ) {
                bReturn = FALSE;
                delete pInfo;
                break;
            } else {
                nChar = lstrlen(bstrPath) + 1;
                pInfo->pszPath = new WCHAR [nChar];

                if ( NULL == pInfo->pszPath ) {
                    delete pInfo;
                    SysFreeString(bstrPath);
                    bReturn = FALSE;
                    break;
                }
                StringCchCopy(pInfo->pszPath, nChar, bstrPath);
                SysFreeString(bstrPath);

            }
            // Add the log file name to the list box
            iIndex = AddItemToFileListBox(pInfo);
    
            if ( LB_ERR == iIndex ) {
                bReturn = FALSE;
                delete [] pInfo->pszPath;
                delete pInfo;                
                break;
            }

            iLogFile++;
        } 

        // Get SQL DSN name, populate list box.
        pObj->get_SqlDsnName(&bstrTemp);
        memset ( m_szSqlDsnName, 0, sizeof (m_szSqlDsnName) );
    
        if ( NULL != bstrTemp ) { 
            if ( bstrTemp[0] != L'\0' ) {
                lstrcpyn ( 
                    m_szSqlDsnName, 
                    bstrTemp, min(SQL_MAX_DSN_LENGTH + 1, lstrlen (bstrTemp)+1) );
            }
            SysFreeString (bstrTemp);
            bstrTemp = NULL;
        }
        InitSqlDsnList();

        // Get SQL log set name, populate list box.
        pObj->get_SqlLogSetName(&bstrTemp);
        memset ( m_szSqlLogSetName, 0, sizeof (m_szSqlLogSetName) );
    
        if ( NULL != bstrTemp ) { 
            if ( bstrTemp[0] != L'\0' ) {
                lstrcpyn ( 
                    m_szSqlLogSetName, 
                    bstrTemp, min(SLQ_MAX_LOG_SET_NAME_LEN+1, lstrlen (bstrTemp)+1) );
            }
            SysFreeString (bstrTemp);
        }
        InitSqlLogSetList();

        if ( m_eDataSourceType == sysmonLogFiles
            || m_eDataSourceType == sysmonSqlLog) {

            pPrivObj->GetLogFileRange(&m_llBegin, &m_llEnd);
            m_pTimeRange->SetBeginEnd(m_llBegin, m_llEnd);

            pObj->get_LogViewStart(&date);
            VariantDateToLLTime(date, &m_llStart);

            pObj->get_LogViewStop(&date);
            VariantDateToLLTime(date, &m_llStop);

            m_pTimeRange->SetStartStop(m_llStart, m_llStop);

            // OpenLogFile sets BeginEnd, StartStop values in the 
            // time range control, if the file and range are valid.
            dwStatus = OpenLogFile ();

            if ( ERROR_SUCCESS == dwStatus ) {
                bIsValidLogFile = TRUE;
                bIsValidLogFileRange = TRUE;
            } else {

                bIsValidLogFile = FALSE;
                bIsValidLogFileRange = FALSE;
                
                m_llStart = MIN_TIME_VALUE;
                m_llStop = MAX_TIME_VALUE;

                if ( sysmonLogFiles == m_eDataSourceType ) {
                    BuildLogFileList ( m_hDlg, NULL, &ulLogListBufLen );

                    szLogFileList =  new WCHAR[ulLogListBufLen];
                    if ( NULL != szLogFileList ) {
                        BuildLogFileList ( m_hDlg, szLogFileList, &ulLogListBufLen );
                    }
                }

                if ( NULL != szLogFileList || sysmonSqlLog == m_eDataSourceType ) {

                    DisplayDataSourceError (
                            m_hDlg,
                            dwStatus,
                            m_eDataSourceType,
                            szLogFileList,
                            m_szSqlDsnName,
                            m_szSqlLogSetName );

                    if ( NULL != szLogFileList ) {
                        delete [] szLogFileList;
                        szLogFileList = NULL;
                        ulLogListBufLen = 0;
                    }
                }
            }
        } else {
            bIsValidLogFile = FALSE;
            bIsValidLogFileRange = FALSE;
            
            m_llStart = MIN_TIME_VALUE;
            m_llStop = MAX_TIME_VALUE;            
        }

        // Set the start and stop time bars invisible or not, depending on time range
        pPrivObj->SetLogViewTempRange( m_llStart, m_llStop );

        SetTimeRangeCtrlState ( bIsValidLogFile, bIsValidLogFileRange );

        // Clear change flags
        m_bInitialTimeRangePending = !bIsValidLogFileRange;
        m_bLogFileChg = FALSE;
        m_bSqlDsnChg = FALSE;
        m_bSqlLogSetChg = FALSE;
        m_bRangeChg = FALSE;
        m_bDataSourceChg = FALSE;

        bReturn = TRUE; 
    }

    return bReturn;
}


/*
 * CSourcePropPage::SetProperties
 * 
 */

BOOL CSourcePropPage::SetProperties(void)
{
    ISystemMonitor* pObj = NULL;
    CImpISystemMonitor* pPrivObj = NULL;
    BOOL    bIsValidLogFile = TRUE;
    BOOL    bIsValidLogFileRange = TRUE;
    DWORD   dwStatus = ERROR_SUCCESS;
    LPWSTR  szLogFileList   = NULL;
    ULONG   ulLogListBufLen = 0;
    PLogItemInfo    pInfo = NULL;
    PLogItemInfo    pInfoNext = NULL;
    DATE            date;
    BOOL            bReturn = TRUE;
    HWND            hwndLogFileList = NULL;
    INT             iLogFileCnt = 0;
    INT             i;  
    UINT            uiMessage = 0;
    HRESULT         hr = NOERROR;
    BOOL            bNewFileIsValid = TRUE;
    BSTR            bstrTemp     = NULL;

    USES_CONVERSION
    
    hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);

    if ( 0 != m_cObjects ) {
        pObj = m_ppISysmon[0];
        
        // Get pointer to actual object for internal methods
        pPrivObj = (CImpISystemMonitor*)pObj;
    }

    if (pObj == NULL || pPrivObj == NULL) {
        return FALSE;
    }

    if ( NULL != hwndLogFileList) {

        iLogFileCnt = LBNumItems(hwndLogFileList);
        // Validate properties
        if (m_eDataSourceType == sysmonLogFiles ) {
            if ( 0 == iLogFileCnt ) {
                uiMessage = IDS_NOLOGFILE_ERR;
            } else {
                // Check validity of existing files.
                // LogFilesAreValid displays any errors.
                LogFilesAreValid ( NULL, bNewFileIsValid, bReturn );
            }
        } else if ( m_eDataSourceType == sysmonSqlLog ){
            if ( L'\0' == m_szSqlDsnName[0] ) {
                uiMessage = IDS_NO_SQL_DSN_ERR;
            } else if ( L'\0' == m_szSqlLogSetName[0] ) {
                uiMessage = IDS_NO_SQL_LOG_SET_ERR;
            }
        }
        if ( 0 != uiMessage ) {
            MessageBox(m_hDlg, ResourceString(uiMessage), ResourceString(IDS_APP_NAME), MB_OK | MB_ICONEXCLAMATION);
            bReturn = FALSE;
        }

        if ( !bReturn ) {
            bIsValidLogFile = FALSE;
            // Todo:  Set log file time range?
        }

        if ( m_eDataSourceType == sysmonLogFiles
            || m_eDataSourceType == sysmonSqlLog) {
            if ( bReturn && m_bInitialTimeRangePending ) {
                // If log file or SQL specified, but range has not been determined
                // Try to open it now and get the range
                dwStatus = OpenLogFile();
                if ( ERROR_SUCCESS == dwStatus ) {
                    bIsValidLogFile = TRUE;
                    bIsValidLogFileRange = TRUE;
                    m_bInitialTimeRangePending = FALSE;
                } else {

                    bReturn = FALSE;

                    bIsValidLogFile = FALSE;
                    bIsValidLogFileRange = FALSE;
                    
                    m_llStart = MIN_TIME_VALUE;
                    m_llStop = MAX_TIME_VALUE;

                    if ( sysmonLogFiles == m_eDataSourceType ) {
                        BuildLogFileList ( m_hDlg, NULL, &ulLogListBufLen );

                        szLogFileList =  (LPWSTR) new WCHAR [ulLogListBufLen];
                        if ( NULL != szLogFileList ) {
                            BuildLogFileList (  m_hDlg, szLogFileList, &ulLogListBufLen );
                        }
                    }

                    if ( NULL != szLogFileList || sysmonSqlLog == m_eDataSourceType ) {

                        DisplayDataSourceError (
                            m_hDlg,
                            dwStatus,
                            m_eDataSourceType,
                            szLogFileList,
                            m_szSqlDsnName,
                            m_szSqlLogSetName );

                        if ( NULL != szLogFileList ) {
                            delete [] szLogFileList;
                            szLogFileList = NULL;
                            ulLogListBufLen = 0;
                        }
                    }
                }
            }
             // Set the start and stop time bars invisible or not, depending on time range
            pPrivObj->SetLogViewTempRange( m_llStart, m_llStop );

            SetTimeRangeCtrlState ( bIsValidLogFile, bIsValidLogFileRange );
       }
    }


    // Remove all deleted log files from the control.
    // Get first object
    if ( bReturn ) {

        if (m_bLogFileChg || m_bSqlDsnChg || m_bSqlLogSetChg ) {

            // Always set the log source to null data source before modifying the log file list
            // or database fields.
            // TodoLogFiles:  This can leave the user with state different than before, in the
            // case of log file load failure.
            pObj->put_DataSourceType ( sysmonNullDataSource );
            m_bDataSourceChg = TRUE;
        }

        if ( m_bSqlDsnChg) {
            bstrTemp = SysAllocString(m_szSqlDsnName);
            if ( NULL != bstrTemp ) {
                hr = pObj->put_SqlDsnName(bstrTemp);
            } else {
                hr = E_OUTOFMEMORY;
            }
            SysFreeString (bstrTemp);
            bstrTemp = NULL;
            bReturn = SUCCEEDED ( hr );
        }

        if ( bReturn && m_bSqlLogSetChg) {
            bstrTemp = SysAllocString(m_szSqlLogSetName);
            if ( NULL != bstrTemp ) {
                hr = pObj->put_SqlLogSetName(bstrTemp);
            } else {
                hr = E_OUTOFMEMORY;
            }
            SysFreeString (bstrTemp);
            bstrTemp = NULL;
            bReturn = SUCCEEDED ( hr );
        }

        if (m_bLogFileChg) {

            // Remove all items in the delete list from the control.
            pInfo = m_pInfoDeleted;
            while ( NULL != pInfo ) {

                // If this counter exists in the control
                if ( NULL != pInfo->pItem ) {

                    // Tell control to remove it
                    // Always set the log source to CurrentActivity before modifying the log file list.
                    pPrivObj->DeleteLogFile(pInfo->pItem);
                    // Release the local reference
                    pInfo->pItem->Release();
                }

                // Free the path string
                delete [] pInfo->pszPath;

                // Delete the Info structure and point to the next one
                pInfoNext = pInfo->pNextInfo;
                delete pInfo;
                pInfo = pInfoNext;
            }

            m_pInfoDeleted = NULL;
        
            // For each item
            for (i=0; i<iLogFileCnt; i++) {
                pInfo = (PLogItemInfo)LBData(hwndLogFileList,i);

                // If new item, create it now
                if (pInfo->pItem == NULL) {
                    // The following code inits the pItem field of pInfo.
                    bstrTemp = SysAllocString(pInfo->pszPath);
                    if ( NULL != bstrTemp ) {
                        hr = pPrivObj->AddLogFile(bstrTemp, &pInfo->pItem);
                        SysFreeString (bstrTemp);
                        bstrTemp = NULL;
                    } else {
                       hr = E_OUTOFMEMORY;
                    }
                }
                if ( FAILED ( hr) ) {
                    break;
                }
            }
            bReturn = SUCCEEDED ( hr );
        }

        
        if ( bReturn && m_bDataSourceChg ) {
            // This covers CurrentActivity as well as log files, database 
            hr = pObj->put_DataSourceType(m_eDataSourceType);
            bReturn = SUCCEEDED ( hr );
            if ( SUCCEEDED ( hr ) ) {
                m_bDataSourceChg = FALSE;
                m_bLogFileChg = FALSE;
                m_bSqlDsnChg = FALSE;
                m_bSqlLogSetChg = FALSE;
            } else {
                if ( sysmonLogFiles == m_eDataSourceType
                    || sysmonSqlLog == m_eDataSourceType ) {

                    // Display error messages, then retry in 
                    // Current Activity data source type.

                    // TodoLogFiles: Message re: data source set to CurrentActivity if
                    // put_DataSourceType failed.

                    if ( sysmonLogFiles == m_eDataSourceType ) {
                        BuildLogFileList (  m_hDlg, NULL, &ulLogListBufLen );

                        szLogFileList =  new WCHAR [ulLogListBufLen];
                        if ( NULL != szLogFileList ) {
                            BuildLogFileList (  m_hDlg, szLogFileList, &ulLogListBufLen );
                        }
                    }

                    if ( NULL != szLogFileList || sysmonSqlLog == m_eDataSourceType ) {

                        DisplayDataSourceError (
                            m_hDlg,
                            (DWORD)hr,
                            m_eDataSourceType,
                            szLogFileList,
                            m_szSqlDsnName,
                            m_szSqlLogSetName );

                        if ( NULL != szLogFileList ) {
                            delete [] szLogFileList;
                            szLogFileList = NULL;
                            ulLogListBufLen = 0;
                        }
                    }
                }
                // m_hDataSource should always be cleared unless in OpenLogFile method.
                assert ( H_REALTIME_DATASOURCE == m_hDataSource );
                
                // TodoLogFiles:  Need separate method to handle all changes necesary
                // when the log source type changes.
                if ( sysmonCurrentActivity != m_eDataSourceType ) {
                    m_eDataSourceType = sysmonCurrentActivity;
        
                    CheckRadioButton(
                        m_hDlg, IDC_SRC_REALTIME, IDC_SRC_SQL,
                        IDC_SRC_REALTIME + m_eDataSourceType - 1);
                
                    m_bDataSourceChg = TRUE;

                    SetSourceControlStates();
    
                    SetTimeRangeCtrlState ( 
                        FALSE, 
                        FALSE );

                    hr = pObj->put_DataSourceType ( m_eDataSourceType );
                    bReturn = SUCCEEDED ( hr );

                    m_bDataSourceChg = FALSE;
                    
                    m_bLogFileChg = FALSE;
                    m_bSqlDsnChg = FALSE;
                    m_bSqlLogSetChg = FALSE;
                } // else setting to Current Activity failed.
            }
        }
        if ( bReturn ) {

            if (m_eDataSourceType == sysmonLogFiles || m_eDataSourceType == sysmonSqlLog) 
                pPrivObj->SetLogFileRange(m_llBegin, m_llEnd);
            else 
                pObj->UpdateGraph();

        } else {
            SetFocus(GetDlgItem(m_hDlg, IDC_ADDFILE));
        }

        if (bReturn && m_bRangeChg
                    && (   m_eDataSourceType == sysmonLogFiles
                        || m_eDataSourceType == sysmonSqlLog)) {

            // With active logs, the begin/end points might have changed.
            pPrivObj->SetLogFileRange(m_llBegin, m_llEnd);

            // Always set Stop time first, to handle live logs.
            LLTimeToVariantDate(m_llStop, &date);
            pObj->put_LogViewStop(date);

            LLTimeToVariantDate(m_llStart, &date);
            pObj->put_LogViewStart(date);

            // Set the start and stop time bars visible in the graph
            pPrivObj->SetLogViewTempRange( m_llStart, m_llStop );

            m_bRangeChg = FALSE;
        }
    } else {
        bReturn = FALSE;
    }
    return bReturn;
}

void
CSourcePropPage::LogFilesAreValid (
    PLogItemInfo pNewInfo,
    BOOL&   rbNewIsValid,
    BOOL&   rbExistingIsValid )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    INT     iIndex;
    INT     iLogFileCnt = 0;
    HWND    hwndLogFileList = NULL;
    WCHAR   szLogFile[MAX_PATH + 1];
    LPCWSTR pszTestFile = NULL;
    PLogItemInfo pInfo = NULL;
    WCHAR*  pszMessage = NULL;
    WCHAR   szSystemMessage[MAX_PATH + 1];
    DWORD   dwType = PDH_LOG_TYPE_BINARY;
    UINT    uiErrorMessageID = 0;

    rbNewIsValid = TRUE;
    rbExistingIsValid = TRUE;

    hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
    if ( NULL != hwndLogFileList ) {
        iLogFileCnt = LBNumItems(hwndLogFileList);
    }

    if ( NULL != pNewInfo && NULL != hwndLogFileList ) {
        if ( NULL != pNewInfo->pszPath ) {
            // Check for duplicates.             
            for (iIndex = 0; iIndex < iLogFileCnt; iIndex++ ) {
                LBGetText(hwndLogFileList, iIndex, szLogFile);
                if ( 0 == lstrcmpi ( pNewInfo->pszPath, szLogFile ) ) {
                    MessageBox(
                        m_hDlg,
                        ResourceString(IDS_DUPL_LOGFILE_ERR), 
                        ResourceString(IDS_APP_NAME),
                        MB_OK | MB_ICONWARNING);
                    iIndex = LB_ERR;
                    rbNewIsValid = FALSE;
                    break;
                }    
            }

            // Validate added log file type if multiple log files
            if ( rbNewIsValid && 0 < iLogFileCnt ) {
                // Validate the new file
                dwType = PDH_LOG_TYPE_BINARY;

                pszTestFile = pNewInfo->pszPath;
                if ( NULL != pszTestFile ) {
                    dwStatus = PdhGetLogFileType ( 
                                    pszTestFile, 
                                    &dwType );

                    if ( ERROR_SUCCESS == dwStatus ) {
                        if ( PDH_LOG_TYPE_BINARY != dwType ) {
                            if ( (DWORD)ePdhLogTypeRetiredBinary == dwType ) {
                                uiErrorMessageID = IDS_MULTILOG_BIN_TYPE_ADD_ERR;
                            } else {
                                uiErrorMessageID = IDS_MULTILOG_TEXT_TYPE_ADD_ERR;
                            }
                            rbNewIsValid = FALSE;
                        }
                    } else {
                        // bad dwStatus error message handled below
                        rbNewIsValid = FALSE;
                    }
                }
            }
        } else {
            rbNewIsValid = FALSE;
            assert ( FALSE );
        }
    }

    // Validate existing files if the new count will be > 1
    if ( rbNewIsValid 
            && ( NULL != pNewInfo || iLogFileCnt > 1 ) )
    {
        dwType = PDH_LOG_TYPE_BINARY;

        for (iIndex=0; iIndex<iLogFileCnt; iIndex++) {
            pInfo = (PLogItemInfo)LBData(hwndLogFileList,iIndex);
            if ( NULL != pInfo ) {
                pszTestFile = pInfo->pszPath;
                if ( NULL != pszTestFile ) {
                
                    dwStatus = PdhGetLogFileType ( 
                                    pszTestFile, 
                                    &dwType );

                    if ( PDH_LOG_TYPE_BINARY != dwType ) {
                        rbExistingIsValid = FALSE;
                        break;
                    }
                }
            }
        }
        if ( ERROR_SUCCESS == dwStatus ) {
            if ( PDH_LOG_TYPE_BINARY != dwType ) {
                if ( (DWORD)ePdhLogTypeRetiredBinary == dwType ) {
                    uiErrorMessageID = IDS_MULTILOG_BIN_TYPE_ERR;
                } else {
                    uiErrorMessageID = IDS_MULTILOG_TEXT_TYPE_ERR;
                }
                rbExistingIsValid = FALSE;
            }
        } else {
            rbExistingIsValid = FALSE;
        }
    }

    if ( ( !rbNewIsValid || !rbExistingIsValid ) 
            && NULL != pszTestFile ) 
    {
        iIndex = LB_ERR;
        // Check dwStatus of PdhGetLogFileType call.
        if ( ERROR_SUCCESS == dwStatus ) {
            if ( PDH_LOG_TYPE_BINARY != dwType ) {
                assert ( 0 != uiErrorMessageID );
                pszMessage = new WCHAR [ ( 2*lstrlen(pszTestFile) )  + RESOURCE_STRING_BUF_LEN + 1];
                if ( NULL != pszMessage ) {
                    StringCchPrintf(pszMessage, 
                        ( 2*lstrlen(pszTestFile) )  + RESOURCE_STRING_BUF_LEN + 1,
                        ResourceString(uiErrorMessageID), 
                        pszTestFile,
                        pszTestFile );
                    MessageBox (
                        m_hDlg, 
                        pszMessage, 
                        ResourceString(IDS_APP_NAME), 
                        MB_OK | MB_ICONSTOP );
                    delete [] pszMessage;
                }
            }
        } else {
            pszMessage = new WCHAR [lstrlen(pszTestFile) + MAX_PATH + RESOURCE_STRING_BUF_LEN+1];

            if ( NULL != pszMessage ) {
                StringCchPrintf( pszMessage, 
                    lstrlen(pszTestFile) + MAX_PATH + RESOURCE_STRING_BUF_LEN + 1,
                    ResourceString(IDS_MULTILOG_CHECKTYPE_ERR), 
                    pszTestFile );

                FormatSystemMessage ( 
                    dwStatus, szSystemMessage, MAX_PATH );

                StringCchCat(pszMessage, 
                             lstrlen(pszTestFile) + MAX_PATH + RESOURCE_STRING_BUF_LEN + 1, 
                             szSystemMessage );

                MessageBox (
                    m_hDlg, 
                    pszMessage, 
                    ResourceString(IDS_APP_NAME), 
                    MB_OK | MB_ICONSTOP);

                delete [] pszMessage;
            }
        }
    }

    return;
}


INT
CSourcePropPage::AddItemToFileListBox (
    IN PLogItemInfo pNewInfo )
/*++

Routine Description:

    AddItemToFileListBox adds a log file's path name to the dialog list box and
    attaches a pointer to the log file's LogItemInfo structure as item data.
    It also adjusts the horizontal scroll of the list box.


Arguments:

    pInfo - Pointer to log file's LogItemInfo structure

Return Value:

    List box index of added log file (LB_ERR on failure)

--*/
{
    INT     iIndex = LB_ERR;
    HWND    hwndLogFileList = NULL; 
    DWORD   dwItemExtent = 0;
    HDC     hDC = NULL;
    BOOL    bNewIsValid;
    BOOL    bExistingAreValid;

    hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);

    if ( NULL != pNewInfo && NULL != hwndLogFileList ) {
        LogFilesAreValid ( pNewInfo, bNewIsValid, bExistingAreValid );

        if ( bNewIsValid && NULL != pNewInfo->pszPath ) {
            iIndex = (INT)LBAdd ( hwndLogFileList, pNewInfo->pszPath );
            LBSetSelection( hwndLogFileList, iIndex);

            if ( LB_ERR != iIndex && LB_ERRSPACE != iIndex ) { 
    
                LBSetData(hwndLogFileList, iIndex, pNewInfo);

                hDC = GetDC ( hwndLogFileList );
                if ( NULL != hDC ) {
                    dwItemExtent = (DWORD)TextWidth ( hDC, pNewInfo->pszPath );

                    if (dwItemExtent > m_dwMaxHorizListExtent) {
                        m_dwMaxHorizListExtent = dwItemExtent;
                        LBSetHorzExtent ( hwndLogFileList, dwItemExtent ); 
                    }
                    ReleaseDC ( hwndLogFileList, hDC );
                }
                OnLogFileChange();
            } else {
                iIndex = LB_ERR ; 
            }
        }
    }
    return iIndex;
}

BOOL
CSourcePropPage::RemoveItemFromFileListBox (
    void )
/*++

Routine Description:

    RemoveItemFromFileListBox removes the currently selected log file from 
    the dialog's log file name listbox. It adds the item to the deletion 
    list, so the actual log file can be deleted from the control when 
    (and if) the changes are applied.

    The routine selects selects the next log file in the listbox if there
    is one, and adjusts the horizontal scroll appropriately.

Arguments:
    
    None.

Return Value:

    None.

--*/
{
    BOOL    bChanged = FALSE;
    HWND    hWnd;
    INT     iIndex;
    PLogItemInfo    pInfo = NULL;
    LPWSTR  szBuffer = NULL;
    DWORD   dwItemExtent = 0;
    INT     iCurrentBufLen = 0;
    INT     iTextLen;
    HDC     hDC = NULL;

    // Get selected index
    hWnd = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
    iIndex = LBSelection(hWnd);

    if ( LB_ERR != iIndex ) {

        // Get selected item info
        pInfo = (PLogItemInfo)LBData(hWnd, iIndex);
        
        // Move it to the "Deleted" list.
        pInfo->pNextInfo = m_pInfoDeleted;
        m_pInfoDeleted = pInfo;

        // Remove the string from the list box.
        LBDelete(hWnd, iIndex);

        // Select next item if possible, else the previous
        if (iIndex == LBNumItems(hWnd)) {
            iIndex--;
        }
        LBSetSelection( hWnd, iIndex);

        hDC = GetDC ( hWnd );

        if ( NULL != hDC ) {
            // Clear the max horizontal extent and recalculate
            m_dwMaxHorizListExtent = 0;                
            for ( iIndex = 0; iIndex < (INT)LBNumItems ( hWnd ); iIndex++ ) {
                iTextLen = (INT)LBGetTextLen ( hWnd, iIndex );
                if ( iTextLen >= iCurrentBufLen ) {
                    if ( NULL != szBuffer ) {
                        delete [] szBuffer;
                        szBuffer = NULL;
                    }
                    iCurrentBufLen = iTextLen + 1;
                    szBuffer = new WCHAR [iCurrentBufLen];
                }
                if ( NULL != szBuffer ) {
                    LBGetText ( hWnd, iIndex, szBuffer );
                    dwItemExtent = (DWORD)TextWidth ( hDC, szBuffer );
                    if (dwItemExtent > m_dwMaxHorizListExtent) {
                        m_dwMaxHorizListExtent = dwItemExtent;
                    }
                }
            }
            LBSetHorzExtent ( hWnd, m_dwMaxHorizListExtent ); 

            ReleaseDC ( hWnd, hDC );    
        }
        if ( NULL != szBuffer ) {
            delete [] szBuffer;
        }
        bChanged = TRUE;
        OnLogFileChange();
    }
    return bChanged;
}
 
void
CSourcePropPage::OnLogFileChange ( void )
{
    HWND    hwndLogFileList = NULL;
    INT     iLogFileCnt = 0;
    BOOL    bIsValidDataSource = FALSE;

    m_bLogFileChg = TRUE;
    m_bInitialTimeRangePending = TRUE;

    hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
    if ( NULL != hwndLogFileList ) {
        iLogFileCnt = LBNumItems(hwndLogFileList);
    }
    bIsValidDataSource = (iLogFileCnt > 0);

    if (m_eDataSourceType == sysmonLogFiles) {
        DialogEnable(m_hDlg, IDC_REMOVEFILE, ( bIsValidDataSource ) );     
    }
    
    SetTimeRangeCtrlState( bIsValidDataSource, FALSE );

}

void
CSourcePropPage::OnSqlDataChange ( void )
{
    BOOL    bIsValidDataSource = FALSE;

    assert ( sysmonSqlLog == m_eDataSourceType );

    m_bInitialTimeRangePending = TRUE;

    bIsValidDataSource = 0 < lstrlen ( m_szSqlDsnName ) && 0 < lstrlen ( m_szSqlLogSetName );
    
    SetTimeRangeCtrlState( bIsValidDataSource, FALSE );
}

void 
CSourcePropPage::DialogItemChange(WORD wID, WORD wMsg)
{
    ISystemMonitor  *pObj = NULL;
    CImpISystemMonitor *pPrivObj = NULL;
    HWND    hwndCtrl = NULL;
    BOOL    fChange = FALSE;
    DataSourceTypeConstants eNewDataSourceType;
    HWND    hwndLogFileList = NULL;
    INT     iLogFileCnt = 0;;
    BOOL    bIsValidDataSource;


    switch(wID) {

        case IDC_SRC_REALTIME:
        case IDC_SRC_LOGFILE:
        case IDC_SRC_SQL:

            // Check which button is involved
            eNewDataSourceType = (DataSourceTypeConstants)(wID - IDC_SRC_REALTIME + 1); 

            // If state changed
            if (   wMsg == BN_CLICKED
                && eNewDataSourceType != m_eDataSourceType) {

                // Set change flags and update the radio button
                m_bDataSourceChg = TRUE;
                fChange = TRUE;

                m_eDataSourceType = eNewDataSourceType;

                CheckRadioButton(
                        m_hDlg, IDC_SRC_REALTIME, IDC_SRC_SQL,
                        IDC_SRC_REALTIME + m_eDataSourceType - 1);

                SetSourceControlStates();

                pObj = m_ppISysmon[0];  
                if ( NULL != m_ppISysmon[0] ) {
                    pPrivObj = (CImpISystemMonitor*) pObj;
                }
                if ( NULL != pPrivObj ) {
                    bIsValidDataSource = FALSE;

                    hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
                    if ( NULL != hwndLogFileList ) {
                        iLogFileCnt = LBNumItems(hwndLogFileList);
                    }

                    if ( sysmonLogFiles == m_eDataSourceType && iLogFileCnt > 0) {

                        bIsValidDataSource = (iLogFileCnt > 0);

                        if ( bIsValidDataSource ) {
                            SetFocus(GetDlgItem(m_hDlg, IDC_ADDFILE));
                        }

                    } else if ( sysmonSqlLog == m_eDataSourceType ) {

                        bIsValidDataSource = ( 0 < lstrlen ( m_szSqlDsnName ) )
                                            && ( 0 < lstrlen ( m_szSqlLogSetName ) );
                    } // else  current activity, so no valid data source 

                    if ( bIsValidDataSource ) {
                        // Set the start and stop time bars visible in the graph
                        pPrivObj->SetLogViewTempRange( m_llStart, m_llStop );
                    } else {
                        // Set the start and stop time bars invisible in the graph
                        pPrivObj->SetLogViewTempRange( MIN_TIME_VALUE, MAX_TIME_VALUE );
                    }

                }
                m_bDataSourceChg = TRUE;
            }
            break;

        case IDC_REMOVEFILE:
            fChange = RemoveItemFromFileListBox();
            break;

        case IDC_ADDFILE:
        {
            WCHAR   szDefaultFolderBuff[MAX_PATH + 1];
            LPWSTR  szBrowseBuffer = NULL;
            INT     iFolderBufLen;
            PDH_STATUS pdhstat;
            LogItemInfo* pInfo = NULL;
            DWORD   cchLen = 0;
            DWORD   cchBrowseBuffer = 0;

            szDefaultFolderBuff[0] = L'\0';

            iFolderBufLen = MAX_PATH;
            
            if ( ERROR_SUCCESS != LoadDefaultLogFileFolder(szDefaultFolderBuff, &iFolderBufLen ) ) {
                StringCchCopy(szDefaultFolderBuff, 
                              MAX_PATH + 1,
                              ResourceString ( IDS_DEFAULT_LOG_FILE_FOLDER ) );
            }

            //
            // Expand environment strings.
            //
            cchLen = ExpandEnvironmentStrings ( szDefaultFolderBuff, NULL, 0 );

            if ( 0 < cchLen ) {
                //
                // cchLen includes space for null.
                //
                cchBrowseBuffer =  max ( cchLen, MAX_PATH + 1 );
                szBrowseBuffer = new WCHAR [ cchBrowseBuffer ];
                szBrowseBuffer[0] = L'\0';

                if ( NULL != szBrowseBuffer ) {
                    cchLen = ExpandEnvironmentStrings (
                                szDefaultFolderBuff, 
                                szBrowseBuffer,
                                cchBrowseBuffer );

                    if ( 0 < cchLen && cchLen <= cchBrowseBuffer ) {
                        SetCurrentDirectory(szBrowseBuffer);
                    }
                }
            }

            if ( NULL != szBrowseBuffer ) {

                szBrowseBuffer[0] = L'\0';
                pdhstat = PdhSelectDataSource(
                            m_hDlg,
                            PDH_FLAGS_FILE_BROWSER_ONLY,
                            szBrowseBuffer,
                            &cchBrowseBuffer);

                // Todo:  Error message if file name is too long.
                if ( (ERROR_SUCCESS != pdhstat) 
                    || szBrowseBuffer [0] == L'\0' ) {
                    delete [] szBrowseBuffer;
                    szBrowseBuffer = NULL;
                    break;
                }

                // Load file name into edit control
                pInfo = new LogItemInfo;
                if ( NULL != pInfo ) {
                    ZeroMemory ( pInfo, sizeof(LogItemInfo) );
                    //
                    // Make own copy of path name string
                    //
                    pInfo->pszPath = new WCHAR [lstrlen( szBrowseBuffer ) + 1];
                    if ( NULL != pInfo->pszPath ) {
                        INT iIndex = 0;
                        StringCchCopy(pInfo->pszPath, lstrlen( szBrowseBuffer ) + 1, szBrowseBuffer);

                        iIndex = AddItemToFileListBox ( pInfo );

                        fChange = ( LB_ERR != iIndex );

                        if (!fChange) {
                            // Todo:  error message
                            delete [] pInfo->pszPath;
                            delete pInfo;
                        }
                    } else {
                        // Todo:  error message
                        delete pInfo;
                    }
                }
                // Todo:  error message
            }
    
            if ( NULL != szBrowseBuffer ) {
                delete [] szBrowseBuffer;
            }

            break;
        }

/*
        // Doesn't do anything
        case IDC_LIST_LOGFILENAME:
            // If selection changed
            if (wMsg == LBN_SELCHANGE) {

                // TodoLogFiles:  Selection change won't matter when multi-file support
                fChange = TRUE;
                OnLogFileChange();
                
                // Get selected index   
                hwndCtrl = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
                iIndex = LBSelection(hwndCtrl);
            }
            break;        
*/
        case IDC_DSN_COMBO:
        {
            WCHAR*  szDsnName = NULL;
            INT     iSel;
            HWND    hDsnCombo;
            LRESULT lresultDsnLen;

            if (wMsg == CBN_CLOSEUP) {
                hDsnCombo = GetDlgItem ( m_hDlg, IDC_DSN_COMBO);
                if ( NULL != hDsnCombo ) {
                    iSel = (INT)CBSelection ( hDsnCombo );
                    if ( LB_ERR != iSel ) {
                        lresultDsnLen = (INT)CBStringLen ( hDsnCombo, iSel );
                        if ( lresultDsnLen < INT_MAX ) {
                            szDsnName = new WCHAR[lresultDsnLen+1];
                            if ( NULL != szDsnName ) {
                                szDsnName[0] = L'\0';
                                CBString( hDsnCombo, iSel, szDsnName);
                                szDsnName[lresultDsnLen] = L'\0';
                                if ( 0 != lstrcmpi ( m_szSqlDsnName, szDsnName ) ) {

                                    lstrcpyn ( 
                                        m_szSqlDsnName, 
                                        szDsnName, 
                                        min ( SQL_MAX_DSN_LENGTH+1, lstrlen(szDsnName)+1 ) );
                                    m_bSqlDsnChg = TRUE;
                                    InitSqlLogSetList();
                                    OnSqlDataChange();
                                    fChange = TRUE;
                                }
                                delete [] szDsnName;
                            }
                        }
                    }
                }
            } 
            break;
        }

        case IDC_LOGSET_COMBO:
        {
            WCHAR* szLogSetName = NULL;
            INT    iSel;
            HWND   hLogSetCombo;
            LRESULT lresultLogSetLen;

            if (wMsg == CBN_CLOSEUP) {
                hLogSetCombo = GetDlgItem ( m_hDlg, IDC_LOGSET_COMBO);
                if ( NULL != hLogSetCombo ) {
                    iSel = (INT)CBSelection ( hLogSetCombo );
                    if ( LB_ERR != iSel ) {
                        lresultLogSetLen = CBStringLen ( hLogSetCombo, iSel );
                        if ( lresultLogSetLen < INT_MAX ) {
                            szLogSetName = new WCHAR[lresultLogSetLen+1];
                            if ( NULL != szLogSetName ) {
                                szLogSetName[0] = L'\0';
                                CBString ( hLogSetCombo, iSel, szLogSetName );
                                szLogSetName[lresultLogSetLen] = L'\0';   
                                if ( ( 0 != lstrcmpi ( m_szSqlLogSetName, szLogSetName ) )
                                    && ( 0 != lstrcmpi ( szLogSetName, ResourceString ( IDS_LOGSET_NOT_FOUND ) ) ) ) {
                                    lstrcpyn ( m_szSqlLogSetName, 
                                           szLogSetName, 
                                           min ( SLQ_MAX_LOG_SET_NAME_LEN + 1, lstrlen(szLogSetName)+1 ) );
                                    m_bSqlLogSetChg = TRUE;
                                    OnSqlDataChange();
                                    fChange = TRUE;
                                }
                                delete [] szLogSetName;
                            }
                        }
                    }
                }
            }
            break;
        }

        case IDC_TIMESELECTBTN:
        {
            DWORD   dwStatus = ERROR_SUCCESS;
            BOOL    bAttemptedReload = FALSE;
            hwndCtrl = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
            if ( NULL != hwndCtrl ) {
                { 
                    CWaitCursor cursorWait;
                    dwStatus = OpenLogFile ();
                }
                if ( SMON_STATUS_LOG_FILE_SIZE_LIMIT == dwStatus ) {
                    WCHAR   szMessage[RESOURCE_STRING_BUF_LEN + 1];
                    BSTR    bstrPath;
                    int iResult;
                
                    pObj = m_ppISysmon[0];  
                    pObj->get_LogFileName ( &bstrPath );
                    if ( bstrPath ) {
                        if ( bstrPath[0] ) {
                            StringCchCopy(szMessage, 
                                          RESOURCE_STRING_BUF_LEN+1, 
                                          ResourceString(IDS_LARGE_LOG_FILE_RELOAD) );

                            iResult = MessageBox(
                                    m_hDlg, 
                                    szMessage, 
                                    ResourceString(IDS_APP_NAME), 
                                    MB_YESNO | MB_ICONEXCLAMATION);

                            if ( IDYES == iResult ) {
                                CWaitCursor cursorWait;
                                dwStatus = OpenLogFile ();
                                bAttemptedReload = TRUE;
                            }
                        }
                        SysFreeString(bstrPath);
                    }
                }
                if ( ERROR_SUCCESS == dwStatus ) {
                    m_bInitialTimeRangePending = FALSE;

                    // Show graph log view start/stop time bars               
                    pObj = m_ppISysmon[0];  
                    pPrivObj = (CImpISystemMonitor*)pObj;
                    pPrivObj->SetLogViewTempRange( m_llStart, m_llStop );

                    SetTimeRangeCtrlState ( 
                        TRUE,
                        TRUE ); 

                    m_bRangeChg = TRUE;
                    fChange = TRUE;
                } else {   // OpenLogFile failure
                    if ( ( SMON_STATUS_LOG_FILE_SIZE_LIMIT == dwStatus ) && !bAttemptedReload ) {
                        // Message already displayed, user chose not to continue.
                    } else {

                        LPWSTR  szLogFileList   = NULL;
                        ULONG   ulLogListBufLen = 0;

                        if ( sysmonLogFiles == m_eDataSourceType ) {
                            BuildLogFileList ( 
                                m_hDlg,
                                NULL,
                                &ulLogListBufLen );

                            szLogFileList =  new WCHAR[ulLogListBufLen];
                            if ( NULL != szLogFileList ) {
                                BuildLogFileList ( 
                                    m_hDlg,
                                    szLogFileList,
                                    &ulLogListBufLen );
                            }
                        }

                        if ( NULL != szLogFileList || sysmonSqlLog == m_eDataSourceType ) {

                            DisplayDataSourceError (
                                m_hDlg,
                                dwStatus,
                                m_eDataSourceType,
                                szLogFileList,
                                m_szSqlDsnName,
                                m_szSqlLogSetName );

                            if ( NULL != szLogFileList ) {
                                delete [] szLogFileList;
                                szLogFileList = NULL;
                                ulLogListBufLen = 0;
                            }
                        }
                    }
                }
            }
            
            break;
        }

        case IDC_TIMERANGE:
        {
            m_llStart = m_pTimeRange->GetStart();
            m_llStop = m_pTimeRange->GetStop();

            // Show graph log view start/stop time bars               
            pObj = m_ppISysmon[0];  
            pPrivObj = (CImpISystemMonitor*)pObj;
            pPrivObj->SetLogViewTempRange( m_llStart, m_llStop );
            fChange = TRUE;
            m_bRangeChg = TRUE;
            break;
        }
    }

    if (fChange)
        SetChange();
}

DWORD 
CSourcePropPage::OpenLogFile (void)
{
    DWORD         dwStatus = ERROR_SUCCESS;
    DWORD         nBufSize;
    DWORD         nLogEntries = 0;
    PDH_TIME_INFO TimeInfo;

    LPWSTR       szLogFileList   = NULL;
    LPWSTR       szCurrentLogFile;
    ULONG        LogFileListSize = 0;
    HWND         hwndLogFileList = NULL;
    INT          iLogFileCount = 0;
    INT          iLogFileIndex;
    PLogItemInfo pInfo;
    BOOLEAN      bSqlLogSet =
                    (BST_CHECKED == IsDlgButtonChecked(m_hDlg,IDC_SRC_SQL));
    WCHAR*  szDsnName = NULL;
    WCHAR*  szLogSetName = NULL;
    INT     iSel;
    HWND    hDsnCombo;
    HWND    hLogSetCombo;

    memset (&TimeInfo, 0, sizeof(TimeInfo));

    hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
    if ( NULL != hwndLogFileList ) {
        iLogFileCount = LBNumItems(hwndLogFileList);
    }

    if (bSqlLogSet) {
        LogFileListSize = 0;
        szDsnName = new WCHAR[SQL_MAX_DSN_LENGTH+1];
        szLogSetName = new WCHAR[SLQ_MAX_LOG_SET_NAME_LEN+1];
        hDsnCombo = GetDlgItem ( m_hDlg, IDC_DSN_COMBO);
        hLogSetCombo = GetDlgItem ( m_hDlg, IDC_LOGSET_COMBO);
    
        if ( NULL != szDsnName && NULL != szLogSetName 
            && NULL != hDsnCombo && NULL != hLogSetCombo ) {
            szDsnName[0] = L'\0';
            szLogSetName[0] = L'\0';
            iSel = (INT)CBSelection ( hDsnCombo );
            if ( LB_ERR != iSel ) {
                if ( SQL_MAX_DSN_LENGTH >= CBStringLen( hDsnCombo, iSel ) ) {
                    CBString ( hDsnCombo, iSel, szDsnName);
                    iSel = (INT)CBSelection ( hLogSetCombo );
                    if ( LB_ERR != iSel ) {
                        if ( SLQ_MAX_LOG_SET_NAME_LEN >= CBStringLen( hLogSetCombo, iSel ) ) {
                            CBString( hLogSetCombo, iSel, szLogSetName);
                            // Size includes 5 characters "SQL:" "!"and 2 nulls
                            LogFileListSize = lstrlen(szDsnName) + lstrlen(szLogSetName) + 7;
                        }
                    }
                }
            }
        }
    } else {
        if ( NULL != hwndLogFileList ) {
            for (iLogFileIndex = 0; iLogFileIndex < iLogFileCount; iLogFileIndex ++) {
                pInfo = (PLogItemInfo) LBData(hwndLogFileList, iLogFileIndex);
                if (pInfo && pInfo->pszPath) {
                    LogFileListSize += (lstrlen(pInfo->pszPath) + 1);
                }
            }
            LogFileListSize ++;
        }
    }
    
    szLogFileList = (LPWSTR) malloc(LogFileListSize * sizeof(WCHAR));
    if (szLogFileList) {
        if (bSqlLogSet) {
            ZeroMemory(szLogFileList, LogFileListSize * sizeof(WCHAR));
            StringCchPrintf(szLogFileList, LogFileListSize, L"SQL:%s!%s", szDsnName, szLogSetName);
        } else {
            if ( NULL != hwndLogFileList ) {
                szCurrentLogFile = szLogFileList;
                for (iLogFileIndex = 0;
                     iLogFileIndex < iLogFileCount;
                     iLogFileIndex ++) {
                    pInfo = (PLogItemInfo) LBData(hwndLogFileList, iLogFileIndex);
                    if (pInfo && pInfo->pszPath) {
                        StringCchCopy(szCurrentLogFile,lstrlen(pInfo->pszPath) + 1, pInfo->pszPath);
                        szCurrentLogFile   += lstrlen(pInfo->pszPath);
                        * szCurrentLogFile  = L'\0';
                        szCurrentLogFile ++;
                    }
                }
                * szCurrentLogFile = L'\0';
            }
        }

        if (   m_hDataSource != H_REALTIME_DATASOURCE
            && m_hDataSource != H_WBEM_DATASOURCE) 
        {
            PdhCloseLog(m_hDataSource, 0);
            m_hDataSource = H_REALTIME_DATASOURCE;
        }
        dwStatus = PdhBindInputDataSource(& m_hDataSource, szLogFileList);
        if ( ERROR_SUCCESS == dwStatus ) {
            // Get time and sample count info
            nBufSize = sizeof(TimeInfo);
            dwStatus = PdhGetDataSourceTimeRangeH(
                        m_hDataSource, &nLogEntries, &TimeInfo, & nBufSize);
            PdhCloseLog(m_hDataSource, 0);
            m_hDataSource = H_REALTIME_DATASOURCE;
        }
  
        free(szLogFileList);
        szLogFileList = NULL;

    } else {
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (ERROR_NOT_ENOUGH_MEMORY == dwStatus ) {
        dwStatus = SMON_STATUS_LOG_FILE_SIZE_LIMIT;
    }
    
    if ( ERROR_SUCCESS == dwStatus ) {
        // Check that at least 2 samples exist:
        //  If 0 samples, StartTime is 0, EndTime is 0
        //  If 1 sample, StartTime == EndTime
        if ( ( TimeInfo.StartTime < TimeInfo.EndTime )
                && ( 1 < TimeInfo.SampleCount ) ){
            // Load log time range into time range control
            m_llBegin = TimeInfo.StartTime;
            m_llEnd = TimeInfo.EndTime; 

            // Limit view range to actual log file range
            if (m_llStop > m_llEnd ) {
                m_llStop = m_llEnd;
            } else if (m_llStop < m_llBegin ) {
                m_llStop = m_llBegin;    
            }

            if (m_llStart < m_llBegin)
                m_llStart = m_llBegin;

            if (m_llStart > m_llStop) 
                m_llStart = m_llStop;

            m_pTimeRange->SetBeginEnd(m_llBegin, m_llEnd);
            m_pTimeRange->SetStartStop(m_llStart, m_llStop);
        } else {
            dwStatus = SMON_STATUS_TOO_FEW_SAMPLES;
        }
    }
    if ( NULL != szDsnName ) {
        delete [] szDsnName;
    }
    if ( NULL != szLogSetName ) {
        delete [] szLogSetName;
    }
    return dwStatus;    
    
}

void
CSourcePropPage::SetTimeRangeCtrlState ( 
    BOOL bIsValidLogFile, 
    BOOL bIsValidLogFileRange ) 
{
    // Enable time range button if valid log file, even if log data is invalid.
    DialogEnable ( m_hDlg, IDC_TIMESELECTBTN, bIsValidLogFile );

    // Set time range controls visible or not, depending on valid log file and data.
    DialogEnable ( m_hDlg, IDC_TIMERANGE, bIsValidLogFile && bIsValidLogFileRange );
    DialogEnable ( m_hDlg, IDC_STATIC_TOTAL, bIsValidLogFile && bIsValidLogFileRange );
    DialogEnable ( m_hDlg, IDC_STATIC_SELECTED, bIsValidLogFile && bIsValidLogFileRange );
}

void
CSourcePropPage::InitSqlDsnList(void)
{
    HENV     henv;
    RETCODE  retcode;
    INT      DsnCount = 0;
    HWND     hWnd = NULL;
    WCHAR*   szTmpName = NULL; 

    hWnd = GetDlgItem(m_hDlg, IDC_DSN_COMBO);
    szTmpName = new WCHAR[SQL_MAX_DSN_LENGTH + 1];

    if ( NULL != hWnd && NULL != szTmpName ) {
    
        if (SQL_SUCCEEDED(SQLAllocHandle(SQL_HANDLE_ENV, NULL, & henv))) {
            (void) SQLSetEnvAttr(henv,
                                 SQL_ATTR_ODBC_VERSION,
                                 (SQLPOINTER) SQL_OV_ODBC3,
                                 SQL_IS_INTEGER);
            // Todo:  NULL hWnd
            CBReset(hWnd);          
            
            ZeroMemory ( szTmpName, sizeof(szTmpName) );

            retcode = SQLDataSources(henv,
                                     SQL_FETCH_FIRST_SYSTEM,
                                     szTmpName,           
                                     (SQL_MAX_DSN_LENGTH+1),
                                     NULL,
                                     NULL, 
                                     0, 
                                     NULL);
            while (SQL_SUCCEEDED(retcode)) {
                CBAdd(hWnd, szTmpName);
                ZeroMemory ( szTmpName, sizeof(szTmpName) );
                retcode = SQLDataSources(henv,
                                         SQL_FETCH_NEXT,
                                         szTmpName,
                                         (SQL_MAX_DSN_LENGTH+1),
                                         NULL,
                                         NULL,
                                         0,
                                         NULL);
            }

            DsnCount = CBNumItems(hWnd) - 1;
            if (DsnCount >= 0) {
                if ( m_szSqlDsnName[0] != L'\0') {
                    while (DsnCount >= 0) {
                        CBString(hWnd, DsnCount, szTmpName);
                        if (lstrcmpi(m_szSqlDsnName, szTmpName) == 0) {
                            CBSetSelection(hWnd, DsnCount);
                            break;
                        }
                        else {
                            DsnCount --;
                        }
                    }
                    // Todo: Clear m_szSqlDsnName if not in list? 
                }
                else {
                    DsnCount = -1;
                }
            }
            SQLFreeHandle(SQL_HANDLE_ENV, henv);
        }
    }

    if ( NULL!= szTmpName ) {
        delete [] szTmpName;
    }
}

void
CSourcePropPage::InitSqlLogSetList(void)
{
    PDH_STATUS      pdhStatus          = ERROR_SUCCESS;
    INT             iLogSetIndex       = 0;
    LPWSTR          pLogSetList        = NULL;
    DWORD           dwBufferLen        = 0;
    LPWSTR          pLogSetPtr         = NULL;
    HWND            hwndLogSetCombo    = NULL;
    LPWSTR          szTmpName = NULL;
    INT             iBufAllocCount = 0;
    INT             iMaxNameLen = 0;
    INT             iCurrentNameLen = 0;

    if ( L'\0' == m_szSqlDsnName[0] ) {
        goto Cleanup;
    }

    hwndLogSetCombo = GetDlgItem(m_hDlg, IDC_LOGSET_COMBO);

    if ( NULL == hwndLogSetCombo ) {
        goto Cleanup;
    }

    do {
        pdhStatus = PdhEnumLogSetNames(
                                m_szSqlDsnName, pLogSetList, & dwBufferLen);
        if (pdhStatus == PDH_INSUFFICIENT_BUFFER || pdhStatus == PDH_MORE_DATA)
        {
            iBufAllocCount += 1;
            if (pLogSetList) {
                delete [] pLogSetList;
                pLogSetList = NULL;
            }
            pLogSetList = (LPWSTR) new WCHAR[dwBufferLen];
            if (pLogSetList == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }
    }
    while ( ( PDH_INSUFFICIENT_BUFFER == pdhStatus || PDH_MORE_DATA == pdhStatus ) 
                && iBufAllocCount < 10 );

    if (pdhStatus == ERROR_SUCCESS && pLogSetList != NULL) {
        CBReset(hwndLogSetCombo);
        for (  pLogSetPtr  = pLogSetList;
             * pLogSetPtr != L'\0';
               pLogSetPtr += ( iCurrentNameLen + 1)) 
        {
            iCurrentNameLen = lstrlen(pLogSetPtr);
            // Ignore log set names that longer than the max allowed length.
            if ( iCurrentNameLen <= SLQ_MAX_LOG_SET_NAME_LEN ) {
                CBAdd(hwndLogSetCombo, pLogSetPtr);
                if ( iMaxNameLen < iCurrentNameLen ) {
                    iMaxNameLen = iCurrentNameLen;
                }
            }
        }
        iLogSetIndex = CBNumItems(hwndLogSetCombo) - 1;

        if (iLogSetIndex >= 0) {
            if ( m_szSqlLogSetName[0] != L'\0') {
                szTmpName = new WCHAR[iMaxNameLen+1];
                if ( NULL != szTmpName ) {
                    while (iLogSetIndex >= 0) {
                        CBString(hwndLogSetCombo, iLogSetIndex, szTmpName);
                        if (lstrcmpi( m_szSqlLogSetName, szTmpName) == 0) {
                            CBSetSelection(hwndLogSetCombo, iLogSetIndex);
                            break;
                        }
                        else {
                            iLogSetIndex --;
                        }
                    }
                } else {
                    iLogSetIndex = -1;
                }
            } else {
                iLogSetIndex = -1;
            }
                // Todo: Clear m_szSqlLogSetName if not in list? 
        } else {
            if ( 0 == CBNumItems(hwndLogSetCombo) ) {
                iMaxNameLen = lstrlen ( ResourceString(IDS_LOGSET_NOT_FOUND) );
                szTmpName = new WCHAR[iMaxNameLen+1];
                if ( NULL != szTmpName ) {
                    StringCchCopy(szTmpName,  iMaxNameLen+1, ResourceString(IDS_LOGSET_NOT_FOUND));
                    CBReset(hwndLogSetCombo);
                    iLogSetIndex = (INT)CBAdd(hwndLogSetCombo, szTmpName);
                    CBSetSelection( hwndLogSetCombo, iLogSetIndex);
                }
            }
        }
    } else {
        if ( 0 == CBNumItems(hwndLogSetCombo) ) {
            iMaxNameLen = lstrlen ( ResourceString(IDS_LOGSET_NOT_FOUND) );
            szTmpName = new WCHAR[iMaxNameLen+1];
            if ( NULL != szTmpName ) {
                StringCchCopy(szTmpName, iMaxNameLen+1, ResourceString(IDS_LOGSET_NOT_FOUND));
                CBReset(hwndLogSetCombo);
                iLogSetIndex = (INT)CBAdd(hwndLogSetCombo, szTmpName);
                CBSetSelection( hwndLogSetCombo, iLogSetIndex);
            }
        }
    }

Cleanup:
    if (pLogSetList) {
        delete [] pLogSetList;
    }

    if ( szTmpName ) {
        delete [] szTmpName;
    }
    return;
}

HRESULT 
CSourcePropPage::EditPropertyImpl( DISPID dispID )
{
    HRESULT hr = E_NOTIMPL;

    if ( DISPID_SYSMON_DATASOURCETYPE == dispID ) {
        if ( sysmonCurrentActivity == m_eDataSourceType ) {
            m_dwEditControl = IDC_SRC_REALTIME;
        } else if ( sysmonLogFiles == m_eDataSourceType ) {
            m_dwEditControl = IDC_SRC_LOGFILE;
        } else if ( sysmonSqlLog == m_eDataSourceType ) {
            m_dwEditControl = IDC_SRC_SQL;
        }
        hr = S_OK;
    }

    return hr;
}

void 
CSourcePropPage::SetSourceControlStates ( void )
{
    HWND    hwndLogFileList = NULL; 
    INT     iLogFileCnt = 0; 
    BOOL    bIsValidDataSource = FALSE;

    if ( sysmonCurrentActivity == m_eDataSourceType ) { 
        DialogEnable(m_hDlg, IDC_ADDFILE, FALSE);
        DialogEnable(m_hDlg, IDC_REMOVEFILE, FALSE);
        DialogEnable(m_hDlg, IDC_STATIC_DSN, FALSE);
        DialogEnable(m_hDlg, IDC_DSN_COMBO, FALSE);
        DialogEnable(m_hDlg, IDC_STATIC_LOGSET, FALSE);
        DialogEnable(m_hDlg, IDC_LOGSET_COMBO, FALSE);

        bIsValidDataSource = FALSE;
    
    } else if ( sysmonLogFiles == m_eDataSourceType ) {
        DialogEnable(m_hDlg, IDC_ADDFILE, TRUE);
        DialogEnable(m_hDlg, IDC_STATIC_DSN, FALSE);
        DialogEnable(m_hDlg, IDC_DSN_COMBO, FALSE);
        DialogEnable(m_hDlg, IDC_STATIC_LOGSET, FALSE);
        DialogEnable(m_hDlg, IDC_LOGSET_COMBO, FALSE);

        hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
        if ( NULL != hwndLogFileList ) {
            iLogFileCnt = LBNumItems(hwndLogFileList);
        }
        bIsValidDataSource = (iLogFileCnt > 0);

        DialogEnable(m_hDlg, IDC_REMOVEFILE, ( bIsValidDataSource ) );     
        
    } else {
        assert ( sysmonSqlLog == m_eDataSourceType );
        
        DialogEnable(m_hDlg, IDC_ADDFILE, FALSE);
        DialogEnable(m_hDlg, IDC_REMOVEFILE, FALSE);
        DialogEnable(m_hDlg, IDC_STATIC_DSN, TRUE);
        DialogEnable(m_hDlg, IDC_DSN_COMBO, TRUE);
        DialogEnable(m_hDlg, IDC_STATIC_LOGSET, TRUE);
        DialogEnable(m_hDlg, IDC_LOGSET_COMBO, TRUE);

        bIsValidDataSource = 0 < lstrlen ( m_szSqlDsnName ) && 0 < lstrlen ( m_szSqlLogSetName );
    }
    m_bInitialTimeRangePending = TRUE;
    SetTimeRangeCtrlState( bIsValidDataSource, FALSE );
}

DWORD
CSourcePropPage::BuildLogFileList ( 
    HWND    /*hwndDlg*/,
    LPWSTR  szLogFileList,
    ULONG*  pulBufLen )
{

    DWORD           dwStatus = ERROR_SUCCESS;
    ULONG           ulListLen;
    HWND            hwndLogFileList = NULL;
    INT             iLogFileCount;
    INT             iLogFileIndex;
    PLogItemInfo    pInfo = NULL;
    LPCWSTR         szThisLogFile = NULL;
    LPWSTR          szLogFileCurrent = NULL;

    WCHAR           cwComma = L',';

    if ( NULL != pulBufLen ) {

        ulListLen = 0;
        hwndLogFileList = DialogControl(m_hDlg, IDC_LIST_LOGFILENAME);
        if ( NULL != hwndLogFileList ) {
            iLogFileCount = LBNumItems(hwndLogFileList);
            if ( 0 < iLogFileCount ) {
                for ( iLogFileIndex = 0; iLogFileIndex < iLogFileCount; iLogFileIndex++ ) {
                    pInfo = (PLogItemInfo)LBData(hwndLogFileList,iLogFileIndex);
                    szThisLogFile = pInfo->pszPath;
                    ulListLen += (lstrlen(szThisLogFile) + 1);
                } 
                
                ulListLen ++; // for the single final NULL character.
    
                if ( ulListLen <= *pulBufLen ) {
                    if ( NULL != szLogFileList ) {
                        ZeroMemory(szLogFileList, (ulListLen * sizeof(WCHAR)));
                        szLogFileCurrent = (LPWSTR) szLogFileList;
                        for ( iLogFileIndex = 0; iLogFileIndex < iLogFileCount; iLogFileIndex++ ) {
                            pInfo = (PLogItemInfo)LBData(hwndLogFileList,iLogFileIndex);
                            szThisLogFile = pInfo->pszPath;
                            StringCchCopy(szLogFileCurrent, lstrlen(szThisLogFile) + 1, szThisLogFile);
                            szLogFileCurrent  += lstrlen(szThisLogFile);
                            *szLogFileCurrent = L'\0';
                            if ( (iLogFileIndex + 1) < iLogFileCount ) {
                                // If comma delimited, replace the NULL char with a comma
                                *szLogFileCurrent = cwComma;
                            }
                            szLogFileCurrent ++;
                        }
                    }
                } else if ( NULL != szLogFileList ) {
                    dwStatus = ERROR_MORE_DATA;
                } 
            }
        }
        *pulBufLen = ulListLen;
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
        assert ( FALSE );
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\stepper.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    stepper.h

Abstract:

    <abstract>

--*/

#ifndef _STEPPER_H_
#define _STEPPER_H_

class CStepper
{
private:
    INT     m_iStepCnt;
    INT     m_iRemainder;
    INT     m_iStepSize;
    INT     m_iState;
    INT     m_iStepNum;
    INT     m_iPos;

public:
    CStepper(void);
    void Init( INT iLength, INT nSteps ) ;
    void Reset ( void ) ;
    INT NextPosition (void) ;
    INT PrevPosition (void) ;
    INT StepTo (INT nSteps) ;

    INT StepNum (void) { return m_iStepNum; }
    INT PrevStepNum (INT iPosition);

    INT Position (void) { return m_iPos; }
    INT StepCount (void) { return m_iStepCnt; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\stepper.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    stepper.cpp

Abstract:

    Implements time keeping and display in the graph window.

--*/

#include "polyline.h"

CStepper::CStepper()
{
    m_iPos = 0;
    m_iStepNum = 0;
    m_iStepCnt = 1;
}

void CStepper::Init(INT iLength, INT iStepCnt)
{
    m_iStepCnt = iStepCnt ? iStepCnt : 1;
    m_iStepSize = iLength / m_iStepCnt;
    m_iRemainder = iLength - m_iStepCnt * m_iStepSize;

    m_iState = m_iStepCnt;
    m_iPos = 0;
    m_iStepNum = 0;
}

void CStepper::Reset()
{
    m_iPos = 0;
    m_iStepNum = 0;
    m_iState = m_iStepCnt;
}

INT CStepper::NextPosition()
{
    m_iPos += m_iStepSize;

    m_iState -= m_iRemainder;

    if (m_iState <= 0)
        {
        m_iState += m_iStepCnt;
        m_iPos++;
        }

    m_iStepNum++;

    return m_iPos;
}


INT CStepper::PrevPosition()
{   
    m_iPos -= m_iStepSize;

    m_iState += m_iRemainder;

    if (m_iState > m_iStepCnt)
    {
        m_iState -= m_iStepCnt;
        m_iPos--;
    }

    m_iStepNum--;

    return m_iPos;
}

    
INT CStepper::StepTo(INT nSteps)
{
    INT iDiff;

    iDiff = (nSteps * m_iRemainder) / m_iStepCnt;
    m_iState = (iDiff + 1) * m_iStepCnt - (nSteps * m_iRemainder);

    m_iPos = (nSteps * m_iStepSize) + iDiff;

    m_iStepNum = nSteps;

    return m_iPos;
}

INT CStepper::PrevStepNum( INT iPosition )
{
    INT iStepNum = -1;
    INT iLength;

    // Floating point conversion to integer truncates,
    // so this method returns the step previous to the position.

    iLength = m_iStepCnt * m_iStepSize + m_iRemainder;

    if ( iPosition <= iLength ) {
        // Calculation is (iPosition/iLength) * m_iStepCnt.
        iStepNum = iPosition * m_iStepCnt;
        iStepNum = iStepNum / iLength;
    }

    return iStepNum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\strids.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    strids.h

Abstract:

    This file contains constants for all of the resource strings. It must
    parallel file strings.rc which contains the strings themselves.

    Constants of the form IDS_*_BASE are not strings but are base values
    for use in indexing within the string group. The base value must match the
    ID of the first string and the order of the strings must not be changed.

--*/

#ifndef _STRIDS_H_
#define _STRIDS_H_



#define RCSTRING_MIN_ID     128

// Statistics Bar Labels
#define IDS_STAT_BASE       128
#define IDS_LAST            128
#define IDS_AVERAGE         129
#define IDS_MINIMUM         130
#define IDS_MAXIMUM         131
#define IDS_GRAPH_TIME      132 

// Legend Labels
#define IDS_LEGEND_BASE     135
#define IDS_COLOR           135
#define IDS_SCALE           136
#define IDS_COUNTER         137
#define IDS_INSTANCE        138
#define IDS_PARENT          139
#define IDS_OBJECT          140
#define IDS_SYSTEM          141

// OLE Strings
#define IDS_USERTYPE        144
#define IDS_CLOSECAPTION    145
#define IDS_CLOSEPROMPT     146

// Property Page Titles
#define IDS_PROPFRM_TITLE       150
#define IDS_CTR_PROPP_TITLE     151
#define IDS_GEN_PROPP_TITLE     152
#define IDS_GRAPH_PROPP_TITLE   153
#define IDS_SRC_PROPP_TITLE     154
#define IDS_APPEAR_PROPP_TITLE  155

// Error Messages
#define IDS_VERTMIN_ERR         160
#define IDS_VERTMAX_ERR         161
#define IDS_SCALE_ERR           162
#define IDS_DUPL_PATH_ERR       163
#define IDS_NOLOGFILE_ERR       164
#define IDS_INTERVAL_ERR        165
#define IDS_DISPLAY_INT_ERR     166
#define IDS_BADDATASOURCE_ERR   167
#define IDS_NOSYSMONOBJECT_ERR  168
#define IDS_SAVEAS_ERR          169
#define IDS_TOO_FEW_SAMPLES_ERR 170
#define IDS_LARGE_LOG_FILE_RELOAD   171
#define IDS_LOG_FILE_TOO_LARGE_ERR  172
#define IDS_LOGSET_NOT_FOUND    173
#define IDS_READFILE_ERR        174
#define IDS_ADD_COUNTER_ERR     175
#define IDS_ADD_LOG_FILE_ERR    176

// toolbar tooltip strings
#define IDS_TB_BASE             177
#define IDS_TB_TOOLBAR          177
#define IDS_TB_NEW              178
#define IDS_TB_CLEAR            179
#define IDS_TB_REALTIME         180
#define IDS_TB_LOGFILE          181
#define IDS_TB_CHART            182
#define IDS_TB_HISTOGRAM        183
#define IDS_TB_REPORT           184
#define IDS_TB_ADD              185
#define IDS_TB_DELETE           186
#define IDS_TB_HIGHLIGHT        187
#define IDS_TB_COPY             188
#define IDS_TB_PASTE            189
#define IDS_TB_PROPERTIES       190
#define IDS_TB_FREEZE           191
#define IDS_TB_UPDATE           192
#define IDS_TB_HELP             193


// Appearance and BorderStyle

#define IDS_APPEARANCE_FLAT     196
#define IDS_APPEARANCE_3D       197
#define IDS_BORDERSTYLE_NONE    198
#define IDS_BORDERSTYLE_SINGLE  199

// Copy/Paste
#define IDS_HTML_OBJECT_HEADER      200
#define IDS_HTML_OBJECT_FOOTER      201
#define IDS_HTML_PARAM_TAG          202
#define IDS_HTML_VALUE_TAG          203
#define IDS_HTML_VALUE_EOL_TAG      204
#define IDS_HTML_PARAM_SEARCH_TAG   205
#define IDS_HTML_VALUE_SEARCH_TAG   206

// Save As
#define IDS_HTML_FILE               210
#define IDS_HTM_EXTENSION           211
#define IDS_HTML_FILE_HEADER1       212
#define IDS_HTML_FILE_HEADER2       213
#define IDS_HTML_FILE_FOOTER        214
#define IDS_HTML_FILE_OVERWRITE     215
#define IDS_TSV_EXTENSION           216
#define IDS_DEF_EXT                 217
#define IDS_COMPUTER                218
#define IDS_OBJECT_NAME             219
#define IDS_REPORT_HEADER           220
#define IDS_REPORT_INTERVAL         221
#define IDS_REPORT_REAL_TIME        222
#define IDS_REPORT_LOG_START        223
#define IDS_REPORT_LOG_STOP         224
#define IDS_REPORT_DATE_TIME        225
#define IDS_REPORT_START_STOP       226
#define IDS_REPORT_VALUE_TYPE       227
#define IDS_LOG_FILE                228
#define IDS_LOG_FILE_EXTENSION      229
#define IDS_CSV_EXTENSION           230
#define IDS_BLG_EXTENSION           231
#define IDS_SAVE_DATA_CAPTION       232
#define IDS_HTML_EXTENSION          233

// Miscellaneous
#define IDS_APP_NAME                250
#define IDS_DEFAULT                 251
#define IDS_ADDCOUNTERS             252
#define IDS_SAMPLE_DATA_OVERWRITE   253
#define IDS_SAMPLE_DATA_MISSING     254
#define IDS_DEFAULT_LOG_FILE_FOLDER 255

#define IDS_COLORCHOICE_GRAPH       256
#define IDS_COLORCHOICE_CONTROL     257
#define IDS_COLORCHOICE_TEXT        258 
#define IDS_COLORCHOICE_GRID        259
#define IDS_COLORCHOICE_TIMEBAR     260
#define IDS_HTML_FILE_HEADER2RTL    261

// Command line arguments
#define IDS_CMDARG_WMI              300
#define IDS_CMDARG_SETTINGS         301

//TraceLog Message
#define IDS_TRACE_LOG_ERR_MSG       350
#define IDS_HTML_LOG_TYPE           351 

// More error messages
#define IDS_NO_SQL_DSN_ERR              400
#define IDS_NO_SQL_LOG_SET_ERR          401
#define IDS_DUPL_LOGFILE_ERR            402
#define IDS_MULTILOG_BIN_TYPE_ADD_ERR   403
#define IDS_MULTILOG_TEXT_TYPE_ADD_ERR  404
#define IDS_MULTILOG_BIN_TYPE_ERR       405
#define IDS_MULTILOG_TEXT_TYPE_ERR      406
#define IDS_MULTILOG_CHECKTYPE_ERR      407
#define IDS_MULTILOG_TIMERANGE_ERR      408
#define IDS_FILTER_VALUE_ERR            409
#define IDS_SCRIPT_NOT_ALLOWED          410
#define IDS_COUNTER_TRUNCATION_ERR      411
#define IDS_FILENAME_TRUNCATION_ERR     412

#endif // _STRIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\statbar.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    statbar.h

Abstract:

    <abstract>

--*/

#ifndef _STATBAR_H_
#define _STATBAR_H_

#define SZ_HRTIME_FORMAT    TEXT("%1d%s%02d%s%02d")
#define SZ_MINTIME_FORMAT   TEXT("%1d%s%02d")
#define SZ_DAYTIME_FORMAT   TEXT("%1dD %1d%s%02d")

#define E_MEDIUM_VALUE      999999.999
#define E_LARGE_VALUE       9999999999.0
#define E_TOO_LARGE_VALUE   1.0E+20

#define SZ_VALUE_TOO_HIGH       TEXT("+ + + +")
#define SZ_VALUE_TOO_LOW        TEXT("- - - -")

#define LABEL_MARGIN 12
#define VALUE_MARGIN 4
#define RECT_BORDER 1
#define LINE_SPACING (2 * RECT_BORDER + 4)

#define STAT_LAST   0
#define STAT_AVG    1
#define STAT_MIN    2
#define STAT_MAX    3
#define STAT_TIME   4
#define STAT_ITEM_CNT   5

// Structure for one item
typedef struct _STAT_ITEM {
   INT      xPos ;
   INT      yPos ;
   INT      xLabelWidth;
   double   dNewValue;
   double   dValue ;
   INT      iInitialized ;
   DWORD    dwCounterType;
   } STAT_ITEM, *PSTAT_ITEM ;

class CSysmonControl;
class CGraphItem;

class CStatsBar
{
    private:

        enum eStatFormat {
            eMinimumWidth = 10,
            eSmallPrecision = 3,
            eMediumPrecision = 0,
            eLargePrecision = 4,
            eIntegerPrecision = 0
        };
        
        void DrawValues (HDC hDC, BOOL bForce);

        CSysmonControl  *m_pCtrl;   
        STAT_ITEM       m_StatItem[STAT_ITEM_CNT];
        RECT            m_Rect;
        INT             m_iFontHeight;
        INT             m_iValueWidth;
        PCGraphItem     m_pGraphItemToInit;     
   
    
    public:

        CStatsBar (void);
        ~CStatsBar (void);

        BOOL Init (CSysmonControl *pCtrl, HWND hWnd);
        void SizeComponents(LPRECT pRect);
        void SetTimeSpan(double dSeconds);
        INT  Height (INT iMaxHeight, INT iMaxWidth);
        void ChangeFont(HDC hDC);

        void Draw (HDC hDC, HDC hAttribDC, PRECT prcUpdate);
        void Update(HDC hDC, CGraphItem* pGraphItem);
        void Clear( void );
        void GetUpdateRect( PRECT pRect ) { *pRect = m_Rect; } 
};

typedef CStatsBar *PSTATSBAR;

#endif // _STATBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\srcprop.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    srcprop.h

Abstract:

    Data Source Property Page

--*/

#ifndef _SRCPROP_H_
#define _SRCPROP_H_

#include <sqlext.h>
#include "timerng.h"
#include "smonprop.h"

// Dialog Controls
#define IDD_SRC_PROPP_DLG       400
#define IDC_SRC_REALTIME        401
#define IDC_SRC_LOGFILE         402
#define IDC_SRC_SQL             403     // IDH value is out of sync, should still work
#define IDC_SRC_GROUP           405
#define IDC_TIME_GROUP          406
#define IDC_TIMERANGE           407
#define IDC_TIMESELECTBTN       408
#define IDC_STATIC_TOTAL        410
#define IDC_STATIC_SELECTED     411

#define IDC_LIST_LOGFILENAME    412
#define IDC_ADDFILE             413
#define IDC_REMOVEFILE          414

#define IDC_DSN_COMBO           416
#define IDC_LOGSET_COMBO        417
#define IDC_STATIC_DSN          418
#define IDC_STATIC_LOGSET       419

#define REALTIME_SRC       1
#define LOGFILE_SRC        2

//
// The maximum lenght of log set name must be greater
// than or equal to that in smlogsvc.exe.
//
#define SLQ_MAX_LOG_SET_NAME_LEN 255

typedef struct _LogItemInfo {
    struct _LogItemInfo*   pNextInfo;   // For "Deleted" list
    ILogFileItem*   pItem;
    LPWSTR      pszPath;
} LogItemInfo, *PLogItemInfo;

// Data source property page class
class CSourcePropPage : public CSysmonPropPage
{
    public:
        
                CSourcePropPage(void);
        virtual ~CSourcePropPage(void);

        virtual BOOL Init( void );

    protected:

        virtual BOOL    GetProperties(void);   //Read current properties
        virtual BOOL    SetProperties(void);   //Set new properties
        virtual BOOL    InitControls(void);
        virtual void    DeinitControls(void);       // Deinitialize dialog controls
        virtual void    DialogItemChange(WORD wId, WORD wMsg); // Handle item change
        virtual HRESULT EditPropertyImpl( DISPID dispID);   // Set focus control      

    private:

        enum eConstants {
            ePdhLogTypeRetiredBinary = 3
        };
        
                DWORD   OpenLogFile(void); // Open log file and get time range
                void    SetTimeRangeCtrlState ( BOOL bValidLogFile, BOOL bValidLogFileRange );  
                BOOL    AddItemToFileListBox ( PLogItemInfo pInfo );
                BOOL    RemoveItemFromFileListBox ( void );
                void    OnLogFileChange ( void );
                void    OnSqlDataChange ( void );
                void    InitSqlDsnList(void);
                void    InitSqlLogSetList(void);
                void    SetSourceControlStates(void);
                void    LogFilesAreValid ( PLogItemInfo pNewInfo, BOOL& rbNewIsValid, BOOL& rbExistingIsValid );

                DWORD   BuildLogFileList (
                            HWND    hwndDlg,
                            LPWSTR  szLogFileList,
                            ULONG*  pulBufLen );

        PCTimeRange m_pTimeRange;

        // Properties
        DataSourceTypeConstants m_eDataSourceType;
        BOOL        m_bInitialTimeRangePending;
        LONGLONG    m_llStart;
        LONGLONG    m_llStop;
        LONGLONG    m_llBegin;
        LONGLONG    m_llEnd;
        HLOG        m_hDataSource;
        DWORD       m_dwMaxHorizListExtent;
        WCHAR       m_szSqlDsnName[SQL_MAX_DSN_LENGTH + 1];       
        WCHAR       m_szSqlLogSetName[SLQ_MAX_LOG_SET_NAME_LEN + 1];
        PLogItemInfo    m_pInfoDeleted;


        // Property change flags
        BOOL    m_bLogFileChg;
        BOOL    m_bSqlDsnChg;
        BOOL    m_bSqlLogSetChg;
        BOOL    m_bRangeChg;
        BOOL    m_bDataSourceChg;
};
typedef CSourcePropPage *PCSourcePropPage;

// {0CF32AA1-7571-11d0-93C4-00AA00A3DDEA}
DEFINE_GUID(CLSID_SourcePropPage,
        0xcf32aa1, 0x7571, 0x11d0, 0x93, 0xc4, 0x0, 0xaa, 0x0, 0xa3, 0xdd, 0xea);

#endif //_SRCPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\strnoloc.h ===
#ifndef _STR_NO_LOC_H_
#define _STR_NO_LOC_H_

class CGlobalString {
public:
    CGlobalString() {};
    ~CGlobalString() {};

    static LPCWSTR m_cszVersion;
    static LPCWSTR m_cszLogType;
    static LPCWSTR m_cszExtentX;
    static LPCWSTR m_cszExtentY;
    static LPCWSTR m_cszDisplayType;
    static LPCWSTR m_cszReportValueType;
    static LPCWSTR m_cszMaximumScale;
    static LPCWSTR m_cszMinimumScale;
    static LPCWSTR m_cszAppearance;
    static LPCWSTR m_cszBorderStyle;
    static LPCWSTR m_cszShowLegend;
    static LPCWSTR m_cszShowToolBar;
    static LPCWSTR m_cszShowValueBar;
    static LPCWSTR m_cszShowScaleLabels;
    static LPCWSTR m_cszShowHorizontalGrid;
    static LPCWSTR m_cszShowVerticalGrid;
    static LPCWSTR m_cszHighLight;
    static LPCWSTR m_cszManualUpdate;
    static LPCWSTR m_cszReadOnly;
    static LPCWSTR m_cszMonitorDuplicateInstance;
    static LPCWSTR m_cszUpdateInterval;
    static LPCWSTR m_cszDisplayFilter;
    static LPCWSTR m_cszBackColorCtl;
    static LPCWSTR m_cszBackColor;
    static LPCWSTR m_cszForeColor;
    static LPCWSTR m_cszGridColor;
    static LPCWSTR m_cszTimeBarColor;
    static LPCWSTR m_cszGraphTitle;
    static LPCWSTR m_cszYAxisLabel;
    static LPCWSTR m_cszSqlDsnName;
    static LPCWSTR m_cszSqlLogSetName;
    static LPCWSTR m_cszLogViewStart;
    static LPCWSTR m_cszLogViewStop;
    static LPCWSTR m_cszDataSourceType;
    static LPCWSTR m_cszAmbientFont;
    static LPCWSTR m_cszNextCounterColor;
    static LPCWSTR m_cszNextCounterWidth;
    static LPCWSTR m_cszLogFileName;
    static LPCWSTR m_cszLogFileCount;
    static LPCWSTR m_cszCounterCount;
    static LPCWSTR m_cszMaximumSamples;
    static LPCWSTR m_cszSampleCount;
    static LPCWSTR m_cszSampleIndex;
    static LPCWSTR m_cszStepNumber;
    static LPCWSTR m_cszSelected;
    static LPCWSTR m_cszNextCounterLineStyle;
    static LPCWSTR m_cszCounter;
    static LPCWSTR m_cszLogNameFormat;
    static LPCWSTR m_cszHtmlObjectHeader; 
    static LPCWSTR m_cszHtmlObjectFooter;  
    static LPCWSTR m_cszHtmlParamTag;      
    static LPCWSTR m_cszHtmlValueTag;      
    static LPCWSTR m_cszHtmlParamSearchTag;
    static LPCWSTR m_cszHtmlValueSearchTag;
    static LPCWSTR m_cszHtmlValueEolTag;   
    static LPCWSTR m_cszHtmlFileHeader;   
    static LPCWSTR m_cszHtmlFileHeaderRTL;
    static LPCWSTR m_cszHtmlFileFooter;    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\strnoloc.cpp ===
#include <windows.h>
#include "strnoloc.h"

LPCWSTR CGlobalString::m_cszVersion                   = L"_Version";
LPCWSTR CGlobalString::m_cszLogType                   = L"LogType";
LPCWSTR CGlobalString::m_cszExtentX                   = L"_ExtentX";
LPCWSTR CGlobalString::m_cszExtentY                   = L"_ExtentY";
LPCWSTR CGlobalString::m_cszDisplayType               = L"DisplayType";
LPCWSTR CGlobalString::m_cszReportValueType           = L"ReportValueType";
LPCWSTR CGlobalString::m_cszMaximumScale              = L"MaximumScale";
LPCWSTR CGlobalString::m_cszMinimumScale              = L"MinimumScale";
LPCWSTR CGlobalString::m_cszAppearance                = L"Appearance";
LPCWSTR CGlobalString::m_cszBorderStyle               = L"BorderStyle";
LPCWSTR CGlobalString::m_cszShowLegend                = L"ShowLegend";
LPCWSTR CGlobalString::m_cszShowToolBar               = L"ShowToolbar";
LPCWSTR CGlobalString::m_cszShowValueBar              = L"ShowValueBar";
LPCWSTR CGlobalString::m_cszShowScaleLabels           = L"ShowScaleLabels";
LPCWSTR CGlobalString::m_cszShowHorizontalGrid        = L"ShowHorizontalGrid";
LPCWSTR CGlobalString::m_cszShowVerticalGrid          = L"ShowVerticalGrid";
LPCWSTR CGlobalString::m_cszHighLight                 = L"Highlight";
LPCWSTR CGlobalString::m_cszManualUpdate              = L"ManualUpdate";
LPCWSTR CGlobalString::m_cszReadOnly                  = L"ReadOnly";
LPCWSTR CGlobalString::m_cszMonitorDuplicateInstance  = L"MonitorDuplicateInstances";
LPCWSTR CGlobalString::m_cszUpdateInterval            = L"UpdateInterval";
LPCWSTR CGlobalString::m_cszDisplayFilter             = L"DisplayFilter";
LPCWSTR CGlobalString::m_cszBackColorCtl              = L"BackColorCtl";
LPCWSTR CGlobalString::m_cszBackColor                 = L"BackColor";
LPCWSTR CGlobalString::m_cszForeColor                 = L"ForeColor";
LPCWSTR CGlobalString::m_cszGridColor                 = L"GridColor";
LPCWSTR CGlobalString::m_cszTimeBarColor              = L"TimeBarColor";
LPCWSTR CGlobalString::m_cszGraphTitle                = L"GraphTitle";
LPCWSTR CGlobalString::m_cszYAxisLabel                = L"YAxisLabel";
LPCWSTR CGlobalString::m_cszSqlDsnName                = L"SqlDsnName";
LPCWSTR CGlobalString::m_cszSqlLogSetName             = L"SqlLogSetName";
LPCWSTR CGlobalString::m_cszLogViewStart              = L"LogViewStart";
LPCWSTR CGlobalString::m_cszLogViewStop               = L"LogViewStop";
LPCWSTR CGlobalString::m_cszDataSourceType            = L"DataSourceType";
LPCWSTR CGlobalString::m_cszAmbientFont               = L"AmbientFont";
LPCWSTR CGlobalString::m_cszNextCounterColor          = L"NextCounterColor";
LPCWSTR CGlobalString::m_cszNextCounterWidth          = L"NextCounterWidth";
LPCWSTR CGlobalString::m_cszNextCounterLineStyle      = L"NextCounterLineStyle";
LPCWSTR CGlobalString::m_cszLogFileName               = L"LogFileName";
LPCWSTR CGlobalString::m_cszLogFileCount            = L"LogFileCount";
LPCWSTR CGlobalString::m_cszCounterCount              = L"CounterCount";
LPCWSTR CGlobalString::m_cszMaximumSamples            = L"MaximumSamples";
LPCWSTR CGlobalString::m_cszSampleCount               = L"SampleCount";
LPCWSTR CGlobalString::m_cszSampleIndex               = L"SampleIndex";
LPCWSTR CGlobalString::m_cszStepNumber                = L"StepNumber";
LPCWSTR CGlobalString::m_cszSelected                  = L"Selected";
LPCWSTR CGlobalString::m_cszCounter                 = L"Counter";
LPCWSTR CGlobalString::m_cszLogNameFormat           = L"%s%03d";

LPCWSTR CGlobalString::m_cszHtmlObjectHeader        = L"<OBJECT ID=\"DISystemMonitor1\" WIDTH=\"100%\" HEIGHT=\"100%\"\r\nCLASSID=\"CLSID:C4D2D8E0-D1DD-11CE-940F-008029004347\">\r\n";
LPCWSTR CGlobalString::m_cszHtmlObjectFooter        = L"</OBJECT>";
LPCWSTR CGlobalString::m_cszHtmlParamTag            = L"\t<PARAM NAME=\"";
LPCWSTR CGlobalString::m_cszHtmlValueTag            = L"\" VALUE=\"";
LPCWSTR CGlobalString::m_cszHtmlParamSearchTag      = L"PARAM NAME";
LPCWSTR CGlobalString::m_cszHtmlValueSearchTag      = L"VALUE";
LPCWSTR CGlobalString::m_cszHtmlValueEolTag         = L"\"/>\r\n";

LPCWSTR CGlobalString::m_cszHtmlFileHeader         = L"<HTML>\r\n<HEAD>\r\n<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html;\" />\r\n<META NAME=\"GENERATOR\" Content=\"Microsoft System Monitor\" />\r\n</HEAD>\r\n<BODY>\r\n";
LPCWSTR CGlobalString::m_cszHtmlFileHeaderRTL      = L"<HTML DIR=\"RTL\">\r\n<HEAD>\r\n<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html;\" />\r\n<META NAME=\"GENERATOR\" Content=\"Microsoft System Monitor\" />\r\n</HEAD>\r\n<BODY>\r\n";

LPCWSTR CGlobalString::m_cszHtmlFileFooter          = L"\r\n</BODY>\r\n</HTML>";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\strtable.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    strtable.h

Abstract:

    <abstract>

--*/

class CStringTable
    {
    protected:
        UINT            m_idsMin;
        UINT            m_idsMax;
        USHORT          m_cStrings;
        LPWSTR         *m_ppszTable;

    public:
        CStringTable(void);
        ~CStringTable(void);

        BOOL Init( UINT idsMin, UINT idsMax );

        //Function to resolve an ID into a string pointer.
        LPWSTR operator []( const UINT );
    };


typedef CStringTable *PCStringTable;

#ifdef  CCHSTRINGMAX
#undef  CCHSTRINGMAX
#endif
#define CCHSTRINGMAX	256		


// Global instance of string table
extern CStringTable StringTable;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\strtable.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    strtable.cpp

Abstract:

    Implementation of a string table handler.  The CStringTable
    class hides details of storage from the user.  The strings might
    be cached, or they might be loaded as necessary.  In either case,
    we must know the number of strings so we know whether or not to
    reload strings.

--*/

#include <windows.h>
#include <malloc.h>
#include "polyline.h"
#include "strtable.h"

// Create global instance of table
CStringTable StringTable;

/*
 * CStringTable::CStringTable
 * CStringTable::~CStringTable
 *
 * Constructor Parameters:
 *  hInst           HANDLE to the application instance from which we
 *                  load strings.
 */

CStringTable::CStringTable(void)
{
    m_ppszTable = NULL;
}


CStringTable::~CStringTable(void)
{
    INT i;

    // Free the loaded strings and table
    if (NULL != m_ppszTable)
        {
        for (i=0; i<m_cStrings; i++)
            {
            if (m_ppszTable[i] != NULL)
                free(m_ppszTable[i]);
            }

        free(m_ppszTable);
        }
}


/*
 * CStringTable::Init
 *
 * Purpose:
 *  Initialization function for a StringTable that is prone to
 *  failure.  If this fails then the caller is responsible for
 *  guaranteeing that the destructor is called quickly.
 *
 * Parameters:
 *  idsMin          UINT first identifier in the stringtable
 *  idsMax          UINT last identifier in the stringtable.
 *
 * Return Value:
 *  BOOL            TRUE if the function is successful, FALSE
 *                  otherwise.
 */


BOOL CStringTable::Init(UINT idsMin, UINT idsMax)
{
    UINT        i;

    m_idsMin = idsMin;
    m_idsMax = idsMax;
    m_cStrings = (idsMax - idsMin + 1);

    //Allocate space for the pointer table.
    m_ppszTable = (LPWSTR *)malloc(sizeof(LPWSTR) * m_cStrings);

    if (NULL==m_ppszTable)
        return FALSE;

    // Clear all table entries
    for (i=0; i<m_cStrings; i++)
        m_ppszTable[i] = NULL;

    return TRUE;
}


/*
 * CStringTable::operator[]
 *
 * Purpose:
 *  Returns a pointer to the requested string in the stringtable or
 *  NULL if the specified string does not exist.
 */

LPWSTR CStringTable::operator[] (const UINT uID)
{
    WCHAR   szBuf[CCHSTRINGMAX];
    LPWSTR  psz;
    INT     iLen;
    static  WCHAR szMissing[] = L"????";

    // if string not in range, return NULL
    if (uID < m_idsMin || uID > m_idsMax)
        return szMissing;

    // if already loaded, return it
    if (m_ppszTable[uID - m_idsMin] != NULL)
        return m_ppszTable[uID - m_idsMin];

    BEGIN_CRITICAL_SECTION
    // if selected string not loaded, load it now
    if (m_ppszTable[uID - m_idsMin] == NULL)
        {
        iLen = LoadString(g_hInstance, uID, szBuf, CCHSTRINGMAX - 1);
        if (iLen == 0)
            lstrcpy(szBuf, szMissing);

        psz = (LPWSTR)malloc((iLen + 1) * sizeof(WCHAR));
        if (psz != NULL)
            {
            lstrcpy(psz, szBuf);
            m_ppszTable[uID - m_idsMin] = psz;
            }
        }
    END_CRITICAL_SECTION

    // Now return selected pointer
    return m_ppszTable[uID - m_idsMin];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\timerng.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    timerng.h

Abstract:

    <abstract>

--*/

#ifndef _TIMERNG_H_
#define _TIMERNG_H_


#include "intrvbar.h"

class CTimeRange
{
    friend LRESULT APIENTRY TimeRangeWndProc (
        HWND hWnd,
        UINT uiMsg,
        WPARAM wParam,
        LPARAM lParam
        );

    private:
       HWND              m_hWnd;
       PCIntervalBar     m_pIntrvBar;
       HFONT             m_hFont ;

       LONGLONG          m_llBegin;     
       LONGLONG          m_llEnd;
       LONGLONG          m_llStart;
       LONGLONG          m_llStop;

       INT               m_yFontHeight ;
       INT               m_xMaxTimeWidth ;
       INT               m_xBegin ;
       INT               m_xEnd ;
   
       RECT              m_rectStartDate ;
       RECT              m_rectStartTime ;
       RECT              m_rectStopDate ;
       RECT              m_rectStopTime ;

       INT               m_iCurrentStartPos ;
       INT               m_iCurrentStopPos ;

       INT MaxTimeWidth ( HDC hDC );
       void DrawBeginEnd ( HDC hDC );
       void DrawStartStop ( HDC hDC );

       void OnSize ( INT xWidth, INT yHeight );

    public:
        CTimeRange ( HWND hWnd );
       ~CTimeRange ( void );
        BOOL Init  ( void );

        void SetBeginEnd (LONGLONG llBegin, LONGLONG llEnd);
        void SetStartStop ( LONGLONG llStart, LONGLONG llStop );
        LONGLONG GetStart ( void ) { return m_llStart; }
        LONGLONG GetStop ( void ) { return m_llStop; }
   };

typedef CTimeRange *PCTimeRange;


BOOL RegisterTimeRangeClass (void) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\toolbar.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    toolbar.cpp

Abstract:

    <abstract>

--*/

#include "toolbar.h"
#include "globals.h"

// define the toolbar button properties for each toolbar button
// these will be added to the toolbar structure as determined by the bitmap
//
// BUGBUG: TBBUTTON structure changed!!!
TBBUTTON SysmonToolbarButtons[] = {
    // include this separator on ALL toolbars
    {(int)sysmonTbBlank,            0,                 TBSTATE_ENABLED, TBSTYLE_SEP,        0, 0},
    {(int)sysmonTbNew,              IDM_TB_NEW,        TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbBlank,            0,                 TBSTATE_ENABLED, TBSTYLE_SEP,        0, 0},
    {(int)sysmonTbClear,            IDM_TB_CLEAR,      TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbBlank,            0,                 TBSTATE_ENABLED, TBSTYLE_SEP,        0, 0},
    {(int)sysmonTbCurrentActivity,  IDM_TB_REALTIME,   TBSTATE_ENABLED, TBSTYLE_CHECK,      0, 0},
    {(int)sysmonTbLogData,          IDM_TB_LOGFILE,    TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbBlank,            0,                 TBSTATE_ENABLED, TBSTYLE_SEP,        0, 0},
    {(int)sysmonTbChartDisplay,     IDM_TB_CHART,      TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0, 0},
    {(int)sysmonTbHistogramDisplay, IDM_TB_HISTOGRAM,  TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0, 0},
    {(int)sysmonTbReportDisplay,    IDM_TB_REPORT,     TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, 0, 0},
    {(int)sysmonTbBlank,            0,                 TBSTATE_ENABLED, TBSTYLE_SEP,        0, 0},
    {(int)sysmonTbAdd,              IDM_TB_ADD,        TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbDelete,           IDM_TB_DELETE,     TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbHighlight,        IDM_TB_HIGHLIGHT,  TBSTATE_ENABLED, TBSTYLE_CHECK,      0, 0},
    {(int)sysmonTbBlank,            0,                 TBSTATE_ENABLED, TBSTYLE_SEP,        0, 0},
    {(int)sysmonTbCopy,             IDM_TB_COPY,       TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbPaste,            IDM_TB_PASTE,      TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbProperties,       IDM_TB_PROPERTIES, TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbBlank,            0,                 TBSTATE_ENABLED, TBSTYLE_SEP,        0, 0},
    {(int)sysmonTbFreeze,           IDM_TB_FREEZE,     TBSTATE_ENABLED, TBSTYLE_CHECK,      0, 0},
    {(int)sysmonTbUpdate,           IDM_TB_UPDATE,     0,               TBSTYLE_BUTTON,     0, 0},
    {(int)sysmonTbBlank,            0,                 TBSTATE_ENABLED, TBSTYLE_SEP,        0, 0},
    {(int)sysmonTbHelp,             IDM_TB_HELP,       TBSTATE_ENABLED, TBSTYLE_BUTTON,     0, 0}
};

#define TB_BUTTON_COUNT (DWORD)((DWORD)sysmonTbLastButton + 1)
#define TB_ENTRIES      (sizeof(SysmonToolbarButtons) / sizeof (SysmonToolbarButtons[0]))

CSysmonToolbar::CSysmonToolbar (void)
{
    m_hToolbarWnd     = NULL;
    m_pCtrl           = NULL;
    m_dwToolbarFlags  = TBF_DefaultButtons;
    m_bVisible        = TRUE;
    m_pTbArray        = NULL;
    m_dwBtnCnt        = 0;

    SetRectEmpty(&m_rectToolbar);
}

CSysmonToolbar::~CSysmonToolbar (void)
{
    if (m_hToolbarWnd != NULL) {
        DestroyWindow (m_hToolbarWnd);
        m_hToolbarWnd = NULL;
    }
}

LONG CSysmonToolbar::GetToolbarCmdId (UINT nBtnId)
{
    LONG  lBtnIndex;

    for (lBtnIndex = 0; lBtnIndex < TB_ENTRIES; lBtnIndex++) {
        if (SysmonToolbarButtons[lBtnIndex].iBitmap == (int)nBtnId) {
            return SysmonToolbarButtons[lBtnIndex].idCommand;
        }
    }

    return (LONG)-1;
}

BOOL CSysmonToolbar::Init (CSysmonControl *pCtrl, HWND hWnd)
{
    BOOL    bReturn = TRUE;
    UINT    nIndex;
    DWORD   dwBitMask;
    DWORD   dwStyle;

    if (m_hToolbarWnd == NULL) {

        if ( NULL != pCtrl && NULL != hWnd ) {

            // save pointer to owner control
            m_pCtrl = pCtrl;

            dwStyle = WS_CHILD | WS_BORDER | WS_VISIBLE | TBSTYLE_TOOLTIPS |
                      TBSTYLE_WRAPABLE | TBSTYLE_CUSTOMERASE;

            if (!pCtrl->m_fRTL) {
                dwStyle |= TBSTYLE_TRANSPARENT;
            }

            // create toolbar window
            m_hToolbarWnd = CreateToolbarEx (
                                            hWnd,
                                            dwStyle,
                                            IDM_TOOLBAR,
                                            TB_BUTTON_COUNT,
                                            g_hInstance,
                                            IDB_TOOLBAR,
                                            SysmonToolbarButtons,
                                            TB_ENTRIES,
                                            SMTB_BM_X,
                                            SMTB_BM_Y,
                                            SMTB_BM_X,
                                            SMTB_BM_Y,
                                            sizeof (TBBUTTON));

            if (m_hToolbarWnd != NULL) {
                if (pCtrl->m_fRTL) {
                    SetWindowLongPtr (m_hToolbarWnd,
                                   GWL_EXSTYLE,
                                   GetWindowLongPtr(m_hToolbarWnd,GWL_EXSTYLE) | WS_EX_LAYOUTRTL);
                }

                // set/enable the buttons as desired
                dwBitMask = 0;
                for (nIndex = 0; nIndex < TB_BUTTON_COUNT; nIndex++) {
                    dwBitMask = 1 << nIndex;
                    if ((m_dwToolbarFlags & dwBitMask) == 0) {
                        RemoveButton(nIndex);
                    }
                }


                // hide/show toolbar as desired
                ShowToolbar (m_bVisible);
            } else {
                bReturn = FALSE;
            }
        } else {
            bReturn = FALSE;
        }
    }

    return bReturn;
}

BOOL CSysmonToolbar::GetRect(LPRECT pRect)
{
    BOOL    bReturn = FALSE;

    SetRectEmpty(pRect);

    if (m_hToolbarWnd) {
        if (m_bVisible) {
            bReturn = GetWindowRect (m_hToolbarWnd, pRect);
        } else {
            bReturn = TRUE;
        }
    }

    return bReturn;
}

LONG CSysmonToolbar::Height()
{
    RECT tbRect;

    GetRect (&tbRect);
    return (LONG)(tbRect.bottom - tbRect.top);
}

BOOL CSysmonToolbar::RemoveButton (UINT  nBtnId)
{
    int   nBtnIndex;
    BOOL  bReturn = TRUE;

    if (m_hToolbarWnd != NULL) {
        // find matching toolbar in array
        nBtnIndex = (int)GetToolbarCmdId (nBtnId);
        if (nBtnIndex >= 0) {
            bReturn = (BOOL)SendMessage (m_hToolbarWnd, TB_DELETEBUTTON, nBtnIndex, 0L);
        } else {
            //not found
            bReturn = FALSE;
        }
    } else {
        // no toolbar window
        bReturn = FALSE;
    }

    return bReturn;
}

BOOL CSysmonToolbar::SizeComponents (LPRECT pRect)
{
    //stretch toolbar to fit
    RECT  rNewToolbar;
    int   cX, cY;

    rNewToolbar = *pRect;

    cX = rNewToolbar.right - rNewToolbar.left;
    cY = Height();

    if ((cX > 0) &&  (m_bVisible)) {
        SetWindowPos(m_hToolbarWnd, NULL, 0, 0, cX, cY, SWP_NOMOVE);
    } // else do nothing

    return TRUE;
}

BOOL CSysmonToolbar::EnableButton (UINT nBtnId, BOOL bState)
{
    int     nBtnIndex;
    BOOL    bReturn = TRUE;

    if (m_hToolbarWnd != NULL) {
        // find matching toolbar in array
        nBtnIndex = (int)GetToolbarCmdId (nBtnId);
        if (nBtnIndex >= 0) {
            bReturn = (BOOL)SendMessage (m_hToolbarWnd, TB_ENABLEBUTTON, nBtnIndex, (LONG)bState);
        } else {
            //not found
            bReturn = FALSE;
        }
    } else {
        // no toolbar window
        bReturn = FALSE;
    }

    return bReturn;
}

void 
CSysmonToolbar::PostEnableButton (UINT nBtnId, BOOL bState)
{
    int  nBtnIndex;

    if (m_hToolbarWnd != NULL) {
        // find matching toolbar in array
        nBtnIndex = (int)GetToolbarCmdId (nBtnId);
        if (nBtnIndex >= 0) {
            PostMessage (
                m_hToolbarWnd, 
                TB_ENABLEBUTTON, 
                nBtnIndex, 
                (LPARAM)MAKELONG(bState, 0));
        } 
    }
}

BOOL CSysmonToolbar::SyncToolbar ()
{
    LONG    lPushBtnId = -1;
    LONG    lUnPushBtnId = -1;
    LONG    lUnPush2BtnId;
    LONG    wpBtnIndex;
    BOOL    bClearBtnState;
    BOOL    bBtnState;
    DWORD   dwNumCounters;
    BOOL    bCanModify;
    INT     iDisplayType;
    BOOL    bContinue = TRUE;

    if ( NULL != m_pCtrl ) {
        if ( NULL == m_pCtrl->m_pObj ) {
            bContinue = FALSE;
        }
    } else {
        bContinue = FALSE;
    }

    if ( bContinue ) {
        // get the count of counters in the control to use later
        dwNumCounters = m_pCtrl->m_pObj->m_Graph.CounterTree.NumCounters();

        // Get the Modify state to use later;
        // Buttons disabled for ReadOnly:
        //      New counter set
        //      Current data vs. log file data source
        //      Add counter
        //      Delete counter
        //      Paste
        //      Properties
        //
    
        bCanModify = !m_pCtrl->IsReadOnly();

        // sync data source
        if ( bCanModify ) {        

            wpBtnIndex = GetToolbarCmdId (sysmonTbCurrentActivity);
            if (wpBtnIndex >= 0) {
                PostMessage (m_hToolbarWnd, TB_CHECKBUTTON, wpBtnIndex,(LPARAM)MAKELONG(!m_pCtrl->IsLogSource(), 0));           
            }
        }

        // sync display type
        iDisplayType = m_pCtrl->m_pObj->m_Graph.Options.iDisplayType;
        switch ( iDisplayType ) {
            case LINE_GRAPH:
                lPushBtnId = sysmonTbChartDisplay;
                lUnPushBtnId = sysmonTbHistogramDisplay;
                lUnPush2BtnId = sysmonTbReportDisplay;
                bClearBtnState = TRUE;
                break;

            case BAR_GRAPH:
                lUnPushBtnId = sysmonTbChartDisplay;
                lPushBtnId = sysmonTbHistogramDisplay;
                lUnPush2BtnId = sysmonTbReportDisplay;
                bClearBtnState = TRUE;
                break;

            case REPORT_GRAPH:
                lUnPushBtnId = sysmonTbChartDisplay;
                lUnPush2BtnId = sysmonTbHistogramDisplay;
                lPushBtnId = sysmonTbReportDisplay;
                bClearBtnState = FALSE;
                break;

            default:
                lUnPush2BtnId = 0;
                bClearBtnState = TRUE;
                assert (FALSE);
                break;
        }

        wpBtnIndex = GetToolbarCmdId (lUnPushBtnId);
        if (wpBtnIndex >= 0) {
            PostMessage (m_hToolbarWnd, TB_CHECKBUTTON, wpBtnIndex,(LPARAM)MAKELONG(FALSE, 0));
        }

        wpBtnIndex = GetToolbarCmdId (lUnPush2BtnId);
        if (wpBtnIndex >= 0) {
            PostMessage (m_hToolbarWnd, TB_CHECKBUTTON, wpBtnIndex,(LPARAM)MAKELONG(FALSE, 0));
        }

        wpBtnIndex = GetToolbarCmdId (lPushBtnId);
        if (wpBtnIndex >= 0) {
            PostMessage (m_hToolbarWnd, TB_CHECKBUTTON, wpBtnIndex,(LPARAM)MAKELONG(TRUE, 0));
        }

        // sync update status
        wpBtnIndex = GetToolbarCmdId (sysmonTbFreeze);
        if (wpBtnIndex >= 0) {
            // set push state
            PostMessage (m_hToolbarWnd, TB_CHECKBUTTON, wpBtnIndex,
                (LPARAM)MAKELONG(m_pCtrl->m_pObj->m_Graph.Options.bManualUpdate, 0));
            // set enable state
            bBtnState =  (dwNumCounters > 0);
            PostMessage (m_hToolbarWnd, TB_ENABLEBUTTON, wpBtnIndex,
                (LPARAM)MAKELONG(bBtnState, 0));
        }

        // Manual update button not enabled in design mode.
        bBtnState = m_pCtrl->m_pObj->m_Graph.Options.bManualUpdate 
                        && (dwNumCounters > 0)
                        && m_pCtrl->IsUserMode();
        PostEnableButton ( sysmonTbUpdate, bBtnState );

        // clear display button
        bBtnState = bClearBtnState && (dwNumCounters > 0) && (!m_pCtrl->IsLogSource());
        PostEnableButton ( sysmonTbClear, bBtnState );

        // Help is always enabled
        PostEnableButton ( sysmonTbHelp, TRUE );

        // Add, paste and properties are affected by the ReadOnly state.
        PostEnableButton ( sysmonTbAdd, bCanModify );
        PostEnableButton ( sysmonTbPaste, bCanModify );
        PostEnableButton ( sysmonTbProperties, bCanModify );

        // Data source buttons are affectedby bCanModify;
        PostEnableButton ( sysmonTbLogData, bCanModify );
        PostEnableButton ( sysmonTbCurrentActivity, bCanModify );

        // set the other buttons that are contingent on the presence of counters
        bBtnState = (dwNumCounters > 0);

        // the highlight button is only enabled in line_graph and histogram views

        PostEnableButton ( 
            sysmonTbHighlight, 
            ( bBtnState && ( REPORT_GRAPH != iDisplayType ) ) );
        wpBtnIndex = GetToolbarCmdId (sysmonTbHighlight);
        if (wpBtnIndex >= 0)  {
            PostMessage (m_hToolbarWnd, 
                         TB_CHECKBUTTON, 
                         wpBtnIndex,
                        (LPARAM)MAKELONG(m_pCtrl->m_pObj->m_Graph.Options.bHighlight, 0));
        }

        // the copy button
        PostEnableButton ( sysmonTbCopy, bBtnState );

        // New/reset and delete are affected by ReadOnly state.

        bBtnState = (dwNumCounters > 0) && bCanModify;
    
        // the new/reset button
        PostEnableButton ( sysmonTbNew, bBtnState );

        // the delete button
        PostEnableButton ( sysmonTbDelete, bBtnState );

        bContinue = TRUE;
    }
    return bContinue;
}

BOOL CSysmonToolbar::ShowToolbar (BOOL bVisible)
{
    BOOL  bReturn = m_bVisible;

    if ((m_hToolbarWnd != NULL) && (m_bVisible != bVisible)) {
        // only do this is the window is there and the new stat is different
        // from the old state
        ShowWindow (m_hToolbarWnd, (bVisible ? SW_SHOW : SW_HIDE));

        // update local flag
        m_bVisible = bVisible;

        //sync buttons with the control if it's visible
        if (m_pCtrl && m_bVisible) {
            SyncToolbar ();
        }
    } else {
        if (m_hToolbarWnd != NULL) {
            bReturn = FALSE;
        } else {
            // the state is already as requested so that's ok
            bReturn = TRUE;
        }
    }

    return bReturn;
}

BOOL CSysmonToolbar::SetBackgroundColor (COLORREF ocBackClr)
{

    COLORSCHEME csToolbar;
    LRESULT     lResult;
    BOOL        bReturn = TRUE;

    memset (&csToolbar, 0, sizeof(csToolbar));
    csToolbar.dwSize = sizeof(csToolbar);

    // get current scheme
    lResult = SendMessage (m_hToolbarWnd, 
                           TB_GETCOLORSCHEME, 
                           0, 
                           (LPARAM)&csToolbar);
    if (lResult) {
        // set color
        csToolbar.clrBtnHighlight = ocBackClr;
        // leave shadow color alone
        lResult = SendMessage (m_hToolbarWnd, 
                              TB_SETCOLORSCHEME,
                              0, 
                              (LPARAM)&csToolbar);
        if (!lResult) {
            bReturn = FALSE;
        }
    } else {
        bReturn = FALSE;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\timerng.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    timerng.cpp

Abstract:

    <abstract>

--*/

//==========================================================================//
//                                  Includes                                //
//==========================================================================//
#include <assert.h>
#include <windows.h>
#include "winhelpr.h"
#include "utils.h"
#include "timerng.h"
#include "globals.h"

#define INTRVBAR_RANGE 1000
#define MAX_TIME_CHARS  20
#define MAX_DATE_CHARS  20

WCHAR szTimeRangeClass[] = L"TimeRange";

INT 
CTimeRange::MaxTimeWidth (
    HDC hDC 
    )
/*
   Effect:        Return a reasonable maximum number of pixels to hold
                  expected time and date strings.  

   To Do:         When we use the alleged local-date and local-time display
                  functions, we will modify this routine to use them.
*/
{
   return (max (TextWidth (hDC, L" 99 XXX 99 "),
                TextWidth (hDC, L" 99:99:99.9 PM "))) ;
}

void 
CTimeRange::DrawBeginEnd (
    HDC hDC
    )
{
   WCHAR  szDate [MAX_TIME_CHARS] ;
   WCHAR  szTime [MAX_DATE_CHARS] ;

   SetTextAlign (hDC, TA_TOP) ;
   SelectFont (hDC, m_hFont) ;
   SetBkColor(hDC, GetSysColor(COLOR_3DFACE));
   SetTextColor(hDC, GetSysColor(COLOR_BTNTEXT));

   // Draw the begin time
   FormatDateTime(m_llBegin, szTime, szDate);
   SetTextAlign (hDC, TA_RIGHT) ;
   TextOut (hDC, m_xBegin, 0, szDate, lstrlen (szDate)) ;
   TextOut (hDC, m_xBegin, m_yFontHeight, szTime, lstrlen (szTime)) ;

   // Draw the end time
   FormatDateTime(m_llEnd, szTime, szDate);
   SetTextAlign (hDC, TA_LEFT) ;
   TextOut (hDC, m_xEnd, 0, szDate, lstrlen (szDate)) ;
   TextOut (hDC, m_xEnd, m_yFontHeight, szTime, lstrlen (szTime)) ;
}



void
CTimeRange::DrawStartStop (
    HDC hDC
    )
/*
   Effect:        Draw the start and stop date/times on the bottom of the
                  timeline. Draw the start date/time right justified at the
                  outer edge of the start point and the stop date/time left
                  justified with the outer edge of the stop point.

                  Erase previous start and stop date/times in the process.
*/
{
   RECT           rectDate ;
   RECT           rectTime ;
   RECT           rectOpaque ;

   WCHAR          szTime [MAX_TIME_CHARS] ;
   WCHAR          szDate [MAX_DATE_CHARS] ;

   INT            xStart ;
   INT            xStop ;

   INT            iStart ;
   INT            iStop ;

   INT            xDateTimeWidth ;


   SelectFont (hDC, m_hFont) ;
   SetTextAlign (hDC, TA_TOP) ;
   SetBkColor(hDC, GetSysColor(COLOR_3DFACE));
   SetTextColor(hDC, GetSysColor(COLOR_BTNTEXT));

   //=============================//
   // Get Start Information       //
   //=============================//

   xStart = m_xBegin + m_pIntrvBar->XStart();

   iStart = m_pIntrvBar->Start() ;
   m_llStart = m_llBegin + ((m_llEnd - m_llBegin) * iStart) / INTRVBAR_RANGE;

   FormatDateTime(m_llStart, szTime, szDate);

   xDateTimeWidth = max (TextWidth (hDC, szDate),
                         TextWidth (hDC, szTime)) ;

   //=============================//
   // Write Start Date            //
   //=============================//

   rectDate.left = xStart - xDateTimeWidth ;
   rectDate.top = m_rectStartDate.top ;
   rectDate.right = xStart ;
   rectDate.bottom = m_rectStartDate.bottom ;
 
   SetTextAlign (hDC, TA_RIGHT) ;
   UnionRect (&rectOpaque, &m_rectStartDate, &rectDate) ;

   ExtTextOut (hDC, 
               rectDate.right, rectDate.top,
               ETO_OPAQUE,
               &rectOpaque,
               szDate, lstrlen (szDate),
               NULL) ;
   m_rectStartDate = rectDate ;

   //=============================//
   // Write Start Time            //
   //=============================//
   
   rectTime.left = rectDate.left ;
   rectTime.top = m_rectStartTime.top ;
   rectTime.right = rectDate.right ;
   rectTime.bottom = m_rectStartTime.bottom ;

   UnionRect (&rectOpaque, &m_rectStartTime, &rectTime) ;

   ExtTextOut (hDC, 
               rectTime.right, rectTime.top,
               ETO_OPAQUE,
               &rectOpaque,
               szTime, lstrlen (szTime),
               NULL) ;
   m_rectStartTime = rectTime ;

   //=============================//
   // Get Stop Information        //
   //=============================//

   xStop = m_xBegin + m_pIntrvBar->XStop() ;

   iStop = m_pIntrvBar->Stop () ;
   m_llStop = m_llBegin + ((m_llEnd - m_llBegin) * iStop) / INTRVBAR_RANGE;

   FormatDateTime(m_llStop, szTime, szDate);

   xDateTimeWidth = max (TextWidth (hDC, szDate),
                         TextWidth (hDC, szTime)) ;

   //=============================//
   // Write Stop Date             //
   //=============================//

   rectDate.left = xStop ;
   rectDate.top = m_rectStopDate.top ;
   rectDate.right = xStop + xDateTimeWidth ;
   rectDate.bottom = m_rectStopDate.bottom ;
 
   SetTextAlign (hDC, TA_LEFT) ;
   UnionRect (&rectOpaque, &m_rectStopDate, &rectDate) ;

   ExtTextOut (hDC, 
               rectDate.left, rectDate.top,
               ETO_OPAQUE,
               &rectOpaque,
               szDate, lstrlen (szDate),
               NULL) ;
   m_rectStopDate = rectDate ;

   //=============================//
   // Write Stop Time             //
   //=============================//
   
   rectTime.left = rectDate.left ;
   rectTime.top = m_rectStopTime.top ;
   rectTime.right = rectDate.right ;
   rectTime.bottom = m_rectStopTime.bottom ;

   UnionRect (&rectOpaque, &m_rectStopTime, &rectTime) ;

   ExtTextOut (hDC, 
               rectTime.left, rectTime.top,
               ETO_OPAQUE,
               &rectOpaque,
               szTime, lstrlen (szTime),
               NULL) ;
   m_rectStopTime = rectTime ;
}



//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


CTimeRange::CTimeRange (
    HWND hWnd )
{

    HDC      hDC ;

    // Caller checks for NULL hwnd before calling this procedure
    assert ( NULL != hWnd );

    m_hWnd = hWnd ;

    SetWindowLongPtr(hWnd, 0, (INT_PTR)this);

    m_hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT) ;

    hDC = GetDC (hWnd) ;
    if (hDC) {
        if ( NULL != m_hFont ) {
            SelectFont (hDC, m_hFont) ;
        }
        m_yFontHeight = FontHeight (hDC, TRUE) ;
        m_xMaxTimeWidth = MaxTimeWidth (hDC) ;

        ReleaseDC (hWnd, hDC) ;
    } else {
        m_yFontHeight = 0;
        m_xMaxTimeWidth = 0;
    }

    m_pIntrvBar = NULL;
}


CTimeRange::~CTimeRange (
    void 
    )
{
    if (m_pIntrvBar != NULL) {
        delete m_pIntrvBar;
        m_pIntrvBar = NULL;
    }
}

BOOL
CTimeRange::Init(
    void
    )
{
    RECT        rc;

    m_pIntrvBar = new CIntervalBar();
    if (m_pIntrvBar != NULL) {
        if (m_pIntrvBar->Init(m_hWnd)) {
            // Size now because we didn't exist when the window 
            // got the initial WM_SIZE message
            GetWindowRect(m_hWnd, &rc);
            OnSize(rc.right - rc.left, rc.bottom - rc.top);
            m_pIntrvBar->SetRange(0, INTRVBAR_RANGE);
        }
        else {
            delete m_pIntrvBar;
            m_pIntrvBar = NULL;
        }
    }

    return ( NULL != m_pIntrvBar );
}

void
CTimeRange::OnSize (
    INT xWidth,
    INT yHeight
    )
/*
   Effect:        Perform all actions needed when the size of the timeline
                  hWnd has changed. In particular, determine the appropriate
                  size for the ILine window and set the rectangles for the
                  top and bottom displays.
*/
{
   INT            yLine ;
   INT            yDate, yTime ;
   INT            xEnd ;

   xEnd = xWidth - m_xMaxTimeWidth ;
   yLine = m_yFontHeight ;
   yDate = yHeight - 2 * yLine ;
   yTime = yHeight - yLine ;


   SetRect (&m_rectStartDate, 0, yDate, 0, yDate + yLine) ;

   SetRect (&m_rectStartTime, 0, yTime, 0, yTime + yLine) ;

   SetRect (&m_rectStopDate, xEnd, yDate, xEnd, yDate + yLine) ;

   SetRect (&m_rectStopTime, xEnd, yTime, xEnd, yTime + yLine) ;

   MoveWindow (m_pIntrvBar->Window(),
               m_xMaxTimeWidth, 2 * m_yFontHeight,
               xWidth - 2 * m_xMaxTimeWidth,
               yHeight - 4 * m_yFontHeight,
               FALSE) ;

   m_xBegin = m_xMaxTimeWidth ;
   m_xEnd = xWidth - m_xMaxTimeWidth ;
}


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


LRESULT APIENTRY TimeRangeWndProc (
    HWND hWnd,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*
   Note:          This function must be declared in the application's
                  linker-definition file, perfmon.def file.
*/
{
   BOOL           bCallDefWindowProc ;
   LRESULT        lrsltReturnValue ;
   PCTimeRange    pTimeRange = (PCTimeRange) GetWindowLongPtr(hWnd, 0);;
   bCallDefWindowProc = FALSE ;
   lrsltReturnValue = 0L ;


    if (pTimeRange) {

       switch ( uiMsg ) {

          case WM_SETFOCUS:
             return 0 ;

          case WM_KILLFOCUS:
             return 0 ;

          case WM_ENABLE:
              WindowInvalidate(hWnd);
              EnableWindow(pTimeRange->m_pIntrvBar->Window(), (BOOL)wParam);
              break;

          case WM_COMMAND:
              { 
                HDC hDC;

                hDC = GetDC (hWnd) ;
                if (hDC) {
                    pTimeRange->DrawStartStop (hDC) ;
                    ReleaseDC (hWnd, hDC) ;
                }
                SendMessage(
                    WindowParent(hWnd),
                    WM_COMMAND, (WPARAM)WindowID(hWnd), (LPARAM)hWnd);
             }
             break ;

          case WM_PAINT:
             {
                HDC          hDC ;
                PAINTSTRUCT  ps ;

                hDC = BeginPaint (hWnd, &ps) ;
                
                if (hDC) {
                    if (IsWindowEnabled(hWnd)) {
                        pTimeRange->DrawBeginEnd (hDC) ;
                        pTimeRange->DrawStartStop (hDC) ;
                    }

                    EndPaint (hWnd, &ps) ;
                }
             }
             break ;

          case WM_SIZE:
             pTimeRange->OnSize (LOWORD (lParam), HIWORD (lParam)) ;
             break ;

          default:
             bCallDefWindowProc = TRUE ;
          }
    }
    else {
        bCallDefWindowProc = TRUE;
    }

    if (bCallDefWindowProc)
        lrsltReturnValue = DefWindowProc (hWnd, uiMsg, wParam, lParam) ;

   return (lrsltReturnValue) ;
}



BOOL RegisterTimeRangeClass (
    void
    )
{

#define dwTimeRangeClassStyle  (CS_HREDRAW | CS_VREDRAW)

    BEGIN_CRITICAL_SECTION

    // Register window class once
    if (pstrRegisteredClasses[TIMERANGE_WNDCLASS] == NULL) {

           WNDCLASS       wc ;

           wc.style =           dwTimeRangeClassStyle ;
           wc.lpfnWndProc =     TimeRangeWndProc ;
           wc.cbClsExtra =      0 ;
           wc.cbWndExtra =      sizeof(PCTimeRange);
           wc.hInstance =       g_hInstance ;
           wc.hIcon =           NULL ;
           wc.hCursor =         LoadCursor (NULL, IDC_ARROW) ;
           wc.hbrBackground =   (HBRUSH) (COLOR_3DFACE + 1) ;
           wc.lpszMenuName =    NULL ;
           wc.lpszClassName =   szTimeRangeClass ;

            if (RegisterClass (&wc)) {
                pstrRegisteredClasses[TIMERANGE_WNDCLASS] = szTimeRangeClass;
        }
    }

    END_CRITICAL_SECTION

    return (pstrRegisteredClasses[LEGEND_WNDCLASS] != NULL);
}


void 
CTimeRange::SetBeginEnd ( 
    LONGLONG llBegin, 
    LONGLONG llEnd
    )
{
    HDC hDC;
    m_llBegin = llBegin;
    m_llEnd = llEnd;

    hDC = GetDC (m_hWnd) ;
    
    if (hDC) {
        DrawBeginEnd (hDC) ;
        ReleaseDC (m_hWnd, hDC) ;
    }
}

void 
CTimeRange::SetStartStop (
    LONGLONG    llStart,
    LONGLONG    llStop
    )
{
    INT iStart;
    INT iStop;
    HDC hDC; 
    LONGLONG llBeginToEnd;

    if (llStart < m_llBegin)
        llStart = m_llBegin;

    if (llStop > m_llEnd)
        llStop = m_llEnd;

    m_llStart = llStart;
    m_llStop = llStop;

    llBeginToEnd = m_llEnd - m_llBegin;

    if ( 0 != llBeginToEnd ) {
        iStart = (INT)(((llStart - m_llBegin) * INTRVBAR_RANGE) / llBeginToEnd);
        iStop = (INT)(((llStop - m_llBegin) * INTRVBAR_RANGE) / llBeginToEnd);
    } else {
        iStart = 0;
        iStop = 0;
    }

    m_pIntrvBar->SetStart(iStart);
    m_pIntrvBar->SetStop(iStop);

    hDC = GetDC (m_hWnd) ;
    if (hDC) {
        DrawStartStop (hDC) ;
        ReleaseDC (m_hWnd, hDC) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\toolbar.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    toolbar.h

Abstract:

    <abstract>

--*/

#include <windows.h>
#ifdef _WIN32_IE
#if      _WIN32_IE < 0x0400
#undef     _WIN32_IE
#define    _WIN32_IE 0x0400 // for color scheme info
#endif // < 0x0400
#endif // defined

#include <commctrl.h>
#include <assert.h>
#include "polyline.h"
#include "smonctrl.h"

#ifndef _TOOLBAR_H_
#define _TOOLBAR_H_

#include "resource.h"


// button ID's
// these must correspond to the individual button 
// locations in the toolbar bitmap
enum sysmonTb {
    sysmonTbBlank = -1,
    sysmonTbNew = 0,
    sysmonTbClear,
    sysmonTbCurrentActivity,
    sysmonTbLogData,
    sysmonTbChartDisplay,
    sysmonTbHistogramDisplay,
    sysmonTbReportDisplay,
    sysmonTbAdd,
    sysmonTbDelete,
    sysmonTbHighlight,
    sysmonTbCopy,
    sysmonTbPaste,
    sysmonTbProperties,
    sysmonTbFreeze,
    sysmonTbUpdate,
    sysmonTbHelp, 
    sysmonTbLastButton = sysmonTbHelp
};

// define Toolbar bitmap fields
#define TBF_sysmonTbNew             (DWORD)(0x00000001 << (DWORD)sysmonTbNew)
#define TBF_sysmonTbCurrentActivity (DWORD)(0x00000001 << (DWORD)sysmonTbCurrentActivity)
#define TBF_sysmonTbLogData         (DWORD)(0x00000001 << (DWORD)sysmonTbLogData)
#define TBF_sysmonTbChartDisplay    (DWORD)(0x00000001 << (DWORD)sysmonTbChartDisplay)
#define TBF_sysmonTbHistogramDisplay (DWORD)(0x00000001 << (DWORD)sysmonTbHistogramDisplay)
#define TBF_sysmonTbReportDisplay   (DWORD)(0x00000001 << (DWORD)sysmonTbReportDisplay)
#define TBF_sysmonTbAdd             (DWORD)(0x00000001 << (DWORD)sysmonTbAdd)
#define TBF_sysmonTbDelete          (DWORD)(0x00000001 << (DWORD)sysmonTbDelete)
#define TBF_sysmonTbCopy            (DWORD)(0x00000001 << (DWORD)sysmonTbCopy)
#define TBF_sysmonTbPaste           (DWORD)(0x00000001 << (DWORD)sysmonTbPaste)
#define TBF_sysmonTbProperties      (DWORD)(0x00000001 << (DWORD)sysmonTbProperties)
#define TBF_sysmonTbFreeze          (DWORD)(0x00000001 << (DWORD)sysmonTbFreeze)
#define TBF_sysmonTbUpdate          (DWORD)(0x00000001 << (DWORD)sysmonTbUpdate)
#define TBF_sysmonTbHelp            (DWORD)(0x00000001 << (DWORD)sysmonTbHelp)

// define bitmap & button sizes
#define SMTB_BM_X   16
#define SMTB_BM_Y   15
//#define SMTB_BT_X   20
//#define SMTB_BT_Y   20

// this constant defines the buttons that are defined by default
// it can be edited as desired to alter the default appearance 
// of the bitmap.
#define TBF_DefaultButtons  (DWORD)(\
    TBF_sysmonTbNew             | \
    TBF_sysmonTbCurrentActivity | \
    TBF_sysmonTbLogData         | \
    TBF_sysmonTbChartDisplay    | \
    TBF_sysmonTbHistogramDisplay | \
    TBF_sysmonTbReportDisplay   | \
    TBF_sysmonTbAdd             | \
    TBF_sysmonTbDelete          | \
    TBF_sysmonTbCopy            | \
    TBF_sysmonTbPaste           | \
    TBF_sysmonTbProperties      | \
    TBF_sysmonTbUpdate          | \
    TBF_sysmonTbFreeze          | \
    TBF_sysmonTbHelp            )

class CSysmonControl;

class CSysmonToolbar {
    private:
        LONG    GetToolbarCmdId (UINT nBtnId);
        void    PostEnableButton ( UINT nBtnId, BOOL bState );
        
        HWND            m_hToolbarWnd;
        RECT            m_rectToolbar;
        CSysmonControl  *m_pCtrl;
        DWORD           m_dwToolbarFlags;
        TBBUTTON        *m_pTbArray;
        DWORD           m_dwBtnCnt;
        BOOL            m_bVisible;

    public:
        CSysmonToolbar (void);
        ~CSysmonToolbar (void);

        BOOL    Init            (CSysmonControl *pCtrl, HWND hWnd);
        BOOL    SizeComponents  (LPRECT pRect);
        BOOL    EnableButton    (UINT   nBtnId, BOOL bState);
        BOOL    RemoveButton    (UINT   nBtnId);
        BOOL    ShowToolbar     (BOOL   bVisible);
        BOOL    SyncToolbar     (void);
        BOOL    SetBackgroundColor  (COLORREF   ocBackClr);

        LONG    Height          (void);
        BOOL    GetRect         (LPRECT pRect);     
        
        LRESULT DoCmd           (WPARAM wParam, LPARAM lParam);

};

typedef CSysmonToolbar *PSYSMONTOOLBAR;

#endif //_TOOLBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\unkhlpr.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    unkhlpr.h

Abstract:

    <abstract>

--*/

#define IMPLEMENT_CONTAINED_QUERYINTERFACE(IClassName) \
	STDMETHODIMP IClassName::QueryInterface(REFIID riid, PPVOID ppv)	\
    	{	\
    	return m_pUnkOuter->QueryInterface(riid, ppv);	\
    	}

#define IMPLEMENT_CONTAINED_ADDREF(IClassName) \
		STDMETHODIMP_(ULONG) IClassName::AddRef(void) \
    	{	\
    	++m_cRef;	\
    	return m_pUnkOuter->AddRef();	\
    	}

#define IMPLEMENT_CONTAINED_RELEASE(IClassName) \
	STDMETHODIMP_(ULONG) IClassName::Release(void)	\
    	{	\
    	--m_cRef;	\
    	return m_pUnkOuter->Release();	\
    	}

#define IMPLEMENT_CONTAINED_IUNKNOWN(IClassName) \
	IMPLEMENT_CONTAINED_QUERYINTERFACE(IClassName)	\
	IMPLEMENT_CONTAINED_ADDREF(IClassName)	\
	IMPLEMENT_CONTAINED_RELEASE(IClassName)


#define IMPLEMENT_CONTAINED_CONSTRUCTOR(CClassName, IClassName) \
	IClassName::IClassName(CClassName *pObj, LPUNKNOWN pUnkOuter) \
    {	\
    m_cRef = 0;	\
    m_pObj = pObj;	\
    m_pUnkOuter = pUnkOuter;	\
    return;	\
    }

 #define IMPLEMENT_CONTAINED_DESTRUCTOR(IClassName) \
	IClassName::~IClassName( void ) \
	{	\
		return;	\
	}
	
#define IMPLEMENT_CONTAINED_INTERFACE(CClassName, IClassName) \
	IMPLEMENT_CONTAINED_CONSTRUCTOR(CClassName, IClassName) \
	IMPLEMENT_CONTAINED_DESTRUCTOR(IClassName) \
	IMPLEMENT_CONTAINED_IUNKNOWN(IClassName)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\unihelpr.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    unihelpr.h

Abstract:

    <abstract>

--*/

#ifndef _UNIHELPR_H_
#define _UNIHELPR_H_

/*
    These macros are based on the MFC macros found in file afxconv.h. They have been modified
    slightly to delete references to the MFC helper functions AfxW2AHelper and AfxA2WHelper
    so that the MFC DLL is not required.
*/

#include <malloc.h>

#define _MbToWide(dst, src, cnt) \
	MultiByteToWideChar(CP_ACP, 0, src, (int)cnt, dst, (int)cnt)

#define _WideToMb(dst, src, cnt) \
	WideCharToMultiByte(CP_ACP, 0, src, (int)cnt, dst, (int)(2 * cnt), NULL, NULL)


#define A2CW(lpa) (\
	((LPCSTR)lpa == NULL) ? NULL : ( \
		_convert = (lstrlenA(lpa)+1), \
		_convPtr = alloca(_convert*2), \
		_MbToWide((LPWSTR)_convPtr, lpa, _convert), \
		(LPCWSTR)_convPtr \
	) \
)

#define A2W(lpa) (\
	((LPCSTR)lpa == NULL) ? NULL : ( \
		_convert = (lstrlenA(lpa)+1), \
		_convPtr = alloca(_convert*2), \
		_MbToWide((LPWSTR)_convPtr, lpa, _convert),\
		(LPWSTR)_convPtr \
	) \
)

#define W2CA(lpw) (\
	((LPCWSTR)lpw == NULL) ? NULL : ( \
		_convert = (wcslen(lpw)+1), \
		_convPtr = alloca(_convert*2),  \
		_WideToMb((LPSTR)_convPtr, lpw, _convert), \
		(LPCSTR)_convPtr \
	)\
)

#define W2A(lpw) (\
	((LPCWSTR)lpw == NULL) ? NULL : (\
		_convert = (wcslen(lpw)+1),\
		_convPtr = alloca(_convert*2), \
		_WideToMb((LPSTR)_convPtr, lpw, _convert), \
		(LPSTR)_convPtr \
	)\
)

#ifndef _DEBUG
#define USES_CONVERSION size_t _convert; void *_convPtr; _convPtr, _convert;
#else
#define USES_CONVERSION int _convert = 0; void *_convPtr = NULL; assert( 0 == _convert ); assert( NULL ==_convPtr );
#endif


#ifdef _UNICODE
	#define T2A W2A
	#define A2T A2W
	#define T2W(x)  (x)
	#define W2T(x)  (x)
#else
	#define T2W A2W
	#define W2T W2A
	#define T2A(x)  (x)
	#define A2T(x)  (x)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\visuals.cpp ===
/*++

Copyright (C) 1997-1999 Microsoft Corporation

Module Name:

    visuals.cpp

Abstract:

    Miscellaneous visual utility routines.

--*/

//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include <windows.h>
#include "visuals.h"

//==========================================================================//
//                                  Exported data structures                //
//==========================================================================//

COLORREF argbStandardColors[] =  {
   RGB (0xff, 0x00, 0x00), 
   RGB (0x00, 0x80, 0x00), 
   RGB (0x00, 0x00, 0xff), 
   RGB (0xff, 0xff, 0x00), 
   RGB (0xff, 0x00, 0xff), 
   RGB (0x00, 0xff, 0xff), 
   RGB (0x80, 0x00, 0x00), 
   RGB (0x40, 0x40, 0x40), 
   RGB (0x00, 0x00, 0x80), 
   RGB (0x80, 0x80, 0x00), 
   RGB (0x80, 0x00, 0x80), 
   RGB (0x00, 0x80, 0x80), 
   RGB (0x40, 0x00, 0x00), 
   RGB (0x00, 0x40, 0x00), 
   RGB (0x00, 0x00, 0x40), 
   RGB (0x00, 0x00, 0x00)
};


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//

INT 
ColorToIndex( 
    COLORREF rgbColor
    )
{
    // Returns NumColorStandardColorIndices() if not found. This index is
    // used to indicate custom color.

    INT iColorIndex;

    for (iColorIndex = 0; 
         iColorIndex < NumStandardColorIndices(); 
         iColorIndex++) {

        if (argbStandardColors[iColorIndex] == rgbColor) {
            break;
        }
    }

    return iColorIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\utils.cpp ===
/*++

Copyright (C) 1992-1999 Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

	This file contains miscellaneous utiltity routines, mostly 
	low-level windows helpers. These routines are not specific
	to the System Monitor control.

--*/

//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include <windows.h>
#include <assert.h>
#include <math.h>
#include <winperf.h>
#include "utils.h"
#include "unihelpr.h"
#include "globals.h"
#include "winhelpr.h"
#include "polyline.h"   // For eDataSourceType
#include <strsafe.h>
#include "smonmsg.h"     // For error string IDs.

#define NUM_RESOURCE_STRING_BUFFERS     16
#define MISSING_RESOURCE_STRING  L"????"

#define szHexFormat                 L"0x%08lX"
#define szLargeHexFormat            L"0x%08lX%08lX"

LPCWSTR cszSqlDataSourceFormat = L"SQL:%s!%s";

//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


VOID
Line (
    IN  HDC     hDC,
    IN  HPEN    hPen,
    IN  INT     x1,
    IN  INT     y1,
    IN  INT     x2,
    IN  INT     y2
    )
{
    HPEN hPenPrevious = NULL;

    assert ( NULL != hDC );

    if ( NULL != hDC ) {
        if ( NULL != hPen ) {
            hPenPrevious = (HPEN)SelectObject (hDC, hPen) ;
        }

        MoveToEx (hDC, x1, y1, NULL) ;
        LineTo (hDC, x2, y2) ;

        if ( NULL != hPen ) {
            SelectObject (hDC, hPenPrevious);
        }
    }
}


VOID
Fill (
    IN  HDC     hDC,
    IN  DWORD   rgbColor,
    IN  LPRECT  lpRect
    )
{
    HBRUSH   hBrush = NULL;

    assert ( NULL != hDC && NULL != lpRect );
    
    if ( NULL != hDC && NULL != lpRect ) {

        hBrush = CreateSolidBrush (rgbColor) ;

        if ( NULL != hBrush ) {
            FillRect (hDC, lpRect, hBrush) ;
            DeleteObject (hBrush) ;
        }
    }
}


INT 
TextWidth (
    IN  HDC     hDC, 
    IN  LPCWSTR lpszText
    )
{
    SIZE     size ;
    INT      iReturn;

    iReturn = 0;

    assert ( NULL != hDC && NULL != lpszText );

    if ( NULL != lpszText && NULL != hDC) {
        if ( GetTextExtentPoint (hDC, lpszText, lstrlen (lpszText), &size) ) {
            iReturn = size.cx;
        }
    }
    return iReturn;
}


INT 
FontHeight (
    IN  HDC     hDC, 
    IN  BOOL    bIncludeLeading
    )
{
    TEXTMETRIC   tm ;
    INT  iReturn = 0;

    assert ( NULL != hDC );

    if ( NULL != hDC ) {
        GetTextMetrics (hDC, &tm) ;
        if (bIncludeLeading) {
            iReturn = tm.tmHeight + tm.tmExternalLeading;
        } else {
            iReturn = tm.tmHeight;
        }
    } 
    return iReturn;
}


INT
TextAvgWidth (
    IN  HDC hDC,
    IN  INT iNumChars
    )
{
    TEXTMETRIC   tm ;
    INT          xAvgWidth ;
    INT          iReturn = 0;

    assert ( NULL != hDC );

    if ( NULL != hDC ) {
        GetTextMetrics (hDC, &tm) ;

        xAvgWidth = iNumChars * tm.tmAveCharWidth ;

        // add 10% slop
        iReturn = MulDiv (xAvgWidth, 11, 10);  
    }
    return iReturn;
}


BOOL 
DialogEnable (
    IN  HWND hDlg,
    IN  WORD wID,
    IN  BOOL bEnable
    )
/*
   Effect:        Enable or disable (based on bEnable) the control 
                  identified by wID in dialog hDlg.

   See Also:      DialogShow.
*/
{
    BOOL    bStatus = TRUE;     // Success
    DWORD   dwStatus = ERROR_SUCCESS;
    HWND       hControl ;

    assert ( NULL != hDlg );

    if ( NULL != hDlg ) {
        hControl = GetDlgItem (hDlg, wID) ;

        if (hControl) {
            if ( 0 == EnableWindow (hControl, bEnable) ) {
                dwStatus = GetLastError();
                if ( ERROR_SUCCESS != dwStatus ) {
                    bStatus = FALSE;
                }
            }
        } else {
            bStatus = FALSE;
        }
    } else {
        bStatus = FALSE;
    }
    return bStatus;
}


VOID
DialogShow (
    IN  HWND hDlg,
    IN  WORD wID,
    IN  BOOL bShow
    )
{
    HWND       hControl ;

    assert ( NULL != hDlg );

    if ( NULL != hDlg ) {

        hControl = GetDlgItem (hDlg, wID) ;

        if (hControl) {
            ShowWindow (hControl, bShow ? SW_SHOW : SW_HIDE) ;
        }
    }
}


FLOAT 
DialogFloat (
    IN  HWND hDlg, 
    IN  WORD wControlID,
    OUT BOOL *pbOK)
/*
   Effect:        Return a floating point representation of the string
                  value found in the control wControlID of hDlg.

   Internals:     We use sscanf instead of atof becuase atof returns a 
                  double. This may or may not be the right thing to do.
*/
{
    WCHAR    szValue [MAX_VALUE_LEN] ;
    FLOAT    eValue = 0.0;
    UINT     uiCharCount = 0;
    INT      iNumScanned = 0 ;

    assert ( NULL != hDlg );
    assert ( NULL != pbOK );

    //
    // If any errors, iNumScanned remains 0 and *pbOK = FALSE
    //
    if ( NULL != hDlg ) {

        uiCharCount = DialogText (hDlg, wControlID, szValue) ;
        if ( 0 < uiCharCount ) {
            iNumScanned = swscanf (szValue, L"%e", &eValue) ;
        }
    }
    if (pbOK) {
        *pbOK = ( 1 == iNumScanned ) ;
    }
    return (eValue) ;
}


BOOL NeedEllipses (  
    IN  HDC hAttribDC,
    IN  LPCWSTR pszText,
    IN  INT nTextLen,
    IN  INT xMaxExtent,
    IN  INT xEllipses,
    OUT INT *pnChars
   )
{

    SIZE size;

    *pnChars = 0;
    // If no space or no chars, just return
    if (xMaxExtent <= 0 || nTextLen == 0) {
        return FALSE;
    }


    assert ( NULL != hAttribDC 
                && NULL != pszText
                && NULL != pnChars );

    if ( NULL == hAttribDC 
            || NULL == pszText
            || NULL == pnChars ) {
        return FALSE;
    }

    // Find out how many characters will fit
    GetTextExtentExPoint(hAttribDC, pszText, nTextLen, xMaxExtent, pnChars, NULL, &size);

    // If all or none fit, we're done
    if (*pnChars == nTextLen || *pnChars == 0) {
        return FALSE;
    }

    // How many chars will fit with ellipses?
    if (xMaxExtent > xEllipses) {
        GetTextExtentExPoint(hAttribDC, pszText, *pnChars, (xMaxExtent - xEllipses), 
                             pnChars, NULL, &size);
    } else {
        *pnChars = 0;
    }

    // Better to show one char than just ellipses
    if ( 0 == *pnChars ) {
        *pnChars = 1;
        return FALSE;
    }

    return TRUE;
}


VOID 
FitTextOut (
    IN HDC hDC,
    IN HDC hAttribDC,
    IN UINT fuOptions, 
    IN CONST RECT *lprc, 
    IN LPCWSTR lpString,
    IN INT cchCount,
    IN INT iAlign,
    IN BOOL fVertical
   )
{
    LPWSTR  szOutput = NULL;
    LPWSTR  szDisplay = NULL;
    INT     iExtent;
    INT     nOutCnt = 0;
    SIZE    size;
    INT     x,y;

    assert ( NULL != hAttribDC
            && NULL != lprc
            && NULL != lpString );

    if ( NULL != hAttribDC
            && NULL != lprc
            && NULL != lpString ) {

        szDisplay = const_cast<LPWSTR>(lpString);

        //
        // Add one for NULL
        //
        szOutput = new WCHAR [ cchCount + ELLIPSES_CNT + 1 ];

        if ( NULL != szOutput ) {

            iExtent = fVertical ? (lprc->bottom - lprc->top) : (lprc->right - lprc->left);

            GetTextExtentPoint (hAttribDC, ELLIPSES, ELLIPSES_CNT, &size) ;

            if (NeedEllipses(hAttribDC, lpString, cchCount, iExtent, size.cx, &nOutCnt)) {

                ZeroMemory ( szOutput, (cchCount + ELLIPSES_CNT + 1) * sizeof(WCHAR) );

                StringCchCopyN ( szOutput, cchCount + ELLIPSES_CNT + 1, lpString, cchCount );

                StringCchCopy(
                    &szOutput[nOutCnt], 
                    (cchCount + ELLIPSES_CNT + 1) - nOutCnt, 
                    ELLIPSES );

                nOutCnt += ELLIPSES_CNT;
                szDisplay = szOutput;
            }
        }

        if (fVertical) {
            switch (iAlign) {

            case TA_CENTER: 
                y = (lprc->top + lprc->bottom) / 2;
                break;

            case TA_RIGHT: 
                y = lprc->top; 
                break;

            default:
                y = lprc->bottom;
                break;
            }

            x = lprc->left;
        } 
        else {
            switch (iAlign) {

            case TA_CENTER: 
                x = (lprc->left + lprc->right) / 2;
                break;

            case TA_RIGHT: 
                x = lprc->right; 
                break;

            default:
                x = lprc->left;
                break;
            }

            y = lprc->top;           
        }

        ExtTextOut(hDC, x, y, fuOptions, lprc, szDisplay, nOutCnt, NULL);
    }
    if ( NULL != szOutput ) {
        delete [] szOutput;
    }
}

BOOL
TruncateLLTime (
    IN  LONGLONG llTime,
    OUT LONGLONG* pllTime
    )
{
    SYSTEMTIME SystemTime;
    BOOL bReturn = FALSE;

    assert ( NULL != pllTime );
    
    if ( NULL != pllTime ) { 
        if ( FileTimeToSystemTime((FILETIME*)&llTime, &SystemTime) ) {
            SystemTime.wMilliseconds = 0;
            bReturn = SystemTimeToFileTime(&SystemTime, (FILETIME*)pllTime);
        }
    }
    return bReturn;
}


BOOL
LLTimeToVariantDate (
    IN  LONGLONG llTime,
    OUT DATE *pdate
    )
{
    BOOL bReturn = FALSE;
    SYSTEMTIME SystemTime;

    assert ( NULL != pdate );

    if ( NULL != pdate ) {
        if ( FileTimeToSystemTime((FILETIME*)&llTime, &SystemTime) ) {
            bReturn = SystemTimeToVariantTime(&SystemTime, pdate);
        } 
    }
    return bReturn;
}

    
BOOL
VariantDateToLLTime (
    IN  DATE date,
    OUT LONGLONG *pllTime
    )
{
    BOOL bReturn = FALSE;
    SYSTEMTIME SystemTime;


    assert ( NULL != pllTime );

    if ( NULL != pllTime ) {
        if ( VariantTimeToSystemTime(date, &SystemTime) ) {
            bReturn = SystemTimeToFileTime(&SystemTime,(FILETIME*)pllTime);
        }
    }
    return bReturn;
}

//
//  WideStringFromStream also supports multi-sz
//
HRESULT
WideStringFromStream (
    LPSTREAM    pIStream,
    LPWSTR      *ppsz,
    INT         nLen
    )
{
    ULONG       bc = 0;
    LPWSTR      pszWide = NULL;
    HRESULT     hr = E_POINTER;

    assert ( NULL != pIStream && NULL != ppsz );

    // This method does not perform conversion from W to T.
    assert ( sizeof(WCHAR) == sizeof(WCHAR) );

    if ( NULL != pIStream
           && NULL != ppsz ) {

        *ppsz = NULL;

        if (nLen == 0) {
            hr = S_OK;
        } else {
            pszWide = new WCHAR[nLen + 1];
            if (pszWide == NULL) {
                hr = E_OUTOFMEMORY;
            }
            else {
                hr = pIStream->Read(pszWide, nLen*sizeof(WCHAR), &bc);
            }
 
            if (SUCCEEDED(hr)) {
                if (bc != (ULONG)nLen*sizeof(WCHAR)) {
                    hr = E_FAIL;
                }
            }
            if (SUCCEEDED(hr)) {
                // Write ending NULL for non-multisz strings.
                pszWide[nLen] = L'\0';

                *ppsz = new WCHAR [nLen + 1];
                if ( NULL != *ppsz ) {
                    memcpy(*ppsz, pszWide, (nLen+1)*sizeof(WCHAR) );
                } else {
                    hr = E_OUTOFMEMORY;
                }
            }
            if (pszWide != NULL) {
                delete [] pszWide;
            }
        }
    }
    return hr;
}

//
// Property bag I/O - only include if user knows about IStream
//
#ifdef __IPropertyBag_INTERFACE_DEFINED__

HRESULT
IntegerToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCWSTR szPropName, 
    INT intData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_I4;
        vValue.lVal = intData;

        hr = pIPropBag->Write(szPropName, &vValue );

        VariantClear ( &vValue );
    }
    return hr;
}

HRESULT
OleColorToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCWSTR szPropName, 
    OLE_COLOR& clrData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_COLOR;       // VT_COLOR = VT_I4
        vValue.lVal = clrData;

        hr = pIPropBag->Write(szPropName, &vValue );

        VariantClear ( &vValue );
    }
    return hr;
}

HRESULT
ShortToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCWSTR szPropName, 
    SHORT iData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_I2;
        vValue.iVal = iData;

        hr = pIPropBag->Write(szPropName, &vValue );

        VariantClear ( &vValue );
    }
    return hr;
}

HRESULT
BOOLToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCWSTR szPropName, 
    BOOL bData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_BOOL;
        vValue.boolVal = (SHORT)bData;

        hr = pIPropBag->Write(szPropName, &vValue );

        VariantClear ( &vValue );
    }
    return hr;
}

HRESULT
DoubleToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCWSTR szPropName, 
    DOUBLE dblData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_R8;
        vValue.dblVal = dblData;

        hr = pIPropBag->Write(szPropName, &vValue );

        VariantClear ( &vValue );
    }
    return hr;
}

HRESULT
FloatToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCWSTR szPropName, 
    FLOAT fData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_R4;
        vValue.fltVal = fData;

        hr = pIPropBag->Write(szPropName, &vValue );

        VariantClear ( &vValue );
    }
    return hr;
}

HRESULT
CyToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCWSTR szPropName, 
    CY& cyData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_CY;
        vValue.cyVal.int64 = cyData.int64;
    
        hr = VariantChangeType ( &vValue, &vValue, NULL, VT_BSTR );

        if ( SUCCEEDED ( hr ) ) 
            hr = pIPropBag->Write(szPropName, &vValue );

        VariantClear ( &vValue );
    }
    return hr;
}

typedef struct _HTML_ENTITIES {
    LPWSTR szHTML;
    LPWSTR szEntity;
} HTML_ENTITIES;

HTML_ENTITIES g_htmlentities[] = {
    L"&",    L"&amp;",
    L"\"",   L"&quot;",
    L"<",    L"&lt;",
    L">",    L"&gt;",
    NULL, NULL
};

HRESULT
StringToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCWSTR szPropName, 
    LPCWSTR szData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;
    LPWSTR  szTrans = NULL;
    BOOL    bAllocated = FALSE;
    size_t  cchTrans = 0;
    LPWSTR  szScan = NULL;
    int i;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_BSTR;
        vValue.bstrVal = NULL;

        if ( NULL != szData ) {

            //
            // Max length of szHTML is 6.  Add 5 because 1 will be added
            // when add original data length below.
            //
            for( i=0 ;g_htmlentities[i].szHTML != NULL; i++ ){
                szScan = (LPWSTR)szData;
                while( *szScan != L'\0' ) {
                    if( *szScan == *g_htmlentities[i].szHTML ){
                        cchTrans += 5;
                    }
                    szScan++;
                }
            }

            if( cchTrans > 0 ){
                //
                //  Add 1 for null.
                //
                cchTrans += lstrlen (szData) + 1;

                szTrans = new WCHAR [ cchTrans ];
                if( szTrans != NULL ){
                    bAllocated = TRUE;
                    ZeroMemory( szTrans, cchTrans * sizeof(WCHAR) );
                    szScan = (LPWSTR)szData;
                    while( *szScan != L'\0' ){
                        BOOL bEntity = FALSE;

                        for( i=0; g_htmlentities[i].szHTML != NULL; i++ ){
                            if( *szScan == *g_htmlentities[i].szHTML ){
                                bEntity = TRUE;
                                StringCchCat(szTrans, cchTrans, g_htmlentities[i].szEntity);
                                break;
                            }
                        }

                        if( !bEntity ){
                            StringCchCatN ( szTrans, cchTrans, szScan, 1 );
                        }
                        szScan++;
                    }
                } else {
                    szTrans = (LPWSTR)szData;
                }
            } else {
                szTrans = (LPWSTR)szData;
            }

            vValue.bstrVal = SysAllocString ( szTrans );

            if ( NULL != vValue.bstrVal ) {
                hr = pIPropBag->Write(szPropName, &vValue );    
                VariantClear ( &vValue );
            } else {
                hr = E_OUTOFMEMORY;
            }
        } else {
            hr = pIPropBag->Write(szPropName, &vValue );    
        }
    }

    if( NULL != szTrans && bAllocated ){
        delete [] szTrans;
    }
    return hr;
}

HRESULT
LLTimeToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCWSTR szPropName, 
    LONGLONG& rllData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;
    BOOL bStatus;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_DATE;

        bStatus = LLTimeToVariantDate ( rllData, &vValue.date );

        if ( bStatus ) {

            hr = pIPropBag->Write(szPropName, &vValue );

            VariantClear ( &vValue );
    
        } else { 
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT
IntegerFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    INT& rintData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_I4;
        vValue.lVal = 0;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );

        if ( SUCCEEDED ( hr ) ) {
            rintData = vValue.lVal;
        }
    }
    return hr;
}

HRESULT
OleColorFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    OLE_COLOR& rintData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_COLOR;   // VT_COLOR == VT_I4;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );

        if ( SUCCEEDED ( hr ) ) {
            rintData = vValue.lVal;
        }
    }
    return hr;
}

HRESULT
BOOLFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    BOOL& rbData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_BOOL;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );

        if ( SUCCEEDED ( hr ) ) {
            rbData = vValue.boolVal;
        }
    }
    return hr;
}

HRESULT
DoubleFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    DOUBLE& rdblData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_R8;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );

        if ( SUCCEEDED ( hr ) ) {
            rdblData = vValue.dblVal;
        }
    }

    return hr;
}

HRESULT
FloatFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    FLOAT& rfData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_R4;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );

        if ( SUCCEEDED ( hr ) ) {
            rfData = vValue.fltVal;
        }
    }
    return hr;
}

HRESULT
ShortFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    SHORT& riData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_I2;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );

        if ( SUCCEEDED ( hr ) ) {
            riData = vValue.iVal;
        }
    }
    return hr;
}

HRESULT
CyFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    CY& rcyData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_CY;
        vValue.cyVal.int64 = 0;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );
    
        if ( SUCCEEDED( hr ) ) {
            hr = VariantChangeType ( &vValue, &vValue, NULL, VT_CY );

            if ( SUCCEEDED ( hr ) ) {
                rcyData.int64 = vValue.cyVal.int64;
            }
        }
    }
    return hr;
}

HRESULT
StringFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    LPWSTR szData,
    INT& riCchBufLen )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;
    INT iCchNewBufLen = 0;
    LPWSTR szLocalData = NULL;
    LPWSTR szTrans = NULL;
    LPWSTR szScan = NULL;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        if ( NULL != szData ) {
            *szData = L'\0';
        }

        VariantInit( &vValue );
        vValue.vt = VT_BSTR;
        vValue.bstrVal = NULL;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );

        if ( SUCCEEDED(hr) && vValue.bstrVal ) {

            iCchNewBufLen = SysStringLen(vValue.bstrVal) + 1;

            if ( iCchNewBufLen > 1 ) {
                
                if ( riCchBufLen >= iCchNewBufLen && NULL != szData ) {
                    
                    //
                    // Translate HTML entities back to single characters.
                    //
                    szTrans = new WCHAR [iCchNewBufLen];
                    szLocalData = new WCHAR [iCchNewBufLen];
                    if ( NULL != szTrans && NULL != szLocalData ) {

                        StringCchCopy(szLocalData, riCchBufLen, vValue.bstrVal);

                        for( int i=0;g_htmlentities[i].szHTML != NULL;i++ ){
                            szScan = NULL;

                            while( szScan = wcsstr( szLocalData, g_htmlentities[i].szEntity ) ){
                                //
                                // Null the character at szScan, so that the string 
                                // at the beginning of szLocalData will copied to szTrans.  
                                // Then the NULL character is overwritten with the character
                                // represented by the specified HTML entity.
                                //
                                *szScan = L'\0';

                                StringCchCopy(szTrans, iCchNewBufLen, szLocalData);
                                StringCchCat(szTrans, iCchNewBufLen, g_htmlentities[i].szHTML);

                                //
                                // szScan is then set to one character past the HTML entity.
                                //
                                szScan += lstrlenW( g_htmlentities[i].szEntity);
                                //
                                // The rest of the original string is concatenated onto
                                // szTrans, and szLocalData replaced by the string at szTrans, 
                                // so the next loop will start again at the beginning
                                // of the string.
                                //
                                StringCchCat(szTrans, iCchNewBufLen, szScan);
                                StringCchCopy(szLocalData, riCchBufLen, szTrans);
                            }
                        }
                        StringCchCopy(szData, riCchBufLen, szLocalData);
                    } else {
                        StringCchCopy(szData,  riCchBufLen, vValue.bstrVal);
                        hr = E_OUTOFMEMORY;
                    }

                    if ( NULL != szLocalData ) {
                        delete [] szLocalData;
                    }

                    if ( NULL != szTrans ) {
                        delete [] szTrans;
                    }
                }
                riCchBufLen = iCchNewBufLen;
            } else {    
                riCchBufLen = 0;
            }
        }
        VariantClear ( &vValue );
    }
    return hr;
}

HRESULT
LLTimeFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    LONGLONG& rllData )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT vValue;

    assert ( NULL != pIPropBag );

    if ( NULL != pIPropBag ) {

        VariantInit( &vValue );
        vValue.vt = VT_DATE;

        hr = pIPropBag->Read(szPropName, &vValue, pIErrorLog );

        if ( SUCCEEDED(hr) ) {
            if ( !VariantDateToLLTime ( vValue.date, &rllData ) ) {
                hr = E_FAIL;
            }
            VariantClear( &vValue );
        }
    }
    return hr;
}

#endif // Property bag

LPWSTR
ResourceString (
    UINT    uID
    )
{

    static WCHAR aszBuffers[NUM_RESOURCE_STRING_BUFFERS][RESOURCE_STRING_BUF_LEN];
    static INT iBuffIndex = 0;

    // Use next buffer
    if (++iBuffIndex >= NUM_RESOURCE_STRING_BUFFERS)
        iBuffIndex = 0;

    // Load and return string
    if (LoadString(g_hInstance, uID, aszBuffers[iBuffIndex], RESOURCE_STRING_BUF_LEN))
        return aszBuffers[iBuffIndex];
    else
        return MISSING_RESOURCE_STRING;
}

DWORD
FormatSystemMessage (
    DWORD   dwMessageId,
    LPWSTR  pszSystemMessage, 
    DWORD   dwBufSize )
{
    DWORD dwReturn = 0;
    HINSTANCE hPdh = NULL;
    DWORD dwFlags = FORMAT_MESSAGE_FROM_SYSTEM;

    assert ( NULL != pszSystemMessage );

    if ( NULL != pszSystemMessage ) {
        pszSystemMessage[0] = L'\0';

        hPdh = LoadLibrary( L"PDH.DLL") ;

        if ( NULL != hPdh ) {
            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
        }

        dwReturn = ::FormatMessage ( 
                         dwFlags,
                         hPdh,
                         dwMessageId,
                         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                         pszSystemMessage,
                         dwBufSize,
                         NULL );
    
        if ( NULL != hPdh ) {
            FreeLibrary( hPdh );
        }

        if ( L'\0' == pszSystemMessage[0] ) {
            StringCchPrintf(pszSystemMessage, dwBufSize, L"0x%08lX", dwMessageId );
        }
    }
    return dwReturn;
}

INT
GetNumSeparators  (
    LPWSTR& rpDecimal,
    LPWSTR& rpThousand )
{
#define NUM_BUF_LEN  4
    INT iLength;

    static WCHAR szDecimal[NUM_BUF_LEN] = L".";
    static WCHAR szThousand[NUM_BUF_LEN] = L",";

    iLength = GetLocaleInfo (
                    LOCALE_USER_DEFAULT,
                    LOCALE_SDECIMAL,
                    szDecimal,
                    NUM_BUF_LEN );

    if ( 0 != iLength ) {
        iLength  = GetLocaleInfo (
                        LOCALE_USER_DEFAULT,
                        LOCALE_STHOUSAND,
                        szThousand,
                        NUM_BUF_LEN );

    }

    rpDecimal = szDecimal;
    rpThousand = szThousand;

    return iLength;
}

LPWSTR
GetTimeSeparator  ( void )
{
#define TIME_MARK_BUF_LEN  5
    static INT iInitialized;   // Initialized to 0
    static WCHAR szTimeSeparator[TIME_MARK_BUF_LEN];

    if ( 0 == iInitialized ) {
        INT iLength;
        
        iLength = GetLocaleInfo (
                        LOCALE_USER_DEFAULT,
                        LOCALE_STIME,
                        szTimeSeparator,
                        TIME_MARK_BUF_LEN );

        // Default to colon for time separator
        if ( '\0' == szTimeSeparator[0] ) {
            StringCchCopy(szTimeSeparator, TIME_MARK_BUF_LEN, L":" );
        }

        iInitialized = 1;
    }

    assert ( L'\0' != szTimeSeparator[0] );

    return szTimeSeparator;
}
            
BOOL    
DisplayThousandsSeparator ( void )
{
    long nErr;
    HKEY hKey = NULL;
    DWORD dwRegValue;
    DWORD dwDataType;
    DWORD dwDataSize;
    DWORD dwDisposition;

    static INT siInitialized;   // Initialized to 0
    static BOOL sbUseSeparator; // Initialized to 0 ( FALSE )

    // check registry setting to see if thousands separator is enabled
    if ( 0 == siInitialized ) {
        nErr = RegOpenKey( 
                    HKEY_CURRENT_USER,
                    L"Software\\Microsoft\\SystemMonitor",
                    &hKey );

        if( ERROR_SUCCESS != nErr ) {
            nErr = RegCreateKeyEx( 
                        HKEY_CURRENT_USER,
                        L"Software\\Microsoft\\SystemMonitor",
                        0,
                        L"REG_DWORD",
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dwDisposition );
        }

        dwRegValue = 0;
        if ( ERROR_SUCCESS == nErr ) {

            dwDataSize = sizeof(DWORD);
            nErr = RegQueryValueExW (
                        hKey,
                        L"DisplayThousandsSeparator",
                        NULL,
                        &dwDataType,
                        (LPBYTE) &dwRegValue,
                        (LPDWORD) &dwDataSize );

            if ( ERROR_SUCCESS == nErr 
                    && REG_DWORD == dwDataType
                    && sizeof(DWORD) == dwDataSize )
            {
                if ( 0 != dwRegValue ) {
                    sbUseSeparator = TRUE;
                }
            }
            siInitialized = 1;
        }

        if ( NULL != hKey ) {        
            nErr = RegCloseKey( hKey );
        }
    }

    return sbUseSeparator;
}


INT
FormatNumberInternal (
    LPWSTR  pNumOrig,
    LPWSTR  pNumFormatted,
    INT     cchars,
    UINT    uiPrecision,
    UINT    uiLeadingZero,
    UINT    uiGrouping,
    UINT    uiNegativeMode )
{
    INT iLength = 0;
    WCHAR* pszSrc;

    static INT siInitialized;   // Initialized to 0
    static NUMBERFMT NumberFormat;

    assert ( NULL != pNumOrig && NULL != pNumFormatted );

    if ( NULL != pNumOrig && NULL != pNumFormatted ) {

        iLength = 2;

        NumberFormat.NumDigits = uiPrecision;
        NumberFormat.LeadingZero = uiLeadingZero; 
        NumberFormat.NegativeOrder = uiNegativeMode;

        if ( DisplayThousandsSeparator() ) {
            NumberFormat.Grouping = uiGrouping;
        } else {
            NumberFormat.Grouping = 0;
        }

        if ( 0 == siInitialized ) {
            GetNumSeparators ( 
                        NumberFormat.lpDecimalSep,
                        NumberFormat.lpThousandSep );

            siInitialized = 1;
        }

        // Programming error if either pointer is NULL.
        assert ( NULL != NumberFormat.lpDecimalSep );
        assert ( NULL != NumberFormat.lpThousandSep );

        // GetNumberFormat requires "." for decimal point.
        if ( NumberFormat.lpDecimalSep != NULL) {
            if (0 != lstrcmpi(NumberFormat.lpDecimalSep, L".") ) { 
                for ( pszSrc = pNumOrig; *pszSrc != L'\0'; pszSrc++) {
                    if ( *pszSrc == NumberFormat.lpDecimalSep[0] ) {
                        *pszSrc = L'.';
                        break;
                    }
                }
            }

            iLength = GetNumberFormat ( 
                        LOCALE_USER_DEFAULT,
                        0,
                        pNumOrig,
                        &NumberFormat,
                        pNumFormatted,
                        cchars );
        }
    }
    // Return 0 on failure, number of chars on success.
    // GetNumberFormat includes the null terminator in the length.
    return iLength;
}

INT
FormatHex (
    double  dValue,
    LPWSTR  pNumFormatted,
    BOOL    bLargeFormat
    )
{
    INT     iLength = 0;
    WCHAR   szPreFormat[24];
    
    assert ( NULL != pNumFormatted );

    if ( NULL != pNumFormatted ) {
        iLength = 8;
        // Localization doesn't handle padding blanks.
        StringCchPrintf( szPreFormat, 
                        24,
                        (bLargeFormat ? szLargeHexFormat : szHexFormat ),
                        (ULONG)dValue );

        StringCchCopy(pNumFormatted, MAX_VALUE_LEN, szPreFormat);
    }
     
    return iLength;
}

INT
FormatNumber (
    double  dValue,
    LPWSTR  pNumFormatted,
    INT     ccharsFormatted,
    UINT    /* uiMinimumWidth */,
    UINT    uiPrecision )
{
    INT iLength = 0;
    INT iLeadingZero = FALSE;
    WCHAR   szPreFormat[MAX_VALUE_LEN];

    assert ( NULL != pNumFormatted );
    // This method enforces number format commonality
    if ( NULL != pNumFormatted ) {

        assert ( 8 > uiPrecision );

        // Localization doesn't handle padding blanks.
        StringCchPrintf( szPreFormat, 
                         MAX_VALUE_LEN,
                         L"%0.7f",   // assumes 7 >= uiPrecision 
                         dValue );

        if ( 1 > dValue )
            iLeadingZero = TRUE;

        iLength = FormatNumberInternal ( 
                    szPreFormat, 
                    pNumFormatted,
                    ccharsFormatted,
                    uiPrecision,
                    iLeadingZero,   // Leading 0 
                    3,              // Grouping
                    1 );            // Negative format
    }
    
    // Return 0 on failure, number of chars on success.
    // GetNumberFormat includes the null terminator in the length.
    return iLength;
}

INT
FormatScientific (
    double  dValue,
    LPWSTR  pszNumFormatted,
    INT     ccharsFormatted,
    UINT    /* uiMinimumWidth */,
    UINT    uiPrecision )
{
    INT     iLength = 0;
    WCHAR   szPreFormat[24];
    WCHAR   szPreFormNumber[24];
    WCHAR   *pche;
    INT     iPreLen;
    INT     iPostLen;
    INT     iLeadingZero = FALSE;

    assert ( NULL != pszNumFormatted );
    // This method enforces number format commonality
    if ( NULL != pszNumFormatted ) {

        assert ( 8 > uiPrecision );
        assert ( 32 > ccharsFormatted );

        // Localization doesn't handle padding blanks.
        StringCchPrintf( szPreFormat, 
                        24,
                        L"%0.8e",   // assumes 8 >= uiPrecision 
                        dValue );

        pche = wcsrchr(szPreFormat, L'e');
        if (pche != NULL) {
            iPreLen = (INT)((UINT_PTR)pche - (UINT_PTR)szPreFormat);    // Number of bytes
            iPreLen /= sizeof (WCHAR);                                  // Number of characters
            iPostLen = lstrlen(pche) + 1;

            StringCchCopyN ( szPreFormNumber, 24, szPreFormat, iPreLen );

            if ( 1 > dValue ) {
                iLeadingZero = TRUE;
            }

            iLength = FormatNumberInternal ( 
                            szPreFormNumber, 
                            pszNumFormatted,
                            ccharsFormatted,
                            uiPrecision,
                            iLeadingZero,   // Leading 0 
                            0,              // Grouping
                            1 );            // Negative format

            if( ( iLength + iPostLen ) < ccharsFormatted ) {    
                StringCchCopy(pszNumFormatted, ccharsFormatted, pche );
                iLength += iPostLen;
            }
        }
    }    
    // Return 0 on failure, number of chars on success.
    // GetNumberFormat includes the null terminator in the length.
    return iLength;
}

void
FormatDateTime (
    LONGLONG    llTime,
    LPWSTR      pszDate,
    LPWSTR      pszTime )
{
   SYSTEMTIME SystemTime;

   assert ( NULL != pszDate && NULL != pszTime );
   if ( NULL != pszDate
       && NULL != pszTime ) {

       FileTimeToSystemTime((FILETIME*)&llTime, &SystemTime);
       GetTimeFormat (LOCALE_USER_DEFAULT, 0, &SystemTime, NULL, pszTime, MAX_TIME_CHARS) ;
       GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &SystemTime, NULL, pszDate, MAX_DATE_CHARS) ;
   } 
}

// CreateTargetDC is based on AtlCreateTargetDC.
HDC
CreateTargetDC(HDC hdc, DVTARGETDEVICE* ptd)
{
    USES_CONVERSION

    // cases  hdc, ptd, hdc is metafile, hic
//  NULL,    NULL,  n/a,    Display
//  NULL,   !NULL,  n/a,    ptd
//  !NULL,   NULL,  FALSE,  hdc
//  !NULL,   NULL,  TRUE,   display
//  !NULL,  !NULL,  FALSE,  ptd
//  !NULL,  !NULL,  TRUE,   ptd

    if ( NULL != ptd ) {
        LPDEVMODE lpDevMode;
        LPOLESTR lpszDriverName;
        LPOLESTR lpszDeviceName;
        LPOLESTR lpszPortName;

        if (ptd->tdExtDevmodeOffset == 0)
            lpDevMode = NULL;
        else
            lpDevMode  = (LPDEVMODE) ((LPSTR)ptd + ptd->tdExtDevmodeOffset);

        lpszDriverName = (LPOLESTR)((BYTE*)ptd + ptd->tdDriverNameOffset);
        lpszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd->tdDeviceNameOffset);
        lpszPortName   = (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);

        return ::CreateDC(lpszDriverName, lpszDeviceName,
            lpszPortName, lpDevMode);
    } else if ( NULL == hdc ) {
        return ::CreateDC(L"DISPLAY", NULL, NULL, NULL);
    } else if ( GetDeviceCaps(hdc, TECHNOLOGY) == DT_METAFILE ) {
        return ::CreateDC(L"DISPLAY", NULL, NULL, NULL);
    } else
        return hdc;
}

/***********************************************************************

  FUNCTION   : HitTestLine

  PARAMETERS : POINT pt0 - endpoint for line segment
               POINT pt1 - endpoint for line segment
               POINTS ptMouse - mouse coordinates of hit
               INT nWidth - width of pen

  PURPOSE    : test if mouse click occurred on line segment while 
               adjusting for the width of line

  CALLS      : GetDC
               ReleaseDC
               SetGraphicsMode
               SetWorldTransform

  MESSAGES   : none

  RETURNS    : BOOL - TRUE if the point was within the width of the 
                      pen about the line 
                      FALSE if the point lies outside of the width
                      of the pen about the line

  COMMENTS   : uses VECTOR2D.DLL

  HISTORY    : 9/20/93 - created - denniscr

************************************************************************/

BOOL HitTestLine( POINT pt0, POINT pt1, POINTS ptMouse, INT nWidth )
{
    POINT PtM;
    VECTOR2D tt0, tt1;
    double dist;
    INT nHalfWidth;

    nHalfWidth = (nWidth/2 < 1) ? 1 : nWidth/2;

    //
    //convert the line into a vector
    //
    
    POINTS2VECTOR2D(pt0, pt1, tt0);
    //
    //convert the mouse points (short) into POINT (long)
    //
    
    MPOINT2POINT(ptMouse ,PtM);
    POINTS2VECTOR2D(pt0, PtM, tt1);
    
    //
    //if the mouse click is past the endpoints of 
    //a line segment return FALSE
    //
    
    if (pt0.x <= pt1.x)
    {
        if (PtM.x < pt0.x || PtM.x > pt1.x)
            return (FALSE);
    }
    else
    {
        if (PtM.x > pt0.x || PtM.x < pt1.x)
            return (FALSE);
    }
    //
    //this is the call to the function that does the work
    //of obtaining the distance of the point to the line
    //
    dist = vDistFromPointToLine(&pt0, &pt1, &PtM);

    //
    //TRUE if the distance is within the width of the pen about the
    //line otherwise FALSE
    //
    return (dist >= -nHalfWidth && dist <= nHalfWidth);
}

/***********************************************************************

vSubtractVectors 

The vSubtractVectors function subtracts the components of a two 
dimensional vector from another. The resultant vector 
c = (a1 - b1, a2 - b2).

Parameters

v0  A pointer to a VECTOR2D structure containing the components 
    of the first two dimensional vector.
v1  A pointer to a VECTOR2D structure containing the components 
    of the second two dimensional vector.
vt  A pointer to a VECTOR2D structure in which the components 
    of the two dimensional vector obtained from the subtraction of 
    the first two are placed.

Return value

A pointer to a VECTOR2D structure containing the new vector obtained 
from the subtraction of the first two parameters.

HISTORY    : - created - denniscr

************************************************************************/

PVECTOR2D  vSubtractVectors(PVECTOR2D v0, PVECTOR2D v1, PVECTOR2D v)
{
  if (v0 == NULL || v1 == NULL)
    v = (PVECTOR2D)NULL;
  else
  {
    v->x = v0->x - v1->x;
    v->y = v0->y - v1->y;
  }
  return(v);
}

/***********************************************************************

vVectorSquared

The vVectorSquared function squares each of the components of the 
vector and adds then together to produce the squared value of the 
vector. SquaredValue = a.x * a.x + a.y * a.y.

Parameters

v0  A pointer to a VECTOR2D structure containing the vector upon which 
to determine the squared value.

Return value

A double value which is the squared value of the vector. 

HISTORY    : - created - denniscr

************************************************************************/

double  vVectorSquared(PVECTOR2D v0)
{
  double dSqLen;

  if (v0 == NULL)
    dSqLen = 0.0;
  else
    dSqLen = (double)(v0->x * v0->x) + (double)(v0->y * v0->y);
  return (dSqLen);
}

/***********************************************************************

vVectorMagnitude

The vVectorMagnitude function determines the length of a vector by 
summing the squares of each of the components of the vector. The 
magnitude is equal to a.x * a.x + a.y * a.y.

Parameters

v0  A pointer to a VECTOR2D structure containing the vector upon 
    which to determine the magnitude.

Return value

A double value which is the magnitude of the vector. 

HISTORY    : - created - denniscr

************************************************************************/

double  vVectorMagnitude(PVECTOR2D v0)
{
  double dMagnitude;

  if (v0 == NULL)
    dMagnitude = 0.0;
  else
    dMagnitude = sqrt(vVectorSquared(v0));
  return (dMagnitude);
}


/***********************************************************************

vDotProduct

The function vDotProduct computes the dot product of two vectors. The 
dot product of two vectors is the sum of the products of the components 
of the vectors ie: for the vectors a and b, dotprod = a1 * a2 + b1 * b2.

Parameters

v0  A pointer to a VECTOR2D structure containing the first vector used 
    for obtaining a dot product.
v1  A pointer to a VECTOR2D structure containing the second vector used 
    for obtaining a dot product.

Return value

A double value containing the scalar dot product value.

HISTORY    : - created - denniscr

************************************************************************/

double  vDotProduct(PVECTOR2D v0, PVECTOR2D v1)
{
  return ((v0 == NULL || v1 == NULL) ? 0.0 
                                     : (v0->x * v1->x) + (v0->y * v1->y));
}


/***********************************************************************

vProjectAndResolve

The function vProjectAndResolve resolves a vector into two vector 
components. The first is a vector obtained by projecting vector v0 onto 
v1. The second is a vector that is perpendicular (normal) to the 
projected vector. It extends from the head of the projected vector 
v1 to the head of the original vector v0.

Parameters

v0     A pointer to a VECTOR2D structure containing the first vector 
v1     A pointer to a VECTOR2D structure containing the second vector
ppProj A pointer to a PROJECTION structure containing the resolved 
       vectors and their lengths.

Return value

void.

HISTORY    : - created - denniscr

************************************************************************/

void  vProjectAndResolve(PVECTOR2D v0, PVECTOR2D v1, PPROJECTION ppProj)
{
  VECTOR2D ttProjection, ttOrthogonal;
  double vDotProd;
  double proj1 = 0.0;
  //
  //obtain projection vector
  //
  //c = a * b
  //    ----- b
  //    |b|^2
  //

  ttOrthogonal.x = 0.0;
  ttOrthogonal.y = 0.0;
  vDotProd = vDotProduct(v1, v1);

  if ( 0.0 != vDotProd ) {
    proj1 = vDotProduct(v0, v1)/vDotProd;
  }

  ttProjection.x = v1->x * proj1;
  ttProjection.y = v1->y * proj1;
  //
  //obtain perpendicular projection : e = a - c
  //
  vSubtractVectors(v0, &ttProjection, &ttOrthogonal);
  //
  //fill PROJECTION structure with appropriate values
  //
  ppProj->LenProjection = vVectorMagnitude(&ttProjection);
  ppProj->LenPerpProjection = vVectorMagnitude(&ttOrthogonal);

  ppProj->ttProjection.x = ttProjection.x;
  ppProj->ttProjection.y = ttProjection.y;
  ppProj->ttPerpProjection.x = ttOrthogonal.x;
  ppProj->ttPerpProjection.y = ttOrthogonal.y;
}

/***********************************************************************

vDistFromPointToLine

The function vDistFromPointToLine computes the distance from the point 
ptTest to the line defined by endpoints pt0 and pt1. This is done by 
resolving the the vector from pt0 to ptTest into its components. The 
length of the component vector that is attached to the head of the 
vector from pt0 to ptTest is the distance of ptTest from the line.

Parameters

pt0    A pointer to a POINT structure containing the first endpoint of the 
       line.
pt1    A pointer to a POINT structure containing the second endpoint of the 
       line.
ptTest A pointer to a POINT structure containing the point for which the 
       distance from the line is to be computed.

Return value

A double value that contains the distance of ptTest to the line defined 
  by the endpoints pt0 and pt1.

HISTORY    : - created - denniscr
************************************************************************/

double  vDistFromPointToLine(LPPOINT pt0, LPPOINT pt1, LPPOINT ptTest)
{
  VECTOR2D ttLine, ttTest;
  PROJECTION pProjection;

  POINTS2VECTOR2D(*pt0, *pt1, ttLine);
  POINTS2VECTOR2D(*pt0, *ptTest, ttTest);

  vProjectAndResolve(&ttTest, &ttLine, &pProjection);
 
  return(pProjection.LenPerpProjection);
}


BOOL 
FileRead (
    HANDLE hFile,
    void* lpMemory,
    DWORD nAmtToRead)
{  
    BOOL           bSuccess = FALSE;
    DWORD          nAmtRead = 0;

    assert ( NULL != hFile );
    assert ( NULL != lpMemory );

    if ( NULL != hFile
            && NULL != lpMemory ) {
        bSuccess = ReadFile (hFile, lpMemory, nAmtToRead, &nAmtRead, NULL) ;
    } 
    return (bSuccess && (nAmtRead == nAmtToRead)) ;
}  // FileRead


BOOL 
FileWrite (
    HANDLE hFile,
    void* lpMemory,
    DWORD nAmtToWrite)
{  
    BOOL           bSuccess = FALSE;
    DWORD          nAmtWritten  = 0;
    DWORD          dwFileSizeLow, dwFileSizeHigh;
    LONGLONG       llResultSize;

    if ( NULL != hFile
            && NULL != lpMemory ) {

        dwFileSizeLow = GetFileSize (hFile, &dwFileSizeHigh);
        // limit file size to 2GB

        if (dwFileSizeHigh > 0) {
            SetLastError (ERROR_WRITE_FAULT);
            bSuccess = FALSE;
        } else {
            // note that the error return of this function is 0xFFFFFFFF
            // since that is > the file size limit, this will be interpreted
            // as an error (a size error) so it's accounted for in the following
            // test.
            llResultSize = dwFileSizeLow + nAmtToWrite;
            if (llResultSize >= 0x80000000) {
                SetLastError (ERROR_WRITE_FAULT);
                bSuccess = FALSE;
            } else {
                // write buffer to file
                bSuccess = WriteFile (hFile, lpMemory, nAmtToWrite, &nAmtWritten, NULL) ;
                if (bSuccess) 
                    bSuccess = (nAmtWritten == nAmtToWrite ? TRUE : FALSE);
                if ( !bSuccess ) {
                    SetLastError (ERROR_WRITE_FAULT);
                }
            }
        }
    } else {
        assert ( FALSE );
        SetLastError (ERROR_INVALID_PARAMETER);
    } 

    return (bSuccess) ;

}  // FileWrite

// This routine extract the filename portion from a given full-path filename
LPWSTR 
ExtractFileName ( LPWSTR pFileSpec )
{
    LPWSTR   pFileName = NULL ;
    WCHAR    DIRECTORY_DELIMITER1 = TEXT('\\') ;
    WCHAR    DIRECTORY_DELIMITER2 = TEXT(':') ;

    assert ( NULL != pFileSpec );
    if ( pFileSpec ) {
        pFileName = pFileSpec + lstrlen (pFileSpec) ;

        while (*pFileName != DIRECTORY_DELIMITER1 &&
            *pFileName != DIRECTORY_DELIMITER2) {
            if (pFileName == pFileSpec) {
                // done when no directory delimiter is found
                break ;
            }
            pFileName-- ;
        }

        if (*pFileName == DIRECTORY_DELIMITER1
            || *pFileName == DIRECTORY_DELIMITER2) {
         
             // directory delimiter found, point the
             // filename right after it
             pFileName++ ;
        }
   }
   return pFileName ;
}  // ExtractFileName

// CWaitCursor class

CWaitCursor::CWaitCursor()
: m_hcurWaitCursorRestore ( NULL )
{ 
    DoWaitCursor(1); 
}

CWaitCursor::~CWaitCursor()
{ 
    DoWaitCursor(-1); 
}

void 
CWaitCursor::DoWaitCursor(INT nCode)
{
    // 1=> begin, -1=> end
    assert(nCode == 1 || nCode == -1);

    if ( 1 == nCode )
    {
        m_hcurWaitCursorRestore = SetHourglassCursor();
    } else {
        if ( NULL != m_hcurWaitCursorRestore ) {
            SetCursor(m_hcurWaitCursorRestore);
        } else {
            SetArrowCursor();
        }
    }
}

DWORD
LoadDefaultLogFileFolder(
    LPWSTR szFolder,
    INT* piBufLen )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    HKEY    hKey = NULL;
    DWORD   dwDataType;
    DWORD   dwBufferSize = 0;
    WCHAR*  szNewStringBuffer = NULL;

    assert ( NULL != szFolder );
    assert ( NULL != piBufLen );

    if ( NULL != szFolder 
        && NULL != piBufLen ) {

        dwStatus = RegOpenKey (
                     HKEY_LOCAL_MACHINE,
                     L"System\\CurrentControlSet\\Services\\SysmonLog",
                     &hKey );

        if ( ERROR_SUCCESS == dwStatus ) {

            dwDataType = 0;

            // Determine the size of the required buffer.
            dwStatus = RegQueryValueExW (
                hKey,
                L"DefaultLogFileFolder",
                NULL,
                &dwDataType,
                NULL,
                &dwBufferSize);

            if (dwStatus == ERROR_SUCCESS) {
                if (dwBufferSize > 0) {

                    szNewStringBuffer = new WCHAR[dwBufferSize / sizeof(WCHAR) ];
                    if ( NULL != szNewStringBuffer ) {
                        *szNewStringBuffer = L'\0';
                    
                        dwStatus = RegQueryValueEx(
                                     hKey,
                                     L"DefaultLogFileFolder",
                                     NULL,
                                     &dwDataType,
                                     (LPBYTE) szNewStringBuffer,
                                     (LPDWORD) &dwBufferSize );
                             
                    } else {
                        dwStatus = ERROR_OUTOFMEMORY;
                    }
                } else {
                    dwStatus = ERROR_NO_DATA;
                }
            }
            RegCloseKey(hKey);
        }

        if (dwStatus == ERROR_SUCCESS) {
            if ( *piBufLen >= (INT)(dwBufferSize / sizeof(WCHAR)) ) {
                StringCchCopy(szFolder, *piBufLen, szNewStringBuffer );
            } else {
                dwStatus = ERROR_INSUFFICIENT_BUFFER;
            }
            *piBufLen = dwBufferSize / sizeof(WCHAR);
        }
        if ( NULL != szNewStringBuffer ) 
            delete [] szNewStringBuffer;
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
    }
    return dwStatus;
}


BOOL
AreSameCounterPath (
    PPDH_COUNTER_PATH_ELEMENTS pFirst,
    PPDH_COUNTER_PATH_ELEMENTS pSecond )
{
    BOOL bSame = FALSE;

    assert ( NULL != pFirst && NULL != pSecond );

    if ( NULL != pFirst && NULL != pSecond ) {

        if ( 0 == lstrcmpi ( pFirst->szMachineName, pSecond->szMachineName ) ) { 
            if ( 0 == lstrcmpi ( pFirst->szObjectName, pSecond->szObjectName ) ) { 
                if ( 0 == lstrcmpi ( pFirst->szInstanceName, pSecond->szInstanceName ) ) { 
                    if ( 0 == lstrcmpi ( pFirst->szParentInstance, pSecond->szParentInstance ) ) { 
                        if ( pFirst->dwInstanceIndex == pSecond->dwInstanceIndex ) { 
                            if ( 0 == lstrcmpi ( pFirst->szCounterName, pSecond->szCounterName ) ) { 
                                bSame = TRUE; 
                            }
                        }
                    }
                }
            }
        }
    }
    return bSame;
};

BOOL    
DisplaySingleLogSampleValue ( void )
{
    long nErr;
    HKEY hKey = NULL;
    DWORD dwRegValue;
    DWORD dwDataType;
    DWORD dwDataSize;
    DWORD dwDisposition;

    static INT siInitialized;   // Initialized to 0
    static BOOL sbSingleValue;  // Initialized to 0 ( FALSE )

    // check registry setting to see if thousands separator is enabled
    if ( 0 == siInitialized ) {
        nErr = RegOpenKey( 
                    HKEY_CURRENT_USER,
                    L"Software\\Microsoft\\SystemMonitor",
                    &hKey );

        if( ERROR_SUCCESS != nErr ) {
            nErr = RegCreateKeyEx( 
                        HKEY_CURRENT_USER,
                        L"Software\\Microsoft\\SystemMonitor",
                        0,
                        L"REG_DWORD",
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dwDisposition );
        }

        dwRegValue = 0;
        if ( ERROR_SUCCESS == nErr ) {

            dwDataSize = sizeof(DWORD);
            nErr = RegQueryValueExW (
                        hKey,
                        L"DisplaySingleLogSampleValue",
                        NULL,
                        &dwDataType,
                        (LPBYTE) &dwRegValue,
                        (LPDWORD) &dwDataSize );

            if ( ERROR_SUCCESS == nErr 
                    && REG_DWORD == dwDataType
                    && sizeof(DWORD) == dwDataSize )
            {
                if ( 0 != dwRegValue ) {
                    sbSingleValue = TRUE;
                }
            }
            siInitialized = 1;
        }

        if ( NULL != hKey ) {        
            nErr = RegCloseKey( hKey );
        }
    }

    return sbSingleValue;
}

DWORD
FormatSqlDataSourceName (
    LPCWSTR szSqlDsn,
    LPCWSTR szSqlLogSetName,
    LPWSTR  szSqlDataSourceName,
    ULONG*  pulBufLen )
{

    DWORD dwStatus = ERROR_SUCCESS;
    ULONG ulNameLen;

    if ( NULL != pulBufLen ) {
        ulNameLen =  lstrlen (szSqlDsn) 
                     + lstrlen(szSqlLogSetName)
                     + 5    // SQL:<DSN>!<LOGSET>
                     + 2;   // 2 NULL characters at the end;
    
        if ( ulNameLen <= *pulBufLen ) {
            if ( NULL != szSqlDataSourceName ) {
                StringCchPrintf( szSqlDataSourceName,
                                 *pulBufLen,
                                 cszSqlDataSourceFormat,
                                 szSqlDsn,
                                 szSqlLogSetName );
            }
        } else if ( NULL != szSqlDataSourceName ) {
            dwStatus = ERROR_MORE_DATA;
        }    
        *pulBufLen = ulNameLen;
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
        assert ( FALSE );
    }
    return dwStatus;
}


DWORD 
DisplayDataSourceError (
    HWND    hwndOwner,
    DWORD   dwErrorStatus,
    INT     iDataSourceType,
    LPCWSTR szLogFileName,
    LPCWSTR szSqlDsn,
    LPCWSTR szSqlLogSetName )
{
    DWORD   dwStatus = ERROR_SUCCESS;

    LPWSTR  szMessage = NULL;
    LPWSTR  szDataSource = NULL;
    ULONG   ulMsgBufLen = 0;
    WCHAR   szSystemMessage[MAX_PATH];

    // todo:  Alloc message buffers

    if ( sysmonLogFiles == iDataSourceType ) {
        if ( NULL != szLogFileName ) {
            ulMsgBufLen = lstrlen ( szLogFileName ) +1;
            szDataSource = new WCHAR [ulMsgBufLen];
            if ( NULL != szDataSource ) {
                StringCchCopy(szDataSource, ulMsgBufLen, szLogFileName );
            } else {
                dwStatus = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            assert ( FALSE );
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    } else if ( sysmonSqlLog == iDataSourceType ){
        if ( NULL != szSqlDsn && NULL != szSqlLogSetName ) {

            FormatSqlDataSourceName ( 
                        szSqlDsn,
                        szSqlLogSetName,
                        NULL,
                        &ulMsgBufLen );
            szDataSource = new WCHAR [ulMsgBufLen];
            if ( NULL != szDataSource ) {
                FormatSqlDataSourceName ( 
                            szSqlDsn,
                            szSqlLogSetName,
                            (LPWSTR)szDataSource,
                            &ulMsgBufLen );
            
            // todo:  check status
            } else {
                dwStatus = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            assert ( FALSE );
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    } else {
        assert ( FALSE );
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    if ( ERROR_SUCCESS == dwStatus ) {
        ulMsgBufLen += RESOURCE_STRING_BUF_LEN;
        ulMsgBufLen += MAX_PATH;
        szMessage = new WCHAR [ulMsgBufLen];
        if ( NULL != szMessage ) {
            if ( SMON_STATUS_TOO_FEW_SAMPLES == dwErrorStatus ) {
                StringCchPrintf(szMessage, 
                                ulMsgBufLen,
                                ResourceString(IDS_TOO_FEW_SAMPLES_ERR), 
                                szDataSource );
            } else if ( SMON_STATUS_LOG_FILE_SIZE_LIMIT == dwErrorStatus ) {
                StringCchPrintf(szMessage, 
                                ulMsgBufLen,
                                ResourceString(IDS_LOG_FILE_TOO_LARGE_ERR), 
                                szDataSource );
            } else {
                StringCchPrintf(szMessage, 
                                ulMsgBufLen,
                                ResourceString(IDS_BADDATASOURCE_ERR), 
                                szDataSource );
                FormatSystemMessage ( dwErrorStatus, szSystemMessage, MAX_PATH - 1 );
                StringCchCat(szMessage, ulMsgBufLen, szSystemMessage );
            }

            MessageBox(
                hwndOwner, 
                szMessage, 
                ResourceString(IDS_APP_NAME), 
                MB_OK | MB_ICONEXCLAMATION);
        }
    }
    
    if ( NULL != szDataSource ) {
        delete [] szDataSource;
    }

    if ( NULL != szMessage ) {
        delete [] szMessage;
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\visuals.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    visuals.h

Abstract:

    <abstract>

--*/

#ifndef _VISUALS_H_
#define _VISUALS_H_

#define NumStandardColorIndices() (16)
#define NumColorIndices() (NumStandardColorIndices()+1)                         
#define NumStyleIndices() (5)
#define NumWidthIndices() (9)                

#define IndexToStandardColor(i) (argbStandardColors[i])
#define IndexToStyle(i) (i)
#define IndexToWidth(i) (i+1)                  

#define WidthToIndex(i) (i-1)
#define StyleToIndex(i) (i)
    
extern COLORREF argbStandardColors[16];

//===========================================================================
// Exported Functions
//===========================================================================

INT ColorToIndex( COLORREF );

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\winhelpr.h ===
/*++

Copyright (C) 1992-1999 Microsoft Corporation

Module Name:

    winhelpr.h

Abstract:

    This file contains macros for more easily dealing with windows
    messages and objects. Think of it as an extension to windows.h.
--*/

//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


#define SetFont(hWnd, hFont)                          \
   (SendMessage ((hWnd), WM_SETFONT, (WPARAM)hFont, (LPARAM)0))

#define GetFont(hWnd) \
    (HFONT)(SendMessage((hWnd), WM_GETFONT, (WPARAM)0, (LPARAM)0))

#define PrintClient(hWnd, hDC, uFlags) \
    (SendMessage((hWnd), WM_PRINTCLIENT, (WPARAM)hDC, (LPARAM)(uFlags)) )

//======================================//
// Object-differentiation routines      //
//======================================//


// Windows APIs deal with all GDI objects the same. There's a SelectObject,
// no SelectBitmap, SelectFont, etc. We use these instead to make the code
// easier to read. Also, you can redefine one of these to check the 
// validity of a particular GDI object type.


#define SelectBitmap(hDC, hBitmap)                    \
   ((HBITMAP)SelectObject (hDC, hBitmap))

#define SelectFont(hDC, hFont)                        \
   ((HFONT)SelectObject (hDC, hFont))

#define SelectBrush(hDC, hBrush)                      \
   ((HBRUSH)SelectObject (hDC, hBrush))

#define DeleteBrush(hBrush)                           \
   (DeleteObject (hBrush))

#define SelectPen(hDC, hPen)                          \
   ((HPEN)SelectObject (hDC, hPen))

#define DeletePen(hPen)                               \
   (DeleteObject (hPen))


//======================================//
//                                      //
//======================================//


#define CBData(hWndCB, iIndex)                        \
   (SendMessage (hWndCB, CB_GETITEMDATA, (WPARAM)iIndex, (LPARAM)0))


#define CBSetData(hWndCB, iIndex, lData)              \
   (SendMessage (hWndCB, CB_SETITEMDATA, (WPARAM)iIndex, (LPARAM)lData))


#define CBAdd(hWndCB, lpszText)                       \
   ((INT)(DWORD)SendMessage((hWndCB), CB_ADDSTRING,   \
    (WPARAM)0, (LPARAM)(LPCTSTR)(lpszText)))

#define CBDelete(hWndCB, iIndex)                        \
   ((INT)(DWORD)SendMessage((hWndCB), CB_DELETESTRING,  \
    (WPARAM)iIndex, (LPARAM)0))

#define CBFind(hWndCB, lpszText)                      \
   (SendMessage (hWndCB, CB_FINDSTRING, (WPARAM)(-1), (LPARAM) lpszText))


#define CBInsert(hWndCB, iIndex, lpszText)            \
   (SendMessage (hWndCB, CB_INSERTSTRING, (WPARAM)iIndex, (LPARAM) lpszText))


#define CBNumItems(hWndCB)                            \
   ((INT) SendMessage (hWndCB, CB_GETCOUNT, (WPARAM)0, (LPARAM)0))


#define CBReset(hWndCB)                               \
   ((INT)(DWORD)SendMessage((hWndCB), CB_RESETCONTENT,\
    (WPARAM)0, (LPARAM)0))


#define CBSelection(hWndCB)                           \
   ((INT)(DWORD)(SendMessage (hWndCB, CB_GETCURSEL, (WPARAM)0, (LPARAM)0)))


#define CBSetSelection(hWndCB, iIndex)                \
   ((INT)(DWORD)SendMessage ((hWndCB), CB_SETCURSEL, \
    (WPARAM)iIndex, (LPARAM)0))


#define CBString(hWndCB, iIndex, lpszText)            \
   (SendMessage (hWndCB, CB_GETLBTEXT, (WPARAM)iIndex, (LPARAM)lpszText))


#define CBStringLen(hWndCB, iIndex)                   \
   (SendMessage (hWndCB, CB_GETLBTEXTLEN, (WPARAM)iIndex, (LPARAM)0))



//======================================//
// Listbox helpers                      //
//======================================//


#define LBAdd(hWndLB, lpszText)                       \
   (SendMessage (hWndLB, LB_ADDSTRING, (WPARAM)0, (LPARAM)lpszText))


#define LBData(hWndLB, iIndex)                        \
(SendMessage (hWndLB, LB_GETITEMDATA, (WPARAM)iIndex, (LPARAM)0))


#define LBDelete(hWndLB, iIndex)                      \
   (SendMessage (hWndLB, LB_DELETESTRING, (WPARAM)iIndex, (LPARAM)0))


#define LBFind(hWndLB, lpszText)                      \
   (SendMessage (hWndLB, LB_FINDSTRING, (WPARAM)-1, (LPARAM)lpszText))


#define LBFocus(hWndLB)                               \
   ((INT)SendMessage (hWndLB, LB_GETCARETINDEX, (WPARAM)0, (LPARAM)0))


#define LBInsert(hWndLB, iIndex, lpszText)            \
   (SendMessage (hWndLB, LB_INSERTSTRING, (WPARAM)iIndex, (LPARAM)lpszText))


#define LBNumItems(hWndLB)                            \
   ((INT) SendMessage (hWndLB, LB_GETCOUNT, (WPARAM)0, (LPARAM)0))


#define LBReset(hWndLB)                               \
   ((INT)(DWORD)SendMessage((hWndLB), LB_RESETCONTENT,\
    (WPARAM)0, (LPARAM)0))


#define LBSelected(hwndLB, index)                     \
   ((INT)(DWORD)SendMessage((hwndLB), LB_GETSEL,      \
    (WPARAM)(INT)(index), (LPARAM)0))


#define LBSelection(hWndLB)                           \
   ((INT)(DWORD)SendMessage (hWndLB, LB_GETCURSEL, (WPARAM)0, (LPARAM)0))


#define LBSetData(hWndLB, iIndex, lData)              \
   (SendMessage (hWndLB, LB_SETITEMDATA, (WPARAM)iIndex, (LPARAM)lData))


#define LBSetSelection(hWndLB, iIndex)                \
   (SendMessage (hWndLB, LB_SETCURSEL, (WPARAM)iIndex, (LPARAM)0))

#define MLBSetSelection(hWndMLB, iIndex, bSet)        \
   (SendMessage (hWndMLB, LB_SETSEL, (WPARAM)bSet, (LPARAM)iIndex))

#define LBSetVisible(hWndLB, iIndex)                  \
   (SendMessage (hWndLB, LB_SETCARETINDEX, (WPARAM)iIndex, (LPARAM)0))

 
#define LBSetRedraw(hWndLB, bDrawOnOff)               \
   (SendMessage (hWndLB, WM_SETREDRAW, (WPARAM)bDrawOnOff, (LPARAM)0))


#define LBSetHorzExtent(hWndLB, wExtent)              \
   (SendMessage (hWndLB, LB_SETHORIZONTALEXTENT, (WPARAM)wExtent, (LPARAM)0))


#define LBSetItemHeight(hWndLB, iHeight)              \
    (SendMessage (hWndLB, LB_SETITEMHEIGHT, (WPARAM)0, (LPARAM)iHeight)) 


#define LBGetTextLen(hWndLB, iIndex)                  \
    (SendMessage (hWndLB, LB_GETTEXTLEN, (WPARAM)iIndex, (LPARAM)0))


#define LBGetText(hWndLB, iIndex, szPath)             \
    (SendMessage (hWndLB, LB_GETTEXT, (WPARAM)iIndex, (LPARAM)szPath))

#define LBSelectCount(hWndLB)             \
    ((INT)SendMessage (hWndLB, LB_GETSELCOUNT, (WPARAM)0, (LPARAM)0))

#define LBSetSel(hWndLB, fSelected, iIndex)                \
   (SendMessage (hWndLB, LB_SETSEL, (WPARAM)fSelected, (LPARAM)iIndex))

#define LBGetSelItems(hWndLB, nMax, pBuffer)                \
   ((INT)SendMessage (hWndLB, LB_GETSELITEMS, (WPARAM)nMax, (LPARAM)pBuffer))

//======================================//
// Edit helpers                         //
//======================================//


#define EditModified(hWndEdit)                        \
   (SendMessage ((hWndEdit), EM_GETMODIFY, (WPARAM)0, (LPARAM)0))


#define EditSetModified(hWndEdit, bModified)                     \
   (SendMessage ((hWndEdit), EM_SETMODIFY, (WPARAM)bModified, (LPARAM)0))


#define EditSetLimit(hWndEdit, iLimit)                \
   (SendMessage ((hWndEdit), EM_LIMITTEXT, (WPARAM)iLimit, (LPARAM)0))
#define EditSetTextPos(hWnd, idControl, iStartPos, iEndPos)    \
   (SendMessage (GetDlgItem(hWnd, idControl), EM_SETSEL, (WPARAM)iStartPos, (LPARAM)iEndPos))

#define EditSetTextEndPos(hWnd, idControl)    \
   EditSetTextPos(hWnd, idControl, (WPARAM)0, (LPARAM)32767)

//======================================//
// Cursor helpers                       //
//======================================//

#define SetHourglassCursor() \
    (SetCursor(LoadCursor(NULL, IDC_WAIT)))

#define SetArrowCursor() \
    (SetCursor(LoadCursor(NULL, IDC_ARROW)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\controls\smonctrl\utils.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    <abstract>

--*/

#ifndef _UTILS_H_
#define _UTILS_H_

#include <pdh.h>
#include <wtypes.h>  // for DATE typedef

extern LPCWSTR cszSqlDataSourceFormat;

//===========================================================================
// Macro Definitions
//===========================================================================

//
// String lengths
//

#define MAX_MESSAGE_LEN (MAX_PATH)
// If RESOURCE_STRING_BUF_LEN > MAX_PATH, must check all calls to ResourceString()
// to ensure caller's buffer size is correct.
#define RESOURCE_STRING_BUF_LEN  (MAX_PATH * 2)
#define MAX_VALUE_LEN     30

//
// General purpose
//
#define PinInclusive(x, lo, hi) \
   max (lo, min (x, hi))

#define PinExclusive(x, lo, hi) \
   max ((lo) + 1, min (x, (hi) - 1))

//
// Text
//
#define ELLIPSES L"..."
#define ELLIPSES_CNT 3

//
// Window
//
#define WindowInvalidate(hWnd) \
   InvalidateRect (hWnd, NULL, TRUE)

#define WindowShow(hWnd, bShow) \
   ShowWindow (hWnd, (bShow) ? SW_SHOW : SW_HIDE)

#define WindowID(hWnd) \
    GetWindowLongPtr(hWnd, GWLP_ID)

#define WindowStyle(hWnd) \
   GetWindowLong (hWnd, GWL_STYLE)

#define WindowSetStyle(hWnd, lStyle) \
   SetWindowLong (hWnd, GWL_STYLE, lStyle)

#define WindowParent(hWnd) \
   ((HWND) GetWindowLongPtr (hWnd, GWLP_HWNDPARENT))


//
// Dialog
//
#define DialogControl(hDlg, wControlID) \
   GetDlgItem (hDlg, wControlID)

#define DialogText(hDlg, wControlID, szText) \
   ((INT)(DWORD)GetDlgItemText (hDlg, wControlID, szText, (sizeof(szText) / sizeof(WCHAR))))


//
// GDI
//
#define ClearRect(hDC, lpRect) \
    ExtTextOut (hDC, 0, 0, ETO_OPAQUE, lpRect, NULL, 0, NULL )

//===========================================================================
// Exported Functions
//===========================================================================

//
// Font/Text
//
INT TextWidth (
    HDC hDC, 
    LPCWSTR lpszText
) ;

INT FontHeight (
    HDC hDC, 
    BOOL bIncludeLeading
) ;

BOOL NeedEllipses (  
    IN  HDC hAttribDC,
    IN  LPCWSTR pszText,
    IN  INT nTextLen,
    IN  INT xMaxExtent,
    IN  INT xEllipses,
    OUT INT *pnChars
) ;


VOID FitTextOut (
    IN HDC hDC, 
    IN HDC hAttribDC,
    IN UINT fuOptions,
    IN CONST RECT *lprc,
    IN LPCWSTR lpString, 
    IN INT cbCount,
    IN INT iAlign,
    IN BOOL fVertical
) ;

//
// Dialog
//
BOOL DialogEnable (HWND hDlg, WORD wID, BOOL bEnable) ;
void DialogShow (HWND hDlg, WORD wID, BOOL bShow) ;
FLOAT DialogFloat (HWND hDlg, WORD wControlID, BOOL *pbOK) ;

//
// Graphic
//
void Line (HDC hDC, HPEN hPen, INT x1, INT y1, INT x2, INT y2) ;
void Fill (HDC hDC, COLORREF rgbColor, LPRECT lpRect);

#ifdef __IEnumFORMATETC_INTERFACE_DEFINED__
HDC  CreateTargetDC(HDC hdc, DVTARGETDEVICE* ptd);
#endif

//
// Conversion
//
BOOL TruncateLLTime (LONGLONG llTime, LONGLONG* pllTime);
BOOL LLTimeToVariantDate (LONGLONG llTime, DATE *pDate);
BOOL VariantDateToLLTime (DATE Date, LONGLONG *pllTime);

//
// Stream I/O - only include if user knows about IStream
//
#ifdef __IStream_INTERFACE_DEFINED__
HRESULT WideStringFromStream (LPSTREAM pIStream, LPWSTR *ppsz, INT nLen);
#endif

//
// Property bag I/O - only include if user knows about IStream
//
#ifdef __IPropertyBag_INTERFACE_DEFINED__
HRESULT 
IntegerToPropertyBag (
    IPropertyBag* pPropBag, 
    LPCWSTR szPropName, 
    INT intData );

HRESULT
OleColorToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCWSTR szPropName, 
    OLE_COLOR& clrData );

HRESULT
ShortToPropertyBag (
    IPropertyBag* pPropBag, 
    LPCWSTR szPropName, 
    SHORT iData );


HRESULT 
BOOLToPropertyBag (
    IPropertyBag* pPropBag, 
    LPCWSTR szPropName, 
    BOOL bData );

HRESULT 
DoubleToPropertyBag (
    IPropertyBag* pPropBag, 
    LPCWSTR szPropName, 
    DOUBLE dblData );

HRESULT
FloatToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCWSTR szPropName, 
    FLOAT fData );

HRESULT 
CyToPropertyBag (
    IPropertyBag* pPropBag, 
    LPCWSTR szPropName, 
    CY& cyData );

HRESULT 
StringToPropertyBag (
    IPropertyBag* pPropBag, 
    LPCWSTR szPropName, 
    LPCWSTR szData );

HRESULT
LLTimeToPropertyBag (
    IPropertyBag* pIPropBag, 
    LPCWSTR szPropName, 
    LONGLONG& rllData );

HRESULT 
IntegerFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    INT& rintData );

HRESULT
OleColorFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    OLE_COLOR& rintData );

HRESULT 
ShortFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    SHORT& riData );

HRESULT
BOOLFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    BOOL& rbData );

HRESULT 
DoubleFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    DOUBLE& rdblData );

HRESULT
FloatFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    FLOAT& rfData );

HRESULT
CyFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    CY& rcyData );

HRESULT 
StringFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    LPWSTR szData,
    INT& riBufSize );

HRESULT
LLTimeFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog*  pIErrorLog,
    LPCWSTR szPropName, 
    LONGLONG& rllData );
#endif

//
// Resources
//
LPWSTR ResourceString(UINT uID);

//
// Message format
//

DWORD
FormatSystemMessage (
    DWORD   dwMessageId,
    LPWSTR  pszSystemMessage, 
    DWORD   dwBufSize );

//
// Locale and format
//

#define MAX_TIME_CHARS  20
#define MAX_DATE_CHARS  20

INT
FormatHex (
double  dValue,
LPWSTR  pNumFormatted,
BOOL    bLargeFormat
);

INT
FormatNumber (
double  dValue,
LPWSTR  pNumFormatted,
INT     ccharsFormatted,
UINT    uiMinimumWidth,
UINT    uiPrecision );

INT
FormatScientific (
double  dValue,
LPWSTR  pNumFormatted,
INT     ccharsFormatted,
UINT    uiMinimumWidth,
UINT    uiPrecision );

void 
FormatDateTime (
    LONGLONG    llTime,
    LPWSTR      pszDate,
    LPWSTR      pszTime );

LPWSTR 
GetTimeSeparator ( void );

BOOL    
DisplayThousandsSeparator ( void );

BOOL    
DisplaySingleLogSampleValue ( void );

//
// Hit testing
//

BOOL 
HitTestLine (
    POINT pt0, 
    POINT pt1, 
    POINTS ptMouse, 
    INT nWidth );

#define MPOINT2POINT(mpt, pt)   ((pt).x = (mpt).x, (pt).y = (mpt).y)
#define POINT2MPOINT(pt, mpt)   ((mpt).x = (SHORT)(pt).x, (mpt).y = (SHORT)(pt).y)
#define POINTS2VECTOR2D(pt0, pt1, vect) ((vect).x = (double)((pt1).x - (pt0).x), \
                                         (vect).y = (double)((pt1).y - (pt0).y))
typedef struct tagVECTOR2D  {
        double     x;
        double     y;
} VECTOR2D, *PVECTOR2D, FAR *LPVECTOR2D; 

typedef struct tagPROJECTION  {
        VECTOR2D   ttProjection;
        VECTOR2D   ttPerpProjection;
        double     LenProjection;
        double     LenPerpProjection;
} PROJECTION, *PPROJECTION, FAR *LPPROJECTION; 

typedef struct tagPOINTNORMAL  {
        VECTOR2D   vNormal;
        double     D;
} POINTNORMAL, *PPOINTNORMAL, FAR *LPPOINTNORMAL;

PVECTOR2D   vSubtractVectors(PVECTOR2D v0, PVECTOR2D v1, PVECTOR2D v);
double      vVectorSquared(PVECTOR2D v0);
double      vVectorMagnitude(PVECTOR2D v0);
double      vDotProduct(PVECTOR2D v, PVECTOR2D v1);
void        vProjectAndResolve(PVECTOR2D v0, PVECTOR2D v1, PPROJECTION ppProj);
double      vDistFromPointToLine(LPPOINT pt0, LPPOINT pt1, LPPOINT ptTest);

BOOL 
FileRead (
    HANDLE hFile,
    void* lpMemory,
    DWORD nAmtToRead );

BOOL
FileWrite (
    HANDLE hFile,
    void* lpMemory,
    DWORD nAmtToWrite );

LPWSTR 
ExtractFileName (
    LPWSTR pFileSpec );

// Folder path 
DWORD
LoadDefaultLogFileFolder(
    WCHAR   *szFolder,
    INT*    piBufLen );

// Pdh counter paths

BOOL
AreSameCounterPath (
    PPDH_COUNTER_PATH_ELEMENTS pFirst,
    PPDH_COUNTER_PATH_ELEMENTS pSecond );

// SQL data source

DWORD
FormatSqlDataSourceName (
    LPCWSTR szSqlDsn,
    LPCWSTR szSqlLogSetName,
    LPWSTR  szSqlDataSourceName,
    ULONG*  pulBufLen );

DWORD 
DisplayDataSourceError (
    HWND    hwndOwner,
    DWORD   dwErrorStatus,
    INT     iDataSourceType,
    LPCWSTR szLogFileName,
    LPCWSTR szSqlDsn,
    LPCWSTR szSqlLogSetName );

/////////////////////////////////////////////////////////////////////////////
// class CWaitCursor

class CWaitCursor
{
// Construction/Destruction
public:
	CWaitCursor();
	virtual ~CWaitCursor();

private:
    void DoWaitCursor ( INT nCode );
    
    HCURSOR  m_hcurWaitCursorRestore;
};


#endif //_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\dsrestore\passfilt\clogger.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  File Name 
//      EventLogger.CPP
//
//  Description
//
//  Revision: 2.01
//
//  Copyright (c) 1996-1999 Acotec, Inc.
//  All rights reserved.
//
//
//  Portions Copyright (c) 1999 Microsoft Corporation.  All rights reserved.
//
#include "clogger.h"

///////////////////////////////////////////////////////////////////////////////
//    CEventLogger::CEventLogger()
//
//    Parameters
//
//    Purpose
//      
//    Return Value
//
CEventLogger::CEventLogger()
{
    InitializeCriticalSection (&m_csObj);
    m_hEventLog = NULL;
    m_wServiceCategory = 0;
    m_LoggingLevel = LOGGING_LEVEL_1;
    m_hLogMutex = NULL;
	m_fLogEvent = TRUE;
    m_hMsgSource = NULL;
    ZeroMemory (m_szCat, sizeof(m_szCat));
}

///////////////////////////////////////////////////////////////////////////////
//    CEventLogger::CEventLogger()
//
//    Parameters
//
//    Purpose
//      
//    Return Value
//
CEventLogger::CEventLogger(LPTSTR szEventSource, WORD wEventsCategory)
{
    CEventLogger();
    InitEventLog (szEventSource, wEventsCategory);
}

///////////////////////////////////////////////////////////////////////////////
//    CEventLogger::~CEventLogger()
//
//    Parameters
//
//    Purpose
//      
//    Return Value
//
CEventLogger::~CEventLogger()
{
    if (m_hLogMutex)
    {
        CloseHandle (m_hLogMutex);
    }
    if (m_hEventLog)
    {
        DeregisterEventSource (m_hEventLog);
    }
    DeleteCriticalSection (&m_csObj);
}


///////////////////////////////////////////////////////////////////////////////
//    CEventLogger::InitEventLog()
//
//    Parameters
//
//    Purpose
//      
//    Return Value
//
DWORD WINAPI CEventLogger::InitEventLog (LPTSTR szEventSource,
                                         WORD  wEventsCategory,
                                         LPTSTR szRegKey)
{
    EnterCriticalSection (&m_csObj);
    if (m_hEventLog)
    {
        DeregisterEventSource (m_hEventLog);
        m_hEventLog = NULL;
    }
    m_wServiceCategory = wEventsCategory;
    m_LoggingLevel = LOGGING_LEVEL_1;
    
    HKEY hKey;
    DWORD dwValue=LOGGING_LEVEL_1, dwError = 0, dwSize = sizeof(DWORD);

    m_hEventLog = RegisterEventSource (NULL, szEventSource);
    if (!m_hEventLog)
    {
        dwError = GetLastError();
        m_LoggingLevel = LOGGING_LEVEL_0;
    }
    else 
    if (szRegKey && 
        ERROR_SUCCESS == (dwError=RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                                   szRegKey,
                                                   0,
                                                   KEY_READ,
                                                   &hKey)))
    {
        dwError=RegQueryValueEx (hKey,
                         REGVAL_LOGGING_LEVEL,
                         NULL,
                         NULL,
                         (LPBYTE)&dwValue,
                         &dwSize);
        if(ERROR_SUCCESS == dwError )
        {
            if (dwValue > (DWORD)LOGGING_LEVEL_3)
            {
                dwValue = (DWORD)LOGGING_LEVEL_3;
            }
            m_LoggingLevel = (LOGLEVEL)dwValue;
        }
        RegCloseKey (hKey);
	}
    
    LeaveCriticalSection (&m_csObj);
    return dwError;
}

///////////////////////////////////////////////////////////////////////////////
//    CEventLogger::SetLoggingLevel()
//
//    Parameters
//
//    Purpose
//      
//    Return Value
//
void WINAPI CEventLogger::SetLoggingLevel (LOGLEVEL NewLoggingLevel)
{
    EnterCriticalSection (&m_csObj);
    m_LoggingLevel = NewLoggingLevel;
    LeaveCriticalSection (&m_csObj);
}

///////////////////////////////////////////////////////////////////////////////
//    CEventLogger::LogEvent()
//
//    Parameters
//
//    Purpose
//      
//    Return Value
//
void WINAPI CEventLogger::LogEvent (LOGTYPE Type,
                                    DWORD   dwEventID,
                                    DWORD   dwData,
                                    LPCTSTR  rgszMsgs[],
                                    WORD    wCount,
                                    DWORD   cbData,
                                    LPVOID  pvData)
{
    if (LOGGING_LEVEL_0 == m_LoggingLevel &&
        LOGTYPE_FORCE_ERROR != Type &&
        LOGTYPE_FORCE_WARNING != Type &&
        LOGTYPE_FORCE_INFORMATION != Type)
    {
        return;
    }
	if (!m_fLogEvent)
		return;


    TCHAR szBuffer[64];
    LPCTSTR rgszError[] =
    {
        szBuffer
    };

    LPTSTR pszType;
    WORD wEventType;
    switch (Type)
    {
        case LOGTYPE_ERR_CRITICAL :
        case LOGTYPE_FORCE_ERROR :
            pszType = _T("ERROR");
            wEventType = EVENTLOG_ERROR_TYPE;
            if (NULL == rgszMsgs)
            {
                _stprintf (szBuffer, _T("%d"), dwData);
                rgszMsgs = rgszError;
                wCount = 1;
            }
            break;
        case LOGTYPE_ERR_WARNING :
            if (m_LoggingLevel < LOGGING_LEVEL_2) { return; }
        case LOGTYPE_FORCE_WARNING :
            pszType = _T("WARNING");
            wEventType = EVENTLOG_WARNING_TYPE;
            if (dwData && NULL == rgszMsgs)
            {
                _stprintf (szBuffer, _T("%d"), dwData);
                rgszMsgs = rgszError;
                wCount = 1;
            }
            break;
        case LOGTYPE_AUDIT_SECURITY_ACCESS :
        case LOGTYPE_AUDIT_SECURITY_DENIED :
            pszType = _T("SECURITY");
        case LOGTYPE_INFORMATION :
            if (m_LoggingLevel < LOGGING_LEVEL_3) { return; }
        case LOGTYPE_FORCE_INFORMATION :
            switch (Type)
            {
                case LOGTYPE_AUDIT_SECURITY_ACCESS : wEventType = EVENTLOG_AUDIT_SUCCESS; break;
                case LOGTYPE_AUDIT_SECURITY_DENIED : wEventType = EVENTLOG_AUDIT_FAILURE; break;
                case LOGTYPE_FORCE_INFORMATION :
                case LOGTYPE_INFORMATION :
                    wEventType = EVENTLOG_INFORMATION_TYPE;
                    pszType = _T("INFORMATION");
                    break;
            }
            break;
        case LOGTYPE_VERBOSE :
        case LOGTYPE_VERBOSE_ERROR :
        case LOGTYPE_VERBOSE_WARNING :
            if (m_LoggingLevel < LOGGING_LEVEL_3) { return; }
            if ((LOGTYPE_VERBOSE_ERROR == Type || LOGTYPE_VERBOSE_WARNING == Type) &&
                dwData && NULL == rgszMsgs)
            {
                _stprintf (szBuffer, _T("%d"), dwData);
                rgszMsgs = rgszError;
                wCount = 1;
            }
            switch (Type)
            {
                case LOGTYPE_VERBOSE :
                    wEventType = EVENTLOG_INFORMATION_TYPE;
                    pszType = _T("V_INFORMATION");
                    break;
                case LOGTYPE_VERBOSE_ERROR :
                    wEventType = EVENTLOG_ERROR_TYPE;
                    pszType = _T("V_ERROR");
                    break;
                case LOGTYPE_VERBOSE_WARNING :
                    wEventType = EVENTLOG_WARNING_TYPE;
                    pszType = _T("V_WARNING");
                    break;
            }
            break;
        default :
            return;
    }

    if (m_hEventLog)
    {
         ReportEvent (m_hEventLog,
		              wEventType, 
		              m_wServiceCategory,
		              dwEventID,
		              NULL,
		              wCount,
		              cbData,
		              rgszMsgs,
		              pvData);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\dsrestore\passfilt\main.h ===
/************************************************************************************************
Copyright (c) 2001 Microsoft Corporation

Module Name:    main.h.
Abstract:       Declares the DSRestoreSync class. See description below.
Notes:          
History:        05/9/2001 - created, Paolo Raden (paolora).
************************************************************************************************/

#pragma once

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS  ((NTSTATUS)0x00000000L)
#endif

BOOL NTAPI InitializeChangeNotify( void );
NTSTATUS NTAPI PasswordChangeNotify( PUNICODE_STRING UserName, ULONG RelativeId, PUNICODE_STRING NewPassword );
BOOL NTAPI PasswordFilter( PUNICODE_STRING AccountName, PUNICODE_STRING FullName, PUNICODE_STRING Password, BOOLEAN SetOperation );
DWORD WINAPI PassCheck( LPVOID lpParameter );
HRESULT NTAPI RegisterFilter( void );
HRESULT NTAPI UnRegisterFilter( void );


// End of file main.h.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\dsrestore\passfilt\clogger.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  File Name 
//      EventLogger.h
//
//
//  Portions Copyright (c) 2002 Microsoft Corporation.  All rights reserved.
//
#ifndef _CEVENTLOGGER_H
#define _CEVENTLOGGER_H

#pragma warning (disable : 4100)
#pragma warning (disable : 4127)
#pragma warning (disable : 4201)
#pragma warning (disable : 4237)
#pragma warning (disable : 4245)
#pragma warning (disable : 4514)

#ifndef STRICT
#define STRICT
#endif //!STRICT
#include <WINDOWS.H>
#include <TCHAR.H>
#include <stdio.h>
#include <stdlib.h>

#define REGVAL_LOGGING_LEVEL        _T("Logging")

#define COUNTOF(a) (sizeof(a)/sizeof(a[0]))
#define STR_BYTE_SIZE(a)  ((_tcslen (a) + 1)*sizeof(TCHAR))

// Level of logging in the event registry

typedef enum LOGLEVEL
{
    LOGGING_LEVEL_0    =  0, // None: No event log traces at all.
    LOGGING_LEVEL_1,         // Minimal: No audit or information traces. Only critical and warning errors
    LOGGING_LEVEL_2,         // Normal: Security audit traces plus previous level
    LOGGING_LEVEL_3          // Verbose: All transactions are traced out plus previous level
} LOGLEVEL;

typedef enum LOGTYPE
{
    LOGTYPE_FORCE_ERROR,            // Logged in any Level regardless.
    LOGTYPE_FORCE_WARNING,          // Logged in any Level regardless.
    LOGTYPE_FORCE_INFORMATION,      // Logged in any Level regardless.
    LOGTYPE_ERR_CRITICAL,           // Logged in level 1 or above
    LOGTYPE_ERR_WARNING,            // Logged in level 1 or above
    LOGTYPE_AUDIT_SECURITY_ACCESS,  // Logged in level 2 or above
    LOGTYPE_AUDIT_SECURITY_DENIED,  // Logged in level 2 or above
    LOGTYPE_INFORMATION,            // Logged in level 3 or above
    LOGTYPE_VERBOSE,                // Logged in level 4
    LOGTYPE_VERBOSE_ERROR,          // Logged in level 4
    LOGTYPE_VERBOSE_WARNING         // Logged in level 4
} LOGTYPE;



class CEventLogger
{
public :
    DWORD WINAPI InitEventLog
                    (LPTSTR                     szEventSource,
                     WORD                       wEventsCategory,
                     LPTSTR                     szRegKey = NULL);
    DWORD WINAPI InitEventLog
                    (LPTSTR                     szEventSource,
                     WORD                       wEventsCategory,
                     LOGLEVEL                   NewLoggingLevel)
                    {
                        LPTSTR szKey = NULL;
                        DWORD dwError = InitEventLog (szEventSource, wEventsCategory, szKey);
                        if (!dwError)
                        {
                            SetLoggingLevel (NewLoggingLevel);
                        }
                        return dwError;
                    }
    void WINAPI SetLoggingLevel
                    (DWORD                      dwNewLoggingLevel)
                    {
                        if (dwNewLoggingLevel > (DWORD)LOGGING_LEVEL_3)
                        {
                            dwNewLoggingLevel = (DWORD)LOGGING_LEVEL_3;
                        }
                        SetLoggingLevel ((LOGLEVEL)dwNewLoggingLevel);
                    }
    void WINAPI SetLoggingLevel
                    (LOGLEVEL                   NewLoggingLevel);
    DWORD WINAPI GetLoggingLevel
                    ()
                    {
                        EnterCriticalSection (&m_csObj);
                        DWORD dwLevel = (DWORD)m_LoggingLevel;
                        LeaveCriticalSection (&m_csObj);
                        return dwLevel;
                    }
    void WINAPI LogEvent
                    (LOGTYPE                    Type,
                     DWORD                      dwEventID,
                     DWORD                      dwData,
                     LPCTSTR                     rgszMsgs[],
                     WORD                       wCount,
                     DWORD                      cbData = 0,
                     LPVOID                     pvData = NULL);
    void WINAPI LogEvent
                    (LOGTYPE                    Type,
                     DWORD                      dwEventID,
                     DWORD                      dwError = 0)
                    { LogEvent (Type, dwEventID, dwError, NULL, 0); }
    void WINAPI LogEvent
                    (LOGTYPE                    Type,
                     DWORD                      dwEventID,
                     int                        iError )
                    { LogEvent (Type, dwEventID, iError, NULL, 0); }
    void WINAPI LogEvent
                    (LOGTYPE                    Type,
                     DWORD                      dwEventID,
                     LPCTSTR                    rgszMsgs[],
                     WORD                       wCount)
                    { LogEvent (Type, dwEventID, 0, rgszMsgs, wCount); };

    void WINAPI LogEvent
                    (LOGTYPE                    Type,
                     DWORD                      dwEventID,
                     HRESULT                    hResult)
                    { TCHAR szBuffer[32];
                      LPCTSTR rgText[] = { szBuffer };
                      _stprintf (szBuffer, _T("%#08x"), hResult);
                      LogEvent (Type, dwEventID, 0, rgText, 1); };
    void WINAPI LogEvent
                    (LOGTYPE                    Type,
                     DWORD                      dwEventID,
                     LPCTSTR                    szString,
                     HRESULT                    hResult)
                    { TCHAR szBuffer[32];
                      LPCTSTR rgText[] = { szString, szBuffer };
                      _stprintf (szBuffer, _T("%#08x"), hResult);
                      LogEvent (Type, dwEventID, 0, rgText, 2); };

public :
    CEventLogger();
    CEventLogger(LPTSTR                          szEventSource,
                 WORD                           wEventsCategory);
    ~CEventLogger();

private :
    CRITICAL_SECTION    m_csObj;
    WORD                m_wServiceCategory;
    LOGLEVEL            m_LoggingLevel;
    HANDLE              m_hEventLog;
    HANDLE              m_hLogMutex;
    HMODULE             m_hMsgSource;
    TCHAR               m_szCat[32];
	BOOL				m_fLogEvent;
};

#endif // _CEVENTLOGGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\dsrestore\passfilt\main.cpp ===
extern "C"
{
 // include NT and SAM headers here, 
 // order of these files DOES matter
#include <nt.h>
#include <ntrtl.h>     
#include <nturtl.h>    
#include <rpc.h>        
#include <string.h>     
#include <stdio.h>      
#include <assert.h>
#include <samrpc.h>     
#include <ntlsa.h>
#define SECURITY_WIN32
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
#include <samisrv.h>    
#include <lsarpc.h>
#include <lsaisrv.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <netlib.h>
#include <windows.h>
#include <lmerr.h>
#include <lmcons.h>
#include <netlib.h>
#include <ntdef.h>
}


#ifndef OEM_STRING
typedef STRING OEM_STRING;
#endif



#include "main.h"
#include "Clogger.h"

#include "DSREvents.h"

static WCHAR g_wszLSAKey[] = L"SYSTEM\\CurrentControlSet\\Control\\Lsa";
static WCHAR g_wszNotPac[] = L"Notification Packages";
static WCHAR g_wszName[] = L"dsrestor";
static WCHAR g_wszEventLog[] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application";
static WCHAR g_wszEventFileName[] = L"EventMessageFile";
static WCHAR g_wszTypesSupported[] = L"TypesSupported";
static WCHAR g_wszEventFilePath[] = L"%SystemRoot%\\System32\\DSREvt.dll";
static DWORD g_dwTypesSupported = 0x7;

//For comparison of OLD_LARGE_INTEGER
BOOL operator > ( OLD_LARGE_INTEGER li1, OLD_LARGE_INTEGER li2 )
{
    return(   li1.HighPart > li2.HighPart || 
            ( li1.HighPart ==li2.HighPart && li1.LowPart > li2.LowPart ) );
}



//Generate Domain Admin Sid based on Domain Sid
NTSTATUS CreateDomainAdminSid(PSID *ppDomainAdminSid, //[Out] return Domain Admin Sid 
                              PSID pDomainSid)        //[in]  Domain Sid
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    UCHAR       AccountSubAuthorityCount;
    ULONG       AccountSidLength;
    PULONG      RidLocation;
 
    if (!ppDomainAdminSid || !pDomainSid)
        return STATUS_INSUFFICIENT_RESOURCES;

    // Calculate the size of the new sid
    
    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(pDomainSid) + (UCHAR)1;
    AccountSidLength = RtlLengthRequiredSid(AccountSubAuthorityCount);
 
    // Allocate space for the account sid
                        
    *ppDomainAdminSid = RtlAllocateHeap(RtlProcessHeap(), 0, AccountSidLength);
 
    if (*ppDomainAdminSid == NULL) 
    {
 
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    } 
    else 
    { 
        // Copy the domain sid into the first part of the account sid
 
        NTSTATUS IgnoreStatus = RtlCopySid(AccountSidLength, *ppDomainAdminSid, pDomainSid);
 
        // Increment the account sid sub-authority count
 
        if (RtlSubAuthorityCountSid(*ppDomainAdminSid))
            *RtlSubAuthorityCountSid(*ppDomainAdminSid) = AccountSubAuthorityCount;
 
        // Add the rid as the final sub-authority
 
        RidLocation = RtlSubAuthoritySid(*ppDomainAdminSid, AccountSubAuthorityCount-1);
        if (RidLocation)
            *RidLocation = DOMAIN_USER_RID_ADMIN;
 
        NtStatus = STATUS_SUCCESS;
    }

    return NtStatus;

} 




// Create a thread to run PassCheck()
BOOL NTAPI InitializeChangeNotify( void )
{
    ULONG ulID = 0;
    HANDLE hThread = CreateThread( NULL, 0, PassCheck, NULL,  0, &ulID );
    if (hThread && (hThread != INVALID_HANDLE_VALUE))
        CloseHandle( hThread );
    
    return TRUE;
}



NTSTATUS NTAPI PasswordChangeNotify( PUNICODE_STRING UserName, 
                                     ULONG RelativeId, 
                                     PUNICODE_STRING NewPassword )
{
    return STATUS_SUCCESS;
}



BOOL NTAPI PasswordFilter( PUNICODE_STRING AccountName, 
                           PUNICODE_STRING FullName, 
                           PUNICODE_STRING Password, 
                           BOOLEAN SetOperation )
{
    return TRUE;
}




// Get Password for DSRestoreMode and DomainAdmin and set to same if not already
// then sleep for 30 minutes
DWORD WINAPI PassCheck( LPVOID lpParameter )
{
    CEventLogger                EventLogger;
    DWORD                       dwRt=0; //Return Value
    DWORD                       dwSleepTime = 30*60*1000;  
                                        // 30 min * 60 sec * 1000 msec
    NTSTATUS                    RtVal = STATUS_SUCCESS;
    OLD_LARGE_INTEGER           liPasswordLastSet = {0,0};
    SAMPR_HANDLE                hSAMPR = NULL;
    PSAMPR_SERVER_NAME          pSvrName = NULL;
    SAMPR_HANDLE                hServerHandle = NULL;
    SAMPR_HANDLE                hDomainHandle = NULL;
    PSAMPR_USER_INFO_BUFFER     pUserBuffer = NULL;
    LSA_HANDLE                  hPolicyHd = NULL;
    LSA_OBJECT_ATTRIBUTES       ObjAttr;
    PPOLICY_PRIMARY_DOMAIN_INFO pDomainInfo=NULL;
    WCHAR                       szSvrName[MAX_COMPUTERNAME_LENGTH + 1]; 
    DWORD                       dwSvrName = MAX_COMPUTERNAME_LENGTH + 1;
    LSA_UNICODE_STRING          ServerName;
    SID_IDENTIFIER_AUTHORITY    sia = SECURITY_NT_AUTHORITY;
    PSID                        pDomainAdminSid = NULL;   
    NT_OWF_PASSWORD             Password;
    SID_AND_ATTRIBUTES_LIST     GroupMembership;
    SAMPR_HANDLE                UserHandle = NULL;
    UNICODE_STRING              PsudoUserName;


    //Get ready for event logging
    EventLogger.InitEventLog(g_wszName ,0, LOGGING_LEVEL_3);    
    EventLogger.LogEvent(LOGTYPE_INFORMATION, 
                         EVENTDSR_FILTER_STARTED);

    //Required by LsaOpenPolicy
    ZeroMemory(&ObjAttr,sizeof(LSA_OBJECT_ATTRIBUTES));
    ServerName.MaximumLength=sizeof(WCHAR)*(MAX_COMPUTERNAME_LENGTH + 1);
    GroupMembership.Count = 0;
    GroupMembership.SidAndAttributes = NULL;


    // First get the local server name 
    if( !GetComputerName(szSvrName, &dwSvrName))
    {
        dwRt = GetLastError();
        EventLogger.LogEvent(LOGTYPE_FORCE_ERROR, 
                             EVENTDSR_FILTER_NO_HOST_NAME, 
                             dwRt);
        goto EXIT;
    }

    ServerName.Buffer=szSvrName;
    ServerName.Length=(USHORT)(sizeof(WCHAR)*dwSvrName);

    // To get the Policy Handle
    if( STATUS_SUCCESS != (RtVal=LsaOpenPolicy(
                            &ServerName,
                            &ObjAttr,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &hPolicyHd
                            )) )
    {
        //Error output    RtVal
        dwRt = GetLastError();
        EventLogger.LogEvent(LOGTYPE_FORCE_ERROR, 
                             EVENTDSR_FILTER_NO_LOCAL_POLICY, 
                             dwRt);

        goto EXIT;
    }
    
       // Get the Primary Domain information
    if( STATUS_SUCCESS != (RtVal=LsaQueryInformationPolicy(
                            hPolicyHd,
                            PolicyPrimaryDomainInformation,
                            reinterpret_cast<PVOID *> (&pDomainInfo) ) ))
    {
        //Error, log return value RtVal
        EventLogger.LogEvent(LOGTYPE_FORCE_ERROR, 
                             EVENTDSR_FILTER_NO_DOMAIN_INFO, 
                             RtVal);
        goto EXIT;
    }

    if( NULL == pDomainInfo->Sid )
    {
        // If we are running in the DS Restore mode, the Domain sid will be NULL
        // No need to run in this case.
        goto EXIT;
    }

    //Build the sid for domain admin    
    if( STATUS_SUCCESS != CreateDomainAdminSid(&pDomainAdminSid, pDomainInfo->Sid) )
    {
        //Error output    RtVal
        dwRt = GetLastError();
        EventLogger.LogEvent(LOGTYPE_FORCE_ERROR, 
                             EVENTDSR_FILTER_NO_ADMIN_SID, 
                             dwRt);
        goto EXIT;
    }
                                    
    //Check if the domain admin Sid just generated is valid
    if(! IsValidSid( pDomainAdminSid ))    
    {
        dwRt = GetLastError();
        EventLogger.LogEvent(LOGTYPE_FORCE_ERROR, 
                             EVENTDSR_FILTER_NO_ADMIN_SID, 
                             dwRt);
        goto EXIT;
    }

    // Starting the loop of polling domain admin password
    while( TRUE )
    {

        //Get the server handle
        if(STATUS_SUCCESS != SamIConnect(
                                pSvrName, 
                                &hServerHandle,
                                POLICY_ALL_ACCESS,
                                TRUE) )
        {
            dwRt = GetLastError();
            EventLogger.LogEvent(LOGTYPE_FORCE_ERROR, 
                                 EVENTDSR_FILTER_CONNECT_SAM_FAIL, 
                                 dwRt);
            break;
        }


        // Get the domain handle 
        if(STATUS_SUCCESS != SamrOpenDomain(
                                hServerHandle, 
                                POLICY_ALL_ACCESS, 
                                (PRPC_SID)(pDomainInfo->Sid),
                                 //PSID and PRPC_SID are basically the same
                                &hDomainHandle) )
        {
            dwRt = GetLastError();
            EventLogger.LogEvent(LOGTYPE_FORCE_ERROR, 
                                 EVENTDSR_FILTER_CONNECT_DOMAIN_FAIL, 
                                 dwRt);
            break;
        }    

        PsudoUserName.Buffer = reinterpret_cast<PWSTR> (pDomainAdminSid);
        PsudoUserName.Length = (USHORT)GetLengthSid(pDomainAdminSid);
        PsudoUserName.MaximumLength = PsudoUserName.Length;
        
        //Get accout info for Domain Admin
        if(STATUS_SUCCESS != ( RtVal= SamIGetUserLogonInformation(
                                hDomainHandle,
                                SAM_OPEN_BY_SID,
                                &PsudoUserName,
                                &pUserBuffer,
                                &GroupMembership,
                                &UserHandle) ) )                                
        {
            dwRt = GetLastError();
            EventLogger.LogEvent(LOGTYPE_FORCE_ERROR, 
                                 EVENTDSR_FILTER_NO_DOMAIN_ADMIN_INFO, 
                                 dwRt);
            break;
        }
        
    
        // Check if the password of the Domain Admin was changed in
        // the last sleep period.
        // The first time, always set the password.
        if( pUserBuffer->All.PasswordLastSet > liPasswordLastSet )
        {
            RtlCopyMemory(
                &Password,
                pUserBuffer->All.NtOwfPassword.Buffer,
                NT_OWF_PASSWORD_LENGTH);

            if(STATUS_SUCCESS != SamiSetDSRMPasswordOWF(
                                    &ServerName,
                                    DOMAIN_USER_RID_ADMIN,
                                    &Password
                                    ) )
            {
                dwRt = GetLastError();
                EventLogger.LogEvent(LOGTYPE_FORCE_ERROR, 
                                     EVENTDSR_FILTER_SET_PAWD_FAIL, 
                                     dwRt);
                break;
            }

            liPasswordLastSet=pUserBuffer->All.PasswordLastSet;
        }

        // Clean up for next loop
        SamIFree_SAMPR_USER_INFO_BUFFER(pUserBuffer, UserAllInformation);
        RtlZeroMemory(&Password, NT_OWF_PASSWORD_LENGTH);
        SamrCloseHandle(&hServerHandle);
        SamrCloseHandle(&hDomainHandle);
        pUserBuffer = NULL;
        hServerHandle=NULL;
        hDomainHandle=NULL;

        // Sleep 30 minutes
        Sleep( dwSleepTime );
    }

EXIT:                                 
    //Clean up

    if( NULL != pUserBuffer )
    {
        SamIFree_SAMPR_USER_INFO_BUFFER(
            pUserBuffer, UserAllInformation);
    }
    if( NULL != hServerHandle )
    {
        SamrCloseHandle(&hServerHandle);
    }
    if( NULL != hDomainHandle )
    {
        SamrCloseHandle(&hDomainHandle);
    }

    if( NULL != pDomainAdminSid )
    {
         RtlFreeHeap( RtlProcessHeap(), 0, (PVOID)pDomainAdminSid);
    }
    if( NULL != pDomainInfo )
    {
         LsaFreeMemory(pDomainInfo);            
    }
    if( NULL != hPolicyHd )
    {
         LsaClose(hPolicyHd);
    }    

    return dwRt;
}


HRESULT NTAPI RegisterFilter( void )
{
    DWORD   dwType = 0;
    DWORD   dwcbSize = 0;
    HKEY    hLSAKey = NULL;
    HKEY    hEventLogKey = NULL;
    HKEY    hDSEvtKey = NULL;
    BOOL    bSuccess = FALSE;
    BOOL    bRegistered = FALSE;
    
    LONG    lRetVal = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                                 g_wszLSAKey, 
                                 0, 
                                 KEY_ALL_ACCESS, 
                                 &hLSAKey );
    if (ERROR_SUCCESS == lRetVal)
    {
        ULONG ulStrLen = wcslen( g_wszName );
        lRetVal = RegQueryValueEx( hLSAKey, 
                                   g_wszNotPac, 
                                   NULL, 
                                   &dwType, 
                                   NULL, 
                                   &dwcbSize );
        if (ERROR_SUCCESS == lRetVal) // Key exists, must add my value to the end
        {
            WCHAR   *pwsz     = NULL;
            DWORD   dwBufSize = dwcbSize + (ulStrLen+1)*sizeof(WCHAR);
            BYTE    *pbyVal   = new BYTE[dwBufSize];
            if (NULL != pbyVal)
            {
                lRetVal = RegQueryValueEx( hLSAKey, 
                                           g_wszNotPac, 
                                           NULL, 
                                           &dwType, 
                                           pbyVal, 
                                           &dwcbSize );
                if (ERROR_SUCCESS == lRetVal)
                {
                    //First, check if we have already registered
                    pwsz = (WCHAR *)pbyVal;
                    while( *pwsz != 0 )
                    {
                        if (0 == wcscmp( pwsz, g_wszName ))
                        {
                           //It is already registered
                           bRegistered = TRUE;
                           bSuccess = TRUE;
                           break;                            
                        }    
                        pwsz += (wcslen( pwsz ) + 1);
                    }

                    if(! bRegistered)
                    {
                        // Got the value, now I need to add myself to the end
                        pwsz = (WCHAR *)&(pbyVal[dwcbSize - 2]);
                        wcscpy( pwsz, g_wszName );
                        // Make sure we're termintate by 2 UNICODE NULLs (REG_MULTI_SZ)
                        pwsz += ulStrLen + 1; 
                        *pwsz = 0;
                        lRetVal = RegSetValueEx( hLSAKey, 
                                                 g_wszNotPac, 
                                                 0, 
                                                 (DWORD)REG_MULTI_SZ, 
                                                 pbyVal, 
                                                 dwBufSize );
                        if (ERROR_SUCCESS == lRetVal)
                            bSuccess = TRUE;
                    }
                }
                delete[] pbyVal;
            }
        }
        else // Key doesn't exist.  Have to create it
        {
            DWORD dwBufSize=(ulStrLen+2)*sizeof(WCHAR);
            BYTE  *rgbyVal= new BYTE[dwBufSize];
            if( NULL != rgbyVal )
            {
                WCHAR *pwsz = (WCHAR *)rgbyVal;
                wcscpy( pwsz, g_wszName );
                
                // Make sure we're terminated by two UNICODE NULLs (REG_MULTI_SZ)
                pwsz += ulStrLen + 1; 
                *pwsz = 0;

                lRetVal = RegSetValueEx( hLSAKey, 
                                         g_wszNotPac, 
                                         0, 
                                         (DWORD)REG_MULTI_SZ, 
                                         rgbyVal, 
                                         dwBufSize ); 
                if (ERROR_SUCCESS == lRetVal)
                    bSuccess = TRUE;
                delete[] rgbyVal;
            }
        }
        
        RegCloseKey( hLSAKey );
    }
    
    if( bSuccess )
    {
       
        lRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                               g_wszEventLog, 
                               0,     
                               KEY_ALL_ACCESS,  
                               &hEventLogKey);
        if ( ERROR_SUCCESS == lRetVal )
        {
            //Create the Reg Key for eventlogging
            lRetVal = RegCreateKeyEx(hEventLogKey, 
                               g_wszName, 
                               0,
                               NULL,
                               0,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hDSEvtKey,
                               NULL);
           if ( ERROR_SUCCESS == lRetVal )
           {
               lRetVal = RegSetValueEx(hDSEvtKey, 
                               g_wszEventFileName,
                               0,
                               REG_SZ,
                               reinterpret_cast<CONST BYTE*>(g_wszEventFilePath),
                               sizeof(WCHAR)*wcslen(g_wszEventFilePath));
                if (ERROR_SUCCESS == lRetVal )
                {
                    lRetVal = RegSetValueEx(hDSEvtKey,
                               g_wszTypesSupported,
                               0,
                               REG_DWORD,
                               reinterpret_cast<CONST BYTE*>(&g_dwTypesSupported),
                               sizeof(DWORD));
               }
               RegCloseKey(hDSEvtKey);
           }

            if (ERROR_SUCCESS != lRetVal)
            {
               bSuccess = FALSE;
            }
        }
        RegCloseKey(hEventLogKey);
    }


    return bSuccess ? (bRegistered ? S_FALSE : S_OK ) : E_FAIL;
}


HRESULT NTAPI UnRegisterFilter( void )
{
    DWORD   dwType = 0;
    DWORD   dwcbSize = 0;
    HKEY    hLSAKey = NULL;
    HKEY    hEventLogKey =NULL;
    BOOL    bSuccess = FALSE;
    
    LONG lRetVal = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                                 g_wszLSAKey, 
                                 0, 
                                 KEY_ALL_ACCESS, 
                                 &hLSAKey );
    if (ERROR_SUCCESS == lRetVal)
    {
        lRetVal = RegQueryValueEx( hLSAKey, 
                                 g_wszNotPac, 
                                 NULL, 
                                 &dwType, 
                                 NULL, 
                                 &dwcbSize );
        // Key exists, must delete my value from the end
        if (ERROR_SUCCESS == lRetVal) 
        {
            ULONG ulStrLen = wcslen( g_wszName );
            BYTE *pbyVal = new BYTE[dwcbSize];
            if (pbyVal)
            {
                lRetVal = RegQueryValueEx( hLSAKey, 
                                 g_wszNotPac, 
                                 NULL, 
                                 &dwType, 
                                 pbyVal, 
                                 &dwcbSize );

                if (ERROR_SUCCESS == lRetVal)
                {
                    // Got the old key, 
                    // now step through and remove my part of the key
                    WCHAR *pwsz = (WCHAR *)pbyVal;
                    WCHAR *wszNewRegVal = new WCHAR[dwcbSize];
                    WCHAR *pwszNewVal = wszNewRegVal;
                    DWORD dwLen = 0;
                    
                    if (wszNewRegVal)
                    {
                        *pwszNewVal = 0;
                        while( *pwsz != 0 )
                        {
                            if (wcscmp( pwsz, g_wszName ))
                            {
                                wcscpy( pwszNewVal, pwsz );
                                dwLen += wcslen( pwsz ) + 1;
                                pwszNewVal += (wcslen( pwsz ) + 1);
                            }
                            pwsz += (wcslen( pwsz ) + 1);
                        }
                        
                        // if we got here and there's nothing in the buffer, 
                        // we were the only one installed,
                        // now we must delete the key, else set it to the old value
                        wszNewRegVal[dwLen] = 0; // add the last NULL
                        dwLen++; // account for that last NULL
                        lRetVal = RegSetValueEx(hLSAKey, 
                                           g_wszNotPac, 
                                           0, 
                                           (DWORD)REG_MULTI_SZ, 
                                           reinterpret_cast<CONST BYTE*>(wszNewRegVal),  
                                           dwLen*sizeof(WCHAR));
                        if (ERROR_SUCCESS == lRetVal)
                            bSuccess = TRUE;
                        delete[] wszNewRegVal;
                    }
                }
                delete[] pbyVal;                
            }
            // NTRAID#NTBUG9-655545-2002/07/05-artm
            RegCloseKey( hLSAKey );
        }
    }
    
    if( bSuccess )
    {
        //Delete the Reg Key for eventlogging
        lRetVal=RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                             g_wszEventLog, 
                             0,     
                             KEY_ALL_ACCESS,  
                             &hEventLogKey);
        if (ERROR_SUCCESS == lRetVal)
        {
            RegDeleteKey(hEventLogKey, g_wszName );
            if( ERROR_SUCCESS != lRetVal && 
                ERROR_FILE_NOT_FOUND != lRetVal )
                // If the key does not exist, ERROR_FILE_NOT_FOUND wii be returened
            {
                bSuccess = FALSE;
            }
            RegCloseKey( hEventLogKey );
        }    
        else
        {
            bSuccess = FALSE;
        }
    }

    return bSuccess ? S_OK : E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\dsrestore\passfilt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__122FFAC7_F1D2_429A_9F62_8DDE9547E3DA__INCLUDED_)
#define AFX_STDAFX_H__122FFAC7_F1D2_429A_9F62_8DDE9547E3DA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__122FFAC7_F1D2_429A_9F62_8DDE9547E3DA__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\dsrestore\passfilt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <..\..\..\public\sdk\inc\atl30\statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\inc\cys.h ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      CYS.h
//
// Synopsis:  Declares the common data structures
//            and types for the CYS.exe and CYSlib.lib
//
// History:   01/21/2002  JeffJon Created

#ifndef __CYS_H
#define __CYS_H

// NOTE: you must have $(ENDUSER_INC_PATH) in your INCLUDES list
//       to get this file
#include "sainstallcom.h"

// Get the staticly defined initialization guard to manage resources
#include "init.h"

// This enum defines the installation unit types.  It is used as the key to
// the map in the InstallationUnitProvider to get the InstallationUnit
// associated with the type. Not all of these roles are exposed to the user
// through MYS/CYS.  Some, like the indexing service, are used by other roles
// to provide a means of installing the service.  Do not enumerate through
// this list to discover the exposed roles.  Use the serverRoleStatusTable
// instead.

enum ServerRole
{
   DNS_SERVER,
   DHCP_SERVER,
   WINS_SERVER,
   RRAS_SERVER,
   TERMINALSERVER_SERVER,
   FILESERVER_SERVER,
   PRINTSERVER_SERVER,
   MEDIASERVER_SERVER,
   WEBAPP_SERVER,
   EXPRESS_SERVER,
   DC_SERVER,
   POP3_SERVER,
   INDEXING_SERVICE,
   NO_SERVER
};

// These are the values that can be returned from
// InstallationUnit::GetStatus()

enum InstallationStatus
{
   STATUS_NONE,
   STATUS_CONFIGURED,
   STATUS_COMPLETED,
   STATUS_NOT_AVAILABLE
};

// String representations of the status codes
// above. These are used for logging purposes

const String statusStrings[] = 
{ 
   String(L"STATUS_NONE"), 
   String(L"STATUS_CONFIGURED"), 
   String(L"STATUS_COMPLETED"),
   String(L"STATUS_NOT_AVAILABLE")
};

// Macro to help with logging of status results

#define LOG_ROLE_STATUS(status) LOG(statusStrings[status]);

// Helper to get the status if all you have is the installation type

InstallationStatus
GetInstallationStatusForServerRole(
   ServerRole role);

// Functions to determine the server role status

InstallationStatus GetDNSStatus();
InstallationStatus GetDHCPStats();
InstallationStatus GetWINSStatus();
InstallationStatus GetRRASStatus();
InstallationStatus GetTerminalServerStatus();
InstallationStatus GetFileServerStatus();
InstallationStatus GetPrintServerStatus();
InstallationStatus GetMediaServerStatus();
InstallationStatus GetWebServerStatus();
InstallationStatus GetDCStatus();
// NTRAID#NTBUG9-698722-2002/09/03-artm
InstallationStatus GetDCStatusForMYS();
InstallationStatus GetPOP3Status(); 

// Declares a function pointer type to use in the 
typedef InstallationStatus (*CYSRoleStatusFunction)();

struct ServerRoleStatus
{
   ServerRole            role;  
   CYSRoleStatusFunction Status;
};


// table of items that are available in the server type list box
extern ServerRoleStatus serverRoleStatusTable[];

// returns the number of items in the serverTypeTable
size_t
GetServerRoleStatusTableElementCount();

// Determines if a particular Server Appliance Kit component
// is installed.  SA_TYPE is defined in sainstallcom.h

bool
IsSAKUnitInstalled(SA_TYPE unitType);

// Determines if the current server is a cluster server

bool
IsClusterServer();

// Returns the URL of the SAK webpages

String
GetSAKURL();

// Returns true if CYS/MYS is supported on this SKU

bool
IsSupportedSku();

// Checks all the regkeys associated with MYS/CYS to see if MYS should
// be run

bool
IsStartupFlagSet();

// Checks the policy registry keys to see if MYS should be run

bool
ShouldShowMYSAccordingToPolicy();
#endif __CYS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\inc\init.h ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      init.h
//
// Synopsis:  Declares an initialization guard
//            to ensure that all resources are freed
//
// History:   03/26/2002  JeffJon Created

#ifndef __CYSINIT_H
#define __CYSINIT_H

// For an explanation of the initialization guard thing, see Meyers,
// Scott. "Effective C++ pp. 178-182  Addison-Wesley 1992.  Basically, it
// guarantees that this library is properly initialized before any code
// that uses it is called.

class CYSInitializationGuard
{
   public:

   CYSInitializationGuard();
   ~CYSInitializationGuard();

   private:

   static unsigned counter;

   // not defined

   CYSInitializationGuard(const CYSInitializationGuard&);
   const CYSInitializationGuard& operator=(const CYSInitializationGuard&);
};

static CYSInitializationGuard cysguard;


#endif // __CYSINIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\inc\common.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      common.h
//
// Synopsis:  Defines some commonly used functions
//            This is really just a dumping ground for functions
//            that don't really belong to a specific class in
//            this design.  They may be implemented in other
//            files besides common.cpp.
//
// History:   02/03/2001  JeffJon Created

#define DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY       64
#define DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8  155
#define MAX_NETBIOS_NAME_LENGTH                       DNLEN


// Service names used for both the OCManager and launching wizards

// DHCP
#define CYS_DHCP_SERVICE_NAME          L"DHCPServer"

// DNS
#define CYS_DNS_SERVICE_NAME           L"DNS"

// Printer
#define CYS_PRINTER_WIZARD_NAME        L"AddPrinter"
#define CYS_PRINTER_DRIVER_WIZARD_NAME L"AddPrinterDriver"

// RRAS
#define CYS_RRAS_SERVICE_NAME          L"RRAS"
#define CYS_RRAS_UNINSTALL             L"RRASUninstall"

// IIS
#define CYS_WEB_SERVICE_NAME           L"w3svc"
#define CYS_IIS_COMMON_COMPONENT       L"iis_common"
#define CYS_INETMGR_COMPONENT          L"iis_inetmgr"

// WINS
#define CYS_WINS_SERVICE_NAME          L"WINS"

// Other needed constants

// Switch provided by explorer.exe when launching CYS
#define EXPLORER_SWITCH                L"explorer"

// Special share names that don't have the "special" flag set
#define CYS_SPECIAL_SHARE_SYSVOL       L"SYSVOL"
#define CYS_SPECIAL_SHARE_NETLOGON     L"NETLOGON"
#define CYS_SPECIAL_SHARE_PRINT        L"PRINT$"

extern Popup popup;

// Typedefs for common STL containers

typedef 
   std::vector<DWORD, Burnslib::Heap::Allocator<DWORD> > 
   IPAddressList;


bool
IsServiceInstalledHelper(const wchar_t* serviceName);

bool
InstallServiceWithOcManager(
   const String& infText,
   const String& unattendText,
   const String& additionalArgs = String());

DWORD
MyWaitForSendMessageThread(HANDLE hThread, DWORD dwTimeout);

HRESULT
CreateTempFile(const String& name, const String& contents);

HRESULT
CreateAndWaitForProcess(
   const String& fullPath,
   String& commandline, 
   DWORD& exitCode,
   bool minimize = false);

HRESULT
MyCreateProcess(
   const String& fullPath,
   String& commandline);

bool
IsKeyValuePresent(RegistryKey& key, const String& value);

bool
GetRegKeyValue(
   const String& key, 
   const String& value, 
   String& resultString,
   HKEY parentKey = HKEY_LOCAL_MACHINE);

bool
GetRegKeyValue(
   const String& key, 
   const String& value, 
   DWORD& resultValue,
   HKEY parentKey = HKEY_LOCAL_MACHINE);

bool
SetRegKeyValue(
   const String& key, 
   const String& value, 
   const String& newString,
   HKEY parentKey = HKEY_LOCAL_MACHINE,
   bool create = false);

bool
SetRegKeyValue(
   const String& key, 
   const String& value, 
   DWORD newValue,
   HKEY parentKey = HKEY_LOCAL_MACHINE,
   bool create = false);

bool 
ExecuteWizard(
   HWND     parent,     
   PCWSTR   serviceName,
   String&  resultText, 
   HRESULT& hr);        


// This really comes from Burnslib but it is not provided in a header
// so I am putting the declaration here and we will link to the 
// Burnslib definition

HANDLE
AppendLogFile(const String& logBaseName, String& logName);


// Macros to help with the log file operations

#define CYS_APPEND_LOG(text) \
   if (logfileHandle)        \
      FS::Write(logfileHandle, text);



bool 
IsDhcpConfigured();

extern "C"
{
   DWORD
   AnyDHCPServerRunning(
      ULONG uClientIp,
      ULONG * pServerIp
    );
}


// Converts a VARIANT of type VT_ARRAY | VT_BSTR to a list of Strings

HRESULT
VariantArrayToStringVector(VARIANT* variant, StringVector& stringList);


// Will convert a DWORD IP Address into a string

String
IPAddressToString(DWORD ipAddress);

// Will convert a string in the form of an IP address to 
// a DWORD. A return value of INADDR_NONE means that we failed
// to do the conversion

DWORD
StringToIPAddress(const String& stringIPAddress);

// Converts a DWORD IP address from Intel processor byte order to 
// inorder.  For example, an address of 1.2.3.4 would come from inet_addr as
// 04030201 but the UI control returns it as 01020304.  This function allows
// for conversion between the two

DWORD
ConvertIPAddressOrder(DWORD address);

// This function allocates an array of DWORDs and fills it with the IP addresses
// from the StringList.  The caller must free the returned pointer using
// delete[]
DWORD*
StringIPListToDWORDArray(const StringList& stringIPList, DWORD& count);

// Helper function for creating the INF file for unattended OCM installations

void
CreateInfFileText(
   String& infFileText, 
   unsigned int windowTitleResourceID);

// Helper function for creating the unattend file for unattended OCM installations

void
CreateUnattendFileText(
   String& unattendFileText, 
   PCWSTR  serviceName,
   bool    install = true);

// Opens the favorites folder and creates a favorite for
// the specified URL

HRESULT
AddURLToFavorites(
   HWND hwnd,
   const String& url,
   const String& fileName);

// Launches the specified MMC console
// It assumes the console is in the %windir%\system32 directory
// unless the alternatePath is specified

void
LaunchMMCConsole(
   const String& consoleFile,
   String& alternatePath = String());

// Launches the Manage Your Server HTA

void
LaunchMYS();

// Retrieves the path to the start menu for All Users

HRESULT
GetAllUsersStartMenu(
   String& startMenuPath);

// Retrieves the path to the Administrative Tools menu for All Users

HRESULT
GetAllUsersAdminTools(
   String& adminToolsPath);

// Creates a link (shortcut) at the specified location 
// with the specified target

HRESULT
CreateShortcut(
   const String& shortcutPath,
   const String& target,
   const String& description);

// Takes a LPARAM from a WM_NOTIFY message from a SysLink control
// and decodes it to return the link index

int
LinkIndexFromNotifyLPARAM(LPARAM lParam);


// Starts the hh.exe process with the given parameter

void
ShowHelp(const String& helpTopic);

// Opens the Configure Your Server logfile

void
OpenLogFile();

// Returns true if the log file is present

bool
IsLogFilePresent();

// Gets the path the "All Users" Administrative Tools
// link in the Start Menu

HRESULT
GetAdminToolsShortcutPath(
   String& adminToolsShortcutPath,
   const String& linkToAppend);

// Adds the given shortcut with description to the Administrative Tools 
// Start Menu with the given link

HRESULT
AddShortcutToAdminTools(
   const String& target,
   unsigned int descriptionID,
   unsigned int linkID);

// Determines if a share should be considered special
// "special" shares are those like C$, SYSVOL$, etc.

bool
IsSpecialShare(const SHARE_INFO_1& shareInfo);

// Determines if there are any shared folders that are not "special"
// "special" shares are those like C$, SYSVOL$, etc.

bool
IsNonSpecialSharePresent();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\inc\networkadapterconfig.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      NetworkAdapterConfig.h
//
// Synopsis:  Declares a NetworkAdapterConfig
//            This object has the knowledge for installing 
//            using WMI to retrieve network adapter information
//
// History:   02/16/2001  JeffJon Created

#ifndef __CYS_NETWORKADAPTERCONFIG_H
#define __CYS_NETWORKADAPTERCONFIG_H

#include "NetworkInterface.h"

class NetworkAdapterConfig
{
   public:
      
      // Constructor

      NetworkAdapterConfig();

      // Destructor

      ~NetworkAdapterConfig();

      // Initializer
      
      HRESULT
      Initialize();

      // Pulic methods

      unsigned int
      GetNICCount() const;

      NetworkInterface*
      GetNIC(unsigned int nicIndex);

      NetworkInterface*
      GetNICFromName(
         const String& name,
         bool& found);

      bool
      IsInitialized() const { return initialized; }

      void
      SetLocalNIC(
         const NetworkInterface& nic,
         bool setInRegistry = false);

      void
      SetLocalNIC(
         String guid,
         bool setInRegistry = false);

      NetworkInterface*
      GetLocalNIC();

      unsigned int
      FindNIC(const String& guid, bool& found) const;

   protected:

      void
      AddInterface(NetworkInterface* newInterface);

   private:

      void
      SetLocalNICInRegistry(const NetworkInterface& nic);

      bool  initialized;
      unsigned int nicCount;
      int localNICIndex;

      typedef 
         std::vector<
            NetworkInterface*, 
            Burnslib::Heap::Allocator<NetworkInterface*> > 
            NetworkInterfaceContainer;
      NetworkInterfaceContainer networkInterfaceContainer;
};


#endif // __CYS_NETWORKADAPTERCONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\inc\regkeys.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      regkeys.h
//
// Synopsis:  Declares all the registry keys used throughout CYS
//
// History:   02/13/2001  JeffJon Created


#ifndef __CYS_REGKEYS_H
#define __CYS_REGKEYS_H

// Networking

#define CYS_NETWORK_INTERFACES_KEY  L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\"
#define CYS_NETWORK_NAME_SERVERS    L"NameServer"
#define CYS_NETWORK_DHCP_NAME_SERVERS L"DhcpNameServer"

// Terminal Server

#define CYS_APPLICATION_MODE_REGKEY L"SYSTEM\\CurrentControlSet\\Control\\Terminal Server"
#define CYS_APPLICATION_MODE_VALUE  L"TSAppCompat"
#define CYS_APPLICATION_MODE_ON     1

// DHCP

#define CYS_DHCP_DOMAIN_IP_REGKEY   L"Software\\Microsoft\\Windows NT\\CurrentVersion\\srvWiz"
#define CYS_DHCP_DOMAIN_IP_VALUE    L"DomainDNSIP"
#define CYS_DHCP_WIZARD_RESULT      L"DHCPWizResult"

// DNS

#define DNS_WIZARD_RESULT_REGKEY    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\srvWiz"
#define DNS_WIZARD_RESULT_VALUE     L"DnsWizResult"
#define DNS_WIZARD_CONFIG_REGKEY    L"System\\CurrentControlSet\\Services\\DNS\\Parameters"
#define DNS_WIZARD_CONFIG_VALUE     L"AdminConfigured"

// Media Services

#define REGKEY_WINDOWS_MEDIA              L"SOFTWARE\\Microsoft\\Windows Media\\Server"                                
#define REGKEY_WINDOWS_MEDIA_SERVERDIR   L"InstallDir"

// RRAS

#define CYS_RRAS_CONFIGURED_REGKEY        L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess"
#define CYS_RRAS_CONFIGURED_VALUE         L"ConfigurationFlags"

// POP3

#define CYS_POP3_REGKEY                   L"SOFTWARE\\Microsoft\\POP3 service"
#define CYS_POP3_VERSION                  L"Version"
#define CYS_POP3_CONSOLE                  L"ConsoleFile"

// Web Application Server

#define CYS_WEBAPP_OCM_COMPONENTS         L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents"
#define CYS_WEBAPP_FPSE_COMPONENT         L"fp_extensions"
#define CYS_WEBAPP_ASPNET_COMPONENT       L"aspnet"
#define CYS_WEBAPP_DTC_COMPONENT          L"dtcnetwork"
#define CYS_IIS_NNTP_COMPONENT            L"iis_nntp"
#define CYS_IIS_FTP_COMPONENT             L"iis_ftp"
#define CYS_IIS_SMTP_COMPONENT            L"iis_smtp"

// Express Setup

#define CYS_FIRST_DC_REGKEY               L"Software\\Microsoft\\Windows NT\\CurrentVersion\\srvWiz"
#define CYS_FIRST_DC_VALUE                L"FirstDC"
#define CYS_FIRST_DC_VALUE_SET            1
#define CYS_FIRST_DC_VALUE_UNSET          0
#define CYS_FIRST_DC_FORWARDER            L"Forwarder"
#define CYS_FIRST_DC_AUTOFORWARDER        L"AutoForwarder"
#define CYS_FIRST_DC_DHCP_SERVERED        L"DHCPInstalled"
#define CYS_DHCP_SERVERED_VALUE           1 
#define CYS_DHCP_NOT_SERVERED_VALUE       0
#define CYS_FIRST_DC_SCOPE_START          L"DHCPStart"
#define CYS_FIRST_DC_SCOPE_END            L"DHCPEnd"
#define CYS_FIRST_DC_LOCAL_NIC            L"LocalNIC"
#define CYS_FIRST_DC_STATIC_IP            L"StaticIP"

#define CYS_ORGNAME_REGKEY                L"Software\\Microsoft\\Windows NT\\CurrentVersion"
#define CYS_ORGNAME_VALUE                 L"RegisteredOrganization"

// CYS general

#define CYS_HOME_REGKEY                         L"Software\\Microsoft\\Windows NT\\CurrentVersion\\srvWiz"
#define CYS_HOME_VALUE                          L"home"
#define CYS_HOME_REGKEY_TERMINAL_SERVER_VALUE   L"terminalServer"
#define CYS_HOME_REGKEY_UNINSTALL_TERMINAL_SERVER_VALUE L"terminalServerUninstall"
#define CYS_HOME_REGKEY_DCPROMO_VALUE           L"DCPROMO"
#define CYS_HOME_REGKEY_DCDEMOTE_VALUE          L"DCDEMOTE"
#define CYS_HOME_REGKEY_FIRST_SERVER_VALUE      L"FirstServer"
#define CYS_HOME_REGKEY_DEFAULT_VALUE           L"home"
#define CYS_HOME_REGKEY_MUST_RUN                L"CYSMustRun"
#define CYS_HOME_RUN_KEY_DONT_RUN               0
#define CYS_HOME_RUN_KEY_RUN_AGAIN              1
#define CYS_HOME_REGKEY_DOMAINDNS               L"DomainDNSName"
#define CYS_HOME_REGKEY_DOMAINIP                L"DomainDNSIP"

// MYS regkeys

#define MYS_REGKEY_POLICY                       L"Software\\Policies\\Microsoft\\Windows NT\\CurrentVersion\\MYS"
#define MYS_REGKEY_POLICY_DISABLE_SHOW          L"DisableShowAtLogon"

#define SZ_REGKEY_SRVWIZ_ROOT                   L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\srvWiz"
#define REGTIPS                                 REGSTR_PATH_EXPLORER L"\\Tips"
#define REGTIPS_SHOW_VALUE                      L"Show"
#define SZ_REGKEY_W2K                           L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\Welcome"
#define SZ_REGVAL_W2K                           L"srvwiz"

// This isn't a regkey but this was a good place to put it

#define CYS_LOGFILE_NAME   L"Configure Your Server"

#endif // __CYS_REGKEYS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\inc\networkinterface.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      NetworkInterface.h
//
// Synopsis:  Declares a NetworkInterface
//            This object has the knowledge of an
//            IP enabled network connection including 
//            IP address, DHCP information, etc.
//
// History:   03/01/2001  JeffJon Created

#ifndef __CYS_NETWORKINTERFACE_H
#define __CYS_NETWORKINTERFACE_H


#define CYS_DEFAULT_IPADDRESS          static_cast<DWORD>(MAKEIPADDRESS(192,168,0,1))
#define CYS_DEFAULT_IPADDRESS_STRING   L"192.168.0.1"
#define CYS_DEFAULT_SUBNETMASK         static_cast<DWORD>(MAKEIPADDRESS(255,255,255,0))
#define CYS_DEFAULT_SUBNETMASK_STRING  L"255.255.255.0"



class NetworkInterface
{
   public:

      // Constructor

      NetworkInterface();

      // Desctructor

      ~NetworkInterface();

      // Initializer

      HRESULT
      Initialize(const IP_ADAPTER_INFO& adapterInfo);


      // Pulic accessor methods

      DWORD
      GetIPAddress(DWORD addressIndex) const;

      DWORD
      GetIPAddressCount() const { return static_cast<DWORD>(ipaddresses.size()); }
      
      DWORD
      GetSubnetMask(DWORD addressIndex) const;

      bool
      IsDHCPEnabled() const { return dhcpEnabled; }

      bool
      DoesAtLeastOneNicFailDHCPLease();

      String
      GetName() const;

      // Converts the name member into a GUID.

      HRESULT
      GetNameAsGUID(GUID& guid) const;

      String
      GetFriendlyName(
         const String defaultName) const;

      String
      GetDescription() const;

      UINT
      GetType() const;

      DWORD
      GetIndex() const;

      String
      GetStringIPAddress(DWORD addressIndex) const;

      String
      GetStringSubnetMask(DWORD addressIndex) const;

      void
      SetIPAddress(DWORD address, String addressString);

      void
      SetSubnetMask(DWORD mask, String maskString);

      String
      GetDNSServerString(DWORD index);

      void
      GetDNSServers(IPAddressList& servers);

      bool
      IsDHCPAvailable() const;

      bool
      CanDetectDHCPServer();

      bool
      IsConnected() const;

      bool
      IsModem() const;

      // Uses IsIPAddressInUse to see if the IP address is in use
      // on the network. If it is, the IP address is incremented and tried 
      // again.  The returned IP address is the next available IP address on 
      // the network or the startAddress if all are detected.

      DWORD
      GetNextAvailableIPAddress(
         DWORD startAddress, 
         DWORD subnetMask);

      // Uses SendARP to see if the available IP is in use on the network using
      // the IP address of the interface as the src. 

      bool
      IsIPAddressInUse(
         DWORD ipaddress,
         DWORD subnetMask);

   private:

      // Adds a route to the TCP/IP table so that we can send packets for
      // the specified IP address to the interface reguardless of whether
      // or not the IP address is on the same subnet as the interface's IP

      void
      SetRoute(
         DWORD ipaddress,
         DWORD subnetMask);

      // Removes a route in the TCP/IP table that was set with SetRoute

      void
      RemoveRoute(
         DWORD ipaddress,
         DWORD subnetMask);

	  HRESULT
      RetrieveAdapterInfoFromRegistry();

      HRESULT
      SetIPList(const IP_ADDR_STRING& ipList);

      bool
      IsStandardAdapterConnected(const GUID& guid) const;

      bool           initialized;

      String         name;
      String         description;
      UINT           type;
      DWORD          index;
      bool           dhcpEnabled;
      bool           dhcpServerAvailable;

      StringVector ipaddressStringList;
      StringVector subnetMaskStringList;
      StringVector dnsServerSearchOrder;

      IPAddressList ipaddresses;
      IPAddressList subnetMasks;

      // Copy constructor and assignment operator not allowed

      NetworkInterface(const NetworkInterface& nic);
      NetworkInterface& operator=(const NetworkInterface& rhs);
};

#endif // __CYS_NETWORKINTERFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\lib\init.cpp ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      init.cpp
//
// Synopsis:  Defines an initialization guard
//            to ensure that all resources are freed
//
// History:   03/26/2002  JeffJon Created

#include "pch.h"

#include "init.h"
#include "state.h"

unsigned CYSInitializationGuard::counter = 0;

CYSInitializationGuard::CYSInitializationGuard()
{
   counter++;
}

CYSInitializationGuard::~CYSInitializationGuard()
{
   if (--counter == 0)
   {
      // cleanup the State

      State::Destroy();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\inc\state.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      state.h
//
// Synopsis:  Declares the state object that is global
//            to CYS.  It holds the network and OS/SKU info
//
// History:   02/02/2001  JeffJon Created

#ifndef __CYS_STATE_H
#define __CYS_STATE_H

#include "NetworkAdapterConfig.h"

#define CYS_DATACENTER_SERVER     0x00000001
#define CYS_ADVANCED_SERVER       0x00000002
#define CYS_SERVER                0x00000004
#define CYS_UNSUPPORTED_SKU       0x00000008
#define CYS_64BIT                 0x80000000
#define CYS_32BIT                 0x40000000

#define CYS_ALL_SERVER_SKUS       (CYS_DATACENTER_SERVER |  \
                                   CYS_ADVANCED_SERVER   |  \
                                   CYS_SERVER            |  \
                                   CYS_64BIT             |  \
                                   CYS_32BIT)

#define CYS_ALL_SKUS_NO_64BIT     (CYS_DATACENTER_SERVER |  \
                                   CYS_ADVANCED_SERVER   |  \
                                   CYS_SERVER            |  \
                                   CYS_32BIT)

class State
{
   public:

      // Called from WinMain to delete the global instance of the state object

      static
      void
      Destroy();

      // Retrieves a reference to the global instance of the state object

      static
      State&
      GetInstance();

      // Does the work to determine the state of the machine

      bool
      RetrieveMachineConfigurationInformation(
         HWND progressLabel,
         bool doDHCPCheck,
         int  nicInfoResID,
         int  osInfoResID,
         int  defaultConnectionNameResID,
         int  detectSettingsResID);


      // Data accessors

      unsigned int 
      GetNICCount() const;

      unsigned int
      GetNonModemNICCount();

      NetworkInterface*
      GetNIC(unsigned int nicIndex);

      NetworkInterface*
      GetNICFromName(
         const String& name,
         bool& found);

      bool
      IsRemoteSession() const;

      bool
      IsWindowsSetupRunning() const;

      bool
      IsDC() const;

      bool
      IsDCPromoRunning() const;

      bool
      IsDCPromoPendingReboot() const;

      bool
      IsJoinedToDomain() const;

      bool
      IsUpgradeState() const;

      bool
      IsFirstDC() const;

      bool
      IsDHCPServerAvailableOnAllNics() const { return dhcpServerAvailableOnAllNics; }

      bool 
      HasStateBeenRetrieved() const { return hasStateBeenRetrieved; }

      bool 
      RerunWizard() const { return rerunWizard; }

/*
      void 
      SetRerunWizard(bool rerun);
*/
      void
      SetStartPage(UINT startPage) { wizardStartPage = startPage; }

      UINT
      GetStartPage() const { return wizardStartPage; }

      DWORD 
      GetProductSKU() const { return productSKU; }

      DWORD
      GetPlatform() const { return platform; }

      bool
      Is64Bit() const { return (platform & CYS_64BIT) != 0; }

      bool
      Is32Bit() const { return (platform & CYS_32BIT) != 0; }

      bool 
      HasNTFSDrive() const;


      bool 
      SetHomeRegkey(const String& newKeyValue);

      bool
      GetHomeRegkey(String& newKeyValue) const;

      String
      GetComputerName();

      String
      GetDomainDNSName();

      String
      GetDomainNetbiosName();

      bool
      HasDNSServerOnAnyNicToForwardTo();

      void
      SetLocalNIC(
         String guid,
         bool setInRegistry = false);

      NetworkInterface*
      GetLocalNIC();

      NetworkInterface*
      GetLocalNICFromRegistry();

      DWORD
      GetNextAvailableIPAddress(
         DWORD startAddress,
         DWORD subnetMask);

      DWORD
      RetrieveProductSKU();

      bool
      IsRebootScenario() const;

      void
      SetRebootScenario(bool reboot);

      bool
      ShouldRunMYS() const;

   private:

      // Determines if there is a DHCP server on the network

      void
      CheckDhcpServer(
         HWND progressStatic,
         int  defaultConnectionNameResID,
         int  detectSettingsResID);

      HRESULT
      RetrieveNICInformation();

      void
      RetrievePlatform();

      void
      RetrieveDriveInformation();

      bool     hasStateBeenRetrieved;
      bool     dhcpAvailabilityRetrieved;

      UINT     wizardStartPage;

      bool     dhcpServerAvailableOnAllNics;
      bool     rerunWizard;
      bool     isRebootScenario;
      bool     hasNTFSDrive;
      DWORD    productSKU;
      DWORD    platform;

      Computer localComputer;
      String   computerName;
      String   domainDNSName;
      String   domainNetbiosName;

      NetworkAdapterConfig adapterConfiguration;

      // Constructor

      State();

      // not defined: no copying allowed
      State(const State&);
      const State& operator=(const State&);
      
};
#endif // __CYS_STATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\lib\common.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      common.cpp
//
// Synopsis:  Commonly used functions
//
// History:   02/03/2001  JeffJon Created

#include "pch.h"


bool
IsServiceInstalledHelper(const wchar_t* serviceName)
{
   LOG_FUNCTION2(IsServiceInstalledHelper, serviceName);
   ASSERT(serviceName);

   // if we can open the service, then it is installed

   bool result = false;

   SC_HANDLE hsc =
      ::OpenSCManager(0, SERVICES_ACTIVE_DATABASE, GENERIC_READ);

   if (hsc)
   {
      SC_HANDLE hs = ::OpenServiceW(hsc, serviceName, GENERIC_READ);

      if (hs)
      {
         ::CloseServiceHandle(hs);
         result = true;
      }

      ::CloseServiceHandle(hsc);
   }

   LOG_BOOL(result);

   return result;
}


// Wait for a handle to become signalled, or a timeout to expire, or WM_QUIT
// to appear in the message queue.  Pump the message queue while we wait.
// 
// WARNING: UI should diable itself before calling any function that invokes
// this function, or functions calling this one should guard against
// re-entrance.  Otherwise there will be a re-entrancy problem.
// 
// e.g. command handler gets button clicked message, calls a func that calls
// this wait function, then user clicks the button again, command handler call
// a func that calls this one, and so on.

DWORD
MyWaitForSendMessageThread(HANDLE hThread, DWORD dwTimeout)
{
   LOG_FUNCTION(MyWaitForSendMessageThread);
   ASSERT(hThread);

    MSG msg;
    DWORD dwRet;
    DWORD dwEnd = GetTickCount() + dwTimeout;
    bool quit = false;

    // We will attempt to wait up to dwTimeout for the thread to
    // terminate

    do 
    {
        dwRet = MsgWaitForMultipleObjects(1, &hThread, FALSE,
                dwTimeout, QS_ALLEVENTS | QS_SENDMESSAGE );

        if (dwRet == (WAIT_OBJECT_0 + 1))
        {
            // empty out the message queue.  We call DispatchMessage to
            // ensure that we still process the WM_PAINT messages.
            // DANGER:  Make sure that the CYS UI is completely disabled
            // or there will be re-entrancy problems here

            while (::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
               if (msg.message == WM_QUIT)
               {
                  // Need to re-post this so that we know to close CYS

                  ::PostMessage(msg.hwnd, WM_QUIT, 0, 0);
                  quit = true;
                  break;
               }
               ::TranslateMessage(&msg);
               ::DispatchMessage(&msg);
            }

            // Calculate if we have any more time left in the timeout to
            // wait on.

            if (dwTimeout != INFINITE)
            {
                dwTimeout = dwEnd - GetTickCount();
                if ((long)dwTimeout <= 0)
                {
                    // No more time left, fail with WAIT_TIMEOUT
                    dwRet = WAIT_TIMEOUT;
                }
            }
        }

        // dwRet == WAIT_OBJECT_0 || dwRet == WAIT_FAILED
        // The thread must have exited, so we are happy
        //
        // dwRet == WAIT_TIMEOUT
        // The thread is taking too long to finish, so just
        // return and let the caller kill it

    } while (dwRet == (WAIT_OBJECT_0 + 1) && !quit);

    return(dwRet);
}


HRESULT
CreateAndWaitForProcess(
   const String& fullPath,
   String& commandLine,
   DWORD& exitCode,
   bool minimize)
{
   LOG_FUNCTION2(CreateAndWaitForProcess, fullPath);
   LOG(commandLine);
   ASSERT(!fullPath.empty());

   exitCode = 0;

   HRESULT hr = S_OK;
   do
   {
      PROCESS_INFORMATION procInfo;
      memset(&procInfo, 0, sizeof(procInfo));

      STARTUPINFO startup;
      memset(&startup, 0, sizeof(startup));

      if (minimize)
      {
         LOG(L"Starting minimized");
         startup.dwFlags = STARTF_USESHOWWINDOW;
         startup.wShowWindow = SW_MINIMIZE;
      }

      LOG(L"Calling CreateProcess");
      LOG(fullPath);
      LOG(commandLine);

      hr =
         Win::CreateProcess(
            fullPath,
            commandLine,
            0,
            String(),
            startup,
            procInfo);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(procInfo.hProcess);

      DWORD dwRet = MyWaitForSendMessageThread(procInfo.hProcess, INFINITE);

      ASSERT(dwRet == WAIT_OBJECT_0);

      hr = Win::GetExitCodeProcess(procInfo.hProcess, exitCode);
      BREAK_ON_FAILED_HRESULT(hr);

      Win::CloseHandle(procInfo.hThread);
      Win::CloseHandle(procInfo.hProcess);
   }
   while (0);

   LOG(String::format(L"exit code = %1!x!", exitCode));
   LOG_HRESULT(hr);

   return hr;
}


HRESULT
MyCreateProcess(
   const String& fullPath,
   String& commandline)
{
   LOG_FUNCTION2(MyCreateProcess, fullPath);
   LOG(commandline);
   ASSERT(!fullPath.empty());

   HRESULT hr = S_OK;
   do
   {
      PROCESS_INFORMATION procInfo;
      memset(&procInfo, 0, sizeof(procInfo));

      STARTUPINFO startup;
      memset(&startup, 0, sizeof(startup));

        
      LOG(L"Calling CreateProcess");

      hr =
         Win::CreateProcess(
            fullPath,
            commandline,
            0,
            String(),
            startup,
            procInfo);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(procInfo.hProcess);

      Win::CloseHandle(procInfo.hThread);
      Win::CloseHandle(procInfo.hProcess);
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}

bool
IsKeyValuePresent(RegistryKey& key, const String& valueKey)
{
   LOG_FUNCTION(IsKeyValuePresent);

   bool result = false;

   do 
   {

      String value;
      HRESULT hr = key.GetValue(valueKey, value);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to read regkey %1 because: hr = %2!x!",
                valueKey,
                hr));
         break;
      }

      if (!value.empty())
      {
         result = true;
         break;
      }
   } while (false);

   LOG_BOOL(result);

   return result;
}


bool
GetRegKeyValue(
   const String& keyName, 
   const String& value, 
   String& resultString,
   HKEY parentKey)
{
   LOG_FUNCTION(GetRegKeyValue);

   bool result = true;
   
   do
   {
      HRESULT hr = S_OK;
      RegistryKey key;

      hr = key.Open(parentKey, keyName);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to open regkey %1 because: hr = %2!x!",
                keyName.c_str(),
                hr));

         result = false;

         break;
      }

      hr = key.GetValue(value, resultString);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to read regkey %1 because: hr = %2!x!",
                value.c_str(),
                hr));

         result = false;

         break;
      }

      LOG(String::format(
             L"Value of key: %1",
             resultString.c_str()));

   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
GetRegKeyValue(
   const String& keyName, 
   const String& value, 
   DWORD& resultValue,
   HKEY parentKey)
{
   LOG_FUNCTION(GetRegKeyValue);

   bool result = true;
   
   do
   {
      HRESULT hr = S_OK;
      RegistryKey key;

      hr = key.Open(parentKey, keyName);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to open regkey %1 because: hr = %2!x!",
                keyName.c_str(),
                hr));

         result = false;

         break;
      }

      hr = key.GetValue(value, resultValue);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to read regkey %1 because: hr = %2!x!",
                value.c_str(),
                hr));

         result = false;

         break;
      }

      LOG(String::format(
             L"Key value: %1!d!",
             resultValue));

   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
SetRegKeyValue(
   const String& keyName, 
   const String& value, 
   const String& newString,
   HKEY parentKey,
   bool create
)
{
   LOG_FUNCTION(SetRegKeyValue);

   bool result = true;
   
   do
   {
      HRESULT hr = S_OK;
      RegistryKey key;

      if (create)
      {
         hr = key.Create(parentKey, keyName);
      }
      else
      {
         hr = key.Open(parentKey, keyName, KEY_SET_VALUE);
      }
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to open regkey %1 because: hr = %2!x!",
                keyName.c_str(),
                hr));

         result = false;

         break;
      }

      hr = key.SetValue(value, newString);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to write regkey %1 because: hr = %2!x!",
                value.c_str(),
                hr));

         result = false;

         break;
      }

   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
SetRegKeyValue(
   const String& keyName, 
   const String& value, 
   DWORD newValue,
   HKEY parentKey,
   bool create)
{
   LOG_FUNCTION(SetRegKeyValue);

   bool result = true;
   
   do
   {
      HRESULT hr = S_OK;
      RegistryKey key;

      if (create)
      {
         hr = key.Create(parentKey, keyName);
      }
      else
      {
         hr = key.Open(parentKey, keyName, KEY_WRITE);
      }
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to open regkey %1 because: hr = %2!x!",
                keyName.c_str(),
                hr));

         result = false;

         break;
      }

      hr = key.SetValue(value, newValue);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to write regkey %1 because: hr = %2!x!",
                value.c_str(),
                hr));

         result = false;

         break;
      }

   } while (false);

   LOG_BOOL(result);

   return result;
}

HRESULT
VariantArrayToStringVector(VARIANT* variant, StringVector& stringList)
{
   LOG_FUNCTION(VariantArrayToStringVector);

   HRESULT hr = S_OK;

   stringList.clear();

   do
   {
      ASSERT(variant);

      LOG(String::format(
             L"Variant type = 0x%1!x!",
             V_VT(variant)));

      if (V_VT(variant) == VT_EMPTY ||
          V_VT(variant) == VT_NULL)
      {
         break;
      }

      ASSERT(V_VT(variant) == (VT_ARRAY | VT_BSTR));


      SAFEARRAY* psa = V_ARRAY(variant);

      ASSERT(psa);
      ASSERT(psa != (SAFEARRAY*)-1);

      if (!psa || psa == (SAFEARRAY*)-1)
      {
         LOG(L"variant not safe array");
         break;
      }

      if (::SafeArrayGetDim(psa) != 1)
      {
         LOG(L"safe array: wrong number of dimensions");
         break;
      }

      VARTYPE vt = VT_EMPTY;
      hr = ::SafeArrayGetVartype(psa, &vt);
      if (FAILED(hr) || vt != VT_BSTR)
      {
         LOG(L"safe array: wrong element type");
         break;
      }

      long lower = 0;
      long upper = 0;
     
      hr = ::SafeArrayGetLBound(psa, 1, &lower);
      if (FAILED(hr))
      {
         LOG(L"can't get lower bound");      
         break;
      }

      hr = ::SafeArrayGetUBound(psa, 1, &upper);
      if (FAILED(hr))
      {
         LOG(L"can't get upper bound");      
         break;
      }
      
      for (long i = lower; i <= upper; ++i)
      {
         BSTR item;
         hr = ::SafeArrayGetElement(psa, &i, &item);
         if (FAILED(hr))
         {
            LOG(String::format(L"index %1!d! failed", i));
            continue;
         }

         if (item)
         {
            stringList.push_back(String(item));
         }

         ::SysFreeString(item);
      }
      
   }
   while (0);

   LOG_HRESULT(hr);
   
   return hr;   
}


String
IPAddressToString(DWORD ipAddress)
{
   String result = String::format(
                      L"%1!d!.%2!d!.%3!d!.%4!d!",
                      FIRST_IPADDRESS(ipAddress),
                      SECOND_IPADDRESS(ipAddress),
                      THIRD_IPADDRESS(ipAddress),
                      FOURTH_IPADDRESS(ipAddress));

   return result;
}

// Will convert a string in the form of an IP address to 
// a DWORD. A return value of INADDR_NONE means that we failed
// to do the conversion

DWORD
StringToIPAddress(const String& stringIPAddress)
{
   DWORD result = INADDR_NONE;

   // Convert the string to ansi so that we can use inet_addr 
   // to convert to an IP address DWORD

   AnsiString ansi;

   String::ConvertResult convertResult = stringIPAddress.convert(ansi);

   if (String::CONVERT_SUCCESSFUL == convertResult)
   {
      // Convert the string to an address

      result = inet_addr(ansi.c_str());
   }
   return result;
}

DWORD
ConvertIPAddressOrder(DWORD address)
{
   DWORD result = 0;
   result |= (address & 0xff) << 24;
   result |= (address & 0xff00) << 8;
   result |= (address >> 8) & 0x0000ff00;
   result |= (address >> 24) & 0x000000ff;

   return result;
}

// This function allocates an array of DWORDs and fills it with the IP addresses
// from the StringList.  The caller must free the returned pointer using
// delete[]
DWORD* 
StringIPListToDWORDArray(
   const StringList& stringIPList, 
   DWORD& count)
{
   // This is an exception throwing new so there is no
   // reason to check for NULL

   count = 0;
   DWORD ipCount = static_cast<DWORD>(stringIPList.size());
   DWORD* array = new DWORD[ipCount];

   try
   {
      // Copy the forwarders addresses into the array

      for (StringList::iterator itr = stringIPList.begin();
           itr != stringIPList.end();
           ++itr)
      {
          if (!(*itr).empty())
          {
             DWORD newAddress = StringToIPAddress(*itr);
             if (newAddress != INADDR_NONE)
             {
                array[count++] = newAddress;
             }
          }
      }
   }
   catch (exception &e)
   {
      // NTRAID#NTBUG9-654260-2002/07/08-artm
      // Avoid leaking "array" if encounter any exceptions based on
      // std::exception.  Among these are std::length_error and std::bad_alloc,
      // but there could be others.
      delete [] array;

      // Don't really know how to handle exceptions at this level, so pass the buck.
      throw e;
   }
   return array;
}


void
CreateInfFileText(
   String& infFileText, 
   unsigned int windowTitleResourceID)
{
   LOG_FUNCTION(CreateInfFileText);

   infFileText =  L"[Version]\n";
   infFileText += L"Signature =  \"$Windows NT$\"\n";
   infFileText += L"[Components]\n";
   infFileText += L"NetOC=netoc.dll,NetOcSetupProc,netoc.inf\n";
   infFileText += L"[Global]\n";
   infFileText += L"WindowTitle=";
   infFileText += String::load(windowTitleResourceID, hResourceModuleHandle);
   infFileText += L"\n";
   infFileText += L"[Strings]\n";
   infFileText += L";(empty)";
  
}


void
CreateUnattendFileText(
   String& unattendFileText, 
   PCWSTR serviceName,
   bool install)
{
   LOG_FUNCTION(CreateUnattendFileText);

   ASSERT(serviceName);

   unattendFileText =  L"[NetOptionalComponents]\n";
   unattendFileText += serviceName;

   if (install)
   {
      unattendFileText += L"=1";
   }
   else
   {
      unattendFileText += L"=0";
   }
}

HRESULT
GetShellPath(
   int folder,
   String& shellPath,
   HWND hwnd = 0)
{
   LOG_FUNCTION(GetShellPath);

   HRESULT hr = S_OK;
   PWSTR path = 0;

   do
   {
      path = new WCHAR[MAX_PATH];
      ZeroMemory(path, sizeof(WCHAR) * MAX_PATH);

      hr = ::SHGetFolderPath(
              hwnd, 
              folder,
              0,
              SHGFP_TYPE_DEFAULT,
              path);

      if (FAILED(hr))
      {
         LOG(
            String::format(
               L"Failed to get shell path: hr = %1!x!",
               hr));

         break;
      }

      shellPath = path;
   } while(false);

   if (path)
   {
      delete[] path;
      path = 0;
   }

   LOG_HRESULT(hr);

   return hr;
}


// Opens the favorites folder and creates a favorite for
// the specified URL

HRESULT
AddURLToFavorites(HWND hwnd, const String& url, const String& fileName)
{
   LOG_FUNCTION(AddURLToFavorites);

   ASSERT(Win::IsWindow(hwnd));
   ASSERT(!url.empty());
   ASSERT(!fileName.empty());

   HRESULT hr = S_OK;

   do
   {
      String path;

      hr = GetShellPath(
              CSIDL_FAVORITES,
              path);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to get favorites path: hr = %1!x!",
                hr));

         break;
      }

      // Create the favorites .url file

      String fileContents = L"[InternetShortcut]\r\n";
      fileContents       += L"URL=";
      fileContents       += url;
      fileContents       += L"\r\n";

      String fullPath = FS::AppendPath(path, fileName);
      if (fullPath.empty())
      {
         LOG(L"Failed to append path");

         hr = E_FAIL;

         break;
      }

      HANDLE h = 0;

      hr =
         FS::CreateFile(
            fullPath,
            h,
            GENERIC_WRITE,
            0, 
            CREATE_NEW,
            FILE_ATTRIBUTE_NORMAL);

      if (FAILED(hr))
      {
         LOG(
            String::format(
               L"Failed to create file: hr = %1!x!",
               hr));

         break;
      }

      // Write contents and end-of-file marker

      hr = FS::Write(h, fileContents + L"\032");

      if (FAILED(hr))
      {
         LOG(
            String::format(
               L"Failed to write contents to file: hr = %1!x!",
               hr));

         break;
      }

   } while (false);

   LOG_HRESULT(hr);

   return hr;
}

void
LaunchMMCConsole(
   const String& consoleFile,
   String& alternatePath)
{
   LOG_FUNCTION2(LaunchMMCConsole, consoleFile);

   String fullPath = Win::GetSystemDirectory() + L"\\mmc.exe";

   String commandLine = L"\"";
   if (!alternatePath.empty())
   {
      LOG(String::format(L"alternatePath = %1", alternatePath.c_str()));

      commandLine += alternatePath;
   }
   else
   {
      commandLine += Win::GetSystemDirectory();
   }
   
   commandLine += L"\\" + consoleFile + L"\"";

   LOG(String::format(L"fullPath = %1", fullPath.c_str()));
   LOG(String::format(L"commandLine = %1", commandLine.c_str()));

   HRESULT unused = MyCreateProcess(fullPath, commandLine);
   ASSERT(SUCCEEDED(unused));

   LOG_HRESULT(unused);
}

void
LaunchMYS()
{
   LOG_FUNCTION(LaunchMYS);

   String fullPath =
      Win::GetSystemDirectory() + 
      L"\\mshta.exe";

   String commandLine = L"res://" +
      Win::GetSystemDirectory() +
      L"\\mys.dll/mys.hta";

   LOG(String::format(
          L"MYS path = %1",
          fullPath.c_str()));

   LOG(String::format(
          L"MYS commandline = %1",
          commandLine.c_str()));

   HRESULT unused = MyCreateProcess(fullPath, commandLine);
   ASSERT(SUCCEEDED(unused));

   LOG_HRESULT(unused);
}

HRESULT
GetAllUsersStartMenu(String& startMenuPath)
{
   LOG_FUNCTION(GetAllUsersStartMenu);

   HRESULT hr = GetShellPath(
                   CSIDL_COMMON_STARTMENU,
                   startMenuPath);

   if (FAILED(hr))
   {
      LOG(String::format(
             L"Failed to get the start menu path: hr = %1!x!",
             hr));
   }
   
   LOG_HRESULT(hr);

   return hr;
}

HRESULT
GetAllUsersAdminTools(String& adminToolsPath)
{
   LOG_FUNCTION(GetAllUsersAdminTools);

   HRESULT hr = GetShellPath(
                   CSIDL_COMMON_ADMINTOOLS,
                   adminToolsPath);

   if (FAILED(hr))
   {
      LOG(String::format(
             L"Failed to get the admin tools path: hr = %1!x!",
             hr));
   }

   LOG_HRESULT(hr);

   return hr;
}

HRESULT
CreateShortcut(
   const String& shortcutPath,
   const String& target,
   const String& description)
{
   LOG_FUNCTION(CreateShortcut);

   HRESULT hr = S_OK;

   do
   {
      ASSERT(!shortcutPath.empty());
      ASSERT(!target.empty());

      if (shortcutPath.empty() ||
          target.empty())
      {
         LOG(String::format(
                L"A parameter was empty: shortcutPath = %1, target = %2",
                shortcutPath.c_str(),
                target.c_str()));

         hr = E_INVALIDARG;
         break;
      }

      LOG(String::format(
             L"shortcutPath = %1",
             shortcutPath.c_str()));

      LOG(String::format(
             L"target = %1",
             target.c_str()));

      SmartInterface<IShellLink> shellLink;

      hr = shellLink.AcquireViaCreateInstance(
              CLSID_ShellLink,
              0,
              CLSCTX_INPROC_SERVER);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to CoCreate IShellLink: hr = %1!x!",
                hr));
         break;
      }

      hr = shellLink->SetPath(target.c_str());
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to set the target path: hr = %1!x!",
                hr));
         break;
      }

      if (!description.empty())
      {
         LOG(L"Setting description");

         hr = shellLink->SetDescription(description.c_str());
         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to set shortcut description: hr = 0x%1!x!",
                   hr));
         }
      }

      SmartInterface<IPersistFile> persistFile;

      hr = persistFile.AcquireViaQueryInterface(
              shellLink, 
              IID_IPersistFile);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to QI for IPersistFile: hr = %1!x!",
                hr));
         break;
      }

      hr = persistFile->Save(shortcutPath.c_str(), FALSE);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to save the shortcut: hr = %1!x!",
                hr));
         break;
      }

   } while (false);

   LOG_HRESULT(hr);

   return hr;
}

int
LinkIndexFromNotifyLPARAM(LPARAM lParam)
{
   LOG_FUNCTION(LinkIndexFromNotifyLPARAM);

   int result = 0;
   
   do
   {
      ASSERT(lParam);

      if (!lParam)
      {
         break;
      }

      NMLINK* linkHeader = reinterpret_cast<NMLINK*>(lParam);
      if (!linkHeader)
      {
         LOG(L"Cast of notify link header failed");
         break;
      }

      result = linkHeader->item.iLink;
   } while (false);

   LOG(String::format(
          L"result = %1!d!",
          result));

   return result;
}


void
ShowHelp(
   const String& helpTopic)
{
   LOG_FUNCTION2(
      ShowHelp,
      helpTopic.c_str());

   // NOTE: I am not using Win::HtmlHelp here so that the help
   //       is actually running in a different process.  This
   //       allows us to close down CYS without closing the help
   //       window.

   String fullPath = Win::GetSystemWindowsDirectory() + L"\\hh.exe";
   String commandLine = helpTopic;

   HRESULT hr = MyCreateProcess(fullPath, commandLine);
   if (FAILED(hr))
   {
      LOG(String::format(
             L"Failed to open help: hr = 0x%1!x!",
             hr));
   }
}

void
OpenLogFile()
{
   LOG_FUNCTION(OpenLogFile);

   String fullPath = Win::GetSystemDirectory() + L"\\notepad.exe";
   String commandLine = Win::GetWindowsDirectory();
   commandLine += L"\\Debug\\";
   commandLine += CYS_LOGFILE_NAME;
   commandLine += L".log";

   HRESULT hr = MyCreateProcess(fullPath, commandLine);
   ASSERT(SUCCEEDED(hr));
}

bool
IsLogFilePresent()
{
   LOG_FUNCTION(IsLogFilePresent);

   bool result = false;

   String logfile = Win::GetWindowsDirectory();
   logfile += L"\\Debug\\";
   logfile += CYS_LOGFILE_NAME;
   logfile += L".log";

   result = FS::FileExists(logfile);

   LOG_BOOL(result);

   return result;
}

HRESULT
GetAdminToolsShortcutPath(
   String& adminToolsShortcutPath,
   const String& linkToAppend)
{
   LOG_FUNCTION(GetAdminToolsShortcutPath);

   HRESULT hr = S_OK;

   String adminToolsPath;

   hr = GetAllUsersAdminTools(adminToolsPath);
   if (SUCCEEDED(hr))
   {
      if (!linkToAppend.empty())
      {
         adminToolsShortcutPath = 
            FS::AppendPath(
               adminToolsPath,
               linkToAppend);

      }

      LOG(String::format(
               L"Admin Tools Link = %1",
               adminToolsShortcutPath.c_str()));
   }

   LOG_HRESULT(hr);

   return hr;
}

HRESULT
AddShortcutToAdminTools(
   const String& target,
   unsigned int descriptionID,
   unsigned int linkID)
{
   LOG_FUNCTION2(
      AddShortcutToAdminTools,
      target);

   HRESULT hr = S_OK;

   String description = String::load(descriptionID);
   String link = String::load(linkID);

   do
   {
      String adminToolsLinkPath;
      hr = GetAdminToolsShortcutPath(
              adminToolsLinkPath,
              link);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to GetAdminToolsShortcutPath: hr = 0x%1!x!",
                hr));
      }
      else
      {
         hr = CreateShortcut(
                 adminToolsLinkPath, 
                 target,
                 description);

         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to create admin tools shortcut: hr = %1!x!",
                   hr));
         }
      }

   } while (false);

   LOG_HRESULT(hr);
   return hr;
}

bool
IsSpecialShare(const SHARE_INFO_1& shareInfo)
{
   LOG_FUNCTION2(
      IsSpecialShare,
      shareInfo.shi1_netname);

   bool result = false;

   if (shareInfo.shi1_type == STYPE_DISKTREE)
   {
      LOG(L"Share is of type STYPE_DISKTREE");

      String shareName = shareInfo.shi1_netname;

      if (shareName.icompare(CYS_SPECIAL_SHARE_SYSVOL) == 0 ||
          shareName.icompare(CYS_SPECIAL_SHARE_NETLOGON) == 0 || 
          shareName.icompare(CYS_SPECIAL_SHARE_PRINT) == 0)
      {
         LOG(L"Share has a special name");

         result = true;
      }
   }
   else
   {
      LOG(L"Share is not of type STYPE_DISKTREE");

      result = true;
   }

   LOG_BOOL(result);

   return result;
}

bool
IsNonSpecialSharePresent()
{
   LOG_FUNCTION(IsNonSpecialSharePresent);

   bool result = false;

   SHARE_INFO_1* shareInfoArray = 0;
   NET_API_STATUS shareResult = 0;

   do
   {
      DWORD entriesRead = 0;
      DWORD totalEntries = 0;
      DWORD resumeHandle = 0;

      shareResult = NetShareEnum(
                       0,
                       1,
                       reinterpret_cast<BYTE**>(&shareInfoArray),
                       static_cast<DWORD>(-1),
                       &entriesRead,
                       &totalEntries,
                       &resumeHandle);

      if ((shareResult == ERROR_SUCCESS ||
           shareResult == ERROR_MORE_DATA) &&
          shareInfoArray)
      {
         for (
            DWORD index = 0;
            index < entriesRead;
            ++index)
         {
            // Look for only normal shares and ignore special shares
            // like C$, ADMIN$, and IPC$

            if (!IsSpecialShare(shareInfoArray[index]))
            {
               LOG(String::format(
                     L"Share found: %1",
                     shareInfoArray[index].shi1_netname));

               result = true;
               break;
            }
         }
      }
      else
      {
         LOG(String::format(
                L"NetShareEnum failed: result = %1!x!",
                shareResult));
      }

      if (shareInfoArray)
      {
         NetApiBufferFree(shareInfoArray);
         shareInfoArray = 0;
      }

      if (result)
      {
         break;
      }
   } while(shareResult == ERROR_MORE_DATA);

   LOG_BOOL(result);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\lib\isdhcp.c ===
/*++

Copyright (C) 1999-2002 Microsoft Corporation

Module Name:

    isdhcp.c

Abstract:

    test program to see if a DHCP server is around or not.

Environment:

    Win2K+

 History:

    Code provided by JRuan on May 8, 2002 and integrated into
    CYS by JeffJon

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <dhcpcapi.h>
#include <iprtrmib.h>
#include <iphlpapi.h>
#include <stdio.h>

#define OPTION_PAD                      0
#define OPTION_HOST_NAME                12
#define OPTION_MESSAGE_TYPE             53
#define OPTION_SERVER_IDENTIFIER        54
#define OPTION_PARAMETER_REQUEST_LIST   55
#define OPTION_CLIENT_ID                61
#define OPTION_END                      255

#define DHCP_CLIENT_PORT    68
#define DHCP_SERVR_PORT     67

BYTE HardwareAddress[16];
BYTE HardwareAddressLength = 6;
#define SOCKET_RECEIVE_BUFFER_SIZE      1024 * 4    // 4K max.
#define AUTH_SERVERS_MAX                64
#define SMALL_BUFFER_SIZE               32
#define ALERT_INTERVAL                  5 * 60      // 5 mins
#define ALERT_MESSAGE_LENGTH            256
#define MAX_ALERT_NAMES                 256

#define BOOT_REQUEST   1
#define DHCP_BROADCAST      0x8000
#define DHCP_DISCOVER_MESSAGE  1
#define DHCP_INFORM_MESSAGE    8

#define DHCP_MESSAGE_SIZE       576
#define DHCP_RECV_MESSAGE_SIZE  4096

#define BOOT_FILE_SIZE          128
#define BOOT_SERVER_SIZE        64
#define DHCP_MAGIC_COOKIE_BYTE1     99
#define DHCP_MAGIC_COOKIE_BYTE2     130
#define DHCP_MAGIC_COOKIE_BYTE3     83
#define DHCP_MAGIC_COOKIE_BYTE4     99

#include <packon.h>
typedef struct _OPTION {
    BYTE OptionType;
    BYTE OptionLength;
    BYTE OptionValue[1];
} OPTION, *POPTION, *LPOPTION;
typedef struct _DHCP_MESSAGE {
    BYTE Operation;
    BYTE HardwareAddressType;
    BYTE HardwareAddressLength;
    BYTE HopCount;
    DWORD TransactionID;
    WORD SecondsSinceBoot;
    WORD Reserved;
    ULONG ClientIpAddress;
    ULONG YourIpAddress;
    ULONG BootstrapServerAddress;
    ULONG RelayAgentIpAddress;
    BYTE HardwareAddress[16];
    BYTE HostName[ BOOT_SERVER_SIZE ];
    BYTE BootFileName[BOOT_FILE_SIZE];
    OPTION Option;
} DHCP_MESSAGE, *PDHCP_MESSAGE, *LPDHCP_MESSAGE;
#include <packoff.h>

LPOPTION
DhcpAppendOption(
    LPOPTION Option,
    BYTE OptionType,
    PVOID OptionValue,
    ULONG OptionLength,
    LPBYTE OptionEnd
)
/*++

Routine Description:

    This function writes a DHCP option to message buffer.

Arguments:

    Option - A pointer to a message buffer.

    OptionType - The option number to append.

    OptionValue - A pointer to the option data.

    OptionLength - The length, in bytes, of the option data.

    OptionEnd - End of Option Buffer.

Return Value:

    A pointer to the end of the appended option.

--*/
{
    if (!Option)
    {
       return Option;
    }

    if ( OptionType == OPTION_END ) {

        //
        // we should alway have atleast one BYTE space in the buffer
        // to append this option.
        //

        Option->OptionType = OPTION_END;
        return( (LPOPTION) ((LPBYTE)(Option) + 1) );

    }

    if ( OptionType == OPTION_PAD ) {

        //
        // add this option only iff we have enough space in the buffer.
        //

        if(((LPBYTE)Option + 1) < (OptionEnd - 1) ) {
            Option->OptionType = OPTION_PAD;
            return( (LPOPTION) ((LPBYTE)(Option) + 1) );
        }

        return Option;
    }


    //
    // add this option only iff we have enough space in the buffer.
    //

    if(((LPBYTE)Option + 2 + OptionLength) >= (OptionEnd - 1) ) {
        return Option;
    }

    if( OptionLength <= 0xFF ) {
        // simple option.. no need to use OPTION_MSFT_CONTINUED
        Option->OptionType = OptionType;
        Option->OptionLength = (BYTE)OptionLength;
        memcpy( Option->OptionValue, OptionValue, OptionLength );
        return( (LPOPTION) ((LPBYTE)(Option) + Option->OptionLength + 2) );
    }

    // option size is > 0xFF --> need to continue it using multiple ones..
    // there are OptionLenght / 0xFF occurances using 0xFF+2 bytes + one
    // using 2 + (OptionLength % 0xFF ) space..

    // check to see if we have the space first..

    if( 2 + (OptionLength%0xFF) + 0x101*(OptionLength/0xFF)
        + (LPBYTE)Option >= (OptionEnd - 1) ) {
        return Option;
    }

    return Option;
}

LPBYTE
DhcpAppendMagicCookie(
    LPBYTE Option,
    LPBYTE OptionEnd
    )
/*++

Routine Description:

    This routine appends magic cookie to a DHCP message.

Arguments:

    Option - A pointer to the place to append the magic cookie.

    OptionEnd - End of Option buffer.

Return Value:

    A pointer to the end of the appended cookie.

    Note : The magic cookie is :

     --------------------
    | 99 | 130 | 83 | 99 |
     --------------------

--*/
{
    if( (Option + 4) < (OptionEnd - 1) ) {
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE1;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE2;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE3;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE4;
    }

    return( Option );
}

LPOPTION
DhcpAppendClientIDOption(
    LPOPTION Option,
    BYTE ClientHWType,
    LPBYTE ClientHWAddr,
    BYTE ClientHWAddrLength,
    LPBYTE OptionEnd

    )
/*++

Routine Description:

    This routine appends client ID option to a DHCP message.

History:
    8/26/96 Frankbee    Removed 16 byte limitation on the hardware
                        address

Arguments:

    Option - A pointer to the place to append the option request.

    ClientHWType - Client hardware type.

    ClientHWAddr - Client hardware address

    ClientHWAddrLength - Client hardware address length.

    OptionEnd - End of Option buffer.

Return Value:

    A pointer to the end of the newly appended option.

    Note : The client ID option will look like as below in the message:

     -----------------------------------------------------------------
    | OpNum | Len | HWType | HWA1 | HWA2 | .....               | HWAn |
     -----------------------------------------------------------------

--*/
{
    struct _CLIENT_ID {
        BYTE    bHardwareAddressType;
        BYTE    pbHardwareAddress[1];
    } *pClientID;

    LPOPTION lpNewOption = 0;

    pClientID = LocalAlloc(LMEM_FIXED, sizeof( struct _CLIENT_ID ) + ClientHWAddrLength);

    //
    // currently there is no way to indicate failure.  simply return unmodified option
    // list
    //

    if ( !pClientID )
        return Option;

    pClientID->bHardwareAddressType    = ClientHWType;
    memcpy( pClientID->pbHardwareAddress, ClientHWAddr, ClientHWAddrLength );

    lpNewOption =  DhcpAppendOption(
                         Option,
                         OPTION_CLIENT_ID,
                         (LPBYTE)pClientID,
                         (BYTE)(ClientHWAddrLength + sizeof(BYTE)),
                         OptionEnd );

    LocalFree( pClientID );

    return lpNewOption;
}

DWORD
OpenSocket(
    SOCKET *Socket,
    unsigned long IpAddress,
    unsigned short Port
    )
{
    DWORD Error = 0;
    SOCKET Sock;
    DWORD OptValue = TRUE;

    struct sockaddr_in SocketName;

    //
    // Create a socket
    //

    Sock = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );

    if ( Sock == INVALID_SOCKET ) {
        Error = WSAGetLastError();
        goto error;
    }

    //
    // Make the socket share-able
    //

    Error = setsockopt(
                Sock,
                SOL_SOCKET,
                SO_REUSEADDR,
                (char*)&OptValue,
                sizeof(OptValue) );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto error;
    }

    OptValue = TRUE;
    Error = setsockopt(
                Sock,
                SOL_SOCKET,
                SO_BROADCAST,
                (char*)&OptValue,
                sizeof(OptValue) );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto error;
    }

    OptValue = SOCKET_RECEIVE_BUFFER_SIZE;
    Error = setsockopt(
                Sock,
                SOL_SOCKET,
                SO_RCVBUF,
                (char*)&OptValue,
                sizeof(OptValue) );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto error;
    }

    SocketName.sin_family = PF_INET;
    SocketName.sin_port = Port;
    SocketName.sin_addr.s_addr = IpAddress;
    RtlZeroMemory( SocketName.sin_zero, 8);

    //
    // Bind this socket to the DHCP server port
    //

    Error = bind(
               Sock,
               (struct sockaddr FAR *)&SocketName,
               sizeof( SocketName )
               );

    if ( Error != ERROR_SUCCESS ) {

        Error = WSAGetLastError();
        goto error;
    }

    *Socket = Sock;
    Error = ERROR_SUCCESS;

error:

    if( Error != ERROR_SUCCESS ) {

        //
        // if we aren't successful, close the socket if it is opened.
        //

        if( Sock != INVALID_SOCKET ) {
            closesocket( Sock );
        }
    }

    return( Error );
}

DWORD
SendInformOrDiscover(
    SOCKET Sock,
    ULONG uClientIp,
    BYTE  ucMessageType,
    PBYTE pMessageBuffer,
    ULONG uMessageBufferSize,
    ULONG DestIp,
    PULONG puXid
    )
{
    DWORD Error = 0;
    PDHCP_MESSAGE dhcpMessage = (PDHCP_MESSAGE)pMessageBuffer;
    LPOPTION option = 0;
    LPBYTE OptionEnd = 0;
    BYTE value = 0;
    ULONG uXid = 0;
    LPSTR HostName = "detective";
    ULONG uNumOfRequestOptions = 0;
    UCHAR ucRequestOptions[256];
    struct sockaddr_in socketName;
    DWORD i;

    uXid = (rand() & 0xff);
    uXid <<= 8;
    uXid |= (rand() & 0xff);
    uXid <<= 8;
    uXid |= (rand() & 0xff);
    uXid <<= 8;
    uXid |= (rand() & 0xff);

    HardwareAddressLength = 6;
    for (i = 0; i < HardwareAddressLength; i++) {
        HardwareAddress[i] = (BYTE)(rand() & 0xff);
    }

    //
    // prepare message.
    //

    RtlZeroMemory( dhcpMessage, uMessageBufferSize );

    dhcpMessage->Operation = BOOT_REQUEST;
    dhcpMessage->ClientIpAddress = uClientIp;
    dhcpMessage->HardwareAddressType = 1;
    dhcpMessage->SecondsSinceBoot = 60; // random value ??
    dhcpMessage->Reserved = htons(DHCP_BROADCAST);
    dhcpMessage->TransactionID = uXid;
    *puXid = uXid;

    memcpy(
        dhcpMessage->HardwareAddress,
        HardwareAddress,
        HardwareAddressLength
        );

    dhcpMessage->HardwareAddressLength = (BYTE)HardwareAddressLength;

    option = &dhcpMessage->Option;
    OptionEnd = (LPBYTE)dhcpMessage + uMessageBufferSize;

    //
    // always add magic cookie first
    //

    option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) option, OptionEnd );

    value = ucMessageType;
    option = DhcpAppendOption(
                option,
                OPTION_MESSAGE_TYPE,
                &value,
                1,
                OptionEnd );


    //
    // Add client ID Option.
    //

    option = DhcpAppendClientIDOption(
                option,
                1,
                HardwareAddress,
                HardwareAddressLength,
                OptionEnd );

    //
    // add Host name and comment options.
    //

    option = DhcpAppendOption(
                 option,
                 OPTION_HOST_NAME,
                 (LPBYTE)HostName,
                 (BYTE)((strlen(HostName) + 1) * sizeof(CHAR)),
                 OptionEnd );

    //
    // Add requested option
    //

    uNumOfRequestOptions = 0;
    ucRequestOptions[uNumOfRequestOptions++] = 3;
    option = DhcpAppendOption(
                 option,
                 OPTION_PARAMETER_REQUEST_LIST,
                 ucRequestOptions,
                 uNumOfRequestOptions,
                 OptionEnd
                 );

    //
    // Add END option.
    //

    option = DhcpAppendOption( option, OPTION_END, NULL, 0, OptionEnd );

    //
    // Initialize the outgoing address.
    //

    socketName.sin_family = PF_INET;
    socketName.sin_port = htons( DHCP_SERVR_PORT );
    socketName.sin_addr.s_addr = DestIp;

    for ( i = 0; i < 8 ; i++ ) {
        socketName.sin_zero[i] = 0;
    }

    Error = sendto(
                Sock,
                (char*)pMessageBuffer,
                (int)(((PBYTE)option) - pMessageBuffer),
                0,
                (struct sockaddr *)&socketName,
                sizeof( struct sockaddr )
                );

    if ( Error == SOCKET_ERROR ) {
        Error = WSAGetLastError();
        return( Error );
    }

    return( ERROR_SUCCESS );
}

DWORD
GetSpecifiedMessage(
    SOCKET Sock,
    PBYTE pMessageBuffer,
    ULONG uMessageBufferSize,
    ULONG uXid,
    ULONG uTimeout,
    ULONG * pServerIpAddress
    )
{
    DWORD Error = 0;
    fd_set readSocketSet;
    struct timeval timeout;
    struct sockaddr socketName;
    int socketNameSize = sizeof( socketName );
    PDHCP_MESSAGE dhcpMessage = (PDHCP_MESSAGE)pMessageBuffer;
    time_t start_time = 0, now = 0;
    PUCHAR pucOption = NULL;
    ULONG uBytesRemain = 0;
    ULONG uOptionSize = 0;
    BOOL bWellFormedPacket = FALSE;
    ULONG uRemainingTime = 0;
    BOOL continueLooping = TRUE;
    BOOL continueInternalLoop = TRUE;
    BOOL continueInternalLoop2 = FALSE;

    BYTE ReqdCookie[] = {
        (BYTE)DHCP_MAGIC_COOKIE_BYTE1,
        (BYTE)DHCP_MAGIC_COOKIE_BYTE2,
        (BYTE)DHCP_MAGIC_COOKIE_BYTE3,
        (BYTE)DHCP_MAGIC_COOKIE_BYTE4
    };

    time(&now);
    start_time = now;

    *pServerIpAddress = 0;

    while (continueLooping) {
        time(&now);
        uRemainingTime = uTimeout - (ULONG)(now - start_time);

        FD_ZERO( &readSocketSet );


//        FD_SET( Sock, &readSocketSet );
        // Had to inline the macro because the compiler was complaining
        // about the while(0) that was present in FD_SET

        do {
            u_int __i;
            for (__i = 0; __i < ((fd_set FAR *)(&readSocketSet))->fd_count; __i++) {
               if (((fd_set FAR *)(&readSocketSet))->fd_array[__i] == (Sock)) {
                     continueInternalLoop2 = FALSE;
                     break;
               }
            }
            if (__i == ((fd_set FAR *)(&readSocketSet))->fd_count) {
               if (((fd_set FAR *)(&readSocketSet))->fd_count < FD_SETSIZE) {
                     ((fd_set FAR *)(&readSocketSet))->fd_array[__i] = (Sock);
                     ((fd_set FAR *)(&readSocketSet))->fd_count++;
               }
            }
         } while(continueInternalLoop2);

        timeout.tv_sec = uRemainingTime;
        timeout.tv_usec = 0;

        Error = select(1, &readSocketSet, NULL, NULL, &timeout);

        if (Error == 0) {
            Error = ERROR_SEM_TIMEOUT;
            continueLooping = FALSE;
            break;
        }

        //
        // receive available message.
        //

        Error = recvfrom(
                    Sock,
                    (char*)pMessageBuffer,
                    uMessageBufferSize,
                    0,
                    &socketName,
                    &socketNameSize
                    );

        if ( Error == SOCKET_ERROR ) {

            Error = WSAGetLastError();

            //
            // Don't bail out here.
            //

            continue;
        }

        //
        // Some sanity check
        //
        if (Error < sizeof(DHCP_MESSAGE)) {
            continue;
        }

        if (dhcpMessage->HardwareAddressLength != HardwareAddressLength) {
            continue;
        }

        if (memcmp(dhcpMessage->HardwareAddress, HardwareAddress, HardwareAddressLength) != 0) {
            continue;
        }

        if (dhcpMessage->TransactionID != uXid) {
            continue;
        }

        //
        // Make sure the option part is well-formed
        //  +--------------+----------+----------+-------------+
        //  | magic cookie | Option 1 | Length 1 | Option Data 1 ...
        //  +--------------+----------+----------+-------------+
        //

        pucOption = (PUCHAR)(&dhcpMessage->Option);
        uBytesRemain = Error - (ULONG)(pucOption - ((PUCHAR)dhcpMessage));
        if (uBytesRemain < sizeof(ReqdCookie)) {
            continue;
        }

        if (0 != memcmp(pucOption, ReqdCookie, sizeof(ReqdCookie))) {
            continue;
        }

        pucOption += sizeof(ReqdCookie);
        uBytesRemain -= sizeof(ReqdCookie);
        bWellFormedPacket = FALSE;

        while (continueInternalLoop) {

            //
            // Make sure pucOption[0] is readable
            //
            if (uBytesRemain < 1) {
                continueInternalLoop = FALSE;
                break;
            }

            if (pucOption[0] == OPTION_PAD) {
                pucOption++;
                uBytesRemain--;
                continue;
            }

            if (pucOption[0] == OPTION_END) {
                //
                // See the OPTION_END. This is a well-formed packet
                //
                bWellFormedPacket = TRUE;
                continueInternalLoop = FALSE;
                break;
            }

            //
            // Make sure pucOption[1] is readable
            //
            if (uBytesRemain < 2) {
                continueInternalLoop = FALSE;
                break;
            }

            uOptionSize = pucOption[1];

            //
            // Make sure there is enough bytes for the option data
            //
            if (uBytesRemain < uOptionSize) {
                continueInternalLoop = FALSE;
                break;
            }

            if (pucOption[0] == OPTION_SERVER_IDENTIFIER) {
                if (uOptionSize != sizeof(ULONG)) {
                    continueInternalLoop = FALSE;
                    break;
                }
                memcpy(pServerIpAddress, pucOption + 2, sizeof(ULONG));
            }


            //
            // Skip the option head and option data and move
            // to the next option
            //
            uBytesRemain -= uOptionSize + 2;
            pucOption += uOptionSize + 2;
        }

        if (bWellFormedPacket) {
            Error = ERROR_SUCCESS;
            continueLooping = FALSE;
            break;
        }
    }

    return( Error );
}


// This will first attempt a DHCP_INFORM to detect a DHCP server.
// If that fails it will attempt a DHCP_DISCOVER.

DWORD
AnyDHCPServerRunning(
    ULONG uClientIp,
    ULONG * pServerIp
    )
{
    CHAR MessageBuffer[DHCP_RECV_MESSAGE_SIZE];
    SOCKET Sock = INVALID_SOCKET;
    ULONG DestIp = htonl(INADDR_BROADCAST);
    DWORD dwError = ERROR_SUCCESS;
    ULONG uXid = 0;
    ULONG uMessageBufferSize = sizeof(MessageBuffer);
    ULONG uTimeout = 4;
    int retries = 0;

    if (!pServerIp)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }

    dwError = OpenSocket(
                &Sock,
                uClientIp,
                htons(DHCP_CLIENT_PORT)
                );

    if( dwError != ERROR_SUCCESS ) {
        goto error;
    }

    for (retries = 0; retries < 3; retries++) {
        //
        // Try inform
        //
        dwError = 
           SendInformOrDiscover(
              Sock, 
              uClientIp, 
              DHCP_INFORM_MESSAGE, 
              (PBYTE)MessageBuffer, 
              uMessageBufferSize, 
              DestIp, 
              &uXid);

        if (dwError != ERROR_SUCCESS) {
            goto error;
        }

        dwError = GetSpecifiedMessage(
                    Sock,
                    (PBYTE)MessageBuffer,
                    uMessageBufferSize,
                    uXid,
                    uTimeout,
                    pServerIp
                    );
        if (dwError != ERROR_SEM_TIMEOUT && *pServerIp != htonl(INADDR_ANY) && *pServerIp != htonl(INADDR_BROADCAST)) {
            break;
        }

        //
        // Try discover
        //
        dwError = 
           SendInformOrDiscover(
               Sock, 
               uClientIp,
               DHCP_DISCOVER_MESSAGE, 
               (PBYTE)MessageBuffer, 
               uMessageBufferSize, 
               DestIp, 
               &uXid);

        if (dwError != ERROR_SUCCESS) {
            goto error;
        }

        dwError = GetSpecifiedMessage(
                    Sock,
                    (PBYTE)MessageBuffer,
                    uMessageBufferSize,
                    uXid,
                    uTimeout,
                    pServerIp
                    );
        if (dwError != ERROR_SEM_TIMEOUT && *pServerIp != htonl(INADDR_ANY) && *pServerIp != htonl(INADDR_BROADCAST)) {
            break;
        }
    }

error:
    if (Sock != INVALID_SOCKET) {
        closesocket(Sock);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\lib\isdhcpconfigured.cpp ===
// Copyright (c) 2000-2001 Microsoft Corporation
//
// Implementation of IConfigureYourServer::IsDhcpConfigured
//
// 20 Apr 2000 sburns
// 06 Feb 2001 jeffjon Copied from CYS HTA sources for use with CYS win32 sources



#include "pch.h"

// make sure the DLLs for all these APIs are present with base install.
// if not, then need to wrap usage in load-lib calls
// 
// DhcpLeaseIpAddress        DHCPCSVC    ok
// DhcpReleaseIpAddressLease DHCPCSVC    ok
// DhcpDsInitDS              DSAUTH      ok
// DhcpAddServerDS           DSAUTH      ok
// DhcpDsCleanupDS           DSAUTH      ok
// DhcpGetAllOptions         DHCPSAPI    ok
// DhcpRpcFreeMemory         DHCPSAPI    ok
// DhcpEnumSubnets           DHCPSAPI    ok
// DhcpEnumMscopes           DHCPSAPI    ok



String
GetIpAddress()
{
   LOG_FUNCTION(GetIpAddress);

   String result;

   HRESULT hr = S_OK;
   BYTE* buf = 0;
   do
   {
      // first, determine the size of the table

      ULONG tableSize = 0;
      DWORD err = ::GetIpAddrTable(0, &tableSize, FALSE);
      if (err != ERROR_INSUFFICIENT_BUFFER)
      {
         LOG(L"GetIpAddrTable for table size failed");
         LOG_HRESULT(Win32ToHresult(err));
         break;
      }

      // allocate space for the table.

      buf = new BYTE[tableSize + 1];
      memset(buf, 0, tableSize + 1);
      PMIB_IPADDRTABLE table = reinterpret_cast<PMIB_IPADDRTABLE>(buf);

      LOG(L"Calling GetIpAddrTable");

      hr =
         Win32ToHresult(
            ::GetIpAddrTable(
               table,
               &tableSize,
               FALSE));
      BREAK_ON_FAILED_HRESULT2(hr, L"GetIpAddrTable failed");

      LOG(String::format(L"dwNumEntries: %1!d!", table->dwNumEntries));

      for (DWORD i = 0; i < table->dwNumEntries; ++i)
      {
         DWORD addr = table->table[i].dwAddr;
         LOG(String::format(L"entry %1!d!", i));
         LOG(String::format(
            L"dwAddr %1!X! (%2!d!.%3!d!.%4!d!.%5!d!)",
            addr,
				((BYTE*)&addr)[0],
				((BYTE*)&addr)[1],
				((BYTE*)&addr)[2],
				((BYTE*)&addr)[3]));

         // skip loopback, etc.

         if (
               INADDR_ANY        == addr
            || INADDR_BROADCAST  == addr
            || INADDR_LOOPBACK   == addr
            || 0x0100007f        == addr )
         {
            LOG(L"is loopback/broadcast -- skipping");

            continue;
         }

         // Exclude MCAST addresses (class D).

         if (
               IN_CLASSA(htonl(addr))
            || IN_CLASSB(htonl(addr))
            || IN_CLASSC(htonl(addr)) )
         {
            LOG(L"is class A/B/C");

            result = 
               String::format(
                  L"%1!d!.%2!d!.%3!d!.%4!d!",
				      ((BYTE*)&addr)[0],
				      ((BYTE*)&addr)[1],
				      ((BYTE*)&addr)[2],
				      ((BYTE*)&addr)[3]);

            break;
         }

         LOG(L"not class A/B/C -- skipping");
      }
   }
   while (0);

   delete[] buf;

   LOG(result);
   LOG_HRESULT(hr);

   return result;
}



bool
AreDhcpOptionsPresent(const String& ipAddress)
{
   LOG_FUNCTION2(AreDhcpOptionsPresent, ipAddress);
   ASSERT(!ipAddress.empty());

   bool result = false;

   LPDHCP_ALL_OPTIONS options = 0;
   do
   {
      DWORD err =
         ::DhcpGetAllOptions(
            const_cast<wchar_t*>(ipAddress.c_str()),
            0,
            &options);

      if (err != ERROR_SUCCESS)
      {
         LOG(String::format(L"DhcpGetAllOptions failed with 0x%1!08X!", err));
         break;
      }

      if (options)
      {
         // options are set, so some dhcp configuration was done.

         result = true;
         break;
      }
   }
   while (0);

   if (options)
   {
      ::DhcpRpcFreeMemory(options);
   }

   LOG_BOOL(result);

   return result;
}



bool
AreDhcpSubnetsPresent(const String& ipAddress)
{
   LOG_FUNCTION2(AreDhcpSubnetsPresent, ipAddress);
   ASSERT(!ipAddress.empty());

   bool result = false;

   LPDHCP_IP_ARRAY subnets = 0;
   do
   {
      DHCP_RESUME_HANDLE resume    = 0;
      DWORD              unused1   = 0;
      DWORD              unused2   = 0;
      DWORD err =
         ::DhcpEnumSubnets(
            ipAddress.c_str(),
            &resume,
            ~(static_cast<DWORD>(0)),
            &subnets,
            &unused1,
            &unused2);

      if (err == ERROR_NO_MORE_ITEMS)
      {
         // no subnets.

         break;
      }

      if (err != NO_ERROR and err != ERROR_MORE_DATA)
      {
         LOG(String::format(L"DhcpEnumSubnets failed with 0x%1!08X!", err));
         break;
      }

      ASSERT(subnets);

      result = true;

      // the resume handle is simply discarded...
   }
   while (0);

   if (subnets)
   {
      ::DhcpRpcFreeMemory(subnets);
   }

   LOG_BOOL(result);

   return result;
}



bool
AreDhcpMscopesPresent(const String& ipAddress)
{
   LOG_FUNCTION2(AreDhcpMscopesPresent, ipAddress);
   ASSERT(!ipAddress.empty());

   bool result = false;

   LPDHCP_MSCOPE_TABLE mscopes = 0;
   do
   {
      DHCP_RESUME_HANDLE resume    = 0;
      DWORD              unused1   = 0;
      DWORD              unused2   = 0;
      DWORD err =
         ::DhcpEnumMScopes(
            ipAddress.c_str(),
            &resume,
            ~(static_cast<DWORD>(0)),
            &mscopes,
            &unused1,
            &unused2);

      if (err == ERROR_NO_MORE_ITEMS)
      {
         // no mscopes.

         break;
      }

      if (err != NO_ERROR and err != ERROR_MORE_DATA)
      {
         LOG(String::format(L"DhcpEnumMscopes failed with 0x%1!08X!", err));
         break;
      }

      ASSERT(mscopes);

      result = true;

      // the resume handle is simply discarded...
   }
   while (0);

   if (mscopes)
   {
      ::DhcpRpcFreeMemory(mscopes);
   }

   LOG_BOOL(result);

   return result;
}


bool 
IsDhcpConfigured()
{
   LOG_FUNCTION(IsDhcpConfigured);

   bool result = false;
   do
   {

      // if any of the following return any results, then we consider dhcp to
      // have been configured.
      //    
      // DhcpGetAllOptions retrieves the options configured.
      // DhcpEnumSubnets retrieves the list of subnets configured.
      // DhcpEnumMscopes retrieves the list of mscopes configured.

      String ipAddress = GetIpAddress();
      if (ipAddress.empty())
      {
         LOG(L"no ip address");
         break;
      }

      if (AreDhcpOptionsPresent(ipAddress))
      {
         LOG(L"dchp options found");

         result = true;
         break;
      }

      // no options found.  go on to next test

      if (AreDhcpSubnetsPresent(ipAddress))
      {
         LOG(L"dchp subnets found");

         result = true;
         break;
      }

      // no subnets found.  go on.

      if (AreDhcpMscopesPresent(ipAddress))
      {
         LOG(L"dchp mscopes found");

         result = true;
         break;
      }
   }
   while (0);

   LOG_BOOL(result);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\lib\pch.h ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      pch.h
//
// Synopsis:  precompiled header for the 
//            Configure Your Server Wizard project
//
// History:   02/02/2001  JeffJon Created

#ifndef __CYS_PCH_H
#define __CYS_PCH_H


// Stuff from burnslib

#include <burnslib.hpp>

#include <process.h>
#include <iphlpapi.h>
#include <shlwapi.h>
#include <dsrolep.h>
#include <comdef.h>

extern "C"
{
   #include <dhcpapi.h>
   #include <mdhcsapi.h>
}

#include <netconp.h>

#include <shlobjp.h>
#include <shgina.h>

// Printer shares

#include <winspool.h>

// File shares

#include <lmshare.h>

// Cluster

#include <clusapi.h>


#include "regkeys.h"
#include "common.h"


#endif // __CYS_PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\lib\networkinterface.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      NetworkInterface.cpp
//
// Synopsis:  Defines a NetworkInterface
//            This object has the knowledge of an
//            IP enabled network connection including 
//            IP address, DHCP information, etc.
//
// History:   03/01/2001  JeffJon Created

#include "pch.h"

#include "NetworkInterface.h"

#include <iphlpstk.h>      // SetIpForwardEntryToStack
#include <IPIfCons.h>      // Adapter type info
#include <raserror.h>      // RAS error codes

#define MPR50 1            // Needed in order to include routprot.h
#include <routprot.h>      // Router protocols

#define  CYS_WMIPROP_IPADDRESS      L"IPAddress"
#define  CYS_WMIPROP_IPSUBNET       L"IPSubnet"
#define  CYS_WMIPROP_DHCPENABLED    L"DHCPEnabled"
#define  CYS_WMIPROP_DESCRIPTION    L"Description"
#define  CYS_WMIPROP_DNSSERVERS     L"DNSServerSearchOrder"
#define  CYS_WMIPROP_INDEX          L"Index"

// An array of strings to ease the logging of the adapter type

static PCWSTR adapterTypes[] =
{
   L"IF_TYPE_OTHER",                   // 1 None of the below
   L"IF_TYPE_REGULAR_1822",            // 2
   L"IF_TYPE_HDH_1822",                // 3
   L"IF_TYPE_DDN_X25",                 // 4
   L"IF_TYPE_RFC877_X25",              // 5
   L"IF_TYPE_ETHERNET_CSMACD",         // 6
   L"IF_TYPE_IS088023_CSMACD",         // 7
   L"IF_TYPE_ISO88024_TOKENBUS",       // 8
   L"IF_TYPE_ISO88025_TOKENRING",      // 9
   L"IF_TYPE_ISO88026_MAN",            // 10
   L"IF_TYPE_STARLAN",                 // 11
   L"IF_TYPE_PROTEON_10MBIT",          // 12
   L"IF_TYPE_PROTEON_80MBIT",          // 13
   L"IF_TYPE_HYPERCHANNEL",            // 14
   L"IF_TYPE_FDDI",                    // 15
   L"IF_TYPE_LAP_B",                   // 16
   L"IF_TYPE_SDLC",                    // 17
   L"IF_TYPE_DS1",                     // 18 DS1-MIB
   L"IF_TYPE_E1",                      // 19 Obsolete; see DS1-MIB
   L"IF_TYPE_BASIC_ISDN",              // 20
   L"IF_TYPE_PRIMARY_ISDN",            // 21
   L"IF_TYPE_PROP_POINT2POINT_SERIAL", // 22 proprietary serial
   L"IF_TYPE_PPP",                     // 23
   L"IF_TYPE_SOFTWARE_LOOPBACK",       // 24
   L"IF_TYPE_EON",                     // 25 CLNP over IP
   L"IF_TYPE_ETHERNET_3MBIT",          // 26
   L"IF_TYPE_NSIP",                    // 27 XNS over IP
   L"IF_TYPE_SLIP",                    // 28 Generic Slip
   L"IF_TYPE_ULTRA",                   // 29 ULTRA Technologies
   L"IF_TYPE_DS3",                     // 30 DS3-MIB
   L"IF_TYPE_SIP",                     // 31 SMDS, coffee
   L"IF_TYPE_FRAMERELAY",              // 32 DTE only
   L"IF_TYPE_RS232",                   // 33
   L"IF_TYPE_PARA",                    // 34 Parallel port
   L"IF_TYPE_ARCNET",                  // 35
   L"IF_TYPE_ARCNET_PLUS",             // 36
   L"IF_TYPE_ATM",                     // 37 ATM cells
   L"IF_TYPE_MIO_X25",                 // 38
   L"IF_TYPE_SONET",                   // 39 SONET or SDH
   L"IF_TYPE_X25_PLE",                 // 40
   L"IF_TYPE_ISO88022_LLC",            // 41
   L"IF_TYPE_LOCALTALK",               // 42
   L"IF_TYPE_SMDS_DXI",                // 43
   L"IF_TYPE_FRAMERELAY_SERVICE",      // 44 FRNETSERV-MIB
   L"IF_TYPE_V35",                     // 45
   L"IF_TYPE_HSSI",                    // 46
   L"IF_TYPE_HIPPI",                   // 47
   L"IF_TYPE_MODEM",                   // 48 Generic Modem
   L"IF_TYPE_AAL5",                    // 49 AAL5 over ATM
   L"IF_TYPE_SONET_PATH",              // 50
   L"IF_TYPE_SONET_VT",                // 51
   L"IF_TYPE_SMDS_ICIP",               // 52 SMDS InterCarrier Interface
   L"IF_TYPE_PROP_VIRTUAL",            // 53 Proprietary virtual/internal
   L"IF_TYPE_PROP_MULTIPLEXOR",        // 54 Proprietary multiplexing
   L"IF_TYPE_IEEE80212",               // 55 100BaseVG
   L"IF_TYPE_FIBRECHANNEL",            // 56
   L"IF_TYPE_HIPPIINTERFACE",          // 57
   L"IF_TYPE_FRAMERELAY_INTERCONNECT", // 58 Obsolete, use 32 or 44
   L"IF_TYPE_AFLANE_8023",             // 59 ATM Emulated LAN for 802.3
   L"IF_TYPE_AFLANE_8025",             // 60 ATM Emulated LAN for 802.5
   L"IF_TYPE_CCTEMUL",                 // 61 ATM Emulated circuit
   L"IF_TYPE_FASTETHER",               // 62 Fast Ethernet (100BaseT)
   L"IF_TYPE_ISDN",                    // 63 ISDN and X.25
   L"IF_TYPE_V11",                     // 64 CCITT V.11/X.21
   L"IF_TYPE_V36",                     // 65 CCITT V.36
   L"IF_TYPE_G703_64K",                // 66 CCITT G703 at 64Kbps
   L"IF_TYPE_G703_2MB",                // 67 Obsolete; see DS1-MIB
   L"IF_TYPE_QLLC",                    // 68 SNA QLLC
   L"IF_TYPE_FASTETHER_FX",            // 69 Fast Ethernet (100BaseFX)
   L"IF_TYPE_CHANNEL",                 // 70
   L"IF_TYPE_IEEE80211",               // 71 Radio spread spectrum
   L"IF_TYPE_IBM370PARCHAN",           // 72 IBM System 360/370 OEMI Channel
   L"IF_TYPE_ESCON",                   // 73 IBM Enterprise Systems Connection
   L"IF_TYPE_DLSW",                    // 74 Data Link Switching
   L"IF_TYPE_ISDN_S",                  // 75 ISDN S/T interface
   L"IF_TYPE_ISDN_U",                  // 76 ISDN U interface
   L"IF_TYPE_LAP_D",                   // 77 Link Access Protocol D
   L"IF_TYPE_IPSWITCH",                // 78 IP Switching Objects
   L"IF_TYPE_RSRB",                    // 79 Remote Source Route Bridging
   L"IF_TYPE_ATM_LOGICAL",             // 80 ATM Logical Port
   L"IF_TYPE_DS0",                     // 81 Digital Signal Level 0
   L"IF_TYPE_DS0_BUNDLE",              // 82 Group of ds0s on the same ds1
   L"IF_TYPE_BSC",                     // 83 Bisynchronous Protocol
   L"IF_TYPE_ASYNC",                   // 84 Asynchronous Protocol
   L"IF_TYPE_CNR",                     // 85 Combat Net Radio
   L"IF_TYPE_ISO88025R_DTR",           // 86 ISO 802.5r DTR
   L"IF_TYPE_EPLRS",                   // 87 Ext Pos Loc Report Sys
   L"IF_TYPE_ARAP",                    // 88 Appletalk Remote Access Protocol
   L"IF_TYPE_PROP_CNLS",               // 89 Proprietary Connectionless Proto
   L"IF_TYPE_HOSTPAD",                 // 90 CCITT-ITU X.29 PAD Protocol
   L"IF_TYPE_TERMPAD",                 // 91 CCITT-ITU X.3 PAD Facility
   L"IF_TYPE_FRAMERELAY_MPI",          // 92 Multiproto Interconnect over FR
   L"IF_TYPE_X213",                    // 93 CCITT-ITU X213
   L"IF_TYPE_ADSL",                    // 94 Asymmetric Digital Subscrbr Loop
   L"IF_TYPE_RADSL",                   // 95 Rate-Adapt Digital Subscrbr Loop
   L"IF_TYPE_SDSL",                    // 96 Symmetric Digital Subscriber Loop
   L"IF_TYPE_VDSL",                    // 97 Very H-Speed Digital Subscrb Loop
   L"IF_TYPE_ISO88025_CRFPRINT",       // 98 ISO 802.5 CRFP
   L"IF_TYPE_MYRINET",                 // 99 Myricom Myrinet
   L"IF_TYPE_VOICE_EM",                // 100 Voice recEive and transMit
   L"IF_TYPE_VOICE_FXO",               // 101 Voice Foreign Exchange Office
   L"IF_TYPE_VOICE_FXS",               // 102 Voice Foreign Exchange Station
   L"IF_TYPE_VOICE_ENCAP",             // 103 Voice encapsulation
   L"IF_TYPE_VOICE_OVERIP",            // 104 Voice over IP encapsulation
   L"IF_TYPE_ATM_DXI",                 // 105 ATM DXI
   L"IF_TYPE_ATM_FUNI",                // 106 ATM FUNI
   L"IF_TYPE_ATM_IMA",                 // 107 ATM IMA
   L"IF_TYPE_PPPMULTILINKBUNDLE",      // 108 PPP Multilink Bundle
   L"IF_TYPE_IPOVER_CDLC",             // 109 IBM ipOverCdlc
   L"IF_TYPE_IPOVER_CLAW",             // 110 IBM Common Link Access to Workstn
   L"IF_TYPE_STACKTOSTACK",            // 111 IBM stackToStack
   L"IF_TYPE_VIRTUALIPADDRESS",        // 112 IBM VIPA
   L"IF_TYPE_MPC",                     // 113 IBM multi-proto channel support
   L"IF_TYPE_IPOVER_ATM",              // 114 IBM ipOverAtm
   L"IF_TYPE_ISO88025_FIBER",          // 115 ISO 802.5j Fiber Token Ring
   L"IF_TYPE_TDLC",                    // 116 IBM twinaxial data link control
   L"IF_TYPE_GIGABITETHERNET",         // 117
   L"IF_TYPE_HDLC",                    // 118
   L"IF_TYPE_LAP_F",                   // 119
   L"IF_TYPE_V37",                     // 120
   L"IF_TYPE_X25_MLP",                 // 121 Multi-Link Protocol
   L"IF_TYPE_X25_HUNTGROUP",           // 122 X.25 Hunt Group
   L"IF_TYPE_TRANSPHDLC",              // 123
   L"IF_TYPE_INTERLEAVE",              // 124 Interleave channel
   L"IF_TYPE_FAST",                    // 125 Fast channel
   L"IF_TYPE_IP",                      // 126 IP (for APPN HPR in IP networks)
   L"IF_TYPE_DOCSCABLE_MACLAYER",      // 127 CATV Mac Layer
   L"IF_TYPE_DOCSCABLE_DOWNSTREAM",    // 128 CATV Downstream interface
   L"IF_TYPE_DOCSCABLE_UPSTREAM",      // 129 CATV Upstream interface
   L"IF_TYPE_A12MPPSWITCH",            // 130 Avalon Parallel Processor
   L"IF_TYPE_TUNNEL",                  // 131 Encapsulation interface
   L"IF_TYPE_COFFEE",                  // 132 Coffee pot
   L"IF_TYPE_CES",                     // 133 Circuit Emulation Service
   L"IF_TYPE_ATM_SUBINTERFACE",        // 134 ATM Sub Interface
   L"IF_TYPE_L2_VLAN",                 // 135 Layer 2 Virtual LAN using 802.1Q
   L"IF_TYPE_L3_IPVLAN",               // 136 Layer 3 Virtual LAN using IP
   L"IF_TYPE_L3_IPXVLAN",              // 137 Layer 3 Virtual LAN using IPX
   L"IF_TYPE_DIGITALPOWERLINE",        // 138 IP over Power Lines
   L"IF_TYPE_MEDIAMAILOVERIP",         // 139 Multimedia Mail over IP
   L"IF_TYPE_DTM",                     // 140 Dynamic syncronous Transfer Mode
   L"IF_TYPE_DCN",                     // 141 Data Communications Network
   L"IF_TYPE_IPFORWARD",               // 142 IP Forwarding Interface
   L"IF_TYPE_MSDSL",                   // 143 Multi-rate Symmetric DSL
   L"IF_TYPE_IEEE1394",                // 144 IEEE1394 High Perf Serial Bus
   L"IF_TYPE_RECEIVE_ONLY",            // 145 TV adapter type
};

// macro that uses the string table above to log the adapter type

#define LOG_ADAPTER_TYPE(type) \
   if (type >= 145 || type <= 0) \
   { \
      LOG(String::format(L"adapterType = %1", adapterTypes[0])); \
   } \
   else \
   { \
      LOG(String::format(L"adapterType = %1", adapterTypes[type-1])); \
   }
      


NetworkInterface::NetworkInterface()
   : initialized(false),
     dhcpEnabled(false),
     dhcpServerAvailable(false),
     index(0)
{
   LOG_CTOR(NetworkInterface);

}


NetworkInterface::~NetworkInterface()
{
   LOG_DTOR(NetworkInterface);

   if (!ipaddresses.empty())
   {
      ipaddresses.clear();
   }

   if (!subnetMasks.empty())
   {
      subnetMasks.clear();
   }
}

NetworkInterface::NetworkInterface(const NetworkInterface &nic)
{
   LOG_CTOR2(NetworkInterface, L"Copy constructor");

   if (this == &nic)
   {
      return;
   }

   name        = nic.name;
   description = nic.description;
   initialized = nic.initialized;
   dhcpEnabled = nic.dhcpEnabled;
   index       = nic.index;

   ipaddressStringList = nic.ipaddressStringList;
   subnetMaskStringList = nic.subnetMaskStringList;
   dnsServerSearchOrder = nic.dnsServerSearchOrder;

   // Make a copy of the ipaddress array

   ipaddresses = nic.ipaddresses;
   subnetMasks = nic.subnetMasks;
}

NetworkInterface&
NetworkInterface::operator=(const NetworkInterface& rhs)
{
   LOG_FUNCTION(NetworkInterface::operator=);

   if (this == &rhs)
   {
      return *this;
   }

   name        = rhs.name;
   description = rhs.description;
   initialized = rhs.initialized;
   dhcpEnabled = rhs.dhcpEnabled;
   index       = rhs.index;

   ipaddressStringList = rhs.ipaddressStringList;
   subnetMaskStringList = rhs.subnetMaskStringList;
   dnsServerSearchOrder = rhs.dnsServerSearchOrder;

   // Make a copy of the ipaddress array

   ipaddresses = rhs.ipaddresses;
   subnetMasks = rhs.subnetMasks;

   return *this;
}

HRESULT
NetworkInterface::Initialize(const IP_ADAPTER_INFO& adapterInfo)
{
   LOG_FUNCTION(NetworkInterface::Initialize);

   HRESULT hr = S_OK;

   do
   {
      if (initialized)
      {
         ASSERT(!initialized);
         hr = E_UNEXPECTED;
      }
      else
      {
         // Get the name

         name = adapterInfo.AdapterName;
         LOG(String::format(
                L"name = %1",
                name.c_str()));

         // the description

         description = adapterInfo.Description;
         LOG(String::format(
                L"description = %1",
                description.c_str()));


         // the type
         
         type = adapterInfo.Type;
         LOG_ADAPTER_TYPE(type);

         // the index

         index = adapterInfo.Index;
         LOG(String::format(
                L"index = %1!d!",
                index));

         // Is DHCP enabled?

         dhcpEnabled = (adapterInfo.DhcpEnabled != 0);
         LOG_BOOL(dhcpEnabled);

         hr = SetIPList(adapterInfo.IpAddressList);
         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to set the IP and subnet mask: hr = 0x%1!x!",
                   hr));
            break;
         }

         // Now retrieve the rest of the info from the registry
         // Note: this has to be done after getting the name from
         // the Adapter Info

         hr = RetrieveAdapterInfoFromRegistry();
         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to retrieve adapter info from registry: hr = 0x%1!x!",
                   hr));
            break;
         }
      } 
   } while (false);

   // If we succeeded in retrieving the data we need,
   // mark the object initialized

   if (SUCCEEDED(hr))
   {
      initialized = true;
   }

   LOG_HRESULT(hr);

   return hr;
}

HRESULT
NetworkInterface::RetrieveAdapterInfoFromRegistry()
{
   LOG_FUNCTION(NetworkInterface::RetrieveAdapterInfoFromRegistry);

   HRESULT hr = S_OK;

   do
   {
      String keyName = CYS_NETWORK_INTERFACES_KEY;
      keyName += String(name);

      RegistryKey key;
      hr = key.Open(
              HKEY_LOCAL_MACHINE,
              keyName,
              KEY_READ);

      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to read the interfaces regkey: hr = 0x%1!x!",
                hr));
         break;
      }

      // Read the NameServer key

      String nameServers;

      hr = key.GetValue(
              CYS_NETWORK_NAME_SERVERS,
              nameServers);
      if (SUCCEEDED(hr))
      {
         LOG(String::format(
                L"nameServers = %1",
                nameServers.c_str()));

         // Adds the name servers to the dnsServerSearchOrder member

         nameServers.tokenize(std::back_inserter(dnsServerSearchOrder));
      }
      else
      {
         LOG(String::format(
                L"Failed to read the NameServer regkey: hr = 0x%1!x!",
                hr));

         // This is not a breaking condition. We still can try the 
         // DhcpNameServer key
      }

      // Read the DhcpNameServer key

      String dhcpNameServers;

      hr = key.GetValue(
              CYS_NETWORK_DHCP_NAME_SERVERS,
              dhcpNameServers);
      if (SUCCEEDED(hr))
      {
         LOG(String::format(
                L"dhcpNameServers = %1",
                dhcpNameServers.c_str()));

         // Adds the name servers to the dnsServerSearchOrder member

         dhcpNameServers.tokenize(std::back_inserter(dnsServerSearchOrder));
      }
      else
      {
         LOG(String::format(
                L"Failed to read the DhcpNameServer regkey: hr = 0x%1!x!",
                hr));
      }

      // It doesn't matter if we were not able to retrieve the name servers
      // These are just used as suggestions for DNS forwarding.

      hr = S_OK;
   } while (false);

   LOG_HRESULT(hr);
   return hr;
}

HRESULT
NetworkInterface::SetIPList(
   const IP_ADDR_STRING& ipList)
{
   LOG_FUNCTION(NetworkInterface::SetIPList);

   HRESULT hr = S_OK;

   // if the list already contains some entries, delete them and start over

   if (!ipaddresses.empty())
   {
      ipaddresses.erase(ipaddresses.begin());
   }

   if (!subnetMasks.empty())
   {
      subnetMasks.erase(subnetMasks.begin());
   }

   const IP_ADDR_STRING* current = &ipList;
   while (current)
   {
      // IP Address - convert and add

      String ipAddress(current->IpAddress.String);
      
      DWORD newAddress = StringToIPAddress(ipAddress);
      ASSERT(newAddress != INADDR_NONE);

      // StringToIPAddress returns an address of 1.2.3.4 as 04030201.  The UI
      // controls return the same address as 01020304.  So to make
      // things consistent convert to the UI way

      ipaddresses.push_back(ConvertIPAddressOrder(newAddress));

      // also add it to the string list

      ipaddressStringList.push_back(ipAddress);

      LOG(String::format(
             L"Adding address: %1",
             ipAddress.c_str()));


      // Subnet Mask - convert and add

      String subnetMask(current->IpMask.String);
      
      DWORD newMask = StringToIPAddress(subnetMask);

      // NTBUG#NTRAID-561163-2002/03/19-JeffJon
      // Do not assert the subnet mask is not INADDR_NONE because
      // if there is an RRAS connection then the subnet mask may be
      // 255.255.255.255 which is the same as INADDR_NONE. The appropriate
      // fix would be to use WSAStringToAddress inside StringToIPAddress
      // but that would require rearchitecting all of CYS since IP addresses
      // have a different structure for use to with that API
      // ASSERT(newMask != INADDR_NONE);

      // StringToIPAddress returns an address of 1.2.3.4 as 04030201.  The UI
      // controls return the same address as 01020304.  So to make
      // things consistent convert to the UI way

      subnetMasks.push_back(ConvertIPAddressOrder(newMask));

      // also add it to the string list

      subnetMaskStringList.push_back(subnetMask);

      LOG(String::format(
             L"Adding subnet: %1",
             subnetMask.c_str()));


      current = current->Next;
   }

   LOG_HRESULT(hr);

   return hr;
}

DWORD
NetworkInterface::GetIPAddress(DWORD addressIndex) const
{
   LOG_FUNCTION2(
      NetworkInterface::GetIPAddress,
      String::format(
         L"%1!d!",
         addressIndex));

   ASSERT(initialized);

   DWORD result = 0;
   if (addressIndex < ipaddresses.size())
   {
      result = ipaddresses[addressIndex];
   }
   
   LOG(IPAddressToString(result));
   return result;
}

String
NetworkInterface::GetStringIPAddress(DWORD addressIndex) const
{
   LOG_FUNCTION2(
      NetworkInterface::GetStringIPAddress,
      String::format(L"%1!d!", addressIndex));

   ASSERT(addressIndex < ipaddressStringList.size());

   String result;

   if (addressIndex < ipaddressStringList.size())
   {
      result = ipaddressStringList[addressIndex];
   }

   LOG(result);
   return result;
}

DWORD
NetworkInterface::GetSubnetMask(DWORD addressIndex) const
{
   LOG_FUNCTION2(
      NetworkInterface::GetSubnetMask,
      String::format(
         L"%1!d!",
         addressIndex));

   ASSERT(initialized);

   DWORD result = 0;
   if (addressIndex < subnetMasks.size())
   {
      result = subnetMasks[addressIndex];
   }

   LOG(IPAddressToString(result));
   return result;
}

String
NetworkInterface::GetStringSubnetMask(DWORD addressIndex) const
{
   LOG_FUNCTION2(
      NetworkInterface::GetStringSubnetMask,
      String::format(L"%1!d!", addressIndex));

   ASSERT(addressIndex < subnetMaskStringList.size());

   String result;
   if (addressIndex < subnetMaskStringList.size())
   {
      result = subnetMaskStringList[addressIndex];
   }

   LOG(result);
   return result;
}

String
NetworkInterface::GetName() const
{
   LOG_FUNCTION(NetworkInterface::GetName);

   ASSERT(initialized);

   LOG(name);
   return name;
}

String
NetworkInterface::GetFriendlyName(
   const String defaultName) const
{
   LOG_FUNCTION(NetworkInterface::GetFriendlyName);

   DWORD dwRet = 0;
   HANDLE hMprConfig = 0;

   static const unsigned friendlyNameLength = 128;
   wchar_t wszFriendlyName[friendlyNameLength];
   ZeroMemory(wszFriendlyName, sizeof(wchar_t) * friendlyNameLength);

   String result;

   String guidName = GetName();
   
   dwRet = MprConfigServerConnect(0, &hMprConfig);
   if (NO_ERROR == dwRet)
   {
      dwRet =
         MprConfigGetFriendlyName(
            hMprConfig,
            const_cast<wchar_t*>(guidName.c_str()), 
            wszFriendlyName,
            sizeof(wchar_t) * friendlyNameLength);
      if (NO_ERROR != dwRet)
      {
         LOG(String::format(
                L"MprConfigGetFriendlyName() failed: error = %1!x!",
                dwRet));
         *wszFriendlyName = 0;
      }
      else
      {
         LOG(String::format(
                L"MprConfigGetFriendlyName() failed: error = 0x%1!x!",
                dwRet));
      }
   }
   else
   {
      LOG(String::format(
             L"MprConfigServerConnect() failed: error = 0x%1!x!",
             dwRet));
   }

   MprConfigServerDisconnect(hMprConfig);

   if (!*wszFriendlyName)
   {
      // we failed to get a friendly name, so use the default one

      result = defaultName;
   }
   else
   {
      result = wszFriendlyName;
   }

   LOG(result);

   return result;
}

HRESULT
NetworkInterface::GetNameAsGUID(GUID& guid) const
{
   LOG_FUNCTION(NetworkInterface::GetNameAsGUID);

   ASSERT(initialized);

   LPOLESTR oleString = 0;
   HRESULT hr = name.as_OLESTR(oleString);
   if (SUCCEEDED(hr))
   {
      hr = ::CLSIDFromString(
              oleString,
              &guid);
      ASSERT(SUCCEEDED(hr));

      ::CoTaskMemFree(oleString);
   }

   LOG_HRESULT(hr);
   return hr;
}

String
NetworkInterface::GetDescription() const
{
   LOG_FUNCTION(NetworkInterface::GetDescription);

   ASSERT(initialized);

   LOG(description);
   return description;
}

UINT
NetworkInterface::GetType() const
{
   LOG_FUNCTION(NetworkInterface::GetType);

   UINT result = type;
   LOG_ADAPTER_TYPE(result);
   return result;
}

DWORD
NetworkInterface::GetIndex() const
{
   LOG_FUNCTION(NetworkInterface::GetIndex);

   DWORD result = index;
   LOG(String::format(L"index = %1!d!", result));
   return result;
}


void
NetworkInterface::SetIPAddress(DWORD address, String addressString)
{
   LOG_FUNCTION2(
      NetworkInterface::SetIPAddress,
      addressString);

   DWORD newIPAddress = ConvertIPAddressOrder(address);

   LOG(IPAddressToString(newIPAddress));

   // Clear out the old values

   if (!ipaddresses.empty())
   {
      ipaddresses.clear();
   }

   if (!ipaddressStringList.empty())
   {
      ipaddressStringList.clear();
   }

   // Now add the new values

   ipaddresses.push_back(newIPAddress);
   ipaddressStringList.push_back(addressString);
}

void
NetworkInterface::SetSubnetMask(DWORD address, String addressString)
{
   LOG_FUNCTION2(
      NetworkInterface::SetSubnetMask,
      addressString);

   LOG(IPAddressToString(address));

   // Clear out the old values

   if (!subnetMasks.empty())
   {
      subnetMasks.clear();
   }

   if (!subnetMaskStringList.empty())
   {
      subnetMaskStringList.clear();
   }

   // Now add the new values

   subnetMasks.push_back(address);
   subnetMaskStringList.push_back(addressString);
}


String
NetworkInterface::GetDNSServerString(DWORD index)
{
   LOG_FUNCTION2(
      NetworkInterface::GetDNSServerString,
      String::format(
         L"%1!d!",
         index));

   String dnsServer;

   if (dnsServerSearchOrder.empty())
   {
   }

   if (index < dnsServerSearchOrder.size())
   {
      dnsServer = dnsServerSearchOrder[index];
   }
   else
   {
      LOG(String::format(
             L"Index to large for dnsServerSearchOrder vector: index = %1!d!, size = %2!d!",
             index,
             dnsServerSearchOrder.size()));
   }

   LOG(dnsServer);
   return dnsServer;
}

void
NetworkInterface::GetDNSServers(IPAddressList& servers)
{
   LOG_FUNCTION(NetworkInterface::GetDNSServers);

   // Note: this will read the values from WMI if they
   //       haven't already been retrieved

   String server = GetDNSServerString(0);

   if (!dnsServerSearchOrder.empty())
   {
      for (StringVector::iterator itr = dnsServerSearchOrder.begin();
           itr != dnsServerSearchOrder.end();
           ++itr)
      {
         server = *itr;

         if (!server.empty())
         {
            DWORD newAddress = StringToIPAddress(server);

            if (newAddress != INADDR_NONE)
            {
               // Don't add the current IP address of this server
               
               DWORD newInorderAddress = ConvertIPAddressOrder(newAddress);
               if (newInorderAddress != GetIPAddress(0))
               {
                  LOG(String::format(
                           L"Adding server: %1",
                           IPAddressToString(newInorderAddress).c_str()));

                  servers.push_back(newInorderAddress);
               }
            }
         }
      }
   }
}

bool
NetworkInterface::IsDHCPAvailable() const
{
   LOG_FUNCTION(NetworkInterface::IsDHCPAvailable);

   LOG_BOOL(dhcpServerAvailable);
   return dhcpServerAvailable;
}

bool
NetworkInterface::CanDetectDHCPServer()
{
   LOG_FUNCTION(NetworkInterface::CanDetectDHCPServer);

   bool result = false;

   do
   {
      if (!IsConnected())
      {
         // Since the NIC isn't connected there
         // is no reason to make the check

         break;
      }

      ULONG serverIPAddress = 0;

      DWORD interfaceIPAddress = 
         ConvertIPAddressOrder(GetIPAddress(0));

      // This will perform a DHCP_INFORM to try
      // to detect the DHCP server, if that fails
      // it will attemp a DHCP_DISCOVER to attempt
      // to detect the DHCP server.

      DWORD error =
         AnyDHCPServerRunning(
            interfaceIPAddress,
            &serverIPAddress);

      if (error == ERROR_SUCCESS)
      {
         // DHCP server found

         result = true;

         LOG(
            String::format(
               L"DHCP server found at the following IP: %1",
               IPAddressToString(
                  ConvertIPAddressOrder(serverIPAddress)).c_str()));
      }
      else
      {
         LOG(
            String::format(
               L"DHCP server not found: error = 0x%1!x!",
               error));
      }
   } while (false);

   dhcpServerAvailable = result;
   LOG_BOOL(result);
   return result;
}

bool
NetworkInterface::IsConnected() const
{
   LOG_FUNCTION(NetworkInterface::IsConnected);

   bool result = true;

   do
   {
      // Convert the name to a GUID

      GUID guid;
      ZeroMemory(&guid, sizeof(GUID));

      HRESULT hr = GetNameAsGUID(guid);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to get name as guid: hr = 0x%1!x!",
                hr));

         result = false;
         break;
      }

      // Different adapter types require different
      // ways of detecting connection state

      if (IsModem())
      {
         // We only know about modems if they are connected

         result = true;
      }
      else
      {
         result = IsStandardAdapterConnected(guid);
      }

   } while(false);

   LOG_BOOL(result);
   return result;
}

bool
NetworkInterface::IsStandardAdapterConnected(const GUID& guid) const
{
   LOG_FUNCTION(NetworkInterface::IsStandardAdapterConnected);

   bool result = true;

   do
   {
      // Now get the status using the GUID

      NETCON_STATUS status = NCS_CONNECTED;
      HRESULT hr = HrGetPnpDeviceStatus(&guid, &status);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to get device status: hr = 0x%1!x!",
                hr));
         
         result = false;
         break;
      }

      // The status values are defined in netcon.h

      LOG(String::format(
             L"Device status = %1!d!",
             status));

      if (status == NCS_DISCONNECTED ||
          status == NCS_DISCONNECTING ||
          status == NCS_HARDWARE_NOT_PRESENT ||
          status == NCS_HARDWARE_DISABLED ||
          status == NCS_HARDWARE_MALFUNCTION ||
          status == NCS_MEDIA_DISCONNECTED)
      {
         result = false;
      }
   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
NetworkInterface::IsModem() const
{
   LOG_FUNCTION(NetworkInterface::IsModem);

   bool isModem = false;

   switch (GetType())
   {
      case IF_TYPE_PPP:
         isModem = true;
         break;

      default:
         isModem = false;
   }

   LOG_BOOL(isModem);

   return isModem;
}


DWORD
NetworkInterface::GetNextAvailableIPAddress(
   DWORD startAddress, 
   DWORD subnetMask)
{
   LOG_FUNCTION2(
      NetworkInterface::GetNextAvailableIPAddress,
      IPAddressToString(startAddress));

   DWORD result = startAddress;
   DWORD currentAddress = startAddress;

   bool isIPInUse = false;

   do
   {
      isIPInUse = 
         IsIPAddressInUse(
            currentAddress,
            subnetMask);

      if (!isIPInUse)
      {
         break;
      }

      ++currentAddress;

      if ((currentAddress & subnetMask) != (startAddress & subnetMask))
      {
         // REVIEW_JEFFJON : what should the behavior be if there are
         // no available addresses?  Is this likely to happen?

         // Since we couldn't find an available address in this subnet
         // use the start address

         currentAddress = startAddress;
         break;
      }
   } while (isIPInUse);

   result = currentAddress;

   LOG(IPAddressToString(result));

   return result;
}


bool
NetworkInterface::IsIPAddressInUse(
   DWORD ipaddress,
   DWORD subnetMask)
{
   LOG_FUNCTION2(
      NetworkInterface::IsIPAddressInUse,
      IPAddressToString(ipaddress));

   bool result = false;

   do
   {
      if (!IsConnected())
      {
         break;
      }

      // Before calling SendARP we have to set a route
      // on the interface for the subnet we are interested
      // in so that SendARP will work even if the interface
      // IP address is completely different than the IP 
      // address we are looking for.

      SetRoute(
         ipaddress,
         subnetMask);

      // Use the interface IP address to tell TCP which interface
      // to send the ARP on

      DWORD interfaceIPAddress = GetIPAddress(0);

      if (interfaceIPAddress == ipaddress)
      {
         // If the IP address is in use by the NIC then
         // of course it is in use on the network

         result = true;

         break;
      }

	  // MSDN doesn't mention whether or not the buffer needs to be
	  // there but it appears that SendArp() is now failing if we
	  // don't pass it a buffer even though we ignore the macAddress.
	  // The size was taken from the example in MSDN.

      ULONG macAddress[2];
      ULONG macLength = sizeof(macAddress);

	  memset(macAddress, 0xff, macLength);

      DWORD error =
         SendARP(
            ConvertIPAddressOrder(ipaddress),
            ConvertIPAddressOrder(interfaceIPAddress),
            macAddress,
            &macLength);

      LOG(
         String::format(
            L"SendARP returned: error = 0x%1!x!",
            error));

      if (error == NO_ERROR)
      {
         result = true;
      }

      // Now that we are done with the SendARP
      // remove the route so that the TCP stack
      // reverts to normal behavior

      RemoveRoute(
         ipaddress,
         subnetMask);

   } while (false);

   LOG_BOOL(result);

   return result;
}

void
NetworkInterface::SetRoute(
   DWORD ipaddress,
   DWORD subnetMask)
{
   LOG_FUNCTION2(
      NetworkInterface::SetRoute,
      IPAddressToString(ipaddress));

   LOG(
      String::format(
         L"subnetMask = %1",
         IPAddressToString(subnetMask).c_str()));

   MIB_IPFORWARDROW routerTableEntry;
   ZeroMemory(&routerTableEntry, sizeof(MIB_IPFORWARDROW));

   // Destination

   routerTableEntry.dwForwardDest = 
      ConvertIPAddressOrder(ipaddress) & ConvertIPAddressOrder(subnetMask);

   LOG(
      String::format(
         L"dwForwardDest = %1",
         IPAddressToString(ipaddress & subnetMask).c_str()));

   // net mask

   routerTableEntry.dwForwardMask = ConvertIPAddressOrder(subnetMask);

   LOG(
      String::format(
         L"dwForwardMask = %1",
         IPAddressToString(subnetMask).c_str()));

   // Interface index

   routerTableEntry.dwForwardIfIndex = GetIndex();

   LOG(
      String::format(
         L"dwForwardIfIndex = %1!d!",
         GetIndex()));

   // Gateway

   routerTableEntry.dwForwardNextHop = ConvertIPAddressOrder(GetIPAddress(0));

   LOG(
      String::format(
         L"dwForwardNextHop = %1",
         IPAddressToString(GetIPAddress(0)).c_str()));

   // Protocol generator (must be PROTO_IP_NETMGMT according to MSDN)

   routerTableEntry.dwForwardProto = PROTO_IP_NETMGMT;

   // Taking these from %sdxroot%\net\rras\cm\customactions\cmroute\cmroute.cpp
   // since I can't get the API to succeed without them

   routerTableEntry.dwForwardType    = 3;
   routerTableEntry.dwForwardAge     = INFINITE;
   routerTableEntry.dwForwardMetric1 = 1;
   routerTableEntry.dwForwardMetric2 = 0xFFFFFFFF;
   routerTableEntry.dwForwardMetric3 = 0xFFFFFFFF;
   routerTableEntry.dwForwardMetric4 = 0xFFFFFFFF;
   routerTableEntry.dwForwardMetric5 = 0xFFFFFFFF;
   
   // Create the table entry
   // NTRAID#NTBUG9-667088-2002/09/25-JeffJon
   // Do not use CreateIpForwardEntry here because if
   // RRAS is running the call will become asynchronous
   // and the route may not be in the table by the time
   // we call SendARP()

   DWORD error =
      SetIpForwardEntryToStack(&routerTableEntry);

   if (error != NO_ERROR)
   {
      LOG(
         String::format(
            L"SetIpForwardEntryToStack failed: error = 0x%1!x!",
            error));
   }
}

void
NetworkInterface::RemoveRoute(
   DWORD ipaddress,
   DWORD subnetMask)
{
   LOG_FUNCTION2(
      NetworkInterface::RemoveRoute,
      IPAddressToString(ipaddress));

   LOG(
      String::format(
         L"subnetMask = %1",
         IPAddressToString(subnetMask).c_str()));

   MIB_IPFORWARDROW routerTableEntry;
   ZeroMemory(&routerTableEntry, sizeof(MIB_IPFORWARDROW));

   // Destination

   routerTableEntry.dwForwardDest = 
      ConvertIPAddressOrder(ipaddress) & ConvertIPAddressOrder(subnetMask);

   LOG(
      String::format(
         L"dwForwardDest = %1",
         IPAddressToString(ipaddress & subnetMask).c_str()));

   // net mask

   routerTableEntry.dwForwardMask = ConvertIPAddressOrder(subnetMask);

   LOG(
      String::format(
         L"dwForwardMask = %1",
         IPAddressToString(subnetMask).c_str()));

   // Interface index

   routerTableEntry.dwForwardIfIndex = GetIndex();

   LOG(
      String::format(
         L"dwForwardIfIndex = %1!d!",
         GetIndex()));

   // Gateway

   routerTableEntry.dwForwardNextHop = ConvertIPAddressOrder(GetIPAddress(0));

   LOG(
      String::format(
         L"dwForwardNextHop = %1",
         IPAddressToString(GetIPAddress(0)).c_str()));

   // Delete the table entry

   DWORD error =
      DeleteIpForwardEntry(&routerTableEntry);

   if (error != NO_ERROR)
   {
      LOG(
         String::format(
            L"DeleteIpForwardEntry failed: error = 0x%1!x!",
            error));
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\lib\networkadapterconfig.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      NetworkAdapterConfig.cpp
//
// Synopsis:  Defines a NetworkAdapterConfig
//            This object has the knowledge for installing 
//            using WMI to retrieve network adapter information
//
// History:   02/16/2001  JeffJon Created


#include "pch.h"

#include "NetworkAdapterConfig.h"
#include "NetworkInterface.h"

      
NetworkAdapterConfig::NetworkAdapterConfig() :
   initialized(false),
   nicCount(0),
   localNICIndex(-1)
{
   LOG_CTOR(NetworkAdapterConfig);
}


NetworkAdapterConfig::~NetworkAdapterConfig()
{
   LOG_DTOR(NetworkAdapterConfig);

   // Free all the NIC info from the vector and reset the count

   for (NetworkInterfaceContainer::iterator itr = networkInterfaceContainer.begin();
        itr != networkInterfaceContainer.end();
        ++itr)
   {
      if (*itr)
      {
         delete *itr;
      }
   }
   networkInterfaceContainer.erase(
      networkInterfaceContainer.begin(),
      networkInterfaceContainer.end());

   nicCount = 0;
   localNICIndex = 0;
}


HRESULT
NetworkAdapterConfig::Initialize()
{
   LOG_FUNCTION(NetworkAdapterConfig::Initialize);

   HRESULT hr = S_OK;

   PIP_ADAPTER_INFO pInfo = 0;
   do
   {
      DWORD status = 0;
      ULONG size = 0;

      while (1)
      {
         status = ::GetAdaptersInfo(pInfo, &size);
         if (ERROR_BUFFER_OVERFLOW != status)
         {
            hr = HRESULT_FROM_WIN32(status);
            break;
         }

         if (pInfo)
         {
            Win::LocalFree(pInfo);
            pInfo = 0;
         }
         if (0 == size)
         {
            hr = E_FAIL;
            LOG_HRESULT(hr);
            return hr;
         }

         pInfo = (PIP_ADAPTER_INFO) ::LocalAlloc(LPTR, size);
         if ( NULL == pInfo )
         {
            hr = E_OUTOFMEMORY;
            LOG_HRESULT(hr);
            return hr;
         }
      }

      PIP_ADAPTER_INFO current = pInfo;
      while (current)
      {

         // Create a new network interface based on the adapter info

         NetworkInterface* newInterface = new NetworkInterface();
         if (!newInterface)
         {
            LOG(L"Failed to create new interface object");
            
            current = current->Next;
            continue;
         }

         hr = newInterface->Initialize(*current);
         if (FAILED(hr))
         {
            LOG(String::format(
                   L"Failed to initialize network interface: hr = 0x%1!x!",
                   hr));

            delete newInterface;

            current = current->Next;
            continue;
         }

         // Add the new interface to the embedded container
         
         AddInterface(newInterface);

         current = current->Next;
      }

   } while (false);

   if (pInfo)
   {
      HRESULT unused = Win::LocalFree(pInfo);
      ASSERT(SUCCEEDED(unused));
   }

   if (SUCCEEDED(hr))
   {
      initialized = true;
   }

   LOG_HRESULT(hr);

   return hr;
}


void
NetworkAdapterConfig::AddInterface(NetworkInterface* newInterface)
{
   LOG_FUNCTION(NetworkAdapterConfig::AddInterface);

   do
   {
      // verify parameters

      if (!newInterface)
      {
         ASSERT(newInterface);
         break;
      }

      // Add the new NIC to the container and increment the count

      networkInterfaceContainer.push_back(newInterface);
      ++nicCount;

   } while (false);
}


unsigned int
NetworkAdapterConfig::GetNICCount() const
{
   LOG_FUNCTION(NetworkAdapterConfig::GetNICCount);

   ASSERT(IsInitialized());

   LOG(String::format(
          L"nicCount = %1!d!",
          nicCount));

   return nicCount;
}

NetworkInterface*
NetworkAdapterConfig::GetNIC(unsigned int nicIndex)
{
   LOG_FUNCTION2(
      NetworkAdapterConfig::GetNIC,
      String::format(
         L"%1!d!",
         nicIndex));

   ASSERT(IsInitialized());

   NetworkInterface* nic = 0;
   
   if (nicIndex < GetNICCount())
   {
      nic = networkInterfaceContainer[nicIndex];
   }
      
   if (!nic)
   {
      LOG(L"Unable to find NIC");
   }

   return nic;
}

unsigned int
NetworkAdapterConfig::FindNIC(const String& guid, bool& found) const
{
   LOG_FUNCTION2(
      NetworkAdapterConfig::FindNIC,
      guid.c_str());

   unsigned int result = 0;
   found = false;

   for (unsigned int index = 0;
        index < networkInterfaceContainer.size();
        ++index)
   {
      String name = networkInterfaceContainer[index]->GetName();
      if (name.icompare(guid) == 0)
      {
         found = true;
         result = index;
         break;
      }
   }

   LOG(String::format(
          L"result = %1!d!",
          result));
   return result;
}

NetworkInterface*
NetworkAdapterConfig::GetNICFromName(const String& name, bool& found)
{
   LOG_FUNCTION2(
      NetworkAdapterConfig::GetNICFromName,
      name.c_str());

   found = false;

   // Default to the first NIC if a match is not found

   NetworkInterface* nic = networkInterfaceContainer[FindNIC(name, found)];

   if (!nic ||
       !found)
   {
      LOG(L"NIC not found");
   }
   return nic;
}

void
NetworkAdapterConfig::SetLocalNIC(
   const NetworkInterface& nic,
   bool setInRegistry)
{
   LOG_FUNCTION(NetworkAdapterConfig::SetLocalNIC);
   LOG_BOOL(setInRegistry);

   SetLocalNIC(nic.GetName(), setInRegistry);
}

void
NetworkAdapterConfig::SetLocalNIC(
   String guid,
   bool setInRegistry)
{
   LOG_FUNCTION2(
      NetworkAdapterConfig::SetLocalNIC,
      guid.c_str());
   LOG_BOOL(setInRegistry);

   bool found = false;
   localNICIndex = FindNIC(guid, found);

   if (found && setInRegistry)
   {
      ASSERT(networkInterfaceContainer[localNICIndex]);
      SetLocalNICInRegistry(*networkInterfaceContainer[localNICIndex]);
   }
}

void
NetworkAdapterConfig::SetLocalNICInRegistry(const NetworkInterface& nic)
{
   LOG_FUNCTION2(
      NetworkAdapterConfig::SetLocalNICInRegistry,
      nic.GetName());

   // Write the GUID into a regkey so that it can be retrieved
   // after reboot
   
   if (!SetRegKeyValue(
           CYS_FIRST_DC_REGKEY,
           CYS_FIRST_DC_LOCAL_NIC,
           nic.GetName(),
           HKEY_LOCAL_MACHINE,
           true))
   {
      LOG(L"Failed to set local NIC regkey");
   }
}

NetworkInterface*
NetworkAdapterConfig::GetLocalNIC()
{
   LOG_FUNCTION(NetworkAdapterConfig::GetLocalNIC);

   NetworkInterface* nic = 0;
   
   if (localNICIndex >= 0)
   {
      nic = networkInterfaceContainer[localNICIndex];
   }
   else
   {
      // Since the local NIC hasn't been set, we will
      // use the first connected NIC in the list for which 
      // we failed to obtain an IP lease 

      for (unsigned int index = 0;
           index < networkInterfaceContainer.size();
           ++index)
      {
         nic = networkInterfaceContainer[index];
         if (nic &&
             nic->IsConnected() &&
             !nic->IsDHCPAvailable())
         {
            break;
         }
      }

      if (nic)
      {
         SetLocalNIC(*nic, true);
      }
   }

   return nic;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\lib\sources.inc ===
# CYS/MYS shared library
#
# Copyright (c) 2002 Microsoft Corporation
#
# 01-22-2002 jeffjon


CYSLIB_BASE_NAME=cyslib
TARGETPATH=$(PROJECT_ROOT)\cys\lib\$(_OBJ_DIR)
TARGETLIBPATH=$(PROJECT_ROOT)\cys\lib\$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows
	
C_DEFINES=$(C_DEFINES) -DWIN32 -DWINNT -DUNICODE -D_UNICODE -DWORD97_STYLE -DISOLATION_AWARE_ENABLED

INCLUDES= ..\; \
          ..\..\inc;                    \
          $(PROJECT_ROOT)\burnslib\inc; \
          $(DS_INC_PATH);               \
          $(ENDUSER_INC_PATH);          \
          $(NET_INC_PATH);              \
          $(SHELL_INC_PATH);           
          

# required for C++ exceptions
USE_NATIVE_EH=1

# required for thread-safe heap
USE_MSVCRT=1

# required to support dynamic_cast
USE_RTTI=1

# required for STL (list, vector, string, etc.)
USE_STL=1

USE_PDB=1

PRECOMPILED_INCLUDE=..\pch.h
PRECOMPILED_CXX=1


MSC_WARNING_LEVEL=/W4

SOURCES=\
    ..\common.cpp               \
    ..\init.cpp                 \
    ..\isdhcp.c                 \
    ..\IsDhcpConfigured.cpp     \
    ..\NetworkAdapterConfig.cpp \
    ..\NetworkInterface.cpp     \
    ..\RoleStatus.cpp           \
    ..\state.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\makefile.inc ===
.SUFFIXES : .xml

{res}.xml{$(O)\}.unicode:
	unitext -m -z -a $** $@


#	for /f "usebackq" %i in (`dir /b *.xml`) do unitext -m -z -a %i %~ni.unicode.xml
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\lib\state.cpp ===
// Copyright (c) 2001 Microsoft Corporation
//
// File:      state.cpp
//
// Synopsis:  Defines the state object that is global
//            to CYS.  It holds the network and OS/SKU info
//
// History:   02/02/2001  JeffJon Created

#include "pch.h"

#include "state.h"
#include "cys.h"

static State* stateInstance = 0;


State::State() :
   dhcpServerAvailableOnAllNics(true),
   dhcpAvailabilityRetrieved(false),
   hasStateBeenRetrieved(false),
   rerunWizard(true),
   isRebootScenario(false),
   productSKU(CYS_SERVER),
   hasNTFSDrive(false),
   localComputer(),
   computerName(),
   domainDNSName(),
   domainNetbiosName(),
   wizardStartPage(0)
{
   LOG_CTOR(State);
   
   HRESULT unused = localComputer.Refresh();
   ASSERT(SUCCEEDED(unused));

   RetrievePlatform();
}


void
State::Destroy()
{
   LOG_FUNCTION(State::Destroy);

   if (stateInstance)
   {
      delete stateInstance;
      stateInstance = 0;
   }
}


State&
State::GetInstance()
{
   if (!stateInstance)
   {
      stateInstance = new State();
   }

   ASSERT(stateInstance);

   return *stateInstance;
}

bool
State::IsRemoteSession() const
{
   LOG_FUNCTION(State::IsRemoteSession);

   bool result = 
      Win::GetSystemMetrics(SM_REMOTESESSION)    ?
         true : false;

   LOG_BOOL(result);

   return result;
}

bool
State::IsWindowsSetupRunning() const
{
   LOG_FUNCTION(State::IsWindowsSetupRunning);

   bool result = false;

   // Try to create a mutex for the default
   // sysoc inf file. If it already exists
   // then we know SYSOCMGR is running

   static const String mutexName = L"Global\\sysoc";

   HANDLE mutexHandle = INVALID_HANDLE_VALUE;

   HRESULT hr = 
      Win::CreateMutex(
         0, 
         true, 
         mutexName, 
         mutexHandle);

   if (hr == Win32ToHresult(ERROR_ALREADY_EXISTS))
   {
      // SysOCMGR is running

      result = true;
   }


   if (mutexHandle != INVALID_HANDLE_VALUE)
   {
      // Close the handle

      Win::CloseHandle(mutexHandle);
   }

   LOG_BOOL(result);

   return result;
}

bool
State::IsDC() const
{
   LOG_FUNCTION(State::IsDC);

   bool result = localComputer.IsDomainController();

   LOG_BOOL(result);

   return result;
}

bool
State::IsDCPromoRunning() const
{
   LOG_FUNCTION(State::IsDCPromoRunning);

   // Uses the IsDcpromoRunning from Burnslib

   bool result = IsDcpromoRunning();

   LOG_BOOL(result);

   return result;
}

bool
State::IsDCPromoPendingReboot() const
{
   LOG_FUNCTION(State::IsDCPromoPendingReboot);

   bool result = false;

   do
   {
      // Uses the IsDcpromoRunning from Burnslib

      if (!IsDcpromoRunning())
      {
         // this test is redundant if dcpromo is running, so only
         // perform it when dcpromo is not running.

         DSROLE_OPERATION_STATE_INFO* info = 0;
         HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
         if (SUCCEEDED(hr) && info)
         {
            if (info->OperationState == DsRoleOperationNeedReboot)
            {
               result = true;
            }

            ::DsRoleFreeMemory(info);
         }
      }

   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
State::IsJoinedToDomain() const
{
   LOG_FUNCTION(State::IsJoinedToDomain);

   bool result = localComputer.IsJoinedToDomain();

   LOG_BOOL(result);

   return result;
}

bool
State::IsUpgradeState() const
{
   LOG_FUNCTION(State::IsUpgradeState);

   bool result = false;

   do
   {
      DSROLE_UPGRADE_STATUS_INFO* info = 0;
      HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"MyDsRoleGetPrimaryDomainInformation(0): hr = 0x%1!x!",
                hr));

         break;
      }

      if (info && info->OperationState == DSROLE_UPGRADE_IN_PROGRESS)
      {
         result = true;
      }

      ::DsRoleFreeMemory(info);
   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
State::IsFirstDC() const
{
   LOG_FUNCTION(State::IsFirstDC);

   DWORD value = 0;
   bool result = GetRegKeyValue(CYS_FIRST_DC_REGKEY, CYS_FIRST_DC_VALUE, value);
   
   if (value != 1)
   {
      result = false;
   }

   LOG_BOOL(result);

   return result;
}

unsigned int 
State::GetNICCount() const 
{ 
   return adapterConfiguration.GetNICCount(); 
}

unsigned int
State::GetNonModemNICCount()
{
   unsigned int result = 0;

   for (
      unsigned int index = 0;
      index < GetNICCount();
      ++index)
   {
      NetworkInterface* nic = GetNIC(index);

      if (nic &&
          !nic->IsModem())
      {
         ++result;
      }
   }

   LOG(
      String::format(
         L"Non-modem NIC count: %1!d!",
         result));

   return result;
}

NetworkInterface*
State::GetNIC(unsigned int nicIndex)
{
   LOG_FUNCTION2(
      State::GetNIC,
      String::format(
         L"%1!d!",
         nicIndex));

   return adapterConfiguration.GetNIC(nicIndex);
}

NetworkInterface*
State::GetNICFromName(const String& name, bool& found)
{
   LOG_FUNCTION2(
      State::GetNICFromName,
      name.c_str());

   return adapterConfiguration.GetNICFromName(name, found);
}

NetworkInterface*
State::GetLocalNICFromRegistry()
{
   LOG_FUNCTION(State::GetLocalNICFromRegistry);

   // Read the local NIC GUID from the registry

   String nicName;
   NetworkInterface* nic = 0;

   if (!GetRegKeyValue(
           CYS_FIRST_DC_REGKEY,
           CYS_FIRST_DC_LOCAL_NIC,
           nicName))
   {
      LOG(L"Failed to read LocalNIC regkey, using default local NIC");

      nic = State::GetInstance().GetLocalNIC();

      if (nic)
      {
         nicName = nic->GetName();
      }
   }
           
   SetLocalNIC(nicName, false);

   if (!nic)
   {
      nic = GetLocalNIC();
   }
   return nic;
}

bool
State::RetrieveMachineConfigurationInformation(
   HWND progressStatic,
   bool doDHCPCheck,
   int  nicInfoResID,
   int  osInfoResID,
   int  defaultConnectionResID,
   int  detectSettingsResID)
{
   LOG_FUNCTION(State::RetrieveMachineConfigurationInformation);

   ASSERT(!hasStateBeenRetrieved);

   // This is used to get the minimal information needed to 
   // determine if we should enable the express path
   // This should probably just be changed to gather the 
   // information and let the page decide what to do

   if (progressStatic)
   {
      Win::SetWindowText(
         progressStatic,
         String::load(nicInfoResID));
   }

   HRESULT hr = RetrieveNICInformation();
   if (SUCCEEDED(hr))
   {

      // Only bother to check for a DHCP server on the network if we are not
      // a DC, not a DNS server, not a DHCP server and have at least one NIC.  
      // Right now we only use this info for determining whether or not to 
      // show the Express path option

      if (!(IsDC() || IsUpgradeState()) &&
          (GetNICCount() > 0) &&
          doDHCPCheck)
      {
         CheckDhcpServer(
            progressStatic, 
            defaultConnectionResID,
            detectSettingsResID);
      }
   }

   if (progressStatic)
   {
      Win::SetWindowText(
         progressStatic,
         String::load(osInfoResID));
   }

   RetrieveProductSKU();
   RetrievePlatform();

   // Retrieve the drive information (quotas enabled, partition types, etc.)

   RetrieveDriveInformation();

   hasStateBeenRetrieved = true;
   return true;
}

DWORD
State::RetrieveProductSKU()
{
   LOG_FUNCTION(State::RetrieveProductSKU);

   // I am making the assumption that we are on a 
   // Server SKU if GetVersionEx fails

   productSKU = CYS_UNSUPPORTED_SKU;

   OSVERSIONINFOEX info;
   HRESULT hr = Win::GetVersionEx(info);
   if (SUCCEEDED(hr))
   {
      LOG(String::format(
             L"wSuiteMask = 0x%1!x!",
             info.wSuiteMask));
      LOG(String::format(
             L"wProductType = 0x%1!x!",
             info.wProductType));

      do
      {
         if (info.wProductType == VER_NT_SERVER ||
             info.wProductType == VER_NT_DOMAIN_CONTROLLER)
         {

            if (info.wSuiteMask & VER_SUITE_DATACENTER)
            {
               // datacenter
      
               productSKU = CYS_DATACENTER_SERVER;
               break;
            }
            else if (info.wSuiteMask & VER_SUITE_ENTERPRISE)
            {
               // advanced server
      
               productSKU = CYS_ADVANCED_SERVER;
               break;
            }
            else if (info.wSuiteMask & VER_SUITE_SMALLBUSINESS  ||
                     info.wSuiteMask & VER_SUITE_BACKOFFICE     ||
                     info.wSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED ||
                     info.wSuiteMask & VER_SUITE_EMBEDDEDNT     ||
                     info.wSuiteMask & VER_SUITE_BLADE)
            {
               // Unsupported server

               productSKU = CYS_UNSUPPORTED_SKU;
               break;
            }
            else
            {
               // default to standard server

               productSKU = CYS_SERVER;
            }
            break;
         }

         // All other SKUs are unsupported

         productSKU = CYS_UNSUPPORTED_SKU;

      } while (false);
   }
   LOG(String::format(L"Product SKU = 0x%1!x!", productSKU ));

   return productSKU;
}

void
State::RetrievePlatform()
{
   LOG_FUNCTION(State::RetrievePlatform);

   // I am making the assumption that we are not on a 
   // 64bit machine if GetSystemInfo fails

   SYSTEM_INFO info;
   Win::GetSystemInfo(info);

   switch (info.wProcessorArchitecture)
   {
      case PROCESSOR_ARCHITECTURE_IA64:
      case PROCESSOR_ARCHITECTURE_AMD64:
         platform = CYS_64BIT;
         break;

      default:
         platform = CYS_32BIT;
         break;
   }

   LOG(String::format(L"Platform = 0x%1!x!", platform));

   return;
}

HRESULT
State::RetrieveNICInformation()
{
   ASSERT(!hasStateBeenRetrieved);

   HRESULT hr = S_OK;

   if (!adapterConfiguration.IsInitialized())
   {
      hr = adapterConfiguration.Initialize();
   }

   LOG_HRESULT(hr);

   return hr;
}

void
State::CheckDhcpServer(
   HWND progressStatic,
   int  defaultConnectionNameResID,
   int  detectSettingsResID)
{
   LOG_FUNCTION(State::CheckDhcpServer);

   // This should loop through all network interfaces
   // seeing if we can obtain a lease on any of them

   for (unsigned int idx = 0; idx < GetNICCount(); ++idx)
   {
      NetworkInterface* nic = GetNIC(idx);

      if (!nic)
      {
         continue;
      }

      // Update the text on the NetDetectProgressDialog

      String progress = 
         String::format(
            detectSettingsResID, 
            nic->GetFriendlyName(
               String::load(defaultConnectionNameResID)).c_str());

      if (progressStatic)
      {
         Win::SetWindowText(progressStatic, progress);
      }

      // Now try to renew the lease

      if (!nic->CanDetectDHCPServer())
      {
         dhcpServerAvailableOnAllNics = false;

         // Don't break because we need to retrieve the
         // avialability of a DHCP server on all NICs
      }
   }
   dhcpAvailabilityRetrieved = true;

   LOG_BOOL(dhcpServerAvailableOnAllNics);
}


bool
State::HasNTFSDrive() const
{
   LOG_FUNCTION(State::HasNTFSDrive);

   return hasNTFSDrive;
}

void
State::RetrieveDriveInformation()
{
   LOG_FUNCTION(State::RetrieveDriveInformation);

   do
   {
      // Get a list of the valid drives

      StringVector dl;
      HRESULT hr = FS::GetValidDrives(std::back_inserter(dl));
      if (FAILED(hr))
      {
         LOG(String::format(L"Failed to GetValidDrives: hr = %1!x!", hr));
         break;
      }

      // Loop through the list

      ASSERT(dl.size());
      for (
         StringVector::iterator i = dl.begin();
         i != dl.end();
         ++i)
      {
         // look for the NTFS partition

         FS::FSType fsType = FS::GetFileSystemType(*i);
         if (fsType == FS::NTFS5 ||
             fsType == FS::NTFS4)
         {
            // found one.  good to go

            LOG(String::format(L"%1 is NTFS", i->c_str()));

            hasNTFSDrive = true;
            break;
         }
      }
   } while (false);

   LOG_BOOL(hasNTFSDrive);

   return;
}

/*
void
State::SetRerunWizard(bool rerun)
{
   LOG_FUNCTION2(
      State::SetRerunWizard,
      rerun ? L"true" : L"false");

   rerunWizard = rerun;
}
*/

bool
State::SetHomeRegkey(const String& newKeyValue)
{
   LOG_FUNCTION2(
      State::SetHomeRegkey,
      newKeyValue);

   bool result = SetRegKeyValue(
                    CYS_HOME_REGKEY,
                    CYS_HOME_VALUE,
                    newKeyValue,
                    HKEY_LOCAL_MACHINE,
                    true);
   ASSERT(result);

   LOG_BOOL(result);

   return result;
}

bool
State::GetHomeRegkey(String& keyValue) const
{
   LOG_FUNCTION(State::GetHomeRegkey);

   bool result = GetRegKeyValue(
                    CYS_HOME_REGKEY,
                    CYS_HOME_VALUE,
                    keyValue);

   LOG_BOOL(result);

   return result;
}

String
State::GetComputerName()
{
   LOG_FUNCTION(State::GetComputerName);

   if (computerName.empty())
   {
      computerName = Win::GetComputerNameEx(ComputerNameDnsHostname);
   }

   LOG(computerName);
   return computerName;
}

String
State::GetDomainDNSName()
{
   LOG_FUNCTION(State::GetDomainDNSName);

   if (domainDNSName.empty())
   {
      domainDNSName = localComputer.GetDomainDnsName();
   }

   LOG(domainDNSName);
   return domainDNSName;
}

String
State::GetDomainNetbiosName()
{
   LOG_FUNCTION(State::GetDomainNetbiosName);

   if (domainNetbiosName.empty())
   {
      domainNetbiosName = localComputer.GetDomainNetbiosName();
   }

   LOG(domainNetbiosName);
   return domainNetbiosName;
}

bool
State::HasDNSServerOnAnyNicToForwardTo()
{
   LOG_FUNCTION(State::HasDNSServerOnAnyNicToForwardTo);

   // A valid DNS server is considered to be any DNS
   // server defined on any NIC that does not point
   // to itself for resolution.  The reason I consider
   // a DNS server that points to itself as invalid is
   // because this routine is used to determine if the
   // DNS server can be used as a forwarder.  Since DNS
   // servers cannot forward to themselves I consider
   // this an invalid DNS server.
   // Also consider the "next available" IP address to
   // be invalid because chances are the "next available"
   // IP address will be used as the static IP address
   // of this server in the express path.

   bool result = false;

   DWORD nextAvailableAddress = 
      GetNextAvailableIPAddress(
         CYS_DEFAULT_IPADDRESS,
         CYS_DEFAULT_SUBNETMASK);

   for (unsigned int idx = 0; idx < GetNICCount(); ++idx)
   {
      IPAddressList dnsServers;

      NetworkInterface* nic = GetNIC(idx);

      if (!nic)
      {
         continue;
      }

      nic->GetDNSServers(dnsServers);

      if (dnsServers.empty())
      {
         continue;
      }

      // Only return true if there is a DNS server in the list
      // and the IP address is not the local machine

      DWORD ipaddress = nic->GetIPAddress(0);

      for (IPAddressList::iterator itr = dnsServers.begin();
           itr != dnsServers.end();
           ++itr)
      {
         DWORD currentServer = *itr;

         if (ipaddress != currentServer &&
             ipaddress != nextAvailableAddress)
         {
            LOG(String::format(
                   L"Found valid server: %1",
                   IPAddressToString(currentServer).c_str()));

            result = true;
            break;
         }
      }

      if (result)
      {
         break;
      }
   }

   LOG_BOOL(result);
   return result;
}

void
State::SetLocalNIC(
   String guid, 
   bool setInRegistry)
{
   LOG_FUNCTION2(
      State::SetLocalNIC,
      guid.c_str());

   LOG_BOOL(setInRegistry);
   adapterConfiguration.SetLocalNIC(guid, setInRegistry);
}

NetworkInterface*
State::GetLocalNIC()
{
   LOG_FUNCTION(State::GetLocalNIC);

   return adapterConfiguration.GetLocalNIC();
}

bool
State::IsRebootScenario() const
{
   LOG_FUNCTION(State::IsRebootScenario);

   LOG_BOOL(isRebootScenario);
   return isRebootScenario;
}

void
State::SetRebootScenario(bool reboot)
{
   LOG_FUNCTION(State::SetRebootScenario);
   LOG_BOOL(reboot);

   isRebootScenario = reboot;
}

bool
State::ShouldRunMYS() const
{
   LOG_FUNCTION(State::ShouldRunMYS);

   bool result = false;

   do
   {
      // First check to be sure this is a supported SKU

      if (!::IsSupportedSku())
      {
         break;
      }

      // Now check the startup flags

      if (!::IsStartupFlagSet())
      {
         break;
      }

      // Check the policy setting

      if (!::ShouldShowMYSAccordingToPolicy())
      {
         // The policy is enabled so that means don't show MYS

         break;
      }

      // everything passed so we should run MYS

      result = true;
   } while (false);

   LOG_BOOL(result);

   return result;
}

DWORD
State::GetNextAvailableIPAddress(
   DWORD startAddress,
   DWORD subnetMask)
{
   LOG_FUNCTION2(
      State::GetNextAvailableIPAddress,
      IPAddressToString(startAddress));

   DWORD result = startAddress;
   DWORD currentAddress = startAddress;

   bool isIPInUse = false;

   do
   {
      isIPInUse = false;

      // Check to see if the IP address
      // is in use on any NIC. If it is
      // then increment and try all the NICs
      // again.

      for (
         unsigned int index = 0;
         index < GetNICCount();
         ++index)
      {
         NetworkInterface* nic = GetNIC(index);

         if (nic)
         {
            bool isInUseOnThisNIC = 
               nic->IsIPAddressInUse(
                  currentAddress,
                  subnetMask);

            isIPInUse = isIPInUse || isInUseOnThisNIC;
         }

         if (isIPInUse)
         {
            break;
         }
      }

      if (isIPInUse)
      {
         ++currentAddress;

         if ((currentAddress & subnetMask) != (startAddress & subnetMask))
         {
            // REVIEW_JEFFJON : what should the behavior be if there are
            // no available addresses?  Is this likely to happen?

            // Since we couldn't find an available address in this subnet
            // use the start address

            currentAddress = startAddress;
            break;
         }
      }
   } while (isIPInUse);

   result = currentAddress;

   LOG(IPAddressToString(result));

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\lib\rolestatus.cpp ===
// Copyright (c) 2002 Microsoft Corporation
//
// File:      RoleStatus.h
//
// Synopsis:  Defines the functions that are declared
//            in CYS.h that are used to determine the
//            status of the CYS server roles
//
// History:   01/21/2002  JeffJon Created

#include "pch.h"

#include "CYS.h"
#include "state.h"
#include "regkeys.h"


// table of items that are available in the server type list box
// The order in this table is important because it is the order
// in which the roles will show up in CYS.  Please do not change
// the order unless there is a good reason to do so.

extern ServerRoleStatus serverRoleStatusTable[] =
{
   {  FILESERVER_SERVER,         GetFileServerStatus       },
   {  PRINTSERVER_SERVER,        GetPrintServerStatus      },
   {  WEBAPP_SERVER,             GetWebServerStatus        },
   {  POP3_SERVER,               GetPOP3Status             },
   {  TERMINALSERVER_SERVER,     GetTerminalServerStatus   },
   {  RRAS_SERVER,               GetRRASStatus             },
   {  DC_SERVER,                 GetDCStatus               },
   {  DNS_SERVER,                GetDNSStatus              },
   {  DHCP_SERVER,               GetDHCPStats              },
   {  MEDIASERVER_SERVER,        GetMediaServerStatus      }, 
   {  WINS_SERVER,               GetWINSStatus             },
};

size_t
GetServerRoleStatusTableElementCount()
{
   return sizeof(serverRoleStatusTable)/sizeof(ServerRoleStatus);
}

// Helper to get the status if all you have is the installation type

InstallationStatus
GetInstallationStatusForServerRole(
   ServerRole role)
{
   LOG_FUNCTION(GetInstallationStatusForServerRole);

   InstallationStatus result = STATUS_NONE;

   for (
      size_t index = 0; 
      index < GetServerRoleStatusTableElementCount(); 
      ++index)
   {
      if (serverRoleStatusTable[index].role == role)
      {
         result = serverRoleStatusTable[index].Status();
         break;
      }
   }
   LOG_ROLE_STATUS(result);

   return result;
}


// Helper function to verify role against SKU and platform

bool
IsAllowedSKUAndPlatform(DWORD flags)
{
   LOG_FUNCTION(IsAllowedSKUAndPlatform);

   bool result = false;

   LOG(String::format(
            L"Current role SKUs: 0x%1!x!",
            flags));

   DWORD sku = State::GetInstance().GetProductSKU();

   LOG(String::format(
            L"Verifying against computer sku: 0x%1!x!",
            sku));

   if (sku & flags)
   {
      DWORD platform = State::GetInstance().GetPlatform();

      LOG(String::format(
               L"Verifying against computer platform: 0x%1!x!",
               platform));

      if (platform & flags)
      {
         result = true;
      }
   }
   
   LOG_BOOL(result);

   return result;
}


// Functions to determine the server role status

InstallationStatus 
GetDNSStatus()
{
   LOG_FUNCTION(GetDNSStatus);

   InstallationStatus result = STATUS_NONE;

   do
   {
      if (!IsAllowedSKUAndPlatform(CYS_ALL_SERVER_SKUS))
      {
         result = STATUS_NOT_AVAILABLE;
         break;
      }

      if (IsServiceInstalledHelper(CYS_DNS_SERVICE_NAME))
      {
         result = STATUS_COMPLETED;
      }
   } while (false);

   LOG_ROLE_STATUS(result);

   return result;
}

InstallationStatus 
GetDHCPStats()
{
   LOG_FUNCTION(GetDHCPStats);

   InstallationStatus result = STATUS_NONE;

   do
   {
      if (!IsAllowedSKUAndPlatform(CYS_ALL_SERVER_SKUS))
      {
         result = STATUS_NOT_AVAILABLE;
         break;
      }

      if (IsServiceInstalledHelper(CYS_DHCP_SERVICE_NAME))
      {
         result = STATUS_COMPLETED;
      }
      else if (IsDhcpConfigured())
      {
         result = STATUS_CONFIGURED;
      }

   } while (false);

   LOG_ROLE_STATUS(result);

   return result;
}

InstallationStatus 
GetWINSStatus()
{
   LOG_FUNCTION(GetWINSStatus);

   InstallationStatus result = STATUS_NONE;

   do
   {
      if (!IsAllowedSKUAndPlatform(CYS_ALL_SERVER_SKUS))
      {
         result = STATUS_NOT_AVAILABLE;
         break;
      }

      if (IsServiceInstalledHelper(CYS_WINS_SERVICE_NAME))
      {
         result = STATUS_COMPLETED;
      }
   } while (false);

   LOG_ROLE_STATUS(result);

   return result;
}

InstallationStatus
GetRRASStatus()
{
   LOG_FUNCTION(GetRRASStatus);

   InstallationStatus result = STATUS_NONE;

   do
   {
      if (!IsAllowedSKUAndPlatform(CYS_ALL_SERVER_SKUS))
      {
         result = STATUS_NOT_AVAILABLE;
         break;
      }

      DWORD resultValue = 0;
      bool regResult = GetRegKeyValue(
                          CYS_RRAS_CONFIGURED_REGKEY,
                          CYS_RRAS_CONFIGURED_VALUE,
                          resultValue);

      if (regResult &&
          resultValue != 0)
      {
         result = STATUS_COMPLETED;
      }

   } while (false);

   LOG_ROLE_STATUS(result);

   return result;
}

InstallationStatus 
GetTerminalServerStatus()
{
   LOG_FUNCTION(GetTerminalServerStatus);

   InstallationStatus result = STATUS_NONE;

   do
   {
      if (!IsAllowedSKUAndPlatform(CYS_ALL_SERVER_SKUS))
      {
        result = STATUS_NOT_AVAILABLE;
        break;
      }

      DWORD regValue = 0;
      bool keyResult = GetRegKeyValue(
                          CYS_APPLICATION_MODE_REGKEY, 
                          CYS_APPLICATION_MODE_VALUE, 
                          regValue);
      ASSERT(keyResult);

      if (keyResult &&
          regValue == CYS_APPLICATION_MODE_ON)
      {
         result = STATUS_COMPLETED;
      } 
   } while (false);

   LOG_ROLE_STATUS(result);

   return result;
}

InstallationStatus 
GetFileServerStatus()
{
   LOG_FUNCTION(GetFileServerStatus);

   InstallationStatus result = STATUS_NONE;

   do
   {
      if (!IsAllowedSKUAndPlatform(CYS_ALL_SERVER_SKUS))
      {
         result = STATUS_NOT_AVAILABLE;
         break;
      }

      if (IsNonSpecialSharePresent())
      {
         result = STATUS_CONFIGURED;
      }

   } while (false);

   LOG_ROLE_STATUS(result);

   return result;
}

InstallationStatus
GetPrintServerStatus()
{
   LOG_FUNCTION(GetPrintServerStatus);

   InstallationStatus result = STATUS_NONE;

   do
   {
      if (!IsAllowedSKUAndPlatform(CYS_ALL_SERVER_SKUS))
      {
         result = STATUS_NOT_AVAILABLE;
         break;
      }

      // I am using level 4 here because the MSDN documentation
      // says that this will be the fastest.

      BYTE* printerInfo = 0;
      DWORD bytesNeeded = 0;
      DWORD numberOfPrinters = 0;
      DWORD error = 0;

      do
      {
         if (!EnumPrinters(
               PRINTER_ENUM_LOCAL | PRINTER_ENUM_SHARED,
               0,
               4,
               printerInfo,
               bytesNeeded,
               &bytesNeeded,
               &numberOfPrinters))
         {
            error = GetLastError();

            if (error != ERROR_INSUFFICIENT_BUFFER &&
               error != ERROR_INVALID_USER_BUFFER)
            {
               LOG(String::format(
                     L"EnumPrinters() failed: error = %1!x!",
                     error));
               break;
            }

            // The buffer isn't large enough so allocate
            // a new buffer and try again

            LOG(L"Reallocating buffer and trying again...");

            if (printerInfo)
            {
               delete[] printerInfo;
               printerInfo = 0;
            }

            printerInfo = new BYTE[bytesNeeded];
            if (!printerInfo)
            {
               LOG(L"Could not allocate printerInfo buffer!");
               break;
            }
         }
         else
         {
            break;
         }
      } while (true);

      LOG(String::format(
            L"numberOfPrinters = %1!d!",
            numberOfPrinters));

      if (numberOfPrinters > 0)
      {
         result = STATUS_COMPLETED;
      }

      delete[] printerInfo;
      
   } while (false);

   LOG_ROLE_STATUS(result);

   return result;
}

InstallationStatus 
GetMediaServerStatus()
{
   LOG_FUNCTION(GetMediaServerStatus);

   InstallationStatus result = STATUS_NONE;

   do
   {
      // All 32bit SKUs 

      if (!IsAllowedSKUAndPlatform(CYS_ALL_SKUS_NO_64BIT))
      {
         result = STATUS_NOT_AVAILABLE;
         break;
      }

      // If we can find wmsserver.dll, we assume netshow is installed

      String installDir;
      if (!GetRegKeyValue(
             REGKEY_WINDOWS_MEDIA,
             REGKEY_WINDOWS_MEDIA_SERVERDIR,
             installDir,
             HKEY_LOCAL_MACHINE))
      {
         LOG(L"Failed to read the installDir regkey");
         result = STATUS_NONE;
         break;
      }

      String wmsServerPath = installDir + L"WMServer.exe";

      LOG(String::format(
             L"Path to WMS server: %1",
             wmsServerPath.c_str()));

      if (!wmsServerPath.empty())
      {
         if (FS::FileExists(wmsServerPath))
         {
            result = STATUS_COMPLETED;
         }
         else
         {
            LOG(L"Path does not exist");
         }
      }
      else
      {
         LOG(L"Failed to append path");
      }
   } while (false);

   LOG_ROLE_STATUS(result);

   return result;
}

InstallationStatus 
GetWebServerStatus()
{
   LOG_FUNCTION(GetWebServerStatus);

   InstallationStatus result = STATUS_NONE;

   do
   {
      if (!IsAllowedSKUAndPlatform(CYS_ALL_SERVER_SKUS))
      {
         result = STATUS_NOT_AVAILABLE;
         break;
      }

      if (IsServiceInstalledHelper(CYS_WEB_SERVICE_NAME))
      {
         result = STATUS_COMPLETED;
      }
   } while (false);

   LOG_ROLE_STATUS(result);

   return result;
}


InstallationStatus
GetDCStatus()
{
   LOG_FUNCTION(GetDCStatus);

   InstallationStatus result = STATUS_NONE;

   do
   {
      if (!IsAllowedSKUAndPlatform(CYS_ALL_SERVER_SKUS))
      {
         result = STATUS_NOT_AVAILABLE;
         break;
      }

      // Special case AD installation so that it is not available if
      // CertServer is installed

      if (NTService(L"CertSvc").IsInstalled())
      {
         result = STATUS_NOT_AVAILABLE;
         break;
      }

      if (State::GetInstance().IsDC())
      {
         result = STATUS_COMPLETED;
      }
   } while (false);

   LOG_ROLE_STATUS(result);

   return result;
}


// NTRAID#NTBUG9-698722-2002/09/03-artm
// Only need to check if machine is currently a DC, not if
// running dcpromo would be allowed.
InstallationStatus
GetDCStatusForMYS()
{
   LOG_FUNCTION(GetDCStatusForMYS);

   InstallationStatus result = STATUS_NONE;

   if (State::GetInstance().IsDC())
   {
      result = STATUS_COMPLETED;
   }

   LOG_ROLE_STATUS(result);

   return result;
}


InstallationStatus 
GetPOP3Status()
{
   LOG_FUNCTION(GetPOP3Status);

   InstallationStatus result = STATUS_NONE;

   do
   {
      if (!IsAllowedSKUAndPlatform(CYS_ALL_SERVER_SKUS))
      {
         result = STATUS_NOT_AVAILABLE;
         break;
      }

      // If we can read this regkey then POP3 is installed

      String pop3Version;
      bool regResult = GetRegKeyValue(
                          CYS_POP3_REGKEY,
                          CYS_POP3_VERSION,
                          pop3Version,
                          HKEY_LOCAL_MACHINE);

      if (regResult)
      {
         result = STATUS_COMPLETED;
      }

   } while (false);

   LOG_ROLE_STATUS(result);

   return result;
}


// Define the GUIDs used by the Server Appliance Kit COM object

#include <initguid.h>
DEFINE_GUID(CLSID_SaInstall,0x142B8185,0x53AE,0x45B3,0x88,0x8F,0xC9,0x83,0x5B,0x15,0x6C,0xA9);
DEFINE_GUID(IID_ISaInstall,0xF4DEDEF3,0x4D83,0x4516,0xBC,0x1E,0x10,0x3A,0x63,0xF5,0xF0,0x14);

bool
IsSAKUnitInstalled(SA_TYPE unitType)
{
   LOG_FUNCTION2(
      IsSAKUnitInstalled,
      String::format(L"type = %1!d!", (int) unitType));

   bool result = true;

   do
   {
      // Check to make sure we are not on 64bit

      if (State::GetInstance().Is64Bit())
      {
         result = false;
         break;
      }

      // Get the Server Appliance Kit COM object

      SmartInterface<ISaInstall> sakInstall;
      HRESULT hr = sakInstall.AcquireViaCreateInstance(
                      CLSID_SaInstall,
                      0,
                      CLSCTX_INPROC_SERVER);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed to get the SAK COM object: hr = 0x%1!x!",
                hr));

         break;
      }

      // Check to see if NAS is already installed 

      VARIANT_BOOL saInstalled;
      hr = sakInstall->SAAlreadyInstalled(unitType, &saInstalled);
      if (FAILED(hr))
      {
         LOG(String::format(
                L"Failed call to SAAlreadyInstalled: hr = 0x%1!x!",
                hr));
         break;
      }

      if (!saInstalled)
      {
         result = false;
      }

   } while (false);

   LOG_BOOL(result);
   return result;
}

bool
IsClusterServer()
{
   LOG_FUNCTION(IsClusterServer());

   bool result = false;

   DWORD clusterState = 0;
   DWORD err = ::GetNodeClusterState(0, &clusterState);
   if (err == ERROR_SUCCESS &&
       clusterState != ClusterStateNotConfigured)
   {
      result = true;
   }
   else
   {
      LOG(String::format(
             L"GetNodeClusterState returned err = %1!x!",
             err));
   }

   LOG_BOOL(result);

   return result;
}

String
GetSAKURL()
{
   LOG_FUNCTION(GetSAKURL);

   String result =
      String::format(
         L"https://%1:8098",
         State::GetInstance().GetComputerName().c_str());

   LOG(result);
   return result;
}

bool
IsSupportedSku()
{
   LOG_FUNCTION(IsSupportedSku);

   bool result = true;
   
   DWORD productSKU = State::GetInstance().RetrieveProductSKU();
   if (CYS_UNSUPPORTED_SKU == productSKU)
   {
      result = false;
   }

   LOG_BOOL(result);
   
   return result;
}

bool
IsStartupFlagSet()
{
   LOG_FUNCTION(IsStartupFlagSet);

   bool result = false;

   do
   {
      // This code copied from shell\explorer\initcab.cpp
      
      DWORD data = 0;
      
      // If the user's preference is present and zero, then don't show
      // the wizard, else continue with other tests

      bool regResult =
         GetRegKeyValue(
            REGTIPS, 
            REGTIPS_SHOW_VALUE, 
            data, 
            HKEY_CURRENT_USER);

      if (regResult && !data)
      {
         break;
      }

      // This is to check an old W2K regkey that was documented in Q220838.
      // If the key exists and is zero then don't run the wizard

      data = 0;

      regResult = 
         GetRegKeyValue(
            SZ_REGKEY_W2K,
            SZ_REGVAL_W2K,
            data,
            HKEY_CURRENT_USER);
      
      if (regResult && !data)
      {
         break;
      }

      // If the user's preference is absent or non-zero, then we need to
      // start the wizard.

      data = 0;

      regResult =
         GetRegKeyValue(
            SZ_REGKEY_SRVWIZ_ROOT,
            L"",
            data,
            HKEY_CURRENT_USER);

      if (!regResult ||
          data)
      {
         result = true;
         break;
      }

   } while (false);

   LOG_BOOL(result);

   return result;
}

bool
ShouldShowMYSAccordingToPolicy()
{
   LOG_FUNCTION(ShouldShowMYSAccordingToPolicy);

   bool result = true;

   do
   {
      // If group policy is set for "Don't show MYS",
      // then don't show MYS regardless of user setting

      DWORD data = 0;

      bool regResult =
         GetRegKeyValue(
            MYS_REGKEY_POLICY,
            MYS_REGKEY_POLICY_DISABLE_SHOW,
            data);

      if (regResult && data)
      {
         result = false;
      }

   } while (false);

   LOG_BOOL(result);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\dllmain.cpp ===
// Copyright (C) 2002 Microsoft Corporation
//
// DllMain and COM DllXxx functions
//
// 21 January 2002


// To test this app: "mshta.exe res://mys.dll/mys.hta"



#include "headers.hxx"
#include "ManageYourServer.hpp"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME  = L"mys";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_MUTE;



static WCHAR moduleFileName[MAX_PATH];    // Initialized in DllMain



struct RegistryEntry
{
    const wchar_t *keyName;
    const wchar_t *valueName;
    const wchar_t *value;
};



// This is the junk we put in the registry to register the COM objects
// this dll implements.

static const RegistryEntry registryEntries[] =
{
   {
      L"CLSID\\" CLSID_STRING,
      0,
      CLASSNAME_STRING
   },
   { 
      L"CLSID\\" CLSID_STRING L"\\InprocServer32",
      0,
      moduleFileName
   },
   { 
      L"CLSID\\" CLSID_STRING L"\\InprocServer32",
      L"ThreadingModel",
      L"Apartment"
   },
   {
      L"CLSID\\" CLSID_STRING L"\\ProgID",
      0,
      PROGID_VERSION_STRING
   },
   {
      L"CLSID\\" CLSID_STRING L"\\VersionIndependentProgID",
      0,
      PROGID_STRING
   },
   {
      PROGID_VERSION_STRING,
      0,
      CLASSNAME_STRING
   },
   {
      PROGID_VERSION_STRING L"\\CLSID",
      0,
      CLSID_STRING
   },
   {
      PROGID_STRING,
      0,
      CLASSNAME_STRING
   },
   {
      PROGID_STRING L"\\CLSID",
      0,
      CLSID_STRING
   },
   {
      PROGID_STRING L"\\CurVer",
      0,
      PROGID_VERSION_STRING
   },
};



HRESULT
Unregister(const RegistryEntry *rgEntries, int cEntries)
{
   LOG_FUNCTION(Unregister);

   LOG(L"Calling UnRegisterTypeLib");

   HRESULT hr =
      ::UnRegisterTypeLib(LIBID_ManageYourServerLib, 1, 0, 0, SYS_WIN32);

   LOG_HRESULT(hr);

   // don't break: continue on attempting to remove as much as possible
   // of our registration

   bool success = SUCCEEDED(hr);
   for (int i = cEntries - 1; i >= 0; i--)
   {
      LONG err = ::RegDeleteKey(HKEY_CLASSES_ROOT, rgEntries[i].keyName);
      if (err != ERROR_SUCCESS)
      {
         success = false;
      }
   }

   return success ? S_OK : S_FALSE;
}



// unregisters the CYS (srvwiz.dll) from win2k, if applicable

void
UnregisterPriorCys()
{
   LOG_FUNCTION(UnregisterPriorCys);

   static const GUID LIBID_OldSrvWiz = 
   {  /* D857B805-5F40-11D2-B002-00C04FC30936 */
      0xD857B805,
      0x5F40,
      0x11D2,
      {0xB0, 0x02, 0x00, 0xC0, 0x4F, 0xC3, 0x09, 0x36}
   };

   LOG(L"UnRegisterTypeLib");

   HRESULT hr = ::UnRegisterTypeLib(LIBID_OldSrvWiz, 1, 0, 0, SYS_WIN32);

   LOG_HRESULT(hr);

   // the list of subkeys of HKCR to delete

   static const String keys[] =
   {
      L"CLSID\\{D857B813-5F40-11D2-B002-00C04FC30936}",
      L"Interface\\{D857B811-5F40-11D2-B002-00C04FC30936}",
      L"SrvWiz.SrvWiz",
      L"SrvWiz.SrvWiz.1"
   };

   for (int i = 0; i < (sizeof(keys) / sizeof(String)); ++i)
   {
      LOG(keys[i]);

      hr = Win32ToHresult(::SHDeleteKey(HKEY_CLASSES_ROOT, keys[i].c_str()));

      LOG_HRESULT(hr);
   }
}



static
HRESULT
Register(const RegistryEntry *rgEntries, int cEntries)
{

   BOOL bSuccess = TRUE;
   HRESULT hr = S_OK;   // 447822 prefix warning
   const RegistryEntry *pEntry = rgEntries;

   UnregisterPriorCys();

    while (pEntry < rgEntries + cEntries)
    {
        HKEY hkey;
        LONG err = RegCreateKey(HKEY_CLASSES_ROOT,
                                pEntry->keyName,
                               &hkey);
        if (err == ERROR_SUCCESS)
        {
            if (pEntry->value)
                err = RegSetValueEx(hkey, 
                                pEntry->valueName,
                                0, REG_SZ, 
                                (const BYTE*)pEntry->value,
                                (lstrlen(pEntry->value) + 1) * sizeof(TCHAR));
            if (err != ERROR_SUCCESS)
            {
                bSuccess = FALSE;
                Unregister(rgEntries, static_cast<int>(1 + pEntry - rgEntries));
            }
            RegCloseKey(hkey);
        }
        if (err != ERROR_SUCCESS)
        {
            bSuccess = FALSE;
            if (pEntry != rgEntries)
                Unregister(rgEntries, static_cast<int>(pEntry - rgEntries));
        }
        pEntry++;
    };

   if (bSuccess)
	{
     
      OLECHAR g_wszFileName[MAX_PATH];

      // ISSUE-2002/03/07-sburns consider strsafe function
      
      //NTRAID#NTBUG9-571986-2002/03/10-jmessec   Defense in Depth, should check length of moduleFileName; even
	  //though buffers are currently the same size, this may later change, and/or
	  //moduleFileName might get horked, not initialized, etc
	  lstrcpy(g_wszFileName, moduleFileName);     
		ITypeLib *ptl = 0;
		hr = LoadTypeLib(g_wszFileName, &ptl);
		if (SUCCEEDED(hr))
		{
			hr = RegisterTypeLib(ptl, g_wszFileName, 0);
			ptl->Release();
		}

		if (bSuccess)
			hr = S_OK;
		else
			hr = E_FAIL;
	}

    return hr ;//bSuccess ? S_OK : E_FAIL;
}



BOOL
APIENTRY
DllMain(HINSTANCE h, DWORD dwReason, void *)
{
   switch (dwReason)
   {
      case DLL_PROCESS_ATTACH:
      {
         hResourceModuleHandle = h;

         LOG(L"DLL_PROCESS_ATTACH");

         GetModuleFileName(h, moduleFileName, MAX_PATH);
         //NTRAID#NTBUG9-571986-2002/03/10-jmessec   Not checking for error return value of GetModuleFileName

         // we don't need thread attach notifications
         
         ::DisableThreadLibraryCalls(h);

         break;
      }
      case DLL_PROCESS_DETACH:
      {

#ifdef DBG
         LOG(TEXT("DLL_PROCESS_DETACH"));
         if (!ComServerLockState::CanUnloadNow())
         {
            LOG(L"server locks and/or outstanding object instances exit");
         }
         else
         {
            LOG(L"server can unload now.");
         }
#endif

         break;
      }
      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
      default:
      {
         // we should never get here

         ASSERT(false);
         break;
      }
   }

   return TRUE;
}



STDAPI
DllRegisterServer()
{
   LOG_FUNCTION(DllRegisterServer);

   return
      Register(
         registryEntries,
         sizeof(registryEntries) / sizeof(*registryEntries));
}



STDAPI
DllUnregisterServer()
{
   LOG_FUNCTION(DllUnregisterServer);

   return
      Unregister(
         registryEntries,
         sizeof(registryEntries) / sizeof(*registryEntries));
}



STDAPI
DllCanUnloadNow()
{
   LOG_FUNCTION(DllCanUnloadNow);

   if (ComServerLockState::CanUnloadNow())
   {
      return S_OK;
   }

   return S_FALSE;
}



STDAPI
DllGetClassObject(
   const CLSID&   classID,
   const IID&     interfaceID,
   void**         interfaceDesired)
{
   LOG_FUNCTION(DllGetClassObject);

   IClassFactory* factory = 0;

   // The class objects are instances of ClassFactory<>, which are ref-counted
   // in the usual fashion (i.e. they track their ref counts, and
   // self-destruct on final Release).  I could have used static instances of
   // a C++ class that ignored the refcounting (ala Don Box's examples in
   // Essential COM)

   if (classID == CLSID_ManageYourServer)
   {
      factory = new ClassFactory<ManageYourServer>;
   }
   else
   {
      *interfaceDesired = 0;
      return CLASS_E_CLASSNOTAVAILABLE;
   }

   // the class factory instance starts with a ref count of 1.  If the QI
   // fails, then it self-destructs upon Release.
   HRESULT hr = factory->QueryInterface(interfaceID, interfaceDesired);
   factory->Release();
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\manageyourserver.hpp ===
// Copyright (C) 2002 Microsoft Corporation
//
// class ManageYourServer, which implements IManageYourServer
//
// 21 January 2002 sburns



#ifndef MANAGEYOURSERVER_HPP_INCLUDED
#define MANAGEYOURSERVER_HPP_INCLUDED



#include <cys.h>

enum HardenedLevel {
   NO_HARDENING,
   USERS_HARDENED,
   ADMINS_HARDENED,
   ALL_HARDENED
};

class ManageYourServer
   :
   public IManageYourServer /* ,
   public ISupportErrorInfo */ // CODEWORK: add support for ErrorInfo
{
   // this is the only entity with access to the ctor of this class

   friend class ClassFactory<ManageYourServer>;

	public:

   // IUnknown methods

   virtual 
   HRESULT __stdcall
   QueryInterface(const IID& riid, void **ppv);

   virtual
   ULONG __stdcall
   AddRef();

   virtual
   ULONG __stdcall
   Release();

	// IDispatch methods

   virtual 
   HRESULT __stdcall
   GetTypeInfoCount(UINT *pcti);

	virtual 
   HRESULT __stdcall
   GetTypeInfo(UINT cti, LCID, ITypeInfo **ppti);

   virtual 
   HRESULT __stdcall
	GetIDsOfNames(
	   REFIID  riid,    
	   OLECHAR **prgpsz,
	   UINT    cNames,  
	   LCID    lcid,    
	   DISPID  *prgids);

   virtual 
   HRESULT __stdcall
	Invoke(
	   DISPID     id,         
	   REFIID     riid,       
	   LCID       lcid,       
	   WORD       wFlags,     
	   DISPPARAMS *params,    
	   VARIANT    *pVarResult,
	   EXCEPINFO  *pei,       
	   UINT       *puArgErr); 

//    // ISupportErrorInfo methods
// 
//    virtual 
//    HRESULT __stdcall
//    InterfaceSupportsErrorInfo(const IID& iid);
      


   // 
   // IManageYourServer methods
   // 

   virtual
   HRESULT __stdcall
   GetConfiguredRoleMarkup( 
       /* [retval][out] */ BSTR *result);
   
   virtual
   HRESULT __stdcall
   HasRoleStatusChanged( 
       /* [retval][out] */ BOOL *result);

   virtual
   HRESULT __stdcall
   IsClusterNode( 
      /* [retval][out] */ BOOL *result);

   virtual       
   HRESULT __stdcall
   IsCurrentUserAnAdministrator(
      /* [out, retval] */ BOOL* result);

   virtual
   HRESULT __stdcall
   IsSupportedSku(
      /* [out, retval] */ BOOL* result);

   virtual
   HRESULT __stdcall
   IsStartupFlagSet(
      /* [out, retval] */ BOOL* result);
       
   virtual
   HRESULT __stdcall
   SetRunAtLogon(
      /* [in] */ BOOL newState);

   // NTRAID#NTBUG9-530202-29-Mar-2002-jrowlett
   // support needed to check if link is valid
   virtual
   HRESULT __stdcall
   IsServerManagementConsolePresent(
      /* [out, retval] */ BOOL* result );

   // NTRAID#NTBUG9-602954-29-Apr-2002-jrowlett
   // support hiding the startup checkbox when policy is enabled.
   virtual
   HRESULT __stdcall
   IsShowAtStartupPolicyEnabled(
      /* [out, retval] */ BOOL* result );

   // NTRAID#NTBUG9-627875-2002/05/22-artm
   // support hiding startup checkbox when running on datacenter server
   virtual
   HRESULT __stdcall
   IsDatacenterServer(
      /* [out, retval] */ BOOL* result );

   // NTRAID#NTBUG9-648428-2002/06/25-artm
   // support hiding web application server console link if on IA64
   virtual
   HRESULT __stdcall
   IsWebServerConsolePresent(
      /* [out, retval] */ BOOL* result );

   // NTRAID#NTBUG9-632113-2002/07/01-artm
   // support saving collapsed/expanded state of role nodes
   virtual
   HRESULT __stdcall
   CollapseRole(
      /* [in] */ BSTR roleId, /* [in] */ BOOL collapse );

   // NTRAID#NTBUG9-632113-2002/07/01-artm
   // support checking collapsed state of role nodes
   virtual
   HRESULT __stdcall
   IsRoleCollapsed(
      /* [in] */ BSTR roleId, /* [out, retval] */ BOOL* result);

   // NTRAID#NTBUG9-680200-2002/08/01-artm
   // Support retrieving working area of the display.
   //
   // Area info is returned as a comma separated string b/c JScript does not
   // support getting back SAFEARRAY's.  
   // 
   // e.g. "0,0,800,600"  --> working area is 800 wide, 600 high, and starts at
   //                         screen position (0,0)
   virtual
   HRESULT __stdcall
   GetWorkingAreaInfo(
      /* [out, retval] */ BSTR* info);

   
	private:

   // only our friend class factory can instantiate us.

   ManageYourServer();

   // only Release can cause us to be deleted

   virtual
   ~ManageYourServer();

   // not implemented: no copying allowed

   ManageYourServer(const ManageYourServer&);
   const ManageYourServer& operator=(const ManageYourServer&);

   struct RoleStatus
   {
      ServerRole           role;      // The enum used to identify a role
      InstallationStatus   status;    // The enum used for the role's state

      // we sort by role
      
      bool
      operator<(const RoleStatus& rhs) const
      {
         if (this == &rhs)
         {
            return false;
         }
         return this->role < rhs.role;
      }


      
      bool
      operator==(const RoleStatus& rhs) const
      {
         if (this == &rhs)
         {
            // identity is equality
            
            return true;
         }

         return (this->role == rhs.role) && (this->status == rhs.status);
      }
         
   };

   typedef
      std::vector<RoleStatus, Burnslib::Heap::Allocator<RoleStatus> >
      RoleStatusVector;

   typedef void (*ParamSubFunc)(String& target);
   
   typedef
      std::map<
         ServerRole,
         std::pair<String, ParamSubFunc>,
         std::less<ServerRole>,
         Burnslib::Heap::Allocator<std::pair<String, ParamSubFunc> > >
      RoleToFragmentNameMap;
   
   static
   void
   AppendXmlFragment(
      String&        s,
      const String&  fragName,
      ParamSubFunc   subFunc);

   static
   void
   BuildFragMap();
   
   static
   void
   GetRoleStatus(RoleStatusVector& stat);

   // NTRAID#NTBUG9-698722-2002/09/03-artm
   static
   void
   InitDCPromoStatusCheck();

   static bool isDCCheckInitialized;
   
   static RoleToFragmentNameMap fragMap;
   static bool                  fragMapBuilt;
      
   RoleStatusVector   roleStatus;
      
   ComServerReference dllref;      
   long               refcount;    
   ITypeInfo**        m_ppTypeInfo;
   bool foundTLS;       // Found terminal licensing server?
   HardenedLevel ieSecurity;  // Level of IE security (hardening patch)
};



#endif   // MANAGEYOURSERVER_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\manageyourserver.cpp ===
// Copyright (C) 2002 Microsoft Corporation
//
// class ManageYourServer, which implements IManageYourServer
//
// 21 January 2002 sburns



#include "headers.hxx"
#include "resource.h"
#include "ManageYourServer.hpp"
#include "util.hpp"
#include <cys.h>
#include <regkeys.h>

// All of these includes are needed to get functionality in State class in CYS.
#include <iptypes.h>
#include <lm.h>
#include <common.h>
#include <state.h>

const size_t NUMBER_OF_AUTOMATION_INTERFACES = 1;

bool ManageYourServer::isDCCheckInitialized = false;

bool ManageYourServer::fragMapBuilt = false;
ManageYourServer::RoleToFragmentNameMap ManageYourServer::fragMap;

const String QUOT(L"&quot;");
const String OPEN_XML_PI(L"<?xml");
const String CLOSE_XML_PI(L"?>");

// This constant needs to be the same as that defined in res\mysdynamic.xsl in 
// the template "TranslateParagraphs".
const String NEW_PARAGRAPH (L"PARA_MARKER");


// NTRAID#NTBUG9-626890-2002/06/28-artm  
// support changing TS text based on [non]presence of licensing server
bool
FoundTSLicensingServer()
{
    LOG_FUNCTION(FoundTSLicensingServer);

#ifdef DBG
    // Calculate the hresult that corresponds to asking for the wrong type of key value.
    static const HRESULT WRONG_VALUE_TYPE = Win32ToHresult(ERROR_INVALID_FUNCTION);
#endif

    static const String TS_LICENSING_PATH(L"Software\\Microsoft\\MSLicensing\\Parameters");
    static const String REG_DOMAIN_SERVER_MULTI(L"DomainLicenseServerMulti");
    static const String ENTERPRISE_SERVER_MULTI(L"EnterpriseServerMulti");

    bool found = false;

    RegistryKey tsLicensingKey;

    // Try to open the TS licensing key.
    HRESULT keyHr = tsLicensingKey.Open(
        HKEY_LOCAL_MACHINE,
        TS_LICENSING_PATH,
        KEY_READ);


    if (SUCCEEDED(keyHr))
    {
        StringList data;

        // Was a licensing server found at the domain level?
        keyHr = tsLicensingKey.GetValue(
            REG_DOMAIN_SERVER_MULTI, 
            back_inserter(data));
        ASSERT(keyHr != WRONG_VALUE_TYPE);
        
        // NTRAID#NTBUG9-691505-2002/08/23-artm
        // If a value is empty then that means a licensing server was not found.

        if (FAILED(keyHr) || data.empty())
        {
            // If not, was a licensing server found at the enterprise level?
            data.clear();
            keyHr = tsLicensingKey.GetValue(
                ENTERPRISE_SERVER_MULTI, 
                back_inserter(data));
            ASSERT(keyHr != WRONG_VALUE_TYPE);
        }

        // Did we find the value?
        if (SUCCEEDED(keyHr) && !data.empty())
        {
            found = true;
        }
    }

    return found;
}


bool
IsHardened(const String& keyName)
{
   LOG_FUNCTION2(IsHardened, keyName);

   // By default, IE security is not hardened.
   bool hardened = false;
   RegistryKey key;

   static const String IE_HARD_VALUE (L"IsInstalled");
   static const DWORD HARD_SECURITY = 1;
   static const DWORD SOFT_SECURITY = 0;

   do
   {
      HRESULT hr = key.Open(HKEY_LOCAL_MACHINE, keyName);

      // If key not found, assume default setting.
      BREAK_ON_FAILED_HRESULT(hr);

      DWORD setting = 0;
      hr = key.GetValue(IE_HARD_VALUE, setting);

      // If value not found, assume default setting.
      BREAK_ON_FAILED_HRESULT(hr);

      if (setting == HARD_SECURITY)
      {
         hardened = true;
      }
      else if (setting == SOFT_SECURITY)
      {
         hardened = false;
      }
      else
      {
         LOG(L"unexpected value for IE security level, assuming default level");
      }

   } while(false);

   key.Close();

   LOG_BOOL(hardened);
   return hardened;
}

#ifdef LOGGING_BUILD
static const String HARDENED_LEVEL [] = {
   L"NO_HARDENING",
   L"USERS_HARDENED",
   L"ADMINS_HARDENED",
   L"ALL_HARDENED"
};
#endif

HardenedLevel
GetIEHardLevel()
{
   LOG_FUNCTION(GetIEHardLevel);

   static const String IE_HARD_ADMINS_KEY (L"SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{A509B1A7-37EF-4b3f-8CFC-4F3A74704073}");
   static const String IE_HARD_USERS_KEY (L"SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{A509B1A8-37EF-4b3f-8CFC-4F3A74704073}");

   HardenedLevel level = NO_HARDENING;

   bool usersHard = IsHardened(IE_HARD_USERS_KEY);
   bool adminsHard = IsHardened(IE_HARD_ADMINS_KEY);

   if (adminsHard && usersHard)
   {
      level = ALL_HARDENED;
   }
   else if (adminsHard)
   {
      level = ADMINS_HARDENED;
   }
   else if (usersHard)
   {
      level = USERS_HARDENED;
   }
   else
   {
      level = NO_HARDENING;
   }

   LOG(HARDENED_LEVEL[level]);

   return level;
}


void
TerminalServerParamSub(String& s)
{
    LOG_FUNCTION(TerminalServerParamSub);

    static const String tlsFound     = String::load(IDS_TS_LICENSING_FOUND);
    static const String tlsNotFound  = String::load(IDS_TS_LICENSING_NOT_FOUND);

    String description = FoundTSLicensingServer() ? tlsFound : tlsNotFound;

    // This lookup table needs to be the same size as the HardenedLevel
    // enumeration defined above, and should be in the same order.
    static const String TS_HARD_TABLE [] = {
       String::load(IDS_TS_IE_SOFTENED),
       String::load(IDS_TS_IE_HARDENED_USERS),
       String::load(IDS_TS_IE_HARDENED_ADMINS),
       String::load(IDS_TS_IE_HARDENED)
    };

    static const int DESCRIPTION_TABLE_SIZE = 
       sizeof(TS_HARD_TABLE) / sizeof(TS_HARD_TABLE[0]);

    HardenedLevel level = GetIEHardLevel();

    if (0 <= level && level < DESCRIPTION_TABLE_SIZE)
    {
       description += NEW_PARAGRAPH + TS_HARD_TABLE[level];
    }
    else
    {
       // Unexpected hardening level.
       LOG(L"unexpected hardening level");
       ASSERT(false);
       description += NEW_PARAGRAPH + TS_HARD_TABLE[0];
    }

    s = String::format(s, description.c_str());
}


//NTRAID#9-607219-30-Apr-2002-jrowlett
// callback function to fill out the web role xml to give to the HTA.
void
WebServerParamSub(String& s)
{
   // NTRAID#NTBUG9-665774-2002/07/17-artm
   // Need to customize role description based on if the machine is 64-bit or not.
   //   <Role
   //       name="Application Server"
   //       description="%1"
   //       mys_id="WebServer"
   //       >
   //       <Link
   //           description="%2"
   //           type="%3"
   //           command="%4"
   //           tooltip="Provides tools for using a Web browser to administer a Web server remotely."
   //           />

   LOG_FUNCTION(WebServerParamSub);
   
   String roleDesc;
   String webDesc; 
   String webType;
   String webCommand;

   if (State::GetInstance().Is64Bit())
   {
      roleDesc = String::load(IDS_WEB_SERVER_64_DESC);
   }
   else
   {
      roleDesc = String::load(IDS_WEB_SERVER_NO64_DESC);
   }

   if (IsSAKUnitInstalled(WEB))
   {
      webDesc    = String::load(IDS_WEB_SERVER_SAK_DESC);
      webType    = L"url";                                
      webCommand = GetSAKURL();
   }
   else
   {
      webDesc    = String::load(IDS_WEB_SERVER_NO_SAK_DESC);
      webType    = L"help";                                  
      webCommand = L"ntshowto.chm::/SAK_howto.htm";           
   }
   
   s =
      String::format(
         s,
         roleDesc.c_str(),
         webDesc.c_str(),
         webType.c_str(),
         webCommand.c_str());
}




void
Pop3ServerParamSub(String& s)
{
   LOG_FUNCTION(Pop3ServerParamSub);

   static String pop3ConsolePath;

   if (pop3ConsolePath.empty())
   {
      // initialize the path from the registry
      
      do
      {
         RegistryKey key;

         HRESULT hr =
            key.Open(
               HKEY_LOCAL_MACHINE,
               L"Software\\Microsoft\\Pop3 Service",
               KEY_READ);
         BREAK_ON_FAILED_HRESULT(hr);

         // not the file, like you might think from the name, but the
         // folder the file is in.  Bother.
         
         hr = key.GetValue(L"ConsoleFile", pop3ConsolePath);
         BREAK_ON_FAILED_HRESULT(hr);

         pop3ConsolePath = FS::AppendPath(pop3ConsolePath, L"p3server.msc");
         
         if (!FS::PathExists(pop3ConsolePath))
         {
            // the path had better exist if the reg key is present!

            ASSERT(false);
            LOG(L"pop3 console is not present");
            pop3ConsolePath.erase();
         }
      }
      while (0);
   }

   s =
      String::format(
         s,
            pop3ConsolePath.empty()

            // If we can't find it, then hope that the console is on the
            // search path
            
         ?  L"&quot;p3server.msc&quot;"
         :  (QUOT + pop3ConsolePath + QUOT).c_str());
}


// NTRAID#NTBUG9-698722-2002/09/03-artm
//
// Replace the DCPromo status check function pointer
// with one appropriate for MYS.
//
// This is a little bit of a hack, but there isn't
// a better alternative...
void
ManageYourServer::InitDCPromoStatusCheck()
{
   LOG_FUNCTION(ManageYourServer::InitDCPromoStatusCheck);

   size_t roleCount = GetServerRoleStatusTableElementCount();
      
   for (size_t i = 0; i < roleCount; ++i)
   {
      if (serverRoleStatusTable[i].role == DC_SERVER)
      {
         serverRoleStatusTable[i].Status = GetDCStatusForMYS;
         // Sanity check.
         ASSERT(serverRoleStatusTable[i].Status);
         break;
      }
   }
}



void
ManageYourServer::BuildFragMap()
{
   LOG_FUNCTION(ManageYourServer::BuildFragMap);

   fragMap.insert(
      RoleToFragmentNameMap::value_type(
         DHCP_SERVER,
         std::make_pair(
            String(L"DhcpServerRole.xml"),
            (ParamSubFunc) 0) ) );

   fragMap.insert(
      RoleToFragmentNameMap::value_type(
         WINS_SERVER,
         std::make_pair(
            String(L"WinsServerRole.xml"),
            (ParamSubFunc) 0) ) );
      
   fragMap.insert(
      RoleToFragmentNameMap::value_type(
         RRAS_SERVER,
         std::make_pair(
            String(L"RrasServerRole.xml"),
            (ParamSubFunc) 0) ) );
      
   fragMap.insert(
      RoleToFragmentNameMap::value_type(
         TERMINALSERVER_SERVER,
         std::make_pair(
            String(L"TerminalServerRole.xml"),
            (ParamSubFunc) TerminalServerParamSub) ) );
      
   fragMap.insert(
      RoleToFragmentNameMap::value_type(
         FILESERVER_SERVER,
         std::make_pair(
            String(L"FileServerRole.xml"),
            (ParamSubFunc) 0) ) );
      
   fragMap.insert(
      RoleToFragmentNameMap::value_type(
         PRINTSERVER_SERVER,
         std::make_pair(
            String(L"PrintServerRole.xml"),
            (ParamSubFunc) 0) ) );
      
   fragMap.insert(
      RoleToFragmentNameMap::value_type(
         MEDIASERVER_SERVER,
         std::make_pair(
            String(L"MediaServerRole.xml"),
            (ParamSubFunc) 0) ) );
   
   fragMap.insert(
      RoleToFragmentNameMap::value_type(
         WEBAPP_SERVER,
         std::make_pair(
            String(L"WebServerRole.xml"),
            (ParamSubFunc) WebServerParamSub) ) );
            
   fragMap.insert(
      RoleToFragmentNameMap::value_type(
         DC_SERVER,
         std::make_pair(
            String(L"DomainControllerRole.xml"),
            (ParamSubFunc) 0) ) );
            
   fragMap.insert(
      RoleToFragmentNameMap::value_type(
         POP3_SERVER,
         std::make_pair(
            String(L"Pop3ServerRole.xml"),
            (ParamSubFunc) Pop3ServerParamSub) ) );
            
   fragMap.insert(
      RoleToFragmentNameMap::value_type(
         DNS_SERVER,
         std::make_pair(
            String(L"DnsServerRole.xml"),
            (ParamSubFunc) 0) ) );

   ASSERT(fragMap.size() == GetServerRoleStatusTableElementCount());
}



ManageYourServer::ManageYourServer()
   :
   refcount(1), // implicit AddRef
   roleStatus(),
   foundTLS(false),
   ieSecurity(NO_HARDENING)
{
   LOG_CTOR(ManageYourServer);

   m_ppTypeInfo = new ITypeInfo*[NUMBER_OF_AUTOMATION_INTERFACES];

   for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
   {
      m_ppTypeInfo[i] = NULL;
   }

   ITypeLib *ptl = 0;
   HRESULT hr = LoadRegTypeLib(LIBID_ManageYourServerLib, 1, 0, 0, &ptl);
   if (SUCCEEDED(hr))
   {
      ptl->GetTypeInfoOfGuid(IID_IManageYourServer, &(m_ppTypeInfo[0]));
      ptl->Release();
   }

   if (!isDCCheckInitialized)
   {
      InitDCPromoStatusCheck();
      isDCCheckInitialized = true;
   }

   if (!fragMapBuilt)
   {
      BuildFragMap();
      fragMapBuilt = true;
   }

   foundTLS = FoundTSLicensingServer();
   ieSecurity = GetIEHardLevel();
}



ManageYourServer::~ManageYourServer()
{
   LOG_DTOR(ManageYourServer);
   ASSERT(refcount == 0);

   for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
   {
      m_ppTypeInfo[i]->Release();
   }

   delete[] m_ppTypeInfo;
}



HRESULT __stdcall
ManageYourServer::QueryInterface(REFIID riid, void **ppv)
{
   LOG_FUNCTION(ManageYourServer::QueryInterface);

   if (riid == IID_IUnknown)
   {
      LOG(L"IUnknown");

      *ppv =
         static_cast<IUnknown*>(static_cast<IManageYourServer*>(this));
   }
   else if (riid == IID_IManageYourServer)
   {
      LOG(L"IManageYourServer");

      *ppv = static_cast<IManageYourServer*>(this);
   }
   else if (riid == IID_IDispatch && m_ppTypeInfo[0])
   {
      LOG(L"IDispatch");

      *ppv = static_cast<IDispatch*>(this);
   }
// CODEWORK
//    else if (riid == IID_ISupportErrorInfo)
//    {
//       LOG(L"ISupportErrorInfo");
// 
//       *ppv = static_cast<ISupportErrorInfo*>(this);
//    }
   else
   {
      LOG(L"unknown interface queried");

      return (*ppv = 0), E_NOINTERFACE;
   }

   reinterpret_cast<IUnknown*>(*ppv)->AddRef();
   return S_OK;
}



ULONG __stdcall
ManageYourServer::AddRef(void)
{
   LOG_ADDREF(ManageYourServer);

   return Win::InterlockedIncrement(refcount);
}



ULONG __stdcall
ManageYourServer::Release(void)
{
   LOG_RELEASE(ManageYourServer);

   // need to copy the result of the decrement, because if we delete this,
   // refcount will no longer be valid memory, and that might hose
   // multithreaded callers.  NTRAID#NTBUG9-566901-2002/03/06-sburns
   
   long newref = Win::InterlockedDecrement(refcount);
   if (newref == 0)
   {
      delete this;
      return 0;
   }

   // we should not have decremented into negative values.
   
   ASSERT(newref > 0);

   return newref;
}



HRESULT __stdcall
ManageYourServer::GetTypeInfoCount(UINT *pcti)
{
   LOG_FUNCTION(ManageYourServer::GetTypeInfoCount);

    if (pcti == 0)
    {
      return E_POINTER;
    }

    *pcti = 1;
    return S_OK;
}



HRESULT __stdcall
ManageYourServer::GetTypeInfo(UINT cti, LCID, ITypeInfo **ppti)
{
   LOG_FUNCTION(ManageYourServer::GetTypeInfo);

   if (ppti == 0)
   {
      return E_POINTER;
   }
   if (cti != 0)
   {
      *ppti = 0;
      return DISP_E_BADINDEX;
   }

   (*ppti = m_ppTypeInfo[0])->AddRef();
   return S_OK;
}



HRESULT __stdcall
ManageYourServer::GetIDsOfNames(
   REFIID  riid,    
   OLECHAR **prgpsz,
   UINT    cNames,  
   LCID    lcid,    
   DISPID  *prgids) 
{
   LOG_FUNCTION(ManageYourServer::GetIDsOfNames);

   HRESULT hr = S_OK;
   for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
   {
     hr = (m_ppTypeInfo[i])->GetIDsOfNames(prgpsz, cNames, prgids);
     if (SUCCEEDED(hr) || DISP_E_UNKNOWNNAME != hr)
       break;
   }

   return hr;
}



HRESULT __stdcall
ManageYourServer::Invoke(
   DISPID     id,         
   REFIID     riid,       
   LCID       lcid,       
   WORD       wFlags,     
   DISPPARAMS *params,    
   VARIANT    *pVarResult,
   EXCEPINFO  *pei,       
   UINT       *puArgErr) 
{
   LOG_FUNCTION(ManageYourServer::Invoke);

   HRESULT    hr = S_OK;
   IDispatch *pDispatch[NUMBER_OF_AUTOMATION_INTERFACES] =
   {
      (IDispatch*)(IManageYourServer *)(this),
   };

   for (int i = 0; i < NUMBER_OF_AUTOMATION_INTERFACES; i++)
   {
      hr =
         (m_ppTypeInfo[i])->Invoke(
            pDispatch[i],
            id,
            wFlags,
            params,
            pVarResult,
            pei,
            puArgErr);

      if (DISP_E_MEMBERNOTFOUND != hr)
        break;
   }

   return hr;
}



// HRESULT __stdcall
// ManageYourServer::InterfaceSupportsErrorInfo(const IID& iid)
// {
//    LOG_FUNCTION(ManageYourServer::InterfaceSupportsErrorInfo);
// 
//    if (iid == IID_IManageYourServer) 
//    {
//       return S_OK;
//    }
// 
//    return S_FALSE;
// }



void
ManageYourServer::GetRoleStatus(RoleStatusVector& stat)
{
   LOG_FUNCTION(ManageYourServer::GetRoleStatus);

   size_t roleCount = GetServerRoleStatusTableElementCount();
   
   stat.clear();
   stat.resize(roleCount);
   
   for (size_t i = 0; i < roleCount; ++i)
   {
      ASSERT(serverRoleStatusTable[i].Status);
      
      stat[i].role   = serverRoleStatusTable[i].role;    
      stat[i].status = serverRoleStatusTable[i].Status();

      // this is for debugging
      // stat[i].status = STATUS_CONFIGURED;
         
      LOG(
         String::format(
            L"role = %1!d! status = %2",
            stat[i].role,
            statusStrings[stat[i].status].c_str()));
   }
}
   


void
ManageYourServer::AppendXmlFragment(
   String&        s,
   const String&  fragName,
   ParamSubFunc   subFunc)
{
   LOG_FUNCTION2(ManageYourServer::AppendXmlFragment, fragName);
   ASSERT(!fragName.empty());

   // Look up the resource by name, load it into a string, and append
   // the string to s.

   String fragment;
   size_t fragmentCharCount = 0;
   
   HRESULT hr = S_OK;
   do
   {
      HRSRC rsc = 0;
      hr = Win::FindResource(fragName.c_str(), RT_HTML, rsc);
      BREAK_ON_FAILED_HRESULT2(hr, L"Find Resource");

      DWORD resSize = 0;
      hr = Win::SizeofResource(rsc, resSize);
      BREAK_ON_FAILED_HRESULT2(hr, L"SizeofResource");

      if (!resSize)
      {
         hr = E_FAIL;
         BREAK_ON_FAILED_HRESULT2(hr, L"resource is size 0");
      }

      // we don't expect the xml fragments to be larger than this.
      // NTRAID#NTBUG9-628965-2002/05/29-artm
      // Resource limit was too small.  Increasing to 1MB.
      
      static const size_t RES_MAX_BYTES = 1024 * 1024;

      if (resSize > RES_MAX_BYTES)
      {
         hr = E_FAIL;
         BREAK_ON_FAILED_HRESULT2(hr, L"resource is too big");
      }

      HGLOBAL glob = 0;
      hr = Win::LoadResource(rsc, glob);
      BREAK_ON_FAILED_HRESULT2(hr, L"Load Resource");

      void* data = ::LockResource(glob);
      if (!data)
      {
         hr = E_FAIL;
         BREAK_ON_FAILED_HRESULT2(hr, L"Lock Resource");
      }

      ASSERT(data);

      // at this point, we have a pointer to the beginning of the binary
      // resource data, which we know is a stream of unicode characters
      // beginning with 0xFFFE, and is resSize bytes large.

      const wchar_t* text = (wchar_t*) data;

      // FEFF == FFFE to you and me. hey, that rhymes!
      
      static const int FFFE    = 0xFEFF;
      ASSERT(text[0] == FFFE);

      // skip the leading marker.

      ++text;

      // character count is 1 less 'cause we skipped a the leading marker
      
      fragmentCharCount = resSize / sizeof(wchar_t) - 1;

      // +1 for paranoid null termination
      
      fragment.resize(fragmentCharCount + 1, 0);
      wchar_t* rawBuf = const_cast<wchar_t*>(fragment.c_str());
      
      // REVIEWED-2002/03/07-sburns correct byte count passed
      
      ::CopyMemory(rawBuf, text, fragmentCharCount * sizeof wchar_t);

      // now that we have a fragment, dike off the xml format tag. This is
      // to turn the text from a valid xml document to a fragment, which is
      // necessary because of a limitation of our xml localization tools.
      // NTRAID#NTBUG9-559423-2002/04/02-sburns
      //
      // Part II:  NTRAID#NTBUG9-620044-2002/05/12-artm
      // Apparently localization needs encoding="unicode" as an attribute 
      // on the process instruction.  To reduce resource churn and load
      // on localization---and to make this code more robust---we'll search
      // for any <?xml ... ?> processing instruction and replace it with an
      // empty string.  The code is uglier but less fragile.
      
      String::size_type endPosition = 0;
      String sub;

      // Look for an XML processing instruction.
      for (String::size_type nextPosition = fragment.find(OPEN_XML_PI);
          nextPosition != String::npos;
          nextPosition = fragment.find(OPEN_XML_PI))
      {
         // We found one, locate the end of the PI.
         endPosition = fragment.find(CLOSE_XML_PI);

         // Do a sanity check on the resources we've loaded.
         // The PI should be closed, and the closing should
         // come after the opening.  This should never happen.

         if (endPosition == String::npos || endPosition < nextPosition)
         {
            ASSERT(false);
            break;
         }

         // Move the end position past the end of the PI.
         endPosition += CLOSE_XML_PI.length();

         // Get the substring and replace it with an empty string.
         // The more elegant way to do this would be to call a different
         // version of replace() with the start position and max # characters;
         // however, the compiler cannot find that inherited overload.
         sub = fragment.substr(nextPosition, endPosition - nextPosition);
         fragment.replace(sub, L"");
      }

   }
   while (0);

   if (subFunc)
   {
      subFunc(fragment);
   }

   LOG(fragment);
   
   s.append(fragment);
}

  

HRESULT __stdcall
ManageYourServer::GetConfiguredRoleMarkup( 
   /* [retval][out] */ BSTR *result)
{
   LOG_FUNCTION(ManageYourServer::GetConfiguredRoleMarkup);
   ASSERT(result);

   HRESULT hr = S_OK;

   do
   {
      if (!result)
      {
         hr = E_INVALIDARG;
         break;
      }

      // Localization will need to include the encoding="unicode" attribute.  For
      // consistency we will use that encoding by default.  
      // NTRAID#NTBUG9-620044-2002/05/12-artm
      String s(L"<?xml version=\"1.0\" encoding=\"unicode\" ?>\n");
      s.append(L"<Roles>");

      GetRoleStatus(roleStatus);

      // Assemble the role markup fragments in the same order as in the
      // role status table used by CYS (which is the order that the roles
      // appear in the CYS role listbox.
      
      for (
         RoleStatusVector::iterator i = roleStatus.begin();
         i != roleStatus.end();
         ++i)
      {
         if (i->status == STATUS_CONFIGURED || i->status == STATUS_COMPLETED)
         {
            // find the corresponding XML fragment for the role.

            String fragmentName = fragMap[i->role].first;
            ASSERT(!fragmentName.empty());

            if (!fragmentName.empty())
            {
               AppendXmlFragment(s, fragmentName, fragMap[i->role].second);
            }
         }
      }

      s.append(L"</Roles>");
            
      *result = ::SysAllocString(s.c_str());

      // sort by role so that the comparison to old status vectors will work
      // with operator != in HasRoleStatusChanged
      
      std::sort(roleStatus.begin(), roleStatus.end());
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}



HRESULT __stdcall
ManageYourServer::HasRoleStatusChanged( 
   /* [retval][out] */ BOOL *result)
{
   LOG_FUNCTION(ManageYourServer::HasRoleStatusChanged);
   ASSERT(result);

   HRESULT hr = S_OK;

   do
   {
      if (!result)
      {
         hr = E_INVALIDARG;
         break;
      }

      *result = FALSE;

      RoleStatusVector newStatus;

      GetRoleStatus(newStatus);

      // sort by role so that the comparison to old status vectors will work
      // with operator != 
      
      std::sort(newStatus.begin(), newStatus.end());

      HardenedLevel currentSecurity = GetIEHardLevel();
      
      if (newStatus != roleStatus)
      {
         *result = TRUE;
         roleStatus = newStatus;
      }
      else if (FoundTSLicensingServer() != foundTLS)
      {
         // NTRAID#NTBUG9-626890-2002/07/03-artm
         // If a TS licensing server comes on line, that counts as a role status change.
         foundTLS = !foundTLS;
         *result = TRUE;
      }
      else if (currentSecurity != ieSecurity)
      {
         // If the IE security settings have changed, that counts
         // as a role status change (b/c it updates TS text).
         // NTRAID#NTBUG9-760269-2003/01/07-artm
         ieSecurity = currentSecurity;
         *result = TRUE;
      }

      LOG_BOOL(*result);
            
      // CODEWORK:
      // the links can change based on the installation of add-ons, even
      // if the role has not changed:
      // fileserver: sak becomes installed, server mgmt becomes installed
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}




HRESULT __stdcall
ManageYourServer::IsClusterNode( 
  /* [retval][out] */ BOOL *result)
{
   LOG_FUNCTION(ManageYourServer::IsClusterNode);

   ASSERT(result);

   HRESULT hr = S_OK;

   do
   {
      if (!result)
      {
         hr = E_INVALIDARG;
         break;
      }

      *result = IsClusterServer() ? TRUE : FALSE;
      LOG_BOOL(*result);      
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}
   


HRESULT __stdcall
ManageYourServer::IsCurrentUserAnAdministrator(
   /* [out, retval] */ BOOL* result)
{   
   LOG_FUNCTION(ManageYourServer::IsCurrentUserAnAdministrator);

   ASSERT(result);

   HRESULT hr = S_OK;

   do
   {
      if (!result)
      {
         hr = E_INVALIDARG;
         break;
      }

      *result = IsCurrentUserAdministrator() ? TRUE : FALSE;
      LOG_BOOL(*result);      
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}



HRESULT __stdcall
ManageYourServer::IsSupportedSku(
   /* [out, retval] */ BOOL* result)
{   
   LOG_FUNCTION(ManageYourServer::IsSupportedSku);

   ASSERT(result);

   HRESULT hr = S_OK;

   do
   {
      if (!result)
      {
         hr = E_INVALIDARG;
         break;
      }

      *result = ::IsSupportedSku() ? TRUE : FALSE;
      LOG_BOOL(*result);      
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}



HRESULT __stdcall
ManageYourServer::IsStartupFlagSet(
   /* [out, retval] */ BOOL* result)
{
   LOG_FUNCTION(ManageYourServer::IsStartupFlagSet);
   
   ASSERT(result);

   HRESULT hr = S_OK;

   do
   {
      if (!result)
      {
         hr = E_INVALIDARG;
         break;
      }

      *result = ::IsStartupFlagSet();

      LOG_BOOL(*result);
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}
      

    
HRESULT __stdcall
ManageYourServer::SetRunAtLogon(
   /* [in] */ BOOL newState)
{
   LOG_FUNCTION2(
      ManageYourServer::SetRunAtLogon,
      newState ? L"TRUE" : L"FALSE");

   HRESULT hr = S_OK;

   do
   {
      // we only need to set the uplevel flag, since this will only run on an
      // uplevel machine.

      RegistryKey key;

      hr = key.Create(HKEY_CURRENT_USER, SZ_REGKEY_SRVWIZ_ROOT);
      BREAK_ON_FAILED_HRESULT2(hr, L"Create key");

      hr = key.SetValue(L"", newState ? 1 : 0);
      BREAK_ON_FAILED_HRESULT2(hr, L"Set Value");

      hr = key.Close();
      BREAK_ON_FAILED_HRESULT2(hr, L"Close key");
      
      // NTRAID#NTBUG9-627785-2002/05/22-artm  
      // Need to update REGTIPS key as well if it exists, o'wise user's setting is potentially
      // ignored.

      hr = key.Open(HKEY_CURRENT_USER, REGTIPS, KEY_WRITE);
      if (SUCCEEDED(hr))
      {
          hr = key.SetValue(L"Show", newState ? 1 : 0);

          // If this failed we still want to remove the obsolete
          // key if it exists.
          //BREAK_ON_FAILED_HRESULT2(hr, L"Set Tips Value");
      }

      // attempt to remove the obsolete Win2k value so that it doesn't
      // enter into the "should run" equation.

      HRESULT hr2 =
         Win32ToHresult(
            ::SHDeleteValue(HKEY_CURRENT_USER, SZ_REGKEY_W2K, SZ_REGVAL_W2K));
      if (FAILED(hr2))
      {
         // this is not a problem: if the key is not there, fine. If it
         // is and we can't remove it, oh well.
         
         LOG(String::format(L"failed to delete win2k value %1!08X!", hr2));
      }
   }
   while (0);
      
   LOG_HRESULT(hr);   

   return hr;   
}

#define WSZ_FILE_SERVMGMT_MSC   L"\\administration\\servmgmt.msc"

// NTRAID#NTBUG9-530202-29-Mar-2002-jrowlett
// support needed to check if link is valid
HRESULT __stdcall
ManageYourServer::IsServerManagementConsolePresent(
   /* [out, retval] */ BOOL* result)
{   
   LOG_FUNCTION(ManageYourServer::IsServerManagementConsolePresent);

   ASSERT(result);

   HRESULT hr = S_OK;

   do
   {
      if (!result)
      {
         hr = E_INVALIDARG;
         break;
      }
     
      String serverManagementConsole =
         Win::GetSystemDirectory() + WSZ_FILE_SERVMGMT_MSC;

      LOG(String::format(
         L"Server Management Console = %1",
         serverManagementConsole.c_str()));
      
      *result = FS::FileExists(serverManagementConsole) ? TRUE : FALSE;

      LOG_BOOL(*result);      
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}

// NTRAID#NTBUG9-602954-29-Apr-2002-jrowlett
// support needed to show or hide check box is the policy is configured and enabled.
HRESULT __stdcall
ManageYourServer::IsShowAtStartupPolicyEnabled(
   /* [out, retval] */ BOOL* result)
{   
   LOG_FUNCTION(ManageYourServer::IsShowAtStartupPolicyEnabled);

   ASSERT(result);

   HRESULT hr = S_OK;
   DWORD dwType = REG_DWORD;
   DWORD dwData = 0;
   DWORD cbSize = sizeof(dwData);

   do
   {
      if (!result)
      {
         hr = E_INVALIDARG;
         break;
      }

      // If group policy is set for "Don't show MYS",
      // then don't show MYS regardless of user setting

      *result = !::ShouldShowMYSAccordingToPolicy();

      // failure is interpreted as if the policy is "not configured"
     
      LOG_BOOL(*result);      
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}

// NTRAID#NTBUG9-627875-2002/05/22-artm
// support hiding startup checkbox when running on datacenter servers
HRESULT __stdcall
ManageYourServer::IsDatacenterServer(
   /* [out, retval] */ BOOL* result)
{   
   LOG_FUNCTION(ManageYourServer::IsDatacenterServer);

   ASSERT(result);

   HRESULT hr = S_OK;

   do
   {
      if (!result)
      {
         hr = E_INVALIDARG;
         break;
      }

      *result = FALSE;

      if (State::GetInstance().GetProductSKU() & CYS_DATACENTER_SERVER)
      {
          *result = TRUE;
      }

      LOG_BOOL(*result);

   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}

// NTRAID#NTBUG9-648428-2002/06/25-artm
// support hiding web application server console link if on IA64
HRESULT __stdcall
ManageYourServer::IsWebServerConsolePresent(
    /* [out, retval] */ BOOL* result )
{
    LOG_FUNCTION(ManageYourServer::IsWebServerConsolePresent);

    HRESULT hr = S_OK;

    if (result)
    {
        static String sys32 = Win::GetSystemDirectory();
        static String webmgmtPath = FS::AppendPath(sys32, String::load(IDS_WEB_SERVER_MSC));

        *result = FS::PathExists(webmgmtPath);
        LOG_BOOL(*result);
    }
    else
    {
        ASSERT(false);
        hr = E_INVALIDARG;
    }

    return hr;
}

// NTRAID#NTBUG9-632113-2002/07/01-artm
// support saving collapsed/expanded state of role nodes
HRESULT __stdcall
ManageYourServer::CollapseRole(
    /* [in] */ BSTR roleId, /* [in] */ BOOL collapse )
{
    LOG_FUNCTION(ManageYourServer::CollapseRole);
    ASSERT(roleId);

    HRESULT hr = S_OK;

    do
    {
        RegistryKey key;

        if (!roleId)
        {
            hr = E_INVALIDARG;
            break;
        }

        hr = key.Create(HKEY_CURRENT_USER, SZ_REGKEY_SRVWIZ_ROOT);
        BREAK_ON_FAILED_HRESULT2(hr, L"Create key");

        // Update the collapsed state for the given role.
        hr = key.SetValue(roleId, collapse ? 1 : 0);
        BREAK_ON_FAILED_HRESULT2(hr, L"Set Value");

        hr = key.Close();
        BREAK_ON_FAILED_HRESULT2(hr, L"Close key");
        
    }
    while (0);
      
    LOG_HRESULT(hr);   

    return hr;
}


// NTRAID#NTBUG9-632113-2002/07/01-artm
// support checking collapsed state of role nodes
HRESULT __stdcall
ManageYourServer::IsRoleCollapsed(
    /* [in] */ BSTR roleId, /* [out, retval] */ BOOL* result)
{
    LOG_FUNCTION(ManageYourServer::IsRoleCollapsed);
    ASSERT(result);
    ASSERT(roleId);

    HRESULT hr = S_OK;

    do // false loop
    {
        if (!result || !roleId)
        {
            hr = E_INVALIDARG;
            break;
        }

        DWORD data = 0;
        *result = FALSE;

        // The role is only collapsed if it has a non-zero saved value.

        bool regResult =
            GetRegKeyValue(
                SZ_REGKEY_SRVWIZ_ROOT,
                roleId,
                data,
                HKEY_CURRENT_USER);

        if (regResult && (data != 0))
        {
            *result = TRUE;
        }

    } while(0);

    LOG_HRESULT(hr);

    return hr;
}

// NTRAID#NTBUG9-680200-2002/08/01-artm
// Support retrieving working area of the display.
//
// Area info is returned as a comma separated string b/c JScript does not
// support getting back SAFEARRAY's.  
// 
// e.g. "0,0,800,600"  --> working area is 800 wide, 600 high, and starts at
//                         screen position (0,0)
HRESULT __stdcall
ManageYourServer::GetWorkingAreaInfo(
    /* [out, retval] */ BSTR* info)
{
    LOG_FUNCTION(ManageYourServer::GetDisplayWorkingArea);

    if (!info)
    {
        ASSERT(NULL != info);
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    *info = NULL;

    do // false loop
    {
        static const String AREA_FORMAT_STRING = L"%1!d!,%2!d!,%3!d!,%4!d!";

        // Get the area info from the system.

        RECT area;
        ::ZeroMemory(&area, sizeof(RECT));

        BOOL success = SystemParametersInfo(
            SPI_GETWORKAREA,
            0,
            &area,
            0);

        if (!success)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        // Copy the area info to the return parameter.

        String result;

        try
        {
            // The (right, bottom) point of the area is not
            // inclusive.  In other words, if we get back
            // (0, 0) and (800, 600), the point (800, 600)
            // should not be considered to be in the display 
            // area.  If it was the width and height would
            // actually be 801 and 601, respectively.
            result = String::format(
                AREA_FORMAT_STRING,
                area.left,
                area.top,
                area.right - area.left,   // width
                area.bottom - area.top);  // height
        }
        catch (const std::bad_alloc&)
        {
            hr = E_OUTOFMEMORY;
        }

        if (FAILED(hr))
        {
            break;
        }

        *info = ::SysAllocString(result.c_str());
        if (NULL == *info)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    while(false);

    LOG_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

#define IDI_MAIN                    1000

#define IDS_FILE_SERVER_MSC         1001
#define IDS_FILE_SERVER_MSC_TOOLTIP 1002
#define IDS_SERVER_MGMT_MSC         1003

#define IDS_WEB_SERVER_SAK_DESC 1007
#define IDS_WEB_SERVER_NO_SAK_DESC  1008
#define IDS_START_MENU_TOOLTIP 1009
#define IDS_START_MENU_NAME 1010
#define IDS_WEB_SERVER_MSC 1011
#define IDS_TS_LICENSING_FOUND      1012
#define IDS_TS_LICENSING_NOT_FOUND  1013
#define IDS_WEB_SERVER_64_DESC      1014
#define IDS_WEB_SERVER_NO64_DESC    1015
#define IDS_TS_IE_HARDENED          1016
#define IDS_TS_IE_HARDENED_ADMINS   1017
#define IDS_TS_IE_HARDENED_USERS    1018
#define IDS_TS_IE_SOFTENED          1019

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\setcomerror.hpp ===
// Copyright (C) 1999-2000 Microsoft Corporation
//
// SetComError routines
//
// sburns 5-3-99



void
SetComError(
   const String&  desciption,
   DWORD          helpContext = 0);



void
SetComError(
   unsigned descriptionMessageResID,
   DWORD    helpContext = 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\setcomerror.cpp ===
// Copyright (C) 1999-2000 Microsoft Corporation
//
// SetComError routines
//
// sburns 5-3-99



#include "headers.hxx"
#include "common.hpp"



void
SetComError(
   unsigned descriptionMessageResID,
   DWORD    helpContext)
{
   SetComError(String::load(descriptionMessageResID), helpContext);
}



void
SetComError(
   const String&  description,
   DWORD          helpContext)
{
   LOG_FUNCTION2(SetComError, description);

   ICreateErrorInfo* cei = 0;
   HRESULT hr = S_OK;

   do
   {
      hr = ::CreateErrorInfo(&cei);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = cei->SetGUID(IID_IConfigureYourServer);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = cei->SetSource(PROGID_VERSION_STRING);
      BREAK_ON_FAILED_HRESULT(hr);

      hr =
         cei->SetDescription(
            const_cast<String::value_type*>(description.c_str()));
      BREAK_ON_FAILED_HRESULT(hr);

      hr = cei->SetHelpFile(L"" /* HELPFILE_NAME */ );
      BREAK_ON_FAILED_HRESULT(hr);

      hr = cei->SetHelpContext(helpContext);
      BREAK_ON_FAILED_HRESULT(hr);

      SmartInterface<IErrorInfo> ei;
      hr = ei.AcquireViaQueryInterface(*cei);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = ::SetErrorInfo(0, ei);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (cei)
   {
      cei->Release();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\mys\util.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// utility grab bag
//
// 28 Mar 2000 sburns



#ifndef UTIL_HPP_INCLUDED
#define UTIL_HPP_INCLUDED



HRESULT
CreateAndWaitForProcess(const String& commandLine, DWORD& exitCode);



DWORD
MyWaitForSendMessageThread(HANDLE hThread, DWORD dwTimeout);



#endif   // UTIL_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\au_accnt\accntwiz.cpp ===
// AccntWiz.cpp : Implementation of CAddUser_AccntWiz
#include "stdafx.h"
#include "AU_Accnt.h"
#include "AccntWiz.h"

// ----------------------------------------------------------------------------
// Constructor
// ----------------------------------------------------------------------------
CAddUser_AccntWiz::CAddUser_AccntWiz() :
    m_AcctP(this),
    m_PasswdP(this)
{
    m_bFirstTime    = TRUE;
}

// ----------------------------------------------------------------------------
// Destructor
// ----------------------------------------------------------------------------
CAddUser_AccntWiz::~CAddUser_AccntWiz()
{
}

// ----------------------------------------------------------------------------
// EnumPropertySheets()
// ----------------------------------------------------------------------------
HRESULT CAddUser_AccntWiz::EnumPropertySheets( IAddPropertySheet* pADS )
{   
    HRESULT hr;
    
    // Add the User Account Information page.
    hr = pADS->AddPage( m_AcctP );
    if( FAILED(hr) )
        return hr;

    // Add the Password Generation page.
    hr = pADS->AddPage( m_PasswdP );
    if( FAILED(hr) )
        return hr;    

    return S_FALSE;
}

// ----------------------------------------------------------------------------
// ProvideFinishText()
// ----------------------------------------------------------------------------
HRESULT CAddUser_AccntWiz::ProvideFinishText( LPOLESTR* lpolestrString, LPOLESTR* lpMoreInfoText )
{
    CWaitCursor cWaitCur;
    *lpolestrString = NULL;
    
    CString str = _T("");
    
    str.LoadString( IDS_FIN_TEXT );
    
    m_AcctP.ProvideFinishText  ( str );    
    
    if( !(*lpolestrString = (LPOLESTR)CoTaskMemAlloc( (str.GetLength() + 1) * sizeof(OLECHAR) )) )
        return E_OUTOFMEMORY;
    
    wcscpy( *lpolestrString, str );

    *lpMoreInfoText = NULL;

    return S_OK;
}

// ----------------------------------------------------------------------------
// ReadProperties()
// ----------------------------------------------------------------------------
HRESULT CAddUser_AccntWiz::ReadProperties( IPropertyPagePropertyBag* pPPPBag )
{
    if( m_bFirstTime == TRUE ) 
    {
        CWaitCursor cWaitCur;        
        
        m_bFirstTime = FALSE;   // only once.        
    
        // Let the pages read the property bag.
        m_AcctP.ReadProperties  ( pPPPBag );
        m_PasswdP.ReadProperties( pPPPBag );        
    }

    return S_OK;
}

// ----------------------------------------------------------------------------
// WriteProperties()
// ----------------------------------------------------------------------------
HRESULT CAddUser_AccntWiz::WriteProperties( IPropertyPagePropertyBag* pPPPBag )
{
    CWaitCursor cWaitCur;

    // Have the pages write out their values into the property bag.
    m_AcctP.WriteProperties  ( pPPPBag );
    m_PasswdP.WriteProperties( pPPPBag );    

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\au_accnt\accntcmt.h ===
// AccntCmt.h : Declaration of the CAddUser_AccntCommit

#ifndef _ACCNTCMT_H
#define _ACCNTCMT_H

#include "AUsrUtil.h"
#include "resource.h"       // main symbols

#define ERROR_CREATION      0x01
#define ERROR_PROPERTIES    0x02
#define ERROR_MAILBOX       0x04
#define ERROR_MEMBERSHIPS   0x08
#define ERROR_PASSWORD      0x10
#define ERROR_DUPE          0x20

class CAddUser_AccntCommit;

// ----------------------------------------------------------------------------
// class CUserInfo
// ----------------------------------------------------------------------------
class CUserInfo
{
    public:
        CUserInfo(IPropertyPagePropertyBag * pPPPBag, CAddUser_AccntCommit * pCmt);

        HRESULT ReadBag();    
        HRESULT CreateAccount();
        HRESULT CreateMailbox();        
        HRESULT CreatePOP3Mailbox();
        HRESULT SetPasswd();   
        HRESULT JoinToDomainUsers();
        
    private:

        // User Stuff
        CString m_csUserOU;
        CString m_csUserName;
        CString m_csUserCN;
        CString m_csPasswd;
        CString m_csUserNamePre2k;
        CString m_csFirstName;
        CString m_csLastName;
        CString m_csFullName;
        CString m_csTelephone;
        CString m_csOffice;
        CString m_csDesc;                
        DWORD   m_dwAccountOptions;
        
        // Server Stuff
        CString m_csLogonDns;        
        CString m_csDomainName;
        CString m_csFQDomainName;
        
        // Mailbox stuff        
        BOOL    m_bPOP3;
        CString m_csEXAlias;
        CString m_csEXServer;
        CString m_csEXHomeServer;
        CString m_csEXHomeMDB;
        
        IPropertyPagePropertyBag * m_pPPPBag;
        CAddUser_AccntCommit     * m_pCmt;		
};


// ----------------------------------------------------------------------------
// CAddUser_AccntCommit
// ----------------------------------------------------------------------------
class ATL_NO_VTABLE CAddUser_AccntCommit : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAddUser_AccntCommit, &CLSID_AddUser_AccntCommit>,
    public IDispatchImpl<IWizardCommit, &__uuidof(IWizardCommit), &LIBID_ACCNTDLLLib>
{
    public:
        CAddUser_AccntCommit()
        {
            m_dwErrCode = 0;
            m_csErrStr  = L"";
            m_csADName  = L"";
        }
    
        DECLARE_REGISTRY_RESOURCEID(IDR_AUSR_ACCNT_COMMIT)
        DECLARE_NOT_AGGREGATABLE(CAddUser_AccntCommit)
        
        DECLARE_PROTECT_FINAL_CONSTRUCT()
        
        BEGIN_COM_MAP(CAddUser_AccntCommit)
            COM_INTERFACE_ENTRY(IWizardCommit)
            COM_INTERFACE_ENTRY(IDispatch)
        END_COM_MAP()
    
        // IWizardCommit
        STDMETHOD(Commit)(IDispatch * pdispPPPBag);
        STDMETHOD(Revert)();
    
        // IAddUser_AccntCommit
        DWORD       m_dwErrCode;
        CString     m_csErrStr;
        CString     m_csADName;

        void    SetErrCode          (DWORD dwCode);
        HRESULT SetErrorResults     (DWORD dwErrType, BOOL bPOP3 = FALSE);
        HRESULT WriteErrorResults   (IPropertyPagePropertyBag* pPPPBag);
};

#endif //_ACCNTCMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\au_accnt\accntwiz.h ===
// AccntWiz.h : Declaration of the CAddUser_AccntWiz

#ifndef _ACCNTWIZ_H
#define _ACCNTWIZ_H

#include "AU_Accnt.h"
#include "resource.h"       // main symbols

// include files for individual pages
#include "CAcctP.h"
#include "CPasswdP.h"

/////////////////////////////////////////////////////////////////////////////
// CAddUser_AccntWiz
class ATL_NO_VTABLE CAddUser_AccntWiz : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAddUser_AccntWiz, &CLSID_AddUser_AccntWiz>,
    public IAddPropertySheets
{
    private:
        CPasswdPage m_PasswdP;      // Password Generation page.        
        BOOL        m_bFirstTime;   // for Init(s)
    
    public:
        CAcctPage   m_AcctP;        // User Account Information page.

        CAddUser_AccntWiz();
        ~CAddUser_AccntWiz();
        
        DECLARE_REGISTRY_RESOURCEID(IDR_AUSR_ACCNT_WIZ)
        DECLARE_NOT_AGGREGATABLE(CAddUser_AccntWiz)
        
        DECLARE_PROTECT_FINAL_CONSTRUCT()
        
        BEGIN_COM_MAP(CAddUser_AccntWiz)
            COM_INTERFACE_ENTRY(IAddPropertySheets)
        END_COM_MAP()
    
    // IAddPropertySheets
    public:
        STDMETHOD(EnumPropertySheets)(IAddPropertySheet *pADS);
        STDMETHOD(ProvideFinishText )(LPOLESTR* lpolestrString, LPOLESTR* lpMoreInfoText);
        STDMETHOD(ReadProperties    )(IPropertyPagePropertyBag * pPPPBag);
        STDMETHOD(WriteProperties   )(IPropertyPagePropertyBag * pPPPBag);
};

#endif //_ACCNTWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\au_accnt\accntcmt.cpp ===
// AccntCmt.cpp : Implementation of CAddUser_AccntCommit
#include "stdafx.h"
#include "AU_Accnt.h"
#include "AccntCmt.h"

#include <dsgetdc.h>
#include <lm.h>
#include <lmshare.h>
#include <Aclapi.h>
#include <atlcom.h>

// ldap/adsi includes
#include <iads.h>
#include <adshlp.h>
#include <adsiid.h>

#include <proputil.h>
#include <CreateEmailName.h>
#include <P3admin.h>
#include <CheckUser.h>

// POP3 Defines
#define SZ_AUTH_ID_MD5_HASH _T("c395e20c-2236-4af7-b736-54fad07dc526")

// Defines for account flags.
#define PASSWD_NOCHANGE     0x01
#define PASSWD_CANCHANGE    0x02
#define PASSWD_MUSTCHANGE   0x04

#ifndef CHECK_HR

#define CHECK_HR( x ) CHECK_HR_RET( x, _hr );
#define CHECK_HR_RET( x, y ) \
{ \
	HRESULT _hr = x; \
	if( FAILED(_hr) ) \
	{ \
		_ASSERT( !_T("CHECK_HR_RET() failed.  calling TRACE() with HRESULT and statement") ); \
		return y; \
	} \
}

#endif	// CHECK_HRhr;

// ****************************************************************************                                                        
// CAddUser_AccntCommit
// ****************************************************************************                                                        

// ----------------------------------------------------------------------------
// WriteErrorResults()
// ----------------------------------------------------------------------------
HRESULT CAddUser_AccntCommit::WriteErrorResults( IPropertyPagePropertyBag* pPPPBag )
{
    // ------------------------------------------------------------------------
    // Write the the values to the property bag.
    // ------------------------------------------------------------------------
    if( FAILED(WriteInt4  ( pPPPBag, PROP_ACCNT_ERROR_CODE_GUID_STRING, m_dwErrCode, FALSE )) )
    {
        _ASSERT(FALSE);
    }
    if( FAILED(WriteString( pPPPBag, PROP_ACCNT_ERROR_STR_GUID_STRING,  m_csErrStr,  FALSE )) )
    {
        _ASSERT(FALSE);
    }

    return S_OK;
}

// ----------------------------------------------------------------------------
// SetErrCode()
// ----------------------------------------------------------------------------
void CAddUser_AccntCommit::SetErrCode( DWORD dwCode )
{
    m_dwErrCode |= dwCode;
    return;
}

// ----------------------------------------------------------------------------
// SetErrorResults()
// ----------------------------------------------------------------------------
HRESULT CAddUser_AccntCommit::SetErrorResults( DWORD dwErrType, BOOL bPOP3 /* = FALSE */ )
{
    SetErrCode(dwErrType);

    CString csTemp;

    switch( dwErrType )
    {
    case ERROR_CREATION:
    case ERROR_PROPERTIES:
        {
            m_csErrStr.LoadString(IDS_ERROR_CREATING_USER);
            break;
        }
    case ERROR_MAILBOX:
        {
            csTemp.LoadString( IDS_ERROR_POP3MAILBOX);
            m_csErrStr += csTemp;
            break;
        }
    case ERROR_PASSWORD:
        {
            csTemp.LoadString(IDS_ERROR_PASSWORD);
            m_csErrStr += csTemp;
            break;
        }
    case ERROR_DUPE:
        {
            csTemp.LoadString(IDS_ERROR_DUPLICATE);
            m_csErrStr += csTemp;
            break;
        }
    case ERROR_MEMBERSHIPS:
        {
            csTemp.LoadString(IDS_ERROR_MEMBERSHIP);
            m_csErrStr += csTemp;
            break;
        }
    default :
        {
            m_dwErrCode = 0;
            m_csErrStr  = _T("");
            break;
        }
    }

    return S_OK;
}

// ----------------------------------------------------------------------------
// Commit()
// ----------------------------------------------------------------------------
HRESULT CAddUser_AccntCommit::Commit( IDispatch* pdispPPPBag )
{
    HRESULT hr = S_OK;

    HRESULT hrAdmin   = IsUserInGroup( DOMAIN_ALIAS_RID_ADMINS );    
    if( hrAdmin != S_OK )
    {
        return E_ACCESSDENIED;
    }

    CComPtr<IPropertyPagePropertyBag> spPPPBag = NULL;
    hr = pdispPPPBag->QueryInterface( __uuidof(IPropertyPagePropertyBag), (void**)&spPPPBag );
    if ( !spPPPBag )
        return hr;

    BOOL bRO = FALSE;
    BOOL bPOP3 = FALSE;
    
    ReadBool( spPPPBag, PROP_POP3_CREATE_MB_GUID_STRING, &bPOP3, &bRO );

    // Reset the error conditions
    SetErrorResults( 0 );

    // ------------------------------------------------------------------------
    // Read in the values from the property bag.
    // ------------------------------------------------------------------------
    CUserInfo cUInfo( spPPPBag, this );

    // ------------------------------------------------------------------------
    // Use those values to do something.
    // ------------------------------------------------------------------------
    hr = cUInfo.CreateAccount();
    if( FAILED(hr) )
    {
        if( !(m_dwErrCode & (ERROR_PASSWORD | ERROR_MEMBERSHIPS)) )
        {
            if ( HRESULT_CODE(hr) == ERROR_OBJECT_ALREADY_EXISTS )
            {
                SetErrorResults(ERROR_DUPE);
            }
            else
            {
                SetErrorResults(ERROR_CREATION);
            }

            WriteErrorResults(spPPPBag);
            return E_FAIL;
        }
    }

    hr = cUInfo.CreateMailbox();
    if( FAILED(hr) )
    {
        SetErrorResults(ERROR_MAILBOX, bPOP3);
    }            

    if( m_dwErrCode )
    {
        hr = E_FAIL;
        WriteErrorResults(spPPPBag);
    }

    return hr;
}

// ----------------------------------------------------------------------------
// Revert()
// ----------------------------------------------------------------------------
HRESULT CAddUser_AccntCommit::Revert()
{    
    NET_API_STATUS          nApi;
    HRESULT                 hr          = S_OK;
    CComPtr<IADs>           spUser      = NULL;  
    CComPtr<IADsDeleteOps>  spDelOps    = NULL;

    // Remove the entry-point in the AD if we made one.
    if( m_csADName != _T("") )
    {        
        CHECK_HR( ::ADsGetObject( m_csADName, IID_IADs, (void**)&spUser ) );

        // Delete the User
        hr = spUser->QueryInterface( IID_IADsDeleteOps, (void**)&spDelOps );
        if( SUCCEEDED(hr) && spDelOps )
        {
            hr = spDelOps->DeleteObject( 0 );
        }        
    }

    return hr;
}


// ****************************************************************************                                                        
// CUserInfo
// ****************************************************************************                                                        

// ----------------------------------------------------------------------------
// CUserInfo()
// 
// Constructor.
// ----------------------------------------------------------------------------
CUserInfo::CUserInfo( IPropertyPagePropertyBag* pPPPBag, CAddUser_AccntCommit* pCmt )  
{
    _ASSERT(pCmt);

    m_pCmt              = pCmt;
    m_pPPPBag           = pPPPBag;
    m_dwAccountOptions  = 0;    
    m_bPOP3             = FALSE;

    // Get domain controller name
    PDOMAIN_CONTROLLER_INFO pDCI = NULL;
    DWORD dwErr = DsGetDcName( NULL, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED, &pDCI );

    // cache the domain
    if( (dwErr == NO_ERROR) && pDCI )
    {
        m_csDomainName = pDCI->DomainName;        
        NetApiBufferFree( pDCI );
        pDCI = NULL;
    }

    // convert from '.' separated names to Dc=xxx,DC=yyy,... format
    m_csFQDomainName = GetDomainPath( m_csDomainName ).c_str();

    ReadBag( );
}

// ----------------------------------------------------------------------------
// ReadBag()
//
// Read in the values from the property bag into the member variables.
// ----------------------------------------------------------------------------
HRESULT CUserInfo::ReadBag()
{
    HRESULT hr = S_OK;

    if ( !m_pPPPBag )       // Make sure we have the property bag to read from.
        return(E_FAIL);     // If not, fail.

    BOOL bRO;

    // User Properties
    ReadString( m_pPPPBag, PROP_USEROU_GUID_STRING,         m_csUserOU,         &bRO );
    ReadString( m_pPPPBag, PROP_USERNAME_GUID_STRING,       m_csUserName,       &bRO );
    ReadString( m_pPPPBag, PROP_USER_CN,                    m_csUserCN,         &bRO );
    ReadString( m_pPPPBag, PROP_PASSWD_GUID_STRING,         m_csPasswd,         &bRO );
    ReadInt4  ( m_pPPPBag, PROP_ACCOUNT_OPT_GUID_STRING,    (LONG*)&m_dwAccountOptions, &bRO );
    ReadString( m_pPPPBag, PROP_USERNAME_PRE2K_GUID_STRING, m_csUserNamePre2k,  &bRO );
    ReadString( m_pPPPBag, PROP_FIRSTNAME_GUID_STRING,      m_csFirstName,      &bRO );
    ReadString( m_pPPPBag, PROP_LASTNAME_GUID_STRING,       m_csLastName,       &bRO );
    ReadString( m_pPPPBag, PROP_TELEPHONE_GUID_STRING,      m_csTelephone,      &bRO );
    ReadString( m_pPPPBag, PROP_OFFICE_GUID_STRING,         m_csOffice,         &bRO );
    ReadString( m_pPPPBag, PROP_DESCRIPTION_GUID_STRING,    m_csDesc,           &bRO );        
    ReadString( m_pPPPBag, PROP_LOGON_DNS,                  m_csLogonDns,       &bRO );

    // Mailbox properties
    ReadBool  ( m_pPPPBag, PROP_POP3_CREATE_MB_GUID_STRING, &m_bPOP3,           &bRO );    
    ReadString( m_pPPPBag, PROP_EX_ALIAS_GUID_STRING,       m_csEXAlias,        &bRO );
    ReadString( m_pPPPBag, PROP_EX_SERVER_GUID_STRING,      m_csEXServer,       &bRO );
    ReadString( m_pPPPBag, PROP_EX_HOMESERVER_GUID_STRING,  m_csEXHomeServer,   &bRO );
    ReadString( m_pPPPBag, PROP_EX_HOME_MDB_GUID_STRING,    m_csEXHomeMDB,      &bRO );

    // Escape the User's Name
    m_csUserCN = EscapeString(((LPCTSTR)m_csUserCN+3), 2);
    m_csUserCN = _T("CN=") + m_csUserCN;

    // Let's figure out the fullname right here and fill in the m_csFullName variable.
    m_csFirstName.TrimLeft ( );
    m_csFirstName.TrimRight( );
    m_csLastName.TrimLeft  ( );
    m_csLastName.TrimRight ( );
    m_csFullName.FormatMessage(IDS_FULLNAME_FORMAT_STR, (LPCTSTR)m_csFirstName, (LPCTSTR)m_csLastName);
    m_csFullName.TrimLeft  ( );
    m_csFullName.TrimRight ( );

    return(hr);
}

// ----------------------------------------------------------------------------
// CreateAccount()
// 
// Makes a new user account in the Active Directory.
// ----------------------------------------------------------------------------
HRESULT CUserInfo::CreateAccount( )
{
    HRESULT hr  = S_OK;
    BOOL    bRO = TRUE;

    CComVariant vaTmpVal;
    CComBSTR    bstrProp;
    CComPtr<IADsContainer> spADsContainer = NULL;

    // Bind to the container.
    CString csLdapUserOU = _T("LDAP://");
    if( _tcsstr( (LPCTSTR)m_csUserOU, _T("LDAP://") ) )
    {
        csLdapUserOU = m_csUserOU;
    }
    else
    {
        csLdapUserOU += m_csUserOU;
    }
    
    hr = ::ADsGetObject( (LPWSTR)(LPCWSTR)csLdapUserOU, IID_IADsContainer, (VOID**) &spADsContainer );
    CHECK_HR(hr);

    // Create the user account.
    CComPtr<IDispatch> spDisp = NULL;
    bstrProp = _T("user");
    CComBSTR bstrValue = (LPCWSTR)m_csUserCN;
    hr = spADsContainer->Create( bstrProp, bstrValue, &spDisp );
    CHECK_HR(hr);

    m_pCmt->m_csADName = _T("LDAP://");
    m_pCmt->m_csADName += m_csUserCN;
    m_pCmt->m_csADName += _T(",");
    m_pCmt->m_csADName += (LPCTSTR)csLdapUserOU+7;

    // Use this new account and set it's properties (e.g. first name, home folder, etc.).
    CComQIPtr<IADsUser, &IID_IADsUser> spADsUserObj(spDisp);
    if( !spADsUserObj )
    {
        _ASSERT(FALSE);
        return E_FAIL;
    }

    TCHAR   szTmp[MAX_PATH*4] = {0};
    LdapToDCName( (LPCTSTR)csLdapUserOU, szTmp, (MAX_PATH*4) );

    CString csUserPrincName = m_csUserName;
    csUserPrincName += _T("@");
    csUserPrincName += szTmp;    

    // Username:    
    vaTmpVal.Clear();
    vaTmpVal = ((LPCWSTR)csUserPrincName);
    bstrProp = _T("userPrincipalName");
    CHECK_HR( spADsUserObj->Put( bstrProp, vaTmpVal ) );

    // Pre-Win2000 username:    
    vaTmpVal.Clear();
    vaTmpVal = ((LPCWSTR)m_csUserNamePre2k);
    bstrProp = _T("sAMAccountName");
    CHECK_HR( spADsUserObj->Put( bstrProp, vaTmpVal ) );

    // First name:
    if( m_csFirstName.GetLength() )
    {
        bstrProp = (LPCWSTR)m_csFirstName;
        CHECK_HR( spADsUserObj->put_FirstName( bstrProp ) );
    }

    // Last name:
    if( m_csLastName.GetLength() )
    {
        bstrProp = (LPCWSTR)m_csLastName;
        CHECK_HR( spADsUserObj->put_LastName( bstrProp ) );
    }

    if( m_csFullName.GetLength() )
    {
        // Full name:      
        bstrProp = (LPCWSTR)m_csFullName;
        CHECK_HR( spADsUserObj->put_FullName( bstrProp ) );

        // Display Name     
        vaTmpVal.Clear();
        vaTmpVal = (LPCWSTR)m_csFullName;
        bstrProp = _T("displayName");
        CHECK_HR( spADsUserObj->Put( bstrProp, vaTmpVal ) );
    }

    // Telephone number
    if( _tcslen((LPCTSTR)m_csTelephone) )
    {
        vaTmpVal.Clear();
        vaTmpVal = (LPCWSTR)m_csTelephone;
        bstrProp = _T("telephoneNumber");
        CHECK_HR( spADsUserObj->Put( bstrProp, vaTmpVal ) );
    }

    // Office Location
    if( _tcslen((LPCTSTR)m_csOffice) )
    {
        vaTmpVal.Clear();
        vaTmpVal = (LPCWSTR)m_csOffice;
        bstrProp = _T("physicalDeliveryOfficeName");
        CHECK_HR( spADsUserObj->Put( bstrProp, vaTmpVal ) );
    }

    // Commit this information to the AD.
    CHECK_HR( spADsUserObj->SetInfo() );

    // Password expired?
    vaTmpVal.Clear();
    vaTmpVal = (m_dwAccountOptions & PASSWD_MUSTCHANGE) ? (INT) 0 : (INT) -1;
    bstrProp = _T("pwdLastSet");
    CHECK_HR( spADsUserObj->Put( bstrProp, vaTmpVal ) );

    // Account disabled?
    vaTmpVal.Clear();
    bstrProp = _T("userAccountControl");
    CHECK_HR( spADsUserObj->Get( bstrProp, &vaTmpVal ) );
    
    vaTmpVal.lVal &= ~UF_PASSWD_NOTREQD;            // Make passwd required.
    vaTmpVal.lVal &= ~UF_ACCOUNTDISABLE;            // Do not disable the account.    
    bstrProp = _T("userAccountControl");
    CHECK_HR( spADsUserObj->Put( bstrProp, vaTmpVal ) );

    // Set the password.    
    if( FAILED(SetPasswd()) )
    {
        m_pCmt->SetErrorResults( ERROR_PASSWORD );

        vaTmpVal.Clear();
        bstrProp = _T("userAccountControl");
        CHECK_HR( spADsUserObj->Get( bstrProp, &vaTmpVal ) );
        
        vaTmpVal.lVal &= ~UF_PASSWD_NOTREQD;            // Make passwd required.
        vaTmpVal.lVal |= UF_ACCOUNTDISABLE;             // Disable the account.
        bstrProp = _T("userAccountControl");
        CHECK_HR( spADsUserObj->Put( bstrProp, vaTmpVal ) );

        // Commit this information to the AD.
        CHECK_HR( spADsUserObj->SetInfo() );

        return E_FAIL;
    }

    // Commit this information to the AD.
    CHECK_HR( spADsUserObj->SetInfo() );

    // Join to Domain Users    
    if ( FAILED(JoinToDomainUsers()) )
    {
        m_pCmt->SetErrorResults( ERROR_MEMBERSHIPS );
        return E_FAIL;
    }    

    return S_OK;
}

// ----------------------------------------------------------------------------
// CreateMailbox()
// 
// Makes a new mailbox for the user.
// ----------------------------------------------------------------------------
HRESULT CUserInfo::CreateMailbox()
{
    HRESULT hr = S_OK;

    if( m_bPOP3 )
    {
        hr = CreatePOP3Mailbox();        
    }

    return hr;
}

// ----------------------------------------------------------------------------
// CreatePOP3Mailbox()
// 
// Makes a new (MS) POP3 mailbox for the user.
// ----------------------------------------------------------------------------
HRESULT CUserInfo::CreatePOP3Mailbox()
{
    HRESULT hr = S_OK;

    CComPtr<IP3Config>    spConfig  = NULL;
	CComPtr<IAuthMethods> spMethods = NULL;
    CComPtr<IAuthMethod>  spAuth	= NULL;	
    CComPtr<IP3Domains>   spDomains = NULL;
    CComPtr<IP3Domain>    spDomain  = NULL;
    CComPtr<IP3Users>     spUsers   = NULL;

    // Open our Pop3 Admin Interface
	hr = CoCreateInstance(__uuidof(P3Config), NULL, CLSCTX_ALL, __uuidof(IP3Config), (LPVOID*)&spConfig);    

    if( SUCCEEDED(hr) )
    {
        // Get the Domains
	    hr = spConfig->get_Domains( &spDomains );
    }

    if( SUCCEEDED(hr) )
    {
        // Get the first domain
        CComVariant cVar;
        cVar = 1;
        
        hr = spDomains->get_Item( cVar, &spDomain );
    }

    if( SUCCEEDED(hr) )
    {
        hr = spDomain->get_Users( &spUsers );
    }
	
	if ( SUCCEEDED(hr) )
    {
		hr = spConfig->get_Authentication( &spMethods );
	}

	CComVariant var;
    if ( SUCCEEDED(hr) )
    {
        hr = spMethods->get_CurrentAuthMethod( &var );
    }	
    
	if ( SUCCEEDED(hr) )
    {        
        hr = spMethods->get_Item( var, &spAuth );
    }

	CComBSTR bstrID;
    if( SUCCEEDED(hr) )
    {        
        hr = spAuth->get_ID( &bstrID );        
    }    

    if( SUCCEEDED(hr) )
    {
		CComBSTR bstrName = (LPCTSTR)m_csEXAlias;

		if( _tcsicmp(bstrID, SZ_AUTH_ID_MD5_HASH) == 0 )
		{
			CComBSTR bstrPassword = m_csPasswd;
			hr = spUsers->AddEx( bstrName, bstrPassword );
			SecureZeroMemory( (LPOLESTR)bstrPassword.m_str, sizeof(OLECHAR)*bstrPassword.Length() );
		}
		else
		{			
			hr = spUsers->Add( bstrName );
		}
    }

    return hr;
}

// ----------------------------------------------------------------------------
// SetPasswd()
// ----------------------------------------------------------------------------
HRESULT CUserInfo::SetPasswd()
{    
    HRESULT     hr          = S_OK;
    TCHAR       *szPath     = NULL;
    TCHAR       *szTok      = NULL;    
    CString     csUser      = _T("LDAP://");

    if ( _tcsstr((LPCTSTR)m_csUserOU, _T("LDAP://")) )
    {                
        csUser += m_csUserCN;
        csUser += _T(",");
        csUser += (LPCTSTR)m_csUserOU+7;
    }
    else
    {        
        csUser += m_csUserCN;
        csUser += _T(",");
        csUser += (LPCTSTR)m_csUserOU;
    }

    // Now csUser is something like "WinNT://test.microsoft.com/JohnDoe,user"
    CComPtr<IADsUser> spDS = NULL;
    hr = ::ADsGetObject( (LPCWSTR)csUser, IID_IADsUser, (void**)&spDS );
    if ( FAILED(hr) )
        return(hr);

    // Set the password.
    if ( _tcslen((LPCTSTR)m_csPasswd) )                 // Only if there IS a passwd!
    {
        CComBSTR bszPasswd = (LPCWSTR) m_csPasswd;

        hr = spDS->SetPassword(bszPasswd);
        if ( FAILED(hr) )
            return(hr);
    }

    // Allow change?
    if ( m_dwAccountOptions & PASSWD_NOCHANGE )
    {
        // Get the current ACL.
        CComBSTR             bstrName = csUser;
        PACL                 pDACL    = NULL;
        PSECURITY_DESCRIPTOR pSD      = NULL;
        
	hr = GetSDForDsObjectPath( bstrName, &pDACL, &pSD); 
        if( hr != S_OK ) return hr;        
        
        // build SID's for Self and World.
        PSID pSidSelf = NULL;
        SID_IDENTIFIER_AUTHORITY NtAuth    = SECURITY_NT_AUTHORITY;        
        if( !AllocateAndInitializeSid(&NtAuth, 1, SECURITY_PRINCIPAL_SELF_RID, 0, 0, 0, 0, 0, 0, 0, &pSidSelf) )
        {            
            return HRESULT_FROM_WIN32(GetLastError());
        }       

        PSID pSidWorld;
        SID_IDENTIFIER_AUTHORITY WorldAuth = SECURITY_WORLD_SID_AUTHORITY;        
        if( !AllocateAndInitializeSid(&WorldAuth, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSidWorld) )
        {            
            return HRESULT_FROM_WIN32(GetLastError());
        }

        // initialize the entries (DENY ACE's)
        EXPLICIT_ACCESS rgAccessEntry[2]   = {0};
        OBJECTS_AND_SID rgObjectsAndSid[2] = {0};        
        rgAccessEntry[0].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
        rgAccessEntry[0].grfAccessMode        = DENY_ACCESS;
        rgAccessEntry[0].grfInheritance       = NO_INHERITANCE;

        rgAccessEntry[1].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
        rgAccessEntry[1].grfAccessMode        = DENY_ACCESS;
        rgAccessEntry[1].grfInheritance       = NO_INHERITANCE;
        
        // build the trustee structs for change password
        GUID UserChangePasswordGUID = { 0xab721a53, 0x1e2f, 0x11d0,  { 0x98, 0x19, 0x00, 0xaa, 0x00, 0x40, 0x52, 0x9b}};
        BuildTrusteeWithObjectsAndSid( &(rgAccessEntry[0].Trustee), &(rgObjectsAndSid[0]), &UserChangePasswordGUID, NULL, pSidSelf  );
        BuildTrusteeWithObjectsAndSid( &(rgAccessEntry[1].Trustee), &(rgObjectsAndSid[1]), &UserChangePasswordGUID, NULL, pSidWorld );
        
        // Build the new DACL
        PACL pNewDACL = NULL;
        DWORD dwErr = ::SetEntriesInAcl(2, rgAccessEntry, pDACL, &pNewDACL);
        if( dwErr != ERROR_SUCCESS ) return HRESULT_FROM_WIN32(dwErr);

        // Set the new DACL
	hr = SetDaclForDsObjectPath( bstrName, pNewDACL );
        if( hr != S_OK ) return hr;

        LocalFree(pSD);
    }

    // SetInfo only if we actually changed anything.
    if ( ( _tcslen((LPCTSTR)m_csPasswd) ) ||            // Did we mess with the passwd?
         ( m_dwAccountOptions & PASSWD_NOCHANGE ) )     // Did we make it unable to change?
    {
        hr = spDS->SetInfo();                           // If either, then set the new info.
    }

    return(hr);
}

// ----------------------------------------------------------------------------
// JoinToGroup()
// ----------------------------------------------------------------------------
HRESULT CUserInfo::JoinToDomainUsers()
{
    USES_CONVERSION;

    HRESULT hr = S_OK;
    CString csGroupName;
    tstring strDomain;
    tstring strUser;    
    
    // Get Domain SID
    USER_MODALS_INFO_2 *pUserModalsInfo2;        
    NET_API_STATUS      status = ::NetUserModalsGet( NULL, 2, (LPBYTE *)&pUserModalsInfo2 );

    if ( (status != ERROR_SUCCESS) || (pUserModalsInfo2 == NULL) )
    {
        return E_FAIL;
    }

    PSID pSIDDomain = pUserModalsInfo2->usrmod2_domain_id;

    // copy Domain RIDs
    UCHAR nSubAuthorities = *::GetSidSubAuthorityCount(pSIDDomain);

    DWORD adwSubAuthority[8];
    for ( UCHAR index = 0; index < nSubAuthorities; index++ )
    {
        adwSubAuthority[index] = *::GetSidSubAuthority(pSIDDomain, index);
    }

    adwSubAuthority[nSubAuthorities++] = DOMAIN_GROUP_RID_USERS; // finally, append the RID we want.    

    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    PSID pSid = NULL;

    if ( !::AllocateAndInitializeSid(&SIDAuthNT, nSubAuthorities,
                                     adwSubAuthority[0], adwSubAuthority[1],
                                     adwSubAuthority[2], adwSubAuthority[3],
                                     adwSubAuthority[4], adwSubAuthority[5],
                                     adwSubAuthority[6], adwSubAuthority[7],
                                     &pSid) )
    {
        ::NetApiBufferFree(pUserModalsInfo2);
        return E_FAIL;
    }
    ::NetApiBufferFree(pUserModalsInfo2);

    // The builtin group names are looked up on the DC
    TCHAR szDomain[MAX_PATH];
    TCHAR szName[MAX_PATH];
    DWORD cbDomain = MAX_PATH;
    DWORD cbName = MAX_PATH;
    SID_NAME_USE peUse;

    if( !::LookupAccountSid( NULL, pSid, szName, &cbName, szDomain, &cbDomain, &peUse ) )
    {
        FreeSid(pSid);
        return E_FAIL;
    }
    
    FreeSid( pSid );
    
    // Find the Group Name
    CString csTmp;
    tstring strTmp = _T("LDAP://");
    strTmp += m_csFQDomainName;

    hr = FindADsObject(strTmp.c_str(), szName, _T("(name=%1)"), csTmp, 1, TRUE);
    CHECK_HR( hr );    

    strTmp = _T("LDAP://");
    strTmp += csTmp;

    // Open the group
    CComPtr<IADsGroup> spGroup = NULL;    
    hr = ::ADsGetObject( strTmp.c_str(), IID_IADsGroup, (void**)&spGroup );
    if( SUCCEEDED(hr) )
    {
        // Add the User
        CComBSTR bstrName = (LPCTSTR)m_csUserOU;
        hr = spGroup->Add( bstrName );

        if ( HRESULT_CODE(hr) == ERROR_OBJECT_ALREADY_EXISTS )
        {
            hr = S_FALSE;
        }
    }   
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\au_accnt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\au_accnt\au_accnt.cpp ===
// AU_Accnt.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f AU_Accntps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>

#include "AU_Accnt.h"
#include "AU_Accnt_i.c"

#include "AccntWiz.h"
#include "AccntCmt.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_AddUser_AccntWiz, CAddUser_AccntWiz)
OBJECT_ENTRY(CLSID_AddUser_AccntCommit, CAddUser_AccntCommit)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_ACCNTDLLLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\au_accnt\cacctp.cpp ===
#include <stdafx.h>

#include "CAcctP.h"
#include "AccntWiz.h"

#include <imm.h>
#include <dsgetdc.h>

#include <P3admin.h>
#include <proputil.h>
#include <CreateEmailName.h>
#include <EscStr.h>

BYTE g_ASCII128[128] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 00-0F
                         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 10-1F
                         0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0, // 20-2F
                         1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0, // 30-3F
                         0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 40-4F
                         1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1, // 50-5F
                         1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 60-6F
                         1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1  // 70-7F
                      };

BOOL ValidChar( TCHAR pszInput, BOOL bPOP3 )
{    
    if( pszInput > 127 ) return !bPOP3;
    if( pszInput < 0) return FALSE;
    if( g_ASCII128[pszInput] == 1 ) return TRUE;
    
    return FALSE;
}

BOOL ValidString( LPCTSTR pszInput, BOOL bPOP3 )
{
    if( !pszInput ) return FALSE;

    for( int i = 0; i < _tcslen(pszInput); i++ )
    {
        if( !ValidChar(pszInput[i], bPOP3) ) return FALSE;
    }

    return TRUE;
}

// --------------------------------------------------------------------------------------------------------------------------------
// CAcctPage class
// --------------------------------------------------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// Constructor
// ----------------------------------------------------------------------------
CAcctPage::CAcctPage (CAddUser_AccntWiz * pASW) :
    m_csUserOU(),
    m_csFirstName(),
    m_csLastName(),
    m_csTelephone(),
    m_csOffice(),
    m_csUName(),
    m_csUNamePre2k(),
    m_csUserCN(),
    m_csAlias()
{
    m_pASW = pASW;
    m_psp.dwFlags          |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    m_psp.pszHeaderTitle    = MAKEINTRESOURCE(IDS_ACCT_INFO_TITLE);
    m_psp.pszHeaderSubTitle = MAKEINTRESOURCE(IDS_ACCT_INFO_SUBTITLE);

    // Defaults
    m_fInit          = TRUE;
    m_fSimpleMode    = TRUE;    
    m_bPOP3Installed = FALSE;
    m_bCreatePOP3MB  = TRUE;
    m_bPOP3Valid     = FALSE;

    m_dwAutoMode  = 0;  
}

// ----------------------------------------------------------------------------
// Destructor
// ----------------------------------------------------------------------------
CAcctPage::~CAcctPage()
{    
}

// ----------------------------------------------------------------------------
// OnDestroy()
// ----------------------------------------------------------------------------
LRESULT CAcctPage::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Detach all of our controls from the windows.
    m_ctrlFirstName.Detach();
    m_ctrlLastName.Detach();
    m_ctrlTelephone.Detach();
    m_ctrlOffice.Detach();
    m_ctrlUName.Detach();
    m_ctrlUNameLoc.Detach();
    m_ctrlUNamePre2k.Detach();
    m_ctrlUNamePre2kLoc.Detach();
    m_ctrlAlias.Detach();

    return 0;
}

// ----------------------------------------------------------------------------
// OnInitDialog()
// ----------------------------------------------------------------------------
LRESULT CAcctPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // ------------------------------------------------------------------------
    // Attach controls.
    // ------------------------------------------------------------------------
    m_ctrlFirstName.Attach      ( GetDlgItem(IDC_FIRST_NAME)    );
    m_ctrlLastName.Attach       ( GetDlgItem(IDC_LAST_NAME)     );
    m_ctrlTelephone.Attach      ( GetDlgItem(IDC_TELEPHONE)     );
    m_ctrlOffice.Attach         ( GetDlgItem(IDC_OFFICE)        );
    m_ctrlUName.Attach          ( GetDlgItem(IDC_UNAME)         );
    m_ctrlUNameLoc.Attach       ( GetDlgItem(IDC_UNAME_LOC)     );
    m_ctrlUNamePre2k.Attach     ( GetDlgItem(IDC_UNAME_PRE2K)   );
    m_ctrlUNamePre2kLoc.Attach  ( GetDlgItem(IDC_UNAME_PRE2K_LOC) );
    m_ctrlAlias.Attach          ( GetDlgItem(IDC_EMAIL_ALIAS)   );
    
    HWND hWndAlias = GetDlgItem(IDC_EMAIL_ALIAS);
    if( hWndAlias && ::IsWindow( hWndAlias ) )
    {    
        m_ctrlImplAlias.SubclassWindow( hWndAlias );    
    }
    
    // ------------------------------------------------------------------------
    // Other Stuff! :)
    // ------------------------------------------------------------------------
    m_ctrlFirstName.SetLimitText ( 28  );
    m_ctrlLastName.SetLimitText  ( 29  );    
    m_ctrlUNamePre2k.SetLimitText( 20  );
    m_ctrlTelephone.SetLimitText ( 32  );
    m_ctrlOffice.SetLimitText    ( 128 );
    m_ctrlAlias.SetLimitText     ( 64  );

    return(0);
}

// ----------------------------------------------------------------------------
// Init()
// 
// Initializes the controls on the page with the values from the property bag.
// NOTE:  This is called from OnSetActive(), but only on the first SetActive.
//        This is because even though the control attaching could be done in
//        the WM_INITDIALOG handler, setting the values of the controls from 
//        the values read from the property bag can only safely be done in the
//        PSN_SETACTIVE.  
// ----------------------------------------------------------------------------
LRESULT CAcctPage::Init (void)
{
    CString                     csDns           = L""; 
    CString                     csNetbios       = L"";
    TCHAR                       *szPath         = NULL;
    TCHAR                       *szTok          = NULL;
    DWORD                       dwErr           = 0;
    PDOMAIN_CONTROLLER_INFO     pDCInfo         = NULL;
    ULONG                       ulGetDcFlags    = DS_DIRECTORY_SERVICE_REQUIRED | DS_IP_REQUIRED | 
                                                  DS_WRITABLE_REQUIRED | DS_RETURN_FLAT_NAME;

    // ------------------------------------------------------------------------
    // Get the special values to put in the windows.
    // ------------------------------------------------------------------------
    // DNS Name
    TCHAR   szTmp[MAX_PATH*2] = {0};
    LdapToDCName((LPCTSTR)m_csUserOU, szTmp, (MAX_PATH*2));
    csDns = szTmp;
    m_csLogonDns = L"@" + csDns;

    // Pre-Windows2000 DNS name
    dwErr = DsGetDcName(NULL, (LPCWSTR)csDns, NULL, NULL, ulGetDcFlags, &pDCInfo);
    if( (dwErr == NO_ERROR) && pDCInfo )
    {
        csNetbios = pDCInfo->DomainName;                    // Get the NT4 DNS name.
    }

    NetApiBufferFree(pDCInfo);                              // Free up the memory DsGetDcName() might have allocated.
    pDCInfo = NULL;

    if( dwErr != NO_ERROR )                     // If there was a problem, try again.
    {
        ulGetDcFlags |= DS_FORCE_REDISCOVERY;
        dwErr = DsGetDcName(NULL, (LPCWSTR)csDns, NULL, NULL, ulGetDcFlags, &pDCInfo);
        
        if( (dwErr == NO_ERROR) && pDCInfo )
        {
            csNetbios = pDCInfo->DomainName;                // Get the NT4 DNS name.
        }
        
        NetApiBufferFree(pDCInfo);                          // Free up the memory DsGetDcName() might have allocated.
        pDCInfo = NULL;
    }

    csNetbios += L"\\";     // Covert from TEST to TEST\

    // ------------------------------------------------------------------------
    // Set the windows' values.
    // ------------------------------------------------------------------------
    m_ctrlFirstName.SetWindowText       ( (LPCWSTR) m_csFirstName   );
    m_ctrlLastName.SetWindowText        ( (LPCWSTR) m_csLastName    );
    m_ctrlTelephone.SetWindowText       ( (LPCWSTR) m_csTelephone   );
    m_ctrlOffice.SetWindowText          ( (LPCWSTR) m_csOffice      );
    m_ctrlAlias.SetWindowText           ( (LPCWSTR) m_csAlias       );
    m_ctrlUName.SetWindowText           ( (LPCWSTR) m_csUName       );
    m_ctrlUNamePre2k.SetWindowText      ( (LPCWSTR) m_csUNamePre2k  );
    m_ctrlUNameLoc.SetWindowText        ( (LPCWSTR) m_csLogonDns    );
    m_ctrlUNamePre2kLoc.SetWindowText   ( (LPCWSTR) csNetbios       );

    // Needs to be done here...
    m_ctrlUName.LimitText( m_bPOP3Valid ? 20 : 64  );
   
    ::EnableWindow( GetDlgItem(IDC_EMAIL_CHECKBOX), m_bPOP3Valid);    

    if( m_bPOP3Installed )
    {
        COMBOBOXINFO cbi;
        ZeroMemory( &cbi, sizeof(cbi) );
        cbi.cbSize = sizeof(cbi);
        if( ::SendMessage( GetDlgItem(IDC_UNAME), CB_GETCOMBOBOXINFO, 0, (LPARAM)&cbi ) )
        {
            // If we are in POP3 mode, our criteria is much more strict for the logon name
            m_ctrlImplUName.SubclassWindow( cbi.hwndItem );
        }


        // Default the checkbox.
        CheckDlgButton( IDC_EMAIL_CHECKBOX, (m_bCreatePOP3MB ? BST_CHECKED : BST_UNCHECKED) );
    }

    return 0;
}

// ----------------------------------------------------------------------------
// ReadProperties()
// ----------------------------------------------------------------------------
HRESULT CAcctPage::ReadProperties( IPropertyPagePropertyBag* pPPPBag )
{
    HRESULT                 hr;
    BOOL                    fTmp        = FALSE;

    // POP3 mailbox    
    ReadBool  ( pPPPBag, PROP_POP3_CREATE_MB_GUID_STRING,   &m_bCreatePOP3MB,   &fTmp );    
    ReadBool  ( pPPPBag, PROP_POP3_VALID_GUID_STRING,       &m_bPOP3Valid,      &fTmp );
    ReadBool  ( pPPPBag, PROP_POP3_INSTALLED_GUID_STRING,   &m_bPOP3Installed,  &fTmp );

    // User settings
    ReadString( pPPPBag, PROP_USEROU_GUID_STRING,           m_csUserOU,         &fTmp );
    ReadString( pPPPBag, PROP_USER_CN,                      m_csUserCN,         &fTmp );
    ReadString( pPPPBag, PROP_FIRSTNAME_GUID_STRING,        m_csFirstName,      &fTmp );
    ReadString( pPPPBag, PROP_LASTNAME_GUID_STRING,         m_csLastName,       &fTmp );
    ReadString( pPPPBag, PROP_TELEPHONE_GUID_STRING,        m_csTelephone,      &fTmp );
    ReadString( pPPPBag, PROP_OFFICE_GUID_STRING,           m_csOffice,         &fTmp );
    ReadString( pPPPBag, PROP_EX_ALIAS_GUID_STRING,         m_csAlias,          &fTmp );
    ReadString( pPPPBag, PROP_USERNAME_GUID_STRING,         m_csUName,          &fTmp );
    ReadString( pPPPBag, PROP_USERNAME_PRE2K_GUID_STRING,   m_csUNamePre2k,     &fTmp );

    // Wizard settings
    ReadInt4  ( pPPPBag, PROP_AUTOCOMPLETE_MODE,            (LONG*)&m_dwAutoMode, &fTmp );    
    
    // Validate / fix up the values.
    m_csFirstName.TrimLeft();
    m_csFirstName.TrimRight();
    m_csLastName.TrimLeft();
    m_csLastName.TrimRight();
    m_csTelephone.TrimLeft();
    m_csTelephone.TrimRight();
    m_csOffice.TrimLeft();
    m_csOffice.TrimRight();
    m_csUName.TrimLeft();
    m_csUName.TrimRight();
    m_csUNamePre2k.TrimLeft();
    m_csUNamePre2k.TrimRight();
    
    if ( !_tcslen((LPCTSTR)m_csUserOU) )
    {
        CString                 csDns       = _T("");
        PDOMAIN_CONTROLLER_INFO pDCI        = NULL;

        DWORD dwErr = DsGetDcName(NULL, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME, &pDCI);
        if ((dwErr == NO_ERROR) && pDCI ) 
        {
            csDns = pDCI->DomainName;

    	    NetApiBufferFree (pDCI);
            pDCI = NULL;
        }

        tstring strTemp = GetDomainPath((LPCTSTR)csDns);
        m_csUserOU = L"LDAP://CN=Users,";
        m_csUserOU += strTemp.c_str();
    }

    return S_OK;    
}

// ----------------------------------------------------------------------------
// WriteProperties()
// ----------------------------------------------------------------------------
HRESULT CAcctPage::WriteProperties( IPropertyPagePropertyBag* pPPPBag )
{
    if ( !m_fInit )     // IF the page has already been initialized...
    {
        // Get the values from the edit boxes.        
        m_csFirstName   = StrGetWindowText( m_ctrlFirstName.m_hWnd ).c_str();
        m_csLastName    = StrGetWindowText( m_ctrlLastName.m_hWnd ).c_str();
        m_csTelephone   = StrGetWindowText( m_ctrlTelephone.m_hWnd ).c_str();
        m_csOffice      = StrGetWindowText( m_ctrlOffice.m_hWnd ).c_str();
        m_csUName       = StrGetWindowText( m_ctrlUName.m_hWnd ).c_str();
        m_csUNamePre2k  = StrGetWindowText( m_ctrlUNamePre2k.m_hWnd ).c_str();
        m_csAlias       = StrGetWindowText( m_ctrlAlias.m_hWnd ).c_str();

        // Trim the strings
        m_csFirstName.TrimLeft  ( );
        m_csFirstName.TrimRight ( );
        m_csLastName.TrimLeft   ( );
        m_csLastName.TrimRight  ( );
        m_csTelephone.TrimLeft  ( );
        m_csTelephone.TrimRight ( );
        m_csOffice.TrimLeft     ( );
        m_csOffice.TrimRight    ( );
        m_csUName.TrimLeft      ( );
        m_csUName.TrimRight     ( );
        m_csUNamePre2k.TrimLeft ( );
        m_csUNamePre2k.TrimRight( );
        m_csAlias.TrimLeft      ( );
        m_csAlias.TrimRight     ( );
    }

    CString csUserCN;
    csUserCN.FormatMessage(IDS_FULLNAME_FORMAT_STR, (LPCTSTR)m_csFirstName, (LPCTSTR)m_csLastName);
    csUserCN = L"CN=" + csUserCN;
  
    // Write the values to the property bag.
    WriteString( pPPPBag, PROP_FIRSTNAME_GUID_STRING,       m_csFirstName,      FALSE );
    WriteString( pPPPBag, PROP_LASTNAME_GUID_STRING,        m_csLastName,       FALSE );
    WriteString( pPPPBag, PROP_USER_CN,                     m_csUserCN,         FALSE );
    WriteString( pPPPBag, PROP_TELEPHONE_GUID_STRING,       m_csTelephone,      FALSE );
    WriteString( pPPPBag, PROP_OFFICE_GUID_STRING,          m_csOffice,         FALSE );
    WriteString( pPPPBag, PROP_USERNAME_GUID_STRING,        m_csUName,          FALSE );
    WriteString( pPPPBag, PROP_USERNAME_PRE2K_GUID_STRING,  m_csUNamePre2k,     FALSE );
    WriteString( pPPPBag, PROP_LOGON_DNS,                   m_csLogonDns,       FALSE );
    WriteString( pPPPBag, PROP_EX_ALIAS_GUID_STRING,        m_csAlias,          FALSE );

    WriteInt4  ( pPPPBag, PROP_AUTOCOMPLETE_MODE,           m_dwAutoMode,       FALSE );
    WriteBool  ( pPPPBag, PROP_POP3_CREATE_MB_GUID_STRING,  m_bCreatePOP3MB,    FALSE );    

    return S_OK;
}

// ----------------------------------------------------------------------------
// ProvideFinishText()
// ----------------------------------------------------------------------------
HRESULT CAcctPage::ProvideFinishText( CString &str )
{
    if ( m_fInit )
        return E_FAIL;        
    
    TCHAR szTmp[1024+1] = {0};
    
    // Get the values from the edit boxes.    
    m_csFirstName   = StrGetWindowText( m_ctrlFirstName.m_hWnd ).c_str();
    m_csLastName    = StrGetWindowText( m_ctrlLastName.m_hWnd ).c_str();
    m_csTelephone   = StrGetWindowText( m_ctrlTelephone.m_hWnd ).c_str();
    m_csOffice      = StrGetWindowText( m_ctrlOffice.m_hWnd ).c_str();
    m_csUName       = StrGetWindowText( m_ctrlUName.m_hWnd ).c_str();
    m_csUNamePre2k  = StrGetWindowText( m_ctrlUNamePre2k.m_hWnd ).c_str();
    m_csAlias       = StrGetWindowText( m_ctrlAlias.m_hWnd ).c_str();

    m_csFirstName.TrimLeft();
    m_csFirstName.TrimRight();
    m_csLastName.TrimLeft();
    m_csLastName.TrimRight();
    m_csTelephone.TrimLeft();
    m_csTelephone.TrimRight();
    m_csOffice.TrimLeft();
    m_csOffice.TrimRight();
    m_csUName.TrimLeft();
    m_csUName.TrimRight();
    m_csUNamePre2k.TrimLeft();
    m_csUNamePre2k.TrimRight();
    m_csAlias.TrimLeft();
    m_csAlias.TrimRight();
  
    CString csTmp;
    CString csFinFullname;
    csFinFullname.FormatMessage(IDS_FULLNAME_FORMAT_STR, (LPCTSTR)m_csFirstName, (LPCTSTR)m_csLastName);
    csTmp.FormatMessage(IDS_FIN_FULLNAME, csFinFullname);
    str += csTmp;
    
    csTmp.FormatMessage(IDS_FIN_LOGONNAME, m_csUName);
    str += csTmp;

    if( m_bPOP3Valid && m_csAlias.GetLength() )
    {
        CString csDomainName = m_csLogonDns;

        if( m_bCreatePOP3MB )
        {
            // Get the first domain name from POP3
            HRESULT             hr        = S_OK;
            CComPtr<IP3Config>  spConfig  = NULL;
            CComPtr<IP3Domains> spDomains = NULL;
            CComPtr<IP3Domain>  spDomain  = NULL;            
            CComVariant         cVar;
            CComBSTR            bstrDomainName;

            // Open our Pop3 Admin Interface
	        hr = CoCreateInstance(__uuidof(P3Config), NULL, CLSCTX_ALL, __uuidof(IP3Config), (LPVOID*)&spConfig);    

            if( SUCCEEDED(hr) )
            {
                // Get the Domains
	            hr = spConfig->get_Domains( &spDomains );
            }

            if( SUCCEEDED(hr) )
            {
                // Get the first domain                
                cVar = 1;
                
                hr = spDomains->get_Item( cVar, &spDomain );
            }

            if( SUCCEEDED(hr) )
            {
                hr = spDomain->get_Name( &bstrDomainName );                
            }

            if( SUCCEEDED(hr) )
            {
                csDomainName  = _T("@");
                csDomainName += bstrDomainName;
            }
        }

        CString csEmailName = m_csAlias + csDomainName;
        csTmp.FormatMessage(IDS_FIN_EXCHANGE, csEmailName);
        str += csTmp;
    }
    
    return S_OK;
}

// ----------------------------------------------------------------------------
// DeleteProperties()
// ----------------------------------------------------------------------------
HRESULT CAcctPage::DeleteProperties( IPropertyPagePropertyBag* pPPPBag )
{
    return S_OK;
}

// ----------------------------------------------------------------------------
// OnChangeEdit()
// ----------------------------------------------------------------------------
LRESULT CAcctPage::OnChangeEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if ( !m_fInit )     // IF the page has already been initialized...
    {        
        m_csFirstName   = StrGetWindowText( m_ctrlFirstName.m_hWnd ).c_str();        
        m_csLastName    = StrGetWindowText( m_ctrlLastName.m_hWnd ).c_str();        
        m_csFirstName.TrimLeft();
        m_csFirstName.TrimRight();
        m_csLastName.TrimLeft();
        m_csLastName.TrimRight();
    }

    // Update the Logon Name field (which will in turn update the PreWin2000 Name).
    TCHAR   ch;
    INT     iLen = 0;
    CString csFirstName = _T("");
    CString csLastName = _T("");    
    CString csOut = _T("");
    
    // Clear invalid characters out of both first and last name
    csFirstName = m_csFirstName;    
    iLen = csFirstName.GetLength();    
    for ( INT i=0; i<iLen; i++ )
    {
        ch = csFirstName.GetAt(i);
        if ( !_istspace(ch) &&                 // If it's not a space, 
             ValidChar(ch, m_bPOP3Installed) ) // And not an invalid character.   
        {                                      // then append it.
            csOut += ch;
        }
    }    
    csFirstName = CreateEmailName(csOut);    
    
    csOut = _T("");
    csLastName = m_csLastName;
    iLen = csLastName.GetLength();    
    for ( INT i=0; i<iLen; i++ )
    {
        ch = csLastName.GetAt(i);
        if ( !_istspace(ch) &&                 // If it's not a space, 
             ValidChar(ch, m_bPOP3Installed) ) // And not an invalid character.   
        {                                      // then append it.
            csOut += ch;
        }
    }    
    csLastName = CreateEmailName(csOut);        
        
    // We now create four options for the user when they update the User Name
    m_ctrlUName.ResetContent();

    CString csInsertString = _T("");

    csInsertString = csFirstName + csLastName;
    m_ctrlUName.InsertString( 0, csInsertString.Left(m_bPOP3Valid ? 20 : 64) );

    csInsertString = csLastName + csFirstName;
    m_ctrlUName.InsertString( 1, csInsertString.Left(m_bPOP3Valid ? 20 : 64) );

    csInsertString = csFirstName[0] + csLastName;
    m_ctrlUName.InsertString( 2, csInsertString.Left(m_bPOP3Valid ? 20 : 64) );

    csInsertString = csFirstName + csLastName[0];
    m_ctrlUName.InsertString( 3, csInsertString.Left(m_bPOP3Valid ? 20 : 64) );

    // Now set it to our current selection
    m_ctrlUName.SetCurSel( m_dwAutoMode );        
    PostMessage( WM_COMMAND, MAKEWPARAM(IDC_UNAME, CBN_EDITCHANGE), (LPARAM)GetDlgItem(IDC_UNAME) );
    
    NextCheck();    
    return(0);
}

// ----------------------------------------------------------------------------
// OnChangeUName()
// ----------------------------------------------------------------------------
LRESULT CAcctPage::OnChangeUName(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_csUName = StrGetWindowText( m_ctrlUName.m_hWnd ).c_str();
    m_csUName.TrimLeft();
    m_csUName.TrimRight();
    
    TCHAR szTmp[LM20_UNLEN+1] = {0};
    TCHAR *pchOut = szTmp;
    TCHAR *pch = NULL;
    int   nCount = 0;

    for ( pch=(LPTSTR)(LPCTSTR)m_csUName; (nCount < LM20_UNLEN) && (*pch != 0); nCount++, pch++ )
    {
        if( ValidChar(*pch, m_bPOP3Installed) )
        {
            *pchOut++ = *pch;
        }
    }
        
    *pchOut = 0;    // The last character needs to be a NULL!
    m_ctrlUNamePre2k.SetWindowText( szTmp );    

    if( m_bPOP3Valid && m_bCreatePOP3MB )
    {
        // In the POP3 case, the Email alias and the UserName need to be in perfect sync        
        m_ctrlAlias.SetWindowText((LPCTSTR)m_csUName);
    }

    NextCheck();
    return(0);
}

LRESULT CAcctPage::OnChangeUNameSel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // Store the selection
    m_dwAutoMode = m_ctrlUName.GetCurSel();
    m_dwAutoMode = (m_dwAutoMode == CB_ERR) ? 0 : m_dwAutoMode;  // Just in case we hit an error, set it to the first option.

    PostMessage( WM_COMMAND, MAKEWPARAM(wID, CBN_EDITCHANGE), (LPARAM)hWndCtl );    
    return 0;   
}

// ----------------------------------------------------------------------------
// OnChangePre2kUName()
// ----------------------------------------------------------------------------
LRESULT CAcctPage::OnChangePre2kUName(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{        
    m_csUNamePre2k = StrGetWindowText( m_ctrlUNamePre2k.m_hWnd ).c_str();
    m_csUNamePre2k.TrimLeft();
    m_csUNamePre2k.TrimRight();

    NextCheck();
    return(0);
}

// ----------------------------------------------------------------------------
// OnChangeAlias()
// ----------------------------------------------------------------------------
LRESULT CAcctPage::OnChangeAlias(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_csAlias = StrGetWindowText( m_ctrlAlias.m_hWnd ).c_str();
    m_csAlias.TrimLeft();
    m_csAlias.TrimRight();

    NextCheck();
    return(0);
}

// ----------------------------------------------------------------------------
// OnSetActive()
// ----------------------------------------------------------------------------
BOOL CAcctPage::OnSetActive()
{
    CWaitCursor cWaitCur;
    
    // Enable the next and back buttons.
    ::SendMessage( GetParent(), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_NEXT );

    // Our fake InitDialog()
    // NOTE: This is because if this is the first wizard page, it will get
    //       the WM_INITDIALOG message before its ReadProperties() function
    //       has been called.  
    if ( m_fInit )          // Is this the first SetActive?
    {
        Init();             // Call our init function.
        m_fInit = FALSE;    // And mark that this isn't the first SetActive.
    }

    NextCheck();
    return TRUE;
}

// ----------------------------------------------------------------------------
// OnWizardBack()
// ----------------------------------------------------------------------------
int CAcctPage::OnWizardBack()
{
    CWaitCursor cWaitCur;
    HRESULT         hr = S_OK;    

    m_csFirstName   = StrGetWindowText( m_ctrlFirstName.m_hWnd ).c_str();
    m_csLastName    = StrGetWindowText( m_ctrlLastName.m_hWnd ).c_str();
    m_csTelephone   = StrGetWindowText( m_ctrlTelephone.m_hWnd ).c_str();
    m_csOffice      = StrGetWindowText( m_ctrlOffice.m_hWnd ).c_str();
    m_csUName       = StrGetWindowText( m_ctrlUName.m_hWnd ).c_str();
    m_csUNamePre2k  = StrGetWindowText( m_ctrlUNamePre2k.m_hWnd ).c_str();
    m_csAlias       = StrGetWindowText( m_ctrlAlias.m_hWnd ).c_str();

    m_csFirstName.TrimLeft();
    m_csFirstName.TrimRight();
    m_csLastName.TrimLeft();
    m_csLastName.TrimRight();
    m_csTelephone.TrimLeft();
    m_csTelephone.TrimRight();
    m_csOffice.TrimLeft();
    m_csOffice.TrimRight();
    m_csUName.TrimLeft();
    m_csUName.TrimRight();
    m_csUNamePre2k.TrimLeft();
    m_csUNamePre2k.TrimRight();
    m_csAlias.TrimLeft();
    m_csAlias.TrimRight();
    
    m_csUserCN.FormatMessage(IDS_FULLNAME_FORMAT_STR, (LPCTSTR)m_csFirstName, (LPCTSTR)m_csLastName);
    m_csUserCN = L"CN=" + m_csUserCN;
 
    return 0;   // Go back.
}

// ----------------------------------------------------------------------------
// OnWizardNext()
// ----------------------------------------------------------------------------
int CAcctPage::OnWizardNext()
{
    CWaitCursor cWaitCur;
    HRESULT         hr = S_OK;    
    CString         csTmp;
    
    m_csFirstName   = StrGetWindowText( m_ctrlFirstName.m_hWnd ).c_str();
    m_csLastName    = StrGetWindowText( m_ctrlLastName.m_hWnd ).c_str();
    m_csTelephone   = StrGetWindowText( m_ctrlTelephone.m_hWnd ).c_str();
    m_csOffice      = StrGetWindowText( m_ctrlOffice.m_hWnd ).c_str();
    m_csUName       = StrGetWindowText( m_ctrlUName.m_hWnd ).c_str();
    m_csUNamePre2k  = StrGetWindowText( m_ctrlUNamePre2k.m_hWnd ).c_str();
    m_csAlias = StrGetWindowText( m_ctrlAlias.m_hWnd ).c_str();
    
    m_csFirstName.TrimLeft();
    m_csFirstName.TrimRight();    
    m_csLastName.TrimLeft();
    m_csLastName.TrimRight();    
    m_csTelephone.TrimLeft();
    m_csTelephone.TrimRight();
    m_csOffice.TrimLeft();
    m_csOffice.TrimRight();
    m_csUName.TrimLeft();
    m_csUName.TrimRight();
    m_csUNamePre2k.TrimLeft();
    m_csUNamePre2k.TrimRight();
    m_csAlias.TrimLeft();
    m_csAlias.TrimRight();    

    m_csUserCN.FormatMessage( IDS_FULLNAME_FORMAT_STR, (LPCTSTR)m_csFirstName, (LPCTSTR)m_csLastName );
    m_csUserCN.TrimLeft();
    m_csUserCN.TrimRight();

    CString csTmpCN = m_csUserCN;
    m_csUserCN = L"CN=" + m_csUserCN;

    csTmpCN = EscapeString(((LPCTSTR)csTmpCN), 4);  // Escape just the \s

    CString csUPN = m_csUName;
    csUPN += m_csLogonDns;      // Create the UPN...

    BOOL    bCantCheck = FALSE;

    int iLenTmp = m_csUName.GetLength();
    TCHAR chTmp = m_csUName.GetAt(iLenTmp-1);
    

    // Check for valid logon name and pre-win2000 name;
    if ( chTmp == _T('.') ||	 
         !ValidString( (LPCTSTR)m_csUName, m_bPOP3Installed ) || 
         !ValidString( (LPCTSTR)m_csUNamePre2k, m_bPOP3Installed ) )
    {
        ErrorMsg(IDS_ERROR_BAD_LOGON, IDS_TITLE);     // If we're in simple mode, they don't see the Pre2K name
        m_ctrlUName.SetFocus();
        m_ctrlUName.SetEditSel(0, -1);
        return(-1);
    }
    
    // Check for duplicate userPrincipalName
    hr = FindADsObject((LPCTSTR)m_csUserOU, (LPCTSTR)csUPN, _T("(userPrincipalName=%1)"), csTmp, 0, TRUE);
    if ( SUCCEEDED(hr) )
    {
        if ( hr == S_FALSE )
        {
            // Can't check for uniqueness.
            bCantCheck = TRUE;
        }
        else
        {
            ErrorMsg(IDS_ERROR_DUP_LOGON, IDS_TITLE);
            m_ctrlUName.SetFocus();
            m_ctrlUName.SetEditSel(0, -1);
            return(-1);
        }
    }

    // Check for duplicate CN
    hr = FindADsObject((LPCTSTR)m_csUserOU, (LPCTSTR)csTmpCN, _T("(|(cn=%1)(ou=%1))"), csTmp, 0, FALSE);
    if ( SUCCEEDED(hr) )
    {
        if ( hr == S_FALSE )
        {
            // Can't check for uniqueness.
            bCantCheck = TRUE;
        }
        else
        {
            ErrorMsg(IDS_ERROR_DUP_CN, IDS_TITLE);
            m_ctrlFirstName.SetFocus();
            m_ctrlFirstName.SetSel(0, -1);
            return(-1);
        }
    }
    
    // Check for duplicate pre-Win2000 name;
    hr = FindADsObject((LPCTSTR)m_csUserOU, (LPCTSTR)m_csUNamePre2k, _T("(sAMAccountName=%1)"), csTmp, 3, TRUE);
    if ( SUCCEEDED(hr) )
    {
        if ( hr == S_FALSE )
        {
            // Can't check for uniqueness.
            bCantCheck = TRUE;
        }
        else
        {
            ErrorMsg(IDS_ERROR_DUP_PRE2K, IDS_TITLE);     // If we're in simple mode, they don't see the Pre2K name
            m_ctrlUName.SetFocus();
            m_ctrlUName.SetEditSel(0, -1);
            return(-1);
        }
    }    

    if( m_bPOP3Valid && m_csAlias.GetLength() )
    {
        // Check for duplicate email alias
        // Get the first domain name from POP3        
        CComPtr<IP3Config>  spConfig  = NULL;
        CComPtr<IP3Domains> spDomains = NULL;
        CComPtr<IP3Domain>  spDomain  = NULL;            
        CComPtr<IP3Users>   spUsers   = NULL;            
        CComPtr<IP3User>    spUser    = NULL;            
        CComVariant         cVar;
        CComBSTR            bstrDomainName;

        // Open our Pop3 Admin Interface
	    hr = CoCreateInstance(__uuidof(P3Config), NULL, CLSCTX_ALL, __uuidof(IP3Config), (LPVOID*)&spConfig);    

        if( SUCCEEDED(hr) )
        {
            // Get the Domains
	        hr = spConfig->get_Domains( &spDomains );
        }

        if( SUCCEEDED(hr) )
        {
            // Get the first domain                
            cVar = 1;
            
            hr = spDomains->get_Item( cVar, &spDomain );
        }

        if( SUCCEEDED(hr) )
        {
            // get the users from the domain
            hr = spDomain->get_Users( &spUsers );            
        }

        if( SUCCEEDED(hr) )
        {
            // Try and get this users email name
            CComVariant varUserName = m_csAlias;
            hr = spUsers->get_Item( varUserName, &spUser );
        }

        if( SUCCEEDED(hr) && spUser )
        {
            // It's a duplicate, sorry!
            ErrorMsg(IDS_ERROR_POP3DUP, IDS_TITLE);
            m_ctrlUName.SetFocus();
            m_ctrlUName.SetEditSel(0, -1);
            return(-1);
        }
    }

    return 0;   // Go next.
}

BOOL CAcctPage::NextCheck(void)
{
    if ( ( _tcslen((LPCTSTR)m_csUName ) )               &&
         ( _tcslen((LPCTSTR)m_csUNamePre2k ) )          && 
         ( _tcslen((LPCTSTR)m_csFirstName) || _tcslen((LPCTSTR)m_csLastName) ) )
    {
        ::SendMessage( GetParent(), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_NEXT );
        return(TRUE);
    }
    
    ::SendMessage( GetParent(), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK );
    return(FALSE);
}

LRESULT CAcctPage::OnEmailClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    m_bCreatePOP3MB = (IsDlgButtonChecked(IDC_EMAIL_CHECKBOX) == BST_CHECKED);
    m_csAlias = _T("");
    m_ctrlAlias.SetWindowText( m_csAlias );

    OnChangeUName( wNotifyCode, wID, hWndCtl, bHandled );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\au_accnt\cacctp.h ===
#ifndef _CACCTP_H
#define _CACCTP_H

#include <tmplEdit.h>

#include "pp_base.h"
#include "AU_Accnt.h"
#include "AUsrUtil.h"

class CAddUser_AccntWiz;

// ----------------------------------------------------------------------------
// CAcctPage
// ----------------------------------------------------------------------------
class CAcctPage : public CBasePropertyPageInterface, public CPropertyPageImpl<CAcctPage>
{
    public:
        // Constructor/destructor
        CAcctPage( CAddUser_AccntWiz* pNW );
        ~CAcctPage();
    
        // CBasePropertyPageInterface pure virtual function(s)
        enum { IDD = IDD_ACCT_INFO };
        virtual long GetIDD () { return IDD; }
    
        // ATL::CPropertyPageImpl overrides
        virtual BOOL OnSetActive ();
        virtual int  OnWizardBack();
        virtual int  OnWizardNext();
    
        // Property Bag functions
        HRESULT ReadProperties    ( IPropertyPagePropertyBag* pPPPBag );
        HRESULT WriteProperties   ( IPropertyPagePropertyBag* pPPPBag );
        HRESULT DeleteProperties  ( IPropertyPagePropertyBag* pPPPBag );
        HRESULT ProvideFinishText ( CString &str );

        CString     m_csUNamePre2k;

    private:
        CAddUser_AccntWiz *m_pASW;      // pointer to owning property sheet
    
        BOOL        m_fInit;
        BOOL        m_fSimpleMode;
        BOOL        m_bExchange;
        BOOL        m_bCreatePOP3MB;
        BOOL        m_bPOP3Installed;
        BOOL        m_bPOP3Valid;
        CString     m_csUserOU;
        CString     m_csFirstName;
        CString     m_csLastName;
        CString     m_csTelephone;
        CString     m_csOffice;
        CString     m_csUName;
        CString     m_csUserCN;
        CString     m_csAlias;
        DWORD       m_dwAutoMode;
        
        CString     m_csLogonDns;

        CEdit       m_ctrlFirstName;    // Controls on the page.
        CEdit       m_ctrlLastName;     // "
        CEdit       m_ctrlTelephone;    // "     
        CEdit       m_ctrlOffice;       // "
        CComboBox   m_ctrlUName;        // "        
        CEdit       m_ctrlUNameLoc;     // "
        CEdit       m_ctrlUNamePre2k;   // "
        CEdit       m_ctrlUNamePre2kLoc;// "

        CEdit       m_ctrlAlias;        // "
        CWindowImplAlias<> m_ctrlImplAlias; // Limits the typing to specific characters
        CWindowImplAlias<> m_ctrlImplUName; // Limits the typing to specific characters

        LRESULT     Init     ( );        // Our "InitDialog" (called from OnSetActive).    
        BOOL        NextCheck( );
    
    protected:
        BEGIN_MSG_MAP (CAcctPage)
            MESSAGE_HANDLER     (WM_INITDIALOG,                     OnInitDialog      )
            MESSAGE_HANDLER     (WM_DESTROY,                        OnDestroy         )

            COMMAND_HANDLER     (IDC_FIRST_NAME,    EN_CHANGE,      OnChangeEdit      )
            COMMAND_HANDLER     (IDC_LAST_NAME,     EN_CHANGE,      OnChangeEdit      )                        
            COMMAND_HANDLER     (IDC_UNAME_PRE2K,   EN_CHANGE,      OnChangePre2kUName)
            COMMAND_HANDLER     (IDC_EMAIL_ALIAS,   EN_CHANGE,      OnChangeAlias     )
            COMMAND_HANDLER     (IDC_UNAME,         CBN_EDITCHANGE, OnChangeUName     )            
            COMMAND_HANDLER     (IDC_UNAME,         CBN_SELCHANGE,  OnChangeUNameSel  )
            COMMAND_HANDLER     (IDC_EMAIL_CHECKBOX,BN_CLICKED,     OnEmailClicked    )
            CHAIN_MSG_MAP       (CPropertyPageImpl<CAcctPage>)
        END_MSG_MAP()
    
        LRESULT OnInitDialog        ( UINT uMsg,  WPARAM wParam, LPARAM lParam, BOOL& bHandled );
        LRESULT OnDestroy           ( UINT uMsg,  WPARAM wParam, LPARAM lParam, BOOL& bHandled );
        LRESULT OnChangeEdit        ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
        LRESULT OnChangeUName       ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
        LRESULT OnChangeUNameSel    ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
        LRESULT OnChangePre2kUName  ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
        LRESULT OnChangeAlias       ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
        LRESULT OnEmailClicked      ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
};

#endif  // _CACCTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\au_accnt\resource.h ===
#define IDS_TITLE                       100
#define IDS_ACCT_INFO_TITLE             110
#define IDS_ACCT_INFO_SUBTITLE          111
#define IDS_PASSWD_GEN_TITLE            120
#define IDS_PASSWD_GEN_SUBTITLE         121

#define IDS_ERROR_DUP_LOGON             200
#define IDS_ERROR_DUP_PRE2K             201
#define IDS_ERROR_DUP_CN                202
#define IDS_ERROR_BAD_LOGON             203
#define IDS_ERROR_BAD_PRE2K             204
#define IDS_ERROR_DUP_ALIAS             205
#define IDS_ERROR_BAD_ALIAS             206

#define IDS_ERROR_PASSWD_MATCH          210
#define IDS_ERROR_PASSWDLEN             211

#define IDS_ERROR_CREATING_USER         230
#define IDS_ERROR_PASSWORD              232
#define IDS_ERROR_MEMBERSHIP            233
#define IDS_ERROR_DUPLICATE             234
#define IDS_ERROR_POP3MAILBOX           235
#define IDS_ERROR_LONGPW                236
#define IDS_ERROR_POP3DUP               237

#define IDS_FINISH_TEXT                 300
#define IDS_FIN_FULLNAME                301
#define IDS_FIN_LOGONNAME               302
#define IDS_FIN_EXCHANGE                303
#define IDS_FIN_PASSWD                  304
#define IDS_FIN_TEXT                    305

#define IDS_HF_APPENDUSERNAME           350
#define IDS_HF_PATHALREADYEXISTS        351

#define IDD_ACCT_INFO                   400

#define IDC_FIRST_NAME                  401
#define IDC_LAST_NAME                   402
#define IDC_TELEPHONE                   403
#define IDC_OFFICE                      404
#define IDC_UNAME                       405
#define IDC_UNAME_LOC                   406
#define IDC_PRE2K_TEXT                  407
#define IDC_UNAME_PRE2K                 408
#define IDC_UNAME_PRE2K_LOC             409
#define IDC_EMAIL_ALIAS_TEXT            410
#define IDC_EMAIL_ALIAS                 411
#define IDC_EMAIL_CHECKBOX              412

#define IDD_PASSWD_GEN                  500
#define IDC_RAD_1_SPECIFY               520
#define IDC_PASSWD_1A_TEXT              521
#define IDC_PASSWD_1A                   522
#define IDC_PASSWD_1B_TEXT              523
#define IDC_PASSWD_1B                   524
#define IDC_PASSWD_2_TEXT               525
#define IDC_PASSWD_2                    526
#define IDC_RAD_2_MUST                  527
#define IDC_RAD_2_CANNOT                538
#define IDC_RAD_2_CAN                   539

#define IDB_BITMAP1                     800

#define IDR_AUSR_ACCNT_WIZ              901
#define IDR_AUSR_ACCNT_COMMIT           902

#define IDS_FULLNAME_FORMAT_STR         6000

#define IDS_NOLOC_USEREMAILALIAS        8000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\au_accnt\cpasswdp.h ===
#ifndef _CPASSWDP_H
#define _CPASSWDP_H

// Generated
#include "AU_Accnt.h"

// DLL\INC
#include "pp_base.h"
#include "AUsrUtil.h"

class CAddUser_AccntWiz;

// ----------------------------------------------------------------------------
// CPasswdPage
// ----------------------------------------------------------------------------
class CPasswdPage : public CBasePropertyPageInterface, public CPropertyPageImpl<CPasswdPage>
{
    public:
        // Constructor/destructor
        CPasswdPage(CAddUser_AccntWiz* pNW);
        ~CPasswdPage();
    
        // CBasePropertyPageInterface pure virtual function(s)
        enum { IDD = IDD_PASSWD_GEN };
        virtual long GetIDD () { return IDD; }
    
        // ATL::CPropertyPageImpl overrides
        virtual BOOL OnSetActive();
        virtual int  OnWizardBack();
        virtual int  OnWizardNext();
    
        // Property Bag functions
        HRESULT ReadProperties    ( IPropertyPagePropertyBag* pPPPBag );
        HRESULT WriteProperties   ( IPropertyPagePropertyBag* pPPPBag );
        HRESULT DeleteProperties  ( IPropertyPagePropertyBag* pPPPBag );
        HRESULT ProvideFinishText ( CString &str );

    private:
        
        CAddUser_AccntWiz *m_pASW;      // pointer to owning property sheet
    
        BOOL        m_fInit;       
        
        DWORD       m_dwOptions;

        CString     m_csPasswd1a;       // Text to hold the controls values.
        CString     m_csPasswd1b;       // Text to hold the controls values.
        CString     m_csPasswd2;
        CString     m_csUserOU;
        CString     m_csWinNTDC;
        
        CEdit       m_ctrlPasswd1a;     // Controls on the page.
        CEdit       m_ctrlPasswd1b;     // "
        CButton     m_ctrlRad2Must;     // "
        CButton     m_ctrlRad2Cannot;   // "
        CButton     m_ctrlRad2Can;      // "
        CButton     m_ctrlAcctDisabled; // "

        LRESULT     Init (void);        // Our "InitDialog" (called from OnSetActive).
    
    protected:
        BEGIN_MSG_MAP (CPasswdPage)
            MESSAGE_HANDLER     (WM_INITDIALOG,     OnInitDialog)
            MESSAGE_HANDLER     (WM_DESTROY,        OnDestroy   )

            CHAIN_MSG_MAP       (CPropertyPageImpl<CPasswdPage>)
        END_MSG_MAP()
    
        LRESULT OnInitDialog    (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);    
        LRESULT OnDestroy       (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};

// ----------------------------------------------------------------------------
// Non-class functions
// ----------------------------------------------------------------------------


#endif  // _CPASSWDP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\au_accnt\cpasswdp.cpp ===
#include <stdafx.h>
#include "CPasswdP.h"

#include "AccntWiz.h"
#include "proputil.h"

#include <imm.h>
#include <dsgetdc.h>

#define PASSWD_NOCHANGE     0x01
#define PASSWD_CANCHANGE    0x02
#define PASSWD_MUSTCHANGE   0x04

// --------------------------------------------------------------------------------------------------------------------------------
// CPasswdPage class
// --------------------------------------------------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// Constructor
// ----------------------------------------------------------------------------
CPasswdPage::CPasswdPage( CAddUser_AccntWiz* pASW ) :
    m_csUserOU(),
    m_csPasswd1a(),
    m_csPasswd1b()
{
    m_pASW = pASW;
    m_psp.dwFlags          |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    m_psp.pszHeaderTitle    = MAKEINTRESOURCE(IDS_PASSWD_GEN_TITLE);
    m_psp.pszHeaderSubTitle = MAKEINTRESOURCE(IDS_PASSWD_GEN_SUBTITLE);

    // Defaults
    m_fInit       = TRUE;    
    m_dwOptions   = 0;
}

// ----------------------------------------------------------------------------
// Destructor
// ----------------------------------------------------------------------------
CPasswdPage::~CPasswdPage( )
{     
}

// ----------------------------------------------------------------------------
// OnDestroy()
// ----------------------------------------------------------------------------
LRESULT CPasswdPage::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Detach all of our controls from the windows.
    m_ctrlPasswd1a.Detach();
    m_ctrlPasswd1b.Detach();
    m_ctrlRad2Must.Detach();
    m_ctrlRad2Cannot.Detach();
    m_ctrlRad2Can.Detach();   

    return 0;
}

// ----------------------------------------------------------------------------
// OnInitDialog()
// ----------------------------------------------------------------------------
LRESULT CPasswdPage::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{        
    // Attach controls. 
    m_ctrlPasswd1a.Attach       ( GetDlgItem(IDC_PASSWD_1A)     );
    m_ctrlPasswd1b.Attach       ( GetDlgItem(IDC_PASSWD_1B)     );
    m_ctrlRad2Must.Attach       ( GetDlgItem(IDC_RAD_2_MUST)    );
    m_ctrlRad2Cannot.Attach     ( GetDlgItem(IDC_RAD_2_CANNOT)  );
    m_ctrlRad2Can.Attach        ( GetDlgItem(IDC_RAD_2_CAN)     );    
    
    // Limit the Edit boxes   
    m_ctrlPasswd1a.SetLimitText( PWLEN );
    m_ctrlPasswd1b.SetLimitText( PWLEN );    
    
    // Initialize the controls' state
    m_ctrlRad2Can.SetCheck(1);    
    
    // Disable IME for the controls.
    ::ImmAssociateContext( m_ctrlPasswd1a.m_hWnd, NULL );
    ::ImmAssociateContext( m_ctrlPasswd1b.m_hWnd, NULL );
    
    return(0);
}

// ----------------------------------------------------------------------------
// Init()
// 
// Initializes the controls on the page with the values from the property bag.
// NOTE:  This is called from OnSetActive(), but only on the first SetActive.
//        This is because even though the control attaching could be done in
//        the WM_INITDIALOG handler, setting the values of the controls from 
//        the values read from the property bag can only safely be done in the
//        PSN_SETACTIVE.  
// ----------------------------------------------------------------------------
LRESULT CPasswdPage::Init( )
{
    return 0;
}

// ----------------------------------------------------------------------------
// ReadProperties()
// ----------------------------------------------------------------------------
HRESULT CPasswdPage::ReadProperties( IPropertyPagePropertyBag * pPPPBag )
{
    return S_OK;
}

// ----------------------------------------------------------------------------
// WriteProperties()
// ----------------------------------------------------------------------------
HRESULT CPasswdPage::WriteProperties( IPropertyPagePropertyBag * pPPPBag )
{
    m_dwOptions = 0;
    
    if ( !m_fInit )     // IF the page has already been initialized...
    {
        // Get the values from the edit boxes.        
        m_csPasswd1a = StrGetWindowText( m_ctrlPasswd1a.m_hWnd ).c_str();
        
        if( m_ctrlRad2Must.GetCheck() )
        {
            m_dwOptions |= PASSWD_MUSTCHANGE;    
        }
        else if( m_ctrlRad2Cannot.GetCheck() )
        {
            m_dwOptions |= PASSWD_NOCHANGE;    
        }
        else
        {
            m_dwOptions |= PASSWD_CANCHANGE;    
        }        
    }
    
    // Write the values to the property bag.    
    WriteString( pPPPBag, PROP_PASSWD_GUID_STRING,      m_csPasswd1a,      FALSE );
    WriteInt4  ( pPPPBag, PROP_ACCOUNT_OPT_GUID_STRING, (LONG)m_dwOptions, FALSE );
    
    return S_OK;
}

// ----------------------------------------------------------------------------
// ProvideFinishText()
// ----------------------------------------------------------------------------
HRESULT CPasswdPage::ProvideFinishText( CString &str )
{
    if ( m_fInit )
        return E_FAIL;        
        
    return S_OK;
}

// ----------------------------------------------------------------------------
// DeleteProperties()
// ----------------------------------------------------------------------------
HRESULT CPasswdPage::DeleteProperties( IPropertyPagePropertyBag * pPPPBag )
{
    return S_OK;
}

// ----------------------------------------------------------------------------
// OnSetActive()
// ----------------------------------------------------------------------------
BOOL CPasswdPage::OnSetActive()
{
    CWaitCursor cWaitCur;
    
    // Enable the next and back buttons.
    ::SendMessage( GetParent(), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_NEXT );

    // Our fake InitDialog()
    // NOTE: This is because if this is the first wizard page, it will get
    //       the WM_INITDIALOG message before its ReadProperties() function
    //       has been called.  
    if ( m_fInit )          // Is this the first SetActive?
    {
        Init();             // Call our init function.
        m_fInit = FALSE;    // And mark that this isn't the first SetActive.
    }
    
    return TRUE;
}

// ----------------------------------------------------------------------------
// OnWizardBack()
// ----------------------------------------------------------------------------
int CPasswdPage::OnWizardBack()
{    
    return 0;   // Go back.
}

// ----------------------------------------------------------------------------
// OnWizardNext()
// ----------------------------------------------------------------------------
int CPasswdPage::OnWizardNext()
{
    CWaitCursor     cWaitCur;    
    CString         csPasswd;
    CString         csTitle;
    CString         csError;
    HWND            hWndPasswd;
    HRESULT         hr = S_OK;
    
    // Get the values from the edit boxes.    
    m_csPasswd1a = StrGetWindowText( m_ctrlPasswd1a.m_hWnd ).c_str();
    m_csPasswd1b = StrGetWindowText( m_ctrlPasswd1b.m_hWnd ).c_str();
    
    hWndPasswd = m_ctrlPasswd1a.m_hWnd;
    csPasswd   = m_csPasswd1a;    
    
    // Make sure they match...    
    if ( _tcscmp((LPCTSTR)m_csPasswd1a, (LPCTSTR)m_csPasswd1b) )
    {
        csError.LoadString(IDS_ERROR_PASSWD_MATCH);
        csTitle.LoadString(IDS_TITLE);

        ::MessageBox(m_hWnd, (LPCTSTR)csError, (LPCTSTR)csTitle, MB_OK | MB_TASKMODAL | MB_ICONERROR);
        ::SetFocus(hWndPasswd);

        return(-1);
    }
    
    // Make sure it meets the minimum length requirements. (bug 4210)    
    CString                 csDns       = _T("");
    CString                 csDCName    = _T("");
    PDOMAIN_CONTROLLER_INFO pDCI        = NULL;

    hr = DsGetDcName( NULL, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME, &pDCI );
    if( (hr == S_OK) && (pDCI != NULL) ) 
    {
        csDns = pDCI->DomainName;

    	NetApiBufferFree (pDCI);
        pDCI = NULL;
    }

    tstring strDomain = GetDomainPath((LPCTSTR)csDns);
    csDCName  = L"LDAP://";
    csDCName += strDomain.c_str();
    
    // Now open the IADs object for the LDAP version of the DC..
    // Then convert to WinNT version.
    CComPtr<IADs> spADs = NULL;

    hr = ::ADsGetObject( (LPTSTR)(LPCTSTR)csDCName, IID_IADs, (VOID**)&spADs );
    if( SUCCEEDED(hr) )
    {
        CComVariant var;
        CComBSTR bstrProp = _T("dc");
        spADs->Get( bstrProp, &var );
        
        csDCName  = L"WinNT://";        
        csDCName += V_BSTR(&var);
    }

    CComPtr<IADsDomain> spADsDomain = NULL;

    hr = ::ADsOpenObject( (LPTSTR)(LPCTSTR)csDCName, NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADsDomain, (VOID**)&spADsDomain );
    if( SUCCEEDED(hr) )
    {
        long lMinLength = 0;
        
        spADsDomain->get_MinPasswordLength( &lMinLength );
        
        if( csPasswd.GetLength() < lMinLength )
        {
            TCHAR szMin[128];
            
            _itot(lMinLength, szMin, 10);
            
            csError.FormatMessage(IDS_ERROR_PASSWDLEN, szMin);
            csTitle.LoadString(IDS_TITLE);
    
            ::MessageBox(m_hWnd, (LPCTSTR)csError, (LPCTSTR)csTitle, MB_OK | MB_TASKMODAL | MB_ICONERROR);
            ::SetFocus(hWndPasswd);
    
            return(-1);
        }
    }    

    // Finally Check if it is more than 14 characters.
    if( csPasswd.GetLength() > LM20_PWLEN )
    {
        csError.LoadString(IDS_ERROR_LONGPW);
        csTitle.LoadString(IDS_TITLE);

        if( ::MessageBox( m_hWnd, (LPCTSTR)csError, (LPCTSTR)csTitle, MB_YESNO | MB_ICONWARNING ) == IDNO )
        {
            ::SetFocus( hWndPasswd );
            return -1;
        }
    }
    
    return 0;   // Go next.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\au_accnt\pp_base.h ===
#ifndef __PP_BASE_H__
#define __PP_BASE_H__

#include <atlbase.h>
#include <shellapi.h>   // atlwin.h needs DragAcceptFiles
#include <atlwin.h>
#include <atldlgs.h>
#include "resource.h"

class CBasePropertyPageInterface
{
public:
    // Constructor/destructor
    CBasePropertyPageInterface( ) { m_previousIDD = m_nextIDD = 0; }
    virtual ~CBasePropertyPageInterface( ) {}

    virtual long GetIDD       ( ) = 0;
    
    virtual void SetPrevious  ( long IDD ) { m_previousIDD = IDD; }
    virtual long GetPrevious  ( )  { return  m_previousIDD; }
    
    virtual void SetNext      ( long IDD ) { m_nextIDD = IDD; }
    virtual long GetNext      ( )  { return  m_nextIDD; }

private:
    long m_previousIDD, m_nextIDD;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\au_accnt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__54C42B2D_405C_11D3_B40C_00C04F9900F5__INCLUDED_)
#define AFX_STDAFX_H__54C42B2D_405C_11D3_B40C_00C04F9900F5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0501
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <wizchain.h>

#include <dlgs.h>
#include <shellapi.h>
#include <lm.h>
#include <activeds.h>
#include <atlwin.h>

#include <atlctrls.h>
#include <atltmp.h>

#include <commctrl.h>

#include "propuid.h"
#include "cwaitcur.h"

#include <string>
typedef std::basic_string<TCHAR> tstring;
typedef tstring TSTRING;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__54C42B2D_405C_11D3_B40C_00C04F9900F5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\inc\ausrutil.h ===
#ifndef _AUSRUTIL_H
#define _AUSRUTIL_H

#include <activeds.h>
#include "EscStr.h"

#include <lm.h>
#include <lmapibuf.h>
#include <lmshare.h>

#define SECURITY_WIN32
#include <security.h>

enum NameContextType
{
    NAMECTX_SCHEMA = 0,
    NAMECTX_CONFIG = 1,
    NAMECTX_COUNT
};

// ----------------------------------------------------------------------------
// GetADNamingContext()
// ----------------------------------------------------------------------------
inline HRESULT GetADNamingContext(NameContextType ctx, LPCWSTR* ppszContextDN)
{
    const static LPCWSTR pszContextName[NAMECTX_COUNT] = { L"schemaNamingContext", L"configurationNamingContext"};
    static CString strContextDN[NAMECTX_COUNT];

    HRESULT hr = S_OK;

    if (strContextDN[ctx].IsEmpty())
    {
        CComVariant var;
        CComPtr<IADs> pObj;
    
        hr = ADsGetObject(L"LDAP://rootDSE", IID_IADs, (void**)&pObj);
        if (SUCCEEDED(hr))
        {
            CComBSTR bstrProp = pszContextName[ctx];
            hr = pObj->Get( bstrProp, &var );
            if (SUCCEEDED(hr))
            {
                strContextDN[ctx] = var.bstrVal;
                *ppszContextDN = strContextDN[ctx];
            }
        }
    }
    else
    {
        *ppszContextDN = strContextDN[ctx];
        hr = S_OK;
    }

    return hr;
}

//--------------------------------------------------------------------------
// EnableButton
//
// Enables or disables a dialog control. If the control has the focus when
// it is disabled, the focus is moved to the next control
//--------------------------------------------------------------------------
inline void EnableButton(HWND hwndDialog, int iCtrlID, BOOL bEnable)
{
    HWND hWndCtrl = ::GetDlgItem(hwndDialog, iCtrlID);
    ATLASSERT(::IsWindow(hWndCtrl));

    if (!bEnable && ::GetFocus() == hWndCtrl)
    {
        HWND hWndNextCtrl = ::GetNextDlgTabItem(hwndDialog, hWndCtrl, FALSE);
        if (hWndNextCtrl != NULL && hWndNextCtrl != hWndCtrl)
        {
            ::SetFocus(hWndNextCtrl);
        }
    }

    ::EnableWindow(hWndCtrl, bEnable);
}

// ----------------------------------------------------------------------------
// ErrorMsg()
// ----------------------------------------------------------------------------
inline void ErrorMsg(UINT uiError, UINT uiTitle)
{
    CString csError; 
    CString csTitle;

    csError.LoadString(uiError);
    csTitle.LoadString(uiTitle);

    ::MessageBox(NULL, (LPCWSTR)csError, (LPCWSTR)csTitle, MB_OK | MB_TASKMODAL | MB_ICONERROR);
}

inline BOOL StrContainsDBCS(LPCTSTR szIn)
{
    if( !szIn ) return FALSE;

    BOOL    bFound  = FALSE;
    TCHAR   *pch    = NULL;

    for ( pch=(LPTSTR)szIn; *pch && !bFound; pch=_tcsinc(pch) )
    {
        if ( IsDBCSLeadByte((BYTE)*pch) )
        {
            bFound = TRUE;
        }
    }
    
    return bFound;
}

inline BOOL LdapToDCName(LPCTSTR pszPath, LPTSTR pszOutBuf, int nOutBufSize)
{
    if( !pszPath || !pszOutBuf || !nOutBufSize ) return FALSE;

    pszOutBuf[0] = 0;
    
    TCHAR* pszTemp = _tcsstr( pszPath, _T("DC=") );
    if( !pszTemp ) return FALSE;

    DWORD dwSize = nOutBufSize;

    BOOLEAN bSuccess = TranslateName( pszTemp, NameFullyQualifiedDN, NameCanonical, pszOutBuf, &dwSize );    

    if( bSuccess && (dwSize > 2) )
    {
        if( pszOutBuf[dwSize-2] == _T('/') )
        {
            pszOutBuf[dwSize-2] = 0;
        }
    }

    return (BOOL)bSuccess;

}    

// ----------------------------------------------------------------------------
// FindADsObject()
// 
// szFilterFmt must be of the format "(|(cn=%1)(ou=%1))"
//  NOTE: szFilterFmt must contain ONLY %1's..  i.e. %2 is right out!
// ----------------------------------------------------------------------------
inline HRESULT FindADsObject( LPCTSTR szOU, LPCTSTR szObject, LPCTSTR szFilterFmt, CString &csResult, DWORD dwRetType/*=0*/, BOOL bRoot/*=FALSE*/ )
{
    if( !szOU || !szObject || !szFilterFmt ) return E_POINTER;

    // Find out if the szObject contains any '(' or ')'s..  if so then we have to exit.
    if ( _tcschr(szObject, _T('(')) ||
         _tcschr(szObject, _T(')')) )
    {
        return S_FALSE;
    }    

    HRESULT     hr      = S_OK;
    CString     csTmp   = szOU;
    CString     csOU    = L"LDAP://";
    TCHAR       *pch    = NULL;
    
    if ( bRoot )
    {
        csTmp.MakeUpper();
        pch = _tcsstr( (LPCTSTR)csTmp, L"DC=" );    // Find the first DC=
        if ( !pch ) return E_FAIL;
            
        csOU += pch;    // Append from the DC= on.
        
        if ( (pch = _tcschr((LPCTSTR)csOU + 7, L'/')) != NULL )
        {
            // Hmmm. . something was after the DC='s... I don't even know
            //  if that's allowed.
            //  (e.g. LDAP://DC=ted,DC=microsoft,DC=com/foo)
            // If so, let's end the string at the /
            *pch = 0;
        }
    }
    else
    {
        csTmp.MakeUpper();
        pch = _tcsstr( (LPCTSTR)csTmp, L"LDAP://" );    // Did the string include the LDAP://?
        if ( !pch )
        {
            csOU += csTmp;
        }
        else
        {
            csOU = csTmp;
        }
        // Now csOU contains the LDAP:// for sure.
    }

    // Set query parameters
    CComPtr<IDirectorySearch>   spDirSearch = NULL;
    ADS_SEARCH_HANDLE   hSearch;                                        // Handle used for searching.
    ADS_SEARCH_COLUMN   col;                                            // Used to hold the current column.
    CString             csFilter;
    LPTSTR              pszAttr[]   = { _T("cn"), _T("distinguishedName"), _T("description"), _T("sAMAccountName"), _T("mailNickname") };
    DWORD               dwCount     = sizeof(pszAttr) / sizeof(LPTSTR);
    
    
    csFilter.FormatMessage(szFilterFmt, szObject);
    
    // Open our search object.
    hr = ::ADsOpenObject(const_cast<LPTSTR>((LPCTSTR)csOU), NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (void**)&spDirSearch);
    if ( !SUCCEEDED(hr) )
    {
        _ASSERT(FALSE);
        return hr;
    }
    
    // Search for out object.
    hr = spDirSearch->ExecuteSearch(const_cast<LPTSTR>((LPCTSTR)csFilter), pszAttr, dwCount, &hSearch);
    if ( !SUCCEEDED(hr) )   
    {
        return(hr);
    }
    
    if ( spDirSearch->GetNextRow(hSearch) == S_ADS_NOMORE_ROWS )
    {
        spDirSearch->CloseSearchHandle(hSearch);
        return(E_FAIL);
    }
    
    // If we got to here, then we got the object, so let's get the LDAP path to the 
    //  object so that we can return it to the caller.
    hr = spDirSearch->GetColumn(hSearch, pszAttr[dwRetType], &col);
    if ( !SUCCEEDED(hr) )
    {
        _ASSERT(FALSE);
        csResult = _T("");
    }
    else
    {        
        csResult = col.pADsValues->CaseExactString;
        spDirSearch->FreeColumn(&col);
    }
    
    spDirSearch->CloseSearchHandle(hSearch);
    
    return(S_OK);
}

inline tstring GetDomainPath( LPCTSTR lpServer )
{
    if( !lpServer ) return _T("");

    // get the domain information
    CComVariant   var;
    tstring       strRet  = _T("");
    
    TCHAR         pszString[MAX_PATH*2] = {0};
    _sntprintf( pszString, (MAX_PATH*2)-1, L"LDAP://%s/rootDSE", lpServer );

    CComPtr<IADs> pDS = NULL;
    HRESULT hr = ::ADsGetObject( pszString, IID_IADs, (void**)&pDS );
    if( SUCCEEDED(hr) )
    {
        CComBSTR bstrProp = _T("defaultNamingContext");        
        hr = pDS->Get( bstrProp, &var );
    }

    if( SUCCEEDED(hr) && (V_VT(&var) == VT_BSTR) )
    {
        strRet = V_BSTR( &var );
    }


    return strRet;
}

//+----------------------------------------------------------------------------
//
//  Function:   RemoveTrailingWhitespace
//
//  Synopsis:   Trailing white space is replaced by NULLs.
//
//-----------------------------------------------------------------------------
inline void RemoveTrailingWhitespace(LPTSTR pszIn)
{
    if( !pszIn ) return;

    int nLen = _tcslen(pszIn);

    while( nLen )
    {
        if( !iswspace(pszIn[nLen - 1]) )
        {
            return;
        }
        pszIn[nLen - 1] = L'\0';
        nLen--;
    }
}

inline tstring StrFormatSystemError( HRESULT hrErr )
{
    tstring strError = _T("");
    LPVOID  lpMsgBuf = NULL;

    // look up the error from the system
    if ( ::FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_FROM_SYSTEM |
                          FORMAT_MESSAGE_IGNORE_INSERTS,
                          NULL,
                          hrErr,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                          (LPTSTR)&lpMsgBuf,
                          0,
                          NULL ))
    {
        if( lpMsgBuf )
        {
            strError = (LPTSTR)lpMsgBuf;
            LocalFree( lpMsgBuf );
        }
    }

    // return the error string
    return strError;
}

inline tstring StrGetWindowText( HWND hWnd )
{
    if( !hWnd || !IsWindow(hWnd) )
    {
        return _T("");
    }

    TSTRING strRet  = _T("");
    INT     iLen    = GetWindowTextLength(hWnd);
    TCHAR*  pszText = new TCHAR[ iLen + 1 ];
    if ( pszText )
    {
        if ( GetWindowText(hWnd, pszText, iLen + 1) )
        {
            strRet = pszText;
        }

        delete[] pszText;
    }

    return strRet;
}

inline HRESULT SetSecInfoMask( LPUNKNOWN punk, SECURITY_INFORMATION si )
{
    HRESULT hr = E_INVALIDARG;
    if( punk )
    {
        CComPtr<IADsObjectOptions> spOptions;
        hr = punk->QueryInterface( IID_IADsObjectOptions, (void**)&spOptions );
        if( SUCCEEDED(hr) )
        {
            VARIANT var;
            VariantInit( &var );
            V_VT( &var ) = VT_I4;
            V_I4( &var ) = si;
            
            hr = spOptions->SetOption( ADS_OPTION_SECURITY_MASK, var );            
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSDForDsObject
//  Synopsis:   Reads the security descriptor from the specied DS object
//              It only reads the DACL portion of the security descriptor
//
//  Arguments:  [IN  pDsObject] --  DS object
//              [ppDACL]            --pointer to dacl in ppSD is returned here
//              [OUT ppSD]          --  Security descriptor returned here.
//              calling API must free this by calling LocalFree                
//
//  Notes:      The returned security descriptor must be freed with LocalFree
//
//----------------------------------------------------------------------------

inline HRESULT GetSDForDsObject( IDirectoryObject* pDsObject, PACL* ppDACL, PSECURITY_DESCRIPTOR* ppSD )
{
    if(!pDsObject || !ppSD) return E_POINTER;

    *ppSD = NULL;
    if(ppDACL)
    {
       *ppDACL = NULL;
    }

    HRESULT hr = S_OK;    
    PADS_ATTR_INFO pSDAttributeInfo = NULL;            
   
    WCHAR const c_szSDProperty[]  = L"nTSecurityDescriptor";      
    LPWSTR pszProperty = (LPWSTR)c_szSDProperty;
      
    // Set the SECURITY_INFORMATION mask to DACL_SECURITY_INFORMATION
    hr = SetSecInfoMask(pDsObject, DACL_SECURITY_INFORMATION);

    DWORD dwAttributesReturned;
    if( SUCCEEDED(hr) )
    {
        // Read the security descriptor attribute
        hr = pDsObject->GetObjectAttributes( &pszProperty, 1, &pSDAttributeInfo, &dwAttributesReturned );
        if(SUCCEEDED(hr) && !pSDAttributeInfo)
        {
            hr = E_FAIL;
        }
    }     

    if( SUCCEEDED(hr) )
    {
        if((ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->dwADsType) && 
           (ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->pADsValues->dwType))
        {
            *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, pSDAttributeInfo->pADsValues->SecurityDescriptor.dwLength);
            if (!*ppSD)
            {
                hr = E_OUTOFMEMORY;                
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    if( SUCCEEDED(hr) )
    {
        CopyMemory( *ppSD, pSDAttributeInfo->pADsValues->SecurityDescriptor.lpValue, pSDAttributeInfo->pADsValues->SecurityDescriptor.dwLength );

        if( ppDACL )
        {
            BOOL bDaclPresent,bDaclDeafulted;
            if( !GetSecurityDescriptorDacl(*ppSD, &bDaclPresent, ppDACL, &bDaclDeafulted) )
            {
                DWORD dwErr = GetLastError();
                hr = HRESULT_FROM_WIN32(dwErr);
            }
        }
    }
    
    if( pSDAttributeInfo )
    {
        FreeADsMem( pSDAttributeInfo );
    }

    if( FAILED(hr) )
    {
        if(*ppSD)
        {
            LocalFree(*ppSD);
            *ppSD = NULL;
            if(ppDACL)
                *ppDACL = NULL;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSDForDsObjectPath
//  Synopsis:   Reads the security descriptor from the specied DS object
//              It only reads the DACL portion of the security descriptor
//
//  Arguments:  [IN  pszObjectPath] --  LDAP Path of ds object
//              [ppDACL]            --pointer to dacl in ppSD is returned here
//              [OUT ppSD]          --  Security descriptor returned here.
//              calling API must free this by calling LocalFree                
//
//  Notes:      The returned security descriptor must be freed with LocalFree
//
//----------------------------------------------------------------------------
inline HRESULT GetSDForDsObjectPath( LPCWSTR pszObjectPath, PACL* ppDACL, PSECURITY_DESCRIPTOR* ppSecurityDescriptor )
{
    if(!pszObjectPath || !ppSecurityDescriptor) return E_POINTER;
    
    CComPtr<IDirectoryObject> spDsObject = NULL;
    HRESULT hr = ADsGetObject(pszObjectPath, IID_IDirectoryObject,(void**)&spDsObject);
    if(SUCCEEDED(hr))
    {
        hr = GetSDForDsObject( spDsObject, ppDACL, ppSecurityDescriptor );
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetDaclForDsObject
//  Synopsis:   Sets the  the DACL for the specified DS object
//
//  Arguments:  [IN  pDsObject] --  ds object
//              [IN pDACL]     --pointer to dacl to be set
//
//----------------------------------------------------------------------------
inline HRESULT SetDaclForDsObject( IDirectoryObject* pDsObject, PACL pDACL )
{
    if(!pDsObject || !pDACL) return E_POINTER;
    
    WCHAR const c_szSDProperty[]  = L"nTSecurityDescriptor";
    PSECURITY_DESCRIPTOR pSD = NULL;
    PSECURITY_DESCRIPTOR pSDCurrent = NULL;
    HRESULT hr = S_OK;

    //Get the current SD for the object
    hr = GetSDForDsObject(pDsObject,NULL,&pSDCurrent);   

    //Get the control for the current security descriptor
    SECURITY_DESCRIPTOR_CONTROL currentControl;
    DWORD dwRevision = 0;
    if( SUCCEEDED(hr) )
    {
        if( !GetSecurityDescriptorControl(pSDCurrent, &currentControl, &dwRevision) )
        {
            DWORD dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErr);            
        }
    }

    if( SUCCEEDED(hr) )
    {
        //Allocate the buffer for Security Descriptor
        pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH + pDACL->AclSize);
        if(!pSD)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if( SUCCEEDED(hr) )
    {
        if(!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
        {
            DWORD dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErr);            
        }
    }

    if( SUCCEEDED(hr) )
    {
        PISECURITY_DESCRIPTOR pISD = (PISECURITY_DESCRIPTOR)pSD;
      
        //
        // Finally, build the security descriptor
        //
        pISD->Control |= SE_DACL_PRESENT | SE_DACL_AUTO_INHERIT_REQ | (currentControl & (SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED));

        if (pDACL->AclSize > 0)
        {
            pISD->Dacl = (PACL)(pISD + 1);
            CopyMemory(pISD->Dacl, pDACL, pDACL->AclSize);
        }

        // We are only setting DACL information
        hr = SetSecInfoMask(pDsObject, DACL_SECURITY_INFORMATION);
    }
    
    SECURITY_DESCRIPTOR_CONTROL sdControl = 0;
    if( SUCCEEDED(hr) )
    {
        //
        // If necessary, make a self-relative copy of the security descriptor
        //        
        if(!GetSecurityDescriptorControl(pSD, &sdControl, &dwRevision))
        {
            DWORD dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErr);            
        }
    }

    DWORD dwSDLength = 0;
    if( SUCCEEDED(hr) )
    {
        // Need the total size
        dwSDLength = GetSecurityDescriptorLength(pSD);

        if (!(sdControl & SE_SELF_RELATIVE))
        {
            PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSDLength);

            if (psd == NULL || !MakeSelfRelativeSD(pSD, psd, &dwSDLength))
            {
                DWORD dwErr = GetLastError();
                hr = HRESULT_FROM_WIN32(dwErr);                
            }

            // Point to the self-relative copy
            LocalFree(pSD);        
            pSD = psd;
        }
    }

    if( SUCCEEDED(hr) )
    {
        ADSVALUE attributeValue;
        attributeValue.dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
        attributeValue.SecurityDescriptor.dwLength = dwSDLength;
        attributeValue.SecurityDescriptor.lpValue = (LPBYTE)pSD;

        ADS_ATTR_INFO attributeInfo;
        attributeInfo.pszAttrName = (LPWSTR)c_szSDProperty;
        attributeInfo.dwControlCode = ADS_ATTR_UPDATE;
        attributeInfo.dwADsType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
        attributeInfo.pADsValues = &attributeValue;
        attributeInfo.dwNumValues = 1;

        // Write the security descriptor
        DWORD dwAttributesModified;
        hr = pDsObject->SetObjectAttributes(&attributeInfo, 1, &dwAttributesModified);
    }

    if(pSDCurrent)
    {
        LocalFree(pSDCurrent);
    }

    if(pSD)
    {
        LocalFree(pSD);
    }

    return S_OK;
}

inline HRESULT SetDaclForDsObjectPath( LPCWSTR pszObjectPath, PACL pDACL )
{
    // VAlidate the parameters
    if(!pszObjectPath || !pDACL) return E_POINTER;

    // Get the object and then pass it on to the helper function
    CComPtr<IDirectoryObject> spDsObject = NULL;
    HRESULT hr = ADsGetObject( pszObjectPath, IID_IDirectoryObject, (void**)&spDsObject );
    if( SUCCEEDED(hr) )
    {
        hr = SetDaclForDsObject( spDsObject, pDACL );
    }

    return hr;
}

#endif  // _AUSRUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\inc\createemailname.h ===
#ifndef _CREATEEMAILNAME
#define _CREATEEMAILNAME

CString CreateEmailName(LPCTSTR psName);
const TCHAR ALLOWED_CHARS[] = _T("!#$%^'()-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz{}~");

inline CString CreateEmailName(LPCTSTR psName)
{
    CString sBuildName = _T("");

    if( !psName ) 
		return sBuildName;	// length of psName handled below

    int iSize = _tcslen(psName);

    LPTSTR psBuildName = new TCHAR[iSize + 1];
    LPTSTR psChar = new TCHAR[2];

    if( (0 < iSize) && psBuildName && psChar )
    {
        int i, j = 0;
        ZeroMemory( psChar, 2 * sizeof(TCHAR) );
        ZeroMemory( psBuildName, ( iSize + 1 ) * sizeof( TCHAR ));
        LPTSTR psResult = NULL;

        for ( i = 0; i < iSize; i++ )
        {
            _tcsncpy( psChar, &(psName[i]), 1 );
            psResult = _tcspbrk( psChar, ALLOWED_CHARS );
            if( psResult )
            {
                psBuildName[j++] = psName[i];
            }
        }
    
        sBuildName = psBuildName;        
    }
    else
        sBuildName = psName;

    if( psBuildName )
    {
        delete [] psBuildName;
        psBuildName = NULL;
    }

    if( psChar )
    {
        delete [] psChar;
        psChar = NULL;
    }

    return sBuildName;
}

#endif  //_CREATEEMAILNAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\inc\cwaitcur.h ===
#ifndef _CWAITCUR_H
#define _CWAITCUR_H

// ----------------------------------------------------------------------------
// CWaitCursor()
// ----------------------------------------------------------------------------
class CWaitCursor
{
    public:
        CWaitCursor() : m_hOldCursor(NULL)
        {
            m_hWaitCursor = ::LoadCursor(NULL, IDC_WAIT);
            if (!m_hWaitCursor) 
                return;
        
            m_hOldCursor = ::SetCursor(m_hWaitCursor);
        }

        ~CWaitCursor()
        {
            if( m_hOldCursor )
            {
                ::SetCursor(m_hOldCursor);
            }
        }
    
    private:
        HCURSOR m_hOldCursor;
        HCURSOR m_hWaitCursor;
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\inc\cmdline.h ===
#ifndef _CMDLINE_H
#define _CMDLINE_H

inline LPCTSTR _FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}


inline LPCTSTR _FindOption(LPCTSTR p1)
{
	if (p1 == NULL)
		return NULL;

	// loop until end of string
	while (*p1)
	{
		// if space then check next char for option (- or /)
		if (*p1 == _T(' '))
		{
			p1 = CharNext(p1);
			if (*p1 == _T('-') || *p1 == _T('/'))
				return CharNext(p1);
		}
		// if quote then skip over quoted string
		else if (*p1 == _T('"'))
		{
			// loop until single quote or end of string found
			p1 = CharNext(p1);
			while (*p1)
			{
				if (*p1 == _T('"'))
				{
					p1 = CharNext(p1);
					if (*p1 != _T('"'))
						break;
				}
				p1 = CharNext(p1);
			}
			
		}
		else
		{
			p1 = CharNext(p1);
		}
	}

	return NULL;
}


inline BOOL _ReadParam(/*in,out*/TCHAR* &pszIn, /*out*/TCHAR* pszOut)
{
    ATLASSERT(pszIn && pszOut);
    if (!pszIn || !pszOut) {
        return FALSE;
    }

    // skip the switch
    pszIn = CharNext(pszIn);

    // skip leading spaces
    while (*pszIn == _T(' '))
        pszIn = CharNext(pszIn);

    // deal with parameters enclosed in quotes to allow embedded spaces
    BOOL fQuoted = FALSE;
    if (*pszIn == _T('"')) {
        pszIn = CharNext(pszIn);
        fQuoted = TRUE;
    }

    // get the next arg (delimited by space or null or end quote)
    int nPos = 0;
    while (*pszIn && nPos < MAX_PATH) {
        if (fQuoted) {
            if (*pszIn == _T('"')) {
                // don't break on double quotes
                if (pszIn[1] == _T('"')) {
                    pszOut[nPos++] = *pszIn;
                    pszIn = CharNext(pszIn);
                    pszIn = CharNext(pszIn);
                    continue;
                }
                else {
                    pszIn = CharNext(pszIn);
                    break;
                }
            }
        }
        else { 
            if(*pszIn == _T(' '))
               break;
        }
        pszOut[nPos++] = *pszIn;
        pszIn = CharNext(pszIn);
    }
    pszOut[nPos] = 0;

    return TRUE;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\inc\checkuser.h ===
//-----------------------------------------------------------------------------
// checkuser.h
//-----------------------------------------------------------------------------

#ifndef _CHECKUSER_H
#define _CHECKUSER_H


HRESULT _CheckSIDInProcess( SID* pSID )
{
	if( !pSID )
	{
		return E_POINTER;
	}

	BOOL bRet = FALSE;
	if( !CheckTokenMembership(NULL, pSID, &bRet) )
	{
		return HRESULT_FROM_WIN32( GetLastError() );
	}

	return bRet ? S_OK : S_FALSE;
}

HRESULT IsUserInGroup( DWORD dwRID )
{
    PSID psid = NULL;
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    BOOL bRet = AllocateAndInitializeSid( &sia,
										  2,
										  SECURITY_BUILTIN_DOMAIN_RID,
										  dwRID,
										  0, 0, 0, 0, 0, 0,
										  &psid);
	if( !bRet  )
	{
		return HRESULT_FROM_WIN32( GetLastError() );
	}
	else if( !psid )
	{
		return E_FAIL;
	}
	
	HRESULT hr = _CheckSIDInProcess( (SID*)psid );
	FreeSid( psid );
	return hr;
}

HRESULT IsUserInGroup( const TCHAR* pszGroup )
{
	if( !pszGroup )
	{
		return E_POINTER;
	}

	HRESULT hr = S_FALSE;
	DWORD dwSize = 0;
	DWORD dwDomainSize = 0;
	SID_NAME_USE snu;
	if( !LookupAccountName(NULL, pszGroup, NULL, &dwSize, NULL, &dwDomainSize, &snu) &&
		GetLastError() == ERROR_INSUFFICIENT_BUFFER )
	{
		SID* psid = (SID*)new BYTE[dwSize];
		if( !psid )
		{
			return E_OUTOFMEMORY;
		}

		TCHAR* pszDomain = new TCHAR[dwDomainSize];
		if( !pszDomain )
		{
			delete[] psid;
			return E_OUTOFMEMORY;
		}

		if( LookupAccountName(NULL, pszGroup, psid, &dwSize, pszDomain, &dwDomainSize, &snu) )
		{
			hr = _CheckSIDInProcess( psid );
		}
		else
		{
			hr = HRESULT_FROM_WIN32( GetLastError() );
		}

		delete[] psid;
		delete[] pszDomain;
	}
	else
	{
		return E_FAIL;
	}

	return hr;
}


#endif	// _CHECKUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\inc\escstr.h ===
#ifndef _ESCSTR_H
#define _ESCSTR_H

#define ESC_CHAR_LIST_1     L",=+<>#;"
#define ESC_CHAR_LIST_2     L"/,=\r\n+<>#;\"\\"
#define ESC_CHAR_LIST_3     L"/"
#define ESC_CHAR_LIST_4     L"\\"

// ----------------------------------------------------------------------------
// EscapeString()
// ----------------------------------------------------------------------------
inline void EscapeString(LPWSTR szInOut, DWORD dwList=0)   // WSTR so that it can't be compiled ANSI
{
    if ( !szInOut || !wcslen(szInOut) )       // Empty string?
        return;
    
    WCHAR   *szTmp  = new WCHAR[wcslen(szInOut) * 2];
    WCHAR   *pIn    = NULL;
    WCHAR   *pOut   = NULL;
    WCHAR   *szList = NULL;
    
    if ( !szTmp )
    {
        _ASSERT(FALSE);
        return;
    }
    
    switch(dwList)
    {
        case 0:
        case 1:
            szList = ESC_CHAR_LIST_1;
            break;
        case 2:
            szList = ESC_CHAR_LIST_2;
            break;
        case 3:
            szList = ESC_CHAR_LIST_3;
            break;
        case 4:
            szList = ESC_CHAR_LIST_4;
            break;
        default:
            szList = ESC_CHAR_LIST_1;
            break;
    }
    
    for ( pIn = szInOut, pOut = szTmp; *pIn != 0; pIn++ )
    {
        if ( wcschr(szList, *pIn) )         // If it's a bad char...
            *pOut++ = L'\\';                // then add the '\'
    
        *pOut++ = *pIn;                     // then append the char
    }
    *pOut = 0;
    
    wcscpy(szInOut, szTmp);                 // Copy the new string to "szInOut"
    delete[] szTmp;                         //  cause we're modifying in place.
    
    return;
}

// ----------------------------------------------------------------------------
// EscapeString()
// ----------------------------------------------------------------------------
inline CString EscapeString(LPCWSTR szIn, DWORD dwList=0)   // WSTR so that it can't be compiled ANSI
{
    CString csOut   = _T("");

    if( !szIn || !wcslen(szIn) ) return csOut;

    WCHAR   *szOut  = new WCHAR[wcslen(szIn) * 2];
    WCHAR   *pIn    = NULL;
    WCHAR   *pOut   = NULL;
    WCHAR   *szList = NULL;
    
    if ( !szOut )
    {
        _ASSERT(FALSE);
        csOut = szIn;
        return csOut;
    }
    
    switch(dwList)
    {
        case 0:
        case 1:
            szList = ESC_CHAR_LIST_1;
            break;
        case 2:
            szList = ESC_CHAR_LIST_2;
            break;
        case 3:
            szList = ESC_CHAR_LIST_3;
            break;
        case 4:
            szList = ESC_CHAR_LIST_4;
            break;
        default:
            szList = ESC_CHAR_LIST_1;
            break;
    }
    
    for ( pIn = (LPWSTR)szIn, pOut = szOut; *pIn != 0; pIn++ )
    {
        if( wcschr(szList, *pIn) )          // // If it's a bad char...
            *pOut++ = L'\\';                // then add the '\'
    
        *pOut++ = *pIn;                     // then append the char
    }
    *pOut = 0;
    
    csOut = szOut;
    delete[] szOut;
    
    return csOut;
}

// ----------------------------------------------------------------------------
// EscapeString()
// ----------------------------------------------------------------------------
inline CString EscapeString(CString csIn, DWORD dwList=0)
{
    CString csOut = _T("");
    
    csOut = EscapeString((LPCTSTR)csIn, dwList);
    
    return csOut;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\inc\createtempfile.h ===
#ifndef CREATETEMPFILE_H
#define CREATETEMPFILE_H


#include <aclapi.h>
#include <shlwapi.h>
#include <shlobj.h>


/*
Routine Name:   CreateTempFile

Routine Description:
    Creates a temporary file only the caller can access.

Arguments:
pszTempFileName
    [in/out] Pointer to a null terminated string that is the full path to the temp file or
    receives the full path to the temp file if bCreateName is TRUE. You should set the size
    of this buffer to MAX_PATH to ensure that it is large enough to hold the returned string.
pszExtension
    [in] Pointer to a null terminated string that specifies the extension of the file name to be 
    created.If pszExtension is NULL, the default extension is tmp.
bCreateName
    [in] Species whether pszTempFileName should receive a temp file name generated by the function.
    if bCreateName is TRUE, a temp file in user's temp directory is created and full path to the file
    is returned to the caller in pszTempFileName.
dwFlags
    [in] Specifies the file attributes and flags for the file.


Return Values:
    If the function succeeds, the return value is a handle to the temp file.
    if the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information
    call GetLastError()

Author:
    gokmenh, March, 2002
*/

inline HANDLE _CreateTempFile  (
                            LPTSTR pszTempFileName,
                            LPTSTR pszExtension = NULL,
                            BOOL bCreateName = TRUE,
                            DWORD dwFlags = 0
                        )
{
    TCHAR szTempPath[MAX_PATH];
    TCHAR szTempFile[MAX_PATH];
    DWORD dwRC = ERROR_SUCCESS;
    DWORD dwLength;
    TOKEN_USER * pTokenUser = NULL;
    EXPLICIT_ACCESS ea[1];
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    SECURITY_ATTRIBUTES sa;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hToken = NULL;
    BOOL bCreateDir = FALSE;
    
    szTempPath[0] = NULL;
    szTempFile[0] = NULL;

    ZeroMemory( ea, sizeof(ea) );

    if (NULL == pszTempFileName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    
    // If the caller does not specify the file name we
    // need to come up with our own.

    if (TRUE == bCreateName)
    {    
        if (0 == GetTempPath(sizeof(szTempPath)/sizeof(TCHAR), szTempPath))
        {
            dwRC = GetLastError();
        }

        if (ERROR_SUCCESS == dwRC)
        {
            if (0 == GetTempFileName(szTempPath, _T("tmp"), 0, szTempFile))
            {
                dwRC = GetLastError();
            }
            else
            {
                if (NULL != pszExtension)
                {
                    // We will change the extension, get rid of the file with the old extension

                    if (FALSE == DeleteFile(szTempFile))
                    {
                        dwRC = GetLastError();
                    }

                    if (ERROR_SUCCESS == dwRC)
                    {
                        if (FALSE == PathRenameExtension(szTempFile, pszExtension))
                        {
                            dwRC = ERROR_INVALID_DATA;
                        }
                    }
                }
            }

        }
    }
    else
    {
        szTempPath[MAX_PATH - 1] = NULL;

        _tcsncpy(szTempFile, pszTempFileName, MAX_PATH);
        _tcsncpy(szTempPath, pszTempFileName, MAX_PATH);

        if (NULL != szTempPath[MAX_PATH - 1])
        {
            dwRC = ERROR_INVALID_PARAMETER;
        }
    }
    
    if (ERROR_SUCCESS == dwRC)
    {
        // We will first try to get to the impersonation token for the thread
        
        if (0 == OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken))
        {
            dwRC = GetLastError();

            if (ERROR_NO_TOKEN == dwRC)
            {
                // It seems that the thread is not doing impersonation. We will stick to the 
                // process token
                
                if (0 == OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
                {
                    dwRC = GetLastError();
                }
                else
                {
                    dwRC = ERROR_SUCCESS;
                }    
            }
        }
    }
            
    if (ERROR_SUCCESS == dwRC)
    {
        // First try to obtain how much space we need

        if (0 == GetTokenInformation(hToken, TokenUser, NULL, 0, &dwLength))
        {
            dwRC = GetLastError();

            if (ERROR_INSUFFICIENT_BUFFER == dwRC)
            {
                // Allocate the required memory and retry.

                dwRC = ERROR_SUCCESS;
                pTokenUser = (TOKEN_USER *) new BYTE[dwLength];

                if (NULL == pTokenUser)
                {
                    dwRC = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                if (0 == GetTokenInformation(hToken, TokenUser, pTokenUser, dwLength, &dwLength))
                {
                    dwRC = GetLastError();
                }
            }
        }
        else
        {
            // GetTokenInformation works with a NULL pointer?

            dwRC = ERROR_INVALID_DATA;
        }
    }

    if (ERROR_SUCCESS == dwRC)
    {
        // We now have the token info for the current user which contains the sid for the user.
        // We will try to create a security descriptor which allows only the user to access the file.

        ea[0].grfAccessPermissions = GENERIC_ALL;
        ea[0].grfAccessMode = SET_ACCESS;
        ea[0].grfInheritance = NO_INHERITANCE;
        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        ea[0].Trustee.ptstrName = (LPTSTR) pTokenUser->User.Sid;

        dwRC = SetEntriesInAcl(1, ea, NULL, &pACL);
    }

    if (ERROR_SUCCESS == dwRC)
    {
        pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

        if (NULL == pSD)
        {
            dwRC = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (ERROR_SUCCESS == dwRC)
    {
        if ( 0 == InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
        {
            dwRC = GetLastError();
        }
    }

    if (ERROR_SUCCESS == dwRC)
    {
        if (0 == SetSecurityDescriptorDacl(pSD, TRUE, pACL, FALSE))
        {
            dwRC = GetLastError();
        }
    }

    if (ERROR_SUCCESS == dwRC)
    {
        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.bInheritHandle = FALSE;
        sa.lpSecurityDescriptor = pSD;

        if (FALSE == bCreateName)
        {
            if (FALSE == PathRemoveFileSpec(szTempPath))
            {
                dwRC = ERROR_INVALID_PARAMETER;
            }
            else
            {
                // We do not want to create root dirs

                if (FALSE == PathIsRoot(szTempPath))
                {
                    dwRC = SHCreateDirectoryEx(NULL, szTempPath, &sa);

                    if ((ERROR_FILE_EXISTS == dwRC) || (ERROR_ALREADY_EXISTS == dwRC))
                    {
                        dwRC = ERROR_SUCCESS;
                    }
                }
            }
        }
    }

    if (ERROR_SUCCESS == dwRC)
    {
        hFile = CreateFile  (
                                szTempFile,
                                GENERIC_ALL,
                                FILE_SHARE_READ,
                                &sa,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_TEMPORARY | dwFlags,
                                NULL
                            );

        dwRC = GetLastError();

        if (INVALID_HANDLE_VALUE != hFile)
        {
            if (ERROR_ALREADY_EXISTS == dwRC)
            {
                // If the file already exists, we will still have a handle to the file but
                // CreateFile does not change the security descriptor for the file so we need
                // to make sure that we ACL the file properly.

                dwRC = SetNamedSecurityInfo (
                                                (LPTSTR) szTempFile,                    // File name
                                                SE_FILE_OBJECT,                         // This is a file
                                                DACL_SECURITY_INFORMATION |             // We will pass in an ACL
                                                PROTECTED_DACL_SECURITY_INFORMATION,    // File will not inherit anything from the parent
                                                NULL,                                   // Owner sid
                                                NULL,                                   // Group sid
                                                pACL,                                   // ACL
                                                NULL                                    // SACL
                                            );

            }
        }
    }
    
    if (NULL != pSD)
    {
        LocalFree(pSD);
    }

    if (NULL != pACL)
    {
        LocalFree(pACL);
    }

    if (NULL != pTokenUser)
    {
        delete [] (LPBYTE) pTokenUser;
    }

    if (NULL != hToken)
    {
        CloseHandle(hToken);
    }

    if (ERROR_SUCCESS == dwRC)
    {
        _tcsncpy(pszTempFileName, szTempFile, MAX_PATH);

        return hFile;
    }
    else
    {
        if (INVALID_HANDLE_VALUE != hFile)
        {
            CloseHandle(hFile);
        }
        SetLastError(dwRC);
        return INVALID_HANDLE_VALUE;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\inc\proglist.h ===
//-----------------------------------------------------------------------------
// ProgList.h
//-----------------------------------------------------------------------------

#ifndef _PROGLIST_H
#define _PROGLIST_H


//-----------------------------------------------------------------------------
// state of the item
//-----------------------------------------------------------------------------
typedef enum
{
	IS_NONE = 0,	// the item hasn't been run yet
	IS_SUCCEEDED,	// the item succeeded
	IS_FAILED		// the item failed

} ItemState;

//-----------------------------------------------------------------------------
// an entry in the list
//-----------------------------------------------------------------------------
class CProgressItem
{
public:

	CProgressItem() :
		m_strText(_T("")),
		m_bActive(FALSE),
		m_eState(IS_NONE),
		m_lData(0)
	{
	}

	TSTRING		m_strText;		// display string of the item
	BOOL		m_bActive;		// is the item active / currently processing
	ItemState	m_eState;		// state of the item
	LPARAM		m_lData;		// misc item data

};	// class CProgressItem


//-----------------------------------------------------------------------------
// the list itself
//-----------------------------------------------------------------------------
class CProgressList : public CWindowImpl< CProgressList, CListViewCtrl >
{
//-----------------------------------------------------------------------------
// functions
//-----------------------------------------------------------------------------
	public:

	BEGIN_MSG_MAP(CProgressList)
	END_MSG_MAP()

	typedef CWindowImpl< CProgressList, CListViewCtrl >	BC;

	VOID Attach( HWND h )
	{
		// call the base class to attach to the control
		BC::Attach( h );

		// initialize the background of the control
		SetBkColor( GetSysColor(COLOR_BTNFACE) );

		// create the fonts for the control
		HFONT hf;
        LOGFONT lf;
		ZeroMemory( &lf, sizeof(lf) );

		hf = GetFont();
		::GetObject( hf, sizeof(lf), &lf );

		// create the normal/text font from the current font
		m_hfText = CreateFontIndirect( &lf );

		// create the bold font
		lf.lfWeight = FW_BOLD;
		m_hfBoldText = CreateFontIndirect( &lf );

		// make the symbol font
		lf.lfHeight = min( GetSystemMetrics(SM_CXVSCROLL), GetSystemMetrics(SM_CYVSCROLL) ) - 4;
		lf.lfHeight = MulDiv( lf.lfHeight, 3, 2 );
		lf.lfWeight = FW_NORMAL;
		lf.lfCharSet = SYMBOL_CHARSET;
		_tcscpy( lf.lfFaceName, _T("Marlett") );
		m_hfSymbol = CreateFontIndirect( &lf );

		// need to use a larger font for one of the symbols
		lf.lfHeight -= ( lf.lfHeight / 4 );
		m_hfLargeSymbol = CreateFontIndirect( &lf );

		// add a column that is the width of the control
		RECT rc;
		GetWindowRect( &rc );

		LVCOLUMN lvC;
		lvC.mask = LVCF_TEXT | LVCF_WIDTH;
		lvC.cx = (rc.right - rc.left) - GetSystemMetrics(SM_CXVSCROLL) - 2;
		lvC.pszText = _T("");
		InsertColumn( 0, &lvC );
	}

	INT AddItem( TSTRING strText )
	{
		// create a new progress item and insert into the list control and internal list		
        CProgressItem* pItem = new CProgressItem();
        if( !pItem ) return -1;

		pItem->m_strText = strText;
		m_lItems.push_back( pItem );

		LVITEM lvI;
        ZeroMemory( &lvI, sizeof(lvI) );
		lvI.mask = LVIF_PARAM;
		lvI.iItem = GetItemCount();
		lvI.lParam = (LPARAM)pItem;
		return InsertItem( &lvI );
	}

	VOID OnMeasureItem( LPARAM lParam )
	{
		MEASUREITEMSTRUCT* p = (MEASUREITEMSTRUCT*)lParam;
        if( !p ) return;

		HDC hDC = GetDC();

		TEXTMETRIC tm;
		GetTextMetrics( hDC, &tm );
		p->itemWidth = 0;
		p->itemHeight = tm.tmHeight + 2;
		ReleaseDC( hDC );
	}

	VOID OnDrawItem( LPARAM lParam )
	{
		// get the data we need and stop redrawing
		DRAWITEMSTRUCT* p = (DRAWITEMSTRUCT*)lParam;
        if( !p ) return;

		CProgressItem* pI = (CProgressItem*)p->itemData;
        if( !pI ) return;

		SetRedraw( FALSE );

		// get the symbol to draw next to the item
		TCHAR ch = 0;
		COLORREF crText = GetSysColor( COLOR_WINDOWTEXT );
		HFONT hfSymbol = m_hfSymbol;
		if( pI->m_bActive )
		{
			ch = _T('4');
		}
		else if( pI->m_eState == IS_SUCCEEDED )
		{
			ch = _T('a');
			crText = RGB( 0, 128, 0 );
		}
		else if( pI->m_eState == IS_FAILED )
		{
			ch = _T('r');
			crText = RGB( 128, 0, 0 );
			hfSymbol = m_hfLargeSymbol;
		}

		// setup the text and draw the symbol if there is one
		if( ch )
		{
			HFONT hfPre = (HFONT)SelectObject( p->hDC, hfSymbol );
			COLORREF crPre = ::SetTextColor( p->hDC, crText );

			DrawText( p->hDC, &ch, 1, &p->rcItem, DT_SINGLELINE | DT_VCENTER );

			SelectObject( p->hDC, hfPre );
			::SetTextColor( p->hDC, crPre );
		}

		// draw the item text, inc the RECT for the symbol
		p->rcItem.left += 20;

		HFONT hfPre = (HFONT)SelectObject( p->hDC, ch == _T('4') ? m_hfBoldText : m_hfText );
		COLORREF crPre = ::SetTextColor( p->hDC, GetSysColor(COLOR_WINDOWTEXT) );
		DrawText( p->hDC, pI->m_strText.c_str(), pI->m_strText.length(), &p->rcItem, DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS | DT_NOPREFIX );
		SelectObject( p->hDC, hfPre );
		::SetTextColor( p->hDC, crPre );

		// allow the redraws to happen
		SetRedraw( TRUE );
	}

	VOID SetItemState( INT iIndex, ItemState eState, BOOL bRedraw = TRUE )
	{
		// get the CProgressItem and set the state
		CProgressItem* pI = GetProgressItem( iIndex );
		if( pI )
		{
			pI->m_eState = eState;
		}

		if( bRedraw )
		{
			SendMessage( LVM_REDRAWITEMS, iIndex, iIndex );
			UpdateWindow();
		}
	}

	VOID ToggleActive( INT iIndex, BOOL bRedraw = TRUE )
	{
		// get the CProgress Item and toggle it's 'active' flag
		CProgressItem* pI = GetProgressItem( iIndex );
		if( pI )
		{
			pI->m_bActive = !pI->m_bActive;
		}

		if( bRedraw )
		{
			SendMessage( LVM_REDRAWITEMS, iIndex, iIndex );
			UpdateWindow();
		}
	}

	CProgressItem* GetProgressItem( INT iIndex )
	{
		LVITEM lvI;
        ZeroMemory( &lvI, sizeof(lvI) );
		lvI.mask = LVIF_PARAM;
		lvI.iItem = iIndex;
		if( !SendMessage(LVM_GETITEM, 0, (LPARAM)&lvI) )
		{
			return NULL;
		}
		return (CProgressItem*)lvI.lParam;
	}

	CProgressList() :
		m_hfText(NULL),
		m_hfBoldText(NULL),
		m_hfSymbol(NULL),
		m_hfLargeSymbol(NULL)
	{
	}    

	~CProgressList()
	{
		if( m_hfText )          DeleteObject( m_hfText );
		if( m_hfBoldText )      DeleteObject( m_hfBoldText );
		if( m_hfSymbol )        DeleteObject( m_hfSymbol );
		if( m_hfLargeSymbol )   DeleteObject( m_hfLargeSymbol );

		EmptyList();
	}

	VOID EmptyList( VOID )
	{
		// cleanup the progress list items
		for( list<CProgressItem*>::iterator it = m_lItems.begin(); it != m_lItems.end(); ++it )
		{
			delete (*it);
		}
		m_lItems.clear();
	}

	BOOL DeleteAllItems( VOID )
	{
		EmptyList();
		return BC::DeleteAllItems();
	}


	private:

//-----------------------------------------------------------------------------
// variables
//-----------------------------------------------------------------------------
	public:

	private:

	HFONT	m_hfText;
	HFONT	m_hfBoldText;
	HFONT	m_hfSymbol;
	HFONT	m_hfLargeSymbol;

	list< CProgressItem* >	m_lItems;

};	// class CProgressList

#endif	// _PROGLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\inc\propuid.h ===
#ifndef _PROPUID_H
#define _PROPUID_H

// User Properties
#define PROP_USER_CN                        L"5496EF6F-1F9A-4f7b-A724-E9485D55C7CC"
#define PROP_USERNAME_GUID_STRING           L"B06F0849-1F92-4350-B09A-BE08D2DC3679"
#define PROP_USEROU_GUID_STRING             L"05AEA5BD-FD98-47e9-AEB2-71D7875451B2"
#define PROP_PASSWD_GUID_STRING             L"40BA3A1F-D018-4b71-BBDC-67CF7827EC77"
#define PROP_ACCOUNT_OPT_GUID_STRING        L"4A27CA65-F2B7-4334-A019-99D8906EDD79"
#define PROP_USERNAME_PRE2K_GUID_STRING     L"8560DB97-CE90-47ef-AD49-2FCB81447F68"
#define PROP_FIRSTNAME_GUID_STRING          L"401BFD91-FB70-426a-ABE2-CA7C2143BC5D"
#define PROP_LASTNAME_GUID_STRING           L"6E225CA1-DD8A-4120-8911-38B3F060C405"
#define PROP_TELEPHONE_GUID_STRING          L"8A7E6D8B-3D99-4925-B304-BB1EC1B69FBB"
#define PROP_OFFICE_GUID_STRING             L"E5F1ED40-18F9-4208-8621-FFB7423DB183"
#define PROP_DESCRIPTION_GUID_STRING        L"67CDC8A8-FDB9-4aed-B32D-12F3FAA40620"
#define PROP_LOGON_DNS                      L"9CA7B552-7F60-4ee8-A88D-F5D2E931CEFF"

// Wizard mode properties
#define PROP_AUTOCOMPLETE_MODE              L"9B3029CA-0941-476e-8C1A-F99B43863B46"

// Exchange Properties
#define PROP_EX_CREATE_MB_GUID_STRING       L"A2FC5DEA-790C-4af5-B608-416FB209F8A9"
#define PROP_EX_ALIAS_GUID_STRING           L"5D85C110-9994-48d8-8F42-8673650EB4C9"
#define PROP_EX_SERVER_GUID_STRING          L"E04B6007-417B-4c20-AFF9-25F899E3125E"
#define PROP_EX_HOMESERVER_GUID_STRING      L"1233EB70-C74F-4833-90EF-8A8C1A19756D"
#define PROP_EX_HOME_MDB_GUID_STRING        L"C43DF1F7-EE86-42e1-8C5F-1DD573D74A87"

// POP3 Properties
#define PROP_POP3_CREATE_MB_GUID_STRING     L"9C36034D-76CB-4204-894D-E84D9AAB2F7E"
#define PROP_POP3_INSTALLED_GUID_STRING     L"DD03FF9E-7FCA-4043-976E-09E13BD9718B"
#define PROP_POP3_VALID_GUID_STRING         L"0F2214B5-12F4-4660-83AB-4DBE211FEEC9"

// Error Properties
#define PROP_ACCNT_ERROR_CODE_GUID_STRING   L"3206D28C-B77A-48b8-B1EC-C2A106CA6940"
#define PROP_ACCNT_ERROR_STR_GUID_STRING    L"C05F2BB3-D926-4f53-A1DC-D22A208140CD"

#endif //_PROPUID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\inc\txttohtm.h ===
//-----------------------------------------------------------------------------
// txttohtm.h
//-----------------------------------------------------------------------------

#ifndef _TXTTOHTM_H
#define _TXTTOHTM_H

#define PRE_TAG         _T("<pre>")
#define PRE_ENDTAG      _T("</pre>")


inline HRESULT FinishTextToHTML(LPCTSTR szFinishText, LPTSTR * pszHtmlText)
{
    if (!szFinishText || !pszHtmlText)
    {
        return E_POINTER;
    }

    HRESULT hr = S_OK;

    *pszHtmlText = new TCHAR[_tcslen(szFinishText) + _tcslen(PRE_TAG) + _tcslen(PRE_ENDTAG) + 1];

    if (*pszHtmlText)
    {
        _tcscpy(*pszHtmlText, PRE_TAG);
        _tcscat(*pszHtmlText, szFinishText);
        _tcscat(*pszHtmlText, PRE_ENDTAG);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

#endif	// _TXTTOHTM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\inc\proputil.h ===
#ifndef _PROPUTIL_H
#define _PROPUTIL_H

#ifndef __wizchain_h__
#include "wizchain.h"
#endif

// delete
inline HRESULT DeleteProperty (IPropertyPagePropertyBag * pPPPBag, LPOLESTR szGUID)
{
    USES_CONVERSION;
    if( !pPPPBag || !szGUID ) return E_POINTER;

    HRESULT hr = S_OK;
    BSTR szGuid = SysAllocString (szGUID);
    if (!szGuid)
        hr = E_OUTOFMEMORY;
    else {
        VARIANT var;
        VariantInit (&var);
        hr = pPPPBag->SetProperty (szGuid, &var, PPPBAG_TYPE_DELETION);
        SysFreeString (szGuid);
    }
    return hr;
}

// readers
inline HRESULT ReadInt4 (IPropertyPagePropertyBag * pPPPBag, LPOLESTR szGUID, long * pl, BOOL * pbReadOnly)
{
    USES_CONVERSION;
    if( !pPPPBag || !szGUID || !pl || !pbReadOnly )  return E_POINTER;

    *pbReadOnly = FALSE;  // default

    HRESULT hr = S_OK;
    BSTR szGuid = SysAllocString (szGUID);
    if (!szGuid)
        hr = E_OUTOFMEMORY;
    else {
        VARIANT var;
        VariantInit (&var);
        PPPBAG_TYPE dwFlags = PPPBAG_TYPE_UNINITIALIZED;
        BOOL  bIsOwner = FALSE;
        hr = pPPPBag->GetProperty (szGuid, &var, &dwFlags, &bIsOwner);
        if (hr == S_OK) {
            *pbReadOnly = FALSE;
            if (dwFlags == PPPBAG_TYPE_READONLY)
                if (bIsOwner == FALSE)
                    *pbReadOnly = TRUE;

            if (V_VT(&var) == VT_I4)    // make sure variant is a i4
                *pl = V_I4(&var);
            else
            if (V_VT(&var) == VT_I2)    // VBScript uses i2
                *pl = V_I2(&var);
            else
                hr = E_UNEXPECTED;

            VariantClear (&var);
        }
        SysFreeString (szGuid);
    }
    return hr;
}

inline HRESULT ReadString (IPropertyPagePropertyBag * pPPPBag, LPOLESTR szGUID, CString& str, BOOL * pbReadOnly)
{
    USES_CONVERSION;
    if( !pPPPBag || !szGUID || !pbReadOnly ) return E_POINTER;

    *pbReadOnly = FALSE;  // default

    HRESULT hr = S_OK;
    BSTR szGuid = SysAllocString (szGUID);
    if (!szGuid)
        hr = E_OUTOFMEMORY;
    else {
        VARIANT var;
        VariantInit (&var);
        PPPBAG_TYPE dwFlags = PPPBAG_TYPE_UNINITIALIZED;
        BOOL  bIsOwner = FALSE;
        hr = pPPPBag->GetProperty (szGuid, &var, &dwFlags, &bIsOwner);
        if (hr == S_OK) {
            if (V_VT(&var) != VT_BSTR)    // make sure variant is a bstr
                hr = E_UNEXPECTED;
            else {
                *pbReadOnly = FALSE;
                if (dwFlags == PPPBAG_TYPE_READONLY)
                    if (bIsOwner == FALSE)
                        *pbReadOnly = TRUE;
                str = V_BSTR(&var);
            }
            VariantClear (&var);
        }
        SysFreeString (szGuid);
    }
    return hr;
}

inline HRESULT ReadBool (IPropertyPagePropertyBag * pPPPBag, LPOLESTR szGUID, BOOL * pb, BOOL * pbReadOnly)
{
    USES_CONVERSION;
    if( !pPPPBag || !szGUID || !pb || !pbReadOnly) return E_POINTER;

    *pbReadOnly = FALSE;  // defaults

    HRESULT hr = S_OK;
    BSTR szGuid = SysAllocString (szGUID);
    if ( NULL == szGuid )
        hr = E_OUTOFMEMORY;
    else {
        VARIANT var;
        VariantInit (&var);
        PPPBAG_TYPE dwFlags = PPPBAG_TYPE_UNINITIALIZED;
        BOOL  bIsOwner = FALSE;
        hr = pPPPBag->GetProperty (szGuid, &var, &dwFlags, &bIsOwner);
        if ( S_OK == hr ) {
            if ( VT_BOOL != V_VT( &var ))  // make sure variant is a bool
                hr = E_INVALIDARG;
            else {
                *pbReadOnly = FALSE;
                if ( PPPBAG_TYPE_READONLY == dwFlags )
                    if ( FALSE == bIsOwner )
                        *pbReadOnly = TRUE;
                if ( VARIANT_FALSE == V_BOOL( &var ))
                    *pb = FALSE;
                else
                    *pb = TRUE;
            }
            VariantClear (&var);
        }
        SysFreeString (szGuid);
    }
    return hr;
}

inline HRESULT ReadSafeArray (IPropertyPagePropertyBag * pPPPBag, LPOLESTR szGUID, SAFEARRAY ** ppSA, BOOL * pbReadOnly)
{
    USES_CONVERSION;
    if( !pPPPBag || !szGUID || !ppSA || !pbReadOnly ) return E_POINTER;

    *ppSA = NULL;
    *pbReadOnly = FALSE;  // defaults

    HRESULT hr = S_OK;
    BSTR szGuid = SysAllocString (szGUID);
    if (!szGuid)
        hr = E_OUTOFMEMORY;
    else {
        VARIANT var;
        VariantInit (&var);
        PPPBAG_TYPE dwFlags = PPPBAG_TYPE_UNINITIALIZED;
        BOOL  bIsOwner = FALSE;
        hr = pPPPBag->GetProperty (szGuid, &var, &dwFlags, &bIsOwner);
        if (hr == S_OK) {
            if (!(V_VT(&var) & VT_ARRAY))// make sure variant is a safearray
                hr = E_UNEXPECTED;
            else {
                *pbReadOnly = FALSE;
                if (dwFlags == PPPBAG_TYPE_READONLY)
                    if (bIsOwner == FALSE)
                        *pbReadOnly = TRUE;

                if (V_VT(&var) & VT_BYREF)   // VBScript does stuff byref
                   hr = SafeArrayCopy (*V_ARRAYREF(&var), ppSA);
                else
                   hr = SafeArrayCopy (V_ARRAY(&var), ppSA);
            }
            VariantClear (&var);
        }
        SysFreeString (szGuid);
    }
    return hr;
}

inline HRESULT ReadVariant (IPropertyPagePropertyBag * pPPPBag, LPOLESTR szGUID, VARIANT& var, BOOL * pbReadOnly)
{
    USES_CONVERSION;
    if( !pPPPBag || !szGUID || !pbReadOnly ) return E_POINTER;

    *pbReadOnly = FALSE;  // default

    HRESULT hr = S_OK;
    BSTR szGuid = SysAllocString (szGUID);
    if (!szGuid)
        hr = E_OUTOFMEMORY;
    else {
        VariantInit (&var);
        PPPBAG_TYPE dwFlags = PPPBAG_TYPE_UNINITIALIZED;
        BOOL  bIsOwner = FALSE;
        hr = pPPPBag->GetProperty (szGuid, &var, &dwFlags, &bIsOwner);
        if (hr == S_OK) {
            *pbReadOnly = FALSE;
            if (dwFlags == PPPBAG_TYPE_READONLY)
                if (bIsOwner == FALSE)
                    *pbReadOnly = TRUE;
        }
        SysFreeString (szGuid);
    }
    return hr;
}

// writers
inline HRESULT WriteInt4 (IPropertyPagePropertyBag * pPPPBag, LPOLESTR szGUID, long l, BOOL bReadOnly)
{
    USES_CONVERSION;
    if( !pPPPBag || !szGUID ) return E_POINTER;

    HRESULT hr = S_OK;
    BSTR szGuid = SysAllocString (szGUID);
    if (!szGuid)
        hr = E_OUTOFMEMORY;
    else {
        VARIANT var;
        VariantInit (&var);
        V_VT(&var) = VT_I4;
        V_INT(&var) = l;    // signed int (I4, I hope)
        hr = pPPPBag->SetProperty (szGuid, &var, bReadOnly == FALSE ? PPPBAG_TYPE_READWRITE : PPPBAG_TYPE_READONLY);
        VariantClear (&var);

        SysFreeString (szGuid);
    }
    return hr;
}

inline HRESULT WriteString (IPropertyPagePropertyBag * pPPPBag, LPOLESTR szGUID, CString& str, BOOL bReadOnly)
{
    USES_CONVERSION;
    if( !pPPPBag || !szGUID ) return E_POINTER;    

    HRESULT hr = S_OK;
    BSTR szGuid = SysAllocString (szGUID);
    if (!szGuid)
        hr = E_OUTOFMEMORY;
    else {
        BSTR bstr = SysAllocString (T2BSTR(str));
        if (!bstr)
            hr = E_OUTOFMEMORY;
        else {
            VARIANT var;
            VariantInit (&var);
            V_VT(&var) = VT_BSTR;
            V_BSTR(&var) = bstr;
            hr = pPPPBag->SetProperty (szGuid, &var, bReadOnly == FALSE ? PPPBAG_TYPE_READWRITE : PPPBAG_TYPE_READONLY);
            VariantClear (&var);
            // the line above frees the bstr.
        }
        SysFreeString (szGuid);
    }
    return hr;
}

inline HRESULT WriteBool (IPropertyPagePropertyBag * pPPPBag, LPOLESTR szGUID, BOOL b, BOOL bReadOnly)
{
    USES_CONVERSION;
    if( !pPPPBag || !szGUID ) return E_POINTER;

    HRESULT hr = S_OK;
    BSTR szGuid = SysAllocString (szGUID);
    if (!szGuid)
        hr = E_OUTOFMEMORY;
    else {
        VARIANT var;
        VariantInit (&var);
        V_VT(&var) = VT_BOOL;
        V_BOOL(&var) = b == FALSE ? VARIANT_FALSE : VARIANT_TRUE;
        hr = pPPPBag->SetProperty (szGuid, &var, bReadOnly == FALSE ? PPPBAG_TYPE_READWRITE : PPPBAG_TYPE_READONLY);
        VariantClear (&var);

        SysFreeString (szGuid);
    }
    return hr;
}

inline HRESULT WriteSafeArray (IPropertyPagePropertyBag * pPPPBag, LPOLESTR szGUID, SAFEARRAY * pSA, BOOL bReadOnly)
{
    USES_CONVERSION;
    if( !pPPPBag || !szGUID || !pSA ) return E_POINTER;

    HRESULT hr = S_OK;
    BSTR szGuid = SysAllocString (szGUID);
    if (!szGuid)
        hr = E_OUTOFMEMORY;
    else {
        VARIANT var;
        VariantInit (&var);
        V_VT(&var) = VT_ARRAY | VT_VARIANT;
        SAFEARRAY * pSACopy = NULL;
        hr = SafeArrayCopy (pSA, &pSACopy);
        if (pSACopy) {
            V_ARRAY(&var) = pSACopy;
            hr = pPPPBag->SetProperty (szGuid, &var, bReadOnly == FALSE ? PPPBAG_TYPE_READWRITE : PPPBAG_TYPE_READONLY);
            // DON'T call VariantClear!
        }
        SysFreeString (szGuid);
    }
    return hr;
}

inline HRESULT WriteVariant (IPropertyPagePropertyBag * pPPPBag, LPOLESTR szGUID, VARIANT var, BOOL bReadOnly)
{
    USES_CONVERSION;
    if( !pPPPBag || !szGUID ) return E_POINTER;

    HRESULT hr = S_OK;
    BSTR szGuid = SysAllocString (szGUID);
    if (!szGuid)
        hr = E_OUTOFMEMORY;
    else {
        hr = pPPPBag->SetProperty (szGuid, &var, bReadOnly == FALSE ? PPPBAG_TYPE_READWRITE : PPPBAG_TYPE_READONLY);
        SysFreeString (szGuid);
    }
    return hr;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\inc\tmpledit.h ===
#ifndef __tmplEdit_h
#define __tmplEdit_h

#include <imm.h>

/////////////////////////////////////////////////////////////////////////////
// CWindowImplNoImm 
// Purpose - Meant to prevent entry of DBCS characters into an edit box by 
//           disabling IME 
//
// Usage   - CWindowImplNoImm<> m_NoImmEditWindow1;
//           CDialog::OnInitDialog(..) 
//           {
//              ...
//              m_NoImmEditWindow1.SubClassWindow( GetDlgItem( IDC_NOIMMEDITWINDOW1 ));
//              ...
//           }

template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplNoImm : public CWindowImpl< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoImm)
    END_MSG_MAP()

	BOOL SubclassWindow(HWND hWnd)
	{
        if( !hWnd ) 
            return FALSE;

		BOOL bRC = CWindowImpl< T, TBase, TWinTraits >::SubclassWindow( hWnd );
		if ( bRC )
			ImmAssociateContext( hWnd, NULL );
        return bRC;
	}

    void LTrim()
    {
        LPTSTR  psBuffer;
        unsigned int i = 0;
        DWORD   dwSize;
        
        dwSize = ::GetWindowTextLength( m_hWnd );
        if ( 0 < dwSize )
        {
            dwSize++;
            psBuffer = new TCHAR[dwSize];
            ::GetWindowText( m_hWnd , psBuffer, dwSize );
            while ( i < dwSize && 32 == psBuffer[i] )
                i++;
            if ( 0 < i )
                ::SetWindowText( m_hWnd, psBuffer + i );
            delete [] psBuffer;
        }
    }
    void RTrim()
    {
        LPTSTR  psBuffer;
        unsigned int i = 0;
        DWORD   dwSize;
        
        dwSize = ::GetWindowTextLength( m_hWnd );
        if ( 0 < dwSize )
        {
            i = dwSize;
            dwSize++;
            psBuffer = new TCHAR[dwSize];
            ::GetWindowText( m_hWnd , psBuffer, dwSize );
            while ( 0 < i && ( 32 == psBuffer[i] || 0 == psBuffer[i] ))
            {
                psBuffer[i] = 0;
                i--;
            }
            if ( i < dwSize - 1 )
                ::SetWindowText( m_hWnd, psBuffer );
            delete [] psBuffer;
        }
    }
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplNoPaste 
// Purpose - Meant to prevent entry of DBCS characters into an edit box by 
//           disabling IME and not allowing any pasting of charaters
//
// Usage   - CWindowImplNoPaste<> m_NoPasteEditWindow1;
//           CDialog::OnInitDialog(..) 
//           {
//              ...
//              m_NoPasteEditWindow1.SubClassWindow( GetDlgItem( IDC_NOPASTEEDITWINDOW1 ));
//              ...
//           }

template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplNoPaste : public CWindowImpl< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoPaste)
        MESSAGE_HANDLER( WM_PASTE, OnPaste )
    END_MSG_MAP()

	LRESULT OnPaste( UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/ )
	{
		MessageBeep( MB_ICONEXCLAMATION );
		return 0;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplNoCopy 
// Purpose - Meant to prevent entry of DBCS characters into an edit box by 
//           disabling IME and not allowing any pasting of charaters
//
// Usage   - CWindowImplNoCopy<> m_NoCopyEditWindow1;
//           CDialog::OnInitDialog(..) 
//           {
//              ...
//              m_NoCopyEditWindow1.SubClassWindow( GetDlgItem( IDC_NOCOPYEDITWINDOW1 ));
//              ...
//           }

template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplNoCopy : public CWindowImpl< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoCopy)
        MESSAGE_HANDLER( WM_COPY, OnCopy )
    END_MSG_MAP()

	LRESULT OnCopy( UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/ )
	{
		MessageBeep( MB_ICONEXCLAMATION );
		return 0;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplPhoneNumber 
// Purpose - Meant to allow entry of only telephone number related characters
//
// Usage   - CWindowImplPhoneNumber<> m_PhoneNumberEditWindow1;
//           CDialog::OnInitDialog(..) 
//           {
//              ...
//              m_PhoneNumberEditWindow1.SubClassWindow( GetDlgItem( IDC_PHONENOEDITWINDOW1 ));
//              ...
//           }

template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplPhoneNumber : public CWindowImpl< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplPhoneNumber)
        MESSAGE_HANDLER( WM_CHAR, OnChar )
    END_MSG_MAP()

	LRESULT OnChar( UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled )
	{
        int i = GetKeyState( VK_CONTROL );

        if ( !(( _T( '0' ) <= wParam &&  _T( '9' ) >= wParam ) || _T( ' ' ) == wParam || _T( '-' ) == wParam || _T( ',' ) == wParam
              || VK_BACK == wParam || VK_SPACE == wParam || VK_DELETE == wParam || VK_INSERT == wParam )
              && 0 == HIWORD( i ))
        {
            MessageBeep( static_cast<unsigned int>(-1) );
            return TRUE;
        }

        bHandled = FALSE;
		return FALSE;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplFileChar 
// Purpose - Meant to allow entry of any characters except those specifically disallowed for files
//
// Usage   - CWindowImplFileChar<> m_FileNameEditWindow1;
//           CDialog::OnInitDialog(..) 
//           {
//              ...
//              m_FileNameEditWindow1.SubClassWindow( GetDlgItem( IDC_FILENAMEEDITWINDOW1 ));
//              ...
//           }

template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplFileChar : public CWindowImpl< T, TBase, TWinTraits >
{
public:

    CWindowImplFileChar() : m_isWildCardsAllowed( false ),
                            m_isFullPathAllowed( false )
    {}

    BEGIN_MSG_MAP(CWindowImplFileChar)
        MESSAGE_HANDLER( WM_CHAR, OnChar )
    END_MSG_MAP()

	LRESULT OnChar( UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled )
	{
        TCHAR sCharList[] = { _T('/'), _T('"'), _T('<'), _T('>'), _T('|'), 0, 0, 0, 0, 0};

        if (! m_isWildCardsAllowed)
        {
            sCharList[_tcslen(sCharList)] = _T('*');
            sCharList[_tcslen(sCharList)] = _T('?');
        }

        if (! m_isFullPathAllowed)
        {
            sCharList[_tcslen(sCharList)] = _T('\\');
            sCharList[_tcslen(sCharList)] = _T(':');
        }

        int i = GetKeyState( VK_CONTROL );

        if ( (NULL != _tcschr(sCharList, static_cast<TCHAR>(wParam))) && (0 == HIWORD(i)) )
        {
            MessageBeep( static_cast<unsigned int>(-1) );
            return TRUE;
        }

        bHandled = FALSE;
		return FALSE;
	}

public:
// Attributes:
    bool m_isWildCardsAllowed;
    bool m_isFullPathAllowed;
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplASCII 
// Purpose - Meant to allow entry of only ASCII characters (a-z, A-Z, 0-9, space)
//
// Usage   - CWindowImplASCII<> m_ASCIIEditWindow1;
//           CDialog::OnInitDialog(..) 
//           {
//              ...
//              m_ASCIIEditWindow1.SubClassWindow( GetDlgItem( IDC_ASCIIEDITWINDOW1 ));
//              ...
//           }

template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplASCII : public CWindowImpl< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplASCII)
        MESSAGE_HANDLER( WM_CHAR, OnChar )
    END_MSG_MAP()

	LRESULT OnChar( UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled )
	{
        int i = GetKeyState( VK_CONTROL );

        if ( !(( 32 <= wParam && 126 >= wParam )
              || VK_BACK == wParam )
              && 0 == HIWORD( i ))
        {
            MessageBeep( static_cast<unsigned int>(-1) );
            return TRUE;
        }

        bHandled = FALSE;
		return FALSE;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplNoImmPaste = CWindowImplNoImm + CWindowImplNoPaste 
template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplNoImmPaste : public CWindowImplNoImm< T, TBase, TWinTraits >, public CWindowImplNoPaste< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoPaste)
		if(CWindowImplNoPaste< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
    END_MSG_MAP()

	BOOL SubclassWindow(HWND hWnd)
	{
        if( !hWnd )
            return FALSE;

        return CWindowImplNoImm< T, TBase, TWinTraits >::SubclassWindow(hWnd);
    }
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplNoImmPN = CWindowImplNoImm + CWindowImplPhoneNumber
template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplNoImmPN : public CWindowImplNoImm< T, TBase, TWinTraits >, public CWindowImplPhoneNumber< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoImmPastePN)
		if(CWindowImplPhoneNumber< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
    END_MSG_MAP()

	BOOL SubclassWindow(HWND hWnd)
	{
        if( !hWnd )
            return FALSE;

        return CWindowImplNoImm< T, TBase, TWinTraits >::SubclassWindow(hWnd);
    }
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplNoImmPasteASCII = CWindowImplNoImm + CWindowImplNoPaste + CWindowImplASCII
template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplNoImmPasteASCII : public CWindowImplNoImm< T, TBase, TWinTraits >, public CWindowImplNoPaste< T, TBase, TWinTraits >, public CWindowImplASCII< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoPasteASCII)
		if(CWindowImplNoPaste< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
		if(CWindowImplASCII< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
    END_MSG_MAP()

	BOOL SubclassWindow(HWND hWnd)
	{
        if( !hWnd )
            return FALSE;

        return CWindowImplNoImm< T, TBase, TWinTraits >::SubclassWindow(hWnd);
    }
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplNoImmASCII = CWindowImplNoImm + CWindowImplASCII
template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplNoImmASCII : public CWindowImplNoImm< T, TBase, TWinTraits >, public CWindowImplASCII< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoPasteASCII)
		if(CWindowImplASCII< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
    END_MSG_MAP()

	BOOL SubclassWindow(HWND hWnd)
	{
        if( !hWnd )
            return FALSE;

        return CWindowImplNoImm< T, TBase, TWinTraits >::SubclassWindow(hWnd);
    }
};

//-----------------------------------------------------------------------------
// CWindowImplComputerName = CWindowImplNoImm + CWindowImplNoPaste + computer name
//	character checking
//-----------------------------------------------------------------------------
template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplComputerName : public CWindowImplNoImm< T, TBase, TWinTraits >,
								public CWindowImplNoPaste< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoPaste)
		MESSAGE_HANDLER(WM_CHAR, OnChar)
		MESSAGE_HANDLER(WM_GETDLGCODE, OnDlgCode)
		if(CWindowImplNoPaste< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
    END_MSG_MAP()

	CWindowImplComputerName() :
		m_hWndButton(NULL),
		m_hWndEdit(NULL)
	{
	}

	VOID SetHandles( HWND hWndButton, HWND hWndEdit )
	{
		m_hWndButton = hWndButton;
		m_hWndEdit = hWndEdit;
	}

	BOOL SubclassWindow(HWND hWnd)
	{
        if( !hWnd )
            return FALSE;

        return CWindowImplNoImm< T, TBase, TWinTraits >::SubclassWindow(hWnd);
    }

	LRESULT OnChar( UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled )
	{
		if( (wParam >= _T('a') && wParam <= _T('z')) ||
			(wParam >= _T('A') && wParam <= _T('Z')) ||
			(wParam >= _T('0') && wParam <= _T('9')) ||
			(wParam == _T('-')) ||
			(wParam == VK_BACK) )
		{
		}
		else if( wParam == VK_RETURN )
		{
			::SendMessage( m_hWndButton, BM_CLICK, 0, 0 );
			bHandled = TRUE;
			return FALSE;
		}
		else
		{
            MessageBeep( static_cast<unsigned int>(-1) );
            return TRUE;
        }

        bHandled = FALSE;
		return FALSE;
	}

	LRESULT OnDlgCode( UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
	{
		if( m_hWndEdit )
		{
			MSG* pMsg = (MSG*)lParam;
			if( pMsg )
			{
				if( (pMsg->message == WM_KEYDOWN) &&
					(LOWORD(pMsg->wParam) == VK_RETURN) )
				{
					// only take it if we have text
					if( ::SendMessage(m_hWndEdit, WM_GETTEXTLENGTH, 0, 0) )
					{
						bHandled = TRUE;
						return DLGC_WANTALLKEYS;
					}
				}
			}
		}

		bHandled = FALSE;
		return 0;
	}

	HWND	m_hWndButton;
	HWND	m_hWndEdit;

};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplAlias = CWindowImplNoImm + Alias ASCII checking 
template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplAlias : public CWindowImplNoImm< T, TBase, TWinTraits >,  public CWindowImplNoPaste< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoPaste)
		MESSAGE_HANDLER(WM_CHAR, OnChar)
		if(CWindowImplNoPaste< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
    END_MSG_MAP()

	BOOL SubclassWindow(HWND hWnd)
	{
        if( !hWnd )
            return FALSE;

        return CWindowImplNoImm< T, TBase, TWinTraits >::SubclassWindow(hWnd);
    }

	LRESULT OnChar( UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled )
	{
		if ( (wParam >= 35  && wParam <= 39)  ||
             (wParam >= 42  && wParam <= 43)  ||
             (wParam >= 45  && wParam <= 57)  ||
             (wParam >= 63  && wParam <= 90)  ||
             (wParam >= 94  && wParam <= 126) ||
             (wParam == 33)                   ||
             (wParam == 61)                   ||
             (wParam == 92)                   ||
             (wParam == 0x08)                    )  // Backspace!
        {
        }
        else
		{
            MessageBeep( static_cast<unsigned int>(-1) );
            return TRUE;
        }

        bHandled = FALSE;
		return FALSE;
	}

};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplPassword = CWindowImplNoImm + CWindowImplNoCopy + CWindowImplASCII
template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplPassword : public CWindowImplNoImm< T, TBase, TWinTraits >, public CWindowImplNoCopy< T, TBase, TWinTraits >, public CWindowImplASCII< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplPassword)
		if(CWindowImplNoCopy< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
		if(CWindowImplASCII< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
    END_MSG_MAP()

	BOOL SubclassWindow(HWND hWnd)
	{
        if( !hWnd )
            return FALSE;

        return CWindowImplNoImm< T, TBase, TWinTraits >::SubclassWindow(hWnd);
    }
};


//-----------------------------------------------------------------------------
// CWindowImplDiskSpace = CWindowImplNoImm + CWindowImplNoPaste + disk space
//	character checking
//-----------------------------------------------------------------------------
template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplDiskSpace : public CWindowImplNoImm< T, TBase, TWinTraits >,
								public CWindowImplNoPaste< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoPaste)
		MESSAGE_HANDLER(WM_CHAR, OnChar)
		if(CWindowImplNoPaste< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
    END_MSG_MAP()

	BOOL SubclassWindow(HWND hWnd)
	{
        if( !hWnd )
            return FALSE;

        return CWindowImplNoImm< T, TBase, TWinTraits >::SubclassWindow(hWnd);
    }

	LRESULT OnChar( UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled )
	{
		if( !_istdigit((INT)wParam) &&
			(wParam != _T('.')) &&
			(wParam != VK_BACK) )
		{
            MessageBeep( static_cast<unsigned int>(-1) );
            return TRUE;
		}

        bHandled = FALSE;
		return FALSE;
	}

};

#endif // #ifndef __tmplEdit.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\inc\singleinst.h ===
//-----------------------------------------------------------------------------
// SingleInst.h
//-----------------------------------------------------------------------------

#ifndef _SINGLEINST_H
#define _SINGLEINST_H  

class CSingleInstance
{
public:

	CSingleInstance( LPTSTR strID ) :
		m_hFileMap(NULL),
		m_pdwID(NULL),
		m_strID(NULL)
	{
        if ( NULL != strID )
        {
            m_strID = new TCHAR[ _tcslen( strID ) + 1 ];
            if ( NULL != m_strID )
                _tcscpy( m_strID, strID );
        }
	}

	~CSingleInstance()
	{
		// if we have PID we're mapped
		if( m_pdwID )
		{
			UnmapViewOfFile( m_pdwID );
			m_pdwID = NULL;
		}

		// if we have a handle close it
		if( m_hFileMap )
		{
			CloseHandle( m_hFileMap );
			m_hFileMap = NULL;
		}
        if ( NULL != m_strID )
        {
            delete [] m_strID;
            m_strID = NULL;
        }
	}

	static BOOL CALLBACK enumProc( HWND hWnd, LPARAM lParam )
	{
		DWORD dwID = 0;
		GetWindowThreadProcessId( hWnd, &dwID );
		
// JeffZi - 13800: when the tooltips_class32 was being created after the welcome page of the wizards,
//					it was being returned as the first window for this PID.  so, make sure this window
//					has children before setting focus
		if( (dwID == (DWORD)lParam) &&
			GetWindow(hWnd, GW_CHILD) )
		{
			SetForegroundWindow( hWnd );
			SetFocus( hWnd );
			return FALSE;
		}
		return TRUE;
	}

	BOOL IsOpen( VOID )
	{
        return !(Open());
    }

private:

	BOOL Open( VOID )
	{
        BOOL bRC = FALSE;

        m_hFileMap = CreateFileMapping( (HANDLE)-1, NULL, PAGE_READWRITE, 0, sizeof(DWORD), m_strID );
        if( NULL != m_hFileMap )
        {
            if ( ERROR_ALREADY_EXISTS == GetLastError())
            {
                // get the pid and bring the other window to the front
                DWORD* pdwID = static_cast<DWORD *>( MapViewOfFile( m_hFileMap, FILE_MAP_READ, 0, 0, sizeof(DWORD) ) );
                if( pdwID )
                {
                    DWORD dwID = *pdwID;
                    UnmapViewOfFile( pdwID );
                    EnumWindows( enumProc, (LPARAM)dwID );
                }
                CloseHandle( m_hFileMap );
                m_hFileMap = NULL;
            }
            else
            {
                m_pdwID = static_cast<DWORD *>( MapViewOfFile( m_hFileMap, FILE_MAP_WRITE, 0, 0, sizeof(DWORD) ) );
                if ( NULL != m_pdwID )
                {
                    *m_pdwID = GetCurrentProcessId();
                    bRC = TRUE;
                }
            }
        }
		
		return bRC;
	}

private:

	LPTSTR	m_strID;
	HANDLE	m_hFileMap;
	DWORD*	m_pdwID;

};	// class CSingleInstance

#endif  // _SINGLEINST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\inc\tmplrichedit.h ===
#ifndef __tmplrEdit_h
#define __tmplrEdit_h

#include <atlctrls.h>
#include <winuser.h>

/////////////////////////////////////////////////////////////////////////////
// CWindowImplHotlinkRichEdit 
// Purpose - To display a hyperlink control (like Syslink in Whistler) using a rich edit ctrl
//
// Usage   - CWindowImplHotlinkRichEdit<> m_Hotlink;
//           CDialog::OnInitDialog(..) 
//           {
//              ...
//              m_Hotlink.SubClassWindow( GetDlgItem( IDC_RICHEDIT1 ));
//              ::SendMessage   (
//                                  GetDlgItem(IDC_RICHEDIT1), WM_SETTEXT, 0 ,
//                                  (LPARAM) _T("Click <A>here</A> to do something")
//                              );
//              ...
//           }


#define LINKSTARTTAG    _T("<A>")
#define LINKENDTAG      _T("</A>")

template <class T = CRichEditCtrl, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplHotlinkRichEdit : public CWindowImpl< T, TBase, TWinTraits >
{

private:

    
    int m_iLinkIndex;
    RECT m_rect;
    BOOL m_bHasFocus;
    
  
public:


    CWindowImplHotlinkRichEdit() : m_iLinkIndex(-1), m_bHasFocus(FALSE)
    {
        ZeroMemory(&m_rect, sizeof(m_rect));
                
    }



    BEGIN_MSG_MAP(CWindowImplHotlinkRichEdit)
        MESSAGE_HANDLER(WM_SETFOCUS, OnFocus)
        MESSAGE_HANDLER(WM_SETTEXT, OnSetText)
        MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
        MESSAGE_HANDLER(WM_PAINT, OnPaint)
        MESSAGE_HANDLER(WM_CHAR, OnChar)
        MESSAGE_HANDLER(WM_NCHITTEST, OnHitTest) 
        MESSAGE_HANDLER(WM_KEYDOWN, OnKey) 
        MESSAGE_HANDLER(WM_KEYUP, OnKey) 
    END_MSG_MAP()


    HFONT CharFormatToHFont(CHARFORMAT * pcf)
    {
        // Create a font that matches the font specified by pcf

        HFONT hFont = NULL;
        HDC hDC = GetDC();

        if (pcf)
        {
            LOGFONT lf;

            ZeroMemory(&lf, sizeof(lf));

            lf.lfCharSet =  pcf->bCharSet;
            lf.lfPitchAndFamily = pcf->bPitchAndFamily;

            // yHeight is in twips. 
            
            lf.lfHeight =  -1 * pcf->yHeight / 20.0 * GetDeviceCaps (hDC, LOGPIXELSY) / 72;

            _tcsncpy(lf.lfFaceName, pcf->szFaceName, LF_FACESIZE);
            lf.lfFaceName[LF_FACESIZE-1] = NULL;

            hFont = CreateFontIndirect(&lf);
        }

        if (hDC)
        {
            ReleaseDC(hDC);
        }

        return hFont;
            
    }

    BOOL HFontToCharFormat(HFONT hFont, CHARFORMAT * pcf)
    {
        BOOL bRet = FALSE;

        HDC hDC = GetDC();

        if (hFont)
        {

            LOGFONT lf;

            ZeroMemory(&lf, sizeof(lf));

            if (GetObject(hFont, sizeof(lf), &lf))
            {
                pcf->bCharSet = lf.lfCharSet;
                pcf->bPitchAndFamily =  lf.lfPitchAndFamily;

                // yHeight is in twips

                pcf->yHeight = 20 * lf.lfHeight * 72.0 / GetDeviceCaps (hDC, LOGPIXELSY);


                pcf->yHeight = pcf->yHeight < 0 ? -pcf->yHeight : pcf->yHeight;
                    
                _tcsncpy(pcf->szFaceName, lf.lfFaceName, LF_FACESIZE);
                pcf->szFaceName[LF_FACESIZE-1] = NULL;

                pcf->dwMask |= CFM_CHARSET | CFM_FACE | CFM_SIZE;

                bRet = TRUE;
            }
        }

        if (hDC)
        {
            ReleaseDC(hDC);
        }

        return bRet;
    }

   

	BOOL SubclassWindow(HWND hWnd)
	{
        BOOL bRC = FALSE;

        if (::IsWindow(hWnd))
        {
            bRC = CWindowImpl< T, TBase, TWinTraits >::SubclassWindow( hWnd );

            ::SendMessage(hWnd, EM_SETSEL, -1, 0);
            
        }

		
        return bRC;
	}

    LRESULT OnPaint( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
    {

        DefWindowProc(uMsg, wParam, lParam);

        ::SendMessage(m_hWnd, EM_SETSEL,  -1, 0);

        HideCaret();

        if (m_bHasFocus)
        {
            DrawHotlinkFocusRect();
            
        }

        bHandled = TRUE;
        return 0;
    }

    LRESULT OnKey( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
    {
        if (VK_TAB == wParam || VK_SHIFT == wParam || VK_ESCAPE == wParam)
        {
            return DefWindowProc(uMsg, wParam, lParam);
        }

        bHandled = TRUE;
        
        return 0;
    }

    LRESULT OnChar( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
    {
        if (VK_RETURN == wParam || VK_SPACE == wParam)   // Enter and space when we have the focus...
        {
            HWND hWndParent;

            hWndParent = ::GetParent(m_hWnd);

            if (hWndParent)
            {
                NMHDR nmhdr;
                ENLINK enlink;

                nmhdr.hwndFrom = m_hWnd;
                nmhdr.idFrom = ::GetDlgCtrlID(m_hWnd);
                nmhdr.code = EN_LINK;

                enlink.msg = uMsg;
                enlink.lParam = lParam;
                enlink.wParam = wParam;
                enlink.nmhdr = nmhdr;

                // DO NOT USE PostMessage for the notification, can cause AV
                
                ::SendMessage(hWndParent, WM_NOTIFY, ::GetDlgCtrlID(m_hWnd), (LPARAM) &enlink);
            }
            
        }

        bHandled = TRUE;

        return 0;
    }


    LRESULT OnHitTest( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
    {
        POINTS pts;
        POINT pt;

        pts = MAKEPOINTS(lParam);

        POINTSTOPOINT(pt, pts);

        ::MapWindowPoints(NULL, m_hWnd, &pt, 1);

        if (PtInRect(&m_rect, pt))
        {
           return DefWindowProc(uMsg, wParam, lParam);
        }

        return HTTRANSPARENT;
    }

    LRESULT OnKillFocus( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
    {
        DefWindowProc(uMsg, wParam, lParam);

        if (TRUE == m_bHasFocus)
        {

            DrawHotlinkFocusRect();

            m_bHasFocus = FALSE;
        }


        bHandled = TRUE;

        return 0;
        
    }

    LRESULT OnFocus( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
    {
        // Each time we get WM_SETFOCUS we need to draw focus rect
        // around the link

        DefWindowProc(uMsg, wParam, lParam);

        ::SendMessage(m_hWnd, EM_SETSEL,  -1, 0);

        HideCaret();

        if (FALSE == m_bHasFocus)
        {

            DrawHotlinkFocusRect();

            m_bHasFocus = TRUE;
        }

        bHandled = TRUE;

        return 0;
    }


    LRESULT OnSetText( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
    {
        TCHAR szLink[128];
        TCHAR * szText = reinterpret_cast<LPTSTR> (lParam);
        TCHAR * szActualText = NULL;
        TCHAR * pLinkStart, * pLinkEnd, * pTemp;
        int i,j;

        // When we get WM_SETTEXT message, we will search the text for 
        // the link identified by <A> </A>
        // After identifying the link we will strip off the tags and send the message 
        // to DefWindowProc
        // Ex: "Click <A>here</A> to do something interesting"
        
        if (szText)
        {
            pLinkStart = _tcsstr(szText, LINKSTARTTAG);
            pLinkEnd = _tcsstr(szText, LINKENDTAG);

            // Make sure that we have a link in the text

            if (pLinkStart && pLinkEnd && pLinkStart < pLinkEnd)
            {
                // szActualText will hold the final text without the tags

                szActualText = new TCHAR[_tcslen(szText) + 1];

                if (szActualText)
                {
                    i = j = 0;
                    pTemp = pLinkStart + _tcslen(LINKSTARTTAG); // pTemp = "here</A> to do something interesting"
                
                    while (pTemp < pLinkEnd)
                    {
                        szLink[i++] = *pTemp++; 
                    }

                    szLink[i] = NULL;       // szLink = "here"

                    while(szText < pLinkStart)
                    {
                        szActualText[j++] = *szText++;
                    }
                    szActualText[j] = NULL; // szActualText = "Click"

                    m_iLinkIndex = j;

                    _tcscat(szActualText, szLink); // szActualText = "Click here"

                    pTemp = pLinkEnd + _tcslen(LINKENDTAG);   // pTemp = " to do something interesting"

                    _tcscat(szActualText, pTemp); // szActualText = "Click here to do something interesting"
                }
            }
        }

        bHandled = TRUE;

        if (szActualText)
        {
            HWND hWndParent;
            HFONT hFont;

            CHARFORMAT cf;

            ZeroMemory(&cf, sizeof(cf));

            cf.cbSize = sizeof(cf);

            hWndParent = ::GetParent(m_hWnd);

            if (hWndParent)
            {
                // Stick to parent window's font...

                hFont = reinterpret_cast<HFONT> (::SendMessage(hWndParent, WM_GETFONT, 0, 0));

                if (hFont)
                {
                    if (HFontToCharFormat(hFont, &cf))
                    {
                        ::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_ALL, (LPARAM) &cf); 
                    }
                    
                }
            }

            // Let the control display the text without the links

            DefWindowProc(uMsg, wParam, (LPARAM) szActualText);

            // Get current char format

            ::SendMessage(m_hWnd, EM_GETCHARFORMAT, SCF_DEFAULT, (LPARAM) &cf);

            cf.dwEffects |= CFE_LINK;   // For link style

            // Select the link text

            ::SendMessage(m_hWnd, EM_SETSEL, m_iLinkIndex, m_iLinkIndex + _tcslen(szLink));

            // Change the format of the link text 

            ::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM) &cf); 

            // Get the rect that covers the link in logical units
            // We will use this rect to draw focus rect around the link

            GetLinkRect(szActualText, szLink);

            return 0;

        
        }
        else
        {
            return DefWindowProc(uMsg, wParam, lParam);
        }

    }

    BOOL GetLinkRect(LPTSTR szText, LPCTSTR szLink)
    {
        if (!szText || !szLink)
        {
            return FALSE;
        }

        BOOL bSuccess = FALSE;

        if (-1 != m_iLinkIndex)
        {
            DWORD dwStart;
            DWORD dwEnd;

            dwStart = ::SendMessage(m_hWnd, EM_POSFROMCHAR, m_iLinkIndex, 0);
            dwEnd = ::SendMessage(m_hWnd, EM_POSFROMCHAR, m_iLinkIndex + _tcslen(szLink), 0);

            CHARFORMAT cf;

            ZeroMemory(&cf, sizeof(cf));

            cf.cbSize = sizeof(cf);

            cf.dwMask |= CFM_CHARSET | CFM_FACE | CFM_SIZE;

            ::SendMessage(m_hWnd, EM_SETSEL, 0, -1);

            ::SendMessage(m_hWnd, EM_GETCHARFORMAT, SCF_SELECTION, (LPARAM) &cf);

            HFONT hFont = CharFormatToHFont(&cf);

            if (hFont)
            {
                HDC hDC = GetDC();

                if (hDC)
                {
                
                    SelectObject(hDC, hFont);
                      
                    TEXTMETRIC tm;

                    ZeroMemory(&tm, sizeof(tm));

                    if (GetTextMetrics(hDC, &tm))
                    {
                       m_rect.left = LOWORD(dwStart);
                       m_rect.top = HIWORD(dwStart);
                       m_rect.right = LOWORD(dwEnd);
                       m_rect.bottom = m_rect.top + tm.tmHeight + tm.tmDescent;

                       bSuccess = TRUE;
                    }

                    ReleaseDC(hDC);

                }

                DeleteObject(hFont);
            }
        }

        return bSuccess;

    }

    BOOL DrawHotlinkFocusRect()
    {
        BOOL bRet = FALSE;

        if (-1 != m_iLinkIndex)
        {
          
            HDC hdc = GetDC();
                            
            bRet = DrawFocusRect(hdc, &m_rect);

            ReleaseDC(hdc);
            
            
        }

        return bRet;

    }

    
};



#endif // #ifndef __tmplEdit.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\pppbag.cpp ===
// PPPBag.cpp : Implementation of CPropertyPagePropertyBag
#include "stdafx.h"

#include "WizChain.h"
#include "PPPBag.h"
#include "PropItem.h"

/////////////////////////////////////////////////////////////////////////////
// CPropertyPagePropertyBag

STDMETHODIMP CPropertyPagePropertyBag::GetProperty( BSTR szGUID, VARIANT* pvar, PPPBAG_TYPE* pdwFlags, BOOL* pbIsOwner )
{
    if ( !szGUID || !pvar || !pdwFlags || !pbIsOwner ) return E_POINTER;

    CLSID clsid;
    HRESULT hr = S_OK;
    RPC_STATUS rpcs = UuidFromString( (LPOLESTR)szGUID, &clsid );

    if( RPC_S_OK != rpcs )
    {
        return HRESULT_FROM_WIN32(rpcs);
    }

    VariantInit( pvar );
    *pdwFlags = PPPBAG_TYPE_UNINITIALIZED;

    // no need to make sure szGUID is a valid guid
    // since it won't be in the map
    std::map<BSTR, CBagEntry*, CBSTR_Less>::iterator mapiter;
    mapiter = m_map.find( szGUID );

    if( mapiter != m_map.end() )
    {
        CBagEntry * pBE = mapiter->second;
        if( pBE ) 
        {
            if( SUCCEEDED(VariantCopy( pvar, pBE->GetVariant() )) )
            {
                *pdwFlags  = pBE->GetFlags( );
                *pbIsOwner = (pBE->GetOwner( ) == m_dwOwner);

                return S_OK;
            }
            else
            {
                return E_FAIL;
            }
        }
    }

	return E_INVALIDARG;
}

// a couple of helper functions
HRESULT HelperDelete(std::map<BSTR, CBagEntry*, CBSTR_Less>& map, BSTR szGUID, DWORD dwOwner  );
HRESULT HelperAdd   (std::map<BSTR, CBagEntry*, CBSTR_Less>& map, BSTR szGUID, CBagEntry* pBE);

STDMETHODIMP CPropertyPagePropertyBag::SetProperty( BSTR szGUID, VARIANT* pvar, PPPBAG_TYPE dwFlags )
{
    // validate parameters
    if( !szGUID || !pvar ) return E_POINTER;

    CLSID       clsid;    
    RPC_STATUS  rpcs    = UuidFromString( (LPOLESTR)szGUID, &clsid );

    if( RPC_S_OK != rpcs )
    {
        return HRESULT_FROM_WIN32(rpcs);
    }

    switch( dwFlags )
    {
    case PPPBAG_TYPE_READWRITE:
    case PPPBAG_TYPE_READONLY:
    case PPPBAG_TYPE_ADDITIVE:
    case PPPBAG_TYPE_DELETION:
        {
            break;
        }
    default:
        {
            return E_INVALIDARG;
        }
    }

    if( m_bReadOnly != FALSE )
    {
        return E_UNEXPECTED;
    }

    switch( dwFlags ) 
    {
    case PPPBAG_TYPE_DELETION:
        {
            return HelperDelete( m_map, szGUID, m_dwOwner );
        }
    case PPPBAG_TYPE_READWRITE:
        {
            // anyone can write to one of these
            HelperDelete( m_map, szGUID, m_dwOwner );
            CBagEntry* pBagEntry = new CBagEntry( pvar, dwFlags, m_dwOwner );
            if( !pBagEntry ) return E_OUTOFMEMORY;

            return HelperAdd( m_map, szGUID, pBagEntry );
        }
    case PPPBAG_TYPE_READONLY:        
        {
            // only allow owner to write to this kind of entry
            HRESULT hr = HelperDelete( m_map, szGUID, m_dwOwner );
            if( hr == S_OK )
            {
                CBagEntry* pBagEntry = new CBagEntry( pvar, dwFlags, m_dwOwner );
                if( !pBagEntry ) return E_OUTOFMEMORY;

                hr = HelperAdd( m_map, szGUID, pBagEntry );
            }

            return hr;
        }
    case PPPBAG_TYPE_ADDITIVE:
        {
            // TODO:  add code so that additive properties work correctly
            return E_NOTIMPL;
        }
    }

	return S_OK;
}

HRESULT HelperDelete( std::map<BSTR, CBagEntry*, CBSTR_Less> & map, BSTR szGUID, DWORD dwOwner )
{
    std::map<BSTR, CBagEntry*, CBSTR_Less>::iterator mapiter;
    mapiter = map.find( szGUID );

    if( mapiter != map.end( ) ) 
    {
        CBagEntry * pBE = mapiter->second;
        if( pBE )
        {
            if( pBE->GetFlags( ) == PPPBAG_TYPE_READONLY )
            {
                if( pBE->GetOwner( ) != dwOwner )    // component's trying to delete
                {
                    return E_UNEXPECTED;      // an entry that doesn't belong to it
                }
            }
        }

        SysFreeString( mapiter->first );
        delete mapiter->second;
        map.erase( mapiter );
    }

    return S_OK;    
}

HRESULT HelperAdd( std::map<BSTR, CBagEntry*, CBSTR_Less>& map, BSTR szGUID, CBagEntry* pBE )
{
    std::map<BSTR, CBagEntry*, CBSTR_Less>::iterator mapiter = map.find( szGUID );

    if( mapiter != map.end() ) 
    {
        assert( 0 && "this should have been deleted by now!" );
        SysFreeString( mapiter->first );
        delete mapiter->second;
        map.erase( mapiter );
    }

    BSTR bstr = SysAllocString( (LPOLESTR)szGUID );
    
    if( !bstr )
    {
        return E_OUTOFMEMORY;
    }

    map[bstr] = pBE;
    return S_OK;
}

HRESULT CPropertyPagePropertyBag::Enumerate( long index, BSTR* pbstr, VARIANT* pvar, PPPBAG_TYPE* pdwFlags, BOOL* pbIsOwner, BOOL* pbInRange )
{
    if( !pbstr || !pvar|| !pdwFlags || !pbIsOwner || !pbInRange ) return E_POINTER;

    if( index >= 0 ) 
    {
        long i = 0;
        std::map<BSTR, CBagEntry *, CBSTR_Less>::iterator mapiter = m_map.begin( );

        while( mapiter != m_map.end() ) 
        {
            if( i == index )
            {
                *pbstr = SysAllocString( mapiter->first );
                CBagEntry* pBE = mapiter->second;

                assert( pBE != NULL );

                if( SUCCEEDED(VariantCopy( pvar, pBE->GetVariant() )) )
                {
                    *pdwFlags  = pBE->GetFlags();
                    *pbIsOwner = (pBE->GetOwner() == m_dwOwner);
                    *pbInRange = TRUE;
                    
                    return S_OK;
                }
                
                return E_FAIL;
            }

            mapiter++;
            i++;
        }
    }

    // out of range
    *pdwFlags  = PPPBAG_TYPE_UNINITIALIZED;
    *pbInRange = FALSE;

    return S_FALSE;
}

// helper
IDispatch* CreateItem( BSTR bstrGuid, VARIANT* var, PPPBAG_TYPE dwFlags )
{
    // create the item and initialize it
    CComObject<CPropertyItem>* pPI = NULL;
    CComObject<CPropertyItem>::CreateInstance( &pPI );
    if( !pPI ) return NULL;

    pPI->Initialize( bstrGuid, var, dwFlags );  // Initialize the Property Item

    // return back an IDispatch *
    IDispatch* pDisp = NULL;
    
    pPI->AddRef( );
    pPI->QueryInterface( IID_IDispatch, (void**)&pDisp );    // can't fail
    pPI->Release( );
    
    assert( pDisp != NULL );
    
    return pDisp;
}

class CEnumVariant : public IEnumVARIANT
{

private:
    ULONG m_refs;
    ULONG m_index;
    CPropertyPagePropertyBag* m_pPPPBag;   // addref'd !

    CEnumVariant( CPropertyPagePropertyBag* pPPPBag )
    {
        assert( pPPPBag != NULL );

        m_refs = 0;
        m_index = 0;

        m_pPPPBag = pPPPBag;
        m_pPPPBag->AddRef();
    }

   ~CEnumVariant ()
    {
        m_pPPPBag->Release();
    }

public:
    
    static IEnumVARIANT* CreateInstance( CPropertyPagePropertyBag* pPPPBag )
    {
        assert( pPPPBag != NULL );

        CEnumVariant* pCEV = new CEnumVariant( pPPPBag );

        if( !pCEV )
        {
            return NULL;
        }

        IEnumVARIANT* pIEV = NULL;

        pCEV->AddRef( );
        pCEV->QueryInterface( IID_IEnumVARIANT, (void**)&pIEV );
        pCEV->Release( );

        return pIEV;
    }

// IUnknown
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, void** ppvObject )
    {
        HRESULT hr = S_OK;

        if ((riid == IID_IUnknown) ||
            (riid == IID_IEnumVARIANT) )
        {
            AddRef();
            *ppvObject = (void*)this;
        }
        else
        {
            hr = E_NOINTERFACE;
        }

        return hr;
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( )
    {
        InterlockedIncrement( (PLONG)&m_refs );
        
        return m_refs;
    }

    virtual ULONG STDMETHODCALLTYPE Release( )
    {
        InterlockedDecrement( (PLONG)&m_refs );
        
        ULONG l = m_refs;
        
        if( m_refs == 0 )
        {
            delete this;
        }

        return l;
    }

// IEnumVARIANT
    virtual HRESULT STDMETHODCALLTYPE Next( /*[in]*/ ULONG celt, /*[out, size_is(celt), length_is(*pCeltFetched)]*/ VARIANT* rgVar, /*[out]*/ ULONG* pCeltFetched )
    {
        // clear stuff being passed in (just in case)
        if( pCeltFetched )
        {
            *pCeltFetched = 0;
        }
        for( ULONG i = 0; i < celt; i++ )
        {
            VariantInit( &rgVar[i] );
        }

        // get the next celt elements
        for( i = 0; i < celt; i++ )
        {
            BSTR    bstr = NULL;
            VARIANT var;
            VariantInit( &var );
            
            PPPBAG_TYPE dwFlags = PPPBAG_TYPE_UNINITIALIZED;
            BOOL bIsOwner = FALSE;
            BOOL bInRange = FALSE;
            
            m_pPPPBag->Enumerate( (long)m_index++, &bstr, &var, &dwFlags, &bIsOwner, &bInRange );
            
            if( bInRange == FALSE )
            {
                break;
            }

            IDispatch* pDisp = CreateItem( bstr, &var, dwFlags );
            VariantClear( &var );
            if( pDisp == NULL )
            {
                return E_OUTOFMEMORY;
            }

            rgVar[i].vt       = VT_DISPATCH;
            rgVar[i].pdispVal = pDisp;
        }

        // fill out how many we're returning
        if( pCeltFetched )
        {
           *pCeltFetched = i;
        }

        return ( (i < celt) ? S_FALSE : S_OK);
    }

    virtual HRESULT STDMETHODCALLTYPE Skip( /*[in]*/ ULONG celt )
    {
        long count;
        m_pPPPBag->get_Count( &count );

        if( (celt + m_index) > (ULONG)count )
        {
            return S_FALSE;
        }

        m_index += celt;
        
        return S_OK;
    }

    virtual HRESULT STDMETHODCALLTYPE Reset( )
    {
        m_index = 0;
        return S_OK;
    }

    virtual HRESULT STDMETHODCALLTYPE Clone( /*[out]*/ IEnumVARIANT** ppEnum )
    {
        if( !(*ppEnum = CreateInstance( m_pPPPBag )) )
        {
            return E_OUTOFMEMORY;
        }

        return S_OK;
    }
};

// CPropertyCollection
STDMETHODIMP CPropertyPagePropertyBag::get__NewEnum( IUnknown** pVal )
{
    if( !pVal ) return E_POINTER;

    IEnumVARIANT* pEV = CEnumVariant::CreateInstance( this );
    if( !pEV ) return E_OUTOFMEMORY;

    HRESULT hr = pEV->QueryInterface( IID_IUnknown, (void**)pVal );
    pEV->Release();

	return hr;
}

STDMETHODIMP CPropertyPagePropertyBag::get_Item( VARIANT* pVar, IDispatch** pVal )
{
    // handle both:
    // objFoo.Item(1), and
    // objFoo.Item("string");
    // validate parameters
    if( !pVar || !pVal ) return E_POINTER;

    *pVal = NULL;

    if( V_VT(pVar) == VT_BSTR )
    {
        BSTR    bstrGuid = V_BSTR(pVar);
        CLSID   clsid;
        HRESULT hr = S_OK;
        RPC_STATUS rpcs = UuidFromString( (LPOLESTR)bstrGuid, &clsid );
        if( RPC_S_OK != rpcs )
        {
            return HRESULT_FROM_WIN32(rpcs);
        }

        std::map<BSTR, CBagEntry*, CBSTR_Less>::iterator mapiter;
        mapiter = m_map.find( bstrGuid );

        if( mapiter != m_map.end() )
        {
            CBagEntry* pBE = mapiter->second;
            if( pBE ) 
            {
                if( !(*pVal = CreateItem( bstrGuid, pBE->GetVariant(), pBE->GetFlags() )) )
                {
                    return E_OUTOFMEMORY;
                }

                return S_OK;
            }
        }
    } 
    else if ( (V_VT(pVar) == VT_I2) || (V_VT(pVar) == VT_I4) )
    {
        long index;
        if( V_VT(pVar) == VT_I4 )
        {
            index = V_I4(pVar);
        }
        else
        {
            index = V_I2(pVar);
        }

        BSTR    bstr = NULL;
        VARIANT var;    
        VariantInit (&var);

        PPPBAG_TYPE dwFlags  = PPPBAG_TYPE_UNINITIALIZED;
        BOOL        bIsOwner = FALSE;
        BOOL        bInRange = FALSE;
        HRESULT     hr       = Enumerate( index, &bstr, &var, &dwFlags, &bIsOwner, &bInRange );

        if( SUCCEEDED(hr) && (bInRange == TRUE) )
        {
            if( !(*pVal = CreateItem( bstr, &var, dwFlags )) )
            {
                hr = E_OUTOFMEMORY;
            }
        }

        VariantClear ( &var );
        SysFreeString( bstr );

        return hr;
    } 
    else
    {
        return E_UNEXPECTED;    // not a valid variant type
    }

	return S_FALSE;
}

STDMETHODIMP CPropertyPagePropertyBag::get_Count( long *pVal )
{
    if( !pVal ) return E_POINTER;

    // TODO:  figure out how to use map.count method 
    long i = 0;
    std::map<BSTR, CBagEntry*, CBSTR_Less>::iterator mapiter = m_map.begin();

    while( mapiter != m_map.end() )
    {
        mapiter++;
        i++;
    }

    *pVal = i;
	return S_OK;
}

STDMETHODIMP CPropertyPagePropertyBag::Add(BSTR bstrGuid, VARIANT *varValue, long iFlags, IPropertyItem **ppItem)
{
    // validate parameters
    if( !bstrGuid || !varValue || !ppItem ) return E_POINTER;

    *ppItem = NULL;

    HRESULT hr = SetProperty( bstrGuid, varValue, (PPPBAG_TYPE)iFlags );
    if( hr == S_OK )
    {
        IDispatch* pDisp = CreateItem( bstrGuid, varValue, (PPPBAG_TYPE)iFlags );
        if( !pDisp )
        {
            hr = E_OUTOFMEMORY;
        }
        else 
        {
            hr = pDisp->QueryInterface( IID_IPropertyItem, (void**)ppItem );
            pDisp->Release();
        }
    }
	return hr;
}

STDMETHODIMP CPropertyPagePropertyBag::Remove( BSTR bstrGuid )
{
    if( !bstrGuid ) return E_POINTER;

    CLSID   clsid;
    RPC_STATUS rpcs = UuidFromString( (LPOLESTR)bstrGuid, &clsid );
    if( RPC_S_OK != rpcs )
    {
        return HRESULT_FROM_WIN32(rpcs);
    }

    return HelperDelete( m_map, bstrGuid, m_dwOwner );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\chainwiz.h ===
// ChainWiz.h : Declaration of the CChainWiz

#ifndef __CHAINWIZ_H_
#define __CHAINWIZ_H_

#include "resource.h"       // main symbols

#include "PPPBag.h"
#include "tmplRichEdit.h"

#include <assert.h>

class CDummyComponent : public IAddPropertySheets
{

private:
    BOOL    m_bIsWelcomePage;
    ULONG   m_refs;

    CDummyComponent( BOOL bIsWelcomePage )
    {
        m_bIsWelcomePage = bIsWelcomePage;
        m_refs = 0;
    }

   ~CDummyComponent( ) {}

public:
    static IAddPropertySheets* Create( BOOL bIsWelcomePage )
    {
        IAddPropertySheets* pAPSs = NULL;
        CDummyComponent* pDC = new CDummyComponent( bIsWelcomePage );

        if( pDC )
        {
            pDC->AddRef();
            pDC->QueryInterface( IID_IAddPropertySheets, (void**)&pAPSs );
            pDC->Release();
        }
        
        return pAPSs;
    }

    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, void** ppvObject )
    {
        HRESULT hr = S_OK;

        if ((riid == IID_IUnknown) ||
            (riid == IID_IAddPropertySheets) )
        {
            AddRef();
            *ppvObject = (void*)this;
        } 
        else
        {
            hr = E_NOINTERFACE;
        }

        return hr;
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( )
    {
        InterlockedIncrement( (PLONG)&m_refs );
        return m_refs;
    }

    virtual ULONG STDMETHODCALLTYPE Release( )
    {
        InterlockedDecrement( (PLONG)&m_refs );
        
        ULONG l = m_refs;

        if( m_refs == 0 )
        {
            delete this;
        }

        return l;
    }

    virtual HRESULT STDMETHODCALLTYPE EnumPropertySheets( IAddPropertySheet* pADS) { return S_FALSE; }
    virtual HRESULT STDMETHODCALLTYPE ProvideFinishText ( LPOLESTR* lpolestrString, LPOLESTR * pMoreInfoText) { return E_NOTIMPL; }
    virtual HRESULT STDMETHODCALLTYPE ReadProperties    ( IPropertyPagePropertyBag* pPPPBag) { return S_OK; }
    virtual HRESULT STDMETHODCALLTYPE WriteProperties   ( IPropertyPagePropertyBag* pPPPBag) { return S_OK; }
};

class CComponents
{

private:
    IAddPropertySheets* m_pAPSs;

public:
    CComponents( IAddPropertySheets* pAPSs )
    {
        if( pAPSs )
        {
           pAPSs->AddRef ();
        }

        m_pAPSs = pAPSs;
    }

   ~CComponents( )
    {
        if( m_pAPSs ) 
        {
            m_pAPSs->Release();
            m_pAPSs = NULL;
        }
    }

    IAddPropertySheets* GetComponent( ) { return m_pAPSs; }
};

/////////////////////////////////////////////////////////////////////////////
// CChainWiz
class ATL_NO_VTABLE CChainWiz : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CChainWiz, &CLSID_ChainWiz>,
    public IChainWiz
{

public:
    HWND m_hWndLink;
    HWND m_hWndWelcomeLink;

    CWindowImplHotlinkRichEdit<> m_Hotlink;
    DWORD m_dwWizardStyle;

    HMODULE m_hModuleRichEdit;    

private:        
    
    PROPSHEETHEADERW*       m_psh;
    std::list<CComponents*> m_listOfAPSs;
    std::map<LPDLGTEMPLATE, LPDLGTEMPLATE> m_mapOfTemplates;    
    LPOLESTR                m_szFinishText;
    HFONT                   m_hf;

    BSTR m_szWelcomeTitle;
    BSTR m_szFinishHeader;
    BSTR m_szFinishSubHeader;
    BSTR m_szFirstFinishTextLine;
    BSTR m_bstrTempFileName;

    CComObject<CPropertyPagePropertyBag>* m_PPPBag;
    IAddPropertySheets* m_CurrentComponent;
    IAddPropertySheets* m_PreviousComponent;

private:
    void DestroyMaps( )
    {
        std::list<CComponents*>::iterator iterAPSs = m_listOfAPSs.begin();

        for( CComponents* pComps = *iterAPSs; iterAPSs != m_listOfAPSs.end(); pComps = *++iterAPSs )
        {
            delete pComps;
        }

        m_listOfAPSs.clear();

        // destroy templates
        std::map<LPDLGTEMPLATE, LPDLGTEMPLATE>::iterator iterTemp = m_mapOfTemplates.begin();
        while( iterTemp != m_mapOfTemplates.end() )
        {
            GlobalFree( iterTemp->second );
            iterTemp++;
        }

        m_mapOfTemplates.clear();
    }

public:
    CChainWiz( ) : m_bstrTempFileName(NULL), m_hWndLink(NULL), m_hWndWelcomeLink(NULL), m_szFirstFinishTextLine(NULL), m_dwWizardStyle(0)
    {
        m_hModuleRichEdit   = NULL;
        m_psh               = NULL;
        m_szFinishText      = NULL;
        m_szWelcomeTitle    = NULL;
        m_szFinishHeader    = NULL;
        m_szFinishSubHeader = NULL;
        m_PPPBag            = NULL;

        CComObject<CPropertyPagePropertyBag>::CreateInstance( &m_PPPBag );

        if( m_PPPBag )
        {
            m_PPPBag->AddRef();  
        }

        m_CurrentComponent  = NULL;
        m_PreviousComponent = NULL;

        // copied from wiz97.cpp (sample code)
        NONCLIENTMETRICS ncm = {0};
        ncm.cbSize = sizeof (ncm);

        SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, 0 );
        
        LOGFONT lf  = ncm.lfMessageFont;
        lf.lfWeight = FW_BOLD;

        // using font name in resource file instead of hard-coding 'Verdana Bold'
        WCHAR szFont[32];
        ::LoadString( (HINSTANCE)_Module.GetModuleInstance(), IDS_WIZARD97_FONT, szFont, 32 );
        wcscpy (lf.lfFaceName, szFont);        
        // using font name in resource file instead of hard-coding 'Verdana Bold'

        HDC hdc      = GetDC( NULL ); // gets the screen DC
        int FontSize = 12;
        lf.lfHeight  = 0 - ((GetDeviceCaps( hdc, LOGPIXELSY ) * FontSize) / 72);        
        m_hf         = CreateFontIndirect( &lf );

        ReleaseDC( NULL, hdc );
    }

   ~CChainWiz()
    {
        if( m_hModuleRichEdit )
        {
            FreeLibrary(m_hModuleRichEdit);
        }

        if( m_hf )
        {
            DeleteObject( (HGDIOBJ)m_hf );
        }

        if( m_PPPBag )
        {
            m_PPPBag->Release();
        }

        if( m_psh ) 
        {
            delete[] m_psh->phpage;
            delete m_psh;
        }        

        if( m_szFinishText )
        {
            CoTaskMemFree( m_szFinishText );
        }
        
        if( m_szWelcomeTitle )
        {
            SysFreeString( m_szWelcomeTitle );
        }

        if( m_szFinishHeader )
        {
            SysFreeString( m_szFinishHeader );
        }

        if( m_szFinishSubHeader )
        {
            SysFreeString( m_szFinishSubHeader );
        }

        if( m_szFirstFinishTextLine )
        {
            SysFreeString( m_szFirstFinishTextLine );
        }

        if (m_bstrTempFileName)
        {
            DeleteFile( m_bstrTempFileName );
            SysFreeString( m_bstrTempFileName );
        }

        // release all pAPSs
        DestroyMaps( );
    }

    HRESULT Add( PROPSHEETPAGEW* psp );
    HRESULT GetAllFinishText( LPOLESTR* pstring, LPOLESTR* pMoreInfoText );

DECLARE_REGISTRY_RESOURCEID(IDR_CHAINWIZ)
DECLARE_NOT_AGGREGATABLE(CChainWiz)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CChainWiz)
    COM_INTERFACE_ENTRY(IChainWiz)
END_COM_MAP()

// IChainWiz
public:
    STDMETHOD(DoModal)              ( /*[out]*/ long* ret );
    STDMETHOD(AddWizardComponent)   ( /*[in, string]*/ LPOLESTR szClsidOfComponent );
    STDMETHOD(Initialize)           ( /*[in]*/ HBITMAP hbmWatermark, /*[in]*/ HBITMAP hbmHeader, /*[in, string]*/ LPOLESTR szTitle, /*[in, string]*/ LPOLESTR szWelcomeHeader, /*[in, string]*/ LPOLESTR szWelcomeText, /*[in, string]*/ LPOLESTR szFinishHeader, /*[in, string]*/ LPOLESTR szFinishIntroText, LPOLESTR /*[in, string]*/ szFinishText );    
    STDMETHOD(get_MoreInfoFileName) ( /*[out, retval*]*/ BSTR * pbstrMoreInfoFileName);
    STDMETHOD(put_WizardStyle)(/*[in*/ VARIANT * pVar);

public:
    // for welcomedlgproc
    PROPSHEETHEADERW* GetPropSheetHeader( ) { return m_psh; }

    // for finishdlgproc
    HFONT GetBoldFont( )        { return m_hf; }
    BSTR  GetFinishHeader( )    { return m_szFinishHeader; }
    BSTR  GetFinishSubHeader( ) { return m_szFinishSubHeader; }

    // for cancel message box
    BSTR GetTitle( ) { return m_szWelcomeTitle; }

    STDMETHOD(get_PropertyBag)( /*[out, retval]*/ IDispatch* *pVal );
    CComObject<CPropertyPagePropertyBag>* GetPPPBag( ) { return m_PPPBag; }

    IAddPropertySheets* GetCurrentComponent( ) { return m_CurrentComponent; }
    void SetCurrentComponent( IAddPropertySheets* CurrentComponent ) { m_CurrentComponent = CurrentComponent; }

    IAddPropertySheets* GetPreviousComponent( ) { return m_PreviousComponent; }
    void SetPreviousComponent( IAddPropertySheets* PreviousComponent ) { m_PreviousComponent = PreviousComponent; }

    HRESULT WriteTempFile ( LPCTSTR szText );
    HRESULT LaunchMoreInfo( );

    LPDLGTEMPLATE GetAtlTemplate( LPDLGTEMPLATE lpdt )
    {
        std::map<LPDLGTEMPLATE, LPDLGTEMPLATE>::iterator iterTemp = m_mapOfTemplates.find (lpdt);

        if( iterTemp != m_mapOfTemplates.end() )
        {
            return iterTemp->second;
        }

        return NULL;
    }
};

#endif //__CHAINWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\propitem.cpp ===
// PropItem.cpp : Implementation of CPropertyItem
#include "stdafx.h"

#include "WizChain.h"
#include "PropItem.h"

/////////////////////////////////////////////////////////////////////////////
// CPropertyItem

HRESULT CPropertyItem::get_Value( /*[out, retval]*/ VARIANT *varValue )
{
    if( !varValue ) return E_POINTER;

    VariantInit( varValue );
    return VariantCopy( varValue, &m_var );
}

HRESULT CPropertyItem::get_Name( /*[out, retval]*/ BSTR *strName )
{
    if( !strName ) return E_POINTER;

    if( !(*strName = SysAllocString( m_bstrName )) )
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
HRESULT CPropertyItem::get_Type( /*[out, retval]*/ long *dwFlags )
{
    if( !dwFlags ) return E_POINTER;

    *dwFlags = m_dwFlags;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\pppbag.h ===
// PPPBag.h : Declaration of the CPropertyPagePropertyBag

#ifndef __PROPERTYPAGEPROPERTYBAG_H_
#define __PROPERTYPAGEPROPERTYBAG_H_

#include "resource.h"       // main symbols

#include <map>
#include <assert.h>

class CBSTR_Less 
{

public:
    bool operator()( BSTR p, BSTR q ) const
    {
        return (_wcsicmp( (WCHAR*)p, (WCHAR*)q ) < 0);
    }
};

class CBagEntry
{

private:
    VARIANT     m_var;
    PPPBAG_TYPE m_dwFlags;
    DWORD       m_dwOwner;

public:
    CBagEntry( VARIANT * v, PPPBAG_TYPE dwFlags, DWORD dwOwner )
    {
        VariantInit( &m_var );
        HRESULT hr = VariantCopy( &m_var, v );
        assert( SUCCEEDED(hr) );
        m_dwFlags = dwFlags;
        m_dwOwner = dwOwner;
    }

   ~CBagEntry( )
    {
        VariantClear( &m_var );
    }

    VARIANT *   GetVariant( ) { return &m_var;    }
    PPPBAG_TYPE GetFlags  ( ) { return m_dwFlags; }
    DWORD       GetOwner  ( ) { return m_dwOwner; }
};

#define PPPBAG_SYSTEM_OWNER (-1)

/////////////////////////////////////////////////////////////////////////////
// CPropertyPagePropertyBag
class ATL_NO_VTABLE CPropertyPagePropertyBag : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CPropertyPagePropertyBag, &CLSID_PropertyPagePropertyBag>,
    public IDispatchImpl<IPropertyCollection, &IID_IPropertyCollection, &LIBID_WIZCHAINLib>
{

private:
    BOOL    m_bReadOnly;
    DWORD   m_dwOwner; // component id
    std::map<BSTR, CBagEntry*, CBSTR_Less> m_map;

public:
    CPropertyPagePropertyBag()
    {
        m_bReadOnly = FALSE;
        m_dwOwner   = PPPBAG_SYSTEM_OWNER;  // initially owned by wizard, not any component
    }

   ~CPropertyPagePropertyBag()
    {
        // free map entries
        std::map<BSTR, CBagEntry *, CBSTR_Less>::iterator mapiter = m_map.begin();

        while( mapiter != m_map.end() )
        {
            SysFreeString( mapiter->first );
            delete mapiter->second;
            mapiter++;
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_PROPERTYPAGEPROPERTYBAG)
DECLARE_NOT_AGGREGATABLE(CPropertyPagePropertyBag)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPropertyPagePropertyBag)
    COM_INTERFACE_ENTRY(IPropertyPagePropertyBag)
    COM_INTERFACE_ENTRY(IPropertyCollection)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
// IPropertyPagePropertyBag
    STDMETHOD(SetProperty)( /*[in]*/ BSTR szGUID, /*[in]*/ VARIANT * pvar, /*[in]*/ PPPBAG_TYPE dwFlags );
    STDMETHOD(GetProperty)( /*[in]*/ BSTR szGUID, /*[out]*/ VARIANT * pvar, /*[out]*/ PPPBAG_TYPE * dwFlags, /*[out]*/ BOOL * pbIsOwner );
    STDMETHOD(Enumerate  )( /*[in]*/ long index, /*[out]*/ BSTR * pbstr, /*[out]*/ VARIANT * pvar, /*[out]*/PPPBAG_TYPE* pdwFlags, /*[out]*/ BOOL* pbIsOwner, /*[out,retval]*/ BOOL* pbInRange );

// IPropertyCollection
    STDMETHOD(Remove      )( /*[in]*/ BSTR bstrGuid);    
    STDMETHOD(Add         )( /*[in]*/ BSTR bstrGuid, /*[in]*/ VARIANT *varValue, /*[in, optional, defaultvalue(0)]*/ long iFlags, /*[out, retval]*/ IPropertyItem **ppItem);
    STDMETHOD(get_Count   )( /*[out, retval]*/ long *pVal);
    STDMETHOD(get_Item    )( /*[in]*/ VARIANT * pVar, /*[out, retval]*/ IDispatch* *pVal);
    STDMETHOD(get__NewEnum)( /*[out, retval]*/ IUnknown* *pVal);


public:
    void SetReadOnly( BOOL b       ) { m_bReadOnly = b;     }
    void SetOwner   ( DWORD dwOwner) { m_dwOwner = dwOwner; }

};

class COwnerPPPBag: public IPropertyCollection
{

private:    
    CPropertyPagePropertyBag * m_pPPPBag;
    ULONG m_refs;
    DWORD m_dwOwner; // component id

    COwnerPPPBag( CPropertyPagePropertyBag * pPPPBag, DWORD dwOwner )
    {
        assert (pPPPBag != NULL);
        assert (dwOwner != 0);

        m_pPPPBag = pPPPBag;
        m_dwOwner = dwOwner;
        m_refs = 0;
    }

   ~COwnerPPPBag( ) {}

public:
    static IPropertyPagePropertyBag* Create( CPropertyPagePropertyBag* pCPPPBag, DWORD dwOwner )
    {
        IPropertyPagePropertyBag * pPPPBag = NULL;
        COwnerPPPBag * pOPPPBag = new COwnerPPPBag (pCPPPBag, dwOwner);
        if( pOPPPBag )
        {
            pOPPPBag->AddRef();
            pOPPPBag->QueryInterface (IID_IPropertyPagePropertyBag, (void**)&pPPPBag);
            pOPPPBag->Release();
        }

        return pPPPBag;
    }
    
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, void** ppvObject )
    {
        HRESULT hr = S_OK;
        if ((riid == IID_IUnknown)            ||
            (riid == IID_IDispatch)           ||
            (riid == IID_IPropertyCollection) ||
            (riid == IID_IPropertyPagePropertyBag) )
        {
            AddRef();
            *ppvObject = (void *)this;
        } 
        else
        {
            hr = E_NOINTERFACE;
        }

        return hr;
    }

    virtual ULONG STDMETHODCALLTYPE AddRef( )
    {
        InterlockedIncrement( (PLONG)&m_refs );
        return m_refs;
    }

    virtual ULONG STDMETHODCALLTYPE Release( )
    {
        InterlockedDecrement( (PLONG)&m_refs );
        ULONG l = m_refs;
        
        if( m_refs == 0 )
        {
            delete this;
        }

        return l;
    }

// IDispatch
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount( UINT* pctinfo )
    {
        m_pPPPBag->SetOwner( m_dwOwner );
        
        HRESULT hr = m_pPPPBag->GetTypeInfoCount( pctinfo );
        m_pPPPBag->SetOwner( NULL );
        
        return hr;
    }
        
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo( UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo )
    {
        m_pPPPBag->SetOwner( m_dwOwner );

        HRESULT hr = m_pPPPBag->GetTypeInfo( iTInfo, lcid, ppTInfo );
        m_pPPPBag->SetOwner( NULL );
        
        return hr;
    }
    
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames( REFIID riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgDispId )
    {
        m_pPPPBag->SetOwner( m_dwOwner );

        HRESULT hr = m_pPPPBag->GetIDsOfNames( riid, rgszNames, cNames, lcid, rgDispId );
        m_pPPPBag->SetOwner( NULL );

        return hr;
    }
    
    virtual HRESULT STDMETHODCALLTYPE Invoke( DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pDispParams, VARIANT* pVarResult, EXCEPINFO* pExcepInfo, UINT* puArgErr )
    {
        m_pPPPBag->SetOwner( m_dwOwner );

        HRESULT hr = m_pPPPBag->Invoke( dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr );
        m_pPPPBag->SetOwner( NULL );

        return hr;
    }

// IPropertyPagePropertyBag
    virtual HRESULT STDMETHODCALLTYPE SetProperty( BSTR szGUID, VARIANT* pvar, PPPBAG_TYPE dwFlags )
    {
        m_pPPPBag->SetOwner( m_dwOwner );

        HRESULT hr = m_pPPPBag->SetProperty( szGUID, pvar, dwFlags );
        m_pPPPBag->SetOwner( NULL );
        
        return hr;
    }

    virtual HRESULT STDMETHODCALLTYPE GetProperty( BSTR szGUID, VARIANT* pvar, PPPBAG_TYPE* dwFlags, BOOL* pbIsOwner )
    {
        m_pPPPBag->SetOwner( m_dwOwner );

        HRESULT hr = m_pPPPBag->GetProperty( szGUID, pvar, dwFlags, pbIsOwner );
        m_pPPPBag->SetOwner( NULL );

        return hr;
    }

    virtual HRESULT STDMETHODCALLTYPE Enumerate( long index, BSTR* pbstr, VARIANT* pvar, PPPBAG_TYPE* pdwFlags, BOOL* pbIsOwner, BOOL* pbInRange )
    {
        m_pPPPBag->SetOwner( m_dwOwner );

        HRESULT hr = m_pPPPBag->Enumerate( index, pbstr, pvar, pdwFlags, pbIsOwner, pbInRange );
        m_pPPPBag->SetOwner( NULL );

        return hr;
    }

    STDMETHOD(Remove)( /*[in]*/ BSTR bstrGuid )
    {
        m_pPPPBag->SetOwner( m_dwOwner );

        HRESULT hr = m_pPPPBag->Remove( bstrGuid );
        m_pPPPBag->SetOwner( NULL );

        return hr;
    }

    STDMETHOD(Add)( /*[in]*/ BSTR bstrGuid, /*[in]*/ VARIANT* varValue, /*[in, optional, defaultvalue(0)]*/ long iFlags, /*[out, retval]*/ IPropertyItem** ppItem )
    {
        m_pPPPBag->SetOwner( m_dwOwner );

        HRESULT hr = m_pPPPBag->Add( bstrGuid, varValue, iFlags, ppItem );
        m_pPPPBag->SetOwner( NULL );

        return hr;
    }

    STDMETHOD(get_Count)( /*[out, retval]*/ long* pVal )
    {
        m_pPPPBag->SetOwner( m_dwOwner );

        HRESULT hr = m_pPPPBag->get_Count( pVal );
        m_pPPPBag->SetOwner( NULL );

        return hr;
    }

    STDMETHOD(get_Item)( /*[in]*/ VARIANT* pVar, /*[out, retval]*/ IDispatch** pVal )
    {
        m_pPPPBag->SetOwner( m_dwOwner );

        HRESULT hr = m_pPPPBag->get_Item( pVar, pVal );
        m_pPPPBag->SetOwner( NULL );

        return hr;
    }

    STDMETHOD(get__NewEnum)( /*[out, retval]*/ IUnknown** pVal )
    {
        m_pPPPBag->SetOwner( m_dwOwner );

        HRESULT hr = m_pPPPBag->get__NewEnum( pVal );
        m_pPPPBag->SetOwner( NULL );

        return hr;
    }

};

#endif //__PROPERTYPAGEPROPERTYBAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\chainwiz.cpp ===
// ChainWiz.cpp : Implementation of CChainWiz
#include "stdafx.h"

#include "WizChain.h"
#include "ChainWiz.h"
#include "propsht.h"

#include <commctrl.h>
#include <shellapi.h>
#include <htmlhelp.h>

#include "txttohtm.h"
#include "createtempfile.h"

// From sdnt\shell\comctl32\v6\rcids.h 
#define IDD_NEXT 0x3024

// helper(s)
static LPDLGTEMPLATE GetDialogTemplate( HINSTANCE hinst, LPCWSTR wszResource )
{
    HRSRC hrsrc = FindResourceW( hinst, wszResource, (LPCWSTR)RT_DIALOG );

    if (hrsrc) 
    {
        HGLOBAL hg = LoadResource( hinst, hrsrc );

        if( hg )
        {
            return (LPDLGTEMPLATE)LockResource( hg );
        }
    }

    return NULL;
}

static LPCWSTR DupStringResource( HINSTANCE hinst, LPCWSTR wszResource )
{
    if ( NULL == wszResource )
        return NULL;

    LONG_PTR lid = (LONG_PTR)wszResource;

    // first, try a static 256 wchar buffer....
    WCHAR wszBuffer[256];
    int iLen = LoadStringW( hinst, (UINT)lid, wszBuffer, 256 );
    if( iLen <= 0 )
    {
        // resource not found:  should be a string....
        if ( IsBadStringPtrW( wszResource, 16384 ))
        {
            return NULL;    // resource not found, and can't read memory
        }

        return _wcsdup( wszResource );
    }

    if( iLen < 256 )
    {
        return _wcsdup( wszBuffer );
    }

    // else alloc a bigger and bigger buffer until it all fits, then dup
    for( int i = 512; i < 16384; i += 256) 
    {
        WCHAR* pw = (WCHAR*)malloc( i * sizeof(WCHAR) );
        if( !pw )
        {
            break;  // yikes!
        }
        else 
        {
            iLen = LoadStringW( hinst, (UINT)lid, pw, i );
            if( iLen < i ) 
            {
                WCHAR* pwResult = _wcsdup( pw );
                free( pw );
                return pwResult;
            }

            free( pw );
        }
    }

    return NULL;
}

void FreeStringResources( PROPSHEETPAGEW* psp )
{
    if( psp->pszTitle )
    {
        free( (void*)psp->pszTitle );
    }

    if( psp->pszHeaderTitle )
    {
        free( (void*)psp->pszHeaderTitle );
    }

    if( psp->pszHeaderSubTitle )
    {
        free( (void*)psp->pszHeaderSubTitle );
    }
}

// thunking stuff
struct CThunkData 
{
public:
    void*                m_sig;     // signature (pointer back to self)
    CChainWiz*           m_pCW;
    PROPSHEETPAGEW*      m_theirPSP;
    WNDPROC              m_theirWndProc;
    IAddPropertySheets*  m_pAPSs;   // not AddRef'd

    CThunkData( CChainWiz* pCW, PROPSHEETPAGEW* theirPSP, WNDPROC WndProc, IAddPropertySheets* pAPSs )
    {
        m_sig          = (void*)this;
        m_theirWndProc = WndProc;
        m_pCW          = pCW;      // need one of these inside my thunking layers
        m_pAPSs        = pAPSs;    // not AddRef'd

        // their stuff (variable size!!!)
        BYTE* temp     = new BYTE[theirPSP->dwSize];
        m_theirPSP     = (PROPSHEETPAGEW*)temp;
        
        if( temp )
        {
            MoveMemory( temp, theirPSP, theirPSP->dwSize );
        }
    }

    ~CThunkData( )
    {
        delete [] (BYTE*)m_theirPSP;
    }
};

UINT CALLBACK ChainCallback( HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp )
{
    if( !ppsp ) return 0;
    // get my data
    CThunkData* pTD = (CThunkData*)ppsp->lParam;

    if( !pTD ) return 0;

    if( pTD->m_theirPSP &&
        (pTD->m_theirPSP->dwFlags & PSP_USECALLBACK) && 
        (pTD->m_theirPSP->pfnCallback != NULL) )
    {
        // swap their data and my data
        CThunkData td( NULL, ppsp, NULL, NULL );
        MoveMemory( ppsp, pTD->m_theirPSP, ppsp->dwSize );

        // call their callback
        ppsp->pfnCallback( hWnd, uMsg, ppsp );

        // change everything back
        MoveMemory( ppsp, td.m_theirPSP, ppsp->dwSize );
    }

    if( uMsg == PSPCB_RELEASE )
    {
        delete pTD; // delete my thunk data
        ppsp->lParam = NULL;
    }

    return 1;
}

INT_PTR CALLBACK ChainSubclassProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CThunkData* pTD = (CThunkData*)GetPropW( hwndDlg, L"IWizChain" );

    if( !pTD || (pTD->m_sig != (void*)pTD) )
    {
        return FALSE;   // this is bad....
    }

    // special thunking for PSN_WIZBACK, PSN_WIZNEXT
    if( uMsg == WM_NOTIFY ) 
    {
        NMHDR* pNMHDR = (NMHDR*)lParam;

        if( pNMHDR->code == PSN_SETACTIVE )
        {
            CChainWiz* pCW = pTD->m_pCW;
            assert( pCW != NULL );

            CPropertyPagePropertyBag* pCPPPBag = pCW->GetPPPBag( );
            assert( pCPPPBag != NULL );

            IAddPropertySheets* pThisAPSs = pTD->m_pAPSs;
            if( pThisAPSs != pCW->GetCurrentComponent( ) ) 
            {
                // crossed component boundary:
                pCW->SetPreviousComponent( pCW->GetCurrentComponent( ) );
                pCW->SetCurrentComponent( pThisAPSs );

                IAddPropertySheets* pLastAPSs = pCW->GetPreviousComponent( );
                
                // let previous guy write
                if( pLastAPSs ) 
                {
                    pCPPPBag->SetReadOnly( FALSE );
                    pCPPPBag->SetOwner( (DWORD)(LONG_PTR)pLastAPSs );
                    IPropertyPagePropertyBag* pOPPPBag = COwnerPPPBag::Create( pCPPPBag, (DWORD)(LONG_PTR)pLastAPSs );

                    if( pOPPPBag )
                    {
                        pLastAPSs->WriteProperties( pOPPPBag );
                        pOPPPBag->Release( );
                    }
                }

                // let current guy read
                if( pThisAPSs ) 
                {
                    pCPPPBag->SetReadOnly( TRUE );
                    pCPPPBag->SetOwner( PPPBAG_SYSTEM_OWNER );
                    IPropertyPagePropertyBag* pOPPPBag = COwnerPPPBag::Create( pCPPPBag, (DWORD)(LONG_PTR)pThisAPSs );

                    if( pOPPPBag )
                    {
                        pThisAPSs->ReadProperties( pOPPPBag );
                        pOPPPBag->Release( );
                    }
                }
            }
        } 
        else if( (pNMHDR->code == PSN_WIZBACK) || (pNMHDR->code == PSN_WIZNEXT) )
        {
            // MFC hack:
            // they don't set the DWL_MSGRESULT like they're supposed to!
            // instead, they just return the IDD
            // so, I'm gonna put a bogus value up there and check for it
            const LONG BOGUS_IDD = -10L;
            SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, (LONG_PTR)BOGUS_IDD );

            // fixup IDDs from PSN_WIZBACK, PSN_WIZNEXT
            LPARAM lparamTemp = CallWindowProc( pTD->m_theirWndProc, hwndDlg, uMsg, wParam, lParam );

            // get IDDs (maybe)
            LONG_PTR idd = GetWindowLongPtr( hwndDlg, DWLP_MSGRESULT );
            if( idd == BOGUS_IDD ) 
            {
                idd = lparamTemp;    // MFC hack:  see above.
                SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, idd );
            }

            // translate as necessary.
            switch (idd) 
            {
            case 0:
            case -1:
                {
                    break;
                }
            default:                
                {
                    // try to map idd to LPCDLGTEMPLATE
                    // if it fails, it must have been a LPCDLGTEMPLATE already
                    if( pTD->m_theirPSP )
                    {                        
                        LPDLGTEMPLATE lpdt = GetDialogTemplate( pTD->m_theirPSP->hInstance, (LPCWSTR)idd );

                        if( lpdt ) 
                        {
                            LPDLGTEMPLATE lpdt2 = pTD->m_pCW->GetAtlTemplate( lpdt );
                            
                            if( lpdt2 ) 
                            {
                                SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, (LONG_PTR)lpdt2 );
                                return (LPARAM)lpdt2;
                            } 
                            else 
                            {
                                SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, (LONG_PTR)lpdt );
                                return (LPARAM)lpdt;
                            }
                        }
                    }

                    break;
                }         
            }

            return lparamTemp;
        } 
        else if( pNMHDR->code == PSN_QUERYCANCEL )
        {
            CChainWiz* pCW = pTD->m_pCW;

            WCHAR wsz[2048];
            ::LoadStringW( (HINSTANCE)_Module.GetModuleInstance(), IDS_QUERYCANCEL, wsz, 2048 );
            return (IDYES != ::MessageBoxW( hwndDlg, wsz, (LPOLESTR)pCW->GetTitle (), MB_YESNO | MB_ICONWARNING ));
        }
    }

    return CallWindowProc( pTD->m_theirWndProc, hwndDlg, uMsg, wParam, lParam );
}

static LOGFONT g_lf;
static LPARAM  g_lp;
INT_PTR CALLBACK ChainDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    /*
        the first time we ever get into this function and have my CThunkData
        (this will be after the WM_SETFONT message, during WM_INITDIALOG),

        1.  subclass dlg hwnd
        2.  hang my    stuff off window prop
        3.  setup for atl hook discarding test
        4.  call their dlgproc

        Do thunking and PPPBag IO inside subclass function
    */    

    if( uMsg == WM_SETFONT )
    {
        // hang onto this so I can send it before WM_INITDIALOG
        HFONT hf = (HFONT)wParam;
        GetObject( (HGDIOBJ)hf, sizeof(g_lf), (void*)&g_lf );
        
        g_lp = lParam;
        return FALSE;
    }

    if( uMsg == WM_INITDIALOG ) 
    {
        // get my thunking data
        PROPSHEETPAGEW* psp = (PROPSHEETPAGEW*)lParam;
        CThunkData* pTD     = (CThunkData*)psp->lParam;

        if( pTD && pTD->m_theirPSP )
        {
            // 1.  subclass dlg hwnd
            pTD->m_theirWndProc = (WNDPROC)SetWindowLongPtr( hwndDlg, GWLP_WNDPROC, (LONG_PTR)ChainSubclassProc );

            // 2.  hang my stuff off window prop
            SetPropW( hwndDlg, L"IWizChain", (HANDLE)pTD );

            // 3.  see 5. below
            DLGPROC dlgproc = (DLGPROC)GetWindowLongPtr( hwndDlg, DWLP_DLGPROC );

            // 4.  call their dlgproc
            // first send 'em WM_SETFONT (see above)
            HFONT hf = CreateFontIndirect( &g_lf );
            if( hf ) 
            {
                pTD->m_theirPSP->pfnDlgProc( hwndDlg, WM_SETFONT, (WPARAM)hf, g_lp );
                DeleteObject( (HGDIOBJ)hf ); // should I delete this later? or now?
            }

            // 5.
            // atl has this great feature where they blindly subclass the hwndDlg
            // and throw the rest of 'em away.
            // I can detect this...
            if( dlgproc != (DLGPROC)GetWindowLongPtr( hwndDlg, DWLP_DLGPROC ) ) 
            {
                // re-subclass
                pTD->m_theirPSP->pfnDlgProc = (DLGPROC)SetWindowLongPtr( hwndDlg, DWLP_DLGPROC, (LONG_PTR)ChainDlgProc );
            }

            // then send 'em the WM_INITDIALOG
            return pTD->m_theirPSP->pfnDlgProc( hwndDlg, uMsg, wParam, (LPARAM)pTD->m_theirPSP );
        }
        else
        {
            return FALSE;
        }
    }

    CThunkData* pTD = (CThunkData*)GetPropW( hwndDlg, L"IWizChain" );

    if( !pTD || (pTD->m_sig != (void*)pTD) || !pTD->m_theirPSP )
    {
        return FALSE;
    }

    return pTD->m_theirPSP->pfnDlgProc( hwndDlg, uMsg, wParam, lParam );
}

static void ModifyStyleEx( HWND hwnd, DWORD dwRemove, DWORD dwAdd, UINT nFlags )
{
    // cloned from atl
	DWORD dwStyle    = ::GetWindowLongPtr( hwnd, GWL_EXSTYLE );
	DWORD dwNewStyle = (dwStyle & ~dwRemove) | dwAdd;

	if( dwStyle == dwNewStyle )
    {
		return;
    }

	::SetWindowLongPtr( hwnd, GWL_EXSTYLE, (LONG_PTR)dwNewStyle );
    ::SetWindowPos ( hwnd, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags );
}
static void ShowBorder( HWND hwnd, BOOL bBorder )
{
    if( bBorder )
    {
        ModifyStyleEx( hwnd, 0, WS_EX_CLIENTEDGE, SWP_FRAMECHANGED );
    }
    else
    {
        ModifyStyleEx( hwnd, WS_EX_CLIENTEDGE, 0, SWP_FRAMECHANGED );
    }
}

BOOL IsComctrlVersion6orGreater( )
{
    BOOL bVersion6 = FALSE;
    
    INITCOMMONCONTROLSEX init;
    ZeroMemory( &init, sizeof(init) );
    
    init.dwSize = sizeof(init);
    init.dwICC  = ICC_LINK_CLASS;    // This is the SysLink control in v6

    if( InitCommonControlsEx( &init ) )
    {
        bVersion6 = TRUE;
    }
    else
    {
        bVersion6 = FALSE;
    }

    return bVersion6;
}

INT_PTR CALLBACK FinishDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    // Note that this function is not calling DefWindowProc at the end.
    // Respect that otherwise things can be screwed up.
    CChainWiz* pCW = (CChainWiz*)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );

    switch( uMsg )
    {
    case WM_CLOSE:
        {
            // This will cover us when the focus is in the edit control and the user hits esc
            if( ::GetFocus() == GetDlgItem( hwndDlg, IDC_EDIT1 ) )
            {
                HWND hWndParent = ::GetParent( hwndDlg );
            
                if( hWndParent )
                {
                    ::SendMessage( hWndParent, PSM_PRESSBUTTON, PSBTN_CANCEL, 0 );
                }
            }

            break;
        }        

    case DM_GETDEFID:
        {
            // This will cover us when the focus is in the edit control and the user hits Enter
            if( ::GetFocus() == GetDlgItem( hwndDlg, IDC_EDIT1 ) )
            {
                HWND hWndParent = ::GetParent( hwndDlg );
            
                if( hWndParent )
                {
                    ::SendMessage( hWndParent, PSM_PRESSBUTTON, PSBTN_FINISH, 0 );
                }
            }

            break;
        }

    case WM_INITDIALOG:
        {
            PROPSHEETPAGEW* psp = (PROPSHEETPAGEW*)lParam;
            
            // get whatever's hanging on psp->lParam
            // and hang it on hwndDlg via SetWindowLong
            SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)psp->lParam );

            pCW = reinterpret_cast<CChainWiz*>(psp->lParam);

            if( pCW )
            {
                CString csLink;
                BOOL    bCommctrlV6 = IsComctrlVersion6orGreater();                
                RECT    rect;

                // Get the size of the static control 
                GetClientRect( GetDlgItem( hwndDlg, IDC_STATIC_3 ), &rect );

                // Map rect coordinates to the dialog
                MapWindowPoints( GetDlgItem( hwndDlg, IDC_STATIC_3 ), hwndDlg, reinterpret_cast<LPPOINT>(&rect), 2 );

                if( bCommctrlV6 )
                {
                    //
                    // if Comctrl version >= 6, we will stick to the Syslink control
                    //                    
                    pCW->m_hWndLink = CreateWindow( WC_LINK, NULL,  WS_CHILD | WS_VISIBLE | WS_TABSTOP, 
                                                    rect.left, rect.top,  (rect.right - rect.left), (rect.bottom - rect.top),
                                                    hwndDlg, NULL, NULL, NULL );                        
                }
                else
                {
                    // Will use rich edit control for the hyperlink
                    if( NULL == pCW->m_hModuleRichEdit)
                    {
                        TCHAR szSystemDirectory[MAX_PATH + 1];
                        szSystemDirectory[0] = NULL;

                        if (GetSystemDirectory(szSystemDirectory, MAX_PATH + 1))
                        {
                            if (PathAppend(szSystemDirectory, _T("RichEd20.dll")))
                            {
                                pCW->m_hModuleRichEdit = LoadLibrary(szSystemDirectory);
                            }
                        }
                    }

                    if (NULL != pCW->m_hModuleRichEdit)
                    {                        
                        pCW->m_hWndLink = CreateWindowEx( ES_MULTILINE, RICHEDIT_CLASS, NULL, 
                                                          WS_VISIBLE | WS_TABSTOP | WS_CHILD | ES_READONLY|ES_LEFT | ES_MULTILINE, 
                                                          rect.left, rect.top,  rect.right - rect.left, rect.bottom - rect.top,
                                                          hwndDlg, 0, _Module.GetModuleInstance(), NULL );

                        if( pCW->m_hWndLink )
                        {
                            // We want to recive ENM_LINK notifications
                            ::SendMessage( pCW->m_hWndLink, EM_SETEVENTMASK, 0, ENM_LINK ); 
                            
                            pCW->m_Hotlink.SubclassWindow( pCW->m_hWndLink );
                        }
                    }
                }                
            }

            break;
        }        

    case WM_COMMAND:
        {
            if( pCW ) 
            {
                switch( HIWORD( wParam ) ) 
                {
                default:
                    {
                        break;
                    }
                case EN_SETFOCUS:
                    {
                        if (LOWORD(wParam) == IDC_EDIT1) 
                        {
                            HWND hwnd = (HWND)lParam;
                            _ASSERT( IsWindow( hwnd ) );
                            ::SendMessage( hwnd, EM_SETSEL, 0, 0 );
                        }
                        
                        break;
                    }
                }
            }
            
            break;
        }

    case WM_NOTIFY:
        {
            if (pCW) 
            {
                // do something with notifies...
                NMHDR* pNMHDR = (NMHDR*)lParam;
                if( !pNMHDR )
                {
                    return FALSE;
                }

                switch( pNMHDR->code )
                {
                case NM_RETURN:
                case NM_CLICK:
                    {
                        if( pCW->m_hWndLink && pNMHDR->idFrom == GetDlgCtrlID(pCW->m_hWndLink) )
                        {
                            pCW->LaunchMoreInfo();
                        }
                        
                        break;
                    }

                case EN_LINK:
                    {
                        if( pCW->m_hWndLink )
                        {
                            if( (WM_LBUTTONDOWN == ((ENLINK*)lParam)->msg) || (WM_CHAR == ((ENLINK*)lParam)->msg) )
                            {
                                pCW->LaunchMoreInfo();
                            }
                        }
                        
                        break;
                    }                    

                case PSN_SETACTIVE:
                    {
                        // set font
                        ::SendMessage  ( GetDlgItem( hwndDlg, IDC_STATIC_1 ), WM_SETFONT, (WPARAM)pCW->GetBoldFont(), MAKELPARAM(TRUE, 0) );
                        
                        // set text
                        ::SetWindowText( GetDlgItem( hwndDlg, IDC_STATIC_1 ), (LPWSTR)pCW->GetFinishHeader()    );
                        ::SetWindowText( GetDlgItem( hwndDlg, IDC_STATIC_2 ), (LPWSTR)pCW->GetFinishSubHeader() );                                        

                        // get finish text from each component...
                        LPOLESTR szFinish   = NULL;
                        LPOLESTR szMoreInfo = NULL;
                        HRESULT  hr;
                        CString  csLink;

                        hr = pCW->GetAllFinishText( &szFinish, &szMoreInfo );

                        if( SUCCEEDED(hr) )
                        {
                            if( szFinish )
                            {
                                // ... and add to edit field
                                HWND hwnd = GetDlgItem( hwndDlg, IDC_EDIT1 );
                                if( hwnd )
                                {
                                    ShowScrollBar ( hwnd, SB_VERT, TRUE );
                                    SetWindowTextW( hwnd, szFinish );

                                    // hide vertical scroll if we don't need it
                                    SCROLLINFO si = {0};
                                    si.cbSize = sizeof(SCROLLINFO);
                                    si.fMask  = SIF_ALL;
                                    
                                    GetScrollInfo( hwnd, SB_VERT, &si );
                                    
                                    if( si.nMax < si.nPage ) 
                                    {
                                        ShowBorder   ( hwnd, FALSE );
                                        ShowScrollBar( hwnd, SB_VERT, FALSE );
                                    } 
                                    else
                                    {
                                        ShowBorder( hwnd, TRUE );
                                    }
                                }

                            }

                            if( szMoreInfo )
                            {
                                if( csLink.LoadString(IDS_LINK_TEXT_WITHINFO) )
                                {
                                    if( pCW->m_hWndLink )
                                    {
                                        ::SendMessage( pCW->m_hWndLink, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(static_cast<LPCTSTR>(csLink)) );
                                    
                                        pCW->WriteTempFile( szMoreInfo );
                                    }
                                }
                                
                                CoTaskMemFree( szMoreInfo );
                                szMoreInfo = NULL;
                            }
                            else
                            {
                                if( csLink.LoadString(IDS_LINK_TEXT) )
                                {
                                    if( pCW->m_hWndLink )
                                    {
                                        ::SendMessage( pCW->m_hWndLink, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(static_cast<LPCTSTR>(csLink)) );

                                        LPTSTR szMoreInfoHtml = NULL;

                                        hr = FinishTextToHTML( szFinish, &szMoreInfoHtml );
                                        if( SUCCEEDED(hr) )
                                        {
                                            pCW->WriteTempFile( szMoreInfoHtml );
                                            if( szMoreInfoHtml )
                                            {
                                                delete [] szMoreInfoHtml;
                                                szMoreInfoHtml = NULL;
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        //
                        // We need to disable the Back button on the finish page 
                        // if the wizard asked us to do so...
                        //

                        if ((pCW->m_dwWizardStyle) & CHAINWIZ_FINISH_BACKDISABLED)
                        {
	                        ::SendMessage(::GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH | (~PSWIZB_BACK));
                        }
                        else
                        {
	                        // setup buttons
	                        ::SendMessage( GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_FINISH );
                        }
                        
                        break;
                    }                    
                default:
                    {
                        break;
                    }
                }
            } //if( pCW )
            break;
        }   // WM_NOTIFY

    default:
        {
            break;
        }
    }

    return FALSE;
}

struct CDataHolder 
{
public:
    BSTR        m_szHeader;
    BSTR        m_szText;
    HFONT       m_hf;
    CChainWiz*  m_pCW;

    CDataHolder( LPOLESTR szHeader, LPOLESTR szText, HFONT hf, CChainWiz* pCW )
    {
        m_szHeader = SysAllocString( szHeader );
        m_szText   = SysAllocString( szText   );
        m_hf       = hf;
        m_pCW      = pCW;
    }

   ~CDataHolder( )
    {
        if( m_szHeader ) 
        {
            SysFreeString( m_szHeader );
        }

        if( m_szText )   
        {
            SysFreeString( m_szText );
        }
        
        // don't delete hf
    }
};

INT_PTR CALLBACK WelcomeDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg ) 
    {
    case WM_DESTROY:
        {
            CDataHolder* pdh = (CDataHolder*)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );

            if( pdh )
            {
                delete pdh;
            }

            SetWindowLongPtr( hwndDlg, GWLP_USERDATA, 0 );
        }
        break;

    case WM_INITDIALOG:
        {
            // center on desktop
            RECT r1;
            RECT r2;

            ::GetWindowRect( GetParent(hwndDlg), &r1 );
            ::GetWindowRect( GetDesktopWindow(), &r2 );

            int x = ((r2.right - r2.left) - (r1.right - r1.left)) / 2;
            int y = ((r2.bottom - r2.top) - (r1.bottom - r1.top)) / 2;

            ::MoveWindow( GetParent(hwndDlg), x, y, (r1.right - r1.left), (r1.bottom - r1.top), TRUE );

            PROPSHEETPAGEW* psp = (PROPSHEETPAGEW*)lParam;

            // get whatever's hanging on psp->lParam
            // and hang it on hwndDlg via SetWindowLong
            SetWindowLongPtr( hwndDlg, GWLP_USERDATA, (LONG_PTR)psp->lParam );

            // add the rest of the pages now:
            // this allows me to force all the pages to a
            // fixed size.
            CDataHolder* pdh = (CDataHolder*)psp->lParam;
            if( pdh ) 
            {
                HWND hwndParent = ::GetParent( hwndDlg );

                PropSheet_RemovePage( hwndParent, 1, NULL );

                PROPSHEETHEADERW* psh = pdh->m_pCW->GetPropSheetHeader();

                for( int i = 2; i < psh->nPages; i++ )
                {
                    PropSheet_AddPage( hwndParent, psh->phpage[i] );
                }
            }

            BOOL bCommctrlV6 = IsComctrlVersion6orGreater();

            if( bCommctrlV6 )
            {
                if( pdh && pdh->m_pCW )
                {
                    HWND hwnd = GetDlgItem( hwndDlg, IDC_STATIC_2 );
                    RECT rect;

                    // Get the size of the static control 
                    GetClientRect( hwnd, &rect );

                    // Map rect coordinates to the dialog
                    MapWindowPoints( hwnd, hwndDlg, reinterpret_cast<LPPOINT>(&rect), 2 );
                
                    pdh->m_pCW->m_hWndWelcomeLink = CreateWindow( WC_LINK, NULL,  WS_CHILD | WS_VISIBLE | WS_TABSTOP,
                                                            rect.left, rect.top, (rect.right - rect.left), (rect.bottom - rect.top),
                                                            hwndDlg, NULL, NULL, NULL );
                }
            }

            break;
        }        

    case WM_NOTIFY:
        {            
            NMHDR* pNMHDR = (NMHDR*)lParam;
            if( !pNMHDR )
            {
                return FALSE;
            }

            switch( pNMHDR->code )
            {
            case NM_RETURN:
            case NM_CLICK:
                {
                    // No links on the Welcome page for CYS.
                    break;
                }

            case PSN_SETACTIVE:
                {
                    CDataHolder* pdh = (CDataHolder*)GetWindowLongPtr( hwndDlg, GWLP_USERDATA );
                    if( pdh ) 
                    {
                        HWND hwnd;
                        if( pdh->m_szHeader ) 
                        {
                            hwnd = GetDlgItem( hwndDlg, IDC_STATIC_1 );
                            
                            if( hwnd )
                            {
                                // set font
                                ::SendMessage   ( hwnd, WM_SETFONT, (WPARAM)pdh->m_hf, MAKELPARAM(TRUE, 0) );
    
                                // set header text
                                ::SetWindowTextW( hwnd, (LPWSTR)pdh->m_szHeader );
                            }
                        }

                        if( pdh->m_szText )
                        {
                            hwnd = NULL;

                            if( pdh->m_pCW && pdh->m_pCW->m_hWndWelcomeLink )
                            {
                                hwnd = pdh->m_pCW->m_hWndWelcomeLink;
                            }
                            else
                            {
                                hwnd = GetDlgItem( hwndDlg, IDC_STATIC_2 );
                            }

                            if( hwnd )
                            {
                                ::SetWindowText( hwnd, pdh->m_szText );
                            }
                        }                        
                    }

					// 
					// If we show the link on the welcome page, it will have the keyboard focus
					// thus pressing enter will activate the link and launch the more info stuff
					// To work around this problem, we are telling the wizard (parent window)
					// to set the focus to the Next button in this particular case.
					//

					//
					// Make sure the keyboard focus is set to the Next button
					//

					HWND hWndParent = GetParent(hwndDlg);                
					if( hWndParent )
					{
						HWND hWndNext = GetDlgItem( hWndParent, IDD_NEXT );

						if( hWndNext )
						{
							// SendMessage will not work
							PostMessage( hWndParent, WM_NEXTDLGCTL, reinterpret_cast<WPARAM> (hWndNext), TRUE );
						}
					}
                    
                    ::SendMessage( GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT );
                    break;
                }
                
            default:
                {
                    break;
                }
            }

            break;
        } // WM_NOTIFY        

    default:
        {
            break;
        }
    }

    return FALSE;
}

INT_PTR CALLBACK DummyDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    // we should never get here!!!
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CChainWiz

STDMETHODIMP CChainWiz::Initialize( HBITMAP hbmWatermark, HBITMAP hbmHeader, LPOLESTR szTitle, LPOLESTR szWelcomeHeader, LPOLESTR szWelcomeText, LPOLESTR szFinishHeader, LPOLESTR szFinishIntroText, LPOLESTR szFinishText )
{
    // make sure this is called only once.
    if( m_psh )
    {
        return E_UNEXPECTED;
    }

    // validate parameters
    if( hbmWatermark != NULL )
    {
        if( GetObjectType( (HGDIOBJ)hbmWatermark ) != OBJ_BITMAP )
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    if( hbmHeader != NULL )
    {
        if( GetObjectType( (HGDIOBJ)hbmHeader ) != OBJ_BITMAP )
        {
            return ERROR_INVALID_PARAMETER;
        }
    }
    
    if ( !szTitle || !szWelcomeHeader || !szWelcomeText || !szFinishHeader || !szFinishIntroText || !szFinishText )
    {
        return E_POINTER;
    }

    HRESULT hr = S_OK;

    m_psh = new PROPSHEETHEADERW;
    
    if( !m_psh )
    {
        hr = E_OUTOFMEMORY;
    }
    else 
    {
        // save title in case a page doesn't have one.
        if (szTitle[0] == 0)
        {
            szTitle = L" "; // use space instead of empty string (for jmenter)
        }

        m_szWelcomeTitle        = SysAllocString( szTitle           );
        m_szFinishHeader        = SysAllocString( szFinishHeader    );
        m_szFinishSubHeader     = SysAllocString( szFinishIntroText );
        m_szFirstFinishTextLine = SysAllocString( szFinishText      );

        // create wizard (property sheet header) here
        ZeroMemory( m_psh, sizeof(PROPSHEETHEADERW) );
        m_psh->dwSize    = sizeof(PROPSHEETHEADERW);
        m_psh->dwFlags  |= PSH_WIZARD97;

        if( hbmWatermark ) 
        {
            m_psh->dwFlags       |= (PSH_USEHBMWATERMARK | PSH_WATERMARK);
            m_psh->hbmWatermark   = hbmWatermark;
        }
        
        if( hbmHeader ) 
        {
            m_psh->dwFlags       |= ( PSH_USEHBMHEADER | PSH_HEADER);
            m_psh->hbmHeader      = hbmHeader;
        }

        // make an array of HPROPSHEETPAGE FAR *phpage, to hold all the pages
        m_psh->phpage     = new HPROPSHEETPAGE[MAXPROPPAGES];   // just handles....
        m_psh->nPages     = 0;  // so far
        m_psh->nStartPage = 0;  // my Welcome page (see below)

        
        // TODO: do I need these?  may need to pass in more params...
        // ? HWND      hwndParent;
        // ? HINSTANCE hInstance;
        // not using PFNPROPSHEETCALLBACK pfnCallback;

        // create welcome page here from parameters above        
        PROPSHEETPAGEW psp;
        ZeroMemory( &psp, sizeof(psp) );
        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_HIDEHEADER;   // welcome page: use watermark
        psp.dwFlags    |= PSP_USETITLE;
        psp.pszTitle    = szTitle;
        psp.hInstance   = (HINSTANCE)_Module.GetModuleInstance();
        psp.pszTemplate = (LPCWSTR)MAKEINTRESOURCE(IDD_PROPPAGE_WELCOME);
        psp.pfnDlgProc  = WelcomeDlgProc;
        
        CDataHolder* pDataHolder = new CDataHolder( szWelcomeHeader, szWelcomeText, m_hf, this );
        if( !pDataHolder )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            psp.lParam      = (LPARAM)pDataHolder;       
            // ~CDataHolder is called after first PSN_SETACTIVE notification
            psp.pfnCallback = 0;        
        }

        if( SUCCEEDED(hr) )
        {
            hr = Add( &psp );        
        }
            
        if( SUCCEEDED(hr) )
        {   
            // add dummy entry to list of APSs
            CComPtr<IAddPropertySheets> spDummyAPS;
            CComponents* pComponents = new CComponents(spDummyAPS);
            
            spDummyAPS.Attach( CDummyComponent::Create(TRUE) ); // assignment causes AddRef !!!! so use Attach instead (!@$#$%&$%@!!!)

            if( !pComponents )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                m_listOfAPSs.push_back( pComponents );
            }
        }        

        if( hr == S_OK )
        {
            // now add a dummy property page so that sizing works right:
            // this page will be deleted, first thing, by WelcomeDlgProc.
            ZeroMemory( &psp, sizeof(psp) );
            psp.dwSize            = sizeof(psp);
            psp.dwFlags          |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
            psp.pszHeaderTitle    = MAKEINTRESOURCE(0);
            psp.pszHeaderSubTitle = MAKEINTRESOURCE(0);
            psp.hInstance         = (HINSTANCE)_Module.GetModuleInstance();
            psp.pszTemplate       = (LPCWSTR)MAKEINTRESOURCE(IDD_PROPPAGE_DUMMY);
            psp.pfnDlgProc        = DummyDlgProc;
            psp.lParam            = 0;
            psp.pfnCallback       = 0;

            hr = Add( &psp );
            // TODO: do I need to add to the list of APSs ???
        }
    }
	return hr;
}

STDMETHODIMP CChainWiz::AddWizardComponent( LPOLESTR szClsidOfComponent )
{
    // make sure wizard has been created (in Initalize, above)
    if( !m_psh ) return E_UNEXPECTED;

    // validate parameter(s)
    if( !szClsidOfComponent ) return E_POINTER;

    // convert string to clsid
    CLSID   clsid;
    HRESULT    hr   = S_OK;
    RPC_STATUS rpcs = CLSIDFromString( szClsidOfComponent, &clsid );
    
    if (rpcs == RPC_S_OK) 
    {
        // create wizard component
        IAddPropertySheets* pAPSs = NULL;
        hr = CoCreateInstance( clsid, NULL, CLSCTX_INPROC_SERVER, IID_IAddPropertySheets, (void **)&pAPSs);
        
        if( hr == S_OK )
        {
            SetCurrentComponent( pAPSs );

            CAddPropertySheet* pAPS = new CAddPropertySheet(this);

            if( !pAPS )
            {
                hr = E_OUTOFMEMORY;
            }
            else 
            {
                pAPS->AddRef();
                do 
                {
                    // call IAddPropertySheets::EnumPropertySheets until S_FALSE,
                    // adding pages to wizard
                    hr = pAPSs->EnumPropertySheets( pAPS );
                } while( hr == S_OK );

                pAPS->Release();

                if( hr == S_FALSE )
                {
                    hr = S_OK;  // S_FALSE means no more pages (not an error).
                }

                // hang onto pAPSs in order to:
                // 1. keep code in memory so that each pages dlgproc will work
                // 2. be able to call pAPSs->ProvideFinishText for finish page
                if( hr == S_OK )
                {
                    CComponents* pComponents = new CComponents(pAPSs);
                    if( !pComponents )
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        m_listOfAPSs.push_back( pComponents );
                    }
                }

                pAPSs->Release();   // not using this anymore, but have addref'd copies in my listofAPSs
            }
            SetCurrentComponent( NULL );
        }
    }

    return hr;
}

STDMETHODIMP CChainWiz::DoModal( long* ret )
{
    // make sure wizard has been created.
    if( !m_psh ) return E_UNEXPECTED;

    // validate parameter(s)
    if( !ret ) return E_POINTER;

    *ret = 0;

    // add finish page
    PROPSHEETPAGEW psp;
    ZeroMemory( &psp, sizeof(psp) );
    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_HIDEHEADER;   // finish page: use watermark
    psp.hInstance   = _Module.GetModuleInstance();
    psp.pszTemplate = (LPCWSTR)MAKEINTRESOURCE(IDD_PROPPAGE_FINISH);
    psp.pfnDlgProc  = FinishDlgProc;
    psp.lParam      = (LPARAM)this;
    
    HRESULT hr = Add (&psp);    // can't continue without a "Finish" button...

    {   // add dummy entry to list of APSs
        CComponents* pComponents = NULL;
        CComPtr<IAddPropertySheets> spDummyAPS;        
        spDummyAPS.Attach (CDummyComponent::Create (FALSE)); // assignment causes AddRef !!!! so use Attach instead (!@$#$%&$%@!!!)

        pComponents = new CComponents(spDummyAPS);
        if( !pComponents ) 
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            m_listOfAPSs.push_back ( pComponents );
        }
    }

    if( hr == S_OK )
    {
        // make a copy so I can muck with the count:
        // I need to do this so I can set a fixed size
        // for all the property pages.
        PROPSHEETHEADERW psh;
        memcpy( &psh, m_psh, sizeof(PROPSHEETHEADERW) );
        
        psh.nPages = 2; // welcome and dummy pages
        
        *ret = ::PropertySheet( &psh );

        // clean up: so that DoModal can't be called twice
        delete m_psh;
        m_psh = NULL;

        // also, clean up maps
        DestroyMaps();

        if( *ret == -1 )
        {
            hr = GetLastError();
        }
    }

    return hr;
}

#ifdef DEBUG
DLGITEMTEMPLATE* DumpItem( DLGITEMTEMPLATE* pdit )
{
    TCHAR szBuffer[256];

    wsprintf( szBuffer,
              _T("\n\nDialog Item:\nstyle: 0x%x\ndwExtendedStyle: 0x%x\nx, y: %d, %d\ncx, cy: %d, %d\nid: %d\n"), 
              pdit->style,
              pdit->dwExtendedStyle,
              pdit->x, pdit->y,
              pdit->cx, pdit->cy,
              pdit->id );
    
    OutputDebugString( szBuffer );

    WORD* pw = (WORD*)(pdit + 1);

    // window class:
    // WORD 0xffff => predefined system class (1 more word)
    // anything else => UNICODE string of class
    switch( *pw )
    {
    case 0xffff:
        {
            wsprintf (szBuffer, _T("predefined system class: %d\n"), pw[1] );
            OutputDebugString( szBuffer );
            pw += 2;
            break;
        }

    default:
        {
            OutputDebugString( _T("class: ") );
            OutputDebugStringW( pw );
            pw += wcslen( pw ) + 1;
            OutputDebugString( _T("\n") );
            break;
        }
    }

    // title
    // WORD 0xffff => 1 more word specifying resource id
    // anything else => UNICODE text
    switch( *pw )
    {
    case 0xffff:
        {
            wsprintf( szBuffer, _T("resource id: %d\n"), pw[1] );
            OutputDebugString( szBuffer );
            pw += 2;
            break;
        }
    default:
        {
            OutputDebugString( _T("text: ") );
            OutputDebugStringW( pw );
            pw += wcslen( pw ) + 1;
            OutputDebugString( _T("\n") );
            break;
        }
    }

    // creation data array
    // first word is size of array (in bytes)
    wsprintf( szBuffer, _T("%d bytes of creation data\n"), *pw );
	OutputDebugString( szBuffer );
    pw = 1 + (WORD*)(*pw + (BYTE*)pw);

    // DWORD align
    return (DLGITEMTEMPLATE*)(((DWORD_PTR)pw + 3) & ~DWORD_PTR(3));
}
void DumpTemplate( LPDLGTEMPLATE pdt )
{
    if( ((WORD *)pdt)[1] == 0xFFFF )
    {
        return;
    }

    TCHAR szBuffer[256];

    // dump info about DLGTEMPLATE
    wsprintf( szBuffer,
              _T("\n\nDialog Template:\nstyle: 0x%x\ndwExtendedStyle: 0x%x\ncdit: %d\nx, y: %d, %d\ncx, cy: %d, %d\n"), 
              pdt->style,
              pdt->dwExtendedStyle,
              pdt->cdit,
              pdt->x, pdt->y,
              pdt->cx, pdt->cy );
    OutputDebugString( szBuffer );

    WORD* pw = (WORD*)(pdt + 1);

    // menu:  0000 = no menu; ffff = menu id; else Unicode string
    switch( *pw ) 
    {
    case 0:
        {
            OutputDebugString( _T("no menu\n") );
            pw += 2;
            break;
        }
    case 0xFFFF:
        {
            pw++;
            wsprintf( szBuffer, _T("menu id: %d\n"), *(DWORD*)pw );
            OutputDebugString( szBuffer );
            pw += 2;
            break;
        }
    default:
        {
            OutputDebugStringW( pw );
            pw += wcslen( pw ) + 1;
            OutputDebugString( _T("\n") );
            break;
        }
    }

    // caption string:
    OutputDebugString( _T("caption: ") );
    OutputDebugStringW( pw );
    pw += wcslen( pw ) + 1;
    OutputDebugString( _T("\n") );

    // extra font information
    if (pdt->style & DS_SETFONT) 
    {
        // font size
        wsprintf( szBuffer, _T("font size: %d\n"), *pw++ );
        OutputDebugString( szBuffer );

        // typeface
        OutputDebugString( _T("typeface: ") );
        OutputDebugStringW( pw );
        pw += wcslen( pw ) + 1;
        OutputDebugString( _T("\n") );
    }

    // DWORD align
    DLGITEMTEMPLATE* pdit = (DLGITEMTEMPLATE*)(((DWORD_PTR)pw + 3) & ~DWORD_PTR(3));

    // dump all dlg items
    for( WORD i = 0; i < pdt->cdit; i++ )
    {
        pdit = DumpItem( pdit );
    }
}
#endif

INT_PTR CALLBACK SanityDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return FALSE;
}

HRESULT SanityTest( PROPSHEETPAGEW* psp )
{
    HRESULT hr = S_OK;
    
    assert( psp->dwFlags & PSP_DLGINDIRECT );

    LPCDLGTEMPLATE pdt = psp->pResource;

#ifdef DEBUG
    DumpTemplate( (LPDLGTEMPLATE)pdt );
#endif

    HWND hwndPage = CreateDialogIndirectParam( psp->hInstance, pdt, GetDesktopWindow(), SanityDlgProc, NULL );
    if( hwndPage )
    {
        DestroyWindow( hwndPage );
    }
    else 
    {
        hr = GetLastError();
        if( hr == S_OK )
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

HRESULT CChainWiz::Add( PROPSHEETPAGEW* psp )
{
    if( !psp )
    {
        return E_POINTER;
    }

    if( !psp->hInstance )
    {
        return ERROR_INVALID_PARAMETER;
    }

    // allocate my data to do thunking
    CThunkData* pTD = new CThunkData( this, psp, NULL, m_CurrentComponent );
    if( !pTD )
    {
        return E_OUTOFMEMORY;
    }
        
    // swap my data for their data
    DWORD dwFlags = psp->dwFlags;
    if( !(dwFlags & PSP_DLGINDIRECT) ) 
    {
        LPDLGTEMPLATE lpdt = GetDialogTemplate( psp->hInstance, psp->pszTemplate );
        if( lpdt )
        {
            psp->dwFlags  |= PSP_DLGINDIRECT;

            LPDLGTEMPLATE lpdt2 = _DialogSplitHelper::SplitDialogTemplate( (LPDLGTEMPLATE)lpdt, NULL );
            if( lpdt2 == lpdt )
            {
                psp->pResource = lpdt;
            }
            else 
            {
                psp->pResource = lpdt2;
                
                // add to map so I can remap resource id to new template ptr
                m_mapOfTemplates[lpdt] = lpdt2;
            }
        }        
    }

    psp->dwFlags    |= PSP_USECALLBACK | PSP_USETITLE;
    psp->pfnDlgProc  = ChainDlgProc;
    psp->lParam      = (LPARAM)pTD;
    psp->pfnCallback = ChainCallback;

    // this is not used in wizard pages....
    // remove it just in case comctl32.dll wants to use the hinstance that
    // I'm about to replace, below
    if( psp->dwFlags & PSP_USEICONID )
    {
        psp->dwFlags &= ~PSP_USEICONID;
    }

    // similarly, lock string resources (title, header, subtitle)
    if( !(psp->pszTitle     = DupStringResource (psp->hInstance, psp->pszTitle)) )
    {
        psp->pszTitle = _wcsdup (m_szWelcomeTitle); // use default from welcome page
    }

    psp->pszHeaderTitle    = DupStringResource( psp->hInstance, psp->pszHeaderTitle    );
    psp->pszHeaderSubTitle = DupStringResource( psp->hInstance, psp->pszHeaderSubTitle );

    // in order to get OCXs to be created we need:
    // 1.  to register AtlAxWin class (this is done in DllGetClassObject)
    // 2.  to pass our hinstance, not their's, as RegisterClass is not system-wide.
    // So, I've fixed up all resource ids to be pointers and so now can
    // replace their hinstance with mine.
    psp->hInstance = (HINSTANCE)_Module.GetModuleInstance();

    // run some sanity checks
    HRESULT hr = SanityTest( psp );
    if( hr != S_OK )
    {
        // oops!  something didn't work:
        // change everything back
        FreeStringResources( psp );

        if( pTD->m_theirPSP )
        {
            MoveMemory( psp, pTD->m_theirPSP, pTD->m_theirPSP->dwSize );
        }

        delete pTD; // won't be using this....

        return hr;
    }

    // create the page
    HPROPSHEETPAGE hpsp = CreatePropertySheetPage( psp );
    if( hpsp == NULL )
    {
        hr = GetLastError( );
        if( hr == S_OK ) // no docs on this....
        {
            hr = E_FAIL;
        }
    } 
    else 
    {
        // all is well
        m_psh->phpage[m_psh->nPages++] = hpsp;
    }

    // change everything back
    FreeStringResources( psp );
    MoveMemory( psp, pTD->m_theirPSP, pTD->m_theirPSP->dwSize );

    return hr;
}

HRESULT CChainWiz::GetAllFinishText(LPOLESTR* pstring, LPOLESTR* ppMoreInfoText )
{
    if( !pstring || !ppMoreInfoText )
    {
        return E_POINTER;
    }

    *pstring        = NULL;    // in case of errors
    *ppMoreInfoText = NULL;

    if( m_szFinishText ) 
    {
        CoTaskMemFree( m_szFinishText );
        m_szFinishText = NULL;
    }

    m_szFinishText = (LPOLESTR)CoTaskMemAlloc( 1 * sizeof(OLECHAR) );
    if( !m_szFinishText )
    {
        return E_OUTOFMEMORY;
    }

    m_szFinishText[0] = 0;  // so wcscat works
    OLECHAR szCRLF[]  = L"\r\n";
    DWORD dwSize      = 0;
    DWORD dwSizeMoreInfoText = 0;    
    
    // First line will precede any finish text from wizard components. 
    if( m_szFirstFinishTextLine && (0 < _tcslen( m_szFirstFinishTextLine )) ) 
    {
        dwSize += (sizeof(OLECHAR) * (wcslen( m_szFirstFinishTextLine ) + 1 )) + (sizeof(szCRLF) * 2);

        LPOLESTR szTemp = (LPOLESTR)CoTaskMemRealloc( m_szFinishText, dwSize );
        
        if( szTemp ) 
        {
            m_szFinishText = szTemp;
            wcscat( m_szFinishText, m_szFirstFinishTextLine );
            wcscat( m_szFinishText, szCRLF );
            wcscat( m_szFinishText, szCRLF );
        }
    }

    std::list<CComponents*>::iterator iterAPSs = m_listOfAPSs.begin();

    CComponents* pLastComp = *iterAPSs;
    for (CComponents* pComps = *iterAPSs; iterAPSs != m_listOfAPSs.end(); pComps = *++iterAPSs) 
    {
        if( pLastComp->GetComponent() == pComps->GetComponent() )
        {
            continue;       // look for unique APSs only
        }

        pLastComp = pComps; // for next time

        IAddPropertySheets* pAPSs = pComps->GetComponent();

        // have 'em re-read their properties (esp. read-write properties)
        m_PPPBag->SetReadOnly( TRUE );
        m_PPPBag->SetOwner   ( (LONG_PTR)pAPSs );

        IPropertyPagePropertyBag* pOPPPBag = COwnerPPPBag::Create( m_PPPBag, (LONG_PTR)pAPSs );
        if( pOPPPBag ) 
        {
            pAPSs->ReadProperties( pOPPPBag );
            pOPPPBag->Release();
        }

        m_PPPBag->SetReadOnly( FALSE );  // in case committers want to write

        // get the finish text
        LPOLESTR szFinishPiece   = NULL;
        LPOLESTR szMoreInfoPiece = NULL;

        pAPSs->ProvideFinishText( &szFinishPiece, &szMoreInfoPiece );

        if( szFinishPiece ) 
        {
            dwSize += (sizeof(OLECHAR) * (wcslen( szFinishPiece ) + 1)) + sizeof(szCRLF);

            LPOLESTR szTemp = (LPOLESTR)CoTaskMemRealloc( m_szFinishText, dwSize );

            if (szTemp) 
            {
                m_szFinishText = szTemp;
                wcscat( m_szFinishText, szFinishPiece );
                wcscat( m_szFinishText, szCRLF );
            }

            CoTaskMemFree( szFinishPiece );
        }

        if( szMoreInfoPiece )
        {
            dwSizeMoreInfoText += (sizeof(OLECHAR) * (wcslen(szMoreInfoPiece) + 1)) + sizeof(szCRLF);

            LPOLESTR szTemp = (LPOLESTR)CoTaskMemRealloc( *ppMoreInfoText, dwSizeMoreInfoText );

            if( szTemp )
            {
                *ppMoreInfoText = szTemp;
                wcscat( *ppMoreInfoText, szMoreInfoPiece );
                wcscat( *ppMoreInfoText, szCRLF );
            }

            CoTaskMemFree( szMoreInfoPiece );
        }
    }

    *pstring = m_szFinishText;
    return S_OK;
}

STDMETHODIMP CChainWiz::get_PropertyBag( IDispatch** pVal )
{
    if( !pVal ) return E_POINTER;

    *pVal = NULL;

    HRESULT hr = S_OK;

    // don't give anybody a raw bag:  wrap it up in an owner bag
    IPropertyPagePropertyBag* pOPPPBag = COwnerPPPBag::Create( m_PPPBag, PPPBAG_SYSTEM_OWNER );
    if( !pOPPPBag )
    {
        hr = E_OUTOFMEMORY;
    }
    else 
    {
        hr = pOPPPBag->QueryInterface( IID_IDispatch, (void**)pVal );
        pOPPPBag->Release();
    }

    return hr;
}

STDMETHODIMP CChainWiz::get_MoreInfoFileName( BSTR* pbstrMoreInfoFileName )
{
    if( !pbstrMoreInfoFileName ) return E_POINTER;

    HRESULT hr = S_OK;

    if( NULL == m_bstrTempFileName )
    {
        return E_UNEXPECTED;
    }
    else
    {
        *pbstrMoreInfoFileName = SysAllocString( m_bstrTempFileName );

        if( NULL == *pbstrMoreInfoFileName )
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

STDMETHODIMP CChainWiz::put_WizardStyle(VARIANT * pVarWizardStyle)
{
    if (NULL == pVarWizardStyle)
    {
	    return E_POINTER;
    }

    if (VT_UI4 != V_VT(pVarWizardStyle))
    {
	    return E_INVALIDARG;
    }


    m_dwWizardStyle = V_UI4(pVarWizardStyle);

    return S_OK;
}

HRESULT CChainWiz::WriteTempFile( LPCTSTR pszText )
{
    if( !pszText ) return E_POINTER;

    HRESULT hr   = S_OK;
    HANDLE hFile = NULL;
    TCHAR szTempFileName[MAX_PATH] = {0};
    BOOL bGenerateFileName = FALSE;

    if( NULL == m_bstrTempFileName )
    {
        bGenerateFileName = TRUE;
    }
    else
    {
        szTempFileName[MAX_PATH - 1] = NULL;
        _tcsncpy(szTempFileName, m_bstrTempFileName, MAX_PATH);
        
        if (NULL != szTempFileName[MAX_PATH - 1])
        {
            hr = E_UNEXPECTED;
        }
    }

    hFile = _CreateTempFile( szTempFileName, _T(".html"), bGenerateFileName );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }    
    else
    {
        if( 0 == _tcslen( szTempFileName ) )
        {
            hr = E_UNEXPECTED;
        }
    }

    if( SUCCEEDED(hr) )
    {
        DWORD dwcBytesWritten;

#ifdef UNICODE
		// write UNICODE signature
        // IE is doing fine without this but, anyway...

		unsigned char sig[2] = { 0xFF, 0xFE };
		
        if( !WriteFile( hFile, reinterpret_cast<LPVOID>(sig), 2, &dwcBytesWritten, NULL ) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
#endif
        
        if( SUCCEEDED(hr) )
        {
            if( !WriteFile( hFile, pszText, (sizeof(TCHAR) * _tcslen( pszText )), &dwcBytesWritten, NULL ) )
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        m_bstrTempFileName = SysAllocString(szTempFileName);

        if (NULL == m_bstrTempFileName)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if( hFile )
    {
        CloseHandle( hFile );
    }

    return hr;
}

HRESULT CChainWiz::LaunchMoreInfo( )
{
    HRESULT hr = S_OK;

    if( !m_bstrTempFileName )
    {
        return E_FAIL;
    }

    INT_PTR hRet = (INT_PTR)ShellExecute( NULL, _T("open"), m_bstrTempFileName, NULL, _T("."), SW_SHOW );

    if( 32 >= hRet )
    {
        hr = E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\propsht.h ===
// PropSht.h: Definition of the CAddPropertySheet class
//
//////////////////////////////////////////////////////////////////////

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

#include "ChainWiz.h"

/////////////////////////////////////////////////////////////////////////////
// CAddPropertySheet

class CAddPropertySheet : 
    public IAddPropertySheet
{

private:
    CChainWiz * m_pCW;
    ULONG m_refs;

public:
    CAddPropertySheet(CChainWiz * pCW)
    {
        m_pCW = pCW;
        m_refs = 0;
    }

// IAddPropertySheet
public:
    STDMETHOD (QueryInterface)( REFIID riid, void** ppvObject );
    STDMETHOD_(ULONG, AddRef) ( );
    STDMETHOD_(ULONG, Release)( );
    STDMETHOD (AddPage)       ( /*[in]*/ PROPSHEETPAGEW* psp );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\propitem.h ===
// PropItem.h : Declaration of the CPropertyItem

#ifndef __PROPERTYITEM_H_
#define __PROPERTYITEM_H_

#include "resource.h"       // main symbols

#include "pppbag.h"

/////////////////////////////////////////////////////////////////////////////
// CPropertyItem
class ATL_NO_VTABLE CPropertyItem : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IPropertyItem, &IID_IPropertyItem, &LIBID_WIZCHAINLib>
{

private:
    VARIANT     m_var;
    PPPBAG_TYPE m_dwFlags;
    BSTR        m_bstrName;

public:
    CPropertyItem( )
    {
        VariantInit (&m_var);
        m_dwFlags  = PPPBAG_TYPE_UNINITIALIZED;
        m_bstrName = NULL;
    }

    HRESULT Initialize( BSTR bstrName, VARIANT * v, PPPBAG_TYPE dwFlags )
    {
        // should be called only once
        assert (m_bstrName == NULL);
        assert (m_var.vt   == VT_EMPTY);

        HRESULT hr = S_OK;

        m_dwFlags  = dwFlags;
        hr = VariantCopy( &m_var, v );

        if( hr == S_OK )
        {
           if( !(m_bstrName = SysAllocString (bstrName)) )
           {
               hr = E_OUTOFMEMORY;
           }
        }
        return hr;
    }

   ~CPropertyItem( )
    {
        VariantClear( &m_var );

        if( m_bstrName )
        {
            SysFreeString( m_bstrName );
        }
    }

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPropertyItem)
    COM_INTERFACE_ENTRY(IPropertyItem)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IPropertyItem
public:
    virtual HRESULT STDMETHODCALLTYPE get_Value( /*[out, retval]*/ VARIANT *varValue );
    virtual HRESULT STDMETHODCALLTYPE get_Name ( /*[out, retval]*/ BSTR *strName );
    virtual HRESULT STDMETHODCALLTYPE get_Type ( /*[out, retval]*/ long *dwFlags );
};

#endif //__PROPERTYITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\propsht.cpp ===
// PropSht.cpp : Implementation of CWizChainApp and DLL registration.

#include "stdafx.h"

#include "WizChain.h"
#include "PropSht.h"

/////////////////////////////////////////////////////////////////////////////
//
// IUnknown

HRESULT CAddPropertySheet::QueryInterface( REFIID riid, void** ppvObject )
{
    HRESULT hr = S_OK;

    if( (riid == IID_IUnknown) || (riid == IID_IAddPropertySheet) )
    {
        AddRef();
        *ppvObject = (void*)this;
    } 
    else
    {
        hr = E_NOINTERFACE;
    }
    return hr;
}

ULONG CAddPropertySheet::AddRef( )
{
    InterlockedIncrement( (PLONG)&m_refs );
    return m_refs;
}
ULONG CAddPropertySheet::Release( )
{
    InterlockedDecrement( (PLONG)&m_refs );

    ULONG l = m_refs;

    if( m_refs == 0 )
    {
        delete this;
    }
    
    return l;
}

STDMETHODIMP CAddPropertySheet::AddPage( PROPSHEETPAGEW *psp )
{
    return m_pCW->Add( psp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wizchain.rc
//

#define IDR_CHAINWIZ                    100
#define IDR_STATUSDLG                   101
#define IDR_AddPropertySheet            102
#define IDR_PROPERTYPAGEPROPERTYBAG     103
#define IDR_WIZARDSCRIPTINGENGINE       104
#define IDR_PROPERTYCOLLECTION          105
#define IDR_STATUSPROGRESS              106

#define IDD_PROPPAGE_WELCOME            200
#define IDD_PROPPAGE_FINISH             201
#define IDD_PROPPAGE_DUMMY              202
#define IDD_DIALOG                      203
#define IDD_DIALOG1                     204
#define IDD_STATUSDIALOG                205

#define IDC_STATIC_1                    300
#define IDC_STATIC_2                    301
#define IDC_STATIC_3                    302
#define IDC_STATIC1                     303
#define IDC_STATIC2                     304
#define IDC_STATIC3                     305
#define IDC_EDIT1                       306
#define IDC_STATIC_OVERALL              307
#define IDC_STATIC_COMPONENT            308
#define IDC_LIST1                       309
#define IDC_LIST2                       310
#define IDC_BUTTON1                     311
#define IDC_PROGRESS1                   312
#define IDC_PROGRESS2                   313

#define IDB_BITMAP1                     400

#define IDS_STATUS_SUCCESS              500
#define IDS_STATUS_FAIL                 501


#define IDS_WIZARD97_FONT               6000
#define IDS_PROJNAME                    8100
#define IDS_ADDPROPERTYSHEET_DESC       8101

#define IDS_HERE                        1200
#define IDS_LINK_TEXT                   1201
#define IDS_LINK_TEXT_WITHINFO          1202
#define IDS_OK                          1203
#define IDS_QUERYCANCEL                 1204

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        1205
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         314
#define _APS_NEXT_SYMED_VALUE           114
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\statsdlg.cpp ===
// StatsDlg.cpp : Implementation of CStatusDlg
#include "stdafx.h"

#include "WizChain.h"
#include "StatsDlg.h"

// This is the thread that displays the status dialog
DWORD WINAPI DialogThreadProc( LPVOID lpv )
{
    HRESULT hr;

    CStatusDlg * pSD = (CStatusDlg *)lpv;

    // Increment the ref count so that the object does not disappear when the user releases it
    hr = pSD->AddRef();
    if( SUCCEEDED(hr) && pSD )
    {
        pSD->DoModal(NULL); 
    }

    // Decrement the ref count
    pSD->Release();    
    return 0;
}

STDMETHODIMP CStatusDlg::AddComponent( BSTR bstrComponent, long * plIndex )
{
    HRESULT hr = S_OK;

    // If the dialog is already displayed
    // we are not accepting new components

    if( m_hThread )
        return E_UNEXPECTED; 

    // Validate the arguments

    if( NULL == bstrComponent || NULL == plIndex )
        return E_INVALIDARG;

    // Get a new index
    long lNewIndex = m_mapComponents.size();
    if( m_mapComponents.find(lNewIndex) == m_mapComponents.end() )
    {
        // Add the new component 
        BSTR bstrNewComponent = SysAllocString(bstrComponent);        
        if( bstrNewComponent )
        {
            m_mapComponents.insert(COMPONENTMAP::value_type(lNewIndex, bstrNewComponent));
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_UNEXPECTED;  // This cannot happen!
    }

    if( SUCCEEDED(hr) )
    {
        *plIndex = lNewIndex;
    }
    
    return hr;
}


STDMETHODIMP CStatusDlg::Initialize( BSTR bstrWindowTitle, BSTR bstrWindowText, VARIANT varFlags )
{
    HRESULT hr = S_OK;

    // If the dialog is already displayed
    // do not allow to reinitialize 
    
    if( m_hThread ) return E_UNEXPECTED;
    if( !bstrWindowTitle || !bstrWindowText ) return E_INVALIDARG;
    if( VT_I2 != V_VT(&varFlags) && VT_I4 != V_VT(&varFlags) ) return E_INVALIDARG;
    
    if( VT_I2 == V_VT(&varFlags) ) 
    {
        m_lFlags = (long) varFlags.iVal;
    }
    else 
    {
        m_lFlags = varFlags.lVal;
    }
     
    if( SUCCEEDED(hr) )
    {
        // Initialize the common control library
        INITCOMMONCONTROLSEX initCommonControlsEx;
        initCommonControlsEx.dwSize = sizeof(initCommonControlsEx);
        initCommonControlsEx.dwICC = ICC_PROGRESS_CLASS | ICC_LISTVIEW_CLASSES;

        if( !::InitCommonControlsEx(&initCommonControlsEx) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if( SUCCEEDED(hr) )
    {
        if( bstrWindowTitle )
        {
            m_strWindowTitle = bstrWindowTitle; // Status Dialog Title
        }

        if( bstrWindowText )
        {
            m_strWindowText = bstrWindowText;   // Status Dialog Text 
        }
    }

    return hr;
}

STDMETHODIMP CStatusDlg::SetStatus(long lIndex, SD_STATUS lStatus)
{
    HRESULT hr = S_OK;
    BOOL    bToggleActive = FALSE;
    COMPONENTMAP::iterator compIterator;
    
    // Validate the arguments
    if( (SD_STATUS_NONE > lStatus) || (SD_STATUS_RUNNING < lStatus) ) 
    {
        return E_INVALIDARG;
    }

    compIterator = m_mapComponents.find(lIndex);

    if( compIterator == m_mapComponents.end() )
    {
        return E_INVALIDARG;    // Cannot find the component
    }
        
    if( IsWindow() )
    {
        if( m_pProgressList )
        {
            CProgressItem * pPI;            
            compIterator = m_mapComponents.begin();

            // Make sure that no component has status "running"
            while( compIterator != m_mapComponents.end() )
            {
                pPI = m_pProgressList->GetProgressItem(compIterator->first);

                if( pPI && pPI->m_bActive )
                {
                    m_pProgressList->ToggleActive(compIterator->first);
                }

                compIterator++;
            }

            if( SD_STATUS_RUNNING == lStatus )
            {
                m_pProgressList->ToggleActive(lIndex); // New status is "running"
            }
            else
            {                
                // Update the state of the component on the Listview
                m_pProgressList->SetItemState(lIndex, (ItemState) lStatus);

                // If the component's done, update the total progress
                if( (lStatus == SD_STATUS_SUCCEEDED) || (lStatus == SD_STATUS_FAILED) )
                {
                    // TO DO: No need to do this, just send a message to the dialog to do that                        
                    PBRANGE range;
                    SendDlgItemMessage(IDC_PROGRESS1, PBM_GETRANGE, FALSE, (LPARAM) &range);
                    SendDlgItemMessage(IDC_PROGRESS1, PBM_SETPOS, range.iHigh, 0);
                    InterlockedExchangeAdd(&m_lTotalProgress, range.iHigh);
                }
            }
        }
        else
        {
            hr = E_UNEXPECTED;
        }

        if( SUCCEEDED(hr) )
        {
            SetupButtons( );
        }
        
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

void CStatusDlg::SetupButtons( )
{
    HWND hWnd = NULL;
    HWND hWndOK = NULL;
    HWND hWndCancel = NULL;

    CString csText;

    BOOL bFailed = FALSE;

    BSTR bstrText = NULL;

    USES_CONVERSION;

    hWndOK = GetDlgItem(IDOK);
    hWndCancel = GetDlgItem(IDCANCEL);

    if( IsWindow() && hWndOK && hWndCancel )
    {
        if( AreAllComponentsDone(bFailed) )
        {
            // Enable OK button
            ::EnableWindow(hWndOK, TRUE);
                
            // Disable Cancel button
            ::EnableWindow(hWndCancel, FALSE);

            // Default button is the Close button
            ::SendMessage(m_hWnd, WM_NEXTDLGCTL, (WPARAM) hWndOK, 1);

            //
            // When all components are done we will hide the progress bars to give the user 
            // a visual clue to realize that the wizard is done. I know, that sounds stupid.
            //

            hWnd = GetDlgItem(IDC_STATIC2); // Component progress text

            if (NULL != hWnd)
            {
                ::ShowWindow(hWnd, SW_HIDE);
            }

            hWnd = GetDlgItem(IDC_PROGRESS1); // Component progress text

            if (NULL != hWnd)
            {
                ::ShowWindow(hWnd, SW_HIDE);
            }

            hWnd = GetDlgItem(IDC_STATIC3); // Overall progress text

            if (NULL != hWnd)
            {
                ::ShowWindow(hWnd, SW_HIDE);
            }

            hWnd = GetDlgItem(IDC_PROGRESS2); // Overall progress

            if (NULL != hWnd)
            {
                ::ShowWindow(hWnd, SW_HIDE);
            }

            if (FALSE == bFailed)
            {
                if (csText.LoadString(IDS_STATUS_SUCCESS))
                {
                    bstrText = T2BSTR(csText);

                    if (NULL != bstrText)
                    {
                        SetStatusText(bstrText);
                    }
               
                }
            }
            else
            {
                if (csText.LoadString(IDS_STATUS_FAIL))
                {
                    bstrText = T2BSTR(csText);

                    if (NULL != bstrText)
                    {
                        SetStatusText(bstrText);
                    }
                }
            }

            if (NULL != bstrText)
            {
                ::SysFreeString(bstrText);
            }
        }
        else
        {
            // Disable OK button
            ::EnableWindow( hWndOK, FALSE );

            if( m_lFlags & SD_BUTTON_CANCEL )
            {
                ::EnableWindow( hWndCancel, TRUE );
            }
        }
    }
}

STDMETHODIMP CStatusDlg::Display( BOOL bShow )
{
    HRESULT hr = S_OK;

    if( bShow )
    {
        if( m_hThread != NULL )
        {
            if( !IsWindowVisible() )  // We are already on
            {
                ShowWindow(SW_SHOW); 
            }
        }
        else
        {
            // Create a new thread which will DoModal the status dialog
            m_hThread = CreateThread( NULL, 0, DialogThreadProc, (void *) this, 0, NULL );
            
            if( NULL == m_hThread )
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else if( m_hDisplayedEvent ) // Wait till the dialog is displayed
            {
                if( WAIT_OBJECT_0 != WaitForSingleObject(m_hDisplayedEvent, INFINITE) ) 
                {
                    hr = E_UNEXPECTED;
                }
            }
        }
    }    
    else
    {
        // Will close the dialog
        if( m_hThread != NULL )
        {
            EndDialog(IDCANCEL);

            WaitForSingleObject(m_hThread, INFINITE);
        }            
    }

    return hr;
}


// The wizard writer should call this function to wait on user response
// If the user has already responded: clicked OK or Cancel 
// then this method will return immediately
STDMETHODIMP CStatusDlg::WaitForUser( )
{
    if( m_hThread )
    {
        WaitForSingleObject(m_hThread, INFINITE);
    }

    return S_OK;
}

STDMETHODIMP CStatusDlg::get_Cancelled( BOOL *pVal )
{
    if( NULL == pVal )
    {
        return E_INVALIDARG;
    }

    if( m_lFlags & SD_BUTTON_CANCEL )
    {
        if( m_iCancelled == 0 )
        {
            *pVal = FALSE;
        }
        else
        {
            *pVal = TRUE;
        }
    }
    else
    {
        *pVal = FALSE;
    }

    return S_OK;
}

STDMETHODIMP CStatusDlg::get_ComponentProgress( IStatusProgress** pVal )
{
    HRESULT hr = S_OK;

    if( NULL == pVal )
    {
        return E_INVALIDARG;
    }
    
    if( m_lFlags & SD_PROGRESS_COMPONENT )
    {
        // Create component progress object
        if( m_pComponentProgress == NULL )
        {
            hr = CComObject<CStatusProgress>::CreateInstance(&m_pComponentProgress);

            if( SUCCEEDED(hr) )
            {
                hr = m_pComponentProgress->AddRef();
            }        

            if( SUCCEEDED(hr) && IsWindow() )
            {    
                // Initialize the component progress with the progress bar handle
                hr = m_pComponentProgress->Initialize(this, GetDlgItem(IDC_PROGRESS1), FALSE);
            }
        }
            
        if( SUCCEEDED(hr) )
        {
            hr = (m_pComponentProgress->QueryInterface(IID_IStatusProgress, (void **) pVal));
        }                
    } 
    
    return hr;
}

LRESULT CStatusDlg::OnInitDialog( UINT uint, WPARAM wparam, LPARAM lparam, BOOL& bbool ) 
{
    HWND    hWndText            = GetDlgItem(IDC_STATIC1);
    HWND    hWndLV              = GetDlgItem(IDC_LIST2);
    HWND    hWndCompText        = GetDlgItem(IDC_STATIC2);
    HWND    hWndCompProgress    = GetDlgItem(IDC_PROGRESS1);
    HWND    hWndOverallText     = GetDlgItem(IDC_STATIC3);
    HWND    hWndOverallProgress = GetDlgItem(IDC_PROGRESS2);
    HWND    hWndOK              = GetDlgItem(IDOK);
    HWND    hWndCancel          = GetDlgItem(IDCANCEL);    

    LOGFONT     logFont;
    HIMAGELIST  hILSmall;
    HBITMAP     hBitmap;
    HDC         hDC;
    TEXTMETRIC  tm;
    RECT        rect;
    CWindow     wnd;

    int iResizeLV   = 0;
    int iResize     = 0;

    // Attach to the Listview
    wnd.Attach(hWndLV);
    wnd.GetWindowRect(&rect);
    hDC = GetDC();
    GetTextMetrics(hDC, &tm);
    ReleaseDC(hDC);

    // Check if size of the list view is OK enough to hold all the components
    iResizeLV = rect.bottom - rect.top - ((tm.tmHeight + 2) * (m_mapComponents.size() + 1));

    // Depending on the options selected, decide whether the stus dialog will shrink or expand
    if( (m_lFlags & SD_PROGRESS_COMPONENT) && !(m_lFlags & SD_PROGRESS_OVERALL) )
    {
       iResize = GetWindowLength(hWndOverallText, hWndOverallProgress);
    }
    else if( !(m_lFlags & SD_PROGRESS_COMPONENT) && (m_lFlags & SD_PROGRESS_OVERALL) )
    {
        iResize = GetWindowLength(hWndCompText, hWndCompProgress);
    }
    else if( !(m_lFlags & SD_PROGRESS_COMPONENT) && !(m_lFlags & SD_PROGRESS_OVERALL) )
    {
        iResize = GetWindowLength(hWndCompText, hWndOverallProgress);
    }

    // Hide component progress if necessary
    if( !(m_lFlags & SD_PROGRESS_COMPONENT) )
    {
       ::ShowWindow(hWndCompText, SW_HIDE);
       ::ShowWindow(hWndCompProgress, SW_HIDE);
    }

    // Hide overall progress if necessary
    if( !(m_lFlags & SD_PROGRESS_OVERALL) )
    {
       ::ShowWindow(hWndOverallText, SW_HIDE);
       ::ShowWindow(hWndOverallProgress, SW_HIDE);
    }

    if ((!(m_lFlags & SD_PROGRESS_OVERALL)) || (!(m_lFlags & SD_PROGRESS_COMPONENT)))
    {        
        // We need to get rid of the space between the progress bars        
        iResize -= GetWindowLength(hWndCompText, hWndOverallProgress) - GetWindowLength(hWndOverallText, hWndOverallProgress) - GetWindowLength(hWndCompText, hWndOverallProgress) + 4;
    }

    // Well, we may need to make LV bigger, but the dialog length could stay the same
    // if the user does not want component and/or overall progress
    if( iResizeLV < 0 )  // Will need to make the LV bigger
    {
        iResize += iResizeLV;
    }
    else
    {
        iResizeLV = 0;  // We will not touch the LV
    }

    
    if( iResizeLV != 0 || iResize != 0 ) // We will need to do some moving and resizing
    {
        VerticalResizeWindow(m_hWnd, iResize);
        VerticalMoveWindow(hWndOK, iResize);
        VerticalMoveWindow(hWndCancel, iResize);

        // Location of progress bars completely depend on the resizing of the LV
        VerticalMoveWindow(hWndOverallText, iResizeLV);  
        VerticalMoveWindow(hWndOverallProgress, iResizeLV);
        VerticalMoveWindow(hWndCompText, iResizeLV);
        VerticalMoveWindow(hWndCompProgress, iResizeLV);

        // Last, but not the least, resize the LV
        VerticalResizeWindow(hWndLV, iResizeLV);
    }
    
    if( !(m_lFlags & SD_BUTTON_CANCEL) ) // We will only have an OK button
    {
        LONG_PTR dwStyle = ::GetWindowLongPtr( m_hWnd, GWL_STYLE );
        if( 0 != dwStyle )
        {
            // Get rid of the System Menu (Close X) as well
            dwStyle &= ~WS_SYSMENU; 
            ::SetWindowLongPtr( m_hWnd, GWL_STYLE, dwStyle );
        }

        ReplaceWindow(hWndCancel, hWndOK);
    }

    // if we only have overall progress, we need to move it up
    // so that it replaces the component progress
    if( (m_lFlags & SD_PROGRESS_OVERALL) && !(m_lFlags & SD_PROGRESS_COMPONENT) )
    {
        ReplaceWindow(hWndCompText, hWndOverallText);
        ReplaceWindow(hWndCompProgress, hWndOverallProgress);
    }

    // Set some style for the LV
    ::SendMessage(hWndLV, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_SUBITEMIMAGES);
    ::SendMessage(hWndLV, LVM_SETBKCOLOR, 0, (LPARAM) CLR_NONE);
    ::SendMessage(hWndLV, LVM_SETTEXTBKCOLOR, 0, (LPARAM) CLR_NONE); 
        
    LVCOLUMN col;
    ZeroMemory (&col, sizeof(col));
    col.mask    = LVCF_WIDTH;
    col.cx      = 500;

    SendMessage( hWndLV, LVM_INSERTCOLUMN, 0, (LPARAM)&col );

    // Thanks to Jeffzi
    m_pProgressList->Attach( hWndLV );
    COMPONENTMAP::iterator compIterator;
    
    compIterator = m_mapComponents.begin();          
    while( compIterator != m_mapComponents.end() )
    {
        // Add each component to the LV
        m_pProgressList->AddItem(compIterator->second);
        m_pProgressList->SetItemState(compIterator->first, IS_NONE, FALSE );
        compIterator++;
    }

    if( m_pComponentProgress )
    {
        // Initialize the component progress with the progress bar handle
        m_pComponentProgress->Initialize( this, hWndCompProgress, FALSE );
    }

    if (m_pOverallProgress)
    {
        // Initialize the overall progress with the progress bar handle
        m_pOverallProgress->Initialize( this, hWndOverallProgress, TRUE );
    }

    // Here comes the dialog title and text
    SetWindowText(m_strWindowTitle.c_str());
    ::SetWindowText(hWndText, m_strWindowText.c_str());
    SetupButtons();
    
    // Center the window, no Jeff this works just right if you have 2 monitors
    CenterWindow();
   
    if( m_hDisplayedEvent )
    {
        SetEvent(m_hDisplayedEvent);
    }

    return TRUE;
}

BOOL CStatusDlg::VerticalMoveWindow( HWND hWnd, int iResize )
{
    BOOL bRet;
    CWindow wnd;
    RECT rect;

    wnd.Attach( hWnd );   // Returns void

    if(wnd.GetWindowRect(&rect) )
    {
        rect.top -= iResize;
        rect.bottom -= iResize;

        // GetWindowRect fills in RECT relative to the desktop
        // We need to make it relative to the dialog
        // as MoveWindow works that way
        if( ScreenToClient(&rect) )
        {
            bRet = wnd.MoveWindow(&rect);
        }
        else
        {
            bRet = FALSE;
        }
    }
    else
    {
        bRet = FALSE;
    }
    
    return bRet;
}

BOOL CStatusDlg::ReplaceWindow( HWND hWndOld, HWND hWndNew )
{
    BOOL bRet;
    CWindow wnd;
    RECT rect;

    wnd.Attach(hWndOld);
    
    // Get the coordinates of the old Window
    if( wnd.GetWindowRect(&rect) )
    {
        // Hide it, we are trying to replace it
        wnd.ShowWindow(SW_HIDE);

        // Attach to the new one
        wnd.Attach(hWndNew);
    
        // Map the coordinates and move the window on top of the old one
        if( ScreenToClient(&rect) )
        {
            bRet = wnd.MoveWindow(&rect);
        }
        else
        {
            bRet = FALSE;
        }
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}

BOOL CStatusDlg::VerticalResizeWindow( HWND hWnd, int iResize )
{
    CWindow wnd;
    RECT rect;
    BOOL bRet = FALSE;
    
    if( iResize )
    {
        // Attach to the window        
        wnd.Attach(hWnd);
        
        // Get the coordinates
        if( wnd.GetWindowRect(&rect) )
        {
            rect.bottom -= iResize; // Increase the bottom

            if( ScreenToClient(&rect) )
            {
                bRet = wnd.MoveWindow(&rect);  // Resize
            }
            else
            {
                bRet= FALSE;
            }
        }
        else
        {
            bRet = FALSE;
        }
    }

    return bRet;
}

int CStatusDlg::GetWindowLength( HWND hWndTop, HWND hWndBottom )
{
    CWindow wnd;
    RECT rect;
    int iTop;

    wnd.Attach(hWndTop);

    if( wnd.GetWindowRect(&rect) )
    {
        iTop = rect.top;
        wnd.Attach(hWndBottom);

        if( wnd.GetWindowRect(&rect) )
        {
            return rect.bottom - iTop;
        }
    }

    return 0;
}

STDMETHODIMP CStatusDlg::get_OverallProgress( IStatusProgress** pVal )
{
    HRESULT hr = S_OK;

	if( NULL == pVal )
    {
        return E_INVALIDARG;
    }

    if( m_lFlags & SD_PROGRESS_OVERALL )
    {
        // Create component progress object
        if( m_pOverallProgress == NULL )
        {
            hr = CComObject<CStatusProgress>::CreateInstance(&m_pOverallProgress);

            if( SUCCEEDED(hr) )
            {
                hr = m_pOverallProgress->AddRef();
            }
            
            if( SUCCEEDED(hr) && IsWindow() )
            {
                // Initialize the overall progress with the progress bar handle
                hr = m_pOverallProgress->Initialize(this, GetDlgItem(IDC_PROGRESS2), TRUE);
            }
        }
        
        hr = m_pOverallProgress->QueryInterface(IID_IStatusProgress, (void **) pVal);                
    } 
    
    return hr;
}

BOOL CStatusDlg::AreAllComponentsDone( BOOL& bFailedComponent )
{
    BOOL bComponentToRun = FALSE;

    COMPONENTMAP::iterator compIterator = m_mapComponents.begin();

    if( m_pProgressList )
    {
        // Look for a component that's not done
        while( m_pProgressList && !bComponentToRun && compIterator != m_mapComponents.end() )
        {
            CProgressItem * pPI = m_pProgressList->GetProgressItem(compIterator->first);

            if( NULL != pPI )
            {
                // Is the component done?
                if( IS_NONE == pPI->m_eState )
                {
                    bComponentToRun = TRUE;
                }            
                else if( IS_FAILED == pPI->m_eState )
                {
                    bFailedComponent = TRUE;
                }
            }
            else
            {
                _ASSERT( pPI );
            }

            compIterator++;
        }
    }

    return !bComponentToRun;
}

LRESULT CStatusDlg::OnCloseCmd( WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/ )
{
    EndDialog(wID); 

	return 0;
} 

LRESULT CStatusDlg::OnCancelCmd( WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/ )
{
    HWND hWnd = NULL;

    if( 0 == m_iCancelled )
    {
        InterlockedIncrement((LONG *) &m_iCancelled);  
    }

    // Disable the Cancel button    
    hWnd = GetDlgItem(IDCANCEL);
    if( hWnd && ::IsWindow(hWnd) )
    {
        ::EnableWindow( hWnd, FALSE );
    }

    //  EndDialog(wID);
    //  Leaving it to the component to close the dialog  
    return 0;
}

LRESULT CStatusDlg::OnDrawItem( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	if( wParam == IDC_LIST2 )
	{
        if( m_pProgressList )
        {
		    m_pProgressList->OnDrawItem( lParam );
        }
	}
	return 0;
}

LRESULT CStatusDlg::OnMeasureItem( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	if( wParam == IDC_LIST2)
	{
        if( m_pProgressList )
        {
            m_pProgressList->OnMeasureItem( lParam );
        }
	}
	return 0;
}


LRESULT CStatusDlg::OnClose( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    if( m_lFlags & SD_BUTTON_CANCEL )    // Cancel button?
    {
        if( ::IsWindowEnabled( GetDlgItem(IDCANCEL) ) ) // Is it enabled?
        {
            if( 0 == m_iCancelled )
            {
                InterlockedIncrement( (LONG*)&m_iCancelled );
            }

            EndDialog(0);
        }
        else if( ::IsWindowEnabled( GetDlgItem(IDOK) ) )
        {
            // it could be OK button sending WM_CLOSE or the user
            // As long as OK button is enabled we need to close the dialog
            EndDialog(1);
        }
    }
    else if( ::IsWindowEnabled( GetDlgItem(IDOK) ) )
    {
        EndDialog( 1 );
    }
	return 0;
}

LRESULT CStatusDlg::OnTimerProgress( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    HRESULT hr;
    long lPosition;

    if( wParam && (m_lTimer == wParam) )   // Make sure that this is for our timer
    {
        lPosition = SendDlgItemMessage(IDC_PROGRESS1, PBM_GETPOS, 0, 0);

        if( lPosition < m_lMaxSteps )    // Do we still have room for progress?
        {
            SendDlgItemMessage(IDC_PROGRESS1, PBM_STEPIT, 0, 0);    // Step 1
            SendMessage(WM_UPDATEOVERALLPROGRESS, 0, 0);            // Update the overall progress
        }
        else
        {
            // There's no room to progress, we've reached the max
            // Let's kill the timer
            SendMessage(WM_KILLTIMER, 0);
        }        
    }

    return 0;
}

LRESULT CStatusDlg::OnUpdateOverallProgress( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    long lPosition = 0;

    if( m_lFlags & SD_PROGRESS_COMPONENT )   // Make sure that there's a component progress
    {
        lPosition = SendDlgItemMessage(IDC_PROGRESS1, PBM_GETPOS, 0, 0);

        // Update the overall progress        
        SendDlgItemMessage(IDC_PROGRESS2, PBM_SETPOS, m_lTotalProgress + lPosition, 0);
    }

    return 0;
}

LRESULT CStatusDlg::OnStartTimer( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    if( !m_lTimer ) // There might be a timer already
    {
        m_lTimer = SetTimer(SD_TIMER_ID, wParam * 500); // Create a timer
        m_lMaxSteps = (long) lParam;    // Max. not to exceed for the progress bar
    }

    return 0;
}

LRESULT CStatusDlg::OnKillTimer( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    if( m_lTimer )   // Is there a timer?
    {
        KillTimer( m_lTimer );    // Kill it
        m_lTimer = 0;           
        m_lMaxSteps = 0;
    }

    return 0;
}

STDMETHODIMP CStatusDlg::SetStatusText(BSTR bstrText)
{
    if( !bstrText ) return E_POINTER;

    HRESULT hr = S_OK;
    HWND    hWnd = GetDlgItem(IDC_STATIC1);

    if( hWnd && ::IsWindow(hWnd) )
    {
        if( 0 == ::SetWindowText(hWnd, OLE2T(bstrText)) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


STDMETHODIMP CStatusDlg::DisplayError(BSTR bstrError, BSTR bstrTitle, DWORD dwFlags, long * pRet)
{
    if( !bstrError || !bstrTitle || !pRet ) return E_POINTER;

    HRESULT hr = S_OK;    

    *pRet = MessageBox( bstrError, bstrTitle, dwFlags );

    if( 0 == *pRet )
    {
	    hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\statsdlg.h ===
// StatsDlg.h : Declaration of the CStatusDlg

#ifndef __STATUSDLG_H_
#define __STATUSDLG_H_

#include "resource.h"       // main symbols

#include <map>
#include <limits.h>
#include <commctrl.h>
#include <atlctrls.h>

#include "StatusProgress.h"
#include "ProgList.h"

typedef std::map<long, BSTR, std::less<long> > COMPONENTMAP;

#define SD_TIMER_ID 333

/////////////////////////////////////////////////////////////////////////////
// CStatusDlg
class ATL_NO_VTABLE CStatusDlg :
    public CDialogImpl<CStatusDlg>, 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CStatusDlg, &CLSID_StatusDlg>,
    public IDispatchImpl<IStatusDlg, &IID_IStatusDlg, &LIBID_WIZCHAINLib>
{
public:
    
    enum { IDD = IDD_STATUSDIALOG };

    LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL&);
    LRESULT OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/);
    LRESULT OnCancelCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/);
    LRESULT OnDrawItem( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnMeasureItem( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnClose( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnTimerProgress( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnUpdateOverallProgress( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnStartTimer( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnKillTimer( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );    

    CStatusDlg() :
        m_hThread(NULL),
        m_lFlags(LONG_MAX),
        m_iCancelled(0),
        m_pComponentProgress(NULL),
        m_pOverallProgress(NULL),
        m_strWindowTitle(_T("")),
        m_strWindowText(_T("")),
        m_lTotalProgress(0),
        m_lTimer(0),
        m_lMaxSteps(0)                    
    {        
        m_hDisplayedEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        m_pProgressList = new CProgressList;
        m_mapComponents.clear(); 
    }

   ~CStatusDlg()
    {
        if (m_hDisplayedEvent)
            CloseHandle(m_hDisplayedEvent);
       
        if (m_hThread)
            CloseHandle(m_hThread);

        if (m_pProgressList)
            delete m_pProgressList;

        if (m_pComponentProgress)
        {
            m_pComponentProgress->Release();
        }

        if (m_pOverallProgress)
        {
            m_pOverallProgress->Release();
        }
         
        COMPONENTMAP::iterator compIterator = m_mapComponents.begin();

        while (compIterator != m_mapComponents.end())
        {
            ::SysFreeString(compIterator->second);
            compIterator++;
        }
    }

BEGIN_MSG_MAP(CStatusDlg)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnCloseCmd)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancelCmd)
    MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
	MESSAGE_HANDLER(WM_MEASUREITEM, OnMeasureItem)
    MESSAGE_HANDLER(WM_CLOSE, OnClose)
    MESSAGE_HANDLER(WM_UPDATEOVERALLPROGRESS, OnUpdateOverallProgress)
    MESSAGE_HANDLER(WM_TIMER, OnTimerProgress)
    MESSAGE_HANDLER(WM_STARTTIMER, OnStartTimer)
    MESSAGE_HANDLER(WM_KILLTIMER, OnKillTimer)
END_MSG_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_STATUSDLG)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CStatusDlg)
    COM_INTERFACE_ENTRY(IStatusDlg)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//CStatusDlg
public:
	STDMETHOD(DisplayError)         ( BSTR bstrError, BSTR bstrTitle, DWORD dwFlags, long* pRet );
    STDMETHOD(SetStatusText)        ( BSTR bstrText );	
	STDMETHOD(get_OverallProgress)  ( /*[out, retval]*/ IStatusProgress* *pVal );
    STDMETHOD(AddComponent)         ( BSTR bstrComponent, long * lIndex );
	STDMETHOD(Initialize)           ( BSTR bstrWindowTitle, BSTR bstrWindowText, VARIANT varFlags );
	STDMETHOD(SetStatus)            ( long lIndex, SD_STATUS lStatus );
	STDMETHOD(Display)              ( BOOL vb );	
	STDMETHOD(WaitForUser)          ( );
    STDMETHOD(get_Cancelled)        ( BOOL *pVal );
	STDMETHOD(get_ComponentProgress)( IStatusProgress * *pVal );    

private:
	
    BOOL AreAllComponentsDone( BOOL& bFailed );
    BOOL VerticalResizeWindow( HWND hWnd, int iResize        );
	BOOL ReplaceWindow       ( HWND hWndOld, HWND hWndNew    );
	BOOL VerticalMoveWindow  ( HWND hWnd, int iResize        );
	int  GetWindowLength     ( HWND hWndTop, HWND hWndBottom );    
    void SetupButtons        ( );
	
    volatile int m_iCancelled;
    HANDLE  m_hThread;
    
    TSTRING m_strWindowTitle;
    TSTRING m_strWindowText;
    
    long    m_lFlags;
    HANDLE  m_hDisplayedEvent;        

    CComObject<CStatusProgress>* m_pComponentProgress;
    CComObject<CStatusProgress>* m_pOverallProgress;
    COMPONENTMAP m_mapComponents;
    CProgressList * m_pProgressList;

    volatile long m_lTotalProgress;
    long    m_lTimer;
    long    m_lMaxSteps;
};

#endif //__STATUSDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\statusprogress.cpp ===
// StatusProgress.cpp : Implementation of CStatusProgress
#include "stdafx.h"

#include "Wizchain.h"
#include "StatusProgress.h"

#include "commctrl.h"

/////////////////////////////////////////////////////////////////////////////
// CStatusProgress


STDMETHODIMP CStatusProgress::EnableOnTimerProgress(BOOL bEnable, long lFrequency, long lMaxSteps)
{
    if (!m_bOverallProgress && IsWindow(m_hWndProgress))
    {
        if (bEnable)
        {        
            ::SendMessage(GetParent(m_hWndProgress), WM_STARTTIMER, lFrequency, lMaxSteps);
        }
        else
        {
            ::SendMessage(GetParent(m_hWndProgress), WM_KILLTIMER, 0, 0);
        }
    }

    return S_OK;
}

STDMETHODIMP CStatusProgress::get_Position(long *pVal)
{
    if (IsWindow(m_hWndProgress))
    {
        *pVal = ::SendMessage(m_hWndProgress, PBM_GETPOS, 0, 0); 
    }

    return S_OK;
}

STDMETHODIMP CStatusProgress::put_Position(long newVal)
{
    if (IsWindow(m_hWndProgress))
    {
        ::SendMessage(m_hWndProgress, PBM_SETPOS, newVal, 0);
        
        if (!m_bOverallProgress)
        {
            ::SendMessage(GetParent(m_hWndProgress), WM_KILLTIMER, 0, 0);
            ::SendMessage(GetParent(m_hWndProgress), WM_UPDATEOVERALLPROGRESS, 0, 0);
        }
    }

    return S_OK;
}

STDMETHODIMP CStatusProgress::get_Range(long *pVal)
{
    PBRANGE range;
    range.iHigh = -1;

    if (IsWindow(m_hWndProgress))
    {
        ::SendMessage(m_hWndProgress, PBM_GETRANGE, FALSE, (LPARAM) &range); 

        if (range.iHigh >= 0)
            *pVal = range.iHigh;
        else
            return E_FAIL;
    }

    return S_OK;
}

STDMETHODIMP CStatusProgress::put_Range(long newVal)
{
    if (IsWindow(m_hWndProgress))
    {
        if (!::SendMessage(m_hWndProgress, PBM_SETRANGE, 0, MAKELPARAM(0, newVal)))
            return E_FAIL;
    }

    return S_OK;
}

STDMETHODIMP CStatusProgress::put_Step(long newVal)
{
    if (IsWindow(m_hWndProgress))
    {
        ::SendMessage(m_hWndProgress, PBM_SETSTEP, newVal, 0); 
    }

    return S_OK;

}


STDMETHODIMP CStatusProgress::StepIt(long lSteps)
{
    if (IsWindow(m_hWndProgress))
    {
        for (int i = 1; i <= lSteps; i++)
        {
            ::SendMessage(m_hWndProgress, PBM_STEPIT, 0, 0);
        }
        
        if (!m_bOverallProgress)
        {
            ::SendMessage(GetParent(m_hWndProgress), WM_KILLTIMER, 0, 0);
            ::SendMessage(GetParent(m_hWndProgress), WM_UPDATEOVERALLPROGRESS, 0, 0);
        }
    }

    return S_OK;

}

HRESULT CStatusProgress::Initialize(IDispatch * pdispSD, HWND hWnd, BOOL bOverallProgress)
{
    m_hWndProgress = hWnd;
    m_bOverallProgress = bOverallProgress;
    m_pdispSD = pdispSD;

    return pdispSD->AddRef();
}

STDMETHODIMP CStatusProgress::put_Text(BSTR newVal)
{
	if (IsWindow(m_hWndProgress))
    {
        if (m_bOverallProgress)
        {
            ::SetDlgItemText(GetParent(m_hWndProgress), IDC_STATIC_OVERALL, newVal);
        }
        else
        {
            ::SetDlgItemText(GetParent(m_hWndProgress), IDC_STATIC_COMPONENT, newVal);
        }
        
    }

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\statusprogress.h ===
// StatusProgress.h : Declaration of the CStatusProgress

#ifndef __STATUSPROGRESS_H_
#define __STATUSPROGRESS_H_

#include "resource.h"       // main symbols


#define WM_KILLTIMER WM_USER + 10
#define WM_STARTTIMER WM_USER + 11
#define WM_UPDATEOVERALLPROGRESS WM_USER + 12

/////////////////////////////////////////////////////////////////////////////
// CStatusProgress
class ATL_NO_VTABLE CStatusProgress : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CStatusProgress, &CLSID_StatusProgress>,
	public IDispatchImpl<IStatusProgress, &IID_IStatusProgress, &LIBID_WIZCHAINLib>
{
public:
    CStatusProgress() : m_pdispSD(NULL), 
                        m_hWndProgress(NULL),
                        m_bOverallProgress(FALSE)
	{
    }

    
    ~CStatusProgress()
    {
        if (m_pdispSD)
            m_pdispSD->Release();

    }

DECLARE_REGISTRY_RESOURCEID(IDR_STATUSPROGRESS)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CStatusProgress)
	COM_INTERFACE_ENTRY(IStatusProgress)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IStatusProgress
public:	
	STDMETHOD(put_Text)(/*[in]*/ BSTR newVal);
    HRESULT Initialize(IDispatch * pdispSD, HWND hWnd, BOOL bOverallProgress);
    STDMETHOD(StepIt)               ( long lSteps );
	STDMETHOD(put_Step)             ( long newVal );
	STDMETHOD(put_Range)            ( long newVal );
	STDMETHOD(get_Range)            ( long* pVal  );
	STDMETHOD(put_Position)         ( long newVal );
	STDMETHOD(get_Position)         ( long* pVal  );
	STDMETHOD(EnableOnTimerProgress)( BOOL bEnable, long lFrequency, long lMaxSteps );

private:
    IDispatch * m_pdispSD;
    HWND m_hWndProgress;
    BOOL m_bOverallProgress;
};

#endif //__STATUSPROGRESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A6730A2C_0D6C_11D3_84A2_00C04F6837E0__INCLUDED_)
#define AFX_STDAFX_H__A6730A2C_0D6C_11D3_84A2_00C04F6837E0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0501
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlhost.h>
#include <atltmp.h>

#include <list>
#include <string>
typedef std::basic_string<TCHAR> tstring;
typedef tstring TSTRING;

using namespace std;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.



#endif // !defined(AFX_STDAFX_H__A6730A2C_0D6C_11D3_84A2_00C04F6837E0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\exe\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\wizchain.cpp ===
// WizChain.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f WizChainps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"

#include <initguid.h>

#include "WizChain.h"
#include "WizChain_i.c"

#include "PropItem.h"
#include "ChainWiz.h"
#include "WzScrEng.h"
#include "PropSht.h"
#include "StatsDlg.h"
#include "StatusProgress.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ChainWiz, CChainWiz)
OBJECT_ENTRY(CLSID_PropertyPagePropertyBag, CPropertyPagePropertyBag)
OBJECT_ENTRY(CLSID_WizardScriptingEngine, CWizardScriptingEngine)
OBJECT_ENTRY(CLSID_StatusDlg, CStatusDlg)
OBJECT_ENTRY(CLSID_StatusProgress, CStatusProgress)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_WIZCHAINLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
#include <commctrl.h>
#include "StatusProgress.h"
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    AtlAxWinInit();     // init ATL control containment code

    // init common controls
    INITCOMMONCONTROLSEX icce;
    ZeroMemory (&icce, sizeof(icce));
    icce.dwSize = sizeof(icce);
    icce.dwICC  = ICC_LISTVIEW_CLASSES | ICC_LINK_CLASS;
    if (!InitCommonControlsEx (&icce))
    {
        icce.dwICC = ICC_LISTVIEW_CLASSES;
        InitCommonControlsEx (&icce);
    }


    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\wzscreng.cpp ===
// WzScrEng.cpp : Implementation of CWizardScriptingEngine
#include "stdafx.h"
#include "WizChain.h"
#include "WzScrEng.h"

// local proto(s)
HBITMAP LoadPicture (LPOLESTR szURLorPath, long lWidth, long lHeight);

/////////////////////////////////////////////////////////////////////////////
// CWizardScriptingEngine


STDMETHODIMP CWizardScriptingEngine::Initialize(BSTR bstrWatermarkBitmapFile, BSTR bstrHeaderBitmapFile, BSTR bstrTitle, BSTR bstrHeader, BSTR bstrText, BSTR bstrFinishHeader, BSTR bstrFinishIntroText, BSTR bstrFinishText)
{
    if (m_pCW != NULL)
        return E_UNEXPECTED;    // should only be called once

    HRESULT hr = CComObject<CChainWiz>::CreateInstance (&m_pCW);
    if (hr != S_OK)
        return hr;
    if (!m_pCW)
        return E_FAIL;
    m_pCW->AddRef();    // CreateInstance above doesn't addref

    // try bitmaps first
    m_hbmLarge = (HBITMAP)LoadImageW (NULL,    // no hinstance when loading from file
                                      (LPWSTR)bstrWatermarkBitmapFile,    // filename
                                      IMAGE_BITMAP,   // type of image
                                      0, 0,   // size (width and height)
                                      LR_LOADFROMFILE);
    m_hbmSmall = (HBITMAP)LoadImageW (NULL,    // no hinstance when loading from file
                                      (LPWSTR)bstrHeaderBitmapFile,       // filename
                                      IMAGE_BITMAP,   // type of image
                                      0, 0,   // size (width and height)
                                      LR_LOADFROMFILE);

    // use IPicture 
    if(!m_hbmLarge)
        m_hbmLarge = LoadPicture ((LPOLESTR)bstrWatermarkBitmapFile, 0, 0);
    if(!m_hbmSmall)
        m_hbmSmall = LoadPicture ((LPOLESTR)bstrHeaderBitmapFile, 49, 49);

    // TODO:  should I add defaults when LoadImage calls above fail?

    hr = m_pCW->Initialize (m_hbmLarge, m_hbmSmall, (LPOLESTR)bstrTitle, (LPOLESTR)bstrHeader, (LPOLESTR)bstrText, (LPOLESTR)bstrFinishHeader, (LPOLESTR)bstrFinishIntroText, (LPOLESTR)bstrFinishText);
    return hr;
}

STDMETHODIMP CWizardScriptingEngine::AddWizardComponent(BSTR bstrClassIdOrProgId)
{
    if (m_pCW == NULL)
        return E_UNEXPECTED;

    // if progid, get clsid
    OLECHAR * p = (OLECHAR *)bstrClassIdOrProgId;
    if (*p != L'{') {
        CLSID clsid;
        HRESULT hr = CLSIDFromProgID ((LPCOLESTR)bstrClassIdOrProgId, &clsid);
        if (hr != S_OK)
            return hr;
        OLECHAR szClsid[50];    // find a define for this
        StringFromGUID2 (clsid, szClsid, sizeof(szClsid)/sizeof(OLECHAR));
        return m_pCW->AddWizardComponent (szClsid);
    } else
        return m_pCW->AddWizardComponent ((LPOLESTR)bstrClassIdOrProgId);
}

STDMETHODIMP CWizardScriptingEngine::DoModal(long *lRet)
{
    if (m_pCW == NULL)
        return E_UNEXPECTED;
    return m_pCW->DoModal (lRet);
}

STDMETHODIMP CWizardScriptingEngine::get_ScriptablePropertyBag(IDispatch **pVal)
{
    if (m_pCW == NULL)
        return E_UNEXPECTED;
    return m_pCW->get_PropertyBag (pVal);
}

HBITMAP LoadPicture (LPOLESTR szURLorPath, long lWidth, long lHeight)
{   // idea:  load picture using OleLoadPicturePath
    // play into memory dc, get back a hbitmap
    HBITMAP hbm = NULL;

    IPicture * pPic = NULL;
    HRESULT hr = OleLoadPicturePath (szURLorPath,
                        NULL,                  // LPUNKNOWN punkCaller,
                        0,                     // DWORD     dwReserved,
                        (OLE_COLOR)-1,         // OLE_COLOR clrReserved,
                        __uuidof(IPicture),    // REFIID
                        (void**)&pPic);        // LPVOID *
    if (pPic) {
        OLE_XSIZE_HIMETRIC xhi;
        OLE_YSIZE_HIMETRIC yhi;
        pPic->get_Width (&xhi);
        pPic->get_Height(&yhi);

        SIZEL him, pixel = {0};
        him.cx = xhi;
        him.cy = yhi;
        AtlHiMetricToPixel (&him, &pixel);

        if (lWidth  == 0)   lWidth  = pixel.cx;
        if (lHeight == 0)   lHeight = pixel.cy;

        HDC hdcNULL = GetDC (NULL);
        HDC hdc = CreateCompatibleDC (hdcNULL);
        hbm = CreateCompatibleBitmap (hdcNULL, lWidth, lHeight);
        ReleaseDC (NULL, hdcNULL);
        HBITMAP holdbm = (HBITMAP)SelectObject (hdc, (HGDIOBJ)hbm);

        // do palette action if any
        HPALETTE hpal = NULL;
        HPALETTE holdpal = NULL;
        hr = pPic->get_hPal ((OLE_HANDLE *)&hpal);
        if( SUCCEEDED(hr) && hpal) 
        {
            holdpal = SelectPalette (hdc, hpal, FALSE);
            RealizePalette (hdc);
        
            hr = pPic->Render (hdc,
                               0,
                               lHeight-1,  // 0,
                               lWidth,
                               -lHeight, // lHeight,
                               0, 0, 
                               xhi, yhi,
                               NULL);    // lpcrect used only if metafiledc
        }

        SelectObject (hdc, (HGDIOBJ)holdbm);
        if (holdpal) {
            SelectPalette (hdc, holdpal, FALSE);
            DeleteObject ((HGDIOBJ)hpal);
        }
        if (hr != S_OK) {
            DeleteObject ((HGDIOBJ)hbm);
            hbm = NULL;
        }

        if( NULL != hdc )
        {
            ReleaseDC (NULL, hdc);
        }
        
        pPic->Release();
    }
    return hbm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\dll\wizchain\wzscreng.h ===
// WzScrEng.h : Declaration of the CWizardScriptingEngine

#ifndef __WIZARDSCRIPTINGENGINE_H_
#define __WIZARDSCRIPTINGENGINE_H_

#include "resource.h"       // main symbols

#include "ChainWiz.h"

/////////////////////////////////////////////////////////////////////////////
// CWizardScriptingEngine
class ATL_NO_VTABLE CWizardScriptingEngine : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CWizardScriptingEngine, &CLSID_WizardScriptingEngine>,
    public IDispatchImpl<IWizardScriptingEngine, &IID_IWizardScriptingEngine, &LIBID_WIZCHAINLib>
{
private:
    CComObject<CChainWiz>* m_pCW;
    HBITMAP m_hbmLarge;
    HBITMAP m_hbmSmall;

public:
    CWizardScriptingEngine( )
    {
        m_pCW      = NULL;
        m_hbmLarge = NULL;
        m_hbmSmall = NULL;
    }
   ~CWizardScriptingEngine()
    {
        if( m_pCW )      
        {
            m_pCW->Release();
        }

        if( m_hbmLarge ) 
        {
            DeleteObject ((HGDIOBJ)m_hbmLarge);
        }

        if( m_hbmSmall ) 
        {
            DeleteObject ((HGDIOBJ)m_hbmSmall);
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_WIZARDSCRIPTINGENGINE)
DECLARE_NOT_AGGREGATABLE(CWizardScriptingEngine)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWizardScriptingEngine)
    COM_INTERFACE_ENTRY(IWizardScriptingEngine)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IWizardScriptingEngine
public:
    STDMETHOD(get_ScriptablePropertyBag)( /*[out, retval]*/ IDispatch** pVal );
    STDMETHOD(DoModal                  )( /*[out,retval]*/ long* lRet );
    STDMETHOD(AddWizardComponent       )( /*[in]*/ BSTR bstrClassIdOrProgId );
    STDMETHOD(Initialize               )( /*[in]*/ BSTR bstrWatermarkBitmapFile, /*[in]*/ BSTR bstrHeaderBitmapFile, /*[in]*/ BSTR bstrTitle, /*[in]*/ BSTR bstrWelcomeHeader, /*[in]*/ BSTR bstrWelcomeText, /*[in]*/ BSTR bstrFinishHeader, /*[in]*/ BSTR bstrFinishIntroText, /*[in]*/ BSTR bstrFinishText );
};

#endif //__WIZARDSCRIPTINGENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\exe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ausrexe.rc
//

#define IDS_NOT_ADMIN                   102
#define IDS_ERROR_TITLE                 103

#define IDS_TITLE                       104
#define IDS_WELCOME_HEADER              105
#define IDS_WELCOME_TEXT                106
#define IDS_FINISH_HEADER               107
#define IDS_FINISH_TEXT                 108
#define IDS_WELCOME_TEXT_NEXT           110
#define IDS_WELCOME_TEXT_BULK           111

#define IDS_STATUS_INFO                 150
#define IDS_STATUS_ACCNT                152

// Errors
#define IDS_CANT_FIND_DC                905
#define IDS_ERROR_MISSINGDLL            920
#define IDS_ERROR_EXTENDED_FMT          925
#define IDS_ERR_FORMAT_NAME             926

// Bitmaps.
#define IDB_BMP_LARGE                   1000
#define IDB_BMP_SMALL                   1001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\setup\resource.h ===
// Mini-Resource file
#define MANIFEST_RESOURCE_ID            2

#define IDS_INSERT_CD                   100
#define IDS_TITLE                       110

#define IDR_SMCYSCOM                    900
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\exe\ausrexe.cpp ===
// AUsrExe.cpp : Implementation of WinMain
#include "stdafx.h"
#include "resource.h"

// DLL\Inc
#include <wizchain.h>
#include <propuid.h>
#include <AUsrUtil.h>                      
#include <singleinst.h>
#include <cmdline.h>
#include <proputil.h>
#include <AU_Accnt.h>       // Core User component (account, mailbox, group)
#include <P3admin.h>
#include <checkuser.h>

#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmserver.h>
#include <lmshare.h>
#include <iads.h>
#include <adshlp.h>
#include <adserr.h>
#include <dsgetdc.h>

#define ERROR_CREATION      0x01
#define ERROR_PROPERTIES    0x02
#define ERROR_MAILBOX       0x04
#define ERROR_MEMBERSHIPS   0x08
#define ERROR_PASSWORD      0x10
#define ERROR_DUPE          0x20
#define ERROR_GROUP         0x40

// Defines for account flags.
#define PASSWD_NOCHANGE     0x01
#define PASSWD_CANCHANGE    0x02
#define PASSWD_MUSTCHANGE   0x04
#define ACCOUNT_DISABLED    0x10

#define MAX_GUID_STRING_LENGTH  64
#define SINGLE_INST_NAME _T("{19C2E967-1198-4e4c-A55F-515C5F13B73F}")

HINSTANCE g_hInstance;
DWORD   g_dwAutoCompMode;
TCHAR   g_szUserOU[MAX_PATH*2]  = {0};

// Prototypes
DWORD   FixParams( void );

// ****************************************************************************
inline void MakeLDAPUpper( TCHAR* szIn )
{
    if( !szIn ) return;

    if( _tcsnicmp( szIn, _T("ldap://"), 7 ) == 0 )
    {
        szIn[0] = _T('L');
        szIn[1] = _T('D');
        szIn[2] = _T('A');
        szIn[3] = _T('P');
    }
}

class CHBmp
{
public:
    CHBmp() 
    {
        m_hbmp = NULL;
    }

    CHBmp( HINSTANCE hinst, INT iRes ) 
    {
        m_hbmp = (HBITMAP)LoadImage( hinst, MAKEINTRESOURCE(iRes), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR );
    }

    ~CHBmp()
    {
        if ( m_hbmp )
            DeleteObject((HGDIOBJ)m_hbmp);
    }

    HBITMAP SetBmp( HINSTANCE hinst, INT iRes )
    {
        m_hbmp = (HBITMAP)LoadImage( hinst, MAKEINTRESOURCE(iRes), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR );
        return(m_hbmp);
    }

    HBITMAP GetBmp()
    {
        return(m_hbmp);    
    }

private: 
    HBITMAP m_hbmp;

};

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

// ----------------------------------------------------------------------------
// SetPBagPropStr()
// ----------------------------------------------------------------------------
HRESULT SetPBagPropStr( IChainWiz *spCW, LPCTSTR szPropGuid, LPCTSTR szValue, PPPBAG_TYPE dwFlags )
{
    HRESULT hr = E_FAIL;

    if ( !spCW || !szPropGuid )
        return E_FAIL;

    CComPtr<IDispatch> spDisp;
    spCW->get_PropertyBag( &spDisp );
    CComQIPtr<IPropertyPagePropertyBag> spPPPBag(spDisp);

    if ( spPPPBag )
    {
        hr = S_OK;
        CComBSTR    bstrPropGuid = szPropGuid;
        CComVariant var          = szValue;
        spPPPBag->SetProperty (bstrPropGuid, &var, dwFlags);
    }

    return hr;
}

// ----------------------------------------------------------------------------
// SetPBagPropBool()
// ----------------------------------------------------------------------------
HRESULT SetPBagPropBool( IChainWiz *spCW, LPCTSTR szPropGuid, BOOL fValue, PPPBAG_TYPE dwFlags )
{
    HRESULT hr = E_FAIL;

    if ( !spCW || !szPropGuid )
        return E_FAIL;

    CComPtr<IDispatch> spDisp;
    spCW->get_PropertyBag( &spDisp );
    CComQIPtr<IPropertyPagePropertyBag> spPPPBag(spDisp);

    if ( spPPPBag )
    {
        hr = S_OK;
        CComBSTR    bstrPropGuid = szPropGuid;
        CComVariant var          = (bool) !!fValue;
        spPPPBag->SetProperty (bstrPropGuid, &var, dwFlags);
    }

    return hr;
}

// ----------------------------------------------------------------------------
// SetPBagPropInt4()
// ----------------------------------------------------------------------------
HRESULT SetPBagPropInt4( IChainWiz *spCW, LPCTSTR szPropGuid, long lValue, PPPBAG_TYPE dwFlags )
{
    HRESULT hr = E_FAIL;

    if ( !spCW || !szPropGuid )
        return E_FAIL;

    CComPtr<IDispatch> spDisp;
    spCW->get_PropertyBag( &spDisp );
    CComQIPtr<IPropertyPagePropertyBag> spPPPBag(spDisp);

    if ( spPPPBag )
    {
        hr = S_OK;
        CComBSTR    bstrPropGuid = szPropGuid;
        WriteInt4 (spPPPBag, bstrPropGuid, lValue, dwFlags == PPPBAG_TYPE_READONLY ? true : false);
    }

    return hr;
}

// ----------------------------------------------------------------------------
// TmpSetProps()
// ----------------------------------------------------------------------------
HRESULT TmpSetProps(IChainWiz *spCW)
{
    if ( !spCW )
        return(E_FAIL);

    SetPBagPropInt4( spCW, PROP_AUTOCOMPLETE_MODE,          g_dwAutoCompMode,   PPPBAG_TYPE_READWRITE );        
    SetPBagPropStr ( spCW, PROP_USEROU_GUID_STRING,         g_szUserOU,         PPPBAG_TYPE_READWRITE );

    // Check for POP3 installation
    BOOL bPOP3Installed     = FALSE;
    BOOL bPOP3Valid         = FALSE;    

    CRegKey cReg;
            
    //To detect if POP3 is installed:
    //Key:   HKLM\SOFTWARE\Microsoft\POP3 Service
    //Value: Version REG_SZ eg. "1.0"        
    tstring strPath = _T("Software\\Microsoft\\POP3 Service");
    tstring strKey  = _T("Version");

    if( cReg.Open( HKEY_LOCAL_MACHINE, strPath.c_str() ) == ERROR_SUCCESS )
    {
        TCHAR szValue[MAX_PATH] = {0};
        DWORD dwSize            = MAX_PATH;
        bPOP3Installed = (cReg.QueryValue( szValue, strKey.c_str(), &dwSize ) == ERROR_SUCCESS);
        cReg.Close();
    }

    if( bPOP3Installed )
    {
        // Test if there is at least one domain                
        HRESULT hr = S_OK;
        CComPtr<IP3Config>  spConfig  = NULL;
        CComPtr<IP3Domains> spDomains = NULL;
        CComPtr<IP3Domain>  spDomain  = NULL;            
        long                lCount    = 0;

        // Open our Pop3 Admin Interface
	    hr = CoCreateInstance(__uuidof(P3Config), NULL, CLSCTX_ALL, __uuidof(IP3Config), (LPVOID*)&spConfig);    

        if( SUCCEEDED(hr) )
        {
            // Get the Domains
	        hr = spConfig->get_Domains( &spDomains );
        }

        if( SUCCEEDED(hr) )
        {                    
            hr = spDomains->get_Count( &lCount );
        }

        bPOP3Valid = (lCount > 0);
    }   

    SetPBagPropBool( spCW, PROP_POP3_CREATE_MB_GUID_STRING, bPOP3Valid,     PPPBAG_TYPE_READWRITE );
    SetPBagPropBool( spCW, PROP_POP3_VALID_GUID_STRING,     bPOP3Valid,     PPPBAG_TYPE_READWRITE );
    SetPBagPropBool( spCW, PROP_POP3_INSTALLED_GUID_STRING, bPOP3Installed, PPPBAG_TYPE_READWRITE );

    return(S_OK);
}


// ----------------------------------------------------------------------------
// DoAddUsr( )
// ----------------------------------------------------------------------------
HRESULT DoAddUsr( )
{
    HRESULT     hr = S_OK;

    CHBmp       bmpLarge(g_hInstance, IDB_BMP_LARGE);
    CHBmp       bmpSmall(g_hInstance, IDB_BMP_SMALL);

    CString     strTitle         = _T("");
    CString     strWelcomeHeader = _T("");
    CString     strWelcomeText   = _T("");
    CString     strWelcomeNext   = _T("");
    CString     strFinishHeader  = _T("");
    CString     strFinishIntro   = _T("");
    CString     strFinishText    = _T("");    
    CLSID       clsidChainWiz;
    CComPtr<IChainWiz>  spCW;

    // ------------------------------------------------------------------------
    // Init: 
    //  Initialize the wizard's text.
    // ------------------------------------------------------------------------
    strTitle.LoadString         ( IDS_TITLE             );
    strWelcomeHeader.LoadString ( IDS_WELCOME_HEADER    );    
    strWelcomeText.LoadString   ( IDS_WELCOME_TEXT      );    
    strWelcomeNext.LoadString   ( IDS_WELCOME_TEXT_NEXT );
    strFinishHeader.LoadString  ( IDS_FINISH_HEADER     );
    strFinishIntro.LoadString   ( IDS_FINISH_TEXT       );      

    strWelcomeText += strWelcomeNext;

    // ------------------------------------------------------------------------
    // Initialize the wizard.
    // ------------------------------------------------------------------------
    hr = CLSIDFromProgID( L"WizChain.ChainWiz", &clsidChainWiz );
    _ASSERT( hr == S_OK && "CLSIDFromProgID failed" );
    
    hr = CoCreateInstance( clsidChainWiz, NULL, CLSCTX_INPROC_SERVER, __uuidof(IChainWiz), (void **)&spCW );
    _ASSERT( spCW != NULL && "CoCreateInstance failed to create WizChain.ChainWiz" );

    if( FAILED(hr) || !spCW )
    {
        ErrorMsg(IDS_ERROR_MISSINGDLL, IDS_ERROR_TITLE);
        return(hr);
    }
    
    CComPtr<IDispatch> spDisp;
    spCW->get_PropertyBag( &spDisp );
    CComQIPtr<IPropertyPagePropertyBag> spPPPBag(spDisp);

    USES_CONVERSION;
    OLECHAR szClsid[MAX_GUID_STRING_LENGTH] = {0};

    // --------------------------------------------------------------------
    // Setup and run the wizard.
    // --------------------------------------------------------------------

    TmpSetProps( spCW );    // This is to populate the bag

    // Initialize the wizard.
    hr = spCW->Initialize( bmpLarge.GetBmp(), 
                            bmpSmall.GetBmp(), 
                            T2W((LPTSTR)(LPCTSTR)strTitle),
                            T2W((LPTSTR)(LPCTSTR)strWelcomeHeader),
                            T2W((LPTSTR)(LPCTSTR)strWelcomeText),
                            T2W((LPTSTR)(LPCTSTR)strFinishHeader),
                            T2W((LPTSTR)(LPCTSTR)strFinishIntro),
                            T2W((LPTSTR)(LPCTSTR)strFinishText) );
    if ( FAILED(hr) )
        return(hr);

    

    // Add the AddUser Account component.        
    szClsid[0] = 0;
    StringFromGUID2( __uuidof(AddUser_AccntWiz), szClsid, 50 );
    hr = spCW->AddWizardComponent(szClsid);
    if ( FAILED(hr) )
    {
        ErrorMsg(IDS_ERROR_MISSINGDLL, IDS_ERROR_TITLE);
        return(hr);
    }

    // Run the wizard.
    LONG lRet = 0;
    spCW->DoModal(&lRet);

    // --------------------------------------------------------------------
    // Run the Committer(s) -- Commit()
    // lRet != 1 means they cancelled the wizard.
    // --------------------------------------------------------------------
    if ( lRet != 1 )
    {
        return hr;
    }
    
    CComPtr<IWizardCommit>   spWAccntCommit  = NULL;    
    CComPtr<IStatusDlg>      spSD            = NULL;
    CComPtr<IStatusProgress> spComponentProg = NULL;

    BOOL    bRO         = FALSE;    
    DWORD   dwErrCode   = 0;
    DWORD   dwErrTemp   = 0;    
    CString strError    = StrFormatSystemError(E_FAIL).c_str();    
    strTitle.LoadString(IDS_TITLE);    

    // Get the AU_Accnt component.
    hr = CoCreateInstance( __uuidof(AddUser_AccntCommit), NULL, CLSCTX_INPROC_SERVER, __uuidof(IWizardCommit), (void**)&spWAccntCommit );
    if ( FAILED(hr) || !spWAccntCommit ) return FAILED(hr) ? hr : E_FAIL;

    // Get the Status Dialog
    hr = CoCreateInstance( __uuidof(StatusDlg), NULL, CLSCTX_INPROC_SERVER, __uuidof(IStatusDlg), (void **) &spSD );
    if ( FAILED(hr) || !spSD ) return FAILED(hr) ? hr : E_FAIL;                

    // Initialize the Status Dialog
    VARIANT var;
    CString csText;
    CString csDescription;
    long    lAccount;    

    csText.LoadString(IDS_STATUS_INFO);
    
    VariantInit(&var);
    V_VT(&var) = VT_I4;
    
    var.lVal = SD_BUTTON_OK | SD_PROGRESS_OVERALL;

    hr = spSD->Initialize( CComBSTR(strTitle), CComBSTR(csText), var );
    if( FAILED(hr) ) return hr;

    // Add our four components
    csDescription.LoadString(IDS_STATUS_ACCNT);
    hr = spSD->AddComponent(CComBSTR(csDescription), &lAccount);    
    if( FAILED(hr) ) return hr;    

    // Display the Status Bar
    hr = spSD->Display(TRUE);
    if( FAILED(hr) ) return hr;

    // Get the Progress component
    hr = spSD->get_OverallProgress(&spComponentProg);
    if ( FAILED(hr) || !spComponentProg ) return FAILED(hr) ? hr : E_FAIL;

    // Initialize our stepping
    hr = spComponentProg->put_Step(1);
    if( FAILED(hr) ) return hr;

    // Initialize our starting spot
    hr = spComponentProg->put_Position(0);
    if( FAILED(hr) ) return hr;    

    // Initialize our range
    hr = spComponentProg->put_Range(1);  // Just the one!
    if( FAILED(hr) ) return hr;
    
    bool bDeleteUser = false;    
    
    // Wipe out the component status checkmarks
    spSD->SetStatus(lAccount, SD_STATUS_NONE);    

    // Put up the Progress text    
    CString csFormatString  = _T("");
    CString csUserName      = _T("");
    
    // Read the two string to format
    csFormatString.LoadString(IDS_ERR_FORMAT_NAME);
    ReadString( spPPPBag, PROP_USER_CN, csUserName, &bRO );
    
    // This will be in the format "CN=USERNAME"
    csUserName = csUserName.Right(csUserName.GetLength()-3);

    // Format the string and display it
    TCHAR szTempAccount[1024] = {0};
    _sntprintf( szTempAccount, 1023, csFormatString, csUserName );    
    CComBSTR bstrUserName = szTempAccount;
    spComponentProg->put_Text( bstrUserName );

    // Set the Account running
    spSD->SetStatus(lAccount, SD_STATUS_RUNNING);                

    // Accnt Commit
    hr = spWAccntCommit->Commit( spDisp );
    if ( FAILED(hr) )
    {
        // We failed this component
        spSD->SetStatus(lAccount, SD_STATUS_FAILED);

        ReadInt4   ( spPPPBag, PROP_ACCNT_ERROR_CODE_GUID_STRING, (PLONG)&dwErrCode,  &bRO );
        ReadString ( spPPPBag, PROP_ACCNT_ERROR_STR_GUID_STRING,  strError,           &bRO );

        if ( dwErrCode & ERROR_DUPE )
        {
            MessageBox(NULL, strError, strTitle, MB_OK | MB_ICONERROR);            
        }
        else if ( dwErrCode & (ERROR_CREATION | ERROR_PROPERTIES) )
        {
            ::MessageBox(NULL, strError, strTitle, MB_OK | MB_ICONERROR);
            spWAccntCommit->Revert();            
        }
        else if ( dwErrCode & (ERROR_MAILBOX | ERROR_MEMBERSHIPS | ERROR_PASSWORD) )
        {
            CString strOutput;
            strOutput.FormatMessage( IDS_ERROR_EXTENDED_FMT, strError );

            // Do they want to revert?
            if ( MessageBox(NULL, strOutput, strTitle, MB_YESNO | MB_ICONERROR) == IDYES )
            {
                spWAccntCommit->Revert();
            }
        }
        else
        {
            _ASSERT(FALSE);                        
        }
    }
    else
    {
        spSD->SetStatus(lAccount, SD_STATUS_SUCCEEDED);
    }                    

    // Done with the Committer Component
    spComponentProg->StepIt(1);    
    spSD->WaitForUser();    

    // ------------------------------------------------------------------------
    // All done.
    // ------------------------------------------------------------------------
    return hr;
}

// ----------------------------------------------------------------------------
// Main()
// ----------------------------------------------------------------------------
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    // Check that we are not already open.
    CSingleInstance cInst( SINGLE_INST_NAME );
    if ( cInst.IsOpen() )
    {
        return E_UNEXPECTED;
    }

    HRESULT hrAdmin   = IsUserInGroup( DOMAIN_ALIAS_RID_ADMINS );    
    if( hrAdmin != S_OK )
    {
        ErrorMsg(IDS_NOT_ADMIN, IDS_ERROR_TITLE);
        return E_ACCESSDENIED;
    }

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
    HRESULT hRes = CoInitialize(NULL);
#endif
    _ASSERT(SUCCEEDED(hRes));

    BOOL    fBadUsage               = FALSE;
    LPCTSTR lpszToken               = NULL;
    LPTSTR  pszCurrentPos           = NULL;
    CString csTmp;

    // Init Global Vars.        
    g_dwAutoCompMode    = 0;    
    g_szUserOU[0]       = 0;    

    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

    _Module.Init(ObjectMap, hInstance);
    g_hInstance = hInstance;

    // ------------------------------------------------------------------------
    // Do the initial validation to make sure that we can execute the wizard.
    //  If we can't, show an error and exit, if so, get the cmd line parameters
    //  and do the wizard.
    // ------------------------------------------------------------------------

    int iTmp = -1;

    // ------------------------------------------------------------------------
    // Parse command line
    // ------------------------------------------------------------------------
    for ( fBadUsage = FALSE, lpszToken = _FindOption(lpCmdLine) ;                                   // Init to no bad usage and get the first param.
        (!fBadUsage) && (lpszToken != NULL) && (pszCurrentPos = const_cast<LPTSTR>(lpszToken)) ;  // While no bad usage and we still have a param...
        lpszToken = _FindOption(pszCurrentPos) )                                                  // Get the next parameter.
    {
        switch ( *pszCurrentPos )
        {

        case _T('u'):           // HomeOU
        case _T('U'):
            {
                // Only reads in MAX_PATH
                TCHAR szTemp[MAX_PATH+1] = {0};
                if ( !_ReadParam(pszCurrentPos, szTemp) )
                {
                    fBadUsage = TRUE;
                }
                else
                {
                    _tcsncpy( g_szUserOU, szTemp, MAX_PATH );
                    MakeLDAPUpper( g_szUserOU );
                }
                
                break;
            }

        case _T('L'):           // Auto Completion Mode
        case _T('l'):
            {
                TCHAR szMode[MAX_PATH+1] = {0};
                
                // Only reads in MAX_PATH
                if( !_ReadParam(pszCurrentPos, szMode) )
                {
                    fBadUsage = TRUE;
                }
                else
                {
                    g_dwAutoCompMode = _ttoi(szMode);
                }
                break;
            }            

        default:                // Unknown parameter.
            {
                fBadUsage = TRUE;
                break;
            }        
        }
    }

    
    // ------------------------------------------------------------------------
    // Fix up the command line params and launch the wizard.
    // ------------------------------------------------------------------------
    if ( FixParams() )
    {
        DoAddUsr();        
    }

    _Module.Term();
    CoUninitialize();
    return(S_OK);
}


DWORD FixParams(void)
{
    CComPtr<IADs>   pDS = NULL;
    NET_API_STATUS  nApi;

    HRESULT                 hr              = S_OK;
    CString                 csDns           = L"";
    CString                 csNetbios       = L"";
    PDOMAIN_CONTROLLER_INFO pDCInfo         = NULL;
    PDOMAIN_CONTROLLER_INFO pDCI            = NULL;
    DWORD                   dwErr           = 0;
    ULONG                   ulGetDcFlags    = DS_DIRECTORY_SERVICE_REQUIRED | DS_IP_REQUIRED | 
                                              DS_WRITABLE_REQUIRED | DS_RETURN_FLAT_NAME;

    hr = DsGetDcName(NULL, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME, &pDCI);
    if ( (hr == S_OK) && (pDCI != NULL) )
    {
        csDns = pDCI->DomainName;

        NetApiBufferFree (pDCI);
        pDCI = NULL;
    }

    // Pre-Windows2000 DNS name
    dwErr = DsGetDcName(NULL, (LPCWSTR)csDns, NULL, NULL, ulGetDcFlags, &pDCInfo);
    if ( pDCInfo )
    {
        csNetbios = pDCInfo->DomainName;                    // Get the NT4 DNS name.
        NetApiBufferFree(pDCInfo);                          // Free up the memory DsGetDcName() might have allocated.
        pDCInfo = NULL;
    }

    if ( dwErr != ERROR_SUCCESS )                           // If there was a problem, try again.
    {
        ulGetDcFlags |= DS_FORCE_REDISCOVERY;
        dwErr = DsGetDcName(NULL, (LPCWSTR)csDns, NULL, NULL, ulGetDcFlags, &pDCInfo);

        if ( pDCInfo )
        {
            csNetbios = pDCInfo->DomainName;                // Get the NT4 DNS name.
            NetApiBufferFree(pDCInfo);                      // Free up the memory DsGetDcName() might have allocated.
            pDCInfo = NULL;
        }
    }

    tstring strTemp = GetDomainPath((LPCTSTR)csDns);
    if ( strTemp.empty() )
    {
        ErrorMsg(IDS_CANT_FIND_DC, IDS_TITLE);
        return(0);
    }

    TCHAR szDomainOU[MAX_PATH] = {0};
    _sntprintf( szDomainOU, MAX_PATH-1, _T("LDAP://%s"), strTemp.c_str() );
    if ( FAILED(ADsGetObject(szDomainOU, IID_IADs, (void**)&pDS)) )
    {
        ErrorMsg(IDS_CANT_FIND_DC, IDS_TITLE);
        return(0);
    }    

    // ------------------------------------------------------------------------
    // g_szUserOU
    // ------------------------------------------------------------------------
    if ( !_tcslen(g_szUserOU) || FAILED(ADsGetObject(g_szUserOU, IID_IADs, (void**) &pDS)) )     
    {
        _sntprintf( g_szUserOU, (MAX_PATH*2)-1, L"LDAP://CN=Users,%s", strTemp.c_str() );
    }    
    pDS = NULL;    

    if( g_dwAutoCompMode > 3 )
    {
        g_dwAutoCompMode = 0;
    }

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\auw\exe\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__E7317A5F_C27F_45D4_BCA3_4D1E178D301C__INCLUDED_)
#define AFX_STDAFX_H__E7317A5F_C27F_45D4_BCA3_4D1E178D301C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <atltmp.h>
#include <commctrl.h>

#include <string>

typedef std::basic_string<TCHAR> tstring;
typedef tstring TSTRING;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E7317A5F_C27F_45D4_BCA3_4D1E178D301C__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\setup\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\setup\fileperms.h ===
//-----------------------------------------------------------------------------
// fileperms.h
//-----------------------------------------------------------------------------

#include <aclapi.h>

////////////////////////////////////////////////////////////////
//
//  AddPermissionToPath( PATH, ACCOUNT(RID or SAM), PERMISSION, INHERIT, OVERWRITE )
//
//  pszPath - Should be the path to the File Object that you 
//            want to set permissions on.  Note: This is not 
//            setting SHARE permissions, but NTFS file perms.
//            (Directories will work as well.)
//
//  dwRID   - Well-known RID specifying the account you want 
//            to give access to the file.  
//            (DOMAIN_ALIAS_RID_ADMINS, for example.)
//
//  pszSAM  - SAM-Account name specifying the account you want
//            to give access to the file.
//            (Users.h includes all SBS groups and users.)
//
//  nAccess - Specify the File access flags that you want the
//            user to have.
//            (FILE_ALL_ACCESS is the default.)
//
//  bInheritFromParent - Specify whether you want the new ACL
//                       to inherit the parent settings.
//                       (TRUE is the default.)
//
//  bOverwriteExisting - Specify whether you want the existing
//                       ACL on the object to remain.
//                       (FALSE is the default.)
//
//  nInheritance       = Specify the type of inheritance you 
//                       want.
//                       ((OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE) 
//                        is the default.)
//
//                       (NOTE: If you want it to apply to 
//                        directory objects only, use only the 
//                        CONTAINER_INHERIT_ACE.)
//
////////////////////////////////////////////////////////////////

#ifndef _FILEPERMS_H
#define _FILEPERMS_H

inline HRESULT _AddPermissionToPath( LPCTSTR pszPath, 
                                     SID* pSID, 
                                     UINT nAccess = FILE_ALL_ACCESS, 
                                     BOOL bInheritFromParent = TRUE, 
                                     BOOL bOverwriteExisting = FALSE,
                                     UINT nInheritance = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE) )
{
    if( !pszPath ) return E_POINTER;
	if( !pSID )    return E_POINTER;
    
    PSECURITY_DESCRIPTOR    pSD         = NULL;
    PACL                    pOldAcl     = NULL;
    PACL                    pNewAcl     = NULL;    
    DWORD                   dwError     = 0;
    DWORD                   dwOldSize   = 0;
    DWORD                   dwNewSize   = 0;    
    
    ACL_SIZE_INFORMATION    pACLSize;
    ZeroMemory(&pACLSize, sizeof(ACL_SIZE_INFORMATION));    

    // Get the current information for the path
    dwError = GetNamedSecurityInfo( (LPTSTR)pszPath, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, &pOldAcl, NULL, &pSD );
    if( dwError != ERROR_SUCCESS ) 
    {
        goto cleanup;
    }

    // If there was any current information, let's make sure we allocate enough 
    // size for it when we go to add our new ACE.
    if( !bOverwriteExisting && pOldAcl )
    {
        if (!::GetAclInformation( pOldAcl, &pACLSize, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation ))
        {
            dwError = GetLastError();
            goto cleanup;
        }

        dwOldSize = pACLSize.AclBytesInUse;
    }

    dwNewSize = dwOldSize + sizeof(ACL) + sizeof (ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid( pSID );
    pNewAcl = (ACL*)malloc(dwNewSize);
    if (pNewAcl == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    ZeroMemory( pNewAcl, dwNewSize );
    if ( !::InitializeAcl(pNewAcl, dwNewSize, ACL_REVISION) )
    {
        dwError = GetLastError();
        goto cleanup;
    }

    // Copy existing entries into new DACL.    
    if( !bOverwriteExisting )
    {
        for ( DWORD dwCount = 0; dwCount < pACLSize.AceCount; dwCount++ )
        {
            PACCESS_ALLOWED_ACE pACE = NULL;

            // Get the Old ACE
            if ( !::GetAce(pOldAcl, dwCount, (void**)&pACE) )
            {
                ASSERT(FALSE);
                continue;
            }

            if( bInheritFromParent || !(pACE->Header.AceFlags & INHERITED_ACE) )
            {
                // Add it to the new ACL
                if ( !::AddAce(pNewAcl, ACL_REVISION, (DWORD)-1, pACE, pACE->Header.AceSize) )
                {
                    ASSERT(FALSE);
                    continue;
                }
            }
        }
    }
    
    if( !::AddAccessAllowedAceEx(pNewAcl, ACL_REVISION, nInheritance, nAccess, pSID) )
    {
        dwError = GetLastError();
        goto cleanup;
    }    

    SECURITY_INFORMATION siType = DACL_SECURITY_INFORMATION;
    siType |= bInheritFromParent ? 0 : PROTECTED_DACL_SECURITY_INFORMATION;

    dwError = SetNamedSecurityInfo( (LPTSTR)pszPath, SE_FILE_OBJECT, siType, NULL, NULL, pNewAcl, NULL );    
    if( dwError != ERROR_SUCCESS ) 
    {
        goto cleanup;
    }

cleanup:

    if ( pNewAcl != NULL ) 
    {
        free( pNewAcl );
        pNewAcl = NULL;
    }

    if ( pSD != NULL ) 
    {
        LocalFree( pSD );
        pSD = NULL;
        pOldAcl = NULL;
    }
    
    return HRESULT_FROM_WIN32( dwError );
}

//
//  Well-Known RID Version
//

inline HRESULT AddPermissionToPath( LPCTSTR pszPath, 
                                    DWORD dwRID, 
                                    UINT nAccess = FILE_ALL_ACCESS, 
                                    BOOL bInheritFromParent = TRUE, 
                                    BOOL bOverwriteExisting = FALSE,
                                    UINT nInheritance = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE) )
{
    if( !pszPath ) return E_POINTER;
    if( _tcslen(pszPath) == 0 ) return E_INVALIDARG;

    PSID psid = NULL;
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    BOOL bRet = AllocateAndInitializeSid( &sia,
										  2,
										  SECURITY_BUILTIN_DOMAIN_RID,
										  dwRID,
										  0, 0, 0, 0, 0, 0,
										  &psid);
	if( !bRet  )
	{
		return HRESULT_FROM_WIN32( GetLastError() );
	}
	else if( !psid )
	{
		return E_FAIL;
	}
	
	HRESULT hr = _AddPermissionToPath( pszPath, (SID*)psid, nAccess, bInheritFromParent, bOverwriteExisting, nInheritance );
	FreeSid( psid );
	return hr;
}

//
//  SAM Account version
//

inline HRESULT AddPermissionToPath( LPCTSTR pszPath, 
                                    LPCTSTR pszSAM, 
                                    UINT nAccess = FILE_ALL_ACCESS, 
                                    BOOL bInheritFromParent = TRUE, 
                                    BOOL bOverwriteExisting = FALSE,
                                    UINT nInheritance = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE) )
{
    if( !pszPath || !pszSAM ) return E_POINTER;
    if( (_tcslen(pszPath) == 0) || (_tcslen(pszSAM) == 0 ) ) return E_INVALIDARG;

	HRESULT hr          = S_OK;
	DWORD dwSize        = 0;
	DWORD dwDomainSize  = 0;
	SID_NAME_USE snu;
	if( !LookupAccountName(NULL, pszSAM, NULL, &dwSize, NULL, &dwDomainSize, &snu) &&
		GetLastError() == ERROR_INSUFFICIENT_BUFFER )
	{
		SID* psid = (SID*)new BYTE[dwSize];
		if( !psid )
		{
			return E_OUTOFMEMORY;
		}

		TCHAR* pszDomain = new TCHAR[dwDomainSize];
		if( !pszDomain )
		{
			delete[] psid;
			return E_OUTOFMEMORY;
		}

		if( LookupAccountName(NULL, pszSAM, psid, &dwSize, pszDomain, &dwDomainSize, &snu) )
		{
			hr = _AddPermissionToPath( pszPath, psid, nAccess, bInheritFromParent, bOverwriteExisting, nInheritance );
		}
		else
		{
			hr = HRESULT_FROM_WIN32( GetLastError() );
		}

		delete[] psid;
		delete[] pszDomain;
	}
	else
	{
		return E_FAIL;
	}

	return hr;
}

#endif	// _FILEPERMS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\setup\smcys.h ===
// SMCys.h : Declaration of the CSMCys

#ifndef _SMCYS_H
#define _SMCYS_H

#include "SMCysCom.h"
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSMCys
class ATL_NO_VTABLE CSMCys : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<ISMCys, &IID_ISMCys, &LIBID_SMCysComLib>,
    public CComCoClass<CSMCys, &CLSID_SMCys>
{    
public:
    //CSmCys
    CSMCys();
    ~CSMCys();

    DECLARE_REGISTRY_RESOURCEID( IDR_SMCYSCOM )        
    DECLARE_NOT_AGGREGATABLE( CSMCys )        
    DECLARE_PROTECT_FINAL_CONSTRUCT( )
    
    BEGIN_COM_MAP(CSMCys)        
        COM_INTERFACE_ENTRY(ISMCys)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()


public:
    //  ISmCysm
    STDMETHOD(Install)( BSTR bstrDiskName );
};

#endif // _SMCYS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\setup\smcys.cpp ===
// smcys.cpp : Implementation of CSMCys
#include "stdafx.h"
#include "SMCys.h"

#ifndef ASSERT
#define ASSERT _ASSERT
#endif

#include "setupapi.h"
#include "shlobj.h"
#include "fileperms.h"

const TCHAR* pszaMainFilePath[] = 
{
    _T("BOMSnap.dll"),
    _T("BackSnap.dll"),    
    _T("servmgmt.msc"),
    _T("wizchain.dll"),
    _T("au_accnt.dll"),
    _T("addusr.exe"),
    _T("servhome.htm"),
    _T("")
};

const TCHAR* pszaImagesFilePath[] = 
{
    _T("backup.gif"),
    _T("doc.gif"),
    _T("folder.gif"),
    _T("nt_brand.gif"),    
    _T("bg.gif"),    
    _T("cysprint.gif"),
    _T("cysuser.gif"),
    _T("")
};

tstring AddBS( const TCHAR *szDirIn )
{    
    if (!szDirIn || !_tcslen( szDirIn ))
        return _T("");

    tstring str = szDirIn;

    // Do another MBCS ANSI safe comparison
    const TCHAR *szTemp = szDirIn;
    const UINT iSize = _tcsclen( szDirIn ) - 1;
    for( UINT ui = 0; ui < iSize; ui++ )
        szTemp = CharNext( szTemp );

    if (_tcsncmp( szTemp, _T("\\"), 1))
        str += _T("\\");

    return str;
}

BOOL DirExists( const TCHAR *szDir )
{
    _ASSERT( szDir );
    if (!szDir || !_tcslen( szDir ))
        return FALSE;

    DWORD dw = GetFileAttributes( szDir );
    if (dw != INVALID_FILE_ATTRIBUTES)
    {
        if (dw & FILE_ATTRIBUTE_DIRECTORY)
        {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT RegisterFile( tstring strFile )
{
    HRESULT hr = E_FAIL;

    HMODULE hDLL = LoadLibrary( strFile.c_str() );

    if( hDLL )
    {
        HRESULT (STDAPICALLTYPE * lpDllEntryPoint)(void);
        
        (FARPROC&)lpDllEntryPoint = GetProcAddress( hDLL, "DllRegisterServer" );
        if( lpDllEntryPoint )
        {
            hr = (*lpDllEntryPoint)();
        }
        
        FreeLibrary( hDLL );
    }    

    return hr;
}

// ----------------------------------------------------------------------------
// Constructor
// ----------------------------------------------------------------------------
CSMCys::CSMCys()    
{    
}

// ----------------------------------------------------------------------------
// Destructor
// ----------------------------------------------------------------------------
CSMCys::~CSMCys()
{
}

// ----------------------------------------------------------------------------
// Install()
// ----------------------------------------------------------------------------
HRESULT CSMCys::Install( BSTR bstrDiskName )
{   
    if( !bstrDiskName ) return E_POINTER;

    // Create the Administration directory
    tstring strMainInstallPath   = _T("");
    tstring strImagesInstallPath = _T("");    
    TCHAR szSysDir[MAX_PATH+1]   = {0};
    
    tstring strKey      = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Setup");
    tstring strValue    = _T("SourcePath");
    TCHAR   szSuggDir[MAX_PATH] = {0};
    tstring strDirectory = _T("");
    CRegKey cReg;

    if( cReg.Open( HKEY_LOCAL_MACHINE, strKey.c_str() ) == ERROR_SUCCESS )
    {
        DWORD dwRegCount = MAX_PATH;
        if( cReg.QueryValue(szSuggDir, strValue.c_str(), &dwRegCount) != ERROR_SUCCESS )
        {
            szSuggDir[0] = _T('\0');
        }
        else
        {
            strDirectory = AddBS(szSuggDir);
#if defined(_M_IA64)
            strDirectory += _T("ia64");
#else            
            strDirectory += _T("i386");
#endif            
        }
        cReg.Close();
    }

    // Create ADministration Folder
    if( !SHGetSpecialFolderPath( ::GetForegroundWindow(), szSysDir, CSIDL_SYSTEM, TRUE ) )
    {
        return E_FAIL;
    }
    
    strMainInstallPath  = szSysDir;
    strMainInstallPath += _T("\\Administration");

    if( !DirExists( strMainInstallPath.c_str() ) && !CreateDirectory( strMainInstallPath.c_str(), NULL ) )
    {
        return E_FAIL;
    }

    // Set permissions on Admin Folder
    HRESULT hrAdmin = AddPermissionToPath( strMainInstallPath.c_str(), DOMAIN_ALIAS_RID_ADMINS, FILE_ALL_ACCESS, FALSE, TRUE );
    if( FAILED(hrAdmin) )  return hrAdmin;
    HRESULT hrServerOps = AddPermissionToPath( strMainInstallPath.c_str(), DOMAIN_ALIAS_RID_SYSTEM_OPS );
    if( FAILED(hrServerOps) )  return hrServerOps;

    strImagesInstallPath  = strMainInstallPath;
    strImagesInstallPath += _T("\\images");

    if( !DirExists( strImagesInstallPath.c_str() ) && !CreateDirectory( strImagesInstallPath.c_str(), NULL ) )
    {
        return E_FAIL;
    }

    // Copy the main files and register any DLLs
    int nCurrentFile = 0;
    const TCHAR* szCurrentFile = NULL;

    for( szCurrentFile = pszaMainFilePath[nCurrentFile++]; _tcslen(szCurrentFile); szCurrentFile = pszaMainFilePath[nCurrentFile++] )
    {        
        DWORD  dwLen            = MAX_PATH - 1;
        DWORD  dwRealLen        = 0;
        UINT   nRes             = DPROMPT_SUCCESS;
        TCHAR* pszPath          = new TCHAR[MAX_PATH];
        if( !pszPath ) continue;

        nRes = SetupPromptForDisk( ::GetForegroundWindow(), NULL, bstrDiskName, strDirectory.c_str(), szCurrentFile, NULL, IDF_CHECKFIRST | IDF_NOBEEP | IDF_WARNIFSKIP, pszPath, dwLen, &dwRealLen );

        if( nRes == DPROMPT_BUFFERTOOSMALL )
        {
            delete [] pszPath;
            dwLen = dwRealLen;
            pszPath = new TCHAR[dwRealLen];
            if( !pszPath ) continue;
            
            nRes = SetupPromptForDisk( ::GetForegroundWindow(), NULL, bstrDiskName, strDirectory.c_str(), szCurrentFile, NULL, IDF_CHECKFIRST | IDF_NOBEEP | IDF_WARNIFSKIP, pszPath, dwLen, &dwRealLen );
        }
        
        if( nRes == DPROMPT_SUCCESS )
        {
            // Store away the new, real path
            strDirectory = pszPath;

            // Copy the file!            
            tstring strSourceFile = pszPath;
            strSourceFile += _T("\\");
            strSourceFile += szCurrentFile;                        

            tstring strDestFile = strMainInstallPath;
            strDestFile += _T("\\");
            strDestFile += szCurrentFile;

            if( SetupDecompressOrCopyFile( strSourceFile.c_str(), strDestFile.c_str(), NULL ) != ERROR_SUCCESS )
            {
                DWORD dwError = GetLastError();
                if ( (dwError != ERROR_SHARING_VIOLATION) &&
                     (dwError != ERROR_USER_MAPPED_FILE) )     // We don't want to fail if it already exists
                {
                    return E_FAIL;
                }
            }

            TCHAR szExt[_MAX_EXT] = {0};
            _tsplitpath( strDestFile.c_str(), NULL, NULL, NULL, szExt );

            if ( _tcscmp( szExt, _T(".dll") ) == 0 )
            {
                RegisterFile( strDestFile );
            }
        }

        delete [] pszPath;        

        if( nRes != DPROMPT_SUCCESS )
        {
            return E_FAIL;
        }
    }

    // Copy the image files
    nCurrentFile = 0;
    for( szCurrentFile = pszaImagesFilePath[nCurrentFile++]; _tcslen(szCurrentFile); szCurrentFile = pszaImagesFilePath[nCurrentFile++] )
    {        
        DWORD  dwLen            = MAX_PATH-1;
        DWORD  dwRealLen        = 0;                
        UINT   nRes             = DPROMPT_SUCCESS;
        TCHAR* pszPath          = new TCHAR[MAX_PATH];
        if( !pszPath ) continue;
        
        nRes = SetupPromptForDisk( ::GetForegroundWindow(), NULL, bstrDiskName, strDirectory.c_str(), szCurrentFile, NULL, IDF_CHECKFIRST | IDF_NOBEEP | IDF_WARNIFSKIP, pszPath, dwLen, &dwRealLen );
        if( nRes == DPROMPT_BUFFERTOOSMALL )
        {
            delete [] pszPath;
            dwLen = dwRealLen;
            pszPath = new TCHAR[dwRealLen];
            if( !pszPath ) continue;
            
            nRes = SetupPromptForDisk( ::GetForegroundWindow(), NULL, bstrDiskName, strDirectory.c_str(), szCurrentFile, NULL, IDF_CHECKFIRST | IDF_NOBEEP | IDF_WARNIFSKIP, pszPath, dwLen, &dwRealLen );
        }
        
        if( nRes == DPROMPT_SUCCESS )
        {
            // Store away the new, real path
            strDirectory = pszPath;

            // Copy the file!
            tstring strSourceFile = pszPath;
            strSourceFile += _T("\\");
            strSourceFile += szCurrentFile;            

            tstring strDestFile = strImagesInstallPath;
            strDestFile += _T("\\");
            strDestFile += szCurrentFile;

            if( SetupDecompressOrCopyFile( strSourceFile.c_str(), strDestFile.c_str(), NULL ) != ERROR_SUCCESS )
            {
                DWORD dwError = GetLastError();
                if ( (dwError != ERROR_SHARING_VIOLATION) &&
                     (dwError != ERROR_USER_MAPPED_FILE) )     // We don't want to fail if it already exists
                {
                    return E_FAIL;
                }
            }            
        }
        
        delete [] pszPath;    

        if( nRes != DPROMPT_SUCCESS )
        {
            return E_FAIL;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\setup\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__54C42B2D_405C_11D3_B40C_00C04F9900F5__INCLUDED_)
#define AFX_STDAFX_H__54C42B2D_405C_11D3_B40C_00C04F9900F5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0501
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <string>
typedef std::basic_string<TCHAR> tstring;
typedef tstring TSTRING;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__54C42B2D_405C_11D3_B40C_00C04F9900F5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\setup\smcyscom.cpp ===
// AU_Accnt.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f AU_Accntps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>

#include "SMCysCom.h"
#include "SMCysCom_i.c"

#include "SMCys.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SMCys, CSMCys)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SMCysComLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\backup\backup.cpp ===
// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f svrgrpsnapps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "Backup.h"

#include "Backup_i.c"
#include "BackupSnap.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_BackupSnap, CBackupSnapData)
OBJECT_ENTRY(CLSID_BackupSnapAbout, CBackupSnapAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_BackupSNAPLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\backup\resource.h ===
// localizable strings
#define IDS_BackupSNAP_DESC         100
#define IDS_SnapinName				101

#define IDS_WARNING                 200

// non-loc
#define IDS_BackupSNAP_PROVIDER     8000
#define IDS_HELPFILE                8001
#define IDS_HELPTOPIC               8002

// registry
#define IDR_BackupSNAP              10000

// img
#define IDI_Icon					9000
#define IDB_Small					9001
#define IDB_Large					9002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\backup\backupsnap.cpp ===
#include "stdafx.h"
#include "BackupSnap.h"
#include "Backup.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// CBackupSnapNode
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

static const GUID CBackupSnapGUID_NODETYPE = 
{ 0x3fa55cce, 0x7d0a, 0x4b5c, { 0x90, 0xe9, 0x6e, 0x8c, 0xcb, 0x77, 0x5b, 0x23 } };

const GUID*    CBackupSnapNode::m_NODETYPE       = &CBackupSnapGUID_NODETYPE;
const OLECHAR* CBackupSnapNode::m_SZNODETYPE     = OLESTR("3FA55CCE-7D0A-4b5c-90E9-6E8CCB775B23");
const OLECHAR* CBackupSnapNode::m_SZDISPLAY_NAME = OLESTR("");
const CLSID*   CBackupSnapNode::m_SNAPIN_CLASSID = &CLSID_BackupSnap;

CBackupSnapNode::CBackupSnapNode()
{
    // Initialize Scope Data Information
    memset(&m_scopeDataItem, 0, sizeof(m_scopeDataItem));
    m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
    m_scopeDataItem.displayname = L"";
    m_scopeDataItem.nImage = 0;         
    m_scopeDataItem.nOpenImage = 0;     
    m_scopeDataItem.lParam = (LPARAM) this;

    // Initialize Result Data Information
    memset(&m_resultDataItem, 0, sizeof(m_resultDataItem));
    m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
    m_resultDataItem.str = L"";
    m_resultDataItem.nImage = 0;    
    m_resultDataItem.lParam = (LPARAM) this;

    // Load the Snap-In Display Name
    tstring strTemp   = StrLoadString( IDS_SnapinName );
    m_bstrDisplayName = strTemp.c_str();  

    if( m_bstrDisplayName.m_str )
    {
        m_SZDISPLAY_NAME = m_bstrDisplayName.m_str;
    }
}


HRESULT CBackupSnapNode::GetScopePaneInfo(SCOPEDATAITEM *pScopeDataItem)
{
    if( !pScopeDataItem ) return E_POINTER;

    if( pScopeDataItem->mask & SDI_STR )
        pScopeDataItem->displayname = m_bstrDisplayName;
    if( pScopeDataItem->mask & SDI_IMAGE )
        pScopeDataItem->nImage = m_scopeDataItem.nImage;
    if( pScopeDataItem->mask & SDI_OPENIMAGE )
        pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
    if( pScopeDataItem->mask & SDI_PARAM )
        pScopeDataItem->lParam = m_scopeDataItem.lParam;
    if( pScopeDataItem->mask & SDI_STATE )
        pScopeDataItem->nState = m_scopeDataItem.nState;
    
    return S_OK;
}

HRESULT CBackupSnapNode::GetResultPaneInfo(RESULTDATAITEM *pResultDataItem)
{
    if( !pResultDataItem ) return E_POINTER;

    if( pResultDataItem->bScopeItem )
    {
        if( pResultDataItem->mask & RDI_STR )
        {
            pResultDataItem->str = L"";
        }
        if( pResultDataItem->mask & RDI_IMAGE )
        {
            pResultDataItem->nImage = m_scopeDataItem.nImage;
        }
        if( pResultDataItem->mask & RDI_PARAM )
        {
            pResultDataItem->lParam = m_scopeDataItem.lParam;
        }

        return S_OK;
    }
    if( pResultDataItem->mask & RDI_STR )
    {
        pResultDataItem->str = L"";
    }
    if( pResultDataItem->mask & RDI_IMAGE )
    {
        pResultDataItem->nImage = m_resultDataItem.nImage;
    }
    if( pResultDataItem->mask & RDI_PARAM )
    {
        pResultDataItem->lParam = m_resultDataItem.lParam;
    }
    if( pResultDataItem->mask & RDI_INDEX )
    {
        pResultDataItem->nIndex = m_resultDataItem.nIndex;
    }

    return S_OK;
}

HRESULT CBackupSnapNode::GetClassID(CLSID* pID)
{
    if( !pID ) return E_POINTER;

    pID = (CLSID*)m_SNAPIN_CLASSID;

    return S_OK;
}
HRESULT CBackupSnapNode::Notify( MMC_NOTIFY_TYPE event,
                                 LPARAM arg,
                                 LPARAM param,
                                 IComponentData* pComponentData,
                                 IComponent* pComponent,
                                 DATA_OBJECT_TYPES type)
{
    HRESULT hr = S_FALSE;

    _ASSERT( pComponentData || pComponent );

    CComPtr<IConsole> spConsole = NULL;    
    if( pComponentData )
    {
        spConsole = ((CBackupSnapData*)pComponentData)->m_spConsole;
    }
    else if ( pComponent )
    {
        spConsole = ((CBackupSnapComponent*)pComponent)->m_spConsole;
    }    
    
    if( !spConsole ) return E_INVALIDARG;

    switch( event )
    {
    case MMCN_SHOW:
        {
            hr = S_OK;
            // configure the ocx message in the result pane
            IMessageView* pIMessageView = NULL;
            LPUNKNOWN pIUnk = NULL;
            hr = spConsole->QueryResultView(&pIUnk);

            if( SUCCEEDED(hr) )
            {
                hr = pIUnk->QueryInterface(_uuidof(IMessageView), reinterpret_cast<void**>(&pIMessageView));
            }

            if( SUCCEEDED(hr) )
            {
                hr = pIMessageView->SetIcon(Icon_Information);
            }
            
            if( SUCCEEDED(hr) )
            {
                tstring strTitle = StrLoadString( IDS_SnapinName );                
                hr = pIMessageView->SetTitleText( strTitle.c_str() );
            }
            
            if( SUCCEEDED(hr) )
            {
                tstring strMessage = StrLoadString( IDS_WARNING );                
                hr = pIMessageView->SetBodyText( strMessage.c_str() );
            }            

            if( pIMessageView )
            {
                pIMessageView->Release();
                pIMessageView = NULL;
            }

            break;
        }
    case MMCN_EXPAND:
        {                
            hr = S_OK;
            break;
        }
    case MMCN_ADD_IMAGES:
        {            
            IImageList* pImageList = (IImageList*)arg;
            if( !pImageList ) return E_INVALIDARG;
            
            hr = LoadImages(pImageList);
            break;
        }
    case MMCN_SELECT:
        {
            // if selecting node
            if( HIWORD(arg) )
            {
                hr = S_OK;

                // get the verb interface and enable rename
                CComPtr<IConsoleVerb> spConsVerb;
                if( spConsole->QueryConsoleVerb(&spConsVerb) == S_OK )
                {
                    hr = spConsVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, FALSE); 
                    if( FAILED(hr) ) return hr;

                    spConsVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);
                    if( FAILED(hr) ) return hr;
                }
            }

            
            break;
        }    

    case MMCN_CONTEXTHELP:
        {
            hr                                = S_OK;
            TCHAR    szWindowsDir[MAX_PATH+1] = {0};
            tstring  strHelpFile              = _T("");
            tstring  strHelpFileName          = StrLoadString(IDS_HELPFILE);
            tstring  strHelpTopicName         = StrLoadString(IDS_HELPTOPIC);

            if( strHelpFileName.empty() || strHelpTopicName.empty() )
            {
                return E_FAIL;
            }
            
            // Build path to %systemroot%\help
            UINT nSize = GetSystemWindowsDirectory( szWindowsDir, MAX_PATH );
            if( nSize == 0 || nSize > MAX_PATH )
            {
                return E_FAIL;
            }            
        
            strHelpFile = szWindowsDir;       // D:\windows
            strHelpFile += _T("\\Help\\");    // \help
            strHelpFile += strHelpFileName;   // \filename.chm
            strHelpFile += _T("::/");         // ::/
            strHelpFile += strHelpTopicName;  // index.htm            
        
            // Show the Help topic
            CComQIPtr<IDisplayHelp> spHelp = spConsole;
            if( !spHelp ) return E_NOINTERFACE;

            hr = spHelp->ShowTopic( (LPTSTR)strHelpFile.c_str() );
        
            break;
        }

    }// switch

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//
// CBackupSnapData
//
//////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////



HRESULT CBackupSnapData::Initialize(LPUNKNOWN pUnknown)
{
    if( !pUnknown ) return E_POINTER;

    HRESULT hr = IComponentDataImpl<CBackupSnapData, CBackupSnapComponent >::Initialize(pUnknown);
    if( FAILED(hr) ) return hr;

    CComPtr<IImageList> spImageList;


    if( m_spConsole->QueryScopeImageList(&spImageList) != S_OK )
    {
        ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
        return E_UNEXPECTED;
    }

    hr = LoadImages(spImageList);
    return hr;
}

HRESULT WINAPI CBackupSnapData::UpdateRegistry(BOOL bRegister)
{
    // Load snap-in name 
    tstring strSnapinName = StrLoadString(IDS_SnapinName);

    // Specify the substitution parameters for IRegistrar.
    _ATL_REGMAP_ENTRY rgEntries[] =
    {
        {TEXT("SNAPIN_NAME"), strSnapinName.c_str()},
        {NULL, NULL},
    };

    // Register the component data object
    return _Module.UpdateRegistryFromResource(IDR_BackupSNAP, bRegister, rgEntries);
}

HRESULT CBackupSnapData::GetHelpTopic(LPOLESTR* ppszHelpFile)
{
    if( !ppszHelpFile ) return E_POINTER;

    USES_CONVERSION;
	*ppszHelpFile = NULL;    

    tstring strHelpFileName = StrLoadString(IDS_HELPFILE);    
    if( strHelpFileName.empty() ) return E_FAIL;
    
    // Build path to %systemroot%\help
    TCHAR szWindowsDir[MAX_PATH+1] = {0};
    UINT nSize = GetSystemWindowsDirectory( szWindowsDir, MAX_PATH );
    if( (nSize == 0) || (nSize > MAX_PATH) ) return E_FAIL;

    tstring strHelpFile = szWindowsDir; // D:\windows
    strHelpFile += _T("\\Help\\");      // \help
    strHelpFile += strHelpFileName;     // \filename.chm    

    // Show the Help topic
    // Form file path in allocated buffer
    int nLen = strHelpFile.length() + 1;

    *ppszHelpFile = (LPOLESTR)CoTaskMemAlloc(nLen * sizeof(OLECHAR));
    if( !*ppszHelpFile ) return E_OUTOFMEMORY;

    // Copy into allocated buffer
    ocscpy( *ppszHelpFile, T2OLE((LPTSTR)strHelpFile.c_str()) );

    return S_OK;
}


HRESULT CBackupSnapData::GetLinkedTopics(LPOLESTR* ppszLinkedFiles)
{
    if( !ppszLinkedFiles ) return E_POINTER;

	// no linked files
	*ppszLinkedFiles = NULL;

	return S_FALSE;
}



////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
//
// CBackupSnapComponent
//
//////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////

CBackupSnapComponent::CBackupSnapComponent()
{    
}


HRESULT CBackupSnapComponent::GetClassID(CLSID* pID)
{
    return m_pComponentData->GetClassID(pID);
}

HRESULT CBackupSnapComponent::GetResultViewType( MMC_COOKIE cookie, LPOLESTR* ppViewType, long* pViewOptions )
{   
    if( !ppViewType ) return E_POINTER;

    // show standard MMC OCX with message in the result pane
    HRESULT hr = StringFromCLSID(CLSID_MessageView, ppViewType);
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\backup\backupsnap.h ===
#ifndef BackupSnap_h
#define BackupSnap_h

#include "Backup.h"

#include <winver.h>
#include <objidl.h>
#include <atlsnap.h>


//////////////////////////////////////////////////////////////////////////////////
//
// CBackupSnapNode
//
//////////////////////////////////////////////////////////////////////////////////
class CBackupSnapNode : public CSnapInItemImpl<CBackupSnapNode>
{
public:
    static const GUID*    m_NODETYPE;
    static const OLECHAR* m_SZNODETYPE;
    static const OLECHAR* m_SZDISPLAY_NAME;
    static const CLSID*   m_SNAPIN_CLASSID;

    CComPtr<IControlbar> m_spControlBar;

    BEGIN_SNAPINCOMMAND_MAP(CBackupSnapNode, FALSE)
    END_SNAPINCOMMAND_MAP()

    CBackupSnapNode();
    
    virtual ~CBackupSnapNode()
    {
    }

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if ( type == CCT_SCOPE || type == CCT_RESULT )
            return S_OK;
        return S_FALSE;
    }
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem);
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem);
    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param, IComponentData* pComponentData, IComponent* pComponent, DATA_OBJECT_TYPES type );
    LPOLESTR GetResultPaneColInfo(int nCol);
    STDMETHOD(GetClassID)(CLSID* pID);
};

class CBackupSnapData;

/////////////////////////////////////////////////////////////////////////////////
//
// CBackupSnapComponent
//
////////////////////////////////////////////////////////////////////////////////
class CBackupSnapComponent : public CComObjectRootEx<CComSingleThreadModel>,
public CSnapInObjectRoot<2, CBackupSnapData>,
public IComponentImpl<CBackupSnapComponent>
{
public:
    BEGIN_COM_MAP(CBackupSnapComponent)
        COM_INTERFACE_ENTRY(IComponent)
    END_COM_MAP()

    public:

    CBackupSnapComponent();

    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
    {
        if ( lpDataObject != NULL )
        {
            return IComponentImpl<CBackupSnapComponent>::Notify(lpDataObject, event, arg, param);
        }
        else if ( event == MMCN_PROPERTY_CHANGE )
        {
            return S_OK;
        }
        return E_NOTIMPL;
    }
    HRESULT GetClassID(CLSID* pID);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie, LPOLESTR* ppViewType, long* pViewOptions);    
};

//////////////////////////////////////////////////////////////////////////////////////////////////
//
// CBackupSnapData
//
/////////////////////////////////////////////////////////////////////////////////////////////////
class CBackupSnapData : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CSnapInObjectRoot<1, CBackupSnapData>,
    public IComponentDataImpl<CBackupSnapData, CBackupSnapComponent>,
    public CComCoClass<CBackupSnapData, &CLSID_BackupSnap>,
    public ISnapinHelp2
{
public:

    CBackupSnapData()
    {
        // Has to be done in the constructor (Templated Class requires it)
        m_pNode = new CBackupSnapNode;
        _ASSERT(m_pNode != NULL);

        m_pComponentData = this;
    }

    virtual ~CBackupSnapData()
    {
        if( m_pNode )
        {
            delete m_pNode;
            m_pNode = NULL;
        }
    }

    BEGIN_COM_MAP(CBackupSnapData)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(ISnapinHelp2)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CBackupSnapData)

    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

    static void WINAPI ObjectMain(bool bStarting)
    {
        if ( bStarting )
            CSnapInItem::Init();
    }
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
    {
        if ( lpDataObject != NULL )
            return IComponentDataImpl<CBackupSnapData, CBackupSnapComponent>::Notify(lpDataObject, event, arg, param);

        return E_NOTIMPL;
    }

    STDMETHOD(GetClassID)(CLSID* pID)
    {
        if( m_pNode )
        {
            return static_cast<CBackupSnapNode*>(m_pNode)->GetClassID(pID);
        }

        return E_FAIL;
    }

    // ISnapinHelp2
	STDMETHOD(GetHelpTopic)(LPOLESTR* ppszHelpFile);
	STDMETHOD(GetLinkedTopics)(LPOLESTR* ppszHelpFiles);

    // Class registration method
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister); 
};

//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CBackupSnapAbout
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CBackupSnapAbout : public ISnapinAbout,
public CComObjectRoot,
public CComCoClass< CBackupSnapAbout, &CLSID_BackupSnapAbout>
{
public:
    DECLARE_REGISTRY(CBackupSnapAbout, _T("BackupSnapAbout.1"), _T("BackupSnapAbout.1"), IDS_BackupSNAP_DESC, THREADFLAGS_BOTH);

    HICON m_hIcon;

    BEGIN_COM_MAP(CBackupSnapAbout)
        COM_INTERFACE_ENTRY(ISnapinAbout)
    END_COM_MAP()

    CBackupSnapAbout()
    {
        m_hIcon = NULL;
    }

    STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
    {
        if( !lpDescription ) return E_POINTER;

        USES_CONVERSION;
        tstring strDescription = StrLoadString(IDS_BackupSNAP_DESC);
        if( strDescription.empty() ) return E_FAIL;

        *lpDescription = (LPOLESTR)CoTaskMemAlloc((strDescription.length() + 1) * sizeof(OLECHAR));
        if ( *lpDescription == NULL ) return E_OUTOFMEMORY;

        ocscpy(*lpDescription, T2OLE((LPTSTR)strDescription.c_str()));

        return S_OK;
    }

    STDMETHOD(GetProvider)(LPOLESTR *lpName)
    {
        if( !lpName ) return E_POINTER;

        USES_CONVERSION;
        tstring strProvider = StrLoadString(IDS_BackupSNAP_PROVIDER);
        if( strProvider.empty() ) return E_FAIL;

        *lpName = (LPOLESTR)CoTaskMemAlloc((strProvider.length() + 1) * sizeof(OLECHAR));
        if ( *lpName == NULL ) return E_OUTOFMEMORY;

        ocscpy( *lpName, T2OLE((LPTSTR)strProvider.c_str()) );

        return S_OK;
    }

    STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
    {
        if( !lpVersion ) return E_INVALIDARG;

        USES_CONVERSION;

        // Get the Module Filename
        TCHAR szBuf[MAX_PATH+1] = {0};
        DWORD dwLen = GetModuleFileName( _Module.GetModuleInstance(), szBuf, MAX_PATH );        
        if( (dwLen <= 0) || (dwLen > MAX_PATH) ) return E_FAIL;

        // Get the Size and Translation of the file
        LPDWORD pTranslation    = NULL;
        UINT    uNumTranslation = 0;
        DWORD   dwHandle        = NULL;
        DWORD   dwSize          = GetFileVersionInfoSize(szBuf, &dwHandle);
        if( !dwSize ) return E_FAIL;

        BYTE* pVersionInfo = new BYTE[dwSize];           
        if( !pVersionInfo ) return E_OUTOFMEMORY;

        if (!GetFileVersionInfo( szBuf, dwHandle, dwSize, pVersionInfo ) ||
            !VerQueryValue( (const LPVOID)pVersionInfo, _T("\\VarFileInfo\\Translation"), (LPVOID*)&pTranslation, &uNumTranslation ) ||
            !pTranslation ) 
        {
            delete [] pVersionInfo;
            
            pVersionInfo    = NULL;                
            pTranslation    = NULL;
            uNumTranslation = 0;

            return E_FAIL;
        }

        uNumTranslation /= sizeof(DWORD);           

        tstring strQuery = _T("\\StringFileInfo\\");            

        // 8 characters for the language/char-set, 
        // 1 for the slash, 
        // 1 for terminating NULL
        TCHAR szTranslation[128] = {0};            
        _sntprintf( szTranslation, 127, _T("%04x%04x\\"), LOWORD(*pTranslation), HIWORD(*pTranslation));

        strQuery += szTranslation;            
        strQuery += _T("FileVersion");

        LPBYTE lpVerValue = NULL;
        UINT uSize = 0;

        if (!VerQueryValue(pVersionInfo, (LPTSTR)strQuery.c_str(), (LPVOID *)&lpVerValue, &uSize)) 
        {
            delete [] pVersionInfo;
            return E_FAIL;
        }

        // check the version            
        _tcsncpy( szBuf, (LPTSTR)lpVerValue, MAX_PATH-1 );
        delete [] pVersionInfo;

        *lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if( *lpVersion == NULL ) return E_OUTOFMEMORY;

        ocscpy( *lpVersion, T2OLE(szBuf) );

        return S_OK;
    }

    STDMETHOD(GetSnapinImage)(HICON* phAppIcon)
    {
        if( !phAppIcon ) return E_POINTER;

        if( !m_hIcon )
        {
            m_hIcon = LoadIcon(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_Icon));
        }

        *phAppIcon = m_hIcon;

        return S_OK;
    }

    STDMETHOD(GetStaticFolderImage)(HBITMAP*  phSmallImage,
                                    HBITMAP*  phSmallImageOpen,
                                    HBITMAP*  phLargeImage,
                                    COLORREF* pcMask)
    {
        if( !phSmallImage || !phSmallImageOpen || !phLargeImage || !pcMask ) return E_POINTER;

        *phSmallImage     = LoadBitmap(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_Small));
        *phSmallImageOpen = LoadBitmap(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_Small));
        *phLargeImage     = LoadBitmap(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_Large));
        *pcMask           = RGB(255,0,255);

        return S_OK;
    }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\backup\stdafx.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

#include <string>
#include <list>

typedef std::basic_string<TCHAR> tstring;

#include "resource.h"
#include "commctrl.h"

#include <mmc.h>

HRESULT LoadImages( IImageList* pImageList );
tstring StrLoadString( UINT uID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\backup\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

HRESULT LoadImages(IImageList* pImageList)
{
    HRESULT hr = E_FAIL;

    if( pImageList )
    {
        HICON hIcon = (HICON)::LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_Icon), IMAGE_ICON, 0,0,0);

        if( hIcon )
        {
            hr = pImageList->ImageListSetIcon((LONG_PTR *)hIcon, 0);
        }
    }

    return hr;
}

tstring StrLoadString( UINT uID )
{ 
    tstring   strRet = _T("");
    HINSTANCE hInst  = _Module.GetResourceInstance();    
    INT       iSize  = MAX_PATH;
    TCHAR*    psz    = new TCHAR[iSize];
    if( !psz ) return strRet;
    
    while( LoadString(hInst, uID, psz, iSize) == (iSize - 1) )
    {
        iSize += MAX_PATH;
        delete[] psz;
        psz = NULL;
        
        psz = new TCHAR[iSize];
        if( !psz ) return strRet;
    }

    strRet = psz;
    delete[] psz;

    return strRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\about.h ===
// About.h : Declaration of the CSnapInAbout

#ifndef __ABOUT_H_
#define __ABOUT_H_

#include "resource.h"       // main symbols
#include "atlgdi.h"

/////////////////////////////////////////////////////////////////////////////
// CSnapInAbout
class ATL_NO_VTABLE CSnapInAbout : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSnapInAbout, &CLSID_BOMSnapInAbout>,
	public ISnapinAbout

{
public:

    CSnapInAbout() : m_hIcon(NULL) {}
 
    DECLARE_REGISTRY_RESOURCEID(IDR_ABOUT)
    DECLARE_NOT_AGGREGATABLE(CSnapInAbout)

    BEGIN_COM_MAP(CSnapInAbout)
        COM_INTERFACE_ENTRY(ISnapinAbout)
    END_COM_MAP()


    //
    // ISnapinAbout methods
    //
public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR* lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR* lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR* lpVersion);
    STDMETHOD(GetSnapinImage)(HICON* hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP* hSmallImage,
                                    HBITMAP* hSmallImageOpen,
                                    HBITMAP* hLargeImage,
                                    COLORREF* cLargeMask);

private:
	HRESULT GetString(UINT nID, LPOLESTR* psz);

    HICON   m_hIcon;
    CBitmap m_bmpSmallImage;
    CBitmap m_bmpSmallImageOpen;
    CBitmap m_bmpLargeImage;

};

#endif //__ABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\about.cpp ===
// About.cpp : Implementation of CSnapInAbout

#include "stdafx.h"
#include "about.h"
#include "util.h"

#include <winver.h>

//////////////////////////////////////////////////////////////////////////////////////////////
//

HRESULT CSnapInAbout::GetString( UINT nID, LPOLESTR* ppsz )
{
    VALIDATE_POINTER(ppsz)

    USES_CONVERSION;

    tstring strTemp = StrLoadString(nID);
    if( strTemp.empty() ) return E_FAIL;

    *ppsz = reinterpret_cast<LPOLESTR>( CoTaskMemAlloc( (strTemp.length() + 1) * sizeof(OLECHAR)) );
    if( *ppsz == NULL ) return E_OUTOFMEMORY;
    
    ocscpy( *ppsz, T2OLE((LPTSTR)strTemp.c_str()) );

    return S_OK;
}


HRESULT CSnapInAbout::GetSnapinDescription( LPOLESTR* ppszDescr )
{
    return GetString(IDS_SNAPIN_DESC, ppszDescr);
}


HRESULT CSnapInAbout::GetProvider( LPOLESTR* ppszName )
{
    return GetString(IDS_COMPANY, ppszName);
}


HRESULT CSnapInAbout::GetSnapinVersion( LPOLESTR* ppszVersion )
{
    if( !ppszVersion ) return E_INVALIDARG;

    USES_CONVERSION;

    TCHAR szBuf[MAX_PATH] = {0};
    DWORD dwLen = GetModuleFileName( _Module.GetModuleInstance(), szBuf, MAX_PATH );        

    if( dwLen < MAX_PATH )
    {            
        LPDWORD pTranslation    = NULL;
        UINT    uNumTranslation = 0;
        DWORD   dwHandle        = NULL;
        DWORD   dwSize          = GetFileVersionInfoSize(szBuf, &dwHandle);
        if( !dwSize ) return E_FAIL;

        BYTE* pVersionInfo = new BYTE[dwSize];           
        if( !pVersionInfo ) return E_OUTOFMEMORY;

        if (!GetFileVersionInfo( szBuf, dwHandle, dwSize, pVersionInfo ) ||
            !VerQueryValue( (const LPVOID)pVersionInfo, _T("\\VarFileInfo\\Translation"), (LPVOID*)&pTranslation, &uNumTranslation ) ||
            !pTranslation ) 
        {
            delete [] pVersionInfo;
            
            pVersionInfo    = NULL;                
            pTranslation    = NULL;
            uNumTranslation = 0;

            return E_FAIL;
        }

        uNumTranslation /= sizeof(DWORD);           

        tstring strQuery = _T("\\StringFileInfo\\");            

        // 8 characters for the language/char-set, 
        // 1 for the slash, 
        // 1 for terminating NULL
        TCHAR szTranslation[128] = {0};            
        _sntprintf( szTranslation, 127, _T("%04x%04x\\"), LOWORD(*pTranslation), HIWORD(*pTranslation));

        strQuery += szTranslation;            
        strQuery += _T("FileVersion");

        LPBYTE lpVerValue = NULL;
        UINT uSize = 0;

        if (!VerQueryValue(pVersionInfo, (LPTSTR)strQuery.c_str(), (LPVOID *)&lpVerValue, &uSize)) 
        {
            delete [] pVersionInfo;
            return E_FAIL;
        }

        // check the version            
        _tcsncpy( szBuf, (LPTSTR)lpVerValue, MAX_PATH-1 );

        delete [] pVersionInfo;
    }        

    *ppszVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
    if( *ppszVersion == NULL ) return E_OUTOFMEMORY;

    ocscpy( *ppszVersion, T2OLE(szBuf) );

    return S_OK;
}


HRESULT CSnapInAbout::GetSnapinImage(HICON* phAppIcon)
{
    VALIDATE_POINTER(phAppIcon)

    if( !m_hIcon )
    {
        m_hIcon = ::LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_APPL));
    }

    *phAppIcon = m_hIcon;

    return (m_hIcon ? S_OK : E_FAIL);
}


HRESULT CSnapInAbout::GetStaticFolderImage(HBITMAP*  phSmallImage, 
                                           HBITMAP*  phSmallImageOpen,
                                           HBITMAP*  phLargeImage, 
                                           COLORREF* pcMask)
{
    if( !phSmallImage || !phSmallImageOpen || !phLargeImage || !pcMask ) return E_POINTER;

    if( !(HBITMAP)m_bmpSmallImage )
    {
        CBitmap bmp16;

        if( bmp16.LoadBitmap(IDB_ROOT16) )
        {
            m_bmpSmallImage = GetBitmapFromStrip(bmp16, ROOT_NODE_IMAGE, 16);
            m_bmpSmallImageOpen = GetBitmapFromStrip(bmp16, ROOT_NODE_OPENIMAGE, 16);
        }
    }

    if( !(HBITMAP)m_bmpLargeImage )
    {
       CBitmap bmp32;

       if( bmp32.LoadBitmap(IDB_ROOT32) )
       {
           m_bmpLargeImage = GetBitmapFromStrip(bmp32, ROOT_NODE_IMAGE, 32);
       }
    }

    *phSmallImage     = (HBITMAP)m_bmpSmallImage;
    *phSmallImageOpen = (HBITMAP)m_bmpSmallImageOpen;
    *phLargeImage     = (HBITMAP)m_bmpLargeImage;
    *pcMask           = RGB(255,0,255);

    return S_OK;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\adext.cpp ===
// adext.cpp - Active Directory Extension class

#include "stdafx.h"

#include "adext.h"
#include "util.h"
#include "query.h"

#include <shellapi.h>
#include <atlgdi.h>
#include <shlobj.h>
#include <dsclient.h>

#include <lmcons.h> 
#include <lmapibuf.h> // NetApiBufferFree
#include <dsgetdc.h>  // DsGetDCName

// Proxy window class object
CMsgWindowClass ADProxyWndClass(L"ADProxyClass", CActDirExtProxy::WndProc);

UINT CADDataObject::m_cfDsObjects = RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
UINT CADDataObject::m_cfDsDispSpecOptions = RegisterClipboardFormat(CFSTR_DSDISPLAYSPECOPTIONS);


HRESULT CADDataObject::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
{   
    if( !lpFormatetcIn || !lpMedium ) return E_POINTER;

    if (lpFormatetcIn->cfFormat == m_cfDsObjects)
    {
		// Form full object path of form: LDAP://<dc name>/<obj path>
		tstring strFullPath = L"LDAP://";
		strFullPath +=  m_strDcName;
		strFullPath += L"/";
		strFullPath += m_strObjPath;

        // Get sizes of strings to be returned
        int cbObjPath = (strFullPath.length() + 1) * sizeof(WCHAR);
        int cbClass   = (m_strClass.length() + 1) * sizeof(WCHAR);

        // Allocate global memory for object names struct plus two strings
        HGLOBAL hGlobal = ::GlobalAlloc(GMEM_SHARE | GMEM_FIXED, sizeof(DSOBJECTNAMES) + cbObjPath + cbClass);
        if (hGlobal == NULL) return STG_E_MEDIUMFULL;

        // Fill in object names struct
        LPDSOBJECTNAMES pObjNames = reinterpret_cast<LPDSOBJECTNAMES>(GlobalLock(hGlobal));
        if( !pObjNames ) return E_OUTOFMEMORY;

        memset(&pObjNames->clsidNamespace, 0, sizeof(GUID));
		memcpy(&pObjNames->clsidNamespace, &CLSID_MicrosoftDS, sizeof(CLSID_MicrosoftDS));

        pObjNames->cItems = 1;
        pObjNames->aObjects[0].dwFlags = DSPROVIDER_ADVANCED;
        pObjNames->aObjects[0].dwProviderFlags = 0;
        pObjNames->aObjects[0].offsetName = sizeof(DSOBJECTNAMES);
        pObjNames->aObjects[0].offsetClass = sizeof(DSOBJECTNAMES) + cbObjPath;

        // Append strings to struct
        memcpy((LPBYTE)pObjNames + pObjNames->aObjects[0].offsetName, strFullPath.c_str(), cbObjPath);
        memcpy((LPBYTE)pObjNames + pObjNames->aObjects[0].offsetClass, m_strClass.c_str(), cbClass);

        GlobalUnlock(hGlobal);

        // fill in medium struct    
        lpMedium->tymed = TYMED_HGLOBAL;
        lpMedium->hGlobal = hGlobal;
        lpMedium->pUnkForRelease = NULL;

        return S_OK;
    }
    else if (lpFormatetcIn->cfFormat == m_cfDsDispSpecOptions)
    {
        static WCHAR szPrefix[] = L"admin";
        
		int cbDcName = (m_strDcName.length() + 1) * sizeof(WCHAR);

        // Allocate global memory for options struct plus prefix string and Dc name
        // BUGBUG - Due to an error in the DSPropertyPages code (dsuiext.dll), we must pass it a fixed memory block
        HGLOBAL hGlobal = ::GlobalAlloc(GMEM_SHARE | GMEM_FIXED, sizeof(DSDISPLAYSPECOPTIONS) + sizeof(szPrefix) + cbDcName);
        if (hGlobal == NULL) return STG_E_MEDIUMFULL;
        
        // Fill in struct
        LPDSDISPLAYSPECOPTIONS pOptions = reinterpret_cast<LPDSDISPLAYSPECOPTIONS>(GlobalLock(hGlobal));
        if( !pOptions ) return E_OUTOFMEMORY;

        pOptions->dwSize = sizeof(DSDISPLAYSPECOPTIONS);
        pOptions->dwFlags = DSDSOF_HASUSERANDSERVERINFO;
        pOptions->offsetAttribPrefix = sizeof(DSDISPLAYSPECOPTIONS);
        pOptions->offsetUserName = 0;
        pOptions->offsetPassword = 0;
        pOptions->offsetServer = pOptions->offsetAttribPrefix + sizeof(szPrefix);
        pOptions->offsetServerConfigPath = 0;

        // Append prefix string
        memcpy((LPBYTE)pOptions + pOptions->offsetAttribPrefix, szPrefix, sizeof(szPrefix));
	    memcpy((LPBYTE)pOptions + pOptions->offsetServer, m_strDcName.c_str(), cbDcName); 

        GlobalUnlock(hGlobal);

        // fill in medium struct    
        lpMedium->tymed = TYMED_HGLOBAL;
        lpMedium->hGlobal = hGlobal;
        lpMedium->pUnkForRelease = NULL;

        return S_OK;
    }

    return DV_E_FORMATETC;
}


/////////////////////////////////////////////////////////////////////////////////////////
// CActDirExt

HRESULT CActDirExt::Initialize(LPCWSTR pszClass, LPCWSTR pszObjPath)
{
    if( !pszClass || !pszObjPath ) return E_POINTER;

    // Escape each forward slash in object name
    tstring strObj;
    EscapeSlashes(pszObjPath, strObj);

    // Get DC name    
	DOMAIN_CONTROLLER_INFO* pDcInfo = NULL;
    DWORD dwStat = DsGetDcName(NULL, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED|DS_RETURN_DNS_NAME, &pDcInfo);
    if( dwStat != NO_ERROR || pDcInfo == NULL ) 
        return E_FAIL;

	// verify  name begins with '\\'
	if( !(pDcInfo->DomainControllerName && pDcInfo->DomainControllerName[0] == _T('\\') && pDcInfo->DomainControllerName[1] == _T('\\')) )
    {
        NetApiBufferFree(pDcInfo);
		return E_FAIL;
    }

	// discard the leading '\\'
	LPCTSTR pszDcName = pDcInfo->DomainControllerName + 2;
		
    // Create a directory data object
    CComObject<CADDataObject>* pObj;
    HRESULT hr = CComObject<CADDataObject>::CreateInstance(&pObj);

    // Initialize it with the object path and class
    if( SUCCEEDED(hr) )
    {
        hr = pObj->Initialize(strObj.c_str(), pszClass, pszDcName);
    }

    NetApiBufferFree(pDcInfo);
    pDcInfo = NULL;

    // Verify that all is good now
    RETURN_ON_FAILURE(hr);
    
    // Hold IDataObject interface with a smart pointer
    IDataObjectPtr spDataObj = pObj;
    ASSERT(spDataObj != NULL);
    
    // Create a DsPropertyPage object (despite name it handles both context menus and property pages)
    hr = CoCreateInstance(CLSID_DsPropertyPages, NULL, CLSCTX_INPROC_SERVER, IID_IShellExtInit, (LPVOID*)&m_spExtInit);
    RETURN_ON_FAILURE(hr)

    // Intialize the object with our data object
    hr = m_spExtInit->Initialize(NULL, spDataObj, NULL);
    
    if (FAILED(hr))
       m_spExtInit.Release();
       
    return hr;
}


HRESULT CActDirExt::Initialize(LPCWSTR pszClass)
{
    // Find an object of the specified class
    tstring strObjPath;
    HRESULT hr = FindClassObject( pszClass, strObjPath );
    RETURN_ON_FAILURE(hr)

    // Now do normal initialization
    return Initialize(pszClass, strObjPath.c_str());
}
                

HRESULT CActDirExt::GetMenuItems(menu_vector& vMenuNames) 
{ 
    if( !m_spExtInit ) return E_FAIL;
    
    // Get context menu interface    
    CComQIPtr<IContextMenu> spCtxMenu = m_spExtInit;
    if( !spCtxMenu ) return E_NOINTERFACE;

    // Start with clean menu
    m_menu.DestroyMenu();
    if( !m_menu.CreatePopupMenu() ) return E_FAIL;
    if( !m_menu.m_hMenu ) return E_FAIL;

    // Call extension to add menu commands
    HRESULT hr = spCtxMenu->QueryContextMenu(m_menu, 0, MENU_CMD_MIN, MENU_CMD_MAX, CMF_NORMAL);
    RETURN_ON_FAILURE(hr);

    // Copy each menu name to the output string vector
    WCHAR wszCmdName[1024];
    WCHAR wszCmdIndName[1024];

    UINT nItems = m_menu.GetMenuItemCount();
    for( UINT i = 0; i < nItems; i++ )
    {
        UINT uID = m_menu.GetMenuItemID(i);
        if (uID >= MENU_CMD_MIN) 
        {
            BOMMENU bmenu;
            
            int nFullSize = m_menu.GetMenuString(i, wszCmdName, lengthof(wszCmdName), MF_BYPOSITION);
            if( (nFullSize == 0) || (nFullSize >= lengthof(wszCmdName)) )
            {
                return E_FAIL;
            }

            bmenu.strPlain = wszCmdName;

            HRESULT hr2 = spCtxMenu->GetCommandString(uID - MENU_CMD_MIN, GCS_VERBW, NULL, (LPSTR)wszCmdIndName, lengthof(wszCmdIndName));
            if( (hr2 != NOERROR) || (wcslen( wszCmdIndName) >= lengthof(wszCmdIndName)-1) )
            {
                // Lots of Menu items (extended ones!) have no 
                // language-independant menu identifiers
                bmenu.strNoLoc = _T("");
            }
            else
            {
                bmenu.strNoLoc = wszCmdIndName;
            }
            
            vMenuNames.push_back(bmenu);
        }
    }

    return hr; 
}

HRESULT CActDirExt::Execute(BOMMENU* pbmMenu) 
{
    if( !pbmMenu ) return E_POINTER;
    if( !m_spExtInit || !m_menu.m_hMenu ) return E_FAIL;

    // Get context menu interface    
    CComQIPtr<IContextMenu> spCtxMenu = m_spExtInit;
    if( !spCtxMenu ) return E_NOINTERFACE;

    HRESULT hr = E_FAIL;

    // Locate selected command by name
    WCHAR szCmdName[1024];
    WCHAR szCmdNoLocName[1024];

    UINT nItems = m_menu.GetMenuItemCount();
    for (int i=0; i<nItems; i++)
    {
        szCmdName[0]      = 0;
        szCmdNoLocName[0] = 0;

        UINT uID = m_menu.GetMenuItemID(i);
        
        // Get our Unique and non-unique ID Strings
        int nFullSize = m_menu.GetMenuString(i, szCmdName, lengthof(szCmdName), MF_BYPOSITION);            
        if( (nFullSize <= 0) || (nFullSize >= lengthof(szCmdName)) )
        {
            continue;
        }

        hr = spCtxMenu->GetCommandString(uID - MENU_CMD_MIN, GCS_VERBW, NULL, (LPSTR)szCmdNoLocName, lengthof(szCmdNoLocName));        
        if( hr != NOERROR ) 
        {
            // We want to make sure that if there's an error getting the
            // language independant menu name that we don't do anything stupid.
            szCmdNoLocName[0] = 0;    
        }


        // If we got a Unique ID String, compare that to what was passed in, otherwise
        // use the stored Display String

        // NOTE:  We had to use both, because Exchange does not support the language independant
        // menu identifiers
        if( ( pbmMenu->strNoLoc.size() && _tcscmp(pbmMenu->strNoLoc.c_str(), szCmdNoLocName) == 0 ) ||
            ( _tcscmp(pbmMenu->strPlain.c_str(), szCmdName) == 0 ) )
        {
            CMINVOKECOMMANDINFO cmdInfo;
            ZeroMemory( &cmdInfo, sizeof(cmdInfo) );

            cmdInfo.cbSize = sizeof(cmdInfo);
            cmdInfo.fMask = CMIC_MASK_ASYNCOK;
            cmdInfo.hwnd = GetDesktopWindow();
            cmdInfo.lpVerb = (LPSTR)MAKEINTRESOURCE(uID - MENU_CMD_MIN);                
            cmdInfo.nShow = SW_NORMAL;                

            hr = spCtxMenu->InvokeCommand(&cmdInfo);
            break;
        }
    }    

    ASSERT(i < nItems);

    return hr; 
}


//
// Add Page callback function
// 
static BOOL CALLBACK AddPageCallback(HPROPSHEETPAGE hsheetpage, LPARAM lParam)
{
    hpage_vector* pvhPages = reinterpret_cast<hpage_vector*>(lParam);
    if( !pvhPages ) return FALSE;

    pvhPages->push_back(hsheetpage);

    return TRUE;
}



HRESULT CActDirExt::GetPropertyPages(hpage_vector& vhPages)
{
    if( !m_spExtInit ) return E_FAIL;
    
    // Get Property page interface
    CComQIPtr<IShellPropSheetExt> spPropSht = m_spExtInit;
    if( !spPropSht ) return E_NOINTERFACE;
        
    HRESULT hr = spPropSht->AddPages(&AddPageCallback, reinterpret_cast<LPARAM>(&vhPages));
    
    return hr;
}

//////////////////////////////////////////////////////////////////////////////////////////
// CActDirExtProxy

HWND CActDirExtProxy::m_hWndProxy = 0;

LRESULT CALLBACK CActDirExtProxy::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    if (uMsg >= MSG_BEGIN && uMsg < MSG_END)
    {
        if( hWnd != m_hWndProxy )
        {
            ASSERT( !_T("We have the wrong window.") );
            return E_FAIL;
        }

        CActDirExtProxy* pProxy = reinterpret_cast<CActDirExtProxy*>(wParam);
        if( !pProxy ) return E_FAIL;

        CActDirExt* pExt = pProxy->m_pExt;
        if( !pExt ) return E_FAIL;

        HRESULT hr = S_OK;
        switch (uMsg) 
        {
        case MSG_INIT1:
            hr = pExt->Initialize(reinterpret_cast<LPCWSTR>(pProxy->m_lParam1));
            break;
    
        case MSG_INIT2:
            hr = pExt->Initialize(reinterpret_cast<LPCWSTR>(pProxy->m_lParam1),
                                  reinterpret_cast<LPCWSTR>(pProxy->m_lParam2));
            break;
    
        case MSG_GETMENUITEMS:
            hr = pExt->GetMenuItems(*reinterpret_cast<menu_vector*>(pProxy->m_lParam1));
            break;
    
        case MSG_GETPROPPAGES:
            hr = pExt->GetPropertyPages(*reinterpret_cast<hpage_vector*>(pProxy->m_lParam1));
            break;
    
        case MSG_EXECUTE:
            hr = pExt->Execute( reinterpret_cast<BOMMENU*>(pProxy->m_lParam1) );
            break;
    
        case MSG_DELETE:
            delete pExt;
            pProxy->m_pExt = NULL;

            break;    
        }

        return hr;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);   
}


CActDirExtProxy::CActDirExtProxy()
{
    m_pExt = new CActDirExt();
    ASSERT(m_pExt != NULL);
}


CActDirExtProxy::~CActDirExtProxy()
{
    if (m_pExt != NULL)
    {
        ForwardCall(MSG_DELETE);
    }
}

void CActDirExtProxy::InitProxy()
{ 
    if( !m_hWndProxy )
    {
        m_hWndProxy = ADProxyWndClass.Window();
    }
    else
    {
        ASSERT(IsWindow(m_hWndProxy));
    }
}


HRESULT CActDirExtProxy::ForwardCall(eProxyMsg eMsg, LPARAM lParam1, LPARAM lParam2)
{
    m_lParam1 = lParam1;
    m_lParam2 = lParam2;

    if( !m_hWndProxy ) return E_FAIL;    

    return SendMessage(m_hWndProxy, eMsg, reinterpret_cast<LPARAM>(this), NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\adext.h ===
// adext.h - Active Directory Extension header file

#ifndef _ADEXT_H_
#define _ADEXT_H_

#include <atlgdi.h>


// Have to define a dummy _PSP struct because HPROPSHEETPAGE is defined to
// be a ptr to struct _PSP and STL won't allow a vector of pointers
// without having a defineion of the type pointed to.
struct _PSP
{
    int dummy;
};

typedef std::vector<HPROPSHEETPAGE> hpage_vector;


///////////////////////////////////////////////////////////////////////////////
// CActDirExt
//
// This class provides a wrapper around active directory extensions. It provides
// the menu commands and property pages for a particular directory object or
// an object class, depending on which Initialize method is called. The class
// will also execute a menu command if it is passed back the name of the command.

class CActDirExt
{
public:
    CActDirExt() : m_spExtInit(NULL) {}

    HRESULT Initialize(LPCWSTR pszClass, LPCWSTR pszObjPath);
    HRESULT Initialize(LPCWSTR pszClass);
    
    HRESULT GetMenuItems(menu_vector& vMenuNames);
    HRESULT GetPropertyPages(hpage_vector& vhPages);    
    HRESULT Execute(BOMMENU* pbmMenu);

private:
    enum {
        MENU_CMD_MIN = 100,
        MENU_CMD_MAX = 200
    };

    CMenu   m_menu;
    CComPtr<IShellExtInit> m_spExtInit;
};


////////////////////////////////////////////////////////////////////////////////
// CActDirProxy
//
// This class allows a client on a secondary thread to use a directory extension.
// It uses window mesages to create and operate a contained CActDirExt object
// on the main thread. It exposes the same methods as a CActDirExt object.

class CActDirExtProxy
{
public:
    CActDirExtProxy();
    ~CActDirExtProxy();

    static void InitProxy();

    // Forwarded methods
    HRESULT Initialize(LPCWSTR pszClass)
        { return ForwardCall(MSG_INIT1, reinterpret_cast<LPARAM>(pszClass)); }

    HRESULT Initialize(LPCWSTR pszClass, LPCWSTR pszObjPath)
        { return ForwardCall(MSG_INIT2, reinterpret_cast<LPARAM>(pszClass), 
                                  reinterpret_cast<LPARAM>(pszObjPath)); }
    
    HRESULT GetMenuItems(menu_vector& vMenuNames)
        { return ForwardCall(MSG_GETMENUITEMS, reinterpret_cast<LPARAM>(&vMenuNames)); }

    HRESULT GetPropertyPages(hpage_vector& vhPages)
        { return ForwardCall(MSG_GETPROPPAGES, reinterpret_cast<LPARAM>(&vhPages)); }

    HRESULT Execute(BOMMENU* pbmMenu)
        { return ForwardCall(MSG_EXECUTE, reinterpret_cast<LPARAM>(pbmMenu)); }

    static LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    enum eProxyMsg
    {
        MSG_BEGIN = WM_USER + 100,
        MSG_INIT1 = WM_USER + 100,
        MSG_INIT2,
        MSG_GETMENUITEMS,
        MSG_GETPROPPAGES,
        MSG_EXECUTE,
        MSG_DELETE,
        MSG_END
    };

    HRESULT ForwardCall(eProxyMsg eMsg, LPARAM lParam1 = NULL, LPARAM lParam2 = NULL);

private:
    CActDirExt* m_pExt;     // pointer to actual extension object that this is proxying
    LPARAM  m_lParam1;      // calling parameters for the current call
    LPARAM  m_lParam2;
    static HWND m_hWndProxy;  // window on main thread that receives method requests
};

///////////////////////////////////////////////////////////////////////////////////////////
// CADDataObject

class ATL_NO_VTABLE CADDataObject : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDataObject    
{
public:
    
    DECLARE_NOT_AGGREGATABLE(CADDataObject)

    BEGIN_COM_MAP(CADDataObject)
        COM_INTERFACE_ENTRY(IDataObject)
    END_COM_MAP()

    HRESULT Initialize(LPCWSTR pszObjPath, LPCWSTR pszClass, LPCWSTR pszDcName)
    {
        if( !pszObjPath || !pszClass || !pszDcName ) return E_POINTER;

        m_strObjPath = pszObjPath;
        m_strClass   = pszClass;
		m_strDcName  = pszDcName;

        return S_OK;
    }

    // IDataObject
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);

    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; }

    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };

    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

private:
    tstring m_strObjPath;
    tstring m_strClass;
	tstring m_strDcName;

    static UINT m_cfDsObjects;
    static UINT m_cfDsDispSpecOptions;
};


#endif // _ADEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\clsinfo.h ===
// clsinfo.h  -  DS Class Info header

#ifndef _CLSINFO_H_
#define _CLSINFO_H_


//------------------------------------------------------------------
// class CClassInfo
//------------------------------------------------------------------
class CClassInfo
{
    friend IStream& operator>> (IStream& stm, CClassInfo& classinfo);
    friend IStream& operator<< (IStream& stm, CClassInfo& classinfo);

public:

    CClassInfo(LPCWSTR pszClassName = NULL)
    {
        if (pszClassName != NULL)
            m_strName = pszClassName;
    }

    LPCWSTR Name() { return m_strName.c_str(); }
    string_vector& Columns() { return m_vstrColumns; }

private:

    std::wstring m_strName;
    string_vector m_vstrColumns;
};

IStream& operator>> (IStream& stm, CClassInfo& classinfo);
IStream& operator<< (IStream& stm, CClassInfo& classinfo);


typedef std::vector<CClassInfo> classInfo_vector;

class CClassInfoSet
{
public:

    CClassInfo* FindClass(LPCWSTR pszClassName);
    HRESULT AddClass(CClassInfo&);
    HRESULT RemoveClass(LPCWSTR pszClassName);

    operator classInfo_vector&() { return m_vClasses; } 

private:
    classInfo_vector m_vClasses;
};

IStream& operator>> (IStream& stm, CClassInfoSet& classSet);
IStream& operator<< (IStream& stm, CClassInfoSet& classSet);

#endif // _CLSINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\bomsnap.cpp ===
// BOMSnap.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f BOMSnapps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "BOMSnap_i.c"
#include "RowItem.h"
#include "scopenode.h"
#include "compdata.h"
#include "Compont.h"
#include "DataObj.h"
#include "about.h"
#include "queryreq.h"


CComModule _Module;
extern CQueryThread g_QueryThread;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_BOMSnapIn,      CComponentData)
    OBJECT_ENTRY(CLSID_BOMSnapInAbout, CSnapInAbout)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        // NATHAN FIX !!w
        //_set_new_handler( _standard_new_handler );
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        // BUGBUG: This next statement is the offending
        // one that causes AV in Win95 OSR2 while registering.
        _Module.Term();
    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    // if DLL is ready to exit, make sure all threads are killed before unload
    if (_Module.GetLockCount() == 0) 
    {
        g_QueryThread.Kill();

        return S_OK;
    }

    return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\cmndlgs.cpp ===
// cmndlgs.cpp - Common Dialogs

#include "stdafx.h"

#include <adext.h>
#include <windowsx.h>
#include <algorithm>

#include "cmndlgs.h"
#include "query.h"
#include "rowitem.h"
#include "scopenode.h"
#include "namemap.h"
#include "menuCmd.h"
#include "util.h"


//////////////////////////////////////////////////////////////////////////////////
// CAddColumnDlg
LRESULT CAddColumnDlg::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    ASSERT(!m_strClassName.empty());
    DisplayNameMap* pNameMap = DisplayNames::GetMap(m_strClassName.c_str());    
    if (pNameMap == NULL)
        return TRUE;

    SetDlgItemText( IDC_OBJCLASS, pNameMap->GetClassDisplayName() );

    pNameMap->GetFriendlyNames(&m_vstrAllColumns);
 
    HWND hwndList = GetDlgItem(IDC_COLUMNLIST);

    if( hwndList && ::IsWindow(hwndList) )
    {
	    ConfigSingleColumnListView(hwndList);

	    if (!m_vstrAllColumns.empty())
	    {
		    LV_ITEM lvi;
		    lvi.mask = LVIF_TEXT | LVIF_PARAM;
		    lvi.iItem = 0;
		    lvi.iSubItem = 0;
    	
		    string_vector::iterator itStr;
		    for (itStr = m_vstrAllColumns.begin(); itStr != m_vstrAllColumns.end(); itStr++) 
		    {
			    lvi.pszText = const_cast<LPWSTR>(pNameMap->GetAttributeDisplayName(itStr->c_str()));
			    lvi.lParam = (LPARAM)itStr->c_str();
    	
			    int iPos = ListView_InsertItem(hwndList, &lvi);
			    ASSERT(iPos >= 0);
		    }
	    }
    }

    EnableDlgItem( m_hWnd, IDOK, FALSE );

    return TRUE;
}
 

LRESULT CAddColumnDlg::OnClose( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if (wID == IDOK) 
    {
        HWND hwndList = GetDlgItem(IDC_COLUMNLIST);
        ASSERT(hwndList != NULL);

		m_vstrColumns.clear();

		// copy LDAP names of selected items to vector
		int iIndex = -1;
		while ((iIndex = ListView_GetNextItem(hwndList, iIndex, LVNI_SELECTED)) != -1)
		{
			LVITEM lvi;
			lvi.mask = LVIF_PARAM;
			lvi.iItem = iIndex;
			lvi.iSubItem = 0;

			BOOL bStat = ListView_GetItem(hwndList, &lvi);
			ASSERT(bStat);

			m_vstrColumns.push_back(reinterpret_cast<LPWSTR>(lvi.lParam));
		}
     }

    EndDialog(wID);

    return 0;
}


LRESULT CAddColumnDlg::OnColumnChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    LPNMLISTVIEW pnmv = reinterpret_cast<LPNMLISTVIEW>(pNMHDR);
    if( !pnmv ) return 0;

    // if selection change, update OK button
    if ((pnmv->uChanged & LVIF_STATE))
    {
		EnableDlgItem( m_hWnd, IDOK, (ListView_GetSelectedCount(GetDlgItem(idCtrl)) > 0) );
    }        

    return 0;
}

LRESULT CAddColumnDlg::OnColumnActivate(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    SendDlgItemMessage( IDOK, BM_CLICK, (WPARAM)0, (LPARAM)0 );
     
	return 0;
}

//////////////////////////////////////////////////////////////////////////////////
// CAddMenuDlg

CAddMenuDlg::~CAddMenuDlg()
{
    m_MenuTypeCB.Detach();
    DeleteObject(m_hbmArrow);
}

LRESULT CAddMenuDlg::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    DisplayNameMap* pNameMap = DisplayNames::GetMap(m_ClassInfo.Name());    
    if (pNameMap == NULL)
        return TRUE;

    SetDlgItemText( IDC_OBJCLASS, pNameMap->GetClassDisplayName() );

    HWND hwndMenuType = GetDlgItem(IDC_COMMANDTYPE);
    if( hwndMenuType && ::IsWindow(hwndMenuType) )
    {
        m_MenuTypeCB.Attach( hwndMenuType );
    }

    // Set menu arrow bitmap in param menu button
    m_hbmArrow = LoadBitmap(NULL, MAKEINTRESOURCE(OBM_MNARROW));
    if( m_hbmArrow )
    {
        SendDlgItemMessage( IDC_PARAMS_MENU, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)m_hbmArrow );
    }

    COMBOBOXEXITEM cbi;
    cbi.mask = CBEIF_TEXT|CBEIF_LPARAM;
    cbi.iItem = -1;

    tstring strMenuType = StrLoadString(IDS_ACTDIRCMD);
    cbi.pszText = const_cast<LPWSTR>(strMenuType.c_str());
    cbi.lParam = MENUTYPE_ACTDIR;
    m_MenuTypeCB.InsertItem(&cbi);

    strMenuType = StrLoadString(IDS_SHELLCMD);
    cbi.pszText = const_cast<LPWSTR>(strMenuType.c_str());
    cbi.lParam = MENUTYPE_SHELL;
    m_MenuTypeCB.InsertItem(&cbi);

    Edit_LimitText(GetDlgItem(IDC_NAME), 255);
    Edit_LimitText(GetDlgItem(IDC_COMMAND), 255);
    Edit_LimitText(GetDlgItem(IDC_STARTIN), 500);

    LoadClassMenuCmds();

    // If editing an existing menu
    if (m_pMenuCmd != NULL)
    {
        // Set name modified so that it won't be changed to default 
        m_bUserModifiedName = TRUE;

        // Display info for selected menu
        LoadMenuInfo(m_pMenuCmd);
    }
    else
    {        
        m_MenuTypeCB.SetCurSel(0);
        SetMenuType(MENUTYPE_ACTDIR);
    }

    m_bCommandChg = FALSE;
    m_bStartDirChg = FALSE;

    EnableOKButton();

    return TRUE;
}


void CAddMenuDlg::LoadMenuInfo(CMenuCmd* pMenuCmd)
{
    if( !pMenuCmd ) return;

    SetDlgItemText( IDC_NAME, pMenuCmd->Name() );
    Button_SetCheck(GetDlgItem(IDC_REFRESH),  pMenuCmd->IsAutoRefresh() ? BST_CHECKED : BST_UNCHECKED);

    
    switch (pMenuCmd->MenuType()) 
    {
    case MENUTYPE_SHELL:
        {
            CShellMenuCmd* pShellCmd = static_cast<CShellMenuCmd*>(pMenuCmd);

            SetDlgItemText( IDC_COMMAND, pShellCmd->m_strProgPath.c_str() );
            SetDlgItemText( IDC_STARTIN, pShellCmd->m_strStartDir.c_str() );

            // Convert parameters from LDAP names to display names
            tstring strParams = pShellCmd->m_strCmdLine;

            DisplayNameMap* pNameMap = DisplayNames::GetMap(m_ClassInfo.Name());    
            if (pNameMap != NULL)
            {
                // Create function object to do parameter translation
                CLookupDisplayName lookup(m_ClassInfo.Columns(), pNameMap);

                ReplaceParameters(strParams, lookup, TRUE);
            }

            SetDlgItemText( IDC_PARAMS, strParams.c_str() );

            m_MenuTypeCB.SetCurSel(1);
            SetMenuType(MENUTYPE_SHELL);
        }
        break;

    case MENUTYPE_ACTDIR:
        {
            CActDirMenuCmd* pADCmd = static_cast<CActDirMenuCmd*>(pMenuCmd);

            LVFINDINFO lvfi;
            lvfi.flags = LVFI_STRING;
            lvfi.psz = pADCmd->m_strADName.c_str();

            HWND hwndLV = GetDlgItem(IDC_MENULIST);
            int iItem = ListView_FindItem(hwndLV, -1, &lvfi);
            if( iItem == -1 )
            {
                // Couldn't find the language dependant string, try the language independant string                
                int nItems = ListView_GetItemCount(hwndLV);
                
                for( int i = 0; i < nItems; i++ )
                {
                    LVITEM lvi;
                    ZeroMemory( &lvi, sizeof(lvi) );                    
                    lvi.mask = LVIF_PARAM;
                    lvi.iItem = i;
                    
                    ListView_GetItem( hwndLV, &lvi );

                    if( lvi.lParam )
                    {
                        LPCWSTR pszMenuNoLoc = pADCmd->ADNoLocName();

                        // Compare the stored string with the menu string
                        if( pszMenuNoLoc && (wcscmp( (LPCWSTR)(lvi.lParam), pszMenuNoLoc ) == 0) )
                        {
                            iItem = i;
                            break;
                        }
                    }
                }

            }            

            // If we found the string, default the value
            if (iItem != -1)
                ListView_SetItemState(hwndLV, iItem, LVIS_SELECTED, LVIS_SELECTED);           

            m_MenuTypeCB.SetCurSel(0);
            SetMenuType(MENUTYPE_ACTDIR);
        }
        break;

    default:
        ASSERT(FALSE);
    }
}


void CAddMenuDlg::LoadClassMenuCmds()
{
    // Use a directory extension proxy to query for menu items
    // because this dialog may run on a secondary thread and some
    // directory extensions (dsadmin.dll!!) can only run on the main thread.
    CActDirExtProxy adext;

    // Initialize it with selected class name
    HRESULT hr = adext.Initialize(m_ClassInfo.Name());
    if (FAILED(hr))
        return;

    // Get menu commands for the selected class
    menu_vector vMenuNames;
    hr = adext.GetMenuItems(vMenuNames);
    if (FAILED(hr))
        return;

    HWND hwndLV = GetDlgItem(IDC_MENULIST);
    ASSERT(::IsWindow(hwndLV));

    ConfigSingleColumnListView(hwndLV);

    LV_ITEM lvi;
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = 0;
    lvi.iSubItem = 0;

    menu_vector::iterator itstr;
    for (itstr = vMenuNames.begin(); itstr < vMenuNames.end(); ++itstr)
    {
        TCHAR* szNoLoc = new TCHAR[itstr->strNoLoc.length() + 1];        

        if( szNoLoc )
        {
            _tcscpy(szNoLoc, itstr->strNoLoc.c_str());
        }

        lvi.pszText = const_cast<LPWSTR>(itstr->strPlain.c_str());
        lvi.lParam  = reinterpret_cast<LPARAM>(szNoLoc);
        int iPos = ListView_InsertItem(hwndLV, &lvi);
        ASSERT(iPos >= 0);
        if( iPos == -1 )
        {
            // Error, need to clean up here
            delete [] szNoLoc;
            continue;
        }

        // After adding the first item, default the selection to the first item
        if( iPos == 0 )
        {
            ListView_SetItemState(hwndLV, 0, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
        }

        lvi.iItem++;
    }
}


LRESULT CAddMenuDlg::OnTypeSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iItem = m_MenuTypeCB.GetCurSel();
    ASSERT(iItem >= 0);

    if( iItem >= 0 )
    {
        MENUTYPE type = static_cast<MENUTYPE>(m_MenuTypeCB.GetItemData(iItem));
        SetMenuType(type);
    }

    return 0;

}

LRESULT CAddMenuDlg::OnBrowseForCommand( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    tstring strCommand;
    GetItemText( GetDlgItem(IDC_COMMAND), strCommand );

    tstring strFilter = StrLoadString(IDS_EXEFILTER);

    /*
     * The file dialog expects embedded \0's in the string, but those
     * don't load well.  The string in the resource file has \\ where
     * the \0 should be, so let's make the substitution now.
     */
    LPTSTR pchTemp = (LPTSTR)strFilter.data();
    for( LPTSTR pch = pchTemp; *pch != _T('\0'); pch = pchTemp )
    {
        pchTemp = CharNext(pch);
        if (*pch == _T('\\'))
            *pch = _T('\0');
    }
    // don't call ReleaseBuffer, since the string now contains \0 chars

    CFileDialog dlg (true, NULL, strCommand.c_str(), OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, strFilter.c_str(), m_hWnd);

    if (dlg.DoModal() == IDOK)
    {
        SetDlgItemText (IDC_COMMAND, dlg.m_szFileName);
    }

    return (0);
}

// Define private CFolderDialog to handle the OnInitialized callback
class CFolderDialogPriv : public CFolderDialogImpl<CFolderDialogPriv>
{
public:
    CFolderDialogPriv(HWND hWndParent, LPCWSTR pszTitle, UINT uFlags, LPCWSTR pszCurFolder )
        : CFolderDialogImpl<CFolderDialogPriv>(hWndParent, pszTitle, uFlags), m_pszCurFolder(pszCurFolder) {}

   void OnInitialized() { if (m_pszCurFolder) SetSelection(m_pszCurFolder); }

   LPCWSTR m_pszCurFolder;
};


LRESULT CAddMenuDlg::OnBrowseForStartIn( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    tstring strCaption = StrLoadString(IDS_SELECT_STARTDIR);

    tstring strDir;
    GetItemText( GetDlgItem(IDC_STARTIN), strDir );

    CFolderDialogPriv dlg( m_hWnd, strCaption.c_str(), BIF_RETURNONLYFSDIRS|BIF_NEWDIALOGSTYLE, strDir.c_str() );

    if (dlg.DoModal() == IDOK)
        SetDlgItemText (IDC_STARTIN, dlg.GetFolderPath());

    return (0);
}


LRESULT CAddMenuDlg::OnNameChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    m_bUserModifiedName = TRUE;
    EnableOKButton();
    return 0;
}

LRESULT CAddMenuDlg::OnCommandChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    EnableOKButton();

    m_bCommandChg = TRUE;

    return 0;
}

LRESULT CAddMenuDlg::OnStartDirChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    m_bStartDirChg = TRUE;
    return 0;
}

    
LRESULT CAddMenuDlg::OnMenuChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    LPNMLISTVIEW pnmv = reinterpret_cast<LPNMLISTVIEW>(pNMHDR);
    if( !pnmv ) return 0;

    // if new item selected user hasn't entered a name, default name to the menu 
    if ((pnmv->uChanged & LVIF_STATE) && (pnmv->uNewState & LVIS_SELECTED))
    {
        // If user hasn't modified the name or the name is empty, default to the menu name
        if (!m_bUserModifiedName || ::Edit_GetTextLength(GetDlgItem(IDC_NAME)) == 0)
        {               
            WCHAR szName[256];    
            ListView_GetItemText(GetDlgItem(IDC_MENULIST), pnmv->iItem, 0, szName, lengthof(szName));
            ::Edit_SetText(GetDlgItem(IDC_NAME), szName);

            // reset user modified flag becuase it will be set by the Edit_SetText call
            m_bUserModifiedName = FALSE;
        }
    }        

    EnableOKButton();

    return 0;
}

void CAddMenuDlg::EnableOKButton()
{
    BOOL bEnable = TRUE;

    if (::Edit_GetTextLength(GetDlgItem(IDC_NAME)) == 0)
    {
        bEnable = FALSE;
    }
    else
    {
        if (m_menutype == MENUTYPE_SHELL)
        {
            if (::Edit_GetTextLength(GetDlgItem(IDC_COMMAND)) == 0) 
                bEnable = FALSE;
        }
        else
        {
            if (ListView_GetSelectedCount(GetDlgItem(IDC_MENULIST)) == 0) 
                bEnable = FALSE;
        }
    }

    EnableDlgItem( m_hWnd, IDOK, bEnable );
}

void CAddMenuDlg::SetMenuType(MENUTYPE type)
{
    static int aiActDirItems[] = {IDC_OBJCLASS_LBL, IDC_OBJCLASS, IDC_MENULIST_LBL, IDC_MENULIST, 0};
    static int aiShellItems[]  = {IDC_COMMAND_LBL, IDC_COMMAND, IDC_COMMAND_BROWSE, IDC_PARAMS_LBL, 
                                  IDC_PARAMS, IDC_STARTIN_LBL, IDC_STARTIN, IDC_STARTIN_BROWSE, 
                                  IDC_PARAMS_MENU, 0};

    int* piItem = (type == MENUTYPE_SHELL) ? aiActDirItems : aiShellItems;
    while (*piItem) 
    {
	   EnableDlgItem( m_hWnd, *piItem, FALSE );
       ::ShowWindow(GetDlgItem(*piItem), SW_HIDE);
       piItem++;
    }

    piItem = (type == MENUTYPE_SHELL) ? aiShellItems : aiActDirItems;
    while (*piItem)
    {
        ::ShowWindow(GetDlgItem(*piItem), SW_SHOW);
		EnableDlgItem( m_hWnd, *piItem, TRUE );
        piItem++;
    }

    m_menutype = type;

    EnableOKButton();
}

LRESULT CAddMenuDlg::OnParameterMenu(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // Construct parameter menu
    CMenu menu;
    menu.CreatePopupMenu();
    
    // Add standard parameters first
    UINT uID = 1;
    for( int i = 0; i < lengthof(MenuParamTable); i++ )
    {
        if (MenuParamTable[i].ID == 0) 
        {
            menu.AppendMenu(MF_SEPARATOR);
        }
        else
        {
           CString str;
           str.LoadString(MenuParamTable[i].rsrcID);
           menu.AppendMenu(MF_STRING, uID++, str);
        }
    }

    // Then add class attributes
    DisplayNameMap* pNameMap = DisplayNames::GetMap(m_ClassInfo.Name());    
    if (pNameMap != NULL)
    {
        string_vector& vColumns = m_ClassInfo.Columns();
        string_vector::iterator itCol;
        for (itCol = vColumns.begin(); itCol != vColumns.end(); itCol++) 
        {
            menu.AppendMenu(MF_STRING, uID++, pNameMap->GetAttributeDisplayName(itCol->c_str())); 
        }
    }

    // Pop-up menu at menu button
    RECT rc;
    ::GetWindowRect(GetDlgItem(IDC_PARAMS_MENU), &rc);
    long cx = (rc.right + rc.left) / 2;
    long cy = (rc.top + rc.bottom) / 2;

    UINT uCmd = menu.TrackPopupMenu(TPM_LEFTALIGN|TPM_TOPALIGN|TPM_RETURNCMD|TPM_LEFTBUTTON,
                                   cx, cy, m_hWnd);

    if (uCmd != 0) 
    {
        WCHAR szBuf[128] = {0};

        // Convert menu name to parameter format: $<name>
        wcscpy(szBuf, L"$<");

        // BUGBUG - Don't depend on count returned by GetMenuString. For some locales
        // it returns a byte count rather than a character count.
        int iLen = menu.GetMenuString(uCmd, szBuf+2, lengthof(szBuf)-5, MF_BYCOMMAND);
        ASSERT(iLen != 0);

        // Add closing '>' and one trailing space so user can add multiple parameters 
        // without manually entering separating spaces
        wcscat(szBuf, L"> ");

        Edit_ReplaceSel(GetDlgItem(IDC_PARAMS), szBuf);

        ::SetFocus(GetDlgItem(IDC_PARAMS));
    }

    return 0;
}

LRESULT CAddMenuDlg::OnClose( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if (wID == IDOK) 
    {
        CMenuCmd* pMenu = NULL;

        // Get menu name
        tstring strName;
        GetItemText( GetDlgItem(IDC_NAME), strName );

        // Name without the hotkey
        tstring strPlainName = strName;

        // Validate hotkey selection
        int posKey = strName.find(L"&", 0);
        if (posKey != tstring::npos) 
        {
            WCHAR chKey = posKey < strName.length() - 1 ? strName[posKey+1] : 0;
            if (!( (chKey >= L'A' && chKey <= L'Z') || 
                   (chKey >= L'a' && chKey <= L'z') ||
                   (chKey >= L'0' && chKey <= L'9') ))
            {
                DisplayMessageBox(m_hWnd, IDS_ERRORTITLE_MENUNAME, IDS_ERROR_BADACCESSKEY);
                return 0;
            }

            if (strName.find(L"&", posKey+1) != tstring::npos)
            {
                DisplayMessageBox(m_hWnd, IDS_ERRORTITLE_MENUNAME, IDS_ERROR_MULTIACCESSKEY);
                return 0;
            }

            // remove '&'
            strPlainName.erase(posKey, 1);
        }

        // Check for duplicated name
         menucmd_vector::iterator itMenu;
         for (itMenu = m_ClassInfo.Menus().begin(); itMenu != m_ClassInfo.Menus().end(); ++itMenu) 
         {

            // if editing a an existing menu, don't compare to itself
            if (*itMenu == m_pMenuCmd)
                continue;
 
            // Compare names, skipping '&'s
            LPCWSTR pszName = (*itMenu)->Name();
            LPCWSTR pszNewName = strPlainName.c_str();

            if( pszName && pszNewName )
            {
                while (*pszName && *pszNewName) 
                {
                    if (*pszName == L'&')
                        ++pszName;

                    if (*pszName != *pszNewName)
                        break;

                    ++pszName;
                    ++pszNewName;
                }

                // if duplicate name
                if (*pszName == *pszNewName)
                {
                    DisplayMessageBox(m_hWnd, IDS_ERRORTITLE_MENUNAME, IDS_ERROR_DUPMENUNAME, MB_OK|MB_ICONEXCLAMATION, strPlainName.c_str());
                    return 0;
                }
            }
        }
                   

        switch (m_menutype) 
        {
        case MENUTYPE_SHELL:
            {
                CShellMenuCmd* pShellMenu = new CShellMenuCmd();
    
                if (pShellMenu != NULL) 
                {
                    GetItemText( GetDlgItem(IDC_COMMAND), pShellMenu->m_strProgPath );

                    if (m_bCommandChg && ValidateFile(pShellMenu->m_strProgPath) != S_OK) 
                    {
                        int iRet = DisplayMessageBox(m_hWnd, IDS_ERRORTITLE_MENUCMD, IDS_ERROR_MENUCMD,
                                                     MB_ICONINFORMATION | MB_YESNO, pShellMenu->m_strProgPath.c_str());
                        if (iRet != IDYES) 
                        {
                            delete pShellMenu;
                            return 0;
                        }
                    }

                    GetItemText( GetDlgItem(IDC_STARTIN), pShellMenu->m_strStartDir );

                    if (m_bStartDirChg && !pShellMenu->m_strStartDir.empty() && 
                        ValidateDirectory(pShellMenu->m_strStartDir) != S_OK) 
                    {
                        int iRet = DisplayMessageBox(m_hWnd, IDS_ERRORTITLE_STARTDIR, IDS_ERROR_STARTDIR,
                                                     MB_ICONINFORMATION | MB_YESNO, pShellMenu->m_strStartDir.c_str());
                        if (iRet != IDYES) 
                        {
                            delete pShellMenu;
                            return 0;
                        }

                    }

                    tstring strParams;
                    GetItemText( GetDlgItem(IDC_PARAMS), strParams );

                    // Convert parameters from display names to LDAP names
                    DisplayNameMap* pNameMap = DisplayNames::GetMap(m_ClassInfo.Name());    
                    if (pNameMap != NULL)
                    {
                        // Create function object to do parameter translation
                        CLookupLDAPName lookup(m_ClassInfo.Columns(), pNameMap);

                        ReplaceParameters(strParams, lookup, TRUE);
                    }
                    
                    pShellMenu->m_strCmdLine.erase();
                    pShellMenu->m_strCmdLine = strParams;
                        
                    pMenu = pShellMenu;
                }
            }
            break;

        case MENUTYPE_ACTDIR:
            {
                CActDirMenuCmd* pADMenu = new CActDirMenuCmd();

                if (pADMenu != NULL) 
                {
                    HWND hwndLV = GetDlgItem(IDC_MENULIST);

                    int iItem = ListView_GetNextItem(hwndLV, -1, LVNI_SELECTED);
                    ASSERT(iItem != -1);

                    LV_ITEM lvi;
                    lvi.mask = LVIF_TEXT | LVIF_PARAM;
                    lvi.iItem = iItem;
                    lvi.iSubItem = 0;                    

                    WCHAR szBuf[MAX_PATH];
                    szBuf[0] = 0;

                    lvi.pszText    = szBuf;
                    lvi.cchTextMax = MAX_PATH;

                    ListView_GetItem(hwndLV, &lvi);

                    pADMenu->m_strADName = szBuf;
                    pADMenu->m_strADNoLocName = (TCHAR*)lvi.lParam;

                    pMenu = pADMenu;
                }                                    
            }
            break;

        default:
            ASSERT(FALSE);
        }

        if (pMenu != NULL)
        {
            pMenu->m_strName = strName;
             m_pMenuCmd = pMenu;

            pMenu->SetAutoRefresh(Button_GetCheck(GetDlgItem(IDC_REFRESH)) == BST_CHECKED);
        }
    }

    //Iterate through list and delete lParams
    HWND hwndLV = GetDlgItem(IDC_MENULIST);
    int nItems = ListView_GetItemCount(hwndLV);
    
    for( int i = 0; i < nItems; i++ )
    {
        LVITEM lvi;
        ZeroMemory( &lvi, sizeof(lvi) );                    
        lvi.mask = LVIF_PARAM;
        lvi.iItem = i;
        
        ListView_GetItem( hwndLV, &lvi );

        if( lvi.lParam )
        {
            delete [] (TCHAR*)lvi.lParam;
            lvi.lParam = NULL;
            ListView_SetItem( hwndLV, &lvi );
        }
    }


    EndDialog(wID);

    return 0;
}

//////////////////////////////////////////////////////////////////////////////////
// CAddQNMenuDlg

LRESULT CAddQNMenuDlg::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{    
    // If editing an existing menu
    if (m_pMenuCmd != NULL)
    {
        // Set name modified so that it won't be changed to default 
        m_bUserModifiedName = TRUE;

        // Display info for selected menu
        LoadMenuInfo(m_pMenuCmd);
    }    

    m_bCommandChg = FALSE;
    m_bStartDirChg = FALSE;

    EnableOKButton();

    return TRUE;
}


void CAddQNMenuDlg::LoadMenuInfo(CMenuCmd* pMenuCmd)
{
    SetDlgItemText( IDC_NAME, pMenuCmd->Name() );

    Button_SetCheck(GetDlgItem(IDC_REFRESH),  pMenuCmd->IsAutoRefresh() ? BST_CHECKED : BST_UNCHECKED);

    CShellMenuCmd* pShellCmd = static_cast<CShellMenuCmd*>(pMenuCmd);

    SetDlgItemText( IDC_COMMAND, pShellCmd->m_strProgPath.c_str() );
    SetDlgItemText( IDC_STARTIN, pShellCmd->m_strStartDir.c_str() );
    SetDlgItemText( IDC_PARAMS,  pShellCmd->m_strCmdLine.c_str()  );    
    SetMenuType(MENUTYPE_SHELL);         
}

LRESULT CAddQNMenuDlg::OnBrowseForCommand( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    tstring strCommand;
    GetItemText( GetDlgItem(IDC_COMMAND), strCommand );

    tstring strFilter = StrLoadString(IDS_EXEFILTER);

    /*
     * The file dialog expects embedded \0's in the string, but those
     * don't load well.  The string in the resource file has \\ where
     * the \0 should be, so let's make the substitution now.
     */
    LPTSTR pchTemp = (LPTSTR)strFilter.data();
    for (LPTSTR pch = pchTemp; *pch != _T('\0'); pch = pchTemp )
    {
        pchTemp = CharNext(pch);
        if (*pch == _T('\\'))
            *pch = _T('\0');
    }
    // don't call ReleaseBuffer, since the string now contains \0 chars

    CFileDialog dlg (true, NULL, strCommand.c_str(), OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, strFilter.c_str(), m_hWnd);

    if (dlg.DoModal() == IDOK)
    {
        SetDlgItemText (IDC_COMMAND, dlg.m_szFileName);
    }

    return (0);
}

LRESULT CAddQNMenuDlg::OnBrowseForStartIn( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    tstring strCaption = StrLoadString(IDS_SELECT_STARTDIR);

    tstring strDir;
    GetItemText( GetDlgItem(IDC_STARTIN), strDir );

    CFolderDialogPriv dlg( m_hWnd, strCaption.c_str(), BIF_RETURNONLYFSDIRS|BIF_NEWDIALOGSTYLE, strDir.c_str() );

    if (dlg.DoModal() == IDOK)
    {
        SetDlgItemText (IDC_STARTIN, dlg.GetFolderPath());
    }

    return (0);
}


LRESULT CAddQNMenuDlg::OnNameChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    m_bUserModifiedName = TRUE;
    EnableOKButton();
    return 0;
}

LRESULT CAddQNMenuDlg::OnCommandChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    EnableOKButton();

    m_bCommandChg = TRUE;

    return 0;
}

LRESULT CAddQNMenuDlg::OnStartDirChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    m_bStartDirChg = TRUE;
    return 0;
}

void CAddQNMenuDlg::EnableOKButton()
{
    BOOL bEnable = TRUE;

    if (::Edit_GetTextLength(GetDlgItem(IDC_NAME)) == 0)
    {
        bEnable = FALSE;
    }
    else
    {        
        if (::Edit_GetTextLength(GetDlgItem(IDC_COMMAND)) == 0) 
            bEnable = FALSE;        
    }

    EnableDlgItem( m_hWnd, IDOK, bEnable );
}

void CAddQNMenuDlg::SetMenuType(MENUTYPE type)
{   
    m_menutype = type;

    EnableOKButton();
}

LRESULT CAddQNMenuDlg::OnClose( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if (wID == IDOK) 
    {
        CMenuCmd* pMenu = NULL;

        // Get menu name
        tstring strName;
        GetItemText( GetDlgItem(IDC_NAME), strName );

        // Name without the hotkey
        tstring strPlainName = strName;

        // Validate hotkey selection
        int posKey = strName.find(L"&", 0);
        if (posKey != tstring::npos) 
        {
            WCHAR chKey = posKey < strName.size() - 1 ? strName[posKey+1] : 0;
            if (!( (chKey >= L'A' && chKey <= L'Z') || 
                   (chKey >= L'a' && chKey <= L'z') ||
                   (chKey >= L'0' && chKey <= L'9') ))
            {
                DisplayMessageBox(m_hWnd, IDS_ERRORTITLE_MENUNAME, IDS_ERROR_BADACCESSKEY);
                return 0;
            }

            if (strName.find(L"&", posKey+1) != tstring::npos)
            {
                DisplayMessageBox(m_hWnd, IDS_ERRORTITLE_MENUNAME, IDS_ERROR_MULTIACCESSKEY);
                return 0;
            }

            // remove '&'
            strPlainName.erase(posKey, 1);
        }

        // Check for duplicated name
         menucmd_vector::iterator itMenu;
         for (itMenu = m_EditObject.Menus().begin(); itMenu != m_EditObject.Menus().end(); ++itMenu) 
         {

            // if editing a an existing menu, don't compare to itself
            if (*itMenu == m_pMenuCmd)
                continue;
 
            // Compare names, skipping '&'s
            LPCWSTR pszName = (*itMenu)->Name();
            LPCWSTR pszNewName = strPlainName.c_str();

            while (*pszName && *pszNewName) 
            {
                if (*pszName == L'&')
                    ++pszName;

                if (*pszName != *pszNewName)
                    break;

                ++pszName;
                ++pszNewName;
            }

            // if duplicate name
            if (*pszName == *pszNewName)
            {
                DisplayMessageBox(m_hWnd, IDS_ERRORTITLE_MENUNAME, IDS_ERROR_DUPMENUNAME, MB_OK|MB_ICONEXCLAMATION, strPlainName.c_str());
                return 0;
            }
        }
                   
		CShellMenuCmd* pShellMenu = new CShellMenuCmd();

        if (pShellMenu != NULL) 
        {
            GetItemText( GetDlgItem(IDC_COMMAND), pShellMenu->m_strProgPath );

            if (m_bCommandChg && ValidateFile(pShellMenu->m_strProgPath) != S_OK) 
            {
                int iRet = DisplayMessageBox(m_hWnd, IDS_ERRORTITLE_MENUCMD, IDS_ERROR_MENUCMD,
                                             MB_ICONINFORMATION | MB_YESNO, pShellMenu->m_strProgPath.c_str());
                if (iRet != IDYES) 
                {
                    delete pShellMenu;
                    return 0;
                }
            }

            GetItemText( GetDlgItem(IDC_STARTIN), pShellMenu->m_strStartDir );

            if (m_bStartDirChg && !pShellMenu->m_strStartDir.empty() && 
                ValidateDirectory(pShellMenu->m_strStartDir) != S_OK) 
            {
                int iRet = DisplayMessageBox(m_hWnd, IDS_ERRORTITLE_STARTDIR, IDS_ERROR_STARTDIR,
                                             MB_ICONINFORMATION | MB_YESNO, pShellMenu->m_strStartDir.c_str());
                if (iRet != IDYES) 
                {
                    delete pShellMenu;
                    return 0;
                }

            }

            tstring strParams;
            GetItemText( GetDlgItem(IDC_PARAMS), strParams );
            
            pShellMenu->m_strCmdLine.erase();
            pShellMenu->m_strCmdLine = strParams;
                
            pMenu = pShellMenu;
        }    

        if (pMenu != NULL)
        {
            pMenu->m_strName = strName;
            m_pMenuCmd = pMenu;

            pMenu->SetAutoRefresh(Button_GetCheck(GetDlgItem(IDC_REFRESH)) == BST_CHECKED);
        }
    }

    EndDialog(wID);

    return 0;
}



//////////////////////////////////////////////////////////////////////////////////////////////
// Add Group Node Dialog


LRESULT CAddGroupNodeDlg::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    EnableDlgItem( m_hWnd, IDC_SCOPE_LBL,    FALSE );
    EnableDlgItem( m_hWnd, IDC_SCOPE,        FALSE );
    EnableDlgItem( m_hWnd, IDC_SCOPE_BROWSE, FALSE );
    EnableDlgItem( m_hWnd, IDC_FILTER_LBL,   FALSE );
    EnableDlgItem( m_hWnd, IDC_FILTER,       FALSE );
    EnableDlgItem( m_hWnd, IDOK,             FALSE );

    SendDlgItemMessage( IDC_NAME, EM_LIMITTEXT, 255, 0);

    return TRUE;
}

LRESULT CAddGroupNodeDlg::OnApplyScopeClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL bEnable = Button_GetCheck(GetDlgItem(IDC_APPLYSCOPE)) == BST_CHECKED;

    EnableDlgItem( m_hWnd, IDC_SCOPE_LBL,    bEnable );
    EnableDlgItem( m_hWnd, IDC_SCOPE,        bEnable );
    EnableDlgItem( m_hWnd, IDC_SCOPE_BROWSE, bEnable );

    EnableOKButton();

    return 0;
}


LRESULT CAddGroupNodeDlg::OnApplyFilterClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL bEnable = Button_GetCheck(GetDlgItem(IDC_APPLYFILTER)) == BST_CHECKED;

    EnableDlgItem( m_hWnd, IDC_FILTER_LBL, bEnable );
    EnableDlgItem( m_hWnd, IDC_FILTER,     bEnable );

    EnableOKButton();
    return 0;
}


LRESULT CAddGroupNodeDlg::OnScopeBrowse(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = GetQueryScope(m_hWnd, m_strScope);

    if (hr == S_OK) 
    {
        tstring strDisplay;
        GetScopeDisplayString(m_strScope, strDisplay);

        SetDlgItemText( IDC_SCOPE, strDisplay.c_str() );
    }

    EnableOKButton();

    return 0;
}


LRESULT CAddGroupNodeDlg::OnEditChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    EnableOKButton();
    return 0;
}


void CAddGroupNodeDlg::EnableOKButton()
{
    BOOL bEnable;

    if ( (::Edit_GetTextLength(GetDlgItem(IDC_NAME)) == 0) ||

         (Button_GetCheck(GetDlgItem(IDC_APPLYFILTER)) == BST_CHECKED &&
                ::Edit_GetTextLength(GetDlgItem(IDC_FILTER)) == 0) ||

         (Button_GetCheck(GetDlgItem(IDC_APPLYSCOPE)) == BST_CHECKED &&
                m_strScope.size() == 0) )
    {
        bEnable = FALSE;
    }
    else
    {
        bEnable = TRUE;
    }

     EnableDlgItem( m_hWnd, IDOK, bEnable );
}


LRESULT CAddGroupNodeDlg::OnClose( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if (wID == IDOK) 
    {
        if( !m_pnode ) return 0;        

        bool bScope = Button_GetCheck(GetDlgItem(IDC_APPLYSCOPE)) == BST_CHECKED;
        m_pnode->SetApplyScope(bScope);

        m_pnode->SetScope(m_strScope.c_str());

        bool bFilter = Button_GetCheck(GetDlgItem(IDC_APPLYFILTER)) == BST_CHECKED;
        m_pnode->SetApplyFilter(bFilter);

        tstring strFilter;
        GetItemText( GetDlgItem(IDC_FILTER), strFilter );
        m_pnode->SetFilter(strFilter.c_str());

        GetItemText( GetDlgItem(IDC_NAME), m_strName );
    }

    EndDialog(wID);

    return 0;
}


//////////////////////////////////////////////////////////////////////////////////
// CMoveQueryDlg

LRESULT CMoveQueryDlg::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    if( !m_pnodeCurFolder ) return 0;

    CRootNode* pRootNode = m_pnodeCurFolder->GetRootNode();
    if( !pRootNode ) return 0;

    HWND hwndTree = GetDlgItem(IDC_FOLDERTREE);

    // Create a node image list and assign to folder tree
    CImageList images;

    if (images.Create(IDB_QUERY16, 16, 100, RGB(255,0,255)))
        TreeView_SetImageList(hwndTree, images.Detach(), TVSIL_NORMAL);

    // Set snap-in root node as root of tree
    TV_INSERTSTRUCT tvi;
    tvi.hParent = TVI_ROOT;
    tvi.hInsertAfter = TVI_ROOT;
    tvi.item.mask = TVIF_TEXT|TVIF_IMAGE|TVIF_SELECTEDIMAGE|TVIF_PARAM;
    tvi.item.pszText = const_cast<LPWSTR>(pRootNode->GetName());
    tvi.item.iImage = pRootNode->GetImage();
    tvi.item.iSelectedImage = tvi.item.iImage;
    tvi.item.lParam = reinterpret_cast<LPARAM>(pRootNode);

    HTREEITEM hti = TreeView_InsertItem(hwndTree, &tvi);
    if( !hti ) return 0;

    // Insert all group nodes as children of root
    tvi.hParent = hti;
    tvi.hInsertAfter = TVI_LAST;

    CScopeNode* pnode = pRootNode->FirstChild();
    while (pnode != NULL) 
    {
        if (pnode->NodeType() == GROUP_NODETYPE) 
        {
            tvi.item.pszText = const_cast<LPWSTR>(pnode->GetName());
            tvi.item.iImage = pnode->GetImage();
            tvi.item.iSelectedImage = tvi.item.iImage;
            tvi.item.lParam = reinterpret_cast<LPARAM>(pnode);

            HTREEITEM hti2 = TreeView_InsertItem(hwndTree, &tvi);
            ASSERT(hti2 != NULL);
        }

        pnode = pnode->Next();
    }

    // Show the group nodes
    TreeView_Expand(hwndTree, hti, TVE_EXPAND);

    return TRUE;
}
 

LRESULT CMoveQueryDlg::OnClose( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if( (wID == IDOK) && m_ppnodeDestFolder )
    {
        HWND hwndTree = GetDlgItem(IDC_FOLDERTREE);

        // Get the node pointer (lparam) of the selected tree item
        HTREEITEM hti = TreeView_GetSelection(hwndTree);
        if( !hti ) return 0;

        TVITEM tvi;
        tvi.hItem = hti;
        tvi.mask = TVIF_PARAM;
        tvi.lParam = NULL;

        BOOL bStat = TreeView_GetItem(hwndTree, &tvi);
        ASSERT(bStat && tvi.lParam != NULL);

        *m_ppnodeDestFolder = reinterpret_cast<CScopeNode*>(tvi.lParam);
    }

    EndDialog(wID);

    return 0;
}


////////////////////////////////////////////////////////////////////////////////////
// Parameter translation classes
//

// LDAP to Display translator
BOOL CLookupDisplayName::operator() (tstring& strParam, tstring& strValue)
{
    // Check for special parameter ID value 
    if (strParam.size() == 1 && strParam[0] <= MENU_PARAM_LAST)
    {
        // Find entry in param table and return display string
        for (int i = 0; i<lengthof(MenuParamTable); i++)
        {
            if (MenuParamTable[i].ID == strParam[0]) 
            {
                CString str;
                str.LoadString(MenuParamTable[i].rsrcID);

                strValue = str;
                return TRUE;
            }
        }
    }

    // check for class attribute name
    string_vector::iterator itstr = std::find(m_vstrParam.begin(), m_vstrParam.end(), strParam);
    if (itstr == m_vstrParam.end())
        return FALSE;

    strValue = m_pNameMap->GetAttributeDisplayName(itstr->c_str());

    return TRUE;
}


// Display to LDAP translator
BOOL CLookupLDAPName::operator() (tstring& strParam, tstring& strValue)
{
    // Check for standard parameter name
    for (int i=0; i<lengthof(MenuParamTable); i++)
    {
        CString str;
        str.LoadString(MenuParamTable[i].rsrcID);

        // if match, return single wchar equal to param ID
        if (_wcsicmp(strParam.c_str(), str) == 0)
        {
            strValue = (WCHAR)MenuParamTable[i].ID;
            return TRUE;
        }
    }

    // Check for class attribute display name
    string_vector::iterator itstr;
    for (itstr = m_vstrParam.begin(); itstr != m_vstrParam.end(); ++itstr) 
    {
        if (_wcsicmp(strParam.c_str(), m_pNameMap->GetAttributeDisplayName(itstr->c_str())) == 0)
        {
            strValue = (*itstr);
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\compdata.h ===
// compdata.h : Declaration of the CComponentData

#ifndef __COMPDATA_H_
#define __COMPDATA_H_

/////////////////////////////////////////////////////////////////////////////
// CComponentData
class ATL_NO_VTABLE CComponentData : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CComponentData, &CLSID_BOMSnapIn>,
    public CDataObjectImpl,
    public IComponentData,
    public IPersistStream,
    public IExtendContextMenu,
    public IExtendPropertySheet2,
	public ISnapinHelp2
{
public:
    CComponentData() : m_bDirty(FALSE) {}

    DECLARE_NOT_AGGREGATABLE(CComponentData)

    BEGIN_COM_MAP(CComponentData)
        COM_INTERFACE_ENTRY(IDataObject)
        COM_INTERFACE_ENTRY(IBOMObject)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IPersistStream)
        COM_INTERFACE_ENTRY(IExtendPropertySheet2)
		COM_INTERFACE_ENTRY(ISnapinHelp2)
    END_COM_MAP()

	// Class registration method
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister); 

public:
    //
    // IComponentData methods
    //
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

    //
    // IDataObjectImpl methods
    //
    STDMETHOD(GetDataImpl)(UINT cf, HGLOBAL* hGlobal);
    
    //
    // IExtendContextMenu methods
    //
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallback, long* plAllowed);
    STDMETHOD(Command)(long lCommand, LPDATAOBJECT pDataObject);

    // IExtendPropertySheet2 methods
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,LONG_PTR handle, LPDATAOBJECT lpIDataObject);
    STDMETHOD(GetWatermarks)(LPDATAOBJECT lpIDataObject, HBITMAP* lphWatermark, 
                             HBITMAP* lphHeader, HPALETTE* lphPalette, BOOL* bStretch);
 
	// ISnapinHelp2
	STDMETHOD(GetHelpTopic)(LPOLESTR* ppszHelpFile);
	STDMETHOD(GetLinkedTopics)(LPOLESTR* ppszHelpFiles);

    // IPersistStream methods
    //
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStream);
    STDMETHOD(Save)(IStream *pStream, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

    //
    // IBOMObject methods
    //
    STDMETHOD(Notify)(LPCONSOLE2 pCons, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK pCallback, long* lAllowed);
    STDMETHOD(SetToolButtons)(LPTOOLBAR pToolbar);
    STDMETHOD(MenuCommand)(LPCONSOLE2 pConsole, long lCommand);
    STDMETHOD(SetVerbs)(LPCONSOLEVERB pConsVerb);
    STDMETHOD(QueryPagesFor)();
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,LONG_PTR handle);
    STDMETHOD(GetWatermarks)(HBITMAP* lphWatermark, HBITMAP* lphHeader, HPALETTE* lphPalette, BOOL* bStretch);

    CScopeNode* CookieToScopeNode(MMC_COOKIE cookie)
    {
        if (cookie == 0)
        {
            ASSERT(m_spRootNode != NULL);
            return m_spRootNode;
        }
        else
        {
            return reinterpret_cast<CScopeNode*>(cookie);
        }
    }

    IConsole2* GetConsole()           { return m_spConsole; }
    IConsoleNameSpace* GetNameSpace() { return m_spNameSpace; }
    IStringTable* GetStringTable()    { return m_spStringTable; }

private:
        
    IConsole2Ptr         m_spConsole;
    IConsoleNameSpacePtr m_spNameSpace;
    IStringTablePtr      m_spStringTable;
    CRootNodePtr         m_spRootNode;

    BOOL           m_bDirty;
    static UINT    m_cfDisplayName;

};

#endif //__COMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\compdata.cpp ===
// compdata.cpp : Implementation of Ccompdata
#include "stdafx.h"

#include "BOMSnap.h"
#include "rowitem.h"
#include "scopenode.h"
#include "compdata.h"
#include "compont.h"
#include "dataobj.h"

#include "streamio.h"
#include "adext.h"

HWND  g_hwndMain = NULL; // MMC main window
DWORD g_dwFileVer;       // Current console file version number

/////////////////////////////////////////////////////////////////////////////
// CComponentData

UINT CComponentData::m_cfDisplayName = RegisterClipboardFormat(TEXT("CCF_DISPLAY_NAME"));

STDMETHODIMP CComponentData::Initialize(LPUNKNOWN pUnknown)
{
    VALIDATE_POINTER( pUnknown );

    // Get Interfaces
    m_spConsole = pUnknown;
    if (m_spConsole == NULL) return E_NOINTERFACE;

    m_spNameSpace = pUnknown;
    if (m_spNameSpace == NULL) return E_NOINTERFACE;

    m_spStringTable = pUnknown;
    if (m_spStringTable == NULL) return E_NOINTERFACE;

    // Get main window for message boxes (see DisplayMessageBox in util.cpp)
    HRESULT hr = m_spConsole->GetMainWindow(&g_hwndMain);
    ASSERT(SUCCEEDED(hr));

    // Create the root scope node
    CComObject<CRootNode>* pnode;
    hr = CComObject<CRootNode>::CreateInstance(&pnode);
    RETURN_ON_FAILURE(hr);

    m_spRootNode = pnode;
    hr = m_spRootNode->Initialize(this);
    RETURN_ON_FAILURE(hr);

    // Initialize the common controls once
    static BOOL bInitComCtls = FALSE;
    if (!bInitComCtls) 
    { 
        INITCOMMONCONTROLSEX icex;
        icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icex.dwICC   = ICC_USEREX_CLASSES | ICC_LISTVIEW_CLASSES;
        bInitComCtls = InitCommonControlsEx(&icex);
    }

    // Init the active directory proxy class
     CActDirExtProxy::InitProxy();

    return S_OK;
}


STDMETHODIMP CComponentData::Destroy()
{
    // Release all refs to mmc
    m_spConsole.Release();
    m_spNameSpace.Release();
    m_spStringTable.Release();

    return S_OK;
}


STDMETHODIMP CComponentData::CreateComponent(LPCOMPONENT* ppComponent)
{
    VALIDATE_POINTER(ppComponent);

    CComObject<CComponent>* pComp;
    HRESULT hr = CComObject<CComponent>::CreateInstance(&pComp);
    RETURN_ON_FAILURE(hr);

    // Store back pointer to ComponentData
    pComp->SetComponentData(this);

    return pComp->QueryInterface(IID_IComponent, (void**)ppComponent);
}


STDMETHODIMP CComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    // Special handling of prop change message for lpDataObject
    // We will get data object and lparam from PropChangeInfo passed as param
    // The lpDataObject from MMC is NULL
    if (event == MMCN_PROPERTY_CHANGE) 
    {  
        VALIDATE_POINTER( param );
        PropChangeInfo* pchg = reinterpret_cast<PropChangeInfo*>(param);

        lpDataObject = pchg->pDataObject;
        param = pchg->lNotifyParam;

        delete pchg;
    }
    
    // Query data object for private Back Office Manager interface
    IBOMObjectPtr spObj = lpDataObject;
    if (spObj == NULL)
    {
        ASSERT(0 && "Foreign data object");
        return E_INVALIDARG;
    }
    
    // Pass notification to object
    return spObj->Notify(m_spConsole, event, arg, param);
}


STDMETHODIMP CComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    VALIDATE_POINTER( ppDataObject );

    if (type == CCT_SNAPIN_MANAGER)
        return GetUnknown()->QueryInterface(IID_IDataObject, (void**)ppDataObject);

    IDataObject* pDO = NULL;

    if (type == CCT_SCOPE)
    {
        CScopeNode* pNode = CookieToScopeNode(cookie);
        
        if (pNode)
            return pNode->QueryInterface(IID_IDataObject, (void**)ppDataObject);
        else
            return E_INVALIDARG;
    }

    return E_FAIL;
}

STDMETHODIMP CComponentData::GetDisplayInfo(SCOPEDATAITEM* pSDI)
{
    VALIDATE_POINTER( pSDI );

    CScopeNode* pNode = CookieToScopeNode(pSDI->lParam);
    if (pNode == NULL) return E_INVALIDARG;

    return pNode->GetDisplayInfo(pSDI);
}


STDMETHODIMP CComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    IUnknownPtr pUnkA= lpDataObjectA;
    IUnknownPtr pUnkB = lpDataObjectB;

    return (pUnkA == pUnkB) ? S_OK : S_FALSE;
}


HRESULT CComponentData::GetDataImpl(UINT cf, HGLOBAL* phGlobal)
{
    VALIDATE_POINTER( phGlobal );

    HRESULT hr = DV_E_FORMATETC;
    
    tstring strName = StrLoadString(IDS_ROOTNODE);

    if (cf == m_cfDisplayName)
    {
        hr = DataToGlobal(phGlobal, strName.c_str(), (strName.length() + 1) * sizeof(WCHAR) );
    }

    return hr;
}


//--------------------------------------------------------------------------------
// IPersistStreamInit Implementation
//--------------------------------------------------------------------------------
HRESULT CComponentData::GetClassID(CLSID *pClassID)
{
    VALIDATE_POINTER(pClassID)

    memcpy(pClassID, &CLSID_BOMSnapIn, sizeof(CLSID));

    return S_OK;
}


HRESULT CComponentData::IsDirty()
{
    return m_bDirty ? S_OK : S_FALSE;
}


HRESULT CComponentData::Load(IStream *pStream)
{
    VALIDATE_POINTER(pStream)
 
    HRESULT hr = S_OK;
    try
    {
        // Read version code
        *pStream >> g_dwFileVer;
        
        // Should already have a default root node from the Initialize call
        ASSERT(m_spRootNode != NULL);
        if (m_spRootNode == NULL)
            return E_UNEXPECTED;

        // Now load the root node and the rest of the node tree
        hr = m_spRootNode->Load(*pStream);
    }
    catch (_com_error& err)
    {
        hr = err.Error();
    }

    // Don't keep a tree that failed to load
    if (FAILED(hr))
        m_spRootNode.Release();

    return hr;
}


HRESULT CComponentData::Save(IStream *pStream, BOOL fClearDirty)
{
    VALIDATE_POINTER(pStream)

    // Can't save if haven't been loaded or initialized
    if (m_spRootNode == NULL)
        return E_FAIL;

    HRESULT hr = S_OK;
    try
    {
        // Write version code
        *pStream << SNAPIN_VERSION;

        // Write root node and rest of the node tree
        hr = m_spRootNode->Save(*pStream);
    }
    catch (_com_error& err)
    {
        hr = err.Error();
    }

    if (SUCCEEDED(hr) && fClearDirty)
        m_bDirty = FALSE;

    return hr;
}


HRESULT CComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    return E_NOTIMPL;
}


HRESULT CComponentData::Notify(LPCONSOLE2 pCons, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    return S_OK;
}

/******************************************************************************************
 * Menus and verbs
 ******************************************************************************************/

HRESULT CComponentData::AddMenuItems( LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallback, long* plAllowed )
{
    VALIDATE_POINTER( pCallback );
    VALIDATE_POINTER( plAllowed );

    IBOMObjectPtr spObj = pDataObject;
    if (spObj == NULL) return E_INVALIDARG;

    return spObj->AddMenuItems(pCallback, plAllowed);
}

HRESULT CComponentData::Command(long lCommand, LPDATAOBJECT pDataObject)
{
    IBOMObjectPtr spObj = pDataObject;
    if (spObj == NULL)  return E_INVALIDARG;

    return spObj->MenuCommand(m_spConsole, lCommand);
}

HRESULT CComponentData::AddMenuItems(LPCONTEXTMENUCALLBACK pCallback, long* plAllowed)
{
    return S_OK;
}

HRESULT CComponentData::MenuCommand(LPCONSOLE2 pConsole, long lCommand)
{
    return S_FALSE;
}

HRESULT CComponentData::SetToolButtons(LPTOOLBAR pToolbar)
{
    return S_FALSE;
}

HRESULT CComponentData::SetVerbs(LPCONSOLEVERB pConsVerb)
{
    return S_OK;
}

/*****************************************************************************************
 * Property Pages
 *****************************************************************************************/

HRESULT CComponentData::QueryPagesFor(LPDATAOBJECT pDataObject)
{
    IBOMObjectPtr spObj = pDataObject;
    if (spObj == NULL) return E_INVALIDARG;

    return spObj->QueryPagesFor();
}

HRESULT CComponentData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK pProvider, LONG_PTR handle, LPDATAOBJECT pDataObject)
{
    VALIDATE_POINTER( pProvider );

    IBOMObjectPtr spObj = pDataObject;
    if (spObj == NULL) return E_INVALIDARG;

    return spObj->CreatePropertyPages(pProvider, handle);
}

HRESULT CComponentData::GetWatermarks(LPDATAOBJECT pDataObject, HBITMAP* phWatermark, HBITMAP* phHeader, 
                                      HPALETTE* phPalette, BOOL* bStreach)
{
    IBOMObjectPtr spObj = pDataObject;
    if (spObj == NULL) return E_INVALIDARG;

    return spObj->GetWatermarks(phWatermark, phHeader, phPalette, bStreach);
}

HRESULT CComponentData::QueryPagesFor()
{
    return S_FALSE;
}

HRESULT CComponentData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK pProvider, LONG_PTR handle)
{
    return S_FALSE;
}

HRESULT CComponentData::GetWatermarks(HBITMAP* phWatermark, HBITMAP* phHeader, HPALETTE* phPalette, BOOL* bStreach)
{
    return S_FALSE;
}


//--------------------------------------------------------------------------------
// ISnapinHelp2 Implementation
//--------------------------------------------------------------------------------
HRESULT CComponentData::GetHelpTopic(LPOLESTR* ppszHelpFile)
{
	VALIDATE_POINTER(ppszHelpFile);
	*ppszHelpFile = NULL;

	tstring strTmp = _T("");
    tstring strHelpFile = _T("");
    
    // Build path to %systemroot%\help
    TCHAR szWindowsDir[MAX_PATH+1] = {0};
    UINT nSize = GetSystemWindowsDirectory( szWindowsDir, MAX_PATH );
    if( nSize == 0 || nSize > MAX_PATH )
    {
        return E_FAIL;
    }

    strTmp = StrLoadString(IDS_HELPFILE);    
    if( strTmp.empty() ) 
    {
        return E_FAIL;
    }

    strHelpFile  = szWindowsDir;  
    strHelpFile += _T("\\Help\\");
    strHelpFile += strTmp;        

    // Form file path in allocated buffer
    int nLen = strHelpFile.length() + 1;

    *ppszHelpFile = (LPOLESTR)CoTaskMemAlloc(nLen * sizeof(OLECHAR));
    if( *ppszHelpFile == NULL ) return E_OUTOFMEMORY;

    // Copy into allocated buffer
    ocscpy( *ppszHelpFile, T2OLE( (LPTSTR)strHelpFile.c_str() ) );

    return S_OK;
}

HRESULT CComponentData::GetLinkedTopics(LPOLESTR* ppszLinkedFiles)
{
	VALIDATE_POINTER(ppszLinkedFiles);

	// no linked files
	*ppszLinkedFiles = NULL;
	return S_FALSE;
}


//-------------------------------------------------------------------------------------------
// Class registration
//-------------------------------------------------------------------------------------------
HRESULT WINAPI CComponentData::UpdateRegistry(BOOL bRegister)
{
	// Load snap-in root name to use as registered snap-in name
	tstring strSnapinName = StrLoadString(IDS_ROOTNODE);

    // Specify the substitution parameters for IRegistrar.
    _ATL_REGMAP_ENTRY rgEntries[] =
    {
        {TEXT("SNAPIN_NAME"), strSnapinName.c_str()},
        {NULL, NULL},
    };

	// Register the component data object
    HRESULT hr = _Module.UpdateRegistryFromResource(IDR_BOMSNAP, bRegister, rgEntries);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\compont.cpp ===
// Compont.cpp : Implementation of CComponent
#include "stdafx.h"

#include "BOMSnap.h"
#include "ScopeNode.h"
#include "CompData.h"
#include "Compont.h"
#include "qryitem.h"

#include <atlgdi.h>
#include <algorithm>


// Toolbar button data (must match bitmap order in res\toolbar.bmp)
static struct
{
    int iMenuID;
    int iTextID;
    int iTipTextID;
} ToolbarBtns[] =
{
    { MID_EDITQUERY, BTN_EDITQUERY, TIP_EDITQUERY },
    { MID_STOPQUERY, BTN_STOPQUERY, TIP_STOPQUERY }
};


/////////////////////////////////////////////////////////////////////////////
// CComponent

STDMETHODIMP 
CComponent::Initialize(LPCONSOLE lpConsole)
{
    VALIDATE_POINTER(lpConsole);

    ASSERT(lpConsole != NULL);
    if (lpConsole == NULL) return E_INVALIDARG;

    m_spConsole = lpConsole;
    m_spResultData = lpConsole;
    m_spHeaderCtrl = lpConsole;

    ASSERT(m_spHeaderCtrl != NULL);
    ASSERT(m_spResultData != NULL);

    return S_OK;
}


STDMETHODIMP
CComponent::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    IBOMObjectPtr spObj = lpDataObject;
    if (spObj == NULL)
    {
        // until special notifications handled
        return S_FALSE;
    }

    HRESULT hr = S_OK;

    if (event == MMCN_SHOW)
    {
        // if selecting node
        if (arg)
        {
            m_spCurScopeNode = static_cast<CScopeNode*>((IBOMObject*)spObj);
            hr = m_spCurScopeNode->AttachComponent(this);
        }
        else
        {
            if (m_spCurScopeNode != NULL) 
            {
                m_spCurScopeNode->DetachComponent(this);
                m_spCurScopeNode = NULL;
            }

            m_vRowItems.clear();
        }
    }
    else
    {
        hr = spObj->Notify(m_spConsole, event, arg, param);
    }
    

    return hr;
}

HRESULT
CComponent::AddMenuItems(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallback, long* plAllowed)
{
    IBOMObjectPtr spObj = pDataObject;
    if (spObj == NULL) return E_INVALIDARG;

    return spObj->AddMenuItems(pCallback, plAllowed);
}

HRESULT
CComponent::Command(long lCommand, LPDATAOBJECT pDataObject)
{
    IBOMObjectPtr spObj = pDataObject;
    if (spObj == NULL) return E_INVALIDARG;

    return spObj->MenuCommand(m_spConsole, lCommand);
}


HRESULT
CComponent::QueryPagesFor(LPDATAOBJECT pDataObject)
{
    IBOMObjectPtr spObj = pDataObject;
    
    if (spObj == NULL) return E_INVALIDARG;
    
    return spObj->QueryPagesFor();
}

HRESULT
CComponent::CreatePropertyPages(LPPROPERTYSHEETCALLBACK pProvider, LONG_PTR handle, LPDATAOBJECT pDataObject)
{
    IBOMObjectPtr spObj = pDataObject;
    
    if (spObj == NULL) return E_INVALIDARG;

    return spObj->CreatePropertyPages(pProvider, handle);
}

HRESULT
CComponent::GetWatermarks(LPDATAOBJECT pDataObject, HBITMAP* phWatermark, HBITMAP* phHeader, 
                              HPALETTE* phPalette, BOOL* bStreach)
{
    IBOMObjectPtr spObj = pDataObject;
    if (spObj == NULL) return E_INVALIDARG;

    return spObj->GetWatermarks(phWatermark, phHeader, phPalette, bStreach);
}

HRESULT
CComponent::SetControlbar(LPCONTROLBAR pControlbar)
{
    HRESULT hr;

    if (pControlbar != NULL)
    {
        m_spControlbar = pControlbar;

        if (m_spToolbar == NULL)
        {
            hr = pControlbar->Create(TOOLBAR, this, (LPUNKNOWN*)&m_spToolbar);
            ASSERT(SUCCEEDED(hr));

            if (m_spToolbar != NULL)
            {
                CBitmap bmpToolbar;
                bmpToolbar.LoadBitmap(IDB_TOOLBAR);
                ASSERT(bmpToolbar);
    
                if (bmpToolbar) 
                {
                    hr = m_spToolbar->AddBitmap(lengthof(ToolbarBtns), bmpToolbar, 16, 16, RGB(255,0,255));
                    ASSERT(SUCCEEDED(hr));
    
                    if (SUCCEEDED(hr)) 
                    {
                        MMCBUTTON btn;
                        btn.fsState = 0;
                        btn.fsType = TBSTYLE_BUTTON;
    
                        for (int iBtn=0; iBtn < lengthof(ToolbarBtns); iBtn++) 
                        {
                            CString strBtnText;                        
                            strBtnText.LoadString(ToolbarBtns[iBtn].iTextID);
    
                            CString strTipText;
                            strTipText.LoadString(ToolbarBtns[iBtn].iTipTextID);
    
                            btn.nBitmap       = iBtn;
                            btn.idCommand     = ToolbarBtns[iBtn].iMenuID;
                            btn.lpButtonText  = const_cast<LPWSTR>((LPCWSTR)strBtnText);
                            btn.lpTooltipText = const_cast<LPWSTR>((LPCWSTR)strTipText);
    
                            hr = m_spToolbar->InsertButton(iBtn, &btn);
                            ASSERT(SUCCEEDED(hr));
                        }                        
                    }
                }   
            }
        }
    }
    else
    {
        if (m_spControlbar != NULL && m_spToolbar != NULL)
            m_spControlbar->Detach(m_spToolbar);
    }


    return S_OK;
}

HRESULT
CComponent::ControlbarNotify (MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    
    HRESULT hr = S_FALSE;

    switch(event)
    {
    case MMCN_SELECT:
        // if selecting, update toolbar
        if (HIWORD(arg))
        {
            IBOMObjectPtr spObj = reinterpret_cast<LPDATAOBJECT>(param);
            if (spObj == NULL)
                break;

            ASSERT(m_spControlbar != NULL && m_spToolbar != NULL);

            // Let selected object set buttons
            //  Show/hide toolbar based on return value 
            m_spControlbar->Attach(TOOLBAR, m_spToolbar);

            if (spObj->SetToolButtons(m_spToolbar) != S_OK)                
                m_spControlbar->Detach(m_spToolbar);
        }

        hr = S_OK;
        break;

    case MMCN_BTN_CLICK:
        IBOMObjectPtr spObj = reinterpret_cast<LPDATAOBJECT>(arg);
        if (spObj == NULL)
           break;

        // treat button click as corresponding menu item
        hr = spObj->MenuCommand(m_spConsole, param);
        break;
    }

    return hr;
}


HRESULT
CComponent::Destroy(MMC_COOKIE cookie)
{
    m_spConsole    = NULL;
    m_spResultData = NULL;
    m_spControlbar = NULL;
    m_spHeaderCtrl = NULL;
    m_spToolbar    = NULL;
    m_spCurScopeNode = NULL;

    return S_OK;
}


STDMETHODIMP
CComponent::GetResultViewType(MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions)
{
    CScopeNode* pNode = m_pCompData->CookieToScopeNode(cookie);
    if (pNode == NULL) return E_INVALIDARG;

    return pNode->GetResultViewType(ppViewType, pViewOptions);
}

STDMETHODIMP
CComponent::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    if (type == CCT_RESULT)
    {
        if ( (m_spCurScopeNode == NULL) ||
             (cookie < 0) || (cookie >= m_vRowItems.size()) )
        {
            return E_INVALIDARG;
        }

        CQueryableNode* pQNode = dynamic_cast<CQueryableNode*>(m_spCurScopeNode.p);
        if (pQNode == NULL) return E_UNEXPECTED;

        CComObject<CQueryItem>* pItem;
        HRESULT hr = CComObject<CQueryItem>::CreateInstance(&pItem);
        if( SUCCEEDED(hr) )
        {
            hr = pItem->Initialize(pQNode, &m_vRowItems[cookie]);
        }

        if( SUCCEEDED(hr) )
        {
            hr = pItem->QueryInterface(IID_IDataObject, (void**)ppDataObject);
        }

        if( FAILED(hr) )
        {
            delete pItem;            
        }

        return hr;
    }
    else
    {
        ASSERT(m_pCompData != NULL);
        return m_pCompData->QueryDataObject(cookie, type, ppDataObject);
    }
}

                        
STDMETHODIMP CComponent::GetDisplayInfo(RESULTDATAITEM* pRDI)
{
    VALIDATE_POINTER( pRDI );

    HRESULT hr = S_OK;
    
    if (pRDI->bScopeItem)
    {
        CScopeNode* pnode = reinterpret_cast<CScopeNode*>(pRDI->lParam);
        hr = pnode->GetDisplayInfo(pRDI);
    }
    else
    {
        if (pRDI->nIndex >= 0 && pRDI->nIndex < m_vRowItems.size())
        {
            if (pRDI->mask & RDI_STR)
                pRDI->str = const_cast<LPWSTR>(m_vRowItems[pRDI->nIndex][pRDI->nCol]);

            if (pRDI->mask & RDI_IMAGE)
				pRDI->nImage = m_vRowItems[pRDI->nIndex].GetIconIndex();
				
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
}


STDMETHODIMP
CComponent::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    IUnknownPtr pUnkA= lpDataObjectA;
    IUnknownPtr pUnkB = lpDataObjectB;

    return (pUnkA == pUnkB) ? S_OK : S_FALSE;
}

STDMETHODIMP
CComponent::SortItems(int nColumn, DWORD dwSortOptions, LPARAM lUserParam)
{
    if( m_vRowItems.empty() ) return S_FALSE;

    CRowCompare rc(nColumn, dwSortOptions & RSI_DESCENDING);

    std::sort(m_vRowItems.begin(), m_vRowItems.end(), rc);
    
    return S_OK;
}


void
CComponent::ClearRowItems()
{
    m_vRowItems.clear();
    m_spResultData->SetItemCount(0,0);
}


void
CComponent::AddRowItems(RowItemVector& vRowItems)
{
    m_vRowItems.insert(m_vRowItems.end(), vRowItems.begin(), vRowItems.end());   

    CRowCompare rc(0, 0);
    std::sort(m_vRowItems.begin(), m_vRowItems.end(), rc);
	m_spResultData->SetItemCount(m_vRowItems.size(), 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\cmndlgs.h ===
// cmndgls.h - Common dialogs header file

#ifndef _CMNDLGS_H_
#define _CMNDLGS_H_

#include "resource.h"
#include "menucmd.h"
#include "util.h"
#include "qryprop.h"  // For QueryEditNode

#include  <list>

class CClassInfo;
class DisplayNameMap;
class CGroupNode;
class CScopeNode;


class CAddGroupNodeDlg : public CDialogImpl<CAddGroupNodeDlg>
{
public:
    typedef CDialogImpl<CAddGroupNodeDlg> BC;

    CAddGroupNodeDlg() : m_pnode( NULL ) {}

    enum { IDD = IDD_ADDGROUPNODE };

    int DoModal(CGroupNode* pnode, HWND hwndParent)
    {
        m_pnode = pnode;
        return BC::DoModal(hwndParent);
    }

    LPCWSTR GetNodeName() { return m_strName.c_str(); }

    BEGIN_MSG_MAP( CAddGroupNodeDlg )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_HANDLER(IDC_NAME, EN_CHANGE, OnEditChange)
        COMMAND_HANDLER(IDC_FILTER, EN_CHANGE, OnEditChange)
        COMMAND_HANDLER(IDC_APPLYSCOPE, BN_CLICKED, OnApplyScopeClicked)
        COMMAND_HANDLER(IDC_APPLYFILTER, BN_CLICKED, OnApplyFilterClicked)
        COMMAND_HANDLER(IDC_SCOPE_BROWSE, BN_CLICKED, OnScopeBrowse)
        COMMAND_RANGE_HANDLER(IDOK, IDCANCEL, OnClose)
    END_MSG_MAP()

    // message handlers    
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnEditChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnApplyScopeClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnApplyFilterClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnClassSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnScopeBrowse( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnClose( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

protected:
    void EnableOKButton();

private:
    tstring     m_strScope;
    tstring     m_strName;
    CGroupNode* m_pnode;
};


class CAddColumnDlg : public CDialogImpl<CAddColumnDlg>
{
public:
    typedef CDialogImpl<CAddColumnDlg> BC;

    enum { IDD = IDD_ADDCOLUMN };

    CAddColumnDlg(LPCWSTR pszClassName) : m_strClassName(pszClassName) {}

    BEGIN_MSG_MAP( CAddColumnDlg )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	    NOTIFY_HANDLER(IDC_COLUMNLIST, LVN_ITEMCHANGED,  OnColumnChanged)
		NOTIFY_HANDLER(IDC_COLUMNLIST, LVN_ITEMACTIVATE, OnColumnActivate)
        COMMAND_RANGE_HANDLER(IDOK, IDCANCEL, OnClose)
    END_MSG_MAP()

    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnClose( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnColumnChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);
    LRESULT OnColumnActivate(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);
    string_vector& GetColumns() { return m_vstrColumns; }


private:
    tstring       m_strClassName;
    string_vector m_vstrColumns;
    string_vector m_vstrAllColumns;
};

class CAddMenuDlg : public CDialogImpl<CAddMenuDlg>
{
public:
    typedef CDialogImpl<CAddMenuDlg> BC;

    enum { IDD = IDD_ADDMENU };

    CAddMenuDlg(CClassInfo& classInfo, CMenuCmd* pMenu = NULL) : 
                m_ClassInfo(classInfo), m_pMenuCmd(pMenu), m_bUserModifiedName(FALSE) {};
    
    virtual ~CAddMenuDlg();

    CMenuCmd* GetMenu() { return m_pMenuCmd; }

    BEGIN_MSG_MAP( CAddMenuDlg )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        NOTIFY_HANDLER(IDC_MENULIST, LVN_ITEMCHANGED, OnMenuChanged)
        COMMAND_HANDLER(IDC_COMMAND, EN_CHANGE, OnCommandChange)
        COMMAND_HANDLER(IDC_STARTIN, EN_CHANGE, OnStartDirChange)
        COMMAND_HANDLER(IDC_NAME, EN_CHANGE, OnNameChange)
        COMMAND_HANDLER(IDC_COMMANDTYPE, CBN_SELENDOK, OnTypeSelect )
        COMMAND_HANDLER(IDC_COMMAND_BROWSE, BN_CLICKED, OnBrowseForCommand)
        COMMAND_HANDLER(IDC_STARTIN_BROWSE, BN_CLICKED, OnBrowseForStartIn)
        COMMAND_HANDLER(IDC_PARAMS_MENU,    BN_CLICKED, OnParameterMenu)
        COMMAND_RANGE_HANDLER(IDOK, IDCANCEL, OnClose)
    END_MSG_MAP()

    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnTypeSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnClose( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnBrowseForCommand( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnBrowseForStartIn( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnParameterMenu( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnNameChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnCommandChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnStartDirChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnMenuChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);

private:
    void SetMenuType(MENUTYPE type);
    void LoadClassMenuCmds();
    void LoadMenuInfo(CMenuCmd* pMenuCmd);
    void EnableOKButton();
    string_vector& GetStandardParams();


private:
    CClassInfo&     m_ClassInfo;
    CComboBoxEx     m_MenuTypeCB;
    CMenuCmd*       m_pMenuCmd;
    MENUTYPE        m_menutype;
    HBITMAP         m_hbmArrow;
    string_vector   m_vstrStdParam;
    bool            m_bCommandChg;
    bool            m_bStartDirChg;
    bool            m_bUserModifiedName;
};


class CAddQNMenuDlg : public CDialogImpl<CAddQNMenuDlg>
{
public:
    typedef CDialogImpl<CAddQNMenuDlg> BC;

    enum { IDD = IDD_ADDQUERYMENU };

    CAddQNMenuDlg(CQueryEditObj& editObject, CMenuCmd* pMenu = NULL) : 
                m_EditObject(editObject), m_pMenuCmd(pMenu), m_bUserModifiedName(FALSE) {};
	
				
	~CAddQNMenuDlg() {};

    CMenuCmd* GetMenu() { return m_pMenuCmd; }

    BEGIN_MSG_MAP( CAddQNMenuDlg )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)		        
		COMMAND_HANDLER(IDC_COMMAND, EN_CHANGE, OnCommandChange)
        COMMAND_HANDLER(IDC_STARTIN, EN_CHANGE, OnStartDirChange)
        COMMAND_HANDLER(IDC_NAME, EN_CHANGE, OnNameChange)                
		COMMAND_HANDLER(IDC_COMMAND_BROWSE, BN_CLICKED, OnBrowseForCommand)        
		COMMAND_HANDLER(IDC_STARTIN_BROWSE, BN_CLICKED, OnBrowseForStartIn)        
		
        COMMAND_RANGE_HANDLER(IDOK, IDCANCEL, OnClose)
    END_MSG_MAP()

    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );    
    LRESULT OnClose( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    LRESULT OnBrowseForCommand( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnBrowseForStartIn( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    
    LRESULT OnNameChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnCommandChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnStartDirChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );    

private:
    void SetMenuType(MENUTYPE type);    
    void LoadMenuInfo(CMenuCmd* pMenuCmd);
    void EnableOKButton();

private:   
	CQueryEditObj&  m_EditObject;
    CMenuCmd*       m_pMenuCmd;
    MENUTYPE        m_menutype;        
    bool            m_bCommandChg;
    bool            m_bStartDirChg;
    bool            m_bUserModifiedName;
};

class CMoveQueryDlg : public CDialogImpl<CMoveQueryDlg>
{
public:
    typedef CDialogImpl<CMoveQueryDlg> BC;

    CMoveQueryDlg() : m_pnodeCurFolder(NULL), m_ppnodeDestFolder(NULL) {};


    enum { IDD = IDD_MOVEQUERY };
    BEGIN_MSG_MAP( CMoveQueryDlg )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_RANGE_HANDLER(IDOK, IDCANCEL, OnClose)
    END_MSG_MAP()

    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnClose( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    int DoModal(CScopeNode* pnodeCurFolder, CScopeNode** ppnodeDestFolder)
    {
        m_pnodeCurFolder = pnodeCurFolder;
        m_ppnodeDestFolder = ppnodeDestFolder;
        return BC::DoModal();
    }

private:
    CScopeNode*  m_pnodeCurFolder;
    CScopeNode** m_ppnodeDestFolder;
};

//
// Function objects that convert between parameter LDAP and display names
//
class CLookupDisplayName : public CParamLookup
{
public:
    CLookupDisplayName(string_vector& vstrParam, DisplayNameMap* pNameMap) 
        : m_vstrParam(vstrParam), m_pNameMap(pNameMap) {}

    virtual BOOL operator() (tstring& strParam, tstring& strValue);

    string_vector&  m_vstrParam;
    DisplayNameMap* m_pNameMap;
};

class CLookupLDAPName : public CParamLookup
{
public:
    CLookupLDAPName(string_vector& vstrParam, DisplayNameMap* pNameMap) 
        : m_vstrParam(vstrParam), m_pNameMap(pNameMap) {}

    virtual BOOL operator() (tstring& strParam, tstring& strValue);

    string_vector&  m_vstrParam;
    DisplayNameMap* m_pNameMap;
};


#endif // _CMNDLGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\compont.h ===
// Compont.h : Declaration of the CComponent

#ifndef __COMPONENT_H_
#define __COMPONENT_H_

#include "resource.h"       // main symbols

class CScopeNode;
class CComponentData;

/////////////////////////////////////////////////////////////////////////////
// CComponent
class ATL_NO_VTABLE CComponent : 
    public CComObjectRootEx<CComSingleThreadModel>,
//  public CComCoClass<CComponent, &CLSID_Component>,
    public IComponent,
    public IExtendContextMenu,
    public IExtendControlbar,
    public IResultOwnerData,
    public IExtendPropertySheet2
{
public:
    CComponent() : m_pCompData(NULL)
    {
    }

DECLARE_NOT_AGGREGATABLE(CComponent)

BEGIN_COM_MAP(CComponent)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IResultOwnerData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet2)
END_COM_MAP()


public:
    // IComponent
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

    // IExtendContextMenu
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallback, long* plAllowed);
    STDMETHOD(Command)(long lCommand, LPDATAOBJECT pDataObject);

    // IExtendPropertySheet2 methods
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,LONG_PTR handle, LPDATAOBJECT lpIDataObject);
    STDMETHOD(GetWatermarks)(LPDATAOBJECT lpIDataObject, HBITMAP* lphWatermark, 
                             HBITMAP* lphHeader, HPALETTE* lphPalette, BOOL* bStretch);

    // IExtendControlbar
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

    // IResultOwnerData
    STDMETHOD(FindItem)(LPRESULTFINDINFO pFindInfo, int* pnFoundIndex) { return E_NOTIMPL; }
    STDMETHOD(CacheHint)(int nStartIndex, int nEndIndex) { return E_NOTIMPL; }
    STDMETHOD(SortItems)(int nColumn, DWORD dwSortOptions, LPARAM lUserParam);

public:
    void SetComponentData(CComponentData* pCompData)
    {
        ASSERT(pCompData != NULL);
        m_pCompData = pCompData;
    }

    void ClearRowItems();
    void AddRowItems(RowItemVector& vRowItems);
    IHeaderCtrl* GetHeaderCtrl() { return m_spHeaderCtrl; }
    IConsole2*   GetConsole() { return m_spConsole; }
    IToolbar*    GetToolbar() { return m_spToolbar; }

private:
    IConsole2Ptr      m_spConsole;
    IResultDataPtr    m_spResultData;
    IHeaderCtrlPtr    m_spHeaderCtrl;
    IControlbarPtr    m_spControlbar;
    IToolbarPtr       m_spToolbar;
    CComponentData*   m_pCompData;
    RowItemVector     m_vRowItems;
    CComPtr<CScopeNode> m_spCurScopeNode;

};

#endif //__COMPONENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\comptrs.h ===
#ifndef _COMPTRS_H_
#define _COMPTRS_H_

#include <comdef.h>

_COM_SMARTPTR_TYPEDEF(IUnknown,          __uuidof(IUnknown));
_COM_SMARTPTR_TYPEDEF(IComponentData,    __uuidof(IComponentData));
_COM_SMARTPTR_TYPEDEF(IComponent,        __uuidof(IComponent));
_COM_SMARTPTR_TYPEDEF(IConsole,          __uuidof(IConsole));
_COM_SMARTPTR_TYPEDEF(IConsole2,         __uuidof(IConsole2));
_COM_SMARTPTR_TYPEDEF(IConsoleNameSpace, __uuidof(IConsoleNameSpace));
_COM_SMARTPTR_TYPEDEF(IHeaderCtrl,       __uuidof(IHeaderCtrl));
_COM_SMARTPTR_TYPEDEF(IResultData,       __uuidof(IResultData));
_COM_SMARTPTR_TYPEDEF(IControlbar,       __uuidof(IControlbar));
_COM_SMARTPTR_TYPEDEF(IToolbar,          __uuidof(IToolbar));
_COM_SMARTPTR_TYPEDEF(IImageList,        __uuidof(IImageList));
_COM_SMARTPTR_TYPEDEF(IBOMObject,        __uuidof(IBOMObject));
_COM_SMARTPTR_TYPEDEF(IStringTable,      __uuidof(IStringTable));
_COM_SMARTPTR_TYPEDEF(IPropertySheetProvider, __uuidof(IPropertySheetProvider));


#endif //_COMPTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\dataobj.cpp ===
// DataObj.cpp : Implementation of CBOMSnapApp and DLL registration.

#include "stdafx.h"

#include "BOMSnap.h"
#include "DataObj.h"


/////////////////////////////////////////////////////////////////////////////
//

HRESULT CDataObjectImpl::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
{
    if( !lpFormatetcIn || !lpMedium ) return E_POINTER;

    if (lpFormatetcIn->dwAspect != DVASPECT_CONTENT ||
        (lpFormatetcIn->tymed & TYMED_HGLOBAL) == 0)
        return DV_E_FORMATETC;

    HGLOBAL hGlobal = NULL;

    HRESULT hr = GetDataImpl(lpFormatetcIn->cfFormat, &hGlobal);
    RETURN_ON_FAILURE(hr);

    ASSERT(hGlobal != NULL);

    lpMedium->tymed          = TYMED_HGLOBAL;
    lpMedium->hGlobal        = hGlobal;
    lpMedium->pUnkForRelease = NULL;

    return S_OK;    
}


HRESULT CDataObjectImpl::GetDataHere(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
{
    if( !lpFormatetcIn || !lpMedium ) return E_POINTER;

    if (lpFormatetcIn->dwAspect != DVASPECT_CONTENT || (lpFormatetcIn->tymed != TYMED_HGLOBAL))
    {
        return DV_E_FORMATETC;
    }

    if (lpMedium->tymed != TYMED_HGLOBAL || lpMedium->hGlobal == NULL )
    {
        return E_INVALIDARG;
    }
    
    return GetDataImpl(lpFormatetcIn->cfFormat, &lpMedium->hGlobal);
}

HRESULT CDataObjectImpl::DataToGlobal(HGLOBAL* phGlobal, const void* pData, DWORD dwSize)
{
    if( !phGlobal || !pData ) return E_POINTER;

    HRESULT hr = S_OK;

    HGLOBAL hGlobal = *phGlobal;
    if (hGlobal)
    {
        if (GlobalSize(hGlobal) < dwSize)
        {
            hr = STG_E_MEDIUMFULL;
        }
    }
    else
    {
        hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, dwSize);
        if (hGlobal != NULL)
        {
            *phGlobal = hGlobal;
        }
        else
        {
            hr = STG_E_MEDIUMFULL;
        }
    }

    if (SUCCEEDED(hr))
    {
        void* pMem = GlobalLock(hGlobal);
        if( !pMem ) return E_OUTOFMEMORY;

        memcpy(pMem, pData, dwSize);

        GlobalUnlock(hGlobal);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\dataobj.h ===
// DataObj.h: Definition of the CDataObjectImpl class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATAOBJ_H__F9BF06C6_30DF_11D3_9B2F_00C04FA37E1F__INCLUDED_)
#define AFX_DATAOBJ_H__F9BF06C6_30DF_11D3_9B2F_00C04FA37E1F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CDataObjectImpl

class CDataObjectImpl : public IBOMObject    
{

public:
    // IDataObject

    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);

    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };

    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

protected:
    HRESULT DataToGlobal(HGLOBAL* phGlobal, const void* pData, DWORD dwSize);

    // Implemented by derived class
 	STDMETHOD(GetDataImpl)(UINT cf, HGLOBAL* phGlobal) = 0;
};

#endif // !defined(AFX_DATAOBJ_H__F9BF06C6_30DF_11D3_9B2F_00C04FA37E1F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\grpprop.cpp ===
// qryprop.cpp -  Group Property Page Implementation

#include "stdafx.h"
#include "resource.h"
#include "grpprop.h"
#include "scopenode.h"
#include "query.h"
#include "cmndlgs.h"
#include "util.h"
#include "namemap.h"

#include <windowsx.h>
#include <algorithm>

///////////////////////////////////////////////////////////////////////////////////////////
// CGroupGeneralPage

LRESULT CGroupGeneralPage::OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    CGroupNode* pGrpNode = m_EditObject.m_spGroupNode;
    ASSERT(pGrpNode != NULL);

    HICON hIcon = ::LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_GROUPNODE));
    Static_SetIcon(GetDlgItem(IDC_GROUPICON), hIcon);

    // Get word for "None"
    WCHAR szNone[32];
    int nLen = ::LoadString(_Module.GetResourceInstance(), IDS_NONE, szNone, lengthof(szNone));
    ASSERT(nLen != 0);

    SetDlgItemText( IDC_NAME,   pGrpNode->GetName() );
    SetDlgItemText( IDC_FILTER, pGrpNode->Filter()  );

    m_strScope = pGrpNode->Scope();
    if (!m_strScope.empty()) 
    {
        tstring strDisplay;
        GetScopeDisplayString(m_strScope, strDisplay);

        SetDlgItemText( IDC_SCOPE, strDisplay.c_str() );
    }
        
    Button_SetCheck(GetDlgItem(IDC_APPLYSCOPE),  pGrpNode->ApplyScope() ? BST_CHECKED : BST_UNCHECKED);
    if (!pGrpNode->ApplyScope()) 
    {
        EnableDlgItem( m_hWnd, IDC_SCOPE_LBL,    FALSE );
        EnableDlgItem( m_hWnd, IDC_SCOPE,        FALSE );
        EnableDlgItem( m_hWnd, IDC_SCOPE_BROWSE, FALSE );
    }

    Button_SetCheck(GetDlgItem(IDC_APPLYFILTER), pGrpNode->ApplyFilter() ? BST_CHECKED : BST_UNCHECKED);
    if (!pGrpNode->ApplyFilter()) 
    {
        EnableDlgItem( m_hWnd, IDC_FILTER_LBL, FALSE );
        EnableDlgItem( m_hWnd, IDC_FILTER,     FALSE );
    }

    return TRUE;
}


LRESULT CGroupGeneralPage::OnApplyScopeClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL bEnable = Button_GetCheck(GetDlgItem(IDC_APPLYSCOPE)) == BST_CHECKED;

    EnableDlgItem( m_hWnd, IDC_SCOPE_LBL,    bEnable );
    EnableDlgItem( m_hWnd, IDC_SCOPE,        bEnable );
    EnableDlgItem( m_hWnd, IDC_SCOPE_BROWSE, bEnable );

    UpdateButtons();

    return 0;
}


LRESULT CGroupGeneralPage::OnApplyFilterClicked(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL bEnable = Button_GetCheck(GetDlgItem(IDC_APPLYFILTER)) == BST_CHECKED;

    EnableDlgItem( m_hWnd, IDC_FILTER_LBL, bEnable );
    EnableDlgItem( m_hWnd, IDC_FILTER,     bEnable );

    UpdateButtons();

    return 0;
}


LRESULT CGroupGeneralPage::OnFilterChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    UpdateButtons();

    return 0;
}


void CGroupGeneralPage::UpdateButtons()
{
    // Disable OK and Apply buttons if option selected but no value provided
    BOOL bEnable = !(Button_GetCheck(GetDlgItem(IDC_APPLYSCOPE)) == BST_CHECKED &&
                      ::Edit_GetTextLength(GetDlgItem(IDC_SCOPE)) == 0)  &&
                   !(Button_GetCheck(GetDlgItem(IDC_APPLYFILTER)) == BST_CHECKED && 
                      ::Edit_GetTextLength(GetDlgItem(IDC_FILTER)) == 0);
        
    // Note: calling SetModified(FALSE) disables Apply only because there are no other property pages
    SetModified(bEnable);

    // Directly enable/disable parent's OK button
    EnableDlgItem( ::GetParent(m_hWnd), IDOK, bEnable );
}


LRESULT CGroupGeneralPage::OnScopeBrowse(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = GetQueryScope(m_hWnd, m_strScope);

    if (hr == S_OK) 
    {
        tstring strDisplay;
        GetScopeDisplayString(m_strScope, strDisplay);

        SetDlgItemText( IDC_SCOPE, strDisplay.c_str() );

        UpdateButtons();
    }

    return 0;
}


BOOL CGroupGeneralPage::OnSetActive()
{
    m_EditObject.PageActive(m_hWnd);
    return TRUE;
}


BOOL CGroupGeneralPage::OnApply()
{
    CGroupNode* pGrpNode = m_EditObject.m_spGroupNode;
    ASSERT(pGrpNode != NULL);

    // Store Filter Value
    tstring strFilter;
    GetItemText( GetDlgItem(IDC_FILTER), strFilter );
    pGrpNode->SetFilter(strFilter.c_str());

    // Store scope
    pGrpNode->SetScope(m_strScope.c_str());

    // Store "apply" states
    pGrpNode->SetApplyScope(Button_GetCheck(GetDlgItem(IDC_APPLYSCOPE)) == BST_CHECKED);   
    pGrpNode->SetApplyFilter(Button_GetCheck(GetDlgItem(IDC_APPLYFILTER)) == BST_CHECKED);

    return m_EditObject.ApplyChanges(m_hWnd);
}




/////////////////////////////////////////////////////////////////////////////////////////////////
//

void CGroupEditObj::PageActive(HWND hwndPage)
{
    ASSERT(::IsWindow(hwndPage));

    // track the highest created page number for ApplyChanges method
    int iPage = PropSheet_HwndToIndex(GetParent(hwndPage), hwndPage);
    if (iPage > m_iPageMax)
        m_iPageMax = iPage;
}


BOOL CGroupEditObj::ApplyChanges(HWND hwndPage)
{
    ASSERT(::IsWindow(hwndPage));

    // Don't apply changes until called from highest activated page
    if (PropSheet_HwndToIndex(GetParent(hwndPage), hwndPage) < m_iPageMax)
        return TRUE;

    if( m_spGroupNode )
    {
        CRootNode* pRootNode = m_spGroupNode->GetRootNode();
        if( pRootNode )
        {
            pRootNode->UpdateModifyTime();
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\grpprop.h ===
// grpprop.h  - Group node property pages header file

#ifndef _GRPPROP_H_
#define _GRPPROP_H_

#include "scopenode.h"
#include "atlwin.h"
#include "atldlgs.h"
#include "atlctrls.h"

#include <list>

class CGroupEditObj
{
public:
    CGroupEditObj(CGroupNode* pGroupNode) : m_spGroupNode(pGroupNode), m_iPageMax(-1), m_cRef(0)
    {
        ASSERT(pGroupNode != NULL);
    }

    void  PageActive(HWND hwndPage);  
    BOOL  ApplyChanges(HWND hwndPage);

    ULONG AddRef() { return ++m_cRef; }
    ULONG Release() 
    {
        ASSERT(m_cRef > 0);

        if (--m_cRef != 0) 
            return m_cRef; 
       
        delete this; 
        return 0;
    }

public:
    CComPtr<CGroupNode> m_spGroupNode;

private:
    int     m_iPageMax;
    ULONG   m_cRef;
};


class CGroupGeneralPage : public CPropertyPageImpl<CGroupGeneralPage>
{

public:
    typedef CPropertyPageImpl<CGroupGeneralPage> BC;

    // Constructor/destructor
    CGroupGeneralPage(CGroupEditObj* pEditObj) : m_EditObject(*pEditObj)
    {
        ASSERT(pEditObj != NULL);
        m_EditObject.AddRef();
    }

    ~CGroupGeneralPage()
    {
        m_EditObject.Release();
    }

    enum { IDD = IDD_GROUP_GENERAL_PAGE };

protected:
    BEGIN_MSG_MAP( CGroupGeneralPage )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_HANDLER(IDC_FILTER, EN_CHANGE, OnFilterChange)
        COMMAND_HANDLER(IDC_APPLYSCOPE, BN_CLICKED, OnApplyScopeClicked)
        COMMAND_HANDLER(IDC_APPLYFILTER, BN_CLICKED, OnApplyFilterClicked)
        COMMAND_HANDLER(IDC_SCOPE_BROWSE, BN_CLICKED, OnScopeBrowse)
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // message handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnFilterChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnApplyScopeClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnApplyFilterClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnClassSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnScopeBrowse( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    void UpdateButtons();

    // overrrides
    BOOL OnSetActive();
    BOOL OnApply();

private:
    tstring        m_strScope;
    CGroupEditObj& m_EditObject;
};


#endif // _GRPPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\notifmap.h ===
#ifndef _NOTIFMAP_H_
#define _NOTIFMAP_H_

//
// Notify map macros
//
#define DECLARE_NOTIFY_MAP() \
    STDMETHOD(Notify)(LPCONSOLE2 pCons, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

#define BEGIN_NOTIFY_MAP(class) \
    HRESULT class::Notify(LPCONSOLE2 pCons, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param) { \
        switch (event) {

#define CHAIN_NOTIFY_MAP(baseClass) \
        default: return baseClass::Notify(pCons, event, arg, param);

#define END_NOTIFY_MAP() \
        } return S_FALSE; }
    
//
// Notify map entries
//
#define ON_NOTIFY(type, func) \
    case type: return func(pCons, arg, param);

#define ON_SELECT() \
    case MMCN_SELECT: return OnSelect(pCons, HIWORD(arg), LOWORD(arg));

#define ON_RENAME() \
    case MMCN_RENAME: return OnRename(pCons, (LPCWSTR)param);

#define ON_REMOVE_CHILDREN() \
    case MMCN_REMOVE_CHILDREN: return OnRemoveChildren(pCons);

#define ON_EXPAND() \
    case MMCN_EXPAND: return OnExpand(pCons, (BOOL)arg, (HSCOPEITEM)param);

#define ON_ADD_IMAGES() \
    case MMCN_ADD_IMAGES: return OnAddImages(pCons, (LPIMAGELIST)arg);

#define ON_SHOW() \
    case MMCN_SHOW: return OnShow(pCons, (BOOL)arg, (HSCOPEITEM)param);

#define ON_REFRESH() \
    case MMCN_REFRESH: return OnRefresh(pCons);

#define ON_DELETE() \
    case MMCN_DELETE: return OnDelete(pCons);

#define ON_DBLCLICK() \
    case MMCN_DBLCLICK: return OnDblClick(pCons);

#define ON_PROPERTY_CHANGE() \
    case MMCN_PROPERTY_CHANGE: return OnPropertyChange(pCons, param);

#endif // _NOTIFMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\namemap.cpp ===
#include "stdafx.h"
#include "namemap.h"
#include "query.h"
#include "assert.h"

#include <iostream>
using std::wcout;
using std::endl;

DisplayNameMapMap DisplayNames::m_mapMap;
DisplayNameMap* DisplayNames::m_pmapClass = NULL;
LCID DisplayNames::m_locale = GetSystemDefaultLCID();

///////////////////////////////////////////////
DisplayNameMapMap::~DisplayNameMapMap()
{
    for (DisplayNameMapMap::iterator it = begin(); it != end(); it++)
        delete (*it).second;    
}

///////////////////////////////////////////////////////////////////////
//
// class DisplayNames
//
///////////////////////////////////////////////
DisplayNameMap* DisplayNames::GetMap(LPCWSTR name)
{
	DisplayNameMapMap::iterator it;

    if ((it = m_mapMap.find(name)) != m_mapMap.end())
    {
        (*it).second->AddRef();
        return (*it).second;
    }
    else 
    {
        DisplayNameMap* nameMap = new DisplayNameMap();
        if( !nameMap) return NULL;

        m_mapMap.insert(DisplayNameMapMap::value_type(name, nameMap));
    
        nameMap->AddRef();

        nameMap->InitializeMap(name);

        return nameMap;
    }
}

DisplayNameMap* DisplayNames::GetClassMap()
{
	if( !m_pmapClass )
	{
        m_pmapClass = new DisplayNameMap();
        if( !m_pmapClass ) return NULL;
        
        m_pmapClass->InitializeClassMap();
    }

	return m_pmapClass;
}


///////////////////////////////////////////////
DisplayNameMap::DisplayNameMap()
{
    m_nRefCount = 0;
}

void DisplayNameMap::InitializeMap(LPCWSTR name)
{
    if( !name ) return;

    // Check schema for naming attribute
    do
    {
        // Special case for printer queue 
        // (display descr maps "Name" to printerName, but schema reports cn)
        if (wcscmp(name, L"printQueue") == 0) 
        {
            m_strNameAttr = L"printerName";
            break;
        }

        tstring strScope = L"LDAP://schema/";
        strScope += name;
    
        CComPtr<IADsClass> pObj;
        HRESULT hr = ADsGetObject((LPWSTR)strScope.c_str(), IID_IADsClass, (void**)&pObj);
        BREAK_ON_FAILURE(hr)
     
        CComVariant var;
        hr = pObj->get_NamingProperties(&var);
        BREAK_ON_FAILURE(hr);
    
        if (var.vt == VT_BSTR)
            m_strNameAttr = var.bstrVal;
    } while (FALSE);

    // if no display name specified, default to "cn"
    if (m_strNameAttr.empty())
        m_strNameAttr = L"cn";

    CComPtr<IADs> spDispSpecCont;
    CComBSTR      bstrProp;
    CComVariant   svar; 

    // Open Display specifier for this object
    LPCWSTR pszConfigDN;
    EXIT_ON_FAILURE(GetNamingContext(NAMECTX_CONFIG, &pszConfigDN));

    //Build the string to bind to the DisplaySpecifiers container.
    WCHAR szPath[MAX_PATH];
    _snwprintf(szPath, MAX_PATH-1, L"LDAP://cn=%s-Display,cn=%x,cn=DisplaySpecifiers,%s", name, DisplayNames::GetLocale(), pszConfigDN);

    //Bind to the DisplaySpecifiers container.
    EXIT_ON_FAILURE(ADsOpenObject(szPath,
                 NULL,
                 NULL,
                 ADS_SECURE_AUTHENTICATION, //Use Secure Authentication
                 IID_IADs,
                 (void**)&spDispSpecCont)); 

    bstrProp = _T("attributeDisplayNames");
    EXIT_ON_FAILURE(spDispSpecCont->Get( bstrProp, &svar ));

#ifdef MAP_DEBUG_PRINT
       WCHAR szBuf[128];
       _snwprintf(szBuf, (128)-1, L"\n DisplayNameMap for %s\n", name);
       OutputDebugString(szBuf);
#endif

    tstring strIntName;
    tstring strFriendlyName;

    if ((svar.vt & VT_ARRAY) == VT_ARRAY)
    {
        CComVariant svarItem;
        SAFEARRAY *sa = V_ARRAY(&svar);
        LONG lStart, lEnd;

        // Get the lower and upper bound
        EXIT_ON_FAILURE(SafeArrayGetLBound(sa, 1, &lStart));
        EXIT_ON_FAILURE(SafeArrayGetUBound(sa, 1, &lEnd));

        for (long idx=lStart; idx <= lEnd; idx++)
        {
            CONTINUE_ON_FAILURE(SafeArrayGetElement(sa, &idx, &svarItem));

            if( svarItem.vt != VT_BSTR ) return;
            
            strIntName.erase();
            strIntName = wcstok(svarItem.bstrVal, L",");

            if (strIntName != m_strNameAttr) 
            {
                strFriendlyName.erase();
                strFriendlyName = wcstok(NULL, L",");           
                m_map.insert(STRINGMAP::value_type(strIntName, strFriendlyName));
            }

#ifdef MAP_DEBUG_PRINT
                _snwprintf( szBuf, (128)-1, L"  %-20s %s\n", strIntName.c_str(), strFriendlyName.c_str() );
                OutputDebugString(szBuf);
#endif
            svarItem.Clear();
        }
    }
    else
    {
        if( svar.vt != VT_BSTR ) return;

        strIntName = wcstok(svar.bstrVal, L",");

        if (strIntName != m_strNameAttr) 
        {
            strFriendlyName = wcstok(NULL, L",");
            m_map.insert(STRINGMAP::value_type(strIntName, strFriendlyName));
        }
    }

    svar.Clear();

    bstrProp = _T("classDisplayName");
    EXIT_ON_FAILURE(spDispSpecCont->Get( bstrProp, &svar ));
    
    m_strFriendlyClassName = svar.bstrVal;
}

void DisplayNameMap::InitializeClassMap()
{
    CComPtr<IDirectorySearch> spDirSrch;
    CComVariant svar;
    tstring strIntName;
    tstring strFriendlyName;

    m_strFriendlyClassName = L"";
    
    LPCWSTR pszConfigContext;
    EXIT_ON_FAILURE(GetNamingContext(NAMECTX_CONFIG, &pszConfigContext));

	HRESULT hr;

	do
	{
		//Build the string to bind to the DisplaySpecifiers container.
		WCHAR szPath[MAX_PATH];
		_snwprintf( szPath, MAX_PATH-1, L"LDAP://cn=%x,cn=DisplaySpecifiers,%s", DisplayNames::GetLocale(), pszConfigContext );

		//Bind to the DisplaySpecifiers container.
		hr = ADsOpenObject(szPath,
					 NULL,
					 NULL,
					 ADS_SECURE_AUTHENTICATION, //Use Secure Authentication
					 IID_IDirectorySearch,
					 (void**)&spDirSrch);

		// if no display specifiers found, change locale to English (if not already English) and try again
	   if (FAILED(hr) && DisplayNames::GetLocale() != MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
		   DisplayNames::SetLocale(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US));
	   else
	      break;

	} while (TRUE);
 
	EXIT_ON_FAILURE(hr);

    // Set search preferences
    ADS_SEARCHPREF_INFO prefInfo[3];

    prefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;     // sub-tree search
    prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[0].vValue.Integer = ADS_SCOPE_ONELEVEL;

    prefInfo[1].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;     // async
    prefInfo[1].vValue.dwType = ADSTYPE_BOOLEAN;
    prefInfo[1].vValue.Boolean = TRUE;

    prefInfo[2].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;         // paged results
    prefInfo[2].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[2].vValue.Integer = 64;

    EXIT_ON_FAILURE(spDirSrch->SetSearchPreference(prefInfo, 3));

    static LPWSTR pAttr[] = {L"name", L"classDisplayName", L"iconPath"};
    static LPWSTR pFilter = L"(&(objectCategory=displaySpecifier)(attributeDisplayNames=*))"; 
	// Initiate search
 
    ADS_SEARCH_HANDLE hSearch = NULL;
    EXIT_ON_FAILURE(spDirSrch->ExecuteSearch(pFilter, pAttr, lengthof(pAttr), &hSearch));

    // Get Results
    while (spDirSrch->GetNextRow(hSearch) == S_OK)
    {
       ADS_SEARCH_COLUMN col;

       CONTINUE_ON_FAILURE(spDirSrch->GetColumn(hSearch, const_cast<LPWSTR>(pAttr[0]), &col));

       strIntName.erase();
       strIntName = wcstok(col.pADsValues->PrintableString, L"-");
       spDirSrch->FreeColumn(&col);

       CONTINUE_ON_FAILURE(spDirSrch->GetColumn(hSearch, const_cast<LPWSTR>(pAttr[1]), &col));
    
       strFriendlyName.erase();
       strFriendlyName = col.pADsValues->PrintableString;
       spDirSrch->FreeColumn(&col);
       
	   m_map.insert(STRINGMAP::value_type(strIntName, strFriendlyName));

	   //add icon string to map
	   ICONHOLDER IH;

	   //if iconPath exists in the AD, copy the value to the ICONHOLDER structure
	   if(SUCCEEDED(spDirSrch->GetColumn(hSearch, const_cast<LPWSTR>(pAttr[2]), &col))) {
		IH.strPath = col.pADsValues->PrintableString;
		spDirSrch->FreeColumn(&col);
	   }

	   //add the ICONHOLDER structure to the map (empty string for default types) 
	   m_msIcons.insert(std::pair<tstring, ICONHOLDER>(strFriendlyName, IH));

    }

    spDirSrch->CloseSearchHandle(hSearch);
}

LPCWSTR DisplayNameMap::GetAttributeDisplayName(LPCWSTR pszname)
{
    if( !pszname ) return L"";

    STRINGMAP::iterator it;

    if ((it = m_map.find(pszname)) != m_map.end())
        return (*it).second.c_str();
    else
        return pszname;
}

LPCWSTR DisplayNameMap::GetInternalName(LPCWSTR pszDisplayName)
{    
    if( !pszDisplayName ) return L"";

    STRINGMAP::iterator it;
    for (it = m_map.begin(); it != m_map.end(); it++)
    {
        if ((*it).second == pszDisplayName)
            return (*it).first.c_str();
    }

    return pszDisplayName;
}

LPCWSTR DisplayNameMap::GetFriendlyName(LPCWSTR pszDisplayName)
{
    if( !pszDisplayName ) return L"";

	STRINGMAP::iterator it;
    if((it = m_map.find(pszDisplayName)) != m_map.end())
		return it->second.c_str();

    return pszDisplayName;
}

void DisplayNameMap::GetFriendlyNames(string_vector* vec)
{
    if( !vec ) return;

    STRINGMAP::iterator it;

    for (it = m_map.begin(); it != m_map.end(); it++)
    {
        vec->push_back((*it).first);
    }
}


// retreives a handle to the icon for the provided class
// params: pszClassName - class name
// returns: boolean success
bool DisplayNameMap::GetIcons(LPCWSTR pszClassName, ICONHOLDER** pReturnIH)
{
    if( !pszClassName || !pReturnIH ) return FALSE;

	static UINT iFreeIconIndex = RESULT_ITEM_IMAGE + 1; //next free virtual index
	static ICONHOLDER DefaultIH; //upon construction, this item holds default values
	
	*pReturnIH = &DefaultIH; //In the case of errors, returned icon will hold default icon
	
	std::map<tstring, ICONHOLDER>::iterator iconIter;
	ICONHOLDER *pIH; //pointer to the ICONHOLDER

	//CASE: Requested class not found in list returned by Active Directory
	if((iconIter = m_msIcons.find(pszClassName)) == m_msIcons.end()) {
		return false;
	}
	
	pIH = &(iconIter->second); //convenience variable to ICONHOLDER

	//CASE: Requsted icons already loaded
	if(pIH->bAttempted == true) {
		*pReturnIH = pIH;
		return true;
	}
	
	//CASE: An attempt to load the icon has not yet been made
	while(pIH->bAttempted == false)
	{
		//making first attempt
		pIH->bAttempted = true;

		//try to load the icon using the IDsDisplaySpecifier interface first
		IDsDisplaySpecifier *pDS;
		HRESULT hr = CoCreateInstance(CLSID_DsDisplaySpecifier,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IDsDisplaySpecifier,
                           (void**)&pDS);
        if( FAILED(hr) ) return false;

		//load all icon sizes and states
		tstring strIntClassName = GetInternalName(pszClassName);
		pIH->hSmall = pDS->GetIcon(strIntClassName.c_str(), DSGIF_ISNORMAL, 16, 16);
		pIH->hLarge = pDS->GetIcon(strIntClassName.c_str(), DSGIF_ISNORMAL, 32, 32);
		pIH->hSmallDis = pDS->GetIcon(strIntClassName.c_str(), DSGIF_ISDISABLED, 16, 16);
		pIH->hLargeDis = pDS->GetIcon(strIntClassName.c_str(), DSGIF_ISDISABLED, 32, 32);

		pDS->Release();

		//CASE: Icon loaded from AD
		if(pIH->hSmall) break;

		//CASE: No file specified
		if(pIH->strPath.empty()) break;

		//tokenize the iconPath variable
		tstring strState = wcstok(const_cast<wchar_t*>(pIH->strPath.c_str()), L",");
		tstring strFile  = wcstok(NULL, L",");
		tstring strIndex = wcstok(NULL, L",");

		int iIndex; //integer value of index
		
		//CASE: file is environment variable
		if(strFile.at(0) == L'%' && strFile.at(strFile.length()-1) == L'%') 
        {			
			//chop off '%' indicators
			strFile = strFile.substr(1, strFile.length()-2);
			
            int nSize = 512;
			WCHAR* pwszBuffer = new WCHAR[nSize];
            if( !pwszBuffer ) break;

            DWORD dwSize = GetEnvironmentVariable( strFile.c_str(), pwszBuffer, nSize );
            if( dwSize == 0 ) break;
            if( dwSize >= nSize )
            {
                delete [] pwszBuffer;

                nSize = dwSize;
                pwszBuffer = new WCHAR[nSize];
                if( !pwszBuffer ) break;

                dwSize = GetEnvironmentVariable( strFile.c_str(), pwszBuffer, nSize );
                if( dwSize == 0 || dwSize >= nSize ) break;
            }			
			
            strFile = pwszBuffer;
		}		
		
		if(strIndex.empty()) 
        {
            //CASE: ICO file specified
			pIH->hSmall = (HICON)LoadImage(NULL, strFile.c_str(), IMAGE_ICON, 16, 16, LR_LOADFROMFILE);
			pIH->hLarge = (HICON)LoadImage(NULL, strFile.c_str(), IMAGE_ICON, 32, 32, LR_LOADFROMFILE);
		}		
		else 
        {
            //CASE: DLL file specified
			iIndex = _wtoi(strIndex.c_str());
			assert(iIndex <= 0); //in all known cases, the index is indicating an absolute reference
			HINSTANCE hLib = LoadLibraryEx(strFile.c_str(), NULL, LOAD_LIBRARY_AS_DATAFILE);
			if(hLib == NULL) break;
			pIH->hSmall = CopyIcon((HICON)LoadImage(hLib, MAKEINTRESOURCE(-iIndex), IMAGE_ICON, 16, 16, NULL));
			pIH->hLarge = CopyIcon((HICON)LoadImage(hLib, MAKEINTRESOURCE(-iIndex), IMAGE_ICON, 32, 32, NULL));
			FreeLibrary(hLib);
		}
	}

	//CASE: something failed. Fill with default values and return.
	if(pIH->hSmall == NULL)
	{
		pIH->hSmall = pIH->hSmallDis = NULL;
		pIH->hLarge = pIH->hLargeDis = NULL;
		pIH->iNormal = RESULT_ITEM_IMAGE;
		pIH->iDisabled = RESULT_ITEM_IMAGE;
	}
	//CASE: succeeded. Must assign permanent virtual index.
	else
	{
		pIH->iNormal = iFreeIconIndex++;
		pIH->iDisabled = pIH->hSmallDis ? iFreeIconIndex++ : pIH->iNormal;
	}

	*pReturnIH = pIH;
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\namemap.h ===
#ifndef _NAMEMAP_H_
#define _NAMEMAP_H_


#pragma warning( disable : 4786)  // long symbol names

#include <map>
#include <atlcom.h>
#include <iads.h>
#include <adshlp.h>
//used for icon functions
#include <objbase.h>
#define INITGUID
#include <initguid.h>
#include "shlobj.h"
#include "dsclient.h"
 

//glorified structure holds all neccessary information about icons
struct ICONHOLDER
{
	ICONHOLDER() : strPath(L""), hLarge(NULL), hSmall(NULL), hLargeDis(NULL), hSmallDis(NULL),
				    iNormal(RESULT_ITEM_IMAGE), iDisabled(RESULT_ITEM_IMAGE), bAttempted(false) {}

	tstring strPath;	//full iconPath value as returned by AD
	
	HICON	hLarge;		//handle to the large icon as returned by windows API/AD
	HICON   hSmall;		//handle to the small icon as returned by windows API/AD
	UINT	iNormal;    //virtual index to disabled icon passed to MMC

	HICON	hLargeDis;	//handle to the large disabled icon
	HICON   hSmallDis;  //handle to the small disabled icon
	UINT	iDisabled;	//virtual index to disabled icon passed to MMC
	
	bool	bAttempted; //indicates whether an attempt to load this icon has occurred
};

class DisplayNameMap;


// Derive class from std::map in order to add destructor code
class DisplayNameMapMap : public std::map<tstring, DisplayNameMap*>
{
public:
    ~DisplayNameMapMap();
};


typedef std::map<tstring, tstring> STRINGMAP;

class DisplayNameMap
{
public:
    DisplayNameMap();

    void InitializeMap(LPCWSTR name);
    void InitializeClassMap();

    // Note: AddRef and Release don't control lifetimes currently. All maps
    // are cached by the global PMAP until the DLL is unloaded.
    void AddRef()  { m_nRefCount++; }
    void Release() { m_nRefCount--; }

    LPCWSTR GetClassDisplayName() { return m_strFriendlyClassName.c_str(); }
    LPCWSTR GetNameAttribute()    { return m_strNameAttr.c_str(); }
    LPCWSTR GetAttributeDisplayName(LPCWSTR pszname);
    LPCWSTR GetInternalName(LPCWSTR pszDisplayName);
	LPCWSTR GetFriendlyName(LPCWSTR pszDisplayName);
    void    GetFriendlyNames(string_vector* vec);

	//icon functions
	bool	GetIcons(LPCWSTR pszClassName, ICONHOLDER** pReturnIH);

private:
    STRINGMAP m_map;
	std::map<tstring, ICONHOLDER> m_msIcons;
    tstring m_strNameAttr;
    tstring m_strFriendlyClassName;
    int m_nRefCount;
};

//////////////////////////////////////////////////////////////////////////
// class DisplayNames
//
// This class has all static member methods and variables. The functions
// give users access to the class map and the display name maps for the
// AD object classes. This class maintaines a map indexed by class name
// of all display attribute maps.
///////////////////////////////////////////////////////////////////////////
class DisplayNames
{
public:
    static DisplayNameMap* GetMap (LPCWSTR name);
    static DisplayNameMap* GetClassMap ();
	static LCID GetLocale() { return m_locale; }
	static void SetLocale(LCID lcid) { m_locale = lcid; }
        
private:
    static DisplayNameMapMap m_mapMap;
	static DisplayNameMap* m_pmapClass;
	static LCID m_locale;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\menucmd.h ===
// menucmd.h  - context menu commands header file

#ifndef _MENUCMD_H_
#define _MENUCMD_H_

#include <atlgdi.h>
#include "util.h"

class CQueryNode;
class CQueryItem;
class CRowItem;


// These parameter IDs must not change because they are persisted
// in the shell command line strings
enum MENU_PARAM_ID
{
    MENU_PARAM_SCOPE = 1,
    MENU_PARAM_FILTER,
    MENU_PARAM_NAME,
    MENU_PARAM_TYPE,
    MENU_PARAM_LAST = MENU_PARAM_TYPE
};

struct MENU_PARAM_ENTRY
{
    MENU_PARAM_ID   ID;         // Param identifier
    UINT            rsrcID;     // resource string ID
};

#define MENU_PARAM_TABLE_LEN 5
extern const MENU_PARAM_ENTRY MenuParamTable[MENU_PARAM_TABLE_LEN];


//------------------------------------------------------------------
// class CMenuCmd
//------------------------------------------------------------------

enum MENUTYPE
{
    MENUTYPE_SHELL = 0,
    MENUTYPE_ACTDIR
};

enum MENU_FLAGS
{
    MENUFLG_REFRESH = 0x00001
};

typedef MMC_STRING_ID MenuID;

class CMenuCmd
{
    friend class CAddMenuDlg;
	friend class CAddQNMenuDlg;
    friend class CMenuCmdPtr;

public:
    CMenuCmd(LPCWSTR pszMenuName = NULL) 
    {
        m_menuID = 0;
        m_dwFlags   = 0;
        HRESULT hr = CoCreateGuid( &m_guidNoLocMenu );
        ASSERT(SUCCEEDED(hr));

        if (pszMenuName != NULL) 
            m_strName = pszMenuName;
    }
    virtual ~CMenuCmd() {};

    virtual CMenuCmd* Clone() = 0;

    virtual MENUTYPE MenuType() const = 0; 
    virtual HRESULT Save(IStream& stm) = 0;
    virtual HRESULT Load(IStream& stm) = 0;

    LPCWSTR Name()    { return m_strName.c_str(); }
    MenuID  ID()      { return m_menuID; }
    GUID    NoLocID() { return m_guidNoLocMenu; }

    HRESULT LoadName(IStringTable* pStringTable) 
    {
        if (!m_strName.empty())
            return S_OK;

        return StringTableRead(pStringTable, m_menuID, m_strName); 
    }

    HRESULT SetName(IStringTable* pStringTable, LPCWSTR pszName)
    { 
        ASSERT(pszName && pszName[0]);

        HRESULT hr = StringTableWrite(pStringTable, pszName, &m_menuID);
        if (SUCCEEDED(hr))
            m_strName = pszName;

        return hr;
    }

    BOOL IsAutoRefresh() { return (m_dwFlags & MENUFLG_REFRESH); }
    void SetAutoRefresh(BOOL bState) 
        { m_dwFlags = bState ? (m_dwFlags | MENUFLG_REFRESH) : (m_dwFlags & ~MENUFLG_REFRESH); }

    BOOL operator==(MenuID ID) { return (m_menuID == ID); } 

protected:
    tstring m_strName;
    MenuID  m_menuID;
    GUID    m_guidNoLocMenu;
    DWORD   m_dwFlags;
};


class CShellMenuCmd : public CMenuCmd
{
    friend class CAddMenuDlg;
	friend class CAddQNMenuDlg;
	

public:
    // CMenuCmd
    CMenuCmd* Clone() { return new CShellMenuCmd(*this); }

    MENUTYPE MenuType() const { return MENUTYPE_SHELL; }

    LPCWSTR ProgramName() { return m_strProgPath.c_str(); }

    HRESULT Save(IStream& stm);
    HRESULT Load(IStream& stm);
    HRESULT Execute(CParamLookup* pLookup, PHANDLE phProcess);

private:
    tstring m_strProgPath;
    tstring m_strCmdLine;
    tstring m_strStartDir;
};


class CActDirMenuCmd : public CMenuCmd
{
    friend class CAddMenuDlg;

public:

    CMenuCmd* Clone() { return new CActDirMenuCmd(*this); }

    MENUTYPE MenuType() const { return MENUTYPE_ACTDIR; }

    HRESULT Save(IStream& stm);
    HRESULT Load(IStream& stm);

    LPCWSTR ADName() { return m_strADName.c_str(); }
    LPCWSTR ADNoLocName() { return m_strADNoLocName.c_str(); }    

private:    
    tstring m_strADName;
    tstring m_strADNoLocName;    
};


class CMenuCmdPtr
{
public:
    CMenuCmdPtr(CMenuCmd* pMenuCmd = NULL) : m_pMenuCmd(pMenuCmd) {}
    ~CMenuCmdPtr() { delete m_pMenuCmd; }
    
    // Copy constructor
    CMenuCmdPtr (const CMenuCmdPtr& src) { m_pMenuCmd = src.m_pMenuCmd ? src.m_pMenuCmd->Clone() : NULL; }

    // cast to normal pointer
    operator CMenuCmd* () { return m_pMenuCmd; }

    // "->" operator casts to pointer too
    const CMenuCmd* operator->() const { return m_pMenuCmd; }
    CMenuCmd* operator->() { return m_pMenuCmd; }

    // Comparison for search by ID
    BOOL operator==(MenuID ID) { return m_pMenuCmd ? (m_pMenuCmd->ID() == ID) : FALSE; }

    // Assignment from plain pointer does not deep copy
    CMenuCmdPtr& operator= (CMenuCmd* pMenuCmd)
    {
        delete m_pMenuCmd;
        m_pMenuCmd = pMenuCmd;

        return *this;
    }

    // Assignment from another CMenuCmdPtr does deep copy
    CMenuCmdPtr& operator= (const CMenuCmdPtr& src)
    {
        if (this == &src)
            return *this;

        delete m_pMenuCmd;
        m_pMenuCmd = src.m_pMenuCmd ? src.m_pMenuCmd->Clone() : NULL;

        return *this;
    }

private:
    CMenuCmd* m_pMenuCmd;
};

typedef std::vector<CMenuCmdPtr> menucmd_vector;

IStream& operator>> (IStream& stm, menucmd_vector& vMenus);
IStream& operator<< (IStream& stm, menucmd_vector& vMenus);

#endif _MENUCMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\menucmd.cpp ===
// menucmd.cpp  - Context menu command class 

#include "stdafx.h"
#include "menucmd.h"
#include "streamio.h"
#include "qryitem.h"
#include "resource.h"
#include <shellapi.h>
#include <algorithm>
#include <atlgdi.h>

extern DWORD g_dwFileVer; // Current console file version (from compdata.cpp)

// Table of standard menu command parameters
// Gives order for parameter menu and maps ID to resource string
// Zero entry indicates menu separator
const MENU_PARAM_ENTRY MenuParamTable[MENU_PARAM_TABLE_LEN] = 
{
    { MENU_PARAM_SCOPE,  IDS_QUERY_SCOPE  },
    { MENU_PARAM_FILTER, IDS_QUERY_FILTER },
    { MENU_PARAM_ID(0),  0                },
    { MENU_PARAM_NAME,   IDS_NAME         },
    { MENU_PARAM_TYPE,   IDS_TYPE         },
};

/////////////////////////////////////////////////////////////////////////////////////////
// CShellMenuCmd
HRESULT
CShellMenuCmd::Save(IStream& stm)
{
    stm << m_menuID;
    stm << m_dwFlags;
    stm << m_strProgPath;
    stm << m_strCmdLine;
    stm << m_strStartDir;
    stm << m_guidNoLocMenu;

    return S_OK;
}

HRESULT
CShellMenuCmd::Load(IStream& stm)
{
    stm >> m_menuID;

    if (g_dwFileVer >= 101)
        stm >> m_dwFlags;

    stm >> m_strProgPath;
    stm >> m_strCmdLine;
    stm >> m_strStartDir;
    
    if( g_dwFileVer >= 150 )
    {
        stm >> m_guidNoLocMenu;
    }

    return S_OK;
}


HRESULT
CShellMenuCmd::Execute(CParamLookup* pLookup, HANDLE* phProcess)
{
    ASSERT(pLookup != NULL && phProcess != NULL);

    *phProcess = NULL;

    // Substitue parameter values in the command line
    tstring strParam = m_strCmdLine;
    HRESULT hr = ReplaceParameters(strParam, *pLookup, FALSE);
    RETURN_ON_FAILURE(hr);

    // Expand any environment variables
    tstring strLocProgPath;
    hr = ExpandEnvironmentParams(m_strProgPath, strLocProgPath);
    RETURN_ON_FAILURE(hr);

    tstring strLocStartDir;
    hr = ExpandEnvironmentParams(m_strStartDir, strLocStartDir);
    RETURN_ON_FAILURE(hr);

    tstring strLocParam;
    ExpandEnvironmentParams(strParam, strLocParam);
    RETURN_ON_FAILURE(hr);

    // Execute the command
    SHELLEXECUTEINFO info;
    info.cbSize = sizeof(info);
    info.fMask = SEE_MASK_NOCLOSEPROCESS;
    info.hwnd = NULL;
    info.lpVerb = NULL;
    info.lpFile = strLocProgPath.c_str();
    info.lpParameters = strLocParam.c_str();
    info.lpDirectory = strLocStartDir.c_str();
    info.nShow = SW_SHOWNORMAL;
    info. hInstApp = 0;
    info.hProcess = 0;

    *phProcess = info.hProcess;

    BOOL bStat = ShellExecuteEx(&info); 
    if (!bStat)
        return E_FAIL;
        
    *phProcess = info.hProcess;
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////////////
// CActDirMenuCmd
HRESULT
CActDirMenuCmd::Save(IStream& stm)
{
    stm << m_menuID;
    stm << m_dwFlags;
    stm << m_strADName;
    stm << m_guidNoLocMenu;
    stm << m_strADNoLocName;    

    return S_OK;
}

HRESULT
CActDirMenuCmd::Load(IStream& stm)
{
    stm >> m_menuID;

    if (g_dwFileVer >= 101)
        stm >> m_dwFlags;

    stm >> m_strADName;
    
    if( g_dwFileVer >= 150 )
    {
        stm >> m_guidNoLocMenu;
        stm >> m_strADNoLocName;    
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// menu vector stream i/o

IStream& operator<< (IStream& stm, menucmd_vector& vMenus)
{
    stm << static_cast<long>(vMenus.size());

    menucmd_vector::iterator itMenu;
    for (itMenu = vMenus.begin(); itMenu != vMenus.end(); ++itMenu) 
    {
        stm << static_cast<int>((*itMenu)->MenuType());

        HRESULT hr = (*itMenu)->Save(stm);
        THROW_ON_FAILURE(hr);
    }

    return stm;
}


IStream& operator>> (IStream& stm, menucmd_vector& vMenus)
{
    long nItems;
    stm >> nItems;

    vMenus.reserve(nItems);
   
    for (long lItem = 0; lItem < nItems; ++lItem) 
    {
        CMenuCmd* pMenu = NULL;

        int iType;
        stm >> iType;
        MENUTYPE type = static_cast<MENUTYPE>(iType);

        switch (type)
        {
        case MENUTYPE_SHELL:
            pMenu = new CShellMenuCmd();
            ASSERT(pMenu != NULL);
            break;

        case MENUTYPE_ACTDIR:
            pMenu = new CActDirMenuCmd();
            ASSERT(pMenu != NULL);
            break;

        default:
            THROW_ON_FAILURE(E_FAIL);
        }

        if( pMenu )
        {
            HRESULT hr = pMenu->Load(stm);
            THROW_ON_FAILURE(hr);

            vMenus.push_back(CMenuCmdPtr(pMenu));
        }
    }

    return stm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\qryitem.h ===
// qryitem.h  -  header file for CQueryItem class

#ifndef _QRYITEM_H_
#define _QRYITEM_H_

#include "scopenode.h"
#include "rowitem.h"
#include "adext.h"

//------------------------------------------------------------------
// class CQueryItem
//------------------------------------------------------------------
class CQueryItem :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CDataObjectImpl
{

public:
    CQueryItem() : m_pRowItem(NULL), m_pADExt(NULL), m_spQueryNode(NULL) {}
    virtual ~CQueryItem()
    {
        SAFE_DELETE(m_pRowItem);
        SAFE_DELETE(m_pADExt);
    }

    HRESULT Initialize(CQueryableNode* pQueryNode, CRowItem* pRowItem);

    DECLARE_NOT_AGGREGATABLE(CQueryItem)

    BEGIN_COM_MAP(CQueryItem)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IBOMObject)
    END_COM_MAP()


    //
    // Notification handlers
    //
    DECLARE_NOTIFY_MAP()

    STDMETHOD(OnHelp)    (LPCONSOLE2 pConsole, LPARAM arg, LPARAM param);
    STDMETHOD(OnSelect)(LPCONSOLE2 pConsole, BOOL bSelect, BOOL bScope);
    STDMETHOD(OnDblClick)(LPCONSOLE2 pConsole);

    //
    // IDataObject helper method
    //
    STDMETHOD(GetDataImpl)(UINT cf, HGLOBAL* hGlobal);

    //
    // IBOMObject methods
    //

    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK pCallback, long* lAllowed); 
    
    STDMETHOD(MenuCommand)(LPCONSOLE2 pConsole, long lCommand); 
    
    STDMETHOD(SetToolButtons)(LPTOOLBAR pToolbar)
    { return S_FALSE; }

    STDMETHOD(SetVerbs)(LPCONSOLEVERB pConsVerb) 
    { return S_OK; }
    
    STDMETHOD(QueryPagesFor)(); 
    
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,LONG_PTR handle) 
    { return E_UNEXPECTED; }
     
    STDMETHOD(GetWatermarks)(HBITMAP* lphWatermark, HBITMAP* lphHeader, HPALETTE* lphPalette, BOOL* bStretch)
    { return E_UNEXPECTED; }
    
    //
    // Member variables
    //
    CQueryableNode* m_spQueryNode;      // Query node that owns this item
    CRowItem*       m_pRowItem;         // Row item info for this item
    CActDirExt*     m_pADExt;           // Directory extension (handles AD menus and prop pages)
    menucmd_vector  m_vMenus;           // Menu items defined for the query node
    
    static UINT m_cfDisplayName;        // supported clipboard formats
    static UINT m_cfSnapInClsid;
    static UINT m_cfNodeType;
    static UINT m_cfszNodeType;

};

typedef CComPtr<CQueryItem> CQueryItemPtr;

#endif // _QRYITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\qryprop.cpp ===
// qryprop.cpp -  Query Property Page Implementation

#include "stdafx.h"
#include "resource.h"
#include "qryprop.h"
#include "compdata.h"
#include "scopenode.h"
#include "query.h"
#include "cmndlgs.h"

#include "util.h"
#include "namemap.h"

#define SECURITY_WIN32
#include <security.h>   // TranslateName

#include <windowsx.h>
#include <algorithm>

#undef SubclassWindow

int GetDateTimeString(FILETIME* pftime, LPWSTR pszBuf, int cBuf);
void LoadObjectCB(CComboBox& ComboBox, QueryObjVector& vObj);

#define CHECK_OFF INDEXTOSTATEIMAGEMASK(1)
#define CHECK_ON  INDEXTOSTATEIMAGEMASK(2)



///////////////////////////////////////////////////////////////////////////////////////////
// CQueryGeneralPage

CQueryGeneralPage::CQueryGeneralPage(CQueryEditObj* pEditObj)
: m_EditObject(*pEditObj)
{
    ASSERT(pEditObj != NULL);
    m_EditObject.AddRef();
}

CQueryGeneralPage::~CQueryGeneralPage()
{
    m_EditObject.Release();
}

LRESULT CQueryGeneralPage::OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if( !m_EditObject.m_spQueryNode ) return 0;

    // display query node icon
    HICON hIcon = ::LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_QUERYNODE));
    Static_SetIcon(GetDlgItem(IDC_QUERYICON), hIcon);

    // fill dialog fields with query node info
    tstring strTempQuery;
    m_EditObject.m_spQueryNode->ExpandQuery(strTempQuery);

    CQueryNode* pQNode = m_EditObject.m_spQueryNode;
    SetDlgItemText( IDC_NAME,   m_EditObject.m_spQueryNode->GetName() );
    SetDlgItemText( IDC_FILTER, strTempQuery.c_str() );

    tstring strComment;
    m_EditObject.m_spQueryNode->GetComment(strComment);
    SetDlgItemText( IDC_COMMENTS, strComment.c_str() );

    Edit_LimitText(GetDlgItem(IDC_COMMENTS), 255);

    // set scope source toggle button 
    UINT uButton = m_EditObject.m_spQueryNode->UseLocalScope() ? IDC_LOCALSCOPE : IDC_QUERYSCOPE;
    Button_SetCheck(GetDlgItem(uButton), BST_CHECKED);

    tstring strScope = m_EditObject.m_spQueryNode->Scope();
    tstring strDisplay;
    GetScopeDisplayString(strScope, strDisplay);
    SetDlgItemText( IDC_SCOPE, strDisplay.c_str() );

    // if using local scope, then set the persisted scope equal to the local scope so that the
    // user won't see an obsolete scope that may have been saved when creating the node.
    if( m_EditObject.m_spQueryNode->UseLocalScope() )
        m_EditObject.m_spQueryNode->SetScope(strScope.c_str());

    // if classes known, display comma separated class names
    if( m_EditObject.m_vObjInfo.size() != 0 )
    {
        DisplayNameMap* pNameMap = DisplayNames::GetClassMap();
        ASSERT(pNameMap != NULL);
        if( pNameMap != NULL )
        {
            QueryObjVector::iterator itQObj = m_EditObject.m_vObjInfo.begin();
            tstring strClasses = pNameMap->GetAttributeDisplayName(itQObj->Name());

            for( itQObj++; itQObj != m_EditObject.m_vObjInfo.end(); ++itQObj )
            {
                strClasses += L", ";
                strClasses += pNameMap->GetAttributeDisplayName(itQObj->Name());
            }

            SetDlgItemText( IDC_OBJCLASS, strClasses.c_str() );
        }
    }

    return TRUE;
}

LRESULT CQueryGeneralPage::OnScopeChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if( !m_EditObject.m_spQueryNode ) return 0;

    // if user changes scope selection then display the correct scope    
    tstring strScope;

    if( Button_GetCheck(GetDlgItem(IDC_LOCALSCOPE)) == BST_CHECKED )
        strScope = GetLocalDomain();
    else
        strScope = m_EditObject.m_spQueryNode->QueryScope();

    tstring strDisplay;
    GetScopeDisplayString(strScope, strDisplay);

    SetDlgItemText( IDC_SCOPE, strDisplay.c_str() );

    SetModified(TRUE);
    return 0;
}


LRESULT CQueryGeneralPage::OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetModified(TRUE);
    return 0;
}


//------------------------------------------------------------------------------------
// CRootGeneralPage::OnClose
//
// This method is invoked when an edit box receives an Esc char. The method converts
// the WM_CLOSE message into a command to close the property sheet. Otherwise the
// WM_CLOSE message has no effect.
//------------------------------------------------------------------------------------
LRESULT CQueryGeneralPage::OnClose( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    // Simulate press of Cancel button
    ::PropSheet_PressButton(GetParent(), PSBTN_CANCEL);

    return 0;
}

BOOL CQueryGeneralPage::OnSetActive()
{
    m_EditObject.PageActive(m_hWnd);
    return TRUE;
}

BOOL CQueryGeneralPage::OnApply()
{
    if( !m_EditObject.m_spQueryNode ) return FALSE;

    tstring strComment;
    GetItemText(GetDlgItem(IDC_COMMENTS), strComment);
    m_EditObject.m_spQueryNode->SetComment(strComment.c_str());

    bool bLocal = (Button_GetCheck(GetDlgItem(IDC_LOCALSCOPE)) == BST_CHECKED);
    m_EditObject.m_spQueryNode->SetLocalScope(bLocal);

    return m_EditObject.ApplyChanges(m_hWnd);
}


///////////////////////////////////////////////////////////////////////////////////////////
// CQueryMenuPage

CQueryMenuPage::CQueryMenuPage(CQueryEditObj* pEditObj)
: m_EditObject(*pEditObj), m_pObjSel(NULL), m_bLoading(FALSE)
{
    ASSERT(pEditObj != NULL);
    m_EditObject.AddRef();
}

CQueryMenuPage::~CQueryMenuPage()
{
    m_ObjectCB.Detach();
    m_EditObject.Release();
}

LRESULT CQueryMenuPage::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    HWND hwndList = GetDlgItem(IDC_MENULIST);
    ASSERT( hwndList );

    if( hwndList )
    {
        m_MenuLV.SubclassWindow(hwndList);

        RECT rc;
        BOOL bStat = m_MenuLV.GetClientRect(&rc);
        ASSERT(bStat);

        int iWidth = (rc.right - rc.left) - GetSystemMetrics(SM_CXVSCROLL);

        CString strName;

        strName.LoadString(IDS_MENUITEM);
        int iCol = m_MenuLV.InsertColumn(0, strName, LVCFMT_LEFT, (iWidth + 1)/2, 0);
        ASSERT(iCol == 0);

        strName.LoadString(IDS_TYPE);
        iCol = m_MenuLV.InsertColumn(1, strName, LVCFMT_LEFT, iWidth/2, 1);
        ASSERT(iCol == 1);

        m_MenuLV.SetExtendedListViewStyle(LVS_EX_CHECKBOXES|LVS_EX_FULLROWSELECT);
    }

    HWND hwndCombo = GetDlgItem(IDC_OBJECTLIST);
    ASSERT(hwndCombo);
    if( hwndCombo )
    {
        m_ObjectCB.Attach(hwndCombo);

        LoadObjectCB(m_ObjectCB, m_EditObject.m_vObjInfo);

        if( m_EditObject.m_vObjInfo.size() != 0 )
        {
            m_ObjectCB.SetCurSel(0);
            m_pObjSel = reinterpret_cast<CQueryObjInfo*>(m_ObjectCB.GetItemDataPtr(0));

            if( hwndList )
            {
                DisplayMenus();
            }
        }
    }

    return TRUE;
}


void CQueryMenuPage::DisplayMenus()
{
    if( m_pObjSel == NULL )
        return;

    if( !m_EditObject.m_spQueryNode ) return;

    m_bLoading = TRUE;

    m_MenuLV.DeleteAllItems();

    m_DefaultID = 0;

    CRootNode* pRootNode = m_EditObject.m_spQueryNode->GetRootNode(); 
    if( !pRootNode ) return;

    CClassInfo* pClassInfo = pRootNode->FindClass(m_pObjSel->Name());
    if( pClassInfo != NULL )
    {
        int iIndex = 0;

        menuref_vector& vMenuRefs = m_pObjSel->MenuRefs();
        menuref_vector::iterator itMenuRef;

        menucmd_vector& vMenuCmds = pClassInfo->Menus();
        menucmd_vector::iterator itMenuCmd;

        // First add all root menu items that are not yet ref'd by the query node
        for( itMenuCmd = vMenuCmds.begin(); itMenuCmd != vMenuCmds.end(); ++itMenuCmd )
        {
            if( std::find(vMenuRefs.begin(), vMenuRefs.end(), (*itMenuCmd)->ID()) != vMenuRefs.end() )
                break;

            // Add menu to displayed list in an enabled state
            DisplayMenuItem(iIndex++, *itMenuCmd, TRUE);
        }

        // For each query menu reference
        for( itMenuRef = vMenuRefs.begin(); itMenuRef != vMenuRefs.end(); ++itMenuRef )
        {
            // Find the matching root menu cmd
            for( itMenuCmd = vMenuCmds.begin(); itMenuCmd != vMenuCmds.end(); ++itMenuCmd )
            {
                if( (*itMenuCmd)->ID() == itMenuRef->ID() )
                    break;
            }

            // if menu was deleted at the root node, then skip it
            if( itMenuCmd == vMenuCmds.end() )
                continue;

            // Display the menu item
            DisplayMenuItem(iIndex++, *(itMenuCmd++), itMenuRef->IsEnabled());

            // If this is the default menu item save its ID
            if( itMenuRef->IsDefault() )
            {
                ASSERT(m_DefaultID == 0);
                m_DefaultID = itMenuRef->ID();
            }

            // Display any following root items that aren't in the query list
            while( itMenuCmd != vMenuCmds.end() &&
                   std::find(vMenuRefs.begin(), vMenuRefs.end(), (*itMenuCmd)->ID()) == vMenuRefs.end() )
            {
                DisplayMenuItem(iIndex++, *(itMenuCmd++), TRUE);                
            } 
        }
    }

    // Disable buttons until selection made
    EnableDlgItem( m_hWnd, IDC_MOVEUP,      FALSE );
    EnableDlgItem( m_hWnd, IDC_MOVEDOWN,    FALSE );
    EnableDlgItem( m_hWnd, IDC_DEFAULTMENU, FALSE );

    // Uncheck default button until default item selected
    Button_SetCheck(GetDlgItem(IDC_DEFAULTMENU), BST_UNCHECKED);

    // Set Property Menu Checkbox
    Button_SetCheck(GetDlgItem(IDC_PROPERTYMENU), m_pObjSel->HasPropertyMenu() ? BST_CHECKED : BST_UNCHECKED);

    m_bLoading = FALSE;
}

void CQueryMenuPage::DisplayMenuItem(int iIndex, CMenuCmd* pMenuCmd, BOOL bEnabled)
{
    if( !pMenuCmd ) return;

    static CString strShellCmd;
    static CString strADCmd;

    LV_ITEM lvi;
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = iIndex;
    lvi.iSubItem = 0;
    lvi.pszText = const_cast<LPWSTR>(pMenuCmd->Name());
    lvi.lParam = static_cast<LPARAM>(pMenuCmd->ID());

    int iPos = m_MenuLV.InsertItem(&lvi);
    ASSERT(iPos == iIndex);

    lvi.iSubItem = 1;
    lvi.mask = LVIF_TEXT;

    switch( pMenuCmd->MenuType() )
    {
    case MENUTYPE_SHELL:
        if( strShellCmd.IsEmpty() )
            strShellCmd.LoadString(IDS_SHELLCMD);

        lvi.pszText = (LPWSTR)(LPCWSTR)strShellCmd;
        break;

    case MENUTYPE_ACTDIR:
        if( strADCmd.IsEmpty() )
            strADCmd.LoadString(IDS_DISPSPEC);

        lvi.pszText = (LPWSTR)(LPCWSTR)strADCmd;
        break;

    default:
        ASSERT(FALSE);
    }

    m_MenuLV.SetItem(&lvi);

    m_MenuLV.SetCheckState(iIndex, bEnabled);
}

LRESULT CQueryMenuPage::OnObjectSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iItem = m_ObjectCB.GetCurSel();

    // Double-clicking an empty combo box can call this with no selection
    if( iItem >= 0 )
    {
        SaveMenuSet();

        m_pObjSel = reinterpret_cast<CQueryObjInfo*>(m_ObjectCB.GetItemDataPtr(iItem));

        DisplayMenus();
    }

    return 0;
}


LRESULT CQueryMenuPage::OnMoveUpDown( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iItem = m_MenuLV.GetNextItem(-1, LVNI_SELECTED);
    ASSERT(iItem >= 0);

    // Get the selected item data
    WCHAR szName[100];

    LVITEM lvi;
    lvi.mask = LVIF_TEXT|LVIF_PARAM|LVIF_STATE;
    lvi.stateMask = 0xFFFFFFFF;
    lvi.iSubItem = 0;
    lvi.iItem = iItem;
    lvi.pszText = szName;
    lvi.cchTextMax = sizeof(szName);
    m_MenuLV.GetItem(&lvi);

    WCHAR szType[100];
    m_MenuLV.GetItemText(iItem, 1, szType, sizeof(szType));

    // Set loading flag to avoid intermediate button enable/disables
    m_bLoading = TRUE;

    // Delete and insert at new position
    m_MenuLV.DeleteItem(iItem);

    lvi.iItem += (wID == IDC_MOVEUP) ? -1 : 1;
    m_MenuLV.InsertItem(&lvi);
    m_MenuLV.SetItemText(lvi.iItem, 1, szType);

    // re-establish checked state (insert doesn't retain it)
    if( lvi.state & CHECK_ON )
        m_MenuLV.SetCheckState(lvi.iItem, TRUE);

    m_bLoading = FALSE;

    SetModified(TRUE);

    // update button states
    EnableDlgItem( m_hWnd, IDC_MOVEUP,   (lvi.iItem > 0) );
    EnableDlgItem( m_hWnd, IDC_MOVEDOWN, (lvi.iItem < (m_MenuLV.GetItemCount() - 1)) );

    return 0;
}

LRESULT CQueryMenuPage::OnMenuChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    if( !pNMHDR ) return 0;

    if( !m_bLoading )
    {
        LPNMLISTVIEW pnmv = reinterpret_cast<LPNMLISTVIEW>(pNMHDR);

        // if  state has changed    
        if( pnmv->uChanged & LVIF_STATE )
        {
            // if checkbox state change
            if( (pnmv->uNewState ^ pnmv->uOldState) & LVIS_STATEIMAGEMASK )
            {
                // if the changed item is currently selected
                if( m_MenuLV.GetItemState(pnmv->iItem, LVIS_SELECTED) & LVIS_SELECTED )
                {
                    // Change the state of all selcted items to match
                    BOOL bNewState = ((pnmv->uNewState & LVIS_STATEIMAGEMASK) == CHECK_ON);

                    m_bLoading = TRUE;
                    int iItem = -1;
                    while( (iItem = m_MenuLV.GetNextItem(iItem, LVNI_SELECTED)) >= 0 )
                    {
                        m_MenuLV.SetCheckState(iItem, bNewState);                
                    }
                    m_bLoading = FALSE;

                }

                SetModified(TRUE);
            }

            if( (pnmv->uNewState ^ pnmv->uOldState) & LVIS_SELECTED )
            {
                int nItems    = m_MenuLV.GetItemCount();
                int iItem     = m_MenuLV.GetNextItem(-1, LVNI_SELECTED);
                int nSelected = m_MenuLV.GetSelectedCount();

                BOOL bDefault = (nSelected == 1) && (m_MenuLV.GetItemData(iItem) == m_DefaultID);
                Button_SetCheck(GetDlgItem(IDC_DEFAULTMENU), bDefault ? BST_CHECKED : BST_UNCHECKED);

                EnableDlgItem( m_hWnd, IDC_MOVEUP,      ((iItem > 0) && (nSelected == 1)) );
                EnableDlgItem( m_hWnd, IDC_MOVEDOWN,    ((iItem >= 0) && (iItem < (nItems - 1)) && (nSelected == 1)) );
                EnableDlgItem( m_hWnd, IDC_DEFAULTMENU, (nSelected == 1) );
            }

        }
    }

    return TRUE;
}


LRESULT CQueryMenuPage::OnDefaultChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // if user checks the default then save currently selected menu ID as default
    if( Button_GetCheck(GetDlgItem(IDC_DEFAULTMENU)) == BST_CHECKED )
    {
        // button should be disabled unless there is one menu item selected
        ASSERT(m_MenuLV.GetSelectedCount() == 1);

        int iItem = m_MenuLV.GetNextItem(-1, LVNI_SELECTED);
        m_DefaultID = m_MenuLV.GetItemData(iItem);        
    }
    else
    {
        // if user unchecks box there is no default
        m_DefaultID = 0;
    }

    SetModified(TRUE);
    return 0;
}


LRESULT CQueryMenuPage::OnPropertyMenuChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetModified(TRUE);
    return 0;
}


void CQueryMenuPage::SaveMenuSet()
{
    if( m_pObjSel == NULL )
        return;

    m_pObjSel->m_vMenuRefs.clear();

    LVITEM lvi;
    lvi.mask      = LVIF_PARAM | LVIF_STATE;
    lvi.stateMask = LVIS_STATEIMAGEMASK; 
    lvi.iSubItem  = 0;

    int nItems = m_MenuLV.GetItemCount();
    for( int iIndex = 0; iIndex < nItems; iIndex++ )
    {
        lvi.iItem = iIndex;
        BOOL bStat = m_MenuLV.GetItem(&lvi);
        ASSERT(bStat);

        CMenuRef menuref;
        menuref.m_menuID = static_cast<MenuID>(lvi.lParam);
        menuref.SetEnable((lvi.state & LVIS_STATEIMAGEMASK) == CHECK_ON);
        menuref.SetDefault(menuref.m_menuID == m_DefaultID);

        m_pObjSel->m_vMenuRefs.push_back(menuref);
    }

    m_pObjSel->SetPropertyMenu( Button_GetCheck(GetDlgItem(IDC_PROPERTYMENU)) == BST_CHECKED );
}


BOOL CQueryMenuPage::OnSetActive()
{
    m_EditObject.PageActive(m_hWnd);
    return TRUE;
}


BOOL CQueryMenuPage::OnApply()
{
    SaveMenuSet();

    return m_EditObject.ApplyChanges(m_hWnd);
}

///////////////////////////////////////////////////////////////////////////////////////////
// CQueryViewPage

CQueryViewPage::CQueryViewPage(CQueryEditObj* pEditObj)
: m_EditObject(*pEditObj), m_bLoading(FALSE), m_pObjSel(NULL) 
{
    ASSERT(pEditObj != NULL);
    m_EditObject.AddRef();
}

CQueryViewPage::~CQueryViewPage()
{
    m_ObjectCB.Detach();
    m_EditObject.Release();
}


LRESULT CQueryViewPage::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    HWND hwndList = GetDlgItem(IDC_COLUMNLIST);
    if( hwndList )
    {
        m_ColumnLV.SubclassWindow(hwndList);

        RECT rc;
        BOOL bStat = m_ColumnLV.GetClientRect(&rc);
        ASSERT(bStat);

        int iCol = m_ColumnLV.InsertColumn(0, NULL, LVCFMT_LEFT, (rc.right - rc.left), 0);
        ASSERT(iCol == 0);

        m_ColumnLV.SetExtendedListViewStyle(LVS_EX_CHECKBOXES);
    }

    HWND hwndCombo = GetDlgItem(IDC_OBJECTLIST);    
    if( hwndCombo )
    {
        m_ObjectCB.Attach(hwndCombo);

        LoadObjectCB(m_ObjectCB, m_EditObject.m_vObjInfo);

        if( m_EditObject.m_vObjInfo.size() != 0 )
        {
            m_ObjectCB.SetCurSel(0);
            m_pObjSel = reinterpret_cast<CQueryObjInfo*>(m_ObjectCB.GetItemDataPtr(0));

            if( hwndList )
            {
                DisplayColumns();
            }
        }
    }

    return TRUE;
}

LRESULT CQueryViewPage::OnObjectSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iItem = m_ObjectCB.GetCurSel();

    // Double-clicking an empty combo box can call this with no selection
    if( iItem >= 0 )
    {
        SaveColumnSet();

        m_pObjSel = reinterpret_cast<CQueryObjInfo*>(m_ObjectCB.GetItemDataPtr(iItem));

        DisplayColumns();
    }

    return 0;
}


void CQueryViewPage::DisplayColumns()
{
    if( !m_pObjSel ) return;
    if( !m_EditObject.m_spQueryNode ) return;

    m_bLoading = TRUE;

    m_ColumnLV.DeleteAllItems();

    LV_ITEM lvi;
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = 0;
    lvi.iSubItem = 0;

    CRootNode* pRootNode = m_EditObject.m_spQueryNode->GetRootNode(); 
    if( !pRootNode ) return;

    CClassInfo* pClassInfo = pRootNode->FindClass(m_pObjSel->Name());
    if( pClassInfo != NULL )
    {
        DisplayNameMap* pNameMap = DisplayNames::GetMap(m_pObjSel->Name());
        ASSERT(pNameMap != NULL);

        if( pNameMap == NULL )
            return;

        string_vector& vDisabledCols = m_pObjSel->DisabledColumns();

        string_vector::iterator itstrCol;
        for( itstrCol = pClassInfo->Columns().begin(); itstrCol != pClassInfo->Columns().end(); ++itstrCol )
        {
            lvi.pszText = const_cast<LPWSTR>(pNameMap->GetAttributeDisplayName(itstrCol->c_str()));
            lvi.lParam  = reinterpret_cast<LPARAM>(itstrCol->c_str());
            int iPos = m_ColumnLV.InsertItem(&lvi);
            ASSERT(iPos >= 0);

            //Enable all columns that aren't excluded by the query node
            if( std::find(vDisabledCols.begin(), vDisabledCols.end(), *itstrCol) == vDisabledCols.end() )
                m_ColumnLV.SetCheckState(iPos, TRUE);
        }
    }

    m_bLoading = FALSE;
}


LRESULT CQueryViewPage::OnColumnChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    if( !pNMHDR ) return 0;

    if( !m_bLoading )
    {
        LPNMLISTVIEW pnmv = reinterpret_cast<LPNMLISTVIEW>(pNMHDR);

        // if checked state has changed
        if( (pnmv->uChanged & LVIF_STATE) &&
            ((pnmv->uNewState ^ pnmv->uOldState) & LVIS_STATEIMAGEMASK) )
        {
            // if the changed item is currently selected
            if( m_ColumnLV.GetItemState(pnmv->iItem, LVIS_SELECTED) & LVIS_SELECTED )
            {
                // Change the state of all selcted items to match
                BOOL bNewState = ((pnmv->uNewState & LVIS_STATEIMAGEMASK) == CHECK_ON);

                m_bLoading = TRUE;
                int iItem = -1;
                while( (iItem = m_ColumnLV.GetNextItem(iItem, LVNI_SELECTED)) >= 0 )
                {
                    m_ColumnLV.SetCheckState(iItem, bNewState);                
                }
                m_bLoading = FALSE;

            }

            SetModified(TRUE);
        }
    }

    return TRUE;
}

void CQueryViewPage::SaveColumnSet()
{
    if( m_pObjSel == NULL )
        return;

    string_vector vstrNewCols;    

    int nItems = m_ColumnLV.GetItemCount();
    for( int iIndex = 0; iIndex < nItems; iIndex++ )
    {
        // Save list of disabled columns
        if( !m_ColumnLV.GetCheckState(iIndex) )
        {
            LVITEM lvi;
            lvi.mask = LVIF_PARAM;
            lvi.iItem = iIndex;
            lvi.iSubItem = 0;
            BOOL bStat = m_ColumnLV.GetItem(&lvi);
            ASSERT(bStat);

            vstrNewCols.push_back(reinterpret_cast<LPCWSTR>(lvi.lParam));
        }
    }

    m_pObjSel->m_vstrDisabledColumns = vstrNewCols;
}

typedef struct
{
    HWND  hwndList;
    int   iCol;
}
COMPAREPARAM, *LPCOMPAREPARAM;


int CALLBACK ColumnCompare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    if( !lParamSort ) return 0;

    LPCOMPAREPARAM pcmp = reinterpret_cast<LPCOMPAREPARAM>(lParamSort);

    WCHAR sz1[MAX_PATH];
    ListView_GetItemText(pcmp->hwndList, lParam1, pcmp->iCol, sz1, MAX_PATH); 

    WCHAR sz2[MAX_PATH];
    ListView_GetItemText(pcmp->hwndList, lParam2, pcmp->iCol, sz2, MAX_PATH);

    return wcscmp(sz1,sz2);
}


LRESULT CQueryViewPage::OnColumnClick(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    if( !pNMHDR ) return 0;

    LPNMLISTVIEW pnmv = reinterpret_cast<LPNMLISTVIEW>(pNMHDR);

    COMPAREPARAM cmp;
    cmp.hwndList = pnmv->hdr.hwndFrom;
    cmp.iCol     = pnmv->iSubItem;

    ListView_SortItemsEx(pnmv->hdr.hwndFrom, &ColumnCompare, &cmp);

    return TRUE;
}


BOOL CQueryViewPage::OnSetActive()
{
    DisplayColumns();
    m_EditObject.PageActive(m_hWnd);

    return TRUE;
}


BOOL CQueryViewPage::OnApply()
{
    SaveColumnSet();

    return m_EditObject.ApplyChanges(m_hWnd);
}

///////////////////////////////////////////////////////////////////////////////////////////
// CQueryNodeMenuPage

CQueryNodeMenuPage::CQueryNodeMenuPage(CQueryEditObj* pEditObj)
: m_EditObject(*pEditObj)
{
    ASSERT(pEditObj != NULL);
    m_EditObject.AddRef();
}

CQueryNodeMenuPage::~CQueryNodeMenuPage()
{
    m_MenuLV.Detach();
    m_EditObject.Release();
}

LRESULT CQueryNodeMenuPage::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    m_MenuLV.Attach(GetDlgItem(IDC_MENULIST));    

    ::ConfigSingleColumnListView(GetDlgItem(IDC_MENULIST));

    return TRUE;
}

BOOL CQueryNodeMenuPage::OnSetActive()
{
    m_EditObject.PageActive(m_hWnd);    
    DisplayMenus();

    return TRUE;
}


void CQueryNodeMenuPage::DisplayMenus()
{
    if( !m_EditObject.m_spQueryNode ) return;

    HWND hwndLV = GetDlgItem(IDC_MENULIST);

    ASSERT(::IsWindow(hwndLV));

    ListView_DeleteAllItems(hwndLV);

    // make sure menu names have been loaded
    CRootNode* pRootNode = m_EditObject.m_spQueryNode->GetRootNode();
    if( !pRootNode ) return;

    CComponentData* pCompData = pRootNode->GetCompData();
    if( !pCompData ) return;

    IStringTable* pStringTable = pCompData->GetStringTable();
    ASSERT(pStringTable != NULL);
    if( !pStringTable ) return;

    m_EditObject.LoadStrings(pStringTable);

    LV_ITEM lvi;
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = 0;
    lvi.iSubItem = 0;

    menucmd_vector::iterator itMenu;
    for( itMenu = m_EditObject.Menus().begin(); itMenu != m_EditObject.Menus().end(); ++itMenu )
    {
        lvi.pszText = const_cast<LPWSTR>((*itMenu)->Name());
        lvi.lParam = (*itMenu)->ID();

        int iPos = ListView_InsertItem(hwndLV, &lvi);
        ASSERT(iPos >= 0);

        lvi.iItem++;
    }    

    EnableDlgItem( m_hWnd, IDC_ADDMENU,    TRUE  );
    EnableDlgItem( m_hWnd, IDC_REMOVEMENU, FALSE );
    EnableDlgItem( m_hWnd, IDC_EDITMENU,   FALSE );
    EnableDlgItem( m_hWnd, IDC_MOVEUP,     FALSE );
    EnableDlgItem( m_hWnd, IDC_MOVEDOWN,   FALSE );
}


LRESULT CQueryNodeMenuPage::OnAddMenu( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if( !m_EditObject.m_spQueryNode ) return 0;

    CAddQNMenuDlg dlg(m_EditObject);

    if( dlg.DoModal() == IDOK )
    {
        CMenuCmd* pMenuNew = dlg.GetMenu();
        ASSERT(pMenuNew != NULL);
        if( !pMenuNew ) return 0;

        // Add new menu to list
        HWND hwndList = GetDlgItem(IDC_MENULIST);

        // Set name to add it to string table and generate the menu ID
        CRootNode* pRootNode = m_EditObject.m_spQueryNode->GetRootNode(); 
        if( !pRootNode ) return 0;

        CComponentData* pCompData = pRootNode->GetCompData();
        ASSERT( pCompData );
        if( !pCompData ) return 0;

        IStringTable* pStringTable = pCompData->GetStringTable();        
        ASSERT( pStringTable );
        if( !pStringTable ) return 0;


        // Use temp string because string fails an assignement like: strX = strX.c_str()
        // (it relases the private buffer first and then assigns the string)
        tstring strName = pMenuNew->Name();
        pMenuNew->SetName(pStringTable, strName.c_str()); 

        LVITEM lvi;
        lvi.mask = LVIF_PARAM | LVIF_TEXT;
        lvi.iSubItem = 0;
        lvi.iItem = ListView_GetItemCount(hwndList);
        lvi.lParam = pMenuNew->ID();
        lvi.pszText = const_cast<LPWSTR>(pMenuNew->Name());
        ListView_InsertItem(hwndList,&lvi);

        // Add to menu vector (note that temp CMenuCmdPtr will delete pMenuNew)
        m_EditObject.m_vMenus.push_back(CMenuCmdPtr(pMenuNew));

        SetModified(TRUE);
    }

    return 0;
}


LRESULT CQueryNodeMenuPage::OnEditMenu( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if( !m_EditObject.m_spQueryNode ) return 0;

    HWND hwndList = GetDlgItem(IDC_MENULIST);

    int iIndex = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
    ASSERT(iIndex != -1);

    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = iIndex;

    ListView_GetItem(hwndList, &lvi);

    // Locate selected menu by it's ID (lparam)

    menucmd_vector& vMenus = m_EditObject.Menus();

    menucmd_vector::iterator itMenu;
    itMenu = std::find(vMenus.begin(), vMenus.end(), lvi.lParam);
    ASSERT(itMenu != vMenus.end());

    CMenuCmd* pMenu = *itMenu;
    if( !pMenu ) return 0;

    CAddQNMenuDlg dlg(m_EditObject, pMenu);

    if( dlg.DoModal() == IDOK )
    {
        CMenuCmd* pMenuNew = dlg.GetMenu();
        ASSERT(pMenuNew != NULL);
        if( !pMenuNew ) return 0;

        // Set the name again in case it was changed		
        CRootNode* pRootNode = m_EditObject.m_spQueryNode->GetRootNode();
        if( !pRootNode ) return 0;

        CComponentData* pCompData = pRootNode->GetCompData();
        if( !pCompData ) return 0;

        IStringTable* pStringTable = pCompData->GetStringTable();         
        ASSERT(pStringTable != NULL);
        if( !pStringTable ) return 0;

        // Use temp string because string fails an assignement like: strX = strX.c_str()
        // (it relases the private buffer first and then assigns the string)
        tstring strName = pMenuNew->Name();
        pMenuNew->SetName(pStringTable, strName.c_str()); 

        // locate object again because the vector may have been reallocated        
        menucmd_vector& vMenusNew = m_EditObject.Menus();

        // locate with the old ID because it will be different if the name was changed        
        itMenu = std::find(vMenusNew.begin(), vMenusNew.end(), pMenu->ID());
        ASSERT(itMenu != vMenusNew.end());

        // Replace menu with new one
        *itMenu = pMenuNew;

        // Update the list
        lvi.mask = LVIF_PARAM | LVIF_TEXT;
        lvi.lParam = pMenuNew->ID();
        lvi.pszText = const_cast<LPWSTR>(pMenuNew->Name());
        ListView_SetItem(hwndList,&lvi); 

        SetModified(TRUE);
    }

    return 0;
}

LRESULT CQueryNodeMenuPage::OnRemoveMenu( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    HWND hwndList = GetDlgItem(IDC_MENULIST);

    UINT uiMsg = (ListView_GetSelectedCount(hwndList) == 1) ? IDS_MENU_REMOVE_ONE : IDS_MENU_REMOVE;
    int iRet = DisplayMessageBox(m_hWnd, IDS_MENU_REMOVE_TITLE, uiMsg, MB_YESNO|MB_ICONWARNING);
    if( iRet != IDYES )
        return 0;

    menucmd_vector& vMenus = m_EditObject.Menus();

    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;

    int iIndex = -1;
    while( (iIndex = ListView_GetNextItem(hwndList, iIndex, LVNI_SELECTED)) >= 0 )
    {
        lvi.iItem = iIndex;
        ListView_GetItem(hwndList, &lvi);

        // Locate menu by its ID
        menucmd_vector::iterator itMenu = std::find(vMenus.begin(), vMenus.end(), lvi.lParam);
        ASSERT(itMenu != vMenus.end());

        vMenus.erase(itMenu);

        ListView_DeleteItem(hwndList, iIndex);
        iIndex--;
    }

    EnableDlgItem( m_hWnd, IDC_REMOVEMENU, FALSE );
    EnableDlgItem( m_hWnd, IDC_EDITMENU,   FALSE );
    EnableDlgItem( m_hWnd, IDC_MOVEUP,     FALSE );
    EnableDlgItem( m_hWnd, IDC_MOVEDOWN,   FALSE );

    SetModified(TRUE);

    return 0;
}

LRESULT CQueryNodeMenuPage::OnMoveUpDown( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    HWND hwndList = GetDlgItem(IDC_MENULIST); 
    int iItem = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
    ASSERT(iItem >= 0);

    // Determine new position for selected item
    if( wID == IDC_MOVEUP )
        iItem--;
    else
        iItem++;

    // Now swap the selected item with the item at its new position
    //   Do it by moving the unselected item to avoid state change notifications
    //   because they will cause unwanted butten enables/disables.
    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = iItem;
    ListView_GetItem(hwndList, &lvi);


    // Move the menu item in the menu vector
    menucmd_vector& vMenus = m_EditObject.Menus();

    menucmd_vector::iterator itMenu = std::find(vMenus.begin(), vMenus.end(), lvi.lParam);
    ASSERT(itMenu != vMenus.end());

    menucmd_vector::iterator itMenuOld = itMenu;
    if( wID == IDC_MOVEUP )
        itMenu++;
    else
        itMenu--;

    // swap the items
    std::iter_swap (itMenuOld, itMenu);

    //Now delete and reinsert it in the list view
    ListView_DeleteItem(hwndList, lvi.iItem);

    if( wID == IDC_MOVEUP )
        lvi.iItem++;
    else
        lvi.iItem--;
    lvi.mask = LVIF_PARAM | LVIF_TEXT;
    lvi.pszText = const_cast<LPWSTR>((*itMenu)->Name());
    ListView_InsertItem(hwndList, &lvi);


    // Update Up/Down buttons
    EnableDlgItem( m_hWnd, IDC_MOVEUP,   (iItem > 0) );
    EnableDlgItem( m_hWnd, IDC_MOVEDOWN, (iItem < (ListView_GetItemCount(hwndList) - 1)) );

    SetModified(TRUE);

    return 0;
}

LRESULT CQueryNodeMenuPage::OnMenuListChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    HWND hwndList = GetDlgItem(IDC_MENULIST);

    int nItemSel = ListView_GetSelectedCount(hwndList);
    int iItem = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);

    EnableDlgItem( m_hWnd, IDC_REMOVEMENU, (nItemSel > 0)  );
    EnableDlgItem( m_hWnd, IDC_EDITMENU,   (nItemSel == 1) );
    EnableDlgItem( m_hWnd, IDC_MOVEUP,     ((nItemSel == 1) && (iItem > 0)) );
    EnableDlgItem( m_hWnd, IDC_MOVEDOWN,   ((nItemSel == 1) && (iItem < (ListView_GetItemCount(hwndList) - 1))) );

    return TRUE;
}


LRESULT CQueryNodeMenuPage::OnMenuListDblClk(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    if( ListView_GetSelectedCount(GetDlgItem(IDC_MENULIST)) )
        ::SendMessage(GetDlgItem(IDC_EDITMENU), BM_CLICK, (WPARAM)0, (LPARAM)0);

    return 0;
}

BOOL CQueryNodeMenuPage::OnApply()
{
    return m_EditObject.ApplyChanges(m_hWnd);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// CQueryEditObj

void CQueryEditObj::PageActive(HWND hwndPage)
{
    ASSERT(::IsWindow(hwndPage));

    // track the highest created page number for ApplyChanges method
    int iPage = PropSheet_HwndToIndex(GetParent(hwndPage), hwndPage);
    if( iPage > m_iPageMax )
        m_iPageMax = iPage;
}


BOOL CQueryEditObj::ApplyChanges(HWND hwndPage)
{
    if( !m_spQueryNode ) return FALSE;

    ASSERT(::IsWindow(hwndPage));

    // Don't apply changes until called from highest activated page
    if( PropSheet_HwndToIndex(GetParent(hwndPage), hwndPage) < m_iPageMax )
        return TRUE;

    // replace original query objects with edited copies
    m_spQueryNode->Objects() = m_vObjInfo;
    m_spQueryNode->Menus()   = m_vMenus;

    if( m_spQueryNode )
    {
        CRootNode* pRootNode = m_spQueryNode->GetRootNode();
        if( pRootNode )
        {
            pRootNode->UpdateModifyTime();
        }
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// Helper functions

void LoadObjectCB(CComboBox& ComboBox, QueryObjVector& vObj)
{
    ComboBox.ResetContent();

    DisplayNameMap* pNameMap = DisplayNames::GetClassMap();
    ASSERT(pNameMap != NULL);
    if( pNameMap == NULL )
        return;

    for( QueryObjVector::iterator itObj = vObj.begin(); itObj != vObj.end(); ++itObj )
    {
        int iIndex = ComboBox.AddString(pNameMap->GetAttributeDisplayName(itObj->Name()));
        ASSERT(iIndex >= 0);
        ComboBox.SetItemDataPtr(iIndex, &(*itObj));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\qryitem.cpp ===
// qryitem.cpp - CQueryItem class 

#include "stdafx.h"
#include "scopenode.h"
#include "namemap.h"
#include "qryitem.h"

#include <algorithm>

extern HWND g_hwndMain;

UINT CQueryItem::m_cfDisplayName = RegisterClipboardFormat(TEXT("CCF_DISPLAY_NAME")); 
UINT CQueryItem::m_cfSnapInClsid = RegisterClipboardFormat(TEXT("CCF_SNAPIN_CLSID"));
UINT CQueryItem::m_cfNodeType    = RegisterClipboardFormat(TEXT("CCF_NODETYPE"));
UINT CQueryItem::m_cfszNodeType  = RegisterClipboardFormat(TEXT("CCF_SZNODETYPE"));

// {68D2DFD9-86A7-4964-8263-BA025C358992}
static const GUID GUID_QueryItem = 
{ 0x68d2dfd9, 0x86a7, 0x4964, { 0x82, 0x63, 0xba, 0x2, 0x5c, 0x35, 0x89, 0x92 } };


/////////////////////////////////////////////////////////////////////////////////////////////
// CQueryItem

HRESULT CQueryItem::Initialize(CQueryableNode* pQueryNode, CRowItem* pRowItem)
{
    VALIDATE_POINTER( pQueryNode );
    VALIDATE_POINTER( pRowItem   );

    m_spQueryNode = pQueryNode;
    
    m_pRowItem = new CRowItem(*pRowItem);
    if (m_pRowItem == NULL) return E_OUTOFMEMORY;

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// Notification handlers

BEGIN_NOTIFY_MAP(CQueryItem)
    ON_SELECT()
    ON_DBLCLICK()
    ON_NOTIFY(MMCN_CONTEXTHELP, OnHelp)
END_NOTIFY_MAP()

HRESULT CQueryItem::OnHelp(LPCONSOLE2 pConsole, LPARAM /*arg*/, LPARAM /*param*/)
{    
    VALIDATE_POINTER( pConsole );

    tstring strHelpFile  = _T("");
    tstring strHelpTopic = _T("");
    tstring strHelpFull  = _T("");    
        
    strHelpFile = StrLoadString(IDS_HELPFILE);
    if( strHelpFile.empty() ) return E_FAIL;    

    // Special Hack to get a different help topic for the first two nodes.
    int nNodeID = m_spQueryNode->GetNodeID();

    switch( nNodeID )
    {
    case 2:
        {
            // Users Node
            strHelpTopic = StrLoadString(IDS_USERSHELPTOPIC);
            break;
        }

    case 3:
        {
            // Printers Node
            strHelpTopic = StrLoadString(IDS_PRINTERSHELPTOPIC);
            break;
        }
    default:
        {
            strHelpTopic = StrLoadString(IDS_DEFAULTHELPTOPIC);
            break;
        }
    }
    
    if( strHelpTopic.empty() ) return E_FAIL;

    // Build path to %systemroot%\help
    TCHAR szWindowsDir[MAX_PATH+1] = {0};
    UINT nSize = GetSystemWindowsDirectory( szWindowsDir, MAX_PATH );
    if( nSize == 0 || nSize > MAX_PATH )
    {
        return E_FAIL;
    }            

    strHelpFull  = szWindowsDir;
    strHelpFull += _T("\\Help\\");
    strHelpFull += strHelpFile;
    strHelpFull += _T("::/");
    strHelpFull += strHelpTopic;

    // Show the Help topic
    CComQIPtr<IDisplayHelp> spHelp = pConsole;
    if( !spHelp ) return E_NOINTERFACE;
    
    return spHelp->ShowTopic( (LPTSTR)strHelpFull.c_str() );
}

HRESULT CQueryItem::OnSelect(LPCONSOLE2 pConsole, BOOL bSelect, BOOL bScope)
{
    VALIDATE_POINTER( pConsole );
    ASSERT(!bScope);

    if( bSelect ) 
    {
        CComPtr<IConsoleVerb> pConsVerb;
        pConsole->QueryConsoleVerb(&pConsVerb);
        ASSERT(pConsVerb != NULL);

        if (pConsVerb != NULL)
        {    
			// Row item has class display name, so get internal name from class map
			DisplayNameMap* pNameMap = DisplayNames::GetClassMap();
			if (pNameMap == NULL) 
				return E_FAIL;

			ASSERT(m_pRowItem != NULL && m_pRowItem->size() >= ROWITEM_USER_INDEX);
			ASSERT(m_spQueryNode != NULL);
			LPCWSTR pszClass = pNameMap->GetInternalName((*m_pRowItem)[ROWITEM_CLASS_INDEX]);

			// Get menu items for this class from the owning query node
			int iDefault;
			BOOL bPropertyMenu;
			reinterpret_cast<CQueryNode*>(m_pRowItem->GetOwnerParam())->GetClassMenuItems(pszClass, m_vMenus, &iDefault, &bPropertyMenu);

			// if property menu enabled
			if (bPropertyMenu)
			{
				// Enable property button and menu item
				pConsVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
				pConsVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);

				// if no default menu item defined, make properties verb the default
				pConsVerb->SetDefaultVerb( (iDefault >= 0) ? MMC_VERB_NONE : MMC_VERB_PROPERTIES);
			}
		}    
    }

    return S_OK;
}

HRESULT CQueryItem::OnDblClick(LPCONSOLE2 pConsole)
{
    VALIDATE_POINTER(pConsole);

    // Row item has class display name, so get internal name from class map
    DisplayNameMap* pNameMap = DisplayNames::GetClassMap();
    if (pNameMap == NULL) 
        return E_FAIL;

    ASSERT(m_pRowItem != NULL && m_pRowItem->size() >= ROWITEM_USER_INDEX);
    ASSERT(m_spQueryNode != NULL);
    LPCWSTR pszClass = pNameMap->GetInternalName((*m_pRowItem)[ROWITEM_CLASS_INDEX]);

    // Get menu items for this class from the owning query node
    int iDefault;
	BOOL bPropMenu;
    CQueryNode* pQueryNode = reinterpret_cast<CQueryNode*>(m_pRowItem->GetOwnerParam());
    if( !pQueryNode ) return E_FAIL;

    pQueryNode->GetClassMenuItems(pszClass, m_vMenus, &iDefault, &bPropMenu);    

    // if no default menu item, return
    if (iDefault < 0)
        return S_FALSE;

    // if Active directory command, create AD menu extension
    if (m_vMenus[iDefault]->MenuType() == MENUTYPE_ACTDIR) 
    {
        // Create a directory extension object and use it to get the actual menu cmds for the selected object
        // (we might have one already if AddMenuItems was called before)
        if (m_pADExt == NULL) 
            m_pADExt = new CActDirExt();
        
        if( !m_pADExt ) return E_OUTOFMEMORY;

        HRESULT hr = m_pADExt->Initialize(pszClass, m_pRowItem->GetObjPath());
        RETURN_ON_FAILURE(hr);

        menu_vector vADMenus;
        hr = m_pADExt->GetMenuItems(vADMenus);
        RETURN_ON_FAILURE(hr);

        if( m_vMenus.size() <= iDefault ) 
        {
            return E_FAIL;
        }
    
        LPCWSTR pszName      = static_cast<CActDirMenuCmd*>((CMenuCmd*)m_vMenus[iDefault])->ADName();
        LPCWSTR pszNoLocName = static_cast<CActDirMenuCmd*>((CMenuCmd*)m_vMenus[iDefault])->ADNoLocName();

        if( !pszName || !pszNoLocName ) return E_FAIL;

        // if the default command is not provided by the extension, return
        menu_vector::iterator iter;
        for( iter = vADMenus.begin(); iter != vADMenus.end(); iter++ )
        {
            if( _tcslen(pszNoLocName) )
            {
                if( _tcscmp(iter->strNoLoc.c_str(),pszNoLocName) == 0 )
                    break;
            }
            else if( _tcscmp(iter->strPlain.c_str(), pszName) == 0 )
            {
                break;
            }
        }

        if( iter == vADMenus.end() )
        {
            return S_FALSE;
        }        
    }

    // Execute the command as though it had been selected
    return MenuCommand(pConsole, iDefault);
}

HRESULT CQueryItem::AddMenuItems(LPCONTEXTMENUCALLBACK pCallback, long* plAllowed)
{
    VALIDATE_POINTER( pCallback );
    VALIDATE_POINTER( plAllowed );

    if( !m_spQueryNode || !m_pRowItem ) return E_FAIL;

    HRESULT hr = S_OK;

    if (!(*plAllowed & CCM_INSERTIONALLOWED_TOP))
        return S_OK;

    CComQIPtr<IContextMenuCallback2> spContext2 = pCallback;
    if( !spContext2 ) return E_NOINTERFACE;

    ASSERT( m_pRowItem->size() >= ROWITEM_USER_INDEX );    

	//--------------------------- *** HACK ALERT *** -----------------------------------------
	// One or more AD menu extensions allow window message processing while initializing
	// and getting menu items. This causes reentrancy problems because MMC message handlers
	// can execute before this method returns. Specifically, the following can happen:
	//
	//  1. The user right clicks in a taskpad list while the focus is elsewhere.
	//	2. The right button down event causes MMC to call this method to update task buttons.
	//  3. An AD menu extn processes messages allowing the button up event to go to MMC.
	//  4. MMC sees this as a context menu event and calls this method recursively.
	//  5. An AV occurs in nodemgr because a deleted COnContextMenu object is referenced.
	//
	// This can be prevented by not processing menu item requests when the right button is down.
	// The only time this occurs is during the above scenario. The only ill effect is that the
	// task buttons are not enabled until the mouse button up occurs when MMC gets the menu
	// items again.
	//-----------------------------------------------------------------------------------------
	if (GetKeyState(VK_RBUTTON) < 0)
		return S_OK;

    DisplayNameMap* pNameMap = DisplayNames::GetClassMap();
    if (pNameMap == NULL) 
        return E_FAIL;

    LPCWSTR pszClass = pNameMap->GetInternalName((*m_pRowItem)[ROWITEM_CLASS_INDEX]);

    // Get menu items for this class from the owning query node
    int iDefault = 0;
	BOOL bPropertyMenu;
    reinterpret_cast<CQueryNode*>(m_pRowItem->GetOwnerParam())->GetClassMenuItems(pszClass, m_vMenus, &iDefault, &bPropertyMenu);

    // Create a directory extension object and use it to get the actual menu cmds for the selected object
    // (we might have one already if AddMenuItems was called before)
    if (m_pADExt == NULL) 
        m_pADExt = new CActDirExt();

    if( !m_pADExt ) return E_OUTOFMEMORY;
    
    hr = m_pADExt->Initialize(pszClass, m_pRowItem->GetObjPath());
    RETURN_ON_FAILURE(hr);

    menu_vector vADMenus;

    hr = m_pADExt->GetMenuItems(vADMenus);
    RETURN_ON_FAILURE(hr);

    ASSERT(vADMenus.size() > 0);
    ASSERT(vADMenus.begin() != vADMenus.end());

    menucmd_vector::iterator itMenu;
    long lCmdID = 0;
    for (itMenu = m_vMenus.begin(); itMenu != m_vMenus.end(); ++itMenu, ++lCmdID) 
    {
        // if AD menu cmd and not enabled by the selected object, skip it
        if ( (*itMenu)->MenuType() == MENUTYPE_ACTDIR )
        {
            BOOL bFound = FALSE;
            menu_vector::iterator iter = vADMenus.begin();
            while(iter != vADMenus.end())
            {
                LPCWSTR pszName      = static_cast<CActDirMenuCmd*>((CMenuCmd*)(*itMenu))->ADName();
                LPCWSTR pszNoLocName = static_cast<CActDirMenuCmd*>((CMenuCmd*)(*itMenu))->ADNoLocName();
                if( pszNoLocName && wcslen(pszNoLocName) )
                {
                    if( _tcscmp(iter->strNoLoc.c_str(), pszNoLocName) == 0 )
                    {
                        bFound = TRUE;
                        break;
                    }                         
                }
                else if( pszName && _tcscmp(iter->strPlain.c_str(), pszName) == 0 )
                {
                    bFound = TRUE;
                    break;
                }
                iter++;
            }
            if (!bFound)
            {
                continue;
            }
        }        
        
        CONTEXTMENUITEM2 item;
        OLECHAR szGuid[50] = {0};            
        ::StringFromGUID2((*itMenu)->NoLocID(), szGuid, 50);

        item.strName = const_cast<LPWSTR>((*itMenu)->Name());
        item.strStatusBarText = L"";
        item.lCommandID = lCmdID;
        item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
        item.fFlags = 0;
        item.fSpecialFlags = (lCmdID == iDefault) ? CCM_SPECIAL_DEFAULT_ITEM : 0;
        item.strLanguageIndependentName = szGuid;

        hr = spContext2->AddItem(&item);        

        ASSERT(SUCCEEDED(hr));
    }

    return hr;
}


HRESULT
CQueryItem::QueryPagesFor()
{
    ASSERT(m_pRowItem != NULL && m_pRowItem->size() >= ROWITEM_USER_INDEX);
    ASSERT(m_spQueryNode != NULL);

    // Row item has class display name, so get internal name from class map
    DisplayNameMap* pNameMap = DisplayNames::GetClassMap();
    if (pNameMap == NULL) 
        return E_FAIL;

    LPCWSTR pszClass = pNameMap->GetInternalName((*m_pRowItem)[ROWITEM_CLASS_INDEX]);

    // Create a directory extension object    
    // (we might have one already if AddMenuItems was called before)
    if (m_pADExt == NULL) 
        m_pADExt = new CActDirExt();

    ASSERT(m_pADExt != NULL);
    if (m_pADExt == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = m_pADExt->Initialize(pszClass, m_pRowItem->GetObjPath());
    RETURN_ON_FAILURE(hr);

    hpage_vector vhPages;
    hr = m_pADExt->GetPropertyPages(vhPages);

    if (SUCCEEDED(hr) && vhPages.size() > 0) 
    {
        CPropertySheet sheet;

        // Set title to name of item
        // Can't use SetTitle becuase if wrongly asserts (pszText == NULL)
        sheet.m_psh.pszCaption = (*m_pRowItem)[ROWITEM_NAME_INDEX];
        sheet.m_psh.dwFlags |= PSH_PROPTITLE;
    
        hpage_vector::iterator itPage;
        for (itPage = vhPages.begin(); itPage != vhPages.end(); ++itPage) 
        {
           BOOL bStat = sheet.AddPage(*itPage);
           ASSERT(bStat);
        }
    
        sheet.DoModal(g_hwndMain);
    }

    return S_FALSE;
}


class CRefreshCallback : public CEventCallback
{
public:
    CRefreshCallback(HANDLE hProcess, CQueryableNode* pQueryNode)
        : m_hProcess(hProcess), m_spQueryNode(pQueryNode) {}
 
    virtual void Execute() 
    {
        if( m_spQueryNode )
        {
            m_spQueryNode->OnRefresh(NULL);
        }

        CloseHandle(m_hProcess);
    }

    HANDLE m_hProcess;
    CQueryableNodePtr m_spQueryNode;
};

HRESULT
CQueryItem::MenuCommand(LPCONSOLE2 pConsole, long lCommand)
{
    VALIDATE_POINTER(pConsole);

    ASSERT( lCommand < m_vMenus.size() && lCommand >= 0 );
    if( lCommand >= m_vMenus.size() || lCommand < 0 )
        return E_INVALIDARG;

    HRESULT hr = E_FAIL;
    switch (m_vMenus[lCommand]->MenuType())
    {
    case MENUTYPE_SHELL:
        {
            // Create a query Lookup object to translate the command parameters
            CQueryLookup lookup(m_spQueryNode, m_pRowItem);
    
            HANDLE hProcess = NULL;
            hr = static_cast<CShellMenuCmd*>((CMenuCmd*)m_vMenus[lCommand])->Execute(&lookup, &hProcess);

            // if process started and auto-refresh wanted, setup event-triggered callback
            if (SUCCEEDED(hr) && hProcess != NULL && m_vMenus[lCommand]->IsAutoRefresh()) 
            {
                CallbackOnEvent(hProcess, new CRefreshCallback(hProcess, m_spQueryNode));              
            }

            break;
        }

    case MENUTYPE_ACTDIR:
        {
            ASSERT(m_pADExt != NULL);
            BOMMENU bmMenu;
            bmMenu.strPlain = static_cast<CActDirMenuCmd*>((CMenuCmd*)m_vMenus[lCommand])->ADName();
            bmMenu.strNoLoc = static_cast<CActDirMenuCmd*>((CMenuCmd*)m_vMenus[lCommand])->ADNoLocName();
            hr = m_pADExt->Execute(&bmMenu);

            // if commans should auto-refresh, do it now
            if (SUCCEEDED(hr) && m_vMenus[lCommand]->IsAutoRefresh()) 
            {
                ASSERT(m_spQueryNode != NULL);
                m_spQueryNode->OnRefresh(NULL);
            }
            break;
        }
        
    default:
        ASSERT(0 && L"Unhandled menu command type");
    }

    return hr;
}


HRESULT CQueryItem::GetDataImpl(UINT cf, HGLOBAL* phGlobal)
{
    VALIDATE_POINTER( phGlobal );

    HRESULT hr = DV_E_FORMATETC;

    if (cf == m_cfDisplayName)
    {
        hr = DataToGlobal(phGlobal, (*m_pRowItem)[0], wcslen((*m_pRowItem)[0]) * sizeof(WCHAR));
    }
    else if (cf == m_cfSnapInClsid)
    {
        hr = DataToGlobal(phGlobal, &CLSID_BOMSnapIn, sizeof(GUID));
    }
    else if (cf == m_cfNodeType)
    {
        hr = DataToGlobal(phGlobal, &GUID_QueryItem, sizeof(GUID));
    }
    else if (cf == m_cfszNodeType)
    {
        WCHAR szGuid[GUID_STRING_LEN+1];
        StringFromGUID2(GUID_QueryItem, szGuid, GUID_STRING_LEN+1);

        hr = DataToGlobal(phGlobal, szGuid, GUID_STRING_SIZE);
    }
 
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\qryprop.h ===
// qryprop.h  - Query node property pages header file

#ifndef _QRYPROP_H_
#define _QRYPROP_H_

#include "scopenode.h"
#include "atlwin.h"
#include "atldlgs.h"
#include "atlctrls.h"
#include "rootprop.h"

#include <list>

class CQueryEditObj
{
public:
    CQueryEditObj(CQueryNode* pQueryNode) 
    {
        ASSERT(pQueryNode != NULL);
       
		m_spQueryNode = pQueryNode;

        if( pQueryNode )
        {
            m_vObjInfo    = pQueryNode->Objects();
		    m_vMenus      = pQueryNode->Menus();
        }

        m_iPageMax = -1;
        m_cRef     = 0;
    }
    
	HRESULT LoadStrings(IStringTable* pStringTable)
    {    
        menucmd_vector::iterator itMenuCmd;
        for (itMenuCmd = Menus().begin(); itMenuCmd != Menus().end(); ++itMenuCmd)
        {
            HRESULT hr = (*itMenuCmd)->LoadName(pStringTable);
            RETURN_ON_FAILURE(hr);
        }

        return S_OK;
    }

    void  PageActive(HWND hwndPage);  
    BOOL  ApplyChanges(HWND hwndPage);

	menucmd_vector& Menus() { return m_vMenus; }

    ULONG AddRef() { return ++m_cRef; }
    ULONG Release() 
    {
        ASSERT(m_cRef > 0);

        if (--m_cRef != 0) 
            return m_cRef; 
       
        delete this; 
        return 0;
    }


public:
    CComPtr<CQueryNode> m_spQueryNode;
    QueryObjVector      m_vObjInfo;
	menucmd_vector	    m_vMenus;   // Query Nodes now have menus

private:
    int m_iPageMax;
    int m_cRef;
};

class CQueryGeneralPage : public CPropertyPageImpl<CQueryGeneralPage>
{

public:
    typedef CPropertyPageImpl<CQueryGeneralPage> BC;

    // Constructor/destructor
    CQueryGeneralPage(CQueryEditObj* pEditObj);
    virtual ~CQueryGeneralPage();

    enum { IDD = IDD_QUERY_GENERAL_PAGE };

protected:
    BEGIN_MSG_MAP( CQueryGeneralPage )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CLOSE, OnClose)

        COMMAND_HANDLER(IDC_COMMENTS,   EN_CHANGE,  OnChange)
        COMMAND_HANDLER(IDC_QUERYSCOPE, BN_CLICKED, OnScopeChange)
        COMMAND_HANDLER(IDC_LOCALSCOPE, BN_CLICKED, OnScopeChange)
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // message handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnClose( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnScopeChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    // overrrides
    BOOL OnSetActive();
    BOOL OnApply();

private:
    CQueryEditObj& m_EditObject;
};


class CQueryMenuPage : public CPropertyPageImpl<CQueryMenuPage>
{
public:
    typedef CPropertyPageImpl<CQueryMenuPage> BC;

    CQueryMenuPage(CQueryEditObj* pEditObj);
    virtual ~CQueryMenuPage();

    enum { IDD = IDD_QUERY_MENU_PAGE };

protected:
    BEGIN_MSG_MAP( CQueryMenuPage )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        NOTIFY_HANDLER(IDC_MENULIST, LVN_ITEMCHANGED, OnMenuChanged)
        COMMAND_HANDLER(IDC_DEFAULTMENU, BN_CLICKED, OnDefaultChanged)
        COMMAND_HANDLER(IDC_OBJECTLIST, CBN_SELENDOK, OnObjectSelect)
        COMMAND_HANDLER(IDC_MOVEUP, BN_CLICKED, OnMoveUpDown)
        COMMAND_HANDLER(IDC_MOVEDOWN, BN_CLICKED, OnMoveUpDown);
		COMMAND_HANDLER(IDC_PROPERTYMENU, BN_CLICKED, OnPropertyMenuChanged)
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnMenuChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);
    LRESULT OnObjectSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnMoveUpDown( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnDefaultChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPropertyMenuChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    // overrrides       
    BOOL OnSetActive();
    BOOL OnApply();

    void DisplayMenus();
    void DisplayMenuItem(int iIndex, CMenuCmd* pMenuCmd, BOOL bEnabled);
    void SaveMenuSet();

private:
    CQueryEditObj&  m_EditObject;
    CComboBox       m_ObjectCB;
    CListViewEx     m_MenuLV;
    CQueryObjInfo*  m_pObjSel;
    BOOL            m_bLoading;
    BOOL            m_DefaultID;
};


class CQueryViewPage : public CPropertyPageImpl<CQueryViewPage>
{
public:
    typedef CPropertyPageImpl<CQueryViewPage> BC;

    CQueryViewPage(CQueryEditObj* pEditObj);
    virtual ~CQueryViewPage();

    enum { IDD = IDD_QUERY_VIEW_PAGE };


protected:
    BEGIN_MSG_MAP( CQueryViewPage )
        NOTIFY_HANDLER(IDC_COLUMNLIST, LVN_ITEMCHANGED, OnColumnChanged)
        NOTIFY_HANDLER(IDC_COLUMNLIST, LVN_COLUMNCLICK, OnColumnClick)
        COMMAND_HANDLER(IDC_OBJECTLIST, CBN_SELENDOK, OnObjectSelect )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnObjectSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnColumnChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);
    LRESULT OnColumnClick(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);

    // overrrides       
    BOOL OnSetActive();
    BOOL OnApply();

    void DisplayColumns();
    void SaveColumnSet();

private:
    CQueryEditObj&  m_EditObject;
    CQueryObjInfo*  m_pObjSel;
    CComboBox       m_ObjectCB;
    CListViewEx     m_ColumnLV;
    BOOL            m_bLoading;
};

class CQueryNodeMenuPage : public CPropertyPageImpl<CQueryNodeMenuPage>
{
public:
    typedef CPropertyPageImpl<CQueryNodeMenuPage> BC;

    CQueryNodeMenuPage(CQueryEditObj* pEditObj);
    virtual ~CQueryNodeMenuPage();

    enum { IDD = IDD_QUERY_NODE_MENU_PAGE };

protected:
    BEGIN_MSG_MAP( CQueryNodeMenuPage )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        NOTIFY_HANDLER(IDC_MENULIST, LVN_ITEMCHANGED, OnMenuListChanged)
        NOTIFY_HANDLER(IDC_MENULIST, NM_DBLCLK, OnMenuListDblClk)
        
        COMMAND_HANDLER(IDC_ADDMENU, BN_CLICKED, OnAddMenu)
        COMMAND_HANDLER(IDC_REMOVEMENU, BN_CLICKED, OnRemoveMenu)
        COMMAND_HANDLER(IDC_EDITMENU, BN_CLICKED, OnEditMenu)
        COMMAND_HANDLER(IDC_MOVEUP, BN_CLICKED, OnMoveUpDown)
        COMMAND_HANDLER(IDC_MOVEDOWN, BN_CLICKED, OnMoveUpDown);

    
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    
    LRESULT OnAddMenu( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnRemoveMenu( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnEditMenu( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
	LRESULT OnMoveUpDown( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    
	LRESULT OnMenuListChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);
    LRESULT OnMenuListDblClk(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);
    

    // overrrides       
    BOOL OnSetActive();
    BOOL OnApply();
    void OnFinalMessage(HWND) { delete this; }

    // implementation
    void DisplayMenus();

private:
    CListViewCtrl  m_MenuLV;    
    CQueryEditObj& m_EditObject;
};


#endif // _QRYPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\qrythrd.h ===
// qrythrd.h   Header for query thread 


//
// The bg thread communicates with the view using the following messages
//

#define DSQVM_ADDRESULTS            (WM_USER+0)         // lParam = HDPA containing results
#define DSQVM_FINISHED              (WM_USER+1)         // lParam = fMaxResult


//
// Column DSA contains these items
//

#define PROPERTY_ISUNDEFINED        0x00000000          // property is undefined
#define PROPERTY_ISUNKNOWN          0x00000001          // only operator is exacly
#define PROPERTY_ISSTRING           0x00000002          // starts with, ends with, is exactly, not equal
#define PROPERTY_ISNUMBER           0x00000003          // greater, less, equal, not equal
#define PROPERTY_ISBOOL             0x00000004          // equal, not equal

#define DEFAULT_WIDTH               20
#define DEFAULT_WIDTH_DESCRIPTION   40

typedef struct
{
    INT iPropertyType;                  // type of property
    union
    {
        LPTSTR pszText;                 // iPropertyType == PROPERTY_ISSTRING
        INT iValue;                     // iPropertyType == PROPERTY_ISNUMBER
    };
} COLUMNVALUE, * LPCOLUMNVALUE;

typedef struct
{
    BOOL fHasColumnHandler:1;           // column handler specified?
    LPWSTR pProperty;                   // property name
    LPTSTR pHeading;                    // column heading
    INT cx;                             // width of column (% of view)
    INT fmt;                            // formatting information
    INT iPropertyType;                  // type of property
    UINT idOperator;                    // currently selected operator
    COLUMNVALUE filter;                 // the filter applied
//    CLSID clsidColumnHandler;           // CLSID and IDsQueryColumnHandler objects
//    IDsQueryColumnHandler* pColumnHandler;
} COLUMN, * LPCOLUMN;

typedef struct
{
    LPWSTR pObjectClass;                // object class (UNICODE)
    LPWSTR pPath;                       // directory object (UNICODE)
    INT iImage;                         // image / == -1 if none
    COLUMNVALUE aColumn[1];             // column data
} QUERYRESULT, * LPQUERYRESULT;

//STDAPI CDsQuery_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

//
// The outside world commmunicates with the thread using messages (sent via PostThreadMessage).
//

#define RVTM_FIRST                  (WM_USER)
#define RVTM_LAST                   (WM_USER+32)

#define RVTM_STOPQUERY              (WM_USER)           // wParam = 0, lParam =0
#define RVTM_REFRESH                (WM_USER+1)         // wParam = 0, lParam = 0
#define RVTM_SETCOLUMNTABLE         (WM_USER+2)         // wParam = 0, lParam = HDSA columns


//
// THREADINITDATA strucutre, this is passed when the query thread is being
// created, it contains all the parameters required to issue the query,
// and populate the view.
//

typedef struct
{
    DWORD  dwReference;             // reference value for query
    LPWSTR pQuery;                  // base filter to be applied
    LPWSTR pScope;                  // scope to search
    LPWSTR pServer;                 // server to target
    LPWSTR pUserName;               // user name and password to authenticate with
    LPWSTR pPassword;
    BOOL   fShowHidden:1;           // show hidden objects in results
    HWND   hwndView;                // handle of our result view to be filled
//  HDSA   hdsaColumns;             // column table
} THREADINITDATA, * LPTHREADINITDATA;


//
// Query thread, this is passed the THREADINITDATA structure
//

DWORD WINAPI QueryThread(LPVOID pThreadParams);
VOID QueryThread_FreeThreadInitData(LPTHREADINITDATA* ppTID);

//STDAPI CQueryThreadCH_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\query.cpp ===
// query.cpp

#include "stdafx.h"
#include <cmnquery.h>
#include <dsquery.h>
#include <shlobj.h>
#include <dsclient.h>
#include <iads.h>
#include <adshlp.h>

#define SECURITY_WIN32
#include <security.h>   // TranslateName
#include <lmcons.h> 
#include <lmapibuf.h> // NetApiBufferFree
#include <dsgetdc.h>  // DsGetDCName

#include "query.h"
#include "rowitem.h"
#include "resource.h"
#include "namemap.h"

#include "atlgdi.h"
#include "util.h"

#include <list>

struct __declspec( uuid("ab50dec0-6f1d-11d0-a1c4-00aa00c16e65")) ICommonQuery;

typedef const BYTE* LPCBYTE;


HRESULT GetQuery(tstring& strScope, tstring& strQuery, byte_string& bsQueryData, HWND hWnd)
{

    // Get instance of common query object
    CComQIPtr<ICommonQuery, &IID_ICommonQuery> spQuery;
    HRESULT hr = spQuery.CoCreateInstance(CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER);
    RETURN_ON_FAILURE(hr);

    // Structure for DSQuery handler
    DSQUERYINITPARAMS dqip;
    memset(&dqip, 0, sizeof(dqip));

    dqip.cbStruct = sizeof(dqip);
    dqip.dwFlags = DSQPF_NOSAVE | DSQPF_ENABLEADMINFEATURES | DSQPF_ENABLEADVANCEDFEATURES;
    dqip.pDefaultScope = (LPTSTR)strScope.c_str();

    // Structure for common query 
    OPENQUERYWINDOW oqw;
    memset(&oqw, 0, sizeof(oqw));

    oqw.cbStruct = sizeof(oqw);
    oqw.dwFlags = OQWF_SHOWOPTIONAL | OQWF_OKCANCEL | OQWF_HIDESEARCHUI | OQWF_SAVEQUERYONOK | OQWF_HIDEMENUS;
    oqw.clsidHandler = CLSID_DsQuery;
    oqw.pHandlerParameters = &dqip;

    CPersistQuery persistQuery;
    oqw.pPersistQuery = (IPersistQuery*)&persistQuery;

    if( !bsQueryData.empty() )
    {
        persistQuery.Load(bsQueryData, strScope);
        oqw.dwFlags |= OQWF_LOADQUERY;
    }

    CComPtr<IDataObject> spDO;
    hr = spQuery->OpenQueryWindow(hWnd, &oqw, &spDO);

    // if failed to open query window on persisted query
    if( FAILED(hr) && !bsQueryData.empty() )
    {
        // See if there is a problem with the scope
        CComPtr<IUnknown> spUnk;
        if( ADsOpenObject(strScope.c_str(), NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IUnknown, (LPVOID*)&spUnk) != S_OK )
        {
            // if so, try again with a null scope 
            tstring strNullScope;
            persistQuery.Load(bsQueryData, strNullScope);

            hr = spQuery->OpenQueryWindow(hWnd, &oqw, &spDO);
        }
    }

    if( SUCCEEDED(hr) && spDO != NULL )
    {
        FORMATETC fmte = {0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM medium = { TYMED_NULL, NULL, NULL};

        static UINT s_cfDsQueryParams = 0;
        if( !s_cfDsQueryParams )
            s_cfDsQueryParams = RegisterClipboardFormat(CFSTR_DSQUERYPARAMS);

        fmte.cfFormat = (CLIPFORMAT)s_cfDsQueryParams;  

        if( SUCCEEDED(spDO->GetData(&fmte, &medium)) )
        {
            LPDSQUERYPARAMS pDsQueryParams = (LPDSQUERYPARAMS)medium.hGlobal;
            LPWSTR pFilter = (LPWSTR)((CHAR*)pDsQueryParams + pDsQueryParams->offsetQuery);
            strQuery = pFilter;

            ReleaseStgMedium(&medium);
        }

        static UINT s_cfDsQueryScope = 0;
        if( !s_cfDsQueryScope )
            s_cfDsQueryScope = RegisterClipboardFormat(CFSTR_DSQUERYSCOPE);

        fmte.cfFormat = (CLIPFORMAT)s_cfDsQueryScope;  

        if( SUCCEEDED(spDO->GetData(&fmte, &medium)) )
        {
            strScope = (LPWSTR)medium.hGlobal;

            ReleaseStgMedium(&medium);
        }

        persistQuery.Save(bsQueryData);
    }


    return hr; 
}


/////////////////////////////////////////////////////////////////////////////////////////
// CPersistQuery
//

/*-----------------------------------------------------------------------------
/ Constructor / IUnknown methods
/----------------------------------------------------------------------------*/

CPersistQuery::CPersistQuery()
{
    m_cRefCount = 1;
}

//
// IUnknown methods
//

STDMETHODIMP CPersistQuery::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
    VALIDATE_POINTER( ppvObject );

    if( IsEqualIID(riid, IID_IPersistQuery) )
    {
        *ppvObject = (LPVOID)(IPersistQuery*)this;
        return S_OK;
    }

    return E_NOTIMPL;
}

STDMETHODIMP_(ULONG) CPersistQuery::AddRef()
{
    return ++m_cRefCount;
}

STDMETHODIMP_(ULONG) CPersistQuery::Release()
{
    if( --m_cRefCount == 0 )
    {
        delete this;
        return 0;
    }

    return m_cRefCount;
}


/*-----------------------------------------------------------------------------
/ IPersist methods
/----------------------------------------------------------------------------*/

STDMETHODIMP CPersistQuery::GetClassID(THIS_ CLSID* pClassID)
{
    return E_NOTIMPL;
}


/*-----------------------------------------------------------------------------
/ IPersistQuery methods
/----------------------------------------------------------------------------*/


STDMETHODIMP CPersistQuery::WriteString(LPCTSTR pSection, LPCTSTR pKey, LPCTSTR pValue)
{
    if( pValue == NULL )
        return E_INVALIDARG;

    return WriteStruct(pSection, pKey, (LPVOID)pValue, (wcslen(pValue) + 1) * sizeof(WCHAR));
}


STDMETHODIMP CPersistQuery::WriteInt(LPCTSTR pSection, LPCTSTR pKey, INT value)
{
    return WriteStruct(pSection, pKey, (LPVOID)&value, sizeof(int));
}


STDMETHODIMP CPersistQuery::WriteStruct(LPCTSTR pSection, LPCTSTR pKey, LPVOID pStruct, DWORD cbStruct)
{
    if( pSection == NULL || pKey == NULL || pStruct == NULL )
        return E_INVALIDARG;

    LPBYTE pData = (LPBYTE)malloc(cbStruct + sizeof(DWORD));
    if( !pData ) return E_OUTOFMEMORY;

    *(LPDWORD)pData = cbStruct;
    memcpy(pData + sizeof(DWORD), pStruct, cbStruct);

    m_mapQueryData[pSection][pKey] = std::auto_ptr<BYTE>(pData);

    return S_OK;
}


STDMETHODIMP CPersistQuery::ReadString(LPCTSTR pSection, LPCTSTR pKey, LPTSTR pBuffer, INT cchBuffer)
{
    return ReadStruct(pSection, pKey, (LPVOID)pBuffer, cchBuffer);
}


STDMETHODIMP CPersistQuery::ReadInt(LPCTSTR pSection, LPCTSTR pKey, LPINT pValue)
{
    return ReadStruct(pSection, pKey, (LPVOID)pValue, sizeof(INT));
}


STDMETHODIMP CPersistQuery::ReadStruct(LPCTSTR pSection, LPCTSTR pKey, LPVOID pStruct, DWORD cbStruct)
{
    VALIDATE_POINTER( pStruct );

    QueryDataMap::iterator itDataMap = m_mapQueryData.find(pSection);
    if( itDataMap == m_mapQueryData.end() )
        return E_FAIL;

    QuerySectionMap::iterator itSecMap = itDataMap->second.find(pKey);
    if( itSecMap == itDataMap->second.end() )
        return E_FAIL;

    LPBYTE pData = itSecMap->second.get();
    DWORD cbData = pData ? *(LPDWORD)pData : 0;

    if( cbData > cbStruct )
        return E_FAIL;

    // return value
    memcpy(pStruct, pData + sizeof(DWORD), cbData);

    return S_OK;
}


STDMETHODIMP CPersistQuery::Clear()
{
    m_mapQueryData.clear();

    return S_OK;
}


void PutString(byte_string& strOut, const tstring& strData)
{
    DWORD dwLen = strData.size();

    strOut.append((LPBYTE)&dwLen, sizeof(DWORD));
    strOut.append((LPBYTE)strData.data(), dwLen * sizeof(WCHAR));
}


HRESULT CPersistQuery::Save(byte_string& strOut)
{
    strOut.resize(0);

    DWORD dwSize;

    QueryDataMap::iterator itDataMap;
    for( itDataMap = m_mapQueryData.begin(); itDataMap != m_mapQueryData.end(); itDataMap++ )
    {
        const tstring& strSecName = itDataMap->first;
        QuerySectionMap& SecMap = itDataMap->second;

        PutString(strOut, strSecName);

        QuerySectionMap::iterator itSecMap;
        for( itSecMap = SecMap.begin(); itSecMap != SecMap.end(); itSecMap++ )
        {
            const tstring& strValueName = itSecMap->first;
            LPBYTE pData = itSecMap->second.get();

            if( pData )
            {
                PutString(strOut, strValueName);
                strOut.append(pData, *(LPDWORD)pData + sizeof(DWORD));
            }
        }

        dwSize = 0;
        strOut.append((LPBYTE)&dwSize, sizeof(DWORD));
    }

    dwSize = 0;
    strOut.append((LPBYTE)&dwSize, sizeof(DWORD));

    return S_OK;
}


BOOL GetString(LPCBYTE& pbIn, tstring& strData)
{
    if( !pbIn ) return FALSE;

    DWORD dwLen = *(LPDWORD)pbIn;
    pbIn += sizeof(DWORD);

    if( dwLen != 0 )
    {
        strData.assign((LPWSTR)pbIn, dwLen);
        pbIn += dwLen * sizeof(WCHAR);
    }

    return(dwLen != 0);
}


HRESULT CPersistQuery::Load(byte_string& strIn, tstring& strScope)
{
    m_mapQueryData.clear();

    LPCBYTE pData = strIn.data();
    if( !pData ) return E_INVALIDARG;

    tstring strSecName;

    while( GetString(pData, strSecName) )
    {
        QuerySectionMap& SecMap = m_mapQueryData[strSecName];

        tstring strName;
        while( GetString(pData, strName) )
        {
            DWORD dwSize = *(LPDWORD)pData + sizeof(DWORD);         

            if( strName == _T("Value0") )
            {
                tstring strQueryTmp = (LPCWSTR)(pData+sizeof(DWORD));
                ExpandDCWildCard(strQueryTmp);            
                DWORD dwStringSize = strQueryTmp.size() ? ((strQueryTmp.size() + 1) * sizeof(wchar_t)) : 0;            

                LPDWORD pdwBuf = (LPDWORD)malloc(dwStringSize + sizeof(DWORD));
                if( pdwBuf == NULL )
                {
                    return E_OUTOFMEMORY;
                }

                pdwBuf[0] = dwStringSize;            
                memcpy(pdwBuf+1, strQueryTmp.c_str(), dwStringSize);            
                SecMap[strName] = std::auto_ptr<BYTE>((LPBYTE)pdwBuf);
            }
            else
            {
                LPBYTE pBuf = (LPBYTE)malloc(dwSize);
                if( pBuf == NULL )
                    return E_OUTOFMEMORY;

                memcpy(pBuf, pData, dwSize);
                SecMap[strName] = std::auto_ptr<BYTE>(pBuf);
            }                 

            pData += dwSize;
        }

        // if DsQuery section, override the persisted scope & scope size values
        // with our own. This is necessary when the local scope option is specified
        // because then the scope is determined at run-time and may be different than
        // the persisted value.
        if( strSecName == _T("DsQuery") )
        {
            DWORD dwScopeSize = strScope.size() ? ((strScope.size() + 1) * sizeof(wchar_t)) : 0;

            // add scope size integer equal to byte length of scope string
            LPDWORD pdwBuf = (LPDWORD)malloc(2 * sizeof(DWORD));
            if( pdwBuf == NULL )
            {
                return E_OUTOFMEMORY;
            }

            pdwBuf[0] = sizeof(DWORD);
            pdwBuf[1] = dwScopeSize;
            SecMap[_T("ScopeSize")] = std::auto_ptr<BYTE>((LPBYTE)pdwBuf);

            // add scope string value
            if( dwScopeSize )
            {
                pdwBuf = (LPDWORD)malloc(dwScopeSize + sizeof(DWORD));
                if( pdwBuf == NULL )
                {
                    return E_OUTOFMEMORY;
                }

                pdwBuf[0] = dwScopeSize;
                memcpy(pdwBuf+1, strScope.c_str(), dwScopeSize);
                SecMap[_T("Scope")] = std::auto_ptr<BYTE>((LPBYTE)pdwBuf);              
            }
        }
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Query Utility Functions
//

HRESULT GetQueryScope(HWND hDlg, tstring& strScope)
{
    DSBROWSEINFO dsbi;
    TCHAR szBuffer[MAX_PATH] = {0};

    tstring strCaption = StrLoadString(IDS_SCOPEBROWSE_CAPTION);
    tstring strTitle   = StrLoadString(IDS_SELECTSCOPE);

    dsbi.cbStruct    = sizeof(dsbi);
    dsbi.hwndOwner   = hDlg;
    dsbi.pszCaption  = strCaption.c_str();
    dsbi.pszTitle    = strTitle.c_str();
    dsbi.pszRoot     = NULL;
    dsbi.pszPath     = szBuffer;
    dsbi.cchPath     = lengthof(szBuffer);
    dsbi.dwFlags     = DSBI_ENTIREDIRECTORY;
    dsbi.pfnCallback = NULL;
    dsbi.lParam      = (LPARAM)0;

    if( !strScope.empty() && strScope.size() < MAX_PATH )
    {
        lstrcpyn( szBuffer, strScope.c_str(), MAX_PATH );
        dsbi.dwFlags |= DSBI_EXPANDONOPEN;
    }

    HRESULT hr = S_FALSE;

    if( IDOK == DsBrowseForContainer(&dsbi) )
    {
        strScope = szBuffer;
        hr = S_OK;
    }

    return hr;
}


void GetScopeDisplayString(tstring& strScope, tstring& strDisplay)
{
    strDisplay.erase();

    if( !strScope.empty() )
    {
        LPCWSTR pszScope = strScope.c_str();

        // Special case for GC: use display name "Entire Directory"
        if( _wcsnicmp(L"GC:", pszScope, 3) == 0 )
        {
            CString strDir;
            strDir.LoadString(IDS_ENTIRE_DIRECTORY);
            strDisplay = strDir;
        }
        else
        {
            if( _wcsnicmp(L"LDAP://", pszScope, 7) == 0 )
                pszScope += 7;

            WCHAR szBuf[MAX_PATH];    
            ULONG cBuf = MAX_PATH;
            BOOL bStat = TranslateName(pszScope, NameFullyQualifiedDN, NameCanonical, szBuf, &cBuf);
            if( bStat )
            {
                int nLen = wcslen(szBuf);
                if( (nLen > 0) && (szBuf[nLen-1] == L'/') )
                    nLen--;

                strDisplay.assign(szBuf, nLen);
            }
            else
            {
                strDisplay = strScope;
            }
        }
    }
}


void GetFullyQualifiedScopeString(tstring& strScope, tstring& strQualified)
{
    strQualified.erase();
    if( !strScope.empty() )
    {
        // TranslateName expects a trailing '/' on a canonical domain name
        tstring strTmp = strScope;
        strTmp += L"/";

        WCHAR* pszBuf = NULL;    
        ULONG  cBuf  = 0;
        BOOL bStat = TranslateName(strTmp.c_str(), NameCanonical, NameFullyQualifiedDN, pszBuf, &cBuf);        
        if( cBuf )
        {
            pszBuf = new WCHAR[cBuf];
            if( pszBuf )
            {
                bStat = TranslateName(strTmp.c_str(), NameCanonical, NameFullyQualifiedDN, pszBuf, &cBuf);
            }
        }

        if( bStat )
        {
            strQualified = L"LDAP://";
            strQualified += pszBuf;
        }
        else
        {
            strQualified = strScope;
        }        
        
        if( pszBuf )
        {
            delete [] pszBuf;
        }
    }
}


LPCWSTR GetLocalDomain()
{
    static tstring strLocDomain;

    if( !strLocDomain.empty() )
        return strLocDomain.c_str();

    DOMAIN_CONTROLLER_INFO* pDcInfo = NULL;
    DWORD dwStat = DsGetDcName(NULL, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED|DS_RETURN_DNS_NAME, &pDcInfo);

    if( dwStat == NO_ERROR && pDcInfo != NULL )
    {
        tstring str = pDcInfo->DomainName;
        GetFullyQualifiedScopeString(str, strLocDomain);

        NetApiBufferFree(pDcInfo);
    }

    return strLocDomain.c_str();
}


HRESULT GetNamingContext(NameContextType ctx, LPCWSTR* ppszContextDN)
{
    VALIDATE_POINTER( ppszContextDN );

    const static LPCWSTR pszContextName[NAMECTX_COUNT] = { L"schemaNamingContext", L"configurationNamingContext"};
    static tstring strContextDN[NAMECTX_COUNT];

    HRESULT hr = S_OK;

    if( strContextDN[ctx].empty() )
    {
        CComVariant var;
        CComPtr<IADs> pObj;

        hr = ADsGetObject(L"LDAP://rootDSE", IID_IADs, (void**)&pObj);
        if( SUCCEEDED(hr) )
        {
            CComBSTR bstrProp = const_cast<LPWSTR>(pszContextName[ctx]);
            hr = pObj->Get( bstrProp, &var );
            if( SUCCEEDED(hr) )
            {
                strContextDN[ctx] = var.bstrVal;
                *ppszContextDN = strContextDN[ctx].c_str();
            }
        }
    }
    else
    {
        *ppszContextDN = strContextDN[ctx].c_str();
        hr = S_OK;
    }

    return hr;
}


HRESULT GetClassesOfCategory(IDirectorySearch* pDirSrch, tstring& strCategory, std::set<tstring>& setClasses)
{
    VALIDATE_POINTER( pDirSrch );

    // Form query filter for class with class/category name
    tstring strFilter = L"(&(objectCategory=classSchema)(ldapDisplayName=";
    strFilter += strCategory;
    strFilter += L"))";

    // Query for category that class belongs to
    ADS_SEARCH_HANDLE hSearch;    
    LPWSTR pszDn = L"defaultObjectCategory";
    HRESULT hr = pDirSrch->ExecuteSearch(const_cast<LPWSTR>(strFilter.c_str()), &pszDn, 1, &hSearch);

    if( SUCCEEDED(hr) )
    {
        hr = pDirSrch->GetFirstRow(hSearch);

        if( hr == S_OK )
        {
            ADS_SEARCH_COLUMN col;
            hr = pDirSrch->GetColumn(hSearch, pszDn, &col);

            if( SUCCEEDED(hr) )
            {
                // Form query filter for all structure classes belonging to this category 
                strFilter = L"(&(objectCategory=classSchema)(objectClassCategory=1)(defaultObjectCategory=";
                strFilter += col.pADsValues->DNString;
                strFilter += L"))";

                // Query for LDAP name of each class
                ADS_SEARCH_HANDLE hSearch2;            
                LPWSTR pszName = L"ldapDisplayName";
                hr = pDirSrch->ExecuteSearch(const_cast<LPWSTR>(strFilter.c_str()), &pszName, 1, &hSearch2);

                if( SUCCEEDED(hr) )
                {
                    HRESULT hr2;
                    while( (hr2 = pDirSrch->GetNextRow(hSearch2)) == S_OK )
                    {
                        ADS_SEARCH_COLUMN col2;
                        hr2 = pDirSrch->GetColumn(hSearch2, pszName, &col2);

                        if( SUCCEEDED(hr2) )
                        {
                            setClasses.insert(col2.pADsValues->CaseIgnoreString);
                            pDirSrch->FreeColumn(&col2);
                        }
                    }

                    pDirSrch->CloseSearchHandle(hSearch2);
                }

                pDirSrch->FreeColumn(&col);
            }
        }

        pDirSrch->CloseSearchHandle(hSearch);

    }

    return hr;
}

HRESULT GetSubclassesOfClass(IDirectorySearch* pDirSrch, tstring& strClass, std::set<tstring>& setClasses)
{
    VALIDATE_POINTER( pDirSrch );

    // Form query filter for classes that derive from this class
    tstring strFilter = L"(&(objectCategory=classSchema)(subClassOf=";
    strFilter += strClass;
    strFilter += L"))";

    // Get display names of subclasses
    ADS_SEARCH_HANDLE hSearch;    
    LPWSTR pszName = L"lDAPDisplayName";
    HRESULT hr = pDirSrch->ExecuteSearch(const_cast<LPWSTR>(strFilter.c_str()), &pszName, 1, &hSearch);

    if( SUCCEEDED(hr) )
    {
        while( (hr = pDirSrch->GetNextRow(hSearch)) == S_OK )
        {
            ADS_SEARCH_COLUMN col;
            hr = pDirSrch->GetColumn(hSearch, pszName, &col);

            if( SUCCEEDED(hr) )
            {
                tstring strSubclass = col.pADsValues->CaseIgnoreString;
                pDirSrch->FreeColumn(&col);

                setClasses.insert(strSubclass);
                GetSubclassesOfClass(pDirSrch, strSubclass, setClasses);
            }
        }
        
        pDirSrch->CloseSearchHandle( hSearch );
    }

    return hr;
}


HRESULT GetQueryClasses(tstring& strQuery, std::set<tstring>& setClasses)
{
    // Create a schema directory search object
    LPCWSTR pszSchemaDN;
    HRESULT hr = GetNamingContext(NAMECTX_SCHEMA, &pszSchemaDN);
    RETURN_ON_FAILURE(hr);

    tstring strScope = L"LDAP://";
    strScope += pszSchemaDN;

    CComPtr<IDirectorySearch> spDirSrch;
    hr = ADsOpenObject(strScope.c_str(), NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID*)&spDirSrch);
    RETURN_ON_FAILURE(hr)

    // Set search preferences
    ADS_SEARCHPREF_INFO prefInfo[2];

    prefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;     // sub-tree search
    prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[0].vValue.Integer = ADS_SCOPE_ONELEVEL;

    prefInfo[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;         // paged results
    prefInfo[1].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[1].vValue.Integer = 64;

    hr = spDirSrch->SetSearchPreference( prefInfo, lengthof(prefInfo) );
    RETURN_ON_FAILURE(hr)

#define CAT_PROP L"(objectCategory="
#define CLS_PROP L"(objectClass="

    UINT uPos = 0;
    while( (uPos = strQuery.find(CAT_PROP, uPos)) != tstring::npos )
    {
        uPos += wcslen(CAT_PROP);
        UINT uEnd = strQuery.find(L")", uPos);
        if( uEnd != tstring::npos )
        {
            tstring strCat = strQuery.substr(uPos, uEnd - uPos);
            hr = GetClassesOfCategory(spDirSrch, strCat, setClasses);
        }
        uPos = uEnd;
    }

    uPos = 0;
    while( (uPos = strQuery.find(CLS_PROP, uPos)) != tstring::npos )
    {
        uPos += wcslen(CLS_PROP);
        UINT uEnd = strQuery.find(L")", uPos);
        if( uEnd != tstring::npos )
        {
            tstring strClass = strQuery.substr(uPos, uEnd - uPos);
            setClasses.insert(strClass);
            hr = GetSubclassesOfClass(spDirSrch, strClass, setClasses);
        }
        uPos = uEnd;
    }

    // get lower case version of query string
    LPWSTR pszQueryLC = new WCHAR[(strQuery.size() + 1)];
    if( !pszQueryLC ) return E_OUTOFMEMORY;

    wcscpy(pszQueryLC, strQuery.c_str());
    _wcslwr(pszQueryLC);

    // check for non-class related queries generated by DSQuery
    if( wcsstr(pszQueryLC, L"(ou>=\"\")") != NULL )
        setClasses.insert(L"organizationalUnit");

    if( wcsstr(pszQueryLC, L"(samaccounttype=805306369)") != NULL ||
        wcsstr(pszQueryLC, L"(primarygroupid=516)") != NULL )
        setClasses.insert(L"computer");

    delete [] pszQueryLC;

    return hr;
}

HRESULT FindClassObject(LPCWSTR pszClass, tstring& strObjPath)
{
    VALIDATE_POINTER( pszClass );

    CComPtr<IDirectorySearch> spDirSrch;
    HRESULT hr = ADsOpenObject(GetLocalDomain(), NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID*)&spDirSrch);
    RETURN_ON_FAILURE(hr)

    // Set search preferences - search sub-tree for single object
    ADS_SEARCHPREF_INFO prefInfo[2];

    prefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;     // sub-tree search
    prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[0].vValue.Integer = ADS_SCOPE_SUBTREE;

    prefInfo[1].dwSearchPref = ADS_SEARCHPREF_SIZE_LIMIT;        // single object
    prefInfo[1].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[1].vValue.Integer = 1;

    hr = spDirSrch->SetSearchPreference(prefInfo, lengthof(prefInfo));
    RETURN_ON_FAILURE(hr)

    // Set filter string to (&(ObjectCategory=class_name)(objectClass=class_name))
    tstring strFilter = L"(&(objectCategory=";
    strFilter += pszClass;
    strFilter += L")(objectClass=";
    strFilter += pszClass;
    strFilter += L"))";

    // Query for distinguished name of class
    ADS_SEARCH_HANDLE hSearch;    
    LPWSTR pszDn = L"distinguishedName";
    hr = spDirSrch->ExecuteSearch(const_cast<LPWSTR>(strFilter.c_str()), &pszDn, 1, &hSearch);

    if( SUCCEEDED(hr) )
    {
        hr = spDirSrch->GetFirstRow(hSearch);

        if( hr == S_OK )
        {
            ADS_SEARCH_COLUMN col;
            hr = spDirSrch->GetColumn(hSearch, pszDn, &col);

            if( SUCCEEDED(hr) )
            {
                strObjPath = col.pADsValues->DNString;
                spDirSrch->FreeColumn(&col);
            }
        }

        spDirSrch->CloseSearchHandle(hSearch);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\query.h ===
// query.h  - header file for query functions

#ifndef _QUERY_H_
#define _QUERY_H_

#include <cmnquery.h>
#include <list>
#include <set>
#include <map>


enum NameContextType
{
    NAMECTX_SCHEMA = 0,
    NAMECTX_CONFIG = 1,
    NAMECTX_COUNT
};


///////////////////////////////////////////////////////////////////////////////////////
// class CPersistQuery
//

typedef std::map< tstring, std::auto_ptr<BYTE> > QuerySectionMap;
typedef std::map< tstring, QuerySectionMap > QueryDataMap;

interface IPersistQuery;

class CPersistQuery : public IPersistQuery
{

public:
    CPersistQuery();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IPersist
    STDMETHOD(GetClassID)(THIS_ CLSID* pClassID);

    // IPersistQuery
    STDMETHOD(WriteString)(THIS_ LPCTSTR pSection, LPCTSTR pValueName, LPCTSTR pValue);
    STDMETHOD(ReadString)(THIS_ LPCTSTR pSection, LPCTSTR pValueName, LPTSTR pBuffer, INT cchBuffer);
    STDMETHOD(WriteInt)(THIS_ LPCTSTR pSection, LPCTSTR pValueName, INT value);
    STDMETHOD(ReadInt)(THIS_ LPCTSTR pSection, LPCTSTR pValueName, LPINT pValue);
    STDMETHOD(WriteStruct)(THIS_ LPCTSTR pSection, LPCTSTR pValueName, LPVOID pStruct, DWORD cbStruct);
    STDMETHOD(ReadStruct)(THIS_ LPCTSTR pSection, LPCTSTR pValueName, LPVOID pStruct, DWORD cbStruct);
    STDMETHOD(Clear)(THIS);

    HRESULT Save(byte_string& strOut);
    HRESULT Load(byte_string& strIn, tstring& strScope);

private:
    ULONG m_cRefCount;
    QueryDataMap m_mapQueryData;
};

/////////////////////////////////////////////////////////////////////////////////////
// Query Helper Functions
//
HRESULT GetQuery(tstring& strScope, tstring& strQuery, byte_string& bsQueryData, HWND hWnd);
HRESULT GetQueryClasses(tstring& strQuery, std::set<tstring>& setClasses);
HRESULT GetQueryScope(HWND hDlg, tstring& strScope);
HRESULT GetNamingContext(NameContextType ctx, LPCWSTR* ppszContextDN);
HRESULT FindClassObject(LPCWSTR pszClass, tstring& strObjPath);


LPCWSTR GetLocalDomain();

void    GetScopeDisplayString(tstring& strScope, tstring& strDisplay);
void    GetFullyQualifiedScopeString(tstring& strScope, tstring& strQualified);

#endif // _QUERY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\qrythrd.cpp ===
#include "stdafx.h"
#include "qrythrd.h"


HRESULT 
IssueQuery(LPTHREADDATA ptd)
{
    HRESULT hres;
    DWORD dwres;
    LPTHREADINITDATA ptid = ptd->ptid;
    LPWSTR pQuery = NULL;
    INT cItems, iColumn;
    INT cMaxResult = MAX_RESULT;
    BOOL fStopQuery = FALSE;
    IDirectorySearch* pDsSearch = NULL;
    LPWSTR pszTempPath = NULL;
    IDsDisplaySpecifier *pdds = NULL;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCHPREF_INFO prefInfo[3];
    ADS_SEARCH_COLUMN column;
    HDPA hdpaResults = NULL;
    LPQUERYRESULT pResult = NULL;
    WCHAR szBuffer[2048];               // MAX_URL_LENGHT
    INT resid;
    LPWSTR pColumnData = NULL;
    HKEY hkPolicy = NULL;
    USES_CONVERSION;

    TraceEnter(TRACE_QUERYTHREAD, "QueryThread_IssueQuery");    

    // The foreground gave us a query so we are going to go and issue
    // it now, having done this we will then be able to stream the 
    // result blobs back to the caller. 

    hres = QueryThread_GetFilter(&pQuery, ptid->pQuery, ptid->fShowHidden);
    FailGracefully(hres, "Failed to build LDAP query from scope, parameters + filter");

    Trace(TEXT("Query is: %s"), W2T(pQuery));
    Trace(TEXT("Scope is: %s"), W2T(ptid->pScope));
    
    // Get the IDsDisplaySpecifier interface:

    hres = CoCreateInstance(CLSID_DsDisplaySpecifier, NULL, CLSCTX_INPROC_SERVER, IID_IDsDisplaySpecifier, (void **)&pdds);
    FailGracefully(hres, "Failed to get the IDsDisplaySpecifier object");

    hres = pdds->SetServer(ptid->pServer, ptid->pUserName, ptid->pPassword, DSSSF_DSAVAILABLE);
    FailGracefully(hres, "Failed to server information");

    // initialize the query engine, specifying the scope, and the search parameters

    hres = QueryThread_BuildPropertyList(ptd);
    FailGracefully(hres, "Failed to build property array to query for");

    hres = ADsOpenObject(ptid->pScope, ptid->pUserName, ptid->pPassword, ADS_SECURE_AUTHENTICATION,
                            IID_IDirectorySearch, (LPVOID*)&pDsSearch);

    FailGracefully(hres, "Failed to get the IDirectorySearch interface for the given scope");

    prefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;     // sub-tree search
    prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[0].vValue.Integer = ADS_SCOPE_SUBTREE;

    prefInfo[1].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;     // async
    prefInfo[1].vValue.dwType = ADSTYPE_BOOLEAN;
    prefInfo[1].vValue.Boolean = TRUE;

    prefInfo[2].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;         // paged results
    prefInfo[2].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[2].vValue.Integer = PAGE_SIZE;

    hres = pDsSearch->SetSearchPreference(prefInfo, ARRAYSIZE(prefInfo));
    FailGracefully(hres, "Failed to set search preferences");

    hres = pDsSearch->ExecuteSearch(pQuery, ptd->aProperties, ptd->cProperties, &hSearch);
    FailGracefully(hres, "Failed in ExecuteSearch");

    // pick up the policy value which defines the max results we are going to use

    dwres = RegOpenKey(HKEY_CURRENT_USER, DS_POLICY, &hkPolicy);
    if ( ERROR_SUCCESS == dwres )
    {
        DWORD dwType, cbSize;

        dwres = RegQueryValueEx(hkPolicy, TEXT("QueryLimit"), NULL, &dwType, NULL, &cbSize);
        if ( (ERROR_SUCCESS == dwres) && (dwType == REG_DWORD) && (cbSize == SIZEOF(cMaxResult)) )
        {
            RegQueryValueEx(hkPolicy, TEXT("QueryLimit"), NULL, NULL, (LPBYTE)&cMaxResult, &cbSize);
        }

        RegCloseKey(hkPolicy);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\resource.h ===
#define IDR_BOMSNAP                     102
#define IDR_ABOUT                       103
#define IDS_SCOPENODE_DESC              104
#define IDS_DATAOBJECT_DESC             105
#define IDS_SNAPIN_DESC                 106
#define IDS_COLUMNHEADER                109
#define IDS_OBJECTCLASS                 110
#define IDS_YES                         111
#define IDS_NO                          112
#define IDS_NONE                        113
#define IDS_NAME                        114
#define IDS_TYPE                        115
#define IDS_SHELLCMD                    116
#define IDS_ACTDIRCMD                   117
#define IDS_DESCRIPTION                 118
#define IDS_MENUITEM                    119

#define IDS_ERRORTITLE_EDITQUERY        120
#define IDS_ERROR_EDITQUERY             121
#define IDS_ERRORTITLE_MENUNAME         122
#define IDS_ERROR_BADACCESSKEY          123
#define IDS_ERROR_MULTIACCESSKEY        124
#define IDS_ERRORTITLE_MENUCMD          125
#define IDS_ERROR_MENUCMD               126
#define IDS_ERRORTITLE_STARTDIR         127 
#define IDS_ERROR_STARTDIR              128
#define IDS_SELECT_STARTDIR             129

#define IDS_QUERYWIZ_TITLE              130   
#define IDS_QUERYWIZ_SUBTITLE           131
#define IDS_MENUWIZ_TITLE               132
#define IDS_MENUWIZ_SUBTITLE            133
#define IDS_PROPWIZ_TITLE               134
#define IDS_PROPWIZ_SUBTITLE            135
#define IDS_OBJSELWIZ_TITLE             136
#define IDS_OBJSELWIZ_SUBTITLE          137
#define IDS_DISPSPEC                    138
#define IDS_SCOPEBROWSE_CAPTION         139
#define IDS_SELECTSCOPE                 140

#define IDS_ERROR_DUPMENUNAME           141
#define IDS_ERROR_ADDOBJ                142
#define IDS_ERROR_ADDMENU               143
#define IDS_ERROR_ADDPROP               144
#define IDS_ERROR_ADDQUERY              145
#define IDS_ERROR_QUERYFAIL             146

#define IDS_QUERYFINISH1                147
#define IDS_QUERYFINISH2                148        
#define IDS_QUERYFINISH3                149
#define IDS_QUERYFINISH4                150

#define IDS_QUERYWIZ_CANCEL             151
#define IDS_OBJWIZ_CANCEL               152
#define IDS_PROP_REMOVE_TITLE           153
#define IDS_PROP_REMOVE                 154
#define IDS_MENU_REMOVE_TITLE           155
#define IDS_MENU_REMOVE                 156

#define IDS_OBJFINISH1                  157
#define IDS_OBJFINISH2                  158        
#define IDS_OBJFINISH3                  159

#define IDS_OBJECTWIZ_TITLE             160
#define IDS_OBJECTWIZ_SUBTITLE          161
#define IDS_DETAILS                     162
#define IDS_SELECT_MENUS                163
#define IDS_SELECT_COLUMNS              164

#define IDS_COLWIZ_TITLE				165
#define IDS_COLWIZ_SUBTITLE				166
#define IDS_SELECT_PROPERTIES			167
#define IDS_AVAIL_COLUMNS				168

#define IDS_PROP_REMOVE_ONE             169
#define IDS_MENU_REMOVE_ONE             170
#define IDS_ENTIRE_DIRECTORY			171

#define IDI_APPL                        202
#define IDS_ROOTNODE                    203
#define IDS_GROUPNODE                   204
#define IDS_QUERYNODE                   205
#define IDI_QUERYNODE                   206
#define IDI_GROUPNODE                   207

#define IDD_ROOT_GENERAL_PAGE           208
#define IDC_NAME                        209
#define IDC_CREATED                     210
#define IDC_MODIFIED                    212
#define IDC_COMMENTS                    213

#define IDD_ROOT_MENU_PAGE              214
#define IDC_OBJECTLIST                  215
#define IDC_ADDOBJECT                   216
#define IDC_REMOVEOBJECT                217
#define IDC_MENULIST                    218
#define IDC_ADDMENU                     219
#define IDC_REMOVEMENU                  220
#define IDC_EDITMENU                    221
#define IDC_MOVEUP                      222
#define IDC_MOVEDOWN                    223

#define IDD_ROOT_VIEW_PAGE              224
#define IDC_COLUMNLIST                  225
#define IDC_ADDCOLUMN                   226
#define IDC_REMOVECOLUMN                227

#define IDD_ROOT_OBJECT_PAGE            228
#define IDD_ADDOBJECT                   229
#define IDD_ADDCOLUMN                   230
#define IDC_OBJCLASS                    231

#define IDD_QUERY_GENERAL_PAGE          234
#define IDC_SCOPE                       235
#define IDC_FILTER                      236

#define IDD_QUERY_MENU_PAGE             237
#define IDD_QUERY_VIEW_PAGE             238

#define IDD_GROUP_GENERAL_PAGE          239
#define IDC_APPLYSCOPE                  240
#define IDC_SCOPE_BROWSE                241
#define IDC_SCOPE_LBL                   242
#define IDC_FILTER_LBL                  243
#define IDC_OBJCLASS_LBL                244

#define IDC_SHORTCUT                    247
#define IDC_COMMANDTYPE                 248
#define IDC_COMMAND                     249
#define IDC_COMMAND_LBL                 250
#define IDC_COMMAND_BROWSE              251
#define IDC_PARAMS                      252
#define IDC_PARAMS_LBL                  253
#define IDC_PARAMS_MENU                 254
#define IDC_STARTIN_LBL                 255
#define IDC_STARTIN                     256
#define IDC_MENULIST_LBL                257

#define IDC_APPLYFILTER                 258
#define IDC_QUERYICON                   259
#define IDC_GROUPICON                   260

#define IDD_ADDMENU                     261
#define IDD_ADDMENU1                    262
#define IDD_ADDMENU2                    263

#define IDC_QUERYSCOPE                  264
#define IDC_LOCALSCOPE                  265

#define IDM_CMDPARAM                    300
#define IDM_QUERYSCOPE                  301
#define IDM_QUERYCLASS                  302
#define IDM_QUERYFILTER                 303
#define IDM_PARAM_NAME                  304
#define IDM_PARAM_TYPE                  305

#define IDD_ADDGROUPNODE                306

#define IDB_TOOLBAR                     307
#define BTN_EDITQUERY                   308
#define TIP_EDITQUERY                   309
#define BTN_STOPQUERY                   310
#define TIP_STOPQUERY                   311

#define IDS_SEARCHING                   312
#define IDS_QUERYDONE                   313
#define IDS_QUERYSTOPPED                314
#define IDS_QUERYFAILED                 315

#define IDS_DELETENODE_TITLE            316
#define IDS_DELETEQUERYNODE             317
#define IDS_DELETEGROUPNODE             318
#define IDS_DELETEOBJ_TITLE             319
#define IDS_DELETEOBJ                   320
#define IDS_DELETEOBJS                  321

#define IDS_QUERY_SCOPE                 322
#define IDS_QUERY_FILTER                323

#define IDC_STARTIN_BROWSE              324

#define IDD_QUERY_WIZ_WELCOME           325
#define IDD_QUERY_WIZ_QUERY             326
#define IDD_QUERY_WIZ_COMPLETION        327
#define IDB_ADDQUERY                    328
#define IDB_ADDQUERY_HDR                329

#define IDD_OBJECT_WIZ_WELCOME          330
#define IDD_OBJECT_WIZ_COMPLETION       331
#define IDD_OBJECT_WIZ_SELECT           332
#define IDB_ADDOBJECT                   333
#define IDB_ADDOBJECT_HDR               334

#define IDC_CREATEQUERY                 335
#define IDC_SETTINGS                    336

#define IDC_WELCOME                     337
#define IDC_COMPLETION                  338
#define IDD_COMMON_WIZ_MENU             339
#define IDD_COMMON_WIZ_PROPERTIES       340

#define IDC_REFRESH                     341
#define IDC_DEFAULTMENU                 342
#define IDD_MOVEQUERY                   343
#define IDC_FOLDERTREE                  344

#define IDS_ADDQUERY_WIZ                345
#define IDS_ADDOBJECT_WIZ               346

#define IDD_QUERY_WIZ_OBJECT            347
#define IDC_DEFINE_QUERY_OBJS           348
#define IDC_SKIP_QUERY_OBJS             349

#define IDC_SELECT_MENUS                350
#define IDC_SELECT_COLUMNS              351
#define IDC_LIST_LABEL					352
#define IDC_PROPERTYMENU				353
#define IDD_QUERY_NODE_MENU_PAGE        354
#define IDD_ADDQUERYMENU			    355

#define IDD_SELECTICON_PAGE             360
#define IDC_ICONLIST                    361

#define IDS_QUERYICON_TITLE             370
#define IDS_QUERYICON_SUBTITLE          371

#define IDB_ROOT16                      400
#define IDB_ROOT32                      401
#define IDB_QUERY16                     402
#define IDB_QUERY32                     403

// special strings
#define MID_ADDQUERYNODE                6000
#define MID_ADDGROUPNODE                6001
#define MID_EDITQUERY                   6002
#define MID_STOPQUERY                   6003
#define IDS_EXEFILTER                   6004
#define MID_MOVEQUERYNODE               6005
#define IDS_WIZARD97_FONT				6006

// non-localized strings
#define IDS_COMPANY                     8001
#define IDS_PROJNAME                    8002
#define IDS_VERSION                     8003
#define IDS_HELPFILE					8004
#define IDS_DEFAULTHELPTOPIC            8005
#define IDS_USERSHELPTOPIC              8006
#define IDS_PRINTERSHELPTOPIC           8007
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\queryreq.cpp ===
// queryreq.cpp - Query request handler

#include "stdafx.h"
#include <process.h>
#include "queryreq.h"
#include "namemap.h"
#include "resource.h"
#include "util.h"
#include "lmaccess.h"

#include <algorithm>


// singleton query thread object
CQueryThread g_QueryThread;



////////////////////////////////////////////////////////////////////////////////////////////
// class CQueryRequest
//

#define MSG_QUERY_START     (WM_USER + 1)
#define MSG_QUERY_REPLY     (WM_USER + 2)

// static members
HWND CQueryRequest::m_hWndCB = NULL;

// Forward ref
LRESULT CALLBACK QueryRequestWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HANDLE CQueryRequest::m_hMutex = NULL;

// query window class object
CMsgWindowClass QueryWndClass(L"BOMQueryHandler", QueryRequestWndProc);  


CQueryRequest::CQueryRequest()
{
    m_cRef        = 0;
    m_eState      = QRST_INACTIVE;
    m_cPrefs      = 0;
    m_paSrchPrefs = NULL;
    m_hrStatus    = S_OK;
    m_pvstrAttr   = NULL;
    m_pQueryCallback = NULL;
}

CQueryRequest::~CQueryRequest()
{
    if (m_paSrchPrefs != NULL)
        delete m_paSrchPrefs;
}


HRESULT CQueryRequest::SetQueryParameters(LPCWSTR pszScope, LPCWSTR pszFilter, string_vector* pvstrClasses, string_vector* pvstrAttr)
{
    if( !pszScope || !pszScope[0] || !pszFilter || !pvstrClasses || pvstrClasses->empty() ) return E_INVALIDARG;
    if( m_eState != QRST_INACTIVE ) return E_FAIL;

    m_strScope  = pszScope;
    m_strFilter = pszFilter;
    m_vstrClasses = *pvstrClasses;
    m_pvstrAttr = pvstrAttr;

    return S_OK;
}


HRESULT CQueryRequest::SetSearchPreferences(ADS_SEARCHPREF_INFO* paSrchPrefs, int cPrefs)
{
    m_cPrefs = cPrefs;

    if( cPrefs == 0 ) return S_OK;  // Special case

    if( !paSrchPrefs ) return E_POINTER;
    if( m_eState != QRST_INACTIVE ) return E_FAIL;

    m_paSrchPrefs = new ADS_SEARCHPREF_INFO[cPrefs];
    if (m_paSrchPrefs == NULL) return E_OUTOFMEMORY;
    
    memcpy(m_paSrchPrefs, paSrchPrefs, cPrefs * sizeof(ADS_SEARCHPREF_INFO)); 

    return S_OK;
}


HRESULT CQueryRequest::SetCallback(CQueryCallback* pCallback, LPARAM lUserParam)
{
    if( m_eState != QRST_INACTIVE ) return E_FAIL;

    m_pQueryCallback = pCallback;
    m_lUserParam = lUserParam;

    return S_OK;
}


HRESULT CQueryRequest::Start()
{
    if( m_strScope.empty() || !m_pQueryCallback ) return E_FAIL;
    if( m_eState != QRST_INACTIVE ) return E_FAIL;

    // Create callback window the first time (m_hwndCB is static)
    if (m_hWndCB == NULL) 
        m_hWndCB = QueryWndClass.Window();

    if (m_hWndCB == NULL) return E_FAIL;

    // Create mutex the first time (m_hMutex is static)
    if (m_hMutex == NULL) 
        m_hMutex = CreateMutex(NULL, FALSE, NULL);

    if (m_hMutex == NULL) return E_FAIL;

    // Post request to query thread
    Lock();

    BOOL bStat = g_QueryThread.PostRequest(this);
    if (bStat)
    {
        m_eState = QRST_QUEUED;
        m_cRef++;
    }

    Unlock();

    return bStat ? S_OK : E_FAIL;
}


HRESULT CQueryRequest::Stop(BOOL bNotify)
{
    HRESULT hr = S_OK;

    Lock();

    if (m_eState == QRST_QUEUED || m_eState == QRST_ACTIVE)
    {
        // Change state to stopped and notify the user if requested.
        // Don't release the query request here because the query thread needs
        // to see the new state. When the thread sees the stopped state it will
        // send a message to this thread's window proc, which will release the request.
        m_eState = QRST_STOPPED;
        if (bNotify)
        {
            ASSERT(m_pQueryCallback != NULL);
            m_pQueryCallback->QueryCallback(QRYN_STOPPED, this, m_lUserParam);
        }
    }
    else
    {
       hr = S_FALSE;
    }

    Unlock();

    return hr; 
}


void CQueryRequest::Release()
{
    ASSERT(m_cRef > 0);

    if (--m_cRef == 0)
        delete this;
}


void CQueryRequest::Execute()
{
    // Move query to active state (if still in queued state)
    Lock();
    ASSERT(m_eState == QRST_QUEUED || m_eState == QRST_STOPPED);
    if (m_eState == QRST_STOPPED)
    {
        PostMessage(m_hWndCB, MSG_QUERY_REPLY, (WPARAM)this, (LPARAM)QRYN_STOPPED);

        Unlock();
        return;
    }

    m_eState = QRST_ACTIVE;
    Unlock();

    // Intiate the query
    CComPtr<IDirectorySearch> spDirSrch;
    ADS_SEARCH_HANDLE hSearch;
    LPCWSTR* paszAttr = NULL;
    LPCWSTR* paszNameAttr = NULL;

    do
    {
        // Create a directory search object     
        m_hrStatus = ADsOpenObject(m_strScope.c_str(), NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch, (LPVOID*)&spDirSrch);
        BREAK_ON_FAILURE(m_hrStatus)
    
        if (m_cPrefs != 0) 
        {
            m_hrStatus = spDirSrch->SetSearchPreference(m_paSrchPrefs, m_cPrefs);
            BREAK_ON_FAILURE(m_hrStatus)
        }
    

        // Get naming attribute for each query class
        // This will be the attribute placed in column [0] of each RowItem 
        paszNameAttr = new LPCWSTR[m_vstrClasses.size()];
        if (paszNameAttr == NULL) 
        {
            m_hrStatus = E_OUTOFMEMORY;
            break;
        }

        for (int i = 0; i < m_vstrClasses.size(); i++) 
        {
            // get display name map for this class
            DisplayNameMap* pNameMap = DisplayNames::GetMap(m_vstrClasses[i].c_str());
            ASSERT(pNameMap != NULL);

            // Save pointer to naming attribute
            paszNameAttr[i] = pNameMap->GetNameAttribute();
        }


        // Create array of attribute name ptrs for ExecuteSearch
        // Include space for user selected attribs, naming attribs, class and object path (distinguised name)
        paszAttr = new LPCWSTR[m_pvstrAttr->size() + m_vstrClasses.size() + 3];
        if (paszAttr == NULL) 
        {
            m_hrStatus = E_OUTOFMEMORY;
            break;
        }

        int cAttr = 0;

        // add user selected attributes
        // These must be first because the column loop in the query code below indexes through them
        for (i=0; i < m_pvstrAttr->size(); i++)
            paszAttr[cAttr++] = const_cast<LPWSTR>((*m_pvstrAttr)[i].c_str());

        // add class naming attributes
        for (i = 0; i < m_vstrClasses.size(); i++)
        {
            // Multiple classes can use the same name so check for dup before adding
            int j = 0;
            while (j < i && wcscmp(paszNameAttr[i], paszNameAttr[j]) != 0) j++;

            if (j == i)
                paszAttr[cAttr++] = paszNameAttr[i];
        }

        // add path attribute
        paszAttr[cAttr++] = L"distinguishedName";

        // add class attribute
        paszAttr[cAttr++] = L"objectClass";

		// add user state attribute
		paszAttr[cAttr++] = L"userAccountControl";


        // Add (& ... ) around the query because DSQuery leaves it off
        // and GetNextRow causes heap error or endless query without it
        Lock();
        m_strFilter.insert(0, L"(&"),
        m_strFilter.append(L")");

        // Initiate search
        m_hrStatus = spDirSrch->ExecuteSearch((LPWSTR)m_strFilter.c_str(), (LPWSTR*)paszAttr, cAttr, &hSearch);
        Unlock();

        BREAK_ON_FAILURE(m_hrStatus)

    } while (FALSE);
     

    // If search failed, change query state and send failure message
    if (FAILED(m_hrStatus)) 
    {
        // Don't do anything if query has already been stopped
        Lock();
        if (m_eState == QRST_ACTIVE) 
        {
            m_eState = QRST_FAILED;
            PostMessage(m_hWndCB, MSG_QUERY_REPLY, (WPARAM)this, (LPARAM)QRYN_FAILED);
        }
        Unlock();

        delete [] paszAttr;
        paszAttr = NULL;

        delete [] paszNameAttr;
        paszNameAttr = NULL;

        return;
    }
    
    // Get class map for translating class names
    DisplayNameMap* pNameMap = DisplayNames::GetClassMap();
    if( !pNameMap ) return;

    // Get Results
    int nItems = 0;
 
    while (nItems < MAX_RESULT_ITEMS && spDirSrch->GetNextRow(hSearch) == S_OK)
    {
        ADS_SEARCH_COLUMN col;

       // Allocate row item for user attributes plus fixed attributes (name & class)
       CRowItem* pRowItem = new CRowItem(m_pvstrAttr->size() + ROWITEM_USER_INDEX);
       if (pRowItem == NULL)
       {
           m_hrStatus = E_OUTOFMEMORY;
           break;
       }

       // Get path attribute
       if (spDirSrch->GetColumn(hSearch, L"distinguishedName", &col) == S_OK)
       {
           pRowItem->SetObjPath(col.pADsValues->CaseIgnoreString);
           spDirSrch->FreeColumn(&col);
       }

       // Get class attribute
       if (spDirSrch->GetColumn(hSearch, L"objectClass", &col) == S_OK)
       {
            // Class name is last element of multivalued objectClass attribute
            ASSERT(col.dwADsType == ADSTYPE_CASE_IGNORE_STRING);
            LPWSTR pszClass = col.pADsValues[col.dwNumValues-1].CaseIgnoreString;

            // Put class display name in row item
            pRowItem->SetAttribute(ROWITEM_CLASS_INDEX, pNameMap->GetAttributeDisplayName(pszClass));

            // Find class name in query classes vector
            string_vector::iterator itClass = std::find(m_vstrClasses.begin(), m_vstrClasses.end(), pszClass);

            // if found, look up name attribute for this class and put it in the rowitem 
            if (itClass != m_vstrClasses.end()) 
            {
                ADS_SEARCH_COLUMN colName;
                if (spDirSrch->GetColumn(hSearch, (LPWSTR)paszNameAttr[itClass - m_vstrClasses.begin()], &colName) == S_OK)
                {
                    pRowItem->SetAttribute(ROWITEM_NAME_INDEX, colName.pADsValues->CaseIgnoreString);
                    spDirSrch->FreeColumn(&colName);
                }
            }
			else
			{
				// Use CN from path for the name
				LPCWSTR pszPath = pRowItem->GetObjPath();
                if( pszPath == NULL )
                {
                    m_hrStatus = E_OUTOFMEMORY;
                    break;
                }

				LPCWSTR pszSep;
				if (_tcsnicmp(pszPath, L"CN=", 3) == 0 && (pszSep = _tcschr(pszPath + 3, L',')) != NULL)
				{
					// Limit name to MAX_PATH chars
					int cch = pszSep - (pszPath + 3);
					if (cch >= MAX_PATH)
						cch = MAX_PATH - 1;

					// Create null-terminated CN string
					WCHAR szTemp[MAX_PATH];
					memcpy(szTemp, pszPath + 3, cch * sizeof(WCHAR));
					szTemp[cch] = 0;

					pRowItem->SetAttribute(ROWITEM_NAME_INDEX , szTemp);  				
				}
				else
				{
					ASSERT(0);
				}
			}

            spDirSrch->FreeColumn(&col);
       }


	   // Set disabled status based on the value returned by AD
		if (SUCCEEDED(spDirSrch->GetColumn(hSearch, L"userAccountControl", &col)))
		{
			pRowItem->SetDisabled((col.pADsValues->Integer & UF_ACCOUNTDISABLE) != 0);
			spDirSrch->FreeColumn(&col);
		}

       // loop through all user attributes
       for (int iAttr = 0; iAttr < m_pvstrAttr->size(); ++iAttr)
       {
           HRESULT hr = spDirSrch->GetColumn(hSearch, (LPWSTR)paszAttr[iAttr], &col);
           if (SUCCEEDED(hr) && col.dwNumValues > 0)
           {
               WCHAR szBuf[MAX_PATH] = {0};
              LPWSTR psz = NULL;

              switch (col.dwADsType)
              {
                case ADSTYPE_DN_STRING:
                case ADSTYPE_CASE_EXACT_STRING:    
                case ADSTYPE_PRINTABLE_STRING:    
                case ADSTYPE_NUMERIC_STRING:      
                case ADSTYPE_TYPEDNAME:        
                case ADSTYPE_FAXNUMBER:        
                case ADSTYPE_PATH:          
                case ADSTYPE_OBJECT_CLASS:
                case ADSTYPE_CASE_IGNORE_STRING:
                    psz = col.pADsValues->CaseIgnoreString;
                    break;

                case ADSTYPE_BOOLEAN:
                    if (col.pADsValues->Boolean)
                    {
                        static WCHAR szYes[16] = L"";
                        if (szYes[0] == 0)
                        {
                           int nLen = ::LoadString(_Module.GetResourceInstance(), IDS_YES, szYes, lengthof(szYes));
                           ASSERT(nLen != 0);
                        }
                        psz = szYes;
                    }
                    else
                    {
                        static WCHAR szNo[16] = L"";
                        if (szNo[0] == 0)
                        {
                           int nLen = ::LoadString(_Module.GetResourceInstance(), IDS_NO, szNo, lengthof(szNo));
                           ASSERT(nLen != 0);
                        }
                        psz = szNo;
                    }
                    break;

                case ADSTYPE_INTEGER:
                    _snwprintf( szBuf, MAX_PATH-1, L"%d",col.pADsValues->Integer );
                    psz = szBuf;
                    break;

                case ADSTYPE_OCTET_STRING:
                  if ( (_wcsicmp(col.pszAttrName, L"objectGUID") == 0) )
                  {
                     //Cast to LPGUID
                     GUID* pObjectGUID = (LPGUID)(col.pADsValues->OctetString.lpValue);
                     //Convert GUID to string.
                     ::StringFromGUID2(*pObjectGUID, szBuf, 39);
                     psz = szBuf;
                  }
                  break;

                case ADSTYPE_UTC_TIME:
                    {
                      SYSTEMTIME systemtime = col.pADsValues->UTCTime;
                      DATE date;
                      VARIANT varDate;
                      if (SystemTimeToVariantTime(&systemtime, &date) != 0) 
                      {
                        //Pack in variant.vt.
                        varDate.vt = VT_DATE;
                        varDate.date = date;
                        if( SUCCEEDED(VariantChangeType(&varDate,&varDate, VARIANT_NOVALUEPROP, VT_BSTR)) )
                        {
                            wcsncpy(szBuf, varDate.bstrVal, MAX_PATH-1);                            
                        }
                        
                        VariantClear(&varDate);
                      }
                    }
                  break;

                case ADSTYPE_LARGE_INTEGER:
                    {
                        LARGE_INTEGER liValue;
                        FILETIME filetime;
                        DATE date;
                        SYSTEMTIME systemtime;
                        VARIANT varDate;

                        liValue = col.pADsValues->LargeInteger;
                        filetime.dwLowDateTime = liValue.LowPart;
                        filetime.dwHighDateTime = liValue.HighPart;

                        if((filetime.dwHighDateTime!=0) || (filetime.dwLowDateTime!=0))
                        {
                            //Check for properties of type LargeInteger that represent time.
                            //If TRUE, then convert to variant time.
                            if ((0==wcscmp(L"accountExpires", col.pszAttrName)) ||
                                (0==wcscmp(L"badPasswordTime", col.pszAttrName))||
                                (0==wcscmp(L"lastLogon", col.pszAttrName))      ||
                                (0==wcscmp(L"lastLogoff", col.pszAttrName))     ||
                                (0==wcscmp(L"lockoutTime", col.pszAttrName))    ||
                                (0==wcscmp(L"pwdLastSet", col.pszAttrName))
                               )
                            {
                                //Handle special case for Never Expires where low part is -1
                                if (filetime.dwLowDateTime==-1)
                                {
                                    psz = L"Never Expires";
                                }
                                else
                                {

                                    if ( (FileTimeToLocalFileTime(&filetime, &filetime) != 0) && 
                                         (FileTimeToSystemTime(&filetime, &systemtime) != 0)  &&
                                         (SystemTimeToVariantTime(&systemtime, &date) != 0) )
                                    {
                                        //Pack in variant.vt.
                                        varDate.vt = VT_DATE;
                                        varDate.date = date;
                                        if( SUCCEEDED(VariantChangeType(&varDate, &varDate, VARIANT_NOVALUEPROP,VT_BSTR)) )
                                        {
                                            wcsncpy( szBuf, varDate.bstrVal, lengthof(szBuf) );
                                            psz = szBuf;
                                        }

                                        VariantClear(&varDate);
                                    }
                                }
                            }
                            else
                            {
                              //Print the LargeInteger.
                              _snwprintf(szBuf, MAX_PATH-1, L"%d,%d",filetime.dwHighDateTime, filetime.dwLowDateTime);
                            }
                        }
                    }
                    break;

                 case ADSTYPE_NT_SECURITY_DESCRIPTOR:
                     break;
                }


                if (psz != NULL)
                    hr = pRowItem->SetAttribute(iAttr + ROWITEM_USER_INDEX, psz);


                spDirSrch->FreeColumn(&col);
            }
        } // for user attributes

        // Add row to new rows vector and notify client
        Lock();

        // if query is still active
        if (m_eState == QRST_ACTIVE) 
        {
            m_vRowsNew.push_back(*pRowItem);
            delete pRowItem;

            // notify if first new row
            if (m_vRowsNew.size() == 1)
                PostMessage(m_hWndCB, MSG_QUERY_REPLY, (WPARAM)this, (LPARAM)QRYN_NEWROWITEMS);            

            Unlock();
        }
        else
        {
           delete pRowItem;

           Unlock();
           break;
        }
    }

    Lock();

    // If query wasn't stopped, then change state to completed and notify main thread
    if (m_eState == QRST_ACTIVE)
    {
        m_eState = QRST_COMPLETE;
        PostMessage(m_hWndCB, MSG_QUERY_REPLY, (WPARAM)this, (LPARAM)QRYN_COMPLETED);
    }
    else if (m_eState == QRST_STOPPED)
    {
        // if query was stopped, then acknowledge with notify so main thread can release the query req
        PostMessage(m_hWndCB, MSG_QUERY_REPLY, (WPARAM)this, (LPARAM)QRYN_STOPPED);
    }

    Unlock();

    spDirSrch->CloseSearchHandle(hSearch);

    delete [] paszAttr;
    delete [] paszNameAttr;
}


LRESULT CALLBACK QueryRequestWndProc(HWND hWnd, UINT nMsg, WPARAM  wParam, LPARAM  lParam)
{
    if (nMsg == MSG_QUERY_REPLY)
    {
        CQueryRequest* pQueryReq = reinterpret_cast<CQueryRequest*>(wParam);
        if( !pQueryReq ) return 0;

        QUERY_NOTIFY qryn = static_cast<QUERY_NOTIFY>(lParam);

        // Don't do any callbacks for a stopped query. Also, don't forward a stop notification. 
        // The client receives a QRYN_STOPPED directly from the CQueryRequest::Stop() method.
        if (pQueryReq->m_eState != QRST_STOPPED && qryn != QRYN_STOPPED)
            pQueryReq->m_pQueryCallback->QueryCallback(qryn, pQueryReq, pQueryReq->m_lUserParam);

        // any notify but new row items indicates query is completed, so it can be released
        if (qryn != QRYN_NEWROWITEMS)
            pQueryReq->Release();

        return 0;
    }

    return DefWindowProc(hWnd, nMsg, wParam, lParam);
}


////////////////////////////////////////////////////////////////////////////////////////////
// class QueryThread
//
LRESULT CALLBACK QueryHandlerWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

//-----------------------------------------------------------------------------
// CQueryThread::StartThread
//
// Start the thread
//-----------------------------------------------------------------------------

BOOL CQueryThread::Start()
{
    // If thread exists, just return
    if (m_hThread != NULL)
        return TRUE;

    BOOL bRet = FALSE;
    do // False loop
    {
        // Create start event 
        m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (m_hEvent == NULL)
            break;

        // Start the thread
        m_hThread = (HANDLE)_beginthreadex(NULL, 0, ThreadProc, this, 0, &m_uThreadID);
        if (m_hThread == NULL)
            break;

        // Wait for start event
        DWORD dwEvStat = WaitForSingleObject(m_hEvent, 10000);
        if (dwEvStat != WAIT_OBJECT_0)
            break;


        bRet = TRUE;
    } 
    while (0);
    
    ASSERT(bRet);

    // Clean up on failure
    if (!bRet)
    {
        if (m_hEvent)
        {
            CloseHandle(m_hEvent);
            m_hEvent = NULL;
        }

        if (m_hThread)
        {
            CloseHandle(m_hThread);
            m_hThread = NULL;
        }
    }

    return bRet;
}


void CQueryThread::Kill()
{
    if (m_hThread != NULL)
    {
        PostThreadMessage(m_uThreadID, WM_QUIT, 0, 0);

        MSG msg;
        while (TRUE)
        {
            // Wait either for the thread to be signaled or any input event.
            DWORD dwStat = MsgWaitForMultipleObjects(1, &m_hThread, FALSE, INFINITE, QS_ALLINPUT);

            if (WAIT_OBJECT_0 == dwStat)
                break;  // The thread is signaled.

            // There is one or more window message available.
            // Dispatch them and wait.
            if (PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        CloseHandle(m_hThread);
        CloseHandle(m_hEvent);

        m_hThread = NULL;
        m_hEvent = NULL;
    }   
}


BOOL CQueryThread::PostRequest(CQueryRequest* pQueryReq)
{
    // make sure thread is active
    BOOL bStat = Start();
    if (bStat)
        bStat = PostThreadMessage(m_uThreadID, MSG_QUERY_START, (WPARAM)pQueryReq, (LPARAM)0);

    return bStat;
}


unsigned _stdcall CQueryThread::ThreadProc(void* pVoid )
{
    ASSERT(pVoid != NULL);

    // Do a PeekMessage to create the message queue
    MSG msg;
    PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);

    // Then signal that thread is started
    CQueryThread* pThread = reinterpret_cast<CQueryThread*>(pVoid);
    if( !pThread ) return 0;

    ASSERT(pThread->m_hEvent != NULL);
    SetEvent(pThread->m_hEvent);

    HRESULT hr = CoInitialize(NULL);
    RETURN_ON_FAILURE(hr);    

    // Mesage loop
    while (TRUE)
    { 
        long lStat = GetMessage(&msg, NULL, 0, 0);
        
        // zero => WM_QUIT received, so exit thread function
        if (lStat == 0)
            break;

        if (lStat > 0)
        {
            // Only process thread message of the expected type
            if (msg.hwnd == NULL && msg.message == MSG_QUERY_START)
            {
                CQueryRequest* pQueryReq = reinterpret_cast<CQueryRequest*>(msg.wParam);
                if( !pQueryReq ) break;

                pQueryReq->Execute();
            }
            else
            {
                DispatchMessage(&msg);
            }
        }
    } // WHILE (TRUE)

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\rowitem.cpp ===
// rowitem.cpp   CRowItem implementation

#include "stdafx.h"
#include "rowitem.h"

CRowItem::CRowItem(int cAttributes)
{
    ASSERT(cAttributes > 0);

    // Actual attr count is user count plus internal 
    int cActual = cAttributes + INTERNAL_ATTR_COUNT;

    // allocate space for offsets and default parameter storage
    int bcInitial = sizeof(BufferHdr) + cActual * (sizeof(int) + DEFAULT_ATTR_SIZE);
    m_pBuff = (BufferHdr*)malloc(bcInitial);
    if (m_pBuff == NULL)
        THROW_ERROR(E_OUTOFMEMORY)

    // Set all offsets to -1
    memset(m_pBuff->aiOffset, 0xff, cActual * sizeof(int));

    m_pBuff->nRefCnt  = 1;
    m_pBuff->nAttrCnt = cAttributes;
    m_pBuff->bcSize   = bcInitial;
    m_pBuff->bcFree   = cActual * DEFAULT_ATTR_SIZE;
}


HRESULT
CRowItem::SetAttributePriv(int iAttr, LPCWSTR pszAttr)
{
    ASSERT(m_pBuff != NULL);
    ASSERT(pszAttr != NULL);

    iAttr += INTERNAL_ATTR_COUNT;

    // For the current implementaion a given attribute can only be set once.
    // There is no facility for freeing the previous value.
    ASSERT(m_pBuff->aiOffset[iAttr] == -1);

    int bcAttrSize = (wcslen(pszAttr) + 1) * sizeof(WCHAR);

    // if no room, realocate buffer
    if (bcAttrSize > m_pBuff->bcFree)
    {
        BufferHdr* pBuffNew = (BufferHdr*)realloc(m_pBuff, m_pBuff->bcSize + bcAttrSize + EXTENSION_SIZE);
        if (pBuffNew == NULL)
            return E_OUTOFMEMORY;

        m_pBuff = pBuffNew;
        m_pBuff->bcSize += (bcAttrSize + EXTENSION_SIZE);
        m_pBuff->bcFree += (bcAttrSize + EXTENSION_SIZE);
    }

    // Append new attribute to end of memory block
    m_pBuff->aiOffset[iAttr] = m_pBuff->bcSize - m_pBuff->bcFree;
    memcpy(reinterpret_cast<BYTE*>(m_pBuff) + m_pBuff->aiOffset[iAttr], pszAttr, bcAttrSize);

    // adjust free space
    m_pBuff->bcFree -= bcAttrSize;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\rootprop.cpp ===
// rootprop.cpp -  Root Property Page Implementation

#include "stdafx.h"
#include "resource.h"
#include "rootprop.h"
#include "compdata.h"
#include "scopenode.h"
#include "wizards.h"
#include "query.h"
#include "cmndlgs.h"
#include "util.h"
#include "namemap.h"

#include <windowsx.h>
#include <algorithm>

int GetDateTimeString(FILETIME* pftime, LPWSTR pszBuf, int cBuf);
void LoadObjectCB(CComboBox& ComboBox, CEditObjList& ObjList);


///////////////////////////////////////////////////////////////////////////////////////////
// CRootGeneralPage

LRESULT CRootGeneralPage::OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    CRootNode* pRootNode = m_ObjList.RootNode();
    ASSERT(pRootNode != NULL);
    if( !pRootNode ) return 0;

    Edit_LimitText(GetDlgItem(IDC_COMMENTS),255);

    SetDlgItemText( IDC_NAME, pRootNode->GetName() );

    tstring strComment;
    pRootNode->GetComment(strComment);
    SetDlgItemText( IDC_COMMENTS, strComment.c_str() );

    FILETIME ftime;
    WCHAR szDateTime[32];

    pRootNode->GetCreateTime(&ftime);
    if( GetDateTimeString(&ftime, szDateTime, lengthof(szDateTime)) )
    {
        SetDlgItemText( IDC_CREATED, szDateTime );
    }

    pRootNode->GetModifyTime(&ftime);
    if( GetDateTimeString(&ftime, szDateTime, lengthof(szDateTime)) )
    {
        SetDlgItemText( IDC_MODIFIED, szDateTime );
    }

    m_bChgComment = FALSE;

    return TRUE;
}

LRESULT CRootGeneralPage::OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    SetModified(TRUE);
    m_bChgComment = TRUE;

    return 0;
}

//------------------------------------------------------------------------------------
// CRootGeneralPage::OnClose
//
// This method is invoked when the edit box receives an Esc char. The method converts
// the WM_CLOSE message into a command to close the property sheet. Otherwise the
// WM_CLOSE message has no effect.
//------------------------------------------------------------------------------------
LRESULT CRootGeneralPage::OnClose( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    // Simulate press of Cancel button
    ::PropSheet_PressButton(GetParent(), PSBTN_CANCEL);

    return 0;
}

 
BOOL CRootGeneralPage::OnSetActive()
{
    m_ObjList.PageActive(m_hWnd);
    return TRUE;
}

BOOL CRootGeneralPage::OnApply()
{
    if (m_bChgComment) 
    {
        CRootNode* pRootNode = m_ObjList.RootNode();
        ASSERT(pRootNode);
        if( !pRootNode ) return FALSE;

        int cLen = ::GetWindowTextLength(GetDlgItem(IDC_COMMENTS));
        LPWSTR szTemp = new WCHAR[(cLen+1)];
        if( !szTemp ) return FALSE;

        int cLen1 = ::GetWindowText(GetDlgItem(IDC_COMMENTS), szTemp, cLen+1);
        ASSERT(cLen == cLen1);

        pRootNode->SetComment(szTemp);
        pRootNode->UpdateModifyTime();

        m_bChgComment = FALSE;

        delete [] szTemp;
    }

    return m_ObjList.ApplyChanges(m_hWnd);
}



///////////////////////////////////////////////////////////////////////////////////////////
// CRootMenuPage

CRootMenuPage::~CRootMenuPage()
{
    m_ObjectCB.Detach();
    m_MenuLV.Detach();

    m_ObjList.Release();
}

LRESULT CRootMenuPage::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    m_ObjectCB.Attach(GetDlgItem(IDC_OBJECTLIST));
    m_MenuLV.Attach(GetDlgItem(IDC_MENULIST));

    m_itObjSelect = NULL;

    ::ConfigSingleColumnListView(GetDlgItem(IDC_MENULIST));
    
    return TRUE;
}

BOOL CRootMenuPage::OnSetActive()
{
    m_ObjList.PageActive(m_hWnd);

    LoadObjectCB(m_ObjectCB, m_ObjList);

    // if object was previously selected 
    if (m_itObjSelect != NULL) 
    {
        // find the edit object by name because it may have been moved or deleted
        // while another page was active
        m_itObjSelect = m_ObjList.FindObject(m_strObjSelect.c_str());

        if (m_itObjSelect != NULL && m_itObjSelect->IsDeleted())
            m_itObjSelect = NULL;
    }

    // if object still around, reselect it in the combo box
    if (m_itObjSelect != NULL) 
    {
        DisplayNameMap* pNameMap = DisplayNames::GetClassMap();
        ASSERT( pNameMap );
        if( !pNameMap ) return FALSE;

        int iSel = m_ObjectCB.FindStringExact(-1, pNameMap->GetAttributeDisplayName(m_strObjSelect.c_str()));
        ASSERT(iSel != CB_ERR);

        m_ObjectCB.SetCurSel(iSel);
    }
    else if (m_ObjectCB.GetCount() > 0)
    {
        // default to the first object and update the columns
        m_ObjectCB.SetCurSel(0);

        void* pv = m_ObjectCB.GetItemDataPtr(0);
        m_itObjSelect = *(EditObjIter*)&pv;

        m_strObjSelect = m_itObjSelect->Name();
    
        DisplayMenus();
    }
    else
    {
        DisplayMenus();
    }
    
    return TRUE;
}

LRESULT CRootMenuPage::OnObjectSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iItem = m_ObjectCB.GetCurSel();

    // Double-clicking an empty combo box will call this with no selection
    if (iItem >= 0)
    {
        void* pv = m_ObjectCB.GetItemDataPtr(iItem);
        m_itObjSelect = *(EditObjIter*)&pv;
        m_strObjSelect = m_itObjSelect->Name();

        DisplayMenus();
    }

    return 0;

}


void CRootMenuPage::DisplayMenus()
{
    HWND hwndLV = GetDlgItem(IDC_MENULIST);
    if( !hwndLV || !::IsWindow(hwndLV) ) return;

    ListView_DeleteAllItems(hwndLV);

    if (m_itObjSelect != NULL)
    {
        CClassInfo& classInfo = m_itObjSelect->GetObject();

        // make sure menu names have been loaded        
        IStringTable* pStringTable = m_ObjList.RootNode()->GetCompData()->GetStringTable();
        ASSERT(pStringTable != NULL);
        classInfo.LoadStrings(pStringTable);

        LV_ITEM lvi;
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem = 0;
        lvi.iSubItem = 0;
    
        menucmd_vector::iterator itMenu;
        for (itMenu = classInfo.Menus().begin(); itMenu != classInfo.Menus().end(); ++itMenu) 
        {
            lvi.pszText = const_cast<LPWSTR>((*itMenu)->Name());
            lvi.lParam = (*itMenu)->ID();

            int iPos = ListView_InsertItem(hwndLV, &lvi);
            ASSERT(iPos >= 0);

            lvi.iItem++;
        }

        // if items are added, select the first
        if (ListView_GetItemCount(hwndLV) > 0)
        {
            ListView_SetItemState(hwndLV, 0, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
        }
    }


    EnableDlgItem( m_hWnd, IDC_ADDMENU,     (m_itObjSelect != NULL) );
    EnableDlgItem( m_hWnd, IDC_REMOVEMENU,  FALSE );
    EnableDlgItem( m_hWnd, IDC_EDITMENU,    FALSE );
    EnableDlgItem( m_hWnd, IDC_MOVEUP,      FALSE );
    EnableDlgItem( m_hWnd, IDC_MOVEDOWN,    FALSE );
}


LRESULT CRootMenuPage::OnAddMenu( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    // if object is selected
    if (m_itObjSelect == NULL)
        return 0;

    CAddMenuDlg dlg(m_itObjSelect->GetObject());

    if (dlg.DoModal() == IDOK)
    {
        CClassInfo* pClassInfo = m_itObjSelect->GetModifiedObject();
        if( !pClassInfo ) return 0;

        CMenuCmd* pMenuNew = dlg.GetMenu();
        ASSERT(pMenuNew != NULL);

        if( pMenuNew )
        {
            // Add new menu to list
            HWND hwndList = GetDlgItem(IDC_MENULIST);
            
            // Set name to add it to string table and generate the menu ID
            IStringTable* pStringTable = m_ObjList.RootNode()->GetCompData()->GetStringTable();
            ASSERT( pStringTable );
            if( !pStringTable ) return 0;

            // Use temp string because string fails an assignement like: strX = strX.c_str()
            // (it relases the private buffer first and then assigns the string)
            tstring strName = pMenuNew->Name();
            pMenuNew->SetName(pStringTable, strName.c_str()); 

            LVITEM lvi;
            lvi.mask = LVIF_PARAM | LVIF_TEXT;
            lvi.iSubItem = 0;
            lvi.iItem = ListView_GetItemCount(hwndList);
            lvi.lParam = pMenuNew->ID();
            lvi.pszText = const_cast<LPWSTR>(pMenuNew->Name());
            ListView_InsertItem(hwndList,&lvi);

            // if first item is added, select it
            if (ListView_GetItemCount(hwndList) == 1)
            {
                ListView_SetItemState(hwndList, 0, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
            }
                
            // Add to menu vector (note that temp CMenuCmdPtr will delete pMenuNew)
            pClassInfo->Menus().push_back(CMenuCmdPtr(pMenuNew));

            SetModified(TRUE);
        }
    }

    return 0;
}


LRESULT CRootMenuPage::OnEditMenu( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    HWND hwndList = GetDlgItem(IDC_MENULIST);
    if( !hwndList || !::IsWindow(hwndList) ) return 0;

    int iIndex = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
    ASSERT(iIndex != -1);
    if( iIndex == -1 ) return 0;

    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = iIndex;

    ListView_GetItem(hwndList, &lvi);

    // Locate selected menu by it's ID (lparam)
    CClassInfo& classInfo = m_itObjSelect->GetObject();
    menucmd_vector& vMenus = classInfo.Menus();

    menucmd_vector::iterator itMenu;
    itMenu = std::find(vMenus.begin(), vMenus.end(), lvi.lParam);
    ASSERT(itMenu != vMenus.end());
    if( itMenu == vMenus.end() ) return 0;

    CMenuCmd* pMenu = *itMenu;
    if( !pMenu ) return 0;

    CAddMenuDlg dlg(m_itObjSelect->GetObject(), pMenu);

    if (dlg.DoModal() == IDOK)
    {
        CMenuCmd* pMenuNew = dlg.GetMenu();
        ASSERT( pMenuNew );
        if( !pMenuNew ) return 0;

        // Set the name again in case it was changed
        IStringTable* pStringTable = m_ObjList.RootNode()->GetCompData()->GetStringTable();
        ASSERT( pStringTable );
        if( !pStringTable ) return 0;        

        // Use temp string because string fails an assignement like: strX = strX.c_str()
        // (it relases the private buffer first and then assigns the string)
        tstring strName = pMenuNew->Name();
        pMenuNew->SetName(pStringTable, strName.c_str()); 

        // locate object again because the vector may have been reallocated
        CClassInfo* pClassInfoNew = m_itObjSelect->GetModifiedObject();
        if( !pClassInfoNew ) return 0;

        menucmd_vector& vMenusNew = pClassInfoNew->Menus();

        // locate with the old ID because it will be different if the name was changed        
        itMenu = std::find(vMenusNew.begin(), vMenusNew.end(), pMenu->ID());
        ASSERT(itMenu != vMenusNew.end());
        if( itMenu == vMenusNew.end() ) return 0;

        // Replace menu with new one
        *itMenu = pMenuNew;

        // Update the list
        lvi.mask = LVIF_PARAM | LVIF_TEXT;
        lvi.lParam = pMenuNew->ID();
        lvi.pszText = const_cast<LPWSTR>(pMenuNew->Name());
        ListView_SetItem(hwndList,&lvi); 
        
        SetModified(TRUE);
    }
 
    return 0;
}

LRESULT CRootMenuPage::OnRemoveMenu( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if (m_itObjSelect == NULL)
        return 0;

    HWND hwndList = GetDlgItem(IDC_MENULIST);

	UINT uiMsg = (ListView_GetSelectedCount(hwndList) == 1) ? IDS_MENU_REMOVE_ONE : IDS_MENU_REMOVE;
    int iRet = DisplayMessageBox(m_hWnd, IDS_MENU_REMOVE_TITLE, uiMsg, MB_YESNO|MB_ICONWARNING);
    if (iRet != IDYES)
        return 0;

    CClassInfo* pClassInfo = m_itObjSelect->GetModifiedObject();
    if( !pClassInfo ) return 0;
    menucmd_vector& vMenus = pClassInfo->Menus();

    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;

    int iIndex = -1;
    while ((iIndex = ListView_GetNextItem(hwndList, iIndex, LVNI_SELECTED)) >= 0)
    {
        lvi.iItem = iIndex;
        ListView_GetItem(hwndList, &lvi);

        // Locate menu by its ID
        menucmd_vector::iterator itMenu = std::find(vMenus.begin(), vMenus.end(), lvi.lParam);
        ASSERT(itMenu != vMenus.end());

        vMenus.erase(itMenu);

        ListView_DeleteItem(hwndList, iIndex);
        iIndex--;
    }

    EnableDlgItem( m_hWnd, IDC_REMOVEMENU, FALSE );
    EnableDlgItem( m_hWnd, IDC_EDITMENU,   FALSE );
    EnableDlgItem( m_hWnd, IDC_MOVEUP,     FALSE );
    EnableDlgItem( m_hWnd, IDC_MOVEDOWN,   FALSE );

    SetModified(TRUE);

    return 0;
}

LRESULT CRootMenuPage::OnMoveUpDown( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    HWND hwndList = GetDlgItem(IDC_MENULIST); 
    int iItem = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
    ASSERT(iItem >= 0);

    // Determine new position for selected item
    if (wID == IDC_MOVEUP)
        iItem--;
    else
        iItem++;

    // Now swap the selected item with the item at its new position
    //   Do it by moving the unselected item to avoid state change notifications
    //   because they will cause unwanted butten enables/disables.
    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = iItem;
    ListView_GetItem(hwndList, &lvi);


   // Move the menu item in the menu vector
    CClassInfo* pClassInfo = m_itObjSelect->GetModifiedObject();
    if( !pClassInfo ) return 0;
    menucmd_vector& vMenus = pClassInfo->Menus();

    menucmd_vector::iterator itMenu = std::find(vMenus.begin(), vMenus.end(), lvi.lParam);
    ASSERT(itMenu != vMenus.end());
        
    menucmd_vector::iterator itMenuOld = itMenu;
    if (wID == IDC_MOVEUP)
        itMenu++;
    else
        itMenu--;

    // swap the items
    std::iter_swap (itMenuOld, itMenu);

    //Now delete and reinsert it in the list view
    ListView_DeleteItem(hwndList, lvi.iItem);

    if (wID == IDC_MOVEUP)
        lvi.iItem++;
    else
        lvi.iItem--;
    lvi.mask = LVIF_PARAM | LVIF_TEXT;
    lvi.pszText = const_cast<LPWSTR>((*itMenu)->Name());
    ListView_InsertItem(hwndList, &lvi);

 
    // Update Up/Down buttons
    EnableDlgItem( m_hWnd, IDC_MOVEUP,   (iItem > 0) );
    EnableDlgItem( m_hWnd, IDC_MOVEDOWN, (iItem < (ListView_GetItemCount(hwndList) - 1)) );

    SetModified(TRUE);

    return 0;
}

LRESULT CRootMenuPage::OnMenuListChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    HWND hwndList = GetDlgItem(IDC_MENULIST);

    int nItemSel = ListView_GetSelectedCount(hwndList);
    int iItem = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);

    EnableDlgItem( m_hWnd, IDC_REMOVEMENU, (nItemSel > 0)  );
    EnableDlgItem( m_hWnd, IDC_EDITMENU,   (nItemSel == 1) );
    EnableDlgItem( m_hWnd, IDC_MOVEUP,     ((nItemSel == 1) && (iItem > 0)) );
    EnableDlgItem( m_hWnd, IDC_MOVEDOWN,   ((nItemSel == 1) && (iItem < (ListView_GetItemCount(hwndList) - 1))) );

    return TRUE;
}


LRESULT CRootMenuPage::OnMenuListDblClk(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    if (ListView_GetSelectedCount(GetDlgItem(IDC_MENULIST)))    
        ::SendMessage(GetDlgItem(IDC_EDITMENU), BM_CLICK, (WPARAM)0, (LPARAM)0);

    return 0;
}

BOOL CRootMenuPage::OnApply()
{
    return m_ObjList.ApplyChanges(m_hWnd);
}

///////////////////////////////////////////////////////////////////////////////////////////
// CRootObjectPage


LRESULT CRootObjectPage::OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HWND hwndList = GetDlgItem(IDC_OBJECTLIST);

    ConfigSingleColumnListView(hwndList);

    return TRUE;
}

LRESULT CRootObjectPage::OnAddObject(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr;
    do
    {            
        // Pass list of current classes, so wizard won't add one twice
        string_vector vstrClasses;
        for (EditObjIter itObj = m_ObjList.begin(); itObj != m_ObjList.end(); ++itObj) 
        {
            if (!itObj->IsDeleted())
                vstrClasses.push_back(itObj->Name());
        }

        CAddObjectWizard objWiz;
        objWiz.Initialize(&vstrClasses, m_ObjList.RootNode()->GetCompData()->GetStringTable());
    
        // Run the wizard
        IPropertySheetProviderPtr spProvider = m_ObjList.RootNode()->GetCompData()->GetConsole();        
        if( spProvider == NULL ) return E_NOINTERFACE;
            
        hr = objWiz.Run(spProvider, m_hWnd);
        if (hr == S_OK) 
        {
            ASSERT(objWiz.GetNewObject() != NULL);
            if( !(objWiz.GetNewObject()) ) return E_FAIL;

            EditObjIter itObj = m_ObjList.AddObject(objWiz.GetNewObject());
            ASSERT(itObj != NULL);
            if( itObj == NULL ) return E_FAIL;

            LV_ITEM lvi;
            lvi.mask = LVIF_TEXT | LVIF_PARAM;
            lvi.iItem = 0;
            lvi.iSubItem = 0;

            lvi.pszText = const_cast<LPWSTR>(DisplayNames::GetClassMap()->GetAttributeDisplayName(itObj->Name()));
            lvi.lParam  = *(LPARAM*)&itObj;       // NEED BETTER CONVERSION
            
            int iPos = ListView_InsertItem(GetDlgItem(IDC_OBJECTLIST), &lvi);
            ASSERT(iPos >= 0);   

            // if first item is added, select it
            if (ListView_GetItemCount(GetDlgItem(IDC_OBJECTLIST)) == 1)
            {
                ListView_SetItemState(GetDlgItem(IDC_OBJECTLIST), 0, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
            }
            
            SetModified(TRUE);
        }
    }
    while (FALSE);

    return hr;
}


LRESULT CRootObjectPage::OnRemoveObject( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    HWND hwndList = GetDlgItem(IDC_OBJECTLIST);

    BOOL bFirst = TRUE;
    int iIndex = -1;
    while ((iIndex = ListView_GetNextItem(hwndList, iIndex, LVNI_SELECTED)) != -1)
    {
        LVITEM lvi;
        lvi.mask = LVIF_PARAM;
        lvi.iItem = iIndex;
        lvi.iSubItem = 0;

        BOOL bStat = ListView_GetItem(hwndList, &lvi);
        ASSERT(bStat);

        EditObjIter itObj = *(EditObjIter*)&lvi.lParam;

        // get confirmation before deleting first object
        if (bFirst) 
        {
            bFirst = FALSE;

            CString strTitle;
            strTitle.LoadString(IDS_DELETEOBJ_TITLE);
        
            CString strMsgFmt;
            if (ListView_GetSelectedCount(hwndList) == 1)
                strMsgFmt.LoadString(IDS_DELETEOBJ);
            else
                strMsgFmt.LoadString(IDS_DELETEOBJS);
        
            WCHAR szName[MAX_PATH];
            ListView_GetItemText(hwndList, iIndex, 0, szName, sizeof(szName));

            CString strMsg;
            strMsg.Format(strMsgFmt, szName);

            if (::MessageBox(m_hWnd, strMsg, strTitle, MB_YESNO|MB_ICONWARNING) != IDYES)
                return 0;            
        }

        m_ObjList.DeleteObject(itObj);

        ListView_DeleteItem(hwndList, iIndex);

        // backup index because it now points to the next item
        iIndex--;

        SetModified(TRUE);
    }

    EnableDlgItem( m_hWnd, IDC_REMOVEOBJECT, FALSE );
        
    return 0;
}


LRESULT CRootObjectPage::OnObjListChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    EnableDlgItem( m_hWnd, IDC_REMOVEOBJECT, ListView_GetSelectedCount(GetDlgItem(IDC_OBJECTLIST)) );

    return TRUE;
}


BOOL CRootObjectPage::OnSetActive()
{
    HWND hwndList = GetDlgItem(IDC_OBJECTLIST);

    ListView_DeleteAllItems(hwndList);

    LV_ITEM lvi;
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = 0;
    lvi.iSubItem = 0;

    DisplayNameMap* pNameMap = DisplayNames::GetClassMap();
    ASSERT(pNameMap != NULL);
    if (pNameMap == NULL) 
        return TRUE;

    for (EditObjIter itObj = m_ObjList.begin(); itObj != m_ObjList.end(); ++itObj) 
    {
        if (!itObj->IsDeleted())
        {
            lvi.pszText = const_cast<LPWSTR>(pNameMap->GetAttributeDisplayName(itObj->Name()));
            lvi.lParam  = *(LPARAM*)&itObj;       // NEED BETTER CONVERSION

            int iPos = ListView_InsertItem(hwndList, &lvi);
            ASSERT(iPos >= 0);
        }
    }

    // if items are added, select the first
    if (ListView_GetItemCount(hwndList) > 0)
    {
        ListView_SetItemState(hwndList, 0, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
    }

    EnableDlgItem( m_hWnd, IDC_REMOVEOBJECT, FALSE );

    m_ObjList.PageActive(m_hWnd);
    return TRUE;
}


BOOL CRootObjectPage::OnApply()
{
    return m_ObjList.ApplyChanges(m_hWnd);
}

///////////////////////////////////////////////////////////////////////////////////////////
// CRootViewPage

CRootViewPage::~CRootViewPage()
{
    m_ObjectCB.Detach();
    m_ColumnLV.Detach();

    m_ObjList.Release();
}


LRESULT CRootViewPage::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    m_ObjectCB.Attach(GetDlgItem(IDC_OBJECTLIST));
    m_ColumnLV.Attach(GetDlgItem(IDC_COLUMNLIST));

    m_itObjSelect = NULL;

    ::ConfigSingleColumnListView(GetDlgItem(IDC_COLUMNLIST));
    
    return TRUE;
}


LRESULT CRootViewPage::OnObjectSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    int iItem = m_ObjectCB.GetCurSel();

    // Double-clicking an empty combo box can call this with no selection
    if (iItem >= 0)
    {
        void* pv = m_ObjectCB.GetItemDataPtr(iItem);
        m_itObjSelect = *(EditObjIter*)&pv;
        m_strObjSelect = m_itObjSelect->Name();

        DisplayColumns();
    }

    return 0;
}

LRESULT CRootViewPage::OnColumnListChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    EnableDlgItem( m_hWnd, IDC_REMOVECOLUMN, ListView_GetSelectedCount(GetDlgItem(IDC_COLUMNLIST)) );

    return TRUE;
}


void CRootViewPage::DisplayColumns()
{
    HWND hwndLV = GetDlgItem(IDC_COLUMNLIST);
    ASSERT(::IsWindow(hwndLV));

    ListView_DeleteAllItems(hwndLV);

    if (m_itObjSelect != NULL)
    {
        CClassInfo& classInfo = m_itObjSelect->GetObject();

        DisplayNameMap* pNameMap = DisplayNames::GetMap(classInfo.Name());    
        if( !pNameMap ) return;

        LV_ITEM lvi;
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem = 0;
        lvi.iSubItem = 0;
    
         string_vector::iterator itStr;
         for (itStr = classInfo.Columns().begin(); itStr != classInfo.Columns().end(); ++itStr) 
         {
            lvi.pszText = const_cast<LPWSTR>(pNameMap->GetAttributeDisplayName(itStr->c_str()));
            lvi.lParam = reinterpret_cast<LPARAM>(itStr->c_str());

            int iPos = ListView_InsertItem(hwndLV, &lvi);
            ASSERT(iPos >= 0);
         }

        // if items are added, select the first
        if (ListView_GetItemCount(hwndLV) > 0)
        {
            ListView_SetItemState(hwndLV, 0, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
        }
    }

    EnableDlgItem( m_hWnd, IDC_ADDCOLUMN,    (m_itObjSelect != NULL) );
    EnableDlgItem( m_hWnd, IDC_REMOVECOLUMN, FALSE );
}


LRESULT CRootViewPage::OnAddColumn( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    // if object is selected
    if (m_itObjSelect == NULL)
        return 0;

    CAddColumnDlg dlg(m_itObjSelect->Name());

    if (dlg.DoModal() == IDOK)
    {
        BOOL bModified = FALSE;

        CClassInfo* pClassInfo = m_itObjSelect->GetModifiedObject();
        if( !pClassInfo ) return 0;

        HWND hwndList = GetDlgItem(IDC_COLUMNLIST);
        ASSERT(hwndList != NULL);

        string_vector::iterator itStr = dlg.GetColumns().begin();
        while (itStr != dlg.GetColumns().end()) 
        {
            if (std::find(pClassInfo->Columns().begin(), pClassInfo->Columns().end(), *itStr) == pClassInfo->Columns().end())
            {
                pClassInfo->Columns().push_back(*itStr);
                bModified = TRUE;
            }
            ++itStr;
        }

        if (bModified)
        {
            SetModified(TRUE);
            DisplayColumns();
        }
    }

    return 0;
}

LRESULT CRootViewPage::OnRemoveColumn( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if (m_itObjSelect == NULL)
        return 0;

    HWND hwndList = GetDlgItem(IDC_COLUMNLIST);
    ASSERT(hwndList != NULL);

	UINT uiMsg = (ListView_GetSelectedCount(hwndList) == 1) ? IDS_PROP_REMOVE_ONE : IDS_PROP_REMOVE;
    int iRet = DisplayMessageBox(m_hWnd, IDS_PROP_REMOVE_TITLE, uiMsg, MB_YESNO|MB_ICONWARNING);
    if (iRet != IDYES)
        return 0;

    CClassInfo* pClassInfo = m_itObjSelect->GetModifiedObject();
    if( !pClassInfo ) return 0;

    string_vector vstrTmp = pClassInfo->Columns();

    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;

    int iIndex = -1;
    while ((iIndex = ListView_GetNextItem(hwndList, iIndex, LVNI_SELECTED)) >= 0)
    {
        lvi.iItem = iIndex;
        ListView_GetItem(hwndList, &lvi);
        LPCWSTR pszName = reinterpret_cast<LPCWSTR>(lvi.lParam);

        string_vector::iterator itStr;
        itStr = std::find(vstrTmp.begin(), vstrTmp.end(), pszName);
        ASSERT(itStr != vstrTmp.end());
        
        if( itStr != vstrTmp.end() )
        {
            vstrTmp.erase(itStr);
        }
    }

    pClassInfo->Columns() = vstrTmp;

    DisplayColumns();

    SetModified(TRUE);

    return 0;
}

BOOL CRootViewPage::OnSetActive()
{
    m_ObjList.PageActive(m_hWnd);

    LoadObjectCB(m_ObjectCB, m_ObjList);

    // if object was previously selected 
    if (m_itObjSelect != NULL) 
    {
        // find the edit object by name because it may have been moved or deleted
        // while another page was active
        m_itObjSelect = m_ObjList.FindObject(m_strObjSelect.c_str());

        if (m_itObjSelect != NULL && m_itObjSelect->IsDeleted())
            m_itObjSelect = NULL;
    }

    // if object still around, reselect it in the combo box
    if (m_itObjSelect != NULL) 
    {
        DisplayNameMap* pNameMap = DisplayNames::GetClassMap();
        ASSERT(pNameMap != NULL);

        int iSel = m_ObjectCB.FindStringExact(-1, pNameMap->GetAttributeDisplayName(m_strObjSelect.c_str()));
        ASSERT(iSel != CB_ERR);

        m_ObjectCB.SetCurSel(iSel);
    }
    else if (m_ObjectCB.GetCount() > 0)
    {
        // default to the first object and update the columns
        m_ObjectCB.SetCurSel(0);

        void* pv = m_ObjectCB.GetItemDataPtr(0);
        m_itObjSelect = *(EditObjIter*)&pv;

        m_strObjSelect = m_itObjSelect->Name();
    
        DisplayColumns();
    }
    else
    {
        DisplayColumns();
    }
    
    return TRUE;
}


BOOL CRootViewPage::OnApply()
{
    return m_ObjList.ApplyChanges(m_hWnd);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// CEditObjList

HRESULT CEditObjList::Initialize(CRootNode* pRootNode, classInfo_vector& vClasses, LONG_PTR lNotifyHandle)
{
    ASSERT(pRootNode != NULL);
    ASSERT(lNotifyHandle != NULL);

    m_spRootNode = pRootNode;

    classInfo_vector::iterator itClass = vClasses.begin();
    while(itClass != vClasses.end())
    {
        CEditObject* pObj = new CEditObject();
        if( !pObj ) 
        {
            break;
        }
        EditObjIter iter = m_ObjectList.insert(end(), *pObj);
        
        iter->m_strName = itClass->Name();
        iter->m_itObjOriginal = itClass;

        ++itClass; 
    }

    m_pvClasses = &vClasses;

    m_iPageMax = -1;

    m_lNotifyHandle = lNotifyHandle;

    return S_OK;
}


BOOL CEditObjList::ApplyChanges(HWND hwndPage)
{
    ASSERT(::IsWindow(hwndPage));

    // Don't apply changes until called from highest activated page
    if (PropSheet_HwndToIndex(GetParent(hwndPage), hwndPage) < m_iPageMax)
        return TRUE;

    // Build a vector of the modified classes
    string_vector* pvstrModified = new string_vector;
    if( !pvstrModified ) return FALSE;

    // Apply changes in reverse order so deletions won't invalidate stored iterators  
    std::list<CEditObject>::reverse_iterator itObj = m_ObjectList.rbegin();
    while (itObj != m_ObjectList.rend()) 
    {
        // if object is modified, replace the original
        if (itObj->m_itObjOriginal != NULL)
        {
            if (itObj->m_pObjModified != NULL)
            {
                *(itObj->m_itObjOriginal) = *(itObj->m_pObjModified);
                pvstrModified->push_back(itObj->m_pObjModified->Name());
            }
            else if (itObj->IsDeleted()) 
            {
                m_pvClasses->erase(itObj->m_itObjOriginal);
                pvstrModified->push_back(itObj->m_itObjOriginal->Name());
            }
        }
        ++itObj;
    }

    // Now go through list again to add any new objects
    // This must be done separately because it can invalidate all stored iterators
    itObj = m_ObjectList.rbegin();
    while(itObj != m_ObjectList.rend())
    {
        if (itObj->m_itObjOriginal == NULL && itObj->m_pObjModified != NULL) 
        {
            m_pvClasses->push_back(*(itObj->m_pObjModified));
            pvstrModified->push_back(itObj->m_pObjModified->Name());
        }

        ++itObj;
    }

    // clear the edit list and re-initialize it
    m_ObjectList.clear();

    Initialize(m_spRootNode, *m_pvClasses, m_lNotifyHandle);

    // Send change notification to root node, so it can update affected child nodes
    // Use MMC method to send from prop page thread to main thread
    if (pvstrModified->size() != 0)
    {
        // create prop change info struct with root node's data interface
        // and list of changed classes
        PropChangeInfo* pChg = new PropChangeInfo;
        if( !pChg )
        {
            delete pvstrModified;
            return FALSE;
        }

        pChg->pDataObject = static_cast<IDataObject*>(m_spRootNode.p);
        pChg->lNotifyParam = (LPARAM)pvstrModified;

        MMCPropertyChangeNotify(m_lNotifyHandle, (LPARAM)pChg);
    }
    else
        delete pvstrModified;

    return TRUE;
}

void CEditObjList::PageActive(HWND hwndPage)
{
    ASSERT(::IsWindow(hwndPage));

    // track the highest created page number for ApplyChanges method
    int iPage = PropSheet_HwndToIndex(GetParent(hwndPage), hwndPage);
    if (iPage > m_iPageMax)
        m_iPageMax = iPage;
}

EditObjIter CEditObjList::FindObject(LPCWSTR pszName)
{
    if( !pszName ) return NULL;

    EditObjIter iter = begin();
    while (iter != end()) 
    {
        // look for class object with matching name
        if (wcscmp(iter->Name(), pszName) == 0)
        {
            // If the object hasn't been modified (copied) yet, then load any
            // string table strings before returning the object
            if (iter->m_itObjOriginal != NULL && iter->m_pObjModified == NULL) 
            {
                ASSERT(m_spRootNode != NULL);
                if( !m_spRootNode ) return NULL;

                IStringTable* pStringTable = m_spRootNode->GetCompData()->GetStringTable();
                ASSERT(pStringTable != NULL);
                if( !pStringTable ) return NULL;

                HRESULT hr = iter->m_itObjOriginal->LoadStrings(pStringTable);
            }
            return iter;
        }
        ++iter;
    }

    return NULL;
}


EditObjIter CEditObjList::AddObject(CClassInfo* pClassInfo)
{
    if( !pClassInfo ) return NULL;

    EditObjIter iter = begin();
    while (iter != end()) 
    {
        // Check for exiting edit object (can be there if object was deleted)
        if (wcscmp(iter->Name(), pClassInfo->Name()) == 0)
        {
            ASSERT(iter->m_bDeleted && iter->m_pObjModified == NULL);
            iter->m_bDeleted = FALSE;
            iter->m_pObjModified = pClassInfo;

            return iter;
        }
        ++iter;
    }

    // if not found, create new edit object and store new class info as the modified object
    CEditObject* pObj = new CEditObject();
    if( !pObj ) return iter;

    iter = m_ObjectList.insert(end(), *pObj);

    iter->m_strName = pClassInfo->Name();
    iter->m_pObjModified = pClassInfo;

    return iter;
}

void CEditObjList::DeleteObject(EditObjIter itObj)
{
    ASSERT(itObj != NULL);

    if (itObj->m_itObjOriginal == NULL)
    {
        m_ObjectList.erase(itObj);
    }
    else
    {
        if (itObj->m_pObjModified != NULL) 
        {
            delete itObj->m_pObjModified;
            itObj->m_pObjModified = NULL;            
        }

        itObj->m_bDeleted = TRUE;
    }
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//

void LoadObjectCB(CComboBox& ComboBox, CEditObjList& ObjList)
{

    ComboBox.ResetContent();

    DisplayNameMap* pNameMap = DisplayNames::GetClassMap();
    ASSERT(pNameMap != NULL);
    if (pNameMap == NULL) 
        return;

    for (EditObjIter itObj = ObjList.begin(); itObj != ObjList.end(); ++itObj) 
    {
        if (!itObj->IsDeleted())
         {
            int iIndex = ComboBox.AddString(pNameMap->GetAttributeDisplayName(itObj->Name()));
            ASSERT(iIndex >= 0);
            ComboBox.SetItemDataPtr(iIndex, *(LPVOID*)&itObj);
         }
    }
}

int GetDateTimeString(FILETIME* pftime, LPWSTR pszBuf, int cBuf)
{
    if( !pftime || !pszBuf || !cBuf ) return 0;

    FILETIME ftimeLocal;
    BOOL bStat = FileTimeToLocalFileTime(pftime, &ftimeLocal);
    ASSERT(bStat);

    SYSTEMTIME systime;
    bStat = FileTimeToSystemTime(&ftimeLocal, &systime);
    ASSERT(bStat);

    // get date string
    int cDate = GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systime, NULL, pszBuf, cBuf);
    if (cDate == 0 || cDate > cBuf - 2)
        return 0;

   // replace teminating null with ", "
   pszBuf[cDate-1] = ',';
   pszBuf[cDate] = ' ';

   // append time string
   int cTime = GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &systime, NULL,
                              pszBuf + (cDate + 1), cBuf - (cDate + 1));

   if (cTime == 0)
       return 0;

   // return total string length excluding terminating null
   return (cDate + cTime - 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\rootprop.h ===
// rootprop.h  - Root node property pages header file

#ifndef _ROOTPROP_H_
#define _ROOTPROP_H_

#include "scopenode.h"
#include "atlwin.h"
#include "atldlgs.h"
#include "atlctrls.h"
#include <list>

class CRootNode;


////////////////////////////////////////////////////////////////////////////////////////
// CEditObject adn CEditList

class CEditObject
{
    friend class CEditObjList;

public:

    CEditObject(std::vector<CClassInfo>::iterator itObject = NULL)
    {
        m_itObjOriginal = itObject;
        m_pObjModified = NULL;
        m_bDeleted = FALSE;

        if (itObject)
            m_strName = itObject->Name();
    }

    virtual ~CEditObject()  { SAFE_DELETE(m_pObjModified); }

    LPCWSTR Name() { return m_strName.c_str(); }

    BOOL IsDeleted() { return m_bDeleted; }

    CClassInfo& GetObject() 
    {
        ASSERT(!m_bDeleted);

        return m_pObjModified ? *m_pObjModified : *m_itObjOriginal;
    }

    CClassInfo* GetModifiedObject()
    {
        ASSERT(!m_bDeleted);

        if (m_pObjModified == NULL)
        {
            ASSERT(m_itObjOriginal != NULL);     
            m_pObjModified = new CClassInfo(*m_itObjOriginal);
        }

        ASSERT(m_pObjModified != NULL);
        return m_pObjModified;
    }

private:
    std::vector<CClassInfo>::iterator m_itObjOriginal;
    CClassInfo* m_pObjModified;
    tstring     m_strName;
    BOOL        m_bDeleted;    
};


typedef std::list<CEditObject>::iterator EditObjIter;

class CEditObjList
{
public:
    CEditObjList() : m_lNotifyHandle(NULL), m_cRef(0), m_pvClasses(NULL) {}
    virtual ~CEditObjList() 
    { 
        if (m_lNotifyHandle != NULL) 
        {
            MMCFreeNotifyHandle(m_lNotifyHandle); 
        }
    }

    HRESULT Initialize(CRootNode* pRootNode, classInfo_vector& vClasses, LONG_PTR lNotifyHandle);
    void  PageActive(HWND hwndPage);  
    BOOL  ApplyChanges(HWND hwndPage);

    EditObjIter FindObject(LPCWSTR pszName);
    EditObjIter AddObject(CClassInfo* pClassInfo);
    void        DeleteObject(EditObjIter itObj);

    EditObjIter begin() { return m_ObjectList.begin(); }
    EditObjIter end()   { return m_ObjectList.end(); }
    long        size()  { return m_ObjectList.size(); }
    CRootNode*  RootNode() { return m_spRootNode; }

    ULONG AddRef() { return ++m_cRef; }
    ULONG Release() 
    {
        ASSERT(m_cRef > 0);

        if (--m_cRef != 0) 
            return m_cRef; 
       
        delete this; 
        return 0;
    }

private:
    int m_iPageMax;
    CComPtr<CRootNode>     m_spRootNode;
    classInfo_vector*      m_pvClasses;
    std::list<CEditObject> m_ObjectList;
    LONG_PTR               m_lNotifyHandle;
    ULONG                  m_cRef;
};



class CRootGeneralPage : public CPropertyPageImpl<CRootGeneralPage>
{

public:
    typedef CPropertyPageImpl<CRootGeneralPage> BC;

    // Constructor/destructor
    CRootGeneralPage(CEditObjList& ObjList): m_ObjList(ObjList) { m_ObjList.AddRef(); }
    virtual ~CRootGeneralPage() { m_ObjList.Release(); }

    enum { IDD = IDD_ROOT_GENERAL_PAGE };

protected:
    BEGIN_MSG_MAP( CRootGeneralPage )
        COMMAND_HANDLER(IDC_COMMENTS, EN_CHANGE, OnChange)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CLOSE, OnClose)
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // message handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnClose( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    // overrrides
    BOOL OnSetActive();
    BOOL OnApply();
    void OnFinalMessage(HWND) { delete this; }

private:
    CEditObjList& m_ObjList;
    BOOL m_bChgComment;
};


class CRootObjectPage : public CPropertyPageImpl<CRootObjectPage>
{
public:
    typedef CPropertyPageImpl<CRootObjectPage> BC;

    CRootObjectPage(CEditObjList& ObjList): m_ObjList(ObjList) { m_ObjList.AddRef(); }
    virtual ~CRootObjectPage() { m_ObjList.Release(); }

    enum { IDD = IDD_ROOT_OBJECT_PAGE };

protected:
    BEGIN_MSG_MAP( CRootObjectPage )
        NOTIFY_HANDLER(IDC_OBJECTLIST, LVN_ITEMCHANGED, OnObjListChanged)
        COMMAND_HANDLER(IDC_ADDOBJECT, BN_CLICKED, OnAddObject)
        COMMAND_HANDLER(IDC_REMOVEOBJECT, BN_CLICKED, OnRemoveObject)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnAddObject( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnRemoveObject( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnObjListChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);

    // overrrides       
    BOOL OnSetActive();
    BOOL OnApply();
    void OnFinalMessage(HWND) { delete this; }

private:
    CEditObjList&       m_ObjList;
    EditObjIter         m_itObjSelect;
};

class CRootMenuPage : public CPropertyPageImpl<CRootMenuPage>
{
public:
    typedef CPropertyPageImpl<CRootMenuPage> BC;

    CRootMenuPage(CEditObjList& ObjList): m_ObjList(ObjList) { m_ObjList.AddRef(); }
    virtual ~CRootMenuPage();

    enum { IDD = IDD_ROOT_MENU_PAGE };

protected:
    BEGIN_MSG_MAP( CRootMenuPage )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        NOTIFY_HANDLER(IDC_MENULIST, LVN_ITEMCHANGED, OnMenuListChanged)
        NOTIFY_HANDLER(IDC_MENULIST, NM_DBLCLK, OnMenuListDblClk)
        COMMAND_HANDLER(IDC_OBJECTLIST, CBN_SELENDOK, OnObjectSelect )
        COMMAND_HANDLER(IDC_ADDMENU, BN_CLICKED, OnAddMenu)
        COMMAND_HANDLER(IDC_REMOVEMENU, BN_CLICKED, OnRemoveMenu)
        COMMAND_HANDLER(IDC_EDITMENU, BN_CLICKED, OnEditMenu)
        COMMAND_HANDLER(IDC_MOVEUP, BN_CLICKED, OnMoveUpDown)
        COMMAND_HANDLER(IDC_MOVEDOWN, BN_CLICKED, OnMoveUpDown);

    
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnObjectSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnAddMenu( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnRemoveMenu( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnEditMenu( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnMenuListChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);
    LRESULT OnMenuListDblClk(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);
    LRESULT OnMoveUpDown( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    // overrrides       
    BOOL OnSetActive();
    BOOL OnApply();
    void OnFinalMessage(HWND) { delete this; }

    // implementation
    void DisplayMenus();

private:
    CListViewCtrl       m_MenuLV;
    CComboBox           m_ObjectCB;
    CEditObjList&       m_ObjList;
    EditObjIter         m_itObjSelect;
    tstring             m_strObjSelect;
};


class CRootViewPage : public CPropertyPageImpl<CRootViewPage>
{
public:
    typedef CPropertyPageImpl<CRootViewPage> BC;

    CRootViewPage(CEditObjList& ObjList): m_ObjList(ObjList) { m_ObjList.AddRef(); }
    virtual ~CRootViewPage();

    enum { IDD = IDD_ROOT_VIEW_PAGE };


protected:
    BEGIN_MSG_MAP( CRootViewPage )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        NOTIFY_HANDLER(IDC_COLUMNLIST, LVN_ITEMCHANGED, OnColumnListChanged)
        COMMAND_HANDLER( IDC_OBJECTLIST, CBN_SELENDOK, OnObjectSelect )
        COMMAND_HANDLER(IDC_ADDCOLUMN, BN_CLICKED, OnAddColumn)
        COMMAND_HANDLER(IDC_REMOVECOLUMN, BN_CLICKED, OnRemoveColumn)
        
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnObjectSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnAddColumn( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnRemoveColumn( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnColumnListChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);


    // overrrides       
    BOOL OnSetActive();
    BOOL OnApply();
    void OnFinalMessage(HWND) { delete this; }

    // implementation
    void DisplayColumns();

private:
    CListViewCtrl       m_ColumnLV;
    CComboBox           m_ObjectCB;
    CEditObjList&       m_ObjList;
    EditObjIter         m_itObjSelect;
    tstring             m_strObjSelect;
};


#endif // _ROOTPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\queryreq.h ===
// queryreq.h   Query request header file

#ifndef _QUERYREQ_H_
#define _QUERYREQ_H_

#include "rowitem.h"
#include <cmnquery.h>
#include <shlobj.h>
#include <dsclient.h>

#define QUERY_PAGE_SIZE     64
#define MAX_RESULT_ITEMS    10000

//////////////////////////////////////////////////////////////////////////////////////////////
// Query request class
//

enum QUERY_NOTIFY
{
    QRYN_NEWROWITEMS = 1,
    QRYN_STOPPED,
    QRYN_COMPLETED,
    QRYN_FAILED
};

enum QUERYREQ_STATE
{
    QRST_INACTIVE = 0,
    QRST_QUEUED,
    QRST_ACTIVE,
    QRST_STOPPED,
    QRST_COMPLETE,
    QRST_FAILED
};


class CQueryCallback;

class CQueryRequest
{

public:
    friend class CQueryThread;
    friend LRESULT CALLBACK QueryRequestWndProc(HWND hWnd, UINT nMsg, WPARAM  wParam, LPARAM  lParam);

    static HRESULT CreateInstance(CQueryRequest** ppQueryReq)
    {
        VALIDATE_POINTER( ppQueryReq );

        *ppQueryReq = new CQueryRequest();
        
        if (*ppQueryReq != NULL)     
        {
            (*ppQueryReq)->m_cRef = 1;
            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    HRESULT SetQueryParameters(LPCWSTR pszScope, LPCWSTR pszFilter, string_vector* pvstrClasses, string_vector* pvstrAttr);
    HRESULT SetSearchPreferences(ADS_SEARCHPREF_INFO* paSrchPrefs, int cPrefs);
    HRESULT SetCallback(CQueryCallback* pQueryCallback, LPARAM lUserParam);

    HRESULT Start();
    HRESULT Stop(BOOL bNotify);
    void    Release();

    RowItemVector& GetNewRowItems()     { Lock(); return m_vRowsNew; }
    void           ReleaseNewRowItems() { m_vRowsNew.clear(); Unlock(); }

    HRESULT GetStatus()   { return m_hrStatus; }

private:
    CQueryRequest();     
    ~CQueryRequest();

    void Lock()   { DWORD dw = WaitForSingleObject(m_hMutex, INFINITE); ASSERT(dw == WAIT_OBJECT_0); }
    void Unlock() { BOOL bStat = ReleaseMutex(m_hMutex); ASSERT(bStat); }
    void Execute();

    static HWND     m_hWndCB;             // callback window for query thread messages
    static HANDLE   m_hMutex;             // mutex for query locking

    tstring         m_strScope;           // scope to search
    tstring         m_strFilter;          // query filter string
    string_vector   m_vstrClasses;        // classes return by query
    string_vector*  m_pvstrAttr;          // attributes to collect

    ADS_SEARCHPREF_INFO* m_paSrchPrefs;   // preferences array
    int             m_cPrefs;             // preference count

    CQueryCallback* m_pQueryCallback;     // callback interface
    LPARAM          m_lUserParam;         // user data

    QUERYREQ_STATE  m_eState;             // Query request state

    RowItemVector   m_vRowsNew;           // New row items
    HRESULT         m_hrStatus;           // status
    int             m_cRef;               // ref count
};


class CQueryCallback
{
public:
    virtual void QueryCallback(QUERY_NOTIFY event, CQueryRequest* pQueryReq, LPARAM lUserParam) = 0;
};

////////////////////////////////////////////////////////////////////////////////////////////
// Query thread object

class CQueryThread
{
public:
    CQueryThread()
    {
        m_hThread = NULL;
        m_hEvent = NULL; 
        m_uThreadID = 0;
    }

    ~CQueryThread()
    {
        Kill();
    }

    BOOL Start();
    void Kill();

    BOOL PostRequest(CQueryRequest* pQueryReq);

private:

    static unsigned _stdcall ThreadProc(void* pVoid);
    static HRESULT ExecuteQuery(CQueryRequest* pQueryReq, HWND hWndReply);

    HANDLE    m_hThread;         // thread handle
    HANDLE    m_hEvent;          // start event
    unsigned  m_uThreadID;       // thread ID
};


#endif // _QUERYREQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\rowitem.h ===
// rowitem.h    -  CRowItem header file

#ifndef _ROWITEM_H_
#define _ROWITEM_H_

#define DEFAULT_ATTR_SIZE   32
#define EXTENSION_SIZE      256

// First two attributes are fixed followed by user defined attributes
enum ROWITEM_ATTR_INDEX
{
    ROWITEM_PATH_INDEX  = -1, // Path is not an indexed attribute, but is stored like one
    ROWITEM_NAME_INDEX  = 0,  // Object name (usually cn, but depends on class)
    ROWITEM_CLASS_INDEX = 1,  // Class name (display name, not LDAP name)
    ROWITEM_USER_INDEX  = 2   // First user selected attribute
}; 

#define INTERNAL_ATTR_COUNT  1  // Number of internal attributes (ones with negative indicies)

class CRowItem
{
    typedef struct
    {
        LPARAM  lOwnerParam;    // Row item owner parameter
		UINT	iIcon;			// virtual index of the icon
		bool    bDisabled;      // disabled flag for icon state
        int     bcSize;         // size of buffer
        int     bcFree;         // size of free space
        int     nRefCnt;        // ref count for sharing buffer among CRowItems
        int     nAttrCnt;       // number of atributes
        int     aiOffset[1];    // attribute offset array. NOTE: this MUST be the last element
    } BufferHdr;

public:
    // constructor/destructor
    CRowItem() : m_pBuff(NULL) {}

    CRowItem(int cAttributes);

    // Copy constructor
    // NOTE: unlike most classes that share a ref-counted resource, this class does not
    //       make a private copy when there is a change to the resoruce. All instances
    //       sharing the copy see the same change.
    CRowItem(const CRowItem& rRowItem)
    {
        ASSERT(rRowItem.m_pBuff != NULL);

        m_pBuff = rRowItem.m_pBuff;

        if( m_pBuff )
        {
            m_pBuff->nRefCnt++;
        }
    }

    CRowItem& operator= (const CRowItem& rRowItem)
    {
        if (m_pBuff == rRowItem.m_pBuff)
            return (*this);

        ASSERT(rRowItem.m_pBuff != NULL);
        if (m_pBuff != NULL && --(m_pBuff->nRefCnt) == 0)
            free(m_pBuff);

        m_pBuff = rRowItem.m_pBuff;

        if( m_pBuff )
        {
            m_pBuff->nRefCnt++;
        }

        return (*this);
    }

    virtual ~CRowItem()
    {
        if (m_pBuff != NULL && --(m_pBuff->nRefCnt) == 0)
            free(m_pBuff);
    }

    // public methods

    HRESULT SetAttribute(int iAttr, LPCWSTR pszAttr)
    {       
        ASSERT(iAttr >= 0 && iAttr < m_pBuff->nAttrCnt);
    
        return SetAttributePriv(iAttr, pszAttr);
    }


    LPCWSTR operator[](int iAttr)
    {
        ASSERT(m_pBuff != NULL);
        if( !m_pBuff ) return L"";
        
        if( iAttr >= m_pBuff->nAttrCnt || iAttr < 0 )
            return L"";

        return GetAttributePriv(iAttr);
    }

    int size() { return m_pBuff ? m_pBuff->nAttrCnt : 0; }


    HRESULT SetObjPath(LPCWSTR pszPath) { return SetAttributePriv(ROWITEM_PATH_INDEX, pszPath); }
    LPCWSTR GetObjPath() { ASSERT( m_pBuff ); return GetAttributePriv(ROWITEM_PATH_INDEX); }

    void SetOwnerParam(LPARAM lParam) 
    { 
        ASSERT( m_pBuff ); 
        if( !m_pBuff ) return;
        
        m_pBuff->lOwnerParam = lParam;        
    }
    LPARAM GetOwnerParam() { ASSERT( m_pBuff ); return m_pBuff ? m_pBuff->lOwnerParam : 0; }

	void SetIconIndex(UINT index) 
    {
        ASSERT( m_pBuff ); 
        if( !m_pBuff ) return;

        m_pBuff->iIcon = index;        
    }
    UINT GetIconIndex() const {ASSERT( m_pBuff ); return m_pBuff ? m_pBuff->iIcon : 0; }

	void SetDisabled(bool flag) 
    {
        ASSERT( m_pBuff ); 
        if( !m_pBuff ) return;
        
        m_pBuff->bDisabled = flag;
    }
    bool Disabled() const { ASSERT( m_pBuff ); return m_pBuff ? m_pBuff->bDisabled : true; }

protected:
    HRESULT SetAttributePriv(int iAttr, LPCWSTR pszAttr);

    LPCWSTR GetAttributePriv(int iAttr)
    {
        iAttr += INTERNAL_ATTR_COUNT;

        if( !m_pBuff || (m_pBuff->aiOffset[iAttr] == -1) )
        {
            return L"";
        }
        else
        {
            return reinterpret_cast<LPCWSTR>(reinterpret_cast<BYTE*>(m_pBuff) + m_pBuff->aiOffset[iAttr]);
        }
    }

    // member variables
    BufferHdr   *m_pBuff;
};

typedef std::vector<CRowItem> RowItemVector;


class CRowCompare 
{
public:

    CRowCompare(int iCol, bool bDescend): m_iCol(iCol), m_bDescend(bDescend) {}

    int operator()(CRowItem& Item1,  CRowItem& Item2) const
    {
		int iRet = CompareString(LOCALE_USER_DEFAULT,
						 NORM_IGNORECASE|NORM_IGNOREKANATYPE|NORM_IGNOREWIDTH,
						 Item1[m_iCol], -1, Item2[m_iCol], -1);

		return m_bDescend ? (iRet == CSTR_GREATER_THAN) : (iRet == CSTR_LESS_THAN); 
    }

private:
    int  m_iCol;
    bool m_bDescend;
};


#endif // _ROWITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\scopenode.cpp ===
// ScopeNode.cpp : Implementation of CBOMSnapApp and DLL registration.

#include "stdafx.h"
#include "streamio.h"
#include "BOMSnap.h"
#include "ScopeNode.h"
#include "atlgdi.h"

#include "rootprop.h"
#include "qryprop.h"
#include "grpprop.h"
#include "namemap.h"
#include "query.h"
#include "compont.h"
#include "compdata.h"
#include "wizards.h"
#include "cmndlgs.h"

#include <algorithm>
#include <lmcons.h>   // for UNLEN

extern HWND g_hwndMain;
extern DWORD g_dwFileVer; // Current console file version (from compdata.cpp)


// Register static clipboard format members
UINT CScopeNode::m_cfDisplayName = RegisterClipboardFormat(TEXT("CCF_DISPLAY_NAME")); 
UINT CScopeNode::m_cfSnapInClsid = RegisterClipboardFormat(TEXT("CCF_SNAPIN_CLASSID"));
UINT CScopeNode::m_cfNodeType    = RegisterClipboardFormat(TEXT("CCF_NODETYPE"));
UINT CScopeNode::m_cfszNodeType  = RegisterClipboardFormat(TEXT("CCF_SZNODETYPE"));
UINT CScopeNode::m_cfNodeID2     = RegisterClipboardFormat(TEXT("CCF_NODEID2"));
UINT CScopeNode::m_cfColumnSetID = RegisterClipboardFormat(TEXT("CCF_COLUMN_SET_ID"));

// {316A1EEA-C249-44e0-958B-00D2AB989D2F}
static const GUID GUID_RootNode = 
{ 0x316a1eea, 0xc249, 0x44e0, { 0x95, 0x8b, 0x0, 0xd2, 0xab, 0x98, 0x9d, 0x2f } };


// {2A34413B-B565-469e-9C28-5E733768264F}
static const GUID GUID_GroupNode = 
{ 0x2a34413b, 0xb565, 0x469e, { 0x9c, 0x28, 0x5e, 0x73, 0x37, 0x68, 0x26, 0x4f } };


// {1030A359-F520-4748-95CA-8C8CEFA5C63F}
static const GUID GUID_QueryNode = 
{ 0x1030a359, 0xf520, 0x4748, { 0x95, 0xca, 0x8c, 0x8c, 0xef, 0xa5, 0xc6, 0x3f } };


/////////////////////////////////////////////////////////////////////////////
//
// CScopeNode
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CScopeNode::CreateNode(NODETYPE nodetype, CScopeNode** ppnode)
{
    VALIDATE_POINTER( ppnode ); 

    HRESULT hr = E_FAIL;

    switch( nodetype )
    {
    case GROUP_NODETYPE:
        {
            CComObject<CGroupNode>* pGroupNode = NULL;
            hr = CComObject<CGroupNode>::CreateInstance(&pGroupNode);
            *ppnode = pGroupNode;
        }
        break;

    case QUERY_NODETYPE:
        {
            CComObject<CQueryNode>* pQueryNode = NULL;
            hr = CComObject<CQueryNode>::CreateInstance(&pQueryNode);
            *ppnode = pQueryNode;
        }
        break;

    case ROOT_NODETYPE:
        {
            CComObject<CRootNode>* pRootNode = NULL;                                    
            hr = CComObject<CRootNode>::CreateInstance(&pRootNode);
            *ppnode = pRootNode;
        }
        break;

    default:
        ASSERT(0 && "Invalid node type");
    }

    // return addref'd object
    if( SUCCEEDED(hr) )
        (*ppnode)->AddRef();

    return hr;
}


// AddNewChild should only be called when a new node is created, not
// to add an existing node, such as when loading the node tree from
// a console file. 
HRESULT CScopeNode::AddNewChild(CScopeNode* pnodeChild, LPCWSTR pszName)
{
    VALIDATE_POINTER(pnodeChild);
    ASSERT(pszName && pszName[0]);

    // Assign permanent node ID
    // Root node tracks last used ID in its lNodeID member
    CRootNode* pRootNode = GetRootNode();
    pnodeChild->m_lNodeID = pRootNode ? ++(pRootNode->m_lNodeID) : 0;

    // Assign parent node
    pnodeChild->m_pnodeParent = static_cast<CScopeNode*>(this);

    // Now that node has parent we can set the name
    // (needs parent to get to IStringTable)
    HRESULT hr = pnodeChild->SetName(pszName);
    ASSERT(SUCCEEDED(hr));
    RETURN_ON_FAILURE( hr );

    // In order to persist the Column Data, we'll need to get a unique ID
    hr = CoCreateGuid(&m_gColumnID);
    ASSERT(SUCCEEDED(hr));
    RETURN_ON_FAILURE( hr );

    return AddChild(pnodeChild);
}


// Call AddChild to add a new node or a moved node to the parent node
HRESULT CScopeNode::AddChild(CScopeNode* pnodeChild)
{
    VALIDATE_POINTER( pnodeChild );

    HRESULT hr = S_OK;

    // Add new child to end of child list
    if( m_pnodeChild == NULL )
        m_pnodeChild = pnodeChild;
    else
    {
        CScopeNode* pnodePrev = m_pnodeChild;
        while( pnodePrev->Next() )
            pnodePrev = pnodePrev->Next();

        pnodePrev->m_pnodeNext = pnodeChild;
    }

    // Assign parent node
    pnodeChild->m_pnodeParent = static_cast<CScopeNode*>(this);

    pnodeChild->AddRef();

    // if this node has been added to the scope pane
    if( m_hScopeItem != NULL )
    {
        IConsoleNameSpace* pNameSpace = GetCompData()->GetNameSpace();
        ASSERT( pNameSpace );
        if( !pNameSpace ) return E_FAIL;

        SCOPEDATAITEM sdi;
        sdi.ID = m_hScopeItem;
        sdi.mask = SDI_STATE;

        // Has it been expanded?
        HRESULT hr2 = pNameSpace->GetItem(&sdi);
        if( SUCCEEDED(hr2) && (sdi.nState & MMC_SCOPE_ITEM_STATE_EXPANDEDONCE) )
        {
            hr = pnodeChild->Insert(pNameSpace);
        }
        else
        {
            // if can't add children yet, then set children to show the '+'
            SCOPEDATAITEM sdi2;
            sdi2.ID = m_hScopeItem;
            sdi2.mask = SDI_CHILDREN;
            sdi2.cChildren = 1;

            pNameSpace->SetItem(&sdi2);  
        }
    }

    // Force refresh on both child and parent because a query node may be modified
    // by its new parent and a group node is always modified by its children
    OnRefresh(NULL);
    pnodeChild->OnRefresh(NULL);

    return hr;
}

HRESULT CScopeNode::RemoveChild(CScopeNode* pnodeDelete)
{
    VALIDATE_POINTER(pnodeDelete);
    ASSERT(pnodeDelete->Parent() == this);

    // if deleting the first child
    if( m_pnodeChild == pnodeDelete )
    {
        // just set first child to its next sibling
        m_pnodeChild = m_pnodeChild->Next();        
    }
    else
    {
        // Locate preceding sibling
        CScopeNode* pnodePrev = m_pnodeChild;
        while( pnodePrev && pnodePrev->Next() != pnodeDelete )
        {
            pnodePrev = pnodePrev->Next();            
        }

        // remove deleted node from list
        if( pnodePrev )
        {
            pnodePrev->m_pnodeNext = pnodeDelete->Next();
        }
    }

    pnodeDelete->m_pnodeNext = NULL;

    // release the node
    pnodeDelete->Release();

    // Do refresh in case this is a group node losing a child
    OnRefresh(NULL);
    return S_OK;
}


CRootNode* CScopeNode::GetRootNode()
{
    CScopeNode* pNode = this;
    while( pNode && !pNode->IsRootNode() )
    {
        pNode = pNode->Parent();
    }

    return static_cast<CRootNode*>(pNode);
}

CComponentData* CScopeNode::GetCompData()
{
    CRootNode* pRootNode = GetRootNode();    
    return pRootNode ? pRootNode->GetRootCompData() : NULL;
}

CScopeNode::~CScopeNode()
{
    // Release all nodes on child list
    OnRemoveChildren(NULL);
}

HRESULT CScopeNode::GetDataImpl(UINT cf, HGLOBAL* phGlobal)
{
    VALIDATE_POINTER( phGlobal );

    HRESULT hr = DV_E_FORMATETC;

    if( cf == m_cfDisplayName )
    {
        hr = DataToGlobal(phGlobal, m_strName.c_str(), (m_strName.size() + 1) * sizeof(WCHAR));
    }
    else if( cf == m_cfSnapInClsid )
    {
        hr = DataToGlobal(phGlobal, &CLSID_BOMSnapIn, sizeof(GUID));
    }
    else if( cf == m_cfNodeType )
    {
        hr = DataToGlobal(phGlobal, NodeTypeGuid(), sizeof(GUID));
    }
    else if( cf == m_cfszNodeType )
    {
        WCHAR szGuid[GUID_STRING_LEN+1];
        StringFromGUID2(*NodeTypeGuid(), szGuid, GUID_STRING_LEN+1);

        hr = DataToGlobal(phGlobal, szGuid, GUID_STRING_SIZE);
    }
    else if( cf == m_cfNodeID2 )
    {
        // return SNodeID2 struct with the node's ID
        // For a root node always return 1; m_lNodeID for a root node holds the last ID
        // assigned to an enumerated node. It is incremented for each new child node. 
        int nSize = sizeof(SNodeID2) + sizeof(long) - 1;
        SNodeID2* pNodeID = reinterpret_cast<SNodeID2*>(malloc( nSize ));
        if( !pNodeID ) return E_OUTOFMEMORY;

        pNodeID->dwFlags = 0;
        pNodeID->cBytes = sizeof(long);
        *((long*)(pNodeID->id)) = IsRootNode() ? 1 : m_lNodeID;

        hr = DataToGlobal( phGlobal, pNodeID, nSize );

        free( pNodeID );
    }
    else if( cf == m_cfColumnSetID)
    {
        int nSize2 = sizeof(SColumnSetID) + sizeof(m_gColumnID) - 1;
        SColumnSetID* pColumnSetID = reinterpret_cast<SColumnSetID*>(malloc( nSize2 ));
        if( !pColumnSetID ) return E_OUTOFMEMORY;
        
        pColumnSetID->dwFlags = 0;
        pColumnSetID->cBytes = sizeof(m_gColumnID);
        ::CopyMemory(pColumnSetID->id, &m_gColumnID, pColumnSetID->cBytes);
        
        hr = DataToGlobal( phGlobal, pColumnSetID, nSize2 );

        free( pColumnSetID );
    }

    return hr;
}

HRESULT CScopeNode::GetDisplayInfo(RESULTDATAITEM* pRDI)
{
    VALIDATE_POINTER( pRDI );

    if( pRDI->bScopeItem )
    {
        ASSERT(pRDI->lParam == reinterpret_cast<LPARAM>(this));

        if( pRDI->mask & RDI_STR )
            pRDI->str = const_cast<LPWSTR>(GetName());

        if( pRDI->mask & RDI_IMAGE )
            pRDI->nImage = GetImage();

        return S_OK;
    }

    return E_INVALIDARG;
}


HRESULT CScopeNode::GetDisplayInfo(SCOPEDATAITEM* pSDI)
{
    VALIDATE_POINTER( pSDI );

    if( pSDI->mask & SDI_STR )
        pSDI->displayname = const_cast<LPWSTR>(GetName());

    if( pSDI->mask & SDI_IMAGE )
        pSDI->nImage = GetImage();

    if( pSDI->mask & SDI_OPENIMAGE )
        pSDI->nOpenImage = GetOpenImage();

    if( pSDI->mask & SDI_CHILDREN )
        pSDI->cChildren = HasChildren() ? 1 : 0;

    if( pSDI->mask & SDI_PARAM )
        pSDI->lParam = reinterpret_cast<LPARAM>(this);

    return S_OK;
}


HRESULT CScopeNode::AttachComponent(CComponent* pComponent)
{
    VALIDATE_POINTER( pComponent );

    if( std::find(m_vComponents.begin(), m_vComponents.end(), pComponent) != m_vComponents.end() )
        return S_FALSE;

    m_vComponents.push_back(pComponent);

    return S_OK;
}


HRESULT CScopeNode::DetachComponent(CComponent* pComponent)
{
    VALIDATE_POINTER( pComponent );

    std::vector<CComponent*>::iterator it = std::find(m_vComponents.begin(), m_vComponents.end(), pComponent);
    if( it == m_vComponents.end() )
        return S_FALSE;

    m_vComponents.erase(it);

    return S_OK;
}


BOOL CScopeNode::OwnsConsoleView(LPCONSOLE2 pConsole)
{
    if( !pConsole ) return FALSE;

    std::vector<CComponent*>::iterator it;
    for( it = m_vComponents.begin(); it != m_vComponents.end(); ++it )
    {
        if( (*it)->GetConsole() == pConsole )
            return TRUE;
    }

    return FALSE;
}


HRESULT CScopeNode::GetResultViewType(LPOLESTR* ppViewType, long* pViewOptions)
{
    return S_FALSE;
}

/************************************************************************************
 * Notification handlers
 ************************************************************************************/

BEGIN_NOTIFY_MAP(CScopeNode)
ON_NOTIFY(MMCN_CONTEXTHELP, OnHelp)
ON_SELECT()
ON_EXPAND()
ON_RENAME() 
ON_REMOVE_CHILDREN()
ON_ADD_IMAGES()
END_NOTIFY_MAP()

HRESULT CScopeNode::OnHelp(LPCONSOLE2 pConsole, LPARAM /*arg*/, LPARAM /*param*/)
{
    VALIDATE_POINTER( pConsole );

    tstring strHelpFile  = _T("");
    tstring strHelpTopic = _T("");
    tstring strHelpFull  = _T("");    
        
    strHelpFile = StrLoadString(IDS_HELPFILE);
    if( strHelpFile.empty() ) return E_FAIL;

    // Special Hack to get a different help topic for the first two nodes.
    switch( m_lNodeID )
    {
    case 2:
        {
            // Users Node
            strHelpTopic = StrLoadString(IDS_USERSHELPTOPIC);
            break;
        }

    case 3:
        {
            // Printers Node
            strHelpTopic = StrLoadString(IDS_PRINTERSHELPTOPIC);
            break;
        }
    default:
        {            
            strHelpTopic = StrLoadString(IDS_DEFAULTHELPTOPIC);            
            break;
        }
    }    

    // Verify that we got a help topic!
    if( strHelpTopic.empty() ) return E_FAIL;

    // Build path to %systemroot%\help
    TCHAR szWindowsDir[MAX_PATH+1] = {0};
    UINT nSize = GetSystemWindowsDirectory( szWindowsDir, MAX_PATH );
    if( nSize == 0 || nSize > MAX_PATH )
    {
        return E_FAIL;
    }            

    strHelpFull  = szWindowsDir;
    strHelpFull += _T("\\Help\\");
    strHelpFull += strHelpFile;
    strHelpFull += _T("::/");
    strHelpFull += strHelpTopic;

    // Show the Help topic
    CComQIPtr<IDisplayHelp> spHelp = pConsole;
    if( !spHelp ) return E_NOINTERFACE;

    return spHelp->ShowTopic( (LPTSTR)strHelpFull.c_str() );
}

HRESULT CScopeNode::Insert(LPCONSOLENAMESPACE pNameSpace)
{
    if( !pNameSpace ) return E_POINTER;
    if( !m_pnodeParent ) return E_FAIL;
    ASSERT( m_pnodeParent->m_hScopeItem != 0 ); 
    ASSERT( m_hScopeItem == 0 );

    // if not set yet, get name from string table (mmc will ask for it after insertion)
    // (name will be set a new node and not set for reloaded nodes)
    if( m_strName.empty() )
    {
        IStringTable* pStringTable = GetCompData()->GetStringTable();
        ASSERT( pStringTable );
        if( !pStringTable ) return E_FAIL;

        HRESULT hr = StringTableRead(pStringTable, m_nameID, m_strName);
        ASSERT(SUCCEEDED(hr));
        RETURN_ON_FAILURE(hr);
    }

    SCOPEDATAITEM sdi;

    sdi.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN | SDI_PARENT;

    sdi.relativeID  = m_pnodeParent->m_hScopeItem;
    sdi.displayname = MMC_TEXTCALLBACK;         // MMC only allows callback for name
    sdi.nImage      = GetImage();
    sdi.nOpenImage  = GetOpenImage();
    sdi.cChildren   = HasChildren() ? 1 : 0;
    sdi.lParam      = reinterpret_cast<LPARAM>(this);

    HRESULT hr = pNameSpace->InsertItem(&sdi);

    if( SUCCEEDED(hr) )
        m_hScopeItem = sdi.ID;

    return hr;
}


HRESULT CScopeNode::OnExpand(LPCONSOLE2 pConsole, BOOL bExpand, HSCOPEITEM hScopeItem)
{
    VALIDATE_POINTER( pConsole );

    // Nothing to do on collapse
    if( !bExpand )
        return S_OK;

    // Scope item ID shouldn't change
    ASSERT(m_hScopeItem == 0 || m_hScopeItem == hScopeItem);

    // Save scope item ID
    m_hScopeItem = hScopeItem;

    // If expanding root node
    if( m_pnodeParent == NULL )
    {
        // Get Scope image list interface
        IImageListPtr spImageList;
        HRESULT hr = pConsole->QueryScopeImageList(&spImageList);
        ASSERT(SUCCEEDED(hr));

        // Add standard images to the scope pane
        if( SUCCEEDED(hr) )
        {
            hr = OnAddImages(pConsole, spImageList);
            ASSERT(SUCCEEDED(hr));
        }
    }

    // Get namespace interface
    IConsoleNameSpace* pNameSpace = GetCompData()->GetNameSpace();
    if( pNameSpace == NULL )
        return E_FAIL;

    // Step through child list and add each one to scope pane
    CScopeNode* pnode = FirstChild();
    while( pnode != NULL )
    {
        pnode->Insert(pNameSpace);
        pnode = pnode->m_pnodeNext;
    }

    return S_OK;
}


HRESULT CScopeNode::OnRename(LPCONSOLE2 pConsole, LPCWSTR pszName)
{
    if( pszName == NULL || pszName[0] == 0 )
        return E_INVALIDARG;

    return SetName(pszName);
}


HRESULT CScopeNode::SetName(LPCWSTR pszName)
{
    if( !pszName || !pszName[0] ) return E_POINTER;

    IStringTable* pStringTable = GetCompData()->GetStringTable();
    ASSERT( pStringTable );
    if( !pStringTable ) return E_FAIL;

    HRESULT hr = StringTableWrite(pStringTable, pszName, &m_nameID);
    RETURN_ON_FAILURE(hr);

    m_strName = pszName;  

    return S_OK;
}


HRESULT CScopeNode::OnRemoveChildren(LPCONSOLE2 pConsole)
{
    // Step through child list and release each one
    CScopeNode* pnode = m_pnodeChild;
    while( pnode != NULL )
    {
        CScopeNode* pnodeNext = pnode->m_pnodeNext;
        pnode->Release();
        pnode = pnodeNext;
    }

    m_pnodeChild = NULL;

    return S_OK;
}

HRESULT CScopeNode::OnAddImages(LPCONSOLE2 pConsole, LPIMAGELIST pImageList)
{
    VALIDATE_POINTER(pImageList);

    CBitmap bmp16;
    CBitmap bmp32;

    bmp16.LoadBitmap(IDB_QUERY16);
    bmp32.LoadBitmap(IDB_QUERY32);

    ASSERT(bmp16 != (HBITMAP)NULL && (HBITMAP)bmp32 != (HBITMAP)NULL);

    if( bmp16 == (HBITMAP)NULL || bmp32 == (HBITMAP)NULL )
        return E_FAIL;

    HRESULT hr = pImageList->ImageListSetStrip(
                                              (LONG_PTR*)static_cast<HBITMAP>(bmp16), 
                                              (LONG_PTR*)static_cast<HBITMAP>(bmp32),
                                              0, RGB(255,0,255));

    return hr;
}


HRESULT CScopeNode::OnSelect(LPCONSOLE2 pConsole, BOOL bSelect, BOOL bScope)
{
    VALIDATE_POINTER( pConsole );

    // See CScopeNode::OnRefresh for explanation of m_bIgnoreSelect
    if( bSelect && !m_bIgnoreSelect )
    {
        CComPtr<IConsoleVerb> spConsVerb;
        pConsole->QueryConsoleVerb(&spConsVerb);
        ASSERT(spConsVerb != NULL);
        if( !spConsVerb ) return E_NOINTERFACE;

        BOOL bOwnsView = OwnsConsoleView(pConsole);

        if( spConsVerb != NULL )
        {
            EnableVerbs(spConsVerb, bOwnsView);

            spConsVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);
            spConsVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN,  TRUE);

            spConsVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, FALSE); 
            spConsVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);

            spConsVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, FALSE);
            spConsVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);

            // default verb for scope nodes is open
            spConsVerb->SetDefaultVerb(MMC_VERB_OPEN);
        }
    }

    if( bSelect )
    {
        m_bIgnoreSelect = FALSE;
    }
      

    return S_OK;
}


/******************************************************************************************
 * Menus and verbs
 ******************************************************************************************/

BOOL AddMenuItem(LPCONTEXTMENUCALLBACK pCallback, long nID, long lInsertID, long lFlags, TCHAR* szNoLocName)
{
    if( !pCallback ) return FALSE;

    CComQIPtr<IContextMenuCallback2> spContext2 = pCallback;
    if( !spContext2 ) return FALSE;

    CONTEXTMENUITEM2 item;    

    CString strItem;
    strItem.LoadString(nID);
    ASSERT(!strItem.IsEmpty());

    int iSep = strItem.Find(L'\n');
    ASSERT(iSep != -1);

    CString strName = strItem.Left(iSep);
    CString strDescr = strItem.Right(strItem.GetLength() - iSep);

    item.strName = const_cast<LPWSTR>((LPCWSTR)strName);
    item.strStatusBarText = const_cast<LPWSTR>((LPCWSTR)strDescr);
    item.lCommandID = nID;
    item.lInsertionPointID = lInsertID;
    item.fFlags = lFlags;
    item.fSpecialFlags = 0;
    item.strLanguageIndependentName = szNoLocName;

    return SUCCEEDED(spContext2->AddItem(&item));
}


/*******************************************************************************************
 * Persistance methods
 ******************************************************************************************/
HRESULT CScopeNode::LoadNode(IStream& stm)
{
    stm >> m_nameID;    
    ASSERT(m_nameID != 0);

    stm >> m_lNodeID;
    stm >> m_gColumnID;

    return S_OK;
}


HRESULT CScopeNode:: SaveNode(IStream& stm)
{
    ASSERT(m_nameID != 0);
    stm << m_nameID;
    stm << m_lNodeID;
    stm << m_gColumnID;

    return S_OK;
}


HRESULT CScopeNode::Load(IStream& stm)
{
    HRESULT hr = LoadNode(stm);
    RETURN_ON_FAILURE(hr);

    // if container node, then load children
    if( IsContainer() )
    {
        NODETYPE nodetype;
        stm >> *(int*)&nodetype;       

        // If container has a child node
        if( nodetype != NULL_NODETYPE )
        {
            hr = CreateNode(nodetype, &m_pnodeChild);
            RETURN_ON_FAILURE(hr);

            // Set parent before loading, so node can pass it on when
            // it loads its siblings
            m_pnodeChild->m_pnodeParent = static_cast<CScopeNode*>(this);

            // Load first child only; it will load its siblings
            hr = m_pnodeChild->Load(stm);
            RETURN_ON_FAILURE(hr);
        }
    }

    // if this is the first child of a node, then load siblings
    // (Iteration rather than recursion to avoid a potentially
    //  very deep stack.)
    if( m_pnodeParent && m_pnodeParent->FirstChild() == this )
    {
        CScopeNode* pnodePrev = static_cast<CScopeNode*>(this);

        NODETYPE nodetype;
        stm >> *(int*)&nodetype;       

        // Loop until terminating null node type encountered
        while( nodetype != NULL_NODETYPE )
        {
            CScopeNodePtr spnode;
            hr = CreateNode(nodetype, &spnode);
            RETURN_ON_FAILURE(hr);

            spnode->m_pnodeParent = m_pnodeParent;

            hr = spnode->Load(stm);
            RETURN_ON_FAILURE(hr);

            // Link to previous sibling
            pnodePrev->m_pnodeNext = spnode.Detach();
            pnodePrev = pnodePrev->m_pnodeNext;

            stm >> *(int*)&nodetype;       
        }
    }

    return hr;
}


HRESULT CScopeNode::Save(IStream& stm)
{
    // Save the node's data
    HRESULT hr = SaveNode(stm);
    RETURN_ON_FAILURE(hr)

    // if container type node
    if( IsContainer() )
    {
        // Save children (first child saves all its siblings)
        if( FirstChild() )
        {
            stm << (int)FirstChild()->NodeType();
            hr = FirstChild()->Save(stm);
            RETURN_ON_FAILURE(hr)
        }

        // Terminate child list with null node
        stm << (int)NULL_NODETYPE;
    }

    // if this is the first child, save its siblings
    if( m_pnodeParent && m_pnodeParent->FirstChild() == this )
    {
        CScopeNode* pnode = m_pnodeNext;
        while( pnode != NULL )
        {
            stm << (int)pnode->NodeType();

            hr = pnode->Save(stm);
            BREAK_ON_FAILURE(hr);

            pnode = pnode->m_pnodeNext;
        }
    }

    return S_OK;
}


HRESULT CScopeNode::AddQueryNode(LPCONSOLE2 pConsole)
{
    VALIDATE_POINTER( pConsole );
    ASSERT(NodeType() != QUERY_NODETYPE);

    HRESULT hr;
    do
    {
        // Create a new query node
        CQueryNodePtr spnode;
        hr = CreateNode(QUERY_NODETYPE, reinterpret_cast<CScopeNode**>(&spnode));
        BREAK_ON_FAILURE(hr);

        // Create and init wizard
        CAddQueryWizard queryWiz;
        queryWiz.Initialize(spnode, GetRootNode(), GetCompData()->GetStringTable());

        // Run the wizard
        IPropertySheetProviderPtr spProvider = pConsole;        
        if( spProvider == NULL ) return E_NOINTERFACE;
    
        HWND hwndMain;
        pConsole->GetMainWindow(&hwndMain);

        hr = queryWiz.Run(spProvider, hwndMain);
        if( hr != S_OK )
            break;

        // Add any new classes to root node
        CRootNode* pRootNode = GetRootNode();
        if( pRootNode )
        {
            std::vector<CClassInfo*>::iterator itpClass;
            for( itpClass = queryWiz.GetNewClassInfo().begin(); itpClass != queryWiz.GetNewClassInfo().end(); ++itpClass )
            {            
                pRootNode->AddClass(*itpClass);
            }
        }

        // Add the new node
        hr = AddNewChild(spnode, queryWiz.GetQueryName());
    }
    while( FALSE );

    return hr;
}


HRESULT
CScopeNode::AddGroupNode(LPCONSOLE2 pConsole)
{
    ASSERT(NodeType() == ROOT_NODETYPE);

    HRESULT hr;
    do
    {
        // Create a new group node
        CGroupNodePtr spnode;
        hr = CreateNode(GROUP_NODETYPE, reinterpret_cast<CScopeNode**>(&spnode));
        BREAK_ON_FAILURE(hr);

        // Create Add Group Node dialog
        CAddGroupNodeDlg GrpDlg;

        // run dialog and add node as child if successful
        if( GrpDlg.DoModal(spnode, g_hwndMain) == IDOK )
            hr = AddNewChild(spnode, GrpDlg.GetNodeName());
    }
    while( FALSE );

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//
// CRootNode
//
////////////////////////////////////////////////////////////////////////////////////////////////


BEGIN_NOTIFY_MAP(CRootNode)
ON_NOTIFY(MMCN_CONTEXTHELP, OnHelp)
ON_PROPERTY_CHANGE()
CHAIN_NOTIFY_MAP(CScopeNode)
END_NOTIFY_MAP()

HRESULT CRootNode::Initialize(CComponentData* pCompData)
{
    VALIDATE_POINTER( pCompData );
    m_pCompData = pCompData;

    tstring strName = StrLoadString(IDS_ROOTNODE);
    RETURN_ON_FAILURE(SetName(strName.c_str()));

    // Set creation/modify times to now
    GetSystemTimeAsFileTime(&m_ftCreateTime);
    m_ftModifyTime = m_ftCreateTime;

    WCHAR szName[UNLEN+1];
    DWORD cName = UNLEN+1;

    // Set owner to current user
    if( GetUserName(szName, &cName) )
        m_strOwner = szName;

    return S_OK;
}

HRESULT CRootNode::OnHelp(LPCONSOLE2 pConsole, LPARAM /*arg*/, LPARAM /*param*/)
{
    VALIDATE_POINTER( pConsole );

    tstring strHelpFile  = _T("");
    tstring strHelpTopic = _T("");
    tstring strHelpFull  = _T("");    
        
    strHelpFile = StrLoadString(IDS_HELPFILE);
    if( strHelpFile.empty() ) return E_FAIL;

    // Verify that we got a help topic!
    strHelpTopic = StrLoadString(IDS_DEFAULTHELPTOPIC);
    if( strHelpTopic.empty() ) return E_FAIL;

    // Build path to %systemroot%\help
    TCHAR szWindowsDir[MAX_PATH+1] = {0};
    UINT nSize = GetSystemWindowsDirectory( szWindowsDir, MAX_PATH );
    if( nSize == 0 || nSize > MAX_PATH )
    {
        return E_FAIL;
    }            

    strHelpFull  = szWindowsDir;
    strHelpFull += _T("\\Help\\");
    strHelpFull += strHelpFile;
    strHelpFull += _T("::/");
    strHelpFull += strHelpTopic;

    // Show the Help topic
    CComQIPtr<IDisplayHelp> spHelp = pConsole;
    if( !spHelp ) return E_NOINTERFACE;

    return spHelp->ShowTopic( (LPTSTR)strHelpFull.c_str() );
}

HRESULT CRootNode::OnPropertyChange(LPCONSOLE2 pConsole, LPARAM lParam)
{
    VALIDATE_POINTER( lParam );
    string_vector* pvstrClassesChanged = reinterpret_cast<string_vector*>(lParam);

    // Notify all child nodes of class change
    CScopeNode* pNode = FirstChild();
    while( pNode != NULL )
    {
        ASSERT(pNode->NodeType() == QUERY_NODETYPE || pNode->NodeType() == GROUP_NODETYPE);

        static_cast<CQueryableNode*>(pNode)->OnClassChange(*pvstrClassesChanged);

        pNode = pNode->Next();
    }


    delete pvstrClassesChanged;

    return S_OK;
}

HRESULT CRootNode::GetResultViewType(LPOLESTR* ppViewType, long* pViewOptions)
{    
    VALIDATE_POINTER( ppViewType );
    VALIDATE_POINTER( pViewOptions );

    //Show our homepage snapin in this console    
    TCHAR szWindowsDir[MAX_PATH+1] = {0};
    UINT nSize = GetSystemWindowsDirectory( szWindowsDir, MAX_PATH );
    if( nSize == 0 || nSize > MAX_PATH )
    {
        return E_FAIL;
    }    
    
    tstring strHomePage = szWindowsDir;
    strHomePage += _T("\\system32\\administration\\servhome.htm");
    
    *ppViewType = (TCHAR*)CoTaskMemAlloc((strHomePage.length() + 1) * sizeof(OLECHAR));    
    VALIDATE_POINTER( *ppViewType );
    
    ocscpy( *ppViewType, T2OLE((LPTSTR)strHomePage.c_str()) );

    return S_OK;
}


HRESULT CRootNode::LoadNode(IStream& stm)
{
    HRESULT hr = CScopeNode::LoadNode(stm);
    RETURN_ON_FAILURE(hr);

    stm >> m_ftCreateTime;
    stm >> m_ftModifyTime;

    stm >> m_strOwner;
    stm >> m_commentID;

    stm >> m_vClassInfo;

    // Root node's Insert() method is never called, so load the name string here
    IStringTable* pStringTable = GetCompData()->GetStringTable();
    ASSERT( pStringTable );
    if( !pStringTable ) return E_FAIL;

    hr = StringTableRead(pStringTable, m_nameID, m_strName);
    RETURN_ON_FAILURE(hr);

    return S_OK;
}


HRESULT CRootNode::SaveNode(IStream& stm)
{
    HRESULT hr = CScopeNode::SaveNode(stm);
    RETURN_ON_FAILURE(hr);

    stm << m_ftCreateTime;
    stm << m_ftModifyTime;

    stm << m_strOwner;
    stm << m_commentID;

    stm << m_vClassInfo;

    return S_OK;
}


HRESULT CRootNode::GetComment(tstring& strComment)
{
    if( m_commentID == 0 )
    {
        strComment.erase();
        return S_OK;
    }
    else
    {
        IStringTable* pStringTable = GetCompData()->GetStringTable();
        ASSERT( pStringTable );
        if( !pStringTable ) return E_FAIL;

        return StringTableRead(pStringTable, m_commentID, strComment);
    }
}


HRESULT CRootNode::SetComment(LPCWSTR pszComment)
{
    VALIDATE_POINTER(pszComment);

    IStringTable* pStringTable = GetCompData()->GetStringTable();
    ASSERT( pStringTable );
    if( !pStringTable ) return E_FAIL;

    return StringTableWrite(pStringTable, pszComment, &m_commentID);
}


CClassInfo* CRootNode::FindClass(LPCWSTR pszClassName)
{
    if( !pszClassName ) return NULL;

    classInfo_vector::iterator itClass;
    for( itClass = m_vClassInfo.begin(); itClass != m_vClassInfo.end(); ++itClass )
    {
        if( wcscmp(pszClassName, itClass->Name()) == 0 )
            break;
    }

    if( itClass == m_vClassInfo.end() )
        return NULL;


    // Load any strings before returning the class info, so they will be
    // available when referenced
    IStringTable* pStringTable = GetRootCompData()->GetStringTable();
    if( !pStringTable ) return NULL;

    itClass->LoadStrings(pStringTable);

    return itClass;
}


HRESULT CRootNode::AddMenuItems(LPCONTEXTMENUCALLBACK pCallback, long* plAllowed)
{
    VALIDATE_POINTER( pCallback );
    VALIDATE_POINTER( plAllowed );

    HRESULT hr = S_OK;

    if( *plAllowed & CCM_INSERTIONALLOWED_NEW )
    {
        //hr = AddMenuItem(pCallback, MID_ADDGROUPNODE, CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, _T("NEWGROUPFROMROOT"));
        //ASSERT(SUCCEEDED(hr));

        //hr = AddMenuItem(pCallback, MID_ADDQUERYNODE, CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, _T("NEWQUERYFROMROOT"));
        //ASSERT(SUCCEEDED(hr));
    }

    return hr;
}



HRESULT CRootNode::MenuCommand(LPCONSOLE2 pConsole, long lCommand)
{
    VALIDATE_POINTER(pConsole);

    HRESULT hr;

    switch( lCommand )
    {
    case MID_ADDGROUPNODE:
        hr = AddGroupNode(pConsole);
        break;

    case MID_ADDQUERYNODE:
        hr = AddQueryNode(pConsole);
        break;

    default:
        ASSERT(0 && "Unknown menu command");
        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT CRootNode::QueryPagesFor()
{
    return S_OK;
}


HRESULT CRootNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK pProvider, LONG_PTR lNotifyHandle)
{
    // Create a share edit list for all the prop pages to reference
    CEditObjList* pObjList = new CEditObjList();
    if( pObjList == NULL ) return E_OUTOFMEMORY;

    // Keep it alive until prop pages ref it
    pObjList->AddRef();


    // Create an instance of each prop page class and call Create on each.

    // General page
    HPROPSHEETPAGE hpageGen = NULL;
    CRootGeneralPage* pGenPage = new CRootGeneralPage(*pObjList);
    if( pGenPage != NULL )
    {
        hpageGen = pGenPage->Create();
    }

    // Object page
    HPROPSHEETPAGE hpageObj = NULL;
    CRootObjectPage* pObjPage = new CRootObjectPage(*pObjList);
    if( pObjPage != NULL )
    {
        hpageObj = pObjPage->Create();
    }

    // Context menu page
    HPROPSHEETPAGE hpageMenu = NULL;
    CRootMenuPage* pMenuPage = new CRootMenuPage(*pObjList);
    if( pMenuPage != NULL )
    {
        hpageMenu = pMenuPage->Create();
    }

    // Listview page
    HPROPSHEETPAGE hpageView = NULL;
    CRootViewPage* pViewPage = new CRootViewPage(*pObjList);
    if( pViewPage != NULL )
    {
        hpageView = pViewPage->Create();
    }

    HRESULT hr = E_OUTOFMEMORY;

    // if all pages were created, add each one to the prop sheet
    if( hpageGen && hpageObj && hpageMenu && hpageView )
    {
        hr = pProvider->AddPage(hpageGen);

        if( SUCCEEDED(hr) )
            hr = pProvider->AddPage(hpageObj);
        if( SUCCEEDED(hr) )
            hr = pProvider->AddPage(hpageMenu);

        if( SUCCEEDED(hr) )
            hr = pProvider->AddPage(hpageView);
    }

    // If ok so far, initialilze the common edit list
    // It is now responsible for freeing the notify handle (and itself)
    if( SUCCEEDED(hr) )
        hr = pObjList->Initialize(this, m_vClassInfo, lNotifyHandle);


    // On failure, destroy the pages. If a page failed to create
    // then delete the page class object instead (the object is
    // automatically deleted when the page is destroyed)
    if( FAILED(hr) )
    {
        if( hpageGen )
            DestroyPropertySheetPage(hpageGen);
        else
            SAFE_DELETE(pGenPage);

        if( hpageObj )
            DestroyPropertySheetPage(hpageObj);
        else
            SAFE_DELETE(pObjPage);

        if( hpageMenu )
            DestroyPropertySheetPage(hpageMenu);
        else
            SAFE_DELETE(pMenuPage);

        if( hpageView )
            DestroyPropertySheetPage(hpageView);
        else
            SAFE_DELETE(pViewPage);
    }

    // Release temp ref on edit list
    // it will go away when the prop pages release it
    pObjList->Release();

    return hr;
}

HRESULT CRootNode::GetWatermarks(HBITMAP* phWatermark, HBITMAP* phHeader, 
                         HPALETTE* phPalette, BOOL* bStreach)
{
    return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////////
//
// CQueryableNode
//
///////////////////////////////////////////////////////////////////////////////////

HRESULT CQueryableNode::AttachComponent(CComponent* pComponent)
{
    VALIDATE_POINTER( pComponent );

    HRESULT hr = CScopeNode::AttachComponent(pComponent);
    if( hr != S_OK )
        return hr;

    // Get attributes query will collect
    attrib_map mapAttr;

    hr = GetQueryAttributes(mapAttr);
    RETURN_ON_FAILURE(hr);

    // Add column header for each attribute
    IHeaderCtrl* pHdrCtrl = pComponent->GetHeaderCtrl();
    ASSERT( pHdrCtrl );
    if( !pHdrCtrl ) return E_FAIL;

    int iPos = 0;

    // Always add Name and Type columns first
    CString strName;
    strName.LoadString(IDS_NAME);
    pHdrCtrl->InsertColumn(iPos++, strName, LVCFMT_LEFT, 200);

    strName.LoadString(IDS_TYPE);
    pHdrCtrl->InsertColumn(iPos++, strName, LVCFMT_LEFT, 100);

    // Add user selected attributes next (use display name which is the map value)
    attrib_map::iterator itCol;
    for( itCol = mapAttr.begin(); itCol != mapAttr.end(); itCol++ )
    {
        pHdrCtrl->InsertColumn(iPos++, itCol->second, LVCFMT_LEFT, 150);
    }

    // if need to execute query and one is not in progress
    if( m_bQueryChange && m_pQueryReq == NULL )
    {
        // Create vector of query attribute names
        m_vstrColumns.clear();

        if( mapAttr.size() != 0 )
        {
            m_vstrColumns.reserve(mapAttr.size());

            attrib_map::iterator itAttr;
            for( itAttr = mapAttr.begin(); itAttr != mapAttr.end(); itAttr++ )
                m_vstrColumns.push_back(itAttr->first);
        }

        // Clear previous query items
        ClearQueryRowItems();

        // Start the query
        hr = StartQuery(m_vstrColumns, this, &m_pQueryReq);

        // if query started (note group node returns S_FALSE if no children) 
        if( hr == S_OK )
        {
            // Enable stop query button for all attached components
            std::vector<CComponent*>::iterator itComp;
            for( itComp = m_vComponents.begin(); itComp != m_vComponents.end(); itComp++ )
            {
                IToolbar* pToolbar = (*itComp)->GetToolbar();
                if( pToolbar )
                    pToolbar->SetButtonState(MID_STOPQUERY, ENABLED, TRUE);
            }
        }

        // allow node to be attached even if query fails
        hr = S_OK;
    }
    else
    {
        // Replace component's row items with ours
        pComponent->ClearRowItems();
        pComponent->AddRowItems(m_vRowItems);
    }

    return hr;
}


void CQueryableNode::ClearQueryRowItems()
{
    // discard local row items
    m_vRowItems.clear();

    // Clear all attached components rows
    std::vector<CComponent*>::iterator itComp;
    for( itComp = m_vComponents.begin(); itComp != m_vComponents.end(); itComp++ )
        (*itComp)->ClearRowItems();
}


void CQueryableNode::QueryCallback(QUERY_NOTIFY event, CQueryRequest* pQueryReq, LPARAM lUserParam)
{    
    ASSERT(pQueryReq && pQueryReq == m_pQueryReq);
    if( !pQueryReq || pQueryReq != m_pQueryReq ) return;

    CString strMsgFmt;

    switch( event )
    {
    case QRYN_NEWROWITEMS:
        {
            // Get new row items 
            RowItemVector& newRows = pQueryReq->GetNewRowItems();

            DisplayNameMap* pNameMap = DisplayNames::GetClassMap(); //use for icon/class lookup
            if( !pNameMap ) return;

            LPCWSTR strClassName;                 //holds the name of the current lookup class
            static tstring strLastName;           //holds the last lookup class name
            static ICONHOLDER* pLastIcons = NULL; //holds the indices of the last icon lookup

            // Attach owner query node (passed as user param) to each row item 
            for( RowItemVector::iterator itRow = newRows.begin(); itRow != newRows.end(); ++itRow )
            {
                itRow->SetOwnerParam(lUserParam);

                //establish icon virtual index
                strClassName = (*itRow)[ROWITEM_CLASS_INDEX];
                if( strLastName.compare(strClassName) != 0 )
                {
                    //new class type requested. Load from namemap and cache.
                    pNameMap->GetIcons(strClassName, &pLastIcons);
                    strLastName = strClassName;

                }
                
                //use the cached normal/disabled icon depending on object state
                if( pLastIcons )
                {
                    if( itRow->Disabled() )
                        itRow->SetIconIndex(pLastIcons->iDisabled);
                    else
                        itRow->SetIconIndex(pLastIcons->iNormal);
                }
            }

            // Add to node's vector
            m_vRowItems.insert(m_vRowItems.end(), newRows.begin(), newRows.end());

            // Add to all attach components
            std::vector<CComponent*>::iterator itComp;
            for( itComp = m_vComponents.begin(); itComp != m_vComponents.end(); itComp++ )
                (*itComp)->AddRowItems(newRows);

            // Free the rows
            pQueryReq->ReleaseNewRowItems();

            strMsgFmt.LoadString(IDS_SEARCHING);        
            break;
        }

    case QRYN_COMPLETED:
        m_bQueryChange = FALSE;
        strMsgFmt.LoadString(IDS_QUERYDONE);
        break;

    case QRYN_STOPPED:
        strMsgFmt.LoadString(IDS_QUERYSTOPPED);
        break;

    case QRYN_FAILED:
        strMsgFmt.LoadString(IDS_QUERYFAILED);
        break;

    default:
        ASSERT(FALSE);
        return;
    }

    // if components attached, display query progress
    if( m_vComponents.size() != 0 )
    {
        CString strMsg;
        strMsg.Format(strMsgFmt, m_vRowItems.size());

        std::vector<CComponent*>::iterator itComp;
        for( itComp = m_vComponents.begin(); itComp != m_vComponents.end(); ++itComp )
        {
            (*itComp)->GetConsole()->SetStatusText((LPWSTR)(LPCWSTR)strMsg);
        }
    }


    // if query terminated, do cleanup
    if( event != QRYN_NEWROWITEMS )
    {
        pQueryReq->Release();
        m_pQueryReq = NULL;

        // disable query stop button for all components
        std::vector<CComponent*>::iterator itComp;
        for( itComp = m_vComponents.begin(); itComp != m_vComponents.end(); ++itComp )
        {
            IToolbar* pToolbar = (*itComp)->GetToolbar();
            if( pToolbar )
                pToolbar->SetButtonState(MID_STOPQUERY, ENABLED, FALSE);
        }
    }
}

HRESULT CQueryableNode::DetachComponent(CComponent* pComponent)
{
    VALIDATE_POINTER( pComponent );

    HRESULT hr = CScopeNode::DetachComponent(pComponent);
    if( hr != S_OK )
    {
        return FAILED(hr) ? hr : E_FAIL;
    }

    // if that was the last one, stop active query 
    if( m_vComponents.size() == 0 && m_pQueryReq != NULL )
        m_pQueryReq->Stop(TRUE);

    return S_OK;
}

HRESULT CQueryableNode::OnRefresh(LPCONSOLE2 pCons)
{
    // if query in progress stop it
    if( m_pQueryReq != NULL )
    {
        m_pQueryReq->Stop(TRUE);
    }

    // Set change flag to force new query
    m_bQueryChange = TRUE;
    

    // Have each attached component reselect this node
    std::vector<CComponent*>::iterator itComp;
    for( itComp = m_vComponents.begin(); itComp != m_vComponents.end(); itComp++ )
    {
        // Here's a kludge to get around an MMC bug. If the snap-in reselects its scope node
        // while the focus is on a taskpad background, then MMC sends a deselect/select
        // sequence to the snap-in causing it to enable its verbs. But if the user then clicks
        // an enabled tool button (e.g., Rename) nothing happens other than an MMC assert
        // because MMC thinks nothing is selected.
        //
        // The fix is to check the state of the properties verbs prior to doing a reselect.
        // If the verb is disabled then don't enabled it (or any other verbs) when the select 
        // notify is received. This has to be done per component because each may have a
        // different pane focused.

        CComPtr<IConsoleVerb> spConsVerb;
        (*itComp)->GetConsole()->QueryConsoleVerb(&spConsVerb);

        ASSERT(spConsVerb != NULL);
        if( spConsVerb != NULL )
        {
            // Ignore select notify if verbs are disabled before the reselect
            static BOOL bEnabled;
            if( spConsVerb->GetVerbState(MMC_VERB_PROPERTIES, ENABLED, &bEnabled) == S_OK )
            {
                m_bIgnoreSelect = !bEnabled;
            }
        }

        (*itComp)->GetConsole()->SelectScopeItem(m_hScopeItem);

        // Go back to normal select processing
        ASSERT(!m_bIgnoreSelect);
        m_bIgnoreSelect = FALSE;
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////
//
// CGroupNode
//
////////////////////////////////////////////////////////////////////////////////////////////////

BEGIN_NOTIFY_MAP(CGroupNode)
ON_REFRESH()
ON_DELETE()
ON_ADD_IMAGES()
CHAIN_NOTIFY_MAP(CScopeNode)
END_NOTIFY_MAP()

HRESULT CGroupNode::AddMenuItems(LPCONTEXTMENUCALLBACK pCallback, long* plAllowed)
{
    VALIDATE_POINTER( plAllowed );

    BOOL bRes = TRUE;

    if( *plAllowed & CCM_INSERTIONALLOWED_NEW )
    {
        bRes = AddMenuItem(pCallback, MID_ADDQUERYNODE, CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, _T("NEWQUERYFROMGROUP"));
        ASSERT(bRes);
    }

    return bRes ? S_OK : E_FAIL;
}


HRESULT CGroupNode::MenuCommand(LPCONSOLE2 pConsole, long lCommand)
{
    VALIDATE_POINTER(pConsole);

    HRESULT hr;

    switch( lCommand )
    {
    
    case MID_ADDQUERYNODE:
        hr = AddQueryNode(pConsole);
        break;

    default:
        ASSERT(0 && "Unknown menu command");
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CGroupNode::GetResultViewType(LPOLESTR* ppViewType, long* pViewOptions)
{
    VALIDATE_POINTER( pViewOptions );

    *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;

    return S_FALSE;
}

HRESULT CGroupNode::QueryPagesFor()
{
    return S_OK;
}


HRESULT CGroupNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK pProvider, LONG_PTR handle)
{
    // Create a group edit object
    CGroupEditObj* pEditObj = new CGroupEditObj(this);
    if( !pEditObj ) return E_OUTOFMEMORY;

    // Create an instance of each prop page class and call Create on each.

    // Keep it alive until prop pages ref it    
    pEditObj->AddRef();

    // General page
    HPROPSHEETPAGE hpageGen = NULL;
    CGroupGeneralPage* pGenPage = new CGroupGeneralPage(pEditObj);
    if( pGenPage != NULL )
    {
        hpageGen = pGenPage->Create();
    }

    HRESULT hr = E_FAIL;

    // if all pages were created, add each one to the prop sheet
    if( hpageGen )
    {
        hr = pProvider->AddPage(hpageGen);
    }

    // On failure, destroy the pages. If a page failed to create
    // then delete the page class object instead (the object is
    // automatically deleted when the page is destroyed)

    if( FAILED(hr) )
    {
        if( hpageGen )
            DestroyPropertySheetPage(hpageGen);
        else
            SAFE_DELETE(pGenPage);
    }

    // Release temp ref on edit list
    // it will go away when the prop pages release it
    pEditObj->Release();

    return hr;
}

HRESULT CGroupNode::GetQueryAttributes(attrib_map& mapAttr)
{
    // Get union of attributes for child query nodes
    CScopeNode* pNode = FirstChild();
    while( pNode != NULL )
    {
        ASSERT(pNode->NodeType() == QUERY_NODETYPE);
        CQueryNode* pQNode = static_cast<CQueryNode*>(pNode);

        // if query defined for this node, get the attributes
        if( pQNode->Query() && pQNode->Query()[0] )
            pQNode->GetQueryAttributes(mapAttr);

        pNode = pNode->Next();
    }

    return S_OK;
}


HRESULT CGroupNode::StartQuery(string_vector& vstrColumns, CQueryCallback* pCallback, CQueryRequest** ppReq)
{
    VALIDATE_POINTER( pCallback );
    VALIDATE_POINTER( ppReq );

    *ppReq = NULL;

    // if no children, there is no query to perform
    if( FirstChild() == NULL )
        return S_FALSE;

    ASSERT(FirstChild()->NodeType() == QUERY_NODETYPE);
    CQueryNode* pQNode = static_cast<CQueryNode*>(FirstChild());

    // Start a query one the first one
    HRESULT hr = pQNode->StartQuery(vstrColumns, pCallback, ppReq);

    // Save pointer to active query node for callback handler
    if( SUCCEEDED(hr) )
        m_pQNodeActive = pQNode;

    return hr;
}


void CGroupNode::QueryCallback(QUERY_NOTIFY event, CQueryRequest* pQueryReq, LPARAM lUserParam)
{
    if( !pQueryReq || !m_pQNodeActive || (pQueryReq != m_pQueryReq) ) return;    

    // if current query is complete and there are more child query nodes
    if( event == QRYN_COMPLETED && m_pQNodeActive->Next() != NULL )
    {
        CQueryNode* pQNodeNext = static_cast<CQueryNode*>(m_pQNodeActive->Next());

        // Start a query on the next child node
        CQueryRequest* pReqNew = NULL;
        HRESULT hr = pQNodeNext->StartQuery(m_vstrColumns, this, &pReqNew);

        if( SUCCEEDED(hr) )
        {
            // Release the current query node and save new query and node
            pQueryReq->Release();
            m_pQueryReq = pReqNew;

            m_pQNodeActive = pQNodeNext;

            // Bypass normal query termination processing
            return;
        }
    }

    // Do common callback processing
    CQueryableNode::QueryCallback(event, pQueryReq, lUserParam);
}


void CGroupNode::EnableVerbs(IConsoleVerb* pConsVerb, BOOL bOwnsView)
{
    if( bOwnsView && pConsVerb )
    {
        pConsVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);        
    }
}


HRESULT CGroupNode::OnDelete(LPCONSOLE2 pConsole)
{
    // Get namespace interface
    IConsoleNameSpacePtr spNameSpace = pConsole;
    ASSERT(spNameSpace != NULL);
    if( spNameSpace == NULL )
        return E_FAIL;

    // Get confirmation from user before deleting node 
    CString strTitle;
    strTitle.LoadString(IDS_DELETENODE_TITLE);

    CString strMsgFmt;
    strMsgFmt.LoadString(IDS_DELETEGROUPNODE);

    CString strMsg;
    strMsg.Format(strMsgFmt, GetName()); 

    int iRet;
    HRESULT hr = pConsole->MessageBox(strMsg, strTitle, MB_YESNOCANCEL|MB_ICONWARNING, &iRet);

    if( SUCCEEDED(hr) && (iRet == IDYES || iRet == IDNO) )
    {
        // if No, move child nodes up one level before deleting this node
        if( iRet == IDNO )
        {
            // Move each child to the parent of this node
            CScopeNode* pnodeChild = m_pnodeChild;
            while( pnodeChild != NULL )
            {
                // Detach each child from old list before adding it
                CScopeNode* pnodeNext = pnodeChild->m_pnodeNext;
                pnodeChild->m_pnodeNext = NULL;

                // clear the item handle associated with the old position
                // MMC will provide a new one when the node is added
                pnodeChild->m_hScopeItem = NULL;

                Parent()->AddChild(pnodeChild);

                // Release because new parent has ref'd it
                pnodeChild->Release();

                pnodeChild = pnodeNext;
            }

            // Set child list to NULL
            m_pnodeChild = NULL;
        }

        // Tell MMC to delete this node and all the children
        ASSERT(m_hScopeItem != 0);
        hr = spNameSpace->DeleteItem(m_hScopeItem, TRUE);

        // Caution: this call will usually delete this object, 
        // so don't access any members after making it
        if( SUCCEEDED(hr) )
            hr = Parent()->RemoveChild(this);
    }

    return hr;
}

HRESULT
CGroupNode::OnAddImages(LPCONSOLE2 pConsole, LPIMAGELIST pImageList)
{

    CScopeNode* pNode = FirstChild();
    while( pNode != NULL )
    {
        ASSERT(pNode->NodeType() == QUERY_NODETYPE);
        static_cast<CQueryNode*>(pNode)->OnAddImages(pConsole, pImageList);    
        pNode = pNode->Next();
    }

    return S_OK;
}

BOOL
CGroupNode::OnClassChange(string_vector& vstrClasses)
{

    BOOL bChanged = FALSE;

    // Notify all child query nodes of class change
    CScopeNode* pnode = FirstChild();
    while( pnode != NULL )
    {
        // Set change flag if any child node has changed
        ASSERT(pnode->NodeType() == QUERY_NODETYPE);

        bChanged |= static_cast<CQueryNode*>(pnode)->OnClassChange(vstrClasses);             

        pnode = pnode->m_pnodeNext;
    }

    // if any child has changed, need to rerun the group query
    if( bChanged )
        OnRefresh(NULL);

    return bChanged;
}


HRESULT
CGroupNode::LoadNode(IStream& stm)
{
    HRESULT hr = CScopeNode::LoadNode(stm);
    RETURN_ON_FAILURE(hr);

    stm >> m_strScope;
    stm >> m_strFilter;
    stm >> m_bApplyScope;
    stm >> m_bApplyFilter;
    stm >> m_bLocalScope;

    return S_OK;
}


HRESULT CGroupNode::SaveNode(IStream& stm)
{
    HRESULT hr = CScopeNode::SaveNode(stm);
    RETURN_ON_FAILURE(hr);

    stm << m_strScope;
    stm << m_strFilter;
    stm << m_bApplyScope;
    stm << m_bApplyFilter;
    stm << m_bLocalScope;

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////
//
// CQueryNode
//
////////////////////////////////////////////////////////////////////////////////////////////////

BEGIN_NOTIFY_MAP(CQueryNode)
ON_REFRESH()
ON_DELETE()
ON_ADD_IMAGES()
CHAIN_NOTIFY_MAP(CScopeNode)
END_NOTIFY_MAP()


HRESULT CQueryNode::GetResultViewType(LPOLESTR* ppViewType, long* pViewOptions)
{
    VALIDATE_POINTER( pViewOptions );

    *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;

    return S_FALSE;
}


HRESULT CQueryNode::GetDisplayInfo(RESULTDATAITEM* pRDI)
{
    VALIDATE_POINTER( pRDI );

    if( !pRDI->bScopeItem )
    {
        if( pRDI->nIndex < 0 || pRDI->nIndex >= m_vRowItems.size() )
            return E_INVALIDARG;

        if( pRDI->mask & RDI_STR )
            pRDI->str = const_cast<LPWSTR>(m_vRowItems[pRDI->nIndex][pRDI->nCol]);

        if( pRDI->mask & RDI_IMAGE )
            pRDI->nImage = RESULT_ITEM_IMAGE;

        return S_OK;
    }
    else
    {
        return CScopeNode::GetDisplayInfo(pRDI);
    }
}

HRESULT CQueryNode::GetClassMenuItems(LPCWSTR pszClass, menucmd_vector& vMenus, int* piDefault, BOOL* pbPropertyMenu)
{
    VALIDATE_POINTER( pszClass );
    VALIDATE_POINTER( piDefault );
    VALIDATE_POINTER( pbPropertyMenu );
    
    *piDefault = -1;
    *pbPropertyMenu = TRUE;

    QueryObjVector::iterator itQObj;
    for( itQObj = Objects().begin(); itQObj != Objects().end(); ++itQObj )
    {
        if( wcscmp(itQObj->Name(), pszClass) == 0 )
            break;
    }

    if( itQObj == Objects().end() )
        return S_FALSE;

    CRootNode* pRootNode = GetRootNode();
    if( pRootNode == NULL )
        return S_FALSE;

    CClassInfo* pClassInfo = pRootNode->FindClass(pszClass);
    if( pClassInfo == NULL )
        return S_FALSE;

    menuref_vector& vMenuRefs = itQObj->MenuRefs();
    menuref_vector::iterator itMenuRef;

    menucmd_vector& vMenuCmds = pClassInfo->Menus();
    menucmd_vector::iterator itMenuCmd;

    // First add all root menu items that preceed the first query menu item
    for( itMenuCmd = vMenuCmds.begin(); itMenuCmd != vMenuCmds.end(); ++itMenuCmd )
    {
        if( std::find(vMenuRefs.begin(), vMenuRefs.end(), (*itMenuCmd)->ID()) != vMenuRefs.end() )
            break;

        vMenus.push_back(*itMenuCmd);
    }

    // For each query menu item
    for( itMenuRef = vMenuRefs.begin(); itMenuRef != vMenuRefs.end(); ++itMenuRef )
    {
        // Find the root menu item by name
        for( itMenuCmd = vMenuCmds.begin(); itMenuCmd != vMenuCmds.end(); ++itMenuCmd )
        {
            if( (*itMenuCmd)->ID() == itMenuRef->ID() )
                break;
        }

        // if item was deleted at the root node, then skip it
        if( itMenuCmd == vMenuCmds.end() )
            continue;

        // If item is enabled at query level add it to the list
        if( itMenuRef->IsEnabled() )
        {
            vMenus.push_back(*itMenuCmd);

            if( itMenuRef->IsDefault() )
                *piDefault = vMenus.size() - 1;
        }

        ++itMenuCmd;

        // Add any following root items that aren't in the query list
        while( itMenuCmd != vMenuCmds.end() &&
               std::find(vMenuRefs.begin(), vMenuRefs.end(), (*itMenuCmd)->ID()) == vMenuRefs.end() )
        {
            vMenus.push_back(*itMenuCmd);
            ++itMenuCmd;
        } 
    }

    *pbPropertyMenu = itQObj->HasPropertyMenu();

    return S_OK;
}



HRESULT CQueryNode::GetQueryAttributes(attrib_map& mapAttr)
{
    CRootNode* pRootNode = GetRootNode();
    if( !pRootNode ) return E_UNEXPECTED;

    QueryObjVector::iterator itQObj;
    for( itQObj = m_vObjInfo.begin(); itQObj != m_vObjInfo.end(); ++itQObj )
    {
        // skip classes that aren't defined at the root
        CClassInfo* pClassInfo = pRootNode->FindClass(itQObj->Name());
        if( pClassInfo == NULL )
            continue;

        // get display name map for this class
        DisplayNameMap* pNameMap = DisplayNames::GetMap(itQObj->Name());
        ASSERT(pNameMap != NULL);
        if( pNameMap == NULL )
            continue;

        // Use all attributes defined at the root level that aren't disabled at the query level
        string_vector& vstrDisabled = itQObj->DisabledColumns();
        string_vector::iterator itCol;
        for( itCol = pClassInfo->Columns().begin(); itCol != pClassInfo->Columns().end(); ++itCol )
        {
            if( std::find(vstrDisabled.begin(), vstrDisabled.end(), *itCol) == vstrDisabled.end() )
            {
                mapAttr.insert(attrib_map::value_type
                               (itCol->c_str(), pNameMap->GetAttributeDisplayName(itCol->c_str())));
            }
        }
    }

    return S_OK;
}


HRESULT CQueryNode::StartQuery(string_vector& vstrColumns, CQueryCallback* pQueryCallback, CQueryRequest** ppQueryReq)
{
    VALIDATE_POINTER( pQueryCallback );
    VALIDATE_POINTER( ppQueryReq );

    *ppQueryReq = NULL;

    // Create a query request object
    CQueryRequest* pQueryReq = NULL;

    HRESULT hr = S_OK;
    
    // Get query scope and filter
    LPCWSTR pszScope = Scope();

    tstring strTempFilter;
    ExpandQuery(strTempFilter);
    LPCWSTR pszFilter = strTempFilter.c_str();

    CString strJointFilter;

    // Check for scope or filter override by parent group node
    if( Parent()->NodeType() == GROUP_NODETYPE )
    {
        CGroupNode* pGrpNode = static_cast<CGroupNode*>(Parent());

        // if group imposed scope, use it instead
        if( pGrpNode->ApplyScope() )
            pszScope = pGrpNode->Scope();

        // if group imposed filter, AND it with query filter
        if( pGrpNode->ApplyFilter() )
        {
            strJointFilter.Format(L"(&(%s)(%s))", strTempFilter.c_str(), pGrpNode->Filter());
            pszFilter = strJointFilter;
        }
    }

    // Get list of object classes expected from query
    string_vector vstrClasses;
    QueryObjVector::iterator itQObj;
    for( itQObj = m_vObjInfo.begin(); itQObj != m_vObjInfo.end(); ++itQObj )
        vstrClasses.push_back(itQObj->Name());

    // Set query parameters
    hr = CQueryRequest::CreateInstance(&pQueryReq);
    if( SUCCEEDED(hr) )
    {
        pQueryReq->SetQueryParameters(pszScope, pszFilter, &vstrClasses, &vstrColumns);

        // Set search preferences
        ADS_SEARCHPREF_INFO srchPrefs[3];

        srchPrefs[0].dwSearchPref   = ADS_SEARCHPREF_SEARCH_SCOPE;
        srchPrefs[0].vValue.dwType  = ADSTYPE_INTEGER;
        srchPrefs[0].vValue.Integer = ADS_SCOPE_SUBTREE;

        srchPrefs[1].dwSearchPref   = ADS_SEARCHPREF_PAGESIZE;
        srchPrefs[1].vValue.dwType  = ADSTYPE_INTEGER;
        srchPrefs[1].vValue.Integer = 32;

        srchPrefs[2].dwSearchPref   = ADS_SEARCHPREF_ASYNCHRONOUS;
        srchPrefs[2].vValue.dwType  = ADSTYPE_BOOLEAN;
        srchPrefs[2].vValue.Boolean = TRUE;

        pQueryReq->SetSearchPreferences(srchPrefs, lengthof(srchPrefs));

        // Set callback info (pass query node ptr as parameter)
        pQueryReq->SetCallback(pQueryCallback, (LPARAM)this);

        // Start query
        hr = pQueryReq->Start();
    }

    if( SUCCEEDED(hr) )
    {
        // Return active query pointer
        *ppQueryReq = pQueryReq;
    }

    if( FAILED(hr) && pQueryReq )
    {
        pQueryReq->Release();
        pQueryReq = NULL;
    }

    return hr;
}

HRESULT
CQueryNode::GetComment(tstring& strComment)
{
    if( m_commentID == 0 )
    {
        strComment.erase();
        return S_OK;
    }
    else
    {
        IStringTable* pStringTable = GetCompData()->GetStringTable();
        ASSERT(pStringTable != NULL);

        return StringTableRead(pStringTable, m_commentID, strComment);
    }
}


HRESULT CQueryNode::SetComment(LPCWSTR pszComment)
{
    VALIDATE_POINTER(pszComment);

    IStringTable* pStringTable = GetCompData()->GetStringTable();
    ASSERT( pStringTable );
    if( !pStringTable ) return E_FAIL;

    return StringTableWrite(pStringTable, pszComment, &m_commentID);
}


HRESULT CQueryNode::OnDelete(LPCONSOLE2 pConsole)
{
    // Get namespace interface
    IConsoleNameSpacePtr spNameSpace = pConsole;
    ASSERT(spNameSpace != NULL);
    if( spNameSpace == NULL )
        return E_FAIL;

    // Get confirmation from user before deleting node 
    CString strTitle;
    strTitle.LoadString(IDS_DELETENODE_TITLE);

    CString strMsgFmt;
    strMsgFmt.LoadString(IDS_DELETEQUERYNODE);

    CString strMsg;
    strMsg.Format(strMsgFmt, GetName()); 

    int iRet;
    HRESULT hr = pConsole->MessageBox(strMsg, strTitle, MB_YESNO|MB_ICONWARNING, &iRet);
    if( SUCCEEDED(hr) && iRet == IDYES )
    {
        ASSERT(m_hScopeItem != 0);
        hr = spNameSpace->DeleteItem(m_hScopeItem, TRUE);

        // Caution: this call will usually delete this object, 
        // so don't access any members after making it
        if( SUCCEEDED(hr) )
            hr = Parent()->RemoveChild(this);
    }

    return hr;
}

BOOL CQueryNode::OnClassChange(string_vector& vstrClasses)
{
    BOOL bChanged = FALSE;

    // Check if this node's query returns objects of a changed class
    // (object types returned by the query will be in the ObjInfo vector) 
    QueryObjVector::iterator itQObj;
    for( itQObj = m_vObjInfo.begin(); itQObj != m_vObjInfo.end(); ++itQObj )
    {
        if( std::find(vstrClasses.begin(), vstrClasses.end(), itQObj->Name()) != vstrClasses.end() )
        {
            bChanged = TRUE;
            break;
        }
    }

    // if a queried class has changed, refresh the query    
    if( bChanged )
        OnRefresh(NULL);

    return bChanged;
}

HRESULT CQueryNode::OnAddImages(LPCONSOLE2 pConsole, LPIMAGELIST pImageList)
{
    VALIDATE_POINTER(pImageList);

    std::vector<CQueryObjInfo>::iterator vecIter;
    DisplayNameMap* pNameMap = DisplayNames::GetClassMap();
    if( !pNameMap ) return E_FAIL;
    
    ICONHOLDER* pIH = NULL;

    // iterate through classes to be displayed. Call the global namemap
    // to determine icons for each class. Load both large and small icons.
    for( vecIter = m_vObjInfo.begin(); vecIter != m_vObjInfo.end(); vecIter++ )
    {
        //check for class name in namemap
        if( pNameMap->GetIcons(pNameMap->GetFriendlyName(vecIter->Name()), &pIH) && pIH )
        {
            //verify normal icon exists
            if( pIH->hSmall )
            {
                pImageList->ImageListSetIcon((LONG_PTR *)pIH->hSmall, pIH->iNormal); // add small icon
                pImageList->ImageListSetIcon((LONG_PTR *)pIH->hLarge, ILSI_LARGE_ICON(pIH->iNormal)); // add large icon
            }
            //verify disabled icon exists
            if( pIH->hSmallDis )
            {
                pImageList->ImageListSetIcon((LONG_PTR *)pIH->hSmallDis, pIH->iDisabled); // add small disabled icon
                pImageList->ImageListSetIcon((LONG_PTR *)pIH->hLargeDis, ILSI_LARGE_ICON(pIH->iDisabled)); // add large disabled icon
            }
        }
    }
    return CScopeNode::OnAddImages(pConsole, pImageList); //add default images too
}

HRESULT
CQueryNode::LoadNode(IStream& stm)
{
    HRESULT hr = CScopeNode::LoadNode(stm);
    RETURN_ON_FAILURE(hr);

    stm >> m_strScope;
    stm >> m_strQuery;
    stm >> m_bsQueryData;
    stm >> m_commentID;
    stm >> m_vObjInfo;
    stm >> m_bLocalScope;
    stm >> m_vMenus;
    
    if( g_dwFileVer >= 150 )
    {
        stm >> m_nIconIndex;  //Load the icon
    }

    return S_OK;
}


HRESULT CQueryNode::SaveNode(IStream& stm)
{
    HRESULT hr = CScopeNode::SaveNode(stm);
    RETURN_ON_FAILURE(hr);

    stm << m_strScope;
    stm << m_strQuery;
    stm << m_bsQueryData;
    stm << m_commentID;
    stm << m_vObjInfo;
    stm << m_bLocalScope;
    stm << m_vMenus;
    stm << m_nIconIndex;

    return S_OK;
}

void CQueryNode::EnableVerbs(IConsoleVerb* pConsVerb, BOOL bOwnsView)
{
    if( bOwnsView && pConsVerb )
    {
        pConsVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);        
    }
}


HRESULT CQueryNode::AddMenuItems(LPCONTEXTMENUCALLBACK pCallback, long* plAllowed)
{
    VALIDATE_POINTER( plAllowed );

    HRESULT hr = S_OK;
    
    CComQIPtr<IContextMenuCallback2> spContext2 = pCallback;
    if( !spContext2 ) return E_NOINTERFACE;

    if( *plAllowed & CCM_INSERTIONALLOWED_TOP )
    {
        // Add our new Querynode menus
        // Make sure our strings are loaded.
        CRootNode* pRootNode = GetRootNode();
        if( !pRootNode ) return E_FAIL;

        CComponentData* pCompData = pRootNode->GetCompData();
        if( !pCompData ) return E_FAIL;

        IStringTable* pStringTable = pCompData->GetStringTable();
        ASSERT( pStringTable );
        if( !pStringTable ) return E_FAIL;
        
        LoadStrings(pStringTable);

        menucmd_vector::iterator itMenu;
        long lCmdID = 0;
        for( itMenu = m_vMenus.begin(); itMenu != m_vMenus.end(); ++itMenu, ++lCmdID )
        {            
            CONTEXTMENUITEM2 item;
            OLECHAR szGuid[50] = {0};            

            ::StringFromGUID2((*itMenu)->NoLocID(), szGuid, 50);

            item.strName = const_cast<LPWSTR>((*itMenu)->Name());
            item.strStatusBarText = L"";
            item.lCommandID = lCmdID;
            item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
            item.fFlags = 0;
            item.fSpecialFlags = 0;
            item.strLanguageIndependentName = szGuid;

            hr = spContext2->AddItem(&item);            
            ASSERT(SUCCEEDED(hr));
        }

        //hr = AddMenuItem(pCallback, MID_EDITQUERY, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, _T("EDITQUERY"));
        //ASSERT(SUCCEEDED(hr));

        long lFlags = (m_pQueryReq != NULL) ? MF_ENABLED : MF_GRAYED;
        BOOL bRes = AddMenuItem(pCallback, MID_STOPQUERY, CCM_INSERTIONPOINTID_PRIMARY_TOP, lFlags, _T("STOPQUERY"));
        hr = bRes ? S_OK : E_FAIL;
        ASSERT(SUCCEEDED(hr));

        // Show the "Move to" menu item if there is at least one group node
        CScopeNode* pnode = pRootNode->FirstChild();
        while( pnode != NULL )
        {
            if( pnode->NodeType() == GROUP_NODETYPE )
            {
                bRes = AddMenuItem(pCallback, MID_MOVEQUERYNODE, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, _T("MOVEQUERY"));
                hr = bRes ? S_OK : E_FAIL;
                ASSERT(SUCCEEDED(hr));
                break;
            }
            pnode = pnode->Next();
        }
    }
    return hr;
}


HRESULT CQueryNode::SetToolButtons(LPTOOLBAR pToolbar)
{
    VALIDATE_POINTER( pToolbar );

    pToolbar->SetButtonState(MID_EDITQUERY, ENABLED, TRUE);
    pToolbar->SetButtonState(MID_EDITQUERY, HIDDEN,  FALSE);

    pToolbar->SetButtonState(MID_STOPQUERY, ENABLED, (m_pQueryReq != NULL));
    pToolbar->SetButtonState(MID_STOPQUERY, HIDDEN,  FALSE);

    return S_OK;
}

HRESULT CQueryNode::EditQuery(HWND hWndParent)
{
    tstring strQueryTmp;
    tstring strScopeTmp = Scope();        
    ExpandQuery(strQueryTmp);   

    HRESULT hr = GetQuery(strScopeTmp, strQueryTmp, m_bsQueryData, hWndParent);

    if( FAILED(hr) )
    {
        DisplayMessageBox(NULL, IDS_ERRORTITLE_EDITQUERY, IDS_ERROR_EDITQUERY, 
                          MB_OK|MB_ICONEXCLAMATION, GetName());
    }

    if( hr != S_OK )
        return hr;

    m_strQuery = strQueryTmp;

    // if user changed the scope setting
    if( strScopeTmp != Scope() )
    {
        // Update the node scope and turn off local scope option (i.e., use query specified scope)
        SetScope(strScopeTmp.c_str());
        SetLocalScope(FALSE);
    }

    // Determine the classes this query can return
    std::set<tstring> setClasses;
    GetQueryClasses(m_strQuery, setClasses);

    // Delete current objects that aren't in new query
    QueryObjVector::iterator itObj = m_vObjInfo.begin();
    while( itObj != m_vObjInfo.end() )
    {
        if( setClasses.find(itObj->Name()) == setClasses.end() )
        {
            // delete item from list and leave iterator at this position
            m_vObjInfo.erase(itObj);
        }
        else
        {
            // if found delete from set, so only new ones remain
            setClasses.erase(itObj->Name());
            ++itObj;
        }
    }

    DisplayNameMap* pNameMap = DisplayNames::GetClassMap();

    // Add any new objects
    std::set<tstring>::iterator itClass;
    for( itClass = setClasses.begin(); itClass != setClasses.end(); itClass++ )
    {
        if( pNameMap == NULL || 
            pNameMap->GetAttributeDisplayName(itClass->c_str()) != itClass->c_str() )
        {
            CQueryObjInfo* pQueryObj = new CQueryObjInfo(itClass->c_str());
            
            if( pQueryObj )
            {
                m_vObjInfo.push_back(*pQueryObj);
            }
        }
    }

    return S_OK;
}

class CRefreshCallback : public CEventCallback
{
public:
    CRefreshCallback(HANDLE hProcess, CQueryNode* pQueryNode)
    : m_hProcess(hProcess), m_spQueryNode(pQueryNode)
    {
    }

    virtual void Execute() 
    {
        if( m_spQueryNode )
        {
            m_spQueryNode->OnRefresh(NULL);
        }

        CloseHandle(m_hProcess);
    }

    HANDLE m_hProcess;
    CQueryNodePtr m_spQueryNode;
};

class CNoLookup : public CParamLookup
{
public:    
    virtual BOOL operator() (tstring& strParam, tstring& strValue)
    {
        return FALSE;
    };    
};


HRESULT CQueryNode::MenuCommand(LPCONSOLE2 pConsole, long lCommand)
{
    VALIDATE_POINTER(pConsole);

    HRESULT hr = S_OK;

    switch( lCommand )
    {
    case MID_EDITQUERY:
        {
            HWND hWndMain;
            hr = pConsole->GetMainWindow(&hWndMain);
            BREAK_ON_FAILURE(hr);

            hr = EditQuery(hWndMain);

            if( hr == S_FALSE )
            {
                hr = S_OK;
                break;
            }

            m_bQueryChange = TRUE;

            OnRefresh(pConsole);
        }
        break;

    case MID_STOPQUERY:
        if( m_pQueryReq != NULL )
            m_pQueryReq->Stop(TRUE);
        break;

    case MID_MOVEQUERYNODE:
        {
            CScopeNode* pnodeDest = NULL;

            CMoveQueryDlg dlg;
            if( dlg.DoModal(Parent(), &pnodeDest) == IDOK )
            {
                ASSERT( pnodeDest );
                if( !pnodeDest ) return E_FAIL;

                // Ref node during move to prevent deletion
                AddRef();

                // Tell MMC to remove the node 
                IConsoleNameSpace* pNameSpace = GetCompData()->GetNameSpace();
                ASSERT( pNameSpace );
                if( !pNameSpace ) return E_FAIL;

                pNameSpace->DeleteItem(m_hScopeItem, TRUE);

                // clear item handle becuase it's no longer valid
                m_hScopeItem = NULL;

                // Now remove the node internally (MMC does not send a delete notify)
                Parent()->RemoveChild(this);

                // Add back to the new parent
                hr = pnodeDest->AddChild(this);

                Release();
            }
        }
        break;

    default:
        {
            // Must be one of the Querynode menus
            ASSERT(lCommand < m_vMenus.size());
            if( lCommand >= m_vMenus.size() )
                return E_INVALIDARG;

            HANDLE hProcess = NULL;
            CNoLookup lookup;
            hr = static_cast<CShellMenuCmd*>((CMenuCmd*)m_vMenus[lCommand])->Execute(&lookup, &hProcess);

            // if process started and auto-refresh wanted, setup event-triggered callback
            if( SUCCEEDED(hr) && hProcess != NULL && m_vMenus[lCommand]->IsAutoRefresh() )
            {
                CallbackOnEvent(hProcess, new CRefreshCallback(hProcess, this));              
            }
        }
        hr = S_FALSE;
    }

    return hr;
}


HRESULT CQueryNode::QueryPagesFor()
{
    return S_OK;
}


HRESULT CQueryNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK pProvider, LONG_PTR handle)
{
    VALIDATE_POINTER( pProvider );

    // Create a query edit object
    CQueryEditObj* pEditObj = new CQueryEditObj(this);
    if( !pEditObj ) return E_OUTOFMEMORY;

    // Create an instance of each prop page class and call Create on each.

    // Keep it alive until prop pages ref it    
    pEditObj->AddRef();

    // General page
    HPROPSHEETPAGE hpageGen = NULL;
    CQueryGeneralPage* pGenPage = new CQueryGeneralPage(pEditObj);
    if( pGenPage != NULL )
    {
        hpageGen = pGenPage->Create();
    }

    // Context menu page
    HPROPSHEETPAGE hpageMenu = NULL;
    CQueryMenuPage* pMenuPage = new CQueryMenuPage(pEditObj);
    if( pMenuPage != NULL )
    {
        hpageMenu = pMenuPage->Create();
    }

    // Listview page
    HPROPSHEETPAGE hpageView = NULL;
    CQueryViewPage* pViewPage = new CQueryViewPage(pEditObj);
    if( pViewPage != NULL )
        hpageView = pViewPage->Create();

    // Node Menu page
    HPROPSHEETPAGE hpageNodeMenu = NULL;
    CQueryNodeMenuPage* pNodeMenuPage = new CQueryNodeMenuPage(pEditObj);
    if( pNodeMenuPage != NULL )
    {
        hpageNodeMenu = pNodeMenuPage->Create();
    }

    HRESULT hr = E_OUTOFMEMORY;

    // if all pages were created, add each one to the prop sheet
    if( hpageGen && hpageMenu && hpageView )
    {
        hr = pProvider->AddPage(hpageGen);

        if( SUCCEEDED(hr) )
            hr = pProvider->AddPage(hpageMenu);

        if( SUCCEEDED(hr) )
            hr = pProvider->AddPage(hpageView);

        if( SUCCEEDED(hr) )
            hr = pProvider->AddPage(hpageNodeMenu);
    }

    // On failure, destroy the pages. If a page failed to create
    // then delete the page class object instead (the object is
    // automatically deleted when the page is destroyed)

    if( FAILED(hr) )
    {
        if( hpageGen )
            DestroyPropertySheetPage(hpageGen);
        else
            SAFE_DELETE(pGenPage);

        if( hpageMenu )
            DestroyPropertySheetPage(hpageMenu);
        else
            SAFE_DELETE(pMenuPage);

        if( hpageView )
            DestroyPropertySheetPage(hpageView);
        else
            SAFE_DELETE(pViewPage);

        if( hpageNodeMenu )
            DestroyPropertySheetPage(hpageNodeMenu);
        else
            SAFE_DELETE(pNodeMenuPage);        
    }

    // Release temp ref on edit list
    // it will go away when the prop pages release it
    pEditObj->Release();

    return hr;
}

//////////////////////////////////////////////////////////////////////
// CQueryLookup
// 

BOOL CQueryLookup::operator() (tstring& strParam, tstring& strValue)
{
    if( !m_pRowItem ) 
    {
        strValue = _T("");
        return FALSE;
    }
    // Check for single digit parameter ID
    if( strParam.size() == 1 && strParam[0] <= MENU_PARAM_LAST )
    {
        switch( strParam[0] )
        {
        case MENU_PARAM_SCOPE:
            strValue = reinterpret_cast<CQueryNode*>(m_pRowItem->GetOwnerParam())->Scope();
            break;

        case MENU_PARAM_FILTER:                         
            reinterpret_cast<CQueryNode*>(m_pRowItem->GetOwnerParam())->ExpandQuery(strValue);          
            break;

        case MENU_PARAM_NAME:
            strValue = (*m_pRowItem)[ROWITEM_NAME_INDEX];
            break;

        case MENU_PARAM_TYPE:
            strValue = (*m_pRowItem)[ROWITEM_CLASS_INDEX];
            break;
        }
    }
    else
    {
        // see if parameter name matches column name
        string_vector& vstrColumns = m_pQNode->QueryColumns();                                        
        string_vector::iterator itCol = std::find(vstrColumns.begin(), vstrColumns.end(), strParam);

        // if so, substitue row item value at that position
        if( itCol != vstrColumns.end() )
            strValue = (*m_pRowItem)[(itCol - vstrColumns.begin()) + ROWITEM_USER_INDEX];
    }

    return !strValue.empty();
}


//////////////////////////////////////////////////////////////
// Stream operators (<< >>)

IStream& operator<< (IStream& stm, CClassInfo& classInfo)
{
    stm << classInfo.m_strName;
    stm << classInfo.m_vstrColumns;
    stm << classInfo.m_vMenus;
    return stm;
}


IStream& operator>> (IStream& stm, CClassInfo& classInfo)
{
    stm >> classInfo.m_strName;    
    stm >> classInfo.m_vstrColumns;
    stm >> classInfo.m_vMenus;
    return stm;
}

IStream& operator<< (IStream& stm, CQueryObjInfo& objInfo)
{
    stm << objInfo.m_strName;
    stm << objInfo.m_vMenuRefs;
    stm << objInfo.m_vstrDisabledColumns;

    DWORD dwFlags = objInfo.m_bPropertyMenu ? 1 : 0;
    stm << dwFlags;

    return stm;
}


IStream& operator>> (IStream& stm, CQueryObjInfo& objInfo)
{
    stm >> objInfo.m_strName;
    stm >> objInfo.m_vMenuRefs;    
    stm >> objInfo.m_vstrDisabledColumns;

    // File versions >= 102 include flag word
    // Bit 0 enables the property menu
    if( g_dwFileVer >= 102 )
    {
        DWORD dwFlags;
        stm >> dwFlags;
        objInfo.m_bPropertyMenu = (dwFlags & 1);
    }
    else
    {
        objInfo.m_bPropertyMenu = TRUE;
    }

    return stm;
}

IStream& operator>> (IStream& stm, CMenuRef& menuref)
{
    stm >> menuref.m_menuID;
    stm >> menuref.m_flags;
    return stm;
}

IStream& operator<< (IStream& stm, CMenuRef& menuref)
{
    stm << menuref.m_menuID;
    stm << menuref.m_flags;
    return stm;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\streamio.cpp ===
// stream i/o functions

#include "stdafx.h"
#include <memory>


/*+-------------------------------------------------------------------------*
 * ReadScalar 
 *
 * Reads a scalar value from a stream.
 *--------------------------------------------------------------------------*/

template<class T>
static IStream& ReadScalar (IStream& stm, T& t)
{
    ULONG cbActuallyRead;
    HRESULT hr = stm.Read (&t, sizeof (t), &cbActuallyRead);
    THROW_ON_FAILURE(hr);

    if (cbActuallyRead != sizeof (t))
        _com_issue_error (E_FAIL);

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * WriteScalar 
 *
 * Writes a scalar value to a stream.
 *--------------------------------------------------------------------------*/

template<class T>
static IStream& WriteScalar (IStream& stm, const T& t)
{
    ULONG cbActuallyWritten;
    HRESULT hr = stm.Write (&t, sizeof (t), &cbActuallyWritten);
    THROW_ON_FAILURE(hr);

    if (cbActuallyWritten != sizeof (t))
        THROW_ERROR(E_FAIL);

    return (stm);
}


//----------------------------------------------------------------
// Define by-value stream operators
//----------------------------------------------------------------
#define DefineScalarStreamOperators(scalar_type)                \
    IStream& operator>> (IStream& stm, scalar_type& t)          \
        { return (ReadScalar (stm, t)); }                       \
    IStream& operator<< (IStream& stm, scalar_type t)           \
        { return (WriteScalar (stm, t)); }          
  
DefineScalarStreamOperators (         bool);
DefineScalarStreamOperators (         char);
DefineScalarStreamOperators (unsigned char);
DefineScalarStreamOperators (         short);
DefineScalarStreamOperators (unsigned short);
DefineScalarStreamOperators (         int);
DefineScalarStreamOperators (unsigned int);
DefineScalarStreamOperators (         long);
DefineScalarStreamOperators (unsigned long);

//----------------------------------------------------------------
// Define by-value stream operators
//----------------------------------------------------------------                                                    
#define DefineScalarStreamOperatorsByRef(scalar_type)           \
    IStream& operator>> (IStream& stm, scalar_type& t)          \
        { return (ReadScalar (stm, t)); }                       \
    IStream& operator<< (IStream& stm, const scalar_type& t)    \
        { return (WriteScalar (stm, t)); }

DefineScalarStreamOperatorsByRef(CLSID);
DefineScalarStreamOperatorsByRef(FILETIME);



/*+-------------------------------------------------------------------------*
 * ReadString 
 *
 * Reads a std::basic_string of char type CH from a stream.  The string should 
 * have been written with a DWORD character count preceding an array of
 * characters that is not NULL-terminated.
 *--------------------------------------------------------------------------*/

template<class CH>
static IStream& ReadString (IStream& stm, std::basic_string<CH>& str)
{
    /*
     * read the length
     */
    DWORD cch;
    stm >> cch;

    /* Loading more than 1 million characters just isn't going to be supported. */
    if( cch > 1000000 )
        THROW_ERROR(E_OUTOFMEMORY);


    /*
     * allocate a buffer for the characters
     */
    std::auto_ptr<CH> spBuffer (new (std::nothrow) CH[cch + 1]);
    CH* pBuffer = spBuffer.get();

    if (pBuffer == NULL)
        THROW_ERROR(E_OUTOFMEMORY);

    /*
     * read the characters
     */
    ULONG cbActuallyRead;
    const ULONG cbToRead = cch * sizeof (CH);
    HRESULT hr = stm.Read (pBuffer, cbToRead, &cbActuallyRead);
    THROW_ON_FAILURE(hr);

    if (cbToRead != cbActuallyRead)
        THROW_ERROR(E_FAIL);

    /*
     * terminate the character array and assign it to the string
     */
    pBuffer[cch] = 0;

    /*
     * assign it to the string (clear the string first to work around
     * the bug described in KB Q172398)
     */
    str.erase();
    str = pBuffer;

    return (stm);
}

/*+-------------------------------------------------------------------------*
 * ReadString for byte_string 
 *
 * Specialization of ReadString for a string of bytes which may contain NULLs.
 * he string should have been written with a DWORD character count preceding 
 * an array of characters that is not NULL-terminated.
 *--------------------------------------------------------------------------*/

static IStream& ReadString (IStream& stm, std::basic_string<BYTE>& str)
{
    /*
     * read the length
     */
    DWORD cch;
    stm >> cch;

    /* Loading more than 1 million characters just isn't going to be supported. */
    if( cch > 1000000 )
        THROW_ERROR(E_OUTOFMEMORY);


    if (cch == 0)
    {
        str.erase(); 
    }
    else
    {
        /*
         * allocate a buffer for the characters
         */
        std::auto_ptr<BYTE> spBuffer (new (std::nothrow) BYTE[cch]);
        BYTE* pBuffer = spBuffer.get();

        if (pBuffer == NULL)
            THROW_ERROR(E_OUTOFMEMORY);

        /*
         * read the characters
         */
        ULONG cbActuallyRead;
        const ULONG cbToRead = cch;
        HRESULT hr = stm.Read (pBuffer, cbToRead, &cbActuallyRead);
        THROW_ON_FAILURE(hr);

        if (cbToRead != cbActuallyRead)
            THROW_ERROR(E_FAIL);

         /*
         * assign it to the string (clear the string first to work around
         * the bug described in KB Q172398)
         */
        str.erase();
        str.assign(pBuffer, cch);
    }

    return (stm);
}



/*+-------------------------------------------------------------------------*
 * WriteString 
 *
 * Writes a std::basic_string of char type CH to a stream.  The string is 
 * written with a DWORD character count preceding an array of characters that 
 * is not NULL-terminated.
 *--------------------------------------------------------------------------*/

template<class CH>
static IStream& WriteString (IStream& stm, const std::basic_string<CH>& str)
{
    /*
     * write the length
     */
    DWORD cch = str.length();
    stm << cch;

    if (cch > 0)
    {
        /*
         * write the characters
         */
        ULONG cbActuallyWritten;
        const ULONG cbToWrite = cch * sizeof (CH);
        HRESULT hr = stm.Write (str.data(), cbToWrite, &cbActuallyWritten);
        THROW_ON_FAILURE(hr);

        if (cbToWrite != cbActuallyWritten)
            THROW_ERROR(E_FAIL);
    }

    return (stm);
}

//-----------------------------------------------------------------
// Define basic string stream operators
//-----------------------------------------------------------------
#define DefineStringStreamOperators(string_type)                \
    IStream& operator>> (IStream& stm, string_type& str)        \
        { return (ReadString (stm, str)); }                     \
    IStream& operator<< (IStream& stm, const string_type& str)  \
        { return (WriteString (stm, str)); }

DefineStringStreamOperators(tstring);
DefineStringStreamOperators(byte_string);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\util.cpp ===
// util.cpp - miscelaneous helper functions

#include "stdafx.h"
#include "util.h"

// Net API stuffs
#include <dsgetdc.h>
#include <wtsapi32.h>
#include <rassapi.h>
#include <shlobj.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmshare.h>
#include <lmserver.h>


// ldap/adsi includes
#include <iads.h>
#include <adshlp.h>
#include <adsiid.h>

extern HWND g_hwndMain;

LRESULT CALLBACK EventCBWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Event callback window class object
CMsgWindowClass EventCBWndClass(L"OnEventCB", EventCBWndProc);

HBITMAP GetBitmapFromStrip(HBITMAP hbmStrip, int nPos, int cSize)
{
    HBITMAP hbmNew = NULL;

    // Create src & dest DC
    HDC hdc = GetDC(NULL);
    if( hdc == NULL ) return NULL;

    HDC hdcSrc = CreateCompatibleDC(hdc);
    HDC hdcDst = CreateCompatibleDC(hdc);

    if( hdcSrc && hdcDst )
    {
        hbmNew= CreateCompatibleBitmap (hdc, cSize, cSize);
        if( hbmNew )
        {
            // Select src & dest bitmaps into DCs
            HBITMAP hbmSrcOld = (HBITMAP)SelectObject(hdcSrc, (HGDIOBJ)hbmStrip);
            HBITMAP hbmDstOld = (HBITMAP)SelectObject(hdcDst, (HGDIOBJ)hbmNew);

            // Copy selected image from source
            BitBlt(hdcDst, 0, 0, cSize, cSize, hdcSrc, cSize * nPos, 0, SRCCOPY);

            // Restore selections
            if( hbmSrcOld ) SelectObject(hdcSrc, (HGDIOBJ)hbmSrcOld);
            if( hbmDstOld ) SelectObject(hdcDst, (HGDIOBJ)hbmDstOld);
        }

        DeleteDC(hdcSrc);
        DeleteDC(hdcDst);
    }

    ReleaseDC(NULL, hdc);

    return hbmNew;
}

void ConfigSingleColumnListView(HWND hwndListView)
{
    if( !hwndListView || !::IsWindow(hwndListView) ) return;

    RECT rc;

    BOOL bStat = GetClientRect(hwndListView, &rc);
    ASSERT(bStat);

    LV_COLUMN lvc;
    lvc.mask = LVCF_WIDTH | LVCF_SUBITEM;
    lvc.cx = rc.right - rc.left - GetSystemMetrics(SM_CXVSCROLL);
    lvc.iSubItem = 0;

    int iCol = ListView_InsertColumn(hwndListView, 0, &lvc);
    ASSERT(iCol == 0);

    ListView_SetExtendedListViewStyleEx(hwndListView, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);
}


//--------------------------------------------------------------------------
// EnableDlgItem
//
// Enables or disables a dialog control. If the control has the focus when
// it is disabled, the focus is moved to the next control
//--------------------------------------------------------------------------
void EnableDlgItem(HWND hwndDialog, int iCtrlID, BOOL bEnable)
{
    if( !hwndDialog || !::IsWindow(hwndDialog) ) return;

    HWND hWndCtrl = ::GetDlgItem(hwndDialog, iCtrlID);
    
    if( !hWndCtrl || !::IsWindow(hWndCtrl) ) return;

    if( !bEnable && ::GetFocus() == hWndCtrl )
    {
        HWND hWndNextCtrl = ::GetNextDlgTabItem(hwndDialog, hWndCtrl, FALSE);
        if( hWndNextCtrl != NULL && hWndNextCtrl != hWndCtrl )
        {
            ::SetFocus(hWndNextCtrl);
        }
    }

    ::EnableWindow(hWndCtrl, bEnable);
}


//--------------------------------------------------------------------------
// GetItemText
//
// Read text from a control and return it in a string
//---------------------------------------------------------------------------

void GetItemText(HWND hwnd, tstring& strText)
{
    strText = _T("");
    
    if( !hwnd || !::IsWindow(hwnd) ) return;

    int nLen = ::GetWindowTextLength(hwnd);
    if( nLen == 0 ) return;

    LPWSTR pszTemp = new WCHAR[nLen + 1];
    if( !pszTemp ) return;

    int nLen1 = ::GetWindowText( hwnd, pszTemp, (nLen + 1) );
    ASSERT(nLen == nLen1);

    strText = pszTemp;

    delete [] pszTemp;
}

//------------------------------------------------------------------------
// RemoveSpaces
//
// Remove spaces from null-terminated string
//-------------------------------------------------------------------------
void RemoveSpaces(LPWSTR pszBuf)
{
    if( !pszBuf ) return;

    WCHAR* pszDest = pszBuf;
    do 
    {
        if( *pszBuf != L' ' ) *(pszDest++) = *pszBuf;
    }
    while( *(pszBuf++) );
}

//-------------------------------------------------------------------------
// EscapeSlashes
//
// Add escape char '\' in front of each forward slash '/'
//-------------------------------------------------------------------------
void EscapeSlashes(LPCWSTR pszIn, tstring& strOut)
{
    strOut = _T("");
    
    if( !pszIn ) return;
    
    strOut.reserve( wcslen(pszIn) + 8 );

    while( *pszIn != 0 )
    {
        if( *pszIn == L'/' )
            strOut += L'\\';

        strOut += *(pszIn++);
    }
}

HRESULT ReplaceParameters( tstring& str, CParamLookup& lookup, BOOL bRetainMarkers )
{
    // Do for each parameter $<param name>
    int posParam = 0;
    while( (posParam = str.find(L"$<", posParam)) != tstring::npos )
    {
        // skip over the '$<'
        posParam += 2;

        // find terminating ">"
        int posParamEnd = str.find(L">", posParam);
        if( posParamEnd == tstring::npos )
            return E_FAIL;

        // Get replacement string from lookup function
        tstring strValue;
        if( !lookup(str.substr(posParam, posParamEnd - posParam), strValue) )
            return E_FAIL;

        // replace either paramter or parameter and markers
        // and advance pointer to first char after substitution
        if( bRetainMarkers )
        {
            str.replace(posParam, posParamEnd - posParam, strValue);
            posParam += strValue.size();
        }
        else
        {
            str.replace(posParam - 2, posParamEnd - posParam + 3, strValue);
            posParam += strValue.size() - 2;
        }        
    }

    return S_OK;
}

VARIANT GetDomainPath( LPCTSTR lpServer )
{
    VARIANT vDomain;
    ::VariantInit(&vDomain);

    if( !lpServer ) return vDomain;

    // get the domain information
    TCHAR pString[MAX_PATH*2];
    _sntprintf( pString, (MAX_PATH*2)-1, L"LDAP://%s/rootDSE", lpServer );    

    CComPtr<IADs> pDS = NULL;
    HRESULT hr = ::ADsGetObject(pString, IID_IADs, (void**)&pDS);

    ASSERT(hr == S_OK);
    if( hr != S_OK ) return vDomain;

    CComBSTR bstrProp = L"defaultNamingContext";
    hr = pDS->Get( bstrProp, &vDomain );
    ASSERT(hr == S_OK);    

    return vDomain;
}

HRESULT ExpandDCWildCard( tstring& str )
{
    int posParam = 0;
    const tstring strKey = _T("DC=*");
    if( (posParam = str.find(strKey.c_str(), posParam)) != tstring::npos )
    {
        CComVariant             vDomain;   
        HRESULT                 hr              = S_OK;
        CString                 csDns           = L"";
        PDOMAIN_CONTROLLER_INFO pDCI            = NULL;

        hr = DsGetDcName(NULL, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME, &pDCI);
        if( (hr == S_OK) && (pDCI != NULL) )
        {
            csDns = pDCI->DomainName;

            NetApiBufferFree (pDCI);
            pDCI = NULL;
        }

        vDomain = GetDomainPath((LPCTSTR)csDns);   

        if( vDomain.vt == VT_BSTR )
        {
            // Get replacement string from lookup function
            tstring strValue = vDomain.bstrVal;

            // We replace the whole DC=* with the full DC=XYZ,DC=COM
            str.replace(posParam, strKey.size(), strValue);            
        }
        else
        {
            return E_FAIL;
        }
    }

    return S_OK;
}


HRESULT ExpandEnvironmentParams( tstring& strIn, tstring& strOut )
{
    // if no % then just return inout string
    if( strIn.find(L"%") == tstring::npos )
    {
        strOut = strIn;
        return S_OK;
    }

    DWORD dwSize = strIn.size() * 2;

    while( TRUE )
    {
        WCHAR* pszBuf = new WCHAR [dwSize];
        if( !pszBuf ) return E_OUTOFMEMORY;

        ZeroMemory( pszBuf, (dwSize * sizeof(WCHAR)) );

        DWORD dwReqSize = ExpandEnvironmentStrings(strIn.c_str(), pszBuf, dwSize);

        if( dwReqSize <= dwSize )
        {
            strOut = pszBuf;
            delete [] pszBuf;

            return S_OK;
        }

        delete [] pszBuf;
        dwSize = dwReqSize;
    }
}

tstring StrLoadString( UINT uID )
{ 
    tstring   strRet = _T("");
    HINSTANCE hInst  = _Module.GetResourceInstance();    
    INT       iSize  = MAX_PATH;
    TCHAR*    psz    = new TCHAR[iSize];
    if( !psz ) return strRet;
    
    while( LoadString(hInst, uID, psz, iSize) == (iSize - 1) )
    {
        iSize += MAX_PATH;
        delete[] psz;
        psz = NULL;
        
        psz = new TCHAR[iSize];
        if( !psz ) return strRet;
    }

    strRet = psz;
    delete[] psz;

    return strRet;
}

HRESULT StringTableWrite(IStringTable* pStringTable, LPCWSTR psz, MMC_STRING_ID* pID)
{
    VALIDATE_POINTER(pStringTable);
    VALIDATE_POINTER(psz);
    VALIDATE_POINTER(pID);

    MMC_STRING_ID newID = 0;

    // if non-null string store it and get the new ID
    if( psz[0] != 0 )
    {
        HRESULT hr = pStringTable->AddString(psz, &newID);
        ASSERT(SUCCEEDED(hr) && newID != 0);
        RETURN_ON_FAILURE(hr);
    }

    // If had an old string ID, free it
    if( *pID != 0 )
    {
        HRESULT hr = pStringTable->DeleteString(*pID);
        ASSERT(SUCCEEDED(hr));
    }

    *pID = newID;
    return S_OK;
}

HRESULT StringTableRead(IStringTable* pStringTable, MMC_STRING_ID ID, tstring& str)
{
    VALIDATE_POINTER(pStringTable);
    ASSERT(ID != 0);

    // get the length of the string from the string table
    DWORD cb = 0;
    HRESULT hr = pStringTable->GetStringLength(ID, &cb);
    RETURN_ON_FAILURE(hr);

    // alloc stack buffer (+1 for terminating null) 
    cb++;
    LPWSTR pszBuf = new WCHAR[cb + 1];
    if( !pszBuf ) return E_OUTOFMEMORY;

    // read the string
    DWORD cbRead = 0;
    hr = pStringTable->GetString(ID, cb, pszBuf, &cbRead);
    RETURN_ON_FAILURE(hr);

    ASSERT(cb == cbRead + 1);

    str = pszBuf;

    delete [] pszBuf;

    return S_OK;
}

int DisplayMessageBox(HWND hWnd, UINT uTitleID, UINT uMsgID, UINT uStyle, LPCWSTR pvParam1, LPCWSTR pvParam2)
{
    ASSERT(hWnd != NULL || g_hwndMain != NULL);
    if( hWnd == NULL && g_hwndMain == NULL )
        return 0;

    // Display error message 
    CString strTitle;
    strTitle.LoadString(uTitleID);

    CString strMsgFmt;
    strMsgFmt.LoadString(uMsgID);

    CString strMsg;
    strMsg.Format(strMsgFmt, pvParam1, pvParam2); 

    return  MessageBox(hWnd ? hWnd : g_hwndMain, strMsg, strTitle, uStyle);
}


HRESULT ValidateFile( tstring& strFilePath )
{
    if( strFilePath.empty() ) return E_INVALIDARG;

    tstring strTmp;
    ExpandEnvironmentParams(strFilePath, strTmp);

    // if file path includes a directory or drive specifier then check the specific file
    // then look for that specific file
    if( strFilePath.find_first_of(L"\\:") != tstring::npos )
    {
        DWORD dwAttr = GetFileAttributes(strTmp.c_str());
        if( (dwAttr != INVALID_FILE_ATTRIBUTES) && !(dwAttr & FILE_ATTRIBUTE_DIRECTORY) )
            return S_OK;
    }
    else
    {
        // else search for file in standard locations
        DWORD dwLen = SearchPath(NULL, strTmp.c_str(), NULL, 0, NULL, NULL);
        if( dwLen > 0 )
            return S_OK;
    }

    return E_FAIL;
}


HRESULT ValidateDirectory( tstring& strDir )
{
    if( strDir.empty() ) return E_INVALIDARG;

    tstring strTmp;
    ExpandEnvironmentParams(strDir, strTmp);

    DWORD dwAttr = GetFileAttributes( strTmp.c_str() );
    if( (dwAttr != INVALID_FILE_ATTRIBUTES) && (dwAttr & FILE_ATTRIBUTE_DIRECTORY) )
        return S_OK;
    else
        return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////
// Event-triggered callbacks
//
// The main thread can request that a callback be made when an object
// is signaled by calling function CallbackOnEvent. The function starts
// a monitor thread which does a wait on the object. When the object is
// signaled, the thread posts a message to a callback window and exits.  
// The callback window, which is owned by the main thread, then executes
// the callback function.
// 

// the callback window
static HWND hwndCallback = NULL;            // callback window

#define MSG_EVENTCALLBACK (WM_USER+100)     // callback message

struct EVENTCB_INFO                         // callback info struct
{
    CEventCallback* pCallback;              // callback object to execute
    HANDLE hWaitObj;                        // object that triggers the callback
    HANDLE hThread;                         // monitoring thread                     
};

//---------------------------------------------------------------------------
// EventCBThdProc
//
// This is the monitoring thread procedure. It just does a wait for the object
// signal, then posts a callback message to the callback window.
//
// Inputs:  pVoid   ptr to EVENTCB_INFO struct (cast to void*)
//----------------------------------------------------------------------------
static DWORD WINAPI EventCBThdProc(void* pVoid )
{
    if( !pVoid ) return 0;

    EVENTCB_INFO* pInfo = reinterpret_cast<EVENTCB_INFO*>(pVoid);
    ASSERT(pInfo->hWaitObj != NULL && pInfo->pCallback != NULL);

    DWORD dwStat = WaitForSingleObject(pInfo->hWaitObj, INFINITE);
    ASSERT(dwStat == WAIT_OBJECT_0);

    ASSERT(hwndCallback != NULL);
    ::PostMessage(hwndCallback, MSG_EVENTCALLBACK, reinterpret_cast<WPARAM>(pInfo), NULL);

    return 0;
}


//----------------------------------------------------------------------------------
// EventCBWndProc
//
// This is the callback window's WndProc. When it gets a callback message it 
// executes the callback function then destroys the callback function object and
// the callback info struct.
//---------------------------------------------------------------------------------- 
static LRESULT CALLBACK EventCBWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if( uMsg == MSG_EVENTCALLBACK )
    {
        EVENTCB_INFO* pInfo = reinterpret_cast<EVENTCB_INFO*>(wParam);
        if( !pInfo ) return 0;
        
        if( pInfo->pCallback )
        {
            pInfo->pCallback->Execute();

            delete pInfo->pCallback;
            pInfo->pCallback = NULL;            
        }

        delete pInfo;
        pInfo = NULL;

        return 0; 
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);   
}


//-----------------------------------------------------------------------------------
// CallbackOnEvent
//
// This function accepts an event-triggered callback request. It starts a monitoring
// thread which will cause the callback when the specified object signals.
//
// Inputs:  HANDLE hWaitObj     Handle of object to wait on
//          CEventCallback      Callback function object (with single Execute method)
//
// Outputs: HRESULT             Result of event trigger setup
//
// Note: The CEventCallback object is destroyed after the callback is executed. 
//-----------------------------------------------------------------------------------
HRESULT CallbackOnEvent(HANDLE hWaitObj, CEventCallback* pCallback)
{
    ASSERT(pCallback != NULL);

    // Create callback window the first time
    if( hwndCallback == NULL )
    {
        hwndCallback = EventCBWndClass.Window();

        if( hwndCallback == NULL )
            return E_FAIL;
    }

    // Create a callback info object
    EVENTCB_INFO* pInfo = new EVENTCB_INFO;
    if( pInfo == NULL )
        return E_OUTOFMEMORY;

    pInfo->hWaitObj = hWaitObj;
    pInfo->pCallback = pCallback;

    // Start monitor thread passing it the callback info
    pInfo->hThread = CreateThread(NULL, NULL, EventCBThdProc, pInfo, 0, NULL);
    if( pInfo->hThread == NULL )
    {
        delete pInfo;
        return E_FAIL;
    }

    return S_OK;
}


BOOL ModifyStyleEx(HWND hWnd, DWORD dwRemove, DWORD dwAdd, UINT nFlags)
{
    if( !hWnd || !::IsWindow(hWnd) ) return FALSE;

    DWORD dwStyle = ::GetWindowLong(hWnd, GWL_EXSTYLE);
    DWORD dwNewStyle = (dwStyle & ~dwRemove) | dwAdd;
    if( dwStyle == dwNewStyle )
        return FALSE;

    ::SetWindowLong(hWnd, GWL_EXSTYLE, dwNewStyle);
    if( nFlags != 0 )
    {
        ::SetWindowPos(hWnd, NULL, 0, 0, 0, 0,
                       SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags);
    }

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////////////
// CMsgWindowClass


HWND CMsgWindowClass::Window()
{
    ASSERT(m_pszName != NULL && m_pWndProc != NULL);

    if( m_hWnd != NULL )
        return m_hWnd;

    // Create callback window the first time (m_hwndCB is static)
    if( m_atom == NULL )
    {
        // first register window class
        WNDCLASS wc;
        memset(&wc, 0, sizeof(WNDCLASS));

        wc.lpfnWndProc   = m_pWndProc;
        wc.hInstance     = _Module.GetModuleInstance();
        wc.lpszClassName = m_pszName;

        m_atom = RegisterClass(&wc);
        DWORD dwError = GetLastError();

        ASSERT(m_atom);
    }

    if( m_atom )
    {
        m_hWnd = ::CreateWindow(MAKEINTATOM(m_atom), L"", WS_DISABLED, 0,0,0,0, 
                                NULL, NULL, _Module.GetModuleInstance(), NULL);

        ASSERT(m_hWnd);
    }

    return m_hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\util.h ===
//util.h - header file for utiltity functions
#ifndef _UTIL_H_
#define _UTIL_H_

#include <atlwin.h>
#include <atlctrls.h>

// Extended listview control class
// This class adds the feature of setting focus to the listview window
// on a left mouse button down event. 
class CListViewEx : public CWindowImpl<CListViewEx, CListViewCtrl>
{
    BEGIN_MSG_MAP(CListViewEx)
    MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
    END_MSG_MAP()

    LRESULT OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        SetFocus();
        bHandled = 0;

        return TRUE;
    }
};


HBITMAP GetBitmapFromStrip(HBITMAP hbmStrip, int nPos, int cSize);
void    ConfigSingleColumnListView(HWND hwndListView);
BOOL    ModifyStyleEx(HWND hWnd, DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0);
void    EnableDlgItem(HWND hwndDialog, int iCtrlID, BOOL bEnable);
void    GetItemText(HWND hwnd, tstring& strText);
void    RemoveSpaces(LPWSTR pszBuf);
VARIANT GetDomainPath(LPCTSTR lpServer);
HRESULT ExpandDCWildCard(tstring& str);
void    EscapeSlashes(LPCWSTR pszIn, tstring& strOut);
HRESULT ExpandEnvironmentParams(tstring& strIn, tstring& strOut);
tstring StrLoadString( UINT nID );

//
// Parameter substitution function
//

// CParamLookup - function object for looking up parameter values
//
// Looks up parameter replacement string value, returning a BOOL to
// indicate iwhether a value was found.

class CParamLookup
{
public:
    virtual BOOL operator()(tstring& strParm, tstring& strValue) = 0;
};

HRESULT ReplaceParameters(tstring& str, CParamLookup& lookup, BOOL bRetainMarkers);

//
// MMC String table helpers
//
HRESULT StringTableWrite(IStringTable* pStringTable, LPCWSTR psz, MMC_STRING_ID* pID);

HRESULT StringTableRead(IStringTable* pStringTable, MMC_STRING_ID ID, tstring& str);

//
// File/Directory validation functions
//
HRESULT ValidateFile(tstring& strFilePath);

HRESULT ValidateDirectory(tstring& strDir);

//
// Message box helper
//
int DisplayMessageBox(HWND hWnd, UINT uTitleID, UINT uMsgID, UINT uStyle = MB_OK | MB_ICONEXCLAMATION, 
                      LPCWSTR pszP1 = NULL, LPCWSTR pszP2 = NULL);

//
// Event triggered callback
//

// CEventCallback - function object that performs a callback
//
// client who wants a callback derives a class from CEventCallback
// and passes an instance of it to CallbackOnEvent

class CEventCallback
{
public:
    virtual void Execute() = 0;
};

HRESULT CallbackOnEvent(HANDLE handle, CEventCallback* pCallback);


//
// Helper class to register and create hidden message windows
//
class CMsgWindowClass
{
public:
    CMsgWindowClass(LPCWSTR pszClassName, WNDPROC pWndProc) 
    : m_pszName(pszClassName), m_pWndProc(pWndProc), m_atom(NULL), m_hWnd(NULL)
    {
    }                

    virtual ~CMsgWindowClass() 
    {
        if( m_hWnd )
            DestroyWindow(m_hWnd);

        if( m_atom )
            UnregisterClass(m_pszName, _Module.GetModuleInstance());
    }

    HWND Window();

private:
    LPCWSTR m_pszName;
    WNDPROC m_pWndProc;
    ATOM    m_atom;
    HWND    m_hWnd;
};

#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\streamio.h ===
// stream i/o function header

#ifndef _STREAMIO_H_
#define _STREAMIO_H_

#include <vector>
//
// declare by-value stream operators
//
#define DeclareStreamOperators(type)                    \
    IStream& operator>> (IStream& stm,       type& t);  \
    IStream& operator<< (IStream& stm,       type  t);      
                                                        
DeclareStreamOperators (         bool);
DeclareStreamOperators (         char);
DeclareStreamOperators (unsigned char);
DeclareStreamOperators (         short);
DeclareStreamOperators (unsigned short);
DeclareStreamOperators (         int);
DeclareStreamOperators (unsigned int);
DeclareStreamOperators (         long);
DeclareStreamOperators (unsigned long);

//
// declare by-ref stream operators
//
#define DeclareStreamOperatorsByRef(type)               \
    IStream& operator>> (IStream& stm,       type& t);  \
    IStream& operator<< (IStream& stm, const type& t);

DeclareStreamOperatorsByRef (CLSID);
DeclareStreamOperatorsByRef (FILETIME);
DeclareStreamOperatorsByRef (byte_string);
DeclareStreamOperatorsByRef (tstring);

//
// operators for vector of objects
//
template <class T>
IStream& operator<< (IStream& stm, std::vector<T>& vT)
{
    stm << static_cast<long>(vT.size());

    std::vector<T>::iterator it = vT.begin();
    while (it != vT.end()) 
    {
        stm << *it;
        ++it;
    }

    return stm;
}


template <class T>
IStream& operator>> (IStream& stm, std::vector<T>& vT)
{
    long nItems;
    stm >> nItems;

    vT.reserve(nItems);

    for (long lItem = 0; lItem < nItems; lItem++) 
    {
        T* pt = new T();
        
        if( pt )
        {
            vT.push_back(*pt);
            T& rt = vT.back();

            stm >> rt;
        }
    }

    return stm;
}



#endif //_STREAMIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__32F22F6D_2F19_11D3_9B2F_00C04FA37E1F__INCLUDED_)
#define AFX_STDAFX_H__32F22F6D_2F19_11D3_9B2F_00C04FA37E1F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#define _ATL_APARTMENT_THREADED

// the following define is needed to expose system resource ID's in winuser.h
#define OEMRESOURCE

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

// WTL code
#include <atlapp.h>
#include <atlmisc.h>
#include <commctrl.h>

#include <atlwin.h>
#include <atldlgs.h>
#include <atlgdi.h>

// Snapin Info
#include <mmc.h>
#include "BOMSnap.h"
#include "comptrs.h"
#include "bomsnap.h"

#include <string>
#include <vector>
typedef std::basic_string<TCHAR> tstring;

typedef struct _BOMMENU {
    tstring  strPlain;
    tstring  strNoLoc;
} BOMMENU, *PBOMMENU;

typedef std::basic_string<BYTE>  byte_string;
typedef std::vector<tstring>     string_vector;
typedef std::vector<BOMMENU>     menu_vector;

// VERSION History
// 100 - Initial version
// 101 - Added refresh flags to menu commands
// 102 - Added propery menu flag to object class info
// 150 - Added icon's to query nodes, Changed Menu IDs, and changed AD menu reference
#define SNAPIN_VERSION ((DWORD)150)


//
// Error handling macros
//
#define ASSERT(condition) _ASSERT(condition)

#define RETURN_ON_FAILURE(hr)   if (FAILED(hr)) return hr;
#define EXIT_ON_FAILURE(hr)     if (FAILED(hr)) return;
#define BREAK_ON_FAILURE(hr)    if (FAILED(hr)) break;
#define CONTINUE_ON_FAILURE(hr) if (FAILED(hr)) continue;
#define THROW_ON_FAILURE(hr)    if (FAILED(hr)) _com_issue_error(hr);

#define THROW_ERROR(hr) _com_issue_error(hr);

#define VALIDATE_POINTER(p) \
        ASSERT(p != NULL);  \
        if (p == NULL) return E_POINTER;

#define SAFE_DELETE(p) if (p) delete p;

//
// Standard bitmap image indices
//
#define ROOT_NODE_IMAGE         0
#define ROOT_NODE_OPENIMAGE     0
#define GROUP_NODE_IMAGE        6   // Default Query Node Icon
#define GROUP_NODE_OPENIMAGE    6
#define QUERY_NODE_IMAGE        6
#define QUERY_NODE_OPENIMAGE    6
#define RESULT_ITEM_IMAGE       5   // Default Result Icon
 
// length of GUID string representation
#define GUID_STRING_LEN 39

// byte size of GUID string, including termination 
#define GUID_STRING_SIZE ((GUID_STRING_LEN + 1) * sizeof(WCHAR))

// array length
#define lengthof(arr) (sizeof(arr) / sizeof(arr[0]))

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__32F22F6D_2F19_11D3_9B2F_00C04FA37E1F__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\scopenode.h ===
// ScopeNode.h: Definition of the CScopeNode class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SCOPENODE_H__DE757919_30DB_11D3_9B2F_00C04FA37E1F__INCLUDED_)
    #define AFX_SCOPENODE_H__DE757919_30DB_11D3_9B2F_00C04FA37E1F__INCLUDED_

    #if _MSC_VER >= 1000
        #pragma once
    #endif // _MSC_VER >= 1000

    #include <vector>
    #include "resource.h"       // main symbols
    #include "dataobj.h"
    #include "notifmap.h"
    #include "queryreq.h"
    #include "rowitem.h"
    #include "menucmd.h"
    #include "compont.h"
    #include "query.h"

    #include <map>

extern const GUID GUID_RootNode;
extern const GUID GUID_GroupNode;
extern const GUID GUID_QueryNode;

//-----------------------------------------------------------------
// struct PropChangeInfo
//
// A pointer to this structure is passed as the lParam in an
// MMCN_PROPERTY_CHANGE notification. It contains a pointer to the
// target data object and the lParam for the notify. This is needed
// because the notify message from MMC has a null data object so
// the componentdata notify handler can't determine where to
// forward the call. 
//----------------------------------------------------------------
struct PropChangeInfo
{
    IDataObject* pDataObject;
    LPARAM       lNotifyParam;
};


//------------------------------------------------------------------
// class CMenuRef
//
// This class references a menu command defined at the root node
// The ID is the string table ID of the user assigned menu name.
// Names must be unique within an AD class, so the ID is too.
//------------------------------------------------------------------


class CMenuRef
{
    friend IStream& operator>> (IStream& stm, CMenuRef& menuref);
    friend IStream& operator<< (IStream& stm, CMenuRef& menuref);

    enum
    {
        MENUREF_ENABLE =  0x0001,   // set if enabled at query node
        MENUREF_DEFAULT = 0x0002    // set for default menu item
    };

public:
    CMenuRef() : m_menuID(0), m_flags(0)
    {
    };

    MMC_STRING_ID ID()
    {
        return m_menuID;
    }

    BOOL IsEnabled()
    {
        return(m_flags & MENUREF_ENABLE);
    }
    BOOL IsDefault()
    {
        return(m_flags & MENUREF_DEFAULT);
    }

    void SetEnable(BOOL bState) 
    {
        m_flags = bState ? (m_flags | MENUREF_ENABLE) : (m_flags & ~MENUREF_ENABLE);
    };
    void SetDefault(BOOL bState)
    {
        m_flags = bState ? (m_flags | MENUREF_DEFAULT) : (m_flags & ~MENUREF_DEFAULT);
    };

    // define ID comparison for std algorithms
    BOOL operator==(MMC_STRING_ID ID)
    {
        return m_menuID == ID;
    }

    MMC_STRING_ID   m_menuID;     // menu command ID
    DWORD           m_flags;      // state flags
};

typedef std::vector<CMenuRef> menuref_vector;



//------------------------------------------------------------------
// class CClassInfo
//------------------------------------------------------------------
class CClassInfo
{
    friend IStream& operator>> (IStream& stm, CClassInfo& classinfo);
    friend IStream& operator<< (IStream& stm, CClassInfo& classinfo);

public:

    CClassInfo(LPCWSTR pszClassName = NULL)
    {
        if( pszClassName != NULL )
            m_strName = pszClassName;
    }

    LPCWSTR Name()
    {
        return m_strName.c_str();
    }
    string_vector& Columns()
    {
        return m_vstrColumns;
    }
    menucmd_vector& Menus()
    {
        return m_vMenus;
    }

    HRESULT LoadStrings(IStringTable* pStringTable)
    {
        VALIDATE_POINTER( pStringTable );

        menucmd_vector::iterator itMenuCmd;
        for( itMenuCmd = Menus().begin(); itMenuCmd != Menus().end(); ++itMenuCmd )
        {
            HRESULT hr = (*itMenuCmd)->LoadName(pStringTable);
            RETURN_ON_FAILURE(hr);
        }

        return S_OK;
    }

private:

    tstring        m_strName;
    string_vector  m_vstrColumns;
    menucmd_vector m_vMenus;
};

// atribute map - maps attribute LDAP name to display name
struct attrib_comp
{
    bool operator()(const LPCWSTR psz1, const LPCWSTR psz2) const
    {
        if( !psz1 || !psz2 ) return 0;
        return wcscmp(psz1,psz2) < 0;
    }
};

typedef std::map<LPCWSTR, LPCWSTR, attrib_comp> attrib_map;


typedef std::vector<CClassInfo> classInfo_vector;


enum NODETYPE
{
    NULL_NODETYPE = 0,
    ROOT_NODETYPE,
    GROUP_NODETYPE,
    QUERY_NODETYPE
};


class CRootNode;
class CGroupNnode;
class CQueryNode;

//------------------------------------------------------------------
// class CScopeNode
//------------------------------------------------------------------
class CScopeNode :
public CComObjectRootEx<CComSingleThreadModel>,
public CDataObjectImpl
{
    friend class CGroupNode;
    friend class CQueryNode;
    friend class CRootNode;

public:
    CScopeNode() : m_pnodeParent(NULL), m_pnodeNext(NULL), m_pnodeChild(NULL), 
    m_hScopeItem(0), m_nameID(0), m_lNodeID(1), m_bIgnoreSelect(FALSE)
    {
    }
    virtual ~CScopeNode();

    static HRESULT CreateNode(NODETYPE nodetype, CScopeNode** ppnode);

    DECLARE_NOT_AGGREGATABLE(CScopeNode)

    BEGIN_COM_MAP(CScopeNode)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IBOMObject)
    END_COM_MAP()

    public:
    //
    // ScopeNode methods
    //

    // Attributes
    LPCWSTR GetName()
    {
        return m_strName.c_str();
    }
    int     HasChildren()
    {
        return(m_pnodeChild != NULL);
    }
    BOOL    IsRootNode()
    {
        return(m_pnodeParent == NULL);
    }

    int     GetNodeID()
    {
        return m_lNodeID;
    }

    virtual NODETYPE NodeType() = 0;
    virtual const GUID* NodeTypeGuid() = 0;
    virtual int GetImage() = 0;
    virtual int GetOpenImage() = 0;
    virtual BOOL IsContainer()
    {
        return FALSE;
    }

    HRESULT SetName(LPCWSTR);

    // Links
    CScopeNode* FirstChild()
    {
        return m_pnodeChild;
    }
    CScopeNode* Parent()
    {
        return m_pnodeParent;
    }
    CScopeNode* Next()
    {
        return m_pnodeNext;
    }

    CRootNode* GetRootNode();
    CComponentData* GetCompData();

    BOOL OwnsConsoleView(LPCONSOLE2 pConsole);

    //
    // Notification handlers
    //
    DECLARE_NOTIFY_MAP()

    HRESULT OnHelp(LPCONSOLE2 pConsole, LPARAM arg, LPARAM param);

    HRESULT OnExpand(LPCONSOLE2 pConsole, BOOL bExpand, HSCOPEITEM hScopeItem);
    HRESULT OnRemoveChildren(LPCONSOLE2 pConsole);
    HRESULT OnRename(LPCONSOLE2 pConsole, LPCWSTR pszName);
    HRESULT OnAddImages(LPCONSOLE2 pConsole, LPIMAGELIST pImageList);
    HRESULT OnSelect(LPCONSOLE2 pConsole, BOOL bSelect, BOOL bScope);

    virtual HRESULT OnRefresh(LPCONSOLE2 pConsole) = 0;

    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM* pRDI);
    STDMETHOD(GetResultViewType)(LPOLESTR* ppViewType, long* pViewOptions);
    STDMETHOD(AttachComponent)(CComponent* pComponent);
    STDMETHOD(DetachComponent)(CComponent* pComponent);

    HRESULT Load(IStream& stm);
    HRESULT Save(IStream& stm);
    HRESULT GetDisplayInfo(SCOPEDATAITEM* pSDI);
    HRESULT Insert(LPCONSOLENAMESPACE pNameSpace);
    HRESULT AddNewChild(CScopeNode* pnodeChild, LPCWSTR pszName);
    HRESULT AddChild(CScopeNode* pnodeChild);
    HRESULT RemoveChild(CScopeNode* pnodeDelete);
    HRESULT AddQueryNode(LPCONSOLE2 pConsole);
    HRESULT AddGroupNode(LPCONSOLE2 pConsole);
    //
    // IDataObject helper method
    //
    STDMETHOD(GetDataImpl)(UINT cf, HGLOBAL* hGlobal);

protected:
    //
    // Implementation
    //
    virtual HRESULT LoadNode(IStream& stm);
    virtual HRESULT SaveNode(IStream& stm);
    virtual void EnableVerbs(IConsoleVerb* pConsVerb, BOOL bOwnsView)
    {
    }

    //
    // Member variables
    //
protected:
    MMC_STRING_ID   m_nameID;
    long            m_lNodeID;
    tstring         m_strName;
    HSCOPEITEM      m_hScopeItem;
    BOOL            m_bIgnoreSelect;
    GUID            m_gColumnID;

    CScopeNode* m_pnodeChild;
    CScopeNode* m_pnodeNext;
    CScopeNode* m_pnodeParent;

    std::vector<CComponent*> m_vComponents; // attached components

    static UINT m_cfDisplayName;            // supported clipboard formats
    static UINT m_cfSnapInClsid;
    static UINT m_cfNodeType;
    static UINT m_cfszNodeType;
    static UINT m_cfNodeID2;
    static UINT m_cfColumnSetID;
};

typedef CComPtr<CScopeNode> CScopeNodePtr;


//------------------------------------------------------------------
// class CRootNode
//------------------------------------------------------------------
class CRootNode : public CScopeNode
{
public:
    CRootNode() : m_commentID(0)
    {
    };

    virtual NODETYPE NodeType()
    {
        return ROOT_NODETYPE;
    }
    virtual const GUID*  NodeTypeGuid()
    {
        return &GUID_RootNode;
    }

    virtual BOOL IsContainer()
    {
        return TRUE;
    }

    virtual int GetImage()
    {
        return ROOT_NODE_IMAGE;
    }
    virtual int GetOpenImage()
    {
        return ROOT_NODE_OPENIMAGE;
    }

    virtual HRESULT LoadNode(IStream& stm);
    virtual HRESULT SaveNode(IStream& stm);    

    void GetCreateTime(FILETIME* pTime)
    {
        ASSERT(pTime); 
        if( !pTime ) return;
        *pTime = m_ftCreateTime;
    }
    void GetModifyTime(FILETIME* pTime)
    {
        ASSERT(pTime); 
        if( !pTime ) return;
        *pTime = m_ftModifyTime;
    }

    void UpdateModifyTime()
    {
        GetSystemTimeAsFileTime(&m_ftModifyTime);
    }

    LPCWSTR GetOwner()
    {
        return m_strOwner.c_str();
    }
    HRESULT GetComment(tstring& strComment);
    HRESULT SetComment(LPCWSTR psz);

    CComponentData* GetRootCompData()
    {
        ASSERT(m_pCompData != NULL); return m_pCompData;
    }

    CClassInfo* FindClass(LPCWSTR pszClassName);

    void AddClass(CClassInfo* pClass)
    {
        if( !pClass || (FindClass(pClass->Name()) != NULL) ) return;        

        m_vClassInfo.push_back(*pClass); 
    }

    HRESULT Initialize(CComponentData* pCompData);    

    //
    // Notification handlers
    //
    DECLARE_NOTIFY_MAP()

    HRESULT OnHelp(LPCONSOLE2 pConsole, LPARAM arg, LPARAM param);
    HRESULT OnPropertyChange(LPCONSOLE2 pConsole, LPARAM lParam);    
    STDMETHOD(GetResultViewType)(LPOLESTR* ppViewType, long* pViewOptions);

    virtual HRESULT OnRefresh(LPCONSOLE2 pConsole)
    {
        return S_OK;
    }

    //
    // IBOMObject methods
    //
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK pCallback, long* lAllowed);
    STDMETHOD(MenuCommand)(LPCONSOLE2 pConsole, long lCommand);
    STDMETHOD(SetToolButtons)(LPTOOLBAR pToolbar)
    {
        return S_FALSE;
    }
    STDMETHOD(SetVerbs)(LPCONSOLEVERB pConsVerb)
    {
        return S_OK;
    }
    STDMETHOD(QueryPagesFor)();
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,LONG_PTR handle);
    STDMETHOD(GetWatermarks)(HBITMAP* lphWatermark, HBITMAP* lphHeader, HPALETTE* lphPalette, BOOL* bStretch);

private:
    CComponentData*   m_pCompData;
    FILETIME          m_ftCreateTime;
    FILETIME          m_ftModifyTime;
    tstring           m_strOwner;
    MMC_STRING_ID     m_commentID;
    classInfo_vector  m_vClassInfo;
};

typedef CComPtr<CRootNode> CRootNodePtr;


//------------------------------------------------------------------
// CQueryableNode
// 
// This is an abstract class which provides methods common to both
// Group nodes and Query nodes.
//------------------------------------------------------------------
class CQueryableNode : 
public CScopeNode,
public CQueryCallback
{
public:
    CQueryableNode() : m_bQueryChange(TRUE), m_pQueryReq(NULL)
    {
    }

    virtual ~CQueryableNode() 
    {
        if( m_pQueryReq != NULL ) m_pQueryReq->Stop(TRUE);
    }

    void ClearQueryRowItems();
    string_vector& QueryColumns()
    {
        return m_vstrColumns;
    }

    HRESULT OnRefresh(LPCONSOLE2 pConsole);

    STDMETHOD(AttachComponent)(CComponent* pComponent);
    STDMETHOD(DetachComponent)(CComponent* pComponent);

    virtual HRESULT GetQueryAttributes(attrib_map& mapAttr) = 0;
    virtual HRESULT StartQuery(string_vector& vstrColumns, CQueryCallback* pCallback, CQueryRequest** ppReq) = 0;
    virtual BOOL    OnClassChange(string_vector& vstrClasses) = 0;
    //
    // CQueryCallback
    //
    virtual void QueryCallback(QUERY_NOTIFY event, CQueryRequest* pQueryReq, LPARAM lUserParam);

    bool               m_bQueryChange;

protected:

    CQueryRequest*     m_pQueryReq;
    string_vector      m_vstrColumns;
    RowItemVector      m_vRowItems;
};

typedef CComPtr<CQueryableNode> CQueryableNodePtr;

//------------------------------------------------------------------
// class CGroupNode
//------------------------------------------------------------------
class CGroupNode : public CQueryableNode
{
public:
    CGroupNode() : m_bApplyScope(FALSE), m_bApplyFilter(FALSE), m_bLocalScope(FALSE)
    {
    };

    virtual NODETYPE NodeType()
    {
        return GROUP_NODETYPE;
    }
    virtual const GUID* NodeTypeGuid()
    {
        return &GUID_GroupNode;
    }

    virtual BOOL IsContainer()
    {
        return TRUE;
    }

    virtual int GetImage()
    {
        return GROUP_NODE_IMAGE;
    }
    virtual int GetOpenImage()
    {
        return GROUP_NODE_OPENIMAGE;
    }

    LPCWSTR ClassName()
    {
        return m_strClassName.c_str();
    }
    LPCWSTR Filter()
    {
        return m_strFilter. c_str();
    }
    LPCWSTR Scope()
    {
        return m_bLocalScope ? GetLocalDomain() : m_strScope.c_str();
    }
    LPCWSTR QueryScope()
    {
        return m_strScope.c_str();
    }

    BOOL    ApplyScope()
    {
        return m_bApplyScope;
    }
    BOOL    ApplyFilter()
    {
        return m_bApplyFilter;
    }

    //
    // Notification handlers
    //
    DECLARE_NOTIFY_MAP()

    HRESULT OnDelete(LPCONSOLE2 pConsole);
    HRESULT OnAddImages(LPCONSOLE2 pConsole, LPIMAGELIST pImageList);

    STDMETHOD(GetResultViewType)(LPOLESTR* ppViewType, long* pViewOptions);

    virtual void EnableVerbs(IConsoleVerb *pConsVerb, BOOL bOwnsView);
    virtual HRESULT LoadNode(IStream& stm);
    virtual HRESULT SaveNode(IStream& stm);

    void SetScope(LPCWSTR pszScope)
    {
        m_strScope = pszScope;
    }
    void SetFilter(LPCWSTR pszFilter)
    {
        m_strFilter = pszFilter;
    }
    void SetClassName(LPCWSTR pszName)
    {
        m_strClassName = pszName;
    }
    void SetApplyScope(bool bState)
    {
        m_bApplyScope = bState;
    }
    void SetApplyFilter(bool bState)
    {
        m_bApplyFilter = bState;
    }

    //
    // CQueryableNode methods
    //
    virtual HRESULT GetQueryAttributes(attrib_map& mapAttr);
    virtual HRESULT StartQuery(string_vector& vstrColumns, CQueryCallback* pCallback, CQueryRequest** ppReq);
    virtual BOOL    OnClassChange(string_vector& vstrClasses);

    //
    // IBOMObject methods
    //
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK pCallback, long* lAllowed);
    STDMETHOD(MenuCommand)(LPCONSOLE2 pConsole, long lCommand);
    STDMETHOD(SetToolButtons)(LPTOOLBAR pToolbar)
    {
        return S_FALSE;
    }
    STDMETHOD(SetVerbs)(LPCONSOLEVERB pConsVerb)
    {
        return S_OK;
    }

    STDMETHOD(QueryPagesFor)();
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,LONG_PTR handle);

    STDMETHOD(GetWatermarks)(HBITMAP* lphWatermark, HBITMAP* lphHeader, 
                             HPALETTE* lphPalette, BOOL* bStretch)
    {
        return S_FALSE;
    }

    //
    // CQueryCallback
    //
    virtual void QueryCallback(QUERY_NOTIFY event, CQueryRequest* pQueryReq, LPARAM lUserParam);


private:
    tstring m_strClassName;
    tstring m_strScope;
    tstring m_strFilter;
    bool    m_bApplyScope;
    bool    m_bApplyFilter;
    bool    m_bLocalScope;

    CQueryNode* m_pQNodeActive;
};

typedef CComPtr<CGroupNode> CGroupNodePtr;


//------------------------------------------------------------------
// class CQueryObjInfo
//------------------------------------------------------------------

// This class contains AD class information that is define at each
// query node. The query node holds a vector of these structures,
// one for each class that its query can bring back.

class CQueryObjInfo
{
public:
    CQueryObjInfo(LPCWSTR pszName = NULL)
    {
        if( pszName != NULL )
            m_strName = pszName;

        m_bPropertyMenu = TRUE;
    }

    LPCWSTR Name()
    {
        return m_strName.c_str();
    }

    menuref_vector& MenuRefs()
    {
        return m_vMenuRefs;
    }
    string_vector& DisabledColumns()
    {
        return m_vstrDisabledColumns;
    }

    BOOL HasPropertyMenu()
    {
        return m_bPropertyMenu;
    }
    void SetPropertyMenu(BOOL bEnable)
    {
        m_bPropertyMenu = bEnable;
    }

    tstring         m_strName;
    menuref_vector  m_vMenuRefs;
    string_vector   m_vstrDisabledColumns;
    BOOL            m_bPropertyMenu;
};

typedef std::vector<CQueryObjInfo> QueryObjVector;

//------------------------------------------------------------------
// class CQueryNode
//------------------------------------------------------------------

class  CQueryNode : 
public CQueryableNode
{

public:

    CQueryNode() : m_bLocalScope(TRUE), m_commentID(0), m_nIconIndex(-1)
    {
    };

    virtual NODETYPE NodeType()
    {
        return QUERY_NODETYPE;
    }
    virtual const GUID* NodeTypeGuid()
    {
        return &GUID_QueryNode;
    }

    virtual int GetImage()
    {        
        return (m_nIconIndex == -1) ? QUERY_NODE_IMAGE : m_nIconIndex;
    }
    virtual int GetOpenImage()
    {        
        return (m_nIconIndex == -1) ? QUERY_NODE_OPENIMAGE : m_nIconIndex;
    }

    void SetImage(int nIcon)
    {
        m_nIconIndex = nIcon;
    }

    DECLARE_NOTIFY_MAP()

    HRESULT OnDelete(LPCONSOLE2 pConsole);
    HRESULT OnAddImages(LPCONSOLE2 pConsole, LPIMAGELIST pImageList);

    STDMETHOD(GetResultViewType)(LPOLESTR* ppViewType, long* pViewOptions);
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM* pRDI);

    //
    // IBOMObject methods
    //
    STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK pCallback, long* lAllowed);
    STDMETHOD(MenuCommand)(LPCONSOLE2 pConsole, long lCommand);
    STDMETHOD(SetToolButtons)(LPTOOLBAR pToolbar);
    STDMETHOD(SetVerbs)(LPCONSOLEVERB pConsVerb)
    {
        return S_OK;
    }

    STDMETHOD(QueryPagesFor)();
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,LONG_PTR handle);

    STDMETHOD(GetWatermarks)(HBITMAP* lphWatermark, HBITMAP* lphHeader, HPALETTE* lphPalette, BOOL* bStretch)
    {
        return S_FALSE;
    }


    //
    // Implementation
    //        
    virtual HRESULT LoadNode(IStream& stm);
    virtual HRESULT SaveNode(IStream& stm);
    virtual void EnableVerbs(IConsoleVerb *pConsVerb, BOOL bOwnsView);

    void SetScope(LPCWSTR pszScope)
    {
        m_strScope = pszScope;
    }
    void SetQuery(LPCWSTR pszQuery)
    {
        m_strQuery = pszQuery;
    }
    void SetLocalScope(bool bState)
    {
        m_bLocalScope = bState;
    }

    LPCWSTR QueryScope()
    {
        return m_strScope.c_str();
    }
    bool    UseLocalScope()
    {
        return m_bLocalScope;
    }
    LPCWSTR Scope()
    {
        return(m_bLocalScope ? GetLocalDomain() : m_strScope.c_str());
    }

    LPCWSTR Query()
    {
        return m_strQuery.c_str();
    }
    void    ExpandQuery(tstring& strIn)   
    {
        strIn = m_strQuery;
        ExpandDCWildCard(strIn);
    }


    HRESULT GetComment(tstring& strComment);
    HRESULT SetComment(LPCWSTR pszComment);


    QueryObjVector& Objects()
    {
        return m_vObjInfo;
    }
    menucmd_vector& Menus()
    {
        return m_vMenus;
    }    

    HRESULT GetClassMenuItems(LPCWSTR pszClass, menucmd_vector& vMenus, int* piDefault, BOOL* bPropertyMenu);
    HRESULT EditQuery(HWND hWndParent);

    //
    // CQueryableNode methods
    //
    virtual HRESULT GetQueryAttributes(attrib_map& mapAttr);
    virtual HRESULT StartQuery(string_vector& vstrColumns, CQueryCallback* pCallback, CQueryRequest** ppReq);
    virtual BOOL    OnClassChange(string_vector& vstrClasses);

private:

    HRESULT LoadStrings(IStringTable* pStringTable)
    {
        VALIDATE_POINTER( pStringTable );

        menucmd_vector::iterator itMenuCmd;
        for( itMenuCmd = Menus().begin(); itMenuCmd != Menus().end(); ++itMenuCmd )
        {
            HRESULT hr = (*itMenuCmd)->LoadName(pStringTable);
            RETURN_ON_FAILURE(hr);
        }

        return S_OK;
    }

    tstring            m_strScope;
    tstring            m_strQuery;
    byte_string        m_bsQueryData;
    MMC_STRING_ID      m_commentID;
    QueryObjVector     m_vObjInfo;
    bool               m_bLocalScope;
    menucmd_vector     m_vMenus;     // Query Nodes now have menus
    int                m_nIconIndex; // Query Nodes have user-defined icons, too
};

typedef CComPtr<CQueryNode> CQueryNodePtr;


////////////////////////////////////////////////////////////////
// CQueryLookup
//
// This class provides an implementation of CParamLookup which
// is used to translate shell menu command parameters to the
// corresponding query row item values.

class CQueryLookup : public CParamLookup
{
public:
    CQueryLookup(CQueryableNode* pQNode, CRowItem* pRowItem) 
    : m_pQNode(pQNode), m_pRowItem(pRowItem)
    {
    }

    virtual BOOL operator() (tstring& strParam, tstring& strValue);

    CQueryableNode* m_pQNode;
    CRowItem*   m_pRowItem;
};


#endif // !defined(AFX_SCOPENODE_H__DE757919_30DB_11D3_9B2F_00C04FA37E1F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\wizards.h ===
// wizards.h - Wizards header

#ifndef _WIZARDS_H_
#define _WIZARDS_H_

#include "util.h"
#include "scopenode.h"

class CAddQueryWizard;
class CQueryNode;

// Common wizard base class
class CWizardBase 
{
public:
    CWizardBase() : m_hFontWelcome(0) {}
    virtual ~CWizardBase() { if (m_hFontWelcome) DeleteObject(m_hFontWelcome); }

    virtual HRESULT Run(IPropertySheetProvider* pProvider, HWND hwndParent) = 0;

    virtual int OnNext(UINT uPageID) { return 0; }
    virtual int OnBack(UINT uPageID) { return 0; }
    virtual BOOL OnCancel() = 0;

    HFONT GetWelcomeFont();

protected:
    void SetWizardBitmaps(UINT watermarkID, UINT headerID);
    BOOL AddPage(HPROPSHEETPAGE hPage) { return m_propsheet.AddPage(hPage); }
    HWND GetActivePage() { return m_propsheet.GetActivePage(); }
    int DoModal(HWND hwndParent) { return m_propsheet.DoModal(hwndParent); }

private:
    HFONT   m_hFontWelcome;
    CPropertySheet m_propsheet;
};


///////////////////////////////////////////////////////////////////////////
// CQueryWizPage

class CQueryWizPage : public CPropertyPageImpl<CQueryWizPage>
{

public:
    typedef CPropertyPageImpl<CQueryWizPage> BC;

    enum { IDD = IDD_QUERY_WIZ_QUERY };

    // Constructor/destructor
    CQueryWizPage(CWizardBase* pWizard) : m_pWizard(pWizard), m_pQueryNode(NULL) {}

    void Initialize(CQueryNode* pQueryNode) 
    { 
        m_pQueryNode = pQueryNode;

        m_psp.dwFlags |= PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;

        m_strTitle.LoadString(IDS_QUERYWIZ_TITLE);
        m_psp.pszHeaderTitle = m_strTitle;

        m_strSubTitle.LoadString(IDS_QUERYWIZ_SUBTITLE);
        m_psp.pszHeaderSubTitle = m_strSubTitle;   
    }

    LPCWSTR GetQueryName() { return m_strQueryName.c_str(); }

protected:
    BEGIN_MSG_MAP( CQueryWizPage )
        COMMAND_HANDLER(IDC_NAME,        EN_CHANGE,  OnNameChange)
        COMMAND_HANDLER(IDC_CREATEQUERY, BN_CLICKED, OnCreateQuery)
        COMMAND_HANDLER(IDC_QUERYSCOPE, BN_CLICKED, OnScopeChange)
        COMMAND_HANDLER(IDC_LOCALSCOPE, BN_CLICKED, OnScopeChange)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // message handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnNameChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnCreateQuery( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnScopeChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    // overrrides
    BOOL OnSetActive();
    BOOL OnKillActive();
    BOOL OnQueryCancel() { return m_pWizard ? m_pWizard->OnCancel() : FALSE; }
    int OnWizardNext()   { return m_pWizard ? m_pWizard->OnNext(IDD_QUERY_WIZ_QUERY) : 0; }

    void UpdateButtons();
	void DisplayScope();

private:
    CWizardBase* m_pWizard;
    CQueryNode*  m_pQueryNode;
    tstring       m_strQueryName;
    CString      m_strTitle;
    CString      m_strSubTitle;
};


///////////////////////////////////////////////////////////////////////////
// CQueryIconPage

class CQueryIconPage : public CPropertyPageImpl<CQueryIconPage>
{

public:
    typedef CPropertyPageImpl<CQueryIconPage> BC;

    enum { IDD = IDD_SELECTICON_PAGE };

    // Constructor/destructor
    CQueryIconPage(CWizardBase* pWizard) : m_pWizard(pWizard), m_pQueryNode(NULL) {}

    void Initialize(CQueryNode* pQueryNode) 
    { 
        m_pQueryNode = pQueryNode;        

        m_psp.dwFlags |= PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;

        m_strTitle.LoadString(IDS_QUERYICON_TITLE);
        m_psp.pszHeaderTitle = m_strTitle;

        m_strSubTitle.LoadString(IDS_QUERYICON_SUBTITLE);
        m_psp.pszHeaderSubTitle = m_strSubTitle;   
    }

protected:
    BEGIN_MSG_MAP( CQueryIconPage )        
        NOTIFY_HANDLER ( IDC_ICONLIST, LVN_ITEMCHANGED, OnIconSelected )
        MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // message handlers
    LRESULT OnInitDialog    ( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );    
    LRESULT OnIconSelected  ( int idCtrl, LPNMHDR pnmh, BOOL& bHandled );

    // overrrides
    BOOL OnSetActive();
    BOOL OnKillActive();
    BOOL OnQueryCancel() { return m_pWizard ? m_pWizard->OnCancel() : FALSE; }
    int OnWizardBack()   { return m_pWizard ? m_pWizard->OnBack(IDD_SELECTICON_PAGE) : 0; }
    int OnWizardNext()   { return m_pWizard ? m_pWizard->OnNext(IDD_SELECTICON_PAGE) : 0; }

    void UpdateButtons();	

private:
    CWizardBase* m_pWizard;
    CQueryNode*  m_pQueryNode;        
    CString      m_strTitle;
    CString      m_strSubTitle;
};



//////////////////////////////////////////////////////////////////////////
// CObjectWizPage

class CObjectWizPage : public CPropertyPageImpl<CObjectWizPage>
{

public:
    typedef CPropertyPageImpl<CObjectWizPage> BC;

    enum { IDD = IDD_QUERY_WIZ_OBJECT };

    // Constructor/destructor
    CObjectWizPage(CWizardBase* pWizard) : m_pWizard(pWizard), m_bSkipObjects(FALSE), m_pvpClassInfo(NULL) {}

    void Initialize() 
    { 
        m_psp.dwFlags |= PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;

        m_strTitle.LoadString(IDS_OBJECTWIZ_TITLE);
        m_psp.pszHeaderTitle = m_strTitle;

        m_strSubTitle.LoadString(IDS_OBJECTWIZ_SUBTITLE);
        m_psp.pszHeaderSubTitle = m_strSubTitle;   
    }

    void SetClassInfo(std::vector<CClassInfo*>* pvpClassInfo) { m_pvpClassInfo = pvpClassInfo; }
    BOOL SkipObjects() { return m_bSkipObjects; }

protected:
    BEGIN_MSG_MAP( CObjectWizPage )
        COMMAND_HANDLER(IDC_DEFINE_QUERY_OBJS, BN_CLICKED, OnSkipChange)
        COMMAND_HANDLER(IDC_SKIP_QUERY_OBJS,   BN_CLICKED, OnSkipChange)        
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // message handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnSkipChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    // overrrides
    BOOL OnSetActive();
    BOOL OnQueryCancel() { return m_pWizard ? m_pWizard->OnCancel() : FALSE; }
    int OnWizardNext()   { return m_pWizard ? m_pWizard->OnNext(IDD_QUERY_WIZ_OBJECT) : 0; }

private:
    CWizardBase* m_pWizard;
    BOOL         m_bSkipObjects;
    CString      m_strTitle;
    CString      m_strSubTitle;

    std::vector<CClassInfo*>* m_pvpClassInfo;
};



/////////////////////////////////////////////////////////////////
// CMenuWizPage

class CMenuWizPage : public CPropertyPageImpl<CMenuWizPage>
{

public:
    typedef CPropertyPageImpl<CMenuWizPage> BC;

    // Constructor/destructor
    CMenuWizPage(CWizardBase* pWizard) : m_pWizard(pWizard), m_pClassInfo(NULL), m_pStringTable(NULL) {}
    virtual ~CMenuWizPage() { m_MenuLV.Detach(); }

    enum { IDD = IDD_COMMON_WIZ_MENU };

    void Initialize(IStringTable* pStringTable) 
    { 
        m_pStringTable = pStringTable;

        m_psp.dwFlags |= PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;

        m_strTitle.LoadString(IDS_MENUWIZ_TITLE);
        m_psp.pszHeaderTitle = m_strTitle;

        m_strSubTitle.LoadString(IDS_MENUWIZ_SUBTITLE);
        m_psp.pszHeaderSubTitle = m_strSubTitle;
    }
    void SetClassInfo(CClassInfo* pClassInfo) { m_pClassInfo = pClassInfo; }
    void AddMenuItem(CMenuCmd* pMenuCmd);

protected:
    BEGIN_MSG_MAP( CMenuWizPage )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        NOTIFY_HANDLER(IDC_MENULIST, LVN_ITEMCHANGED, OnMenuListChanged)
        COMMAND_HANDLER(IDC_ADDMENU, BN_CLICKED, OnAddMenu)
        COMMAND_HANDLER(IDC_REMOVEMENU, BN_CLICKED, OnRemoveMenu)
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // message handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnAddMenu( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnRemoveMenu( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnMenuListChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);
    
    // overrrides
    BOOL OnSetActive();
    BOOL OnQueryCancel() { return m_pWizard ? m_pWizard->OnCancel() : FALSE; }

    int OnWizardNext() { return m_pWizard ? m_pWizard->OnNext(IDD_COMMON_WIZ_MENU) : 0; }
    int OnWizardBack() { return m_pWizard ? m_pWizard->OnBack(IDD_COMMON_WIZ_MENU) : 0; }

private:
    CWizardBase*  m_pWizard;
    IStringTable* m_pStringTable;
    CClassInfo*   m_pClassInfo;
    CListViewEx   m_MenuLV;
    CString       m_strTitle;
    CString       m_strSubTitle;

};


///////////////////////////////////////////////////////////////////////
// CPropertyWizPage

class CPropertyWizPage : public CPropertyPageImpl<CPropertyWizPage>
{

public:
    typedef CPropertyPageImpl<CPropertyWizPage> BC;

    enum { IDD = IDD_COMMON_WIZ_PROPERTIES };

    // Constructor/destructor
    CPropertyWizPage(CWizardBase* pWizard) : m_pWizard(pWizard), m_pClassInfo(NULL) {}

    void Initialize()
    {
        m_psp.dwFlags |= PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;
        
        m_strTitle.LoadString(IDS_PROPWIZ_TITLE);
        m_psp.pszHeaderTitle = m_strTitle;
        
        m_strSubTitle.LoadString(IDS_PROPWIZ_SUBTITLE);
        m_psp.pszHeaderSubTitle = m_strSubTitle;
    }

    void SetClassInfo(CClassInfo* pClassInfo) { m_pClassInfo = pClassInfo; }

protected:
    BEGIN_MSG_MAP( CPropertyWizPage )
        NOTIFY_HANDLER(IDC_COLUMNLIST, LVN_ITEMCHANGED, OnColumnChanged)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // message handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnColumnChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled);


    // overrrides
    BOOL OnSetActive();
    BOOL OnKillActive();
    BOOL OnQueryCancel() { return m_pWizard ? m_pWizard->OnCancel() : FALSE; }

    int OnWizardNext() { return m_pWizard ? m_pWizard->OnNext(IDD_COMMON_WIZ_PROPERTIES) : 0; }
    int OnWizardBack() { return m_pWizard ? m_pWizard->OnBack(IDD_COMMON_WIZ_PROPERTIES) : 0; }

    virtual void SetDialogText(LPCTSTR pszClass);

protected:
    CWizardBase* m_pWizard;
    CClassInfo*  m_pClassInfo;
    CListViewEx  m_ColumnLV;
    CString      m_strTitle;
    CString      m_strSubTitle;
    BOOL         m_bLoading;
};


///////////////////////////////////////////////////////////////////////////////
// CColumnWizPage
//
// This class derives from CPropertyWizPage and just overrides the Initialization 
// and SetDialogText methods in order to display the term Columns rather than Properties.
// The Object wizard uses the term Properties and the Query wizard uses Columns.
 
class CColumnWizPage : public CPropertyWizPage
{
public:

    CColumnWizPage(CWizardBase* pWizard) : CPropertyWizPage(pWizard) {}

    void Initialize()
	{
        m_psp.dwFlags |= PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;
        
        m_strTitle.LoadString(IDS_COLWIZ_TITLE);
        m_psp.pszHeaderTitle = m_strTitle;
        
        m_strSubTitle.LoadString(IDS_COLWIZ_SUBTITLE);
        m_psp.pszHeaderSubTitle = m_strSubTitle;
	}

protected:
    virtual void SetDialogText(LPCTSTR pszClass);

};


//////////////////////////////////////////////////////////////////////////
// CAddQueryWelcomePage

class CAddQueryWelcomePage : public CPropertyPageImpl<CAddQueryWelcomePage>
{

public:
    typedef CPropertyPageImpl<CAddQueryWelcomePage> BC;

    enum { IDD = IDD_QUERY_WIZ_WELCOME };

    // Constructor/destructor
    CAddQueryWelcomePage(CWizardBase* pWizard) : m_pWizard(pWizard) 
    {
        // show watwrmark rather than header
        m_psp.dwFlags |= PSP_HIDEHEADER;
    }

protected:
    BEGIN_MSG_MAP( CAddQueryWelcomePage )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // message handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );

    // overrrides
    BOOL OnSetActive();
    BOOL OnQueryCancel() { return m_pWizard ? m_pWizard->OnCancel() : FALSE; }


private:
    CWizardBase* m_pWizard;
};


///////////////////////////////////////////////////////////////////////////
// CAddQueryCompletionPage

class CAddQueryCompletionPage : public CPropertyPageImpl<CAddQueryCompletionPage>
{

public:
    typedef CPropertyPageImpl<CAddQueryCompletionPage> BC;

    // Constructor/destructor
    CAddQueryCompletionPage(CWizardBase* pWizard) : m_pWizard(pWizard), m_pQueryNode(NULL) 
    {
        // show watwrmark rather than header
        m_psp.dwFlags |= PSP_HIDEHEADER;
    }

    void Initialize(CQueryNode* pQueryNode) { m_pQueryNode = pQueryNode; }

    enum { IDD = IDD_QUERY_WIZ_COMPLETION };

protected:
    BEGIN_MSG_MAP( CAddQueryCompletionPage )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // message handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );

    // overrrides
    BOOL OnSetActive();
    BOOL OnQueryCancel() { return m_pWizard ? m_pWizard->OnCancel(): FALSE; }

    int OnWizardBack() { return m_pWizard ? m_pWizard->OnBack(IDD_QUERY_WIZ_COMPLETION) : 0; }

private:
    CWizardBase* m_pWizard;
    CQueryNode*  m_pQueryNode;
};


//////////////////////////////////////////////////////////////////////////////
// CAddQueryWizard

class CAddQueryWizard : public CWizardBase
{

public:
    CAddQueryWizard() : m_pQueryNode(NULL), m_pRootNode(NULL), 
        m_WelcomePage(this),  m_ObjectPage(this), m_QueryPage(this), m_MenuPage(this), 
        m_PropertyPage(this), m_CompletionPage(this), m_IconPage(this) {} 

    virtual ~CAddQueryWizard() 
    {
        // Delete the class info because the vector holds plain pointers
        std::vector<CClassInfo*>::iterator itpClass;
        for (itpClass = m_vpClassInfo.begin(); itpClass != m_vpClassInfo.end(); ++itpClass)
            delete *itpClass;
    }

    void Initialize(CQueryNode* pQueryNode, CRootNode* pRootNode, IStringTable* pStringTable) 
    { 
        ASSERT(pQueryNode != NULL && pRootNode != NULL && pStringTable != NULL);
        m_pQueryNode = pQueryNode;
        m_pRootNode =  pRootNode;

        m_QueryPage.Initialize(pQueryNode);
        m_IconPage.Initialize(pQueryNode);
        m_ObjectPage.Initialize();
        m_MenuPage.Initialize(pStringTable);
        m_PropertyPage.Initialize();
        m_CompletionPage.Initialize(pQueryNode);
    }

    virtual HRESULT Run(IPropertySheetProvider* pProvider, HWND hwndParent);
    LPCWSTR GetQueryName() { return m_QueryPage.GetQueryName(); }
    std::vector<CClassInfo*>& GetNewClassInfo() { return m_vpClassInfo; } 

public:

    // CWizardBase methods
    virtual int OnNext(UINT uPageID);
    virtual int OnBack(UINT uPageID);
    virtual BOOL OnCancel();

protected:
    void SelectClasses();

protected:
    CAddQueryWelcomePage    m_WelcomePage;
    CQueryWizPage           m_QueryPage;
    CQueryIconPage          m_IconPage;
    CObjectWizPage          m_ObjectPage;
    CMenuWizPage            m_MenuPage;
    CPropertyWizPage        m_PropertyPage;
    CAddQueryCompletionPage m_CompletionPage;     

    CQueryNode*             m_pQueryNode;
    CRootNode*              m_pRootNode;
    int                     m_iClassIndex;
    std::vector<CClassInfo*> m_vpClassInfo;
};


//////////////////////////////////////////////////////////////////////////
// CAddObjectWelcomePage

class CAddObjectWelcomePage : public CPropertyPageImpl<CAddObjectWelcomePage>
{

public:
    typedef CPropertyPageImpl<CAddObjectWelcomePage> BC;

    enum { IDD = IDD_OBJECT_WIZ_WELCOME };

    // Constructor/destructor
    CAddObjectWelcomePage(CWizardBase* pWizard) : m_pWizard(pWizard) 
    {
        // show watwrmark rather than header
        m_psp.dwFlags |= PSP_HIDEHEADER;
    }

protected:
    BEGIN_MSG_MAP( CAddObjectWelcomePage )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // message handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );

    // overrrides
    BOOL OnSetActive();
    BOOL OnQueryCancel() { return m_pWizard ? m_pWizard->OnCancel() : FALSE; }

private:
    CWizardBase* m_pWizard;
};


///////////////////////////////////////////////////////////////////////////
// CAddObjectCompletionPage

class CAddObjectCompletionPage : public CPropertyPageImpl<CAddObjectCompletionPage>
{

public:
    typedef CPropertyPageImpl<CAddObjectCompletionPage> BC;

    // Constructor/destructor
    CAddObjectCompletionPage(CWizardBase* pWizard) : m_pWizard(pWizard), m_pClassInfo(NULL)
    {
        // show watermark rather than header
        m_psp.dwFlags |= PSP_HIDEHEADER;
    }

    void SetClassInfo(CClassInfo* pClassInfo) { m_pClassInfo = pClassInfo; }


    enum { IDD = IDD_OBJECT_WIZ_COMPLETION };

protected:
    BEGIN_MSG_MAP( CAddObjectCompletionPage )
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_HANDLER(IDC_SETTINGS, EN_SETFOCUS, OnSetFocus)
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // message handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnSetFocus( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    // overrrides
    BOOL OnSetActive();
    BOOL OnQueryCancel() { return m_pWizard ? m_pWizard->OnCancel() : FALSE; }

    int OnWizardBack() { return m_pWizard ? m_pWizard->OnBack(IDD_QUERY_WIZ_COMPLETION) : 0; }

private:
    CWizardBase* m_pWizard;
    CClassInfo* m_pClassInfo;
	BOOL bFirstFocus;
};


///////////////////////////////////////////////////////////////////////////
// CObjSelectWizPage

class CObjSelectWizPage : public CPropertyPageImpl<CObjSelectWizPage>
{

public:
    typedef CPropertyPageImpl<CObjSelectWizPage> BC;

    enum { IDD = IDD_OBJECT_WIZ_SELECT };

    // Constructor/destructor
    CObjSelectWizPage(CWizardBase* pWizard) : m_pWizard(pWizard), m_pvstrCurClasses(NULL) {}

    void Initialize(string_vector* pvstrCurClasses) 
    { 
        m_pvstrCurClasses = pvstrCurClasses; 

        m_psp.dwFlags |= PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;

        m_strTitle.LoadString(IDS_OBJSELWIZ_TITLE);
        m_psp.pszHeaderTitle = m_strTitle;

        m_strSubTitle.LoadString(IDS_OBJSELWIZ_SUBTITLE);
        m_psp.pszHeaderSubTitle = m_strSubTitle;   
    }

    LPCWSTR GetSelectedClass();

protected:
    BEGIN_MSG_MAP( CObjSelectWizPage )
        COMMAND_HANDLER(IDC_OBJECTLIST, LBN_SELCHANGE, OnObjectSelect)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        CHAIN_MSG_MAP(BC)
    END_MSG_MAP()

    // message handlers
    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnObjectSelect( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    // overrrides
    BOOL OnSetActive();
    BOOL OnQueryCancel() { return m_pWizard ? m_pWizard->OnCancel() : FALSE; }

    int OnWizardNext() { return m_pWizard ? m_pWizard->OnNext(IDD_OBJECT_WIZ_SELECT) : 0; }

    void UpdateButtons();

private:
    CWizardBase* m_pWizard;
    string_vector* m_pvstrCurClasses;
    CString     m_strTitle;
    CString     m_strSubTitle;
};


//////////////////////////////////////////////////////////////////////////////
// CAddObjectWizard

class CAddObjectWizard : public CWizardBase
{

public:
    CAddObjectWizard() : m_pRootNode(NULL), m_pClassInfo(NULL), 
        m_WelcomePage(this),  m_ObjSelectPage(this), m_MenuPage(this), 
        m_PropertyPage(this), m_CompletionPage(this) {} 

    virtual ~CAddObjectWizard() {}

    void Initialize(string_vector* pvstrCurClasses, IStringTable* pStringTable) 
    { 
        m_ObjSelectPage.Initialize(pvstrCurClasses);
        m_MenuPage.Initialize(pStringTable);
        m_PropertyPage.Initialize();
    }

    CClassInfo* GetNewObject() { return m_pClassInfo; }

    virtual HRESULT Run(IPropertySheetProvider* pProvider, HWND hwndParent);

public:

    // CWizardBase methods
    virtual int OnNext(UINT uPageID);
    virtual BOOL OnCancel();

protected:
    CAddObjectWelcomePage    m_WelcomePage;
    CObjSelectWizPage        m_ObjSelectPage;
    CMenuWizPage             m_MenuPage;
    CPropertyWizPage         m_PropertyPage;
    CAddObjectCompletionPage m_CompletionPage;     

    CRootNode*         m_pRootNode;
    CClassInfo*        m_pClassInfo;
};

#endif //_WIZARDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cys\servmgmt\snapins\manager\wizards.cpp ===
// wizards.cpp - Add Query Node and Add Object Wizards

#include "stdafx.h"

#include "wizards.h"
#include "namemap.h"
#include "cmndlgs.h"

#include <algorithm>
#include <atlgdi.h>

#include <windowsx.h>

#undef SubclassWindow

HRESULT GetClassNameList(QueryObjVector& vObjects, tstring& strNames, LPCWSTR pszSeparator);

#define CHECK_OFF INDEXTOSTATEIMAGEMASK(1)
#define CHECK_ON  INDEXTOSTATEIMAGEMASK(2)



//////////////////////////////////////////////////////////////////////////////////////////
// CAddQueryWelcomePage

LRESULT CAddQueryWelcomePage::OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if( !m_pWizard ) return 0;

    HFONT hfont = m_pWizard->GetWelcomeFont();
    if( hfont )
    {
        ::SendMessage(GetDlgItem(IDC_WELCOME), WM_SETFONT, (WPARAM)hfont, (LPARAM)0);
    }

    return 0;
}


BOOL CAddQueryWelcomePage::OnSetActive()
{
    ::PostMessage(GetParent(), PSM_SETTITLE, 0, (LPARAM)IDS_ADDQUERY_WIZ); 
    ::PostMessage(GetParent(), PSM_SETWIZBUTTONS, (WPARAM)0, (LPARAM)PSWIZB_NEXT);

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////////
// CQueryWizPage

LRESULT CQueryWizPage::OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // display current scope
    DisplayScope();

    // Limit display name
    Edit_LimitText(GetDlgItem(IDC_NAME), 255);

    return TRUE;
}


BOOL CQueryWizPage::OnSetActive()
{
    UpdateButtons();
    return TRUE;
}

BOOL CQueryWizPage::OnKillActive()
{
    GetItemText(GetDlgItem(IDC_NAME), m_strQueryName);
    return TRUE;
}


LRESULT CQueryWizPage::OnNameChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    UpdateButtons();
    return 0;
}


LRESULT CQueryWizPage::OnScopeChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // if user changes scope selection then update query and display the correct scope    
    if( m_pQueryNode)
    {
        m_pQueryNode->SetLocalScope(Button_GetCheck(GetDlgItem(IDC_LOCALSCOPE)) == BST_CHECKED);
    }

    DisplayScope();

    return 0;
}


LRESULT CQueryWizPage::OnCreateQuery( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if( !m_pQueryNode ) return 0;

    HRESULT hr = m_pQueryNode->EditQuery(m_hWnd);
    if( hr == S_OK )
    {
        tstring strTempQuery;
        m_pQueryNode->ExpandQuery(strTempQuery);
        SetDlgItemText( IDC_FILTER, strTempQuery.c_str() );

        // User may have changed scope and scope source, so redisplay
        DisplayScope();

        // get comma separated list of object classes associated with query
        tstring strClasses;
        GetClassNameList(m_pQueryNode->Objects(), strClasses, L", ");
        SetDlgItemText( IDC_OBJCLASS, strClasses.c_str() );

        UpdateButtons();
    }

    return 0;
}

void CQueryWizPage::UpdateButtons()
{
    if( !m_pQueryNode ) return;

    DWORD dwButtons = PSWIZB_BACK;
    LPCWSTR pszTemp = m_pQueryNode->Query();
    if( pszTemp && wcslen(pszTemp) && ::Edit_GetTextLength(GetDlgItem(IDC_NAME)) )
    {
        dwButtons |= PSWIZB_NEXT;
    }

    ::PropSheet_SetWizButtons(GetParent(), dwButtons);
}

void CQueryWizPage::DisplayScope()
{
    if( !m_pQueryNode ) return;

    Button_SetCheck(GetDlgItem(IDC_LOCALSCOPE), m_pQueryNode->UseLocalScope() ? BST_CHECKED:BST_UNCHECKED);
    Button_SetCheck(GetDlgItem(IDC_QUERYSCOPE), m_pQueryNode->UseLocalScope() ? BST_UNCHECKED:BST_CHECKED);

    tstring strScope = m_pQueryNode->Scope();

    tstring strDisplay;
    GetScopeDisplayString(strScope, strDisplay);
    SetDlgItemText( IDC_SCOPE, strDisplay.c_str() );
}


//////////////////////////////////////////////////////////////////////////////////////////
// CQueryIconPage

LRESULT CQueryIconPage::OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Load up our image list, and fill in the listbox
    HIMAGELIST hImageList = ::ImageList_LoadBitmap( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_QUERY32), 32, 0, RGB(255, 0, 255) );
    
    // Load the icon list
    ListView_SetImageList( GetDlgItem(IDC_ICONLIST), hImageList, LVSIL_NORMAL );

    // Get the dimensions for the number of icons
    HBITMAP     hBitmap    = ::LoadBitmap( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_QUERY32) );    
    BITMAP      bm;        
    int         nIcons  = 0;    
    
    GetObject (hBitmap, sizeof(BITMAP), (LPSTR)&bm);    
    nIcons = (bm.bmHeight == 0) ? 0 : (int)bm.bmWidth / (int)bm.bmHeight;   

    ::DeleteObject(hBitmap);    

    // Set the icon spacing
    ListView_SetIconSpacing( GetDlgItem(IDC_ICONLIST), 40, 40 );

    // Add the icons to the list
    LV_ITEM lvi;

    ZeroMemory( &lvi, sizeof(LV_ITEM) );
    lvi.mask = LVIF_IMAGE;
    lvi.iItem = 0x7ffffff;     

    for( int i = 0; i < nIcons; i++ )
    {
        lvi.iImage = i;
        ListView_InsertItem( GetDlgItem(IDC_ICONLIST), &lvi );
    }    

    return TRUE;
}


BOOL CQueryIconPage::OnSetActive()
{
    UpdateButtons();

    // Select current choice    
    HWND hwndIconList = GetDlgItem(IDC_ICONLIST);
    if( m_pQueryNode && hwndIconList && ::IsWindow(hwndIconList) )
    {
        if (ListView_GetSelectedCount(hwndIconList) == 0 )
        {
            ListView_SetItemState( hwndIconList, m_pQueryNode->GetImage(), LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED );
        }
    }

    return TRUE;
}

BOOL CQueryIconPage::OnKillActive()
{
    return TRUE;
}


LRESULT CQueryIconPage::OnIconSelected( int idCtrl, LPNMHDR pnmh, BOOL& bHandled )
{
    // On select icon...  update the internal icon number
    int nItem = -1;
    HWND hwndIconList = GetDlgItem(IDC_ICONLIST);
    while( m_pQueryNode && hwndIconList && ::IsWindow(hwndIconList) && ((nItem = ListView_GetNextItem(hwndIconList, nItem, LVNI_SELECTED)) != -1) )
    {
        m_pQueryNode->SetImage(nItem);
    }

    UpdateButtons();

    return 0;
}



void CQueryIconPage::UpdateButtons()
{
    if( !m_pQueryNode ) return;

    DWORD dwButtons = PSWIZB_BACK;
    if( m_pQueryNode->GetImage() != -1 )
        dwButtons |= PSWIZB_NEXT;

    ::PropSheet_SetWizButtons(GetParent(), dwButtons);
}

//////////////////////////////////////////////////////////////////////////////////////////
// CObjectWizPage

LRESULT CObjectWizPage::OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // default to define query objects
    Button_SetCheck(GetDlgItem(IDC_DEFINE_QUERY_OBJS), BST_CHECKED);

    return TRUE;
}

BOOL CObjectWizPage::OnSetActive()
{
    if( !m_pvpClassInfo || m_pvpClassInfo->empty() ) return FALSE;

    DisplayNameMap* pNameMap = DisplayNames::GetClassMap();
    ASSERT( pNameMap );
    if( !pNameMap ) return FALSE;

    // Create list of new object classes
    std::vector<CClassInfo*>::iterator itpClass = m_pvpClassInfo->begin();
    tstring strClasses = pNameMap->GetAttributeDisplayName((*itpClass)->Name());

    for( itpClass++; itpClass != m_pvpClassInfo->end(); ++itpClass )
    {
        strClasses += L", ";
        strClasses += pNameMap->GetAttributeDisplayName((*itpClass)->Name());
    }

    SetDlgItemText( IDC_OBJCLASS, strClasses.c_str() );

    ::PostMessage(GetParent(), PSM_SETWIZBUTTONS, (WPARAM)0, (LPARAM)PSWIZB_BACK|PSWIZB_NEXT);

    return TRUE;
}


LRESULT CObjectWizPage::OnSkipChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    m_bSkipObjects = Button_GetCheck(GetDlgItem(IDC_SKIP_QUERY_OBJS)) == BST_CHECKED;
    return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////
// CMenuWizPage

LRESULT CMenuWizPage::OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

    HWND hwndList = GetDlgItem(IDC_MENULIST);
    ASSERT(hwndList != NULL);
    if( !hwndList || !::IsWindow(hwndList) ) return 0;

    m_MenuLV.Attach(hwndList);

    RECT rc;
    BOOL bStat = m_MenuLV.GetClientRect(&rc);
    ASSERT(bStat);
    if( !bStat ) return 0;

    int iWidth = (rc.right - rc.left) - GetSystemMetrics(SM_CXVSCROLL);

    CString strName;

    strName.LoadString(IDS_NAME);
    int iCol = m_MenuLV.InsertColumn(0, strName, LVCFMT_LEFT, iWidth/4, 0);
    ASSERT(iCol == 0);

    strName.LoadString(IDS_TYPE);
    iCol = m_MenuLV.InsertColumn(1, strName, LVCFMT_LEFT, iWidth/4, 1);
    ASSERT(iCol == 1);

    strName.LoadString(IDS_DETAILS);
    iCol = m_MenuLV.InsertColumn(2, strName, LVCFMT_LEFT, iWidth/2, 2);
    ASSERT(iCol == 2);

    m_MenuLV.SetExtendedListViewStyle(LVS_EX_FULLROWSELECT);

    return 0;
}

BOOL CMenuWizPage::OnSetActive()
{
    HWND hwndLV = GetDlgItem(IDC_MENULIST);
    if( !hwndLV || !::IsWindow(hwndLV) ) return FALSE;    
    if( !m_pClassInfo ) return FALSE;

    ListView_DeleteAllItems(hwndLV);

    // Display selection text with current class name
    DisplayNameMap* dnMap = DisplayNames::GetClassMap();
    if( !dnMap ) return FALSE;
    
    LPCWSTR pszTemp = m_pClassInfo->Name();
    if( !pszTemp ) return FALSE;

    LPCWSTR pszClass = dnMap->GetAttributeDisplayName( pszTemp );
    if( !pszClass ) return FALSE;   

    CString strSelect;
    strSelect.Format(IDS_SELECT_MENUS, pszClass); 

    SetDlgItemText( IDC_SELECT_MENUS, strSelect );

    // Display list of current menu commands    
    menucmd_vector::iterator itMenu;
    for( itMenu = m_pClassInfo->Menus().begin(); itMenu != m_pClassInfo->Menus().end(); ++itMenu )
    {
        AddMenuItem(*itMenu);
    }

    EnableDlgItem( m_hWnd, IDC_REMOVEMENU, FALSE );
    ::PostMessage(GetParent(), PSM_SETWIZBUTTONS, (WPARAM)0, (LPARAM)PSWIZB_BACK|PSWIZB_NEXT);

    return TRUE;
}

LRESULT CMenuWizPage::OnAddMenu( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{    
    if( !m_pClassInfo ) return 0;

    CAddMenuDlg dlg(*m_pClassInfo);    

    if( dlg.DoModal() == IDOK )
    {
        CMenuCmd* pMenuNew = dlg.GetMenu();
        ASSERT(pMenuNew != NULL);

        if( pMenuNew )
        {
            // Use temp string because string class fails an assignement like: strX = strX.c_str()
            // (it relases the private buffer first and then assigns the string)
            tstring strName = pMenuNew->Name();
            pMenuNew->SetName(m_pStringTable, strName.c_str()); 

            // Add menu to list
            AddMenuItem(pMenuNew);

            // Add to menu vector (note that temp CMenuCmdPtr will delete pMenuNew
            // after the vector copies it)
            m_pClassInfo->Menus().push_back(CMenuCmdPtr(pMenuNew));
        }
    }

    return 0;
}


void CMenuWizPage::AddMenuItem(CMenuCmd* pMenuCmd)
{
    if( !pMenuCmd ) return;

    // Set first column to menu name
    LVITEM lvi;
    lvi.mask = LVIF_PARAM | LVIF_TEXT;
    lvi.iSubItem = 0;
    lvi.iItem = 0xfffffff;  // large number
    lvi.lParam = pMenuCmd->ID();
    lvi.pszText = const_cast<LPWSTR>(pMenuCmd->Name());

    int iPos = m_MenuLV.InsertItem(&lvi);
    ASSERT(iPos >= 0);

    // Type and details columns are menu type depedent
    CString strType;
    LPCWSTR pszDetail = NULL;

    switch( pMenuCmd->MenuType() )
    {
    case MENUTYPE_SHELL:
        strType.LoadString(IDS_SHELLCMD);
        pszDetail = static_cast<CShellMenuCmd*>(pMenuCmd)->ProgramName(); 
        break;

    case MENUTYPE_ACTDIR:
        strType.LoadString(IDS_DISPSPEC);

        DisplayNameMap* dnMap = DisplayNames::GetClassMap();
        if( !dnMap ) return;

        if( !m_pClassInfo ) return;
        
        LPCWSTR pszTemp = m_pClassInfo->Name();
        if( !pszTemp ) return;

        pszDetail = dnMap->GetAttributeDisplayName( pszTemp );
        break;
    }

    // Second column is Type
    lvi.mask = LVIF_TEXT;
    lvi.iItem = iPos;
    lvi.iSubItem = 1;
    lvi.pszText = (LPWSTR)(LPCWSTR)strType;
    BOOL bStat = m_MenuLV.SetItem(&lvi);
    ASSERT(bStat);

    // Third column is Details
    lvi.iSubItem = 2;
    lvi.pszText = (LPWSTR)pszDetail;
    bStat = m_MenuLV.SetItem(&lvi);
    ASSERT(bStat);
}


LRESULT CMenuWizPage::OnRemoveMenu( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    if( !m_pClassInfo ) return 0;

    menucmd_vector& vMenus = m_pClassInfo->Menus();

    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;

    int iIndex = -1;
    while( (iIndex = m_MenuLV.GetNextItem(iIndex, LVNI_SELECTED)) >= 0 )
    {
        lvi.iItem = iIndex;
        m_MenuLV.GetItem(&lvi);

        // Locate menu by its ID
        menucmd_vector::iterator itMenu = std::find(vMenus.begin(), vMenus.end(), lvi.lParam);
        ASSERT(itMenu != vMenus.end());
    
        if( itMenu == vMenus.end() )
        {
            return 0;
        }

        vMenus.erase(itMenu);

        m_MenuLV.DeleteItem(iIndex);
        iIndex--;
    }

    EnableDlgItem( m_hWnd, IDC_REMOVEMENU, FALSE );

    return 0;
}

LRESULT CMenuWizPage::OnMenuListChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    EnableDlgItem( m_hWnd, IDC_REMOVEMENU, (m_MenuLV.GetSelectedCount() > 0) );

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////////
// CPropertyWizPage

LRESULT CPropertyWizPage::OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HWND hwndList = GetDlgItem(IDC_COLUMNLIST);
    ASSERT( hwndList );

    if( hwndList )
    {
        m_ColumnLV.SubclassWindow(hwndList);
        m_ColumnLV.SetExtendedListViewStyle(LVS_EX_CHECKBOXES);

        ConfigSingleColumnListView(hwndList);
    }

    return 0;
}


void CPropertyWizPage::SetDialogText(LPCTSTR pszClass)
{
    // Insert class name in "Select one or more..." text
    CString strSelect;
    strSelect.Format(IDS_SELECT_PROPERTIES, pszClass); 

    SetDlgItemText( IDC_SELECT_COLUMNS, strSelect );
}

BOOL CPropertyWizPage::OnSetActive()
{
    if( !m_pClassInfo ) return FALSE;

    m_ColumnLV.DeleteAllItems();

    // Display selection text with current class name
    DisplayNameMap* dnMap = DisplayNames::GetClassMap();
    if( !dnMap ) return FALSE;
    
    LPCWSTR pszTemp = m_pClassInfo->Name();
    if( !pszTemp ) return FALSE;

    LPCWSTR pszClass = dnMap->GetAttributeDisplayName( pszTemp );
    if( !pszClass ) return FALSE;

    SetDialogText(pszClass);

    // Get attributes with friendly names for this class
    DisplayNameMap* pNameMap = DisplayNames::GetMap( pszTemp );
    ASSERT( pNameMap );
    if( !pNameMap ) return FALSE;

    string_vector vstrColumns;
    pNameMap->GetFriendlyNames(&vstrColumns);

    // Block change processing when setting checkbox states
    m_bLoading = TRUE;

    // Add friendly name to list
    LV_ITEM lvi;
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = 0;
    lvi.iSubItem = 0;

    string_vector::iterator itstrCol;
    for( itstrCol = vstrColumns.begin(); itstrCol != vstrColumns.end(); ++itstrCol )
    {
        lvi.pszText = const_cast<LPWSTR>(pNameMap->GetAttributeDisplayName(itstrCol->c_str()));
        lvi.lParam  = reinterpret_cast<LPARAM>(itstrCol->c_str());
        int iPos = m_ColumnLV.InsertItem(&lvi);
        ASSERT(iPos >= 0);

        // Enable column if selected in the class info
        if( std::find(m_pClassInfo->Columns().begin(), m_pClassInfo->Columns().end(), *itstrCol) != m_pClassInfo->Columns().end() )
            m_ColumnLV.SetCheckState(iPos, TRUE);
    }

    m_bLoading = FALSE;

    ::PostMessage( GetParent(), PSM_SETWIZBUTTONS, (WPARAM)0, (LPARAM)(PSWIZB_BACK | PSWIZB_NEXT) );

    return TRUE;
}


LRESULT CPropertyWizPage::OnColumnChanged(int idCtrl, LPNMHDR pNMHDR, BOOL& bHandled)
{
    if( !pNMHDR ) return 0;

    if( !m_bLoading )
    {
        LPNMLISTVIEW pnmv = reinterpret_cast<LPNMLISTVIEW>(pNMHDR);

        // if checked state has changed
        if( (pnmv->uChanged & LVIF_STATE) &&
            ((pnmv->uNewState ^ pnmv->uOldState) & LVIS_STATEIMAGEMASK) )
        {
            // if the changed item is currently selected
            if( m_ColumnLV.GetItemState(pnmv->iItem, LVIS_SELECTED) & LVIS_SELECTED )
            {
                // Change the state of all selcted items to match
                BOOL bNewState = ((pnmv->uNewState & LVIS_STATEIMAGEMASK) == CHECK_ON);

                m_bLoading = TRUE;
                int iItem = -1;
                while( (iItem = m_ColumnLV.GetNextItem(iItem, LVNI_SELECTED)) >= 0 )
                {
                    m_ColumnLV.SetCheckState(iItem, bNewState);                
                }
                m_bLoading = FALSE;    
            }
        }
    }

    return TRUE;
}


BOOL CPropertyWizPage::OnKillActive()
{
    string_vector vstrNewCols;

    int nItems = m_ColumnLV.GetItemCount();
    for( int iIndex = 0; iIndex < nItems; iIndex++ )
    {
        // Save list of enabled columns
        if( m_ColumnLV.GetCheckState(iIndex) )
        {
            LVITEM lvi;
            lvi.mask = LVIF_PARAM;
            lvi.iItem = iIndex;
            lvi.iSubItem = 0;
            BOOL bStat = m_ColumnLV.GetItem(&lvi);
            ASSERT(bStat);

            vstrNewCols.push_back(reinterpret_cast<LPCWSTR>(lvi.lParam));
        }
    }

    if( m_pClassInfo )
    {
        m_pClassInfo->Columns() = vstrNewCols;
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////////////////
// CColumnWizPage

void CColumnWizPage::SetDialogText(LPCTSTR pszClass)
{
    // Put class name in "Select one or more..." text
    CString strSelect;
    strSelect.Format(IDS_SELECT_COLUMNS, pszClass); 

    SetDlgItemText( IDC_SELECT_COLUMNS, strSelect );

    // Change list box label to "Available columns:"
    tstring strLabel = StrLoadString(IDS_AVAIL_COLUMNS);
    SetDlgItemText( IDC_LIST_LABEL, strLabel.c_str() );
}


//////////////////////////////////////////////////////////////////////////////////////////
// CAddQueryCompletionPage

LRESULT CAddQueryCompletionPage::OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if( !m_pWizard ) return 0;

    HFONT hfont = m_pWizard->GetWelcomeFont();
    if( hfont )
    {
        SendDlgItemMessage( IDC_COMPLETION, WM_SETFONT, (WPARAM)hfont, (LPARAM)0 );
    }

    // Remove edge from edit control
    HWND hwndSetting = GetDlgItem(IDC_SETTINGS);
    if( hwndSetting )
    {
        ::ModifyStyleEx(hwndSetting, WS_EX_CLIENTEDGE, 0, SWP_FRAMECHANGED);
    }

    return 0;
}

BOOL CAddQueryCompletionPage::OnSetActive()
{
    if( !m_pWizard ) return FALSE;
    if( !m_pQueryNode ) return FALSE;

    const static TCHAR newline[] =  TEXT("\r\n");

    ::PostMessage(GetParent(), PSM_SETWIZBUTTONS, (WPARAM)0, (LPARAM)PSWIZB_BACK|PSWIZB_FINISH);

    // Create query node nameed: <query name>
    CString strOut;
    CString strTmp;
    strTmp.LoadString(IDS_QUERYFINISH1);
    strOut += strTmp;
    strOut += static_cast<CAddQueryWizard*>(m_pWizard)->GetQueryName();
    strOut += newline;

    // Display objects of type: <object class>
    tstring strClasses;
    GetClassNameList(m_pQueryNode->Objects(), strClasses, L", ");

    strTmp.LoadString(IDS_QUERYFINISH2);
    strOut += strTmp;
    strOut += strClasses.c_str();
    strOut += newline;

    // From: <query scope>
    tstring strDisplay;
    tstring strScope = m_pQueryNode->Scope();
    GetScopeDisplayString(strScope, strDisplay);

    strTmp.LoadString(IDS_QUERYFINISH3);
    strOut += strTmp;
    strOut += strDisplay.c_str();
    strOut += newline;

    // Menu items ... available to other query nodes for: <object class>
    strTmp.LoadString(IDS_QUERYFINISH4);
    strOut += strTmp;
    strOut += strClasses.c_str();

    SetDlgItemText( IDC_SETTINGS, strOut );

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////////////////
// CWizardBase

HFONT CWizardBase::GetWelcomeFont()
{
    if( m_hFontWelcome == 0 )
    {
        // copied from wiz97.cpp (sample code)
        NONCLIENTMETRICS ncm = {0};
        ncm.cbSize = sizeof (ncm);
        if( SystemParametersInfo (SPI_GETNONCLIENTMETRICS, 0, &ncm, 0) )
        {
            LOGFONT lf = ncm.lfMessageFont;

            // get font name from resource 'Verdana Bold'
            WCHAR szFont[32];
            ::LoadString( (HINSTANCE)_Module.GetModuleInstance(), IDS_WIZARD97_FONT, szFont, 32 );
            lstrcpyn( lf.lfFaceName, szFont, 32);

            int FontSize = 12;
            lf.lfWeight = FW_BOLD;

            HDC hdc = GetDC(NULL);
            lf.lfHeight = 0 - (GetDeviceCaps(hdc, LOGPIXELSY) * 12)/72;
            ReleaseDC(NULL,hdc);

            m_hFontWelcome = CreateFontIndirect (&lf);
        }
    }

    return m_hFontWelcome;
}


void CWizardBase::SetWizardBitmaps(UINT watermarkID, UINT headerID)
{

    m_propsheet.m_psh.dwFlags |= PSH_WIZARD|PSH_WIZARD97|
                                 PSH_USEHBMWATERMARK|PSH_WATERMARK|PSH_USEHBMHEADER|PSH_HEADER;

    CBitmap bmWatermark;
    bmWatermark.LoadBitmap(watermarkID);
    m_propsheet.m_psh.hbmWatermark = bmWatermark.Detach();
    ASSERT(m_propsheet.m_psh.hbmWatermark != NULL);

    CBitmap bmHeader;
    bmHeader.LoadBitmap(headerID);
    m_propsheet.m_psh.hbmHeader = bmHeader.Detach();
    ASSERT(m_propsheet.m_psh.hbmHeader != NULL);
}


/////////////////////////////////////////////////////////////////////////////////////////
// CAddQueryWizard

HRESULT CAddQueryWizard::Run(IPropertySheetProvider* pProvider, HWND hwndParent)
{
    SetWizardBitmaps(IDB_ADDQUERY, IDB_ADDQUERY_HDR);

    if( !AddPage(m_WelcomePage.Create())    ) return E_FAIL;
    if( !AddPage(m_QueryPage.Create())      ) return E_FAIL;   
    if( !AddPage(m_ObjectPage.Create())     ) return E_FAIL;
    if( !AddPage(m_MenuPage.Create())       ) return E_FAIL;
    if( !AddPage(m_PropertyPage.Create())     ) return E_FAIL;
    if( !AddPage(m_IconPage.Create())       ) return E_FAIL;
    if( !AddPage(m_CompletionPage.Create()) ) return E_FAIL;

    int iRet = DoModal(hwndParent);

    return(iRet == IDOK) ? S_OK : S_FALSE;;
}

int CAddQueryWizard::OnNext(UINT uPageID)
{
    int iRet = 0;

    switch( uPageID )
    {
    case IDD_QUERY_WIZ_QUERY:
        // Dtermine classes returned by query
        SelectClasses();

        // if no classes, skip to finish page
        if( m_vpClassInfo.size() == 0 )
        {
            iRet = IDD_SELECTICON_PAGE;
        }
        else
        {
            // Pass new classes to object page
            m_ObjectPage.SetClassInfo(&m_vpClassInfo);
        }
        break;

    case IDD_QUERY_WIZ_OBJECT:
        // if user wants to defer menu and prop selection, skip to finish
        if( m_ObjectPage.SkipObjects() )
        {
            iRet = IDD_SELECTICON_PAGE;
        }
        else
        {
            // go to menu page for first class
            m_iClassIndex = 0;
            m_MenuPage.SetClassInfo(m_vpClassInfo[0]); 
        }
        break;

    case IDD_COMMON_WIZ_MENU:
        m_PropertyPage.SetClassInfo(m_vpClassInfo[m_iClassIndex]);
        break;

    case IDD_COMMON_WIZ_PROPERTIES:
        // if not on last class, go to menu page for next class
        if( ++m_iClassIndex < m_vpClassInfo.size() )
        {
            m_MenuPage.SetClassInfo(m_vpClassInfo[m_iClassIndex]);
            iRet = IDD_COMMON_WIZ_MENU; 
        }
    }

    return iRet;
}


int CAddQueryWizard::OnBack(UINT uPageID)
{
    int iRet = 0;

    switch( uPageID )
    {
    case IDD_COMMON_WIZ_MENU:
        // if not on first class, go to property page for previous class
        if( m_iClassIndex > 0 )
        {
            m_iClassIndex--;
            m_PropertyPage.SetClassInfo(m_vpClassInfo[m_iClassIndex]);
            iRet = IDD_COMMON_WIZ_PROPERTIES;
        }
        break;

    case IDD_COMMON_WIZ_PROPERTIES:
        m_MenuPage.SetClassInfo(m_vpClassInfo[m_iClassIndex]);
        break;

    case IDD_SELECTICON_PAGE:
        // if there are no classes, go back to query page
        if( m_vpClassInfo.size() == 0 )
        {
            iRet = IDD_QUERY_WIZ_QUERY;
        }
        // if classes skipped, go back to objects page
        else if( m_ObjectPage.SkipObjects() )
        {
            iRet = IDD_QUERY_WIZ_OBJECT;
        }
        else
        {
            // go to prop page for the last class
            m_iClassIndex = m_vpClassInfo.size() - 1;
            m_PropertyPage.SetClassInfo(m_vpClassInfo[m_iClassIndex]);
        }
        break;
    }

    return iRet;
}

BOOL CAddQueryWizard::OnCancel() 
{
    int iRet = DisplayMessageBox(GetActivePage(), IDS_ADDQUERY_WIZ, IDS_QUERYWIZ_CANCEL, MB_YESNO);
    return(iRet == IDYES);
}

void CAddQueryWizard::SelectClasses()
{
    if( !m_pQueryNode ) return;

    // First delete any ClassInfo's the wizard has created that are no longer valid.
    // This can happen if the user backs up to the query page and redefines the query
    std::vector<CClassInfo*>::iterator itpClass = m_vpClassInfo.begin();
    while( itpClass != m_vpClassInfo.end() )
    {
        QueryObjVector::iterator itObj;
        for( itObj = m_pQueryNode->Objects().begin(); itObj != m_pQueryNode->Objects().end(); ++itObj )
        {
            LPCWSTR pszBuf1 = itObj->Name();
            LPCWSTR pszBuf2 = (*itpClass)->Name();

            if( pszBuf1 && pszBuf2 && (wcscmp(pszBuf1, pszBuf2) == 0) )
            {
                break;
            }
        }

        // if class not referenced by query
        if( itObj == m_pQueryNode->Objects().end() )
        {
            // delete the class and remove from vector (vector::erase advances to next item)
            delete *itpClass;
            itpClass = m_vpClassInfo.erase(itpClass);
        }
        else
            ++itpClass;
    }

    // Now create new ClassInfo for any classes referenced by the query that have not been created
    // by the wizard and are not already defined at the root node
    QueryObjVector::iterator itObj;
    for( itObj = m_pQueryNode->Objects().begin(); itObj != m_pQueryNode->Objects().end(); ++itObj )
    {        
        for( itpClass = m_vpClassInfo.begin(); itpClass != m_vpClassInfo.end(); ++itpClass )
        {
            LPCWSTR pszBuf1 = itObj->Name();
            LPCWSTR pszBuf2 = (*itpClass)->Name();

            if( pszBuf1 && pszBuf2 && (wcscmp(pszBuf1, pszBuf2) == 0) )
            {
                break;
            }
        }

        if( itpClass == m_vpClassInfo.end() && m_pRootNode->FindClass(itObj->Name()) == NULL )
        {
            CClassInfo* pClassNew = new CClassInfo(itObj->Name());
            
            ASSERT(pClassNew != NULL);            
            if( pClassNew )
            {
                m_vpClassInfo.push_back(pClassNew);
            }
        }
    }
}


/////////////////////////////////////////////////////////////////////////////////////////
// CAddObjectWizard

HRESULT CAddObjectWizard::Run(IPropertySheetProvider* pProvider, HWND hwndParent)
{
    SetWizardBitmaps(IDB_ADDOBJECT,IDB_ADDOBJECT_HDR);

    if( !AddPage(m_WelcomePage.Create())    ) return E_FAIL;
    if( !AddPage(m_ObjSelectPage.Create())  ) return E_FAIL;
    if( !AddPage(m_MenuPage.Create())       ) return E_FAIL;
    if( !AddPage(m_PropertyPage.Create())   ) return E_FAIL;
    if( !AddPage(m_CompletionPage.Create()) ) return E_FAIL;

    int iRet = DoModal(hwndParent);

    if( iRet != IDOK && m_pClassInfo != NULL )
    {
        delete m_pClassInfo;
        m_pClassInfo = NULL;
    }

    return(iRet == IDOK) ? S_OK : S_FALSE;
}


int CAddObjectWizard::OnNext(UINT uPageID)
{
    switch( uPageID )
    {
    case IDD_OBJECT_WIZ_SELECT:
        {
            LPCWSTR pszClass = m_ObjSelectPage.GetSelectedClass();
            ASSERT( pszClass );
            if( !pszClass ) break;
            
            if( m_pClassInfo == NULL )
            {
                // if first selection, create a class info
                m_pClassInfo = new CClassInfo(pszClass);
            }            
            else if( wcscmp(m_pClassInfo->Name(), pszClass) != 0 )
            {
                // if class changed, replace the class info
                delete m_pClassInfo;
                m_pClassInfo = new CClassInfo(pszClass);
            }

            ASSERT( m_pClassInfo );
            if( m_pClassInfo )
            {
                // Pass class info to menu page
                m_MenuPage.SetClassInfo(m_pClassInfo);
            }
            break;
        }

    case IDD_COMMON_WIZ_MENU:
        {
            ASSERT( m_pClassInfo );
            if( m_pClassInfo )
            {        
                m_PropertyPage.SetClassInfo(m_pClassInfo);
            }
            
            break;
        }

    case IDD_COMMON_WIZ_PROPERTIES:
        {
            ASSERT( m_pClassInfo );
            if( m_pClassInfo )
            {
                m_CompletionPage.SetClassInfo(m_pClassInfo);
            }

            break;
        }
    }

    return 0;
}

BOOL CAddObjectWizard::OnCancel() 
{
    int iRet = DisplayMessageBox(GetActivePage(), IDS_ADDOBJECT_WIZ, IDS_OBJWIZ_CANCEL, MB_YESNO);
    return(iRet == IDYES);
}

//////////////////////////////////////////////////////////////////////////////////////////
// CObjSelectWizPage

LRESULT CObjSelectWizPage::OnInitDialog(UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if( !m_pvstrCurClasses ) return 0;

    // Get list of classes with friendly names
    DisplayNameMap* pNameMap = DisplayNames::GetClassMap();
    if( !pNameMap ) return 0;

    string_vector vstrAllObjects;
    pNameMap->GetFriendlyNames(&vstrAllObjects);

