ho, NULL,  L"Add a link that already exists" },
    { AzoAddProp,    &TestLinkHandleA,   (LPWSTR)&Sid3,   NULL,             ERROR_ALREADY_EXISTS, NULL, NULL,          1 },
    { AzoGetProp,    &TestLinkHandleA,   NULL,            NULL,             NO_ERROR, NULL, (LPWSTR)&Sid3Array,            1 },
    { AzoRemProp,    &TestLinkHandleA,   (LPWSTR)&Sid3,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGetProp,    &TestLinkHandleA,   NULL,            NULL,             NO_ERROR, NULL, (LPWSTR)&EmptyStringArray, 1 },

    { AzoEcho, NULL,  L"Try more than 4 since reference buckets come in multiples of 4" },
    { AzoAddProp,    &TestLinkHandleA,   (LPWSTR)&Sid1,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoAddProp,    &TestLinkHandleA,   (LPWSTR)&Sid4,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoAddProp,    &TestLinkHandleA,   (LPWSTR)&Sid2,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoAddProp,    &TestLinkHandleA,   (LPWSTR)&Sid5,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoAddProp,    &TestLinkHandleA,   (LPWSTR)&Sid3,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoAddProp,    &TestLinkHandleA,   (LPWSTR)&Sid6,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGetProp,    &TestLinkHandleA,   NULL,            NULL,             NO_ERROR, NULL, (LPWSTR)&Sid123456Array,       1 },
    { AzoEndOfList }
};

//
// Specific tests for Task objects
//

//
// Task object tests that are agnostic about the parent object
//  Requires GenParentHandle1 to already be set
//
OPERATION OpGenTask[] = {
    { AzoEcho, NULL, L"Task object specific tests" },

    { AzoTaskCreate,  &GenParentHandle1,  L"Task 1",   &TaskHandle1,     NO_ERROR },
    { AzoGetProp,    &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"",         AZ_PROP_TASK_BIZRULE },

    { AzoEcho, NULL, L"Set the bizrule before the langauge" },
    { AzoSetProp,    &TaskHandle1,       L"While True\nWend", NULL,     ERROR_INVALID_PARAMETER, NULL, NULL, AZ_PROP_TASK_BIZRULE },
    { AzoGetProp,    &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"",         AZ_PROP_TASK_BIZRULE },

    { AzoEcho, NULL,  L"Try an invalid language" },
    { AzoGetProp,    &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"",         AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoSetProp,    &TaskHandle1,       L"LANG1",    NULL,             ERROR_INVALID_PARAMETER, NULL, NULL, AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoGetProp,    &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"",         AZ_PROP_TASK_BIZRULE_LANGUAGE },

    { AzoEcho, NULL,  L"Try the valid languages" },
    { AzoSetProp,    &TaskHandle1,       L"Jscript",  NULL,             NO_ERROR, NULL, L"",         AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoGetProp,    &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"Jscript",  AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoSetProp,    &TaskHandle1,       L"VBScript", NULL,             NO_ERROR, NULL, NULL,        AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoGetProp,    &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"VBScript", AZ_PROP_TASK_BIZRULE_LANGUAGE },

    { AzoEcho, NULL, L"Set a syntactically invalid bizrule" },
    { AzoSetProp,    &TaskHandle1,       L"Rule1,",   NULL,             OLESCRIPT_E_SYNTAX, NULL, NULL,        AZ_PROP_TASK_BIZRULE },
    { AzoGetProp,    &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"",         AZ_PROP_TASK_BIZRULE },

    { AzoEcho, NULL, L"Set a syntactically valid bizrule" },
    { AzoSetProp,    &TaskHandle1,       L"While True\nWend", NULL,     NO_ERROR, NULL, NULL, AZ_PROP_TASK_BIZRULE },
    { AzoGetProp,    &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"While True\nWend", AZ_PROP_TASK_BIZRULE },

    { AzoEcho, NULL,  L"Try bizrule path" },
    { AzoGetProp,    &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"",         AZ_PROP_TASK_BIZRULE_IMPORTED_PATH },
    { AzoSetProp,    &TaskHandle1,       L"c:\\temp", NULL,             NO_ERROR, NULL, NULL,        AZ_PROP_TASK_BIZRULE_IMPORTED_PATH },
    { AzoGetProp,    &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"c:\\temp", AZ_PROP_TASK_BIZRULE_IMPORTED_PATH },


    { AzoEcho, NULL,  L"Try Task application data" },
    { AzoGetProp,    &TaskHandle1,       NULL,                     NULL,             NO_ERROR, NULL, L"",                      AZ_PROP_APPLICATION_DATA },
    { AzoSetProp,    &TaskHandle1,       L"Task Application Data", NULL,             NO_ERROR, NULL, NULL,                     AZ_PROP_APPLICATION_DATA },
    { AzoGetProp,    &TaskHandle1,       NULL,                     NULL,             NO_ERROR, NULL, L"Task Application Data", AZ_PROP_APPLICATION_DATA },


    { AzoTestLink,    &GenParentHandle1,  (LPWSTR)"Task", &TaskHandle1,     AzoTask, OpTestLink, L"Task 1", AZ_PROP_TASK_TASKS },

    { AzoEcho, NULL,  L"Reference ourself" },
    { AzoGetProp,    &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&EmptyStringArray, AZ_PROP_TASK_TASKS },
    { AzoAddProp,    &TaskHandle1,       L"Task 1",   NULL,             ERROR_DS_LOOP_DETECT, NULL, NULL,          AZ_PROP_TASK_TASKS },

    { AzoEcho, NULL, L"Test loops" },
    { AzoTaskCreate,  &GenParentHandle1,  L"Task 2",   &TaskHandle2,     NO_ERROR },
    { AzoAddProp,    &TaskHandle1,       L"Task 2",   NULL,             NO_ERROR, NULL, NULL,               AZ_PROP_TASK_TASKS },
    { AzoAddProp,    &TaskHandle2,       L"Task 1",   NULL,             ERROR_DS_LOOP_DETECT, NULL, NULL,               AZ_PROP_TASK_TASKS },
    { AzoRemProp,    &TaskHandle1,       L"Task 2",   NULL,             NO_ERROR, NULL, NULL,               AZ_PROP_TASK_TASKS },

    { AzoClose,       &TaskHandle2,       NULL,        NULL,             NO_ERROR },
    { AzoClose,       &TaskHandle1,       NULL,        NULL,             NO_ERROR },

    { AzoEndOfList }
};

OPERATION OpAppTask[] = {
    { AzoEcho, NULL, L"Task object specific tests" },
    { AzoInit,        NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,   &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },

    // Do a bunch of stuff not specific to application children
    { AzoDupHandle,    &AppHandle1,        NULL,        &GenParentHandle1,NO_ERROR },
    { AzoGoSub,        NULL,               NULL,        NULL,             NO_ERROR, OpGenTask },

    { AzoEcho, NULL, L"Test linking task to operations." },
    { AzoTaskCreate,  &AppHandle1,         L"Task Y",   &TaskHandle1,     NO_ERROR },
    { AzoTestLink,    &AppHandle1, (LPWSTR)"Operation", &TaskHandle1,     AzoOp, OpTestLink, L"Task Y", AZ_PROP_TASK_OPERATIONS },

    { AzoClose,       &TaskHandle1,       NULL,        NULL,             NO_ERROR },
    { AzoClose,       &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,   &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoClose,       &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

// Tests for Tasks that are children of a scope
OPERATION OpScopeTask[] = {
    { AzoEcho, NULL, L"Task objects that are children of a scope" },
    { AzoInit,         NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,        L"Scope 1",  &ScopeHandle1,    NO_ERROR },

    // Do a bunch of stuff not specific to scope children
    { AzoDupHandle,    &ScopeHandle1,      NULL,        &GenParentHandle1,NO_ERROR },
    { AzoGoSub,        NULL,               NULL,        NULL,             NO_ERROR, OpGenTask },

    { AzoEcho, NULL, L"Test linking task to operations." },
    { AzoTaskCreate,  &ScopeHandle1,       L"Task X",   &TaskHandle1,     NO_ERROR },
    { AzoTestLink,    &AppHandle1, (LPWSTR)"Operation", &TaskHandle1,     AzoOp, OpTestLink, L"Task X", AZ_PROP_TASK_OPERATIONS },

    { AzoEcho, NULL, L"Test linking scope task to app tasks." },
    { AzoTestLink,    &AppHandle1, (LPWSTR)"Task", &TaskHandle1,     AzoTask, OpTestLink, L"Task X", AZ_PROP_TASK_TASKS },

    { AzoClose,        &TaskHandle1,       NULL,        NULL,             NO_ERROR },
    { AzoClose,        &ScopeHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,    &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

//
// Specific tests for Group objects
//

//
// Group object tests that are agnostic about the parent object
//  Requires GenParentHandle1 to already be set
//
OPERATION OpGenGroup[] = {
    { AzoEcho, NULL, L"Group object specific tests" },

    { AzoGroupCreate,  &GenParentHandle1,   L"Group A",   &GroupHandleA,    NO_ERROR },
    { AzoGroupCreate,  &GenParentHandle1,   L"Group B",   &GroupHandleB,    NO_ERROR },

    { AzoEcho, NULL, L"Create some groups to link the group to" },
    { AzoGroupCreate,  &GenParentHandle1,   L"Group 1",   &GroupHandle1,    NO_ERROR },
    { AzoClose,        &GroupHandle1,       NULL,         NULL,             NO_ERROR },
    { AzoGroupCreate,  &GenParentHandle1,   L"Group 2",   &GroupHandle1,    NO_ERROR },
    { AzoClose,        &GroupHandle1,       NULL,         NULL,             NO_ERROR },
    { AzoGroupCreate,  &GenParentHandle1,   L"Group 3",   &GroupHandle1,    NO_ERROR },
    { AzoClose,        &GroupHandle1,       NULL,         NULL,             NO_ERROR },

    { AzoEcho, NULL,  L"Set group type to an invalid value" },
    { AzoSetProp,    &GroupHandleA,       (LPWSTR)&Eight,NULL,            ERROR_INVALID_PARAMETER, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoSetProp,    &GroupHandleA,       (LPWSTR)&GtBasic,NULL,            NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },

    { AzoEcho, NULL,  L"Reference ourself" },
    { AzoGetProp,    &GroupHandleA,       NULL,         NULL,             NO_ERROR, NULL, (LPWSTR)&EmptyStringArray, AZ_PROP_GROUP_APP_MEMBERS },
    { AzoGetProp,    &GroupHandleA,       NULL,         NULL,             NO_ERROR, NULL, (LPWSTR)&EmptyStringArray, AZ_PROP_GROUP_MEMBERS },
    { AzoAddProp,    &GroupHandleA,       L"Group A",   NULL,             ERROR_DS_LOOP_DETECT, NULL, NULL,               AZ_PROP_GROUP_APP_MEMBERS },

    { AzoTestLink,     &GenParentHandle1,   (LPWSTR)"Group", &GroupHandleA, AzoGroup, OpTestLink, L"Group A", AZ_PROP_GROUP_APP_MEMBERS },

    { AzoTestLink,     &GenParentHandle1,   (LPWSTR)"Sid", &GroupHandleA, AzoGroup, OpTestSid, L"Group A", AZ_PROP_GROUP_MEMBERS },

    { AzoEcho, NULL,  L"Same as above, but for the non-members attribute" },
    { AzoGetProp,    &GroupHandleA,       NULL,         NULL,             NO_ERROR, NULL, (LPWSTR)&EmptyStringArray, AZ_PROP_GROUP_APP_NON_MEMBERS },
    { AzoGetProp,    &GroupHandleA,       NULL,         NULL,             NO_ERROR, NULL, (LPWSTR)&EmptyStringArray, AZ_PROP_GROUP_NON_MEMBERS },
    { AzoAddProp,    &GroupHandleA,       L"Group A",   NULL,             ERROR_DS_LOOP_DETECT, NULL, NULL,       AZ_PROP_GROUP_APP_NON_MEMBERS },

    { AzoTestLink,     &GenParentHandle1,   (LPWSTR)"Group", &GroupHandleA, AzoGroup, OpTestLink, L"Group A", AZ_PROP_GROUP_APP_NON_MEMBERS },

    { AzoTestLink,     &GenParentHandle1,   (LPWSTR)"Sid", &GroupHandleA, AzoGroup, OpTestSid, L"Group A", AZ_PROP_GROUP_NON_MEMBERS },

    { AzoEcho, NULL,  L"Set LdapQuery string on a basic group" },
    { AzoGetProp,    &GroupHandleA,       NULL,        NULL,             NO_ERROR, NULL, L"", AZ_PROP_GROUP_LDAP_QUERY },
    { AzoSetProp,    &GroupHandleA,       L"TheQuery", NULL,             ERROR_INVALID_PARAMETER, NULL, NULL,        AZ_PROP_GROUP_LDAP_QUERY },
    { AzoSetProp,    &GroupHandleA,       (LPWSTR)&GtLdap,NULL,          ERROR_INVALID_PARAMETER, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoSetProp,    &GroupHandleA,       L"TheQuery", NULL,             ERROR_INVALID_PARAMETER, NULL, NULL,        AZ_PROP_GROUP_LDAP_QUERY },
    { AzoGetProp,    &GroupHandleA,       NULL,        NULL,             NO_ERROR, NULL, L"", AZ_PROP_GROUP_LDAP_QUERY },
    { AzoSetProp,    &GroupHandleA,       (LPWSTR)&GtBasic,NULL,           NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoSetProp,    &GroupHandleA,       L"TheQuery", NULL,             ERROR_INVALID_PARAMETER, NULL, NULL,        AZ_PROP_GROUP_LDAP_QUERY },
    { AzoSetProp,    &GroupHandleA,       L"",         NULL,             NO_ERROR, NULL, NULL,        AZ_PROP_GROUP_LDAP_QUERY },

    { AzoEcho, NULL,  L"Set LdapQuery string on an ldap query group" },
    { AzoGetProp,    &GroupHandleB,       NULL,        NULL,             NO_ERROR, NULL, L"", AZ_PROP_GROUP_LDAP_QUERY },
    { AzoSetProp,    &GroupHandleB,       L"TheQuery", NULL,             ERROR_INVALID_PARAMETER, NULL, NULL,        AZ_PROP_GROUP_LDAP_QUERY },
    { AzoSetProp,    &GroupHandleB,       (LPWSTR)&GtLdap,NULL,          NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoSetProp,    &GroupHandleB,       L"TheQuery", NULL,             NO_ERROR, NULL, NULL,        AZ_PROP_GROUP_LDAP_QUERY },
    { AzoGetProp,    &GroupHandleB,       NULL,        NULL,             NO_ERROR, NULL, L"TheQuery", AZ_PROP_GROUP_LDAP_QUERY },
    { AzoSetProp,    &GroupHandleB,       (LPWSTR)&GtBasic,NULL,           ERROR_INVALID_PARAMETER, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoGetProp,    &GroupHandleB,       NULL,        NULL,             NO_ERROR, NULL, L"TheQuery", AZ_PROP_GROUP_LDAP_QUERY },
    { AzoSetProp,    &GroupHandleB,       L"",         NULL,             NO_ERROR, NULL, NULL,        AZ_PROP_GROUP_LDAP_QUERY },

    { AzoEcho, NULL, L"Test loops" },
    { AzoSetProp,    &GroupHandleB,       (LPWSTR)&GtBasic,NULL,            NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoAddProp,    &GroupHandleA,       L"Group B",   NULL,             NO_ERROR, NULL, NULL,               AZ_PROP_GROUP_APP_MEMBERS },
    { AzoAddProp,    &GroupHandleB,       L"Group A",   NULL,             ERROR_DS_LOOP_DETECT, NULL, NULL,               AZ_PROP_GROUP_APP_MEMBERS },
    { AzoAddProp,    &GroupHandleA,       L"Group B",   NULL,             NO_ERROR, NULL, NULL,               AZ_PROP_GROUP_APP_NON_MEMBERS },
    { AzoAddProp,    &GroupHandleB,       L"Group A",   NULL,             ERROR_DS_LOOP_DETECT, NULL, NULL,               AZ_PROP_GROUP_APP_NON_MEMBERS },
    { AzoRemProp,    &GroupHandleA,       L"Group B",   NULL,             NO_ERROR, NULL, NULL,               AZ_PROP_GROUP_APP_NON_MEMBERS },
    { AzoRemProp,    &GroupHandleA,       L"Group B",   NULL,             NO_ERROR, NULL, NULL,               AZ_PROP_GROUP_APP_MEMBERS },

    { AzoClose,        &GroupHandleB,       NULL,         NULL,             NO_ERROR },
    { AzoClose,        &GroupHandleA,       NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

// Tests for groups that are children of an admin manager
OPERATION OpAdmGroup[] = {
    { AzoEcho, NULL, L"Group objects that are children of an admin manager" },
    { AzoInit,         NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },

    // Do a bunch of stuff not specific to admin manager children
    { AzoDupHandle,    &AdminMgrHandle1,   NULL,        &GenParentHandle1,NO_ERROR },
    { AzoGoSub,        NULL,               NULL,        NULL,             NO_ERROR, OpGenGroup },

    { AzoAdmDelete,    &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

// Tests for groups that are children of an application
OPERATION OpAppGroup[] = {
    { AzoEcho, NULL, L"Group objects that are children of an application" },
    { AzoInit,         NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },

    // Do a bunch of stuff not specific to application children
    { AzoDupHandle,    &AppHandle1,        NULL,        &GenParentHandle1,NO_ERROR },
    { AzoGoSub,        NULL,               NULL,        NULL,             NO_ERROR, OpGenGroup },

    { AzoEcho, NULL, L"Test linking to groups that are children of the same admin manager as this group." },
    { AzoGroupOpen,   &AppHandle1,        L"Group A",      &GroupHandleA, NO_ERROR },
    { AzoTestLink,    &AdminMgrHandle1,   (LPWSTR)"Group", &GroupHandleA, AzoGroup, OpTestLink, L"Group A", AZ_PROP_GROUP_APP_MEMBERS },
    { AzoTestLink,    &AdminMgrHandle1,   (LPWSTR)"Group", &GroupHandleA, AzoGroup, OpTestLink, L"Group A", AZ_PROP_GROUP_APP_NON_MEMBERS },
    { AzoClose,       &GroupHandleA,      NULL,            NULL,          NO_ERROR },

    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,    &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

// Tests for groups that are children of a scope
OPERATION OpScopeGroup[] = {
    { AzoEcho, NULL, L"Group objects that are children of a scope" },
    { AzoInit,         NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,        L"Scope 1",  &ScopeHandle1,    NO_ERROR },

    // Do a bunch of stuff not specific to scope children
    { AzoDupHandle,    &ScopeHandle1,      NULL,        &GenParentHandle1,NO_ERROR },
    { AzoGoSub,        NULL,               NULL,        NULL,             NO_ERROR, OpGenGroup },

    { AzoEcho, NULL, L"Test linking to groups that are children of the same admin manager as this group." },
    { AzoGroupOpen,   &ScopeHandle1,      L"Group A",      &GroupHandleA, NO_ERROR },
    { AzoTestLink,    &AdminMgrHandle1,   (LPWSTR)"Group", &GroupHandleA, AzoGroup, OpTestLink, L"Group A", AZ_PROP_GROUP_APP_MEMBERS },
    { AzoTestLink,    &AdminMgrHandle1,   (LPWSTR)"Group", &GroupHandleA, AzoGroup, OpTestLink, L"Group A", AZ_PROP_GROUP_APP_NON_MEMBERS },
    { AzoClose,       &GroupHandleA,      NULL,            NULL,          NO_ERROR },

    { AzoEcho, NULL, L"Test linking to groups that are children of the same application as this group." },
    { AzoGroupOpen,   &ScopeHandle1,      L"Group A",      &GroupHandleA, NO_ERROR },
    { AzoTestLink,    &AppHandle1,        (LPWSTR)"Group", &GroupHandleA, AzoGroup, OpTestLink, L"Group A", AZ_PROP_GROUP_APP_MEMBERS },
    { AzoTestLink,    &AppHandle1,        (LPWSTR)"Group", &GroupHandleA, AzoGroup, OpTestLink, L"Group A", AZ_PROP_GROUP_APP_NON_MEMBERS },
    { AzoClose,       &GroupHandleA,      NULL,            NULL,          NO_ERROR },

    { AzoClose,        &ScopeHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,    &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

//
// Specific tests for Role objects
//


// Tests for Roles that are children of an application
OPERATION OpAppRole[] = {
    { AzoEcho, NULL, L"Role objects that are children of an application" },
    { AzoInit,         NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },

    { AzoRoleCreate,  &AppHandle1,   L"Role A",   &RoleHandleA,    NO_ERROR },

    // Test linking roles to groups
    { AzoEcho, NULL, L"Test linking to groups that are children of the same admin manager as the role object." },
    { AzoTestLink,    &AdminMgrHandle1,   (LPWSTR)"Group", &RoleHandleA,     AzoGroup, OpTestLink, L"Role A", AZ_PROP_ROLE_APP_MEMBERS },

    { AzoEcho, NULL, L"Test linking to groups that are children of the same application as the role object." },
    { AzoTestLink,    &AppHandle1,   (LPWSTR)"Group", &RoleHandleA,     AzoGroup, OpTestLink, L"Role A", AZ_PROP_ROLE_APP_MEMBERS },

    { AzoEcho, NULL, L"Test linking to SIDs." },
    { AzoTestLink,    &AdminMgrHandle1,   (LPWSTR)"Sid", &RoleHandleA,     AzoGroup, OpTestSid, L"Role A", AZ_PROP_ROLE_MEMBERS },

    // Test linking roles to operations
    { AzoTestLink,    &AppHandle1,   (LPWSTR)"Operation", &RoleHandleA,     AzoOp, OpTestLink, L"Role A", AZ_PROP_ROLE_OPERATIONS },

    { AzoClose,        &RoleHandleA,       NULL,        NULL,             NO_ERROR },

    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,    &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

// Tests for Roles that are children of an scope
OPERATION OpScopeRole[] = {
    { AzoEcho, NULL, L"Role objects that are children of a scope" },
    { AzoInit,         NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,        L"Scope 1",  &ScopeHandle1,    NO_ERROR },

    { AzoRoleCreate,  &ScopeHandle1,   L"Role A",   &RoleHandleA,    NO_ERROR },

    // Test linking roles to groups
    { AzoEcho, NULL, L"Test linking to groups that are children of the same scope object as the role object." },
    { AzoTestLink,    &ScopeHandle1,   (LPWSTR)"Group", &RoleHandleA,     AzoGroup, OpTestLink, L"Role A", AZ_PROP_ROLE_APP_MEMBERS },

    { AzoEcho, NULL, L"Test linking to groups that are children of the same application as the role object." },
    { AzoTestLink,    &AppHandle1,   (LPWSTR)"Group", &RoleHandleA,     AzoGroup, OpTestLink, L"Role A", AZ_PROP_ROLE_APP_MEMBERS },

    { AzoEcho, NULL, L"Test linking to SIDs." },
    { AzoTestLink,    &AdminMgrHandle1,   (LPWSTR)"Sid", &RoleHandleA,     AzoGroup, OpTestSid, L"Role A", AZ_PROP_ROLE_MEMBERS },

    { AzoEcho, NULL, L"Test linking to groups that are children of the same admin manager as the role object." },
    { AzoTestLink,    &AdminMgrHandle1,   (LPWSTR)"Group", &RoleHandleA,     AzoGroup, OpTestLink, L"Role A", AZ_PROP_ROLE_APP_MEMBERS },

    // Test linking roles to operations
    { AzoTestLink,    &AppHandle1,   (LPWSTR)"Operation", &RoleHandleA,     AzoOp, OpTestLink, L"Role A", AZ_PROP_ROLE_OPERATIONS },

    { AzoClose,        &RoleHandleA,       NULL,        NULL,             NO_ERROR },

    { AzoClose,        &ScopeHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,    &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};


//
// Ensure certain objects can't share names
//
OPERATION OpShare[] = {
    { AzoEcho, NULL, L"Certain objects can't share names" },
    { AzoInit,         NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp2",   &AppHandle2,      NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,        L"Scope 1",  &ScopeHandle1,    NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,        L"Scope 2",  &ScopeHandle2,    NO_ERROR },

    { AzoEcho, NULL, L"Create some tasks and ops as a starting point" },
    { AzoTaskCreate,   &AppHandle1,        L"Task 1",   &TaskHandle1,     NO_ERROR },
    { AzoClose,        &TaskHandle1,       NULL,        NULL,             NO_ERROR },
    { AzoOpCreate,     &AppHandle1,        L"Op 1",     &OpHandle1,       NO_ERROR },
    { AzoClose,        &OpHandle1,         NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Task and operations can't share names" },
    { AzoTaskCreate,   &AppHandle1,        L"Op 1",     &TaskHandle1,     ERROR_ALREADY_EXISTS },
    { AzoOpCreate,     &AppHandle1,        L"Task 1",   &OpHandle1,       ERROR_ALREADY_EXISTS },

    { AzoEcho, NULL, L"... Even via rename" },
    { AzoOpCreate,     &AppHandle1,        L"Op 2",     &OpHandle1,       NO_ERROR },
    { AzoSetProp,       &OpHandle1,         L"Task 1",   NULL,             ERROR_ALREADY_EXISTS, NULL, NULL, AZ_PROP_NAME },
    { AzoClose,        &OpHandle1,         NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Create a task as a starting point" },
    { AzoTaskCreate,   &AppHandle1,        L"Task App", &TaskHandle1,     NO_ERROR },
    { AzoClose,        &TaskHandle1,       NULL,        NULL,             NO_ERROR },
    { AzoTaskCreate,   &ScopeHandle1,      L"Task Scp", &TaskHandle2,     NO_ERROR },
    { AzoClose,        &TaskHandle2,       NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Ensure scope and app task names conflict" },
    { AzoTaskCreate,   &AppHandle1,        L"Task Scp", &TaskHandle1,     ERROR_ALREADY_EXISTS },
    { AzoTaskCreate,   &ScopeHandle1,      L"Task App", &TaskHandle1,     ERROR_ALREADY_EXISTS },

    { AzoEcho, NULL, L"Ensure task names in different scopes don't conflict" },
    { AzoTaskCreate,   &ScopeHandle2,      L"Task Scp", &TaskHandle1,     NO_ERROR },
    { AzoClose,        &TaskHandle1,       NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Scope Tasks and operations can't share names" },
    { AzoTaskCreate,   &ScopeHandle1,      L"Op 1",     &TaskHandle1,     ERROR_ALREADY_EXISTS },
    { AzoOpCreate,     &AppHandle1,        L"Task Scp", &OpHandle1,       ERROR_ALREADY_EXISTS },

    { AzoEcho, NULL, L"Create some groups as a starting point" },
    { AzoGroupCreate,  &AdminMgrHandle1,   L"Group Adm",&GroupHandle1,    NO_ERROR },
    { AzoClose,        &GroupHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoGroupCreate,  &AppHandle1,        L"Group App",&GroupHandle1,    NO_ERROR },
    { AzoClose,        &GroupHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoGroupCreate,  &AppHandle2,        L"Group App2",&GroupHandle2,   NO_ERROR },
    { AzoClose,        &GroupHandle2,      NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Create an app group that conflicts with an adm group, etc" },
    { AzoGroupCreate,  &AppHandle1,        L"Group Adm",&GroupHandleA,    ERROR_ALREADY_EXISTS },
    { AzoGroupCreate,  &AdminMgrHandle1,   L"Group App",&GroupHandleA,    ERROR_ALREADY_EXISTS },

    { AzoEcho, NULL, L"Ensure two apps can have a group by the same name" },
    { AzoGroupCreate,  &AppHandle2,        L"Group App",&GroupHandleA,    NO_ERROR },
    { AzoClose,        &GroupHandleA,      NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Create a scope group" },
    { AzoGroupCreate,  &ScopeHandle1,      L"Group Scp",&GroupHandle1,    NO_ERROR },
    { AzoClose,        &GroupHandle1,      NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Create a scope group that conflicts with an adm group, etc" },
    { AzoGroupCreate,  &ScopeHandle1,      L"Group Adm",&GroupHandleA,    ERROR_ALREADY_EXISTS },
    { AzoGroupCreate,  &ScopeHandle1,      L"Group App",&GroupHandleA,    ERROR_ALREADY_EXISTS },

    { AzoEcho, NULL, L"Create an app/adm group that conflicts with a scope group" },
    { AzoGroupCreate,  &AppHandle1,        L"Group Scp",&GroupHandleA,    ERROR_ALREADY_EXISTS },
    { AzoGroupCreate,  &AdminMgrHandle1,   L"Group Scp",&GroupHandleA,    ERROR_ALREADY_EXISTS },

    { AzoEcho, NULL, L"Ensure two scopes can have a group by the same name" },
    { AzoGroupCreate,  &ScopeHandle2,      L"Group Scp",&GroupHandle2,    NO_ERROR },
    { AzoClose,        &GroupHandle2,      NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Create a role as a starting point" },
    { AzoRoleCreate,   &AppHandle1,        L"Role App", &RoleHandle1,     NO_ERROR },
    { AzoClose,        &RoleHandle1,       NULL,        NULL,             NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1,      L"Role Scp", &RoleHandle2,     NO_ERROR },
    { AzoClose,        &RoleHandle2,       NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Ensure scope and app role names conflict" },
    { AzoRoleCreate,   &AppHandle1,        L"Role Scp", &RoleHandle1,     ERROR_ALREADY_EXISTS },
    { AzoRoleCreate,   &ScopeHandle1,      L"Role App", &RoleHandle1,     ERROR_ALREADY_EXISTS },

    { AzoEcho, NULL, L"Ensure role names in different scopes don't conflict" },
    { AzoRoleCreate,   &ScopeHandle2,      L"Role Scp", &RoleHandle1,     NO_ERROR },
    { AzoClose,        &RoleHandle1,       NULL,        NULL,             NO_ERROR },

    { AzoClose,        &ScopeHandle2,      NULL,        NULL,             NO_ERROR },
    { AzoClose,        &ScopeHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AppHandle2,        NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,    &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};


//
// Ensure peristence works
//
// App object enum
OPERATION OpAppEnum[] = {
    { AzoGetProp,    &GenHandleE,   NULL,        NULL,    NO_ERROR, NULL, NULL, AZ_PROP_NAME },
    { AzoClose,      &GenHandleE,   NULL,        NULL,    NO_ERROR },
    { AzoEndOfList }
};
// Task object enum
OPERATION OpTaskEnum[] = {
    { AzoGetProp,    &GenHandleE,   NULL,        NULL,    NO_ERROR, NULL, NULL, AZ_PROP_NAME },
    { AzoClose,       &GenHandleE,   NULL,        NULL,    NO_ERROR },
    { AzoEndOfList }
};

// Operation object enum
OPERATION OpOpEnum[] = {
    { AzoGetProp,     &GenHandleE,   NULL,        NULL,    NO_ERROR, NULL, NULL, AZ_PROP_NAME },
    { AzoClose,      &GenHandleE,   NULL,        NULL,    NO_ERROR },
    { AzoEndOfList }
};

OPERATION OpPersist[] = {
    { AzoEcho, NULL, L"Ensure objects persist across a close" },
    { AzoInit,         NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoTaskCreate,   &AppHandle1,        L"Task 1",   &TaskHandle1,     NO_ERROR },
    { AzoOpCreate,     &AppHandle1,        L"Op 1",     &OpHandle1,       NO_ERROR },
    { AzoAddProp,      &TaskHandle1,       L"Op 1",     NULL,             NO_ERROR, NULL, NULL, AZ_PROP_TASK_OPERATIONS },
    { AzoGetProp,      &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Op1, AZ_PROP_TASK_OPERATIONS },
    { AzoClose,        &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoSetProp,      &TaskHandle1,       L"Jscript",  NULL,             NO_ERROR, NULL, L"",         AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoGetProp,      &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"Jscript",  AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoClose,        &TaskHandle1,       NULL,        NULL,             NO_ERROR },
    { AzoGroupCreate,  &AppHandle1,        L"Group 1",  &GroupHandle1,    NO_ERROR },
    { AzoAddProp,      &GroupHandle1,     (LPWSTR)&Sid2,NULL,             NO_ERROR, NULL, NULL, AZ_PROP_GROUP_MEMBERS },
    { AzoGetProp,      &GroupHandle1,      NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Sid2Array, AZ_PROP_GROUP_MEMBERS },
    { AzoClose,        &GroupHandle1,      NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Abort an object creation and an attribute change" },
    { AzoOpCreate|AzoAbort, &AppHandle1,   L"Op 2",     &OpHandle1,       NO_ERROR },
    { AzoClose,        &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoOpOpen,       &AppHandle1,        L"Op 2",     &OpHandle1,       ERROR_NOT_FOUND },
    { AzoOpOpen,       &AppHandle1,        L"Op 1",     &OpHandle1,       NO_ERROR },
    { AzoSetProp|AzoAbort, &OpHandle1,    (LPWSTR)&Eight, NULL,             NO_ERROR, NULL, NULL,           AZ_PROP_OPERATION_ID },
    { AzoGetProp,       &OpHandle1,         NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Zero, AZ_PROP_OPERATION_ID },
    { AzoClose,        &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"See if they're still there" },
    { AzoInit,         NULL,             NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, 0 },
    { AzoAppEnum,      &AdminMgrHandle1,   NULL,        &GenHandleE,      NO_ERROR, OpAppEnum },
    { AzoAppOpen,      &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoTaskEnum,     &AppHandle1,        NULL,        &GenHandleE,      NO_ERROR, OpTaskEnum },
    { AzoTaskOpen,     &AppHandle1,        L"Task 1",   &TaskHandle1,     NO_ERROR },
    { AzoGetProp,      &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Op1, AZ_PROP_TASK_OPERATIONS },
    { AzoGetProp,      &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"Jscript",  AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoOpEnum,       &AppHandle1,        NULL,        &GenHandleE,      NO_ERROR, OpOpEnum },
    { AzoOpOpen,       &AppHandle1,        L"Op 1",     &OpHandle1,       NO_ERROR },
    { AzoClose,        &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoOpOpen,       &AppHandle1,        L"Op 2",     &OpHandle1,       ERROR_NOT_FOUND },
    { AzoGroupOpen,   &AppHandle1,        L"Group 1",  &GroupHandle1,    NO_ERROR },
    { AzoGetProp,      &GroupHandle1,      NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Sid2Array, AZ_PROP_GROUP_MEMBERS },
    { AzoClose,        &GroupHandle1,      NULL,        NULL,             NO_ERROR },


    { AzoEcho, NULL, L"Complain if we try to create a child of non-sumbitted parent" },
    { AzoAppCreate|AzoNoSubmit,    &AdminMgrHandle1,   L"MyApp2",   &AppHandle2,      NO_ERROR },
    { AzoTaskCreate,   &AppHandle2,        L"Task 1",   &TaskHandle2,     ERROR_DS_NO_PARENT_OBJECT },

    { AzoEcho, NULL, L"Complain if we try to link to a non-sumbitted object" },
    { AzoOpCreate|AzoNoSubmit,&AppHandle1, L"Op 3",     &OpHandle1,       NO_ERROR },
    { AzoAddProp,     &TaskHandle1,       L"Op 3",     NULL,             ERROR_NOT_FOUND, NULL, NULL,      AZ_PROP_TASK_OPERATIONS },
    { AzoClose,        &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AppHandle2,        NULL,        NULL,             NO_ERROR },


    { AzoEcho, NULL, L"Ensure links are re-ordered upon rename" },
    { AzoOpCreate,     &AppHandle1,        L"Op 2",     &OpHandle1,       NO_ERROR },
    { AzoClose,        &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoAddProp,      &TaskHandle1,       L"Op 2",     NULL,             NO_ERROR, NULL, NULL, AZ_PROP_TASK_OPERATIONS },
    { AzoGetProp,      &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Op12, AZ_PROP_TASK_OPERATIONS },
    { AzoOpOpen,       &AppHandle1,        L"Op 1",     &OpHandle1,       NO_ERROR },
    { AzoSetProp,      &OpHandle1,         L"Op 4",     NULL,             NO_ERROR, NULL, NULL, AZ_PROP_NAME },
    { AzoClose,        &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoGetProp,      &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Op24, AZ_PROP_TASK_OPERATIONS },


    { AzoClose,        &TaskHandle1,       NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,    &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Ensure the an empty admin manager is persisted" },
    { AzoInit,         NULL,               NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoInit|AzoNoSubmit, NULL,           NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, 0 },

    { AzoEcho, NULL, L"Ensure a restored admin manager is writable" },
    { AzoGetProp,      &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&AzGlTrue,  AZ_PROP_WRITABLE },

    { AzoEcho, NULL, L"Ensure we can create an application in the empty restored admin manager" },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,    &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Ensure changes to admin manager are reflected in store" },
    { AzoInit,         NULL,               NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoSetProp,      &AdminMgrHandle1,   L"Desc",     NULL,             NO_ERROR, NULL, NULL,         AZ_PROP_DESCRIPTION },
    { AzoGetProp,      &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR, NULL, L"Desc",  AZ_PROP_DESCRIPTION },
    { AzoInit,         NULL,               NULL,        &AdminMgrHandle2, NO_ERROR, NULL, NULL, 0 },
    { AzoGetProp,      &AdminMgrHandle2,   NULL,        NULL,             NO_ERROR, NULL, L"Desc",  AZ_PROP_DESCRIPTION },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,    &AdminMgrHandle2,   NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle2,   NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Ensure renames are reflected in updated caches" },
    { AzoInit,         NULL,               NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoInit,         NULL,               NULL,        &AdminMgrHandle2, NO_ERROR, NULL, NULL, 0 },

    { AzoSetProp,      &AppHandle1,        L"NewApp",   NULL,             NO_ERROR, NULL, NULL, AZ_PROP_NAME },
    { AzoGetProp,      &AppHandle1,        NULL,        NULL,             NO_ERROR, NULL, L"NewApp",     AZ_PROP_NAME },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },


    { AzoUpdateCache,  &AdminMgrHandle2,   NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Ensure an updated admin manager is writable" },
    { AzoGetProp,      &AdminMgrHandle2,   NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&AzGlTrue,  AZ_PROP_WRITABLE },

    { AzoAppOpen,      &AdminMgrHandle2,   L"MyApp",    &AppHandle1,      ERROR_NOT_FOUND },
    { AzoAppOpen,      &AdminMgrHandle2,   L"NewApp",   &AppHandle1,      NO_ERROR },

    { AzoEcho, NULL, L"Ensure a updated app is writable" },
    { AzoGetProp,      &AppHandle1,        NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&AzGlTrue,  AZ_PROP_WRITABLE },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },

    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,    &AdminMgrHandle2,   NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle2,   NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Ensure that's true even on name conflict" },
    { AzoInit,         NULL,               NULL,        &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1,   L"App 1",    &AppHandle1,      NO_ERROR },
    { AzoAppCreate,    &AdminMgrHandle1,   L"App 2",    &AppHandle2,      NO_ERROR },
    { AzoClose,        &AppHandle2,        NULL,        NULL,             NO_ERROR },
    { AzoInit,         NULL,               NULL,        &AdminMgrHandle2, NO_ERROR, NULL, NULL, 0 },

    { AzoAppDelete,    &AdminMgrHandle1,   L"App 2",    &AppHandle1,      NO_ERROR },
    { AzoSetProp,      &AppHandle1,        L"App 2",    NULL,             NO_ERROR, NULL, NULL, AZ_PROP_NAME },
    { AzoGetProp,      &AppHandle1,        NULL,        NULL,             NO_ERROR, NULL, L"App 2",     AZ_PROP_NAME },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },


    { AzoUpdateCache,  &AdminMgrHandle2,   NULL,        NULL,             NO_ERROR },
    { AzoAppEnum,      &AdminMgrHandle2,   NULL,        &GenHandleE,      NO_ERROR, OpAppEnum },
    { AzoAppOpen,      &AdminMgrHandle2,   L"App 2",    &AppHandle1,      NO_ERROR },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },

    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,    &AdminMgrHandle2,   NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle2,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

//
// Perform access check tests
//

#define OP1_NUM 61
ULONG Op1Num = OP1_NUM;
#define OP2_NUM 62
ULONG Op2Num = OP2_NUM;
#define OP3_NUM 63
ULONG Op3Num = OP3_NUM;
#define OP4_NUM 64
ULONG Op4Num = OP4_NUM;

ULONG Ops1[] = { OP1_NUM };
ULONG Ops2[] = { OP2_NUM };
ULONG Ops3[] = { OP3_NUM };
ULONG Ops4[] = { OP4_NUM };
ULONG Ops1234[] = { OP1_NUM, OP2_NUM, OP3_NUM, OP4_NUM };
ULONG OpsInvalid[] = { 8 };

ULONG ResS[] = { NO_ERROR };
ULONG ResF[] = { ERROR_ACCESS_DENIED };
ULONG ResN[] = { 0xFFFFFFFF };
ULONG ResSSSS[] = { NO_ERROR, NO_ERROR, NO_ERROR, NO_ERROR };
ULONG ResFFFF[] = { ERROR_ACCESS_DENIED, ERROR_ACCESS_DENIED, ERROR_ACCESS_DENIED, ERROR_ACCESS_DENIED };
ULONG ResFSSS[] = { ERROR_ACCESS_DENIED, NO_ERROR, NO_ERROR, NO_ERROR };
ULONG ResSSFF[] = { NO_ERROR, NO_ERROR, ERROR_ACCESS_DENIED, ERROR_ACCESS_DENIED };

OPERATION OpAccess[] = {
    { AzoEcho, NULL, L"Create a complete policy data to perform access checks against" },
    { AzoInit,         NULL,               NULL,   &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },

    { AzoEcho, NULL, L"Create some operations" },
    { AzoOpCreate,     &AppHandle1,        L"Op1",      &OpHandle1,       NO_ERROR },
    { AzoSetProp,       &OpHandle1,      (LPWSTR)&Op1Num,NULL,             NO_ERROR, NULL, NULL,           AZ_PROP_OPERATION_ID },
    { AzoClose,        &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoOpCreate,     &AppHandle1,        L"Op2",      &OpHandle1,       NO_ERROR },
    { AzoSetProp,       &OpHandle1,      (LPWSTR)&Op2Num,NULL,             NO_ERROR, NULL, NULL,           AZ_PROP_OPERATION_ID },
    { AzoClose,        &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoOpCreate,     &AppHandle1,        L"Op3",      &OpHandle1,       NO_ERROR },
    { AzoSetProp,       &OpHandle1,      (LPWSTR)&Op3Num,NULL,             NO_ERROR, NULL, NULL,           AZ_PROP_OPERATION_ID },
    { AzoClose,        &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoOpCreate,     &AppHandle1,        L"Op4",      &OpHandle1,       NO_ERROR },
    { AzoSetProp,       &OpHandle1,      (LPWSTR)&Op4Num,NULL,             NO_ERROR, NULL, NULL,           AZ_PROP_OPERATION_ID },
    { AzoClose,        &OpHandle1,         NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Create some tasks" },
    { AzoTaskCreate,   &AppHandle1,        L"TaskOp1",  &TaskHandle1,     NO_ERROR },
    { AzoAddProp,     &TaskHandle1,       L"Op1",      NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_OPERATIONS },
    { AzoClose,        &TaskHandle1,       NULL,        NULL,             NO_ERROR },
    { AzoTaskCreate,   &AppHandle1,        L"TaskOp1Op2",&TaskHandle1,    NO_ERROR },
    { AzoAddProp,     &TaskHandle1,       L"Op1",      NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_OPERATIONS },
    { AzoAddProp,     &TaskHandle1,       L"Op2",      NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_OPERATIONS },
    { AzoClose,        &TaskHandle1,       NULL,        NULL,             NO_ERROR },
    { AzoTaskCreate,   &AppHandle1,        L"TaskOp1WithEmptyBizRule",  &TaskHandle1,     NO_ERROR },
    { AzoAddProp,     &TaskHandle1,       L"Op1",      NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_OPERATIONS },
    { AzoSetProp,     &TaskHandle1,       L"VBScript", NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoSetProp,     &TaskHandle1,       L" ",        NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_BIZRULE },
    { AzoClose,        &TaskHandle1,       NULL,        NULL,             NO_ERROR },
    { AzoTaskCreate,   &AppHandle1,        L"TaskOp1WithTrivialBizRule",  &TaskHandle1,     NO_ERROR },
    { AzoAddProp,     &TaskHandle1,       L"Op1",      NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_OPERATIONS },
    { AzoSetProp,     &TaskHandle1,       L"VBScript", NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoSetProp,     &TaskHandle1,       L"AccessCheck.BusinessRuleResult = TRUE",        NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_BIZRULE },
    { AzoClose,        &TaskHandle1,       NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Create some groups with NT membership" },
    { AzoGroupCreate,  &AppHandle1,         L"GroupWorld",     &GroupHandleA,    NO_ERROR },
    { AzoSetProp,    &GroupHandleA,       (LPWSTR)&GtBasic,    NULL,      NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoAddProp,    &GroupHandleA,       (LPWSTR)&SidWorld, NULL,      NO_ERROR, NULL, NULL,           AZ_PROP_GROUP_MEMBERS },
    { AzoClose,        &GroupHandleA,       NULL,       NULL,             NO_ERROR },
    { AzoGroupCreate,  &AppHandle1,         L"GroupNotAMember",&GroupHandleA,    NO_ERROR },
    { AzoSetProp,    &GroupHandleA,       (LPWSTR)&GtBasic,    NULL,      NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoAddProp,    &GroupHandleA,       (LPWSTR)&Sid1,     NULL,      NO_ERROR, NULL, NULL,           AZ_PROP_GROUP_MEMBERS },
    { AzoClose,        &GroupHandleA,       NULL,       NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Create a group using app group membership" },
    { AzoGroupCreate,  &AppHandle1,         L"GroupAppMember",&GroupHandleA,    NO_ERROR },
    { AzoSetProp,    &GroupHandleA,       (LPWSTR)&GtBasic,    NULL,      NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoAddProp,    &GroupHandleA,       L"GroupWorld",     NULL,      NO_ERROR, NULL, NULL,           AZ_PROP_GROUP_APP_MEMBERS },
    { AzoClose,        &GroupHandleA,       NULL,       NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Create a group using app group non membership - but still member" },
    { AzoGroupCreate,  &AppHandle1,         L"GroupAppNonMember",&GroupHandleA,    NO_ERROR },
    { AzoSetProp,    &GroupHandleA,       (LPWSTR)&GtBasic,    NULL,      NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoAddProp,    &GroupHandleA,       L"GroupAppMember",     NULL,      NO_ERROR, NULL, NULL,           AZ_PROP_GROUP_APP_MEMBERS },
    { AzoAddProp,    &GroupHandleA,       L"GroupNotAMember",     NULL,      NO_ERROR, NULL, NULL,           AZ_PROP_GROUP_APP_NON_MEMBERS },
    { AzoClose,        &GroupHandleA,       NULL,       NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Create a group using app group non membership - but not member" },
    { AzoGroupCreate,  &AppHandle1,         L"GroupAppReallyNonMember",&GroupHandleA,    NO_ERROR },
    { AzoSetProp,    &GroupHandleA,       (LPWSTR)&GtBasic,    NULL,      NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoAddProp,    &GroupHandleA,       L"GroupAppMember",     NULL,      NO_ERROR, NULL, NULL,           AZ_PROP_GROUP_APP_MEMBERS },
    { AzoAddProp,    &GroupHandleA,       L"GroupWorld",     NULL,      NO_ERROR, NULL, NULL,           AZ_PROP_GROUP_APP_NON_MEMBERS },
    { AzoClose,        &GroupHandleA,       NULL,       NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Create some LdapQuery groups" },
    { AzoGroupCreate,  &AppHandle1,         L"GroupLdapYes", &GroupHandleA,    NO_ERROR },
    { AzoSetProp,    &GroupHandleA,       (LPWSTR)&GtLdap,    NULL,      NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
#ifdef ENABLE_CLIFFV_ACCOUNT
    { AzoSetProp,    &GroupHandleA,       L"(userAccountControl=1049088)", NULL,      NO_ERROR, NULL, NULL,        AZ_PROP_GROUP_LDAP_QUERY },
#endif // ENABLE_CLIFFV_ACCOUNT
#ifdef ENABLE_ADMIN_ACCOUNT
    { AzoSetProp,    &GroupHandleA,       L"(userAccountControl=66048)", NULL,      NO_ERROR, NULL, NULL,        AZ_PROP_GROUP_LDAP_QUERY },
#endif // ENABLE_ADMIN_ACCOUNT
#ifdef ENABLE_CHAITU_ACCOUNT
    { AzoSetProp,    &GroupHandleA,       L"(userAccountControl=512)", NULL,      NO_ERROR, NULL, NULL,        AZ_PROP_GROUP_LDAP_QUERY },
#endif // ENABLE_CHAITU_ACCOUNT
    { AzoClose,        &GroupHandleA,       NULL,       NULL,             NO_ERROR },
    { AzoGroupCreate,  &AppHandle1,         L"GroupLdapNo", &GroupHandleA,    NO_ERROR },
    { AzoSetProp,    &GroupHandleA,       (LPWSTR)&GtLdap,    NULL,      NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoSetProp,    &GroupHandleA,       L"(userAccountControl=1049089)", NULL,      NO_ERROR, NULL, NULL,        AZ_PROP_GROUP_LDAP_QUERY },
    { AzoClose,        &GroupHandleA,       NULL,       NULL,             NO_ERROR },


    { AzoEcho, NULL, L"Create some scopes" },
    { AzoScopeCreate,  &AppHandle1,         L"MyScope", &ScopeHandle1,    NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,         L"MyScope2",&ScopeHandle1,    NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,         L"MyScope3",&ScopeHandle1,    NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,         L"MyScope4",&ScopeHandle1,    NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,         L"MyScope5",&ScopeHandle1,    NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,         L"MyScope6",&ScopeHandle1,    NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,         L"MyScope7",&ScopeHandle1,    NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,         L"MyScope8",&ScopeHandle1,    NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,         L"MyScope9",&ScopeHandle1,    NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,         L"MyScopeQ1",&ScopeHandle1,    NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,         L"MyScopeQ2",&ScopeHandle1,    NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,         L"MyScopeNoRoles",&ScopeHandle1,    NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,         L"MyScopeP1",&ScopeHandle1,    NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Build a context" },
    { AzoInitCFT,      &AppHandle1, (LPWSTR)&TokenHandle, &CCHandle,       NO_ERROR },


    { AzoEcho, NULL, L"Create a role granting op1 access to everyone SID" },
    { AzoScopeOpen,    &AppHandle1,   L"MyScope", &ScopeHandle1,    NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1, L"RoleEveryoneCanOp1", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  (LPWSTR)&SidWorld, NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"Op1",            NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_OPERATIONS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Check a SID on a role granting access" },
    { AzoAccess,      &CCHandle,      L"MyScope", (PAZ_HANDLE)&Ops1,     NO_ERROR, NULL, (LPWSTR) &ResS, 1 },

    { AzoEcho, NULL, L"Create a role granting op2 access to GroupWorld" },
    { AzoRoleCreate,   &ScopeHandle1, L"RoleGroupWorldCanOp2", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  L"GroupWorld",     NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_APP_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"Op2",            NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_OPERATIONS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Check a app group on a role granting access" },
    { AzoAccess,      &CCHandle,      L"MyScope", (PAZ_HANDLE)&Ops2,     NO_ERROR, NULL, (LPWSTR) &ResS, 1 },

    { AzoEcho, NULL, L"Ask again to check out app group caching" },
    { AzoAccess,      &CCHandle,      L"MyScope", (PAZ_HANDLE)&Ops2,     NO_ERROR, NULL, (LPWSTR) &ResS, 1 },

    { AzoEcho, NULL, L"Create a role not granting op3 access to GroupNotAMember" },
    { AzoRoleCreate,   &ScopeHandle1, L"RoleGroupCantOp3", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  L"GroupNotAMember",     NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_APP_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"Op3",            NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_OPERATIONS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Check a app group on a role not granting access" },
    { AzoAccess,      &CCHandle,      L"MyScope", (PAZ_HANDLE)&Ops3,     NO_ERROR, NULL, (LPWSTR) &ResF, 1 },

    { AzoEcho, NULL, L"Check a scope with no roles" },
    { AzoAccess,      &CCHandle,      L"MyScopeNoRoles", (PAZ_HANDLE)&Ops3,     NO_ERROR, NULL, (LPWSTR) &ResF, 1 },

    { AzoEcho, NULL, L"Check zero operations" },
    { AzoAccess,      &CCHandle,      L"MyScope", (PAZ_HANDLE)&Ops3,     ERROR_INVALID_PARAMETER, NULL, (LPWSTR) &ResF, 0 },

    { AzoEcho, NULL, L"Check an invalid scope name" },
    { AzoAccess,      &CCHandle,      L"MyScopeNameInvalid", (PAZ_HANDLE)&Ops3,     ERROR_SCOPE_NOT_FOUND, NULL, (LPWSTR) &ResF, 1 },

    { AzoEcho, NULL, L"Check an invalid operation number" },
    { AzoAccess,      &CCHandle,      L"MyScope", (PAZ_HANDLE)&OpsInvalid,     ERROR_INVALID_OPERATION, NULL, (LPWSTR) &ResN, 1 },

    { AzoEcho, NULL, L"Create two roles that both grant access" },
    { AzoScopeOpen,    &AppHandle1,   L"MyScope2", &ScopeHandle1,    NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1, L"Role2GroupWorldCanOp2", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  L"GroupWorld",     NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_APP_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"Op2",            NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_OPERATIONS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1, L"Role2aGroupWorldCanOp2", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  L"GroupWorld",     NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_APP_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"Op2",            NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_OPERATIONS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Check a app group with two roles granting access" },
    { AzoAccess,      &CCHandle,      L"MyScope2", (PAZ_HANDLE)&Ops2,     NO_ERROR, NULL, (LPWSTR) &ResS, 1 },

    { AzoEcho, NULL, L"Create two roles with one granting and one not granting" },
    { AzoRoleCreate,   &ScopeHandle1, L"Role2GroupCantOp3", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  L"GroupNotAMember",     NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_APP_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"Op3",            NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_OPERATIONS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1, L"Role2GroupWorldCanOp3", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  L"GroupWorld",     NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_APP_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"Op3",            NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_OPERATIONS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Check a app group with one role granting and the other not" },
    { AzoAccess,      &CCHandle,      L"MyScope2", (PAZ_HANDLE)&Ops3,     NO_ERROR, NULL, (LPWSTR) &ResS, 1 },

    { AzoEcho, NULL, L"... in the other order" },
    { AzoRoleCreate,   &ScopeHandle1, L"Role2GroupWorldCanOp4", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  L"GroupWorld",     NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_APP_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"Op4",            NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_OPERATIONS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1, L"Role2GroupCantOp4", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  L"GroupNotAMember",     NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_APP_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"Op4",            NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_OPERATIONS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },

    { AzoEcho, NULL, L"...In the other order" },
    { AzoAccess,      &CCHandle,      L"MyScope2", (PAZ_HANDLE)&Ops4,     NO_ERROR, NULL, (LPWSTR) &ResS, 1 },

    { AzoEcho, NULL, L"Try multiple operations" },
    { AzoAccess,      &CCHandle,      L"MyScope2", (PAZ_HANDLE)&Ops1234,     NO_ERROR, NULL, (LPWSTR) &ResFSSS, 4 },

    { AzoEcho, NULL, L"Create a role granting op1 access to AppGroup" },
    { AzoScopeOpen,    &AppHandle1,   L"MyScope3",       &ScopeHandle1,    NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1, L"RoleAppGroupCanOp1", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  L"GroupAppMember", NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_APP_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"Op1",            NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_OPERATIONS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },

    { AzoAccess,      &CCHandle,      L"MyScope3", (PAZ_HANDLE)&Ops1,      NO_ERROR, NULL, (LPWSTR) &ResS, 1 },

    { AzoEcho, NULL, L"Create a role granting op1 access to AppGroup with non member group" },
    { AzoScopeOpen,    &AppHandle1,   L"MyScope4",       &ScopeHandle1,    NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1, L"Role2AppGroupCanOp1", &RoleHandleA,NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  L"GroupAppNonMember", NULL,          NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_APP_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"Op1",            NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_OPERATIONS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },

    { AzoAccess,      &CCHandle,      L"MyScope4", (PAZ_HANDLE)&Ops1,      NO_ERROR, NULL, (LPWSTR) &ResS, 1 },

    { AzoEcho, NULL, L"Create a role granting op1 access to AppGroup with non member group - really not member" },
    { AzoScopeOpen,    &AppHandle1,   L"MyScope5",       &ScopeHandle1,    NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1, L"Role3AppGroupCanOp1", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  L"GroupAppReallyNonMember", NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_APP_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"Op1",            NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_OPERATIONS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },

    { AzoAccess,      &CCHandle,      L"MyScope5", (PAZ_HANDLE)&Ops1,     NO_ERROR, NULL, (LPWSTR) &ResF, 1 },

    { AzoEcho, NULL, L"Create a role granting op1 access to everyone SID via a task" },
    { AzoScopeOpen,    &AppHandle1,   L"MyScope6",       &ScopeHandle1,    NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1, L"RoleEveryoneCanOp1ViaTask1", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  (LPWSTR)&SidWorld, NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"TaskOp1",        NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_TASKS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Check granted access via a task" },
    { AzoAccess,      &CCHandle,      L"MyScope6", (PAZ_HANDLE)&Ops1,     NO_ERROR, NULL, (LPWSTR) &ResS, 1 },

    { AzoEcho, NULL, L"Create a role granting op1 and op2 access to everyone SID via a task" },
    { AzoScopeOpen,    &AppHandle1,   L"MyScope7",       &ScopeHandle1,    NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1, L"RoleEveryoneCanOp1Op2ViaTask1", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  (LPWSTR)&SidWorld, NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"TaskOp1Op2",        NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_TASKS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Check granted access to two ops via a task" },
    { AzoAccess,      &CCHandle,      L"MyScope7", (PAZ_HANDLE)&Ops1234,  NO_ERROR, NULL, (LPWSTR) &ResSSFF, 4 },

    { AzoEcho, NULL, L"Create a role granting op1 access to an LDAP query group" },
    { AzoScopeOpen,    &AppHandle1,   L"MyScopeQ1",       &ScopeHandle1,    NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1, L"RoleLdapCanOp1", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  L"GroupLdapYes",    NULL,            NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_APP_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"Op1",            NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_OPERATIONS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },

#ifdef ENABLE_DC_DOWN
    { AzoEcho, NULL, L"Check LDAP query groups with the DC down" },
    { AzoAccess,      &CCHandle,      L"MyScopeQ1", (PAZ_HANDLE)&Ops1,    ERROR_NO_SUCH_DOMAIN, NULL, (LPWSTR) &ResF, 1 },
    { AzoAccess,      &CCHandle,      L"MyScopeQ1", (PAZ_HANDLE)&Ops1,    ERROR_NO_SUCH_DOMAIN, NULL, (LPWSTR) &ResF, 1 },
    { AzoSleep, NULL, L"\n\nPlug the DC in now!!!", NULL, NO_ERROR, NULL, NULL, 30 },
#endif // ENABLE_DC_DOWN

    { AzoEcho, NULL, L"Check granted access via LDAP query group" },
#ifdef ENABLE_NON_DS_ACCOUNT
    { AzoAccess,      &CCHandle,      L"MyScopeQ1", (PAZ_HANDLE)&Ops1,    NO_ERROR, NULL, (LPWSTR) &ResF, 1 },
#else // ENABLE_NON_DS_ACCOUNT
    { AzoAccess,      &CCHandle,      L"MyScopeQ1", (PAZ_HANDLE)&Ops1,    NO_ERROR, NULL, (LPWSTR) &ResS, 1 },
#endif // ENABLE_NON_DS_ACCOUNT

    { AzoEcho, NULL, L"Try again to check the cache" },
#ifdef ENABLE_NON_DS_ACCOUNT
    { AzoAccess,      &CCHandle,      L"MyScopeQ1", (PAZ_HANDLE)&Ops1,    NO_ERROR, NULL, (LPWSTR) &ResF, 1 },
#else // ENABLE_NON_DS_ACCOUNT
    { AzoAccess,      &CCHandle,      L"MyScopeQ1", (PAZ_HANDLE)&Ops1,    NO_ERROR, NULL, (LPWSTR) &ResS, 1 },
#endif // ENABLE_NON_DS_ACCOUNT

    { AzoEcho, NULL, L"Create a role granting op1 access to an LDAP query group" },
    { AzoScopeOpen,    &AppHandle1,   L"MyScopeQ2",       &ScopeHandle1,    NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1,   L"RoleLdapCannotOp1", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  L"GroupLdapNo",    NULL,            NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_APP_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"Op1",            NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_OPERATIONS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Check failed access via LDAP query group" },
    { AzoAccess,      &CCHandle,      L"MyScopeQ2", (PAZ_HANDLE)&Ops1,    NO_ERROR, NULL, (LPWSTR) &ResF, 1 },

    // These tests have to be after the ENABLE_DC_DOWN tests
    { AzoEcho, NULL, L"Test if all the query property opcodes work" },
#ifdef ENABLE_CLIFFV_ACCOUNT
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             NO_ERROR, NULL, L"CN=Cliff Van Dyke,OU=Users,OU=ITG,DC=ntdev,DC=microsoft,DC=com",  AZ_PROP_CLIENT_CONTEXT_USER_DN },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             NO_ERROR, NULL, L"NTDEV\\cliffv",  AZ_PROP_CLIENT_CONTEXT_USER_SAM_COMPAT },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             NO_ERROR, NULL, L"Cliff Van Dyke",  AZ_PROP_CLIENT_CONTEXT_USER_DISPLAY },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             NO_ERROR, NULL, L"{ebff0213-bec7-4c11-bd47-06c80df7f356}",  AZ_PROP_CLIENT_CONTEXT_USER_GUID },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             NO_ERROR, NULL, L"ntdev.microsoft.com/ITG/Users/Cliff Van Dyke",  AZ_PROP_CLIENT_CONTEXT_USER_CANONICAL },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             NO_ERROR, NULL, L"cliffv@msft.com",  AZ_PROP_CLIENT_CONTEXT_USER_UPN },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             NO_ERROR, NULL, L"NTDEV.MICROSOFT.COM\\cliffv",  AZ_PROP_CLIENT_CONTEXT_USER_DNS_SAM_COMPAT },
#endif // ENABLE_CLIFFV_ACCOUNT
#ifdef ENABLE_CHAITU_ACCOUNT
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             NO_ERROR, NULL, L"CN=Chaitanya Upadhyay,OU=Users,OU=ITG,DC=ntdev,DC=microsoft,DC=com",  AZ_PROP_CLIENT_CONTEXT_USER_DN },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             NO_ERROR, NULL, L"NTDEV\\chaitu",  AZ_PROP_CLIENT_CONTEXT_USER_SAM_COMPAT },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             NO_ERROR, NULL, L"Chaitanya Upadhyay",  AZ_PROP_CLIENT_CONTEXT_USER_DISPLAY },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             NO_ERROR, NULL, L"{54bd4c43-861e-4b68-9e6c-0b8eec0b4847}",  AZ_PROP_CLIENT_CONTEXT_USER_GUID },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             NO_ERROR, NULL, L"ntdev.microsoft.com/ITG/Users/Chaitanya Upadhyay",  AZ_PROP_CLIENT_CONTEXT_USER_CANONICAL },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             NO_ERROR, NULL, L"chaitu@NTDEV.MICROSOFT.COM",  AZ_PROP_CLIENT_CONTEXT_USER_UPN },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             NO_ERROR, NULL, L"NTDEV.MICROSOFT.COM\\chaitu",  AZ_PROP_CLIENT_CONTEXT_USER_DNS_SAM_COMPAT },
#endif // ENABLE_CHAITU_ACCOUNT
#ifdef ENABLE_NT4_ACCOUNT
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             ERROR_NO_SUCH_DOMAIN, NULL, L"CN=,OU=Users,OU=ITG,DC=ntdev,DC=microsoft,DC=com",  AZ_PROP_CLIENT_CONTEXT_USER_DN },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             NO_ERROR, NULL, L"SECDOMNT4\\Administrator",  AZ_PROP_CLIENT_CONTEXT_USER_SAM_COMPAT },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             ERROR_NO_SUCH_DOMAIN, NULL, L"Cliff Van Dyke",  AZ_PROP_CLIENT_CONTEXT_USER_DISPLAY },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             ERROR_NO_SUCH_DOMAIN, NULL, L"{ebff0213-bec7-4c11-bd47-06c80df7f356}",  AZ_PROP_CLIENT_CONTEXT_USER_GUID },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             ERROR_NO_SUCH_DOMAIN, NULL, L"ntdev.microsoft.com/ITG/Users/Cliff Van Dyke",  AZ_PROP_CLIENT_CONTEXT_USER_CANONICAL },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             ERROR_NO_SUCH_DOMAIN, NULL, L"cliffv@msft.com",  AZ_PROP_CLIENT_CONTEXT_USER_UPN },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             ERROR_NONE_MAPPED, NULL, L"NTDEV.MICROSOFT.COM\\cliffv",  AZ_PROP_CLIENT_CONTEXT_USER_DNS_SAM_COMPAT },
#endif // ENABLE_NT4_ACCOUNT
#ifdef ENABLE_LOCAL_ACCOUNT
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             ERROR_NONE_MAPPED, NULL, L"CN=Cliff Van Dyke,OU=Users,OU=ITG,DC=ntdev,DC=microsoft,DC=com",  AZ_PROP_CLIENT_CONTEXT_USER_DN },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             NO_ERROR, NULL, L"CLIFFV5-PRO\\Administrator",  AZ_PROP_CLIENT_CONTEXT_USER_SAM_COMPAT },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             ERROR_NONE_MAPPED, NULL, L"Cliff Van Dyke",  AZ_PROP_CLIENT_CONTEXT_USER_DISPLAY },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             ERROR_NONE_MAPPED, NULL, L"{ebff0213-bec7-4c11-bd47-06c80df7f356}",  AZ_PROP_CLIENT_CONTEXT_USER_GUID },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             ERROR_NONE_MAPPED, NULL, L"ntdev.microsoft.com/ITG/Users/Cliff Van Dyke",  AZ_PROP_CLIENT_CONTEXT_USER_CANONICAL },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             ERROR_NONE_MAPPED, NULL, L"cliffv@msft.com",  AZ_PROP_CLIENT_CONTEXT_USER_UPN },
    { AzoGetProp,      &CCHandle,       NULL,        NULL,             ERROR_NONE_MAPPED, NULL, L"NTDEV.MICROSOFT.COM\\cliffv",  AZ_PROP_CLIENT_CONTEXT_USER_DNS_SAM_COMPAT },
#endif // ENABLE_LOCAL_ACCOUNT

    { AzoEcho, NULL, L"... except the generic ones" },
    { AzoGetProp,      &CCHandle,   NULL,        NULL,    ERROR_INVALID_PARAMETER, NULL, NULL, AZ_PROP_NAME },
    { AzoGetProp,      &CCHandle,   NULL,        NULL,    ERROR_INVALID_PARAMETER, NULL, NULL, AZ_PROP_DESCRIPTION },


    { AzoEcho, NULL, L"Create a role denying op1 access to everyone SID via a task with a bizrule" },
    { AzoScopeOpen,    &AppHandle1,   L"MyScope8",       &ScopeHandle1,    NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1, L"RoleEveryoneCannotOp1ViaTask1WithBizrule", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  (LPWSTR)&SidWorld, NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"TaskOp1WithEmptyBizRule",        NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_TASKS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },


#if 0
    { AzoEcho, NULL, L"Check denied access via a task with bizrule" },
    { AzoAccess,      &CCHandle,      L"MyScope8", (PAZ_HANDLE)&Ops1,     NO_ERROR, NULL, (LPWSTR) &ResF, 1 },
#endif // 0

    { AzoEcho, NULL, L"Create a role granting op1 access to everyone SID via a task with a bizrule" },
    { AzoScopeOpen,    &AppHandle1,   L"MyScope9",       &ScopeHandle1,    NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1, L"RoleEveryoneCanOp1ViaTask1WithBizrule", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  (LPWSTR)&SidWorld, NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"TaskOp1WithTrivialBizRule",        NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_TASKS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Check granted access via a task with bizrule" },
    { AzoAccess,      &CCHandle,      L"MyScope9", (PAZ_HANDLE)&Ops1,     NO_ERROR, NULL, (LPWSTR) &ResS, 1 },
    { AzoAccess,      &CCHandle,      L"MyScope9", (PAZ_HANDLE)&Ops1,     NO_ERROR, NULL, (LPWSTR) &ResS, 1 },

    { AzoEcho, NULL, L"Create a role granting op1 access to everyone SID via a task with a bizrule (using parameters)" },
    { AzoTaskCreate,   &AppHandle1,   L"TaskOp1WithParameterBizrule",  &TaskHandle1,     NO_ERROR },
    { AzoAddProp,     &TaskHandle1,  L"Op1",      NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_OPERATIONS },
    { AzoSetProp,     &TaskHandle1,  L"VBScript", NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoSetProp,     &TaskHandle1,  L"Dim Amount\nAmount = AccessCheck.GetParameter( \"Amount\" )\nif Amount < 500 then AccessCheckBusinessRuleResult = TRUE",        NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_BIZRULE },
    { AzoClose,        &TaskHandle1,  NULL,        NULL,             NO_ERROR },
    { AzoScopeOpen,    &AppHandle1,   L"MyScopeP1",       &ScopeHandle1,    NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1, L"RoleEveryoneCanOp1WithParameterBizrule", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  (LPWSTR)&SidWorld, NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"TaskOp1WithParameterBizrule",        NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_TASKS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },

    // This fails because I don't pass any parameters to AccessCheck and the Bizrule wants the AmountParameter
    { AzoEcho, NULL, L"Check granted access via a task with bizrule (using parameters)" },
    { AzoAccess,      &CCHandle,      L"MyScopeP1", (PAZ_HANDLE)&Ops1,     ERROR_INVALID_PARAMETER, NULL, (LPWSTR) &ResF, 1 },

    { AzoEcho, NULL, L"Create a role using a task with an infinite loop" },
    { AzoTaskCreate,   &AppHandle1,   L"TaskInfiniteLoop", &TaskHandle1,     NO_ERROR },
    { AzoAddProp,     &TaskHandle1,  L"Op1",      NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_OPERATIONS },
    { AzoSetProp,     &TaskHandle1,  L"VBScript", NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoSetProp,     &TaskHandle1,  L"While True\nWend",        NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_BIZRULE },
    { AzoClose,        &TaskHandle1,  NULL,        NULL,             NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,   L"MyScopeI1",       &ScopeHandle1,    NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1, L"RoleInfinite", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  (LPWSTR)&SidWorld, NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"TaskInfiniteLoop",        NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_TASKS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Set the timeout to 5 seconds" },
    { AzoGetProp,    &AdminMgrHandle1,     NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&FortyFiveThousand, AZ_PROP_ADMIN_SCRIPT_ENGINE_TIMEOUT },
    { AzoSetProp,    &AdminMgrHandle1,     (LPWSTR)&FiveThousand,NULL,    NO_ERROR, NULL, NULL,         AZ_PROP_ADMIN_SCRIPT_ENGINE_TIMEOUT },
    { AzoGetProp,    &AdminMgrHandle1,     NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&FiveThousand,  AZ_PROP_ADMIN_SCRIPT_ENGINE_TIMEOUT },

    { AzoEcho, NULL, L"Check granted access via a task with infinite loop" },
    { AzoAccess,      &CCHandle,      L"MyScopeI1", (PAZ_HANDLE)&Ops1,     ERROR_TIMEOUT, NULL, (LPWSTR) &ResF, 1 },

    { AzoEcho, NULL, L"Create a role under application granting op1 access to everyone SID" },
    { AzoRoleCreate,   &AppHandle1, L"AppRoleEveryoneCanOp1", &RoleHandleA, NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  (LPWSTR)&SidWorld, NULL,              NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"Op1",            NULL,              NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_OPERATIONS },
    { AzoClose,        &RoleHandleA,       NULL,         NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Check a SID on a role granting access with default scope" },
    { AzoAccess,      &CCHandle,      NULL, (PAZ_HANDLE)&Ops1,     NO_ERROR, NULL, (LPWSTR) &ResS, 1 },

    { AzoEcho, NULL, L"Check access granted with default scope anda role granting op1 access to everyone SID" },
    { AzoRoleCreate, &AppHandle1,  L"NoScopeRoleEveryoneCanOp1", &RoleHandleA,      NO_ERROR },
    { AzoAddProp,    &RoleHandleA, (LPWSTR)&SidWorld,            NULL,              NO_ERROR, NULL, NULL, AZ_PROP_ROLE_MEMBERS },
    { AzoAddProp,    &RoleHandleA, L"Op1",                       NULL,              NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_OPERATIONS },
    { AzoClose,      &RoleHandleA, NULL,                         NULL,              NO_ERROR },

    { AzoEcho,       NULL,         L"Check a SID on a role granting access" },
    { AzoAccess,     &CCHandle,    NULL, (PAZ_HANDLE)&Ops1, NO_ERROR, NULL, (LPWSTR) &ResS, 1 },

    { AzoClose,        &CCHandle,          NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,    &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

//
// Special case access checks
//  These are tests we don't always want to run, but we have an option to run them
//  under some circumstances
//

OPERATION OpAccessBegin[] = {
    { AzoEcho, NULL, L"Create a smaller database to do special case access checks" },
    { AzoInit,         NULL,               NULL,   &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoOpCreate,     &AppHandle1,        L"Op1",      &OpHandle1,       NO_ERROR },
    { AzoSetProp,       &OpHandle1,      (LPWSTR)&Op1Num,NULL,             NO_ERROR, NULL, NULL,           AZ_PROP_OPERATION_ID },
    { AzoClose,        &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoGroupCreate,  &AppHandle1,         L"Group1",  &GroupHandleA,    NO_ERROR },
    { AzoSetProp,    &GroupHandleA,  (LPWSTR)&GtBasic,NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoAddProp,    &GroupHandleA,       (LPWSTR)&SidWorld, NULL,      NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_MEMBERS },
    { AzoClose,        &GroupHandleA,       NULL,       NULL,             NO_ERROR },
    { AzoGroupCreate,  &AppHandle1,         L"Group2",  &GroupHandleA,    NO_ERROR },
    { AzoSetProp,    &GroupHandleA,       (LPWSTR)&GtBasic, NULL,       NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoAddProp,    &GroupHandleA,       L"Group1",  NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_APP_MEMBERS },
    { AzoClose,        &GroupHandleA,       NULL,       NULL,             NO_ERROR },
    { AzoGroupCreate,  &AppHandle1,         L"Group3",  &GroupHandleA,    NO_ERROR },
    { AzoSetProp,    &GroupHandleA,  (LPWSTR)&GtBasic,NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoClose,        &GroupHandleA,       NULL,       NULL,             NO_ERROR },
    { AzoGroupCreate,  &AppHandle1,         L"Group4",  &GroupHandleA,    NO_ERROR },
    { AzoSetProp,    &GroupHandleA,  (LPWSTR)&GtBasic,NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoClose,        &GroupHandleA,       NULL,       NULL,             NO_ERROR },
    { AzoGroupCreate,  &AppHandle1,         L"GroupLdapYes", &GroupHandleA,    NO_ERROR },
    { AzoSetProp,    &GroupHandleA,       (LPWSTR)&GtLdap,    NULL,      NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
#ifdef ENABLE_CLIFFV_ACCOUNT
    { AzoSetProp,    &GroupHandleA,       L"(userAccountControl=1049088)", NULL,      NO_ERROR, NULL, NULL,        AZ_PROP_GROUP_LDAP_QUERY },
#endif // ENABLE_CLIFFV_ACCOUNT
#ifdef ENABLE_CHAITU_ACCOUNT
    { AzoSetProp,    &GroupHandleA,       L"(userAccountControl=512)", NULL,      NO_ERROR, NULL, NULL,        AZ_PROP_GROUP_LDAP_QUERY },
#endif // ENABLE_CHAITU_ACCOUNT
    { AzoClose,        &GroupHandleA,       NULL,       NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Create a trivial bizrule" },
    { AzoTaskCreate,   &AppHandle1,        L"TaskOp1WithTrivialBizRule",  &TaskHandle1,     NO_ERROR },
    { AzoAddProp,     &TaskHandle1,       L"Op1",      NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_OPERATIONS },
    { AzoSetProp,     &TaskHandle1,       L"VBScript", NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoSetProp,     &TaskHandle1,       L"AccessCheck.BusinessRuleResult = TRUE",        NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_BIZRULE },
    { AzoClose,        &TaskHandle1,       NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Create a role granting op1 access to everyone SID via a task with a bizrule" },
    { AzoScopeCreate,  &AppHandle1,        L"MyScope",  &ScopeHandle1,    NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1,      L"RoleEveryoneCanOp1ViaTask1WithBizrule", &RoleHandleA, NO_ERROR },
    { AzoAddProp,      &RoleHandleA,       L"Group2",    NULL,             NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_APP_MEMBERS },
    { AzoAddProp,      &RoleHandleA,       L"TaskOp1WithTrivialBizRule", NULL, NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_TASKS },
    { AzoClose,        &RoleHandleA,       NULL,        NULL,             NO_ERROR },
    { AzoClose,        &ScopeHandle1,      NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L".. Another role but using LDAP this time" },
    { AzoScopeCreate,  &AppHandle1,        L"MyScopeLdap",  &ScopeHandle1,    NO_ERROR },
    { AzoRoleCreate,   &ScopeHandle1,      L"RoleEveryoneCanOp1ViaTask1WithBizrule", &RoleHandleA, NO_ERROR },
    { AzoAddProp,      &RoleHandleA,       L"GroupLdapYes", NULL,         NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_APP_MEMBERS },
    { AzoAddProp,      &RoleHandleA,       L"TaskOp1WithTrivialBizRule", NULL, NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_TASKS },
    { AzoClose,        &RoleHandleA,       NULL,        NULL,             NO_ERROR },
    { AzoClose,        &ScopeHandle1,      NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Build a context" },
    { AzoInitCFT,      &AppHandle1, (LPWSTR)&TokenHandle, &CCHandle,       NO_ERROR },
    { AzoEndOfList }
};

OPERATION OpAccess2[] = {
    { AzoAccess,      &CCHandle,      L"MyScope", (PAZ_HANDLE)&Ops1,     NO_ERROR, NULL, (LPWSTR) &ResS, 1 },
    { AzoEndOfList }
};

// Flush group membership cache, too
OPERATION OpAccess2Ldap[] = {
    { AzoEcho, NULL, L"main" },
    { AzoGroupOpen,    &AppHandle1,         L"Group2",   &GroupHandle1,    NO_ERROR },
    { AzoAddProp|AzoNoSubmit,    &GroupHandle1,       L"Group4",   NULL,             NO_ERROR, NULL, NULL,           AZ_PROP_GROUP_APP_MEMBERS },
    { AzoClose,        &GroupHandle1,       NULL,        NULL,             NO_ERROR },
    { AzoAccess,      &CCHandle,      L"MyScopeLdap", (PAZ_HANDLE)&Ops1,     NO_ERROR, NULL, (LPWSTR) &ResS, 1 },
    { AzoEndOfList }
};

//
// Test a group with lots of sids as members
//
OPERATION OpSidxBegin[] = {
    { AzoEcho, NULL, L"Create a group with many sid members" },
    { AzoGroupCreate,  &AppHandle1,   L"GroupManySid",  &GroupHandleA,      NO_ERROR },
    { AzoSetProp,    &GroupHandleA, (LPWSTR)&GtBasic, NULL,               NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },

    { AzoEndOfList }
};

OPERATION OpSidx[] = {
    { AzoAddProp|   AzoNoSubmit, &GroupHandleA, (LPWSTR)&SidX,    NULL,               NO_ERROR, NULL, NULL,           AZ_PROP_GROUP_MEMBERS },
    { AzoEndOfList }
};

OPERATION OpSidxEnd[] = {
    { AzoEcho, NULL, L"Do an access check on the group" },
    { AzoRoleCreate,   &AppHandle1,   L"RoleManySid",   &RoleHandleA,       NO_ERROR },
    { AzoAddProp,     &RoleHandleA,  L"GroupManySid",  NULL,               NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_APP_MEMBERS },
    { AzoAddProp,     &RoleHandleA,  L"Op1",           NULL,               NO_ERROR, NULL, NULL,   AZ_PROP_ROLE_OPERATIONS },
    { AzoClose,        &RoleHandleA,  NULL,             NULL,               NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,   L"ScopeManySid",  &ScopeHandle1,      NO_ERROR },
    { AzoClose,        &ScopeHandle1, NULL,             NULL,               NO_ERROR },

    { AzoAccess,       &CCHandle,     L"ScopeManySid",  (PAZ_HANDLE)&Ops1,  NO_ERROR, NULL, (LPWSTR) &ResF, 1 },
    { AzoClose,        &GroupHandleA, NULL,             NULL,               NO_ERROR },
    { AzoEndOfList }
};

OPERATION OpAccessEnd[] = {
    { AzoClose,        &CCHandle,          NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoAdmDelete,    &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};


OPERATION OpAccess1m[] = {
    { AzoEcho, NULL, L"Second thread" },
    { AzoInitCFT,      &AppHandle1, (LPWSTR)&TokenHandle, &CCHandle2,       NO_ERROR },
    { AzoEndOfList }
};

OPERATION OpAccess2m[] = {
    { AzoEcho, NULL, L"Second thread access" },
    { AzoAccess,      &CCHandle2,      L"MyScope", (PAZ_HANDLE)&Ops1,     NO_ERROR, NULL, (LPWSTR) &ResS, 1 },
    { AzoEndOfList }
};

// Flush group membership cache, too
OPERATION OpAccess2mLdap[] = {
    { AzoEcho, NULL, L"Second thread access" },
    { AzoGroupOpen,    &AppHandle1,         L"Group2",   &GroupHandleT,    NO_ERROR },
    { AzoAddProp|AzoNoSubmit,    &GroupHandleT,       L"Group3",   NULL,             NO_ERROR, NULL, NULL,           AZ_PROP_GROUP_APP_MEMBERS },
    { AzoClose,        &GroupHandleT,       NULL,        NULL,             NO_ERROR },
    { AzoAccess,      &CCHandle2,      L"MyScopeLdap", (PAZ_HANDLE)&Ops1,     NO_ERROR, NULL, (LPWSTR) &ResS, 1 },
    { AzoEndOfList }
};

OPERATION OpAccess3m[] = {
    { AzoEcho, NULL, L"Second thread close" },
    { AzoClose,        &CCHandle2,          NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};


OPERATION OpBizruleThread[] = {
    { AzoEcho, NULL, L"BizRule change thread" },
    { AzoTaskOpen,     &AppHandle1,        L"TaskOp1WithTrivialBizRule",  &TaskHandleT,     NO_ERROR },
    { AzoSetProp,     &TaskHandleT,       L"AccessCheck.BusinessRuleResult = TRUE",        NULL,             NO_ERROR, NULL, NULL,      AZ_PROP_TASK_BIZRULE },
    { AzoClose,        &TaskHandleT,       NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

OPERATION OpGroupThread[] = {
    { AzoEcho, NULL, L"Group change thread" },
    { AzoGroupOpen,    &AppHandle1,         L"Group2",   &GroupHandleT,    NO_ERROR },
    { AzoAddProp,    &GroupHandleT,       L"Group3",   NULL,             NO_ERROR, NULL, NULL,           AZ_PROP_GROUP_APP_MEMBERS },
    { AzoRemProp,    &GroupHandleT,       L"Group3",   NULL,             NO_ERROR, NULL, NULL,           AZ_PROP_GROUP_APP_MEMBERS },
    { AzoClose,        &GroupHandleT,       NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};


WCHAR ScopeBillions[64];

OPERATION OpBillions[] = {
    { AzoScopeCreate,  &AppHandle1,         ScopeBillions, &ScopeHandle1,    NO_ERROR },
    { AzoClose,        &ScopeHandle1,       NULL,       NULL,             NO_ERROR },
    { AzoEndOfList }
};




VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;


    printf("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            printf("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            printf("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    printf("------------------------------------\n");
}

LPSTR
FindSymbolicNameForStatus(
    DWORD Id
    )
{
    ULONG i;

    i = 0;
    if (Id == 0) {
        return "STATUS_SUCCESS";
    }

    if (Id & 0xC0000000) {
        while (ntstatusSymbolicNames[ i ].SymbolicName) {
            if (ntstatusSymbolicNames[ i ].MessageId == (NTSTATUS)Id) {
                return ntstatusSymbolicNames[ i ].SymbolicName;
            } else {
                i += 1;
            }
        }
    }

    while (winerrorSymbolicNames[ i ].SymbolicName) {
        if (winerrorSymbolicNames[ i ].MessageId == Id) {
            return winerrorSymbolicNames[ i ].SymbolicName;
        } else {
            i += 1;
        }
    }

#ifdef notdef
    while (neteventSymbolicNames[ i ].SymbolicName) {
        if (neteventSymbolicNames[ i ].MessageId == Id) {
            return neteventSymbolicNames[ i ].SymbolicName
        } else {
            i += 1;
        }
    }
#endif // notdef

    return NULL;
}

VOID
PrintStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{

    switch (NetStatus) {
    case NO_ERROR:
        printf( "NO_ERROR" );
        break;

    case NERR_DCNotFound:
        printf( "NERR_DCNotFound" );
        break;

    case ERROR_LOGON_FAILURE:
        printf( "ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( "ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( "ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( "ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( "ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( "ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( "ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( "ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( "ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( "ERROR_FILE_NOT_FOUND" );
        break;

    case NERR_NetNotStarted:
        printf( "NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( "NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( "NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( "NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( "NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( "NERR_BadTransactConfig" );
        break;

    case SEC_E_NO_SPM:
        printf( "SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( "SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( "SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( "SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( "SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( "SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( "SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( "SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( "SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( "SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( "SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( "SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( "SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( "SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( "SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( "SEC_E_NOT_SUPPORTED" ); break;
#define OLESCRIPT_E_SYNTAX _HRESULT_TYPEDEF_(0x80020101L)
    case OLESCRIPT_E_SYNTAX:
        printf( "OLESCRIPT_E_SYNTAX" ); break;


    default: {
        LPSTR Name = FindSymbolicNameForStatus( NetStatus );

        if ( Name == NULL ) {
            if ( NetStatus & 0x80000000 ) {
                HRESULT hr = NetStatus;
                if ((HRESULT_FACILITY(hr) == FACILITY_WIN32) && (FAILED(hr))) {
                    DWORD TempStatus;

                    TempStatus = HRESULT_CODE(hr);

                    if ( TempStatus == ERROR_SUCCESS ) {
                        TempStatus = ERROR_INTERNAL_ERROR;
                    }
                    printf( "(0x%lx is ", hr );
                    PrintStatus( TempStatus );
                    printf( ")" );

                } else {
                    printf( "(0x%lx)", NetStatus );
                }
            } else {
                printf( "(%lu)", NetStatus );
            }
        } else {
            printf( "%s", Name );
        }
        break;
    }
    }

}

VOID
PrintIndent(
    IN ULONG Indentation,
    IN BOOLEAN Error
    )
/*++

Routine Description:

    Print line prefix for log file

Arguments:

    Indentation - Number of spaces to indent text by.

    Error - True if this is a program failure.

Return Value:

    None.

--*/
{
    static LPSTR Blanks = "                                                           ";

    printf( "%*.*s", Indentation, Indentation, Blanks );

    if ( Error ) {
        printf("[ERR] ");
    }

}

//return type IDs
typedef enum _ENUM_AZ_DATATYPE
{
    ENUM_AZ_NONE = 0,
    ENUM_AZ_BSTR,
    ENUM_AZ_LONG,
    ENUM_AZ_BSTR_ARRAY,
    ENUM_AZ_SID_ARRAY,
    ENUM_AZ_BOOL,
} ENUM_AZ_DATATYPE, *PENUM_AZ_DATATYPE;


HRESULT
myAzGetPropertyDataType(
    IN   LONG  lPropId,
    OUT  ENUM_AZ_DATATYPE *pDataType)
/*+++
Description:
    a routine to map property ID to a data type
Arguments:
    lPropId - property ID
    pDataType - pointer to hold data type
Return:
---*/
{
    HRESULT  hr;
    ENUM_AZ_DATATYPE  dataType;

    // check property ID and assign data type
    switch (lPropId)
    {
        case AZ_PROP_NAME:
        case AZ_PROP_DESCRIPTION:
        case AZ_PROP_APPLICATION_DATA:
        case AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID:
        case AZ_PROP_APPLICATION_VERSION:
        case AZ_PROP_TASK_BIZRULE:
        case AZ_PROP_TASK_BIZRULE_LANGUAGE:
        case AZ_PROP_TASK_BIZRULE_IMPORTED_PATH:
        case AZ_PROP_GROUP_LDAP_QUERY:
        case AZ_PROP_CLIENT_CONTEXT_USER_DN:
        case AZ_PROP_CLIENT_CONTEXT_USER_SAM_COMPAT:
        case AZ_PROP_CLIENT_CONTEXT_USER_DISPLAY:
        case AZ_PROP_CLIENT_CONTEXT_USER_GUID:
        case AZ_PROP_CLIENT_CONTEXT_USER_CANONICAL:
        case AZ_PROP_CLIENT_CONTEXT_USER_UPN:
        case AZ_PROP_CLIENT_CONTEXT_USER_DNS_SAM_COMPAT:
        case AZ_PROP_ADMIN_TARGET_MACHINE:
        case AZ_PROP_CLIENT_CONTEXT_ROLE_FOR_ACCESS_CHECK:
            dataType = ENUM_AZ_BSTR;
        break;

        case AZ_PROP_ADMIN_DOMAIN_TIMEOUT:
        case AZ_PROP_ADMIN_SCRIPT_ENGINE_TIMEOUT:
        case AZ_PROP_ADMIN_MAX_SCRIPT_ENGINES:
        case AZ_PROP_OPERATION_ID:
        case AZ_PROP_GROUP_TYPE:
        case AZ_PROP_APPLY_STORE_SACL:
        case AZ_PROP_GENERATE_AUDITS:
        //case AZ_PROP_ADMIN_MAJOR_VERSION: make it invisible to clients
        //case AZ_PROP_ADMIN_MINOR_VERSION: make it invisible to clients
            dataType = ENUM_AZ_LONG;
        break;

        case AZ_PROP_TASK_OPERATIONS:
        case AZ_PROP_TASK_TASKS:
        case AZ_PROP_GROUP_APP_MEMBERS:
        case AZ_PROP_GROUP_APP_NON_MEMBERS:
        case AZ_PROP_ROLE_APP_MEMBERS:
        case AZ_PROP_ROLE_OPERATIONS:
        case AZ_PROP_ROLE_TASKS:
            dataType = ENUM_AZ_BSTR_ARRAY;
        break;

        case AZ_PROP_GROUP_MEMBERS:
        case AZ_PROP_GROUP_NON_MEMBERS:
        case AZ_PROP_ROLE_MEMBERS:
        case AZ_PROP_POLICY_ADMINS:
        case AZ_PROP_POLICY_READERS:
        case AZ_PROP_DELEGATED_POLICY_USERS:
            dataType = ENUM_AZ_SID_ARRAY;
        break;

        case AZ_PROP_TASK_IS_ROLE_DEFINITION:
        case AZ_PROP_WRITABLE:
            dataType = ENUM_AZ_BOOL;
        break;

        default:
            hr = E_INVALIDARG;
            goto error;
        break;
    }

    *pDataType = dataType;

    hr = S_OK;
error:
    return hr;
}

BOOL
DoOperations(
    IN POPERATION OperationsToDo,
    IN ULONG Indentation,
    IN ULONG SpecificOpcodeOffset,
    IN LPSTR EchoPrefix
    )
/*++

Routine Description:

    Do a set of operations

Arguments:

    OperationsToDo - a list of operations to do

    Indentation - Number of spaces to indent text by.
        This value increases on recursive calls.

    SpecificOpcodeOffset - Specifies an amount to add to a generic opcode to map
        it to a specific opcode.

    EchoPrefix - Specifies a string to print before all AzoEcho strings

Return Value:

    TRUE - tests completed successfully
    FALSE - tests failed

--*/
{
    BOOL RetVal = TRUE;
    POPERATION Operation;
    LPSTR OpName;
    ULONG Opcode;

    PVOID PropertyValue = NULL;
    ENUM_AZ_DATATYPE PropType;

    ULONG PropertyId;

    BOOLEAN WasGetProperty;
    HANDLE SubmitHandle;
    ULONG SubmitFlags;
    BOOLEAN SubmitOk;

    BOOLEAN UpdateCache;
    BOOLEAN InitUponDelete;

    ULONG SleepTime;

    ULONG EnumerationContext = 0;
    BOOLEAN FirstIteration = TRUE;

    DWORD WinStatus;
    DWORD RealWinStatus;
    DWORD TempWinStatus;
    HRESULT hr;

    CHAR BigBuffer[1000];
    PAZ_STRING_ARRAY StringArray1;
    PAZ_STRING_ARRAY StringArray2;

    PAZ_SID_ARRAY SidArray1;
    PAZ_SID_ARRAY SidArray2;

    LPWSTR ScopeNames[8];
    ULONG Results[50];
    static AZ_HANDLE GlobalAdminManagerHandle = NULL;
    static AZ_HANDLE SavedGlobalAdminManagerHandle = NULL;

    ULONG i;

    //
    // Leave room between tests
    //

    if ( Indentation == 0 ) {
        if ( !Silent ) {
            printf( "\n\n" );
        }
    }


    //
    // Loop through each of the operations
    //

    for ( Operation=OperationsToDo; Operation->Opcode != AzoEndOfList && RetVal; ) {

        //
        // Mark that this change doesn't need to be submitted (by default)
        //

        SubmitHandle = INVALID_HANDLE_VALUE;

        //
        // Compute the flags to pass to submit if a submit turns out to be needed
        //

        Opcode = Operation->Opcode;
        SubmitFlags = 0;

        if ( Opcode & AzoAbort ) {
            SubmitFlags |= AZ_SUBMIT_FLAG_ABORT;
            Opcode &= ~AzoAbort;
        }

        SubmitOk = TRUE;

        if ( Opcode & AzoNoSubmit ) {
            SubmitOk = FALSE;
            Opcode &= ~AzoNoSubmit;
        }

        UpdateCache = TRUE;

        if ( Opcode & AzoNoUpdateCache ) {
            UpdateCache = FALSE;
            Opcode &= ~AzoNoUpdateCache;
        }

        InitUponDelete = FALSE;



        //
        // Compute the mapped property ID
        //

        if ( TestLinkPropId != 0 && Operation->PropertyId != 0 ) {
            PropertyId = TestLinkPropId;
        } else {
            PropertyId = Operation->PropertyId;
        }


        //
        // Setup for get/set property
        //

        PropertyValue = NULL;

        //
        // Convert property id to type
        //

        hr = myAzGetPropertyDataType( PropertyId, &PropType );

        if ( FAILED(hr) ) {
            PropType = ENUM_AZ_NONE;
        }

        WasGetProperty = FALSE;

        SleepTime = 0;

        //
        // Map generic opcodes to a specific opcode
        //

        if ( Opcode < AzoGenMax ) {
            ASSERT( SpecificOpcodeOffset != 0 );
            Opcode += SpecificOpcodeOffset;

        } else if ( Opcode >= AzoTl && Opcode < AzoTlMax ) {
            ASSERT( TestLinkOpcodeOffset != 0 );
            Opcode = Opcode - AzoTl + TestLinkOpcodeOffset;
        }


        //
        // Perform the requested operation
        //
        //
        // Admin Manager APIs
        //

        switch ( Opcode ) {
        case AzoInit:
            OpName = "AzInitialize";
            WinStatus = AzInitialize(
                            AzGlTestFile,
                            PropertyId, // Flags
                            0,  // reserved
                            Operation->OutputHandle );

            SubmitHandle = *Operation->OutputHandle;
            UpdateCache = FALSE;


            //
            // Initialize another copy for refresh testing
            //

            if ( !NoUpdateCache && WinStatus == NO_ERROR && GlobalAdminManagerHandle == NULL ) {
                SavedGlobalAdminManagerHandle = *Operation->OutputHandle;
                TempWinStatus = AzInitialize(
                                    AzGlTestFile,
                                    PropertyId, // Flags
                                    0,  // reserved
                                    &GlobalAdminManagerHandle );
                if ( TempWinStatus != NO_ERROR ) {
                    PrintIndent( Indentation+4, TRUE );
                    RetVal = FALSE;
                    printf( "Cannot AzInitialize new database. %ld\n", TempWinStatus );
                }
            }



            break;

        case AzoUpdateCache:
            OpName = "AzUpdateCache";
            WinStatus = AzUpdateCache(
                            *Operation->InputHandle );

            break;

        case AzoGetProp:
            OpName = "AzGetProperty";

            WinStatus = AzGetProperty(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            &PropertyValue );

            WasGetProperty = TRUE;
            break;

        case AzoSetProp:
            OpName = "AzSetProperty";

            WinStatus = AzSetProperty(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            Operation->Parameter1 );

            SubmitHandle = *Operation->InputHandle;
            break;

        case AzoAddProp:
            OpName = "AzAddProperty";

            WinStatus = AzAddPropertyItem(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            Operation->Parameter1 );

            SubmitHandle = *Operation->InputHandle;

            break;

        case AzoRemProp:
            OpName = "AzRemProperty";

            WinStatus = AzRemovePropertyItem(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            Operation->Parameter1 );

            SubmitHandle = *Operation->InputHandle;

            break;

        case AzoAdmDelete:
            InitUponDelete = TRUE;
            /* Drop through */
        case AzoAdmDeleteNoInit:

            //
            // Take this oportunity to ensure we can initialize from this store
            //
            WinStatus = NO_ERROR;
            if  ( InitUponDelete && !NoInitAllTests ) {
                AZ_HANDLE AdminManagerHandle;

                WinStatus = AzInitialize(
                                AzGlTestFile,
                                0,  // No flags
                                0,  // reserved
                                &AdminManagerHandle );

                if ( WinStatus != NO_ERROR ) {
                    PrintIndent( Indentation+4, TRUE );
                    RetVal = FALSE;
                    printf( "Cannot AzInitialize existing database.\n" );
                } else {
                    AzCloseHandle( AdminManagerHandle, 0 );
                }

            }

            OpName = "AzAdminManagerDelete";
            if ( RetVal ) {
                WinStatus = AzAdminManagerDelete(
                                *Operation->InputHandle,
                                0 );  // reserved
            }

            UpdateCache = FALSE;

            break;




        //
        // Application APIs
        //
        case AzoAppCreate:
            OpName = "AzApplicationCreate";
            WinStatus = AzApplicationCreate(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            SubmitHandle = *Operation->OutputHandle;

            break;

        case AzoAppOpen:
            OpName = "AzApplicationOpen";
            WinStatus = AzApplicationOpen(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            break;

        case AzoAppEnum:
            OpName = "AzApplicationEnum";
            WinStatus = AzApplicationEnum(
                            *Operation->InputHandle,
                            0,  // reserved
                            &EnumerationContext,
                            Operation->OutputHandle );

            break;

        case AzoAppDelete:
            OpName = "AzApplicationDelete";
            WinStatus = AzApplicationDelete(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0 );  // reserved

            SubmitHandle = *Operation->InputHandle;

            break;


        //
        // Operation APIs
        //
        case AzoOpCreate:
            OpName = "AzOperationCreate";
            WinStatus = AzOperationCreate(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            SubmitHandle = *Operation->OutputHandle;

            break;

        case AzoOpOpen:
            OpName = "AzOperationOpen";
            WinStatus = AzOperationOpen(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            break;

        case AzoOpEnum:
            OpName = "AzOperationEnum";
            WinStatus = AzOperationEnum(
                            *Operation->InputHandle,
                            0,  // reserved
                            &EnumerationContext,
                            Operation->OutputHandle );

            break;

        case AzoOpDelete:
            OpName = "AzOperationDelete";
            WinStatus = AzOperationDelete(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0 );  // reserved

            SubmitHandle = *Operation->InputHandle;

            break;


        //
        // Task APIs
        //
        case AzoTaskCreate:
            OpName = "AzTaskCreate";
            WinStatus = AzTaskCreate(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            SubmitHandle = *Operation->OutputHandle;

            break;

        case AzoTaskOpen:
            OpName = "AzTaskOpen";
            WinStatus = AzTaskOpen(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            break;

        case AzoTaskEnum:
            OpName = "AzTaskEnum";
            WinStatus = AzTaskEnum(
                            *Operation->InputHandle,
                            0,  // reserved
                            &EnumerationContext,
                            Operation->OutputHandle );

            break;

        case AzoTaskDelete:
            OpName = "AzTaskDelete";
            WinStatus = AzTaskDelete(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0 );  // reserved

            SubmitHandle = *Operation->InputHandle;

            break;


        //
        // Scope APIs
        //
        case AzoScopeCreate:
            OpName = "AzScopeCreate";
            WinStatus = AzScopeCreate(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            SubmitHandle = *Operation->OutputHandle;

            break;

        case AzoScopeOpen:
            OpName = "AzScopeOpen";
            WinStatus = AzScopeOpen(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            break;

        case AzoScopeEnum:
            OpName = "AzScopeEnum";
            WinStatus = AzScopeEnum(
                            *Operation->InputHandle,
                            0,  // reserved
                            &EnumerationContext,
                            Operation->OutputHandle );

            break;

        case AzoScopeDelete:
            OpName = "AzScopeDelete";
            WinStatus = AzScopeDelete(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0 );  // reserved

            SubmitHandle = *Operation->InputHandle;

            break;


        //
        // Group APIs
        //
        case AzoGroupCreate:
            OpName = "AzGroupCreate";
            WinStatus = AzGroupCreate(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            SubmitHandle = *Operation->OutputHandle;

            break;

        case AzoGroupOpen:
            OpName = "AzGroupOpen";
            WinStatus = AzGroupOpen(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            break;

        case AzoGroupEnum:
            OpName = "AzGroupEnum";
            WinStatus = AzGroupEnum(
                            *Operation->InputHandle,
                            0,  // reserved
                            &EnumerationContext,
                            Operation->OutputHandle );

            break;

        case AzoGroupDelete:
            OpName = "AzGroupDelete";
            WinStatus = AzGroupDelete(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0 );  // reserved

            SubmitHandle = *Operation->InputHandle;

            break;


        //
        // Role APIs
        //
        case AzoRoleCreate:
            OpName = "AzRoleCreate";
            WinStatus = AzRoleCreate(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            SubmitHandle = *Operation->OutputHandle;

            break;

        case AzoRoleOpen:
            OpName = "AzRoleOpen";
            WinStatus = AzRoleOpen(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            break;

        case AzoRoleEnum:
            OpName = "AzRoleEnum";
            WinStatus = AzRoleEnum(
                            *Operation->InputHandle,
                            0,  // reserved
                            &EnumerationContext,
                            Operation->OutputHandle );

            break;

        case AzoRoleDelete:
            OpName = "AzRoleDelete";
            WinStatus = AzRoleDelete(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0 );  // reserved

            SubmitHandle = *Operation->InputHandle;

            break;


        //
        // ClientContext APIs
        //

        case AzoInitCFT:
            OpName = "AzInitializeContextFromToken";

            WinStatus = AzInitializeContextFromToken(
                                *Operation->InputHandle,
                                (HANDLE)*Operation->Parameter1,
                                0,  // reserved
                                Operation->OutputHandle );

            break;

        case AzoAccess:
            OpName = "AzContextAccessCheck";

            ScopeNames[0] = Operation->Parameter1;
            WinStatus = AzContextAccessCheck(
                                *Operation->InputHandle,
                                L"FredObject",
                                (*ScopeNames == NULL)?0:1,  // ScopeCount
                                (*ScopeNames == NULL)? NULL : ScopeNames,
                                Operation->PropertyId,  // OperationCount
                                (PULONG)Operation->OutputHandle,// Operations
                                Results,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL );

            break;


        case AzoClose:

            //
            // If this is the close of the admin manager object,
            //  close my corresponding handle, too
            //
            if ( SavedGlobalAdminManagerHandle != NULL &&
                 *Operation->InputHandle == SavedGlobalAdminManagerHandle ) {

                TempWinStatus = AzCloseHandle( GlobalAdminManagerHandle, 0 );

                if (TempWinStatus != NO_ERROR ) {
                    PrintIndent( Indentation+4, TRUE );
                    RetVal = FALSE;
                    printf( "Cannot AzCloseHandle on refresh database. %ld\n", TempWinStatus );
                }

                GlobalAdminManagerHandle = NULL;
                SavedGlobalAdminManagerHandle = NULL;
            }

            OpName = "AzCloseHandle";
            WinStatus = AzCloseHandle(
                            *Operation->InputHandle,
                            0 );  // reserved

            break;

        // Pseudo function test links between objects
        case AzoTestLink:
            OpName = "TestLink";

            // Handle to the parent of the object being linked from
            TestLinkHandleP = *Operation->InputHandle;

            // Handle to the object being linked from
            TestLinkHandleA = *Operation->OutputHandle;

            // PropId to use for all set/get property
            TestLinkPropId = PropertyId;

            // Opcode offset to use for linked-to objects
            TestLinkOpcodeOffset = Operation->ExpectedStatus;

            // Name of the object being linked from
            wcscpy(TestLinkObjectName, Operation->ExpectedParameter1);


            WinStatus = Operation->ExpectedStatus;

            //
            // Build a new echo prefix
            //

            strcpy( BigBuffer, EchoPrefix );
            strcat( BigBuffer, "->" );
            strcat( BigBuffer, (LPSTR)Operation->Parameter1 );

            //
            // Print a description of the operation
            //

            if ( !Silent ) {
                PrintIndent( Indentation, FALSE );
                printf( "\n%s - Test linking '%s' objects to the object named '%ws' using propid '%ld'.\n",
                    BigBuffer,
                    Operation->Parameter1,
                    TestLinkObjectName,
                    TestLinkPropId );
            }

            UpdateCache = FALSE;

            break;

        // Pseudo function to duplicate a handle
        case AzoDupHandle:
            OpName = "DupHandle";
            *Operation->OutputHandle = *Operation->InputHandle;
            WinStatus = NO_ERROR;
            UpdateCache = FALSE;

            break;

        // Pseudo function to execute a "subroutine" of operations
        case AzoGoSub:
            OpName = "GoSub";
            WinStatus = NO_ERROR;
            UpdateCache = FALSE;

            break;

        // Pseudo function to echo text to stdout
        case AzoSleep:
            SleepTime = Operation->PropertyId;
            /* Drop through */

        case AzoEcho:
            OpName = BigBuffer;
            strcpy( OpName, "\n");
            if ( EchoPrefix ) {
                strcat( OpName, EchoPrefix );
                strcat( OpName, " -" );
            }
            WinStatus = NO_ERROR;
            UpdateCache = FALSE;

            break;

        default:

            OpName = "<Unknown>";
            PrintIndent( Indentation+4, TRUE );
            RetVal = FALSE;
            printf( "Need to fix test app to handle a new opcode: %ld\n", Opcode );
            WinStatus = Operation->ExpectedStatus;
            break;

        }

        //
        // Print the operation
        //

        if ( FirstIteration ) {

            if ( Opcode != AzoTestLink ) {

                if ( !Silent ) {
                    PrintIndent( Indentation, FALSE );
                    printf( "%s ", OpName );
                }

                if ( Operation->Parameter1 != NULL ) {
                    LPWSTR TempString;
                    switch ( PropType ) {
                    case ENUM_AZ_NONE:
                    case ENUM_AZ_BSTR:
                    case ENUM_AZ_BSTR_ARRAY:
                        if ( !Silent ) {
                            printf( "'%ws' ", Operation->Parameter1 );
                        }
                        break;
                    case ENUM_AZ_LONG:
                    case ENUM_AZ_BOOL:
                        if ( !Silent ) {
                            printf( "'%ld' ", *(PULONG)Operation->Parameter1 );
                        }
                        break;
                    case ENUM_AZ_SID_ARRAY:
                        if ( !ConvertSidToStringSidW( (PSID)Operation->Parameter1,
                                                      &TempString ) ) {
                            PrintIndent( Indentation+4, TRUE );
                            RetVal = FALSE;
                            printf( "Cannot convert sid.\n" );

                        } else {
                            if ( !Silent ) {
                                printf( "'%ws'", TempString );
                            }
                        }
                        break;
                    default:
                        if ( !Silent ) {
                            printf( "%ld '%ws' ", PropType, Operation->Parameter1 );
                        }
                        ASSERT(FALSE);
                    }
                }
                if ( PropertyId != 0 ) {
                    if ( !Silent ) {
                        printf( "(%ld) ", PropertyId );
                    }
                }

                if ( Operation->ExpectedStatus != NO_ERROR ) {

                    if ( !Silent ) {
                        printf("(");
                        PrintStatus( Operation->ExpectedStatus );
                        printf(") ");
                    }
                }
                if ( !Silent ) {
                    printf( "\n" );
                }

                if ( SleepTime != 0 ) {
                    ULONG t;
                    PrintIndent( Indentation, FALSE );
                    printf( "Sleeping %ld seconds", SleepTime );
                    for ( t=0;t<SleepTime;t++) {
                        printf(".");
                        Sleep(1000);
                    }
                    printf("\n");

                }
            }
        }
        FirstIteration = FALSE;

        //
        // Handle ERROR_NO_MORE_ITEMS/NO_ERROR mapping
        //

        RealWinStatus = WinStatus;
        if ( Operation->EnumOperations != NULL ) {
            if ( WinStatus == ERROR_NO_MORE_ITEMS ) {
                WinStatus = NO_ERROR;
            }
        }


        //
        // Ensure we got the right status code
        //

        if ( WinStatus != Operation->ExpectedStatus ) {
            PrintIndent( Indentation+4, TRUE );
            RetVal = FALSE;
            printf( "Returned '" );
            PrintStatus( WinStatus );
            printf( "' instead of '");
            PrintStatus( Operation->ExpectedStatus );
            printf( "'");
            printf( "\n" );
            break;
        }

        //
        // Do GetProperty specific code
        //

        if ( WinStatus == NO_ERROR && WasGetProperty ) {

            //
            // Print the property
            //

            switch ( PropType ) {
            case ENUM_AZ_BSTR:
                if ( PropertyValue == NULL ) {
                    PrintIndent( Indentation+4, TRUE );
                    RetVal = FALSE;
                    printf( "<NULL>\n", PropertyValue );
                } else {
                    if ( !Silent ) {
                        PrintIndent( Indentation+4, FALSE );
                        printf( "'%ws'\n", PropertyValue );
                    }
                }

                //
                // Check if that value is expected
                //

                if ( Operation->ExpectedParameter1 != NULL &&
                     (PropertyValue == NULL ||
                     _wcsicmp( Operation->ExpectedParameter1, PropertyValue) != 0 )) {

                    PrintIndent( Indentation+4, TRUE );
                    RetVal = FALSE;
                    printf( "Expected '%ws' instead of '%ws'\n", Operation->ExpectedParameter1, PropertyValue );
                }

                break;

            case ENUM_AZ_BSTR_ARRAY:
                StringArray1 = (PAZ_STRING_ARRAY) PropertyValue;;

                if ( PropertyValue == NULL ) {
                    PrintIndent( Indentation+4, TRUE );
                    RetVal = FALSE;
                    printf( "<NULL>\n", PropertyValue );
                } else {

                    for ( i=0; i<StringArray1->StringCount; i++ ) {
                        if ( !Silent ) {
                            PrintIndent( Indentation+4, FALSE );
                            printf( "'%ws'\n", StringArray1->Strings[i] );
                        }
                    }
                }

                //
                // Check if that value is expected
                //

                if ( Operation->ExpectedParameter1 != NULL ) {
                    StringArray2 = (PAZ_STRING_ARRAY)Operation->ExpectedParameter1;

                    if ( StringArray1->StringCount != StringArray2->StringCount ) {
                        PrintIndent( Indentation+4, TRUE );
                        RetVal = FALSE;
                        printf( "Expected '%ld' strings instead of '%ld' strings\n", StringArray2->StringCount, StringArray1->StringCount );
                    } else {

                        for ( i=0; i<StringArray1->StringCount; i++ ) {

                            if ( wcscmp( StringArray1->Strings[i], StringArray2->Strings[i]) != 0 ) {

                                PrintIndent( Indentation+4, TRUE );
                                RetVal = FALSE;
                                printf( "Expected string %ld to be '%ws' instead of '%ws'\n",
                                        i,
                                        StringArray2->Strings[i],
                                        StringArray1->Strings[i] );

                            }
                        }
                    }
                }

                break;

            case ENUM_AZ_LONG:
            case ENUM_AZ_BOOL:
                if ( PropertyValue == NULL ) {
                    PrintIndent( Indentation+4, TRUE );
                    RetVal = FALSE;
                    printf( "<NULL>\n", PropertyValue );
                } else {
                    if ( !Silent ) {
                        PrintIndent( Indentation+4, FALSE );
                        printf( "'%ld'\n", *(PULONG)PropertyValue );
                    }
                }

                //
                // Check if that value is expected
                //

                if ( *(PULONG)(Operation->ExpectedParameter1) != *(PULONG)PropertyValue ) {
                    PrintIndent( Indentation+4, TRUE );
                    RetVal = FALSE;
                    printf( "Expected '%ld' instead of '%ld'\n",
                                 *(PULONG)(Operation->ExpectedParameter1),
                                 *(PULONG)PropertyValue );
                }
                break;

            case ENUM_AZ_SID_ARRAY:
                SidArray1 = (PAZ_SID_ARRAY) PropertyValue;;

                if ( PropertyValue == NULL ) {
                    PrintIndent( Indentation+4, TRUE );
                    RetVal = FALSE;
                    printf( "<NULL>\n" );
                } else {
                    LPWSTR TempString;

                    for ( i=0; i<SidArray1->SidCount; i++ ) {
                        if ( !Silent ) {
                            PrintIndent( Indentation+4, FALSE );
                        }

                        if ( !ConvertSidToStringSidW( SidArray1->Sids[i],
                                                      &TempString ) ) {
                            PrintIndent( Indentation+4, TRUE );
                            RetVal = FALSE;
                            printf( "Cannot convert sid.\n" );

                        } else {
                            if ( !Silent ) {
                               printf( "'%ws'\n", TempString );
                            }
                        }
                    }
                }

                //
                // Check if that value is expected
                //

                if ( Operation->ExpectedParameter1 != NULL ) {
                    SidArray2 = (PAZ_SID_ARRAY)Operation->ExpectedParameter1;

                    if ( SidArray1->SidCount != SidArray2->SidCount ) {
                        PrintIndent( Indentation+4, TRUE );
                        RetVal = FALSE;
                        printf( "Expected '%ld' sids instead of '%ld' sids\n", SidArray2->SidCount, SidArray1->SidCount );
                    } else {

                        for ( i=0; i<SidArray1->SidCount; i++ ) {

                            if ( !EqualSid( SidArray1->Sids[i], SidArray2->Sids[i]) ) {
                                LPWSTR TempString1;
                                LPWSTR TempString2;

                                if ( !ConvertSidToStringSidW( SidArray1->Sids[i],
                                                             &TempString1 ) ) {
                                    PrintIndent( Indentation+4, TRUE );
                                    RetVal = FALSE;
                                    printf( "Cannot convert sid.\n" );
                                    continue;
                                }

                                if ( !ConvertSidToStringSidW( SidArray2->Sids[i],
                                                             &TempString2 ) ) {
                                    PrintIndent( Indentation+4, TRUE );
                                    RetVal = FALSE;
                                    printf( "Cannot convert sid.\n" );
                                    continue;
                                }

                                PrintIndent( Indentation+4, TRUE );
                                RetVal = FALSE;
                                printf( "Expected string %ld to be '%ws' instead of '%ws'\n",
                                        i,
                                        TempString2,
                                        TempString1 );

                            }
                        }
                    }
                }

                break;

            default:
                ASSERT(FALSE);
            }

            //
            // Free the returned buffer
            //

            AzFreeMemory( PropertyValue );

        }

        //
        // Submit the changes to the database
        //

        if ( WinStatus == NO_ERROR &&
             SubmitHandle != INVALID_HANDLE_VALUE &&
             SubmitOk ) {

            WinStatus = AzSubmit( SubmitHandle,
                                  SubmitFlags,
                                  0);  // reserved

            if ( WinStatus != NO_ERROR ) {
                PrintIndent( Indentation+4, TRUE );
                RetVal = FALSE;
                printf( "AzSubmit failed: " );
                PrintStatus( WinStatus );
                printf( "\n" );
            }

        }

        //
        // Update the cache on our parallel admin manager handle
        //

        if ( UpdateCache && GlobalAdminManagerHandle != NULL ) {

            TempWinStatus = AzUpdateCache( GlobalAdminManagerHandle );

            if ( TempWinStatus != NO_ERROR ) {
                PrintIndent( Indentation+4, TRUE );
                RetVal = FALSE;
                printf( "AzUpdateCache failed: " );
                PrintStatus( TempWinStatus );
                printf( "\n" );
            }

        }


        //
        // Execute a "subroutine" of operations
        //

        if ( Opcode == AzoGoSub ) {

            if (!DoOperations( Operation->EnumOperations, Indentation + 4, SpecificOpcodeOffset, EchoPrefix ) ) {
                RetVal = FALSE;
            }

        //
        // Execute a the special TestLink "subroutine" of operations
        //

        } else if ( Opcode == AzoTestLink ) {

            if (!DoOperations( Operation->EnumOperations, Indentation + 4, SpecificOpcodeOffset, BigBuffer ) ) {
                RetVal = FALSE;
            }

            TestLinkPropId = 0;

        //
        // Check the results of an access check
        //

        } else if ( Opcode == AzoAccess && WinStatus == NO_ERROR ) {

            for ( i=0; i<Operation->PropertyId; i++ ) {

                if ( ((PULONG)(Operation->ExpectedParameter1))[i] != Results[i] ) {
                    PrintIndent( Indentation+4, TRUE );
                    RetVal = FALSE;

                    printf("Operation %ld: Expected '",
                           ((PULONG)(Operation->OutputHandle))[i] );

                    PrintStatus( ((PULONG)(Operation->ExpectedParameter1))[i] );

                    printf("' instead of '" );

                    PrintStatus( Results[i] );
                    printf("'\n");

                }
            }


        //
        // Do enumeration specific code
        //

        } else if ( Operation->EnumOperations != NULL && RealWinStatus == NO_ERROR ) {

            if ( !Silent ) {
                PrintIndent( Indentation+4, FALSE );
                printf( "%ld:\n", EnumerationContext );
            }

            if (!DoOperations( Operation->EnumOperations, Indentation + 8, SpecificOpcodeOffset, EchoPrefix ) ) {
                RetVal = FALSE;
                break;
            }

            continue;
        }

        //
        // Do the next operation
        //

        EnumerationContext = 0;
        FirstIteration = TRUE;
        Operation++;
    }

    return RetVal;
}

DWORD
AzComInitialize(
    OUT PBOOL ComState
    )
/*++

Routine Description:

    This routine initializes COM.  If the caller uses the "C" api, the caller must initialize COM
    in each thread before calling any other AZ api.

    The calling must free all AZ handles before uninitializing COM.

Arguments:

    State - State to pass to AzComUninitialize

Return Value:

    NO_ERROR - The operation was successful.
        The caller should call AzComUninitialize on this thread.

--*/
{
    DWORD WinStatus = NO_ERROR;
    HRESULT hr;

    //
    // Initialize COM
    //

    *ComState = FALSE;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (hr == S_OK || hr == S_FALSE) {
        *ComState = TRUE;

    } else if (hr != RPC_E_CHANGED_MODE) {
        WinStatus = hr;
    }

    return WinStatus;
}

VOID
AzComUninitialize(
    IN BOOL ComState
    )
/*++

Routine Description:

    This routine un-initializes COM.  It should be called once for each thread that successfully
    calls AzComInitialize.

Arguments:

    State - State returned from AzComInitialize

Return Value:

    NO_ERROR - The operation was successful.

--*/
{
    if ( ComState) {
        CoUninitialize();
    }
}


DWORD
AccessCheckThread(
    LPVOID lpThreadParameter
    )
/*++

Routine Description:

    This routine implements a second thread to do access checks in.

    The purpose of the thread is to test bizrules which behave differently if more than one thread is
    executing the bizrule.

Arguments:

    Not used.

Return Value:

    NO_ERROR - The operation was successful.

--*/
{
    DWORD WinStatus;
    DWORD ComState;
    BOOLEAN UseLdap = (BOOLEAN) lpThreadParameter;


    Sleep( 60 );
    WinStatus = AzComInitialize( &ComState );

    if ( WinStatus != NO_ERROR ) {
        printf( "Cannot cominitialize %ld\n", WinStatus );
        goto Cleanup;
    }

    //
    // Do AccessCheck specific tests
    //
    if ( !DoOperations( OpAccess1m, 0, 0, "Access1m" ) ) {
        goto Cleanup;
    }

    {
        DWORD Ticks;
        ULONG i;
        Ticks = GetTickCount();
        for ( i=0; i<900; i++ ) {
            if ( UseLdap ) {
                if ( !DoOperations( OpAccess2mLdap, 0, 0, "Access2mLdap" ) ) {
                    goto Cleanup;
                }
            } else {
                if ( !DoOperations( OpAccess2m, 0, 0, "Access2m" ) ) {
                    goto Cleanup;
                }
            }

            // Sleep a bit to allow other thread a change to use our cached script
            Sleep(10);
        }
        Ticks = GetTickCount() - Ticks;
        printf( "%ld milliseconds\n", Ticks );
    }
    if ( !DoOperations( OpAccess3m, 0, 0, "Access3m" ) ) {
        goto Cleanup;
    }

Cleanup:
    AzComUninitialize( ComState );
    return NO_ERROR;
}

DWORD
BizRuleChangeThread(
    LPVOID lpThreadParameter
    )
/*++

Routine Description:

    This routine implements a second thread to change the bizrule while access check is using it.

Arguments:

    Not used.

Return Value:

    NO_ERROR - The operation was successful.

--*/
{
    DWORD WinStatus;
    DWORD ComState;

    ULONG i;
    WinStatus = AzComInitialize( &ComState );

    if ( WinStatus != NO_ERROR ) {
        printf( "Cannot cominitialize %ld\n", WinStatus );
        goto Cleanup;
    }

    //
    // Do this several times to allow it to interfere with the main thread in several places
    //
    for ( i=0; i<100; i++ ) {



        Sleep( 60 );

        //
        // Do Change bizrule specific tests
        //
        if ( !DoOperations( OpBizruleThread, 0, 0, "BizRuleThread" ) ) {
            goto Cleanup;
        }

    }

Cleanup:
    AzComUninitialize( ComState );
    return NO_ERROR;
}

DWORD
GroupChangeThread(
    LPVOID lpThreadParameter
    )
/*++

Routine Description:

    This routine implements a second thread to change a group membership while access check is using it.

Arguments:

    Not used.

Return Value:

    NO_ERROR - The operation was successful.

--*/
{
    DWORD WinStatus;
    DWORD ComState;

    ULONG i;
    WinStatus = AzComInitialize( &ComState );

    if ( WinStatus != NO_ERROR ) {
        printf( "Cannot cominitialize %ld\n", WinStatus );
        goto Cleanup;
    }

    //
    // Do this several times to allow it to interfere with the main thread in several places
    //
    for ( i=0; i<100; i++ ) {



        Sleep( 60 );

        //
        // Do Change bizrule specific tests
        //
        if ( !DoOperations( OpGroupThread, 0, 0, "GroupThread" ) ) {
            goto Cleanup;
        }

    }

Cleanup:
    AzComUninitialize( ComState );
    return NO_ERROR;
}

int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Test azroles.dll

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    BOOL RetVal = TRUE;

    DWORD WinStatus;
    DWORD ComState;

    ULONG TestNum;
    ULONG Index;
    ULONG Index2;
    CHAR EchoPrefix[1024];

    BOOLEAN TestFound;
    BOOLEAN ObjectTests;
    BOOLEAN ShareTests;
    BOOLEAN PersistTests;
    BOOLEAN AccessTests;
    BOOLEAN SidxTests;
    BOOLEAN CommonInit;
    BOOLEAN ManyScopes;
    BOOLEAN MultiAccessCheck;
    BOOLEAN MultiThread;
    BOOLEAN MultiLdap;
    BOOLEAN BizruleMod;
    BOOLEAN GroupMod;
    BOOLEAN UseThreadToken;
    BOOLEAN fPrintUsage = FALSE;
    BOOLEAN AvoidDefaults;

    LPSTR Argument;


    ULONG TestIndex;
    int ArgIndex;

    struct {
        LPSTR TestName;
        BOOLEAN *EnableIt;
        BOOLEAN IsDefault;
        BOOLEAN AvoidDefaults;
        LPSTR Description;
    } Tests[] = {
        { "/Object",      &ObjectTests,      TRUE,  TRUE,  "Run lots of tests on all objects" },
        { "/Share",       &ShareTests,       TRUE,  TRUE,  "Test name sharing" },
        { "/Persist",     &PersistTests,     TRUE,  TRUE,  "Test persistence" },
        { "/Access",      &AccessTests,      TRUE,  TRUE,  "Test AccessCheck" },
        { "/Sidx",        &SidxTests,        FALSE, TRUE,  "Test a group with *lots* of Sids" },
        { "/ManyScopes",  &ManyScopes,       FALSE, TRUE,  "Test creating *lots* of scopes" },
        { "/MultiAccess", &MultiAccessCheck, FALSE, TRUE,  "Test many AccessChecks in a loop" },
        { "/MultiThread", &MultiThread,      FALSE, TRUE,  "Test AccessCheck in multiple threads" },
        { "/MultiLdap",   &MultiLdap,        FALSE, TRUE,  "Test AccessCheck in multiple threads using LDAP query" },
        { "/BizruleMod",  &BizruleMod,       FALSE, TRUE,  "Test modifying a bizrule during AccessCheck" },
        { "/GroupMod",    &GroupMod,         FALSE, TRUE,  "Test modifying a group membership during AccessCheck" },
        { "/ThreadToken", &UseThreadToken,   FALSE, FALSE, "Use thread token for all access tests" },
        { "/NoInitAll",   &NoInitAllTests,   FALSE, FALSE, "Skip AzInitialize before AzDelete" },
        { "/NoUpdateCache", &NoUpdateCache,  FALSE, FALSE, "Skip AzUpdateCache on every operation" },
        { "/Silent",      &Silent,           FALSE, FALSE, "Be quieter to avoid affecting timing" },
    };
#define TEST_COUNT (sizeof(Tests)/sizeof(Tests[0]))

    //
    // Objects that are children of "AdminManager"
    //
    DWORD GenAdmChildTests[] =    {     AzoApp,        AzoGroup };
    LPSTR GenAdmChildTestName[] = {     "Application", "Group" };
    POPERATION SpeAdmChildTestOps[] = { OpApplication, OpAdmGroup };
    POPERATION GenAdmChildTestOps[] = { OpAdmChildGen, OpAdmChildGenDupName
#ifdef ENABLE_LEAK
        , OpAdmChildGenLeak
#endif // ENABLE_LEAK
    };

    //
    // Objects that are children of "Application"
    //
    DWORD GenAppChildTests[] =    {     AzoOp,       AzoTask, AzoScope, AzoGroup,   AzoRole };
    LPSTR GenAppChildTestName[] = {     "Operation", "Task",  "Scope",  "Group",    "Role" };
    POPERATION SpeAppChildTestOps[] = { OpOperation, OpAppTask, NULL,   OpAppGroup, OpAppRole };
    POPERATION GenAppChildTestOps[] = { OpAppChildGen, OpAppChildGenDupName };

    //
    // Objects that are children of "Scope"
    //
    DWORD GenScopeChildTests[] =    {     AzoGroup,    AzoRole,  AzoTask };
    LPSTR GenScopeChildTestName[] = {     "Group",     "Role",   "Task" };
    POPERATION SpeScopeChildTestOps[] = { OpScopeGroup, OpScopeRole, OpScopeTask };
    POPERATION GenScopeChildTestOps[] = { OpScopeChildGen, OpScopeChildGenDupName };


    struct {

        //
        // Name of the parent object
        LPSTR ParentName;

        //
        // List of children to test for this parent
        DWORD ChildCount;
        DWORD *ChildOpcodeOffsets;
        LPSTR *ChildTestNames;
        // Operation to perform that is specific to the child type
        POPERATION *ChildOperations;

        //
        // List of tests to perform for each child type
        //
        DWORD OperationCount;
        POPERATION *Operations;
    } ParentChildTests[] = {
        { "AdminManager",
           sizeof(GenAdmChildTestName)/sizeof(GenAdmChildTestName[0]),
           GenAdmChildTests,
           GenAdmChildTestName,
           SpeAdmChildTestOps,
           sizeof(GenAdmChildTestOps)/sizeof(GenAdmChildTestOps[0]),
           GenAdmChildTestOps },
        { "Application",
           sizeof(GenAppChildTestName)/sizeof(GenAppChildTestName[0]),
           GenAppChildTests,
           GenAppChildTestName,
           SpeAppChildTestOps,
           sizeof(GenAppChildTestOps)/sizeof(GenAppChildTestOps[0]),
           GenAppChildTestOps },
        { "Scope",
           sizeof(GenScopeChildTestName)/sizeof(GenScopeChildTestName[0]),
           GenScopeChildTests,
           GenScopeChildTestName,
           SpeScopeChildTestOps,
           sizeof(GenScopeChildTestOps)/sizeof(GenScopeChildTestOps[0]),
           GenScopeChildTestOps },
    };

    WinStatus = AzComInitialize( &ComState );

    if ( WinStatus != NO_ERROR ) {
        printf( "Cannot cominitialize %ld\n", WinStatus );
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Assume no tests should be run
    //

    for ( TestIndex=0; TestIndex<TEST_COUNT; TestIndex++ ) {
        *(Tests[TestIndex].EnableIt) = FALSE;
    }


    if ( argc > 1 ) {

        Argument = argv[1];

        //
        // Is this XML or AD store testing?
        //

        if ( !_strcmpi( Argument, "-ad" ) ) {

#ifdef ENABLE_ADMIN_ACCOUNT_AD
            AzGlTestFile = L"msldap://CN=CliffV,OU=AzRoles,DC=cliffvdom,DC=nttest,DC=microsoft,DC=com";
#else // ENABLE_ADMIN_ACCOUNT_AD
            AzGlTestFile = L"msldap://CN=Chaitu,OU=AzRoles,DC=chaitu-dom3602,DC=nttest,DC=microsoft,DC=com";
#endif // ENABLE_ADMIN_ACCOUNT_AD

        } else if ( !_strcmpi( Argument, "-xml" ) ) {

            AzGlTestFile = L"msxml://.//TestFile.xml";
            // Delete the testfile
            DeleteFileW( L".\\TestFile.xml" );

        } else {

            fPrintUsage = TRUE;
            goto Usage;
        }

    } else {

        fPrintUsage = TRUE;
        goto Usage;

    }

    //
    // Parse the command line options
    //

    AvoidDefaults = FALSE;
    for ( ArgIndex=2; ArgIndex<argc; ArgIndex++ ) {

        Argument = argv[ArgIndex];

        //
        // Loop through the list of valid values
        //

        for ( TestIndex=0; TestIndex<TEST_COUNT; TestIndex++ ) {

            //
            // If found, set the boolean
            //
            if ( _strcmpi( Argument, Tests[TestIndex].TestName) == 0 ) {
                *(Tests[TestIndex].EnableIt) = TRUE;
                if ( Tests[TestIndex].AvoidDefaults ) {
                    AvoidDefaults = TRUE;
                }
                break;
            }

        }

        //
        // If typo,
        //  complain
        //

        if ( TestIndex >= TEST_COUNT ) {

            fPrintUsage = TRUE;
            goto Usage;
        }
    }

    //
    // If no options were specified,
    //  use the defaults.
    //

    if ( !AvoidDefaults ) {

        for ( TestIndex=0; TestIndex<TEST_COUNT; TestIndex++ ) {
            if ( Tests[TestIndex].IsDefault) {
                *(Tests[TestIndex].EnableIt) = TRUE;
            }
        }
    }

    //
    // Run the generic object tests
    //

    if ( ObjectTests ) {

        //
        // Do admin manager specific tests
        //
        if ( !DoOperations( OpAdm, 0, 0, "AdminManager" ) ) {
            RetVal = FALSE;
            goto Cleanup;
        }


        //
        // Loop for each object that can be the parent of another object
        //

        for ( TestNum=0; TestNum < sizeof(ParentChildTests)/sizeof(ParentChildTests[0]); TestNum++ ) {

            //
            // Loop for each child of the parent object
            //
            for ( Index=0; Index < ParentChildTests[TestNum].ChildCount; Index ++ ) {

                //
                // output the test name
                //

                strcpy( EchoPrefix, ParentChildTests[TestNum].ParentName );
                strcat( EchoPrefix, "->" );
                strcat( EchoPrefix, ParentChildTests[TestNum].ChildTestNames[Index] );

                if ( !Silent ) {
                    printf("\n%s - Perform tests of '%s' objects that are children of '%s' objects\n",
                            EchoPrefix,
                            ParentChildTests[TestNum].ChildTestNames[Index],
                            ParentChildTests[TestNum].ParentName );
                }

                //
                // Do the various generic tests that apply to all objects
                //

                for ( Index2=0; Index2 < ParentChildTests[TestNum].OperationCount; Index2 ++ ) {

                    if ( !DoOperations(
                                ParentChildTests[TestNum].Operations[Index2],
                                0,
                                ParentChildTests[TestNum].ChildOpcodeOffsets[Index],
                                EchoPrefix ) ) {

                        RetVal = FALSE;
                        goto Cleanup;
                    }

                }

                //
                // Do the one test that is specific to this parent/child relationship
                //

                if ( ParentChildTests[TestNum].ChildOperations[Index] == NULL ) {
                    // ??? Should complain here.  Test is missing
                } else {

                    if ( !DoOperations(
                                ParentChildTests[TestNum].ChildOperations[Index],
                                0,
                                ParentChildTests[TestNum].ChildOpcodeOffsets[Index],
                                EchoPrefix ) ) {

                        RetVal = FALSE;
                        goto Cleanup;
                    }

                }
            }
        }
    }


    //
    // Do name sharing specific tests
    //
    if ( ShareTests ) {
        if ( !DoOperations( OpShare, 0, 0, "NameShare" ) ) {
            RetVal = FALSE;
            goto Cleanup;
        }
    }

    //
    // Do peristence specific tests
    //
    if ( PersistTests ) {
        if ( !DoOperations( OpPersist, 0, 0, "Persist" ) ) {
            RetVal = FALSE;
            goto Cleanup;
        }
    }

    //
    // Grab my token
    //

    if ( UseThreadToken ) {
        if ( !OpenProcessToken( GetCurrentProcess(),
                                TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                                &TokenHandle ) ) {

            printf( "Cannot OpenProcessToken %ld\n", GetLastError() );
            RetVal = FALSE;
            goto Cleanup;
        }
    }


    //
    // Do AccessCheck specific tests
    //

    if ( AccessTests ) {

        if ( !DoOperations( OpAccess, 0, 0, "Access" ) ) {
            RetVal = FALSE;
            goto Cleanup;
        }
    }

    //
    // Is this one of the tests that need common initialization?
    //

    CommonInit = FALSE;
    if ( SidxTests || ManyScopes || MultiAccessCheck || MultiThread || MultiLdap || BizruleMod || GroupMod ) {
        CommonInit = TRUE;

    }

    if ( CommonInit ) {

        if ( !DoOperations( OpAccessBegin, 0, 0, "AccessBegin" ) ) {
            RetVal = FALSE;
            goto Cleanup;
        }
    }

    //
    // Create oodles of scope objects
    //

    if ( ManyScopes ) {
        DWORD OrigTicks;
        DWORD PrevTicks;
        DWORD Ticks;
        ULONG i;
        OrigTicks = GetTickCount();
        PrevTicks = OrigTicks;

        for ( i=0; i<10000; i++) {
            swprintf( ScopeBillions, L"Multi-Scope %ld", i );

            if ( !DoOperations( OpBillions, 0, 0, "Billions" ) ) {
                RetVal = FALSE;
                goto Cleanup;
            }

            Ticks = GetTickCount();
            printf( "%ld milliseconds\n", Ticks - PrevTicks );
            PrevTicks = Ticks;

        }
        printf( "%ld milliseconds\n", GetTickCount() - OrigTicks );
    }

    //
    // Test running access check in multiple threads
    //

    if ( MultiThread || MultiLdap ) {
        // Fire off another thread
        if ( !QueueUserWorkItem( AccessCheckThread, (PVOID)MultiLdap, 0 ) ) {
            RetVal = FALSE;
            goto Cleanup;
        }
    }


    //
    // Fire off a thread to change the bizrule on a task being used to access check
    //
    if ( BizruleMod ) {
        if ( !QueueUserWorkItem( BizRuleChangeThread, NULL, 0 ) ) {
            RetVal = FALSE;
            goto Cleanup;
        }
    }


    //
    // Fire off a thread to change a group being used to access check
    //
    if ( GroupMod ) {
        if ( !QueueUserWorkItem( GroupChangeThread, NULL, 0 ) ) {
            RetVal = FALSE;
            goto Cleanup;
        }
    }

    //
    // Do the tests the are designed to conflict with the above ASYNC operations
    //
    if ( MultiAccessCheck || MultiThread || MultiLdap || BizruleMod || GroupMod ) {
        DWORD Ticks;
        ULONG i;
        Ticks = GetTickCount();
        for ( i=0; i<1000; i++ ) {
            if ( MultiLdap ) {
                if ( !DoOperations( OpAccess2Ldap, 0, 0, "Access2Ldap" ) ) {
                    RetVal = FALSE;
                    goto Cleanup;
                }
            } else {
                if ( !DoOperations( OpAccess2, 0, 0, "Access2" ) ) {
                    RetVal = FALSE;
                    goto Cleanup;
                }
            }

            // Sleep a bit to allow other thread a chance to run
            if ( !MultiAccessCheck ) {
                Sleep(20);
            }
        }
        Ticks = GetTickCount() - Ticks;
        printf( "%ld milliseconds\n", Ticks );
    }

    //
    // Create a group with a *lot* of sids
    //

    if ( SidxTests ) {
        ULONG i;
        PSID Sid = (PSID)SidX;
        SID_IDENTIFIER_AUTHORITY Ia = SECURITY_WORLD_SID_AUTHORITY;

        if ( !DoOperations( OpSidxBegin, 0, 0, "SidxBegin" ) ) {
            RetVal = FALSE;
            goto Cleanup;
        }

        for ( i=0; i<1000; i++ ) {

            //
            // Add the everyone sid at an opportune spot
            //
            if ( i == 9999 ) {
#if 0
                RtlCopyMemory( Sid, &SidWorld, GetLengthSid( &SidWorld ) );
#else // 0
                RtlCopyMemory( Sid, &SidLocal, GetLengthSid( &SidLocal ) );
#endif // 0


            } else {
                DWORD j;

                //
                // Build a huge sid that no-one has
                //
#define AuthorityCount SID_MAX_SUB_AUTHORITIES
                if ( !InitializeSid( Sid, &Ia, AuthorityCount )) {
                    RetVal = FALSE;
                    goto Cleanup;
                }

                for ( j=0; j<AuthorityCount; j++ ) {
                    *GetSidSubAuthority( Sid, j ) = j+1;
                }

                // Set a different sid each time
                *GetSidSubAuthority( Sid, AuthorityCount-1) = i;
            }

            if ( !DoOperations( OpSidx, 0, 0, "Sidx" ) ) {
                RetVal = FALSE;
                goto Cleanup;
            }

        }

        if ( !DoOperations( OpSidxEnd, 0, 0, "SidxEnd" ) ) {
            RetVal = FALSE;
            goto Cleanup;
        }

    }

    //
    // The common initialization requires common rundown
    //

    if ( CommonInit ) {

        if ( !DoOperations( OpAccessEnd, 0, 0, "AccessEnd" ) ) {
            RetVal = FALSE;
            goto Cleanup;
        }
    }

    //
    // print usage
    //

Usage:

    if ( fPrintUsage ) {

        fprintf( stderr, "Usage: aztest <store> [<options>]\n" );
        fprintf( stderr, "\nWhere <store> is:\n\n" );

        fprintf( stderr, "    -xml: Do XML provider testing\n" );
        fprintf( stderr, "    -ad : Do Active directory provider testing\n");

        fprintf( stderr, "\nAnd where <options> are:\n\n" );

        for ( TestIndex=0; TestIndex<TEST_COUNT; TestIndex++ ) {
            fprintf( stderr, "    %s - %s\n", Tests[TestIndex].TestName, Tests[TestIndex].Description );
        }

        fprintf( stderr, "\nIf no options are specified, the following are implied:\n\n    " );

        for ( TestIndex=0; TestIndex<TEST_COUNT; TestIndex++ ) {
            if ( Tests[TestIndex].IsDefault) {
                fprintf( stderr, "%s ", Tests[TestIndex].TestName );
            }
        }

        fprintf( stderr, "\n" );
        return 1;
    }

    //
    // Done
    //
Cleanup:
    AzComUninitialize( ComState );
    printf( "\n\n" );
    if ( RetVal ) {
        printf( "Tests completed successfully!\n");
        return 0;
    } else {
        printf( "One or more tests failed.\n");
        return 1;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\tests\gmopen.inc ===
' global
Dim Prefix
Prefix = Array("", "    ", "        ", "            ")

Sub AzPrintCommon(Level, ObjName, Obj)
    If 0=Level Then
        'level 0 has no name
        WScript.Echo Prefix(Level) & ObjName & "(Description=" & Obj.Description & ")"
    Else
        WScript.Echo Prefix(Level) & ObjName & "(Name=" & Obj.Name & ", Description=" & Obj.Description & ")"
    End If
End Sub

Sub AzPrintAttr(Level, Obj, PId, PName)
    WScript.Echo Prefix(Level) & "  @ " & PName & "=" & Obj.GetProperty(PId, 0)
End Sub

Sub AzPrintItem(Level, Name, Item)
    WScript.Echo Prefix(Level) & "  / " & Name & "=" & Item
End Sub

Sub AzPrintAdmin(Lvl, Obj)
    Dim Writers, Readers, U

    AzPrintCommon Lvl, "AdminManager", Obj
    AzPrintAttr Lvl, Obj, AZ_PROP_ADMIN_DOMAIN_TIMEOUT, "AZ_PROP_ADMIN_DOMAIN_TIMEOUT"
    WScript.Echo "DOMAIN_TIMEOUT" & "=" & Obj.DomainTimeout
    AzPrintAttr Lvl, Obj, AZ_PROP_ADMIN_SCRIPT_ENGINE_TIMEOUT, "AZ_PROP_ADMIN_SCRIPT_ENGINE_TIMEOUT"
    WScript.Echo "SCRIPT_ENGINE_TIMEOUT" & "=" & Obj.ScriptEngineTimeout
    AzPrintAttr Lvl, Obj, AZ_PROP_ADMIN_MAX_SCRIPT_ENGINES, "AZ_PROP_ADMIN_MAX_SCRIPT_ENGINES"
    WScript.Echo "MAX_SCRIPT_ENGINES" & "=" & Obj.MaxScriptEngines

    Writers = Obj.PolicyAdministrators
    For Each U In Writers
        AzPrintItem Lvl, "PolicyAdministrator", U
    Next

    Readers = Obj.PolicyReaders
    For Each U In Readers
        AzPrintItem Lvl, "PolicyReader", U
    Next

    WScript.Echo ""
End Sub

Sub AzPrintApp(Lvl, Obj)
    AzPrintCommon Lvl, "Application", Obj
    AzPrintAttr Lvl, Obj, AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID, "AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID"
    WScript.Echo "AUTHZ_INTERFACE_CLSID" & "=" & Obj.AuthzInterfaceClsid
    AzPrintAttr Lvl, Obj, AZ_PROP_APPLICATION_VERSION, "AZ_PROP_APPLICATION_VERSION"
    WScript.Echo "VERSION" & "=" & Obj.Version
    WScript.Echo ""
End Sub

Sub AzPrintOp(Lvl, Obj)
    AzPrintCommon Lvl, "Operation", Obj
    AzPrintAttr Lvl, Obj, AZ_PROP_OPERATION_ID, "AZ_PROP_OPERATION_ID"
    WScript.Echo "OperationId" & "=" & Obj.OperationId
    WScript.Echo ""
End Sub

Sub AzPrintTask(Lvl, Obj)
    Dim Ops, Tasks

    AzPrintCommon Lvl, "Task", Obj
    AzPrintAttr Lvl, Obj, AZ_PROP_TASK_BIZRULE, "AZ_PROP_TASK_BIZRULE"
    WScript.Echo "Bizrule" & "=" & Obj.BizRule
    AzPrintAttr Lvl, Obj, AZ_PROP_TASK_BIZRULE_LANGUAGE, "AZ_PROP_TASK_BIZRULE_LANGUAGE"
    WScript.Echo "Bizrule Language" & "=" & Obj.BizRuleLanguage
    AzPrintAttr Lvl, Obj, AZ_PROP_TASK_BIZRULE_IMPORTED_PATH, "AZ_PROP_TASK_BIZRULE_IMPORTED_PATH"
    WScript.Echo "Bizrule Imported Path" & "=" & Obj.BizRuleImportedPath
    AzPrintAttr Lvl, Obj, AZ_PROP_TASK_IS_ROLE_DEFINITION, "AZ_PROP_TASK_IS_ROLE_DEFINITION"
    WScript.Echo "IsRoleDefintion" & "=" & Obj.IsRoleDefinition

    Ops = Obj.GetProperty(AZ_PROP_TASK_OPERATIONS, 0)
    For Each Op In Ops
        AzPrintItem Lvl, "OperationLink", Op
    Next

    Tasks = Obj.GetProperty(AZ_PROP_TASK_TASKS, 0)
    For Each Task In Tasks
        AzPrintItem Lvl, "TaskLink", Task
    Next
    WScript.Echo ""
End Sub

Sub AzPrintGroup(Lvl, Obj)
    Dim Mems, NonMems, AppMems, AppNonMems

    AzPrintCommon Lvl, "Group", Obj
    AzPrintAttr Lvl, Obj, AZ_PROP_GROUP_TYPE, "AZ_PROP_GROUP_TYPE"
    WScript.Echo "Type" & "=" & Obj.Type
    AzPrintAttr Lvl, Obj, AZ_PROP_GROUP_LDAP_QUERY, "AZ_PROP_GROUP_LDAP_QUERY"
    WScript.Echo "Ldap Query" & "=" & Obj.LdapQuery

    Mems = Obj.GetProperty(AZ_PROP_GROUP_MEMBERS, 0)
    For Each Mem In Mems
        AzPrintItem Lvl, "SidMember", Mem
    Next

    NonMems = Obj.GetProperty(AZ_PROP_GROUP_NON_MEMBERS, 0)
    For Each Mem In NonMems
        AzPrintItem Lvl, "SidNonMember", Mem
    Next

    AppMems = Obj.GetProperty(AZ_PROP_GROUP_APP_MEMBERS, 0)
    For Each Mem In AppMems
        AzPrintItem Lvl, "AppMemberLink", Mem
    Next

    AppNonMems = Obj.GetProperty(AZ_PROP_GROUP_APP_NON_MEMBERS, 0)
    For Each Mem In AppNonMems
        AzPrintItem Lvl, "AppNonMemberLink", Mem
    Next

    WScript.Echo ""
End Sub

Sub AzPrintScope(Lvl, Obj)
    AzPrintCommon Lvl, "Scope", Obj
    WScript.Echo ""
End Sub

Sub AzPrintRole(Lvl, Obj)
    Dim Mems, SidMems, Ops, Tasks

    AzPrintCommon Lvl, "Role", Obj

    Ops = Obj.GetProperty(AZ_PROP_ROLE_OPERATIONS, 0)
    For Each Op In Ops
        AzPrintItem Lvl, "OperationLink", Op
    Next

    Tasks = Obj.GetProperty(AZ_PROP_ROLE_TASKS, 0)
    For Each Task In Tasks
        AzPrintItem Lvl, "TaskLink", Task
    Next

    SidMems = Obj.GetProperty(AZ_PROP_ROLE_MEMBERS, 0)
    For Each Mem In SidMems
        AzPrintItem Lvl, "SidMember", Mem
    Next

    Mems = Obj.GetProperty(AZ_PROP_ROLE_APP_MEMBERS, 0)
    For Each Mem In Mems
        AzPrintItem Lvl, "AppMemberLink", Mem
    Next

    WScript.Echo ""
End Sub


Sub AzPrintPolicy(Admin)

    AzPrintAdmin 0, Admin

    ' navigate whole tree
    Dim Apps, App
    Set Apps=Admin.Applications
    For Each App In Apps
        AzPrintApp 1, App

        Dim Ops, Op
        Set Ops=App.Operations
        For Each Op In Ops
            AzPrintOp 2, Op
        Next

        Dim Tks, Tk
        Set Tks=App.Tasks
        For Each Tk In Tks
            AzPrintTask 2, Tk
        Next

        Dim Gps, Gp
        Set Gps=App.ApplicationGroups
        For Each Gp In Gps
            AzPrintGroup 2, Gp
        Next

        Dim Rls, Rl
        Set Rls=App.Roles
        For Each Rl In Rls
            AzPrintRole 2, Rl
        Next

        Dim Scs, Sc
        Set Scs=App.Scopes
        For Each Sc In Scs
            AzPrintScope 2, Sc

            Dim STks, STk
            Set STks=Sc.Tasks
            For Each STk In STks
                AzPrintTask 3, STk
            Next

            Dim SGps, SGp
            Set SGps=Sc.ApplicationGroups
            For Each SGp In SGps
                AzPrintGroup 3, SGp
            Next

            Dim SRls, SRl
            Set SRls=Sc.Roles
            For Each SRl In SRls
                AzPrintRole 3, SRl
            Next

            Set STks=Nothing
            Set SGps=Nothing
            Set SRls=Nothing
        Next

        Set Ops=Nothing
        Set Tks=Nothing
        Set Gps=Nothing
        Set Rls=Nothing
        Set Scs=Nothing

    Next


    Dim Groups, Group
    Set Groups=Admin.ApplicationGroups
    For Each Group In Groups
        AzPrintGroup 1, Group
    Next


    Set Groups=Nothing
    Set Apps=Nothing

End Sub 'AzPrintPolicy


Sub AzPrintPolicyFile(localXmlFile)

    Dim Admin

    WScript.Echo "Store = " & localXmlFile
    Set Admin=CreateObject("AzRoles.AzAdminManager")
    Admin.Initialize 0, localXmlFile
    WScript.Echo ""

    AzPrintPolicy Admin

    Set Admin=Nothing

End Sub 'AzPrintPolicyFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\tests\topenad.inc ===
' global
Dim Prefix
Prefix = Array("", "    ", "        ", "            ")

Sub AzPrintCommon(Level, ObjName, Obj)
    If 0=Level Then
        'level 0 has no name
        WScript.Echo Prefix(Level) & ObjName & "(Description=" & Obj.Description & ")"
    Else
        WScript.Echo Prefix(Level) & ObjName & "(Name=" & Obj.Name & ", Description=" & Obj.Description & ")"
    End If
End Sub

Sub AzPrintAttr(Level, Obj, PId, PName)
    WScript.Echo Prefix(Level) & "  @ " & PName & "=" & Obj.GetProperty(PId, 0)
End Sub

Sub AzPrintItem(Level, Name, Item)
    WScript.Echo Prefix(Level) & "  / " & Name & "=" & Item
End Sub

Sub AzPrintAdmin(Lvl, Obj)
    Dim Writers, Readers, U

    AzPrintCommon Lvl, "AdminManager", Obj
    AzPrintAttr Lvl, Obj, AZ_PROP_ADMIN_DOMAIN_TIMEOUT, "AZ_PROP_ADMIN_DOMAIN_TIMEOUT"
    AzPrintAttr Lvl, Obj, AZ_PROP_ADMIN_SCRIPT_ENGINE_TIMEOUT, "AZ_PROP_ADMIN_SCRIPT_ENGINE_TIMEOUT"
    AzPrintAttr Lvl, Obj, AZ_PROP_ADMIN_MAX_SCRIPT_ENGINES, "AZ_PROP_ADMIN_MAX_SCRIPT_ENGINES"
    AzPrintAttr Lvl, Obj, AZ_PROP_GENERATE_AUDITS, "AZ_PROP_GENERATE_AUDITS"

    Writers = Obj.PolicyAdministrators
    For Each U In Writers
        AzPrintItem Lvl, "PolicyAdministrator", U
    Next

    Readers = Obj.PolicyReaders
    For Each U In Readers
        AzPrintItem Lvl, "PolicyReader", U
    Next

    WScript.Echo ""
End Sub

Sub AzPrintApp(Lvl, Obj)
    AzPrintCommon Lvl, "Application", Obj
    AzPrintAttr Lvl, Obj, AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID, "AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID"
    AzPrintAttr Lvl, Obj, AZ_PROP_APPLICATION_VERSION, "AZ_PROP_APPLICATION_VERSION"
    AzPrintAttr Lvl, Obj, AZ_PROP_GENERATE_AUDITS, "AZ_PROP_GENERATE_AUDITS"

    Writers = Obj.PolicyAdministrators
    For Each U In Writers
        AzPrintItem Lvl, "PolicyAdministrator", U
    Next

    Readers = Obj.PolicyReaders
    For Each U In Readers
        AzPrintItem Lvl, "PolicyReader", U
    Next

    WScript.Echo ""
End Sub

Sub AzPrintOp(Lvl, Obj)
    AzPrintCommon Lvl, "Operation", Obj
    AzPrintAttr Lvl, Obj, AZ_PROP_OPERATION_ID, "AZ_PROP_OPERATION_ID"
    WScript.Echo ""
End Sub

Sub AzPrintTask(Lvl, Obj)
    Dim Ops, Tasks

    AzPrintCommon Lvl, "Task", Obj
    AzPrintAttr Lvl, Obj, AZ_PROP_TASK_BIZRULE, "AZ_PROP_TASK_BIZRULE"
    AzPrintAttr Lvl, Obj, AZ_PROP_TASK_BIZRULE_LANGUAGE, "AZ_PROP_TASK_BIZRULE_LANGUAGE"
    AzPrintAttr Lvl, Obj, AZ_PROP_TASK_BIZRULE_IMPORTED_PATH, "AZ_PROP_TASK_BIZRULE_IMPORTED_PATH"
    AzPrintAttr Lvl, Obj, AZ_PROP_TASK_IS_ROLE_DEFINITION, "AZ_PROP_TASK_IS_ROLE_DEFINITION"

    Ops = Obj.GetProperty(AZ_PROP_TASK_OPERATIONS, 0)
    For Each Op In Ops
        AzPrintItem Lvl, "OperationLink", Op
    Next

    Tasks = Obj.GetProperty(AZ_PROP_TASK_TASKS, 0)
    For Each Task In Tasks
        AzPrintItem Lvl, "TaskLink", Task
    Next
    WScript.Echo ""
End Sub

Sub AzPrintGroup(Lvl, Obj)
    Dim Mems, NonMems, AppMems, AppNonMems

    AzPrintCommon Lvl, "Group", Obj
    AzPrintAttr Lvl, Obj, AZ_PROP_GROUP_TYPE, "AZ_PROP_GROUP_TYPE"
    AzPrintAttr Lvl, Obj, AZ_PROP_GROUP_LDAP_QUERY, "AZ_PROP_GROUP_LDAP_QUERY"

    Mems = Obj.GetProperty(AZ_PROP_GROUP_MEMBERS, 0)
    For Each Mem In Mems
        AzPrintItem Lvl, "SidMember", Mem
    Next

    NonMems = Obj.GetProperty(AZ_PROP_GROUP_NON_MEMBERS, 0)
    For Each Mem In NonMems
        AzPrintItem Lvl, "SidNonMember", Mem
    Next

    AppMems = Obj.GetProperty(AZ_PROP_GROUP_APP_MEMBERS, 0)
    For Each Mem In AppMems
        AzPrintItem Lvl, "AppMemberLink", Mem
    Next

    AppNonMems = Obj.GetProperty(AZ_PROP_GROUP_APP_NON_MEMBERS, 0)
    For Each Mem In AppNonMems
        AzPrintItem Lvl, "AppNonMemberLink", Mem
    Next

    WScript.Echo ""
End Sub

Sub AzPrintScope(Lvl, Obj)
    AzPrintCommon Lvl, "Scope", Obj

    Writers = Obj.PolicyAdministrators
    For Each U In Writers
        AzPrintItem Lvl, "PolicyAdministrator", U
    Next

    Readers = Obj.PolicyReaders
    For Each U In Readers
        AzPrintItem Lvl, "PolicyReader", U
    Next

    WScript.Echo ""
End Sub

Sub AzPrintRole(Lvl, Obj)
    Dim Mems, SidMems, Ops, Tasks

    AzPrintCommon Lvl, "Role", Obj

    Ops = Obj.GetProperty(AZ_PROP_ROLE_OPERATIONS, 0)
    For Each Op In Ops
        AzPrintItem Lvl, "OperationLink", Op
    Next

    Tasks = Obj.GetProperty(AZ_PROP_ROLE_TASKS, 0)
    For Each Task In Tasks
        AzPrintItem Lvl, "TaskLink", Task
    Next

    SidMems = Obj.GetProperty(AZ_PROP_ROLE_MEMBERS, 0)
    For Each Mem In SidMems
        AzPrintItem Lvl, "SidMember", Mem
    Next

    Mems = Obj.GetProperty(AZ_PROP_ROLE_APP_MEMBERS, 0)
    For Each Mem In Mems
        AzPrintItem Lvl, "AppMemberLink", Mem
    Next

    WScript.Echo ""
End Sub


Sub AzPrintPolicy(Admin)

    AzPrintAdmin 0, Admin

    ' navigate whole tree
    Dim Apps, App
    Set Apps=Admin.Applications
    For Each App In Apps
        AzPrintApp 1, App

        Dim Ops, Op
        Set Ops=App.Operations
        For Each Op In Ops
            AzPrintOp 2, Op
        Next

        Dim Tks, Tk
        Set Tks=App.Tasks
        For Each Tk In Tks
            AzPrintTask 2, Tk
        Next

        Dim Gps, Gp
        Set Gps=App.ApplicationGroups
        For Each Gp In Gps
            AzPrintGroup 2, Gp
        Next

        Dim Rls, Rl
        Set Rls=App.Roles
        For Each Rl In Rls
            AzPrintRole 2, Rl
        Next

        Dim Scs, Sc
        Set Scs=App.Scopes
        For Each Sc In Scs
            AzPrintScope 2, Sc

            Dim STks, STk
            Set STks=Sc.Tasks
            For Each STk In STks
                AzPrintTask 3, STk
            Next

            Dim SGps, SGp
            Set SGps=Sc.ApplicationGroups
            For Each SGp In SGps
                AzPrintGroup 3, SGp
            Next

            Dim SRls, SRl
            Set SRls=Sc.Roles
            For Each SRl In SRls
                AzPrintRole 3, SRl
            Next

            Set STks=Nothing
            Set SGps=Nothing
            Set SRls=Nothing
        Next

        Set Ops=Nothing
        Set Tks=Nothing
        Set Gps=Nothing
        Set Rls=Nothing
        Set Scs=Nothing

    Next


    Dim Groups, Group
    Set Groups=Admin.ApplicationGroups
    For Each Group In Groups
        AzPrintGroup 1, Group
    Next


    Set Groups=Nothing
    Set Apps=Nothing

End Sub 'AzPrintPolicy


Sub AzPrintADPolicy(url)

    Dim Admin

    WScript.Echo "Store = " & url
    Set Admin=CreateObject("AzRoles.AzAdminManager")
    Admin.Initialize 0, url
    WScript.Echo ""
    WScript.Echo "Admin Initialized"
    AzPrintPolicy Admin

    Set Admin=Nothing

End Sub 'AzPrintADPolicy
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\audit\exts\adtexts.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        N E W E X T . C
//
// Contents:    LSA debugger extensions that use the new style 
//              extension API.
//
//
// History:     
//   07-January-2000  kumarp        created
//
// Note:
// 
// If you want to add extensions to this file, read the following
// guidelines from andreva first:
//
// Everyone who debugs or runs stress will expect debugger extensions 
// to work on both 32 bit and 64 bit TARGETS.  The Debugger extensions must 
// therefore be TARGET independent.  We the only viable solution to this is to 
// get structure definitions from the symbol information, instead of 
// from the header file.  So the way we solve this problem is:
//
// - A debugger extension can only include windows.h and wdbgexts.h
// - A debugger extensions NEVER includes header files from 
//   the component it tries to analyze\debug.
// - Debugger extensions use the new routines we provide to query 
//   type information.
//
//------------------------------------------------------------------------

#include <windows.h>
#include <dbghelp.h>
#define KDEXT_64BIT
#include <wdbgexts.h>
#include <ntverp.h>

// ----------------------------------------------------------------------
//
// globals
//
WINDBG_EXTENSION_APIS   ExtensionApis;
EXT_API_VERSION         ApiVersion =
{
    (VER_PRODUCTVERSION_W >> 8),
    (VER_PRODUCTVERSION_W & 0xff),
    EXT_API_VERSION_NUMBER64,
    0
};
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

// ----------------------------------------------------------------------
//
// The following 3 functions must be present in the extension dll.
// They were lifted straight from base\tools\kdexts\kdexts.c
//
VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis, // 64Bit Change
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

VOID
CheckVersion(
    VOID
    )
{
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
// ----------------------------------------------------------------------


BOOL
GetGlobalVar (
    IN  PUCHAR   Name, 
    IN  USHORT   Size,
    OUT PVOID    pOutValue
   ) 
/*++

Routine Description:

    Get value of global vars of primitive type OR
    Get the address instead for non-primitive global vars.

    Primitive type is defined as the one not-involving any struct/union
    in its type definition. Pointer to struct/unions are ok.
    for example: USHORT, ULONG, PVOID etc.

Arguments:

    Name      - global var name
                (for example: "lsasrv!LsapAdtContextList")

    Size      - size in bytes for primitive types, 0 otherwise

    pOutValue - pointer to return val.

Return Value:

    TRUE on success, FALSE otherwise

Notes:

--*/
{
    ULONG64 Temp=0;

    SYM_DUMP_PARAM Sym =
    {
        sizeof (SYM_DUMP_PARAM),
        Name,
        DBG_DUMP_NO_PRINT | DBG_DUMP_COPY_TYPE_DATA,
        0, 
        NULL,
        &Temp,
        NULL,
        0,
        NULL
    };

    ULONG RetVal;

    RetVal = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );

    //
    // store only the correct number of bytes from the value read
    //
    switch(Size)
    {
        default:
        case 0:
            *((PUCHAR*) pOutValue)  = (PUCHAR) Sym.addr;
            break;

        case 1:
            *((UCHAR*) pOutValue)   = (UCHAR) Temp;
            break;
            
        case 2:
            *((USHORT*) pOutValue)  = (USHORT) Temp;
            break;
            
        case 4:
            *((DWORD*) pOutValue)   = (DWORD) Temp;
            break;
            
        case 8:
            *((ULONG64*) pOutValue) = Temp;
            break;
    }
   
   return (RetVal == NO_ERROR);
}

//
// helper macro to get field of AUDIT_CONTEXT struct
//
#define GetAuditContextField(addr,f)    \
          GetFieldData( (ULONG64) addr, \
                        "AUDIT_CONTEXT",\
                        #f,             \
                        sizeof(f),      \
                        &f )

//
// helper macro to get LIST_ENTRY.Flink
//
#define GetFlink(addr,pflink) \
          GetFieldData( addr,\
                        "LIST_ENTRY", \
                        "Flink",\
                        sizeof(ULONG64),\
                        pflink )
void
DumpAuditContextList(
    )
/*++

Routine Description:

    Dump the audit context list.

Arguments:
    None

Return Value:

    None

Notes:
    It appears that there is a built in support for dumping
    lists using SYM_DUMP_PARAM.listLink but I came to know about it too late.

--*/
{
    LIST_ENTRY LsapAdtContextList = { (PLIST_ENTRY) 22, (PLIST_ENTRY) 33 };
    ULONG64    pLsapAdtContextList=0;
    ULONG      LsapAdtContextListCount=0;
    ULONG64    Temp=0;
    ULONG64    Scan=0;
    ULONG64    Link=0;
    USHORT     CategoryId;
    USHORT     AuditId;
    USHORT     ParameterCount;
    
    ULONG Status=NO_ERROR;
    ULONG i;

    if (!GetGlobalVar( "lsasrv!LsapAdtContextListCount",
                       sizeof(LsapAdtContextListCount),
                       &LsapAdtContextListCount ))
    {
        goto Cleanup;
    }

    dprintf( "# contexts: %ld\n", LsapAdtContextListCount );

    if ( ((LONG) LsapAdtContextListCount) < 0 )
    {
        dprintf("...List/ListCount may be corrupt\n");
        goto Cleanup;
    }

    if ( LsapAdtContextListCount == 0 )
    {
        goto Cleanup;
    }

    if (!GetGlobalVar( "lsasrv!LsapAdtContextList",
                       0,
                       &pLsapAdtContextList ))
    {
        dprintf("...error reading lsasrv!LsapAdtContextList\n");
        goto Cleanup;
    }
    
    Status = GetFlink( pLsapAdtContextList, &Scan );
    if ( Status != NO_ERROR )
    {
        dprintf("...error reading lsasrv!LsapAdtContextList.Flink\n");
        goto Cleanup;
    }

    dprintf("LsapAdtContextList @ %p\n", pLsapAdtContextList);
    
    for (i=0; i < LsapAdtContextListCount; i++)
    {
        dprintf("%02d) [%p]: ", i, Scan);
        
        if ( Scan == pLsapAdtContextList )
        {
            dprintf("...pre-mature end of list\nList/ListCount may be corrupt\n");
            break;
        }
        else if ( Scan == 0 )
        {
            dprintf("...NULL list element found!\nList/ListCount may be corrupt\n");
            break;
        }

        Status = GetAuditContextField( Scan, CategoryId );
                        
        if ( Status != NO_ERROR )
        {
            dprintf("...error reading AUDIT_CONTEXT.CategoryId\n");
            break;
        }

        dprintf("Category: %03x\t", CategoryId);
        
        Status = GetAuditContextField( Scan, AuditId );
                        
        if ( Status != NO_ERROR )
        {
            dprintf("...error reading AUDIT_CONTEXT.AuditId\n");
            break;
        }

        dprintf("AuditId: %03x\t", AuditId);
        
        Status = GetAuditContextField( Scan, Link );
        if ( Status != NO_ERROR )
        {
            dprintf("...error reading AUDIT_CONTEXT.Link\n");
            break;
        }
            
        Status = GetFlink( Link, &Scan );
        if ( Status != NO_ERROR )
        {
            goto Cleanup;
        }

        dprintf("\n");
    }

Cleanup:
    if ( Status != NO_ERROR )
    {
        dprintf("...failed\n");
    }
}

DECLARE_API(AuditContexts)
{
    DumpAuditContextList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\tests\aztest.cs ===
using System;
using System.Runtime.InteropServices;
using System.Security.Principal;
using Microsoft.Interop.Security.AzRoles;
using System.Xml;
using System.Threading;


namespace AzCSharpTest
{
    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    class AzTestEntry
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [MTAThread]
        static void Main(string[] args)
        {
            // if asked for or wrong syntax, do the usage
            if (args.Length < 2 || args.Length > 3 || args[0] == "?" || args[0] == "/?")
            {
                DoUsage();
                return;
            }

            Console.WriteLine("This C# program tests AzRoles managed wrapper");
            try
            {
                // we will read the XML data file for the test

                XmlDocument xmlTestDataDoc = new XmlDocument();
                XmlDocument xmlBaseStoreDoc = new XmlDocument();

                if (xmlTestDataDoc == null || xmlBaseStoreDoc == null)
                {
                    Exception exp = new Exception("Can't create XML documents. Testing aborted.");
                    throw exp;

                }
                
                //
                // test data file is the first argument, and the base store
                // XML document is the second parameter
                //

                xmlTestDataDoc.Load(args[0]);
                xmlBaseStoreDoc.Load(args[1]);

                AzTestMode tm = AzTestMode.PrintAll;
                if (args.Length == 3)
                {
                    //
                    // this may not be a valid string for numbers we can accept
                    // will throw in that case
                    
                    tm = (AzTestMode)(Convert.ToInt32(args[2]));
                }

                Console.WriteLine("");
                Console.WriteLine("Test data and base XML AzRole Store are loaded successfully.");

                CAzRolesTest azTest = new CAzRolesTest(xmlTestDataDoc, xmlBaseStoreDoc);

                azTest.TestAzRoles(tm);
            }
            catch (Exception e)
            {
                Console.WriteLine("Exception occurs " + e.Message + "\r\n" + e.StackTrace);
            }
            finally 
            {
                GC.Collect();
            }
        }

        static void DoUsage()
        {
            Console.WriteLine("To use AzCSharpTest, use the following command:");
            Console.WriteLine("");

            Console.WriteLine("AzCSharpTest.exe TestInstructionFile BaseXMLStoreURL [EchoMode]");

            Console.WriteLine("");
            Console.WriteLine("  Where");
            Console.WriteLine("     TestInstructionFile is the XML file describing how to test.");
            Console.WriteLine("     BaseXMLStoreURL is the XML on which this test will be based on.");
            Console.WriteLine("     Optional EchoMode is default to 5, and can be one of the following values:");
            Console.WriteLine("         1 for echoing error messages only,");
            Console.WriteLine("         2 for echoing warning messages only,");
            Console.WriteLine("         3 for echoing informational messages only,");
            Console.WriteLine("         4 for echoing success messages only,");
            Console.WriteLine("         5 for echoing all messages.");
        }

    }

    enum AzTestMode
    {
        PrintFailure = 1,
        PrintWarning = 2,
        PrintMessage = 3,
        PrintSuccess = 4,
        PrintAll     = 5
    }

    enum AzTestMethod
    {
        PutProp = 1,
        GetProp = 2,
        ExeMethod = 3
    }

    enum AzTestResult
    {
        Success = 1,
        Failure = 2,
        Warning = 3,
        Message = 4
    }

    enum AzTestCase
    {
        Create = 1,
        Open = 2,
        AccessCheck = 3
    }

    //
    // this is the object that our main routine creates to start the test.
    // Call TestAzRoles to do the start testing.
    // This class also has a call back for test results (TestResult)
    //

    class CAzRolesTest
    {
        private int m_iFailureCount;
        private int m_iSuccessCount;
        private int m_iWarningCount;
        private AzTestMode m_TestMode = AzTestMode.PrintFailure;
        
        private XmlDocument m_docTestData;
        private XmlDocument m_docBaseStoreDoc;

        //
        // Our object needs to know two XML document, the first one
        // being the testing instruction XML, and the second one being the 
        // data store (which is exactly an AzRoles XML store). Our test
        // usually consists of three steps:
        //  (1) create a copy of this XML store (second parameter); 
        //  (2) open the newly created store (by our test) and compare the results
        //  (3) Do access check test.
        // The whole test is not hard coded, instead, it is driven by the 
        // testing instruction XML (first parameter). See samples for
        // the schema of this xml file.
        //
        public CAzRolesTest(XmlDocument xmlTestData, XmlDocument xmlStore)
        {
            m_docTestData = xmlTestData;
            m_docBaseStoreDoc = xmlStore;

            m_iSuccessCount = 0;
            m_iFailureCount = 0;
            m_iWarningCount = 0;
        }

        //
        // determines if the given result needs to be echoed to the console
        //
        private bool NeedEcho(AzTestResult atr)
        {
            if (m_TestMode == AzTestMode.PrintAll)
                return true;

            if (atr == AzTestResult.Success)
                return (m_TestMode == AzTestMode.PrintSuccess);
            else if (atr == AzTestResult.Failure)
                return (m_TestMode == AzTestMode.PrintFailure);
            else if (atr == AzTestResult.Warning)
                return (m_TestMode == AzTestMode.PrintWarning);
            else if (atr == AzTestResult.Message)
                return (m_TestMode == AzTestMode.PrintMessage);
            else
                return true;
        }


        //
        // callback for test result
        //
        public void TestResult(AzTestResult atr, string strMsg)
        {
            bool bNeedEcho = NeedEcho(atr);

            string strFinalMsg = "";
            
            if (atr == AzTestResult.Success)
            {
                if (bNeedEcho)
                    strFinalMsg = "---Success--- " + strMsg;
                m_iSuccessCount++;
            }
            else if (atr == AzTestResult.Warning)
            {
                if (bNeedEcho)
                    strFinalMsg = "---Warning--- " + strMsg;
                m_iWarningCount++;
            }
            else if (atr == AzTestResult.Message)
            {
                if (bNeedEcho)
                    strFinalMsg = "-----FYI----- " + strMsg;
            }
            else
            {
                if (bNeedEcho)
                    strFinalMsg = "***Failure*** " + strMsg;
                m_iFailureCount++;
            }

            if (bNeedEcho)
            {
                Console.WriteLine(strFinalMsg);
            }
        }


        //
        // retrive the given named attribute as a integer
        //
        private int GetIntAttribute(XmlNode xNode, string strAttrName, int defIfMissing)
        {
            XmlNode xAttriNode = xNode.Attributes.GetNamedItem(strAttrName);
            if (xAttriNode != null)
                return Convert.ToInt32(xAttriNode.Value);
            else
                return defIfMissing;
        }

        
        //
        // this function kicks out the testing
        //
        public void TestAzRoles(AzTestMode tm)
        {
            m_TestMode = tm;
            try
            {
                // we know that we only have one AzAuthorizationStore node on an AzRoles XML store.

                XmlNode xStoreAdmin = m_docBaseStoreDoc.SelectSingleNode("AzAdminManager");

                int iCreate = Convert.ToInt32(tagAZ_PROP_CONSTANTS.AZ_AZSTORE_FLAG_CREATE);
                int iManage = Convert.ToInt32(tagAZ_PROP_CONSTANTS.AZ_AZSTORE_FLAG_MANAGE_STORE_ONLY);

                // The root of our test instruction XML file is CSharpTestData

                XmlNode xTestRoot = m_docTestData.SelectSingleNode("CSharpTestData");

                // we might be creating a new store and use it for get property test or
                // access check test
                AzAuthorizationStoreClass azStoreNew = null;

                // We must do a create first. There is a single (so far) element called
                // AzAdminCreate, which decides how to create this target new store.
                // The most important attribute of this node is Url, which is the target
                // AzRoels store's url. If this URL points to an AD store, this test
                // will create an AD store.
                XmlNode xAdminNode = xTestRoot.SelectSingleNode("AzAdminCreate");

                CAzTestAzStore.OnTestResult onResult = new CAzTest.OnTestResult(this.TestResult);

                string strUrl = null;
                if (xAdminNode != null)
                {
                    // The flag used to initialize the new store we need to create
                    int flagAzCreate = GetIntAttribute(xAdminNode, "CreateFlag", 0);

                    // Whether a new store will be created or not. We must eventually support
                    // exporting data only, not a brand new store. Currently, we only tested
                    // creating a new store.
                    bool bCreateStore = Convert.ToBoolean(CAzTest.GetAttribute(xAdminNode, "CreateStore", true));

                    // Get the new store's URL and create a brand new one

                    azStoreNew = new AzAuthorizationStoreClass();
                    strUrl = CAzTest.GetAttribute(xAdminNode, "Url", true);
                    CAzTestAzStore.CreateTargetStore(strUrl, bCreateStore, flagAzCreate, ref azStoreNew);

                    // Hook up the callback
                    CAzTestAzStore TestAzStore = new CAzTestAzStore(azStoreNew, onResult, AzTestCase.Create);

                    // Test the creation
                    TestAzStore.StartTest(xStoreAdmin, xStoreAdmin);

                    // resolve the link properties

                    TestAzStore.UpdateLinkProperties(xStoreAdmin, xStoreAdmin);
                }

                // now do the open test. Right now, we don't use any attribute. The mere existence
                // of this element signals that we want to conduct a store wise verification of the
                // newly put data in the new store
                XmlNodeList xList = m_docTestData.GetElementsByTagName("AzAdminOpen");
                if (xList != null)
                {
                    foreach (XmlNode n in xList)
                    {
                        DoOpenACTest(azStoreNew, onResult, AzTestCase.Open, xStoreAdmin, n);
                    }
                }

                // Do access check test.
                xList = m_docTestData.GetElementsByTagName("AzAdminTest");

                if (xList != null)
                {
                    foreach (XmlNode n in xList)
                    {
                        DoOpenACTest(azStoreNew, onResult, AzTestCase.AccessCheck, xStoreAdmin, n);
                    }
                }
            }
            catch (Exception e)
            {
                TestResult(AzTestResult.Failure, e.Message + e.StackTrace);
            }
            finally
            {
                Console.WriteLine("");

                Console.WriteLine("Test completed with {0} successes.", m_iSuccessCount);
                Console.WriteLine("Test completed with {0} warnings.", m_iWarningCount);
                Console.WriteLine("Test completed with {0} errors.", m_iFailureCount);
            }
        }

        private void DoOpenACTest(AzAuthorizationStoreClass azStore, CAzTestAzStore.OnTestResult onResult, 
                                    AzTestCase atc, XmlNode xStoreAdmin, XmlNode xTestNode)
        {
            object obReserved = null;

            // if this node doesn't have a Url attribute, then it means that
            // we are going to use the newly created store.
            // Ultimately, we want to support the Open phase to optionally use it's own URL.
            // But the problem that XML eats insignificant white characters make our
            // straightforward string comparision fail in those cases where insignificant
            // white characters are eaten by XML.

            string strUrl = null;

            //
            // We don't support the open testing to support its own URL at this time
            //
            if (atc == AzTestCase.AccessCheck)
            {
                strUrl = CAzTest.GetAttribute(xTestNode, "Url", false);
            }

            AzAuthorizationStoreClass azStoreOpen = null;
            if (strUrl != null)
            {
                azStoreOpen = new AzAuthorizationStoreClass();
                azStoreOpen.Initialize(0, strUrl, obReserved);
            }
            else
            {
                azStoreOpen = azStore;// if no Url attribute, then we must use the given one
            }
            if (azStoreOpen == null)
            {
                Exception eNoAdmin = new Exception("No AzAuthorizationStore to do open test");
                throw eNoAdmin;
            }
            CAzTestAzStore TestAzStore = new CAzTestAzStore(azStoreOpen, onResult, atc);
            if (atc == AzTestCase.Open)
                TestAzStore.StartTest(null, xStoreAdmin);
            else if (atc == AzTestCase.AccessCheck)
                TestAzStore.StartTest(null, xTestNode);
            else 
            {
                Exception e = new Exception("DoOpenACTest called with invalid AzTestCase parameter");
                throw e;
            }
        }

    }

    struct PropIDAndName
    {
        public PropIDAndName(tagAZ_PROP_CONSTANTS id, string name)
        {
            ID = id;
            strName = name;
        }
        public tagAZ_PROP_CONSTANTS ID;
        public string strName;
    }


    // This is the base interface of our test objects. Since our COM objects
    // do not have a common interface base, we have to invent a new interface
    // which all our test objects (one for each of our objects) implements
    // For example, even the simple GetProperty/SetProperty must be done this
    // way because our IAzXXX do not share a common base interface unless we 
    // will use Invoke to call a method, which is way too complicated.
    interface IAzTest
    {
        // this is to kick out the creation (put) and open (get) tests
        void StartTest(XmlNode xNodeAdmin, XmlNode xNode);

        // this is to kick out the access check test
        void TestAccessCheck(XmlNode xNode);

        // Link properties must be done after the creation is complete
        void UpdateLinkProperties(XmlNode xAdminNode, XmlNode xNode);

        // for echo purposes
        string GetObjectTypeName();
        string GetObjectName();
        void SendWarning(string msg);
        void SendMessage(string msg, bool bCritical);
        void SendTestResult(AzTestMethod atm, bool bSuccess, string strObjType, string strObjName, string strAttr, string strValue, string msg);

        // Some properties of our objects are saved as attributes of the node.
        // But others are saved as sub-elements. This creates a problem for us
        // to do a good OO design. We ask each object to return its own IDs and
        // Names of such properties
        PropIDAndName[] GetPropSubnodesIDAndNames();
        PropIDAndName[] GetPropAttributeIDAndNames();

        // Different IAzXXX objects have different sets of objects they can contain
        // This returns all objects names of such children objects.
        string[] GetChildObjectNames();

        // Set/Get Property must go through each individual object instead of using
        // polymorphism. 
        void SetProperty(tagAZ_PROP_CONSTANTS PropID, string strValue);
        object GetProperty(tagAZ_PROP_CONSTANTS PropID);
        bool FindProperty(tagAZ_PROP_CONSTANTS propID, string strValue);

        // Although each or our IAzXXX object has a Submit method, they are not polymorphic
        // I certainly wish C# has templates as C++ does.
        void Submit(int i);

        // Again, in order for us to do most repeatitive work in the base, each test
        // object must tell us what children test object it can create/open.
        IAzTest GetTestObjectByName(string strEleName, string strObjName, bool bCreateNew);
    }

    // Most of the functionality of our testing objects are implemented by this base object
    // For each IAzXXX, we have a CAzTestXXX class that does the testing for that IAzXXX object.
    // All these CAzTestXXX are derived from CAzTest base class.
    abstract class CAzTest : IAzTest
    {
        // for call back
        protected OnTestResult m_resultCallback;
        public delegate void OnTestResult(AzTestResult atr, string strMsg);

        // this is our test case (create, open, or access check)
        protected AzTestCase m_atcCase;

        // constructor.
        public CAzTest(OnTestResult resultCallback, AzTestCase testCase)
        {
            m_resultCallback = resultCallback;
            m_atcCase = testCase;
        }


        // some XML helpers
        public static string GetSubElementAttribute(XmlNode nAC, 
            string strSubNodeName, 
            string strAttribName,
            bool bThrowIfMissing)
        {
            try 
            {
                XmlNode appNode = nAC.SelectSingleNode(strSubNodeName);
                return appNode.Attributes[strAttribName].Value;
            }
            catch (Exception e)
            {
                if (bThrowIfMissing)
                {
                    Exception Exp = new Exception("Missing " + strSubNodeName + " node or " +
                        strAttribName + " attribute for access check.\r\n" + e.StackTrace);
                    throw Exp;
                }
                else
                {
                    return null;
                }
            }
        }

        public static string GetAttribute(XmlNode nAC, string strAttribName, bool bThrowIfMissing)
        {
            try 
            {
                return nAC.Attributes[strAttribName].Value;
            }
            catch (Exception e)
            {
                if (bThrowIfMissing)
                {
                    Exception eExp = new Exception("Node " + nAC.Name + " is missing attribute " + strAttribName +
                        "\r\n" + e.StackTrace);
                    throw eExp;
                }
                else
                {
                    return null;
                }
            }
        }

        //
        // This is a helper to walk through the XML dom tree to find a
        // particular node with the given guid attribute.
        //
        // *******Warning*******
        //   The algorithm is pretty lazy and slow. When we evolve this
        //   program into a released tool, we need to pay attention
        //   to this kind of slow algorithm and use something faster
        // *******Warning*******
        //

        protected string FindObjectNameByGuid(XmlNode xFindRootNode, string strGuid)
        {
            string strName = null;

            //
            // see if any immediate child has a matching guid.
            //

            foreach (XmlNode n in xFindRootNode.ChildNodes)
            {
                if (n.Attributes == null)
                    continue;

                XmlNode attrNode = n.Attributes.GetNamedItem("Guid");
                if (attrNode != null && attrNode.Value.ToUpper() == strGuid.ToUpper())
                {
                    //
                    // we found it, but don't assume that the name is there
                    //

                    if (n.Attributes["Name"] != null)
                        strName = n.Attributes["Name"].Value;
                    
                    if (strName == null)
                    {
                        //
                        // this is a serious error
                        //

                        Exception e = new Exception("CAzTest.FindNameByBuid no name for " + strGuid);
                        throw e;
                    }

                    return strName;
                }
                else
                {
                    //
                    // no match, then do the recursive search
                    //

                    strName = FindObjectNameByGuid(n, strGuid);
                    if (strName != null)
                    {
                        break;
                    }
                }
            }

            return strName;
        }


        //
        // all of our GetProperty functions will return object. But we only
        // has three different possible values: string, int, and boolean.
        // This function tests if the object is equal to the string representation
        // of the value.
        //

        protected bool ObjectEqualToStringValue(object ob, string strVal)
        {
            System.Type t = ob.GetType();
            if (t == System.Type.GetType("System.String"))
            {
                string strUpperVal = strVal.ToUpper();
                string strUpperGet = ob.ToString().ToUpper();
                return ((strUpperVal.Length == 0 && strUpperGet.Length == 0) || (strUpperVal == strUpperGet));
            }
            else if (t == System.Type.GetType("System.Int32"))
            {
                int iVal = Convert.ToInt32(strVal);
                return (iVal == (int)ob);
            }
            else if (t == System.Type.GetType("System.Boolean"))
            {
                bool b = Convert.ToBoolean(strVal);
                return (b == (bool)ob);
            }
            return false;
        }

        // For echoing purposes. Sub classes should not implement them.
        public void SendWarning(string msg)
        {
            m_resultCallback(AzTestResult.Warning, msg);
        }

        public void SendMessage(string msg, bool bCritical)
        {
            AzTestResult atr = AzTestResult.Message;
            if (bCritical)
                atr = AzTestResult.Failure;
            m_resultCallback(atr, msg);
        }

        public void SendTestResult(AzTestMethod atm, 
            bool bSuccess, 
            string strObjType,
            string strObjName,
            string strAttr, 
            string strValue, 
            string strReason)
        {
            string message;
            string strMethod;

            if (atm == AzTestMethod.PutProp)
            {
                strMethod = "    Setting (" + strAttr + ") to (" + strValue + ") on " + strObjName + "\r\n";
            }
            else if (atm == AzTestMethod.GetProp)
            {
                strMethod = "    Getting (" + strAttr + ") as (" + strValue + ") on " + strObjName + "\r\n";
            }
            else
            {
                strMethod = "    Executing " + strAttr + " on " + strObjName + "\r\n";
            }

            if (bSuccess)
            {
                message = "The following operation on " + strObjType + " has succeeded:\r\n" + strMethod;
            }
            else
            {
                message = "The following operation on " + strObjType + " has failed:\r\n" + strMethod;
                message += "    Reason: " + strReason;
            }
            m_resultCallback((bSuccess ? AzTestResult.Success : AzTestResult.Failure), message);
        }


        // We expect some sub classes to override these implementations.
        // But other leaf objects don't need to, and we provide convenient
        // implementation for them. Note, we will return null and the caller
        // should expect that.
        virtual public string[] GetChildObjectNames()
        {
            return null;
        }

        virtual public IAzTest GetTestObjectByName(string strEleName, string strObjName, bool bCreateNew)
        {
            return null;
        }

        // sub class must implement these functions. We don't know hot to implement them.

        public abstract string GetObjectTypeName();
        public abstract string GetObjectName();
        public abstract void Submit(int i);
        public abstract void SetProperty(tagAZ_PROP_CONSTANTS PropID, string strValue);
        public abstract object GetProperty(tagAZ_PROP_CONSTANTS PropID);

        //
        // Some of our properties returned from GetProperty will be arrays. While
        // the test can only give one string value a time, we need to walk through
        // the entire array to seek a match.
        // Aslo, GroupType attribute of a app group object records string value "LdapQuery"
        // but we will get 1 for "LdapQuery" group type when calling GetProperty
        //

        public virtual bool FindProperty(tagAZ_PROP_CONSTANTS propID, string strValue)
        {
            object obValue = GetProperty(propID);
            if (obValue != null)
            {
                System.Type t = obValue.GetType();

                // if not an array, then do straightforward comparison
                if (!t.IsArray)
                {
                    if (propID == tagAZ_PROP_CONSTANTS.AZ_PROP_GROUP_TYPE)
                    {
                        strValue = (strValue == "LdapQuery") ? "1" : "0";
                    }
                    return ObjectEqualToStringValue(obValue, strValue);
                }
                else
                {
                    // compare with each element until we found a match
                    Array ar = obValue as Array;
                    foreach (object ob in ar)
                    {
                        if (ObjectEqualToStringValue(ob, strValue))
                            return true;
                    }
                    return false;
                }
            }
            return false;
        }

        public virtual PropIDAndName[] GetLinkIDAndNames()
        {
            return null;
        }

        public virtual PropIDAndName[] GetPropSubnodesIDAndNames()
        {
            return null;
        }
        public virtual PropIDAndName[] GetPropAttributeIDAndNames()
        {
            return null;
        }

        virtual public void StartTest(XmlNode xNodeAdmin, XmlNode xNode)
        {
            if (m_atcCase == AzTestCase.Create)
            {
                TestCreateOpen(xNodeAdmin, xNode, true);
            }
            else if (m_atcCase == AzTestCase.Open)
            {
                TestCreateOpen(xNodeAdmin, xNode, false);
            }
            else    // access check
            {
                TestAccessCheck(xNode);
            }
        }

        virtual public void TestAccessCheck(XmlNode xNode)
        {
            ;    // only admin manager knows how to conduct an access check
        }

        protected void TestCreateOpen(XmlNode xNodeAdmin, XmlNode xNode, bool bCreate)
        {
            // create all properties based on the data file's attributes

            AzTestMethod atmPutGet = bCreate ? AzTestMethod.PutProp : AzTestMethod.GetProp;

            bool bDoneSomething = false;
            PropIDAndName[] IdsAndNames = GetPropAttributeIDAndNames();
            if (IdsAndNames != null)
            {
                foreach (PropIDAndName IdName in IdsAndNames)
                {
                    string strValue = "";
                    try
                    {
                        // we allow the attribute to be missing. So, don't throw if can't find it

                        strValue = GetAttribute(xNode, IdName.strName, false);
                        if (strValue != null)
                        {
                            if (bCreate)
                            {
                                SetProperty(IdName.ID, strValue);
                                bDoneSomething = true;
                            }
                            else
                            {
                                if (!FindProperty(IdName.ID, strValue))
                                {
                                    string strMsg = "Property " + IdName.strName + " with value " + strValue + " is missing";
                                    Exception mismatchExp = new Exception(strMsg);
                                    throw mismatchExp;
                                }
                            }
                            SendTestResult(atmPutGet, true, GetObjectTypeName(), GetObjectName(), IdName.strName, strValue, "");
                        }
                        else
                        {
                            SendMessage("The following attribute " + IdName.strName + " is missing on " + GetObjectName(), false);
                        }
                    }
                    catch (Exception eSet)
                    {
                        SendTestResult(atmPutGet, false, GetObjectTypeName(), GetObjectName(),  IdName.strName,  strValue, eSet.Message  + "\r\n" + eSet.StackTrace);
                    }
                }
            }

            if (bCreate)
            {
                if (bDoneSomething)
                    Submit(0);

                bDoneSomething = false;
            }

            // Get information regarding subnodes that are implemented as subnodes

            IdsAndNames = GetPropSubnodesIDAndNames();
            if (IdsAndNames != null)
            {
                foreach (PropIDAndName IdName in IdsAndNames)
                {
                    // since now we know the subnodes' name, we can select all 
                    // and do the creation

                    XmlNodeList xList = xNode.SelectNodes(IdName.strName);
                    foreach (XmlNode n in xList)
                    {
                        try
                        {
                            if (bCreate)
                            {
                                SetProperty(IdName.ID, n.InnerText);
                                bDoneSomething = true;
                            }
                            else
                            {
                                if (!FindProperty(IdName.ID, n.InnerText))
                                {
                                    string strMsg = "Property " + IdName.strName + " with value " + n.InnerText + " is missing.";
                                    Exception mismatchExp = new Exception(strMsg);
                                    throw mismatchExp;
                                }
                            }

                            SendTestResult(atmPutGet, true, GetObjectTypeName(), GetObjectName(), IdName.strName, n.InnerText, "");
                        }
                        catch (Exception eSet)
                        {
                            SendTestResult(atmPutGet, false, GetObjectTypeName(), GetObjectName(), IdName.strName, n.InnerText, eSet.Message + "\r\n" + eSet.StackTrace);
                        }
                    }
                }
            }
            
            if (bCreate && bDoneSomething)
                Submit(0);

            // now do the recursive

            string[] strSubObjects = GetChildObjectNames();

            if (strSubObjects != null)
            {
                foreach (string subElementName in strSubObjects)
                {
                    XmlNodeList xList = xNode.SelectNodes(subElementName);
                    foreach (XmlNode n in xList)
                    {
                        // true -> we will throw if Name attribute is missing because
                        // we can't create sub object without names

                        string NewObjName = GetAttribute(n, "Name", true);

                        // true -> we will create a new object

                        IAzTest azSubObj = null;
                        try 
                        {
                            azSubObj = GetTestObjectByName(subElementName, NewObjName, bCreate);
                        }
                        catch (Exception e)
                        {
                            // this shouldn't happen
                            SendMessage("Failed while calling GetTestObjectByName with type =<" + 
                                subElementName + "> and name=<" + NewObjName + ">\r\n" + e.Message, true);
                        }

                        if (azSubObj != null)
                        {
                            azSubObj.StartTest(xNodeAdmin, n);
                            bDoneSomething = true;
                        }
                    }
                }

            }

            if (bCreate)
                Submit(0);
        }

        virtual public void UpdateLinkProperties(XmlNode xAdminNode, XmlNode xNode)
        {

            bool bDoneSomething = false;
            PropIDAndName[] IdsAndNames = GetLinkIDAndNames();

            if (IdsAndNames != null)
            {
                foreach (PropIDAndName IdName in IdsAndNames)
                {
                    // To resolve linking properties, we need to use
                    // the guid to lookup the name and set the attribute by name

                    XmlNodeList xList = xNode.SelectNodes(IdName.strName);
                    foreach (XmlNode n in xList)
                    {
                        string strLinkName = FindObjectNameByGuid(xAdminNode, n.InnerText);
                        try
                        {
                            SetProperty(IdName.ID, strLinkName);
                            bDoneSomething = true;
                            SendTestResult(AzTestMethod.PutProp, true, GetObjectTypeName(), GetObjectName(), IdName.strName, strLinkName, "");
                        }
                        catch (Exception eSet)
                        {
                            SendTestResult(AzTestMethod.PutProp, false, GetObjectTypeName(), GetObjectName(), IdName.strName, strLinkName, eSet.Message + "\r\n" + eSet.StackTrace);
                        }
                    }
                }
            }

            // if we have updated some links, then commit them
            if (bDoneSomething)
                Submit(0);

            // for each children, ask them to do a link update

            string[] strSubObjects = GetChildObjectNames();
            if (strSubObjects != null)
            {
                string strSubEleName;
                foreach (string strSubEleTagName in strSubObjects)
                {
                    XmlNodeList xList = xNode.SelectNodes(strSubEleTagName);
                    foreach (XmlNode n in xList)
                    {
                        // if must have a name for us to continue
                        strSubEleName = GetAttribute(n, "Name", true);
                        try 
                        {
                            IAzTest subObj = GetTestObjectByName(strSubEleTagName, strSubEleName, false);
                            subObj.UpdateLinkProperties(xAdminNode, n);
                        }
                        catch (Exception e)
                        {
                            SendMessage("Failed while calling GetTestObjectByName with type =<" + 
                                        strSubEleTagName + "> and name=<" + strSubEleName + ">\r\n" + e.Message, true);
                        }
                    }
                }
            }
        }
    }

    class CAzTestAzStore : CAzTest
    {
        IAzAuthorizationStore m_store;

        static PropIDAndName[] AttrIDsNames = {new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_APPLICATION_DATA, "ApplicationData"),
                                               new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_APPLY_STORE_SACL, "ApplyStoreSacl"),
                                               new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_DESCRIPTION, "Description"),
                                               new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_AZSTORE_DOMAIN_TIMEOUT, "DomainTimeout"),
                                               new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_GENERATE_AUDITS, "GenerateAudits"),
                                               new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_AZSTORE_MAX_SCRIPT_ENGINES, "MaxScriptEngines"),
                                               new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_AZSTORE_SCRIPT_ENGINE_TIMEOUT, "ScriptEngineTimeout")};

        static string[] m_strChildSubNodes = {"AzApplication", "AzApplicationGroup"};

        public CAzTestAzStore(IAzAuthorizationStore store, OnTestResult cb, AzTestCase atc)
            : base(cb, atc)
        {
            m_store = store;
        }

        public override string GetObjectTypeName()
        {
            return "AzAuthorizationStore";
        }
        public override  string GetObjectName()
        {
            return "AzStore";
        }

        public override  PropIDAndName[] GetPropAttributeIDAndNames()
        {
            return AttrIDsNames;
        }

        public override string[] GetChildObjectNames()
        {
            return m_strChildSubNodes;
        }
        public override void Submit(int i)
        {
            object ob = null;
            m_store.Submit(i, ob);
        }
        public override void SetProperty(tagAZ_PROP_CONSTANTS PropID, string strVal)
        {
            object obReserved = null;
            m_store.SetProperty(Convert.ToInt32(PropID), strVal, obReserved);
        }

        public override object GetProperty(tagAZ_PROP_CONSTANTS PropID)
        {
            object obReserved = null;
            return m_store.GetProperty(Convert.ToInt32(PropID), obReserved);
        }

        public override IAzTest GetTestObjectByName(string strEleName, string strObjName, bool bCreate)
        {
            object obReserved = null;
            IAzTest testObj = null;
            if (strEleName == "AzApplication")
            {
                // create a task object
                IAzApplication app = null;
                if (bCreate)
                    app = m_store.CreateApplication(strObjName, obReserved);
                else
                    app = m_store.OpenApplication(strObjName, obReserved);

                testObj = new CAzTestApplication(app, m_resultCallback, m_atcCase);
            }
            else if (strEleName == "AzApplicationGroup")
            {
                IAzApplicationGroup AzAppGroup = null;
                if (bCreate)
                    AzAppGroup = m_store.CreateApplicationGroup(strObjName, obReserved);
                else
                    AzAppGroup = m_store.OpenApplicationGroup(strObjName, obReserved);

                testObj = new CAzTestAppGroup(AzAppGroup, m_resultCallback, m_atcCase);
            }

            return testObj;
        }


        public static void CreateTargetStore(string strUrl, bool bCreateNewStore, int iCreateFlag, ref AzAuthorizationStoreClass azStoreOut)
        {
            object obReserved = null;
            AzAuthorizationStoreClass azStore = new AzAuthorizationStoreClass();

            //
            // 1 means create store. So, by adding 1, we mean to create the store.
            // This may fail, and in that case we will just
            // delete it. We will create it and not just manage only. So, we will hard code the 
            // flag as 1 for otherwise, AzRoles won't allow us to do access check
            //

            int iCreate = Convert.ToInt32(tagAZ_PROP_CONSTANTS.AZ_AZSTORE_FLAG_CREATE);
            int iManage = Convert.ToInt32(tagAZ_PROP_CONSTANTS.AZ_AZSTORE_FLAG_MANAGE_STORE_ONLY);

            int iNewStoreCreateFlag = bCreateNewStore ? iCreate + iCreateFlag : iCreateFlag;

            try 
            {
                azStore.Initialize(iNewStoreCreateFlag, strUrl, obReserved);
                Console.WriteLine("");
                Console.WriteLine("AzAuthorizationStore created at " + strUrl);
            }
            catch (COMException)
            {
                try
                {
                    //
                    // we will assume that there is already this store and thus
                    // we will delete it. AZ_ADMIN_FLAG_MANAGE_STORE_ONLY doesn't need auditing priv
                    //

                    azStore = new AzAuthorizationStoreClass();
                    azStore.Initialize(iManage, strUrl, obReserved);
                    azStore.Delete(obReserved);
                    azStore = new AzAuthorizationStoreClass();

                    azStore.Initialize(iNewStoreCreateFlag, strUrl, obReserved);
                    Console.WriteLine("");
                    Console.WriteLine("AzAuthorizationStore created " + strUrl);
                }
                catch (Exception doubleExp)
                {
                    //
                    // we don't know what is really going on, so re-throw
                    //

                    throw doubleExp;
                }
            }

            azStoreOut = azStore;
        }

        public override void TestAccessCheck(XmlNode xNode)
        {
            //
            // We should support the testing of those prop/methods that XML store don't support
            //

            /*
            XmlNodeList acList = xNode.SelectNodes("TestMethod");
            foreach (XmlNode n in acList)
            {
                CAzTestAccessCheck ac = new CAzTestAccessCheck(m_resultCallback);
                ac.DoAccessCheck(m_store, n);
            }
            */

            XmlNodeList acList = xNode.SelectNodes("AccessCheck");
            foreach (XmlNode n in acList)
            {
                CAzTestAccessCheck ac = new CAzTestAccessCheck(m_resultCallback);
                ac.DoAccessCheck(m_store, n);
            }
        }

    }
    class CAzTestAppGroup : CAzTest
    {
        private IAzApplicationGroup m_appGroup;

        static PropIDAndName[] AttrIDsNames = {new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_APPLICATION_DATA, "ApplicationData"),
                                                  new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_DESCRIPTION, "Description"),
                                                  new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_GROUP_TYPE, "GroupType")};

        static PropIDAndName[] SubnodesProp = {new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_GROUP_LDAP_QUERY, "LdapQuery"),
                                                  new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_GROUP_MEMBERS, "Member"),
                                                  new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_GROUP_NON_MEMBERS, "NonMember")};

        static PropIDAndName[] LinkIDsNames = {new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_GROUP_APP_MEMBERS, "AppMemberLink"),
                                                  new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_GROUP_APP_NON_MEMBERS, "AppNonMemberLink")};

        public CAzTestAppGroup(IAzApplicationGroup appGp, OnTestResult cb, AzTestCase atc)
            : base(cb, atc)
        {
            m_appGroup = appGp;
        }

        public override string GetObjectTypeName()
        {
            return "AzApplicationGroup";
        }
        public override  string GetObjectName()
        {
            return m_appGroup.Name;
        }
        public override  PropIDAndName[] GetPropAttributeIDAndNames()
        {
            return AttrIDsNames;
        }
        public override  PropIDAndName[] GetPropSubnodesIDAndNames()
        {
            return SubnodesProp;
        }
        
        public override PropIDAndName[] GetLinkIDAndNames()
        {
            return LinkIDsNames;
        }

        public override void Submit(int i)
        {
            object ob = null;
            m_appGroup.Submit(i, ob);
        }
        public override void SetProperty(tagAZ_PROP_CONSTANTS PropID, string strVal)
        {
            object obReserved = null;
            if (PropID == tagAZ_PROP_CONSTANTS.AZ_PROP_GROUP_APP_MEMBERS)
            {
                m_appGroup.AddAppMember(strVal, obReserved);
            }
            else if (PropID == tagAZ_PROP_CONSTANTS.AZ_PROP_GROUP_APP_NON_MEMBERS)
            {
                m_appGroup.AddAppNonMember(strVal, obReserved);
            }
            else if (PropID == tagAZ_PROP_CONSTANTS.AZ_PROP_GROUP_MEMBERS)
            {
                m_appGroup.AddMember(strVal, obReserved);
            }
            else if (PropID == tagAZ_PROP_CONSTANTS.AZ_PROP_GROUP_NON_MEMBERS)
            {
                m_appGroup.AddNonMember(strVal, obReserved);
            }
            else if (PropID == tagAZ_PROP_CONSTANTS.AZ_PROP_GROUP_LDAP_QUERY)
            {
                m_appGroup.LdapQuery = strVal;
            }
            else
            {
                // group type property is an odd baby. While we see in the store
                // a string "LdapQuery", we translate it in cache 1 and we have
                // to use the numeric value to set.
                if (PropID == tagAZ_PROP_CONSTANTS.AZ_PROP_GROUP_TYPE)
                {
                    if (strVal == "LdapQuery")
                    {
                        strVal = "1";
                    }
                    else
                    {
                        strVal = "0";
                    }
                }
                m_appGroup.SetProperty(Convert.ToInt32(PropID), strVal, obReserved);
            }
        }

        public override object GetProperty(tagAZ_PROP_CONSTANTS PropID)
        {
            object obReserved = null;
            return m_appGroup.GetProperty(Convert.ToInt32(PropID), obReserved);
        }
    }

    class CAzTestApplication : CAzTest
    {
        private IAzApplication m_app;

        static PropIDAndName[] AttrIDsNames = {new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_APPLICATION_DATA, "ApplicationData"),
                                                  new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_DESCRIPTION, "Description"),
                                                  new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_APPLY_STORE_SACL, "ApplyStoreSacl"),
                                                  new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID, "AuthzInterfaceClsid"),
                                                  new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_APPLICATION_VERSION, "Version")};

        string[] ChildSubNodes = {"AzTask", "AzOperation", "AzScope", "AzRole", "AzApplicationGroup"};

        public CAzTestApplication(IAzApplication app, CAzTestAzStore.OnTestResult cb, AzTestCase atc)
            : base(cb, atc)
        {
            m_app = app;
        }

        public override string GetObjectTypeName()
        {
            return "AzApplication";
        }
        public override  string GetObjectName()
        {
            return m_app.Name;
        }
        public override  PropIDAndName[] GetPropAttributeIDAndNames()
        {
            return AttrIDsNames;
        }
        public override string[] GetChildObjectNames()
        {
            return ChildSubNodes;
        }
        public override void Submit(int i)
        {
            object ob = null;
            m_app.Submit(i, ob);
        }
        public override void SetProperty(tagAZ_PROP_CONSTANTS PropID, string strVal)
        {
            object obReserved = null;
            m_app.SetProperty(Convert.ToInt32(PropID), strVal, obReserved);
        }

        public override object GetProperty(tagAZ_PROP_CONSTANTS PropID)
        {
            object obReserved = null;
            return m_app.GetProperty(Convert.ToInt32(PropID), obReserved);
        }

        public override IAzTest GetTestObjectByName(string strEleName, string strObjName, bool bCreate)
        {
            object obReserved = null;
            IAzTest testObj = null;
            if (strEleName == "AzTask")
            {
                // create a task object
                IAzTask task = null;
                if (bCreate)
                    task = m_app.CreateTask(strObjName, obReserved);
                else
                    task = m_app.OpenTask(strObjName, obReserved);

                testObj = new CAzTestTask(task, m_resultCallback, m_atcCase);
            }
            else if (strEleName == "AzOperation")
            {
                IAzOperation op = null;
                if (bCreate)
                    op = m_app.CreateOperation(strObjName, obReserved);
                else
                    op = m_app.OpenOperation(strObjName, obReserved);

                testObj = new CAzTestOperation(op, m_resultCallback, m_atcCase);
            }
            else if (strEleName == "AzScope")
            {
                IAzScope AzScope = null;
                if (bCreate)
                    AzScope = m_app.CreateScope(strObjName, obReserved);
                else
                    AzScope = m_app.OpenScope(strObjName, obReserved);

                testObj = new CAzTestScope(AzScope, m_resultCallback, m_atcCase);
            }
            else if (strEleName == "AzRole")
            {
                IAzRole AzRole = null;
                if (bCreate)
                    AzRole = m_app.CreateRole(strObjName, obReserved);
                else
                    AzRole = m_app.OpenRole(strObjName, obReserved);

                testObj = new CAzTestRole(AzRole, m_resultCallback, m_atcCase);
            }
            else if (strEleName == "AzApplicationGroup")
            {
                IAzApplicationGroup AzAppGroup = null;
                if (bCreate)
                    AzAppGroup = m_app.CreateApplicationGroup(strObjName, obReserved);
                else
                    AzAppGroup = m_app.OpenApplicationGroup(strObjName, obReserved);

                testObj = new CAzTestAppGroup(AzAppGroup, m_resultCallback, m_atcCase);
            }

            return testObj;
        }
    }

    class CAzTestTask : CAzTest
    {
        private IAzTask m_task;

        static PropIDAndName[] AttrSubNodes = {new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_APPLICATION_DATA, "ApplicationData"),
                                               new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_DESCRIPTION, "Description"),
                                               new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_TASK_IS_ROLE_DEFINITION, "RoleDefinition"),
                                               new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_TASK_BIZRULE_IMPORTED_PATH, "BizRuleImportedPath")};

        static PropIDAndName[] PropSubNodes = {new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_TASK_BIZRULE_LANGUAGE, "BizRuleLanguage"),
                                               new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_TASK_BIZRULE, "BizRule")};

        static PropIDAndName[] LinkIDsNames = {new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_TASK_TASKS, "TaskLink"),
                                               new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_TASK_OPERATIONS, "OperationLink")};

        public CAzTestTask(IAzTask task, OnTestResult cb, AzTestCase atc)
            : base(cb, atc) 
        {
            m_task = task;
        }

        public override string GetObjectTypeName()
        {
            return "AzTask";
        }
        public override string GetObjectName()
        {
            return m_task.Name;
        }

        public override PropIDAndName[] GetPropAttributeIDAndNames()
        {
            return AttrSubNodes;
        }

        
        public override PropIDAndName[] GetPropSubnodesIDAndNames()
        {
            return PropSubNodes;
        }

        public override PropIDAndName[] GetLinkIDAndNames()
        {
            return LinkIDsNames;
        }

        public override void Submit(int i)
        {
            object ob = null;
            m_task.Submit(i, ob);
        }

        public override void SetProperty(tagAZ_PROP_CONSTANTS PropID, string strVal)
        {
            object obReserved = null;
            if (PropID == tagAZ_PROP_CONSTANTS.AZ_PROP_TASK_OPERATIONS)
            {
                m_task.AddOperation(strVal, obReserved);
            }
            else if (PropID == tagAZ_PROP_CONSTANTS.AZ_PROP_TASK_TASKS)
            {
                m_task.AddTask(strVal, obReserved);
            }
            else
            {
                m_task.SetProperty(Convert.ToInt32(PropID), strVal, obReserved);
            }
        }

        public override object GetProperty(tagAZ_PROP_CONSTANTS PropID)
        {
            object obReserved = null;
            return m_task.GetProperty(Convert.ToInt32(PropID), obReserved);
        }
    }

    class CAzTestOperation : CAzTest
    {
        private IAzOperation m_op;

        static PropIDAndName[] AttrSubNodes = {new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_APPLICATION_DATA, "ApplicationData"),
                                                new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_DESCRIPTION, "Description")};
        static PropIDAndName[] PropSubNodes = {new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_OPERATION_ID, "OperationID")};

        public CAzTestOperation(IAzOperation op, OnTestResult cb, AzTestCase atc)
            : base(cb, atc) 
        {
            m_op = op;
        }

        public override string GetObjectTypeName()
        {
            return "AzOpearation";
        }
        public override string GetObjectName()
        {
            return m_op.Name;
        }
        public override PropIDAndName[] GetPropSubnodesIDAndNames()
        {
            return PropSubNodes;
        }
        public override PropIDAndName[] GetPropAttributeIDAndNames()
        {
            return AttrSubNodes;
        }
       
        public override void Submit(int i)
        {
            object ob = null;
            m_op.Submit(i, ob);
        }
        public override void SetProperty(tagAZ_PROP_CONSTANTS PropID, string strVal)
        {
            object obReserved = null;
            m_op.SetProperty(Convert.ToInt32(PropID), strVal, obReserved);
        }

        public override object GetProperty(tagAZ_PROP_CONSTANTS PropID)
        {
            object obReserved = null;
            return m_op.GetProperty(Convert.ToInt32(PropID), obReserved);
        }

    }

    class CAzTestScope : CAzTest
    {
        private IAzScope m_scope;

        static PropIDAndName[] AttrSubNodes = {new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_APPLICATION_DATA, "ApplicationData"),
                                               new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_DESCRIPTION, "Description")};

        string[] ChildSubNodes = {"AzTask", "AzApplicationGroup", "AzRole"};

        public CAzTestScope(IAzScope scope, CAzTestAzStore.OnTestResult cb, AzTestCase atc)
            : base(cb, atc) 
        {
            m_scope = scope;
        }

        public override string GetObjectName()
        {
            return m_scope.Name;
        }

        public override string GetObjectTypeName()
        {
            return "AzScope";
        }
        
        public override PropIDAndName[] GetPropAttributeIDAndNames()
        {
            return AttrSubNodes;
        }

        public override string[] GetChildObjectNames()
        {
            return ChildSubNodes;
        }
      
        public override void SetProperty(tagAZ_PROP_CONSTANTS PropID, string strVal)
        {
            object obReserved = null;
            m_scope.SetProperty(Convert.ToInt32(PropID), strVal, obReserved);
        }

        public override object GetProperty(tagAZ_PROP_CONSTANTS PropID)
        {
            object obReserved = null;
            return m_scope.GetProperty(Convert.ToInt32(PropID), obReserved);
        }

        public override void Submit(int i)
        {
            object ob = null;
            m_scope.Submit(i, ob);
        }

        public override IAzTest GetTestObjectByName(string strEleName, string strObjName, bool bCreate)
        {
            object obReserved = null;
            IAzTest testObj = null;
            if (strEleName == "AzTask")
            {
                // create a task object
                IAzTask task = null;
                if (bCreate)
                    task = m_scope.CreateTask(strObjName, obReserved);
                else
                    task = m_scope.OpenTask(strObjName, obReserved);

                testObj = new CAzTestTask(task, m_resultCallback, m_atcCase);
            }
            else if (strEleName == "AzRole")
            {
                IAzRole AzRole = null;
                if (bCreate)
                    AzRole = m_scope.CreateRole(strObjName, obReserved);
                else
                    AzRole = m_scope.OpenRole(strObjName, obReserved);

                testObj = new CAzTestRole(AzRole, m_resultCallback, m_atcCase);
            }
            else if (strEleName == "AzApplicationGroup")
            {
                IAzApplicationGroup AzAppGroup = null;
                if (bCreate)
                    AzAppGroup = m_scope.CreateApplicationGroup(strObjName, obReserved);
                else
                    AzAppGroup = m_scope.OpenApplicationGroup(strObjName, obReserved);

                testObj = new CAzTestAppGroup(AzAppGroup, m_resultCallback, m_atcCase);
            }

            return testObj;
        }
   }

    class CAzTestRole : CAzTest
    {
        private IAzRole m_role;

        static PropIDAndName[] AttrSubNodes = {new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_APPLICATION_DATA, "ApplicationData"),
                                               new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_DESCRIPTION, "Description")};
        
        static PropIDAndName[] PropSubNodes = {new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_ROLE_MEMBERS, "Member")};

        static PropIDAndName[] LinkIDsNames = {new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_ROLE_APP_MEMBERS, "AppMemberLink"),
                                               new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_ROLE_TASKS, "TaskLink"),
                                               new PropIDAndName(tagAZ_PROP_CONSTANTS.AZ_PROP_ROLE_OPERATIONS, "OperationLink")};

        public CAzTestRole(IAzRole role, CAzTestAzStore.OnTestResult cb, AzTestCase atc)
            : base(cb, atc)
        {
            m_role = role;
        }

        public override string GetObjectName()
        {
            return m_role.Name;
        }

        public override string GetObjectTypeName()
        {
            return "AzRole";
        }

        public override PropIDAndName[] GetPropAttributeIDAndNames()
        {
            return AttrSubNodes;
        }
        
        public override PropIDAndName[] GetPropSubnodesIDAndNames()
        {
            return PropSubNodes;
        }

        public override PropIDAndName[] GetLinkIDAndNames()
        {
            return LinkIDsNames;
        }

        public override void Submit(int i)
        {
            object ob = null;
            m_role.Submit(i, ob);
        }

        public override void SetProperty(tagAZ_PROP_CONSTANTS PropID, string strVal)
        {
            object obReserved = null;
            if (PropID == tagAZ_PROP_CONSTANTS.AZ_PROP_ROLE_APP_MEMBERS)
            {
                m_role.AddAppMember(strVal, obReserved);
            }
            else if (PropID == tagAZ_PROP_CONSTANTS.AZ_PROP_ROLE_TASKS)
            {
                m_role.AddTask(strVal, obReserved);
            }
            else if (PropID == tagAZ_PROP_CONSTANTS.AZ_PROP_ROLE_OPERATIONS)
            {
                m_role.AddOperation(strVal, obReserved);
            }
            else if (PropID == tagAZ_PROP_CONSTANTS.AZ_PROP_ROLE_MEMBERS)
            {
                m_role.AddMember(strVal, obReserved);
            }
            else
            {
                m_role.SetProperty(Convert.ToInt32(PropID), strVal, obReserved);
            }
        }

        public override object GetProperty(tagAZ_PROP_CONSTANTS PropID)
        {
            object obReserved = null;
            return m_role.GetProperty(Convert.ToInt32(PropID), obReserved);
        }
    }

    class CAzTestAccessCheck : CAzTest
    {
        public CAzTestAccessCheck(OnTestResult cb) : base(cb, AzTestCase.AccessCheck)
        {
        }

        public override string GetObjectName()
        {
            return null;
        }

        public override string GetObjectTypeName()
        {
            return null;
        }

        public override void SetProperty(tagAZ_PROP_CONSTANTS id, string strval)
        {
            ;// do nothing
        }

        public override object GetProperty(tagAZ_PROP_CONSTANTS PropID)
        {
            return null;
        }

        public override void Submit(int i)
        {
            ;// do nothing
        }

        private object[] GatherAttributes(XmlNode xNode, string strSubEleName, string strAttriName, bool bIsValue)
        {
            int iCount = 0;
            XmlNodeList nList = null;

            if (xNode != null)
            {
                nList = xNode.SelectNodes(strSubEleName);
                if (nList != null)
                {
                    iCount = nList.Count;
                }
            }

            object[] oAllAttributes = new object[iCount];

            for (int i = 0; i < iCount; i++)
            {
                bool bIsInt = false;
                if (bIsValue)
                {
                    // if this attribute is a value (instead of name), then we need
                    // to look for the IsInteger attribute and see what the value is
                    // Also, don't throw if this attribute is missing - default to string value

                    string strIsInt = GetAttribute(nList[i], "IsInteger", false);
                    if (strIsInt != null)
                    {
                        bIsInt = Convert.ToBoolean(strIsInt);
                    }
                }
                if (bIsInt)
                {
                    oAllAttributes[i] = Convert.ToInt32(GetAttribute(nList[i], strAttriName, true));
                }
                else
                {
                    oAllAttributes[i] = GetAttribute(nList[i], strAttriName, true);
                }
            }
            return oAllAttributes;
        }

        public void DoAccessCheck(IAzAuthorizationStore azStore, XmlNode nAC)
        {
            string strApp = "";
            string strUser = "";

            try
            {
                // Each access check must be done against one single application. We must have
                // this element, otherwise, we throw.

                strApp = GetSubElementAttribute(nAC, "App", "Name", true);

                // this attribute tells us if the expected result of the access check is
                // deny or grant access
                bool bExpectSuccess = Convert.ToBoolean(GetAttribute(nAC, "ExpectedResult", true));

                // gather all scope names from the <Scopes> element.
                XmlNode nTemp = nAC.SelectSingleNode("Scopes");
                object[] oScopes = GatherAttributes(nTemp, "Scope", "Name", false);

                // give some meaningful feedback
                SendMessage("Conducting access check for " + strApp, false);

                // we will use this thread's context to check. We can design the test instruction
                // to determine if we should use name to initialize the client context. For now,
                // we simply use the name as feedback information

                object obReserved = null;
                IAzApplication app = azStore.OpenApplication(strApp, obReserved);

                // see if we have Account attribute. If yes, we will use name to create
                // the client context. Otherwise, we will use the thread token

                IAzClientContext clientContext = null;
                strUser = GetAttribute(nAC, "Account", false);
                string strDomain = GetAttribute(nAC, "Domain", false);
                if (strUser == null)
                {
                    WindowsIdentity identity = WindowsIdentity.GetCurrent();
                    strUser = identity.Name;
                    SendMessage("Current user is: " + strUser, false);
                    clientContext = app.InitializeClientContextFromToken(0, obReserved);
                }
                else
                {
                    clientContext = app.InitializeClientContextFromName(strUser, strDomain, obReserved);
                }

                // fill in the access check parameter
                nTemp = nAC.SelectSingleNode("Parameters");

                object[] oNames = GatherAttributes(nTemp, "Parameter", "Name", false);

                // true -> this attribute is a value attribute, so we need to check
                // the type of the value.
                object[] oValues = GatherAttributes(nTemp, "Parameter", "Value", true);

                // populate the Op IDs
                nTemp = nAC.SelectSingleNode("Operations");

                object[] oOperations = GatherAttributes(nTemp, "OpID", "ID", true);

                object[] oOther = new object[1];
                oOther[0] = obReserved;

                object[] results = (object[])clientContext.AccessCheck( strApp, 
                                                                        oScopes, 
                                                                        oOperations, 
                                                                        oNames, 
                                                                        oValues, 
                                                                        null,
                                                                        null,
                                                                        null);

                bool bAuthorized = true;			 					
                foreach(int i in results)
                {
                    if ( i != 0 )
                    {
                        bAuthorized = false;
                        break;
                    }
                }
            
                // if the access check resutl matches our expectation, we consider it a success

                bool bSucceed = (bAuthorized && bExpectSuccess || !bAuthorized && !bExpectSuccess);

                string strExpected = bSucceed ? "AS EXPECTED." : "NOT AS EXPECTED.";
                Console.WriteLine("");
                if (bAuthorized)
                {
                    SendMessage("Client " + strUser + " is authorized - " + strExpected, false);
                }
                else
                {
                    SendMessage("Client " + strUser + " is not authorized - " + strExpected, false);
                }

                SendTestResult(AzTestMethod.ExeMethod, bSucceed, "AccessCheck", strUser, strApp, "", "");
            }
            catch (Exception e)
            {
                SendTestResult(AzTestMethod.ExeMethod, 
                                false, 
                                "AccessCheck", 
                                strUser, 
                                strApp,
                                "",
                                e.Message + "\r\n" + e.StackTrace);
            }

        }

   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\azroles\tests\topen.inc ===
' global
Dim Prefix
Prefix = Array("", "    ", "        ", "            ")

Sub AzPrintCommon(Level, ObjName, Obj)
    If 0=Level Then
        'level 0 has no name
        WScript.Echo Prefix(Level) & ObjName & "(Description=" & Obj.Description & ")"
    Else
        WScript.Echo Prefix(Level) & ObjName & "(Name=" & Obj.Name & ", Description=" & Obj.Description & ")"
    End If
End Sub

Sub AzPrintAttr(Level, Obj, PId, PName)
    WScript.Echo Prefix(Level) & "  @ " & PName & "=" & Obj.GetProperty(PId, 0)
End Sub

Sub AzPrintItem(Level, Name, Item)
    WScript.Echo Prefix(Level) & "  / " & Name & "=" & Item
End Sub

Sub AzPrintAdmin(Lvl, Obj)
    Dim Writers, Readers, U

    AzPrintCommon Lvl, "AdminManager", Obj
    AzPrintAttr Lvl, Obj, AZ_PROP_ADMIN_DOMAIN_TIMEOUT, "AZ_PROP_ADMIN_DOMAIN_TIMEOUT"
    AzPrintAttr Lvl, Obj, AZ_PROP_ADMIN_SCRIPT_ENGINE_TIMEOUT, "AZ_PROP_ADMIN_SCRIPT_ENGINE_TIMEOUT"
    AzPrintAttr Lvl, Obj, AZ_PROP_ADMIN_MAX_SCRIPT_ENGINES, "AZ_PROP_ADMIN_MAX_SCRIPT_ENGINES"
    AzPrintAttr Lvl, Obj, AZ_PROP_GENERATE_AUDITS, "AZ_PROP_GENERATE_AUDITS"

    Writers = Obj.PolicyAdministrators
    For Each U In Writers
        AzPrintItem Lvl, "PolicyAdministrator", U
    Next

    Readers = Obj.PolicyReaders
    For Each U In Readers
        AzPrintItem Lvl, "PolicyReader", U
    Next

    WScript.Echo ""
End Sub

Sub AzPrintApp(Lvl, Obj)
    AzPrintCommon Lvl, "Application", Obj
    AzPrintAttr Lvl, Obj, AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID, "AZ_PROP_APPLICATION_AUTHZ_INTERFACE_CLSID"
    AzPrintAttr Lvl, Obj, AZ_PROP_APPLICATION_VERSION, "AZ_PROP_APPLICATION_VERSION"
    AzPrintAttr Lvl, Obj, AZ_PROP_GENERATE_AUDITS, "AZ_PROP_GENERATE_AUDITS"
    WScript.Echo ""
End Sub

Sub AzPrintOp(Lvl, Obj)
    AzPrintCommon Lvl, "Operation", Obj
    AzPrintAttr Lvl, Obj, AZ_PROP_OPERATION_ID, "AZ_PROP_OPERATION_ID"
    WScript.Echo ""
End Sub

Sub AzPrintTask(Lvl, Obj)
    Dim Ops, Tasks

    AzPrintCommon Lvl, "Task", Obj
    AzPrintAttr Lvl, Obj, AZ_PROP_TASK_BIZRULE, "AZ_PROP_TASK_BIZRULE"
    AzPrintAttr Lvl, Obj, AZ_PROP_TASK_BIZRULE_LANGUAGE, "AZ_PROP_TASK_BIZRULE_LANGUAGE"
    AzPrintAttr Lvl, Obj, AZ_PROP_TASK_BIZRULE_IMPORTED_PATH, "AZ_PROP_TASK_BIZRULE_IMPORTED_PATH"
    AzPrintAttr Lvl, Obj, AZ_PROP_TASK_IS_ROLE_DEFINITION, "AZ_PROP_TASK_IS_ROLE_DEFINITION"

    Ops = Obj.GetProperty(AZ_PROP_TASK_OPERATIONS, 0)
    For Each Op In Ops
        AzPrintItem Lvl, "OperationLink", Op
    Next

    Tasks = Obj.GetProperty(AZ_PROP_TASK_TASKS, 0)
    For Each Task In Tasks
        AzPrintItem Lvl, "TaskLink", Task
    Next
    WScript.Echo ""
End Sub

Sub AzPrintGroup(Lvl, Obj)
    Dim Mems, NonMems, AppMems, AppNonMems

    AzPrintCommon Lvl, "Group", Obj
    AzPrintAttr Lvl, Obj, AZ_PROP_GROUP_TYPE, "AZ_PROP_GROUP_TYPE"
    AzPrintAttr Lvl, Obj, AZ_PROP_GROUP_LDAP_QUERY, "AZ_PROP_GROUP_LDAP_QUERY"

    Mems = Obj.GetProperty(AZ_PROP_GROUP_MEMBERS, 0)
    For Each Mem In Mems
        AzPrintItem Lvl, "SidMember", Mem
    Next

    NonMems = Obj.GetProperty(AZ_PROP_GROUP_NON_MEMBERS, 0)
    For Each Mem In NonMems
        AzPrintItem Lvl, "SidNonMember", Mem
    Next

    AppMems = Obj.GetProperty(AZ_PROP_GROUP_APP_MEMBERS, 0)
    For Each Mem In AppMems
        AzPrintItem Lvl, "AppMemberLink", Mem
    Next

    AppNonMems = Obj.GetProperty(AZ_PROP_GROUP_APP_NON_MEMBERS, 0)
    For Each Mem In AppNonMems
        AzPrintItem Lvl, "AppNonMemberLink", Mem
    Next

    WScript.Echo ""
End Sub

Sub AzPrintScope(Lvl, Obj)
    AzPrintCommon Lvl, "Scope", Obj
    WScript.Echo ""
End Sub

Sub AzPrintRole(Lvl, Obj)
    Dim Mems, SidMems, Ops, Tasks

    AzPrintCommon Lvl, "Role", Obj

    Ops = Obj.GetProperty(AZ_PROP_ROLE_OPERATIONS, 0)
    For Each Op In Ops
        AzPrintItem Lvl, "OperationLink", Op
    Next

    Tasks = Obj.GetProperty(AZ_PROP_ROLE_TASKS, 0)
    For Each Task In Tasks
        AzPrintItem Lvl, "TaskLink", Task
    Next

    SidMems = Obj.GetProperty(AZ_PROP_ROLE_MEMBERS, 0)
    For Each Mem In SidMems
        AzPrintItem Lvl, "SidMember", Mem
    Next

    Mems = Obj.GetProperty(AZ_PROP_ROLE_APP_MEMBERS, 0)
    For Each Mem In Mems
        AzPrintItem Lvl, "AppMemberLink", Mem
    Next

    WScript.Echo ""
End Sub


Sub AzPrintPolicy(Admin)

    AzPrintAdmin 0, Admin

    ' navigate whole tree
    Dim Apps, App
    Set Apps=Admin.Applications
    For Each App In Apps
        AzPrintApp 1, App

        Dim Ops, Op
        Set Ops=App.Operations
        For Each Op In Ops
            AzPrintOp 2, Op
        Next

        Dim Tks, Tk
        Set Tks=App.Tasks
        For Each Tk In Tks
            AzPrintTask 2, Tk
        Next

        Dim Gps, Gp
        Set Gps=App.ApplicationGroups
        For Each Gp In Gps
            AzPrintGroup 2, Gp
        Next

        Dim Rls, Rl
        Set Rls=App.Roles
        For Each Rl In Rls
            AzPrintRole 2, Rl
        Next

        Dim Scs, Sc
        Set Scs=App.Scopes
        For Each Sc In Scs
            AzPrintScope 2, Sc

            Dim STks, STk
            Set STks=Sc.Tasks
            For Each STk In STks
                AzPrintTask 3, STk
            Next

            Dim SGps, SGp
            Set SGps=Sc.ApplicationGroups
            For Each SGp In SGps
                AzPrintGroup 3, SGp
            Next

            Dim SRls, SRl
            Set SRls=Sc.Roles
            For Each SRl In SRls
                AzPrintRole 3, SRl
            Next

            Set STks=Nothing
            Set SGps=Nothing
            Set SRls=Nothing
        Next

        Set Ops=Nothing
        Set Tks=Nothing
        Set Gps=Nothing
        Set Rls=Nothing
        Set Scs=Nothing

    Next


    Dim Groups, Group
    Set Groups=Admin.ApplicationGroups
    For Each Group In Groups
        AzPrintGroup 1, Group
    Next


    Set Groups=Nothing
    Set Apps=Nothing

End Sub 'AzPrintPolicy


Sub AzPrintPolicyFile(localXmlFile)

    Dim Admin

    WScript.Echo "Store = " & localXmlFile
    Set Admin=CreateObject("AzRoles.AzAdminManager")
    Admin.Initialize 0, localXmlFile
    WScript.Echo ""

    AzPrintPolicy Admin

    Set Admin=Nothing

End Sub 'AzPrintPolicyFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\cmdkey\command.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       cmdkey: command.h
//
//  Contents:   Command line parsing functions header
//
//  Classes:
//
//  Functions:
//
//  History:    07-09-01   georgema     Created 
//
//----------------------------------------------------------------------------
#ifndef __COMMAND_H__
#define __COMMAND_H__

/*

CLInit() passes in an array of switch characters and a count of same.  The return value
is FALSE if memory could not be allocated.  A default CLInit(void) may be called which 
defines all 26 letters, 10 digits, and '?' as permissible switches.

CLParse() parses the command line, locating switches and associating argument strings 
with them where appropriate.  The return value is FALSE if duplicate switches are found
on the command line.  The order of the switches is unimportant to this process, but 
read on...

The switch array may be ordered with the principal command switches first to allow 
the caller to determine which of these appeared first on the command line.  This hack was 
inserted to allow differentiation of the diagnostic message that appears if command line 
validation fails -- what is the command that the user most likely could use help with?

CLSetMaxPrincipalSwitch() allows the callser to pass in an integer index to define the 
set of principal command switches.  CLGetPrincipalSwitch will return the index of the 
first principal switch found on the command line, or -1 of none.  Principal switches are defined
as those of index 0 through the max index defined above.  The return value is the previous 
set value, initally -1.

CLExtra() returns TRUE if unidentified switches were found on the command line.

CLFlag() returns TRUE if the indexed switch was found
CLPtr() returns the string argument associated with the switch, or NULL if none.

CLUnInit() must be called sometime after CLInit() to release memory allocated by CLInit().

*/
BOOL CLInit(void);                          // with no known good switches array
BOOL CLInit(INT ccSwitches, WCHAR *prgc);       // with passed valid switch array and count
BOOL CLParse(void);
INT CLSetMaxPrincipalSwitch(INT);
INT CLGetPrincipalSwitch(void);
BOOL CLExtra(void);
BOOL CLFlag(INT i);
WCHAR *CLPtr(INT i);
void CLUnInit(void);
int CLTokens(void);
WCHAR *CLFirstString(WCHAR *pc);
WCHAR *CLLastString(WCHAR *pc);

// Security export for destroying the command line information
void StompCommandLine(INT argc, char **argv);

// Internal APIs for use within command.cpp
WCHAR *TestSwitch(WCHAR *pCmdLine,WCHAR cin);
WCHAR *FetchSwitchString(WCHAR *origin);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\cmdkey\command.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       cmdkey: command.cpp
//
//  Contents:   Command line parsing functions
//
//  Classes:
//
//  Functions:
//
//  History:    07-09-01   georgema     Created 
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "command.h"
#include "switches.h"

#ifdef CLPARSER
WCHAR szsz[500];

#define ODS(x) OutputDebugString(x)
#endif

static BOOL *pf = NULL;
static INT iMaxCommand = -1;
static INT iFirstCommand = -1;
static WCHAR *pModel = NULL;
static WCHAR **pprgc = NULL;
static WCHAR *pCmdline = NULL;
static INT cSwitches = 0;
static BOOL fExtra = FALSE;
static WCHAR rgcAll[] = {L"abcdefghijklmnopqrstuvwxyz?0123456789"};
#define ccAll (sizeof(rgcAll) / sizeof(WCHAR))

// -------------------------------------------------------------------------
//
// Command Parser exports
//
// -------------------------------------------------------------------------

// Get access to the command switches model and the count of valid switches
// Create variables for use by the parser
BOOL CLInit(void)
{
    return CLInit((INT) ccAll,rgcAll);
}

BOOL CLInit(INT ccSwitches, WCHAR *prgc)
{
    if (NULL == prgc) return FALSE;
    if (0 >= ccSwitches) return FALSE;

    // note that GetCommandLine() does not return any cr/lf at the end of the string, just NULL.
    pCmdline = GetCommandLineW();
#ifdef CLPARSER
    swprintf(szsz,L"CMDKEY: Command line :%s\n",pCmdline);
    ODS(szsz);
#endif
    pModel = prgc;
    cSwitches = ccSwitches;

    // accept a count of switches, generate the appropriate
    //  intermediate variables for the parser
    pprgc = (WCHAR **) malloc(sizeof(WCHAR*) * (cSwitches + 1));
    if (NULL == pprgc) return FALSE;
    pf = (BOOL *) malloc(sizeof(BOOL) * (cSwitches + 1));
    if (NULL == pf) return FALSE;

    for (INT i=0;i<cSwitches;i++)
    {
        pprgc[i] = NULL;
        pf[i] = FALSE;
    }
    return TRUE;
}

// Scan for switches, detecting extraneous ones, and setting the switchpresent flag
//  and the switch argument data pointer as appropriate.
//
// Parsing will return failed in the case of finding a duplicate of a switch already 
//  encountered.  In many cases, that can lead to ambiguity.  This should be pretty 
//  uncommon, and will always result from bad input from the user.
BOOL CLParse(void)
{
    BOOL fOK = TRUE;
    WCHAR *pc = pCmdline;
    WCHAR *pa = NULL;
    WCHAR c = 0;
    INT i = 0;
    WCHAR last = 0x0;
#ifdef CLPARSER
    WCHAR sz[] = {L" "};
#endif

#ifdef CLPARSER
    ODS(L"CMDKEY: Scanning for all switches : ");
#endif
    while (0 != (c = *pc++))
    {
        // char found on command line
        if ((c == '/') || (c == '-'))
        {
            if (last != ' ')
            {
                // Only valid switchchar if preceded by a space
                //last = c;
                continue;
            }
            c = *pc;                        // fetch next character
            if (0 == c) break;                              // break on end of line
#ifdef CLPARSER
            sz[0] = c;
            ODS(sz);
#endif
            for (i=0; i<cSwitches;i++)
            {
                c |= 0x20;                  // force to lower case
                if (c == pModel[i]) break;          // break the for for char OK
            }
            if ( i!= cSwitches )
            {
                if (pf[i])
                {   
#ifdef CLPARSER
                    ODS(L"(duplicate!)");
#endif
                    fOK = FALSE;
                    break;                  // fatal parse error - dup switch
                }
                pf[i] = TRUE;
                if (iFirstCommand < 0) 
                {
                    if (i <= iMaxCommand)
                    {
                        iFirstCommand = i;
#ifdef CLPARSER
                        ODS(L"!");
#endif
                    }
                }
                pa = FetchSwitchString(pc);
                if (NULL != pa)
                {
                    pprgc[i] = pa;
#ifdef CLPARSER
                    swprintf(szsz,L"(%s)",pa);
                    ODS(szsz);
#endif
                }
            }
#ifdef PICKY
            else
            {
                // once you find an extraneous switch, cease looking
#ifdef CLPARSER
                ODS(L" (*bad*)");
#endif
                fExtra = TRUE;
                break;                      // get out of while
            }
#endif // PICKY
#ifdef CLPARSER
        ODS(L" ");
#endif
        }
        last = c;
    }
#ifdef CLPARSER
    ODS(L"\n");
#endif
    return fOK;
}

INT 
CLSetMaxPrincipalSwitch(INT i)
{
    INT iOld = iMaxCommand;
    iMaxCommand = i;
    return iOld;
}

INT 
CLGetPrincipalSwitch(void)
{
    return iFirstCommand;
}


// Return TRUE if extraneous switches found
BOOL CLExtra(void)
{
    return fExtra;
}

// Return TRUE if the indexed switch was found
BOOL CLFlag(INT i)
{
    if (i > cSwitches) return FALSE;
    if (i < 0) return FALSE;
    return pf[i];
}

// Returns a pointer to a copy of the switch argument data, or NULL if the switch had no data following
WCHAR *CLPtr(INT i)
{
    if (i > cSwitches) return NULL;
    if (i < 0) return NULL;
    return pprgc[i];
}

// Free allocated parser variables
void CLUnInit(void)
{
    
    for (INT i=0;i<cSwitches;i++)
    {
        if (pprgc[i] != NULL) free((void *) pprgc[i]);
    }
    if (pprgc) free((void *)pprgc);
    if (pf) free((void *)pf);
}

// -------------------------------------------------------------------------
//
// Switch Parsing group
//
// -------------------------------------------------------------------------

// Fetch switch argument after finding switch.  Ret ptr to
//  first non-whitespace char, place null after last non-whitespace
//  char.  In the case of quotes, return ptr to 1st char after quote
//  and place null over last quote.
//
// Note that whitespace seems to be specifically 0x20.  Tabs do not seem to be
//  returned from command lines
//
// Place two pointers, one at the beginning, one at the end, work from
//  there.
//
// Caller should use the value and then free the string.
WCHAR *FetchSwitchString(WCHAR *origin)
{
    WCHAR *p1;
    WCHAR *p2;
    WCHAR c;
    WCHAR l = 0;
    BOOL fQ = FALSE;
    INT_PTR iLen;
    WCHAR *pBuf;

    if (NULL == origin) return NULL;
    p1 = origin;

    // walk to end of switchstring itself
    while (1 )
    {
        c = *p1;
        if (c == 0) return NULL;            // eol before arg found
        // skip to end of switch token
        if (c == ':') break;                    // end of switch
        if (c == 0x20) break;               // end of switch
        if (c == '/') return NULL;          // next switch before arg found
        if (c == '-') return NULL;
        p1++;
        l = c;
    }

    p1++;

    // walk to beginning of the switch argument
    // eat spaces, step over begin quotes
    while (1 )
    {
        c = *p1;
        if (c == '"') 
        {
            fQ = TRUE;
            p1++;
            l = c;
            break;
        }
        else if (c == 0) return NULL;       // did not find an arg
        else if (c == '/') return NULL;
        else if (c == '-') return NULL;
        else if (c > 0x20) break;
        p1++;
        l = c;
    }

    // p1 now pointed to root char of switch arg itself
    // fQ set if in a quoted string

    // Find the end of the arg string
    // If a quoted string, only a quote or EOL ends it
    // else ended by EOL, switchchar or quote
    
    p2 = p1;
    while (1)
    {
        c = *p2;
        if (fQ)
        {
            if (c == 0) break;
            if (c == '"') break;
        }
        else
        {
            if (c == 0) break;
            // Encountering the next switch terminates the string only if the 
            // switch char is preceded by a space (valid switchchar)
            if (l == ' ')
            {
                if (c == '/') break;
                if (c == '-') break;
            }
            // disallow embedded quotes
            if (c == '"') return NULL;
        }
        p2++;
        l = c;
    }
    p2--;                   // ptr to last valid char in arg string

    // now back up until you hit the first printable character, IFF the tail ptr is not already
    // coincident with the head ptr.  In that case, the string length is 1
    while (p2 > p1)
    {
        c = *p2;
        if (c > 0x20) break;
        p2--;
    }

    iLen = p2 - p1;
    
    pBuf = (WCHAR *) malloc(iLen * sizeof(WCHAR) + 2 * sizeof(WCHAR));
    if (pBuf) 
    {
        memset(pBuf,0,iLen * sizeof(WCHAR) + 2 * sizeof(WCHAR));
        wcsncpy(pBuf,p1,iLen + 1);
    }
    return pBuf;
}

// Return a count of tokens on the command line.  The executable name by itself makes 1, so the
//  return value is never zero.
int
CLTokens(void)
{
    BOOL fQ = FALSE;
    WCHAR *p1 = pCmdline;
    int i = 0;
    WCHAR c;

    // walk to beginning of the switch argument
    while (1)
    {
        while (1 )
        {
            c = *p1;
            // handle in and out of quote mode
            if (fQ) 
                if (c == '"') 
                {
                    fQ = FALSE;  // empty quotation
                    p1++;
                    break;
                }
            if (c == '"') 
            {
                fQ = TRUE;
            }

            // exit at end of string only
            else if (c == 0) return ++i;       // did not find an arg

            // space between tokens
            else if (c <= 0x20) 
                if (!fQ) break;         

            // normal character - just keep walking
            p1++;
        }
        ++i;
        // skip over whitespace
        while (1)
        {
            c = *p1;
            if (c > 0x20) break;
            if (c == 0) return i;
            p1++;
        }
    }
}

WCHAR
*CLFirstString(WCHAR *pc)
{
    WCHAR *pd = pc;
    if (NULL == pc) return NULL;
    if (*(pc) == 0) return NULL;
    while (*(++pc) > 0x20) continue;
    *pc = 0;
    return pd;
}

WCHAR 
*CLLastString(WCHAR *pc)
{
    WCHAR c;
    WCHAR *pd = pc;
    if (NULL == pc) return NULL;
    if (NULL == *pc) return NULL;
    while (*(++pc) != 0) continue;
    while (pc > pd)
    {
        c = *(--pc);
        if (0 == c) return NULL;
        if (0x20 >= c) break;
    }
    if (pc == pd) return NULL;
    return ++pc;
}

// -------------------------------------------------------------------------
//
// Security and Utility Group
//
// -------------------------------------------------------------------------
void StompCommandLine(INT argc, char **argv)
{
    //return;
    INT cc;
    WCHAR *pL = GetCommandLineW();
    if (pL)
    {
        cc = wcslen(pL);
        if (cc)
        {
            SecureZeroMemory(pL,cc * sizeof(WCHAR));
        }
    }
    // remove c runtime copy contents, as well
    for (INT i=0 ; i < argc ; i++)
    {
        cc = strlen( argv[i]);
        if (cc)
        {
            SecureZeroMemory(pL,cc * sizeof(char));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\cmdkey\cmdkey.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       cmdkey: cmdkey.cpp
//
//  Contents:   Main & command modules
//
//  Classes:
//
//  Functions:
//
//  History:    07-09-01   georgema     Created 
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wincred.h>
#include <wincrui.h>
#include "command.h"
#include "io.h"
#include "utils.h"
#include "consmsg.h"
#include "switches.h"

#ifdef VERBOSE
WCHAR szdbg[500];   // scratch char buffer for verbose output
#endif

/********************************************************************

GLOBAL VARIABLES, mostly argument parsing results

********************************************************************/

int returnvalue = 0;

// Switch flag model characters
#define VALIDSWITCHES 9         // A G L D HELP R U P S

// Define an array of character models and constants for the index into the array
//  for each
WCHAR rgcS[] = {L"agld?rups"};      // referenced also in command.cpp
#define SWADD           0
#define SWGENERIC       1
#define SWLIST          2
#define SWDELETE        3         
#define SWHELP          4
#define SWSESSION       5
#define SWUSER          6
#define SWPASSWORD      7
#define SWCARD          8

// variables for these to avoid repeated function calls into the parser
BOOL fAdd =         FALSE;
BOOL fSession =     FALSE;
BOOL fCard =        FALSE;
BOOL fGeneric = FALSE;
BOOL fDelete =  FALSE;
BOOL fList =    FALSE;
BOOL fUser =    FALSE;
BOOL fNew = FALSE;          // sets true for any cred-creating switch (asg)

WCHAR SessionTarget[]={L"*Session"};

// temp buffer used for composing output strings involving a marshalled username
WCHAR szUsername[CRED_MAX_USERNAME_LENGTH + 1];     // 513 wchars

/********************************************************************

Conversion routines from enumerated values to their string equivalents

String values are held in an array of 63 character max strings

********************************************************************/

#define SBUFSIZE 64
#define TYPECOUNT 5
#define MAPTYPE(x) (x >= TYPECOUNT ? 0 : x)
WCHAR TString[TYPECOUNT][SBUFSIZE + 1];

#define PERSISTCOUNT 4
#define PERTYPE(x) (x>=PERSISTCOUNT ? 0 : x)
WCHAR PString[PERSISTCOUNT][SBUFSIZE + 1];

// Preload some strings from the application resources into arrays to be used by the 
// application.  These strings describe some enumerated DWORD values.
BOOL
AppInit(void)
{
    // Allocate 2K WCHAR buffer to be used for string composition
    if (NULL == szOut)
    {
        szOut = (WCHAR *) malloc((STRINGMAXLEN + 1) * sizeof(WCHAR));
        if (NULL == szOut) return FALSE;
    }

    // Preload string from resources into buffers allocated on the stack as an array
    // Total array size is 9 x 65 WCHARs = 1190 bytes
    wcsncpy(TString[0],ComposeString(MSG_TYPE0),SBUFSIZE);
    TString[0][SBUFSIZE] = 0;
    wcsncpy(TString[1],ComposeString(MSG_TYPE1),SBUFSIZE);
    TString[1][SBUFSIZE] = 0;
    wcsncpy(TString[2],ComposeString(MSG_TYPE2),SBUFSIZE);
    TString[2][SBUFSIZE] = 0;
    wcsncpy(TString[3],ComposeString(MSG_TYPE3),SBUFSIZE);
    TString[3][SBUFSIZE] = 0;
    wcsncpy(TString[4],ComposeString(MSG_TYPE4),SBUFSIZE);
    TString[4][SBUFSIZE] = 0;
    wcsncpy(PString[0],ComposeString(MSG_PERSIST0),SBUFSIZE);
    PString[0][SBUFSIZE] = 0;
    wcsncpy(PString[1],ComposeString(MSG_PERSIST1),SBUFSIZE);
    PString[1][SBUFSIZE] = 0;
    wcsncpy(PString[2],ComposeString(MSG_PERSIST2),SBUFSIZE);
    PString[2][SBUFSIZE] = 0;
    wcsncpy(PString[3],ComposeString(MSG_PERSIST3),SBUFSIZE);
    PString[3][SBUFSIZE] = 0;
    if (PString[3][0] == 0) return FALSE;
    return TRUE;
}

WCHAR 
*TypeString(DWORD dwType)
{
    return TString[MAPTYPE(dwType)];
}

WCHAR 
*PerString(DWORD dwType)
{
    return PString[PERTYPE(dwType)];
}

/********************************************************************

Get operating modes
(Code stolen from Credui:: CredUIApiInit()

********************************************************************/
#define MODEPERSONAL    1
#define MODESAFE        2
#define MODEDC          4

DWORD GetOSMode(void)
{
    DWORD dwMode = 0;
    // Check for Personal SKU:

    OSVERSIONINFOEXW versionInfo;

    versionInfo.dwOSVersionInfoSize = sizeof OSVERSIONINFOEXW;

    if (GetVersionEx(reinterpret_cast<OSVERSIONINFOW *>(&versionInfo)))
    {
        if  ((versionInfo.wProductType == VER_NT_WORKSTATION) &&
            (versionInfo.wSuiteMask & VER_SUITE_PERSONAL))
            dwMode |= MODEPERSONAL;
        if  (versionInfo.wProductType == VER_NT_DOMAIN_CONTROLLER)
            dwMode |= MODEDC;
    }

    // Check for safe mode:

    HKEY key;

    if (RegOpenKeyEx(
           HKEY_LOCAL_MACHINE,
           L"SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Option",
           0,
           KEY_READ,
           &key) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(
                key,
                L"OptionValue",
                NULL,
                NULL,
                NULL,
                NULL) == ERROR_SUCCESS)
        {
            dwMode |= MODESAFE;
        }

        RegCloseKey(key);
    }
#ifdef VERBOSE
    if (dwMode & MODEPERSONAL) OutputDebugString(L"CMDKEY: OS MODE - PERSONAL\n");
    if (dwMode & MODEDC) OutputDebugString(L"CMDKEY: OS MODE - DOMAIN CONTROLLER\n");
    if (dwMode & MODESAFE) OutputDebugString(L"CMDKEY: OS MODE - SAFE BOOT\n");
#endif
    return dwMode;
}

/********************************************************************

Get allowable persistence value for the current logon session
 taken from keymgr: krdlg.cpp

********************************************************************/
DWORD GetPersistenceOptions(DWORD dwPType) {

    BOOL bResult;
    DWORD i[CRED_TYPE_MAXIMUM];
    DWORD dwCount = CRED_TYPE_MAXIMUM;

    bResult = CredGetSessionTypes(dwCount,&i[0]);
    if (!bResult) {
        return CRED_PERSIST_NONE;
    }

    return i[dwPType];
}

/********************************************************************

COMMAND HANDLERS

********************************************************************/

DWORD DoAdd(INT argc, char **argv)
{
    // Add a credential to the keyring.  
    // Note that the *Session credential is created in this routine, as well, though it uses
    //  a different command line switch than /a.
    // For the *Session credential, the persistence is changed to session persistence, and
    //  the targetname is always "*Session".  When the targetname appears on the command
    //  line UI, however, it is replaced by "<dialup session>" to mimic the behavior of keymgr.

    // these buffers needed if we have to prompt
    WCHAR szUser[CREDUI_MAX_USERNAME_LENGTH + 1];       // 513 wchars
    WCHAR szPass[CREDUI_MAX_PASSWORD_LENGTH + 1];       // 257 wchars
        
    CREDENTIAL stCred;      
    DWORD Persist;
    WCHAR *pT = NULL;           // targetname pointer
    BOOL  fP = FALSE;       // password switch present
    BOOL  fS = FALSE;       // smartcard if /C
    WCHAR *pU = CLPtr(SWUSER);
    WCHAR *pP = CLPtr(SWPASSWORD);
    DWORD dwErr = NO_ERROR;
    BOOL IsPersonal;

    szUser[0] = 0;
    szPass[0] = 0;

    IsPersonal = (GetOSMode() & MODEPERSONAL);
    
    // Get default persistence value
    if (IsPersonal)
    {
        if (fSession)
            Persist = CRED_PERSIST_SESSION;
        else
            Persist = GetPersistenceOptions(CRED_TYPE_GENERIC);
    }
    else
    {
        Persist = GetPersistenceOptions(CRED_TYPE_DOMAIN_PASSWORD);
    }

    // Error if no saves allowed and not on personal
    // In personal, error of add operation unless session flag present
    if (
        (CRED_PERSIST_NONE== Persist) ||
        (IsPersonal & (!(fSession || fGeneric)))
      )
    {
        PrintString(MSG_CANNOTADD);
        StompCommandLine(argc,argv);
        return -1;      // special value -1 will suppress default error message generation
    }

    if (fGeneric)
    {
        pT = CLPtr(SWGENERIC);
    }
    else
    {
        pT = CLPtr(SWADD);  // default targetname - may be overridden by generic or session switches
    }

#ifdef VERBOSE
    // Some logging for debug purposes
    if (pT)
        swprintf(szdbg,L"CMDKEY: Target = %s\n",pT);
    else
        swprintf(szdbg,L"CMDKEY: Target = NULL\n");
    OutputDebugString(szdbg);
        
    if (pU)
        swprintf(szdbg,L"CMDKEY: User = %s\n",pU);
    else
        swprintf(szdbg,L"CMDKEY: User is NULL\n");
    OutputDebugString(szdbg);
#endif

    // Original username - may be modified by prompting
    if (pU) 
    {
        wcsncpy(szUser,pU,CREDUI_MAX_USERNAME_LENGTH);
        szUser[CREDUI_MAX_USERNAME_LENGTH] = 0;
    }
    
    // Override target name for prompting purposes
    ZeroMemory((void *)&stCred, sizeof(CREDENTIAL));

    // Prompting block - enter if password or smartcard switch on the commandline 
    if (CLFlag(SWPASSWORD) || fCard)
    {
        if ((pP) && (!fCard))
        {
            stCred.CredentialBlobSize = wcslen(pP) * sizeof(WCHAR);
            stCred.CredentialBlob = (BYTE *)pP;
        }
        else 
        {
            // prompt using credui command line mode
            BOOL fSave = TRUE;
            DWORD retval = 0;
            
            if (!fCard)
            {
                retval = CredUICmdLinePromptForCredentials( 
                                    pT,
                                    NULL,
                                    0,
                                    szUser,
                                    CREDUI_MAX_USERNAME_LENGTH,
                                    szPass,
                                    CREDUI_MAX_PASSWORD_LENGTH,
                                    &fSave,
                                    CREDUI_FLAGS_DO_NOT_PERSIST | 
                                    CREDUI_FLAGS_EXCLUDE_CERTIFICATES |
                                    CREDUI_FLAGS_GENERIC_CREDENTIALS);
            }
            else
            {
                retval = CredUICmdLinePromptForCredentials( 
                                    pT,
                                    NULL,
                                    0,
                                    szUser,
                                    CREDUI_MAX_USERNAME_LENGTH,
                                    szPass,
                                    CREDUI_MAX_PASSWORD_LENGTH,
                                    &fSave,
                                    CREDUI_FLAGS_DO_NOT_PERSIST | 
                                    CREDUI_FLAGS_REQUIRE_SMARTCARD
                                    );
            }
            if (0 != retval) 
            {
#if DBG
                OutputDebugString(L"CMDKEY: CredUI prompt failed\n");
#endif
                dwErr = GetLastError();
                // dont need to stomp the cmdline, since the psw wasnt on it
                return dwErr;
            }
            else
            {
                stCred.CredentialBlobSize = wcslen(szPass) * sizeof(WCHAR);
                stCred.CredentialBlob = (BYTE *)szPass;
            }

        }
    }

    stCred.Persist = Persist;
    stCred.TargetName = pT;
    stCred.UserName = szUser;
    stCred.Type = CRED_TYPE_DOMAIN_PASSWORD;

    // Override type and or persistence as necessary
    // Override the targetname only in the case of a *Session cred
    // Note that generic takes precedence over smartcard
    
    if (fCard)
    {
        stCred.Type = CRED_TYPE_DOMAIN_CERTIFICATE;
    }
    
    if (fGeneric)
    {
        stCred.Type = CRED_TYPE_GENERIC;
    }
    
    if (!CredWrite((PCREDENTIAL)&stCred,0))
    {
         dwErr = GetLastError();
    }
    else PrintString(MSG_ADDOK);

    StompCommandLine(argc,argv);
    SecureZeroMemory(szPass,sizeof(szPass));

    return dwErr;
}

// List the creds currently on the keyring.  Unlike keymgr, show generic creds as well, though
// they cannot be created with cmdkey in this version.
// NOTE: Generic creds will be created using the /g switch in lieu of /a, just as *Session creds 
//  are created by /s in lieu of /a.
DWORD DoList(void)
{
    PCREDENTIALW *pstC;
    DWORD dwCount = 0;
    WCHAR sz[500];
    WCHAR *pL = CLPtr(SWLIST);
  
    if (pL) 
    {
        szArg[0] = pL;
        PrintString(MSG_LISTFOR);
    }
    else PrintString(MSG_LIST);
        
    if (CredEnumerateW(pL,0,&dwCount,&pstC))
    {
        for (DWORD i=0;i<dwCount;i++)
        {
            //Print target: targetname
            // type: type string
            // username: username from cred
            // blank line
            PrintString(MSG_TARGETPREAMBLE);
            if (!_wcsicmp(pstC[i]->TargetName,SessionTarget))
            {
                //swprintf(sz,L"Dialup Session Credential\n");
                PrintString(MSG_DIALUP);
                PutStdout(L"\n");
            }
            else
            {
                PutStdout(pstC[i]->TargetName);
                PutStdout(L"\n");
            }
            szArg[0] = TypeString(pstC[i]->Type);
            PrintString(MSG_LISTTYPE);

            // if the username is NULL, don't show it.  This will happen with incomplete RAS
            //  creds that have not been filled in by Kerberos yet.
            if ((pstC[i]->UserName != NULL) &&
                 (wcslen(pstC[i]->UserName) != 0))
            {

                // UnMarshallUserName will do so only if it is marshalled.  Otherwise will leave it alone
                szArg[0] = UnMarshallUserName(pstC[i]->UserName);
                PrintString(MSG_LISTNAME);

            }

            PutStdout(PerString(pstC[i]->Persist));
        }
        if (pstC) CredFree(pstC);
    }
    
    if (0 == dwCount) 
    {
        PrintString(MSG_LISTNONE);
    }
    return NO_ERROR;
}


// Delete a cred named using the /d switch, or if the /s switch is used, the *Session cred.
DWORD DoDelete(void)
{
    BOOL fOK = FALSE;
    BOOL fSuccess = FALSE;
    DWORD dwErr = -1;
    DWORD dw2;
    WCHAR *pD = CLPtr(SWDELETE);
    
    // get args from cmd line
    // /d:targetname
#ifdef VERBOSE
    if (pD)
        swprintf(szdbg,L"CMDKEY: Target = %s\n",pD);
    else
        swprintf(szdbg,L"CMDKEY: Target = NULL\n");
    OutputDebugString(szdbg);
#endif

    if (fSession) 
    {
        pD = SessionTarget;
    }

    // remove all creds with this target name
    // Any successful delete is success.  If no success...
    // Failure returned is the last failure found by any attempt, excluding parameter faults
    fOK = CredDelete(pD,CRED_TYPE_DOMAIN_PASSWORD,0);
    if (!fOK)
    {
        dw2 = GetLastError();
        if ((dwErr != NO_ERROR) && (dw2 != ERROR_INVALID_PARAMETER)) dwErr = dw2;
    }
    else dwErr = NO_ERROR;
    
    fOK = CredDelete(pD,CRED_TYPE_DOMAIN_VISIBLE_PASSWORD,0);
    if (!fOK)
    {
        dw2 = GetLastError();
        if ((dwErr != NO_ERROR) && (dw2 != ERROR_INVALID_PARAMETER)) dwErr = dw2;
    }
    else dwErr = NO_ERROR;
    
    fOK = CredDelete(pD,CRED_TYPE_GENERIC,0);
    if (!fOK)
    {
        dw2 = GetLastError();
        if ((dwErr != NO_ERROR) && (dw2 != ERROR_INVALID_PARAMETER)) dwErr = dw2;
    }
    else dwErr = NO_ERROR;
    
    fOK = CredDelete(pD,CRED_TYPE_DOMAIN_CERTIFICATE,0);
    if (!fOK)
    {
        dw2 = GetLastError();
        if ((dwErr != NO_ERROR) && (dw2 != ERROR_INVALID_PARAMETER)) dwErr = dw2;
    }
    else dwErr = NO_ERROR;
    
    if (dwErr == NO_ERROR)
    {
        PrintString(MSG_DELETEOK);
    }
    return dwErr;
}

/********************************************************************

Command dispatcher and error handling

********************************************************************/

// Perform the switched command, and display the error returned by GetLastError() if the error 
//  is both nonzero and not -1.
void
DoCmdKey(INT argc,char **argv)
{
    DWORD dwErr = 0;
    if (fAdd)
    {
        dwErr = DoAdd(argc,argv);
    }
    else if (fDelete)
    {
        dwErr = DoDelete();
    }
    else if (fList)
    {
        dwErr = DoList();
    }
    // Common residual error handler
    if (NO_ERROR != dwErr) 
    {
        returnvalue = 1;
        if (dwErr != -1)
        {
            void *pv = NULL;
            PrintString(MSG_PREAMBLE);
            if (0 != FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
                                 0,dwErr,0,(LPTSTR)&pv,500,NULL))
            {
                PutStdout((WCHAR *)pv);
                LocalFree(pv);
            }
        }
    }
}

// show usage string
void
Usage(BOOL fBad)
{
    if (fBad) PrintString(MSG_BADCOMMAND);
    else PrintString(MSG_CREATES);
    PrintString(MSG_USAGE);
    return;
}


/********************************************************************

Entry point - argument parsing, validation and call to dispatcher

********************************************************************/

int __cdecl
main(int argc, char *argv[], char *envp[])
{
    INT iArgs = 0;                  // arg count
    BOOL fError = FALSE;            // command line error detected

    // load needed strings - fail if failed
    if (!AppInit()) 
    {
        // catastrophic exit
        if (szOut) free(szOut);
        return 1;
    }

    //CLInit allocates memory - you must exit via CLUnInit once this call succeeds
    if (!CLInit(VALIDSWITCHES,rgcS)) return 1;
    CLSetMaxPrincipalSwitch(SWDELETE);

    // Parse the command line - fail on duplicated switch
    if (!CLParse())
    {
        PrintString(MSG_DUPLICATE);
        returnvalue = 1;
        goto bail;
    }

    // Two ways to get help - no args at all
    if (1 == CLTokens()) 
    {
        Usage(0);
        returnvalue = 1;
        goto bail;
    }

    // Explicit call for help via /?
    if (CLFlag(SWHELP)) 
    {
        Usage(0);
        returnvalue = 1;
        goto bail;
    }

    // Detect extraneous switches - bail if found
#ifdef PICKY
    if (CLExtra())
    {
        Usage(1);
        returnvalue = 1;
        goto bail;
    }
#endif

    // Set variables
    fAdd        = CLFlag(SWADD);
    fCard       = CLFlag(SWCARD);
    fDelete     = CLFlag(SWDELETE);
    fGeneric    = CLFlag(SWGENERIC);
    fList       = CLFlag(SWLIST);
    fSession    = CLFlag(SWSESSION);
    fUser       = CLFlag(SWUSER);

    // Command line has been parsed - now look for interactions and missing necessities

    // You have to be doing something - test for no principal command
    if (CLGetPrincipalSwitch() < 0)
    {
        // firstcommand value will still be -1 - handled by default below
        fError = TRUE;
    }

    // Weed out illegal combinations, missing arguments to switches where required
    if (!fError && fAdd)
    {
        // need a name arg for this one in its native form
        if (!CLPtr(SWADD)) fError = TRUE;
        // no contradictory switches
        if (fDelete || fList || fGeneric || fSession ) fError = TRUE;
    }
    
    if (!fError && fDelete)
    {
        //need a name arg unless the session switch is on the line
        if ((!fSession) &&(!CLPtr(SWDELETE))) fError = TRUE;
        //disallow target arg with session switch - success is ambiguous
        if ((fSession) && (CLPtr(SWDELETE))) fError = TRUE;
        // no contradictory switches
        if (fAdd || fList || fGeneric || fUser ) fError = TRUE;
    }
    
    if (!fError && fList)
    {
        // no contradictory switches
        if (fDelete || fAdd || fGeneric ||fUser || fSession) fError = TRUE;
    }

    // The generic flag replaces the add flag, using a different cred type.
    // Do not allow it with the Add flag, and insist on a command argument
    if (!fError && fGeneric)
    {
        if (!CLPtr(SWGENERIC)) fError = TRUE;
        // no contradictory switches
        if (fAdd) fError = TRUE;
        // generic cred is an add operation
        if (!fError) fAdd = TRUE;
    }

    // Display help for what we think is the operation the user attempted
    // First announce that parameters were bad, then show help
    if (fError)
    {
        PrintString(MSG_BADCOMMAND);
        switch(CLGetPrincipalSwitch())
        {
            case SWADD:
                PrintString(MSG_USAGEA);
                break;
            case SWGENERIC:
                PrintString(MSG_USAGEG);
                break;
            case SWLIST:
                PrintString(MSG_USAGEL);
                break;
            case SWDELETE:
                PrintString(MSG_USAGED);
                break;
            default:
                PrintString(MSG_USAGE);
                break;
        }
        goto bail;
    }

    // Must specify a user for any add operation
    // If the smartcard switch is supplied, the username may be absent
    if (fAdd)
    {
        if ((!CLPtr(SWUSER)) && (!fCard)) 
        {
            PrintString(MSG_NOUSER);
            returnvalue = 1;
            goto bail;
        }
    }
    
    DoCmdKey(argc,argv);     // Execute the command action
bail:
    CLUnInit();
    if (NULL != szOut) free(szOut);
    return returnvalue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\cmdkey\io.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       cmdkey: IO.H
//
//  Contents:   Command line input/output header
//
//  Classes:
//
//  Functions:
//
//  History:    07-09-01   georgema     Created 
//
//----------------------------------------------------------------------------
#ifndef __IO_H__
#define __IO_H__

#define STRINGMAXLEN 2000

#ifdef IOCPP
// variables to be allocated by the IO subsystem, visible to other modules
HMODULE hMod = NULL;
WCHAR *szArg[4] = {0};
//WCHAR szOut[STRINGMAXLEN + 1] = {0};
WCHAR *szOut = NULL;
#else
extern HMODULE hMod;
extern WCHAR *szArg[];
//extern WCHAR szOut[];
extern WCHAR *szOut;
#endif

// STD IN/OUT GROUP

DWORD
GetString(
    LPWSTR  buf,
    DWORD   buflen,
    PDWORD  len
    );

VOID
GetStdin(
    OUT LPWSTR Buffer,
    IN DWORD BufferMaxChars
    );

VOID
PutStdout(
    IN LPWSTR String
    );

// MESSAGES GROUP

WCHAR *
 ComposeString(DWORD);

void 
PrintString(DWORD);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\cmdkey\switches.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       cmdkey: switches.h
//
//  Contents:   option switches
//
//  Classes:
//
//  Functions:
//
//  History:    07-09-01   georgema     Created 
//
//----------------------------------------------------------------------------
#ifndef __SWITCHES__
#define __SWITCHES__

#ifndef DBG
#define DBG 0
#endif

#if DBG
#define IF_DEBUG if (TRUE)
#else
#define IF_DEBUG if (FALSE)
#endif

#if DBG
// debug verbosity controls
#undef CLPARSER
#define VERBOSE
#endif

// compile-time code options
#define PICKY
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\cmdkey\utils.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       cmdkey: UTILS.H
//
//  Contents:   Utility functions
//
//                  1.  Convert marshalled username to a more informative string
//
//  Classes:
//
//  Functions:
//
//  History:    08-09-01   georgema     Created 
//
//----------------------------------------------------------------------------
#ifndef __UTILS_H__
#define __UTILS_H__

WCHAR *UnMarshallUserName(WCHAR *pszMarshalled);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\cmdkey\io.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       cmdkey: IO.cpp
//
//  Contents:   Command line input/output routines suitable for international use
//
//  Classes:
//
//  Functions:
//
//  History:    07-09-01   georgema     Created 
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <lmerr.h>
#include <malloc.h>

#define IOCPP
#include "io.h"
#include "consmsg.h"

/***    GetString -- read in string with echo
 *
 *      DWORD GetString(char far *, USHORT, USHORT far *, char far *);
 *
 *      ENTRY:  buf             buffer to put string in
 *              buflen          size of buffer
 *              &len            address of USHORT to place length in
 *
 *      RETURNS:
 *              0 or NERR_BufTooSmall if user typed too much.  Buffer
 *              contents are only valid on 0 return.  Len is ALWAYS valid.
 *
 *      OTHER EFFECTS:
 *              len is set to hold number of bytes typed, regardless of
 *              buffer length.
 *
 *      Read in a string a character at a time.  Is aware of DBCS.
 *
 *      History:
 *              who     when    what
 *              erichn  5/11/89 initial code
 *              dannygl 5/28/89 modified DBCS usage
 *              danhi   3/20/91 ported to 32 bits
 *              cliffv  3/12/01 Stolen from netcmd
 */

DWORD
GetString(
    LPWSTR  buf,
    DWORD   buflen,
    PDWORD  len
    )
{
    DWORD c;
    DWORD err;

    buflen -= 1;    /* make space for null terminator */
    *len = 0;       /* GP fault probe (a la API's) */

    while (TRUE) {
        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), buf, 1, &c, 0);
        if (!err || c != 1) {
            *buf = 0xffff;
        }

        if (*buf == (WCHAR)EOF) {
            break;
        }

        if (*buf ==  '\r' || *buf == '\n' ) {
            INPUT_RECORD    ir;
            DWORD cr;

            if (PeekConsoleInput(GetStdHandle(STD_INPUT_HANDLE), &ir, 1, &cr)) {
                ReadConsole(GetStdHandle(STD_INPUT_HANDLE), buf, 1, &c, 0);
            }
            break;
        }

        buf += (*len < buflen) ? 1 : 0; /* don't overflow buf */
        (*len)++;                       /* always increment len */
    }

    *buf = '\0';            /* null terminate the string */

    return ((*len <= buflen) ? 0 : NERR_BufTooSmall);
}

VOID
GetStdin(
    OUT LPWSTR Buffer,
    IN DWORD BufferMaxChars
    )
/*++

Routine Description:

    Input a string from stdin in the Console code page.

    We can't use fgetws since it uses the wrong code page.

Arguments:

    Buffer - Buffer to put the read string into.
        The Buffer will be zero terminated and will have any traing CR/LF removed

    BufferMaxChars - Maximum number of characters to return in the buffer not including
        the trailing NULL.

    EchoChars - TRUE if the typed characters are to be echoed.
        FALSE if not.

Return Values:

    None.

--*/
{
    DWORD NetStatus;
    DWORD Length;

    NetStatus = GetString( Buffer,
                           BufferMaxChars+1,
                           &Length );

    if ( NetStatus == NERR_BufTooSmall ) {
        Buffer[0] = '\0';
    }
}

VOID
PutStdout(
    IN LPWSTR String
    )
/*++

Routine Description:

    Output a string to stdout in the Console code page

    We can't use fputws since it uses the wrong code page.

Arguments:

    String - String to output

Return Values:

    None.

--*/
{
    int size;
    LPSTR Buffer = NULL;
    DWORD dwcc = 0;                                                     // char count
    DWORD dwWritten = 0;                                            // chars actually sent
    BOOL fIsConsole = TRUE;                                         // default - tested and set
    HANDLE hC = GetStdHandle(STD_OUTPUT_HANDLE);    // std output device handle
    if (INVALID_HANDLE_VALUE == hC) return;                                             // output is unavailable

    if (NULL == String) return;                                       // done if no string
    dwcc = wcslen(String);

    // Determine type of the output handle (Is a console?)
    DWORD ft = GetFileType(hC);
    ft &= ~FILE_TYPE_REMOTE;
    fIsConsole = (ft == FILE_TYPE_CHAR);
    
    if (fIsConsole) 
    {
        WriteConsole(hC,String,dwcc,&dwWritten,NULL);
        return;
    }

    // Handle non-console output routing
    //
    // Compute the size of the converted string
    //

    size = WideCharToMultiByte( GetConsoleOutputCP(),
                                0,
                                String,
                                -1,
                                NULL,
                                0,
                                NULL,
                                NULL );

    if ( size == 0 ) {
        return;
    }

    //
    // Allocate a buffer for it
    //

    __try {
        Buffer = static_cast<LPSTR>( alloca(size) );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Buffer = NULL;
    }

    if ( Buffer == NULL) {
        return;
    }

    //
    // Convert the string to the console code page
    //

    size = WideCharToMultiByte( GetConsoleOutputCP(),
                                0,
                                String,
                                -1,
                                Buffer,
                                size,
                                NULL,
                                NULL );

    if ( size == 0 ) {
        return;
    }

    //
    // Write the string to stdout
    //

    //fputs( Buffer, stdout );
    WriteFile(hC,Buffer,size,&dwWritten,NULL);

}


// --------------------------------------------------------------------------
//
// MESSAGES GROUP
//
// --------------------------------------------------------------------------


/* ++

ComposeString is used to fetch a string from the message resources for the application, substituting 
argument values as appropriate.  Argument values are placed in the global vector of argument
pointers, szArg.

The output string is delivered to the global string buffer, szOut.

This means, of course, that you can't have multiple strings in play at the same time.  If more than
one string needs to be used, you must copy all but the last to external temporary buffers.

-- */
WCHAR *
ComposeString(DWORD dwID)
{
    if (NULL == hMod) hMod = GetModuleHandle(NULL);
    if (0 == dwID) return NULL;

    if (0 == FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      hMod,
                      dwID,
                      0,
                      szOut,
                      STRINGMAXLEN,
                      (va_list *)szArg))
    {
        szOut[0] = 0;
    }
    return szOut;
}

/* ++

Print a string from the message resources with argument substitution.

-- */
void
PrintString(DWORD dwID)
{
    PutStdout(ComposeString(dwID));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\cmdkey\utils.cpp ===
#include <windows.h>
#include <wincred.h>
#include "io.h"
#include "consmsg.h"

extern WCHAR szUsername[];

/*
Accept as input a username via a pointer.  Return a pointer (to the global buffer)
which contains the username string unmodified if it is not a marshalled cert name,
or the certificate display name if it is a certificate.
*/
WCHAR *
UnMarshallUserName
(WCHAR *pszMarshalled)
{
    if (CredIsMarshaledCredential(pszMarshalled))
    {   
        CRED_MARSHAL_TYPE ct;
        PVOID pumc = NULL;
        if (CredUnmarshalCredential(pszMarshalled,
            &ct,
            &pumc))
        {
            if (ct == CertCredential)
            {
                // for now, we're not going to use the actual unmarshalled name, just a constant string
                CredFree(pumc);
                wcsncpy(szUsername, ComposeString(MSG_ISCERT),CRED_MAX_USERNAME_LENGTH);
                return szUsername;
            }
            else
            {
                // This marshalled type should never be persisted in the store.  Pretend it's not really marshalled.
                return pszMarshalled;
            }
        }
        else
        {
            // use missing certificate string
            wcsncpy(szUsername, ComposeString(MSG_NOCERT),CRED_MAX_USERNAME_LENGTH);
            return szUsername;
        }
    }
    return pszMarshalled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\itgras\audit.h ===
#ifndef __AUDIT__
#define __AUDIT__


/*

AUDIT.H is a machine-generated file, created by MAKEAUDIT.EXE.
This file need not be checked into your project, though it will
need to be generated in order to create a testaudit instrumented binary.
This file is included only by testaudit.cpp, only when a testaudit build
is made.  

A testaudit build should always be a clean build, in order to
ensure that the current auditing information is built into the binary.

*/

AUDITDATA AuditData[] = {

    // Searching itgrasxp.cpp
    {2, L"itgrasxp.cpp @ 68 : Username and password not both filled in."}
    ,{3, L"itgrasxp.cpp @ 74 : Username not domain\\username."}
    ,{8, L"itgrasxp.cpp @ 120 : Override server found in registry"}
    ,{9, L"itgrasxp.cpp @ 128 : No server override found in registry"}
    ,{7, L"itgrasxp.cpp @ 162 : Reached the server, but the creds were no good"}
    ,{6, L"itgrasxp.cpp @ 172 : Not able to validate - server unreachable"}
    ,{5, L"itgrasxp.cpp @ 247 : Leave the dialog by cancel."}
    ,{1, L"itgrasxp.cpp @ 286 : No preexisting certificate cred for *Session"}
    ,{4, L"itgrasxp.cpp @ 313 : Sucessfully saved a cred."}
    // Searching itgrasxp.rc

};
#define CHECKPOINTCOUNT (sizeof(AuditData) / sizeof(AUDITDATA))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\itgras\res.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Script1.rc
//
#define IDC_CRED			50
#define IDD_MAINDIALOG 		102
#define IDS_APP_NAME            200
#define IDS_APP_DESCRIPTION    201
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\itgras\itgrasxp.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ItgRasXp

File Name:

    ItgRasXp.cpp

Abstract:

	This is the entry point file for the ITG RAS Smartcard Support Applet.  This app 
	prompts the user for his domain\username and password credentials, and uses 
	these to create a *Session credential that is used for NTLM authentication for 
	servers on the network which do not use Kerberos.
	
Author:


Environment:

    Win32, C++

Revision History:

	none

Notes:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commdlg.h>
#include <commctrl.h>
#include <ole2.h>
#include <stdio.h>

#include <lmcons.h>
#include <wincred.h>
#include <wincrui.h>

#define SECURITY_WIN32
#include <security.h>
#include "testaudit.h"

#include "res.h"

BOOL gfSuccess = FALSE;
HINSTANCE ghInstance = NULL;

#if 0

#define TESTKEY L"Environment"

#else

#define TESTKEY L"Software\\Microsoft\\Connection Manager\\Worldwide Dial-Up RAS to MS Corp"

#endif


// see if name valid - check for common mistakes.  At the moment, we merely insist that
//  the user fill in both username and password, and that the username contains the '\' 
//  character, making it more likely that it is an approved domain\usernaem form.
BOOL CheckUsername(WCHAR *pszUsername,WCHAR *pszPassword)
{
    ASSERT(pszUsername);
    ASSERT(pszPassword);
    if ((0 == wcslen(pszUsername)) || (0 == wcslen(pszPassword)))
    {
        CHECKPOINT(2,"Username and password not both filled in.");
        MessageBox(NULL,L"Both username and password must be specified.",L"Error",MB_ICONHAND);
        return FALSE;
    }
    if (NULL == wcschr(pszUsername,L'\\'))
    {
        CHECKPOINT(3,"Username not domain\\username.");
        MessageBox(NULL,L"The username format must be \"domain\\username\".",L"Error",MB_ICONHAND);
        return FALSE;
    }
    else return TRUE;
}

// Attempt to use the credentials that the user entered and return FALSE if they do not
// appear to be valid on the net.  Show the user any errors that arise from trying to validate
// his credentials.  In the event that validation is impossible owing to a network error or some
// other error not the fault of his credentials, save them anyway, though with a warning.

#define DEFAULTSERVER L"\\\\products\\public"

BOOL IsCredentialOK(WCHAR *pszUsername,WCHAR *pszPassword)
{
    ASSERT(pszUsername);
    ASSERT(pszPassword);
    NETRESOURCE stNetResource;
    WCHAR szServer[MAX_PATH + 1];   // to hold test host string from registry
    BOOL fKeyFound = FALSE;
    DWORD dwErr = 0;
    DWORD dwSize = 0;           // for return from open connection
    DWORD dwResult = 0;         // for return from open connection
    HKEY hKey= NULL;                // reg key rread
    DWORD dwType;                   // reg key read return
    DWORD dwDataSize = 0;       // reg key read in/out

    memset(&stNetResource,0,sizeof(NETRESOURCE));

    // prepare the servername preset to the default
    wcsncpy(szServer,DEFAULTSERVER,MAX_PATH);
    
    // Look for server in registry HKCU.  If found, use it to overwrite the default server
    if ((!fKeyFound) && (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,TESTKEY,0,KEY_READ,&hKey)))
    {
        if ((hKey) && (ERROR_SUCCESS == RegQueryValueEx(hKey,L"RAS Test Host",0,&dwType,(LPBYTE) NULL,&dwDataSize)))
        {
            // key value exists and is of size dwDataSize
            WCHAR *pString = (WCHAR *) LocalAlloc(LMEM_FIXED,dwDataSize);
            ASSERT(pString);
            ASSERT(dwType == REG_SZ);
            if (pString)
            {
                if (ERROR_SUCCESS == RegQueryValueEx(hKey,L"RAS Test Host",0,&dwType,(LPBYTE) pString,&dwDataSize))
                {
                    CHECKPOINT(9,"Override server found in registry in HKCU");
                    wcsncpy(szServer,pString,dwDataSize / sizeof(WCHAR));
                    fKeyFound = TRUE;
                }
                LocalFree(pString);
            }
        }
        RegCloseKey(hKey);
        hKey = NULL;
    }

    // Look for server in registry HKLM.  
    if ((!fKeyFound) && (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,TESTKEY,0,KEY_READ,&hKey)))
    {
        if ((hKey) && (ERROR_SUCCESS == RegQueryValueEx(hKey,L"RAS Test Host",0,&dwType,(LPBYTE) NULL,&dwDataSize)))
        {
            // key value exists and is of size dwDataSize
            WCHAR *pString = (WCHAR *) LocalAlloc(LMEM_FIXED,dwDataSize);
            ASSERT(pString);
            ASSERT(dwType == REG_SZ);
            if (pString)
            {
                if (ERROR_SUCCESS == RegQueryValueEx(hKey,L"RAS Test Host",0,&dwType,(LPBYTE) pString,&dwDataSize))
                {
                    CHECKPOINT(8,"Override server found in registry in HKLM");
                    wcsncpy(szServer,pString,dwDataSize / sizeof(WCHAR));
                    fKeyFound = TRUE;
                }
                LocalFree(pString);
            }
        }
        RegCloseKey(hKey);
        hKey = NULL;
    }

    #if TESTAUDIT
    if (!fKeyFound) CHECKPOINT(10,"No override server found in registry");
    #endif

    stNetResource.dwType = RESOURCETYPE_DISK;
    stNetResource.lpLocalName = NULL;
    stNetResource.lpRemoteName = szServer;
    stNetResource.lpProvider = NULL;
 
    dwErr = WNetUseConnection( NULL,
                                                &stNetResource,
                                                pszPassword,
                                                pszUsername,
                                                0,
                                                NULL,       // lpAccessName
                                                &dwSize,   // size of lpAccessName buffer
                                                &dwResult);
                                                
    if (dwErr == S_OK)
    {
        // On successful connection, tear down the connection and return success
        WNetCancelConnection2(szServer, 0, TRUE);
        return TRUE;
    }

    // Errors are handled by presenting a message box.   If the server was found and rejected
    //  the creds, don't save them - give the user a chance to correct.  If the server was 
    //  unavailable, save the creds anyway, but warn the user that they were unvalidated.
    switch (dwErr)
    {
        case ERROR_ACCESS_DENIED:
        case ERROR_INVALID_PASSWORD:
            // announce that the password is no good
            CHECKPOINT(7,"Reached the server, but the creds were no good");
            MessageBox(NULL,L"The entered username and password are not correct",L"Error",MB_ICONHAND);
            break;

        case ERROR_NO_NET_OR_BAD_PATH:
        case ERROR_NO_NETWORK:
        case ERROR_EXTENDED_ERROR:
        case ERROR_BAD_NET_NAME:
        case ERROR_BAD_PROVIDER:
        default:
            CHECKPOINT(6,"Not able to validate - server unreachable");
            MessageBox(NULL,L"Your username and password will be saved for this session, though they could not be verified. They may be incorrect.",L"Error",MB_ICONHAND);
            return TRUE;        // permit them to be saved anyway
            // announce that we cannot validate, and let them save it anyway
            break;
            
    }
    return FALSE;
}

// Store the user's entered credentials on the keyring as a session persisted *Session cred.
// Call IsCredentialOK() before storing.  If the credentials don't appear correct, present
// a message box describing the error and leave the dialog up.

BOOL WriteDomainCreds(WCHAR *pszUsername,WCHAR *pszPassword)
{
    CREDENTIAL cred;
    
    if (!CheckUsername(pszUsername,pszPassword))
    {   
        return FALSE;
    }
    if (!IsCredentialOK(pszUsername,pszPassword))
    {
        return FALSE;
    }
    
    memset(&cred,0,sizeof(CREDENTIAL));
    cred.TargetName = CRED_SESSION_WILDCARD_NAME_W;
    cred.UserName = pszUsername;
    cred.CredentialBlob = (LPBYTE) pszPassword;
    cred.CredentialBlobSize = (wcslen(pszPassword) * sizeof(WCHAR));
    cred.Type = CRED_TYPE_DOMAIN_PASSWORD;
    cred.Persist = CRED_PERSIST_SESSION;
    return CredWrite(&cred,0);
}

INT_PTR CALLBACK DialogProc(
    HWND hwnd,
    UINT msg,
    WPARAM wparam,
    LPARAM lparam)
{
    INT_PTR ret;
    HWND hwndCred = NULL;
    
    switch (msg)
    {
    case WM_COMMAND:
    	// Button clicks.
    	switch(LOWORD(wparam))
        {
            case IDOK:
                if (HIWORD(wparam) == BN_CLICKED)
                {
                    WCHAR szUser[UNLEN + 1];
                    WCHAR szPass[PWLEN + 1];
                    szUser[0] = 0;
                    szPass[0] = 0;
                    HWND hCc = GetDlgItem(hwnd,IDC_CRED);
                    ASSERT(hCc);
                    Credential_GetUserName(hCc,szUser,UNLEN);
                    Credential_GetPassword(hCc,szPass,PWLEN);
                    // Get contents of the cred control controls and write the session cred
                    gfSuccess = WriteDomainCreds(szUser,szPass);
                    SecureZeroMemory(szPass,sizeof(szPass));
                    if (gfSuccess)
                    {
                        EndDialog(hwnd,IDOK);
                    }
                }
                break;
            case IDCANCEL:
                if (HIWORD(wparam) == BN_CLICKED)
                {
                    CHECKPOINT(5,"Leave the dialog by cancel.");
                    // Exit doing nothing
                    EndDialog(hwnd,IDCANCEL);
                }
                break;
            default:
                break;
        }
    	 break;

    default:
        break;
    }
    //return DefWindowProc(hwnd, msg, wparam, lparam);
    return FALSE;
}

int WINAPI WinMain (
	HINSTANCE hInstance,
	HINSTANCE hPrevInstance,
	LPSTR lpszCmdParam,
	int nCmdShow)
{
        CHECKPOINTINIT;
        ghInstance = hInstance;
        //OleInitialize(NULL);
            
        INITCOMMONCONTROLSEX stICC;
        BOOL fICC;
        stICC.dwSize = sizeof(INITCOMMONCONTROLSEX);
        stICC.dwICC = ICC_WIN95_CLASSES | ICC_STANDARD_CLASSES;
        fICC = InitCommonControlsEx(&stICC);

        // Silent fail if there is no preexisting cert credential.
        CREDENTIAL *pCred = NULL;
        BOOL fOK = CredRead(L"*Session",CRED_TYPE_DOMAIN_CERTIFICATE,0,&pCred);
        CredFree(pCred);
        if (!fOK)
        {
            CHECKPOINT(1,"No preexisting certificate cred for *Session");
            CHECKPOINTFINISH;
            return 1;
        }

        // Gen up credui
        if (!CredUIInitControls()) 
        {
            return 1;
        }

        // show the ui
        INT_PTR iErr = DialogBoxParam(
            hInstance,
            MAKEINTRESOURCE(IDD_MAINDIALOG),
            GetForegroundWindow(),
            DialogProc,
            NULL);

        if (iErr != IDOK && iErr != IDCANCEL)
        {
            MessageBox(NULL,L"An error occurred saving credential information.",L"Error",MB_OK);
            CHECKPOINTFINISH;
            return 0;
        }
        else
        {
            CHECKPOINT(4,"Sucessfully saved a cred.");
            CHECKPOINTFINISH;
            return 1;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keycpl\apsres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by KEYMGR.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        111
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1074
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\itgras\testaudit.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    testaudit.cpp

Abstract:

    Test Auditing routines.  Used by development to document the locations 
    and reach conditions for code checkpoints that test should be sure to cover.
    Used by test to ensure that the test meets the expectations of the developer
    and to locate points of interest in the source files.

    This file will compile to nothing if TESTAUDIT is not a defined symbol in
    the build environment.  For this purpose, buildx.cmd has been modified to
    provide for setting this symbol.

Author:

    georgema        Nov., 2001  created

Environment:

Revision History:

--*/

#if TESTAUDIT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <testaudit.h>
#include "audit.h"

// Data structure element for the auditing data
typedef struct _touchstruct
{
    INT iPoint;
    BOOL fTouched;
}TOUCHSTRUCT, *PTOUCHSTRUCT;

#define TOUCHSIZE sizeof(TOUCHSTRUCT)

// Arbitrary limit on point number range, in order to be able to constrain the
//  size of the runtime point-hit array to manageable size without having to 
//  do anything cute.
#define NUMBERLIMIT 500 

// Global variable to hold mem allocation for auditing data
TOUCHSTRUCT *pTouch = NULL;

// Global variable to hold last touched point
INT iLastPoint = 0;

// Global variable to hold BOOL value for enabling checkpoint hit messages
// This way, the initial value is available to manipulate with the debugger
#if TESTAUDITHITS
    BOOL fShowCheckpointHits = TRUE;
#else
    BOOL fShowCheckpointHits = FALSE;
#endif

/*************************************************************************

BranchInit

    Creates a memory allocation to hold data regarding whether particular
    checkpoints have been visited.  Reads reference numbers from the 
    AuditData structure, and creates pairs of the reference number and
    a boolean to be set true when the point is hit.

    arguments: none
    returns: none
    errors: May fail due to out of memory.  On this case, returns with
             the pointer NULL.  Further calls into these functions with
             a NULL ptr will do nothing at all.

*************************************************************************/
void BranchInit(void)
{
    WCHAR sz[100];
    
    swprintf(sz,L"TEST: %d checkpoints defined\n",CHECKPOINTCOUNT);
    OutputDebugString(sz);
    
    pTouch = (TOUCHSTRUCT *) LocalAlloc(LMEM_FIXED,CHECKPOINTCOUNT * sizeof(TOUCHSTRUCT));
    if (NULL == pTouch) return;

    // table allocation successful.  Initialize using point #s
    memset(pTouch,0,(CHECKPOINTCOUNT * sizeof(TOUCHSTRUCT)));
    for (INT i=0;i<CHECKPOINTCOUNT;i++)
    {
        // go through the AuditData[] struct and fetch the point numbers
        pTouch[i].iPoint = AuditData[i].iPoint;
    }

    // Init the last point variable, in case this is a re-init
    iLastPoint = 0;
    
}


/*************************************************************************

BranchTouch

    Looks through the memory table created by BranchInit for a match with
    the passed point number.  Sets the matching table entry to show that
    the point was visited.  The string is not passed to this routine in 
    order to minimize the amount of memory allocation, processing, and
    debug output.

    arguments: INT point number
    returns: none
    errors: May fail to find the point number.  If so, does nothing.

*************************************************************************/
void BranchTouch(INT iBranch)
{
    WCHAR sz[100];
    INT j;
    
    if (NULL == pTouch) return;

    // warn user about obviously bad checkpoint statements
    if (0 == iBranch)          ASSERT(0);
    if (iBranch > NUMBERLIMIT) ASSERT(0);
    
    if (fShowCheckpointHits)
    {
        swprintf(sz,L"TEST: Checkpoint %d touched. \n",iBranch);
        OutputDebugString(sz);
    }
    // look for this point number and set its touched flag
    for (j=0;j<CHECKPOINTCOUNT;j++)
    {
        if (pTouch[j].iPoint == iBranch)
        {
            pTouch[j].fTouched = TRUE;
            break;
        }
    }
    
    // detect checkpoint for which no table entry exists
    if (j == CHECKPOINTCOUNT) ASSERT(0);
}

/*************************************************************************

BranchSequence

    Modification of BranchTouch() that will mark a checkpoint as visited only if the checkpoint
    named as the second argument had been touched last.  Uses the iLastPoint state variable 
    to keep track of the last sequential checkpoint to be touched.  Only the sequential macros
    will affect this value, so intervening CHECKPOINT macros will have no effect.

    arguments: INT point number, INT point number
    returns: none
    errors: May fail to find the point number.  If so, does nothing.

*************************************************************************/
void BranchSequence(INT iThis,INT iPrevious)
{
    WCHAR sz[100];
    INT j;
    
    if (NULL == pTouch) return;

    // warn user about obviously bad checkpoint statements
    if (iPrevious > NUMBERLIMIT) ASSERT(0);

    // Process force/reset of the sequence
    if (iPrevious == iThis)
    {
        iLastPoint = iThis;
        return;
    }
    
    // Reject out of sequence unless previous was 0
    if ((iPrevious != 0) &&
        (iPrevious != iLastPoint))
    {
        // If detect out of sequence, reset the sequence
        iLastPoint = 0;
        return;
    }

    // Process a touch
    iLastPoint = iThis;
    if (iThis != 0)
    {
        BranchTouch(iThis);
    }
    
}

/*************************************************************************

BranchSummary

    Looks through the memory table created by BranchInit for entries 
    which show that they were not reached.  For these, scans the 
    AuditData table looking for a match, and prints the entry number
    together with the associated string as part of a table shown to 
    the operator in the debug output.

    arguments: none
    returns: none
    errors: none expected unless the table is corrupted

*************************************************************************/
void BranchSummary(void)
{
    WCHAR sz[100];
    INT i;
    BOOL fUntouched = FALSE;        // set true if any untouched found

    if (NULL == pTouch) return;

    // if TESTAUDITSUMMARY is false, this routine will do nothing but
    //  free the touch array
#if TESTAUDITSUMMARY
    swprintf(sz,L"TEST: Total of %d checkpoints.\n",CHECKPOINTCOUNT);
    OutputDebugString(sz);
    OutputDebugString(L"TEST: Untouched checkpoints:\n");

    // Scan every entry in the checkpoint table
    for (i=0;i<CHECKPOINTCOUNT;i++)
    {
        // find all untouched
        if (pTouch[i].fTouched == FALSE)
        {
            // find matching entry in data table
            // there should be no match failures unless the table becomes 
            // corrupted
            INT j;
            for (j=0;j<CHECKPOINTCOUNT;j++)
            {
                // on match, print number and string
                if (pTouch[i].iPoint == AuditData[j].iPoint)
                {
                    swprintf(sz,L"   %d   ",pTouch[i].iPoint);
                    OutputDebugString(sz);
                    if (AuditData[j].pszDescription != NULL)
                    {
                        OutputDebugString(AuditData[j].pszDescription);
                    }
                    OutputDebugString(L"\n");
                    break;
                }
            }
            if (j == CHECKPOINTCOUNT) ASSERT(0);
            fUntouched = TRUE;
        }
    }
    if (!fUntouched)
    {
        OutputDebugString(L"   ***NONE***\n");
    }
#endif
    LocalFree(pTouch);
    pTouch = NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keycpl\keymgr.h ===
#ifndef _KEYMGR_H_
#define _KEYMGR_H_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    KEYMGR.H

Abstract:

    KeyMgr application public API definitions
     
Author:

    990917  johnhaw Created. 
    georgema        000310  updated

Environment:
    Win98, Win2000

Revision History:

--*/

#endif  //  _KEYMGR_H_

//
///// End of file: KeyMgr.h ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keycpl\res.h ===
#ifndef _RES_H_
#define _RES_H_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RES.H

Abstract:

    Resource symbols for keymgr application
     
Author:

    990518  dane    Created. 
    georgema        000310  updated

Environment:
    Win98, Win2000

Revision History:

--*/

#define IDI_UPGRADE                          100

#define IDS_APP_NAME                         500
#define IDS_APP_DESCRIPTION                  504

// NEXT CONTROL VALUE 1091
// NEXT RESOURCE VALUE ?
// NEXT COMMAND VALUE ?
// NEXT SYMED VALUE ?

#endif  //  _RES_H_

//
///// End of file: Res.h   ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\itgras\testaudit.h ===
#ifndef _TESTAUDIT_H_
#define _TESTAUDIT_H_
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    testaudit.h

Abstract:

    Test Auditing routines.  Used by development to document the locations 
    and reach conditions for code checkpoints that test should be sure to cover.
    Used by test to ensure that the test meets the expectations of the developer
    and to locate points of interest in the source files.

    These routines disappear altogether if the build is not a debug build and
    if the symbol TESTAUDIT is not defined.  To accomplish this, the command
    file buildx.cmd in the tools directory, is modified to provide for setting
    this flag.

    To use testaudit.h/cpp in your project, you must run the MAKEAUDIT.EXE utility,
    which processes files in the current directory, and generates an AUDIT.H file
    which is included in testaudit.cpp.  This file defines the descriptive strings
    for the checkpoints unreached by the code.  It should be rebuilt whenever changes
    in the source files result in material changes to the line numbers associated 
    with checkpoints.

    Usage examples:

    CHECKPOINTINIT;             Initializes the test auditing data structure - appears
                                 once in an executable unit
    CHECKPOINT(3,"Print page"); Defines checkpoint 3 as "Print page" - Produces an entry
                                 in AUDIT.H with the file, linenumber, and this
                                 description.
    CHECKPOINTFINISH;           Prints statistics to the debug output and cleans up - 
                                 Called when the executable exits.  Shows the checkpoint
                                 number, file, line number, and description for all 
                                 unreached checkpoints.

    Statement blocks can be conditionally compiled in test auditing builds by use of 
    the preprocessor #if directive and the TESTAUDIT symbol.  The usual use is to preface 
    conditional checkpoints to permit testing for different conditions passing the same 
    checkpoint, something like this:

    #if TESTAUDIT
            if (mode_one) CHECKPOINT(3,"Print page portrait mode");
            if (Mode_two) CHECKPOINT(4,"Print page landscape mode");
    #endif

Author:

    georgema        Nov., 2001  created

Environment:

Revision History:

--*/

// These macros disappear if the build is not debug or if the symbol TESTAUDIT
// is not defined.

#if DBG
#if TESTAUDIT

typedef struct _AuditData 
{
    INT  iPoint;
    WCHAR *pszDescription;     
} AUDITDATA;

#define CHECKPOINT(x,y) BranchTouch(x)
#define SEQUENCE(x,y,z) BranchSequence(x,y)
#define RESETSEQUENCE BranchSequence(0,0)
#define FORCESEQUENCE(x) BranchSequence(x,x)
#define CHECKPOINTINIT BranchInit()
#define CHECKPOINTFINISH BranchSummary()
#else
#define CHECKPOINT(x,y)
#define SEQUENCE(x,y,z)
#define RESETSEQUENCE
#define FORCESEQUENCE(x)
#define CHECKPOINTINIT
#define CHECKPOINTFINISH
#endif
#else
#define CHECKPOINT(x,y)
#define SEQUENCE(x,y,z)
#define RESETSEQUENCE
#define FORCESEQUENCE(x)
#define CHECKPOINTINIT
#define CHECKPOINTFINISH
#endif

#define NCHECKPOINT(x,y)

#if defined (__cplusplus)
extern "C" {
#endif
void BranchTouch(INT);
void BranchSequence(INT,INT);
void BranchInit(void);
void BranchSummary(void);
#if defined (__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\chgpsw.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    CHGPSW.CPP

Abstract:

    Handler for the CHANGE button on the properties dialog, 
    used to change the user's domain password.
     
Author:

    990917  johnhaw Created. 
    georgema        000310  updated
    georgema        000501  used to be EXE, changed to CPL

Comments:

Environment:
    WinXP

Revision History:

--*/
// test/dev switch variables
#include "switches.h"

//////////////////////////////////////////////////////////////////////////////
//
//  Include files
//
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbase.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <scuisupp.h>
#include <wincrui.h>
#include <comctrlp.h>
#include <tchar.h>
#include <shfusion.h>
#include "switches.h"
#include "Dlg.h"
#include "Res.h"
#include "KRDlg.h"
#include "keymgr.h"
#include "testaudit.h"
#include "pswutil.h"

//////////////////////////////////////////////////////////////////////////////
//
//  C_ChangePasswordDlg
//
//  Constructor.
//
//  parameters:
//      hwndParent      parent window for the dialog (may be NULL)
//      hInstance       instance handle of the parent window (may be NULL)
//      lIDD            dialog template id
//      pfnDlgProc      pointer to the function that will process messages for
//                      the dialog.  if it is NULL, the default dialog proc
//                      will be used.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
C_ChangePasswordDlg::C_ChangePasswordDlg(
    HWND                hwndParent,
    HINSTANCE           hInstance,
    LONG                lIDD,
    DLGPROC             pfnDlgProc  //   = NULL
    )
:   C_Dlg(hwndParent, hInstance, lIDD, pfnDlgProc)
{
   m_hInst = hInstance;
}   //  C_ChangePasswordDlg::C_ChangePasswordDlg

//////////////////////////////////////////////////////////////////////////////
//
//  OnInitDialog
//
//  Dialog control and data initialization.
//
//  parameters:
//      hwndDlg         window handle of the dialog box
//      hwndFocus       window handle of the control that will receive focus
//
//  returns:
//      TRUE            if the system should set the default keyboard focus
//      FALSE           if the keyboard focus is set by this app
//
//////////////////////////////////////////////////////////////////////////////
BOOL
C_ChangePasswordDlg::OnInitDialog(
    HWND                hwndDlg,
    HWND                hwndFocus
    )
{
   // To economize on memory, szMsg buffer is sized considerably longer than the MAX_STRING_SIZE
   //  that would be expected for its normal use for short messages.  In one instance, it is being 
   //  used to hold a username (line 139).  It is, therefore considerably longer than otherwise needed.
   //  This size mismatch is benignly not reflected in code which uses counted string functions to 
   //  copy/cat into this buffer.  This is the result of the buffer length having been changed after
   //  the surrounding code was originally written.
   TCHAR szMsg[CRED_MAX_USERNAME_LENGTH + 1];
   TCHAR szTitle[MAX_STRING_SIZE + 1];
   CREDENTIAL *pOldCred = NULL;
   BOOL bResult;
   TCHAR *pC;

   C_Dlg::OnInitDialog(hwndDlg, hwndFocus);

   SetFocus (GetDlgItem ( hwndDlg, IDC_OLD_PASSWORD));
   m_hDlg = hwndDlg;

   // read the currently selected credential, read the cred to get the username,
   // extract the domain, and set the text to show the affected domain.
   bResult = CredRead(g_szTargetName,CRED_TYPE_DOMAIN_PASSWORD,0,&pOldCred);
   if (bResult != TRUE) 
   {
      LoadString ( m_hInst, IDS_PSWFAILED, szMsg, MAX_STRING_SIZE );
      LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
      MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
      EndDialog(IDOK);
      return TRUE;
   
   }

   // Get the domain and user names from the username string in the credential
   // handle domain\user, domain.etc.etc\user, user@domain.etc.etc
   _tcsncpy(m_szFullUsername,pOldCred->UserName,UNLEN + UNLEN + 1 + 1 );
   m_szFullUsername[UNLEN + UNLEN + 1] = 0;
   _tcsncpy(szMsg,pOldCred->UserName,CRED_MAX_USERNAME_LENGTH);       // scratch buff
   szMsg[CRED_MAX_USERNAME_LENGTH] = 0;
   pC = _tcschr(szMsg,((TCHAR)'\\'));
   if (NULL != pC) 
   {
        // name is format domain\something
        *pC = 0;
        _tcsncpy(m_szDomain,szMsg,UNLEN);
        m_szDomain[UNLEN - 1] = 0;
        _tcsncpy(m_szUsername, (pC + 1), UNLEN);
        m_szUsername[UNLEN - 1] = 0;
   }
   else 
   {
        // see if name@something
        pC = _tcschr(szMsg,((TCHAR)'@'));
        if (NULL == pC) 
        {
           LoadString ( m_hInst, IDS_DOMAINFAILED, szMsg, CRED_MAX_USERNAME_LENGTH);
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
           if (pOldCred) CredFree(pOldCred);
           return TRUE; // don't call EndDialog()
        }
        *pC = 0;
        _tcsncpy(m_szDomain,(pC + 1),UNLEN);
        m_szDomain[UNLEN - 1] = 0;
        _tcsncpy(m_szUsername, szMsg,UNLEN);
        m_szUsername[UNLEN - 1] = 0;
   }

   if (pOldCred) CredFree(pOldCred);

   if (0 != LoadString(g_hInstance,IDS_CPLABEL,szTitle,MAX_STRING_SIZE)) 
   {
        INT iLen = MAX_STRING_SIZE - _tcslen(szTitle);
        if (iLen > 0)
        {
            // this will change your password for the domain <appendedname>
            // GMBUG: this may localize inconsistently.  Should use positional
            //  parameters.
            _tcsncat(szTitle,m_szDomain,iLen);
            szTitle[MAX_STRING_SIZE - 1] = 0;
        }
        SetDlgItemText(m_hwnd,IDC_CPLABEL,szTitle);
   }
   return TRUE;
}   //  C_ChangePasswordDlg::OnInitDialog

//////////////////////////////////////////////////////////////////////////////
//
//  OnCommand
//
//  Route WM_COMMAND message to appropriate handlers.
//
//  parameters:
//      wNotifyCode     code describing action that has occured
//      wSenderId       id of the control sending the message, if the message
//                      is from a dialog
//      hwndSender      window handle of the window sending the message if the
//                      message is not from a dialog
//
//  returns:
//      TRUE            if the message was processed completely
//      FALSE           if Windows is to process the message
//
//////////////////////////////////////////////////////////////////////////////
BOOL
C_ChangePasswordDlg::OnCommand(
    WORD                wNotifyCode,
    WORD                wSenderId,
    HWND                hwndSender
    )
{
    // Was the message handled?
    //
    BOOL                fHandled = FALSE;

    switch (wSenderId)
    {
    case IDOK:
        if (BN_CLICKED == wNotifyCode)
        {
            OnOK( );
            fHandled = TRUE;
        }
        break;
    case IDCANCEL:
        if (BN_CLICKED == wNotifyCode)
        {
            EndDialog(IDCANCEL);
            fHandled = TRUE;
        }
        break;

    }   //  switch

    return fHandled;

}   //  C_ChangePasswordDlg::OnCommand



////////////////////////////////////////////////////////////////////////////
//
//  OnOK
//
//  Validate user name, synthesize computer name, and destroy dialog.
//
//  parameters:
//      None.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////

void
C_ChangePasswordDlg::OnOK( )
{
   TCHAR szMsg[CRED_MAX_USERNAME_LENGTH];
   TCHAR szTitle[MAX_STRING_SIZE];
   ULONG Error = 0;

   BOOL bResult;

   ASSERT(::IsWindow(m_hwnd));

   // get old and new passwords from the dialog box
   GetDlgItemText ( m_hDlg, IDC_OLD_PASSWORD, m_szOldPassword, PWLEN );
   GetDlgItemText ( m_hDlg, IDC_NEW_PASSWORD, m_szNewPassword, PWLEN );
   GetDlgItemText ( m_hDlg, IDC_CONFIRM_PASSWORD, m_szConfirmPassword, PWLEN );
   if ( wcslen ( m_szOldPassword ) == 0 && wcslen ( m_szNewPassword ) ==0 && wcslen (m_szConfirmPassword) == 0 )
   {
       // must have something filled in
       return; 
   }
   else if ( wcscmp ( m_szNewPassword, m_szConfirmPassword) != 0 )
   {
       LoadString ( m_hInst, IDS_NEWPASSWORDNOTCONFIRMED, szMsg, CRED_MAX_USERNAME_LENGTH );
       LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
       MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       return; // don't call EndDialog()

   }
   else
   {
       HCURSOR hCursor, hOldCursor;

       hOldCursor = NULL;
       hCursor = ::LoadCursor ( m_hInst, IDC_WAIT );
       if ( hCursor )
       {
           hOldCursor = ::SetCursor ( hCursor );
       }
       // let's try changing it
       // The targetname is not used.  Only the domain name the username, and
       //  old/new passwords are used
#ifdef LOUDLY
       OutputDebugString(L"Changing password on the domain :");
       OutputDebugString(m_szDomain);
       OutputDebugString(L" for ");
       OutputDebugString(m_szUsername);
       OutputDebugString(L" to ");
       OutputDebugString(m_szNewPassword);
       OutputDebugString(L"\n");
#endif
// gm: pass full username and crack it in NetUserChangePasswordEy, so that routine can 
//  decide whether we are facing a Kerberos domain
       Error = NetUserChangePasswordEy ( NULL, m_szFullUsername, m_szOldPassword, m_szNewPassword );
       if ( hOldCursor )
           ::SetCursor ( hOldCursor );
   }

   if ( Error == NERR_Success )
   {
#ifdef LOUDLY
        OutputDebugString(L"Remote password set succeeded\n");
#endif
        // Store the new credential in the keyring.  It will overlay
        //  a previous version if present
        // Note that the user must have knowledge of and actually type in
        //  the old password as well as the new password.  If the user
        //  elects to update only the local cache, the old password 
        //  information is not actually used.
        // CredWriteDomainCredentials() is used
        // m_szDomain holds the domain name
        // m_szUsername holds the username
        // m_szNewPassword holds the password
        CREDENTIAL                    stCredential;
        UINT                          cbPassword;

        memcpy((void *)&stCredential,(void *)g_pExistingCred,sizeof(CREDENTIAL));
        // password length does not include zero term
        cbPassword = _tcslen(m_szNewPassword) * sizeof(TCHAR);
        // Form the domain\username composite username
        stCredential.Type = CRED_TYPE_DOMAIN_PASSWORD;
        stCredential.TargetName = g_szTargetName;
        stCredential.CredentialBlob = (unsigned char *)m_szNewPassword;
        stCredential.CredentialBlobSize = cbPassword;
        stCredential.UserName = m_szFullUsername;
        stCredential.Persist = g_dwPersist;


        bResult = CredWrite(&stCredential,0);

        if (bResult) 
        {
           LoadString ( m_hInst, IDS_DOMAINCHANGE, szMsg, CRED_MAX_USERNAME_LENGTH );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
        }
        else 
        {
           LoadString ( m_hInst, IDS_LOCALFAILED, szMsg, CRED_MAX_USERNAME_LENGTH );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
        }

        // BUGBUG - what to do if the local update operation fails?
        // This is not a very big failure, as the first prompt would 
        //  ripple through all domain\username matching creds on the 
        //  keyring and update them later.  You're pretty much stuck
        //  here, since the domain probably will not let you reset the
        //  psw to the old value.
   }
   else
   {
       // Attempt to be specific about failure to change the psw on the
       // remote system
#ifdef LOUDLY
       OutputDebugString(L"Remote password set failed\n");
#endif       
       if (Error == ERROR_INVALID_PASSWORD) 
       {
           LoadString ( m_hInst, IDS_CP_INVPSW, szMsg, CRED_MAX_USERNAME_LENGTH );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       }
       else if (Error == NERR_UserNotFound) 
       {
           LoadString ( m_hInst, IDS_CP_NOUSER, szMsg, CRED_MAX_USERNAME_LENGTH );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       }
       else if (Error == NERR_PasswordTooShort) 
       {
           LoadString ( m_hInst, IDS_CP_BADPSW, szMsg, CRED_MAX_USERNAME_LENGTH );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       }
       else if (Error == NERR_InvalidComputer) 
       {
           LoadString ( m_hInst, IDS_CP_NOSVR, szMsg, CRED_MAX_USERNAME_LENGTH );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       }
       else if (Error == NERR_NotPrimary) 
       {
           LoadString ( m_hInst, IDS_CP_NOTALLOWED, szMsg, CRED_MAX_USERNAME_LENGTH );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       }
       else  
       {
           // Reaching here signifies a failure to set the remote domain
           //  password for more general reasons
           LoadString ( m_hInst, IDS_DOMAINFAILED, szMsg, CRED_MAX_USERNAME_LENGTH );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       }
   }

    // clean any psw buffers, release the old cred, and go.
    SecureZeroMemory(m_szOldPassword,sizeof(m_szOldPassword));
    SecureZeroMemory(m_szNewPassword,sizeof(m_szNewPassword));   
    SecureZeroMemory(m_szConfirmPassword,sizeof(m_szConfirmPassword));   
    EndDialog(IDOK);
    
}   //  C_ChangePasswordDlg::OnOK

//
///// End of file: krDlg.cpp   ///////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keycpl\keymgr.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    KEYMGR.CPP

Abstract:

    Keyring WinMain() and application support
     
Author:

    990917  johnhaw Created. 
    georgema        000310  updated
    georgema        000501  used to be EXE, changed to CPL

Comments:
    This executable is the control panel applet to allow a user some control 
    over the contents of the Windows Keyring, the so-called "Geek UI".  It was 
    originally an EXE, but that architecture is not as optimized for merging 
    with other control panel applets.  It has been changed to a CPL executable, 
    and can be either left as a CPL if it is desired that it should show up 
    automatically in the master control panel window, or rahter renamed to 
    a DLL file extension if it is desired that a control panel applet container
    application should load it explicitly without it otherwise being visible 
    to the system.

Environment:
    Win98, Win2000

Revision History:

--*/

#pragma comment(user, "Compiled on " __DATE__ " at " __TIME__)
#pragma comment(compiler)


//////////////////////////////////////////////////////////////////////////////
//
//  Include files
//
#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <cpl.h>
#include "Res.h"
#include "keymgr.h"

#undef GSHOW
//////////////////////////////////////////////////////////////////////////////
//
//  Static initialization
//
static const char       _THIS_FILE_[ ] = __FILE__;
//static const WORD       _THIS_MODULE_ = LF_MODULE_UPGRADE;

//////////////////////////////////////////////////////////////////////////////
//
//  Global state info
//


HINSTANCE               g_hInstance = NULL;
HMODULE                 hDll = NULL;
LONG (*CPlFunc)(HWND,UINT,LPARAM,LPARAM);

__declspec(dllexport) LONG APIENTRY CPlApplet(HWND hwndCPl,UINT uMsg,LPARAM lParam1,LPARAM lParam2)
{
    INT_PTR nResult;
    CPLINFO *lpCPlInfo;

    // Handle commands to this dll/cpl from the enclosing presentation app.
    // Default return from any command is 0 (success), except those commands
    //  which ask for specific data in the return value
    
    switch(uMsg) {
        case CPL_INIT:
            hDll = LoadLibrary(L"keymgr.dll");
            if (NULL == hDll) {
#ifdef GMSHOW
                MessageBox(NULL,L"Failed to load dll",NULL,MB_OK);
#endif
                return FALSE;
            }
            CPlFunc = (LONG (*)(HWND,UINT,LPARAM,LPARAM)) GetProcAddress(hDll,"CPlApplet");
            if (NULL == CPlFunc) {
#ifdef GMSHOW
                MessageBox(NULL,L"Failed to find dll export",NULL,MB_OK);
#endif
                return FALSE;
            }
            return CPlFunc(hwndCPl,uMsg,lParam1,lParam2);
            break;
            
        case CPL_GETCOUNT:
            return 1;       // only 1 applet icon in this cpl file
            break;

        case CPL_NEWINQUIRE:
            break;
            
        case CPL_INQUIRE:
            lpCPlInfo = (CPLINFO *) lParam2;  // acquire ptr to target data 
            lpCPlInfo->lData = 0;             // no effect
            lpCPlInfo->idIcon = IDI_UPGRADE;  // store items needed to show the applet
            lpCPlInfo->idName = IDS_APP_NAME;
            lpCPlInfo->idInfo = IDS_APP_DESCRIPTION; // description string
            break;
            
        case CPL_EXIT:
            FreeLibrary(hDll);
            break;
            
        // This will end up handling doubleclick and stop messages
        default:
#ifdef GMSHOW
                MessageBox(NULL,L"Call to linked dll",NULL,MB_OK);
#endif
            return CPlFunc(hwndCPl,uMsg,lParam1,lParam2);
            break;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\audit.h ===
#ifndef __AUDIT__
#define __AUDIT__


/*

AUDIT.H is a machine-generated file, created by MAKEAUDIT.EXE.
This file need not be checked into your project, though it will
need to be generated in order to create a testaudit instrumented binary.
This file is included only by testaudit.cpp, only when a testaudit build
is made.  

A testaudit build should always be a clean build, in order to
ensure that the current auditing information is built into the binary.

*/

AUDITDATA AuditData[] = {

    // Searching dlg.cpp
    // Searching krdlg.cpp
    {9, L"krdlg.cpp @ 90 : DLL Attach"}
    // Searching maindlg.cpp
    ,{41, L"maindlg.cpp @ 263 : Multiple *Session creds"}
    ,{32, L"maindlg.cpp @ 266 : Keymgr: *Session cred in cred list"}
    ,{33, L"maindlg.cpp @ 294 : Keymgr: Passport cred in cred list"}
    ,{34, L"maindlg.cpp @ 312 : Keymgr: Password cred in cred list"}
    ,{35, L"maindlg.cpp @ 321 : Keymgr: Certificate cred in cred list"}
    ,{30, L"maindlg.cpp @ 380 : Keymgr: Large number of credentials > 100"}
    ,{31, L"maindlg.cpp @ 381 : Keymgr: No saved credentials - list empty"}
    ,{36, L"maindlg.cpp @ 388 : Keymgr: Personal SKU or credman disabled"}
    ,{37, L"maindlg.cpp @ 496 : Keymgr: Delete a credential"}
    ,{42, L"maindlg.cpp @ 535 : Delete session cred"}
    ,{38, L"maindlg.cpp @ 736 : Keymgr: Attempt edit a RAS cred"}
    ,{39, L"maindlg.cpp @ 750 : Keymgr: Attempt edit a passport cred"}
    ,{40, L"maindlg.cpp @ 759 : Keymgr: Launch passport website for Passport cred edit"}
    ,{15, L"maindlg.cpp @ 947 : Keymgr: Main dialog OnHelpInfo"}
    // Searching editdlg.cpp
    ,{1, L"editdlg.cpp @ 158 : Keymgr: Edit - Password cred edit"}
    ,{2, L"editdlg.cpp @ 163 : keymgr: Edit - Certificate cred edit"}
    ,{3, L"editdlg.cpp @ 206 : Keymgr: Edit - Show description on prop dialog"}
    ,{12, L"editdlg.cpp @ 225 : Keymgr: Edit - Show properties of non-enterprise persist cred"}
    ,{13, L"editdlg.cpp @ 231 : Keymgr: Edit - Show properties of enterprise persist cred"}
    ,{18, L"editdlg.cpp @ 243 : Keymgr: Edit - Show properties of session cred"}
    ,{19, L"editdlg.cpp @ 249 : Keymgr: Edit - Show properties of non-session cred"}
    ,{5, L"editdlg.cpp @ 386 : Keymgr: Edit - Add dialog OnHelpInfo"}
    ,{4, L"editdlg.cpp @ 579 : Keymgr: Edit - OnOK for add/prop dialog"}
    ,{21, L"editdlg.cpp @ 613 : Keymgr: Edit - Saving a cred preserving the old psw (rename)"}
    ,{20, L"editdlg.cpp @ 617 : Keymgr: Edit - Saving a cred while not preserving the old password"}
    ,{7, L"editdlg.cpp @ 694 : Keymgr: Edit - OnOK - deleting old cred (type changed)"}
    ,{8, L"editdlg.cpp @ 700 : Keymgr: Edit - OnOK - renaming current cred, same type"}
    ,{16, L"editdlg.cpp @ 718 : Keymgr: Edit - Saving password cred"}
    ,{17, L"editdlg.cpp @ 719 : Keymgr: Edit - Saving certificate cred"}
    ,{10, L"editdlg.cpp @ 734 : Keymgr: Edit - Changing password on the domain for the cred"}
    ,{11, L"editdlg.cpp @ 755 : Keymgr: Edit - Add/Edit failed: Show error message box to user"}
    // Searching chgpsw.cpp
    // Searching keymgr.cpp
    // Searching wizard.cpp
    ,{65, L"wizard.cpp @ 344 : Wizard: Password length > 25 chars"}
    ,{54, L"wizard.cpp @ 484 : Wizard: Both - Exactly one removeable drive"}
    ,{53, L"wizard.cpp @ 610 : Wizard: Both - no removeable drives"}
    ,{52, L"wizard.cpp @ 611 : Wizard: Both - more than 1 removeable drive"}
    ,{58, L"wizard.cpp @ 813 : Wizard: Restore - Set account password"}
    ,{50, L"wizard.cpp @ 874 : Wizard: Save - generating recovery data"}
    ,{51, L"wizard.cpp @ 911 : Wizard: Save - write failed (disk full?)"}
    ,{55, L"wizard.cpp @ 919 : Wizard: Save - write to disk OK"}
    ,{59, L"wizard.cpp @ 1178 : Wizard: Both - Drive select page"}
    ,{60, L"wizard.cpp @ 1181 : Wizard: Restore - drive select"}
    ,{61, L"wizard.cpp @ 1261 : Wizard: Save - back from enter old psw page"}
    ,{62, L"wizard.cpp @ 1708 : Wizard: Restore - BACK from enter new psw data page"}
    ,{63, L"wizard.cpp @ 1940 : Wizard: Save - Show from nusrmgr.cpl"}
    ,{64, L"wizard.cpp @ 2028 : Wizard: Restore - show restore wizard from nusrmgr.cpl"}
    ,{56, L"wizard.cpp @ 2174 : Wizard: Save - show from msgina"}
    ,{57, L"wizard.cpp @ 2203 : Wizard: Restore - Show from msgina"}
    // Searching diskio.cpp
    ,{70, L"diskio.cpp @ 216 : Wizard: Save - Unformatted disk in the drive"}
    ,{72, L"diskio.cpp @ 261 : Wizard: Restore - disk present"}
    ,{73, L"diskio.cpp @ 302 : Wizard: Restore - wrong disk (file not found)"}
    ,{74, L"diskio.cpp @ 307 : Wizard: Restore - bad disk"}
    ,{71, L"diskio.cpp @ 314 : Wizard: Restore - no disk"}
    ,{75, L"diskio.cpp @ 363 : Wizard: Save - open output file"}
    ,{76, L"diskio.cpp @ 385 : Wizard: Save - file already exists"}
    // Searching pswutil.cpp
    // Searching keymgr.rc

};
#define CHECKPOINTCOUNT (sizeof(AuditData) / sizeof(AUDITDATA))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\diskio.cpp ===
/*++

Copyright (c) 2000,2001  Microsoft Corporation

Module Name:

    DISKIO.CPP

Abstract:

    Disk IO routines for the password reset wizards.  These routines
    do disk writes as unbuffered writes in order to prevent uncontrolled
    copies of the private key blob from being left lying around.  For that
    reason, utility routines are included to derive a proper size for the
    blob write that will be an integer multiple of the sector size of
    the medium, a required condition to use an unbuffered write operation.

    Assistance is also provided in finding removeable medium drives.

    Some state of the disk IO subsystem is preserved in global variables,
    prefixed by "g_".  
  
Author:

Environment:
    WinXP

--*/

// Dependencies:  shellapi.h, shell32.lib for SHGetFileInfo()
//               windows.h, kernel32.lib for GetDiskFreeSpace()
//               io.h   for _waccess()

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <windows.h>
#include <string.h>
#include <io.h>
#include <stdio.h>
//#include <shellapi.h>
#include <shlwapi.h>
//#include <shlobjp.h>

#include "switches.h"
#include "wizres.h"
#include "testaudit.h"

extern HINSTANCE g_hInstance;

#if !defined(SHFMT_OPT_FULL)
#if defined (__cplusplus)
extern "C" {
#endif
DWORD WINAPI SHFormatDrive(HWND,UINT,UINT,UINT);

#define SHFMT_ID_DEFAULT    0xffff
#define SHFMT_OPT_FULL      0x0001
#define SHFMT_OPT_SYSONLY   0x0002
#define SHFMT_ERROR         0xffffffffL
#define SHFMT_CANCEL        0xfffffffeL
#define SHFMT_NOFORMAT      0xffffffdL
#if defined (__cplusplus)
}
#endif
#endif
// Miscellaneous declarations not contain in header files
// These will be miscellaneous items found in other files within this project
int RMessageBox(HWND hw,UINT_PTR uiResIDTitle, UINT_PTR uiResIDText, UINT uiType);
extern HWND      c_hDlg;
extern WCHAR     pszFileName[];


INT     g_iFileSize = 0;
INT     g_iBufferSize = 0;
INT     g_iSectorSize = 0;
HANDLE  g_hFile = NULL;

/**********************************************************************

GetDriveFreeSpace

Get DWORD value of free space on the drive associated with the path, in bytes.

**********************************************************************/


DWORD GetDriveFreeSpace(WCHAR *pszFilePath) 
{
    WCHAR rgcModel[]={L"A:"};

    DWORD dwSpc,dwBps,dwCfc,dwTcc,dwFree;
    ASSERT(pszFilePath);
    if (NULL == pszFilePath) return 0;
    rgcModel[0] = *pszFilePath;
    if (!GetDiskFreeSpace(rgcModel,&dwSpc,&dwBps,&dwCfc,&dwTcc))
    {
        ASSERTMSG("GetDiskFreeSpace failed",0);
        return 0;
    }

    // Free is bytes per sector * sectors per cluster * free clusters
    dwFree = dwBps * dwCfc * dwSpc;
    return dwFree;
}

/**********************************************************************

GetDriveSectorSize

Return DWORD size in byte of a single sector on the drive associated with the path.

**********************************************************************/

DWORD GetDriveSectorSize(WCHAR *pszFilePath) 
{
    WCHAR rgcModel[]={L"A:"};

    DWORD dwSpc,dwBps,dwCfc,dwTcc;
    ASSERT(pszFilePath);
    if (NULL == pszFilePath) 
    {
        return 0;
    }
    rgcModel[0] = *pszFilePath;
    if (!GetDiskFreeSpace(rgcModel,&dwSpc,&dwBps,&dwCfc,&dwTcc))
    {
        ASSERTMSG("GetDiskFreeSpace failed",0);
        return 0;
    }
    return dwBps;
}

/**********************************************************************

CreateFileBuffer

Create a buffer to contain iDataSize bytes that is an integral multiple of iSectorSize
buffers.

**********************************************************************/

LPVOID CreateFileBuffer(INT iDataSize,INT iSectorSize)
{
    INT iSize;
    LPVOID lpv;
    if (iDataSize == iSectorSize)
    {
        iSize = iDataSize;
    }
    else 
    {
        iSize = iDataSize/iSectorSize;
        iSize += 1;
        iSize *= iSectorSize;
    }
    g_iBufferSize = iSize;
    lpv = VirtualAlloc(NULL,iSize,MEM_COMMIT,PAGE_READWRITE | PAGE_NOCACHE);
    ASSERTMSG("VirtualAlloc failed to create buffer",lpv);
    return lpv;
}

/**********************************************************************

ReleaseFileBuffer()

Release the file buffer created by CreateFileBuffer

**********************************************************************/

void ReleaseFileBuffer(LPVOID lpv)
{   
    ASSERT(lpv);
    if (NULL == lpv) return;
    SecureZeroMemory(lpv,g_iBufferSize);
    VirtualFree(lpv,0,MEM_RELEASE);
    return;
}


/**********************************************************************

FileMediumIsPresent

Test the drive associated with the passed path to see if the medium is present.
Return BOOL TRUE if so.

**********************************************************************/

BOOL FileMediumIsPresent(TCHAR *pszPath) 
{
    UINT uMode = 0;                           
    BOOL bResult = FALSE;
    TCHAR rgcModel[]=TEXT("A:");
    DWORD dwError = 0;

    ASSERT(pszPath);
    if (*pszPath == 0) return FALSE;
    rgcModel[0] = *pszPath;
    
    uMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    if (0 == _waccess(rgcModel,0)) 
    {
        bResult = TRUE;
    }
    else dwError = GetLastError();

    // Correct certain obvious errors with the user's help
    if (ERROR_UNRECOGNIZED_MEDIA == dwError)
    {
        // unformatted disk
        WCHAR rgcFmt[200] = {0};
        WCHAR rgcMsg[200] = {0};
        WCHAR rgcTitle[200] = {0};
        CHECKPOINT(70,"Wizard: Save - Unformatted disk in the drive");

#ifdef LOUDLY
        OutputDebugString(L"FileMediumIsPresent found an unformatted medium\n");
#endif
        INT iCount = LoadString(g_hInstance,IDS_MBTFORMAT,rgcTitle,200 - 1);
        iCount = LoadString(g_hInstance,IDS_MBMFORMAT,rgcFmt,200 - 1);
        ASSERT(iCount);
        if (0 != iCount)
        {
            swprintf(rgcMsg,rgcFmt,rgcModel);
            INT iDrive = PathGetDriveNumber(rgcModel);
            int iRet =  MessageBox(c_hDlg,rgcMsg,rgcTitle,MB_YESNO);
            if (IDYES == iRet) 
            {
                dwError = SHFormatDrive(c_hDlg,iDrive,SHFMT_ID_DEFAULT,0);
                if (0 == bResult) bResult = TRUE;
            }
        }
    }
    uMode = SetErrorMode(uMode);
    return bResult;
}

//
//

/**********************************************************************

GetInputFile

Open input file and return handle to it.  Return NULL on file not found. 
FileName will be in global buffer pszFileName.

**********************************************************************/


HANDLE GetInputFile(void) 
{
    HANDLE       hFile = INVALID_HANDLE_VALUE;
    DWORD       dwErr;
    WIN32_FILE_ATTRIBUTE_DATA stAttributes = {0};

    if (FileMediumIsPresent(pszFileName)) 
    {
        CHECKPOINT(72,"Wizard: Restore - disk present");
        g_iSectorSize = GetDriveSectorSize(pszFileName);
        ASSERT(g_iSectorSize);
        if (0 == g_iSectorSize) 
        {
            return NULL;
        }
        
        if (GetFileAttributesEx(pszFileName,GetFileExInfoStandard,&stAttributes))
        {
            // file exists and we have a size for it.
            g_iFileSize = stAttributes.nFileSizeLow;
        }
        else 
        {
            dwErr = GetLastError();
            if (dwErr == ERROR_FILE_NOT_FOUND) 
            {
                RMessageBox(c_hDlg,IDS_MBTWRONGDISK ,IDS_MBMWRONGDISK ,MB_ICONEXCLAMATION);
            }
            else
            {
                ASSERT(0);      // get file attributes failed
                RMessageBox(c_hDlg,IDS_MBTDISKERROR ,IDS_MBMDISKERROR ,MB_ICONEXCLAMATION);
            }
            g_hFile = NULL;
            return NULL;
        } // end GetFileAttributes
        
        hFile = CreateFileW(pszFileName,
                            GENERIC_READ,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_NO_BUFFERING,
                            NULL);
        
        if (INVALID_HANDLE_VALUE == hFile) {
            dwErr = GetLastError();
            if (dwErr == ERROR_FILE_NOT_FOUND) 
            {
                NCHECKPOINT(73,"Wizard: Restore - wrong disk (file not found)");
                RMessageBox(c_hDlg,IDS_MBTWRONGDISK ,IDS_MBMWRONGDISK ,MB_ICONEXCLAMATION);
            }
            else
            {
                NCHECKPOINT(74,"Wizard: Restore - bad disk");
                RMessageBox(c_hDlg,IDS_MBTDISKERROR ,IDS_MBMDISKERROR ,MB_ICONEXCLAMATION);
            }
       }
    }
    else 
    {
        CHECKPOINT(71,"Wizard: Restore - no disk");
        RMessageBox(c_hDlg,IDS_MBTNODISK ,IDS_MBMNODISK ,MB_ICONEXCLAMATION);
    }
    if ((NULL == hFile) || (INVALID_HANDLE_VALUE == hFile)) 
    {
        g_hFile = NULL;
        return NULL;
    }
    g_hFile = hFile;
    return hFile;
}

/**********************************************************************

CloseInputFile

Close the input file and set the global file handle to NULL

**********************************************************************/

void CloseInputFile(void) 
{
    if (g_hFile) 
    {
        CloseHandle(g_hFile);
        g_hFile = NULL;
    }
    
    return;
}

/**********************************************************************

GetOutputFile

Open for overwrite or Create the output file to pszFileName.  Return handle on 
success or NULL on fail.  Get user permission to overwrite.  

**********************************************************************/


HANDLE GetOutputFile(void) 
{
    
    HANDLE hFile = NULL;
    DWORD dwErr;
    
    if (FileMediumIsPresent(pszFileName)) 
    {
        CHECKPOINT(75,"Wizard: Save - open output file");
        g_iSectorSize = GetDriveSectorSize(pszFileName);
        ASSERT(g_iSectorSize);
        if (0 == g_iSectorSize) 
        {
            return NULL;
        }
        
        hFile = CreateFileW(pszFileName,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_NEW,
                            FILE_FLAG_NO_BUFFERING,
                            NULL);
        if ((NULL == hFile) || (INVALID_HANDLE_VALUE == hFile)) 
        {
            
            dwErr = GetLastError();
            
            if ((dwErr == ERROR_FILE_EXISTS)) 
            {
                CHECKPOINT(76,"Wizard: Save - file already exists");
                if (IDYES != RMessageBox(c_hDlg,IDS_MBTOVERWRITE ,IDS_MBMOVERWRITE ,MB_YESNO)) 
                {
                    // Overwrite abandoned.
                    g_hFile = NULL;
                    return NULL;
                }
                else 
                {
                    SetFileAttributes(pszFileName,FILE_ATTRIBUTE_NORMAL);
                    hFile = CreateFileW(pszFileName,
                                        GENERIC_WRITE,
                                        0,
                                        NULL,
                                        CREATE_ALWAYS,
                                        FILE_FLAG_NO_BUFFERING,
                                        NULL);
#ifdef LOUDLY
                    dwErr = GetLastError();
                    swprintf(rgct,L"File create failed %x\n",dwErr);
                    OutputDebugString(rgct);
#endif
                }
            } // end if already exists error
        } // end if NULL == hFile
    }
    else 
    {
        RMessageBox(c_hDlg,IDS_MBTNODISK ,IDS_MBMNODISK ,MB_ICONEXCLAMATION);
    }
    if (INVALID_HANDLE_VALUE == hFile) 
    {
        g_hFile = NULL;
        return NULL;
    }
    g_hFile = hFile;
    return hFile;
}


/**********************************************************************

DWORD ReadPrivateData(PWSTR, LPBYTE *prgb, INT *piCount)
DWORD WritePrivateData(PWSTR, LPBYTE lpData, INT icbData)

These functions read or write a reasonably short block of data to a disk
device, avoiding buffering of the data.  This allows the data to be wiped 
by the client before the buffers are released.  The created buffer is an integral 
multiple of the medium sector size as required by the unbuffered disk I/O 
routines.

The DWORD return value is that which would return from GetLastError() and
can be handled accordingly.

ReadPrivateData() returns a malloc'd pointer which must be freed by the client.  It
also returns the count of bytes read from the medium to the INT *. 

WritePrivateData() writes a count of bytes from LPBYTE to the disk.  When it returns,
the buffer used to do so has been flushed and the file is closed.

    prgb = byte ptr to data returned from the read
    piCount = size of active data field within the buffer

Note that even if the read fails (file not found, read error, etc.) the buffer
ptr is still valid (non-NULL)

**********************************************************************/

INT ReadPrivateData(BYTE **prgb,INT *piCount)
{
    LPVOID lpv;
    DWORD dwBytesRead;

    // detect / handle errors
    ASSERT(g_hFile);
    ASSERT(prgb);
    ASSERT(piCount);
    if (NULL == prgb) return 0;
    if (NULL == piCount) return 0;
    
    if (g_hFile)
    {

        // set file ptr to beginning in case this is a retry
        SetFilePointer(g_hFile,0,0,FILE_BEGIN);

        // allocate a buffer for the read data
        lpv = CreateFileBuffer(g_iFileSize,g_iSectorSize);
        if (NULL == lpv) 
        {
            *prgb = 0;      // indicate no need to free this buffer
            *piCount = 0;
            return 0;
        }

        // save buffer address and filled size
        *prgb = (BYTE *)lpv;        // even if no data, gotta free using VirtualFree()
        *piCount = 0;

        // do the read - return chars read if successful
        if (0 == ReadFile(g_hFile,lpv,g_iBufferSize,&dwBytesRead,NULL)) return 0;
        *piCount = g_iFileSize;
        if (g_iFileSize == 0) SetLastError(NTE_BAD_DATA);
        
        return g_iFileSize;
    }
    return 0;
}

BOOL WritePrivateData(BYTE *lpData,INT icbData) 
{
    DWORD dwcb = 0;
    LPVOID lpv;

    // detect/handle errors
    ASSERT(lpData);
    ASSERT(g_hFile);
    ASSERT(icbData);
    if (NULL == g_hFile) return FALSE;
    if (NULL == lpData) return FALSE;
    if (0 == icbData) return FALSE;

    if (g_hFile)
    {
        g_iFileSize = icbData;
        lpv = CreateFileBuffer(g_iFileSize,g_iSectorSize);
        if (NULL == lpv) 
        {
            return FALSE;
        }
        
        ZeroMemory(lpv,g_iBufferSize);
        memcpy(lpv,lpData,icbData);

        // I elect to check the result of the write only by checking the byte
        //  count on the write, as some rather normal conditions can cause a fail.  This
        //  test gets em all.  I don't care exactly why.
        WriteFile(g_hFile,lpv,g_iBufferSize,&dwcb,NULL);
        SecureZeroMemory(lpv,g_iBufferSize);
        VirtualFree(lpv,0,MEM_RELEASE);
    }
    // ret TRUE iff file write succeeds and count of bytes is correct
    if ((INT)dwcb != g_iBufferSize) return FALSE;
    else return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\diskio.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    DISKIO.H

Abstract:

    Password reset wizard disk IO utility routines
     
Author:


Comments:

Environment:
    WinXP

Revision History:

--*/

#ifndef __DISKIO__
#define __DISKIO__

DWORD GetDriveFreeSpace(WCHAR *);
INT ReadPrivateData(BYTE **,INT *);
BOOL WritePrivateData(BYTE *,INT);
HANDLE GetOutputFile(void);
HANDLE GetInputFile(void);
void CloseInputFile(void);
void ReleaseFileBuffer(LPVOID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\dlg.h ===
#ifndef _DLG_H_
#define _DLG_H_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    DLG.CPP

Abstract:

    C_Dlg implementation
     
Author:

    990518  dane    Created. 
    georgema        000310  updated

Environment:
    Win98, Win2000

Revision History:

--*/

//////////////////////////////////////////////////////////////////////////////
//
// C_Dlg
//
// Base dialog class: handles default message routing and processing.
//
class C_Dlg 
{
public:                 // operations
    C_Dlg(
        HWND                hwndParent,
        HINSTANCE           hInstance,
        LONG                lIDD,
        DLGPROC             pfnDlgProc = NULL
        );

    ~C_Dlg( );

    virtual INT_PTR
    DoModal(
        LPARAM              lparam = NULL
        );

    BOOL
    EndDialog(
        INT                 nResult = 0
        )
    {
        ASSERT(NULL != m_hwnd);
        return ::EndDialog(m_hwnd, nResult);
    }   //  EndDialog

    // Link the object to the window handle
    //
    virtual BOOL
    OnInitDialog(
        HWND                hwndDlg,
        HWND                hwndFocus
        )
    {
        // Save the page's window handle & link the window handle to the page
        // object.
        //
        m_hwnd = hwndDlg;
        LinkHwnd( );

        // Let the system set the default keyboard focus.
        //
        return TRUE;
    }   //  

    virtual BOOL
    OnDestroyDialog(void)
    {
        return TRUE;
    }

    virtual BOOL
    OnCommand(
        WORD                wNotifyCode,
        WORD                wId,
        HWND                hwndSender
        )
    {
        // Message was not processed
        //
        return FALSE;
    }   //  

    virtual BOOL
    OnHelpInfo(
        LPARAM             lParam
        )
    {
        // Message was not processed
        //
        return FALSE;
    }   //  

    virtual BOOL
    OnContextMenu(
        WPARAM             wParam,
        LPARAM             lParam
        )
    {
        // Message was not processed
        //
        return FALSE;
    }   //  

    virtual BOOL
    OnQueryCancel( )
    {
        // The message was not processed.
        //
        return FALSE;
    }   //  

    virtual BOOL
    OnHelp( )
    {
        // User has clicked the Help button.
        // TODO: Display help

        // The message was not processed.
        //
        return FALSE;
    }   //  

    virtual BOOL
    OnNotify(
        LPNMHDR             pnmh
        )
    {
        // Message was not processed.
        //
        return FALSE;
    }   //  

    virtual void
    OnShutdown() {
        return;
    }
    
#if 0
    // Notification message return their results via the DWL_MSGRESULT window
    // long.  This wrapper keeps me from having to remember that.
    //
    virtual LONG
    SetNotificationMessageResult(
        LONG                lResult
        )
    {
        return SetWindowLong(m_hwnd, DWL_MSGRESULT, lResult);
    }   //  SetNotificationMessageResult
#endif

    // Process application-specific messages (WM_APP + n)
    //
    virtual BOOL
    OnAppMessage(
        UINT                uMessage,
        WPARAM              wparam,
        LPARAM              lparam
        )
    {
        // Message was not processed.
        //
        return FALSE;
    }   //  OnAppMessage

    static HRESULT
    DlgFromHwnd(
        HWND            hwnd,
        C_Dlg**      ppDlg
        );

    const HWND
    Hwnd( ) const
    {
        return m_hwnd;
    }   //  Hwnd

    virtual void
    AssertValid( ) const
    {
        ASSERT(NULL != m_hwnd);
    }   //  AssertValid
protected:              // operations

    static LPCTSTR          SZ_HWND_PROP;

    BOOL
    LinkHwnd( );

    BOOL
    UnlinkHwnd( );

    static INT_PTR CALLBACK
    DlgProc(
        HWND            hwndDlg,
        UINT            uMessage,
        WPARAM          wparam,
        LPARAM          lparam
        );

    static BOOL
    RouteNotificationMessage(
        C_Dlg*      pDlg,
        NMHDR*          pnmhdr
        );

protected:              // data
    // Window handle of the dialog's parent window (may be NULL)
    //
    HWND                m_hwndParent;

    // Window handle of the dialog (may NOT be NULL)
    //
    HWND                m_hwnd;

    // Instance handle of the application displaying this dialog (may be NULL)
    //
    HINSTANCE           m_hInstance;

    //  Identifier for the dialog template associated with this object
    //
    LONG                m_lIDD;

    // Procedure that processes message sent to this dialog
    //
    DLGPROC             m_pfnDlgProc;

private:                // operations

    // Explicitly disallow copy constructor and assignment operator.
    //
    C_Dlg(
        const C_Dlg&      rhs
        );

    C_Dlg&
    operator=(
        const C_Dlg&      rhs
        );

private:                // data

};  //  C_Dlg


#endif  //  _DLG_H_

//
///// End of file: DLG.h   ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\dlg.cpp ===
/*+

Copyright (c) 2000  Microsoft Corporation

Module Name:

    DLG.CPP

Abstract:

    C_Dlg implementation
     
Author:

    990518  dane    Created. 
    990721  dane    Added _THIS_MODULE_ for logging macros.
    georgema        000310  updated

Environment:
    Win98, Win2000

Revision History:

--*/

#pragma comment(user, "Compiled on " __DATE__ " at " __TIME__)
#pragma comment(compiler)

//////////////////////////////////////////////////////////////////////////////
//
//  Include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commctrl.h>
#include <tchar.h>
#include "macros.h"
#include <shfusion.h>
#include "Dlg.h"



//////////////////////////////////////////////////////////////////////////////
//
//  Static initialization
//
static const char       _THIS_FILE_[ ] = __FILE__;


//////////////////////////////////////////////////////////////////////////////
//
//  Static member initialization
//
LPCTSTR          C_Dlg::SZ_HWND_PROP = _T("hwnd");

//////////////////////////////////////////////////////////////////////////////
//
//  C_Dlg
//
//  Constructor.
//
//  parameters:
//      hwndParent      parent window for the dialog (may be NULL)
//      hInstance       instance handle of the parent window (may be NULL)
//      lIDD            dialog template id
//      pfnDlgProc      pointer to the function that will process messages for
//                      the dialog.  if it is NULL, the default dialog proc
//                      will be used.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
C_Dlg::C_Dlg(
    HWND                hwndParent,
    HINSTANCE           hInstance,
    LONG                lIDD,
    DLGPROC             pfnDlgProc     // = NULL
    )
:   m_hwndParent(hwndParent),
    m_hInstance(hInstance),
    m_lIDD(lIDD),
    m_pfnDlgProc(pfnDlgProc),
    m_hwnd(NULL)
{

    ASSERT(NULL != SZ_HWND_PROP);
    if (NULL == m_pfnDlgProc)
    {
        // Use the default dialog proc
        //
        m_pfnDlgProc = C_Dlg::DlgProc;
    }
}   //  C_Dlg::C_Dlg



//////////////////////////////////////////////////////////////////////////////
//
//  ~C_Dlg
//
//  Destructor.
//
//  parameters:
//      None.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
C_Dlg::~C_Dlg( )
{
    OnShutdown();
}   //  C_Dlg::~C_Dlg


//////////////////////////////////////////////////////////////////////////////
//
//  DoModal
//
//  Display the dialog box modally and wait for it to be closed.
//
//  parameters:
//      lparam          user-defined data that will be passed to the dialog
//                      proc as the lparam of the WM_INITDIALOG message.
//
//  returns:
//      User-defined result code returned by EndDialog( ).
//
//////////////////////////////////////////////////////////////////////////////
INT_PTR 
C_Dlg::DoModal(
    LPARAM              lparam      // = NULL
    )
{

    INT_PTR  nResult = DialogBoxParam(m_hInstance, 
                                      MAKEINTRESOURCE(m_lIDD), 
                                      m_hwndParent, 
                                      m_pfnDlgProc,
                                      lparam
                                      );
    // nResult will be 0 or -1 on failure, else will be value assigned from EndDialog()
    return nResult;

}   //  C_Dlg::DoModal




//////////////////////////////////////////////////////////////////////////////
//
//  DlgProc
//
//  Window procedure for wizard pages.  All messages are routed here, then
//  dispatched to the appropriate C_Dlg object.
//
//  parameters:
//      hwndDlg        window handle of the page for which the message is
//                      intended
//      uMessage        the message
//      wparam          message-specific data
//      lparam          message-specific data
//
//  returns:
//      TRUE            if the message was processed
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
 
INT_PTR  CALLBACK
C_Dlg::DlgProc(
    HWND                hwndDlg,
    UINT                uMessage,
    WPARAM              wparam,
    LPARAM              lparam
    )
{

    CHECK_MESSAGE(hwndDlg, uMessage, wparam, lparam);

    // Get the pointer to the C_Dlg object corresponding to the hwndDlg
    //
    C_Dlg*          pDlg = NULL;

    if (WM_INITDIALOG == uMessage)
    {
        // For WM_INITDIALOG, the pointer to the dialog object will be in
        // the lparam.
        //
        pDlg = (C_Dlg*) lparam;
    }
    else
    {
        // For all other messages, it will be attached to the HWND
        //
        HRESULT             hr = C_Dlg::DlgFromHwnd(hwndDlg, &pDlg);
        if (FAILED(hr))
        {
            return FALSE;
        }
        ASSERT(NULL != pDlg);
    }

    // Let the page route application-specific messages
    //
    if (WM_APP <= uMessage)
    {
        return pDlg->OnAppMessage(uMessage, wparam, lparam);
    }

    // Route Windows messages to appropriate handler
    //
    switch (uMessage)
    {
    case WM_INITDIALOG:
        return pDlg->OnInitDialog(hwndDlg,
                                  (HWND)wparam
                                  );
    case WM_HELP:
        return pDlg->OnHelpInfo(lparam);
        
    case WM_CONTEXTMENU:
        return pDlg->OnContextMenu(wparam,lparam);
        
    case WM_COMMAND:
        return pDlg->OnCommand(HIWORD(wparam), LOWORD(wparam), (HWND)lparam);
        
    case WM_NOTIFY:
        return RouteNotificationMessage(pDlg, (NMHDR*)lparam);
        break;

    case WM_DESTROY:
        return pDlg->OnDestroyDialog();
        break;
        
    default:
        // Message was not processed
        //
        return FALSE;
    }   //  switch (uMessage)

}   //  C_Dlg::DlgProc



//////////////////////////////////////////////////////////////////////////////
//
//  RouteNotificationMessage
//
//  Routes notification messages from wizard buttons to the appropriate page
//  and handler.
//
//  parameters:
//      hwndDlg        window handle of page to which message is to be sent
//      pnmhdr          pointer to the NMHDR structure containing info about
//                      the particular notification
//
//  returns:
//      TRUE            if the message is processed
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
BOOL
C_Dlg::RouteNotificationMessage(
    C_Dlg*          pDlg,
    NMHDR*              pnmhdr
    )
{

    if (NULL == pDlg)
    {
        //FIX220699
        return FALSE;
        //return E_INVALIDARG;
    }

    // If any specific notifications are to be handled, switch on pnmhdr->code.
    //
    return pDlg->OnNotify(pnmhdr);

}   //  C_Dlg::RouteNotificationMessage


//////////////////////////////////////////////////////////////////////////////
//
//  LinkHwnd
//
//  Store the pointer to this object in a window handle property.  This
//  provides a way to get to the object when all that is known is the HWND.
//  Particularly useful in window procedures.
//
//  parameters:
//      None.
//
//  returns:
//      TRUE            if the operation is successful
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
BOOL
C_Dlg::LinkHwnd( )
{

    ASSERT(IsWindow(m_hwnd));
    if (! IsWindow(m_hwnd))
    {
        return FALSE;
    }

    return SetProp(m_hwnd, SZ_HWND_PROP, (HANDLE)this);

}   //  C_Dlg::LinkHwnd

//////////////////////////////////////////////////////////////////////////////
//
//  UnlinkHwnd
//
//  Remove the pointer to the associated object from a window handle.  The
//  pointer must have been set with LinkHwnd( ).
//
//  parameters:
//      None.
//
//  returns:
//      TRUE            if the window handle is removed and it is a pointer to
//                      this object
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
BOOL
C_Dlg::UnlinkHwnd( )
{

    ASSERT(IsWindow(m_hwnd));
    if (! IsWindow(m_hwnd))
    {
        return FALSE;
    }

    C_Dlg*          pDlg = (C_Dlg*)RemoveProp(m_hwnd, SZ_HWND_PROP);

    ASSERT(this == pDlg);
    return (this == pDlg);

}   //  C_Dlg::UnlinkHwnd

//////////////////////////////////////////////////////////////////////////////
//
//  DlgFromHwnd
//
//  Retrieves the pointer to the associated object from a window handle.  The
//  pointer was stored in a property by LinkHwnd( ).
//
//  parameters:
//      hwnd            the window handle containing the pointer
//      ppDlg           pointer to a buffer that will receive the pointer to
//                      the C_Dlg object
//
//  returns:
//      S_OK            if the operation is successful
//      E_INVALIDARG    if hwnd is not a valid window or ppDlg is NULL
//      E_POINTER       if the retrieved pointer is NULL
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
C_Dlg::DlgFromHwnd(
    HWND                hwnd,
    C_Dlg**         ppDlg
    )
{

    if (! ::IsWindow(hwnd))
    {
             return (E_INVALIDARG);
    }

    ASSERT(NULL != ppDlg);
    if (NULL == ppDlg)
    {
        return (E_INVALIDARG);
    }

    *ppDlg = (C_Dlg*) GetProp(hwnd, SZ_HWND_PROP);

    if (NULL == *ppDlg)
    {
        return (E_POINTER);
    }

    return (S_OK);

}   //  C_Dlg::DlgFromHwnd

//
///// End of file: Dlg.cpp   ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\keymgr.h ===
#ifndef _KEYMGR_H_
#define _KEYMGR_H_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    KEYMGR.H

Abstract:

    KeyMgr application public API definitions
     
Author:

    990917  johnhaw Created. 
    georgema        000310  updated

Environment:
    Win98, Win2000

Revision History:

--*/
#ifdef __cplusplus
extern "C" 
{
#endif
BOOL WINAPI DllMain(HINSTANCE,DWORD,LPVOID);
LONG WINAPI CPlApplet(HWND hwndCPl,UINT uMsg,LPARAM lParam1,LPARAM lParam2);
void APIENTRY KRShowKeyMgr(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowSaveWizardW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowSaveWizardExW(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowSaveFromMsginaW(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowRestoreWizardW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowRestoreWizardExW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowRestoreFromMsginaW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
#ifdef __cplusplus
}
#endif
#endif  //  _KEYMGR_H_

//
///// End of file: KeyMgr.h ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\keymgr.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    KEYMGR.CPP

Abstract:

    Keyring WinMain() and application support
     
Author:

    990917  johnhaw Created. 
    georgema        000310  updated
    georgema        000501  used to be EXE, changed to CPL

Comments:
    This executable is the control panel applet to allow a user some control 
    over the contents of the Windows Keyring, the so-called "Geek UI".  It was 
    originally an EXE, but that architecture is not as optimized for merging 
    with other control panel applets.  It has been changed to a CPL executable, 
    and can be either left as a CPL if it is desired that it should show up 
    automatically in the master control panel window, or rahter renamed to 
    a DLL file extension if it is desired that a control panel applet container
    application should load it explicitly without it otherwise being visible 
    to the system.

Environment:
    WinXP

Revision History:

--*/

#pragma comment(user, "Compiled on " __DATE__ " at " __TIME__)
#pragma comment(compiler)


//////////////////////////////////////////////////////////////////////////////
//
//  Include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <cpl.h>
#include <wincred.h>
#include <wincrui.h>
#include <shfusion.h>
#include <scuisupp.h>
#include <lmcons.h>
#include "switches.h"
#include "Dlg.h"
#include "Res.h"
#include "keymgr.h"
#include "krDlg.h"

//////////////////////////////////////////////////////////////////////////////
//
//  Static initialization
//
static const char       _THIS_FILE_[ ] = __FILE__;

//////////////////////////////////////////////////////////////////////////////
//
//  Global state info
//

C_KeyringDlg *pDlg = NULL;

/**********************************************************************

CPlApplet is the entrypoint for a control panel applet.  This entry point
is used by keymgr.cpl, generated in the keycpl project.  The decision to 
implement this cpl functionality in keymgr.dll, rather than in keymgr.cpl,
allows the implementation of keymgr to be contained entirely within 
keymgr.dll, as a common component, without need to update the cpl version 
if changes are made to the dll.  The cpl is a very thin wrapper for the dll.

**********************************************************************/

extern "C"LONG APIENTRY CPlApplet(HWND hwndCPl,UINT uMsg,LPARAM lParam1,LPARAM lParam2)
{
    CPLINFO *lpCPlInfo;

    // Handle commands to this dll/cpl from the enclosing presentation app.
    // Default return from any command is 0 (success), except those commands
    //  which ask for specific data in the return value
    
    switch(uMsg) 
    {
        case CPL_INIT:
            g_hInstance = GetModuleHandle(L"keymgr.dll");
            if (NULL == g_hInstance) 
            {
                ASSERT(g_hInstance);
                return FALSE;
            }
            return TRUE;
            break;
            
        case CPL_GETCOUNT:
            return 1;       // only 1 applet icon in this cpl file
            break;

        case CPL_NEWINQUIRE:
            break;
            
        case CPL_INQUIRE:
            ASSERT(lParam2);
            lpCPlInfo = (CPLINFO *) lParam2;  // acquire ptr to target data 
            lpCPlInfo->lData = 0;             // no effect
            lpCPlInfo->idIcon = IDI_UPGRADE;  // store items needed to show the applet
            lpCPlInfo->idName = IDS_APP_NAME;
            lpCPlInfo->idInfo = IDS_APP_DESCRIPTION; // description string
            break;
            
        case CPL_DBLCLK:
            // user has selected this cpl applet - put up our dialog
            if (NULL == pDlg)
            {
                KRShowKeyMgr(NULL,g_hInstance,NULL,0);
            }
            break;
            
        case CPL_STOP:
            delete pDlg;
            pDlg = NULL;
            break;
            
        case CPL_EXIT:
            break;
            
        default:
            ASSERT(0);      // surprising function code
            break;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\krdlg.h ===
#ifndef _KRDLG_H_
#define _KRDLG_H_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    krdlg.h

Abstract:

    keyring dialog class definitions

Author:

    johnhaw     991118  created
    georgema    000310  modified

Environment:

Revision History:

--*/

// keymgr does not currently handle generic credentials.  This means that the maximum
//  string length for a name is greatly contstrained, to 337 chars from a generic max
//  value of 32767.
//#define TARGETNAMEMAXLENGTH (CRED_MAX_GENERIC_TARGET_NAME_LENGTH + MAXSUFFIXSIZE + 1)
#define FULLNAMEMAXLENGTH (UNLEN + UNLEN + 1)
#define TARGETNAMEMAXLENGTH (CRED_MAX_DOMAIN_TARGET_NAME_LENGTH + MAXSUFFIXSIZE + 1)
#define MAX_STRING_SIZE (256)           // misc text buffers
#define MAXSUFFIXSIZE (64)                  // suffix in main dialog display mex length chars

// implemented in krdlg.cpp
DWORD GetPersistenceOptions(DWORD);

#ifdef KRDLG_CPP
#define dllvar
#else
#define dllvar extern
#endif

dllvar HINSTANCE     g_hInstance;
dllvar CREDENTIAL *g_pExistingCred;        // current cred under edit
dllvar DWORD          g_dwPersist;
dllvar DWORD          g_dwType;
dllvar TCHAR*          g_szTargetName;

// suffix strings used in the UI to mark special credential types
#ifdef SHOWPASSPORT
dllvar TCHAR   g_rgcPassport[MAXSUFFIXSIZE];
#endif
dllvar TCHAR   g_rgcCert[MAXSUFFIXSIZE];     // Hold suffix read in from resources

//===================================

//////////////////////////////////////////////////////////////////////////////
//
// C_ChangePasswordDlg
//
class C_ChangePasswordDlg 
:   public C_Dlg
{
public:                 // operations
    C_ChangePasswordDlg(
        HWND                hwndParent,
        HINSTANCE           hInstance,
        LONG                lIDD,
        DLGPROC             pfnDlgProc = NULL
        );

    ~C_ChangePasswordDlg( )
    {
    }   //  ~C_ChangePasswordDlg

    virtual BOOL
    OnInitDialog(
        HWND                hwndDlg,
        HWND                hwndFocus
        );

    virtual BOOL
    OnCommand(
        WORD                wNotifyCode,
        WORD                wSenderId,
        HWND                hwndSender
        );

    virtual void
    AssertValid( ) const
    {
        C_Dlg::AssertValid( );
    }   //  AssertValid

protected:              // operations

public:              // data

   HINSTANCE m_hInst;
   HWND m_hDlg;

   TCHAR m_szFullUsername[FULLNAMEMAXLENGTH + 1 ];
   TCHAR m_szUsername[UNLEN + 1];
   TCHAR m_szDomain[UNLEN + 1];
   TCHAR m_szOldPassword[PWLEN];
   TCHAR m_szNewPassword[PWLEN];
   TCHAR m_szConfirmPassword[PWLEN];

   BOOL m_bIsDefault;

   
private:                // operations

    virtual void
    OnOK( );

    // Explicitly disallow copy constructor and assignment operator.
    //
    C_ChangePasswordDlg(
        const C_ChangePasswordDlg&      rhs
        );

    C_ChangePasswordDlg&
    operator=(
        const C_ChangePasswordDlg&      rhs
        );

private:                // data

};  //  C_ChangePasswordDlg




//////////////////////////////////////////////////////////////////////////////
//
// C_KeyringDlg
//

class C_KeyringDlg 
:   public C_Dlg
{
public:                 // operations
    C_KeyringDlg(
        HWND                hwndParent,
        HINSTANCE           hInstance,
        LONG                lIDD,
        DLGPROC             pfnDlgProc = NULL
        );

    // Perform miscellaneous cleanups required as the dialog is
    //  destroyed

    ~C_KeyringDlg( )
    {
    }   //  ~C_KeyringDlg

    virtual BOOL
    OnInitDialog(
        HWND                hwndDlg,
        HWND                hwndFocus
        );

    virtual BOOL
    OnDestroyDialog(void);
    
    virtual BOOL
    OnCommand(
        WORD                wNotifyCode,
        WORD                wSenderId,
        HWND                hwndSender
        );

// TOOL TIP functions

    virtual BOOL
    InitTooltips(void);

// HELP functions

    virtual BOOL
    OnHelpInfo(
        LPARAM lp
        );


    virtual UINT
    MapID(UINT uid);
    

    virtual void
    AssertValid( ) const
    {
        C_Dlg::AssertValid( );
    }   //  AssertValid

    virtual BOOL
    OnAppMessage(
        UINT                uMessage,
        WPARAM              wparam,
        LPARAM              lparam
        );

    // Register the windows messages expected from the smartcard 
    //  subsystem
    BOOL 
    RegisterMessages(void);

protected:              

    HINSTANCE m_hInst;
    HWND    m_hDlg;
    BOOL    fInit;

   
private:                // operations

    virtual void
    OnOK( );

    BOOL DoEdit(void);

    void BuildList();
    void SetCurrentKey(LONG_PTR iKey);
    void DeleteKey();
    void OnChangePassword();
    BOOL OnHelpButton(void);

    // Explicitly disallow copy constructor and assignment operator.
    //
    C_KeyringDlg(
        const C_KeyringDlg&      rhs
        );

    C_KeyringDlg&
    operator=(
        const C_KeyringDlg&      rhs
        );

private:                // data
	DWORD		m_cCredCount;

};  //  C_KeyringDlg



//////////////////////////////////////////////////////////////////////////////
//
// C_AddKeyDlg
//

class C_AddKeyDlg 
:   public C_Dlg
{
public:                 // operations
    C_AddKeyDlg(
        HWND                hwndParent,
        HINSTANCE           hInstance,
        LONG                lIDD,
        DLGPROC             pfnDlgProc = NULL
        );

    ~C_AddKeyDlg( )
    {
    }   //  ~C_AddKeyDlg

    virtual BOOL
    OnInitDialog(
        HWND                hwndDlg,
        HWND                hwndFocus
        );

    virtual BOOL
    OnDestroyDialog(void);

    virtual BOOL
    OnCommand(
        WORD                wNotifyCode,
        WORD                wSenderId,
        HWND                hwndSender
        );

    virtual BOOL
    OnHelpInfo(
        LPARAM lp
        );


    virtual UINT
    MapID(
        UINT uid
    );
    
virtual void
    AssertValid( ) const
    {
        C_Dlg::AssertValid( );
    }   //  AssertValid

    virtual BOOL
    OnAppMessage(
        UINT                uMessage,
        WPARAM              wparam,
        LPARAM              lparam
        );

    void 
    AdviseUser(void);

    BOOL
    AddItem(TCHAR *psz,INT iImageIndex,INT *pIndexOut);

    BOOL 
    SetItemData(INT_PTR iIndex,LPARAM dwData);

    BOOL 
    GetItemData(INT_PTR iIndex,LPARAM *dwData);

    BOOL 
    SetItemIcon(INT iIndex,INT iWhich);

    void 
    UpdateSCard(INT,CERT_ENUM *pCE);

    void 
    SaveName(void);

    void 
    RestoreName(void);

    void
    ShowDescriptionText(DWORD,DWORD);
    
public:
    // Public data members
    BOOL    m_bEdit;            // set outside the class 
    HWND    m_hDlg;             // used by C_KeyringDlg for g_wmUpdate
    
private:

    void 
    EditFillDialog(void);

    HWND    m_hwndTName;
    HWND    m_hwndCred;
    HWND    m_hwndDomain;
    HWND    m_hwndChgPsw;
    HWND    m_hwndPswLbl;
    HWND    m_hwndDescription;

    INT     m_iUNCount;
    TCHAR   *pUNList;

    HINSTANCE m_hInst;
    DWORD   m_dwOldType;
    TCHAR   m_szUsername[CRED_MAX_USERNAME_LENGTH + 1];
    TCHAR   m_szPassword[PWLEN + 1];
    TCHAR   m_szDomain[UNLEN + 1];

   
private:                // operations

    void OnChangePassword();

    DWORD
    SetPersistenceOptions(void);
    
    virtual void
    OnOK( );

    // Explicitly disallow copy constructor and assignment operator.
    //
    C_AddKeyDlg(
        const C_AddKeyDlg&      rhs
        );

    C_AddKeyDlg&
    operator=(
        const C_AddKeyDlg&      rhs
        );

};  //  C_AddKeyDlg



#endif  //  _KRDLG_H_

//
///// End of file: KrDlg.h   ///////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\krdlg.cpp ===
/*++

Copyright (c) 2000,2001  Microsoft Corporation

Module Name:

    KRDLG.CPP

Abstract:

    Implementation of the dialog behaviors for three application dialogs:
    the add/edit credential dialog, the delete credential dialog, and
    the password change dialog.  These dialogs are derived fom C_Dlg

    Password change operates only on credentials of the form 
    domain\username.  Note that changing a password for such a credential
    will change the psw for all creds with the same domain\username to 
    match (this is done by the credential mgr).

    Add and Edit use the same dialog, differing in implementation on
    the basis of a flag which initializes the two dialogs differently
    and causes the edit case to also delete the underlying previous 
    version of the credential.
  
Author:

    johnhaw         991118  original version created
    georgema        000310  modified, removed "gizmo" services, modified
                             to use the new credential mgr
    georgema        000415  modified, use comboboxex to hold icon as well
                             as user name
    georgema        000515  modified to CPL from EXE, smartcard support 
                             added
    georgema        000712  modified to use cred control in lieu of combo
                             and edit boxes for username/password entry.
                             Delegating smartcard handling to cred ctrl.
Environment:
    Win2000

--*/

#pragma comment(user, "Compiled on " __DATE__ " at " __TIME__)
#pragma comment(compiler)
static const char       _THIS_FILE_[ ] = __FILE__;
#define KRDLG_CPP

//////////////////////////////////////////////////////////////////////////////
//
//  Include files
//
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbase.h>
#include <tchar.h>
#include <wincrui.h>
#include <wincred.h>
#include <comctrlp.h>
#include <shfusion.h>
#include <lmcons.h>
#include <scuisupp.h>
#include "switches.h"
#include "Dlg.h"
#include "Res.h"
#include "KRDlg.h"
#include "keymgr.h"
#include "testaudit.h"

extern C_KeyringDlg *pDlg;

// Named mutex used to prevent running multiple instances
#define KEYMGRMUTEX (TEXT("KeyMgrMutex"))

//////////////////////////////////////////////////////////////////////////////
//
// DLLMain
//
//
//////////////////////////////////////////////////////////////////////////////

BOOL WINAPI DllMain(HINSTANCE hinstDll,DWORD fdwReason,LPVOID lpvReserved) 
{
    BOOL bSuccess = TRUE;
    switch(fdwReason) 
    {
        case DLL_PROCESS_ATTACH:
            CHECKPOINTINIT;
            CHECKPOINT(9,"DLL Attach");
            SHFusionInitializeFromModuleID(hinstDll,123);
            DisableThreadLibraryCalls(hinstDll);
            g_hInstance = hinstDll;
            ASSERT(g_hInstance);
            break;
        case DLL_PROCESS_DETACH:
            CHECKPOINTFINISH;
            SHFusionUninitialize();
            break;
    }
    return bSuccess;
}

/**********************************************************************

   Create and show the keyring main dialog.  Return -1 (unable to create)
   on errors.  If creation goes OK, call the DoModal method of the 
   dialog object.
   
**********************************************************************/
void WINAPI KRShowKeyMgr(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow) 
{
    HANDLE hMutex = CreateMutex(NULL,TRUE,KEYMGRMUTEX);
    ASSERT(hMutex);
    if (NULL == hMutex) 
    {
        return;
    }
    if (ERROR_ALREADY_EXISTS == GetLastError()) 
    {
        // disallow duplicate dialogs
        CloseHandle(hMutex);
        return;
    }
    
    INITCOMMONCONTROLSEX stICC;
    BOOL fICC;
    stICC.dwSize = sizeof(INITCOMMONCONTROLSEX);
    stICC.dwICC = ICC_WIN95_CLASSES | ICC_STANDARD_CLASSES;
    fICC = InitCommonControlsEx(&stICC);

    // bail if initialization fails
    ASSERT(NULL == pDlg);
    if (NULL != pDlg)
    {
        return;
    }
    
    if (!CredUIInitControls()) 
    {
        return;
    }
    
    pDlg = new C_KeyringDlg(hwParent,g_hInstance,IDD_KEYRING,NULL);

    // probably out of memory
    if (NULL == pDlg) 
    {
        return;
    }
    pDlg->DoModal((LPARAM) pDlg);
    
    delete pDlg;
    pDlg = NULL;
    CloseHandle(hMutex);
    return;
}

/********************************************************************

Get allowable persistence value for the current logon session given
 the type of the credential to be saved.  This routine used by both
 the main dialog and the edit dialog.

Gets an array of persistence values, one for each cred type, and returns
the value associated with the passed type.

********************************************************************/
DWORD GetPersistenceOptions(DWORD dwPType) 
{

    BOOL bResult;
    DWORD i[CRED_TYPE_MAXIMUM];
    DWORD dwCount = CRED_TYPE_MAXIMUM;

#if DBG
    if ((dwPType != CRED_TYPE_DOMAIN_CERTIFICATE)      &&
        (dwPType != CRED_TYPE_DOMAIN_PASSWORD)         &&
        (dwPType != CRED_TYPE_DOMAIN_VISIBLE_PASSWORD) &&
        (dwPType != CRED_TYPE_GENERIC))
    {
        ASSERT(0);
    }
#endif

    bResult = CredGetSessionTypes(dwCount,&i[0]);
    if (!bResult) 
    {
        return CRED_PERSIST_NONE;
    }

    return i[dwPType];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\macros.h ===
#ifndef _MACROS_H_
#define _MACROS_H_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    MACROS.H

Abstract:

    Project agnostic utility macros
     
Author:

    990518  dane    Created. 
    990721  dane    Removed ASSERTs from ROE_*.  A failure does not
                    necessarily an ASSERT need.
    georgema        000310  updated

Environment:
    Win98, Win2000

Revision History:

--*/

#include <crtdbg.h>

#if _MSC_VER > 1000

// make the beginning and end of a namespace stand out
//
#define BEGIN_NAMESPACE(name)   namespace name {
#define END_NAMESPACE(name)     };
#define USING_NAMESPACE(name)   using namespace name
#else
#define BEGIN_NAMESPACE(name)   
#define END_NAMESPACE(name)     
#define USING_NAMESPACE(name)  
#endif  //  _MSC_VER > 1000


// Heap allocation...use CRT debug new when _DEBUG is defined
//
#ifdef      _DEBUG
#define _NEW     new(_CLIENT_BLOCK, _THIS_FILE_, __LINE__)
#else   //  ! _DEBUG
#define _NEW     new
#endif  //  _DEBUG

#define _DELETE      delete

// aliases for assertion macros
//
#ifdef      ASSERT
#undef  ASSERT
#endif  //  ASSERT

#ifdef      VERIFY
#undef  VERIFY
#endif  //  VERIFY

#ifdef      _DEBUG
#define ASSERT(cond)      _ASSERTE(cond)
#define VERIFY(cond)      _ASSERTE(cond)
#else   //  NDEBUG
#define ASSERT(cond)      ((void)0)
#define VERIFY(cond)      (cond)
#endif  //  _DEBUG

// aliases for segment names
//
#ifdef      DATASEG_READONLY
#undef  DATASEG_READONLY
#endif  //  DATASEG_READONLY
#define DATASEG_READONLY        ".rdata"

//////////////////////////////////////////////////////////////////////////////
//
// RETURN ON ERROR macros
//
// ROE_HRESULT
// ROE_LRESULT
// ROE_POINTER
//
// Checks a return code or condition and returns a user-supplied error code if
// an error has occurred.
//
// Usage:
//      TYPE Foo( )
//      {
//          TYPE    status = Bar( );
//          ROE_TYPE(status, ret);
//          
//          // continue processing...
//      }
//
//
#define ROE_HRESULT(hr, ret)                                    \
            if (FAILED(hr))                                     \
            {                                                   \
                LogError(0, _THIS_FILE_, __LINE__,                 \
                         _T("0x%08X 0x%08X\n"), \
                         hr, ret);                              \
                return (ret);                                   \
            }

#define ROE_LRESULT(lr, ret)                                    \
            if (ERROR_SUCCESS != lr)                            \
            {                                                   \
                LogError(0, _THIS_FILE_, __LINE__,                 \
                         _T("0x%08X 0x%08X\n"),  \
                         lr, ret);                              \
                return (ret);                                   \
            }

#define ROE_POINTER(p, ret)                                     \
            if (NULL == (p))                                    \
            {                                                   \
                LogError(0, _THIS_FILE_, __LINE__,                 \
                         _T("0x%08X\n"),    \
                         ret);                                  \
                return (ret);                                   \
            }

#define ROE_CONDITION(cond, ret)                                \
            if (! (cond))                                       \
            {                                                   \
                LogError(0, _THIS_FILE_, __LINE__,                 \
                         _T("0x%08X 0x%08X\n"),  \
                         ##cond, ret);                          \
                return (ret);                                   \
            }

//////////////////////////////////////////////////////////////////////////////
//
// CHECK macros
//
// CHECK_HRESULT
// CHECK_LRESULT
// CHECK_POINTER
// CHECK_MESSAGE
//
// Checks a return code or condition and returns a user-supplied error code if
// an error has occurred.
//
// Usage:
//      TYPE Foo( )
//      {
//          TYPE    status = Bar( );
//          CHECK_TYPE(status);
//          
//          // continue processing...
//      }
//
//
#define CHECK_HRESULT(hr)                                       \
            (FAILED(hr))                                        \
                ? LogError(0, _THIS_FILE_, __LINE__, _T("0x%08X"), hr), hr \
                : hr

#define CHECK_LRESULT(lr)                                       \
            (ERROR_SUCCESS != lr)                               \
                ? LogError(0, _THIS_FILE_, __LINE__, _T("0x%08X"), lr), lr \
                : lr

#define CHECK_POINTER(p)                                        \
            (NULL == (p))                                       \
                ? LogError(0, _THIS_FILE_, __LINE__, _T("NULL pointer"), p), p \
                : p

#ifdef      _DEBUG
#define CHECK_MESSAGE(hwnd, msg, wparam, lparam)                \
            {                                                   \
                LogInfo(0, _THIS_FILE_, __LINE__,                  \
                        _T("MESSAGE: 0x%08X, 0x%08X, 0x%08X, 0x%08X\n"), \
                         hwnd, msg, wparam, lparam);            \
            }                                                   
#else
#define CHECK_MESSAGE(hwnd, msg, wparam, lparam) ((void)0)
#endif  //  _DEBUG


// count of elements in an array
//
#define COUNTOF(array)  (sizeof(array) / sizeof(array[0]))

#endif  //  _MACROS_H_

//
///// End of file: Macros.h   ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\editdlg.cpp ===
/*++

Copyright (c) 2000,2001  Microsoft Corporation

Module Name:

    EDITDLG.CPP

Abstract:

    Implementation of the properties dialog which allows the user to create
    a new credential or edit an old one.
  
Author:

Environment:
    WinXP

--*/

//////////////////////////////////////////////////////////////////////////////
//
//  Include files
//
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbase.h>
#include <tchar.h>
#include <windns.h>
#include <shellapi.h>
#include <wincrui.h>
#include <htmlhelp.h>
#include <wincred.h>
#include <credp.h>
#include <comctrlp.h>
#include <scuisupp.h>
#include <shfusion.h>
#include "switches.h"
#include "Dlg.h"
#include "Res.h"
#include "KRDlg.h"
#include "keymgr.h"
#include "testaudit.h"

// character length of buffer to contain localized description string for 
//  the credential being created/edited
#define DESCBUFFERLEN 500

BOOL        g_fPswChanged;              // password window touched by user
extern BOOL g_fReloadList;

/**********************************************************************

Return the help string associated with the UI element passed by ID
as input.

**********************************************************************/

UINT C_AddKeyDlg::MapID(UINT uiID) 
{
   switch(uiID) 
   {
        case 1003:
          return IDH_CUIUSER;
        case 1005:
          return IDH_CUIPSW;
        case 1010:
          return IDH_CUIVIEW;
        case IDOK:
            return IDH_CLOSE;
        case IDCANCEL:
          return IDH_DCANCEL;
        case IDD_ADDCRED:
          return IDH_ADDCRED;
        case IDC_TARGET_NAME:
          return IDH_TARGETNAME;
        case IDC_OLD_PASSWORD:
          return IDH_OLDPASSWORD;
        case IDC_NEW_PASSWORD:
          return IDH_NEWPASSWORD;
        case IDC_CONFIRM_PASSWORD:
          return IDH_CONFIRM;
        case IDD_KEYRING:
          return IDH_KEYRING;
        case IDC_KEYLIST:
          return IDH_KEYLIST;
        case IDC_NEWKEY:
          return IDH_NEW;
        case IDC_EDITKEY:
          return IDH_EDIT;
        case IDC_DELETEKEY:
          return IDH_DELETE;
        case IDC_CHANGE_PASSWORD:
          return IDH_CHANGEPASSWORD;
        default:
          return IDS_NOHELP;
   }
}

//////////////////////////////////////////////////////////////////////////////
//
//  C_AddKeyDlg
//
//  Constructor.
//
//  parameters:
//      hwndParent      parent window for the dialog (may be NULL)
//      hInstance       instance handle of the parent window (may be NULL)
//      lIDD            dialog template id
//      pfnDlgProc      pointer to the function that will process messages for
//                      the dialog.  if it is NULL, the default dialog proc
//                      will be used.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////

C_AddKeyDlg::C_AddKeyDlg(
    HWND                hwndParent,
    HINSTANCE           hInstance,
    LONG                lIDD,
    DLGPROC             pfnDlgProc  //   = NULL
    )
:   C_Dlg(hwndParent, hInstance, lIDD, pfnDlgProc)
{
   m_hInst = hInstance;
}   //  C_AddKeyDlg::C_AddKeyDlg


/**********************************************************************

Fill properties dialog fields with values taken from the currently selected
credential.

**********************************************************************/

void
C_AddKeyDlg::EditFillDialog(void) 
{
    TCHAR       szTitle[CRED_MAX_STRING_LENGTH + 1];        // buffer to hold window title string

    ASSERT(g_pExistingCred);
    if (NULL == g_pExistingCred) return;

    // Set up persistence in the UI
    g_dwPersist = g_pExistingCred->Persist;
    g_dwType =  g_pExistingCred->Type;

    // Enable the change password stuff only on domain password creds
    //
    switch (g_pExistingCred->Type)
    {
        case CRED_TYPE_DOMAIN_PASSWORD:
            CHECKPOINT(1,"Keymgr: Edit - Password cred edit");
            ShowWindow(m_hwndChgPsw,SW_NORMAL);
            ShowWindow(m_hwndPswLbl,SW_NORMAL);
            //deliberate fallthrough
        case CRED_TYPE_DOMAIN_CERTIFICATE:
            CHECKPOINT(2,"keymgr: Edit - Certificate cred edit");
            LoadString ( m_hInst, IDS_TITLE, szTitle, 200 );
            SendMessage(m_hDlg,WM_SETTEXT,0,(LPARAM) szTitle);
            break;
        case CRED_TYPE_GENERIC:
            // generic cred not supported yet
            break;
        case CRED_TYPE_DOMAIN_VISIBLE_PASSWORD:
            // passport cred should not get this far.
            ASSERT(0);
            break;
        default:
            // type data bad
            ASSERT(0);
            break;
    }
    
    // Write targetname to the UI
    SendMessage(m_hwndTName, WM_SETTEXT,0,(LPARAM) g_pExistingCred->TargetName);

    // Write username to the UI - take directly from the existing cred
    if (!Credential_SetUserName(m_hwndCred,g_pExistingCred->UserName)) 
    {
        // make a copy of the original username
        _tcsncpy(m_szUsername,g_pExistingCred->UserName,CRED_MAX_USERNAME_LENGTH);
        m_szUsername[CRED_MAX_USERNAME_LENGTH] = 0;
    }

}

/**********************************************************************

Compose the UI string which describes the type and persistence of the 
credential being created or edited. Write the text to the text control
on the dialog.

**********************************************************************/

void C_AddKeyDlg::ShowDescriptionText(DWORD dwtype, DWORD Persist) 
{
    WCHAR szMsg[DESCBUFFERLEN + 1];
    WCHAR szTemp[DESCBUFFERLEN + 1];
    INT iRem = DESCBUFFERLEN;       // remaining space in the buffer
    CHECKPOINT(3,"Keymgr: Edit - Show description on prop dialog");
    memset(szMsg,0,sizeof(szMsg));
    
    if ((dwtype != CRED_TYPE_DOMAIN_PASSWORD) &&
       (dwtype != CRED_TYPE_DOMAIN_CERTIFICATE))
    {
        // A generic credential - not currently supported
        LoadString ( m_hInst, IDS_DESCAPPCRED, szTemp, DESCBUFFERLEN );
        wcsncpy(szMsg,szTemp,DESCBUFFERLEN);
        szMsg[DESCBUFFERLEN] = 0;
        iRem -= wcslen(szMsg);
    }
    else 
    {
        // a domain-type credential
        // Show usage local machine versis domain
        if (Persist != CRED_PERSIST_ENTERPRISE)
        {
            // either local persist or session persist creds show this string
            CHECKPOINT(12,L"Keymgr: Edit - Show properties of non-enterprise persist cred");
            LoadString ( m_hInst, IDS_DESCLOCAL, szTemp, DESCBUFFERLEN );
        }
        else
        {
            // enterprise persistence - if you have a roaming profile, etc...
            CHECKPOINT(13,L"Keymgr: Edit - Show properties of enterprise persist cred");
            LoadString ( m_hInst, IDS_DESCBASE, szTemp, DESCBUFFERLEN );
        }
        wcsncpy(szMsg,szTemp,DESCBUFFERLEN);
        szMsg[DESCBUFFERLEN] = 0;
        iRem -= wcslen(szMsg);
    }

    // String: until you log off  -or- until you delete it
    if (Persist == CRED_PERSIST_SESSION)
    {
            // until you log off
            CHECKPOINT(18,L"Keymgr: Edit - Show properties of session cred");
            LoadString ( m_hInst, IDS_PERSISTLOGOFF, szTemp, DESCBUFFERLEN );
    }
    else
    {
            // until you delete it
            CHECKPOINT(19,L"Keymgr: Edit - Show properties of non-session cred");
            LoadString ( m_hInst, IDS_PERSISTDELETE, szTemp, DESCBUFFERLEN );
    }

    iRem -= wcslen(szTemp);
    if (0 < iRem) wcsncat(szMsg,szTemp,iRem);
    szMsg[DESCBUFFERLEN] = 0;
    SendMessage(m_hwndDescription, WM_SETTEXT,0,(LPARAM) szMsg);
    return;

}

//////////////////////////////////////////////////////////////////////////////
//
//  OnInitDialog
//
//  Dialog control and data initialization.
//
//  parameters:
//      hwndDlg         window handle of the dialog box
//      hwndFocus       window handle of the control that will receive focus
//
//  returns:
//      TRUE            if the system should set the default keyboard focus
//      FALSE           if the keyboard focus is set by this app
//
//////////////////////////////////////////////////////////////////////////////

BOOL
C_AddKeyDlg::OnInitDialog(
    HWND                hwndDlg,
    HWND                hwndFocus
    )
{
    C_Dlg::OnInitDialog(hwndDlg, hwndFocus);

    m_hDlg = hwndDlg;

    // get control handles, used for various purposes by other member fns
    m_hwndCred  = GetDlgItem(m_hDlg,IDC_CRED);
    m_hwndTName  = GetDlgItem(m_hDlg,IDC_TARGET_NAME);
    m_hwndChgPsw = GetDlgItem(m_hDlg,IDC_CHGPSW);
    m_hwndPswLbl = GetDlgItem(m_hDlg,IDC_DOMAINPSWLABEL);
    m_hwndDescription = GetDlgItem(m_hDlg,IDC_DESCRIPTION);

    // Initialize the cred control to show all usable authenticators
    if (!Credential_InitStyle(m_hwndCred,CRS_USERNAMES | CRS_CERTIFICATES | CRS_SMARTCARDS))
    {
        return FALSE;
    }
    
    
    // Establish limits on string lengths from the user
    SendMessage(m_hwndTName,EM_LIMITTEXT,CRED_MAX_GENERIC_TARGET_NAME_LENGTH,0);

    // Show dummy password for edited credential
    if (m_bEdit)
    {
        Credential_SetPassword(m_hwndCred,L"********");
    }
    
    // Set up the allowable persistence options depending on the type of user session
    // Set the default persistence unless overriden by a cred read on edit
    g_dwType = CRED_TYPE_DOMAIN_PASSWORD;
    g_dwPersist = GetPersistenceOptions(CRED_TYPE_DOMAIN_PASSWORD);

    // By default, hide all optional controls.  These will be enabled as appropriate
    ShowWindow(m_hwndChgPsw,SW_HIDE);
    ShowWindow(m_hwndPswLbl,SW_HIDE);

    // If editing an existing credential, fill dialog fields with existing data
    //  will also override type and persistence globals
    if (m_bEdit) 
    {
        EditFillDialog();
    }

    g_fPswChanged = FALSE;              // password so far unedited
    
    ShowDescriptionText(g_dwType,g_dwPersist);
    return TRUE;
    // On exit from OnInitDialog, g_szTargetName holds the currently selected 
    //  credential's old name, undecorated (having had a null dropped before
    //  the suffix)
}   //  end C_AddKeyDlg::OnInitDialog

/**********************************************************************

Pro forma OnDestroyDialog()

**********************************************************************/

BOOL
C_AddKeyDlg::OnDestroyDialog(
    void    )
{
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OnAppMessage
//
//////////////////////////////////////////////////////////////////////////////

BOOL
C_AddKeyDlg::OnAppMessage(
        UINT                uMessage,
        WPARAM              wparam,
        LPARAM              lparam)
{
    return TRUE;
}

/**********************************************************************

On a help request event, get the control ID, map it to a help string,
and present this as a tooltip over the control.

**********************************************************************/

BOOL
C_AddKeyDlg::OnHelpInfo(LPARAM lp) 
{

    HELPINFO* pH;
    INT iMapped;
    pH = (HELPINFO *) lp;
    HH_POPUP stPopUp;
    RECT rcW;
    UINT gID;

    gID = pH->iCtrlId;
    iMapped = MapID(gID);

    CHECKPOINT(5,"Keymgr: Edit - Add dialog OnHelpInfo");
    if (iMapped == 0) return TRUE;
    
    if (IDS_NOHELP != iMapped) 
    {

      memset(&stPopUp,0,sizeof(stPopUp));
      stPopUp.cbStruct = sizeof(HH_POPUP);
      stPopUp.hinst = g_hInstance;
      stPopUp.idString = iMapped;
      stPopUp.pszText = NULL;
      stPopUp.clrForeground = -1;
      stPopUp.clrBackground = -1; 
      stPopUp.rcMargins.top = -1;
      stPopUp.rcMargins.bottom = -1;
      stPopUp.rcMargins.left = -1;
      stPopUp.rcMargins.right = -1;
      // bug 393244 - leave NULL to allow HHCTRL.OCX to get font information of its own,
      //  which it needs to perform the UNICODE to multibyte conversion. Otherwise, 
      //  HHCTRL must convert using this font without charset information.
      stPopUp.pszFont = NULL;
      if (GetWindowRect((HWND)pH->hItemHandle,&rcW)) 
      {
          stPopUp.pt.x = (rcW.left + rcW.right) / 2;
          stPopUp.pt.y = (rcW.top + rcW.bottom) / 2;
      }
      else stPopUp.pt = pH->MousePos;
      HtmlHelp((HWND) pH->hItemHandle,NULL,HH_DISPLAY_TEXT_POPUP,(DWORD_PTR) &stPopUp);
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OnCommand
//
//  Route WM_COMMAND message to appropriate handlers.
//
//  parameters:
//      wNotifyCode     code describing action that has occured
//      wSenderId       id of the control sending the message, if the message
//                      is from a dialog
//      hwndSender      window handle of the window sending the message if the
//                      message is not from a dialog
//
//  returns:
//      TRUE            if the message was processed completely
//      FALSE           if Windows is to process the message
//
////////////////////////////////////////////////////////////////////////////

BOOL
C_AddKeyDlg::OnCommand(
    WORD                wNotifyCode,
    WORD                wSenderId,
    HWND                hwndSender
    )
{
    BOOL fHandled = FALSE;          // indicate message handled

    switch (wSenderId)
    {
    case IDC_CRED:
        {
            if (wNotifyCode == CRN_PASSWORDCHANGE) 
            {
                g_fPswChanged = TRUE;
            }
        }
        break;
        
    case IDOK:
        if (BN_CLICKED == wNotifyCode)
        {
            OnOK( );
            fHandled = TRUE;
        }
        break;
        
    case IDC_CHGPSW:
        {
            OnChangePassword();
            //EndDialog(IDCANCEL);  do not cancel out of properties dialog
            break;
        }

    case IDCANCEL:
        if (BN_CLICKED == wNotifyCode)
        {
            EndDialog(IDCANCEL);
            fHandled = TRUE;
        }
        break;

    }   //  switch

    return fHandled;

}   //  C_AddKeyDlg::OnCommand

////////////////////////////////////////////////////////////////////////////
//
//  OnOK
//
//  Validate user name, synthesize computer name, and destroy dialog.
//
//  parameters:
//      None.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
void
C_AddKeyDlg::OnOK( )
{
    LONG_PTR j,lCType;
    TCHAR szMsg[MAX_STRING_SIZE + 1];
    TCHAR szTitle[MAX_STRING_SIZE + 1];
    
    TCHAR szUser[FULLNAMEMAXLENGTH + 1];   // in from dialog
    TCHAR szPsw[PWLEN + 1];    // in from dialog
    TCHAR *pszNewTarget;                        // in from dialog
    TCHAR *pszTrimdName;                        // mod'd in from dialog
    DWORD dwFlags = 0;                          // in from dialog
    
    CREDENTIAL stCredential;                    // local copy of cred
    
    UINT  cbPassword;
    BOOL  bResult;
    BOOL  IsCertificate = FALSE;
    BOOL  fDeleteOldCred = FALSE;
    BOOL  fRenameCred = FALSE;
    BOOL  fPsw = FALSE;

    ASSERT(::IsWindow(m_hwnd));
    
    szPsw[0]= 0;
    szUser[0] = 0;

    // Start with a blank cred if this is not an edit, else make a copy of existing one
    if ((m_bEdit) && (g_pExistingCred))
        memcpy((void *) &stCredential,(void *) g_pExistingCred,sizeof(CREDENTIAL));
    else
        memset((void *) &stCredential,0,sizeof(CREDENTIAL));
    
    pszNewTarget = (TCHAR *) malloc((CRED_MAX_GENERIC_TARGET_NAME_LENGTH + 1) * sizeof(TCHAR));
    if (NULL == pszNewTarget) 
    {
        return;
    }
    pszNewTarget[0] = 0;

    // Get Username from the cred control - find out if is a certificate by
    //  IsMarshalledName().
    if (Credential_GetUserName(m_hwndCred,szUser,FULLNAMEMAXLENGTH))
    {
        IsCertificate = CredIsMarshaledCredential(szUser);
    }

    // fetch password/PIN into szPsw.  set fPsw if value is valid
    fPsw = Credential_GetPassword(m_hwndCred,szPsw,CRED_MAX_STRING_LENGTH);

    // Check to see that both name and psw are not missing
    if ( wcslen ( szUser ) == 0 && 
         wcslen ( szPsw )  == 0  ) 
    {
        LoadString ( m_hInst, IDS_ADDFAILED, szMsg, MAX_STRING_SIZE );
        LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
        MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
        free(pszNewTarget);
        return; 
    }
    
    // If the user has typed a \\server style target name, strip the leading hacks
    j = SendMessage(m_hwndTName,WM_GETTEXT,CRED_MAX_GENERIC_TARGET_NAME_LENGTH,(LPARAM)pszNewTarget);
    ASSERT(j);
    pszTrimdName = pszNewTarget;
    while (*pszTrimdName == TCHAR('\\')) pszTrimdName++;

    // Now have:
    //  pszTrimdName
    //  uzUser
    //  szPsw
    //  fPsw
    
    // If target name edited, will need to rename
    // If type changed or psw edited, psw blob will be removed/replaced
    // If type changed, will need to remove old cred
    
    if ((m_bEdit) && (g_pExistingCred)) 
    {

        CHECKPOINT(4,"Keymgr: Edit - OnOK for add/prop dialog");
        if (0 != _tcscmp(pszTrimdName,g_szTargetName)) fRenameCred = TRUE;
        
        // Note that currently DOMAIN_VISIBLE_PASSWORD creds cannot be edited
        //  or created, so there is no handler for those types.
        if (g_pExistingCred->Type == CRED_TYPE_GENERIC) 
        {
            lCType = CRED_TYPE_GENERIC;        
        }
        else  
        {
            if (IsCertificate) lCType = CRED_TYPE_DOMAIN_CERTIFICATE;
            else lCType = CRED_TYPE_DOMAIN_PASSWORD;
        }

        // If the type of the cred changes, you can't save the psw info
        if ((DWORD)lCType != g_pExistingCred->Type) 
        {
            dwFlags &= ~CRED_PRESERVE_CREDENTIAL_BLOB;
            fDeleteOldCred = TRUE;
        }
        else 
        {
            dwFlags |= CRED_PRESERVE_CREDENTIAL_BLOB;
        }

        // You also don't save the psw info if the user changed it explicitly
        if (g_fPswChanged)
        {
            dwFlags &= ~CRED_PRESERVE_CREDENTIAL_BLOB;
        }
#if TESTAUDIT
        if (dwFlags & CRED_PRESERVE_CREDENTIAL_BLOB)
        {
            CHECKPOINT(21,L"Keymgr: Edit - Saving a cred preserving the old psw (rename)");
        }
        else
        {
            CHECKPOINT(20,L"Keymgr: Edit - Saving a cred while not preserving the old password");
        }
#endif
    }
    else 
    {
        // if is a certificate marshalled name is cert or generic
        // if not is generic or domain 
        if (IsCertificate) 
        {
            lCType = CRED_TYPE_DOMAIN_CERTIFICATE;
        }
        else 
        {
            lCType = CRED_TYPE_DOMAIN_PASSWORD;
        }
    }
    
    // Save credential.  If certificate type, do not include a psw blob.
    // After save, if the name had changed, rename the cred

    stCredential.UserName = szUser;
    stCredential.Type = (DWORD) lCType;
    
    // If not an edit, fill in targetname, else do rename later
    if (!m_bEdit) 
    {
        stCredential.TargetName = pszTrimdName;
    }
    stCredential.Persist = g_dwPersist;
    
    // fill credential blob data with nothing if the cred control UI has
    // disabled the password box.  Otherwise supply psw information if
    // the user has edited the box contents.
    if (fPsw) 
    {
        if (g_fPswChanged) 
        {
#ifdef LOUDLY
            OutputDebugString(L"Storing new password data\n");
#endif
            cbPassword = wcslen(szPsw) * sizeof(TCHAR);
            stCredential.CredentialBlob = (unsigned char *)szPsw;
            stCredential.CredentialBlobSize = cbPassword;
        }
#ifdef LOUDLY
        else 
        {
            OutputDebugString(L"No password data stored.\n");
        }
#endif
    }

    bResult = CredWrite(&stCredential,dwFlags);
    SecureZeroMemory(szPsw,sizeof(szPsw));      // delete psw local copy
    
    if ( bResult != TRUE )
    {
#ifdef LOUDLY
    WCHAR szw[200];
    DWORD dwE = GetLastError();
    swprintf(szw,L"CredWrite failed. Last Error is %x\n",dwE);
    OutputDebugString(szw);
#endif
        AdviseUser();
        free(pszNewTarget);
        return;
    }
    
    // Delete old credential only if type has changed
    // Otherwise if name changed, do a rename of the cred
    // If the old cred is deleted, rename is obviated
    if (fDeleteOldCred) 
    {
#ifdef LOUDLY
    OutputDebugString(L"CredDelete called\n");
#endif
        CHECKPOINT(7,"Keymgr: Edit - OnOK - deleting old cred (type changed)");
        CredDelete(g_szTargetName,(ULONG) g_pExistingCred->Type,0);
        g_fReloadList = TRUE;
    } 
    else if (fRenameCred) 
    {
        CHECKPOINT(8,"Keymgr: Edit - OnOK - renaming current cred, same type");
        bResult = CredRename(g_szTargetName, pszTrimdName, (ULONG) stCredential.Type,0);
        g_fReloadList = TRUE;
#ifdef LOUDLY
    OutputDebugString(L"CredRename called\n");
#endif
        if (!bResult) 
        {
            // bugbug: How can rename fail?
            // If it does, what would you tell the user?
            LoadString ( m_hInst, IDS_RENAMEFAILED, szMsg, MAX_STRING_SIZE );
            LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
            MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
            free(pszNewTarget);
            return;
        }
    }
#if TESTAUDIT
    if (stCredential.Type == CRED_TYPE_DOMAIN_PASSWORD) CHECKPOINT(16,"Keymgr: Edit - Saving password cred");
    if (stCredential.Type == CRED_TYPE_DOMAIN_CERTIFICATE) CHECKPOINT(17,"Keymgr: Edit - Saving certificate cred");
#endif
    free(pszNewTarget);
    EndDialog(IDOK);
}   //  C_AddKeyDlg::OnOK

/**********************************************************************



**********************************************************************/

void C_AddKeyDlg::OnChangePassword()
{
   
    CHECKPOINT(10,"Keymgr: Edit - Changing password on the domain for the cred");
    C_ChangePasswordDlg   CPdlg(m_hDlg, g_hInstance, IDD_CHANGEPASSWORD, NULL);
    CPdlg.m_szDomain[0] = 0;
    CPdlg.m_szUsername[0] = 0;
    CPdlg.DoModal((LPARAM)&CPdlg);
}


/**********************************************************************



**********************************************************************/

void C_AddKeyDlg::AdviseUser(void) 
{
    DWORD dwErr;
    TCHAR szMsg[MAX_STRING_SIZE];
    TCHAR szTitle[MAX_STRING_SIZE];
    
    dwErr = GetLastError();
    CHECKPOINT(11,"Keymgr: Edit - Add/Edit failed: Show error message box to user");

    if (dwErr == ERROR_NO_SUCH_LOGON_SESSION) 
    {
       LoadString ( m_hInst, IDS_NOLOGON, szMsg, MAX_STRING_SIZE );
       LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
       MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       // return leaving credential dialog up
       return;
    }
    else if (dwErr == ERROR_BAD_USERNAME) 
    {
       LoadString ( m_hInst, IDS_BADUNAME, szMsg, MAX_STRING_SIZE );
       LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
       MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       // return leaving credential dialog up
       return;
    }
    else if (dwErr == ERROR_INVALID_PASSWORD) 
    {
       LoadString ( m_hInst, IDS_BADPASSWORD, szMsg, MAX_STRING_SIZE );
       LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
       MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       // return leaving credential dialog up
       return;
    }
    else 
    {
        // ERROR_INVALID_PARAMETER, ERROR_INVALID_FLAGS, etc
       LoadString ( m_hInst, IDS_ADDFAILED, szMsg, MAX_STRING_SIZE );
       LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
       MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       // return leaving credential dialog up
       return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\pswutil.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    PSWUTIL.H

Abstract:

    Header file for wrapper to NetUserChangePassword() that expands it to hande
    unc names and MIT Kerberos realms properly.
     
Author:

    georgema        created

Comments:

Environment:
    WinXP

Revision History:

--*/
#ifndef __PSWUTIL_H__
#define __PSWUTIL_H__

BOOL 
IsMITName (
    LPCWSTR UserName
);

NTSTATUS
MitChangePasswordEy(
    LPCWSTR       DomainName,
    LPCWSTR       UserName,
    LPCWSTR       OldPassword,
    LPCWSTR       NewPassword,
    NTSTATUS      *pSubStatus
    );

NET_API_STATUS
NetUserChangePasswordEy (
    LPCWSTR domainname,
    LPCWSTR username,
    LPCWSTR oldpassword,
    LPCWSTR newpassword
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\maindlg.cpp ===
/*++

Copyright (c) 2000,2001  Microsoft Corporation

Module Name:

    MAINDLG.CPP

Abstract:

    Implementation of the mail keymgr dialog which displays existing 
    credentials and offers the ability to create, edit, or delete them.
  
Author:

Environment:
    WinXP

--*/

// test/dev switch variables

//////////////////////////////////////////////////////////////////////////////
//
//  Include files
//
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbase.h>
#include <shellapi.h>
#include<shlwapi.h>
#include <wininet.h> 
#include <tchar.h>
#include <wincrui.h>
#include <wincred.h>
#include <scuisupp.h>
#include <htmlhelp.h>
#include <credp.h>
#include <comctrlp.h>
#include <shfusion.h>
#include "switches.h"
#include "Dlg.h"
#include "Res.h"
#include "KRDlg.h"
#include "keymgr.h"
#include "testaudit.h"

//===================================

// special type value used to obviate string comparison to detect special nature
//  of the *Session credential.  Value arbitrary.
#define SESSION_FLAG_VALUE (0x2222)  

// tooltips support
#define TIPSTRINGLEN 500

TCHAR szTipString[TIPSTRINGLEN];
WNDPROC lpfnOldWindowProc = NULL;   // used to subclass the list box
LRESULT CALLBACK ListBoxSubClassFunction(HWND,WORD,WPARAM,LPARAM);

// global state vars - comm between prop dlg and list dlg
LONG_PTR    g_CurrentKey = 0;       // currently selected item in the main dlg
BOOL        g_HaveShownRASCred = FALSE; // TRUE the first time one is shown
BOOL        g_fReloadList = TRUE;   // reload list if something changed
DWORD_PTR      g_dwHCookie = 0;        // HTML HELP system cookie
HWND        g_hMainDlg = NULL;      // used to give add/new access to target list
C_AddKeyDlg *g_AKdlg = NULL;        // used for notifications


/**********************************************************************

gTestReadCredential()

Arguments:  None
Returns:        BOOL, TRUE if the selected credential could be successfully read.

Comments:   

Read the credential currently selected in the list box from the 
keyring.  

sets g_szTargetName
sets g_pExisitingCred

**********************************************************************/
BOOL gTestReadCredential(void) 
{
    TCHAR       *pC;
    BOOL        f;
    LRESULT     lR;
    LRESULT     lRet = 0;
    DWORD       dwType;
    
    g_pExistingCred = NULL;
    
    // Fetch current credential from list into g_szTargetName
    lR = SendDlgItemMessage(g_hMainDlg,IDC_KEYLIST,LB_GETCURSEL,0,0L);
    
    if (lR == LB_ERR) 
    {
        return FALSE;
    }
    else 
    {
        g_CurrentKey = lR;
        lRet = SendDlgItemMessage(g_hMainDlg,IDC_KEYLIST,LB_GETTEXT,lR,(LPARAM) g_szTargetName);
    }

    // Possible error - zero chars returned from list box
    if (lRet == 0) 
    {
        ASSERT(0);
        return FALSE;       // zero characters returned
    }

    // Get the target type from the combo box item data
    dwType = (DWORD) SendDlgItemMessage(g_hMainDlg,IDC_KEYLIST,LB_GETITEMDATA,lR,0);
    if (LB_ERR == dwType) 
    {
        return FALSE;
    }

    // null term the targetname shown in the UI, 
    //  trimming the suffix if there is one
    pC = _tcschr(g_szTargetName,g_rgcCert[0]);
    if (pC) 
    {
        pC--;
        *pC = 0x0;               // null terminate namestring
    }

    // Attempt to read the credential from the store
    // The returned credential will have to be freed if leaving this block
    f = (CredRead(g_szTargetName,
             (ULONG) dwType,
             0,
             &g_pExistingCred));
    if (!f) 
    {
        return FALSE;           // g_pExistingCred is empty
    }
        
    return TRUE;                // g_pExistingCred has been filled
}

/**********************************************************************

MapID()

Arguments:  UINT dialog control ID
Returns:        UINT string resource number

Comments:   Convert a dialog control identifier to a string identifier.

**********************************************************************/

UINT C_KeyringDlg::MapID(UINT uiID) 
{
    switch(uiID) {
        case IDC_KEYLIST:
          return IDH_KEYLIST;
        case IDC_NEWKEY:
          return IDH_NEW;
        case IDC_DELETEKEY:
          return IDH_DELETE;
        case IDC_CHANGE_PASSWORD:
          return IDH_CHANGEPASSWORD;
        case IDC_EDITKEY:
          return IDH_EDIT;
        case IDOK:
        case IDCANCEL:
            return IDH_CLOSE;
        
        default:
          return IDS_NOHELP;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  C_KeyringDlg
//
//  Constructor.
//
//  parameters:
//      hwndParent      parent window for the dialog (may be NULL)
//      hInstance       instance handle of the parent window (may be NULL)
//      lIDD            dialog template id
//      pfnDlgProc      pointer to the function that will process messages for
//                      the dialog.  if it is NULL, the default dialog proc
//                      will be used.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
C_KeyringDlg::C_KeyringDlg(
    HWND                hwndParent,
    HINSTANCE           hInstance,
    LONG                lIDD,
    DLGPROC             pfnDlgProc  //   = NULL
    )
:   C_Dlg(hwndParent, hInstance, lIDD, pfnDlgProc)
{
   m_hInst = hInstance;             // our instance handle
   m_cCredCount = 0;
   g_AKdlg = NULL;                  // addkey dialog not up
   fInit = FALSE;                   // initial screen draw undone
}  //  C_KeyringDlg::C_KeyringDlg

/**********************************************************************

Initialize the keyring UI credential list.  Read the credentials currently
on the user's keyring and show the targetnames in the list.  Called on 
initial show of the dialog, and again after handling add or delete.

Sets the numeric tag for each list entry to equal the credential type.

*Session creds are detected here and special handled.
Certificate and Passport creds are detected here an a suffix applied to 
 their name.

**********************************************************************/
void C_KeyringDlg::BuildList()
{
    DWORD dwCredCount = 0;
    CREDENTIAL **pCredentialPtrArray = NULL;
    BOOL bResult = 0;
    DWORD i,dwCredType;
    PCREDENTIAL pThisCred = NULL;
    TCHAR *pTargetName = NULL;
    LRESULT idx = 0;
    TCHAR szMsg[64];
#if TESTAUDIT
    BOOL f34 = FALSE;
#endif

    
    g_HaveShownRASCred = FALSE;
    // clear the listbox
    ::SendDlgItemMessage(m_hDlg,IDC_KEYLIST,LB_RESETCONTENT,NULL,0);
    bResult = CredEnumerate(NULL,0,&dwCredCount,&pCredentialPtrArray);

    if ((m_cCredCount != dwCredCount) || (g_fReloadList))
    {
        if (bResult)
        {
            for (i=0 ; i < dwCredCount ; i++) 
            {
#ifdef LOUDLY
                if (!bResult) OutputDebugString(L"Keymgr: Adding a cred to the window\n");
#endif
                pThisCred = pCredentialPtrArray[i];
                pTargetName = pThisCred->TargetName;

                // handle CRED_SESSION_WILDCARD_NAME_W by replacing the string
                if (0 == _tcsicmp(pTargetName,CRED_SESSION_WILDCARD_NAME)) {
                    if (g_HaveShownRASCred)
                    {
                        CHECKPOINT(41,L"Multiple *Session creds");
                        continue;
                    }
                    CHECKPOINT(32,L"Keymgr: *Session cred in cred list");
                    LoadString ( m_hInst, IDS_SESSIONCRED, szMsg, 64 );
                    pTargetName = szMsg;
                    dwCredType = SESSION_FLAG_VALUE;
                    g_HaveShownRASCred = TRUE;
                }
                else 
                {
                    dwCredType = pThisCred->Type;
                }
                
                // name suffixes are localizable
                // we use g_szTargetName for this in order to avoid another
                //  memory allocation, as this buffer is not yet in use.
                switch (dwCredType) 
                {
                
                    case CRED_TYPE_GENERIC:
                        continue;
                        break;

                    // this particular type is not visible in keymgr
                    case CRED_TYPE_DOMAIN_VISIBLE_PASSWORD:
                    {
#ifndef SHOWPASSPORT
                        continue;
#endif
#ifdef SHOWPASSPORT
                        CHECKPOINT(33,L"Keymgr: Passport cred in cred list");
                        // SHOWPASSPORT is currently turned on
                        _tcsncpy(g_szTargetName,pTargetName,CRED_MAX_DOMAIN_TARGET_NAME_LENGTH);
                        g_szTargetName[CRED_MAX_DOMAIN_TARGET_NAME_LENGTH] = 0;
                        _tcsncat(g_szTargetName,_T(" "),2);
                        _tcsncat(g_szTargetName,g_rgcPassport,MAXSUFFIXSIZE);
                        g_szTargetName[TARGETNAMEMAXLENGTH] = 0;
                        break;
#endif
                    }   
                    case CRED_TYPE_DOMAIN_PASSWORD:
                    case SESSION_FLAG_VALUE:
                        // find RAS credential
#if TESTAUDIT
                        // This checkpoint would be very noisy a lot of the time.
                        // Use f34 to get it to show just once.
                        if (!f34)
                        {
                            CHECKPOINT(34,"Keymgr: Password cred in cred list");
                            f34 = TRUE;
                        }
#endif
                        _tcsncpy(g_szTargetName,pTargetName,CRED_MAX_DOMAIN_TARGET_NAME_LENGTH);
                        g_szTargetName[CRED_MAX_DOMAIN_TARGET_NAME_LENGTH] = 0;
                        break;
                        
                    case CRED_TYPE_DOMAIN_CERTIFICATE:
                        CHECKPOINT(35,"Keymgr: Certificate cred in cred list");
                        _tcsncpy(g_szTargetName,pTargetName,CRED_MAX_DOMAIN_TARGET_NAME_LENGTH);
                        g_szTargetName[CRED_MAX_DOMAIN_TARGET_NAME_LENGTH] = 0;
                        _tcsncat(g_szTargetName,_T(" "),2);
                        _tcsncat(g_szTargetName,g_rgcCert,MAXSUFFIXSIZE);
                        g_szTargetName[TARGETNAMEMAXLENGTH] = 0;
                        break;
                        
                    default:
                        break;
                }
                idx = ::SendDlgItemMessage(m_hDlg,IDC_KEYLIST,LB_ADDSTRING,NULL,(LPARAM) g_szTargetName);
                if (idx != LB_ERR) 
                {
                    idx = ::SendDlgItemMessage(m_hDlg,IDC_KEYLIST,LB_SETITEMDATA,(WPARAM)idx,dwCredType);
                }
            }
            if (pCredentialPtrArray) CredFree(pCredentialPtrArray);
        }
        else
        {
            g_CurrentKey = 0;
        }
        
        // Show one as active.
        SetCurrentKey(g_CurrentKey);
        g_fReloadList = FALSE;
    }

}

/**********************************************************************

Set an appropriate state for the buttons on the UI, given the SKU of
the platform, and the population of the keyring.  If creds exist on the
keyring, set the cursor on the key list to the first item.  Thereafter,
this function permist the last cursor to be reloaded after doing
something to the list.  The cursor is reset after an add operation,
because the behavior of the cursor is difficult to do properly under
that circumstance, as you don't know where the item will be inserted in
the list.

On personal, do not show the ADD button, and change the page text.
If no creds, disable the DELETE and PROPERTIES buttons

**********************************************************************/

void C_KeyringDlg::SetCurrentKey(LONG_PTR iKey) 
{

    LONG_PTR iKeys;
    HWND hH;
    LRESULT idx;
    BOOL fDisabled = FALSE;

    // If there are items in the list, select the first one and set focus to the list
    iKeys = ::SendDlgItemMessage ( m_hDlg, IDC_KEYLIST, LB_GETCOUNT, (WPARAM) 0, 0L );
    fDisabled = (GetPersistenceOptions(CRED_TYPE_DOMAIN_PASSWORD) == CRED_PERSIST_NONE);
#if TESTAUDIT
    if (iKeys > 100) CHECKPOINT(30,L"Keymgr: Large number of credentials > 100");
    if (iKeys == 0) CHECKPOINT(31,L"Keymgr: No saved credentials - list empty");
#endif
    // If there are no creds and credman is disabled, the dialog should not be displayed
    // If there are creds, and credman is disabled, show the dialog without the ADD button
    if (fDisabled && !fInit)
    {
        // (Disable with HKLM\System\CurrentControlSet\Control\Lsa\DisableDomainCreds = 1)
        CHECKPOINT(36,L"Keymgr: Personal SKU or credman disabled");
        
        // Make the intro text better descriptive of this condition
        WCHAR szMsg[MAX_STRING_SIZE+1];
        
        LoadString ( m_hInst, IDS_INTROTEXT, szMsg, MAX_STRING_SIZE );
        hH = GetDlgItem(m_hDlg,IDC_INTROTEXT);
        if (hH) SetWindowText(hH,szMsg);
        
        // remove the add button
        hH = GetDlgItem(m_hDlg,IDC_NEWKEY);
        if (hH)
        {
            EnableWindow(hH,FALSE);
            ShowWindow(hH,SW_HIDE);
        }
        // move remaining buttons upfield 22 units
        hH = GetDlgItem(m_hDlg,IDC_DELETEKEY);
        if (hH)
        {
            HWND hw1;
            HWND hw2;
            RECT rw1;
            RECT rw2;
            INT xsize;
            INT ysize;
            INT delta;
            BOOL bOK = FALSE;

            hw1 = hH;
            hw2 = GetDlgItem(m_hDlg,IDC_EDITKEY);
            if (hw1 && hw2)
            {
                 if (GetWindowRect(hw1,&rw1) &&
                      GetWindowRect(hw2,&rw2))
                {
                    MapWindowPoints(NULL,m_hDlg,(LPPOINT)(&rw1),2);
                    MapWindowPoints(NULL,m_hDlg,(LPPOINT)(&rw2),2);
                    delta = rw2.top - rw1.top;
                    xsize = rw2.right - rw2.left;
                    ysize = rw2.bottom - rw2.top;
                    bOK = MoveWindow(hw1,rw1.left,rw1.top - delta,xsize,ysize,TRUE);
                    if (bOK) 
                    {
                         bOK = MoveWindow(hw2,rw2.left,rw2.top - delta,xsize,ysize,TRUE);
                    }
                }
            }
        }

        // prevent moving the buttons twice
        fInit = TRUE;
    }

    // Set the default button to either properties or add
    if ( iKeys > 0 )
    {
        hH = GetDlgItem(m_hDlg,IDC_KEYLIST);
        SetFocus(hH);
        // if asking for key beyond end of list, mark the last one
        if (iKey >= iKeys) iKey = iKeys - 1;
        idx = SendDlgItemMessage ( m_hDlg, IDC_KEYLIST, LB_SETCURSEL, iKey, 0L );

        hH = GetDlgItem(m_hDlg,IDC_EDITKEY);
        if (hH) EnableWindow(hH,TRUE);
        hH = GetDlgItem(m_hDlg,IDC_DELETEKEY);
        if (hH) EnableWindow(hH,TRUE);
    }
    else
    {
        if (!fDisabled)
        {
            // no items in the list, set focus to the New button
            hH = GetDlgItem(m_hDlg,IDC_NEWKEY);
            SetFocus(hH);
        }

        hH = GetDlgItem(m_hDlg,IDC_EDITKEY);
        if (hH) EnableWindow(hH,FALSE);
        hH = GetDlgItem(m_hDlg,IDC_DELETEKEY);
        if (hH) EnableWindow(hH,FALSE);
    }
}

// Remove the currently highlighted key from the listbox

/**********************************************************************

DeleteKey()

Arguments:  None
Returns:        None

Comments:   Deletes the credential currently selected in the list box.  


**********************************************************************/

void C_KeyringDlg::DeleteKey()
{
    TCHAR szMsg[MAX_STRING_SIZE + MAXSUFFIXSIZE] = {0};
    TCHAR szTitle[MAX_STRING_SIZE] = {0};;
    TCHAR *pC;                      // point this to the raw name 
    LONG_PTR lR = LB_ERR;
    LONG_PTR lSel = LB_ERR;
    BOOL bResult = FALSE;
    DWORD dwCredType = 0;

    CHECKPOINT(37,L"Keymgr: Delete a credential");
    LoadString ( m_hInst, IDS_DELETEWARNING, szMsg, MAX_STRING_SIZE );
    LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );

    // ask for confirm to delete
    lR = MessageBox ( m_hDlg,  szMsg, szTitle, MB_OKCANCEL );
    if (IDOK != lR) 
    {
        return;
    }
    
    // Get the credential type information from the item data
    lSel = SendDlgItemMessage(g_hMainDlg,IDC_KEYLIST,LB_GETCURSEL,0,0L);
    if (lSel == LB_ERR) 
    {
        ASSERT(0);
        goto faildelete;
    }
    
    g_CurrentKey = lSel;
    lR = SendDlgItemMessage(g_hMainDlg,IDC_KEYLIST,LB_GETTEXT,lSel,(LPARAM) g_szTargetName);
    if (lR == LB_ERR)
    {
        ASSERT(0);
        goto faildelete;
    }
    
    dwCredType = (DWORD) SendDlgItemMessage(g_hMainDlg,IDC_KEYLIST,LB_GETITEMDATA,lSel,0);
    if (LB_ERR == dwCredType) 
    {
        ASSERT(0);
        goto faildelete;
    }

    // Special case RAS creds, because there can be more than one.  We only show a single entry,
    //  and deleting it automatically seeks and deletes the other if it is present.  For this reason, the
    //  type information associated with this cred is a special value, and not use in the delete.
    if (dwCredType == SESSION_FLAG_VALUE) 
    {
        CHECKPOINT(42,L"Delete session cred");
        // convert the name from user friendly to the internal representation
        _tcsncpy(g_szTargetName,CRED_SESSION_WILDCARD_NAME,TARGETNAMEMAXLENGTH);
        g_szTargetName[TARGETNAMEMAXLENGTH - 1] = 0;

        // bResult will be success if either deleted successfully
        bResult = CredDelete(g_szTargetName,CRED_TYPE_DOMAIN_PASSWORD,0);
        if (!bResult)
        {
            bResult = CredDelete(g_szTargetName,CRED_TYPE_DOMAIN_CERTIFICATE,0);
        }
        else
        {
            CredDelete(g_szTargetName,CRED_TYPE_DOMAIN_CERTIFICATE,0);
        }
    }
    else
    {
        // null term the targetname shown in the UI, 
        //  trimming the suffix if there is one
        pC = _tcschr(g_szTargetName,g_rgcCert[0]);
        if (pC) 
        {
            pC--;
            *pC = 0x0;               // null terminate namestring
        }
        // Delete the single credential on the cursor
        bResult = CredDelete(g_szTargetName,dwCredType,0);
    }

    faildelete:
    if (bResult != TRUE) 
    {
       LoadString ( m_hInst, IDS_DELETEFAILED, szMsg, MAX_STRING_SIZE );
       LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
       MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK);
    }
    else
    {
        // successful delete - resort and re-present the list
        g_fReloadList = TRUE;
    }
}

/**********************************************************************

OnAppMessage()

Arguments:  None
Returns:        BOOL always TRUE

Comments:   Empty handler for method of class.

**********************************************************************/


BOOL
C_KeyringDlg::OnAppMessage(
        UINT                uMessage,
        WPARAM              wparam,
        LPARAM              lparam
        )
{
    return TRUE;
}   //  OnAppMessage


//////////////////////////////////////////////////////////////////////////////
//
//  OnInitDialog
//
//  Dialog control and data initialization.
//
//  parameters:
//      hwndDlg         window handle of the dialog box
//      hwndFocus       window handle of the control that will receive focus
//
//  returns:
//      TRUE            if the system should set the default keyboard focus
//      FALSE           if the keyboard focus is set by this app
//
//////////////////////////////////////////////////////////////////////////////
BOOL
C_KeyringDlg::OnInitDialog(
    HWND                hwndDlg,
    HWND                hwndFocus
    )
{
    // these really should all be in the keyringdlg class
    DWORD i;
    LRESULT lr;

    HtmlHelp(NULL,NULL,HH_INITIALIZE,(DWORD_PTR) &g_dwHCookie);

    // Allow other dialog to query the contents of the listbox
    g_hMainDlg = hwndDlg;
    m_hDlg = hwndDlg;
    g_CurrentKey = 0;
    g_fReloadList = TRUE;
    g_szTargetName = (TCHAR *) malloc((TARGETNAMEMAXLENGTH + 1) * sizeof(TCHAR));
    ASSERT(g_szTargetName);
    if (NULL == g_szTargetName) 
    {
        return FALSE;
    }
    
    // Fetch Icons from the image and assoc them with this dialog
    HICON hI = LoadIcon(m_hInst,MAKEINTRESOURCE(IDI_SMALL));
    lr = SendMessage(hwndDlg,WM_SETICON,(WPARAM) ICON_SMALL,(LPARAM)hI);

    C_Dlg::OnInitDialog(hwndDlg, hwndFocus);

    // Even if mirrored language is default, set list box style to LTR
    // (NOT CURRENTLY TURNED ON)
#ifdef FORCELISTLTR
    {
        LONG_PTR lExStyles;
        HWND hwList;
        hwList = GetDlgItem(hwndDlg,IDC_KEYLIST);
        if (hwList) 
        {
            lExStyles = GetWindowLongPtr(hwList,GWL_EXSTYLE);
            lExStyles &= ~WS_EX_RTLREADING;
            SetWindowLongPtr(hwList,GWL_EXSTYLE,lExStyles);
            InvalidateRect(hwList,NULL,TRUE);
        }
    }
#endif
    // read in the suffix strings for certificate types
    // locate first differing character
    //
    // This code assumes that the strings all have a common preamble, 
    //  and that all are different in the first character position
    //  past the preamble.  Localized strings should be selected which
    //  have this property, like (Generic) and (Certificate).
    i = LoadString(g_hInstance,IDS_CERTSUFFIX,g_rgcCert,MAXSUFFIXSIZE);
    ASSERT(i !=0);
    i = LoadString(g_hInstance,IDS_PASSPORTSUFFIX,g_rgcPassport,MAXSUFFIXSIZE);

    // Read currently saved creds and display names in list box
    BuildList();
    SetCurrentKey(g_CurrentKey);
    InitTooltips();
    return TRUE;
}   //  C_KeyringDlg::OnInitDialog

/**********************************************************************

OnDestroyDialog

Arguments:  None
Returns:        BOOL, always TRUE

Comments:    Performs cleanup needed as dialog is destroyed.  In this case, its only
                    action is to release the HTML Help resources.

**********************************************************************/

BOOL
C_KeyringDlg::OnDestroyDialog(
    void    )
{
    free(g_szTargetName);
    HtmlHelp(NULL,NULL,HH_UNINITIALIZE,(DWORD_PTR)g_dwHCookie);
    return TRUE;
}

/**********************************************************************

DoEdit()

Arguments:  None
Returns:        BOOL always TRUE

Comments:   Filters some special creds on the basis of their special nature.  For the
                    editable ones, kicks off the edit dialog to edit the credential held at 
                    g_pExistingCred.

**********************************************************************/

BOOL C_KeyringDlg::DoEdit(void) 
{
   LRESULT lR;
   
   
   lR = SendDlgItemMessage(m_hDlg,IDC_KEYLIST,LB_GETCURSEL,0,0L);
   if (LB_ERR == lR) 
   {
        // On error, no dialog shown, edit command handled
        return TRUE;
   }
   else 
   {
       // something selected
       g_CurrentKey = lR;

       // If a RAS cred, show it specially, indicate no edit allowed
       lR = SendDlgItemMessage(m_hDlg,IDC_KEYLIST,LB_GETITEMDATA,lR,0);
       if (lR == SESSION_FLAG_VALUE)  
       {
            CHECKPOINT(38,L"Keymgr: Attempt edit a RAS cred");
            // load string and display message box
            TCHAR szMsg[MAX_STRING_SIZE];
            TCHAR szTitle[MAX_STRING_SIZE];
            LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
            LoadString ( m_hInst, IDS_CANNOTEDIT, szMsg, MAX_STRING_SIZE );
            MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
            return TRUE;
       }
#ifdef SHOWPASSPORT
#ifdef NEWPASSPORT
       // if a passport cred, show it specially, indicate no edit allowed
       if (lR == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD) 
       {
            CHECKPOINT(39,L"Keymgr: Attempt edit a passport cred");
            // load string and display message box
            TCHAR szMsg[MAX_STRING_SIZE];
            TCHAR szTitle[MAX_STRING_SIZE];
            LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
            LoadString ( m_hInst, IDS_PASSPORT2, szMsg, MAX_STRING_SIZE );
            INT iResponse = MessageBox ( m_hDlg,  szMsg, szTitle, MB_YESNO );
            if (IDYES == iResponse) 
            {
                CHECKPOINT(40,L"Keymgr: Launch passport website for Passport cred edit");
                HKEY hKey = NULL;
                DWORD dwType;
                //BYTE rgb[500];
                BYTE *rgb=(BYTE *) malloc(INTERNET_MAX_URL_LENGTH * sizeof(WCHAR));
                if (rgb)
                {
                    DWORD cbData = INTERNET_MAX_URL_LENGTH * sizeof(WCHAR);
                    BOOL Flag = TRUE;
                    // launch the passport web site
    #ifndef PASSPORTURLINREGISTRY
                    ShellExecute(m_hDlg,L"open",L"http://www.passport.com",NULL,NULL,SW_SHOWNORMAL);
    #else 
                    // read registry key to get target string for ShellExec
                    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                            L"Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                                            0,
                                            KEY_QUERY_VALUE,
                                            &hKey))
                    {
                        if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                       L"Properties",
                                       NULL,
                                       &dwType,
                                       rgb,
                                       &cbData))
                        {
                            // test the URL for reasonableness before launching
                            WCHAR *szUrl = (WCHAR *)malloc(INTERNET_MAX_URL_LENGTH);
                            if (szUrl)
                            {
                                DWORD ccUrlBuffer = INTERNET_MAX_URL_LENGTH;
                                if (S_OK == UrlCanonicalize((LPCTSTR)rgb, szUrl,&ccUrlBuffer,
                                                            URL_ESCAPE_UNSAFE | URL_ESCAPE_PERCENT))
                                {
                                    if (UrlIs(szUrl,URLIS_URL))
                                    {
                                        WCHAR szScheme[20];
                                        DWORD ccScheme = 20;
                                        if (SUCCEEDED(UrlGetPart(szUrl,szScheme,&ccScheme,URL_PART_SCHEME,0)))
                                        {
                                            // at the least, verify that the target is https schemed
                                            if (0 == _wcsicmp(szScheme,L"https"))
                                            {
                                                ShellExecute(m_hDlg,L"open",(LPCTSTR)rgb,NULL,NULL,SW_SHOWNORMAL);
                                                Flag = FALSE;
                                            }
                                        }
                                    }
                                }
                                free(szUrl);
                            }
                        }
                    }
    #ifdef LOUDLY
                    else 
                    {
                        OutputDebugString(L"DoEdit: reg key HKCU... open failed\n");
                    }
    #endif
                    if (Flag)
                    {
                        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                                L"Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                                                0,
                                                KEY_QUERY_VALUE,
                                                &hKey))
                        {
                            if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                           L"Properties",
                                           NULL,
                                           &dwType,
                                           rgb,
                                           &cbData))
                            {
                                // test the URL for reasonableness before launching
                                WCHAR *szUrl = (WCHAR *) malloc(INTERNET_MAX_URL_LENGTH);
                                if (szUrl)
                                {
                                    DWORD ccUrlBuffer = INTERNET_MAX_URL_LENGTH;
                                    if (S_OK == UrlCanonicalize((LPCTSTR)rgb, szUrl,&ccUrlBuffer,0))
                                    {
                                        if (UrlIs(szUrl,URLIS_URL))
                                        {
                                            WCHAR szScheme[20];
                                            DWORD ccScheme = 20;
                                            if (SUCCEEDED(UrlGetPart(szUrl,szScheme,&ccScheme,URL_PART_SCHEME,0)))
                                            {
                                                if (0 == _wcsicmp(szScheme,L"https"))
                                                {
                                                    // at the least, verify that the target is https scheme
                                                    ShellExecute(m_hDlg,L"open",(LPCTSTR)rgb,NULL,NULL,SW_SHOWNORMAL);
                                                    Flag = FALSE;
                                                }
                                            }
                                        }
                                    }
                                    free(szUrl);
                                }
                            }
                        }
    #ifdef LOUDLY
                        else 
                        {
                            OutputDebugString(L"DoEdit: reg key HKLM... open failed\n");
                        }
    #endif
                    }
                    if (Flag)
                    {
                        LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
                        LoadString ( m_hInst, IDS_PASSPORTNOURL, szMsg, MAX_STRING_SIZE );
                        MessageBox ( m_hDlg,  szMsg, szTitle, MB_ICONHAND );
    #ifdef LOUDLY
                        OutputDebugString(L"DoEdit: Passport URL missing\n");
    #endif
                    }
    #endif
                    free(rgb);
                }
                else
                {
                    // out of memory - nothing we can do
                    return TRUE;
                }
            }
            return TRUE;
       }
#else
       // if a passport cred, show it specially, indicate no edit allowed
       if (lR == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD) 
       {
            // load string and display message box
            TCHAR szMsg[MAX_STRING_SIZE];
            TCHAR szTitle[MAX_STRING_SIZE];
            LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
            LoadString ( m_hInst, IDS_PASSPORT, szMsg, MAX_STRING_SIZE );
            MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
            return TRUE;
       }
#endif
#endif
   }

   // cred is selected, not special type.  Attempt to read it
   
   if (FALSE == gTestReadCredential()) 
   {
       return TRUE;
   }
   g_AKdlg = new C_AddKeyDlg(g_hMainDlg,g_hInstance,IDD_ADDCRED,NULL);
   if (NULL == g_AKdlg) 
   {
        // failed to instantiate add/new dialog
       if (g_pExistingCred) CredFree(g_pExistingCred);
       g_pExistingCred = NULL;
        return TRUE;

   }
   else 
   {
       // read OK, dialog OK, proceed with edit dlg
       g_AKdlg->m_bEdit = TRUE;   
       g_AKdlg->DoModal((LPARAM)g_AKdlg);
       // a credential name may have changed, so reload the list
       delete g_AKdlg;
       g_AKdlg = NULL;
       if (g_pExistingCred) 
       {
           CredFree(g_pExistingCred);
       }
       g_pExistingCred = NULL;
   }
   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OnCommand
//
//  Route WM_COMMAND message to appropriate handlers.
//
//  parameters:
//      wNotifyCode     code describing action that has occured
//      wSenderId       id of the control sending the message, if the message
//                      is from a dialog
//      hwndSender      window handle of the window sending the message if the
//                      message is not from a dialog
//
//  returns:
//      TRUE            if the message was processed completely
//      FALSE           if Windows is to process the message
//
//////////////////////////////////////////////////////////////////////////////

BOOL
C_KeyringDlg::OnHelpInfo(LPARAM lp) 
{

    HELPINFO* pH;
    INT iMapped;
    pH = (HELPINFO *) lp;
    HH_POPUP stPopUp;
    RECT rcW;
    UINT gID;

    CHECKPOINT(15,"Keymgr: Main dialog OnHelpInfo");
    gID = pH->iCtrlId;
    iMapped = MapID(gID);
    
    if (iMapped == 0) 
    {
        return TRUE;
    }
    
    if (IDS_NOHELP != iMapped) 
    {

      memset(&stPopUp,0,sizeof(stPopUp));
      stPopUp.cbStruct = sizeof(HH_POPUP);
      stPopUp.hinst = g_hInstance;
      stPopUp.idString = iMapped;
      stPopUp.pszText = NULL;
      stPopUp.clrForeground = -1;
      stPopUp.clrBackground = -1;
      stPopUp.rcMargins.top = -1;
      stPopUp.rcMargins.bottom = -1;
      stPopUp.rcMargins.left = -1;
      stPopUp.rcMargins.right = -1;
      // bug 393244 - leave NULL to allow HHCTRL.OCX to get font information of its own,
      //  which it needs to perform the UNICODE to multibyte conversion. Otherwise, 
      //  HHCTRL must convert using this font without charset information.
      stPopUp.pszFont = NULL;
      if (GetWindowRect((HWND)pH->hItemHandle,&rcW)) 
      {
          stPopUp.pt.x = (rcW.left + rcW.right) / 2;
          stPopUp.pt.y = (rcW.top + rcW.bottom) / 2;
      }
      else stPopUp.pt = pH->MousePos;
      HtmlHelp((HWND) pH->hItemHandle,NULL,HH_DISPLAY_TEXT_POPUP,(DWORD_PTR) &stPopUp);
    }
    return TRUE;
}

// code for handling linkage to a .chm file is disabled

#if 1
BOOL 
C_KeyringDlg::OnHelpButton(void) 
{
    return FALSE;
}
#else
BOOL
C_KeyringDlg::OnHelpButton(void) 
{
    TCHAR rgc[MAX_PATH + 1];
    TCHAR rgcHelpFile[]=TEXT("\\keyhelp.chm");
    INT ccHelp = _tcslen(rgcHelpFile);
    
    GetSystemDirectory(rgc,MAX_PATH);
    if (_tcslen(rgc) + ccHelp > MAX_PATH)
    {
        return FALSE;
    }
    _tcsncat(rgc, rgcHelpFile, ccHelp + 1);
    rgc[MAX_PATH - 1] = 0;

    HWND hwnd = (m_hwnd,rgc,HH_DISPLAY_TOC,NULL);
    if (NULL != hwnd) return TRUE;
    return FALSE;
}
#endif

/**********************************************************************


OnCommand()

Arguments:  None
Returns:        BOOL always TRUE

Comments:   Dispatcher for button presses and help requests.

**********************************************************************/

BOOL
C_KeyringDlg::OnCommand(
    WORD                wNotifyCode,
    WORD                wSenderId,
    HWND                hwndSender
    )
{

    // Was the message handled?
    //
    BOOL fHandled = FALSE;

    switch (wSenderId)
    {
    case IDC_HELPKEY:
        OnHelpButton();
        break;
        
    case IDC_KEYLIST:
        if (LBN_SELCHANGE == wNotifyCode)
            break;

        if (LBN_DBLCLK == wNotifyCode) 
        {
            fHandled = DoEdit();
            BuildList();                // targetname could have changed
            SetCurrentKey(g_CurrentKey);
            break;
        }
    case IDCANCEL:
    case IDOK:
        if (BN_CLICKED == wNotifyCode)
        {
            
            OnOK( );
            fHandled = TRUE;
        }
        break;
        
   case IDC_EDITKEY:
        {
            fHandled = DoEdit();
            BuildList();                // targetname could have changed
            SetCurrentKey(g_CurrentKey);
            break;
        }

   // NEW and DELETE can alter the count of creds, and the button population
    
   case IDC_NEWKEY:
       {
           g_pExistingCred = NULL;
           g_AKdlg = new C_AddKeyDlg(g_hMainDlg,g_hInstance,IDD_ADDCRED,NULL);
           if (NULL == g_AKdlg) 
           {
                fHandled = TRUE;
                break;
           }
           else 
           {
               g_AKdlg->m_bEdit = FALSE;   
               g_AKdlg->DoModal((LPARAM)g_AKdlg);
               // a credential name may have changed
               delete g_AKdlg;
               g_AKdlg = NULL;
               BuildList();
               SetCurrentKey(g_CurrentKey);
           }
           break;
       }
       break;
       
   case IDC_DELETEKEY:
       DeleteKey();             // frees g_pExistingCred as a side effect
       // refresh list display
       BuildList();
       SetCurrentKey(g_CurrentKey);
       break;

    }   //  switch

    return fHandled;

}   //  C_KeyringDlg::OnCommand



//////////////////////////////////////////////////////////////////////////////
//
//  OnOK
//
//  Validate user name, synthesize computer name, and destroy dialog.
//
//  parameters:
//      None.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
void
C_KeyringDlg::OnOK( )
{
    ASSERT(::IsWindow(m_hwnd));
    EndDialog(IDOK);
}   //  C_KeyringDlg::OnOK

//////////////////////////////////////////////////////////////////////////////
//
// ToolTip Support
//
//
//////////////////////////////////////////////////////////////////////////////

/**********************************************************************
InitToolTips()

Derive a bounding rectangle for the nth element of a list box, 0 based.
Refuse to generate rectangles for nonexistent elements.  Return TRUE if a
 rectangle was generated, otherwise FALSE.

**********************************************************************/
BOOL
C_KeyringDlg::InitTooltips(void) 
{
    TOOLINFO ti;
    memset(&ti,0,sizeof(TOOLINFO));
    ti.cbSize = sizeof(TOOLINFO);
    INT n = 0;
    RECT rLB;   // list box bounding rect for client portion
    
    HWND hLB = GetDlgItem(m_hDlg,IDC_KEYLIST);
    if (NULL == hLB) 
    {
        return FALSE;
    }

    // Create the tooltip window that will be activated and shown when
    //  a tooltip is displayed
    HWND hwndTip = CreateWindowEx(NULL,TOOLTIPS_CLASS,NULL,
                     WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
                     CW_USEDEFAULT,CW_USEDEFAULT,
                     CW_USEDEFAULT,CW_USEDEFAULT,
                     m_hDlg,NULL,m_hInstance,
                     NULL);
    if (NULL == hwndTip) 
    {
        return FALSE;
    }
    SetWindowPos(hwndTip,HWND_TOPMOST, 0, 0, 0, 0,
                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);  

    // Subclass the list box here in order to get the TTN_GETDISPINFO notification
    lpfnOldWindowProc = (WNDPROC) SetWindowLongPtr(hLB,GWLP_WNDPROC,(LONG_PTR) ListBoxSubClassFunction);
    INT_PTR iHeight = SendMessage(hLB,LB_GETITEMHEIGHT,0,0);
    if ((LB_ERR == iHeight) || (iHeight == 0)) 
    {
        return FALSE;
    }
    if (!GetClientRect(hLB,&rLB)) 
    {
        return FALSE;
    }
    
    INT_PTR m = rLB.bottom - rLB.top;   // unit count client area height
    m = m/iHeight;                      // find out how many items
    INT_PTR i;                          // loop control
    LONG itop = 0;                      // top of tip item rect
    
    for (i=0 ; i < m ; i++) 
    {
    
        ti.uFlags = TTF_SUBCLASS;
        ti.hwnd = hLB;                  // window that gets the TTN_GETDISPINFO
        ti.uId = IDC_KEYLIST;
        ti.hinst = m_hInstance;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        
        ti.rect.top =    itop;
        ti.rect.bottom = itop + (LONG) iHeight - 1;
        ti.rect.left =   rLB.left;
        ti.rect.right =  rLB.right;

        itop += (LONG) iHeight;

        ti.lParam = (LPARAM) n++;
        
#ifdef LOUDLY2
        OutputDebugString(L"Adding a tip control region\n");
        _stprintf(szTemp,L"top = %d bottom = %d left = %d right = %d\n",ti.rect.top,ti.rect.bottom,ti.rect.left,ti.rect.right);
        OutputDebugString(szTemp);
#endif
        // Add the keylist to the tool list as a single unit
        SendMessage(hwndTip,TTM_ADDTOOL,(WPARAM) 0,(LPARAM)(LPTOOLINFO)&ti);
    }
    return TRUE;
}


/**********************************************************************

// Get item number from pD->lParam
// Fetch that text string from listbox at pD->hwnd
// trim suffix
// Call translation API
// Write back the string


**********************************************************************/

BOOL
SetToolText(NMTTDISPINFO *pD) {
    CREDENTIAL *pCred = NULL;       // used to read cred under mouse ptr
    INT_PTR iWhich;                 // which index into list
    HWND hLB;                       // list box hwnd
    //NMHDR *pHdr;                    // notification msg hdr
    TCHAR rgt[TIPSTRINGLEN];        // temp string for tooltip
    TCHAR szCredName[TARGETNAMEMAXLENGTH]; // credname
    TCHAR *pszTargetName;           // ptr to target name in pCred
    DWORD dwType;                   // type of target cred
    TCHAR       *pC;                // used for suffix trimming
    BOOL        f;                  // used for suffix trimming
    LRESULT     lRet;               // api ret value
    ULONG ulOutSize;                // ret from CredpValidateTargetName()
    WILDCARD_TYPE OutType;          // enum type to receive ret from api
    UNICODE_STRING OutUString;      // UNICODESTRING to package ret from api
    WCHAR *pwc;
    UINT iString;                 // resource # of string
    TCHAR rgcFormat[TIPSTRINGLEN];  // Hold tooltip template string
    NTSTATUS ns;


    //pHdr = &(pD->hdr);
    hLB = GetDlgItem(g_hMainDlg,IDC_KEYLIST);
    
    iWhich = SendMessage(hLB,LB_GETTOPINDEX,0,0);
    iWhich += pD->lParam;
    
#ifdef LOUDLY
    TCHAR rga[100];
    _stprintf(rga,L"Text reqst for %d\n",iWhich);
    OutputDebugString(rga);
#endif

    // Read the indicated cred from the store, by first fetching the name string and type
    //  from the listbox
    lRet = SendDlgItemMessage(g_hMainDlg,IDC_KEYLIST,LB_GETTEXT,iWhich,(LPARAM) szCredName);
    if ((LB_ERR == lRet) || (0 == lRet)) 
    {
        return FALSE;
    }
    
    dwType = (DWORD) SendDlgItemMessage(g_hMainDlg,IDC_KEYLIST,LB_GETITEMDATA,iWhich,0);
#ifdef LOUDLY
    OutputDebugString(L"Target: ");
    OutputDebugString(szCredName);
    OutputDebugString(L"\n");
#endif
    // null term the targetname, trimming the suffix if there is one
    pC = _tcschr(szCredName,g_rgcCert[0]);
    if (pC) {
        pC--;
        *pC = 0x0;               // null terminate namestring
    }
    
#ifdef LOUDLY
    OutputDebugString(L"Trimmed target: ");
    OutputDebugString(szCredName);
    OutputDebugString(L"\n");
#endif

    // For special cred, replace the credname with a special string
    if (dwType == SESSION_FLAG_VALUE) 
    {
        _tcsncpy(szCredName,CRED_SESSION_WILDCARD_NAME,TARGETNAMEMAXLENGTH - 1);
        dwType = CRED_TYPE_DOMAIN_PASSWORD;
    }
    // Attempt to read the credential from the store
    // The returned credential will have to be freed if leaving this block
    f = (CredRead(szCredName,
             (ULONG) dwType ,
             0,
             &pCred));
    if (!f) 
    {
        return FALSE;        
    }
#ifdef LOUDLY
    if (f) OutputDebugString(L"Successful Cred Read\n");
#endif
    // clear tip strings
    szTipString[0] = 0;
    rgt[0] = 0;

#ifndef SIMPLETOOLTIPS
    pszTargetName = pCred->TargetName;
    if (NULL == pszTargetName) return FALSE;

    ns = CredpValidateTargetName(
                            pCred->TargetName,
                            pCred->Type,
                            MightBeUsernameTarget,
                            NULL,
                            NULL,
                            &ulOutSize,
                            &OutType,
                            &OutUString);

    if (!SUCCEEDED(ns)) 
    {
        return FALSE;
    }

    pwc = OutUString.Buffer;

    switch (OutType) 
    {
        case WcDfsShareName:
            iString = IDS_TIPDFS;
            break;
        case WcServerName:
            iString = IDS_TIPSERVER;
            break;
        case WcServerWildcard:
            iString = IDS_TIPTAIL;
            pwc++;              // trim off the leading '.'
            break;
        case WcDomainWildcard:
            iString = IDS_TIPDOMAIN;
            break;
        case WcUniversalSessionWildcard:
            iString = IDS_TIPDIALUP;
            break;
        case WcUniversalWildcard:
            iString = IDS_TIPOTHER;
            break;
        case WcUserName:
            iString = IDS_TIPUSER;
            break;
        default:
            ASSERT(0);
            iString = 0;
            break;
    }

    // Show tip text unless we fail to get the string
    // On fail, show the username
    if (0 != LoadString(g_hInstance,iString,rgcFormat,TIPSTRINGLEN))
    {
        _stprintf(rgt,rgcFormat,pwc);
    }
    else 
    {
        if (0 != LoadString(g_hInstance,IDS_LOGASUSER,rgcFormat,500))
        {
            _stprintf(rgt,rgcFormat,iWhich,pCred->UserName);
        }
        else 
        {
            rgt[0] = 0;
        }
    }
#endif
        
#ifdef LOUDLY
    OutputDebugString(L"Tip text:");
    //OutputDebugString(pCred->UserName);
    OutputDebugString(rgt);
    OutputDebugString(L"\n");
#endif
    if (rgt[0] == 0) 
    {
        if (pCred) CredFree(pCred);
        return FALSE;
    }
    //_tcscpy(szTipString,pCred->UserName);    // copy to a more persistent buffer
    _tcsncpy(szTipString,rgt,TIPSTRINGLEN - 1);    // copy to a more persistent buffer
    pD->lpszText = szTipString;  // point the response to it
    pD->hinst = NULL;
    if (pCred) 
    {
        CredFree(pCred);
    }
    return TRUE;
}

/**********************************************************************


ListBoxSubClassFunction()

Arguments:  None
Returns:        BOOL always TRUE

Comments:   Message handler subclassing function for the list box, which intercepts
                    requests for tooltip display information and processes them.

**********************************************************************/

LRESULT CALLBACK ListBoxSubClassFunction(HWND hW,WORD Message,WPARAM wparam,LPARAM lparam) 
{
    if (Message == WM_NOTIFY) 
    {
        if ((int) wparam == IDC_KEYLIST) 
        {
            NMHDR *pnm = (NMHDR *) lparam;
            if (pnm->code == TTN_GETDISPINFO) 
            {
                NMTTDISPINFO *pDi;
                pDi = (NMTTDISPINFO *) pnm;
                SetToolText(pDi);
            }
        }
    }
    return CallWindowProc(lpfnOldWindowProc,hW,Message,wparam,lparam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\res.h ===
#ifndef _RES_H_
#define _RES_H_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RES.H

Abstract:

    Resource symbols for keymgr application
     
Author:

    georgema        000310  updated

Environment:
    Win98, Win2000

Revision History:

--*/

#define IDI_UPGRADE                         100
#define IDI_LARGE                           111
#define IDI_SMALL                           112

// app general items
#define IDB_BANNER                          1701
#define IDS_INF_FILE                        1702
#define IDS_INVALID_OS_PROMPT               1703

// strings for cpl display
#define IDS_APP_NAME                        1704
#define IDS_APP_DESCRIPTION                 1705

// dialogs
#define IDD_ADDCRED                         1706
#define IDD_KEYRING                         1707
#define IDD_CHANGEPASSWORD                  1708

// IDD_KEYRING
#define IDC_KEYLIST                         1709
#define IDC_NEWKEY                          1710
#define IDC_DELETEKEY                       1711
#define IDC_EDITKEY                         1712
#define IDC_CHGPSW                 1713
#define IDC_HELPKEY                1731
#define IDC_CHANGE_PASSWORD 1724
#define IDC_PREVIEW                         1730
#define IDC_INTROTEXT                       1731

// IDD_CHANGEPASSWORD
#define IDC_OLD_PASSWORD_LABEL              1714
#define IDC_OLD_PASSWORD                    1715
#define IDC_NEW_PASSWORD_LABEL              1716
#define IDC_NEW_PASSWORD                    1717
#define IDC_CONFIRM_PASSWORD_LABEL          1718
#define IDC_CONFIRM_PASSWORD                1719
#define IDC_CPLABEL                         1729

// IDD_ADDCRED
#define IDC_TARGET_NAME_LABEL               1720
#define IDC_TARGET_NAME                     1721
#define IDC_CRED                            1722
#define IDC_DESCRIPTION                     1723
#define IDC_DOMAINPSWLABEL                  1732

// Title strings for dialogs
#define IDS_TITLE                           1800

// Suffixes used to indicate cred types in key list
//#define IDS_GENERICSUFFIX                   1802
#define IDS_CERTSUFFIX                      1803
#define IDS_PASSPORTSUFFIX                  1832

// Error text used in message boxes
#define IDS_DELETEWARNING                   1804
#define IDS_CANNOTEDIT                      1805
#define IDS_DELETEFAILED                    1807
#define IDS_NONAMESELECTED                  1808
#define IDS_EDITFAILED                      1809
#define IDS_ADDFAILED                       1810
#define IDS_BADUNAME                        1812
#define IDS_NOLOGON                         1813
#define IDS_BADUSERDOMAINNAME               1814
#define IDS_CHANGEPWDFAILED                 1815
#define IDS_PSWFAILED                       1816
#define IDS_DOMAINFAILED                    1817
#define IDS_NEWPASSWORDNOTCONFIRMED         1818
#define IDS_SINGLEEXPIRY                    1819
#define IDS_BADPASSWORD                     1841
#define IDS_RENAMEFAILED                    1842

// change password errors - used in message boxes
#define IDS_CP_INVPSW                       1820
#define IDS_CP_NOUSER                       1821
#define IDS_CP_BADPSW                       1822
#define IDS_CP_NOSVR                        1823
#define IDS_CP_NOTALLOWED                   1824
#define IDS_CPLABEL                         1826

#define IDS_SESSIONCRED                     1825

#define IDS_DOMAINCHANGE                    1828
#define IDS_LOCALFAILED                     1829
#define IDS_PASSPORT                        1831
#define IDS_PASSPORT2                       1844
#define IDS_PASSPORTNOURL                   1851

#define IDS_DESCBASE                        1845
#define IDS_DESCAPPCRED                     1846
#define IDS_PERSISTBASE                     1847
#define IDS_PERSISTLOGOFF                   1848
#define IDS_PERSISTDELETE                   1849
#define IDS_DESCLOCAL                       1850

// Help strings - context help for controls
#define IDS_NOHELP                          1900

#define IDH_KEYRING                         1901
#define IDH_KEYLIST                         1902
#define IDH_ADDCRED                         1903
#define IDH_NEW                             1904
#define IDH_DELETE                          1905
#define IDH_EDIT                            1906
#define IDH_CHANGEPASSWORD                  1907

#define IDH_OLDPASSWORD                     1908
#define IDH_NEWPASSWORD                     1909
#define IDH_CONFIRM                         1910

#define IDH_TARGETNAME                      1911
#define IDH_CUIUSER                         1912
#define IDH_CUIPSW                          1913
#define IDH_CUIVIEW                         1914
#define IDH_CLOSE                           1915
#define IDH_DCANCEL                          1916

#define IDS_TIPDFS                          1833
#define IDS_TIPSERVER                       1834
#define IDS_TIPTAIL                         1835
#define IDS_TIPDOMAIN                       1836
#define IDS_TIPDIALUP                       1837
#define IDS_TIPOTHER                        1838
#define IDS_TIPUSER                         1839
#define IDS_LOGASUSER                       1840
#define IDS_INTROTEXT                       1843

// NEXT CONTROL VALUE (1735)
// NEXT STRING VALUE (1844)
// NEXT HELP VALUE (1921)
// NEXT RESOURCE VALUE ?
// NEXT COMMAND VALUE ?
// NEXT SYMED VALUE ?

#endif  //  _RES_H_

//
///// End of file: Res.h   ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\testaudit.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    testaudit.cpp

Abstract:

    Test Auditing routines.  Used by development to document the locations 
    and reach conditions for code checkpoints that test should be sure to cover.
    Used by test to ensure that the test meets the expectations of the developer
    and to locate points of interest in the source files.

    This file will compile to nothing if TESTAUDIT is not a defined symbol in
    the build environment.  For this purpose, buildx.cmd has been modified to
    provide for setting this symbol.

Author:

    georgema        Nov., 2001  created

Environment:

Revision History:

--*/

#if TESTAUDIT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <testaudit.h>
#include "audit.h"

// Data structure element for the auditing data
typedef struct _touchstruct
{
    INT iPoint;
    BOOL fTouched;
}TOUCHSTRUCT, *PTOUCHSTRUCT;

#define TOUCHSIZE sizeof(TOUCHSTRUCT)

// Arbitrary limit on point number range, in order to be able to constrain the
//  size of the runtime point-hit array to manageable size without having to 
//  do anything cute.
#define NUMBERLIMIT 500 

// Global variable to hold mem allocation for auditing data
TOUCHSTRUCT *pTouch = NULL;

// Global variable to hold BOOL value for enabling checkpoint hit messages
// This way, the initial value is available to manipulate with the debugger
#if TESTAUDITHITS
    BOOL fShowCheckpointHits = TRUE;
#else
    BOOL fShowCheckpointHits = FALSE;
#endif

/*************************************************************************

BranchInit

    Creates a memory allocation to hold data regarding whether particular
    checkpoints have been visited.  Reads reference numbers from the 
    AuditData structure, and creates pairs of the reference number and
    a boolean to be set true when the point is hit.

    arguments: none
    returns: none
    errors: May fail due to out of memory.  On this case, returns with
             the pointer NULL.  Further calls into these functions with
             a NULL ptr will do nothing at all.

*************************************************************************/
void BranchInit(void)
{
    WCHAR sz[100];
    
    swprintf(sz,L"TEST: %d checkpoints defined\n",CHECKPOINTCOUNT);
    OutputDebugString(sz);
    
    pTouch = (TOUCHSTRUCT *) malloc(CHECKPOINTCOUNT * sizeof(TOUCHSTRUCT));
    if (NULL == pTouch) return;

    // table allocation successful.  Initialize using point #s
    memset(pTouch,0,(CHECKPOINTCOUNT * sizeof(TOUCHSTRUCT)));
    for (INT i=0;i<CHECKPOINTCOUNT;i++)
    {
        // go through the AuditData[] struct and fetch the point numbers
        pTouch[i].iPoint = AuditData[i].iPoint;
    }
}


/*************************************************************************

BranchTouch

    Looks through the memory table created by BranchInit for a match with
    the passed point number.  Sets the matching table entry to show that
    the point was visited.  The string is not passed to this routine in 
    order to minimize the amount of memory allocation, processing, and
    debug output.

    arguments: INT point number
    returns: none
    errors: May fail to find the point number.  If so, does nothing.

*************************************************************************/
void BranchTouch(INT iBranch)
{
    WCHAR sz[100];
    INT j;
    
    if (NULL == pTouch) return;

    // warn user about obviously bad checkpoint statements
    if (0 == iBranch)          ASSERT(0);
    if (iBranch > NUMBERLIMIT) ASSERT(0);
    
    if (fShowCheckpointHits)
    {
        swprintf(sz,L"TEST: Checkpoint %d touched. \n",iBranch);
        OutputDebugString(sz);
    }
    // look for this point number and set its touched flag
    for (j=0;j<CHECKPOINTCOUNT;j++)
    {
        if (pTouch[j].iPoint == iBranch)
        {
            pTouch[j].fTouched = TRUE;
            break;
        }
    }
    
    // detect checkpoint for which no table entry exists
    if (j == CHECKPOINTCOUNT) ASSERT(0);
}

/*************************************************************************

BranchSummary

    Looks through the memory table created by BranchInit for entries 
    which show that they were not reached.  For these, scans the 
    AuditData table looking for a match, and prints the entry number
    together with the associated string as part of a table shown to 
    the operator in the debug output.

    arguments: none
    returns: none
    errors: none expected unless the table is corrupted

*************************************************************************/
void BranchSummary(void)
{
    WCHAR sz[100];
    INT i;
    BOOL fUntouched = FALSE;        // set true if any untouched found

    if (NULL == pTouch) return;

    // if TESTAUDITSUMMARY is false, this routine will do nothing but
    //  free the touch array
#if TESTAUDITSUMMARY
    swprintf(sz,L"TEST: Total of %d checkpoints.\n",CHECKPOINTCOUNT);
    OutputDebugString(sz);
    OutputDebugString(L"TEST: Untouched checkpoints:\n");

    // Scan every entry in the checkpoint table
    for (i=0;i<CHECKPOINTCOUNT;i++)
    {
        // find all untouched
        if (pTouch[i].fTouched == FALSE)
        {
            // find matching entry in data table
            // there should be no match failures unless the table becomes 
            // corrupted
            INT j;
            for (j=0;j<CHECKPOINTCOUNT;j++)
            {
                // on match, print number and string
                if (pTouch[i].iPoint == AuditData[j].iPoint)
                {
                    swprintf(sz,L"   %d   ",pTouch[i].iPoint);
                    OutputDebugString(sz);
                    if (AuditData[j].pszDescription != NULL)
                    {
                        OutputDebugString(AuditData[j].pszDescription);
                    }
                    OutputDebugString(L"\n");
                    break;
                }
            }
            if (j == CHECKPOINTCOUNT) ASSERT(0);
            fUntouched = TRUE;
        }
    }
    if (!fUntouched)
    {
        OutputDebugString(L"   ***NONE***\n");
    }
#endif
    free(pTouch);
    pTouch = NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\testaudit.h ===
#ifndef _TESTAUDIT_H_
#define _TESTAUDIT_H_
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    testaudit.h

Abstract:

    Test Auditing routines.  Used by development to document the locations 
    and reach conditions for code checkpoints that test should be sure to cover.
    Used by test to ensure that the test meets the expectations of the developer
    and to locate points of interest in the source files.

    These routines disappear altogether if the build is not a debug build and
    if the symbol TESTAUDIT is not defined.  To accomplish this, the command
    file buildx.cmd in the tools directory, is modified to provide for setting
    this flag.

    To use testaudit.h/cpp in your project, you must run the MAKEAUDIT.EXE utility,
    which processes files in the current directory, and generates an AUDIT.H file
    which is included in testaudit.cpp.  This file defines the descriptive strings
    for the checkpoints unreached by the code.  It should be rebuilt whenever changes
    in the source files result in material changes to the line numbers associated 
    with checkpoints.

    Usage examples:

    CHECKPOINTINIT;             Initializes the test auditing data structure - appears
                                 once in an executable unit
    CHECKPOINT(3,"Print page"); Defines checkpoint 3 as "Print page" - Produces an entry
                                 in AUDIT.H with the file, linenumber, and this
                                 description.
    CHECKPOINTFINISH;           Prints statistics to the debug output and cleans up - 
                                 Called when the executable exits.  Shows the checkpoint
                                 number, file, line number, and description for all 
                                 unreached checkpoints.

    Statement blocks can be conditionally compiled in test auditing builds by use of 
    the preprocessor #if directive and the TESTAUDIT symbol.  The usual use is to preface 
    conditional checkpoints to permit testing for different conditions passing the same 
    checkpoint, something like this:

    #if TESTAUDIT
            if (mode_one) CHECKPOINT(3,"Print page portrait mode");
            if (Mode_two) CHECKPOINT(4,"Print page landscape mode");
    #endif

Author:

    georgema        Nov., 2001  created

Environment:

Revision History:

--*/

// These macros disappear if the build is not debug or if the symbol TESTAUDIT
// is not defined.

#if DBG
#if TESTAUDIT

typedef struct _AuditData 
{
    INT  iPoint;
    WCHAR *pszDescription;     
} AUDITDATA;

#define CHECKPOINT(x,y) BranchTouch(x)
#define CHECKPOINTINIT BranchInit()
#define CHECKPOINTFINISH BranchSummary()
#else
#define CHECKPOINT(x,y)
#define CHECKPOINTINIT
#define CHECKPOINTFINISH
#endif
#else
#define CHECKPOINT(x,y)
#define CHECKPOINTINIT
#define CHECKPOINTFINISH
#endif

#define NCHECKPOINT(x,y)

#if defined (__cplusplus)
extern "C" {
#endif
void BranchTouch(INT);
void BranchInit(void);
void BranchSummary(void);
#if defined (__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\switches.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    SWTICHES.H

Abstract:

    Header file to contain option switches
     
Author:

    georgema        created

Comments:

Environment:
    WinXP

Revision History:

--*/
#ifndef _SWITCHES_
#define _SWITCHES_

// Option switches to switch in or out various code features.  Some are
//  related to debugging, others are code features.


// keymgr switches
// GMDEBUG - various debug stuff
// LOUDLY - turns on verbose debug output during run

#undef GMDEBUG
#undef LOUDLY

// Implement pop CHM file on context help not found when item selected?
#undef LINKCHM

// NOBLANKPASSWORD - disallow blank password
#undef  NOBLANKPASSWORD

// show passport creds in the key list?
#define SHOWPASSPORT

// simple tooltips show only the user account name for the target
#undef SIMPLETOOLTIPS

#define NEWPASSPORT
#define PASSPORTURLINREGISTRY

// This setting forces the string renditions in the main dialog list box to be LTR,
//  regardless of the RTL/LTR orientation of the system selected language.
//  See bug 344434
#undef FORCELISTLTR
#define PASSWORDHINT

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\pswutil.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    PSWUTIL.CPP

Abstract:

    Keyring WinMain() and application support
     
Author:

    990917  johnhaw Created. 
    georgema        000310  updated
    georgema        000501  used to be EXE, changed to CPL

Comments:
   !!!!!
   this file is a duplicate of a nearly identical file in the credui project.  It should be removed when
   the implementation of NetUserChangePassword() is updated to handle unc names and MIT Kerberos
   realms properly.  For now, it wraps NetUserChangePassword() to handle the extra cases.

Environment:
    WinXP

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincred.h>
#include <align.h>
#include <lm.h>
#include <ntsecapi.h>
#include <dsgetdc.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>


// Dependent libraries:
//  secur32.lib, netapi32.lib

// external fn:  NET_API_STATUS NetUserChangePasswordEy(LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR)

BOOL 
IsMITName (
    LPCWSTR UserName
)
{
    BOOL fReturn = FALSE;
    HKEY MitKey;
    DWORD Index;
    PWSTR Realms;
    DWORD RealmSize;
    int err;
    DWORD NumRealms;
    DWORD MaxRealmLength;
    FILETIME KeyTime;
    WCHAR *szUncTail;
    
    if (NULL == UserName)
    {
        return FALSE;
    }
    
    szUncTail = wcschr(UserName,'@');
    if (NULL == szUncTail)
    {
        return FALSE;
    }
    szUncTail++;                        // point to char following @

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Domains"),
                0,
                KEY_READ,
                &MitKey );

    if ( err == 0 )
    {
        err = RegQueryInfoKey( MitKey,
                               NULL,
                               NULL,
                               NULL,
                               &NumRealms,
                               &MaxRealmLength,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL );

        MaxRealmLength++ ;
        MaxRealmLength *= sizeof( WCHAR );

        Realms = (PWSTR) malloc(MaxRealmLength );

        if ( Realms)
        {
            for ( Index = 0 ; Index < NumRealms ; Index++ )
            {
                RealmSize = MaxRealmLength ;

                err = RegEnumKeyEx( MitKey,
                                  Index,
                                  Realms,
                                  &RealmSize,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &KeyTime );
                if (err == 0)
                {
                    if (0 == _wcsicmp(szUncTail, Realms))
                    {
                        fReturn = TRUE;
                        break;
                    }
                }
            }
        }
        free(Realms);
    }
    return fReturn;
}

NTSTATUS
MitChangePasswordEy(
    LPCWSTR       DomainName,
    LPCWSTR       UserName,
    LPCWSTR       OldPassword,
    LPCWSTR       NewPassword,
    NTSTATUS      *pSubStatus
    )
{
    HANDLE hLsa = NULL;
    NTSTATUS Status;
    NTSTATUS SubStatus;
    
    STRING Name;
    ULONG PackageId;
    
    PVOID Response = NULL ;
    ULONG ResponseSize;
    
    PKERB_CHANGEPASSWORD_REQUEST ChangeRequest = NULL;
    ULONG ChangeSize;
    
    UNICODE_STRING User,Domain,OldPass,NewPass;

    Status = LsaConnectUntrusted(&hLsa);
    if (!SUCCEEDED(Status)) goto Cleanup;

    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );

    Status = LsaLookupAuthenticationPackage(
                hLsa,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        // detect / handle failure to find kerberos
        ASSERT(0);
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &User,
        UserName
        );
    RtlInitUnicodeString(
        &Domain,
        DomainName
        );
    RtlInitUnicodeString(
        &OldPass,
        OldPassword
        );
    RtlInitUnicodeString(
        &NewPass,
        NewPassword
        );

    ChangeSize = ROUND_UP_COUNT(sizeof(KERB_CHANGEPASSWORD_REQUEST),4)+
                                    User.Length +
                                    Domain.Length +
                                    OldPass.Length +
                                    NewPass.Length ;
    ChangeRequest = (PKERB_CHANGEPASSWORD_REQUEST) LocalAlloc(LMEM_ZEROINIT, ChangeSize );

    if ( ChangeRequest == NULL )
    {
        ASSERT(0);
        Status = STATUS_NO_MEMORY ;
        goto Cleanup ;
    }

    ChangeRequest->MessageType = KerbChangePasswordMessage;

    ChangeRequest->AccountName = User;
    ChangeRequest->AccountName.Buffer = (LPWSTR) ROUND_UP_POINTER(sizeof(KERB_CHANGEPASSWORD_REQUEST) + (PBYTE) ChangeRequest,4);

    RtlCopyMemory(
        ChangeRequest->AccountName.Buffer,
        User.Buffer,
        User.Length
        );

    ChangeRequest->DomainName = Domain;
    ChangeRequest->DomainName.Buffer = ChangeRequest->AccountName.Buffer + ChangeRequest->AccountName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->DomainName.Buffer,
        Domain.Buffer,
        Domain.Length
        );

    ChangeRequest->OldPassword = OldPass;
    ChangeRequest->OldPassword.Buffer = ChangeRequest->DomainName.Buffer + ChangeRequest->DomainName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->OldPassword.Buffer,
        OldPass.Buffer,
        OldPass.Length
        );

    ChangeRequest->NewPassword = NewPass;
    ChangeRequest->NewPassword.Buffer = ChangeRequest->OldPassword.Buffer + ChangeRequest->OldPassword.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->NewPassword.Buffer,
        NewPass.Buffer,
        NewPass.Length
        );

    //
    // We are running as the caller, so state we are impersonating
    //

    //ChangeRequest->Impersonating = TRUE;
    Status = LsaCallAuthenticationPackage(
                hLsa,
                PackageId,
                ChangeRequest,
                ChangeSize,
                &Response,
                &ResponseSize,
                &SubStatus
                );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
            *pSubStatus = STATUS_UNSUCCESSFUL ;
        } 
        else 
        {
            *pSubStatus = SubStatus;
        }
    }

Cleanup:

    if (hLsa) LsaDeregisterLogonProcess(hLsa);

    if (Response != NULL) LsaFreeReturnBuffer(Response);
    if (ChangeRequest) 
    {
        SecureZeroMemory(ChangeRequest,ChangeSize);
        LocalFree(ChangeRequest);
    }
    
    return(Status);
}

/*

NetUserChangePasswordEy()

A wrapper function to superset the functionality of NetUserChangePassword(), specifically
by adding support for changing the account password for an MIT Kerberos principal.

This routine accepts:

1.  uncracked username, with NULL domain
2.  cracked username, with domain portion routed to the domain argument

In case 1, it handles all cases, including MIT realm password changes
In case 2, it will not handle MIT realms.  

Case 2 is provided for backwards compatibility with NetUserChangePassword().  It is intended
that callers should pass the uncracked name, and remove the cracking code from the client.

*/
NET_API_STATUS
NetUserChangePasswordEy (
    LPCWSTR domainname,
    LPCWSTR username,
    LPCWSTR oldpassword,
    LPCWSTR newpassword
)
{
    NTSTATUS ns;    // status from call
    NET_API_STATUS nas;
    NTSTATUS ss;    // substatus
#ifdef LOUDLY
    OutputDebugString(L"NetUserChangePasswordEy called for ");
    OutputDebugString(username);
    OutputDebugString(L"\n");
#endif
    // domainname may be a kerberos realm
    // If not a UNC name, call through to NetUserChangePassword
    // else
    //  locate UNC suffix
    //  search all domains returned by DsEnumerateDomainTrusts() for a match
    //  On match, if is kerberos realm, call MitChangePasswordEy()
    //  else call NetUserChangePassword
    if ((domainname == NULL) && IsMITName(username))
    {
        ns = MitChangePasswordEy(domainname, username, oldpassword, newpassword, &ss);
        // remap certain errors returned by MitChangePasswordEy to coincide with those of NetUserChangePassword
        if (NT_SUCCESS(ns)) nas = NERR_Success;
        else
        {
            switch (ns)
            {
                case STATUS_CANT_ACCESS_DOMAIN_INFO:
                case STATUS_NO_SUCH_DOMAIN:
                {
                    nas = NERR_InvalidComputer;
                    break;
                }
                case STATUS_NO_SUCH_USER:
                case STATUS_WRONG_PASSWORD_CORE:
                case STATUS_WRONG_PASSWORD:
                {
                    nas = ERROR_INVALID_PASSWORD;
                    break;
                }
                case STATUS_ACCOUNT_RESTRICTION:
                case STATUS_ACCESS_DENIED:
                case STATUS_BACKUP_CONTROLLER:
                {
                    nas = ERROR_ACCESS_DENIED;
                    break;
                }
                case STATUS_PASSWORD_RESTRICTION:
                {
                    nas = NERR_PasswordTooShort;
                    break;
                }
                        
                default:
                    nas = 0xffffffff;       // will produce omnibus error message when found (none of the above)
                    break;
            }
        }
    }
    else if (NULL == domainname)
    {
        WCHAR RetUserName[CRED_MAX_USERNAME_LENGTH + 1];
        WCHAR RetDomainName[CRED_MAX_USERNAME_LENGTH + 1];
        RetDomainName[0] = 0;
        DWORD Status = CredUIParseUserNameW(
                        username,
                        RetUserName,
                        CRED_MAX_USERNAME_LENGTH,
                        RetDomainName,
                        CRED_MAX_USERNAME_LENGTH);
        switch (Status)
        {
            case NO_ERROR:
            {
#ifdef LOUDLY
                OutputDebugString(L"Non-MIT password change for ");
                OutputDebugString(RetUserName);
                OutputDebugString(L" of domain ");
                OutputDebugString(RetDomainName);
                OutputDebugString(L"\n");
#endif
                nas = NetUserChangePassword(RetDomainName,RetUserName,oldpassword,newpassword);
                break;
            }
            case ERROR_INSUFFICIENT_BUFFER:
                nas = ERROR_INVALID_PARAMETER;
                break;
            case ERROR_INVALID_ACCOUNT_NAME:
            default:
                nas = NERR_UserNotFound;
                break;
        }

    }
    else 
    {
        // both username and domainname passed.
        nas = NetUserChangePassword(domainname,username,oldpassword,newpassword);
    }
#ifdef LOUDLY
    WCHAR szsz[200];
    swprintf(szsz,L"NetUserChangePasswordEy returns %x\n",nas);
    OutputDebugString(szsz);
#endif
    return nas;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\wizard.cpp ===
//
//  prwizard.cpp
//
//  Copyright (c) Microsoft Corp, 2000
//
//  This file contains source code for presenting UI wizards to guide the user
//  in creating a password recovery key disk/file, and using such a file to 
//  reset the password on an account.
//
//  History:
//
//  georgema       8/17/2000     Created
//
//
//  Exports: PRShowSaveWizard
//           PRShowRestoreWizard
//
// Dependencies:  shellapi.h, shell32.lib for SHGetFileInfo()

#pragma comment(user, "Compiled on " __DATE__ " at " __TIME__)
#pragma comment(compiler)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>   // STATUS_... error values
#include <windows.h>
#include <shellapi.h>
#include <ole2.h>
#include <security.h>
#include <tchar.h>
#include <io.h>         // _waccess
#include <stdlib.h>
#include <commdlg.h>
#include <passrec.h>
#include <lm.h>
#include <prsht.h>      // includes the property sheet functionality
#include <netlib.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <shfusion.h>
#include "switches.h"
#include "wizres.h"   // includes the definitions for the resources
#include "keymgr.h"
#include "diskio.h"
#include "testaudit.h"

// All of these definitions are for updating the password hint for the user
// DirectUser and DirectUI
#ifdef PASSWORDHINT
 #include <shgina.h>
#endif

// Symbols and variables of global significance

#define FILESPACENEEDED 8192        // how much must be on disk - conservative
#define LERROR_NO_ACCOUNT (0x80008888)

#define NUMSAVEPAGES    5           // how many pages of save wizard
#define NUMRESTOREPAGES 4           // how many pages of restore wizard
#define TEMPSTRINGBUFSIZE 500
//#define PSWBUFSIZE 20

#define TIMERPERIOD 1000            // 1 second tick timer for progress
#define TIMERID     1001

// Error values from SaveThread
#define ERRNOFILE    2
#define ERRSAVEERROR 1
#define ERRSUCCESS   0

// Variables defined in other files
extern HINSTANCE g_hInstance;   // shared with keymgr
extern HANDLE g_hFile;
extern INT g_iFileSize;

// Global vars shared with disk subsystem

TCHAR pszFileName[]       = TEXT("A:\\userkey.psw");
HWND      c_hDlg;

// File scope (locally global)

static WCHAR     Buf[TEMPSTRINGBUFSIZE];       // gen purpose scratch string
static WCHAR     rgszDrives[200];               // drive strings cache
static INT       c_ArrayCount = 0;
static INT       c_DriveCount = 0;
static INT       c_fDrivesCounted = FALSE;
static WCHAR     c_rgcFileName[MAX_PATH];
static WCHAR     c_rgcPsw[PWLEN + 1];
static WCHAR     c_rgcOldPsw[PWLEN + 1];
static WCHAR     c_rgcUser[UNLEN + 1] = {0};
static WCHAR     c_rgcDomain[UNLEN + 1];
static HCURSOR   c_hCursor;

static UINT_PTR  c_iTimer;
static HWND      c_hProgress;
static INT       c_iProg = 0;
static HWND      c_TimerAssociatedWindow;

static BOOL      c_bSaveComplete = FALSE;

// Recovery data

static BYTE    *c_pPrivate = NULL;
static INT     c_cbPrivate = 0;

// Page control handles

static HWND      c_hwndSWelcome1;
static HWND      c_hwndSWelcome2;
static HWND      c_hwndSInstructions;
static HWND      c_hwndSP1E1;
static HWND      c_hwndSP1E2;
static HWND      c_hwndSFinish1;
static HWND      c_hwndSFinish2;
static HWND      c_hwndSCancel;

static HWND      c_hwndDriveInstructions;
static HWND      c_hwndDrivePrompt;
static HWND      c_hwndCBDriveList;

static HWND      c_hwndRWelcome1;
static HWND      c_hwndRWelcome2;
static HWND      c_hwndRInstructions;
static HWND      c_hwndRP1E1;
static HWND      c_hwndRP1E2;
static HWND      c_hwndRP1E3;
static HWND      c_hwndRBackup;
static HWND      c_hwndRFinish1;
static HWND      c_hwndRFinish2;
static HWND      c_hwndRCancel;

static HFONT     c_hTitleFont;
static BOOL      c_fIsBackup;

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Common utility functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
WCHAR *RString(INT iResID) 
{
    ASSERT(iResID);
    Buf[0] = 0;
    if (NULL != g_hInstance)
    {
        LoadString(g_hInstance,iResID,Buf,TEMPSTRINGBUFSIZE);
    }
    return Buf;
}

/**********************************************************************

RMessageBox() - Wrapper for MessageBox(), allowing text elements to be 
 specified either by resource ID or by a pointer to a string.  Text 
 ID greater and 0x1000 (4096) is taken to be a pointer.

**********************************************************************/
int RMessageBox(HWND hw,UINT_PTR uiResIDTitle, UINT_PTR uiResIDText, UINT uiType) 
{
    WCHAR tBuf[TEMPSTRINGBUFSIZE];
    WCHAR mBuf[TEMPSTRINGBUFSIZE];
    INT_PTR iCount = 0;
    
    tBuf[0] = 0;
    mBuf[0] = 0;

    ASSERT(g_hInstance);
    if (NULL != g_hInstance) 
    {
        if (uiResIDTitle < 4096)
        {
            iCount = LoadString(g_hInstance,(UINT)uiResIDTitle,tBuf,TEMPSTRINGBUFSIZE);
        }
        else
        {
            wcsncpy(tBuf,(WCHAR *)uiResIDTitle,TEMPSTRINGBUFSIZE);
            tBuf[TEMPSTRINGBUFSIZE - 1] = 0;
        }
        
        if (uiResIDTitle < 4096)
        {
            iCount = LoadString(g_hInstance,(UINT)uiResIDText,mBuf,TEMPSTRINGBUFSIZE);
        }
        else 
        {
            wcsncpy(mBuf,(WCHAR *)uiResIDText,TEMPSTRINGBUFSIZE);
            mBuf[TEMPSTRINGBUFSIZE - 1] = 0;
        }
        
        if (0 != iCount) 
        {
            return MessageBox(hw,mBuf,tBuf,uiType);
        }
    }

    // 0 is error return value from MessageBox()
    return 0;
}

/**********************************************************************

RSetControlText() - Set text of dialog control by ID to string by ID.
  String ID of zero clears the control.

**********************************************************************/
void RSetControlText(UINT uiControlID, UINT uiTextID)
{
    WCHAR tBuf[TEMPSTRINGBUFSIZE];
    INT iCount;
    ASSERT(g_hInstance);
    ASSERT(uiControlID);
    if ((NULL != g_hInstance) && (0 != uiControlID))
    {
        if (0 != uiTextID)
        {
            iCount = LoadString(g_hInstance,uiTextID,tBuf,TEMPSTRINGBUFSIZE);
            if (iCount)
            {
                SetDlgItemText(c_hDlg,uiControlID,tBuf);
            }
            else
            {
                SetDlgItemText(c_hDlg,uiControlID,L"");
            }
        }
        else
        {
            SetDlgItemText(c_hDlg,uiControlID,L"");
        }
    }
    return;
}

/**********************************************************************

CreateFontY() - Create the fond to use in the wizard.

**********************************************************************/
HFONT CreateFontY(LPCTSTR pszFontName,LONG lWeight,LONG lHeight) 
{
    NONCLIENTMETRICS ncm = {0};
    
    if (NULL == pszFontName)
    {
        return NULL;
    }
    if (0 == lHeight)
    {
        return NULL;
    }
    ncm.cbSize = sizeof(ncm);
    if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS,0,&ncm,0))
    {
        return NULL;
    }
    LOGFONT TitleLogFont = ncm.lfMessageFont;
    TitleLogFont.lfWeight = lWeight;
    lstrcpyn(TitleLogFont.lfFaceName,pszFontName,LF_FACESIZE);

    HDC hdc = GetDC(NULL);
    if (NULL == hdc)
    {
        return NULL;
    }
    INT FontSize = lHeight;
    TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72;
    HFONT h = CreateFontIndirect(&TitleLogFont);
    ReleaseDC(NULL,hdc);
    return h;
}

/**********************************************************************

CenterPage() - Center the passed window on the screen.

**********************************************************************/
void CenterPage(HWND hwndIn) 
{
    RECT rectWorkArea;
    RECT rectWindow;
    DWORD FreeWidth, Width, FreeHeight, Height;

    if (!SystemParametersInfo(SPI_GETWORKAREA,0,&rectWorkArea,0))
    {
        return;
    }
    GetWindowRect(hwndIn,&rectWindow);
    Height = (rectWorkArea.bottom - rectWorkArea.top);
    Width = (rectWorkArea.right - rectWorkArea.left);
    FreeHeight = Height - (rectWindow.bottom - rectWindow.top);
    FreeWidth = Width - (rectWindow.right - rectWindow.left);
    MoveWindow(hwndIn,
                FreeWidth / 2,
                FreeHeight / 2,
                (rectWindow.right - rectWindow.left),
                (rectWindow.bottom - rectWindow.top),
                TRUE);
    return;
}

/**********************************************************************

FetchPsw() - Fetch password from two password windows. Return TRUE on
success, else show message box for user error and return false.  User 
errors include:
     1.  two passwords do not match
     2.  either password is blank

Copies user entered password to global string c_rgcPsw.

**********************************************************************/

BOOL FetchPsw(HWND hE1,HWND hE2) 
{
    TCHAR rgcE1[PWLEN + 1];
    TCHAR rgcE2[PWLEN + 1];
    INT_PTR iCount;

    rgcE1[0] = 0;
    rgcE2[0] = 0;
    if ((NULL == hE2) || (NULL == hE1))
    {
        return FALSE;
    }
    iCount = SendMessage(hE1,WM_GETTEXT,PWLEN + 1,(LPARAM) rgcE1);
    iCount = SendMessage(hE2,WM_GETTEXT,PWLEN + 1,(LPARAM) rgcE2);

    if (0 != _tcsncmp(rgcE1,rgcE2,PWLEN)) 
    {
        RMessageBox(c_hDlg,IDS_MBTINVALIDPSW ,IDS_BADPSW ,MB_ICONHAND);
        return FALSE;
    }
#ifdef NOBLANKPASSWORD
    if (rgcE1[0] == 0) 
    {
        RMessageBox(c_hDlg,IDS_MBTMISSINGPSW ,IDS_NOPSW ,MB_ICONHAND);
        return FALSE;
    }
#endif
#if TESTAUDIT
    if (wcslen(rgcE1) > 25)
    {
        CHECKPOINT(65,"Wizard: Password length > 25 chars");
    }
#endif
    _tcsncpy(c_rgcPsw,rgcE1,PWLEN);
    c_rgcPsw[PWLEN] = 0;
    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File and Disk manipulation functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#define FILENAMESIZE 255;

/**********************************************************************

FileMediumIsRemoveable() - Accept pathname of file to create, return 
TRUE if pathname is to a removeable medium like a floppy or zipdisk.

**********************************************************************/
BOOL FileMediumIsRemoveable(TCHAR *pszPath) 
{
    return (DRIVE_REMOVABLE == GetDriveType(pszPath));
}

/**********************************************************************

FileMediumIsEncrypted

Accepts an input file path which may be a filename, and returns TRUE if the file
is/would be encrypted.

Note that this function touches the drive.  Attempting to call FileMediumIsEncrypted() 
on a floppy drive path with no floppy in the drive produces a pop-up error box.

**********************************************************************/
BOOL FileMediumIsEncrypted(TCHAR *pszPath) 
{
    TCHAR rgcPath[MAX_PATH];
    TCHAR *pOldHack = NULL;
    TCHAR *pHack;
    DWORD dwAttr;
#ifdef GMDEBUG
    OutputDebugString(L"File path = ");
    OutputDebugString(pszPath);
    OutputDebugString(L"\n");
#endif
    _tcsncpy(rgcPath,pszPath,MAX_PATH-1);
    pHack = rgcPath;
    do 
    {
        pOldHack = pHack;
        pHack = _tcschr(++pHack,TCHAR('\\'));
    } while (pHack);
    
    if (pOldHack == NULL) 
    {
        return FALSE;
    }
    *pOldHack = 0;
#ifdef GMDEBUG
    OutputDebugString(L"Trimmed path =");
    OutputDebugString(pszPath);
    OutputDebugString(L"\n");
#endif
    dwAttr = GetFileAttributes(rgcPath);
    if (-1 == dwAttr) 
    {
        return FALSE;
    }
    if (dwAttr & FILE_ATTRIBUTE_ENCRYPTED) 
    {
#ifdef GMDEBUG
        OutputDebugString(L"File is encrypted\n");
#endif
        return TRUE;
    }
    else return FALSE;
}

/**********************************************************************

CountRemoveableDrives

Called to determine whether it is appropriate to display the drive selection page.

The return value is the number of such drives available.  

    If 0, a message box announces that a backup cannot be made and why
    If 1, the drive select page should be skipped
    If more than one, the user chooses the drive
    
**********************************************************************/
INT CountRemoveableDrives(void) {
    //TCHAR rgszDrives[100];
    DWORD dwcc;
    TCHAR *pc;
    INT iCount = 0;
    WCHAR wcDriveLetter = L'A';

    if (c_fDrivesCounted)
    {
        return c_DriveCount;
    }
    dwcc = GetLogicalDriveStrings(200,rgszDrives);
    if (0 == dwcc)
    {
        return 0;
    }
    pc = rgszDrives;
    while (*pc != 0) 
    {
        if (FileMediumIsRemoveable(pc)) 
        {
            if (DRIVE_CDROM != GetDriveType(pc)) 
            {
 #ifdef LOUDLY
                OutputDebugString(L"Removeable drive: ");
                OutputDebugString(pc);
                OutputDebugString(L"\n");
                //MessageBox(NULL,pc,pc,MB_OK);
 #endif
                iCount++;
                wcDriveLetter = *pc;
            }
        }
        while(*pc != 0)
        {
            pc++;
        }
        pc++;
    }
    c_DriveCount = iCount;
    c_fDrivesCounted = TRUE;

    // If only 1 drive, go ahead and stamp the filename
    if (1 == iCount)
    {
        CHECKPOINT(54,"Wizard: Both - Exactly one removeable drive");
        pszFileName[0] = wcDriveLetter;
    }

    return iCount;
}

/**********************************************************************

Get the UI string for the named drive

**********************************************************************/
BOOL GetDriveUIString(WCHAR *pszFilePath,WCHAR *pszUIString,INT icbSize,HANDLE *phImageList,INT *piIconIndex) 
{
    WCHAR rgcModel[] = {L"A:\\"};
    SHFILEINFO sfi = {0};
    
    if ((NULL == pszUIString) || (NULL == pszFilePath)) 
    {
        return FALSE;
    }
    rgcModel[0] = *pszFilePath;
    DWORD_PTR dwRet = SHGetFileInfo(rgcModel,FILE_ATTRIBUTE_DIRECTORY,&sfi,sizeof(sfi),
        0 |
        SHGFI_SYSICONINDEX |
        SHGFI_SMALLICON    |
        SHGFI_DISPLAYNAME);
    
    if ( 0 == dwRet) 
    {
        return FALSE;   // failed to get the string
    }
    
    wcsncpy(pszUIString,sfi.szDisplayName,(icbSize / sizeof(WCHAR)) -sizeof(WCHAR));
    *piIconIndex = sfi.iIcon;
    *phImageList = (HANDLE) dwRet;
    
    return TRUE;
}

/**********************************************************************

ShowRemoveableDrives

Called from within SPageProcX, the page procedure for the drive selection page, this 
function gets the available logical drives on the system, filters them one by one
keeping only removeable and unencrypted volumes.

These are assigned to up to six radio button text labels on IDD_SPAGEX

The return value is the number of such drives available.  

    If 0, a message box announces the failure condition, and the wizard exits
    If 1, this page is skipped, and that drive letter is inserted in the file name string
    If more than one, the user chooses the drive

**********************************************************************/

INT ShowRemoveableDrives(void) 
{
    //TCHAR rgszDrives[200];
    DWORD dwcc;
    TCHAR *pc;
    WCHAR rgcszUI[80];
    HANDLE hIcons;
    INT iIcons;
    BOOL fSetImageList = TRUE;
    COMBOBOXEXITEM stItem = {0};
    INT iDrive = 0;

    ASSERT(c_hwndCBDriveList);
    // test and show
    dwcc = GetLogicalDriveStrings(200,rgszDrives);
    if (0 == dwcc)
    {
        goto fail;
    }
    pc = rgszDrives;
    while (*pc != 0) 
    {
        rgcszUI[0] = 0;
        if (!GetDriveUIString(pc,rgcszUI,80,&hIcons,&iIcons))
        {
            goto fail;
        }

        if ((fSetImageList) && (hIcons != NULL))
        {
            // set image list for the edit control to the system image list
            //  returned from GetDriveUIString
            SendMessage(c_hwndCBDriveList,CBEM_SETIMAGELIST,
                        0,(LPARAM)(HIMAGELIST) hIcons);
            fSetImageList = FALSE;
        }
#ifdef LOUDLY
        {
            OutputDebugString(L"Drive ");
            OutputDebugString(pc);
            OutputDebugString(L"=");
            OutputDebugString(rgcszUI);
            OutputDebugString(L"\n");
        }
#endif
        if (FileMediumIsRemoveable(pc)) 
        {
            if (DRIVE_CDROM != GetDriveType(pc)) 
            {
#ifdef LOUDLY
                {
                    WCHAR sz[100];
                    _stprintf(sz,L"Drive %s added as removeable drive index %d\n",pc,iDrive);
                    OutputDebugString(sz);
                }
#endif
                // add string to combo box
                stItem.mask = CBEIF_SELECTEDIMAGE |CBEIF_IMAGE | CBEIF_TEXT | CBEIF_LPARAM;
                stItem.pszText = rgcszUI;
                stItem.iImage = iIcons;
                stItem.iSelectedImage = iIcons;
                stItem.lParam = iDrive;
                stItem.iItem = -1;
                SendMessage(c_hwndCBDriveList,CBEM_INSERTITEM,0,(LPARAM) &stItem);
            }
        }
        iDrive++;
#if TESTAUDIT
        if (iDrive == 0) CHECKPOINT(53,"Wizard: Both - no removeable drives");
        if (iDrive > 1) CHECKPOINT(52,"Wizard: Both - more than 1 removeable drive");
#endif
        while(*pc != 0)
        {
            pc++;
        }
        pc++;
    }
    c_ArrayCount = iDrive;
    SendMessage(c_hwndCBDriveList,CB_SETCURSEL,0,0);
    return 1;
fail:
    // show message box
    return 0;
}

/**********************************************************************

Get drive letter for zero-based drive number from the drive name strings in rgszDrives.
 Note that c_ArrayCount is 1-based.

**********************************************************************/
WCHAR GetDriveLetter(INT iDrive) 
{
    WCHAR *pc;
    pc = rgszDrives;                

    // return default driveletter if input invalid
    if ((iDrive == 0) || (iDrive < 0) || (iDrive >= c_ArrayCount))
    {
        return *pc;
    }
    for (INT i=0;i<iDrive;i++) 
    {   
        while(*pc != 0) pc++;   // skip non-nulls
        while(*pc == 0) pc++;   // skip nulls
    }
    return *pc;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Password restore/recover functionality routines called within the UI 
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

/****************************************************************************\

ExistsOldKey

Inputs: TCHAR pszUser

Returns: TRUE if user has an existing password backup, FALSE otherwise.

The username string is an account name on the local machine, not prefixed by the 
machine name.

\****************************************************************************/

BOOL ExistsOldKey(TCHAR *pszUser) 
{
    DWORD BUStatus;
    if (0 == PRQueryStatus(NULL, pszUser,&BUStatus)) 
    {
        if (0 == BUStatus) 
        {
            return TRUE;
        }
    }
    return FALSE;
}

/****************************************************************************\

GetNames()

Gets local machine domain name and the username for later use by LogonUser() to 
test the password entered by the user.  A username may be passed in via psz.  If 
psz is NULL, the currently logged in username will be used.  Retrieved strings are 
placed in global strings c_rgcDomain and c_rgcUser.

Inputs: WCHAR username string 

Call with NULL psz to use currently logged on username

Returns:    void

If function fails, the affected global string is set to empty string.
 
\****************************************************************************/
void GetNames(WCHAR *psz) 
{
    OSVERSIONINFOEXW versionInfo;
    BOOL fIsDC = FALSE;
    WCHAR *pName = NULL;
    DWORD dwStatus;
    DWORD dwcb;
    
    versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
    if (GetVersionEx((OSVERSIONINFO *)&versionInfo)) 
    {
        fIsDC = (versionInfo.wProductType == VER_NT_DOMAIN_CONTROLLER);
    }
    if (fIsDC)
    {
        dwStatus = NetpGetDomainName(&pName);
        if (dwStatus == NO_ERROR)
        {
            wcsncpy(c_rgcDomain,pName,UNLEN);
            c_rgcDomain[UNLEN] = 0;
            NetApiBufferFree(pName);
        }
        else c_rgcDomain[0] = 0;
    }
    else
    {
        dwStatus = NetpGetComputerName(&pName);
        if (dwStatus == NO_ERROR)
        {
            wcsncpy(c_rgcDomain,pName,UNLEN);
            c_rgcDomain[UNLEN] = 0;
            NetApiBufferFree(pName);
        }
        else c_rgcDomain[0] = 0;
    }
    if (psz)
    {
        wcsncpy(c_rgcUser,psz,UNLEN);
        c_rgcUser[UNLEN] = 0;
    }
    else 
    {
        dwcb = UNLEN + 1;
        GetUserNameW(c_rgcUser,&dwcb);
    }
#ifdef LOUDLY
    OutputDebugString(L"GetNames: ");
    OutputDebugString(c_rgcDomain);
    OutputDebugString(L" ");
    OutputDebugString(c_rgcUser);
    OutputDebugString(L"\n");
    OutputDebugString(L"Passed Username = ");
    if (psz)OutputDebugString(psz);
    OutputDebugString(L"\n");
#endif
}

#ifdef PASSWORDHINT
/**********************************************************************

SetUserHint() - Set the password hint on a local account by reference
to the username, to a string passed by WCHAR *

**********************************************************************/
HRESULT 
SetUserHint(LPCWSTR pszAccountName,LPCWSTR pszNewHint)
{
    HRESULT hr;
    ILogonEnumUsers *pUsers = NULL;
    VARIANT var;

    hr = CoCreateInstance(CLSID_ShellLogonEnumUsers,
                        NULL, 
                        CLSCTX_INPROC_SERVER,
                        IID_ILogonEnumUsers,
                        (void **) &pUsers);
    if (SUCCEEDED(hr))
    {
        ILogonUser       *pUser = NULL;
        
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString(pszAccountName);
        hr = pUsers->item(var,&pUser);
        if (SUCCEEDED(hr))
        {
            BSTR bstrHint = SysAllocString(L"Hint");
            VariantClear(&var);                 // free embedded bstr
            var.vt = VT_BSTR;
            var.bstrVal = SysAllocString(pszNewHint);
            hr = pUser->put_setting(bstrHint,var);
            // There is no fallback for failure to set the hint.  Just proceed.
            SysFreeString(bstrHint);
            pUser->Release();
        }
        VariantClear(&var);                 // free embedded bstr
        pUsers->Release();
    }
     return hr;
}
#endif

/**********************************************************************

SetAccountPassword() - Call the DPAPI password change function,  passing
the password blob from the reset disk by means of global variables.

**********************************************************************/
DWORD
SetAccountPassword(void) 
{
    DWORD dwErr = ERROR_FUNCTION_FAILED;

    CHECKPOINT(58,"Wizard: Restore - Set account password");
    c_pPrivate = 0;
    if (!ReadPrivateData(&c_pPrivate,&c_cbPrivate))
    {
        dwErr = GetLastError();
        goto cleanup;
    }
    
    if( (c_rgcUser[0]   == 0)) 
    {
        dwErr = LERROR_NO_ACCOUNT;
        goto cleanup;
    }
    
    dwErr = PRRecoverPassword(c_rgcUser,
                              c_pPrivate,
                              c_cbPrivate,
                              c_rgcPsw);

#ifdef PASSWORDHINT
    if (0 == dwErr)
    {
        INT_PTR icb = 0;
        WCHAR szHint[256];
        szHint[0] = 0;
        icb = SendMessage(c_hwndRP1E3,WM_GETTEXT,255,(LPARAM)szHint);
        SetUserHint(c_rgcUser,szHint);
    }
#endif
cleanup:
    // ensure that buffers are cleaned and released
    SecureZeroMemory(c_rgcPsw,sizeof(c_rgcPsw));
    if (NULL != c_pPrivate)
    {
        ReleaseFileBuffer((LPVOID) c_pPrivate);
    }
    c_pPrivate = NULL;
    return dwErr;
}

/****************************************************************************\

SaveInfo

Inputs: void, uses globals c_rgcUser, c_rgcPsw

Returns:  INT, returns nonzero if a password backup has been generated on the host
            machine, and a valid private blob has been generated and written to the
            target disk

\****************************************************************************/
INT
SaveInfo(void) 
{

    BOOL fError = TRUE;
    DWORD dwRet;
    BOOL fStatus = FALSE;
    BYTE *pPrivate = NULL;
    DWORD cbPrivate = 0;

    CHECKPOINT(50,"Wizard: Save - generating recovery data");
    c_hCursor = LoadCursor(g_hInstance,IDC_WAIT);
    c_hCursor = SetCursor(c_hCursor);

#ifdef LOUDLY
    OutputDebugString(L"SaveInfo: Username = ");
    OutputDebugString(c_rgcUser);
    OutputDebugString(L"\n");
#endif
#ifdef LOUDLY
    OutputDebugString(c_rgcUser);
    OutputDebugString(L" \\ ");
    OutputDebugString(c_rgcPsw);
    OutputDebugString(L"\n");
#endif

    dwRet = PRGenerateRecoveryKey(c_rgcUser,
                                  c_rgcPsw,
                                  &pPrivate,
                                  &cbPrivate);
#ifdef LOUDLY
    OutputDebugString(L"PRGenerateRecoveryKey returns\n");
#endif

if (ERROR_SUCCESS != dwRet) 
{
#ifdef LOUDLY
        OutputDebugString(L"GenerateRecoveryKey failed\n");
#endif
        goto cleanup;
    }

    if (!WritePrivateData(pPrivate,cbPrivate)) 
    {
#ifdef LOUDLY
    OutputDebugString(L"WriteOutputFile failed\n");
#endif
        CHECKPOINT(51,"Wizard: Save - write failed (disk full?)");
        // delete output file if created
        DeleteFile(pszFileName);
        goto cleanup;
    }
#if TESTAUDIT
    else
    {
        CHECKPOINT(55,"Wizard: Save - write to disk OK");
    }
#endif

    SetFileAttributes(pszFileName,FILE_ATTRIBUTE_READONLY);
    if (0 == cbPrivate)
    {
        goto cleanup;
    }

    fStatus = TRUE;
    fError = FALSE;
cleanup:
    // zero buffer of c_usPassword (our local psw buffer)
    SecureZeroMemory(c_rgcPsw,sizeof(c_rgcPsw));
    SecureZeroMemory(pPrivate,cbPrivate);
    
    if (fError) 
    {
        KillTimer(c_TimerAssociatedWindow,TIMERID);
        RMessageBox(c_hDlg,IDS_MBTERROR ,IDS_SERROR ,MB_ICONHAND);
        c_iTimer = SetTimer(c_TimerAssociatedWindow,TIMERID,TIMERPERIOD,NULL);
    }
//cleanupnomsg:
    if (fError) 
    {
        // delete output file
        if (g_hFile) 
        {
            CloseHandle(g_hFile);
            g_hFile = NULL;
            DeleteFile(pszFileName);
        }
    }
    if (NULL != g_hFile) 
    {
        CloseHandle(g_hFile);
        g_hFile = NULL;
    }
    LocalFree(pPrivate);
    return fStatus;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// WELCOME page proc doesn't have to do much
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

INT_PTR CALLBACK SPageProc0(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam)
{
   switch (message)
   {
       case WM_INITDIALOG:
           {
               TCHAR SBuf[TEMPSTRINGBUFSIZE];
               c_hDlg = hDlg;
               c_hwndSWelcome1 = GetDlgItem(hDlg,IDC_SWELCOME1);
               if (NULL != c_hTitleFont)
               {
                   SendMessage(c_hwndSWelcome1,WM_SETFONT,(WPARAM) c_hTitleFont,(LPARAM) TRUE);
               }
               LoadString(g_hInstance,IDS_SWELCOME1,SBuf,TEMPSTRINGBUFSIZE);
               SendMessage(c_hwndSWelcome1,WM_SETTEXT,0,(LPARAM)SBuf);
               c_hwndSWelcome2 = GetDlgItem(hDlg,IDC_SWELCOME2);
               LoadString(g_hInstance,IDS_SWELCOME2,SBuf,TEMPSTRINGBUFSIZE);
               SendMessage(c_hwndSWelcome2,WM_SETTEXT,0,(LPARAM)SBuf);
               break;
           }
       case WM_COMMAND:
           //if (HIWORD(wParam) == BN_CLICKED)
           //{
           //    // crack the incoming command messages
           //    INT NotifyId = HIWORD(wParam);
           //    INT ControlId = LOWORD(wParam);
           //}
           break;              

       case WM_NOTIFY:
           switch (((NMHDR FAR *) lParam)->code) 
           {

               case PSN_KILLACTIVE:
                   SetWindowLong(hDlg,DWLP_MSGRESULT, FALSE);
                   return 1;
                   break;

               case PSN_SETACTIVE:
                   // state following a BACK from the next page

                   CenterPage(GetParent(hDlg));

                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);
                   break;

               case PSN_RESET:
                   if (c_hTitleFont) DeleteObject(c_hTitleFont);
                   break;
               
               case PSN_WIZNEXT:
                   break;
                   
               default:
                   return FALSE;
           }
           break;

       default:
           return FALSE;
   }
   return TRUE;   
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// PAGE1 page proc, where the real work is done
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

DWORD c_iThread;
DWORD dwThreadReturn;

DWORD WINAPI SaveThread(LPVOID lpv) 
{
       c_bSaveComplete = FALSE;
       if (g_hFile == NULL) 
       {
           c_bSaveComplete = TRUE;
           dwThreadReturn = ERRNOFILE;
           return 2;
       }
       if (FALSE == SaveInfo()) 
       {
           if (g_hFile)
           {
               CloseHandle(g_hFile);
           }
           g_hFile = NULL;
           c_bSaveComplete = TRUE;
           dwThreadReturn = ERRSAVEERROR;
           return 1;
       }
       if (g_hFile)
       {
           CloseHandle(g_hFile);
       }
       g_hFile = NULL;
       c_bSaveComplete = TRUE;
       dwThreadReturn = ERRSUCCESS;
       return 0;
}

// Dialog procedure for the drive selection page.  This page is common to both the backup and
// restore wizards, with the instruction text being selected on the basis of which mode is being
// exercised.

INT_PTR CALLBACK SPageProcX(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam)
{
   INT i;
    
   switch (message)
   {
       case WM_INITDIALOG:
           {
              c_hwndDriveInstructions = GetDlgItem(hDlg,IDC_DRIVEINSTRUCTIONS);
              c_hwndDrivePrompt = GetDlgItem(hDlg,IDC_DRIVEPROMPT);
              c_hwndCBDriveList = GetDlgItem(hDlg,IDC_COMBO);
              if (1 == CountRemoveableDrives()) 
              {
                 if (c_fIsBackup) 
                 {
                     WCHAR temp[TEMPSTRINGBUFSIZE];
                     WCHAR *pc = RString(IDS_SONLYONEDRIVE);
                     swprintf(temp,pc,pszFileName[0]);
                     SendMessage(c_hwndDriveInstructions,WM_SETTEXT,0,(LPARAM)temp);
                 }
                 else
                 {
                     WCHAR temp[TEMPSTRINGBUFSIZE];
                     WCHAR *pc = RString(IDS_RONLYONEDRIVE);
                     swprintf(temp,pc,pszFileName[0]);
                     SendMessage(c_hwndDriveInstructions,WM_SETTEXT,0,(LPARAM)temp);
                 }
                  ShowWindow(c_hwndDrivePrompt,SW_HIDE);
                  ShowWindow(c_hwndCBDriveList,SW_HIDE);
              }
              else
              {
                  ShowRemoveableDrives();
              }
              break;
           }

       case WM_COMMAND:
           if (HIWORD(wParam) == BN_CLICKED)
           {
               i = LOWORD(wParam);
           }
           break;              

       case WM_NOTIFY:
           switch (((NMHDR FAR *) lParam)->code) 
           {

               case PSN_KILLACTIVE:
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   return 1;
                   break;

               case PSN_RESET:
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   if (c_hTitleFont)
                   {
                       DeleteObject(c_hTitleFont);
                   }
                   break;

               case PSN_SETACTIVE:
                   // Set data in the UI, Set up sequence buttons
                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);
                   break;
                       
               case PSN_WIZNEXT:

				   // take first character (drive letter) of the text associated with the 
				   // selected radio button and copy it to the filename in the drive
				   // letter position.
                    {
                        LRESULT lr;
                        INT iDrive = 0;
                        COMBOBOXEXITEM stCBItem = {0};
                        lr = SendMessage(c_hwndCBDriveList,CB_GETCURSEL,0,0);

                        // If combobox sel error, first drive
                        if (CB_ERR == lr)
                        {
                            iDrive = 0;
                        }
                        else 
                        {
                            stCBItem.mask = CBEIF_LPARAM;
                            stCBItem.iItem = lr;
                            lr = SendMessage(c_hwndCBDriveList,CBEM_GETITEM,0,(LPARAM)&stCBItem);
                            if (CB_ERR != lr)
                            {
                                iDrive = (INT) stCBItem.lParam;
                            }
                        }
                        pszFileName[0] = GetDriveLetter(iDrive);
                   }

                   CHECKPOINT(59,"Wizard: Both - Drive select page");
                   if (!c_fIsBackup) 
                   {
                       CHECKPOINT(60,"Wizard: Restore - drive select");
                       if (NULL == GetInputFile()) 
                       {
                           // failed to open file
                           SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_SPAGEXS);
                           return TRUE;
                       }
                   }
                   return FALSE;
                   break;

               default:
                   return FALSE;

           }
           break;

       default:
           return FALSE;
   }
   return TRUE;   
}

INT_PTR CALLBACK SPageProc1(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam)
{
   INT i;
    
   switch (message)
   {
       case WM_INITDIALOG:
           {
               HWND hC = GetDlgItem(hDlg,PSBTN_CANCEL);
               if (NULL != hC)
               {
                   ShowWindow(hC,SW_HIDE);
               }
               c_hwndSInstructions = GetDlgItem(hDlg,IDC_SINSTRUCTIONS);
               c_hwndSP1E1 = GetDlgItem(hDlg,IDC_SP1E1);
               LoadString(g_hInstance,IDS_SP1INSTRUCTIONS,Buf,TEMPSTRINGBUFSIZE);
               SendMessage(c_hwndSInstructions,WM_SETTEXT,0,(LPARAM)Buf);
               break;
           }

       case WM_COMMAND:
           if (HIWORD(wParam) == BN_CLICKED)
           {
               i = LOWORD(wParam);
           }
           break;              

       case WM_NOTIFY:
           switch (((NMHDR FAR *) lParam)->code) 
           {

               case PSN_KILLACTIVE:
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   return 1;
                   break;

               case PSN_RESET:
                   // reset data to the original values
                   SendMessage(c_hwndSP1E1,WM_SETTEXT,0,0);
                   //SendMessage(c_hwndSP1E2,WM_SETTEXT,0,0);
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   if (c_hTitleFont)
                   {
                       DeleteObject(c_hTitleFont);
                   }
                   break;

               case PSN_SETACTIVE:
                   // Set data in the UI, Set up sequence buttons
                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);
                   break;

               case PSN_WIZBACK:
                    CHECKPOINT(61,"Wizard: Save - back from enter old psw page");
                    break;
                    
               case PSN_WIZNEXT:
                {
                        //Fetch the data and process it - if FALSE, stay on this page
                        // allow null password
                        HANDLE hToken = NULL;
                        BOOL fPswOK = FALSE;

                        SendMessage(c_hwndSP1E1,WM_GETTEXT,PWLEN + 1,(LPARAM)c_rgcPsw);

                        fPswOK = LogonUser(c_rgcUser,c_rgcDomain,c_rgcPsw,
                                                LOGON32_LOGON_INTERACTIVE,
                                                LOGON32_PROVIDER_DEFAULT,
                                                &hToken);
                        if (hToken)
                        {
                            CloseHandle(hToken);
                        }

                        // Handle failure to verify the entered old password
                        if (!fPswOK)
                        {
                            // If the error was account restriction, and the user password
                            // is blank, that may account for the fail.  Skip informing the
                            // user and attempt the write anyway.
                            DWORD dwErr = GetLastError();
                            if ((ERROR_ACCOUNT_RESTRICTION != dwErr) || (wcslen(c_rgcPsw) != 0))
                            {
                                RMessageBox(c_hDlg,IDS_MBTWRONGPSW,IDS_WRONGPSW,MB_ICONHAND);
                                SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_SPAGE1);
                                return TRUE;
                            }
                        }

                        // Handle key file already present - overwrite?
                        if ( ExistsOldKey(c_rgcUser)) 
                        {
                            int k = RMessageBox(c_hDlg,IDS_MBTREPLACE ,IDS_OLDEXISTS ,MB_YESNO);
                            if (k != IDYES) 
                            {
                                SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_SPAGE1);
                                return TRUE;
                            }
                        }

                        // Handle can't create the output file
                        if (NULL == GetOutputFile()) 
                        {
                            SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_SPAGE1);
                            return TRUE;
                        }

                        // Handle not enough space
                        if (FILESPACENEEDED > GetDriveFreeSpace(pszFileName))
                        {
                            // if still not enough space, let go of the attempt to create an output file, 
                            //  or successive attempts will fail for a sharing violation
                            if (g_hFile) 
                            {
                                CloseHandle(g_hFile);
                                g_hFile = NULL;
                            }
                            RMessageBox(c_hDlg,IDS_MBTNOSPACE ,IDS_MBMNOSPACE ,MB_OK);
                            SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_SPAGE1);
                            return TRUE;
                        }
                        
                        // Conditions OK - create a thread to do the operation 
                        //  and generate timer events which march the progress bar
                        // SaveInfo() will zero the psw buffer
                        HANDLE hT = CreateThread(NULL,0,SaveThread,(LPVOID)NULL,0,&c_iThread);
                        if (NULL == hT)
                        {
                            // failed to launch the timer thread.
                            // Announce a nonspecific error
                            if (g_hFile) 
                            {
                                CloseHandle(g_hFile);
                                g_hFile = NULL;
                            }
                            RMessageBox(c_hDlg,IDS_MBTERROR ,IDS_SERROR ,MB_OK);
                            SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_SPAGE1);
                            return TRUE;
                        }
                        return FALSE;
                   }
                   break;

               default:
                   return FALSE;

           }
           break;

       default:
           return FALSE;
   }
   return TRUE;   
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// FINISH page proc - reach this page only on success?
//
// This page receives timer interrupts, advancing the progress bar at each one.  When c_bSaveComplete indicates
// that the operation is complete, it shuts off the timer and waits for the user to advance to the next page.
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
INT_PTR CALLBACK SPageProc2(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam)
{
   WCHAR Msg[200];
   WCHAR Tpl[200];
   Tpl[0] = 0;
   Msg[0] = 0;

   LoadString(g_hInstance,IDS_SPROGRESS,Tpl,200 -1);
   HWND hP = GetDlgItem(hDlg,IDC_SPROGRESS);
   
   switch (message)
   {
       case WM_TIMER:
           // advance the progress bar
           SendMessage(c_hProgress,PBM_STEPIT,0,0);
           c_iProg += 5;
           if (100 <= c_iProg)
           {
               c_iProg = 95;
           }
           // Stop advancing when c_bSaveComplete is nonzero, and
           if (c_bSaveComplete) 
           {
               KillTimer(hDlg,TIMERID);
               c_iTimer =0;
               SecureZeroMemory(c_rgcPsw,sizeof(c_rgcPsw));
               if (dwThreadReturn == ERRSUCCESS) 
               {
                   // set text to indicate complete
                   SendMessage(c_hProgress,PBM_SETPOS,100,0);
                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);
                   c_iProg = 100;
               }
               else 
               {
                   SendMessage(c_hProgress,PBM_SETPOS,0,0);
                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK);
                   c_iProg = 0;
               }
           }
           swprintf(Msg,Tpl,c_iProg);
           if (hP)
           {
               SendMessage(hP,WM_SETTEXT,0,(LPARAM)Msg);
           }
           break;
            
       case WM_INITDIALOG:
           {
               // instead of starting the timer here, do it on the set active
               //  notification, since the init is not redone if you rearrive at
               //  this page after an error.
               c_hProgress = GetDlgItem(hDlg,IDC_PROGRESS1);
               break;
           }

       case WM_COMMAND:
            break;              

       case WM_NOTIFY:
           switch (((NMHDR FAR *) lParam)->code) 
           {
               case PSN_KILLACTIVE:
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   return 1;
                   break;

               case PSN_RESET:
                   SecureZeroMemory(c_rgcPsw,sizeof(c_rgcPsw));
                   // rest to the original values
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   if (c_hTitleFont)
                   {
                       DeleteObject(c_hTitleFont);
                   }
                   break;

               case PSN_SETACTIVE:
                   PropSheet_SetWizButtons(GetParent(hDlg),0);
                   PropSheet_CancelToClose(GetParent(hDlg));
                   SendMessage(c_hProgress,PBM_SETSTEP,5,0);
                   SendMessage(c_hProgress,PBM_SETPOS,0,0);
                   // Start a timer
                   c_iTimer = 0;
                   c_iProg = 0;
                   c_iTimer = SetTimer(hDlg,TIMERID,TIMERPERIOD,NULL);
                   c_TimerAssociatedWindow = hDlg;
                   // Set controls to state indicated by data
                   // Set BACK/FINISH instead of BACK/NEXT
                   break;

               case PSN_WIZBACK:
                   break;


               case PSN_WIZNEXT:
                   // Done
                  SecureZeroMemory(c_rgcPsw,sizeof(c_rgcPsw));
                  if (c_iTimer)
                  {
                      KillTimer(hDlg,TIMERID);
                  }
                  c_iTimer = 0;
                  break;

               default:
                   return FALSE;
           }
           break;

       default:
           return FALSE;
   }
   return TRUE;   
}

INT_PTR CALLBACK SPageProc3(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam)
{
   
   switch (message)
   {
       case WM_INITDIALOG:
           {
               // instead of starting the timer here, do it on the set active
               //  notification, since the init is not redone if you rearrive at
               //  this page after an error.
               c_hwndSFinish1 = GetDlgItem(hDlg,IDC_SFINISH1);
               c_hwndSFinish2 = GetDlgItem(hDlg,IDC_SFINISH2);
               if (NULL != c_hTitleFont) 
               {
                   SendMessage(c_hwndSFinish1,WM_SETFONT,(WPARAM) c_hTitleFont,(LPARAM) TRUE);     
               }
               LoadString(g_hInstance,IDS_SFINISH1,Buf,TEMPSTRINGBUFSIZE);
               SendMessage(c_hwndSFinish1,WM_SETTEXT,0,(LPARAM)Buf);
               PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_FINISH);
               LoadString(g_hInstance,IDS_SFINISH2,Buf,TEMPSTRINGBUFSIZE);
               SendMessage(c_hwndSFinish2,WM_SETTEXT,0,(LPARAM)Buf);
               break;
           }

       case WM_COMMAND:
           break;              

       case WM_NOTIFY:
           switch (((NMHDR FAR *) lParam)->code) 
           {
               case PSN_KILLACTIVE:
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   return 1;
                   break;

               case PSN_RESET:
                   // reset to the original values
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   if (c_hTitleFont)
                   {
                       DeleteObject(c_hTitleFont);
                   }
                   break;

               case PSN_SETACTIVE:
                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_FINISH);
                   PropSheet_CancelToClose(GetParent(hDlg));
                   break;

               case PSN_WIZBACK:
                   break;


               case PSN_WIZFINISH:
                   // Done
                   SecureZeroMemory(c_rgcPsw,sizeof(c_rgcPsw));
                   if (c_hTitleFont)
                   {
                       DeleteObject(c_hTitleFont);
                   }
                   break;

               default:
                   return FALSE;
           }
           break;

       default:
           return FALSE;
   }
   return TRUE;   
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// WELCOME page proc doesn't have to do much
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

INT_PTR CALLBACK RPageProc0(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam)
{
   switch (message)
   {
       case WM_INITDIALOG:
           {
               c_hDlg = hDlg;
               c_hwndRWelcome1 = GetDlgItem(hDlg,IDC_RWELCOME1);
               if (NULL != c_hTitleFont) 
               {
                   SendMessage(c_hwndRWelcome1,WM_SETFONT,(WPARAM) c_hTitleFont,(LPARAM) TRUE);
               }
               LoadString(g_hInstance,IDS_RWELCOME1,Buf,TEMPSTRINGBUFSIZE);
               SendMessage(c_hwndRWelcome1,WM_SETTEXT,0,(LPARAM)Buf);
               c_hwndRWelcome2 = GetDlgItem(hDlg,IDC_RWELCOME2);
               LoadString(g_hInstance,IDS_RWELCOME2,Buf,TEMPSTRINGBUFSIZE);
               SendMessage(c_hwndRWelcome2,WM_SETTEXT,0,(LPARAM)Buf);
               break;
           }
       case WM_COMMAND:
           //if (HIWORD(wParam) == BN_CLICKED)
           //{
           //    // crack the incoming command messages
           //    INT NotifyId = HIWORD(wParam);
           //    INT ControlId = LOWORD(wParam);
           //}
           break;              

       case WM_NOTIFY:
           switch (((NMHDR FAR *) lParam)->code) 
           {

               case PSN_KILLACTIVE:
                   SetWindowLong(hDlg,DWLP_MSGRESULT, FALSE);
                   return 1;
                   break;

               case PSN_SETACTIVE:
                   // state following a BACK from the next page
               
                   CenterPage(GetParent(hDlg));
                   CloseInputFile();  
                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);
                   break;

               case PSN_WIZNEXT:
                    break;
                   
               case PSN_RESET:
                   if (c_hTitleFont) DeleteObject(c_hTitleFont);
                   break;
               
               default:
                   return FALSE;
           }
           break;

       default:
           return FALSE;
   }
   return TRUE;   
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// PAGE1 page proc, where the real work is done
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

INT_PTR CALLBACK RPageProc1(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam)
{
    INT i;
    
   switch (message)
   {
       case WM_INITDIALOG:
           {
               Buf[0] = 0;
               c_hwndRInstructions = GetDlgItem(hDlg,IDC_RINSTRUCTIONS);
               c_hwndRP1E1 = GetDlgItem(hDlg,IDC_RP1E1);
               c_hwndRP1E2 = GetDlgItem(hDlg,IDC_RP1E2);
               c_hwndRP1E3 = GetDlgItem(hDlg,IDC_RP1E3);
               LoadString(g_hInstance,IDS_RP1INSTR,Buf,TEMPSTRINGBUFSIZE);
               SendMessage(c_hwndRInstructions,WM_SETTEXT,0,(LPARAM)Buf);
               break;
           }

       case WM_COMMAND:
           if (HIWORD(wParam) == BN_CLICKED)
           {
               i = LOWORD(wParam);
           }
           break;              

       case WM_NOTIFY:
           switch (((NMHDR FAR *) lParam)->code) 
           {
               DWORD dwRet;

               case PSN_KILLACTIVE:
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   return 1;
                   break;

               case PSN_RESET:
                   // reset data to the original values
                   free(c_pPrivate);
                   c_pPrivate = NULL;
                   SecureZeroMemory(c_rgcPsw,sizeof(c_rgcPsw));
                   SendMessage(c_hwndRP1E1,WM_SETTEXT,0,0);
                   SendMessage(c_hwndRP1E2,WM_SETTEXT,0,0);
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   if (c_hTitleFont) 
                   {
                       DeleteObject(c_hTitleFont);
                   }
                   CloseInputFile();
                   g_hFile = NULL;
                   break;

               case PSN_SETACTIVE:
                   // Set data in the UI, Set up sequence buttons
                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);
                   break;

               case PSN_WIZBACK:
                   CHECKPOINT(62,"Wizard: Restore - BACK from enter new psw data page");
                   CloseInputFile();
                   return FALSE;
                   break;
                   
                case PSN_WIZNEXT:
                   //Fetch the data and process it
                   if (!FetchPsw(c_hwndRP1E1,c_hwndRP1E2)) 
                   {
                       // psw buffers empty if you get here - FetchPsw will have told
                       //  the user what to do
                       SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_RPAGE1);
                       return TRUE;
                   }
                   
                   // SetAccountPassword will clean the psw buffers
                   dwRet = SetAccountPassword();
                   if (ERROR_SUCCESS == dwRet) 
                   {
                       return FALSE;
                   }
                   //else if (NERR_PasswordTooShort == dwRet) {
                   else if (
                    (STATUS_ILL_FORMED_PASSWORD == dwRet) ||
                    (STATUS_PASSWORD_RESTRICTION == dwRet)) 
                   {
                       // Password doesn't conform - try again
                       RMessageBox(hDlg,IDS_MBTINVALIDPSW,IDS_RPSWTOOSHORT,MB_ICONHAND);
                       SendMessage(c_hwndRP1E1,WM_SETTEXT,0,(LPARAM)0);
                       SendMessage(c_hwndRP1E2,WM_SETTEXT,0,(LPARAM)0);
                       SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_RPAGE1);
                       return TRUE;
                   }
                   else if (NTE_BAD_DATA == dwRet)
                   {
                       // ya might get this using an obsolete disk?
                       free(c_pPrivate);
                       c_pPrivate = NULL;
                       RMessageBox(hDlg,IDS_MBTINVALIDDISK ,IDS_RPSWERROR ,MB_ICONHAND);
                       SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_RWELCOME);
                       return TRUE;
                   }
                   else 
                   {
                       RMessageBox(hDlg,IDS_MBTERROR,IDS_RPSWUNSPEC,MB_ICONHAND);
                       SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_RWELCOME);
                       return TRUE;
                   }
                   return FALSE;
                   break;

               default:
                   return FALSE;

           }
           break;

       default:
           return FALSE;
   }
   return TRUE;   
}


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// FINISH page proc - reach this page only on success?
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

INT_PTR CALLBACK RPageProc2(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam)
{
    INT i;
    
   switch (message)
   {
       case WM_INITDIALOG:
           CloseInputFile();
           c_hwndRFinish1 = GetDlgItem(hDlg,IDC_RFINISH1);
           if (NULL != c_hTitleFont)
           {
               SendMessage(c_hwndRFinish1,WM_SETFONT,(WPARAM) c_hTitleFont,(LPARAM) TRUE);
           }
           LoadString(g_hInstance,IDS_RFINISH1,Buf,TEMPSTRINGBUFSIZE);
           SendMessage(c_hwndRFinish1,WM_SETTEXT,0,(LPARAM)Buf);
           c_hwndRFinish2 = GetDlgItem(hDlg,IDC_RFINISH2);
           LoadString(g_hInstance,IDS_RFINISH2,Buf,TEMPSTRINGBUFSIZE);
           SendMessage(c_hwndRFinish2,WM_SETTEXT,0,(LPARAM)Buf);
           break;

       case WM_COMMAND:
           if (HIWORD(wParam) == BN_CLICKED)
           {
               i = LOWORD(wParam);
           }
           break;              

       case WM_NOTIFY:
           switch (((NMHDR FAR *) lParam)->code) 
           {
               case PSN_KILLACTIVE:
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   return 1;
                   break;

               case PSN_RESET:
                   // rest to the original values
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   if (c_hTitleFont)
                   {
                       DeleteObject(c_hTitleFont);
                   }
                   break;

               case PSN_SETACTIVE:
                   CloseInputFile();
                   // Set controls to state indicated by data
                   // Set BACK/FINISH instead of BACK/NEXT
                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_FINISH);
                   PropSheet_CancelToClose(GetParent(hDlg));
                   break;

                case PSN_WIZBACK:
                    break;


                case PSN_WIZFINISH:
                    // Done
                   if (c_hTitleFont)
                   {
                       DeleteObject(c_hTitleFont);
                   }
                   break;

               default:
                   return FALSE;
       }
       break;

       default:
           return FALSE;
   }
   return TRUE;   
}

/////////////////////////////////////////////////////////////////////////
// 
// Common Routines for all pages


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void InitPropertyPage( PROPSHEETPAGE* psp,
                       INT idDlg,
                       DLGPROC pfnDlgProc,
                       DWORD dwFlags,
                       LPARAM lParam)
{
    memset((LPVOID)psp,0,sizeof(PROPSHEETPAGE));
    psp->dwFlags = dwFlags;
    psp->pszTemplate = MAKEINTRESOURCE(idDlg);
    psp->pfnDlgProc = pfnDlgProc;
    psp->dwSize = sizeof(PROPSHEETPAGE);
    psp->hInstance = g_hInstance;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Set the text for title and subtitle for Wizard97 style pages
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void SetPageHeaderText(PROPSHEETPAGE *psp,
                       INT iTitle,
                       INT iSubTitle)
{
    if (0 != (psp->dwFlags & PSP_HIDEHEADER))
    {
        return;
    }
    if (0 != iTitle) 
    {
        psp->pszHeaderTitle = MAKEINTRESOURCE(iTitle);
        psp->dwFlags |= PSP_USEHEADERTITLE;
    }
    if (0 != iSubTitle) 
    {
        psp->pszHeaderSubTitle = MAKEINTRESOURCE(iSubTitle);
        psp->dwFlags |= PSP_USEHEADERSUBTITLE;
    }
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Set the page's title bar caption
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void SetPageCaption(PROPSHEETPAGE *psp,
                    INT iTitle)
{
    if (0 != iTitle) 
    {
        psp->pszTitle = MAKEINTRESOURCE(iTitle);
        psp->dwFlags |= PSP_USETITLE;
    }
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// PRShow[Save|Restore]Wizard()
//
//  Pass the HWND of the owning window, and pass the instance handle of
//  the enclosing binary, for the purpose of locating resources
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void APIENTRY PRShowSaveWizardW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    PROPSHEETPAGE psp[NUMSAVEPAGES];
    HPROPSHEETPAGE hpsp[NUMSAVEPAGES];
    PROPSHEETHEADER psh;
    INT_PTR iRet;

    CHECKPOINT(63,"Wizard: Save - Show from nusrmgr.cpl");
    // do not allow this operation if no drives available
    if (0 == CountRemoveableDrives()) 
    {
        RMessageBox(hwndOwner,IDS_MBTNODRIVE,IDS_MBMNODRIVE,MB_ICONHAND);
        return;
    }

    if (NULL == hwndOwner) 
    {
        hwndOwner = GetForegroundWindow();
    }
    
    HANDLE hMutex = CreateMutex(NULL,TRUE,TEXT("PRWIZARDMUTEX"));
    if (NULL == hMutex) 
    {
        return;
    }
    if (ERROR_ALREADY_EXISTS == GetLastError()) 
    {
        CloseHandle(hMutex);
        return;
    }
    c_fIsBackup = TRUE;
    
    c_hTitleFont = CreateFontY(TEXT("MS Shell Dlg"),FW_BOLD,12);
#ifdef LOUDLY
    if (NULL == c_hTitleFont) OutputDebugString(L"Title font missing\n");
    if (NULL == hwndOwner) OutputDebugString(L"Owner window handle missing\n");
#endif

    InitPropertyPage( &psp[0], IDD_SWELCOME, SPageProc0, PSP_HIDEHEADER,0);
    InitPropertyPage( &psp[1], IDD_SPAGEXS  , SPageProcX, PSP_DEFAULT   ,0);
    InitPropertyPage( &psp[2], IDD_SPAGE1  , SPageProc1, PSP_DEFAULT   ,0);
    InitPropertyPage( &psp[3], IDD_SPAGE2  , SPageProc2, PSP_DEFAULT, 0);
    InitPropertyPage( &psp[4], IDD_SFINISH , SPageProc3, PSP_HIDEHEADER,0);
    
    SetPageHeaderText(&psp[1], IDS_SPXTITLE,IDS_SPXSUBTITLE);
    SetPageHeaderText(&psp[2], IDS_SP1TITLE,IDS_SP1SUBTITLE);
    SetPageHeaderText(&psp[3], IDS_SP2TITLE,IDS_SP2SUBTITLE);

    for (INT j=0;j<NUMSAVEPAGES;j++)
    {
         hpsp[j] = CreatePropertySheetPage((LPCPROPSHEETPAGE) &psp[j]);
    }
    
    psh.dwSize         = sizeof(PROPSHEETHEADER);
    psh.dwFlags        = PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
    psh.hwndParent     = hwndOwner;
    psh.pszCaption     = RString(IDS_BACKUPCAPTION);
    psh.nPages         = NUMSAVEPAGES;
    psh.nStartPage     = 0;
    psh.phpage           = (HPROPSHEETPAGE *) hpsp;
    psh.pszbmWatermark = MAKEINTRESOURCE(IDB_WATERMARK);
    psh.pszbmHeader    = MAKEINTRESOURCE(IDB_TITLE);
    psh.hInstance      = g_hInstance;

    // modal property sheet
    SetErrorMode(0);
    iRet = PropertySheet(&psh);
#ifdef LOUDLY
    if (iRet < 0) 
    {
        WCHAR sz[200];
        DWORD dwErr = GetLastError();
        swprintf(sz,L"PropertySheet() failed : GetLastError() returns: %d\n",dwErr);
        OutputDebugString(sz);
    }
#endif
    if (c_hTitleFont) 
    {
        DeleteObject (c_hTitleFont);
    }
    if (hMutex) 
    {
        CloseHandle(hMutex);
    }
     return;
}

void APIENTRY PRShowRestoreWizardW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    PROPSHEETPAGE psp[NUMRESTOREPAGES];
    HPROPSHEETPAGE hpsp[NUMRESTOREPAGES];
    PROPSHEETHEADER psh;
    INT_PTR iRet;
    BOOL fICC;

    CHECKPOINT(64,"Wizard: Restore - show restore wizard from nusrmgr.cpl");
    if (NULL == hwndOwner) 
    {
        hwndOwner = GetActiveWindow();
    }
    
    if (0 == CountRemoveableDrives()) 
    {
        RMessageBox(hwndOwner,IDS_MBTNODRIVE,IDS_MBMNODRIVE,MB_ICONHAND);
        return;
    }
    INITCOMMONCONTROLSEX stICC;

    OleInitialize(NULL);

    // Initialize common controls in two steps
    stICC.dwSize = sizeof(INITCOMMONCONTROLSEX);
    stICC.dwICC = ICC_WIN95_CLASSES | ICC_DATE_CLASSES | ICC_USEREX_CLASSES;
    fICC = InitCommonControlsEx(&stICC);
#ifdef LOUDLY
    if (fICC) OutputDebugString(L"Common control init 2 OK\n");
    else OutputDebugString(L"Common control init 2 FAILED\n");
#endif

    stICC.dwSize = sizeof(INITCOMMONCONTROLSEX);
    stICC.dwICC =  ICC_WINLOGON_REINIT;
    fICC = InitCommonControlsEx(&stICC);
#ifdef LOUDLY
    if (fICC) OutputDebugString(L"Common control init 1 OK\n");
    else OutputDebugString(L"Common control init 1 FAILED\n");
#endif
    c_fIsBackup = FALSE;
    GetNames(pszCmdLine);         // If name is null, get current user (debug/test use)

    c_hTitleFont = CreateFontY(TEXT("MS Shell Dlg"),FW_BOLD,12);
#ifdef LOUDLY
    if (NULL == c_hTitleFont) OutputDebugString(L"Title font missing\n");
    if (NULL == hwndOwner) OutputDebugString(L"Owner window handle missing\n");
#endif

    InitPropertyPage( &psp[0], IDD_RWELCOME, RPageProc0,PSP_HIDEHEADER,0);
    InitPropertyPage( &psp[1], IDD_SPAGEXR  , SPageProcX,PSP_DEFAULT   ,0);
    InitPropertyPage( &psp[2], IDD_RPAGE1  , RPageProc1,PSP_DEFAULT   ,0);
    InitPropertyPage( &psp[3], IDD_RFINISH , RPageProc2,PSP_HIDEHEADER,0);
    
    SetPageHeaderText(&psp[1], IDS_RPXTITLE,IDS_RPXSUBTITLE);
    SetPageHeaderText(&psp[2], IDS_RP1TITLE,IDS_RP1SUBTITLE);
    
    for (INT j=0;j<NUMRESTOREPAGES;j++)
    {
        hpsp[j] = CreatePropertySheetPage((LPCPROPSHEETPAGE) &psp[j]);
    }
    
    psh.dwSize         = sizeof(PROPSHEETHEADER);
    psh.dwFlags        = PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
    psh.hwndParent     = hwndOwner;
    psh.pszCaption     = RString(IDS_RESTORECAPTION);
    psh.nPages         = NUMRESTOREPAGES;
    psh.nStartPage     = 0;
    psh.phpage         = (HPROPSHEETPAGE *) hpsp;
    psh.pszbmWatermark  = MAKEINTRESOURCE(IDB_WATERMARK);
    psh.pszbmHeader    = MAKEINTRESOURCE(IDB_TITLE);
    psh.hInstance      = g_hInstance;

    iRet = PropertySheet(&psh);
#ifdef LOUDLY
    if (iRet < 0) 
    {
        WCHAR sz[200];
        DWORD dwErr = GetLastError();
        swprintf(sz,L"PropertySheet() returns %x: GetLastError() returns: %d\n", iRet, dwErr);
        OutputDebugString(sz);
    }
#endif
    if (c_hTitleFont)
    {
        DeleteObject (c_hTitleFont);
    }
    OleUninitialize();
    return;
}

// ==================================
//
// These are the real exports from KEYMGR:

// PRShowSaveWizardExW - call from cpl applet, passing window title as pszCmdLine
// PRShowSaveFromMsginaW - call from MSGINA, passing username as pszCmdLine
// PRShowRestoreWizardExW - call from cpl applet, passing username as pszCmdLine
// PRShowRestoreFromMsginaW - call from MSGINA, passing username as pszCmdLine

// This export was added so that the backup wizard could be called from the system context
// (in which msgina runs).  The username is taken from the UI and passed into the wizard,
// which uses it to create the backup key for that account.
//
// The global username string, c_rgcUser, is normally a null string until it is set by either
// getting the current logged user, or matching the SID found in a backup key.  This api
// prestuffs that value.  When it is found non-null, then GetUsernameW() is not called in 
// SaveInfo() where the backup is made.

void APIENTRY PRShowSaveWizardExW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
#ifdef LOUDLY
    OutputDebugString(L"\n\n\n");
#endif
    BOOL fICC;
    if (0 == CountRemoveableDrives()) 
    {
        RMessageBox(hwndOwner,IDS_MBTNODRIVE,IDS_MBMNODRIVE,MB_ICONHAND);
        return;
    }
    INITCOMMONCONTROLSEX stICC;
    stICC.dwSize = sizeof(INITCOMMONCONTROLSEX);
    stICC.dwICC = ICC_WIN95_CLASSES | ICC_USEREX_CLASSES;
    OleInitialize(NULL);
    fICC = InitCommonControlsEx(&stICC);
#ifdef LOUDLY
        if (fICC) OutputDebugString(L"Common control init OK\n");
        else OutputDebugString(L"Common control init FAILED\n");
#endif
    // String passed in for this function is the window title for the user mgr.
    // To get current logged user, call GetNames with NULL arg.
    GetNames(NULL);

    if (pszCmdLine != NULL) 
    {
#ifdef LOUDLY
            OutputDebugString(L"*********");
            OutputDebugString(pszCmdLine);
            OutputDebugString(L"\n");
#endif
            hwndOwner = FindWindow(L"HTML Application Host Window Class",pszCmdLine);
    }
#ifdef LOUDLY
    else OutputDebugString(L"NULL passed in pszCmdLine\n");
#endif
    PRShowSaveWizardW(hwndOwner,NULL,NULL,NULL);
    OleUninitialize();
    return;
}

void APIENTRY PRShowSaveFromMsginaW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    BOOL fICC;
    INITCOMMONCONTROLSEX stICC;

    CHECKPOINT(56,"Wizard: Save - show from msgina");
    stICC.dwSize = sizeof(INITCOMMONCONTROLSEX);
    stICC.dwICC = ICC_WINLOGON_REINIT;
    OleInitialize(NULL);
    fICC = InitCommonControlsEx(&stICC);
#ifdef LOUDLY
        if (fICC) OutputDebugString(L"Common control init OK\n");
        else OutputDebugString(L"Common control init FAILED\n");
#endif
    GetNames(pszCmdLine);
    PRShowSaveWizardW(hwndOwner,g_hInstance,NULL,NULL);
    OleUninitialize();
    return;
}

//These wrapper functions are supposed to rationalize the arguments coming in from two different calling
// environments.  As it turns out, this is not necessary on the restore case, and these turn out to be 
// identical.  In fact, the friendly logon ui calls PRShowRestoreWizardW directly.  PRShowRestoreWizardExW
// is left in so as not to change an existing interface.

void APIENTRY PRShowRestoreWizardExW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    if (NULL == hwndOwner) hwndOwner = GetActiveWindow();
    PRShowRestoreWizardW(hwndOwner,NULL,pszCmdLine,NULL);
    return;
}

void APIENTRY PRShowRestoreFromMsginaW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    CHECKPOINT(57,"Wizard: Restore - Show from msgina");
    if (NULL == hwndOwner) hwndOwner = GetActiveWindow();
    PRShowRestoreWizardW(hwndOwner,NULL,pszCmdLine,NULL);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\keymgr\wizres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wizard.RC
//
#define IDD_SWELCOME           551
#define IDD_SPAGEXS             559
#define IDD_SPAGEXR             560
#define IDD_SPAGE1             552
#define IDD_SFINISH            553
#define IDD_RWELCOME           554
#define IDD_RPAGE1             555
#define IDD_RFINISH            556
#define IDD_RBACKUP            557
#define IDD_PROGRESS           558
#define IDD_SPAGE2              561

#define IDC_SWELCOME1          1501
#define IDC_SWELCOME2          1502
#define IDC_SINSTRUCTIONS      1503
#define IDC_SP1E1              1504
#define IDC_SP1E2              1505
#define IDC_SFINISH1           1506
#define IDC_SFINISH2           1507
#define IDC_RWELCOME1          1508
#define IDC_RWELCOME2          1509
#define IDC_RINSTRUCTIONS      1510
#define IDC_RP1E1              1511
#define IDC_RP1E2              1512
#define IDC_RP1E3              1525
#define IDC_RFINISH1           1513
#define IDC_RFINISH2           1514
#define IDC_RBACKUP            1515
#define IDC_PROGRESS1         1516
#define IDC_SCOMBO            1517
#define IDC_RCOMBO            1518
#define IDC_COMBO             1521
#define IDC_DRIVEPROMPT      1519
#define IDC_DRIVEINSTRUCTIONS 1523
#define IDC_SPROGRESS         1524

#define IDS_SWELCOME1          651
#define IDS_SWELCOME2          652
#define IDS_SP1INSTRUCTIONS    653
#define IDS_SP1TITLE           654
#define IDS_SP1SUBTITLE        655
#define IDS_SFINISH1           656
#define IDS_SFINISH2           657
#define IDS_RWELCOME1          658
#define IDS_RWELCOME2          659
#define IDS_RP1TITLE           661
#define IDS_RP1SUBTITLE        662
#define IDS_RBTITLE            665
#define IDS_RBSUBTITLE         666
#define IDS_RBACKUP            667
#define IDS_RFINISH1           663
#define IDS_RFINISH2           664
#define IDS_RP1INSTR          668
#define IDS_BADPSW             670
#define IDS_RFFILEMISSING      673
#define IDS_SERROR             674
#define IDS_RERROR             675
#define IDS_RPSWERROR          676
#define IDS_NOPSW              677
#define IDS_OLDEXISTS          678
#define IDS_ENCRYPTED          679
#define IDS_NOTREMOVEABLE      680
#define IDS_RPSWTOOSHORT       682
#define IDS_RPSWUNSPEC         683
#define IDS_RPSWDENIED         684
#define IDS_SACCTTYPE          685
#define IDS_WRONGPSW           686
#define IDS_SFINISH1A          687
#define IDS_SFINISH2A          688
#define IDS_RPSWINVALID        689
#define IDS_RPSWNOACCOUNT      690
#define IDS_SDRIVEINSTRUCTIONS  691
#define IDS_SPXTITLE              692
#define IDS_SPXSUBTITLE          693
#define IDS_RDRIVEINSTRUCTIONS  694
#define IDS_RPXTITLE              695
#define IDS_RPXSUBTITLE          696
#define IDS_SP1RETRY             697
#define IDS_SP1RETRYTITLE        698
#define    IDS_BACKUPCAPTION    699
#define    IDS_RESTORECAPTION    700
#define    IDS_MBTINVALIDPSW    701
#define    IDS_MBTMISSINGPSW    702
#define    IDS_MBMWRONGDISK    703
#define    IDS_MBTWRONGDISK     704
#define    IDS_MBMDISKERROR     705
#define    IDS_MBTDISKERROR      706
#define    IDS_MBMNODISK         707
#define    IDS_MBTNODISK         708
#define    IDS_MBMOVERWRITE     709
#define    IDS_MBTOVERWRITE     710
#define    IDS_MBTNOACCOUNT     711
#define    IDS_MBTERROR          712
#define    IDS_MBTREPLACE        713
#define    IDS_MBTWRONGPSW     714
#define    IDS_MBTINVALIDDISK    715
#define    IDS_MBTFORMAT        716
#define    IDS_MBMFORMAT        717
#define    IDS_SDRIVEPROMPT     718
#define    IDS_RDRIVEPROMPT     719
#define    IDS_MBTNODRIVE       720
#define    IDS_MBMNODRIVE       721
#define    IDS_SONLYONEDRIVE    722
#define    IDS_RONLYONEDRIVE    723
#define    IDS_SP2TITLE          724
#define    IDS_SP2SUBTITLE       725
#define    IDS_SPROGRESS         726
#define    IDS_FMBMNODISK        727
#define    IDS_MBTNOSPACE         728
#define    IDS_MBMNOSPACE        729

#define IDB_TITLE              451
#define IDB_WATERMARK          452

//#define IDC_STATIC             -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\client\austub.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    austub.c

Abstract:

    Local Security Authority AUTHENTICATION service client stubs.

Author:

    Jim Kelly (JimK) 20-Feb-1991

Environment:   Kernel or User Modes

Revision History:

--*/

#include "lsadllp.h"
#include <string.h>
#include <zwapi.h>

#ifdef _NTSYSTEM_
//
// Unfortunately the security header files are just not at all constructed
// in a manner compatible with kernelmode. For some reason they are totally
// reliant on usermode header definitions. Just assume the text and const
// pragma's will work. If they don't work on an architecture, they can be
// fixed.
//
#pragma alloc_text(PAGE,LsaFreeReturnBuffer)
#pragma alloc_text(PAGE,LsaRegisterLogonProcess)
#pragma alloc_text(PAGE,LsaConnectUntrusted)
#pragma alloc_text(PAGE,LsaLookupAuthenticationPackage)
#pragma alloc_text(PAGE,LsaLogonUser)
#pragma alloc_text(PAGE,LsaCallAuthenticationPackage)
#pragma alloc_text(PAGE,LsaDeregisterLogonProcess)
//#pragma const_seg("PAGECONST")
#endif //_NTSYSTEM_

const WCHAR LsapEvent[] = L"\\SECURITY\\LSA_AUTHENTICATION_INITIALIZED";
const WCHAR LsapPort[] = L"\\LsaAuthenticationPort";


NTSTATUS
LsaFreeReturnBuffer (
    IN PVOID Buffer
    )


/*++

Routine Description:

    Some of the LSA authentication services allocate memory buffers to
    hold returned information.  This service is used to free those buffers
    when no longer needed.

Arguments:

    Buffer - Supplies a pointer to the return buffer to be freed.

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

    Others - returned by NtFreeVirtualMemory().

--*/

{

    NTSTATUS Status;
    ULONG_PTR Length;

    Length = 0;
    Status = ZwFreeVirtualMemory(
                 NtCurrentProcess(),
                 &Buffer,
                 &Length,
                 MEM_RELEASE
                 );

    return Status;
}


NTSTATUS
LsaRegisterLogonProcess(
    IN PSTRING LogonProcessName,
    OUT PHANDLE LsaHandle,
    OUT PLSA_OPERATIONAL_MODE SecurityMode
    )

/*++

Routine Description:

    This service connects to the LSA server and verifies that the caller
    is a legitimate logon process. this is done by ensuring the caller has
    the SeTcbPrivilege privilege. It also opens the caller's process for
    PROCESS_DUP_HANDLE access in anticipation of future LSA authentication
    calls.

Arguments:

    LogonProcessName  - Provides a name string that identifies the logon
        process.  This should be a printable name suitable for display to
        administrators.  For example, "User32LogonProces" might be used
        for the windows logon process name.  No check is made to determine
        whether the name is already in use.  This name must NOT be longer
        than 127 bytes long.

    LsaHandle - Receives a handle which must be provided in future
        authenticaiton services.

    SecurityMode - The security mode the system is running under.  This
        value typically influences the logon user interface.  For example,
        a system running with password control will prompt for username
        and passwords before bringing up the UI shell.  One running without
        password control would typically automatically bring up the UI shell
        at system initialization.

Return Value:

    STATUS_SUCCESS - The call completed successfully.

    STATUS_PRIVILEGE_NOT_HELD  - Indicates the caller does not have the
        privilege necessary to act as a logon process.  The SeTcbPrivilege
        privilege is needed.


    STATUS_NAME_TOO_LONG - The logon process name provided is too long.

--*/

{
    NTSTATUS Status, IgnoreStatus;
    UNICODE_STRING PortName, EventName;
    LSAP_AU_REGISTER_CONNECT_INFO ConnectInfo;
    ULONG ConnectInfoLength;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE EventHandle;


    //
    // Validate input parameters
    //

    if (LogonProcessName->Length > LSAP_MAX_LOGON_PROC_NAME_LENGTH) {
        return STATUS_NAME_TOO_LONG;
    }


    //
    // Wait for LSA to initialize...
    //


    RtlInitUnicodeString( &EventName, LsapEvent );
    InitializeObjectAttributes(
        &ObjectAttributes,
        &EventName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    Status = NtOpenEvent( &EventHandle, SYNCHRONIZE, &ObjectAttributes );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = NtWaitForSingleObject( EventHandle, TRUE, NULL);
    IgnoreStatus = NtClose( EventHandle );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }



    //
    // Set up the security quality of service parameters to use over the
    // port.  Use the most efficient (least overhead) - which is dynamic
    // rather than static tracking.
    //

    DynamicQos.Length = sizeof( DynamicQos );
    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;




    //
    // Set up the connection information to contain the logon process
    // name.
    //

    ConnectInfoLength = sizeof(LSAP_AU_REGISTER_CONNECT_INFO);
    strncpy(
        ConnectInfo.LogonProcessName,
        LogonProcessName->Buffer,
        LogonProcessName->Length
        );
    ConnectInfo.LogonProcessNameLength = LogonProcessName->Length;
    ConnectInfo.LogonProcessName[ConnectInfo.LogonProcessNameLength] = '\0';


    //
    // Connect to the LSA server
    //

    *LsaHandle = NULL;
    RtlInitUnicodeString(&PortName,LsapPort);
    Status = ZwConnectPort(
                 LsaHandle,
                 &PortName,
                 &DynamicQos,
                 NULL,
                 NULL,
                 NULL,
                 &ConnectInfo,
                 &ConnectInfoLength
                 );
    if ( !NT_SUCCESS(Status) ) {
        //DbgPrint("LSA AU: Logon Process Register failed %lx\n",Status);
        return Status;
    }

    if ( !NT_SUCCESS(ConnectInfo.CompletionStatus) ) {
        //DbgPrint("LSA AU: Logon Process Register rejected %lx\n",ConnectInfo.CompletionStatus);
        if ( LsaHandle && *LsaHandle != NULL ) {
            ZwClose( *LsaHandle );
            *LsaHandle = NULL;
        }
    }

    (*SecurityMode) = ConnectInfo.SecurityMode;

    return ConnectInfo.CompletionStatus;

}


NTSTATUS
LsaConnectUntrusted(
    OUT PHANDLE LsaHandle
    )

/*++

Routine Description:

    This service connects to the LSA server and sets up an untrusted
    connection.  It does not check anything about the caller.

Arguments:


    LsaHandle - Receives a handle which must be provided in future
        authenticaiton services.


Return Value:

    STATUS_SUCCESS - The call completed successfully.

--*/

{
    NTSTATUS Status, IgnoreStatus;
    UNICODE_STRING PortName, EventName;
    LSAP_AU_REGISTER_CONNECT_INFO ConnectInfo;
    ULONG ConnectInfoLength;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE EventHandle;



    //
    // Wait for LSA to initialize...
    //


    RtlInitUnicodeString( &EventName, LsapEvent );
    InitializeObjectAttributes(
        &ObjectAttributes,
        &EventName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    Status = NtOpenEvent( &EventHandle, SYNCHRONIZE, &ObjectAttributes );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = NtWaitForSingleObject( EventHandle, TRUE, NULL);
    IgnoreStatus = NtClose( EventHandle );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }



    //
    // Set up the security quality of service parameters to use over the
    // port.  Use the most efficient (least overhead) - which is dynamic
    // rather than static tracking.
    //

    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;




    //
    // Set up the connection information to contain the logon process
    // name.
    //

    ConnectInfoLength = sizeof(LSAP_AU_REGISTER_CONNECT_INFO);
    RtlZeroMemory(
        &ConnectInfo,
        ConnectInfoLength
        );


    //
    // Connect to the LSA server
    //

    RtlInitUnicodeString(&PortName,LsapPort);
    Status = ZwConnectPort(
                 LsaHandle,
                 &PortName,
                 &DynamicQos,
                 NULL,
                 NULL,
                 NULL,
                 &ConnectInfo,
                 &ConnectInfoLength
                 );
    if ( !NT_SUCCESS(Status) ) {
        //DbgPrint("LSA AU: Logon Process Register failed %lx\n",Status);
        return Status;
    }

    if ( !NT_SUCCESS(ConnectInfo.CompletionStatus) ) {
        //DbgPrint("LSA AU: Logon Process Register rejected %lx\n",ConnectInfo.CompletionStatus);
        ;
    }

    return ConnectInfo.CompletionStatus;

}


NTSTATUS
LsaLookupAuthenticationPackage (
    IN HANDLE LsaHandle,
    IN PSTRING PackageName,
    OUT PULONG AuthenticationPackage
    )

/*++

Arguments:

    LsaHandle - Supplies a handle obtained in a previous call to
        LsaRegisterLogonProcess.

    PackageName - Supplies a string which identifies the
        Authentication Package.  "MSV1.0" is the standard NT
        authentication package name.  The package name must not
        exceed 127 bytes in length.

    AuthenticationPackage - Receives an ID used to reference the
        authentication package in subsequent authentication services.

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_NO_SUCH_PACKAGE - The specified authentication package is
        unknown to the LSA.

    STATUS_NAME_TOO_LONG - The authentication package name provided is too
        long.



Routine Description:

    This service is used to obtain the ID of an authentication package.
    This ID may then be used in subsequent authentication services.


--*/

{

    NTSTATUS Status;
    LSAP_AU_API_MESSAGE Message = {0};
    PLSAP_LOOKUP_PACKAGE_ARGS Arguments;

    //
    // Validate input parameters
    //

    if (PackageName->Length > LSAP_MAX_PACKAGE_NAME_LENGTH) {
        return STATUS_NAME_TOO_LONG;
    }



    Arguments = &Message.Arguments.LookupPackage;

    //
    // Set arguments
    //

    strncpy(Arguments->PackageName, PackageName->Buffer, PackageName->Length);
    Arguments->PackageNameLength = PackageName->Length;
    Arguments->PackageName[Arguments->PackageNameLength] = '\0';



    //
    // Call the Local Security Authority Server.
    //

    Message.ApiNumber = LsapAuLookupPackageApi;
    Message.PortMessage.u1.s1.DataLength = LSAP_AU_DATA_LENGTH(sizeof(*Arguments));
    Message.PortMessage.u1.s1.TotalLength = sizeof(Message);
    Message.PortMessage.u2.ZeroInit = 0L;

    Status = ZwRequestWaitReplyPort(
            LsaHandle,
            (PPORT_MESSAGE) &Message,
            (PPORT_MESSAGE) &Message
            );

    //
    // Return the authentication package ID.
    // If the call failed for any reason, this will be garbage,
    // but who cares.
    //

    (*AuthenticationPackage) = Arguments->AuthenticationPackage;


    if ( NT_SUCCESS(Status) ) {
        Status = Message.ReturnedStatus;
        if ( !NT_SUCCESS(Status) ) {
            //DbgPrint("LSA AU: Package Lookup Failed %lx\n",Status);
            ;
        }
    } else {
#if DBG
        DbgPrint("LSA AU: Package Lookup NtRequestWaitReply Failed %lx\n",Status);
#else
        ;
#endif
    }

    return Status;
}


NTSTATUS
LsaLogonUser (
    IN HANDLE LsaHandle,
    IN PSTRING OriginName,
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG AuthenticationPackage,
    IN PVOID AuthenticationInformation,
    IN ULONG AuthenticationInformationLength,
    IN PTOKEN_GROUPS LocalGroups OPTIONAL,
    IN PTOKEN_SOURCE SourceContext,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID LogonId,
    OUT PHANDLE Token,
    OUT PQUOTA_LIMITS Quotas,
    OUT PNTSTATUS SubStatus
    )

/*++

Arguments:

    LsaHandle - Supplies a handle obtained in a previous call to
        LsaRegisterLogonProcess.

    OriginName - Supplies a string which identifies the origin of the
        logon attempt.  For example, "TTY1" specify terminal 1, or
        "LAN Manager - remote node JAZZ" might indicate a network
        logon attempt via LAN Manager from a remote node called
        "JAZZ".

    LogonType - Identifies the type of logon being attempted.  If the
        type is Interactive or Batch then a PrimaryToken will be
        generated to represent this new user.  If the type is Network
        then an impersonation token will be generated.

    AuthenticationPackage - Supplies the ID of the authentication
        package to use for the logon attempt.  The standard
        authentication package name for NT is called "MSV1.0".

    AuthenticationInformation - Supplies the authentication
        information specific to the authentication package.  It is
        expected to include identification and authentication
        information such as user name and password.

    AuthenticationInformationLength - Indicates the length of the
        authentication information buffer.

    LocalGroups - Optionally supplies a list of additional group
        identifiers to add to the authenticated user's token.  The
        WORLD group will always be included in the token.  A group
        identifying the logon type (INTERACTIVE, NETWORK, BATCH) will
        also automatically be included in the token.

    SourceContext - Supplies information identifying the source
        component (e.g., session manager) and context that may be
        useful to that component.  This information will be included
        in the token and may later be retrieved.

    ProfileBuffer - Receives a pointer to any returned profile and
        accounting information about the logged on user's account.
        This information is authentication package specific and
        provides such information as the logon shell, home directory
        and so forth.  For an authentication package value of
        "MSV1.0", a MSV1_0_PROFILE_DATA data structure is returned.

        This buffer is allocated by this service and must be freed
        using LsaFreeReturnBuffer() when no longer needed.

    ProfileBufferLength - Receives the length (in bytes) of the
        returned profile buffer.

    LogonId - Points to a buffer which receives a LUID that uniquely
        identifies this logon session.  This LUID was assigned by the
        domain controller which authenticated the logon information.

    Token - Receives a handle to the new token created for this
        authentication.

    Quotas - When a primary token is returned, this parameter will be
        filled in with process quota limits that are to be assigned
        to the newly logged on user's initial process.

    SubStatus - If the logon failed due to account restrictions, this
        out parameter will receive an indication as to why the logon
        failed.  This value will only be set to a meaningful value if
        the user has a legitimate account, but may not currently
        logon for some reason.  The substatus values for
        authentication package "MSV1.0" are:

            STATUS_INVALID_LOGON_HOURS

            STATUS_INVALID_WORKSTATION

            STATUS_PASSWORD_EXPIRED

            STATUS_ACCOUNT_DISABLED

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  Indicates the caller does not have
        enough quota to allocate the profile data being returned by
        the authentication package.

    STATUS_NO_LOGON_SERVERS - Indicates that no domain controllers
        are currently able to service the authentication request.

    STATUS_LOGON_FAILURE - Indicates the logon attempt failed.  No
        indication as to the reason for failure is given, but typical
        reasons include mispelled usernames, mispelled passwords.

    STATUS_ACCOUNT_RESTRICTION - Indicates the user account and
        password were legitimate, but that the user account has some
        restriction preventing successful logon at this time.

    STATUS_NO_SUCH_PACKAGE - The specified authentication package is
        unknown to the LSA.

    STATUS_BAD_VALIDATION_CLASS - The authentication information
        provided is not a validation class known to the specified
        authentication package.

Routine Description:

    This routine is used to authenticate a user logon attempt.  This is
    used only for user's initial logon, necessary to gain access to NT
    OS/2.  Subsequent (supplementary) authentication requests must be done
    using LsaCallAuthenticationPackage().  This service will cause a logon
    session to be created to represent the new logon.  It will also return
    a token representing the newly logged on user.

--*/

{

    NTSTATUS Status;
    LSAP_AU_API_MESSAGE Message = {0};
    PLSAP_LOGON_USER_ARGS Arguments;

    Arguments = &Message.Arguments.LogonUser;

    //
    // Set arguments
    //

    Arguments->AuthenticationPackage      = AuthenticationPackage;
    Arguments->AuthenticationInformation  = AuthenticationInformation;
    Arguments->AuthenticationInformationLength = AuthenticationInformationLength;
    Arguments->OriginName                 = (*OriginName);
    Arguments->LogonType                  = LogonType;
    Arguments->SourceContext              = (*SourceContext);

    Arguments->LocalGroups                = LocalGroups;
    if ( ARGUMENT_PRESENT(LocalGroups) ) {
        Arguments->LocalGroupsCount       = LocalGroups->GroupCount;
    } else {
        Arguments->LocalGroupsCount       = 0;
    }


    //
    // Call the Local Security Authority Server.
    //

    Message.ApiNumber = LsapAuLogonUserApi;
    Message.PortMessage.u1.s1.DataLength = LSAP_AU_DATA_LENGTH(sizeof(*Arguments));
    Message.PortMessage.u1.s1.TotalLength = sizeof(Message);
    Message.PortMessage.u2.ZeroInit = 0L;

    Status = ZwRequestWaitReplyPort(
            LsaHandle,
            (PPORT_MESSAGE) &Message,
            (PPORT_MESSAGE) &Message
            );

    //
    // We may be returning bogus return values here, but it doesn't
    // matter.  They will just be ignored if an error occured.
    //

    (*SubStatus)           = Arguments->SubStatus;

    if ( NT_SUCCESS( Status ) )
    {
        Status = Message.ReturnedStatus ;

        // Don't not clear the ProfileBuffer even in case of error, cause
        // subauth packages need the ProfileBuffer.
        *ProfileBuffer = Arguments->ProfileBuffer ;
        *ProfileBufferLength = Arguments->ProfileBufferLength ;

        if ( NT_SUCCESS( Status ) )
        {
            *LogonId = Arguments->LogonId ;
            *Token = Arguments->Token ;
            *Quotas = Arguments->Quotas ;
        } else {
            *Token = NULL;
        }

    } else {

        *ProfileBuffer = NULL ;
        *Token = NULL ;
    }

    return Status;


}


NTSTATUS
LsaCallAuthenticationPackage (
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer OPTIONAL,
    OUT PULONG ReturnBufferLength OPTIONAL,
    OUT PNTSTATUS ProtocolStatus OPTIONAL
    )

/*++

Arguments:

    LsaHandle - Supplies a handle obtained in a previous call to
        LsaRegisterLogonProcess.

    AuthenticationPackage - Supplies the ID of the authentication
        package to use for the logon attempt.  The standard
        authentication package name for NT is called "MSV1.0".

    ProtocolSubmitBuffer - Supplies a protocol message specific to
        the authentication package.

    SubmitBufferLength - Indicates the length of the submitted
        protocol message buffer.

    ProtocolReturnBuffer - Receives a pointer to a returned protocol
        message whose format and semantics are specific to the
        authentication package.

        This buffer is allocated by this service and must be freed
        using LsaFreeReturnBuffer() when no longer needed.

    ReturnBufferLength - Receives the length (in bytes) of the
        returned profile buffer.

    ProtocolStatus - Assuming the services completion is
        STATUS_SUCCESS, this parameter will receive completion status
        returned by the specified authentication package.  The list
        of status values that may be returned are authentication
        package specific.

Return Status:

    STATUS_SUCCESS - The call was made to the authentication package.
        The ProtocolStatus parameter must be checked to see what the
        completion status from the authentication package is.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the call could
        not be completed because the client does not have sufficient
        quota to allocate the return buffer.

    STATUS_NO_SUCH_PACKAGE - The specified authentication package is
        unknown to the LSA.

Routine Description:

    This routine is used when a logon process needs to communicate with an
    authentication package.  There are several reasons why a logon process
    may want to do this.  Some examples are:

     o  To implement multi-message authentication protocols (such as
        the LAN Manager Challenge-response protocol.

     o  To notify the authentication package of interesting state
        change information, such as LAN Manager notifying the MSV1.0
        package that a previously unreachable domain controller is
        now reachable.  In this example, the authentication package
        would re-logon any users logged on to that domain controller.


--*/

{

    NTSTATUS Status;
    LSAP_AU_API_MESSAGE Message = {0};
    PLSAP_CALL_PACKAGE_ARGS Arguments;



    Arguments = &Message.Arguments.CallPackage;

    //
    // Set arguments
    //

    Arguments->AuthenticationPackage = AuthenticationPackage;
    Arguments->ProtocolSubmitBuffer  = ProtocolSubmitBuffer;
    Arguments->SubmitBufferLength    = SubmitBufferLength;



    //
    // Call the Local Security Authority Server.
    //

    Message.ApiNumber = LsapAuCallPackageApi;
    Message.PortMessage.u1.s1.DataLength = LSAP_AU_DATA_LENGTH(sizeof(*Arguments));
    Message.PortMessage.u1.s1.TotalLength = sizeof(Message);
    Message.PortMessage.u2.ZeroInit = 0L;

    Status = ZwRequestWaitReplyPort(
            LsaHandle,
            (PPORT_MESSAGE) &Message,
            (PPORT_MESSAGE) &Message
            );

    //
    // We may be returning bogus return values here, but it doesn't
    // matter.  They will just be ignored if an error occured.
    //

    if ( ProtocolReturnBuffer )
    {
        (*ProtocolReturnBuffer) = Arguments->ProtocolReturnBuffer;
    }

    if ( ReturnBufferLength )
    {
        (*ReturnBufferLength)   = Arguments->ReturnBufferLength;
    }

    if ( ProtocolStatus )
    {
        (*ProtocolStatus)       = Arguments->ProtocolStatus;
    }


    if ( NT_SUCCESS(Status) ) {
        Status = Message.ReturnedStatus;
#if DBG
        if ( !NT_SUCCESS(Status) ) {
            DbgPrint("LSA AU: Call Package Failed %lx\n",Status);
        }
    } else {
        DbgPrint("LSA AU: Call Package Failed %lx\n",Status);
#endif //DBG
    }



    return Status;

}


NTSTATUS
LsaDeregisterLogonProcess (
    IN HANDLE LsaHandle
    )

/*++

    This function deletes the caller's logon process context.


                        ---  WARNING  ---

        Logon Processes are part of the Trusted Computer Base, and,
        as such, are expected to be debugged to a high degree.  If
        a logon process deregisters, we will believe it.  This
        allows us to re-use the old Logon Process context value.
        If the Logon process accidently uses its context value
        after freeing it, strange things may happen.  LIkewise,
        if a client calls to release a context that has already
        been released, then LSA may grind to a halt.



Arguments:

    LsaHandle - Supplies a handle obtained in a previous call to
        LsaRegisterLogonProcess.


Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.


--*/

{

    NTSTATUS Status;
    LSAP_AU_API_MESSAGE Message = {0};
    NTSTATUS TempStatus;

    //
    // Call the Local Security Authority Server.
    //

    Message.ApiNumber = LsapAuDeregisterLogonProcessApi;
    Message.PortMessage.u1.s1.DataLength = 8;
    Message.PortMessage.u1.s1.TotalLength = sizeof(Message);
    Message.PortMessage.u2.ZeroInit = 0L;

    Status = ZwRequestWaitReplyPort(
            LsaHandle,
            (PPORT_MESSAGE) &Message,
            (PPORT_MESSAGE) &Message
            );

    TempStatus = ZwClose(LsaHandle);
    ASSERT(NT_SUCCESS(TempStatus));

    if ( NT_SUCCESS(Status) ) {
        Status = Message.ReturnedStatus;
#if DBG
        if ( !NT_SUCCESS(Status) ) {
            DbgPrint("LSA AU: DeRregisterLogonProcess Failed 0x%lx\n",Status);
        }
    } else {
        DbgPrint("LSA AU: Package Lookup NtRequestWaitReply Failed 0x%lx\n",Status);
#endif
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\common\lsarpcmm.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsarpcmm.c

Abstract:

    LSA - Common Client/Server RPC Memory Management Routines

Author:

    Scott Birrell       (ScottBi)      April 8, 1992

Environment:

Revision History:

--*/

#include <lsacomp.h>


PVOID
MIDL_user_allocate (
    size_t   NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC server transactions.  The RPC stubs will
    either call MIDL_user_allocate when it needs to un-marshall data into a
    buffer that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{
    PVOID Buffer = (PVOID) LocalAlloc(LPTR, NumBytes);

    return( Buffer );
}


VOID
MIDL_user_free (
    void    *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/

{
    LocalFree(MemPointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\client\lsadllp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lsadllp.h

Abstract:

    Local Security Authority DLL include file.

Author:

    Jim Kelly (JimK) 20-Feb-1991

Revision History:

--*/

#ifndef _LSADLLP_
#define _LSADLLP_

#include <nt.h>
#include <ntrtl.h>
#include <ntlsa.h>
#include "aup.h"        // Common AUTHENTICATION related definitions

#endif // _LSADLLP_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\common\lsaprtl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsaprtl.c

Abstract:

    Local Security Authority - Temporary Rtl Routine Definitions.

    This file contains routines used in the LSA that could be made into Rtl
    routines.  They have been written in general purpose form with this in
    mind - the only exception to thisa is that their names have Lsap prefixes
    to indicate that they are currently used only by the LSA.

Author:

    Scott Birrell       (ScottBi)      April 8, 1992

Environment:

Revision History:

--*/

#include <lsacomp.h>
#include <align.h>


BOOLEAN
LsapRtlPrefixSid(
    IN PSID PrefixSid,
    IN PSID Sid
    )

/*++

Routine Description:

    This function checks if one Sid is the Prefix Sid of another.

Arguments:

    PrefixSid - Pointer to Prefix Sid.

    Sid - Pointer to Sid to be checked.

Return Values:

    BOOLEAN - TRUE if PrefixSid is the Prefix Sid of Sid, else FALSE.

--*/

{
    BOOLEAN BooleanStatus = FALSE;

    if ((*RtlSubAuthorityCountSid(Sid)) > 0) {

        //
        // Decrement the SubAuthorityCount of Sid temporarily.
        //

        (*RtlSubAuthorityCountSid(Sid))--;

        //
        // Compare the Prefix Sid with the modified Sid.
        //

        BooleanStatus = RtlEqualSid( PrefixSid, Sid);

        //
        // Restore the original SubAuthorityCount.
        //

        (*RtlSubAuthorityCountSid(Sid))++;
    }

    return(BooleanStatus);
}


BOOLEAN
LsapRtlPrefixName(
    IN PUNICODE_STRING PrefixName,
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This function checks if a Name has the given name as a Prefix

Arguments:

    PrefixName - Pointer to Prefix Name.

    Name - Pointer to Name to be checked.

Return Values:

    BOOLEAN - TRUE if the Name is composite (i.e. contains a "\") and
                   PrefixName is the Prefix part of Name, else FALSE.

--*/

{
    UNICODE_STRING TruncatedName = *Name;

    if ((PrefixName->Length < Name->Length) &&
        Name->Buffer[PrefixName->Length / 2] == L'\\') {

        TruncatedName.Length = PrefixName->Length;

        if (RtlEqualUnicodeString(PrefixName, &TruncatedName, FALSE)) {

            return(TRUE);
        }
    }

    return(FALSE);
}


VOID
LsapRtlSplitNames(
    IN PUNICODE_STRING Names,
    IN ULONG Count,
    IN PUNICODE_STRING Separator,
    OUT PUNICODE_STRING PrefixNames,
    OUT PUNICODE_STRING SuffixNames
    )

/*++

Routine Description:

    This function splits an array of Names into Prefix and Suffix parts
    separated by the given separator.  The input array may contain names of
    the following form:

    <SuffixName>
    <PrefixName> "\" <SuffixName>
    The NULL string

    Note that the output arrays will reference the original name strings.
    No copying is done.

Arguments:

    Names - Pointer to array of Unicode Names.

    Count - Count of Names in Names.

    PrefixNames - Pointer to an array of Count Unicode String structures
        that will be initialized to point to the Prefix portions of the
        Names.

    SuffixNames - Pointer to an array of Count Unicode String structures
        that will be initialized to point to the Suffix portions of the
        Names.

Return Values:

    None.

--*/

{
    ULONG Index;
    LONG SeparatorOffset;
    LONG WideSeparatorOffset;

    //
    // Scan each name, initializing the output Unicode structures.
    //

    for (Index = 0; Index < Count; Index++) {

        PrefixNames[Index] = Names[Index];
        SuffixNames[Index] = Names[Index];

        //
        // Locate the separator "\" if any.
        //

        SeparatorOffset = LsapRtlFindCharacterInUnicodeString(
                              &Names[Index],
                              Separator,
                              FALSE
                              );

        //
        // If there is a separator, make the Prefix Name point to the
        // part of the name before the separator and make the Suffix Name
        // point to the part of the name after the separator.  If there
        // is no separator, set the Prefix Name part to Null.  Rememeber
        // that the Length fields are byte counts, not Wide Character
        // counts.
        //

        if (SeparatorOffset >= 0) {

            WideSeparatorOffset = (SeparatorOffset / sizeof(WCHAR));
            PrefixNames[Index].Length = (USHORT) SeparatorOffset;
            SuffixNames[Index].Buffer += (WideSeparatorOffset + 1);
            SuffixNames[Index].Length -= (USHORT)(SeparatorOffset + sizeof(WCHAR));

        } else {

            WideSeparatorOffset = SeparatorOffset;
            PrefixNames[Index].Length = 0;
        }

        //
        // Set MaximumLengths equal to Lengths and, for safety, clear buffer
        // pointers(s) to NULL in output strings if Length(s) are 0.
        //

        PrefixNames[Index].MaximumLength = PrefixNames[Index].Length;
        SuffixNames[Index].MaximumLength = SuffixNames[Index].Length;

        if (PrefixNames[Index].Length == 0) {

            PrefixNames[Index].Buffer = NULL;
        }

        if (SuffixNames[Index].Length == 0) {

            SuffixNames[Index].Buffer = NULL;
        }
    }
}


LONG
LsapRtlFindCharacterInUnicodeString(
    IN PUNICODE_STRING InputString,
    IN PUNICODE_STRING Character,
    IN BOOLEAN CaseInsensitive
    )

/*++

Routine Description:

    This function returns the byte offset of the first occurrence (if any) of
    a Unicode Character within a Unicode String.

Arguments

    InputString - Pointer to Unicode String to be searched.

    Character - Pointer to Unicode String initialized to character
        to be searched for.

    CaseInsensitive - TRUE if case is to be ignored, else FALSE.
    NOTE - Only FALSE is supported just now.

Return Value:

    LONG - If the character is present within the string, its non-negative
        byte offset is returned.  If the character is not present within
        the string, a negative value is returned.

--*/

{
    BOOLEAN CharacterFound = FALSE;
    ULONG Offset = 0;

    if (!CaseInsensitive) {

        Offset = 0;

        while (Offset < InputString->Length) {

            if (*(Character->Buffer) ==
                InputString->Buffer[Offset / sizeof (WCHAR)]) {

                CharacterFound = TRUE;
                break;
            }

            Offset += 2;
        }

    } else {

        //
        // Case Insensitive is not supported
        //

        CharacterFound = FALSE;
    }

    if (!CharacterFound) {

        Offset = LSA_UNKNOWN_ID;
    }

    return(Offset);
}


VOID
LsapRtlSetSecurityAccessMask(
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    NOTE! THIS ROUTINE IS IDENTICAL WITH SeSetSecurityAccessMask()
    IN \nt\private\ntos\se\semethod.c

    This routine builds an access mask representing the accesses necessary
    to set the object security information specified in the SecurityInformation
    parameter.  While it is not difficult to determine this information,
    the use of a single routine to generate it will ensure minimal impact
    when the security information associated with an object is extended in
    the future (to include mandatory access control information).

Arguments:

    SecurityInformation - Identifies the object's security information to be
        modified.

    DesiredAccess - Points to an access mask to be set to represent the
        accesses necessary to modify the information specified in the
        SecurityInformation parameter.

Return Value:

    None.

--*/

{

    //
    // Figure out accesses needed to perform the indicated operation(s).
    //

    (*DesiredAccess) = 0;

    if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
        (SecurityInformation & GROUP_SECURITY_INFORMATION)   ) {
        (*DesiredAccess) |= WRITE_OWNER;
    }

    if (SecurityInformation & DACL_SECURITY_INFORMATION) {
        (*DesiredAccess) |= WRITE_DAC;
    }

    if (SecurityInformation & SACL_SECURITY_INFORMATION) {
        (*DesiredAccess) |= ACCESS_SYSTEM_SECURITY;
    }

    return;
}


VOID
LsapRtlQuerySecurityAccessMask(
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    NOTE! THIS ROUTINE IS IDENTICAL WITH SeQuerySecurityAccessMask()
    IN \nt\private\ntos\se\semethod.c.

    This routine builds an access mask representing the accesses necessary
    to query the object security information specified in the
    SecurityInformation parameter.  While it is not difficult to determine
    this information, the use of a single routine to generate it will ensure
    minimal impact when the security information associated with an object is
    extended in the future (to include mandatory access control information).

Arguments:

    SecurityInformation - Identifies the object's security information to be
        queried.

    DesiredAccess - Points to an access mask to be set to represent the
        accesses necessary to query the information specified in the
        SecurityInformation parameter.

Return Value:

    None.

--*/

{

    //
    // Figure out accesses needed to perform the indicated operation(s).
    //

    (*DesiredAccess) = 0;

    if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
        (SecurityInformation & GROUP_SECURITY_INFORMATION) ||
        (SecurityInformation & DACL_SECURITY_INFORMATION)) {
        (*DesiredAccess) |= READ_CONTROL;
    }

    if ((SecurityInformation & SACL_SECURITY_INFORMATION)) {
        (*DesiredAccess) |= ACCESS_SYSTEM_SECURITY;
    }

    return;

}


NTSTATUS
LsapRtlSidToUnicodeRid(
    IN PSID Sid,
    OUT PUNICODE_STRING UnicodeRid
    )

/*++

Routine Description:

    This function extracts the Relative Id (Rid) from a Sid and
    converts it to a Unicode String.  The Rid is extracted and converted
    to an 8-digit Unicode Integer.

Arguments:

    Sid - Pointer to the Sid to be converted.  It is the caller's
        responsibility to ensure that the Sid has valid syntax.

    UnicodeRid -  Pointer to a Unicode String structure that will receive
        the Rid in Unicode form.  Note that memory for the string buffer
        in this Unicode String will be allocated by this routine if
        successful.  The caller must free this memory after use by calling
        RtlFreeUnicodeString.

Return Value:

    NTSTATUS - Standard Nt Status code

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to allocate buffer for Unicode String name.
--*/

{
    NTSTATUS Status;
    ULONG Rid;
    UCHAR SubAuthorityCount;
    UCHAR RidNameBufferAnsi[9];

    ANSI_STRING CharacterSidAnsi;

    //
    // First, verify that the given Sid is valid
    //

    if (!RtlValidSid( Sid )) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Sid is valid.  If however, the SubAuthorityCount is zero,
    // we cannot have a Rid so return error.
    //

    SubAuthorityCount = ((PISID) Sid)->SubAuthorityCount;

    if (SubAuthorityCount == 0) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Sid has at least one subauthority.  Get the lowest subauthority
    // (i.e. the Rid).
    //

    Rid = ((PISID) Sid)->SubAuthority[SubAuthorityCount - 1];

    //
    // Now convert the Rid to an 8-digit numeric character string
    //

    Status = RtlIntegerToChar( Rid, 16, -8, RidNameBufferAnsi );

    //
    // Need to add null terminator to string
    //

    RidNameBufferAnsi[8] = 0;

    //
    // Initialize an ANSI string structure with the converted name.
    //

    RtlInitString( &CharacterSidAnsi, RidNameBufferAnsi );

    //
    // Convert the ANSI string structure to Unicode form
    //

    Status = RtlAnsiStringToUnicodeString(
                 UnicodeRid,
                 &CharacterSidAnsi,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}


NTSTATUS
LsapRtlWellKnownPrivilegeCheck(
    IN PVOID ObjectHandle,
    IN ULONG PrivilegeId
    )

/*++

Routine Description:

    This function checks if the given well known privilege is enabled for an
    impersonated client.

Arguments:

    ObjectHandle - used for auditing

    PrivilegeId -  Specifies the well known Privilege Id

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully and the client
            is either trusted or has the necessary privilege enabled.

        STATUS_PRIVILEGE_NOT_HELD - necessary privilege is not enabled

--*/

{
    NTSTATUS Status, SecondaryStatus;
    BOOLEAN PrivilegeHeld = FALSE;
    HANDLE ClientToken = NULL;
    PRIVILEGE_SET Privilege;
    BOOLEAN ClientImpersonatedHere = FALSE;
    UNICODE_STRING SubsystemName;

    //
    // Impersonate the client.
    //

    Status = I_RpcMapWin32Status(RpcImpersonateClient( NULL ));

    if ( !NT_SUCCESS(Status) ) {

        goto WellKnownPrivilegeCheckError;
    }

    ClientImpersonatedHere = TRUE;

    //
    // Open the current thread's impersonation token.
    //

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_QUERY,
                 TRUE,
                 &ClientToken
                 );

    if ( !NT_SUCCESS(Status) ) {

        goto WellKnownPrivilegeCheckError;
    }

    //
    // OK, we have a token open.  Now check for the privilege to execute this
    // service.
    //

    Privilege.PrivilegeCount = 1;
    Privilege.Control = PRIVILEGE_SET_ALL_NECESSARY;
    Privilege.Privilege[0].Luid = RtlConvertLongToLuid(PrivilegeId);
    Privilege.Privilege[0].Attributes = 0;

    Status = NtPrivilegeCheck(
                 ClientToken,
                 &Privilege,
                 &PrivilegeHeld
                 );

    if (!NT_SUCCESS(Status)) {

        goto WellKnownPrivilegeCheckError;
    }

    RtlInitUnicodeString( &SubsystemName, L"LSA" );

    (VOID) NtPrivilegeObjectAuditAlarm ( &SubsystemName,
                                         ObjectHandle,
                                         ClientToken,
                                         ACCESS_SYSTEM_SECURITY,
                                         &Privilege,
                                         PrivilegeHeld
                                         );
    if ( !PrivilegeHeld ) {

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto WellKnownPrivilegeCheckError;
    }

WellKnownPrivilegeCheckFinish:

    //
    // If we impersonated the client, revert to ourself.
    //

    if (ClientImpersonatedHere) {

        SecondaryStatus = I_RpcMapWin32Status(RpcRevertToSelf());
    }

    //
    // If necessary, close the client token.
    //

    if (ClientToken != NULL) {

        SecondaryStatus = NtClose( ClientToken );
        ASSERT(NT_SUCCESS(SecondaryStatus));
        ClientToken = NULL;
    }

    return(Status);

WellKnownPrivilegeCheckError:

    goto WellKnownPrivilegeCheckFinish;
}


NTSTATUS
LsapSplitSid(
    IN PSID AccountSid,
    IN OUT PSID *DomainSid,
    OUT ULONG *Rid
    )

/*++

Routine Description:

    This function splits a sid into its domain sid and rid.  The caller
    can either provide a memory buffer for the returned DomainSid, or
    request that one be allocated.  If the caller provides a buffer, the buffer
    is assumed to be of sufficient size.  If allocated on the caller's behalf,
    the buffer must be freed when no longer required via MIDL_user_free.

Arguments:

    AccountSid - Specifies the Sid to be split.  The Sid is assumed to be
        syntactically valid.  Sids with zero subauthorities cannot be split.

    DomainSid - Pointer to location containing either NULL or a pointer to
        a buffer in which the Domain Sid will be returned.  If NULL is
        specified, memory will be allocated on behalf of the caller.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call successfully.

        STATUS_INVALID_SID - The Sid is has a subauthority count of 0.
--*/

{
    NTSTATUS    NtStatus;
    UCHAR       AccountSubAuthorityCount;
    ULONG       AccountSidLength;

    //
    // Calculate the size of the domain sid
    //

    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(AccountSid);


    if (AccountSubAuthorityCount < 1) {

        NtStatus = STATUS_INVALID_SID;
        goto SplitSidError;
    }

    AccountSidLength = RtlLengthSid(AccountSid);

    //
    // If no buffer is required for the Domain Sid, we have to allocate one.
    //

    if (*DomainSid == NULL) {

        //
        // Allocate space for the domain sid (allocate the same size as the
        // account sid so we can use RtlCopySid)
        //

        *DomainSid = MIDL_user_allocate(AccountSidLength);


        if (*DomainSid == NULL) {

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto SplitSidError;
        }
    }

    //
    // Copy the Account sid into the Domain sid
    //

    RtlMoveMemory(*DomainSid, AccountSid, AccountSidLength);

    //
    // Decrement the domain sid sub-authority count
    //

    (*RtlSubAuthorityCountSid(*DomainSid))--;

    //
    // Copy the rid out of the account sid
    //

    *Rid = *RtlSubAuthoritySid(AccountSid, AccountSubAuthorityCount-1);

    NtStatus = STATUS_SUCCESS;

SplitSidFinish:

    return(NtStatus);

SplitSidError:

    goto SplitSidFinish;
}




ULONG
LsapDsSizeAuthInfo(
    IN PLSAPR_AUTH_INFORMATION AuthInfo,
    IN ULONG Infos
    )
/*++

Routine Description:

    This function returns the size, in bytes, of an authentication information structure

Arguments:

    AuthInfo - AuthenticationInformation to size

    Infos - Number of items in the list

Returns:

    Size, in bytes, of the AuthInfos

--*/
{
    ULONG Len = 0, i;

    if ( AuthInfo == NULL ) {

        return( 0 );
    }

    for ( i = 0 ;  i < Infos; i++ ) {

        //
        // This calculation must match LsapDsMarshalAuthInfo
        //
        Len += sizeof(LARGE_INTEGER) +
               sizeof(ULONG) +
               sizeof(ULONG) +
               ROUND_UP_COUNT(AuthInfo[ i ].AuthInfoLength, ALIGN_DWORD);
    }

    return( Len );
}




VOID
LsapDsMarshalAuthInfo(
    IN PBYTE Buffer,
    IN PLSAPR_AUTH_INFORMATION AuthInfo,
    IN ULONG Infos
    )
/*++

Routine Description:

    This function will marshal an authinfo list into an already allocated buffer

Arguments:

    Buffer - Buffer to marshal into

    AuthInfo - AuthenticationInformation to marshal

    Infos - Number of items in the list

Returns:

    VOID

--*/
{
    ULONG i;

    if ( AuthInfo != NULL )  {

        for (i = 0; i < Infos ; i++ ) {
            ULONG AlignmentBytes;

            RtlCopyMemory( Buffer,  &AuthInfo[i].LastUpdateTime, sizeof( LARGE_INTEGER ) );
            Buffer += sizeof( LARGE_INTEGER );

            *(PULONG)Buffer = AuthInfo[i].AuthType;
            Buffer += sizeof ( ULONG );

            *(PULONG)Buffer = AuthInfo[i].AuthInfoLength;
            Buffer += sizeof ( ULONG );

            RtlCopyMemory( Buffer, AuthInfo[i].AuthInfo, AuthInfo[i].AuthInfoLength );
            Buffer += AuthInfo[i].AuthInfoLength;

            // Zero out the next couple of bytes in the DWORD.
            AlignmentBytes = ROUND_UP_COUNT(AuthInfo[ i ].AuthInfoLength, ALIGN_DWORD) -
                             AuthInfo[ i ].AuthInfoLength;
            RtlZeroMemory( Buffer, AlignmentBytes );
            Buffer += AlignmentBytes;
        }
    }

}

NTSTATUS
LsapDsMarshalAuthInfoHalf(
    IN PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF AuthInfo,
    OUT PULONG Length,
    OUT PBYTE *Buffer
    )
/*++

Routine Description:

    This function will take an AuthInfo half and marshal it into a single self
    relative buffer.

Arguments:

    AuthInfo - AuthenticationInformation to marshal

    Length - Returns the length of the allocated buffer.

    Buffer - Returns an allocated buffer containing the marshalled auth info
        The buffer should be freed using MIDL_user_free.

Returns:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PBYTE LocalBuffer, Current;
    ULONG Len, PrevLen;

    if ( AuthInfo == NULL ) {

        *Length = 0;
        *Buffer = NULL;

        return STATUS_SUCCESS;
    }

    try {
        //
        // First, size the entire auth info buffer...
        //
        Len = LsapDsSizeAuthInfo( AuthInfo->AuthenticationInformation, AuthInfo->AuthInfos );
        PrevLen = LsapDsSizeAuthInfo( AuthInfo->PreviousAuthenticationInformation,
                                      AuthInfo->AuthInfos );

        //
        // The format of the buffer we will create is:
        //
        LocalBuffer = MIDL_user_allocate( Len + PrevLen + ( 3 * sizeof( ULONG ) ) );

        if ( LocalBuffer == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            //
            // The format of the buffer is:
            //
            // [Info count][OffsetCurrent][OffsetPrevious] and then some number of the
            // following:
            // [UpdateTime(LargeInteger)][AuthType][AuthInfoLen][data (sizeis(AuthInfoLen) ]
            //

            //
            // Number of items...
            //
            *(PULONG)LocalBuffer = AuthInfo->AuthInfos;
            Current = LocalBuffer + sizeof( ULONG );

            //
            //
            *(PULONG)(Current) = 3 *  sizeof(ULONG);
            *(PULONG)(Current + sizeof(ULONG)) = *(PULONG)Current + Len;
            Current += 2 * sizeof(ULONG);

            LsapDsMarshalAuthInfo( Current,
                                   AuthInfo->AuthenticationInformation,
                                   AuthInfo->AuthInfos );

            Current += Len;

            LsapDsMarshalAuthInfo( Current,
                                   AuthInfo->PreviousAuthenticationInformation,
                                   AuthInfo->AuthInfos );

            Status = STATUS_SUCCESS;
        }

        *Length = Len + PrevLen + ( 3 * sizeof( ULONG ) );
        *Buffer = LocalBuffer;

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        Status = GetExceptionCode();
    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\crypt\dll\data.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    data.c

Abstract:

    Arbitrary length data encryption functions implementation :

        RtlEncryptData
        RtlDecryptData


Author:

    David Chalmers (Davidc) 12-16-91

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <crypt.h>
#include <engine.h>

//
// Version number of encrypted data
// Update this number if the method used encrypt the data changes
//
#define DATA_ENCRYPTION_VERSION     1

//
// Private data types
//
typedef struct _CRYPTP_BUFFER {
    ULONG   Length;         // Number of valid bytes in buffer
    ULONG   MaximumLength;  // Number of bytes pointed to by buffer
    PCHAR   Buffer;
    PCHAR   Pointer;        // Points into buffer
} CRYPTP_BUFFER;
typedef CRYPTP_BUFFER *PCRYPTP_BUFFER;

//
// Internal helper macros
#define AdvanceCypherData(p) ((PCYPHER_BLOCK)(((PCRYPTP_BUFFER)p)->Pointer)) ++
#define AdvanceClearData(p)  ((PCLEAR_BLOCK)(((PCRYPTP_BUFFER)p)->Pointer)) ++


//
// Private routines
//

VOID
InitializeBuffer(
    OUT PCRYPTP_BUFFER PrivateBuffer,
    IN PCRYPT_BUFFER PublicBuffer
    )
/*++

Routine Description:

    Internal helper routine

    Copies fields from public buffer into private buffer.
    Sets the Pointer field of the private buffer to the
    base of the buffer.

Arguments:

    PrivateBuffer - out internal buffer we want to represent the public structure.

    PublicBuffer - the buffer the caller passed us

Return Values:

    None
--*/
{
    PrivateBuffer->Length = PublicBuffer->Length;
    PrivateBuffer->MaximumLength = PublicBuffer->MaximumLength;
    PrivateBuffer->Buffer = PublicBuffer->Buffer;
    PrivateBuffer->Pointer = PublicBuffer->Buffer;
}


BOOLEAN
ValidateDataKey(
    IN PCRYPTP_BUFFER DataKey,
    IN PBLOCK_KEY BlockKey
    )
/*++

Routine Description:

    Internal helper routine

    Checks the validity of the data key and constructs a minimum length
    key in the passed blockkey if the datakey is not long enough.

Arguments:

    DataKey - The data key

Return Values:

    TRUE if the key is valid, otherwise FALSE

--*/
{
    if ( ( DataKey->Length == 0 ) ||
         ( DataKey->Buffer == NULL ) ) {

        return(FALSE);
    }

    if (DataKey->Length < BLOCK_KEY_LENGTH) {

        // Make up a minimum length key from the small data key we were
        // given. Store it in the passed blockkey variable and point
        // the datakey buffer at this temporary storage.

        ULONG   DataIndex, BlockIndex;

        DataIndex = 0;
        for (BlockIndex = 0; BlockIndex < BLOCK_KEY_LENGTH; BlockIndex ++) {
            ((PCHAR)BlockKey)[BlockIndex] = DataKey->Buffer[DataIndex];
            DataIndex ++;
            if (DataIndex >= DataKey->Length) {
                DataIndex = 0;
            }
        }

        // Point the buffer at our constructed block key
        DataKey->Buffer = (PCHAR)BlockKey;
        DataKey->Pointer = (PCHAR)BlockKey;
        DataKey->Length = BLOCK_KEY_LENGTH;
        DataKey->MaximumLength = BLOCK_KEY_LENGTH;
    }

    return(TRUE);
}


VOID
AdvanceDataKey(
    IN PCRYPTP_BUFFER DataKey
    )
/*++

Routine Description:

    Internal helper routine

    Moves the data key pointer on to point at the key to use to encrypt
    the next data block. Wraps round at end of key data.

Arguments:

    DataKey - The data key

Return Values:

    STATUS_SUCCESS - No problems

--*/
{
    if (DataKey->Length > BLOCK_KEY_LENGTH) {

        PCHAR   EndPointer;

        // Advance pointer and wrap
        DataKey->Pointer += BLOCK_KEY_LENGTH;
        EndPointer = DataKey->Pointer + BLOCK_KEY_LENGTH;

        if (EndPointer > &(DataKey->Buffer[DataKey->Length])) {

            ULONG_PTR  Overrun;

            Overrun = EndPointer - &(DataKey->Buffer[DataKey->Length]);

            DataKey->Pointer = DataKey->Buffer + (BLOCK_KEY_LENGTH - Overrun);
        }
    }
}


ULONG
CalculateCypherDataLength(
    IN PCRYPTP_BUFFER ClearData
    )
/*++

Routine Description:

    Internal helper routine

    Returns the number of bytes required to encrypt the specified number
    of clear data bytes.

Arguments:

    ClearData - The clear data

Return Values:

    Number of cypher bytes required.
--*/
{
    ULONG   CypherDataLength;
    ULONG   BlockExcess;

    // We always store the length of the clear data as a whole block.
    CypherDataLength = CYPHER_BLOCK_LENGTH + ClearData->Length;

    // Round up to the next block
    BlockExcess = CypherDataLength % CYPHER_BLOCK_LENGTH;
    if (BlockExcess > 0) {
        CypherDataLength += CYPHER_BLOCK_LENGTH - BlockExcess;
    }

    return(CypherDataLength);
}


NTSTATUS
EncryptDataLength(
    IN PCRYPTP_BUFFER Data,
    IN PCRYPTP_BUFFER DataKey,
    OUT PCRYPTP_BUFFER CypherData
    )
/*++

Routine Description:

    Internal helper routine

    Encrypts the clear data length and puts the encrypted value in the
    cypherdatabuffer. Advances the cypherdata buffer and datakey buffer pointers

Arguments:

    Data - The buffer whose length is to be encrypted

    DataKey - key to use to encrypt data

    CypherData - Place to store encrypted data

Return Values:

    STATUS_SUCCESS - Success.

    STATUS_UNSUCCESSFUL - Something failed.
--*/
{
    NTSTATUS    Status;
    CLEAR_BLOCK ClearBlock;

    // Fill the clear block with the data value and a version number
    ((ULONG *)&ClearBlock)[0] = Data->Length;
    ((ULONG *)&ClearBlock)[1] = DATA_ENCRYPTION_VERSION;

    Status = RtlEncryptBlock(&ClearBlock,
                             (PBLOCK_KEY)(DataKey->Pointer),
                             (PCYPHER_BLOCK)(CypherData->Pointer));

    // Advance pointers
    AdvanceCypherData(CypherData);
    AdvanceDataKey(DataKey);

    return(Status);
}


NTSTATUS
EncryptFullBlock(
    IN OUT PCRYPTP_BUFFER ClearData,
    IN OUT PCRYPTP_BUFFER DataKey,
    IN OUT PCRYPTP_BUFFER CypherData
    )
/*++

Routine Description:

    Internal helper routine

    Encrypts a full block of data from ClearData and puts the encrypted
    data in CypherData.
    Both cleardata, datakey and cypherdata pointers are advanced.

Arguments:

    ClearData - Pointer to the cleardata buffer

    DataKey - key to use to encrypt data

    CypherData - Pointer to cypherdata buffer.

Return Values:

    STATUS_SUCCESS - Success.

    STATUS_UNSUCCESSFUL - Something failed.
--*/
{
    NTSTATUS    Status;

    Status = RtlEncryptBlock((PCLEAR_BLOCK)(ClearData->Pointer),
                              (PBLOCK_KEY)(DataKey->Pointer),
                              (PCYPHER_BLOCK)(CypherData->Pointer));

    // Advance pointers
    AdvanceClearData(ClearData);
    AdvanceCypherData(CypherData);
    AdvanceDataKey(DataKey);

    return(Status);
}


NTSTATUS
EncryptPartialBlock(
    IN OUT PCRYPTP_BUFFER ClearData,
    IN OUT PCRYPTP_BUFFER DataKey,
    IN OUT PCRYPTP_BUFFER CypherData,
    IN ULONG Remaining
    )
/*++

Routine Description:

    Internal helper routine

    Encrypts a partial block of data from ClearData and puts the full
    encrypted data block in cypherdata.
    Both cleardata, datakey and cypherdata pointers are advanced.

Arguments:

    ClearData - Pointer to the cleardata buffer

    DataKey - key to use to encrypt data

    CypherData - Pointer to cypherdata buffer.

    Remaining - the number of bytes remaining in cleardata buffer

Return Values:

    STATUS_SUCCESS - Success.

    STATUS_UNSUCCESSFUL - Something failed.
--*/
{
    NTSTATUS    Status;
    CLEAR_BLOCK ClearBlockBuffer;
    PCLEAR_BLOCK ClearBlock = &ClearBlockBuffer;

    ASSERTMSG("EncryptPartialBlock called with a block or more", Remaining < CLEAR_BLOCK_LENGTH);

    // Copy the remaining bytes into a clear block buffer
    while (Remaining > 0) {

        *((PCHAR)ClearBlock) ++ = *(ClearData->Pointer) ++;
        Remaining --;
    }

    // Zero pad
    while (ClearBlock < &((&ClearBlockBuffer)[1])) {

        *((PCHAR)ClearBlock) ++ = 0;
    }

    Status = RtlEncryptBlock(&ClearBlockBuffer,
                            (PBLOCK_KEY)(DataKey->Pointer),
                            (PCYPHER_BLOCK)(CypherData->Pointer));

    // Advance pointers
    AdvanceClearData(ClearData);
    AdvanceCypherData(CypherData);
    AdvanceDataKey(DataKey);

    return(Status);
}


NTSTATUS
DecryptDataLength(
    IN PCRYPTP_BUFFER CypherData,
    IN PCRYPTP_BUFFER DataKey,
    OUT PCRYPTP_BUFFER Data
    )
/*++

Routine Description:

    Internal helper routine

    Decrypts the data length pointed to by the cypherdata buffer and puts the
    decrypted value in the length field of the data structure.
    Advances the cypherdata buffer and datakey buffer pointers

Arguments:

    CypherData - The buffer containing the encrypted length

    DataKey - key to use to decrypt data

    Data - Decrypted length field is stored in the length field of this struct.

Return Values:

    STATUS_SUCCESS - Success.

    STATUS_UNSUCCESSFUL - Something failed.
--*/
{
    NTSTATUS    Status;
    CLEAR_BLOCK ClearBlock;
    ULONG       Version;

    Status = RtlDecryptBlock((PCYPHER_BLOCK)(CypherData->Pointer),
                             (PBLOCK_KEY)(DataKey->Pointer),
                             &ClearBlock);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    // Advance pointers
    AdvanceCypherData(CypherData);
    AdvanceDataKey(DataKey);

    // Copy the decrypted length into the data structure.
    Data->Length = ((ULONG *)&ClearBlock)[0];

    // Check the version
    Version = ((ULONG *)&ClearBlock)[1];
    if (Version != DATA_ENCRYPTION_VERSION) {
        return(STATUS_UNKNOWN_REVISION);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
DecryptFullBlock(
    IN OUT PCRYPTP_BUFFER CypherData,
    IN OUT PCRYPTP_BUFFER DataKey,
    IN OUT PCRYPTP_BUFFER ClearData
    )
/*++

Routine Description:

    Internal helper routine

    Decrypts a full block of data from CypherData and puts the encrypted
    data in ClearData.
    Both cleardata, datakey and cypherdata pointers are advanced.

Arguments:

    CypherData - Pointer to cypherdata buffer.

    ClearData - Pointer to the cleardata buffer

    DataKey - key to use to encrypt data

Return Values:

    STATUS_SUCCESS - Success.

    STATUS_UNSUCCESSFUL - Something failed.
--*/
{
    NTSTATUS    Status;

    Status = RtlDecryptBlock((PCYPHER_BLOCK)(CypherData->Pointer),
                              (PBLOCK_KEY)(DataKey->Pointer),
                              (PCLEAR_BLOCK)(ClearData->Pointer));

    // Advance pointers
    AdvanceClearData(ClearData);
    AdvanceCypherData(CypherData);
    AdvanceDataKey(DataKey);

    return(Status);
}


NTSTATUS
DecryptPartialBlock(
    IN OUT PCRYPTP_BUFFER CypherData,
    IN OUT PCRYPTP_BUFFER DataKey,
    IN OUT PCRYPTP_BUFFER ClearData,
    IN ULONG Remaining
    )
/*++

Routine Description:

    Internal helper routine

    Decrypts a full block of data from CypherData and puts the partial
    decrypted data block in cleardata.
    Both cleardata, datakey and cypherdata pointers are advanced.

Arguments:

    CypherData - Pointer to cypherdata buffer.

    ClearData - Pointer to the cleardata buffer

    DataKey - key to use to encrypt data

    Remaining - the number of bytes remaining in cleardata buffer

Return Values:

    STATUS_SUCCESS - Success.

    STATUS_UNSUCCESSFUL - Something failed.
--*/
{
    NTSTATUS    Status;
    CLEAR_BLOCK ClearBlockBuffer;
    PCLEAR_BLOCK ClearBlock = &ClearBlockBuffer;

    ASSERTMSG("DecryptPartialBlock called with a block or more", Remaining < CLEAR_BLOCK_LENGTH);

    // Decrypt the block into a local clear block
    Status = RtlDecryptBlock((PCYPHER_BLOCK)(CypherData->Pointer),
                             (PBLOCK_KEY)(DataKey->Pointer),
                             &ClearBlockBuffer);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    // Copy the decrypted bytes into the cleardata buffer.
    while (Remaining > 0) {

        *(ClearData->Pointer) ++ = *((PCHAR)ClearBlock) ++;
        Remaining --;
    }

    // Advance pointers
    AdvanceClearData(ClearData);
    AdvanceCypherData(CypherData);
    AdvanceDataKey(DataKey);

    return(Status);
}


//
// Public functions
//


NTSTATUS
RtlEncryptData(
    IN PCLEAR_DATA ClearData,
    IN PDATA_KEY DataKey,
    OUT PCYPHER_DATA CypherData
    )

/*++

Routine Description:

    Takes an arbitrary length block of data and encrypts it with a
    data key producing an encrypted block of data.

Arguments:

    ClearData - The data to be encrypted.

    DataKey - The key to use to encrypt the data

    CypherData - Encrypted data is returned here

Return Values:

    STATUS_SUCCESS - The data was encrypted successfully. The encrypted
                     data is in CypherData. The length of the encrypted
                     data is is CypherData->Length.

    STATUS_BUFFER_TOO_SMALL - CypherData.MaximumLength is too small to
                    contain the encrypted data.
                    CypherData->Length contains the number of bytes required.

    STATUS_INVALID_PARAMETER_2 - Block key is invalid

    STATUS_UNSUCCESSFUL - Something failed.
                    The CypherData is undefined.
--*/

{
    NTSTATUS        Status;
    ULONG           CypherDataLength;
    ULONG           Remaining = ClearData->Length;
    CRYPTP_BUFFER   CypherDataBuffer;
    CRYPTP_BUFFER   ClearDataBuffer;
    CRYPTP_BUFFER   DataKeyBuffer;
    BLOCK_KEY       BlockKey; // Only used if datakey less than a block long

    InitializeBuffer(&ClearDataBuffer, (PCRYPT_BUFFER)ClearData);
    InitializeBuffer(&CypherDataBuffer, (PCRYPT_BUFFER)CypherData);
    InitializeBuffer(&DataKeyBuffer, (PCRYPT_BUFFER)DataKey);

    // Check the key is OK
    if (!ValidateDataKey(&DataKeyBuffer, &BlockKey)) {
        return(STATUS_INVALID_PARAMETER_2);
    }

    // Find out how big we need the cypherdata buffer to be
    CypherDataLength = CalculateCypherDataLength(&ClearDataBuffer);

    // Fail if cypher data buffer too small
    if (CypherData->MaximumLength < CypherDataLength) {
        CypherData->Length = CypherDataLength;
        return(STATUS_BUFFER_TOO_SMALL);
    }

    //
    // Encrypt the clear data length into the start of the cypher data.
    //
    Status = EncryptDataLength(&ClearDataBuffer, &DataKeyBuffer, &CypherDataBuffer);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Encrypt the clear data a block at a time.
    //
    while (Remaining >= CLEAR_BLOCK_LENGTH) {

        Status = EncryptFullBlock(&ClearDataBuffer, &DataKeyBuffer, &CypherDataBuffer);
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
        Remaining -= CLEAR_BLOCK_LENGTH;
    }

    //
    // Encrypt any partial block that remains
    //
    if (Remaining > 0) {
        Status = EncryptPartialBlock(&ClearDataBuffer, &DataKeyBuffer, &CypherDataBuffer, Remaining);
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    // Return the encrypted data length
    CypherData->Length = CypherDataLength;

    return(STATUS_SUCCESS);
}



NTSTATUS
RtlDecryptData(
    IN PCYPHER_DATA CypherData,
    IN PDATA_KEY DataKey,
    OUT PCLEAR_DATA ClearData
    )
/*++

Routine Description:

    Takes an arbitrary block of encrypted data and decrypts it with a
    key producing the original clear block of data.

Arguments:

    CypherData - The data to be decrypted

    DataKey - The key to use to decrypt data

    ClearData - The decrpted data of data is returned here


Return Values:

    STATUS_SUCCESS - The data was decrypted successfully. The decrypted
                     data is in ClearData.

    STATUS_BUFFER_TOO_SMALL - ClearData->MaximumLength is too small to
                    contain the decrypted data.
                    ClearData->Length contains the number of bytes required.

    STATUS_INVALID_PARAMETER_2 - Block key is invalid

    STATUS_UNSUCCESSFUL - Something failed.
                    The ClearData is undefined.
--*/

{
    NTSTATUS        Status;
    ULONG           Remaining;
    CRYPTP_BUFFER   CypherDataBuffer;
    CRYPTP_BUFFER   ClearDataBuffer;
    CRYPTP_BUFFER   DataKeyBuffer;
    BLOCK_KEY       BlockKey; // Only used if datakey less than a block long

    InitializeBuffer(&ClearDataBuffer, (PCRYPT_BUFFER)ClearData);
    InitializeBuffer(&CypherDataBuffer, (PCRYPT_BUFFER)CypherData);
    InitializeBuffer(&DataKeyBuffer, (PCRYPT_BUFFER)DataKey);

    // Check the key is OK
    if (!ValidateDataKey(&DataKeyBuffer, &BlockKey)) {
        return(STATUS_INVALID_PARAMETER_2);
    }

    //
    // Decrypt the clear data length from the start of the cypher data.
    //
    Status = DecryptDataLength(&CypherDataBuffer, &DataKeyBuffer, &ClearDataBuffer);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    // Fail if clear data buffer too small
    if (ClearData->MaximumLength < ClearDataBuffer.Length) {
        ClearData->Length = ClearDataBuffer.Length;
        return(STATUS_BUFFER_TOO_SMALL);
    }

    //
    // Decrypt the clear data a block at a time.
    //
    Remaining = ClearDataBuffer.Length;
    while (Remaining >= CLEAR_BLOCK_LENGTH) {

        Status = DecryptFullBlock(&CypherDataBuffer, &DataKeyBuffer, &ClearDataBuffer);
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
        Remaining -= CLEAR_BLOCK_LENGTH;
    }

    //
    // Decrypt any partial block that remains
    //
    if (Remaining > 0) {
        Status = DecryptPartialBlock(&CypherDataBuffer, &DataKeyBuffer, &ClearDataBuffer, Remaining);
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    // Return the length of the decrypted data
    ClearData->Length = ClearDataBuffer.Length;

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\crypt\dll\data2.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    data2.c

Abstract:

    Arbitrary length data encryption functions implementation :

        RtlEncryptData2
        RtlDecryptData2


Author:

    Richard Ward    (richardw)  20 Dec 93

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <crypt.h>
#include <engine.h>
#include <rc4.h>



NTSTATUS
RtlEncryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    )

/*++

Routine Description:

    Takes an arbitrary length block of data and encrypts it with a
    data key producing an encrypted block of data.

Arguments:

    pData - The data that will be encrypt, IN PLACE

    pKey - The key to use to encrypt the data

Return Values:

    STATUS_SUCCESS

--*/

{
    struct RC4_KEYSTRUCT    Key;

    if ( pData->Length != 0 ) {
        rc4_key(&Key, pKey->Length, pKey->Buffer);
        rc4(&Key, pData->Length, pData->Buffer);

        RtlSecureZeroMemory( &Key, sizeof(Key) );
    }

    return STATUS_SUCCESS;
}



NTSTATUS
RtlDecryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    )

/*++

Routine Description:

    Takes an arbitrary length block of data and encrypts it with a
    data key producing an encrypted block of data.

Arguments:

    pData - The data that will be encrypt, IN PLACE

    pKey - The key to use to encrypt the data

Return Values:

    STATUS_SUCCESS

--*/

{
    struct RC4_KEYSTRUCT    Key;

    if ( pData->Length != 0 ) {
        rc4_key(&Key, pKey->Length, pKey->Buffer);
        rc4(&Key, pData->Length, pData->Buffer);

        RtlSecureZeroMemory( &Key, sizeof(Key) );
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\common\cr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cr.c

Abstract:

    Local Security Authority - Cipher Routines common to Client and Server

    These routines interface the LSA client or server sides with the Cipher
    Routines.  They perform RPC-style memory allocation.

Author:

    Scott Birrell       (ScottBi)     December 13, 1991

Environment:

Revision History:

--*/

#include <lsacomp.h>

VOID
LsapCrFreeMemoryValue(
    IN PVOID MemoryValue
    )

/*++

Routine Description:

    This function frees the memory allocated for an Cipher Value.

Arguments:

    None.

Return Value:

--*/

{
    //
    // The memory is currently a counted string contained in a UNICODE
    // STRING structure in which the buffer follows the structure.  A
    // single MIDL_user_free will therefore do the trick.
    //

    MIDL_user_free(MemoryValue);
}


NTSTATUS
LsapCrEncryptValue(
    IN OPTIONAL PLSAP_CR_CLEAR_VALUE ClearValue,
    IN PLSAP_CR_CIPHER_KEY CipherKey,
    OUT PLSAP_CR_CIPHER_VALUE *CipherValue
    )

/*++

Routine Description:

    This function two-way encrypts a Value with the given Cipher Key
    and allocates memory for the output.  The memory must be freed after
    use by calling LsapCrFreeMemoryValue().

Arguments:

    ClearValue - Pointer to structure referencing value to be encrypted.
        A NULL pointer may be specified.

    CipherKey - Pointer to structure referencing the Cipher Key

    CipherValue - Receives a pointer to a structure referencing the
        encrypted value or NULL.

Return Value:

--*/

{
    NTSTATUS Status;
    LSAP_CR_CIPHER_VALUE TempCipherValue;
    PLSAP_CR_CIPHER_VALUE OutputCipherValue = NULL;
    ULONG CipherValueBufferLength;
    LSAP_CR_CLEAR_VALUE LocalFake = { 0 };

    //
    // If NULL is specified for input, return NULL for output.
    //

    if (!ARGUMENT_PRESENT(ClearValue)) {

        *CipherValue = NULL;
        ClearValue = &LocalFake ;
    }

    //
    // Obtain the length of the encrypted value buffer that will be
    // required by calling the encryption routine in 'query' mode
    // by passing a pointer to a return Cipher Value structure containing
    // a MaximumLength of 0.
    //

    TempCipherValue.MaximumLength = 0;
    TempCipherValue.Length = 0;
    TempCipherValue.Buffer = NULL;

    Status = LsapCrRtlEncryptData(
                 ClearValue,
                 CipherKey,
                 &TempCipherValue
                 );

    if (Status != STATUS_BUFFER_TOO_SMALL) {

        goto EncryptValueError;
    }

    //
    // Allocate memory for the output structure followed by buffer.
    //

    CipherValueBufferLength = TempCipherValue.Length;
    Status = STATUS_INSUFFICIENT_RESOURCES;

    OutputCipherValue = MIDL_user_allocate(
                            sizeof (LSAP_CR_CIPHER_VALUE) +
                            CipherValueBufferLength
                            );

    if (OutputCipherValue == NULL) {

        goto EncryptValueError;
    }

    //
    // Initialize Cipher Value structure.  The Buffer pointer is set to
    // to point to the byte following the structure header.
    //

    OutputCipherValue->Buffer = (PCHAR)(OutputCipherValue + 1);
    OutputCipherValue->MaximumLength = CipherValueBufferLength;
    OutputCipherValue->Length = CipherValueBufferLength;

    //
    // Now call the two-way encryption routine.
    //

    Status = LsapCrRtlEncryptData(
                 ClearValue,
                 CipherKey,
                 OutputCipherValue
                 );

    if (NT_SUCCESS(Status)) {

        *CipherValue = OutputCipherValue;
        return(Status);
    }

EncryptValueError:

    //
    // If necessary, free the memory allocated for the output encrypted value.
    //

    if (OutputCipherValue != NULL) {

        MIDL_user_free(OutputCipherValue);
    }

    *CipherValue = NULL;
    return(Status);
}


NTSTATUS
LsapCrDecryptValue(
    IN OPTIONAL PLSAP_CR_CIPHER_VALUE CipherValue,
    IN PLSAP_CR_CIPHER_KEY CipherKey,
    OUT PLSAP_CR_CLEAR_VALUE *ClearValue
    )

/*++

Routine Description:

    This function decrypts a Value that has been two-way Cipher with the
    given Cipher Key and allocates memory for the output.  The memory
    must be freed after use by calling LsapCrFreeMemoryValue();

Arguments:

    CipherValue - Pointer to structure referencing encrypted Value.

    CipherKey - Pointer to structure referencing the Cipher Key

    ClearValue - Receives a pointer to a structure referencing the
        Decrypted Value.

Return Value:

--*/

{
    NTSTATUS Status;
    LSAP_CR_CLEAR_VALUE TempClearValue;
    PLSAP_CR_CLEAR_VALUE OutputClearValue = NULL;
    ULONG ClearValueBufferLength;

    //
    // If NULL is specified for input, return NULL for output.
    //

    if (!ARGUMENT_PRESENT(CipherValue)) {

        *ClearValue = NULL;

    } else {

         if ( CipherValue->MaximumLength < CipherValue->Length ||
              ( CipherValue->Length != 0 && CipherValue->Buffer == NULL ) ) {
             return STATUS_INVALID_PARAMETER;
         }
    }

    //
    // Obtain the length of the decrypted (clear) value buffer that will be
    // required by calling the decryption routine in 'query' mode
    // by passing a pointer to a return Clear Value structure containing
    // a MaximumLength of 0.
    //

    TempClearValue.MaximumLength = 0;
    TempClearValue.Length = 0;
    TempClearValue.Buffer = NULL;

    Status = LsapCrRtlDecryptData(
                 CipherValue,
                 CipherKey,
                 &TempClearValue
                 );

    //
    // Since we supplied a buffer length of 0, we would normally expect
    // to receive STATUS_BUFFER_TOO_SMALL back plus the buffer size required.
    // There is one exceptional case and that is where the original
    // unencrypted data had length 0.  In this case, we expect
    // STATUS_SUCCESS and a length required equal to 0 returned.
    //

    if (Status != STATUS_BUFFER_TOO_SMALL) {

        if (!(Status == STATUS_SUCCESS && TempClearValue.Length == 0)) {
            goto DecryptValueError;
        }
    }

    //
    // Allocate memory for the output structure followed by buffer.
    //

    ClearValueBufferLength = TempClearValue.Length;
    Status = STATUS_INSUFFICIENT_RESOURCES;

    OutputClearValue = MIDL_user_allocate(
                            sizeof (LSAP_CR_CLEAR_VALUE) +
                            ClearValueBufferLength
                            );

    if (OutputClearValue == NULL) {

        goto DecryptValueError;
    }

    //
    // Initialize Clear Value structure.  The Buffer pointer is set to
    // to point to the byte following the structure header.
    //

    OutputClearValue->Buffer = (PCHAR)(OutputClearValue + 1);
    OutputClearValue->MaximumLength = ClearValueBufferLength;
    OutputClearValue->Length = ClearValueBufferLength;

    //
    // Now call the two-way decryption routine.
    //

    Status = LsapCrRtlDecryptData(
                 CipherValue,
                 CipherKey,
                 OutputClearValue
                 );

    if (NT_SUCCESS(Status)) {

        *ClearValue = OutputClearValue;
        return(Status);
    }

DecryptValueError:

    //
    // If necessary, free the memory allocated for the output decrypted value.
    //

    if (OutputClearValue != NULL) {

        MIDL_user_free(OutputClearValue);
    }

    *ClearValue = NULL;
    return(Status);
}


VOID
LsapCrUnicodeToClearValue(
    IN OPTIONAL PUNICODE_STRING UnicodeString,
    OUT PLSAP_CR_CLEAR_VALUE ClearValue
    )

/*++

Routine Description:

    This function converts a Unicode structure to a Clear Value structure.

Arguments:

    UnicodeString - Optional pointer to Unicode string.  If NULL, the
        output Clear Value structure is initialized to have zero
        length and Maximum length, and with a NULL buffer pointer.

    ClearValue - Pointer to Clear Value structure.

Return Value:

    None.

--*/

{

    UNICODE_STRING IntermediateUnicodeString;

    if (ARGUMENT_PRESENT(UnicodeString)) {

        IntermediateUnicodeString = *UnicodeString;

        ClearValue->Length = (ULONG) IntermediateUnicodeString.Length;
        ClearValue->MaximumLength = (ULONG) IntermediateUnicodeString.MaximumLength;
        ClearValue->Buffer = (PUCHAR) IntermediateUnicodeString.Buffer;
        return;
    }

    ClearValue->Length = ClearValue->MaximumLength = 0;
    ClearValue->Buffer = NULL;
}


VOID
LsapCrClearValueToUnicode(
    IN OPTIONAL PLSAP_CR_CLEAR_VALUE ClearValue,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This function converts a Clear Value to a Unicode String.  The Clear
    Value structure must have valid syntax - no checking will be done.


Arguments:

    ClearValue - Optional pointer to Clear Value to be converted.  If
        NULL is specified, the output Unicode String structure will
        be initialized to point to the NULL string.

    UnicodeString - Pointer to target Unicode String structure.

Return Value:

    None.

--*/

{
    LSAP_CR_CLEAR_VALUE IntermediateClearValue;

    if (ARGUMENT_PRESENT(ClearValue)) {

        IntermediateClearValue = *ClearValue;

        UnicodeString->Length = (USHORT) IntermediateClearValue.Length;
        UnicodeString->MaximumLength = (USHORT) IntermediateClearValue.MaximumLength;
        UnicodeString->Buffer = (PWSTR) IntermediateClearValue.Buffer;
        return;
    }

    UnicodeString->Length = UnicodeString->MaximumLength = 0;
    UnicodeString->Buffer = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\crypt\dll\block.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    block.c

Abstract:

    Block encryption functions implementation :

        RtlEncryptBlock
        RtlDecryptBlock
        RtlEncrypStdBlock


Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

    Scott Field (sfield)    03-Nov-97
        Removed critical section around crypto calls.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <crypt.h>
#include <engine.h>

#include <nturtl.h>

#include <windows.h>

#include <ntddksec.h>

#ifndef KMODE

HANDLE g_hKsecDD = NULL;

VOID EncryptMemoryShutdown( VOID );

#endif

BOOLEAN
Sys003Initialize(
    IN PVOID hmod,
    IN ULONG Reason,
    IN PCONTEXT Context
    )
{
#ifndef KMODE
    if( Reason == DLL_PROCESS_DETACH )
    {
        EncryptMemoryShutdown();
    }
#endif

    return TRUE;

    DBG_UNREFERENCED_PARAMETER(hmod);
    DBG_UNREFERENCED_PARAMETER(Context);
}



NTSTATUS
RtlEncryptBlock(
    IN PCLEAR_BLOCK ClearBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    )

/*++

Routine Description:

    Takes a block of data and encrypts it with a key producing
    an encrypted block of data.

Arguments:

    ClearBlock - The block of data that is to be encrypted.

    BlockKey - The key to use to encrypt data

    CypherBlock - Encrypted data is returned here

Return Values:

    STATUS_SUCCESS - The data was encrypted successfully. The encrypted
                     data block is in CypherBlock

    STATUS_UNSUCCESSFUL - Something failed. The CypherBlock is undefined.
--*/

{
    unsigned Result;

    Result = DES_ECB_LM(ENCR_KEY,
                        (const char *)BlockKey,
                        (unsigned char *)ClearBlock,
                        (unsigned char *)CypherBlock
                       );

    if (Result == CRYPT_OK) {
        return(STATUS_SUCCESS);
    } else {
#if DBG
        DbgPrint("EncryptBlock failed\n\r");
#endif
        return(STATUS_UNSUCCESSFUL);
    }
}




NTSTATUS
RtlDecryptBlock(
    IN PCYPHER_BLOCK CypherBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCLEAR_BLOCK ClearBlock
    )
/*++

Routine Description:

    Takes a block of encrypted data and decrypts it with a key producing
    the clear block of data.

Arguments:

    CypherBlock - The block of data to be decrypted

    BlockKey - The key to use to decrypt data

    ClearBlock - The decrpted block of data is returned here


Return Values:

    STATUS_SUCCESS - The data was decrypted successfully. The decrypted
                     data block is in ClearBlock

    STATUS_UNSUCCESSFUL - Something failed. The ClearBlock is undefined.
--*/

{
    unsigned Result;

    Result = DES_ECB_LM(DECR_KEY,
                        (const char *)BlockKey,
                        (unsigned char *)CypherBlock,
                        (unsigned char *)ClearBlock
                       );

    if (Result == CRYPT_OK) {
        return(STATUS_SUCCESS);
    } else {
#if DBG
        DbgPrint("DecryptBlock failed\n\r");
#endif
        return(STATUS_UNSUCCESSFUL);
    }
}



NTSTATUS
RtlEncryptStdBlock(
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    )

/*++

Routine Description:

    Takes a block key encrypts the standard text block with it.
    The resulting encrypted block is returned.
    This is a One-Way-Function - the key cannot be recovered from the
    encrypted data block.

Arguments:

    BlockKey - The key to use to encrypt the standard text block.

    CypherBlock - The encrypted data is returned here

Return Values:

    STATUS_SUCCESS - The encryption was successful.
                     The result is in CypherBlock

    STATUS_UNSUCCESSFUL - Something failed. The CypherBlock is undefined.
--*/

{
    unsigned Result;
    char StdEncrPwd[] = "KGS!@#$%";

    Result = DES_ECB_LM(ENCR_KEY,
                        (const char *)BlockKey,
                        (unsigned char *)StdEncrPwd,
                        (unsigned char *)CypherBlock
                       );

    if (Result == CRYPT_OK) {
        return(STATUS_SUCCESS);
    } else {
#if DBG
        DbgPrint("EncryptStd failed\n\r");
#endif
        return(STATUS_UNSUCCESSFUL);
    }
}

#ifndef KMODE

BOOLEAN
EncryptMemoryInitialize(
    VOID
    )
{
    UNICODE_STRING DriverName;
    OBJECT_ATTRIBUTES ObjA;
    IO_STATUS_BLOCK IOSB;
    HANDLE hFile;
    NTSTATUS Status;

    RtlInitUnicodeString( &DriverName, DD_KSEC_DEVICE_NAME_U );
    InitializeObjectAttributes(
                &ObjA,
                &DriverName,
                0,
                NULL,
                NULL
                );

    //
    // needs to be non-alertable, else, the DeviceIoControl may return
    // STATUS_USER_APC.
    //

    Status = NtOpenFile(
                &hFile,
                SYNCHRONIZE | FILE_READ_DATA,
                &ObjA,
                &IOSB,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT
                );

    if(!NT_SUCCESS(Status))
    {
        return FALSE;
    }

    if(InterlockedCompareExchangePointer(
                &g_hKsecDD,
                hFile,
                NULL
                ) != NULL)
    {
        NtClose( hFile );
    }

    return TRUE;
}

VOID
EncryptMemoryShutdown(
    VOID
    )
{
    if( g_hKsecDD != NULL )
    {
        NtClose( g_hKsecDD );
        g_hKsecDD = NULL;
    }

}

NTSTATUS
RtlEncryptMemory(
    IN      PVOID Memory,
    IN      ULONG MemorySize,
    IN      ULONG OptionFlags
    )
{
    IO_STATUS_BLOCK IoStatus;
    ULONG IoControlCode;
    NTSTATUS Status;

    if( g_hKsecDD == NULL )
    {
        if(!EncryptMemoryInitialize())
        {
            return STATUS_UNSUCCESSFUL;
        }
    }

    switch( OptionFlags )
    {
        case 0:
        {
            IoControlCode = IOCTL_KSEC_ENCRYPT_MEMORY;
            break;
        }

        case RTL_ENCRYPT_OPTION_CROSS_PROCESS:
        {
            IoControlCode = IOCTL_KSEC_ENCRYPT_MEMORY_CROSS_PROC;
            break;
        }

        case RTL_ENCRYPT_OPTION_SAME_LOGON:
        {
            IoControlCode = IOCTL_KSEC_ENCRYPT_MEMORY_SAME_LOGON;
            break;
        }

        default:
        {
            return STATUS_INVALID_PARAMETER;
        }
    }

    Status = NtDeviceIoControlFile(
                g_hKsecDD,
                NULL,
                NULL,
                NULL,
                &IoStatus,
                IoControlCode,
                Memory,
                MemorySize,          // output buffer size
                Memory,
                MemorySize
                );
#if DBG
    if((Status != 0) && (Status != STATUS_INVALID_PARAMETER))
    {
        KdPrint(("EncryptMemory IOCTL failed= 0x%lx\n\r", Status));
    }
#endif

    return Status;
}

NTSTATUS
RtlDecryptMemory(
    IN      PVOID Memory,
    IN      ULONG MemorySize,
    IN      ULONG OptionFlags
    )
{
    IO_STATUS_BLOCK IoStatus;
    ULONG IoControlCode;
    NTSTATUS Status;

    if( g_hKsecDD == NULL )
    {
        if(!EncryptMemoryInitialize())
        {
            return STATUS_UNSUCCESSFUL;
        }
    }

    switch( OptionFlags )
    {
        case 0:
        {
            IoControlCode = IOCTL_KSEC_DECRYPT_MEMORY;
            break;
        }

        case RTL_ENCRYPT_OPTION_CROSS_PROCESS:
        {
            IoControlCode = IOCTL_KSEC_DECRYPT_MEMORY_CROSS_PROC;
            break;
        }

        case RTL_ENCRYPT_OPTION_SAME_LOGON:
        {
            IoControlCode = IOCTL_KSEC_DECRYPT_MEMORY_SAME_LOGON;
            break;
        }

        default:
        {
            return STATUS_INVALID_PARAMETER;
        }
    }

    Status = NtDeviceIoControlFile(
                g_hKsecDD,
                NULL,
                NULL,
                NULL,
                &IoStatus,
                IoControlCode,
                Memory,
                MemorySize,          // output buffer size
                Memory,
                MemorySize
                );

#if DBG
    if((Status != 0) && (Status != STATUS_INVALID_PARAMETER))
    {
        KdPrint(("DecryptMemory IOCTL failed= 0x%lx\n\r", Status));
    }
#endif


    return Status;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\crypt\dll\owf.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    owf.c

Abstract:

    Implentation of the one-way-functions used to implement password hashing.

        RtlCalculateLmOwfPassword
        RtlCalculateNtOwfPassword


Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

--*/

#ifndef KMODE
#define _ADVAPI32_
#endif

#include <nt.h>
#include <ntrtl.h>
#ifndef KMODE
#include <nturtl.h>
#endif
#include <crypt.h>
#include <engine.h>
#ifndef KMODE
#include <windef.h>
#include <winbase.h>
#include <wincrypt.h>
#endif

#ifndef KMODE
//
// Globals used for allowing the replacement of the OWF functions
//
HCRYPTPROV KerbGlobalStrToKeyProvider = 0;
BOOLEAN    KerbGlobalAvailableStrToKeyProvider = TRUE;

//+-------------------------------------------------------------------------
//
//  Function:   CheckForOutsideStringToKey
//
//  Synopsis:   Call CryptoAPI to query to see if a CSP is registered
//              of the type PROV_REPLACE_OWF.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns: STATUS_SUCCESS if it succeeds, otherwise STATUS_UNSUCCESSFUL
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
CheckForOutsideStringToKey()
{
    HCRYPTPROV hProv = 0;
    BOOLEAN fRet = FALSE;

    if (!KerbGlobalAvailableStrToKeyProvider)
    {
        goto Cleanup;
    }
        
    //
    // see if there is a replacement provider
    if (0 != KerbGlobalStrToKeyProvider)
    {
        // if there is proceed to use it
        fRet = TRUE;
        goto Cleanup;
    }
    else
    {
        //
        // Try to acquire a context to a CSP which is used for OWF replacement
        //
        if (!CryptAcquireContext(&hProv,
                                 NULL,
                                 NULL,
                                 PROV_REPLACE_OWF,
                                 CRYPT_VERIFYCONTEXT))
        {
            KerbGlobalAvailableStrToKeyProvider = FALSE;
            goto Cleanup;
        }

        //
        // exchange the local and the global in a safe way
        //
        if (0 != InterlockedCompareExchangePointer(
                    (PVOID*)&KerbGlobalStrToKeyProvider,
                    (PVOID)hProv,
                    0))
        {
            CryptReleaseContext(hProv, 0);
        }
        fRet = TRUE;
    }
Cleanup:
    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Function:   UseOutsideStringToKey
//
//  Synopsis:   Calls the CSP to do an outside StringToKey function
//              using the hashing entry points of CryptoAPI.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
UseOutsideStringToKey(
    IN PCHAR pPassword,
    IN USHORT cbPassword,
    IN ULONG ulFlags,
    IN ULONG cbKey,
    OUT PUCHAR pbKey
    )
{
    HCRYPTHASH hHash = 0;
    ULONG cb;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    if (!CheckForOutsideStringToKey())
    {
        // STATUS_UNSUCCESSFUL indicates not to fallback to default OWF calculation
        // so we don't want to use that here
        Status = NTE_BAD_PROVIDER;
        goto Cleanup;
    }


    //
    // create the hash
    //
    if (!CryptCreateHash(KerbGlobalStrToKeyProvider,
                         CALG_HASH_REPLACE_OWF,
                         0,
                         0,
                         &hHash))
    {
        goto Cleanup;
    }

    //
    // hash the password
    //
    if (!CryptHashData(hHash,
                       pPassword,
                       (ULONG)cbPassword,
                       ulFlags))
    {
        if (NTE_BAD_DATA == GetLastError())
        {
            Status = NTE_BAD_DATA;
        }
        goto Cleanup;
    }

    //
    // Get the HP_HASHVAL, this is the key
    //
    cb = cbKey;
    if (!CryptGetHashParam(hHash,
                           HP_HASHVAL,
                           pbKey,
                           &cb,
                           0))
    {
        if (NTE_BAD_LEN == GetLastError())
        {
            Status = NTE_BAD_DATA;
        }
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;
Cleanup:
    if (0 != hHash)
    {
        CryptDestroyHash(hHash);
    }
    return Status;
}
#endif


NTSTATUS
RtlCalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    )

/*++

Routine Description:

    Takes the passed LmPassword and performs a one-way-function on it.
    The current implementation does this by using the password as a key
    to encrypt a known block of text.

Arguments:

    LmPassword - The password to perform the one-way-function on.

    LmOwfPassword - The hashed password is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully. The hashed
                     password is in LmOwfPassword.

    STATUS_UNSUCCESSFUL - Something failed. The LmOwfPassword is undefined.
--*/

{
    NTSTATUS    Status = STATUS_UNSUCCESSFUL;
    BLOCK_KEY   Key[2];
    PCHAR       pKey;

#ifndef KMODE
    Status = UseOutsideStringToKey(
                    LmPassword,
                    (USHORT)strlen(LmPassword),
                    sizeof(LM_OWF_PASSWORD),
                    CRYPT_OWF_REPL_LM_HASH,
                    (PUCHAR)&(LmOwfPassword->data[0])
                    );

    //
    // the function will return STATUS_UNSUCCESSFUL indicates not to fall
    // back to the typical string to key function.
    // 
    if ((NT_SUCCESS(Status)) || (STATUS_UNSUCCESSFUL == Status))
    {
        return Status;
    }
#endif

    // Copy the password into our key buffer and zero pad to fill the 2 keys

    pKey = (PCHAR)(&Key[0]);

    while (*LmPassword && (pKey < (PCHAR)(&Key[2]))) {
        *pKey++ = *LmPassword++;
    }

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }

    // Use the keys to encrypt the standard text

    Status = RtlEncryptStdBlock(&Key[0], &(LmOwfPassword->data[0]));

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlEncryptStdBlock(&Key[1], &(LmOwfPassword->data[1]));

    //
    // clear our copy of the cleartext password
    //

    pKey = (PCHAR)(&Key[0]);

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }

    RtlSecureZeroMemory( &Key, sizeof(Key) );

    return(Status);
}




NTSTATUS
RtlCalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    )

/*++

Routine Description:

    Takes the passed NtPassword and performs a one-way-function on it.
    Uses the RSA MD4 function

Arguments:

    NtPassword - The password to perform the one-way-function on.

    NtOwfPassword - The hashed password is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully. The hashed
                     password is in NtOwfPassword.
--*/

{
    MD4_CTX     MD4_Context;
    NTSTATUS    Status = STATUS_UNSUCCESSFUL;

#ifndef KMODE
    Status = UseOutsideStringToKey(
                    (PCHAR)NtPassword->Buffer,
                    (USHORT)NtPassword->Length,
                    0,
                    sizeof(*NtOwfPassword),
                    (PUCHAR)NtOwfPassword
                    );

    //
    // the function will return STATUS_UNSUCCESSFUL indicates not to fall
    // back to the typical string to key function.
    // 
    if ((NT_SUCCESS(Status)) || (STATUS_UNSUCCESSFUL == Status))
    {
        return Status;
    }
#endif

    MD4Init(&MD4_Context);

    MD4Update(&MD4_Context, (PCHAR)NtPassword->Buffer, NtPassword->Length);

    MD4Final(&MD4_Context);


    // Copy the digest into our return data area

    ASSERT(sizeof(*NtOwfPassword) == sizeof(MD4_Context.digest));

    RtlCopyMemory((PVOID)NtOwfPassword, (PVOID)MD4_Context.digest,
                  sizeof(*NtOwfPassword));

    RtlSecureZeroMemory( &MD4_Context, sizeof(MD4_Context) );

    return(STATUS_SUCCESS);
}



BOOLEAN
RtlEqualLmOwfPassword(
    IN PLM_OWF_PASSWORD LmOwfPassword1,
    IN PLM_OWF_PASSWORD LmOwfPassword2
    )

/*++

Routine Description:

    Compares two Lanman One-way-function-passwords

Arguments:

    LmOwfPassword1/2 - The one-way-functions to compare

Return Values:

    TRUE if the one-way-functions match, otherwise FALSE

--*/

{
    return((BOOLEAN)(RtlCompareMemory(LmOwfPassword1,
                                      LmOwfPassword2,
                                      LM_OWF_PASSWORD_LENGTH)

                    == LM_OWF_PASSWORD_LENGTH));
}



BOOLEAN
RtlEqualNtOwfPassword(
    IN PNT_OWF_PASSWORD NtOwfPassword1,
    IN PNT_OWF_PASSWORD NtOwfPassword2
    )

/*++

Routine Description:

    Compares two NT One-way-function-passwords

Arguments:

    NtOwfPassword1/2 - The one-way-functions to compare

Return Values:

    TRUE if the one-way-functions match, otherwise FALSE

--*/

{
    return((BOOLEAN)(RtlCompareMemory(NtOwfPassword1,
                                      NtOwfPassword2,
                                      NT_OWF_PASSWORD_LENGTH)

                    == NT_OWF_PASSWORD_LENGTH));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\crypt\dll\rng.c ===
#include <nt.h>
#include <ntrtl.h>
#include <crypt.h>
#include <engine.h>

#include <nturtl.h>

#include <windows.h>
#include <randlib.h>


BOOLEAN
RtlGenRandom(
    OUT PVOID RandomBuffer,
    IN  ULONG RandomBufferLength
    )
{
#ifdef KMODE
    return FALSE;
#else

    return (BOOLEAN)NewGenRandom(
                        NULL,
                        0,
                        (unsigned char*)RandomBuffer,
                        RandomBufferLength
                        );

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\crypt\dll\kmode\makefile.inc ===
$(O)\sys003k.lib: $(O)\cryptk.lib
    lib -out:$@ $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\idl\efsimp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    efsimp.h

Abstract:

    EFS RPC Interfaces, private includes

Author:

    Robert Reichel       (RobertRe)       October 15, 1997

Environment:

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windef.h>
#include <winbase.h>
#include <wincrypt.h>
#include <winefs.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\crypt\dll\owfcrypt.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    owdcrypt.c

Abstract:

    Contains functions that reversibly encrypt OwfPasswords

        RtlEncryptLmOwfPwdWithLmOwfPwd
        RtlDecryptLmOwfPwdWithLmOwfPwd

        RtlEncryptLmOwfPwdWithLmSesKey
        RtlDecryptLmOwfPwdWithLmSesKey

        RtlEncryptLmOwfPwdWithUserKey
        RtlDecryptLmOwfPwdWithUserKey

        RtlEncryptLmOwfPwdWithIndex
        RtlDecryptLmOwfPwdWithIndex

        RtlEncryptNtOwfPwdWithNtOwfPwd
        RtlDecryptNtOwfPwdWithNtOwfPwd

        RtlEncryptNtOwfPwdWithNtSesKey
        RtlDecryptNtOwfPwdWithNtSesKey

        RtlEncryptNtOwfPwdWithUserKey
        RtlDecryptNtOwfPwdWithUserKey

        RtlEncryptNtOwfPwdWithIndex
        RtlDecryptNtOwfPwdWithIndex


Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <crypt.h>


NTSTATUS
RtlEncryptLmOwfPwdWithLmOwfPwd(
    IN PLM_OWF_PASSWORD DataLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    )

/*++

Routine Description:

    Encrypts one OwfPassword with another

Arguments:

    DataLmOwfPassword - OwfPassword to be encrypted

    KeyLmOwfPassword - OwfPassword to be used as a key to the encryption

    EncryptedLmOwfPassword - The encrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The encrypted
                     OwfPassword is in EncryptedLmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The EncryptedLmOwfPassword is undefined.
--*/

{
    NTSTATUS    Status;

    Status = RtlEncryptBlock((PCLEAR_BLOCK)&(DataLmOwfPassword->data[0]),
                             &(((PBLOCK_KEY)(KeyLmOwfPassword->data))[0]),
                             &(EncryptedLmOwfPassword->data[0]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlEncryptBlock((PCLEAR_BLOCK)&(DataLmOwfPassword->data[1]),
                             &(((PBLOCK_KEY)(KeyLmOwfPassword->data))[1]),
                             &(EncryptedLmOwfPassword->data[1]));

    return(Status);
}



NTSTATUS
RtlDecryptLmOwfPwdWithLmOwfPwd(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PLM_OWF_PASSWORD DataLmOwfPassword
    )

/*++

Routine Description:

    Decrypts one OwfPassword with another

Arguments:

    EncryptedLmOwfPassword - The ecnrypted OwfPassword to be decrypted

    KeyLmOwfPassword - OwfPassword to be used as a key to the encryption

    DataLmOwfPassword - The decrpted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The decrypted
                     OwfPassword is in DataLmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The DataLmOwfPassword is undefined.
--*/

{
    NTSTATUS    Status;

    Status = RtlDecryptBlock(&(EncryptedLmOwfPassword->data[0]),
                             &(((PBLOCK_KEY)(KeyLmOwfPassword->data))[0]),
                             (PCLEAR_BLOCK)&(DataLmOwfPassword->data[0]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlDecryptBlock(&(EncryptedLmOwfPassword->data[1]),
                             &(((PBLOCK_KEY)(KeyLmOwfPassword->data))[1]),
                             (PCLEAR_BLOCK)&(DataLmOwfPassword->data[1]));

    return(Status);
}




NTSTATUS
RtlEncryptNtOwfPwdWithNtOwfPwd(
    IN PNT_OWF_PASSWORD DataNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    )
/*++

Routine Description:

    Encrypts one OwfPassword with another

Arguments:

    DataLmOwfPassword - OwfPassword to be encrypted

    KeyLmOwfPassword - OwfPassword to be used as a key to the encryption

    EncryptedLmOwfPassword - The encrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The encrypted
                     OwfPassword is in EncryptedLmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The EncryptedLmOwfPassword is undefined.
--*/
{
    return(RtlEncryptLmOwfPwdWithLmOwfPwd(
            (PLM_OWF_PASSWORD)DataNtOwfPassword,
            (PLM_OWF_PASSWORD)KeyNtOwfPassword,
            (PENCRYPTED_LM_OWF_PASSWORD)EncryptedNtOwfPassword));
}


NTSTATUS
RtlDecryptNtOwfPwdWithNtOwfPwd(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PNT_OWF_PASSWORD DataNtOwfPassword
    )

/*++

Routine Description:

    Decrypts one OwfPassword with another

Arguments:

    EncryptedLmOwfPassword - The ecnrypted OwfPassword to be decrypted

    KeyLmOwfPassword - OwfPassword to be used as a key to the encryption

    DataLmOwfPassword - The decrpted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The decrypted
                     OwfPassword is in DataLmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The DataLmOwfPassword is undefined.
--*/

{
    return(RtlDecryptLmOwfPwdWithLmOwfPwd(
            (PENCRYPTED_LM_OWF_PASSWORD)EncryptedNtOwfPassword,
            (PLM_OWF_PASSWORD)KeyNtOwfPassword,
            (PLM_OWF_PASSWORD)DataNtOwfPassword));
}




NTSTATUS
RtlEncryptLmOwfPwdWithLmSesKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PLM_SESSION_KEY  LmSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    )
/*++

Routine Description:

    Encrypts an OwfPassword with a session key

Arguments:

    LmOwfPassword - OwfPassword to be encrypted

    LmSessionKey - key to the encryption

    EncryptedLmOwfPassword - The ecnrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The encrypted
                     OwfPassword is in EncryptedLmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The LMEncryptedLmOwfPassword is undefined.
--*/
{
    NTSTATUS    Status;

    Status = RtlEncryptBlock((PCLEAR_BLOCK)&(LmOwfPassword->data[0]),
                             (PBLOCK_KEY)LmSessionKey,
                             &(EncryptedLmOwfPassword->data[0]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlEncryptBlock((PCLEAR_BLOCK)&(LmOwfPassword->data[1]),
                             (PBLOCK_KEY)LmSessionKey,
                             &(EncryptedLmOwfPassword->data[1]));

    return(Status);
}



NTSTATUS
RtlDecryptLmOwfPwdWithLmSesKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_SESSION_KEY  LmSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    )
/*++

Routine Description:

    Decrypts one OwfPassword with a session key

Arguments:

    EncryptedLmOwfPassword - The ecnrypted OwfPassword to be decrypted

    LmSessionKey - key to the encryption

    LmOwfPassword - The decrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The decrypted
                     OwfPassword is in LmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The LmOwfPassword is undefined.
--*/
{
    NTSTATUS    Status;


    Status = RtlDecryptBlock(&(EncryptedLmOwfPassword->data[0]),
                             (PBLOCK_KEY)LmSessionKey,
                             (PCLEAR_BLOCK)&(LmOwfPassword->data[0]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlDecryptBlock(&(EncryptedLmOwfPassword->data[1]),
                             (PBLOCK_KEY)LmSessionKey,
                             (PCLEAR_BLOCK)&(LmOwfPassword->data[1]));

    return(Status);
}



NTSTATUS
RtlEncryptNtOwfPwdWithNtSesKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PNT_SESSION_KEY  NtSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    )
/*++

Routine Description:

    Encrypts an OwfPassword with a session key

Arguments:

    NtOwfPassword - OwfPassword to be encrypted

    NtSessionKey - key to the encryption

    EncryptedNtOwfPassword - The encrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The encrypted
                     OwfPassword is in EncryptedNtOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The EncryptedNtOwfPassword is undefined.
--*/
{
    ASSERT(sizeof(LM_OWF_PASSWORD) == sizeof(NT_OWF_PASSWORD));
    ASSERT(sizeof(LM_SESSION_KEY) == sizeof(NT_SESSION_KEY));
    ASSERT(sizeof(ENCRYPTED_LM_OWF_PASSWORD) == sizeof(ENCRYPTED_NT_OWF_PASSWORD));

    return(RtlEncryptLmOwfPwdWithLmSesKey(
            (PLM_OWF_PASSWORD)NtOwfPassword,
            (PLM_SESSION_KEY)NtSessionKey,
            (PENCRYPTED_LM_OWF_PASSWORD)EncryptedNtOwfPassword));
}


NTSTATUS
RtlDecryptNtOwfPwdWithNtSesKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_SESSION_KEY  NtSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    )
/*++

Routine Description:

    Decrypts one OwfPassword with a session key

Arguments:

    EncryptedNtOwfPassword - The ecnrypted OwfPassword to be decrypted

    NtSessionKey - key to the encryption

    NtOwfPassword - The decrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The decrypted
                     OwfPassword is in NtOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The NtOwfPassword is undefined.
--*/
{
    ASSERT(sizeof(LM_OWF_PASSWORD) == sizeof(NT_OWF_PASSWORD));
    ASSERT(sizeof(LM_SESSION_KEY) == sizeof(NT_SESSION_KEY));
    ASSERT(sizeof(ENCRYPTED_LM_OWF_PASSWORD) == sizeof(ENCRYPTED_NT_OWF_PASSWORD));

    return(RtlDecryptLmOwfPwdWithLmSesKey(
            (PENCRYPTED_LM_OWF_PASSWORD)EncryptedNtOwfPassword,
            (PLM_SESSION_KEY)NtSessionKey,
            (PLM_OWF_PASSWORD)NtOwfPassword));
}



VOID
KeysFromIndex(
    IN PCRYPT_INDEX Index,
    OUT BLOCK_KEY Key[2])
/*++

Routine Description:

    Helper function - generates 2 keys from an index value

--*/
{
    PCHAR   pKey, pIndex;
    PCHAR   IndexStart = (PCHAR)&(Index[0]);
    PCHAR   IndexEnd =   (PCHAR)&(Index[1]);
    PCHAR   KeyStart = (PCHAR)&(Key[0]);
    PCHAR   KeyEnd   = (PCHAR)&(Key[2]);

    // Calculate the keys by concatenating the index with itself

    pKey = KeyStart;
    pIndex = IndexStart;

    while (pKey < KeyEnd) {

        *pKey++ = *pIndex++;

        if (pIndex == IndexEnd) {

            // Start at beginning of index again
            pIndex = IndexStart;
        }
    }
}



NTSTATUS
RtlEncryptLmOwfPwdWithIndex(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    )
/*++

Routine Description:

    Encrypts an OwfPassword with an index

Arguments:

    LmOwfPassword - OwfPassword to be encrypted

    INDEX - value to be used as encryption key

    EncryptedLmOwfPassword - The ecnrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The encrypted
                     OwfPassword is in EncryptedLmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The EncryptedLmOwfPassword is undefined.
--*/
{
    NTSTATUS    Status;
    BLOCK_KEY    Key[2];

    // Calculate the keys

    KeysFromIndex(Index, &(Key[0]));

    // Use the keys

    Status = RtlEncryptBlock((PCLEAR_BLOCK)&(LmOwfPassword->data[0]),
                             &(Key[0]),
                             &(EncryptedLmOwfPassword->data[0]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlEncryptBlock((PCLEAR_BLOCK)&(LmOwfPassword->data[1]),
                             &(Key[1]),
                             &(EncryptedLmOwfPassword->data[1]));

    return(Status);
}



NTSTATUS
RtlDecryptLmOwfPwdWithIndex(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    )
/*++

Routine Description:

    Decrypts an OwfPassword with an index

Arguments:

    EncryptedLmOwfPassword - The encrypted OwfPassword to be decrypted

    INDEX - value to be used as decryption key

    LmOwfPassword - Decrypted OwfPassword is returned here


Return Values:

    STATUS_SUCCESS - The function completed successfully. The decrypted
                     OwfPassword is in LmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The LmOwfPassword is undefined.
--*/
{
    NTSTATUS    Status;
    BLOCK_KEY    Key[2];

    // Calculate the keys

    KeysFromIndex(Index, &(Key[0]));

    // Use the keys

    Status = RtlDecryptBlock(&(EncryptedLmOwfPassword->data[0]),
                             &(Key[0]),
                             (PCLEAR_BLOCK)&(LmOwfPassword->data[0]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlDecryptBlock(&(EncryptedLmOwfPassword->data[1]),
                             &(Key[1]),
                             (PCLEAR_BLOCK)&(LmOwfPassword->data[1]));

    return(Status);
}



NTSTATUS
RtlEncryptNtOwfPwdWithIndex(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    )
/*++

Routine Description:

    Encrypts an OwfPassword with an index

Arguments:

    NtOwfPassword - OwfPassword to be encrypted

    Index - value to be used as encryption key

    EncryptedNtOwfPassword - The encrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The encrypted
                     OwfPassword is in EncryptedNtOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The EncryptedNtOwfPassword is undefined.
--*/
{
    ASSERT(sizeof(LM_OWF_PASSWORD) == sizeof(NT_OWF_PASSWORD));
    ASSERT(sizeof(ENCRYPTED_LM_OWF_PASSWORD) == sizeof(ENCRYPTED_NT_OWF_PASSWORD));

    return(RtlEncryptLmOwfPwdWithIndex(
                            (PLM_OWF_PASSWORD)NtOwfPassword,
                            Index,
                            (PENCRYPTED_LM_OWF_PASSWORD)EncryptedNtOwfPassword));
}



NTSTATUS
RtlDecryptNtOwfPwdWithIndex(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    )
/*++

Routine Description:

    Decrypts an NtOwfPassword with an index

Arguments:

    EncryptedNtOwfPassword - The encrypted OwfPassword to be decrypted

    Index - value to be used as decryption key

    NtOwfPassword - Decrypted NtOwfPassword is returned here


Return Values:

    STATUS_SUCCESS - The function completed successfully. The decrypted
                     OwfPassword is in NtOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The NtOwfPassword is undefined.
--*/
{
    ASSERT(sizeof(LM_OWF_PASSWORD) == sizeof(NT_OWF_PASSWORD));
    ASSERT(sizeof(ENCRYPTED_LM_OWF_PASSWORD) == sizeof(ENCRYPTED_NT_OWF_PASSWORD));

    return(RtlDecryptLmOwfPwdWithIndex(
                            (PENCRYPTED_LM_OWF_PASSWORD)EncryptedNtOwfPassword,
                            Index,
                            (PLM_OWF_PASSWORD)NtOwfPassword));
}




NTSTATUS
RtlEncryptLmOwfPwdWithUserKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PUSER_SESSION_KEY  UserSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    )
/*++

Routine Description:

    Encrypts an OwfPassword with a session key

Arguments:

    LmOwfPassword - OwfPassword to be encrypted

    UserSessionKey - key to the encryption

    EncryptedLmOwfPassword - The encrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The encrypted
                     OwfPassword is in EncryptedLmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The EncryptedLmOwfPassword is undefined.
--*/
{
    ASSERT(sizeof(USER_SESSION_KEY) == sizeof(LM_OWF_PASSWORD));

    return(RtlEncryptLmOwfPwdWithLmOwfPwd(LmOwfPassword,
                                          (PLM_OWF_PASSWORD)UserSessionKey,
                                          EncryptedLmOwfPassword));
}



NTSTATUS
RtlDecryptLmOwfPwdWithUserKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PUSER_SESSION_KEY  UserSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    )
/*++

Routine Description:

    Decrypts one OwfPassword with a session key

Arguments:

    EncryptedLmOwfPassword - The ecnrypted OwfPassword to be decrypted

    UserSessionKey - key to the encryption

    LmOwfPassword - The decrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The decrypted
                     OwfPassword is in LmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The LmOwfPassword is undefined.
--*/
{
    ASSERT(sizeof(USER_SESSION_KEY) == sizeof(LM_OWF_PASSWORD));

    return(RtlDecryptLmOwfPwdWithLmOwfPwd(EncryptedLmOwfPassword,
                                          (PLM_OWF_PASSWORD)UserSessionKey,
                                          LmOwfPassword));
}



NTSTATUS
RtlEncryptNtOwfPwdWithUserKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PUSER_SESSION_KEY  UserSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    )
/*++

Routine Description:

    Encrypts an OwfPassword with a user session key

Arguments:

    NtOwfPassword - OwfPassword to be encrypted

    UserSessionKey - key to the encryption

    EncryptedNtOwfPassword - The encrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The encrypted
                     OwfPassword is in EncryptedNtOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The EncryptedNtOwfPassword is undefined.
--*/
{
    ASSERT(sizeof(NT_OWF_PASSWORD) == sizeof(LM_OWF_PASSWORD));
    ASSERT(sizeof(ENCRYPTED_NT_OWF_PASSWORD) == sizeof(ENCRYPTED_LM_OWF_PASSWORD));

    return(RtlEncryptLmOwfPwdWithUserKey(
            (PLM_OWF_PASSWORD)NtOwfPassword,
            UserSessionKey,
            (PENCRYPTED_LM_OWF_PASSWORD)EncryptedNtOwfPassword));
}



NTSTATUS
RtlDecryptNtOwfPwdWithUserKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PUSER_SESSION_KEY  UserSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    )
/*++

Routine Description:

    Decrypts one OwfPassword with a user session key

Arguments:

    EncryptedNtOwfPassword - The ecnrypted OwfPassword to be decrypted

    UserSessionKey - key to the encryption

    NtOwfPassword - The decrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The decrypted
                     OwfPassword is in NtOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The NtOwfPassword is undefined.
--*/
{
    ASSERT(sizeof(NT_OWF_PASSWORD) == sizeof(LM_OWF_PASSWORD));
    ASSERT(sizeof(ENCRYPTED_NT_OWF_PASSWORD) == sizeof(ENCRYPTED_LM_OWF_PASSWORD));

    return(RtlDecryptLmOwfPwdWithUserKey(
            (PENCRYPTED_LM_OWF_PASSWORD)EncryptedNtOwfPassword,
            UserSessionKey,
            (PLM_OWF_PASSWORD)NtOwfPassword));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\crypt\dll\response.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    response.c

Abstract:

    Contains functions that calculate the correct response to return
    to the server when logging on.

        RtlCalculateLmResponse
        RtlCalculateNtResponse


Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <crypt.h>



NTSTATUS
RtlCalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    )

/*++

Routine Description:

    Takes the challenge sent by the server and the OwfPassword generated
    from the password the user entered and calculates the response to
    return to the server.

Arguments:

    LmChallenge - The challenge sent by the server

    LmOwfPassword - The hashed password.

    LmResponse - The response is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The response
                     is in LmResponse.

    STATUS_UNSUCCESSFUL - Something failed. The LmResponse is undefined.
--*/

{
    NTSTATUS    Status;
    BLOCK_KEY    Key;
    PCHAR       pKey, pData;

    // The first 2 keys we can get at by type-casting

    Status = RtlEncryptBlock(LmChallenge,
                             &(((PBLOCK_KEY)(LmOwfPassword->data))[0]),
                             &(LmResponse->data[0]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlEncryptBlock(LmChallenge,
                             &(((PBLOCK_KEY)(LmOwfPassword->data))[1]),
                             &(LmResponse->data[1]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    // To get the last key we must copy the remainder of the OwfPassword
    // and fill the rest of the key with 0s

    pKey = &(Key.data[0]);
    pData = (PCHAR)&(((PBLOCK_KEY)(LmOwfPassword->data))[2]);

    while (pData < (PCHAR)&(LmOwfPassword->data[2])) {
        *pKey++ = *pData++;
    }

    // Zero extend

    while (pKey < (PCHAR)&((&Key)[1])) {
        *pKey++ = 0;
    }

    // Use the 3rd key

    Status = RtlEncryptBlock(LmChallenge, &Key, &(LmResponse->data[2]));

    RtlSecureZeroMemory( &Key, sizeof(Key) );

    return(Status);
}







NTSTATUS
RtlCalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    )
/*++

Routine Description:

    Takes the challenge sent by the server and the OwfPassword generated
    from the password the user entered and calculates the response to
    return(to the server.

Arguments:

    NtChallenge - The challenge sent by the server

    NtOwfPassword - The hashed password.

    NtResponse - The response is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The response
                     is in NtResponse.

    STATUS_UNSUCCESSFUL - Something failed. The NtResponse is undefined.
--*/

{

    // Use the LM version until we change the definitions of any of
    // these data types

    return(RtlCalculateLmResponse((PLM_CHALLENGE)NtChallenge,
                                  (PLM_OWF_PASSWORD)NtOwfPassword,
                                  (PLM_RESPONSE)NtResponse));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\crypt\dll\userkey.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    userkey.c

Abstract:

    Implentation of the functions that get and generate user session keys

        RtlCalculateUserSessionKeyLm
        RtlCalculateUserSessionKeyNt
        RtlGetUserSessionKeyClient
        RtlGetUserSessionKeyServer


Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddnfs.h>
#include <rpc.h>
#include <rpcndr.h>
#include <crypt.h>
#include <srvfsctl.h>       // Server definitions
#include <status.h>         // Server return codes

//
// Define this if you want to know all about user session keys
//

// #define DEBUG_USER_SESSION_KEYS



#define REDIRECTOR_DEVICENAME L"\\Device\\LanmanRedirector\\"
#define REDIRECTOR_IPC_FILENAME L"\\IPC$"


//
// Define the user session key to be used for local connections
// Make sure the initial data fills the structure completely !
//

USER_SESSION_KEY LocalSessionKey = { 'S', 'y', 's', 't', 'e', 'm', 'L', 'i',
                                     'b', 'r', 'a', 'r', 'y', 'D', 'T', 'C'
                                   };

//
// Define the user session key that represents an error.
// This value will be generated by other parts of the system on failure.
// We will check for it in our query code and return an error if it's found.
//

USER_SESSION_KEY ErrorSessionKey = { 0, 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0
                                   };



NTSTATUS
RtlCalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Takes the passed Response and OwfPassword and generates a UserSessionKey.

    The current implementation takes the one-way-function of the OwfPassword
    and returns this as the key.

Arguments:

    LmResponse - The response sent during session setup.

    LmOwfPassword - The hashed version of the user's password.

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_UNSUCCESSFUL - Something failed. The UserSessionKey is undefined.
--*/

{
    NTSTATUS Status;
    NT_PASSWORD NtPassword;

    //
    // Make the Owf password look like an NT password
    //

    NtPassword.Buffer = (PWSTR)LmOwfPassword; // We can do this cast because we
                                              // know the OWF routine treats this
                                              // pointer as a byte pointer.
    NtPassword.Length = sizeof(*LmOwfPassword);
    NtPassword.MaximumLength = sizeof(*LmOwfPassword);


    //
    // Calculate the OWF of the OwfPassword
    //

    ASSERT(sizeof(NT_OWF_PASSWORD) == sizeof(*UserSessionKey));

    Status = RtlCalculateNtOwfPassword( &NtPassword,
                                        (PNT_OWF_PASSWORD)UserSessionKey
                                        );
    if (!NT_SUCCESS(Status)) {
        KdPrint(("RtlCalculateUserSessionKeyLm : OWF calculation failed, status = 0x%lx\n", Status));
        return(Status);
    }

    //
    // Check if we've generated the error session key
    //

    if (RtlCompareMemory(UserSessionKey, &ErrorSessionKey,
                       sizeof(*UserSessionKey)) == sizeof(*UserSessionKey)) {

#ifdef DEBUG_USER_SESSION_KEYS
        KdPrint(("RtlCalculateSessionKeyLm - generated error session key, modifying it\n"));
#endif
        //
        // Move away from the error session key
        //

        UserSessionKey->data[0].data[0] ++;

        ASSERT(RtlCompareMemory(UserSessionKey, &ErrorSessionKey,
                       sizeof(*UserSessionKey)) != sizeof(*UserSessionKey));
    }

#ifdef DEBUG_USER_SESSION_KEYS
    KdPrint(("RtlCalculateUserSessionKeyLm : Key = 0x%lx : %lx : %lx : %lx\n",
            ((PULONG)UserSessionKey)[0], ((PULONG)UserSessionKey)[1],
            ((PULONG)UserSessionKey)[2], ((PULONG)UserSessionKey)[3]));
#endif

    return(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER(LmResponse);
}



NTSTATUS
RtlCalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Takes the passed Response and OwfPassword and generates a UserSessionKey.

Arguments:

    NtResponse - The response sent during session setup.

    NtOwfPassword - The hashed version of the user's password.

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_UNSUCCESSFUL - Something failed. The UserSessionKey is undefined.
--*/

{
    // Just call the LM version

    ASSERT(sizeof(NT_RESPONSE) == sizeof(LM_RESPONSE));
    ASSERT(sizeof(NT_OWF_PASSWORD) == sizeof(LM_OWF_PASSWORD));

    return(RtlCalculateUserSessionKeyLm((PLM_RESPONSE)NtResponse,
                                        (PLM_OWF_PASSWORD)NtOwfPassword,
                                        UserSessionKey));
}


NTSTATUS
RtlGetUserSessionKeyClientBinding(
    IN PVOID RpcBindingHandle,
    OUT HANDLE *RedirHandle,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Returns the user session key associated with an rpc connection.
    This function should be called by the client side of the connection only.

Arguments:

    RpcBindingHandle - The rpc connection we're interested in

    RedirHandle - Returns a handle to the redir.  Since RpcBindingHandles don't represent
        and open connection to the server, we have to ensure the connection stays open
        until the server side has a chance to get this same UserSessionKey.  The only
        way to do that is to keep the connect open.

        Returns NULL if no handle is needed.

        This handle should be closed by calling NtClose.

    UserSessionKey - The user session key is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_LOCAL_USER_SESSION_KEY - An informational status value.
                   - The rpc connection is local, the usersessionkey returned
                   - is constant and not unique to this connection.
                   - There is little to be gained by encrypting data over
                   - this connection

    STATUS_NO_USER_SESSION_KEY - No session key exists for this session.

    ------ these come from parsebinding -------

    RPC_NT_OUT_OF_MEMORY - Insufficent memory is available to allocate
        space for the fields of the string binding.

    RPC_NT_INVALID_STRING_BINDING - The string binding is syntactically
        invalid.

    RPC_NT_INVALID_ARG - The string binding is not specified
        (ie. ARGUMENT_PRESENT(StringBinding) is false).
--*/

{
    NTSTATUS Status, IgnoreStatus;
    WCHAR    *StringBinding;
    WCHAR    *ServerNameZ;
    WCHAR    *BareServerNameZ; // Points to server name minus leading '\'s
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING ServerName;
    UNICODE_STRING RedirDevice;
    UNICODE_STRING IpcFileName;
    UNICODE_STRING ServerIpcFileName;
    USHORT  LengthRequired;
    IO_STATUS_BLOCK IoStatusBlock;
    LMR_REQUEST_PACKET RdrRequestPacket;
    LMR_CONNECTION_INFO_2 ConnectionInfo;


    //
    // Get the string description of the binding from the rpc handle
    //

    *RedirHandle = NULL;
    Status = (NTSTATUS)I_RpcMapWin32Status(
            RpcBindingToStringBindingW(RpcBindingHandle, &StringBinding));
    if (!NT_SUCCESS(Status)) {
        KdPrint(("RtlGetUserSessionKeyClient - failed to get stringbinding, Status = 0x%lx\n\r", Status));
        return(Status);
    }

    //
    // Parse the stringbinding to get the server name
    //

    Status = (NTSTATUS)I_RpcMapWin32Status(RpcStringBindingParseW(
                                StringBinding,
                                NULL,                // object uid
                                NULL,                // protseq !
                                &ServerNameZ,        // network address
                                NULL,                // endpoint
                                NULL                 // network options
                                ));

    //
    // We're finished with the string binding
    //

    IgnoreStatus = I_RpcMapWin32Status(RpcStringFreeW(&StringBinding));
    ASSERT(NT_SUCCESS(IgnoreStatus));

    //
    // Check the result of binding parse
    //

    if (!NT_SUCCESS(Status)) {
        KdPrint(("RtlGetUserSessionKeyClient - failed to parse stringbinding, status = 0x%lx\n\r", Status));
        return(Status);
    }

    //
    // Check for a local connection
    //

    if ( (ServerNameZ == NULL) || (ServerNameZ[0] == UNICODE_NULL) ) {

#ifdef DEBUG_USER_SESSION_KEYS
        KdPrint(("RtlGetUserSessionKeyClient - server name is NULL, returning local key\n"));
#endif
        //
        // Use a constant, default session key
        //

        *UserSessionKey = LocalSessionKey;

        IgnoreStatus = I_RpcMapWin32Status(RpcStringFreeW(&ServerNameZ));
        ASSERT(NT_SUCCESS(IgnoreStatus));

        return(STATUS_LOCAL_USER_SESSION_KEY);
    }

    //
    // Strip the leading '\'s from the server name
    //

    BareServerNameZ = ServerNameZ;
    while (*BareServerNameZ == L'\\') {
        BareServerNameZ ++;
    }

    //
    // Set up a counted string for out server name
    //

    RtlInitUnicodeString(&ServerName, BareServerNameZ);


    //
    // Check for the local server name '.'
    //

    if ( (ServerName.Length == sizeof(*ServerName.Buffer)) &&
         (ServerName.Buffer[0] == L'.') ) {

#ifdef DEBUG_USER_SESSION_KEYS
        KdPrint(("RtlGetUserSessionKeyClient - server name is '.', returning local key\n"));
#endif
        //
        // Use a constant, default session key
        //

        *UserSessionKey = LocalSessionKey;

        IgnoreStatus = I_RpcMapWin32Status(RpcStringFreeW(&ServerNameZ));
        ASSERT(NT_SUCCESS(IgnoreStatus));

        return(STATUS_LOCAL_USER_SESSION_KEY);
    }


    //
    // Create a redirector ipc file name for the referenced server
    //

    RtlInitUnicodeString(&RedirDevice, REDIRECTOR_DEVICENAME);
    RtlInitUnicodeString(&IpcFileName, REDIRECTOR_IPC_FILENAME);

    LengthRequired = RedirDevice.Length + ServerName.Length + IpcFileName.Length;


    //
    // Allocate space for the ipc file name we will create
    //

    ServerIpcFileName.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, LengthRequired);
    if (ServerIpcFileName.Buffer == NULL) {

        KdPrint(("RtlGetUserSessionKeyClient - failed to allocate space for server name (%d bytes)\n", LengthRequired));

        IgnoreStatus = I_RpcMapWin32Status(RpcStringFreeW(&ServerNameZ));
        ASSERT(NT_SUCCESS(IgnoreStatus));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    ServerIpcFileName.Length = 0;
    ServerIpcFileName.MaximumLength = LengthRequired;


    //
    // ServerIpcFileName = \Device\LanmanRedirector\ + servername + \ipc$
    //

    RtlCopyUnicodeString(&ServerIpcFileName, &RedirDevice);

    IgnoreStatus = RtlAppendUnicodeStringToString(&ServerIpcFileName, &ServerName);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    IgnoreStatus = RtlAppendUnicodeStringToString(&ServerIpcFileName, &IpcFileName);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    //
    // Don't need the server name any more
    //

    IgnoreStatus = I_RpcMapWin32Status(RpcStringFreeW(&ServerNameZ));
    ASSERT(NT_SUCCESS(IgnoreStatus));




    //
    // Open up the redirector ipc file
    //

    InitializeObjectAttributes( &Attributes,
                                &ServerIpcFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = NtOpenFile( RedirHandle,
                         FILE_READ_DATA |   // access required to get connection info
                         SYNCHRONIZE,       // access required to wait on object
                         &Attributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ,
                         FILE_CREATE_TREE_CONNECTION );
    //
    // We're finished with the ipc filename
    //

    RtlFreeHeap( RtlProcessHeap(), 0, ServerIpcFileName.Buffer );
    ServerIpcFileName.Buffer = NULL;

    //
    // Check the result of the open
    //

    if (!NT_SUCCESS(Status)) {
        KdPrint(("RtlGetUserSessionKeyClient - failed to open redirector, status = 0x%lx\n\r", Status));
        *RedirHandle = NULL;
        return(Status);
    }



    //
    // Get the connection info for this link
    //

    RdrRequestPacket.Version = REQUEST_PACKET_VERSION;
    RdrRequestPacket.Level = 2; // We want the session key.

    Status = NtFsControlFile( *RedirHandle,
                              NULL,                     // Event
                              NULL,                     // APC routine
                              NULL,                     // APC context
                              &IoStatusBlock,
                              FSCTL_LMR_GET_CONNECTION_INFO,
                              &RdrRequestPacket,        // Input buffer
                              sizeof(RdrRequestPacket), // Input buffer length
                              &ConnectionInfo,          // Output buffer
                              sizeof(ConnectionInfo)    // Output buffer length
                              );

    //
    // remove the reference created on the existing connection.
    // this logic assumes the caller of RtlGetUserSessionKeyClientXXX()
    // has already established a connection.
    //

    {
        LMR_REQUEST_PACKET Rrp;            // Redirector request packet
        NTSTATUS           TempStatus;
 
        RtlZeroMemory(&Rrp,sizeof(LMR_REQUEST_PACKET));
        Rrp.Level = USE_FORCE;  // this tells rdr2 to take away the extra reference
                                // to connection strucutre even when files are open.
        Rrp.Version = REQUEST_PACKET_VERSION;
 
        TempStatus = NtFsControlFile(
                            *RedirHandle,                   // handle
                            NULL,                           // no event
                            NULL,                           // no APC routine
                            NULL,                           // no APC context
                            &IoStatusBlock,                 // I/O stat blk (set)
                            FSCTL_LMR_DELETE_CONNECTION,    // func code
                            &Rrp,
                            sizeof(LMR_REQUEST_PACKET),
                            NULL,
                            0
                            );

        //
        // block on the delete if necessary.
        //

        if( TempStatus == STATUS_PENDING )
        {
            NtWaitForSingleObject( *RedirHandle, TRUE, NULL );
        }
    }



    //
    // Check the result of the control file call
    //

    if (!NT_SUCCESS(Status)) {
        IgnoreStatus = NtClose(*RedirHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));
        *RedirHandle = NULL;
        KdPrint(("RtlGetUserSessionKeyClient - failed to get connection info, status = 0x%lx\n\r", Status));
        ASSERT(FALSE);
        return(Status);
    }

    //
    // Copy the session key into the passed buffer
    //

    *UserSessionKey = *(PUSER_SESSION_KEY)(ConnectionInfo.UserSessionKey);


    //
    // Check for the error session key
    //

    if (RtlCompareMemory(UserSessionKey, &ErrorSessionKey,
                       sizeof(*UserSessionKey)) == sizeof(*UserSessionKey)) {

#ifdef DEBUG_USER_SESSION_KEYS
        KdPrint(("RtlGetUserSessionKeyClient - got error session key, returning error\n"));
#endif
        Status = STATUS_NO_USER_SESSION_KEY;
        IgnoreStatus = NtClose(*RedirHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));
        *RedirHandle = NULL;
    }


#ifdef DEBUG_USER_SESSION_KEYS
    KdPrint(("RtlGetUserSessionKeyClient : Key = 0x%lx : %lx : %lx : %lx\n",
            ((PULONG)UserSessionKey)[0], ((PULONG)UserSessionKey)[1],
            ((PULONG)UserSessionKey)[2], ((PULONG)UserSessionKey)[3]));
#endif

    return(Status);
}






NTSTATUS
RtlGetUserSessionKeyClient(
    IN PVOID RpcContextHandle,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Returns the user session key associated with an rpc connection.
    This function should be called by the client side of the connection only.

Arguments:

    RpcContextHandle - The rpc connection we're interested in
        This can also be an RPC binding handle.

    UserSessionKey - The user session key is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_LOCAL_USER_SESSION_KEY - An informational status value.
                   - The rpc connection is local, the usersessionkey returned
                   - is constant and not unique to this connection.
                   - There is little to be gained by encrypting data over
                   - this connection

    STATUS_NO_USER_SESSION_KEY - No session key exists for this session.

    ------ these come from parsebinding -------

    RPC_NT_OUT_OF_MEMORY - Insufficent memory is available to allocate
        space for the fields of the string binding.

    RPC_NT_INVALID_STRING_BINDING - The string binding is syntactically
        invalid.

    RPC_NT_INVALID_ARG - The string binding is not specified
        (ie. ARGUMENT_PRESENT(StringBinding) is false).
--*/

{
    NTSTATUS Status;
    HANDLE RedirHandle = NULL;

    //
    // Call the worker routine.
    //

    Status = RtlGetUserSessionKeyClientBinding(
                NDRCContextBinding((NDR_CCONTEXT)RpcContextHandle),
                &RedirHandle,
                UserSessionKey );

    if ( RedirHandle != NULL ) {
        NtClose( RedirHandle );
    }

    return Status;
}



NTSTATUS
RtlGetUserSessionKeyServer(
    IN PVOID RpcContextHandle OPTIONAL,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Returns the user session key associated with an rpc connection.
    This function should be called by the server side of the connection only.

Arguments:

    RpcBindingHandle - The rpc connection we're interested in
                     - Note this parameter is ignored for now

    UserSessionKey - The user session key is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_LOCAL_USER_SESSION_KEY - An informational status value.
                   - The rpc connection is local, the usersessionkey returned
                   - is constant and not unique to this connection.
                   - There is little to be gained by encrypting data over
                   - this connection

    STATUS_NO_USER_SESSION_KEY - No session key exists for this session.

--*/

{
    NTSTATUS Status, IgnoreStatus;
    HANDLE  TokenHandle;
    TOKEN_STATISTICS TokenInfo;
    ULONG ReturnedLength;
    UNICODE_STRING ServerDevice;
    ANSI_STRING AnsiString;
    OBJECT_ATTRIBUTES Attributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE  ServerHandle;
    RPC_BINDING_HANDLE RpcBindingHandle;
    unsigned int RpcClientLocalFlag;


    //
    // Get the binding handle for this connection
    //

    // LATER RpcBindingHandle = (RPC_BINDING_HANDLE) RpcContextHandle;
    RpcBindingHandle = NULL;


    //
    // If this is a local connection then we can immediately
    // return the local session key.
    //

    Status = I_RpcBindingIsClientLocal(RpcBindingHandle, &RpcClientLocalFlag);
    if (!NT_SUCCESS(Status)) {
        KdPrint(("RtlGetUserSessionKeyServer: RpcBindingIsClientLocal failed, status = 0x%lx\n", Status));
        return(Status);
    }

    if (RpcClientLocalFlag != 0) {
        *UserSessionKey = LocalSessionKey;
#ifdef DEBUG_USER_SESSION_KEYS
        KdPrint(("RtlGetUserSessionKeyServer: client is local, returning local key\n"));
#endif
        return (STATUS_LOCAL_USER_SESSION_KEY);
    }




    //
    // Get a handle to the client's token
    //

    Status = NtOpenThreadToken(NtCurrentThread(),
                               TOKEN_QUERY,
                               TRUE,
                               &TokenHandle);
    //
    // If we couldn't open the thread token because we weren't impersonating
    // then impersonate and try again.
    //

    if (!NT_SUCCESS(Status)) {

        //
        // Check we failed only because we weren't impersonating
        //

        if (Status != STATUS_NO_TOKEN) {
            KdPrint(("RtlGetUserSessionKeyServer - failed to open thread token, status = 0x%lx\n", Status));
            ASSERT(FALSE);
            return(Status);
        }

        //
        // Impersonate the client ourselves
        //

        Status = I_RpcMapWin32Status(RpcImpersonateClient(RpcBindingHandle));
        if (!NT_SUCCESS(Status)) {
            KdPrint(("RtlGetUserSessionKeyServer - RpcImpersonateClient failed, status = 0x%lx\n", Status));
            ASSERT(FALSE);
            return(Status);
        }

        //
        // Try to get a token handle now we're impersonating
        //

        Status = NtOpenThreadToken(NtCurrentThread(),
                                   TOKEN_QUERY,
                                   TRUE,
                                   &TokenHandle);
        if (!NT_SUCCESS(Status)) {

            KdPrint(("RtlGetUserSessionKeyServer - failed to open thread token after impersonating, status = 0x%lx\n", Status));
            ASSERT(FALSE);

            IgnoreStatus = I_RpcMapWin32Status(RpcRevertToSelf());
            ASSERT(NT_SUCCESS(IgnoreStatus));

            return(Status);
        }

        //
        // We've got a token handle, stop impersonating
        //

        Status = I_RpcMapWin32Status(RpcRevertToSelf());

        if (!NT_SUCCESS(Status)) {

            KdPrint(("RtlGetUserSessionKeyServer - RpcRevertToSelf failed, status = 0x%lx\n", Status));
            ASSERT(FALSE);

            IgnoreStatus = NtClose(TokenHandle);
            ASSERT(NT_SUCCESS(IgnoreStatus));

            return(Status);
        }

    }

    //
    // We've now got a token handle, get the authentication id from it.
    //

    Status = NtQueryInformationToken(
                    TokenHandle,
                    TokenStatistics,
                    &TokenInfo,
                    sizeof(TokenInfo),
                    &ReturnedLength
                    );

    //
    // We're done with the token
    //

    IgnoreStatus = NtClose(TokenHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    //
    // Check result of token query
    //

    if (!NT_SUCCESS(Status)) {

        KdPrint(("RtlGetUserSessionKeyServer - Failed to query token statistics from token, status = 0x%lx\n", Status));
        ASSERT(FALSE);

        return(Status);
    }



    //
    // Open the server device
    //

    RtlInitAnsiString(&AnsiString, SERVER_DEVICE_NAME);

    Status = RtlAnsiStringToUnicodeString(&ServerDevice, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {

        KdPrint(("RtlGetUserSessionKeyServer - RtlAnsiToUnicodeString failed, status = 0x%lx\n", Status));
        ASSERT(FALSE);

        return(Status);
    }

    InitializeObjectAttributes( &Attributes,
                                &ServerDevice,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = NtOpenFile( &ServerHandle,
                         GENERIC_READ | GENERIC_WRITE, // LATER use correct access
                         &Attributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ,
                         0 );

    RtlFreeUnicodeString(&ServerDevice);

    if (!NT_SUCCESS(Status)) {

        //
        // Check for the case when the server driver is not present
        //

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

#ifdef DEBUG_USER_SESSION_KEYS
            KdPrint(("RtlGetUserSessionKeyServer - server driver not present, returning local key\n"));
#endif
            *UserSessionKey = LocalSessionKey;
            Status = STATUS_LOCAL_USER_SESSION_KEY;

        } else {
            KdPrint(("RtlGetUserSessionKeyServer - Failed to open the server, status = 0x%lx\n", Status));
            ASSERT(FALSE);
        }

        return(Status);
    }


    //
    // Get the session key for this client from the server
    //

    Status = NtFsControlFile( ServerHandle,
                              NULL,                 // Event
                              NULL,                 // APC
                              NULL,                 // APC Context
                              &IoStatusBlock,
                              FSCTL_SRV_GET_CHALLENGE,
                              &TokenInfo.AuthenticationId,
                              sizeof(TokenInfo.AuthenticationId),
                              (PVOID)UserSessionKey,
                              sizeof(*UserSessionKey));
    //
    // We're done with the file handle
    //

    IgnoreStatus = NtClose(ServerHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));



    if (NT_SUCCESS(Status)) {

        //
        // Check for the error session key
        //

        if (RtlCompareMemory(UserSessionKey, &ErrorSessionKey,
                           sizeof(*UserSessionKey)) == sizeof(*UserSessionKey)) {

#ifdef DEBUG_USER_SESSION_KEYS
            KdPrint(("RtlGetUserSessionKeyServer - got error session key, returning error\n"));
#endif
            Status = STATUS_NO_USER_SESSION_KEY;
        }

    } else {

        //
        // If the server is not started or the token couldn't be found in the
        // list of server connections, then assume it's a local connection
        //

        if ( (Status == STATUS_SERVER_NOT_STARTED) ||
             (Status == STATUS_NO_TOKEN) ) {

#ifdef DEBUG_USER_SESSION_KEYS
            KdPrint(("RtlGetUserSessionKeyServer - server not started or logon id not found (Status = 0x%lx), returning local key\n", Status));
#endif
            *UserSessionKey = LocalSessionKey;
            Status = STATUS_LOCAL_USER_SESSION_KEY;

        } else {
            KdPrint(("RtlGetUserSessionKeyServer - Failed to query the user session key from the server, status = 0x%lx\n", Status));
            ASSERT(FALSE);
        }
    }


#ifdef DEBUG_USER_SESSION_KEYS
    KdPrint(("RtlGetUserSessionKeyServer : Key = 0x%lx : %lx : %lx : %lx, status = 0x%lx\n",
            ((PULONG)UserSessionKey)[0], ((PULONG)UserSessionKey)[1],
            ((PULONG)UserSessionKey)[2], ((PULONG)UserSessionKey)[3], Status));
#endif


    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\crypt\dll\winnt\makefile.inc ===
$(O)\sys003.lib: $(O)\crypt.lib
    -$(LIB_NAME) $(LIBRARIAN_FLAGS) -out:$@ $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\idl\makefile.inc ===
IDL_NAME = lsarpc

CLIENT_ACF = lsacli.acf
SERVER_ACF = $(PROJECT_ROOT)\published\lsa\lsasrv.acf

CLIENT_INC_FILE = $(IDL_NAME)_c.h
SERVER_INC_FILE = $(IDL_NAME).h

CLIENT_TARGETS = \
        $(O)\$(IDL_NAME)_c.c \
        $(O)\$(CLIENT_INC_FILE)

SERVER_TARGETS = \
        $(O)\$(IDL_NAME)_s.c \
        $(O)\$(SERVER_INC_FILE)

EFS_TARGETS = \
        $(O)\efsrpc.h

MIDL_INCS= -I$(SDK_INC_PATH)  -I$(CRT_INC_PATH) -I$(DS_INC_PATH) -I$(PROJECT_ROOT)\published\lsa
MIDL_OPTIMIZATION_NT5=-Oicf -robust -error all -no_format_opt -protocol all
MIDL_OPTIMIZATION_EFS=-Oicf -robust -error stub_data -protocol all

CLIENT_FLAGS  = $(MIDL_OPTIMIZATION_NT5) -oldnames $(MIDL_FLAGS) -out .\$(O) -acf $(CLIENT_ACF) -server none -header $(CLIENT_INC_FILE)
SERVER_FLAGS  = $(MIDL_OPTIMIZATION_NT5) -oldnames $(MIDL_FLAGS) -out .\$(O) -acf $(SERVER_ACF) -client none -header $(SERVER_INC_FILE)
EFS_FLAGS     = $(MIDL_OPTIMIZATION_EFS) -oldnames $(MIDL_FLAGS) -out .\$(O) -char unsigned -header efsrpc.h

EFS_DEFINES   = -DMIDL_PASS $(FLAGS) -DSECURITY_WIN32

CPP = -cpp_cmd "$(MIDL_CPP)"

TARGETS: \
        $(CLIENT_TARGETS) \
        $(SERVER_TARGETS) \
        $(EFS_TARGETS)

$(CLIENT_TARGETS): $(PROJECT_ROOT)\published\lsa\$(IDL_NAME).idl $(CLIENT_ACF)
    $(MIDL) $(CPP) $(CLIENT_FLAGS) $(MIDL_INCS) $(PROJECT_ROOT)\published\lsa\$(IDL_NAME).idl

$(SERVER_TARGETS): $(PROJECT_ROOT)\published\lsa\$(IDL_NAME).idl $(SERVER_ACF)
    $(MIDL) $(CPP) $(SERVER_FLAGS) $(MIDL_INCS) $(PROJECT_ROOT)\published\lsa\$(IDL_NAME).idl

$(EFS_TARGETS): efsrpc.idl
    $(MIDL) $(CPP) $(EFS_FLAGS) $(MIDL_INCS) $(ERRORS) $(EFS_DEFINES) efsrpc.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\inc\cr.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cr.h

Abstract:

    Local Security Authority - Encryption Routine Definitions

    NOTE:  This file is included via lsacomp.h.  It should
           not be included directly.

Author:

    Scott Birrell       (ScottBi)      December 13, 1991

Environment:

Revision History:

--*/

//
// Max encryption Key Length
//

#define LSAP_CR_MAX_CIPHER_KEY_LENGTH   (0x00000010L)

//
// Cipher Key Structure
//

typedef struct _LSAP_CR_CIPHER_KEY {

    ULONG Length;
    ULONG MaximumLength;
    PUCHAR  Buffer;

} LSAP_CR_CIPHER_KEY, *PLSAP_CR_CIPHER_KEY;


//
// Clear value structure
//

typedef struct _LSAP_CR_CLEAR_VALUE {

    ULONG Length;
    ULONG MaximumLength;
    PUCHAR Buffer;

} LSAP_CR_CLEAR_VALUE, *PLSAP_CR_CLEAR_VALUE;

//
// Two-way encrypted value structure in Self-relative form.  This
// is just like a String.
//

typedef struct _LSAP_CR_CIPHER_VALUE {

    ULONG Length;
    ULONG MaximumLength;
    PUCHAR  Buffer;

} LSAP_CR_CIPHER_VALUE, *PLSAP_CR_CIPHER_VALUE;


NTSTATUS
LsapCrClientGetSessionKey(
    IN LSA_HANDLE ObjectHandle,
    OUT PLSAP_CR_CIPHER_KEY *SessionKey
    );

NTSTATUS
LsapCrServerGetSessionKey(
    IN LSA_HANDLE ObjectHandle,
    OUT PLSAP_CR_CIPHER_KEY *SessionKey
    );

NTSTATUS
LsapCrEncryptValue(
    IN PLSAP_CR_CLEAR_VALUE ClearValue,
    IN PLSAP_CR_CIPHER_KEY CipherKey,
    OUT PLSAP_CR_CIPHER_VALUE *CipherValue
    );

NTSTATUS
LsapCrDecryptValue(
    IN PLSAP_CR_CIPHER_VALUE CipherValue,
    IN PLSAP_CR_CIPHER_KEY CipherKey,
    OUT PLSAP_CR_CLEAR_VALUE *ClearValue
    );

VOID
LsapCrFreeMemoryValue(
    IN PVOID MemoryValue
    );

VOID
LsapCrUnicodeToClearValue(
    IN PUNICODE_STRING UnicodeString,
    OUT PLSAP_CR_CLEAR_VALUE ClearValue
    );

VOID
LsapCrClearValueToUnicode(
    IN PLSAP_CR_CLEAR_VALUE ClearValue,
    OUT PUNICODE_STRING UnicodeString
    );

#define LsapCrRtlEncryptData(ClearData, CipherKey, CipherData)            \
    (                                                                     \
        RtlEncryptData(                                                   \
            (PCLEAR_DATA) ClearData,                                      \
            (PDATA_KEY) CipherKey,                                        \
            (PCYPHER_DATA) CipherData                                     \
            )                                                             \
    )


#define LsapCrRtlDecryptData(ClearData, CipherKey, CipherData)            \
    (                                                                     \
        RtlDecryptData(                                                   \
            (PCLEAR_DATA) ClearData,                                      \
            (PDATA_KEY) CipherKey,                                        \
            (PCYPHER_DATA) CipherData                                     \
            )                                                             \
    )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\inc\lsacomp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsacomp.h

Abstract:

    Local Security Authority - Main Include File for Client/Server Common
                               Definitions.


    This file contains #includes for each of the files that contain
    private LSA definitions that are common to the client/server side.

Author:

    Scott Birrell       (ScottBi)      February 19, 1992

Environment:

Revision History:

--*/

//
// The following come from \nt\public\sdk\inc
//

#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <ntregapi.h>
#include <rpc.h>
#include <msaudite.h>

//
// The following come from \nt\public\sdk\inc\crt
//

#include <stdlib.h>

//
// The following come from \nt\private\inc
//

#include <seopaque.h>
#include <ntrmlsa.h>
#include <ntrpcp.h>
#include <crypt.h>
#include <lsarpc.h>

//
// The following come from \nt\private\lsa\inc
//

#include <cr.h>
#include <lsaprtl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\inc\lsaprtl.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsaprtl.h

Abstract:

    Local Security Authority - Temporary Rtl Routine Definitions.

    This file contains definitions for routines used in the LSA that could
    be made into Rtl routines.  They have been written in general purpose
    form with this in mind - the only exception to thisa is that their names
    have Lsap prefixes to indicate that they are currently used only by the
    LSA.

    Scott Birrell       (ScottBi)      March 26, 1992

Environment:

Revision History:

--*/

// Options for LsapRtlAddPrivileges

#define  RTL_COMBINE_PRIVILEGE_ATTRIBUTES   ((ULONG) 0x00000001L)
#define  RTL_SUPERSEDE_PRIVILEGE_ATTRIBUTES ((ULONG) 0x00000002L)

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

NTSTATUS
LsapRtlAddPrivileges(
    IN OUT PPRIVILEGE_SET * RunningPrivileges,
    IN OUT PULONG           MaxRunningPrivileges,
    IN PPRIVILEGE_SET       PrivilegesToAdd,
    IN ULONG                Options,
    OUT OPTIONAL BOOLEAN *  Changed
    );

NTSTATUS
LsapRtlRemovePrivileges(
    IN OUT PPRIVILEGE_SET ExistingPrivileges,
    IN PPRIVILEGE_SET PrivilegesToRemove
    );

PLUID_AND_ATTRIBUTES
LsapRtlGetPrivilege(
    IN PLUID_AND_ATTRIBUTES Privilege,
    IN PPRIVILEGE_SET Privileges
    );

BOOLEAN
LsapRtlPrefixSid(
    IN PSID PrefixSid,
    IN PSID Sid
    );

BOOLEAN
LsapRtlPrefixName(
    IN PUNICODE_STRING PrefixName,
    IN PUNICODE_STRING Name
    );

LONG
LsapRtlFindCharacterInUnicodeString(
    IN PUNICODE_STRING InputString,
    IN PUNICODE_STRING Character,
    IN BOOLEAN CaseInsensitive
    );

VOID
LsapRtlSplitNames(
    IN PUNICODE_STRING Names,
    IN ULONG Count,
    IN PUNICODE_STRING Separator,
    OUT PUNICODE_STRING PrefixNames,
    OUT PUNICODE_STRING SuffixNames
    );

VOID
LsapRtlSetSecurityAccessMask(
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PACCESS_MASK DesiredAccess
    );

VOID
LsapRtlQuerySecurityAccessMask(
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PACCESS_MASK DesiredAccess
    );

NTSTATUS
LsapRtlSidToUnicodeRid(
    IN PSID Sid,
    OUT PUNICODE_STRING UnicodeRid
    );

NTSTATUS
LsapRtlWellKnownPrivilegeCheck(
    IN PVOID ObjectHandle,
    IN ULONG PrivilegeId
    );

NTSTATUS
LsapSplitSid(
    IN PSID AccountSid,
    IN OUT PSID *DomainSid,
    OUT ULONG *Rid
    );

#define LSAP_ENCRYPTED_AUTH_DATA_FILL 512

//
// This is the individual auth info information stored on, read from, and written to the object
//
typedef struct _LSAPR_TRUST_DOMAIN_AUTH_INFO_HALF {

    ULONG AuthInfos;
    PLSAPR_AUTH_INFORMATION AuthenticationInformation;
    PLSAPR_AUTH_INFORMATION PreviousAuthenticationInformation;

} LSAPR_TRUST_DOMAIN_AUTH_INFO_HALF, *PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF;

#define LsapDsAuthHalfFromAuthInfo( authinf, incoming )                           \
((incoming) == TRUE ?                                                             \
        (PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF) (authinf)   :                        \
        (authinf) == NULL ? NULL :                                                \
        (PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF)((PBYTE) (authinf) +                  \
                                    sizeof(LSAPR_TRUST_DOMAIN_AUTH_INFO_HALF)))

NTSTATUS
LsapDsMarshalAuthInfoHalf(
    IN PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF AuthInfo,
    OUT PULONG Length,
    OUT PBYTE *Buffer
    );

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\inc\aup.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    aup.h

Abstract:

    Local Security Authority definitions that are related to AUTHENTICATION
    services and are shared between the LSA server and LSA client stubs

Author:

    Jim Kelly (JimK) 20-Feb-1991

Revision History:

--*/

#ifndef _AUP_
#define _AUP_


#define LSAP_MAX_LOGON_PROC_NAME_LENGTH 127
#define LSAP_MAX_PACKAGE_NAME_LENGTH    127


//
// Used for connecting to the LSA authentiction port.
//

#define LSAP_AU_KERNEL_CLIENT 0x1

typedef struct _LSAP_AU_REGISTER_CONNECT_INFO {
    NTSTATUS CompletionStatus;
    ULONG SecurityMode;
    ULONG LogonProcessNameLength;
    CHAR LogonProcessName[LSAP_MAX_PACKAGE_NAME_LENGTH+1];
} LSAP_AU_REGISTER_CONNECT_INFO, *PLSAP_AU_REGISTER_CONNECT_INFO;

typedef struct _LSAP_AU_REGISTER_CONNECT_INFO_EX {
    NTSTATUS CompletionStatus;
    ULONG Security;
    ULONG LogonProcessNameLength;
    CHAR LogonProcessName[LSAP_MAX_PACKAGE_NAME_LENGTH+1];
    ULONG ClientMode;
} LSAP_AU_REGISTER_CONNECT_INFO_EX, *PLSAP_AU_REGISTER_CONNECT_INFO_EX;

typedef struct _LSAP_AU_REGISTER_CONNECT_RESP {
    NTSTATUS CompletionStatus;
    LSA_OPERATIONAL_MODE SecurityMode;
    ULONG PackageCount;
    UCHAR Reserved[ LSAP_MAX_PACKAGE_NAME_LENGTH + 1 ];
} LSAP_AU_REGISTER_CONNECT_RESP, * PLSAP_AU_REGISTER_CONNECT_RESP;



//
// Conditional type definition for Wow64 environment.  The LPC messages
// are kept "native" size, so pointers are full size.  The WOW environment
// will do the thunking.  LPC messages are defined with types that are
// always the correct size using these "aliases".
//

#ifdef BUILD_WOW64

#if 0
typedef WCHAR __ptr64 * PWSTR_AU ;
typedef VOID __ptr64 * PVOID_AU ;
#else 
typedef ULONGLONG PWSTR_AU ;
typedef ULONGLONG PVOID_AU ;
#endif 

typedef struct _STRING_AU {
    USHORT Length ;
    USHORT MaximumLength ;
    PVOID_AU Buffer ;
} STRING_AU, * PSTRING_AU ;

typedef PVOID_AU   HANDLE_AU ;

#define SecpStringToLpc( L, S ) \
    (L)->Length = (S)->Length ; \
    (L)->MaximumLength = (S)->MaximumLength ; \
    (L)->Buffer = (PVOID_AU) (S)->Buffer ;

#define SecpLpcStringToString( S, L ) \
    (S)->Length = (L)->Length ;  \
    (S)->MaximumLength = (L)->MaximumLength ; \
    (S)->Buffer = (PCHAR) (L)->Buffer ;


#else

typedef PVOID               PVOID_AU ;
typedef PWSTR               PWSTR_AU ;
typedef STRING STRING_AU, *PSTRING_AU ;
typedef HANDLE HANDLE_AU ;

#define SecpStringToLpc( L, S ) \
        *(L) = *(S) ;

#define SecpLpcStringToString( S, L ) \
        *(S) = *(L) ;

#endif 


//
// Message formats used by clients of the local security authority.
// Note that:
//
//      LsaFreeReturnBuffer() does not result in a call to the server.
//
//      LsaRegisterLogonProcess() is handled completely by the
//      LPC port connection, and requires no API number.
//
//      DeRegister Logon Process doesn't have a call-specific structure.
//

typedef enum _LSAP_AU_API_NUMBER {
    LsapAuLookupPackageApi,
    LsapAuLogonUserApi,
    LsapAuCallPackageApi,
    LsapAuDeregisterLogonProcessApi,
    LsapAuMaxApiNumber
} LSAP_AU_API_NUMBER, *PLSAP_AU_API_NUMBER;


#define LSAP_ADDRESS_LENGTH   32


//
// Each API results in a data structure containing the parameters
// of that API being transmitted to the LSA server.  This data structure
// (LSAP_API_MESSAGE) has a common header and a body which is dependent
// upon the type of call being made.  The following data structures are
// the call-specific body formats.
//

typedef struct _LSAP_LOOKUP_PACKAGE_ARGS {
    ULONG AuthenticationPackage;       // OUT parameter
    ULONG PackageNameLength;
    CHAR PackageName[LSAP_MAX_PACKAGE_NAME_LENGTH+1];
} LSAP_LOOKUP_PACKAGE_ARGS, *PLSAP_LOOKUP_PACKAGE_ARGS;

typedef struct _LSAP_LOGON_USER_ARGS {
    STRING_AU OriginName;
    SECURITY_LOGON_TYPE LogonType;
    ULONG AuthenticationPackage;
    PVOID_AU AuthenticationInformation;
    ULONG AuthenticationInformationLength;
    ULONG LocalGroupsCount;
    PVOID_AU LocalGroups;
    TOKEN_SOURCE SourceContext;
    NTSTATUS SubStatus;                  // OUT parameter
    PVOID_AU ProfileBuffer;              // OUT parameter
    ULONG ProfileBufferLength;           // OUT parameter
    ULONG DummySpacer;                   // Spacer to force LUID to 8 byte alignment
    LUID LogonId;                        // OUT parameter
    HANDLE_AU Token;                     // OUT parameter
    QUOTA_LIMITS Quotas;                 // OUT parameter
    CHAR IpAddress[LSAP_ADDRESS_LENGTH]; // At the end to avoid compat problems with clients
                                         //   built with older versions of lsadll.lib
} LSAP_LOGON_USER_ARGS, *PLSAP_LOGON_USER_ARGS;

typedef struct _LSAP_CALL_PACKAGE_ARGS {
    ULONG AuthenticationPackage;
    PVOID_AU ProtocolSubmitBuffer;
    ULONG SubmitBufferLength;
    NTSTATUS ProtocolStatus;           // OUT parameter
    PVOID_AU ProtocolReturnBuffer;        // OUT parameter
    ULONG ReturnBufferLength;          // OUT parameter
} LSAP_CALL_PACKAGE_ARGS, *PLSAP_CALL_PACKAGE_ARGS;



#define LSAP_AU_DATA_LENGTH(Size)    ((Size) + 8)


//
// This is the message that gets sent for every LSA LPC call.
//

typedef struct _LSAP_AU_API_MESSAGE {
    PORT_MESSAGE PortMessage;
    union {
        LSAP_AU_REGISTER_CONNECT_INFO ConnectionRequest;
        struct {
            LSAP_AU_API_NUMBER ApiNumber;
            NTSTATUS ReturnedStatus;
            union {
                LSAP_LOOKUP_PACKAGE_ARGS LookupPackage;
                LSAP_LOGON_USER_ARGS LogonUser;
                LSAP_CALL_PACKAGE_ARGS CallPackage;
            } Arguments;
        };
    };
} LSAP_AU_API_MESSAGE, *PLSAP_AU_API_MESSAGE;

#endif // _AUP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\msprivs\makefile.inc ===
mspr_rev.rc : msprivs.rc msprivs2.h res\*


# include a dummy dependency so the makefile.inc file gets included
foo : mspr_rev.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\inc\rpcutil.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    rpcutil.h

Abstract:

    This file contains prototypes for the bind and unbind functions that
    all net api stub functions will call.  It also includes the allocate
    and free routines used by the MIDL generated RPC stubs.

Author:

    Dan Lafferty danl 06-Feb-1991
    Scott Birrell   (ScottBi)         April 30, 1991 -  LSA Version

[Environment:]

    User Mode - Win32

Revision History:

--*/

#ifndef _RPCUTIL_
#define _RPCUTIL_

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#include <rpc.h>

//
// Function Prototypes
//

void *
MIDL_user_allocate(
    IN ULONG NumBytes
    );

void
MIDL_user_free(
    IN PVOID MemPointer
    );


RPC_STATUS
LsapBindRpc(
    IN  PLSAPR_SERVER_NAME   ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    );

RPC_STATUS
LsapUnbindRpc(
    RPC_BINDING_HANDLE  BindingHandle
    );



#endif // _RPCUTIL_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\inc\spmlpc.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        SPMLPC.H
//
// Contents:    Defines for the LPC to the SPMgr
//
//
// History:     2 Mar 94    MikeSw  Created
//
//------------------------------------------------------------------------

#ifndef __SPMLPC_H__
#define __SPMLPC_H__

//
// Pickup the LSA lpc messages for compatiblity
//
#pragma warning(disable:4200)

#include <efsstruc.h>
#include <aup.h>


#define SPM_PORTNAME    L"\\LsaAuthenticationPort"
#define SPM_EVENTNAME   L"\\SECURITY\\LSA_AUTHENTICATION_INITIALIZED"


#define SPM_AUTH_PKG_FLAG   0x00001000

//
// Buffers that will fit into the message are placed in there and the
// their pointers will be replaced with this value.  Since all buffers and
// strings are sent with their lengths, to unpack the data move pull out the
// buffers in the order they are listed in the API message.
//
// Since all buffers must be passed from VM, any address above 0x80000000
// will not be confused for an address
//

#define SEC_PACKED_BUFFER_VALUE (IntToPtr(0xFFFFFFFF))

//
// Max secbuffers allowed in a SecBufferDesc
//

#define MAX_SECBUFFERS 10

//
// This bit gets set in the SecurityMode word, indicating that the DLL
// is running in the LSA process.  The DLL will turn around and get the
// direct dispatch routine, and avoid the whole LPC issue
//

#define LSA_MODE_SAME_PROCESS                0x00010000

//
// This flag is added to the version information in a SecBufferDesc to
// indicate that the memory is already mapped to the LSA.
//

#define LSA_MEMORY_KERNEL_MAP               0x80000000
#define LSA_SECBUFFER_VERSION_MASK          0x0000FFFF



//
// Conditional type definition for Wow64 environment.  The LPC messages
// are kept "native" size, so pointers are full size.  The WOW environment
// will do the thunking.  LPC messages are defined with types that are
// always the correct size using these "aliases".
//

#ifdef BUILD_WOW64

#pragma message("Building for WOW64")

#define ALIGN_WOW64         __declspec(align(8))

#define GET_WOW64_PTR(_Wow64Ptr_)  PtrToUlong(_Wow64Ptr_)

#define POINTER_FORMAT  "%I64X"

#if 0
typedef WCHAR * __ptr64 PWSTR_LPC ;
typedef VOID * __ptr64 PVOID_LPC ;
#else
typedef ULONGLONG PWSTR_LPC ;
typedef ULONGLONG PVOID_LPC ;
typedef ULONGLONG PSID_LPC ;
#endif

typedef struct _SECURITY_STRING_WOW64 {
    USHORT      Length ;
    USHORT      MaximumLength ;
    PWSTR_LPC   Buffer ;
} SECURITY_STRING_WOW64, * PSECURITY_STRING_WOW64 ;

typedef struct _SEC_HANDLE_WOW64 {
    PVOID_LPC dwLower ;
    PVOID_LPC dwUpper ;
} SEC_HANDLE_WOW64, * PSEC_HANDLE_WOW64 ;

typedef struct _SEC_BUFFER_WOW64 {
    unsigned long   cbBuffer ;
    unsigned long   BufferType ;
    PVOID_LPC  pvBuffer ;
} SEC_BUFFER_WOW64, * PSEC_BUFFER_WOW64 ;

typedef struct _SEC_BUFFER_DESC_WOW64 {
    unsigned long   ulVersion ;
    unsigned long   cBuffers ;
    PVOID_LPC  pBuffers ;
} SEC_BUFFER_DESC_WOW64, * PSEC_BUFFER_DESC_WOW64 ;

typedef struct _SECPKG_INFO_WOW64 {
    ULONG        fCapabilities;
    USHORT       wVersion;
    USHORT       wRPCID;
    ULONG        cbMaxToken;
    PWSTR_LPC    Name;
    PWSTR_LPC    Comment;
}
SECPKG_INFO_WOW64, * PSECPKG_INFO_WOW64;

typedef struct _SECPKGCONTEXT_NEGOTIATIONINFOWOW64
{
    PVOID_LPC           pPackageInfo64;
    ULONG               NegotiationState;
}
SECPKGCONTEXT_NEGOTIATIONINFOWOW64, *PSECPKGCONTEXT_NEGOTIATIONINFOWOW64;

typedef struct _SECURITY_USER_DATA_WOW64 {
    SECURITY_STRING_WOW64 UserName;
    SECURITY_STRING_WOW64 LogonDomainName;
    SECURITY_STRING_WOW64 LogonServer;
    PSID_LPC              pSid;
}
SECURITY_USER_DATA_WOW64, * PSECURITY_USER_DATA_WOW64;

typedef SECURITY_STRING_WOW64   SECURITY_STRING_LPC ;
typedef SEC_HANDLE_WOW64    SEC_HANDLE_LPC ;
typedef SEC_BUFFER_DESC_WOW64   SEC_BUFFER_DESC_LPC ;
typedef SEC_BUFFER_WOW64        SEC_BUFFER_LPC ;
typedef PVOID_LPC               LSA_SEC_HANDLE_LPC ;

#define SecpSecurityStringToLpc( L, S ) \
            (L)->Length = (S)->Length ;     \
            (L)->MaximumLength = (S)->MaximumLength ; \
            (L)->Buffer = (PWSTR_LPC) GET_WOW64_PTR(((S)->Buffer)) ;

#define SecpLpcStringToSecurityString( S, L ) \
            (S)->Length = (L)->Length ; \
            (S)->MaximumLength = (L)->MaximumLength ; \
            (S)->Buffer = (PWSTR) ( (L)->Buffer ); \

#define SecpSecBufferToLpc( L, S )\
            (L)->cbBuffer = (S)->cbBuffer ; \
            (L)->BufferType = (S)->BufferType ; \
            (L)->pvBuffer = (PVOID_LPC) GET_WOW64_PTR((S)->pvBuffer) ;

#define SecpLpcBufferToSecBuffer( S, L ) \
            (S)->cbBuffer = (L)->cbBuffer ; \
            (S)->BufferType = (L)->BufferType ; \
            (S)->pvBuffer = (PVOID) (L)->pvBuffer ;

#define SecpSecBufferDescToLpc( L, S )\
            (L)->ulVersion = (S)->ulVersion ; \
            (L)->cBuffers = (S)->cBuffers ; \
            (L)->pBuffers = (PVOID_LPC) GET_WOW64_PTR((S)->pBuffers) ;

#define SecpLpcBufferDescToSecBufferDesc( S, L ) \
            (S)->ulVersion = (L)->ulVersion ; \
            (S)->cBuffers = (L)->cBuffers ; \
            (S)->pBuffers = (PSecBuffer) (L)->pBuffers ;

#define SecpSecPkgInfoToLpc( L, S ) \
            (L)->fCapabilities = (S)->fCapabilities ; \
            (L)->wVersion = (S)->wVersion ; \
            (L)->wRPCID = (S)->wRPCID ; \
            (L)->cbMaxToken = (S)->cbMaxToken ; \
            (L)->Name = (PWSTR_LPC) (S)->Name ; \
            (L)->Comment = (PWSTR_LPC) GET_WOW64_PTR((S)->Comment) ;

#define SecpLpcPkgInfoToSecPkgInfo( S, L ) \
            (S)->fCapabilities = (L)->fCapabilities ; \
            (S)->wVersion = (L)->wVersion ; \
            (S)->wRPCID = (L)->wRPCID ; \
            (S)->cbMaxToken = (L)->cbMaxToken ; \
            (S)->Name = (SEC_WCHAR *) (L)->Name ; \
            (S)->Comment = (SEC_WCHAR *) (L)->Comment ;

#else

#define ALIGN_WOW64

#define POINTER_FORMAT  "%p"

typedef SECURITY_STRING     SECURITY_STRING_LPC ;
typedef PVOID               PVOID_LPC ;
typedef SecHandle           SEC_HANDLE_LPC ;
typedef SecBufferDesc       SEC_BUFFER_DESC_LPC ;
typedef SecBuffer           SEC_BUFFER_LPC ;
typedef PWSTR               PWSTR_LPC ;
typedef LSA_SEC_HANDLE      LSA_SEC_HANDLE_LPC ;

#define SecpSecurityStringToLpc( L, S ) \
                *(L) = *(S) ;

#define SecpLpcStringToSecurityString( S, L ) \
                *(S) = *(L) ;

#define SecpSecBufferToLpc( L, S ) \
                *(L) = *(S) ;

#define SecpLpcBufferToSecBuffer( S, L ) \
                *(S) = *(L) ;

#define SecpSecBufferDescToLpc( L, S ) \
                *(L) = *(S) ;

#define SecpLpcBufferDescToSecBufferDesc( S, L ) \
                *(S) = *(L) ;
#endif

typedef SEC_HANDLE_LPC  CRED_HANDLE_LPC, * PCRED_HANDLE_LPC ;
typedef SEC_HANDLE_LPC  CONTEXT_HANDLE_LPC, * PCONTEXT_HANDLE_LPC ;
typedef SEC_HANDLE_LPC * PSEC_HANDLE_LPC ;
typedef SEC_BUFFER_LPC  * PSEC_BUFFER_LPC ;


//
// Connection specific data types
//


//
// The following are message structures for internal routines, such as
// synchronization and state messages
//
#define PACKAGEINFO_THUNKS  16

typedef struct _SEC_PACKAGE_BINDING_INFO_LPC {
    SECURITY_STRING_LPC PackageName;
    SECURITY_STRING_LPC Comment;
    SECURITY_STRING_LPC ModuleName;
    ULONG               PackageIndex;
    ULONG               fCapabilities;
    ULONG               Flags;
    ULONG               RpcId;
    ULONG               Version;
    ULONG               TokenSize;
    ULONG               ContextThunksCount ;
    ULONG               ContextThunks[ PACKAGEINFO_THUNKS ] ;
} SEC_PACKAGE_BINDING_INFO_LPC, * PSEC_PACKAGE_BINDING_INFO_LPC ;

#ifdef BUILD_WOW64

typedef struct _SEC_PACKAGE_BINDING_INFO {
    SECURITY_STRING     PackageName;
    SECURITY_STRING     Comment;
    SECURITY_STRING     ModuleName;
    ULONG               PackageIndex;
    ULONG               fCapabilities;
    ULONG               Flags;
    ULONG               RpcId;
    ULONG               Version;
    ULONG               TokenSize;
    ULONG               ContextThunksCount ;
    ULONG               ContextThunks[ PACKAGEINFO_THUNKS ] ;
} SEC_PACKAGE_BINDING_INFO, * PSEC_PACKAGE_BINDING_INFO ;

#else

typedef SEC_PACKAGE_BINDING_INFO_LPC SEC_PACKAGE_BINDING_INFO ;
typedef SEC_PACKAGE_BINDING_INFO_LPC * PSEC_PACKAGE_BINDING_INFO ;

#endif

#define PACKAGEINFO_BUILTIN 0x00000001
#define PACKAGEINFO_AUTHPKG 0x00000002
#define PACKAGEINFO_SIGNED  0x00000004


typedef struct _SPMGetBindingAPI {
    LSA_SEC_HANDLE_LPC ulPackageId;
    SEC_PACKAGE_BINDING_INFO_LPC BindingInfo;
} SPMGetBindingAPI;


//
// Internal SetSession API.
// not supported in Wow64
//

typedef struct _SPMSetSession {
    ULONG               Request;
    ULONG_PTR           Argument ;
    ULONG_PTR           Response;
    PVOID               ResponsePtr;
    PVOID               Extra ;
} SPMSetSessionAPI;

#define SETSESSION_GET_STATUS       0x00000001
#define SETSESSION_ADD_WORKQUEUE    0x00000002
#define SETSESSION_REMOVE_WORKQUEUE 0x00000003
#define SETSESSION_GET_DISPATCH     0x00000004


typedef struct _SPMFindPackageAPI {
    SECURITY_STRING_LPC ssPackageName;
    LSA_SEC_HANDLE_LPC  ulPackageId;
} SPMFindPackageAPI;


// The following are message structures.  Not surprisingly, they look a
// lot like the API signatures.  Keep that in mind.



// EnumeratePackages API

typedef struct _SPMEnumPackagesAPI {
    ULONG       cPackages;          // OUT
    PSecPkgInfo pPackages;          // OUT
} SPMEnumPackagesAPI;


//
// Credential APIs
//


// AcquireCredentialsHandle API

typedef struct _SPMAcquireCredsAPI {
    SECURITY_STRING_LPC ssPrincipal;       // IN
    SECURITY_STRING_LPC ssSecPackage;      // IN
    ULONG               fCredentialUse;     // IN
    LUID                LogonID;            // IN
    PVOID_LPC           pvAuthData;         // IN
    PVOID_LPC           pvGetKeyFn;         // IN
    PVOID_LPC           ulGetKeyArgument;   // IN
    CRED_HANDLE_LPC     hCredential;        // OUT
    TimeStamp           tsExpiry;           // OUT
    SEC_BUFFER_LPC      AuthData ;          // IN
} SPMAcquireCredsAPI;


// EstablishCredentials API
// not supported in Wow64

typedef struct _SPMEstablishCredsAPI {
    SECURITY_STRING Name;           // IN
    SECURITY_STRING Package;        // IN
    ULONG           cbKey;          // IN
    PUCHAR          pbKey;          // IN
    CredHandle      hCredentials;   // OUT
    TimeStamp       tsExpiry;       // OUT
} SPMEstablishCredsAPI;

// FreeCredentialsHandle API

typedef struct _SPMFreeCredHandleAPI {
    CRED_HANDLE_LPC hCredential;
} SPMFreeCredHandleAPI;


//
// Context APIs
//

// InitializeSecurityContext API

typedef struct _SPMInitSecContextAPI {
    CRED_HANDLE_LPC     hCredential;    // IN
    CONTEXT_HANDLE_LPC  hContext;       // IN
    SECURITY_STRING_LPC ssTarget;       // IN
    ULONG               fContextReq;    // IN
    ULONG               dwReserved1;    // IN
    ULONG               TargetDataRep;  // IN
    SEC_BUFFER_DESC_LPC sbdInput;       // IN
    ULONG               dwReserved2;    // IN
    CONTEXT_HANDLE_LPC  hNewContext;    // OUT
    SEC_BUFFER_DESC_LPC sbdOutput;      // IN OUT
    ULONG               fContextAttr;   // OUT
    TimeStamp           tsExpiry;       // OUT
    BOOLEAN             MappedContext;  // OUT
    SEC_BUFFER_LPC      ContextData;    // OUT
    SEC_BUFFER_LPC      sbData[0];      // IN
} SPMInitContextAPI;



// AcceptSecurityContext API

typedef struct _SPMAcceptContextAPI {
    CRED_HANDLE_LPC     hCredential;    // IN
    CONTEXT_HANDLE_LPC  hContext;       // IN
    SEC_BUFFER_DESC_LPC sbdInput;       // IN
    ULONG               fContextReq;    // IN
    ULONG               TargetDataRep;  // IN
    CHAR                IpAddress[LSAP_ADDRESS_LENGTH]; // IN
    CONTEXT_HANDLE_LPC  hNewContext;    // OUT
    SEC_BUFFER_DESC_LPC sbdOutput;      // IN OUT
    ULONG               fContextAttr;   // OUT
    TimeStamp           tsExpiry;       // OUT
    BOOLEAN             MappedContext;  // OUT
    SEC_BUFFER_LPC      ContextData;    // OUT
    SEC_BUFFER_LPC      sbData[0];      // IN OUT
} SPMAcceptContextAPI;

//
// ApplyControlToken API
//

typedef struct _SPMApplyTokenAPI {
    CONTEXT_HANDLE_LPC  hContext ;
    SEC_BUFFER_DESC_LPC sbdInput ;
    SEC_BUFFER_LPC      sbInputBuffer[ MAX_SECBUFFERS ];
} SPMApplyTokenAPI;

// DeleteContext API

typedef struct _SPMDeleteContextAPI {
    CONTEXT_HANDLE_LPC  hContext;           // IN - Context to delete
} SPMDeleteContextAPI;



//
// Miscelanneous, extension APIs
//


// QueryPackage API

typedef struct _SPMQueryPackageAPI {
    SECURITY_STRING_LPC ssPackageName;
    PSecPkgInfo         pPackageInfo;
} SPMQueryPackageAPI;



// GetSecurityUserInfo
// not supported in Wow64

typedef struct _SPMGetUserInfoAPI {
    LUID                LogonId;        // IN
    ULONG               fFlags;         // IN
    PSecurityUserData   pUserInfo;      // OUT
} SPMGetUserInfoAPI;


//
// Credentials APIs.  Not used.
//

typedef struct _SPMGetCredsAPI {
    CredHandle      hCredentials;       // IN
    SecBuffer       Credentials;        // OUT
} SPMGetCredsAPI;

typedef struct _SPMSaveCredsAPI {
    CredHandle      hCredentials;       // IN
    SecBuffer       Credentials;        // IN
} SPMSaveCredsAPI;

typedef struct _SPMQueryCredAttributesAPI {
    CRED_HANDLE_LPC hCredentials;
    ULONG           ulAttribute;
    PVOID_LPC       pBuffer;
    ULONG           Allocs ;
    PVOID_LPC       Buffers[MAX_BUFFERS_IN_CALL];
} SPMQueryCredAttributesAPI;


typedef struct _SPMAddPackageAPI {
    SECURITY_STRING_LPC Package;
    ULONG               OptionsFlags;
} SPMAddPackageAPI ;

typedef struct _SPMDeletePackageAPI {
    SECURITY_STRING_LPC Package;
} SPMDeletePackageAPI ;

typedef struct _SPMQueryContextAttrAPI {
    CONTEXT_HANDLE_LPC hContext ;
    ULONG              ulAttribute ;
    PVOID_LPC          pBuffer ;
    ULONG              Allocs ;
    PVOID_LPC          Buffers[MAX_BUFFERS_IN_CALL];
} SPMQueryContextAttrAPI ;

typedef struct _SPMSetContextAttrAPI {
    CONTEXT_HANDLE_LPC hContext ;
    ULONG              ulAttribute ;
    PVOID_LPC          pBuffer ;
    ULONG              cbBuffer;
} SPMSetContextAttrAPI ;


//
// Kernel mode EFS API.  None of these are Wow64
//

typedef struct _SPMEfsGenerateKeyAPI {
    PVOID           EfsStream;
    PVOID           DirectoryEfsStream;
    ULONG           DirectoryEfsStreamLength;
    PVOID           Fek;
    ULONG           BufferLength;
    PVOID           BufferBase;
} SPMEfsGenerateKeyAPI;

typedef struct _SPMEfsGenerateDirEfsAPI {
    PVOID       DirectoryEfsStream;
    ULONG       DirectoryEfsStreamLength;
    PVOID       EfsStream;
    PVOID       BufferBase;
    ULONG       BufferLength;
} SPMEfsGenerateDirEfsAPI;

typedef struct _SPMEfsDecryptFekAPI {
    PVOID       Fek;
    PVOID       EfsStream;
    ULONG       EfsStreamLength;
    ULONG       OpenType;
    PVOID       NewEfs;
    PVOID       BufferBase;
    ULONG       BufferLength;
} SPMEfsDecryptFekAPI;

typedef struct  _SPMEfsGenerateSessionKeyAPI {
    PVOID       InitDataExg;
} SPMEfsGenerateSessionKeyAPI;



//
// Usermode policy change notifications
//
//
// Note: Instead of a HANDLE structure use a ULONG64 for EventHandle member
//  to guarantee that passed value will be 64 bits. If not, in Wow64 the passed
//  handle will be 32 bits, while the server side expects it to be 64 bits.
//  Therefore always extend the handle to a 64 bit variable.
//
typedef struct _SPMLsaPolicyChangeNotifyAPI {
    ULONG Options;
    BOOLEAN Register;
    ULONG64 EventHandle;
    POLICY_NOTIFICATION_INFORMATION_CLASS NotifyInfoClass;
} SPMLsaPolicyChangeNotifyAPI;


typedef struct _SPMCallbackAPI {
    ULONG           Type;
    PVOID_LPC       CallbackFunction;
    PVOID_LPC       Argument1;
    PVOID_LPC       Argument2;
    SEC_BUFFER_LPC  Input ;
    SEC_BUFFER_LPC  Output ;
} SPMCallbackAPI ;

#define SPM_CALLBACK_INTERNAL   0x00000001  // Handled by the security DLL
#define SPM_CALLBACK_GETKEY     0x00000002  // Getkey function being called
#define SPM_CALLBACK_PACKAGE    0x00000003  // Package function
#define SPM_CALLBACK_EXPORT     0x00000004  // Ptr to string

//
// Fast name lookup
//

typedef struct _SPMGetUserNameXAPI {
    ULONG               Options ;
    SECURITY_STRING_LPC Name;
} SPMGetUserNameXAPI ;

#define SPM_NAME_OPTION_MASK        0xFFFF0000

#define SPM_NAME_OPTION_NT4_ONLY    0x00010000  // GetUserNameX only, not Ex
#define SPM_NAME_OPTION_FLUSH       0x00020000

//
// AddCredential API.
//

typedef struct _SPMAddCredential {
    CRED_HANDLE_LPC     hCredentials ;
    SECURITY_STRING_LPC ssPrincipal;       // IN
    SECURITY_STRING_LPC ssSecPackage;      // IN
    ULONG               fCredentialUse;     // IN
    LUID                LogonID;            // IN
    PVOID_LPC           pvAuthData;         // IN
    PVOID_LPC           pvGetKeyFn;         // IN
    PVOID_LPC           ulGetKeyArgument;   // IN
    TimeStamp           tsExpiry;           // OUT
} SPMAddCredentialAPI ;

typedef struct _SPMEnumLogonSession {
    PVOID_LPC       LogonSessionList ;      // OUT
    ULONG           LogonSessionCount ;     // OUT
} SPMEnumLogonSessionAPI ;

typedef struct _SPMGetLogonSessionData {
    LUID        LogonId ;                       // IN
    PVOID_LPC   LogonSessionInfo ;              // OUT
} SPMGetLogonSessionDataAPI ;

//
// Internal codes:
//

#define SPM_CALLBACK_ADDRESS_CHECK  1       // Setting up shared buffer
#define SPM_CALLBACK_SHUTDOWN       2       // Inproc shutdown notification


//
// SID translation APIs (for kmode callers, primarily)
//

typedef struct _SPMLookupAccountSidX {
    PVOID_LPC           Sid;        // IN
    SECURITY_STRING_LPC Name ;      // OUT
    SECURITY_STRING_LPC Domain ;    // OUT
    SID_NAME_USE NameUse ;          // OUT
} SPMLookupAccountSidXAPI ;

typedef struct _SPMLookupAccountNameX {
    SECURITY_STRING_LPC Name ;      // IN
    SECURITY_STRING_LPC Domain ;    // OUT
    PVOID_LPC           Sid ;       // OUT
    SID_NAME_USE        NameUse ;   // OUT
} SPMLookupAccountNameXAPI ;

typedef struct _SPMLookupWellKnownSid {
    WELL_KNOWN_SID_TYPE SidType ;
    PVOID_LPC           Sid ;
} SPMLookupWellKnownSidAPI ;


// this is the wrapper for all messages.

typedef union {
    SPMGetBindingAPI            GetBinding;
    SPMSetSessionAPI            SetSession;
    SPMFindPackageAPI           FindPackage;
    SPMEnumPackagesAPI          EnumPackages;
    SPMAcquireCredsAPI          AcquireCreds;
    SPMEstablishCredsAPI        EstablishCreds;
    SPMFreeCredHandleAPI        FreeCredHandle;
    SPMInitContextAPI           InitContext;
    SPMAcceptContextAPI         AcceptContext;
    SPMApplyTokenAPI            ApplyToken;
    SPMDeleteContextAPI         DeleteContext;
    SPMQueryPackageAPI          QueryPackage;
    SPMGetUserInfoAPI           GetUserInfo;
    SPMGetCredsAPI              GetCreds;
    SPMSaveCredsAPI             SaveCreds;
    SPMQueryCredAttributesAPI   QueryCredAttributes;
    SPMAddPackageAPI            AddPackage;
    SPMDeletePackageAPI         DeletePackage ;
    SPMEfsGenerateKeyAPI        EfsGenerateKey;
    SPMEfsGenerateDirEfsAPI     EfsGenerateDirEfs;
    SPMEfsDecryptFekAPI         EfsDecryptFek;
    SPMEfsGenerateSessionKeyAPI EfsGenerateSessionKey;
    SPMQueryContextAttrAPI      QueryContextAttr ;
    SPMCallbackAPI              Callback ;
    SPMLsaPolicyChangeNotifyAPI LsaPolicyChangeNotify;
    SPMGetUserNameXAPI          GetUserNameX ;
    SPMAddCredentialAPI         AddCredential ;
    SPMEnumLogonSessionAPI      EnumLogonSession ;
    SPMGetLogonSessionDataAPI   GetLogonSessionData ;
    SPMSetContextAttrAPI        SetContextAttr ;
    SPMLookupAccountSidXAPI     LookupAccountSidX ;
    SPMLookupAccountNameXAPI    LookupAccountNameX ;
    SPMLookupWellKnownSidAPI    LookupWellKnownSid ;
} SPM_API;

//
// This extends the range of LSA functions with the SPM functions
//

typedef enum _SPM_API_NUMBER {
    SPMAPI_GetBinding = (LsapAuMaxApiNumber + 1),
    SPMAPI_SetSession,
    SPMAPI_FindPackage,
    SPMAPI_EnumPackages,
    SPMAPI_AcquireCreds,
    SPMAPI_EstablishCreds,
    SPMAPI_FreeCredHandle,
    SPMAPI_InitContext,
    SPMAPI_AcceptContext,
    SPMAPI_ApplyToken,
    SPMAPI_DeleteContext,
    SPMAPI_QueryPackage,
    SPMAPI_GetUserInfo,
    SPMAPI_GetCreds,
    SPMAPI_SaveCreds,
    SPMAPI_QueryCredAttributes,
    SPMAPI_AddPackage,
    SPMAPI_DeletePackage,
    SPMAPI_EfsGenerateKey,
    SPMAPI_EfsGenerateDirEfs,
    SPMAPI_EfsDecryptFek,
    SPMAPI_EfsGenerateSessionKey,
    SPMAPI_Callback,
    SPMAPI_QueryContextAttr,
    SPMAPI_LsaPolicyChangeNotify,
    SPMAPI_GetUserNameX,
    SPMAPI_AddCredential,
    SPMAPI_EnumLogonSession,
    SPMAPI_GetLogonSessionData,
    SPMAPI_SetContextAttr,
    SPMAPI_LookupAccountNameX,
    SPMAPI_LookupAccountSidX,
    SPMAPI_LookupWellKnownSid,
    SPMAPI_MaxApiNumber
} SPM_API_NUMBER, *PSPM_API_NUMBER;

//
// These are the valid flags to set in the fAPI field
//

#define SPMAPI_FLAG_ERROR_RET   0x0001  // Indicates an error return
#define SPMAPI_FLAG_MEMORY      0x0002  // Memory was allocated in client
#define SPMAPI_FLAG_PREPACK     0x0004  // Data packed in bData field
#define SPMAPI_FLAG_GETSTATE    0x0008  // driver should call GetState

#define SPMAPI_FLAG_ANSI_CALL   0x0010  // Called via ANSI stub
#define SPMAPI_FLAG_HANDLE_CHG  0x0020  // A handle was changed
#define SPMAPI_FLAG_CALLBACK    0x0040  // Callback to calling process
#define SPMAPI_FLAG_ALLOCS      0x0080  // VM Allocs were placed in prepack
#define SPMAPI_FLAG_EXEC_NOW    0x0100  // Execute in LPC thread
#define SPMAPI_FLAG_WIN32_ERROR 0x0200  // Status is a win32 error
#define SPMAPI_FLAG_KMAP_MEM    0x0400  // Call contains buffers in the kmap

//
// This structure contains all the information needed for SPM api's
//

typedef struct _SPMLPCAPI {
    USHORT          fAPI ;
    USHORT          VMOffset ;
    PVOID_LPC       ContextPointer ;
    SPM_API         API;
} SPMLPCAPI, * PSPMLPCAPI;

//
// This union contains all the info for LSA api's
//

typedef union {
    LSAP_LOOKUP_PACKAGE_ARGS LookupPackage;
    LSAP_LOGON_USER_ARGS LogonUser;
    LSAP_CALL_PACKAGE_ARGS CallPackage;
} LSA_API;


//
// This union contains both SPM and LSA api's
//

typedef union _SPM_LSA_ARGUMENTS {
    LSA_API LsaArguments;
    SPMLPCAPI SpmArguments;
} SPM_LSA_ARGUMENTS, *PSPM_LSA_ARGUMENTS;

//
// For performance, some APIs will attempt to pack small parameters in the
// message being sent to the SPM, rather than have the SPM read it out of
// their memory.  So, this value defines how much data can be stuck in the
// message.
//
// Two items are defined here.  One, CBAPIHDR, is the size of everything
// in the message except the packed data.  The other, CBPREPACK, is the
// left over space.  I subtract 4 at the end to avoid potential boundary
// problems with an LPC message.
//

#define CBAPIHDR    (sizeof(PORT_MESSAGE) + sizeof(ULONG) + sizeof(HRESULT) + \
                    sizeof(SPM_LSA_ARGUMENTS))

#define CBPREPACK   (PORT_MAXIMUM_MESSAGE_LENGTH - CBAPIHDR - sizeof( PVOID_LPC ))

#define NUM_SECBUFFERS  ( CBPREPACK / sizeof(SecBuffer) )

//
// This structure is sent over during an API call rather than a connect
// message
//

typedef struct _SPM_API_MESSAGE {
    SPM_API_NUMBER      dwAPI;
    HRESULT             scRet;
    SPM_LSA_ARGUMENTS   Args;
    UCHAR               bData[CBPREPACK];
} SPM_API_MESSAGE, *PSPM_API_MESSAGE;

#define SecBaseMessageSize( Api ) \
    ( sizeof( SPM_API_NUMBER ) + sizeof( HRESULT ) + \
      ( sizeof( SPM_LSA_ARGUMENTS ) - sizeof( SPM_API ) + \
      sizeof( SPM##Api##API ) ) )


//
// This is the actual message sent over LPC - it contains both the
// connection request information and the api message
//


typedef struct _SPM_LPC_MESSAGE {
    PORT_MESSAGE    pmMessage;
    union {
        LSAP_AU_REGISTER_CONNECT_INFO ConnectionRequest;
        SPM_API_MESSAGE ApiMessage;
    };
} SPM_LPC_MESSAGE, *PSPM_LPC_MESSAGE;


//
// Macros to help prepare LPC messages
//

#ifdef SECURITY_USERMODE
#define PREPARE_MESSAGE_EX( Message, Api, Flags, Context ) \
    RtlZeroMemory( &(Message), sizeof( SPM_LSA_ARGUMENTS ) + sizeof( PORT_MESSAGE )  ); \
    (Message).pmMessage.u1.s1.DataLength =  \
            ( sizeof( SPM_API_NUMBER ) + sizeof( HRESULT ) + \
              ( sizeof( SPM_LSA_ARGUMENTS ) - sizeof( SPM_API ) + \
                sizeof( SPM##Api##API ) ) ); \
    (Message).pmMessage.u1.s1.TotalLength = (Message).pmMessage.u1.s1.DataLength + \
               sizeof( PORT_MESSAGE ); \
    (Message).pmMessage.u2.ZeroInit = 0L; \
    (Message).ApiMessage.scRet = 0L; \
    (Message).ApiMessage.dwAPI = SPMAPI_##Api ; \
    (Message).ApiMessage.Args.SpmArguments.fAPI = (USHORT)(Flags); \
    (Message).ApiMessage.Args.SpmArguments.ContextPointer = (Context);
#else
#define PREPARE_MESSAGE_EX( Message, Api, Flags, Context ) \
    RtlZeroMemory( &(Message), sizeof( SPM_LSA_ARGUMENTS ) + sizeof( PORT_MESSAGE )  ); \
    (Message).pmMessage.u1.s1.DataLength =  \
            ( sizeof( SPM_API_NUMBER ) + sizeof( HRESULT ) + \
              ( sizeof( SPM_LSA_ARGUMENTS ) - sizeof( SPM_API ) + \
                sizeof( SPM##Api##API ) ) );  \
    (Message).pmMessage.u1.s1.TotalLength = (Message).pmMessage.u1.s1.DataLength + \
               sizeof( PORT_MESSAGE ); \
    (Message).pmMessage.u2.ZeroInit = 0L; \
    (Message).ApiMessage.scRet = 0L; \
    (Message).ApiMessage.dwAPI = SPMAPI_##Api ; \
    (Message).ApiMessage.Args.SpmArguments.fAPI = (USHORT)(Flags); \
    (Message).ApiMessage.Args.SpmArguments.ContextPointer = (Context); \
    (Message).pmMessage.u2.s2.Type |= LPC_KERNELMODE_MESSAGE;
#endif

#define PREPARE_MESSAGE(Message, Api) PREPARE_MESSAGE_EX(Message, Api, 0, 0 )

#define LPC_MESSAGE_ARGS( Message, Api )\
    ( & (Message).ApiMessage.Args.SpmArguments.API.Api )

#define LPC_MESSAGE_ARGSP( Message, Api )\
    ( & (Message)->ApiMessage.Args.SpmArguments.API.Api )

#define DECLARE_ARGS( ArgPointer, Message, Api )\
    SPM##Api##API * ArgPointer = & (Message).ApiMessage.Args.SpmArguments.API.Api

#define DECLARE_ARGSP( ArgPointer, Message, Api)\
    SPM##Api##API * ArgPointer = & (Message)->ApiMessage.Args.SpmArguments.API.Api

#define PREPACK_START   FIELD_OFFSET( SPM_LPC_MESSAGE, ApiMessage.bData )

#define LPC_DATA_LENGTH( Length )\
            (USHORT) ((PREPACK_START) + (Length) - sizeof( PORT_MESSAGE ) )

#define LPC_TOTAL_LENGTH( Length )\
            (USHORT) ((PREPACK_START) + (Length))

BOOLEAN
FORCEINLINE
SecLpcIsPointerInMessage(
    PSPM_LPC_MESSAGE Message,
    PVOID_LPC Pointer
    )
{
    ULONG_PTR P ;
    ULONG_PTR B ;

    P = (ULONG_PTR) Pointer ;

    B = (ULONG_PTR) ((ULONG_PTR) Message->ApiMessage.bData) - (ULONG_PTR) Message ;

    return ( ( P >= B ) && (P < B + CBPREPACK ) );

}

PVOID_LPC
FORCEINLINE
SecLpcFixupPointer(
    PSPM_LPC_MESSAGE Message,
    PVOID_LPC Pointer
    )
{
    return (PVOID_LPC) ((PUCHAR) Message + (ULONG_PTR) Pointer );
}
//
// Prototype for the direct dispatch function:
//

typedef NTSTATUS (SEC_ENTRY LSA_DISPATCH_FN)(
    PSPM_LPC_MESSAGE );

typedef LSA_DISPATCH_FN * PLSA_DISPATCH_FN;


//
// structs used to manage memory shared between the LSA and KSEC driver
//

#define LSA_MAX_KMAP_SIZE   65535


//
// This structure describes a chunk of pool that has been copied into
// a kmap buffer.  The original pool address and the location in the
// kmap are here, as is the size of the chunk.  On IA64, this ends up
// with a wasted 32bit padding area
//
typedef struct _KSEC_LSA_POOL_MAP {
    PVOID_LPC   Pool ;                  // Region of pool
    USHORT      Offset ;                // Offset into kmap
    USHORT      Size ;                  // size of chunk
} KSEC_LSA_POOL_MAP, PKSEC_LSA_POOL_MAP ;

#define KSEC_LSA_MAX_MAPS   4

typedef struct _KSEC_LSA_MEMORY_HEADER {
    ULONG   Size ;          // Size of the reserved region
    ULONG   Commit ;        // Size of the committed space
    ULONG   Consumed ;      // Amount consumed
    USHORT  Preserve ;      // Size of the area to keep for ksec
    USHORT  MapCount ;      // number of entries in array
    KSEC_LSA_POOL_MAP   PoolMap[ KSEC_LSA_MAX_MAPS ];
} KSEC_LSA_MEMORY_HEADER, * PKSEC_LSA_MEMORY_HEADER ;

//
// This buffer type is used to indicate the header in the
// message from the driver to the LSA.  It is ignored if
// the call did not originate from kernel mode
//

#define SECBUFFER_KMAP_HEADER   0x00008001

#pragma warning(default:4200)

#endif // __SPMLPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\inc\secur32p.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        secur32p.h
//
// Contents:    Private functions between secur32.dll and lsa
//
//
// History:     16 Dec 98  RichardW Created
//
//------------------------------------------------------------------------

#ifndef __SECUR32P_H__
#define __SECUR32P_H__

NTSTATUS
WINAPI
SecCacheSspiPackages(
    VOID
    );


BOOLEAN
WINAPI
SecpTranslateName(
    PWSTR Domain,
    LPCWSTR Name,
    EXTENDED_NAME_FORMAT Supplied,
    EXTENDED_NAME_FORMAT Desired,
    PWSTR TranslatedName,
    PULONG TranslatedNameSize
    );

BOOLEAN
WINAPI
SecpTranslateNameEx(
    PWSTR Domain,
    LPCWSTR Name,
    EXTENDED_NAME_FORMAT Supplied,
    EXTENDED_NAME_FORMAT *DesiredSelection,
    ULONG  DesiredCount,
    PWSTR **TranslatedNames
    );

VOID
SecpFreeMemory(
    IN PVOID p
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\msprivs\msprivs2.h ===
#ifndef __MSPRIVS2_H_
#define __MSPRIVS2_H_

/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msprivs2.h

Abstract:

    String resource ids for privilege display names.

Author:

    kumarp   08-April-1999

Environment:

Revision History:

--*/

#define IDS_SeCreateTokenPrivilege          00
#define IDS_SeAssignPrimaryTokenPrivilege   01
#define IDS_SeLockMemoryPrivilege           02
#define IDS_SeIncreaseQuotaPrivilege        03
#define IDS_SeMachineAccountPrivilege       04
#define IDS_SeTcbPrivilege                  05
#define IDS_SeSecurityPrivilege             06
#define IDS_SeTakeOwnershipPrivilege        07
#define IDS_SeLoadDriverPrivilege           08
#define IDS_SeSystemProfilePrivilege        09
#define IDS_SeSystemtimePrivilege           10
#define IDS_SeProfileSingleProcessPrivilege 11
#define IDS_SeIncreaseBasePriorityPrivilege 12
#define IDS_SeCreatePagefilePrivilege       13
#define IDS_SeCreatePermanentPrivilege      14
#define IDS_SeBackupPrivilege               15
#define IDS_SeRestorePrivilege              16
#define IDS_SeShutdownPrivilege             17
#define IDS_SeDebugPrivilege                18
#define IDS_SeAuditPrivilege                19
#define IDS_SeSystemEnvironmentPrivilege    20
#define IDS_SeChangeNotifyPrivilege         21
#define IDS_SeRemoteShutdownPrivilege       22
// new in Windows 2000
#define IDS_SeUndockPrivilege               23
#define IDS_SeSyncAgentPrivilege            24
#define IDS_SeEnableDelegationPrivilege     25
// new in Windows 2000 + 1
#define IDS_SeManageVolumePrivilege         26
#define IDS_SeImpersonatePrivilege          27
#define IDS_SeCreateGlobalPrivilege         28

#endif // __MSPRIVS2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\netclient\credapi.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    credapi.c

Abstract:

    This module contains routines common between the netapi32.dll and LSA server side of
        the credential manager.

Author:

    Cliff Van Dyke (CliffV)    Oct 30, 2000

Revision History:

--*/

#ifndef LSA_SERVER_COMPILED
#include <lsacomp.h>
#include <lmcons.h>
#include "credp.h"
#include <windns.h>
#include <netlibnt.h>
#include <names.h>
#endif // LSA_SERVER_COMPILED

//
// Macros
//

#define CredpIsDomainCredential( _Type ) ( \
    (_Type) == CRED_TYPE_DOMAIN_PASSWORD || \
    (_Type) == CRED_TYPE_DOMAIN_CERTIFICATE || \
    (_Type) == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD )


BOOLEAN
CredpValidateDnsString(
    IN OUT LPWSTR String OPTIONAL,
    IN BOOLEAN NullOk,
    IN DNS_NAME_FORMAT DnsNameFormat,
    OUT PULONG StringSize
    )

/*++

Routine Description:

    This routine validates a passed in string.  The string must be a valid DNS name.
    Any trailing . is truncated.

Arguments:

    String - String to validate
        Any trailing . is truncated.
        This field is only modified if the routine returns TRUE.

    NullOk - if TRUE, a NULL string or zero length string is OK.

    DnsNameFormat - Expected format of the name.

    StringSize - Returns the length of the string (in bytes) including the
        trailing zero character.
        This field is only updated if the routine returns TRUE.

Return Values:

    TRUE - String is valid.

    FALSE - String is not valid.

--*/

{
    ULONG TempStringLen;

    if ( String == NULL ) {
        if ( !NullOk ) {
            return FALSE;
        }

        *StringSize = 0;
        return TRUE;
    }

    TempStringLen = wcslen( String );

    if ( TempStringLen == 0 ) {
        if ( !NullOk ) {
            return FALSE;
        }
    } else {
        //
        // Remove the trailing .
        //
        if ( String[TempStringLen-1] == L'.' ) {

            TempStringLen -= 1;

            //
            // Ensure the string isn't empty now.
            //

            if ( TempStringLen == 0 ) {
                if ( !NullOk ) {
                    return FALSE;
                }

            //
            // Ensure there aren't multiple trailing .'s
            //
            } else {
                if ( String[TempStringLen-1] == L'.' ) {
                    return FALSE;
                }
            }
        }

        //
        // Have DNS finish the validation
        //

        if ( TempStringLen != 0 ) {
            DWORD WinStatus;

            WinStatus = DnsValidateName_W( String, DnsNameFormat );

            if ( WinStatus != NO_ERROR &&
                 WinStatus != DNS_ERROR_NON_RFC_NAME ) {

                //
                // The RFC says hostnames cannot have numeric leftmost labels.
                //  However, Win 2K servers have such hostnames.
                //  So, allow them here forever more.
                //

                if ( DnsNameFormat == DnsNameHostnameFull &&
                     WinStatus == DNS_ERROR_NUMERIC_NAME ) {

                    /* Drop through */

                } else {
                    return FALSE;
                }

            }
        }
    }

    if ( TempStringLen > DNS_MAX_NAME_LENGTH ) {
        return FALSE;
    }

    String[TempStringLen] = L'\0';
    *StringSize = (TempStringLen + 1) * sizeof(WCHAR);
    return TRUE;
}


BOOLEAN
CredpValidateString(
    IN LPWSTR String OPTIONAL,
    IN ULONG MaximumLength,
    IN BOOLEAN NullOk,
    OUT PULONG StringSize
    )

/*++

Routine Description:

    This routine validates a passed in string.

Arguments:

    String - String to validate

    MaximumLength - Maximum length of the string (in characters).

    NullOk - if TRUE, a NULL string or zero length string is OK.

    StringSize - Returns the length of the string (in bytes) including the
        trailing zero character.

Return Values:

    TRUE - String is valid.

    FALSE - String is not valid.

--*/

{
    ULONG TempStringLen;

    if ( String == NULL ) {
        if ( !NullOk ) {
            return FALSE;
        }

        *StringSize = 0;
        return TRUE;
    }

    TempStringLen = wcslen( String );

    if ( TempStringLen == 0 ) {
        if ( !NullOk ) {
            return FALSE;
        }

        *StringSize = 0;
        return TRUE;
    }

    if ( TempStringLen > MaximumLength ) {
        return FALSE;
    }

    *StringSize = (TempStringLen + 1) * sizeof(WCHAR);
    return TRUE;
}

NTSTATUS
CredpValidateUserName(
    IN LPWSTR UserName,
    IN ULONG Type,
    OUT LPWSTR *CanonicalUserName
    )

/*++

Routine Description:

    This routine validates a passed in user name.

    For a password credential, a user name must have one of the following two syntaxes:

            <DomainName>\<UserName>
            <UserName>@<DnsDomainName>

        The name is considered to have the first syntax if the string contains an \.
        A string containing a @ is ambiguous since <UserName> may contain an @.

        For the second syntax, the last @ in the string is used since <UserName> may
        contain an @ but <DnsDomainName> cannot.

    For a certificate credential, the user name must be a marshalled cert reference

Arguments:

    UserName - Name of user to validate.

    Type - Specifies the Type of the credential.
        One of the CRED_TYPE_* values should be specified.

    CanonicalUserName - Returns a pointer to a buffer containing the user name in canonical form.
        Buffer must be freed using MIDL_user_free.

Return Values:

    The following status codes may be returned:

        STATUS_INVALID_ACCOUNT_NAME - The user name is not valid.

--*/

{
    NTSTATUS Status;

    LPWSTR SlashPointer;
    LPWSTR AtPointer;
    LPWSTR LocalUserName = NULL;
    ULONG UserNameSize;
    ULONG LocalStringSize;

    //
    // Check the string length
    //

    if ( !CredpValidateString( UserName,
                               CRED_MAX_USERNAME_LENGTH,
                               FALSE,
                               &UserNameSize ) ) {

        Status = STATUS_INVALID_ACCOUNT_NAME;
        goto Cleanup;
    }

    //
    // Grab a local writable copy of the string.
    //

    LocalUserName = (LPWSTR) MIDL_user_allocate( UserNameSize );

    if ( LocalUserName == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( LocalUserName, UserName, UserNameSize );

    //
    // Domain credentials need further validation.
    //

    if ( CredpIsDomainCredential( Type ) ) {

        //
        // Cert credentials have a marshalled cert reference as the UserName
        //

        if ( Type == CRED_TYPE_DOMAIN_CERTIFICATE ) {
            DWORD WinStatus;
            CRED_MARSHAL_TYPE CredType;
            PVOID UnmarshalledUsername;


            if ( !CredUnmarshalCredentialW( LocalUserName, &CredType, &UnmarshalledUsername ) ) {

                WinStatus = GetLastError();

                if ( WinStatus == ERROR_INVALID_PARAMETER ) {
                    Status = STATUS_INVALID_ACCOUNT_NAME;
                } else {
                    Status = NetpApiStatusToNtStatus(WinStatus);
                }

                goto Cleanup;
            }

            CredFree( UnmarshalledUsername );

            if ( CredType != CertCredential ) {
                Status = STATUS_INVALID_ACCOUNT_NAME;
                goto Cleanup;
            }

        //
        // Password credentials have UPN or domain\account user names
        //

        } else {

            //
            // Classify the input account name.
            //
            // The name is considered to be <DomainName>\<UserName> if the string
            // contains an \.
            //

            SlashPointer = wcsrchr( LocalUserName, L'\\' );

            if ( SlashPointer != NULL ) {
                LPWSTR LocalUserNameEnd;
                LPWSTR AfterSlashPointer;

                //
                // Skip the backslash
                //

                *SlashPointer = L'\0';
                AfterSlashPointer = SlashPointer + 1;

                //
                // Ensure the string to the left of the \ is a valid domain name
                //
                // (Do DNS name first to allow the name to be canonicalized.)

                LocalStringSize = (ULONG)(SlashPointer-LocalUserName+1)*sizeof(WCHAR);
                if ( !CredpValidateDnsString( LocalUserName, FALSE, DnsNameDomain, &LocalStringSize ) &&
                     !NetpIsDomainNameValid( LocalUserName ) ) {
                    Status = STATUS_INVALID_ACCOUNT_NAME;
                    goto Cleanup;
                }

                //
                // Ensure the string to the right of the \ is a valid user name
                //

                if ( !NetpIsUserNameValid( AfterSlashPointer )) {
                    Status = STATUS_INVALID_ACCOUNT_NAME;
                    goto Cleanup;
                }

                //
                // If the dns domain name was canonicalized,
                //  rebuild the complete user name.
                //

                *SlashPointer = '\\';

                LocalUserNameEnd = &LocalUserName[LocalStringSize/sizeof(WCHAR) - 1];

                if ( SlashPointer != LocalUserNameEnd ) {
                    RtlMoveMemory( LocalUserNameEnd,
                                   SlashPointer,
                                   (wcslen(SlashPointer) + 1) * sizeof(WCHAR) );
                }

            //
            // Otherwise the name must be a UPN
            //

            } else {

                //
                // A UPN has the syntax <AccountName>@<DnsDomainName>.
                // If there are multiple @ signs,
                //  use the last one since an AccountName can have an @ in it.
                //
                //

                AtPointer = wcsrchr( LocalUserName, L'@' );
                if ( AtPointer == NULL ) {
                    Status = STATUS_INVALID_ACCOUNT_NAME;
                    goto Cleanup;
                }


                //
                // The string to the left of the @ can really have any syntax.
                //  But must be non-null.
                //

                if ( AtPointer == LocalUserName ) {
                    Status = STATUS_INVALID_ACCOUNT_NAME;
                    goto Cleanup;
                }



                //
                // Ensure the string to the right of the @ is a DNS domain name
                //

                AtPointer ++;
                if ( !CredpValidateDnsString( AtPointer, FALSE, DnsNameDomain, &LocalStringSize ) ) {
                    Status = STATUS_INVALID_ACCOUNT_NAME;
                    goto Cleanup;
                }

            }

        }
    }

    Status = STATUS_SUCCESS;

    //
    // Copy parameters back to the caller
    //

    *CanonicalUserName = LocalUserName;
    LocalUserName = NULL;


    //
    // Cleanup
    //
Cleanup:
    if ( LocalUserName != NULL ) {
        MIDL_user_free( LocalUserName );
    }

    return Status;

}

NTSTATUS
NET_API_FUNCTION
CredpValidateTargetName(
    IN OUT LPWSTR TargetName,
    IN ULONG Type,
    IN TARGET_NAME_TYPE TargetNameType,
    IN LPWSTR *UserNamePointer OPTIONAL,
    IN LPDWORD PersistPointer OPTIONAL,
    OUT PULONG TargetNameSize,
    OUT PWILDCARD_TYPE WildcardTypePointer OPTIONAL,
    OUT PUNICODE_STRING NonWildcardedTargetName OPTIONAL
    )

/*++

Routine Description:

    This routine validates a passed in TargetName and TargetType for a credential.

Arguments:

    TargetName - TargetName to validate
        The returned buffer is a canonicalized form of the target name.

    Type - Specifies the Type of the credential.
        One of the CRED_TYPE_* values should be specified.

    TargetNameType - Specifies whether the TargetName needs to match UsernameTarget Syntax

    UserNamePointer - Points to the address of a string which is the user name on the credential.
        If NULL, the UserName is unknown.
        If not NULL, the user name is used for UsernameTarget target name validation.

    PersistPointer - Points to a DWORD describing the persistence of the credential named by TargetName.
        If NULL, the peristence is unknown.
        If not NULL, the persistence will be checked to ensure it is valid for TargetName.

    TargetNameSize - Returns the length of the TargetName (in bytes) including the
        trailing zero character.

    WildcardType - If specified, returns the type of the wildcard specified in TargetName

    NonWildcardedTargetName - If specified, returns the non-wildcarded form of TargetName.
        The caller must free NonWildcardedTargetName->Buffer using MIDL_user_free.

Return Values:

    The following status codes may be returned:

        STATUS_INVALID_PARAMETER - The TargetName or Type are invalid.

        STATUS_INVALID_ACCOUNT_NAME - The user name is not valid.

--*/

{
    NTSTATUS Status;
    ULONG MaxStringLength;
    LPWSTR AllocatedTargetName = NULL;
    ULONG TempTargetNameSize;
    BOOLEAN TargetNameIsUserName = FALSE;
    WILDCARD_TYPE WildcardType;

    LPWSTR CanonicalUserName = NULL;
    LPWSTR TnAsCanonicalUserName = NULL;

    LPWSTR RealTargetName = TargetName;  // TargetName sans wildcard chars
    ULONG RealTargetNameLength;

    //
    // Initialization
    //

    if ( NonWildcardedTargetName != NULL ) {
        RtlInitUnicodeString( NonWildcardedTargetName, NULL );
    }

    //
    // Validate the type
    //

    if ( Type == CRED_TYPE_GENERIC ) {

        MaxStringLength = CRED_MAX_GENERIC_TARGET_NAME_LENGTH;

        //
        // Don't allow generic UsernameTarget credentials
        //

        if ( TargetNameType == IsUsernameTarget ) {
#ifdef LSA_SERVER_COMPILED
            DebugLog(( DEB_TRACE_CRED,
                       "CredpValidateTargetName: Generic creds cannot be UsernameTarget: %ld.\n",
                       Type ));
#endif // LSA_SERVER_COMPILED
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // We really know this isn't a UsernameTarget credential
        //

        TargetNameType = IsNotUsernameTarget;

    } else if ( CredpIsDomainCredential( Type ) ) {

        MaxStringLength = CRED_MAX_DOMAIN_TARGET_NAME_LENGTH;
        ASSERT( CRED_MAX_DOMAIN_TARGET_NAME_LENGTH == DNS_MAX_NAME_LENGTH + 1 + 1 + NNLEN );

    } else {
#ifdef LSA_SERVER_COMPILED
        DebugLog(( DEB_TRACE_CRED,
                   "CredpValidateTargetName: %ws: Invalid Type: %ld.\n",
                   TargetName,
                   Type ));
#endif // LSA_SERVER_COMPILED
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // If this might be a "UsernameTarget" credential,
    //  check if the credential looks like a user name.
    //

    if ( TargetNameType == IsUsernameTarget ||
         TargetNameType == MightBeUsernameTarget ) {

        //
        // Also allow target names that are valid user names
        //  (Don't canonicalize.  We don't have an opportunity to canonicalize short names.)
        //

        Status = CredpValidateUserName( TargetName, Type, &TnAsCanonicalUserName );

        if ( NT_SUCCESS(Status) ) {

            //
            // If we don't know the user name,
            //  accept this as valid syntax.
            //

            if ( UserNamePointer == NULL ) {

                MaxStringLength = CRED_MAX_USERNAME_LENGTH;
                TargetNameIsUserName = TRUE;

            //
            // If we know the user name,
            //  it must match for this syntax to be valid.
            //

            } else {

                UNICODE_STRING UserNameString;
                UNICODE_STRING TargetNameString;

                //
                // Validate the user name before touching it.
                //

                Status = CredpValidateUserName( *UserNamePointer,
                                                Type,
                                                &CanonicalUserName );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }

                RtlInitUnicodeString( &UserNameString, CanonicalUserName );
                RtlInitUnicodeString( &TargetNameString, TnAsCanonicalUserName );

                //
                // The target name might be identical to the UserName.
                //
                // Such credentials are the "UsernameTarget" credentials.
                //

                if ( UserNameString.Length != 0 &&
                     RtlEqualUnicodeString( &TargetNameString,
                                            &UserNameString,
                                            TRUE ) ) {

                    MaxStringLength = CRED_MAX_USERNAME_LENGTH;
                    TargetNameIsUserName = TRUE;

                }

            }


        }


        //
        // If the caller was sure this is a UsernameTarget credential,
        //  make sure it really was.
        //

        if ( TargetNameType == IsUsernameTarget && !TargetNameIsUserName ) {
#ifdef LSA_SERVER_COMPILED
            DebugLog(( DEB_TRACE_CRED,
                       "CredpValidateTargetName: %ws: Is 'UsernameTarget' and target name doesn't match user name: %ld.\n",
                       TargetName,
                       Type ));
#endif // LSA_SERVER_COMPILED
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

    }

    //
    // Validate the string
    //

    if ( !CredpValidateString( TargetName,
                               MaxStringLength,
                               FALSE,   // NULL not OK
                               TargetNameSize ) ) {


#ifdef LSA_SERVER_COMPILED
        DebugLog(( DEB_TRACE_CRED,
                   "CredpValidateTargetName: Invalid TargetName buffer.\n" ));
#endif // LSA_SERVER_COMPILED
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // For generic credentials,
    //  that's all the validation needed.
    //

    WildcardType = WcServerName;
    if ( Type == CRED_TYPE_GENERIC ) {
        /* Do nothing here */

    //
    // For domain credentials,
    //   classify the target name.
    //

    } else {



        //
        // The target name might be a user name.
        //  (If we're not sure, let the other types take precedence.)
        //

        RealTargetName = TargetName;
        RealTargetNameLength = (*TargetNameSize-sizeof(WCHAR))/sizeof(WCHAR);

        if ( TargetNameType == IsUsernameTarget && TargetNameIsUserName ) {
            WildcardType = WcUserName;
            wcscpy( TargetName, TnAsCanonicalUserName );
            *TargetNameSize = (wcslen( TargetName ) + 1) * sizeof(WCHAR);


        //
        // The target name might be of the form <Domain>\*
        //

        } else if ( RealTargetNameLength > 2 &&
             RealTargetName[RealTargetNameLength-1] == L'*' &&
             RealTargetName[RealTargetNameLength-2] == L'\\' ) {

            //
            // Allocate a buffer for the target name so we don't have to modify the
            //  callers buffer.
            //

            WildcardType = WcDomainWildcard;

            AllocatedTargetName = (LPWSTR) MIDL_user_allocate( *TargetNameSize );

            if ( AllocatedTargetName == NULL ) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            RtlCopyMemory( AllocatedTargetName, RealTargetName, *TargetNameSize );
            RealTargetName = AllocatedTargetName;
            RealTargetNameLength -= 2;
            RealTargetName[RealTargetNameLength] = '\0';

            //
            // The domain itself might be a netbios or DNS domain
            //
            // Do DNS test first.  That allows the validate routine to truncate
            //

            TempTargetNameSize = ((RealTargetNameLength+1)*sizeof(WCHAR));
            if ( !CredpValidateDnsString(
                            RealTargetName,
                            FALSE,
                            DnsNameDomain,
                            &TempTargetNameSize ) &&
                 !NetpIsDomainNameValid( RealTargetName ) ) {

                Status = STATUS_INVALID_PARAMETER;
#ifdef LSA_SERVER_COMPILED
                DebugLog(( DEB_TRACE_CRED,
                           "ValidateTargetName: %ws: TargetName for domain wildcard must netbios or dns domain.\n",
                           TargetName ));
#endif // LSA_SERVER_COMPILED
                goto Cleanup;
            }

            //
            // If Dns truncated,
            //  put the canonical name back in the callers buffer.
            //

            RealTargetNameLength = (TempTargetNameSize-sizeof(WCHAR))/sizeof(WCHAR);
            RealTargetName[RealTargetNameLength] = '\0';

            if ( *TargetNameSize-(2*sizeof(WCHAR)) != TempTargetNameSize ) {
                RtlCopyMemory( TargetName,
                               RealTargetName,
                               TempTargetNameSize );
                TargetName[RealTargetNameLength] = '\\';
                TargetName[RealTargetNameLength+1] = '*';
                TargetName[RealTargetNameLength+2] = '\0';
                *TargetNameSize = (wcslen( TargetName ) + 1) * sizeof(WCHAR);
            }

        //
        // Handle the universal wildcard
        //
        } else if ( RealTargetNameLength == 1 &&
                    RealTargetName[0] == L'*' ) {

            WildcardType = WcUniversalWildcard;


        //
        // Handle server wildcards
        //
        } else if ( CredpValidateDnsString(
                        TargetName,
                        FALSE,
                        DnsNameWildcard,
                        TargetNameSize )) {

            WildcardType = WcServerWildcard;
            RealTargetName += 1;
            RealTargetNameLength -= 1;

        //
        // Handle the universal session wildcard
        //

        } else if ( RealTargetNameLength == CRED_SESSION_WILDCARD_NAME_LENGTH &&
                    _wcsicmp( RealTargetName, CRED_SESSION_WILDCARD_NAME_W ) == 0 ) {

            WildcardType = WcUniversalSessionWildcard;

            //
            // This target name requires session persistence.
            //

            if ( PersistPointer != NULL &&
                 *PersistPointer != CRED_PERSIST_SESSION ) {

                Status = STATUS_INVALID_PARAMETER;
#ifdef LSA_SERVER_COMPILED
                DebugLog(( DEB_TRACE_CRED,
                           "ValidateTargetName: %ws: TargetName requires session persistence %ld.\n",
                           TargetName,
                           *PersistPointer ));
#endif // LSA_SERVER_COMPILED
                goto Cleanup;
            }


        //
        //  The target name might be a non-wildcard netbios name.
        //  The target name might be a non-wildcard dns name.
        //
        // Do DNS test first.  That allows the validate routine to truncate
        //  the trailing .
        //
        //

        } else if ( CredpValidateDnsString(
                            TargetName,
                            FALSE,
                            DnsNameHostnameFull,
                            TargetNameSize ) ||
                    NetpIsDomainNameValid( TargetName ) ) {

            WildcardType = WcServerName;

        //
        // This target name might be a DFS share name
        //
        // The format is <DfsRoot>\<DfsShare>
        //

        } else {
            LPWSTR SlashPtr;
            ULONG SavedTargetNameSize;


            //
            // A DFS Share has a slash in it
            //

            SlashPtr = wcschr( TargetName, L'\\' );

            if ( SlashPtr != NULL ) {


                //
                // A DFS share has a share name with the right syntax
                //

                if ( NetpIsShareNameValid( SlashPtr+1 ) ) {


                    //
                    // Allocate a copy of the data for the RealTargetName
                    //

                    AllocatedTargetName = (LPWSTR) MIDL_user_allocate( *TargetNameSize );

                    if ( AllocatedTargetName == NULL ) {
                        Status = STATUS_NO_MEMORY;
                        goto Cleanup;
                    }

                    RtlCopyMemory( AllocatedTargetName, RealTargetName, *TargetNameSize );
                    RealTargetName = AllocatedTargetName;
                    RealTargetNameLength = (ULONG)(SlashPtr-TargetName);
                    RealTargetName[RealTargetNameLength] = '\0';

                    //
                    // The domain itself might be a netbios or DNS domain
                    //
                    // Do DNS test first.  That allows the validate routine to truncate
                    //

                    TempTargetNameSize = ((RealTargetNameLength+1)*sizeof(WCHAR));
                    SavedTargetNameSize = TempTargetNameSize;
                    if ( CredpValidateDnsString(
                                    RealTargetName,
                                    FALSE,
                                    DnsNameDomain,
                                    &TempTargetNameSize ) ||
                         NetpIsDomainNameValid( RealTargetName ) ) {

                        //
                        // If Dns truncated,
                        //  put the canonical name back in the callers buffer.
                        //

                        RealTargetNameLength = (TempTargetNameSize-sizeof(WCHAR))/sizeof(WCHAR);
                        RealTargetName[RealTargetNameLength] = '\0';

                        if ( SavedTargetNameSize != TempTargetNameSize ) {
                            ULONG DfsShareSize;

                            DfsShareSize = *TargetNameSize - (SlashPtr-TargetName)*sizeof(WCHAR);

                            // Copy <DfsRoot>
                            RtlCopyMemory( TargetName,
                                           RealTargetName,
                                           RealTargetNameLength*sizeof(WCHAR) );

                            // Copy \<DfsShare><\0>
                            RtlMoveMemory( &TargetName[RealTargetNameLength],
                                           SlashPtr,
                                           DfsShareSize );

                            *TargetNameSize = RealTargetNameLength*sizeof(WCHAR) + DfsShareSize;

                        }

                        WildcardType = WcDfsShareName;
                    }

                }
            }

            //
            // At this point,
            //  if the syntax isn't DFS SHARE,
            // Then it must be one of the other syntaxes.
            //

            if ( WildcardType != WcDfsShareName ) {

                //
                // The target name might have defaulted to be a user name.
                //

                if ( TargetNameIsUserName ) {
                    WildcardType = WcUserName;
                    wcscpy( TargetName, TnAsCanonicalUserName );
                    *TargetNameSize = (wcslen( TargetName ) + 1) * sizeof(WCHAR);

                //
                // Everything else is invalid
                //

                } else {
                    Status = STATUS_INVALID_PARAMETER;
#ifdef LSA_SERVER_COMPILED
                    DebugLog(( DEB_TRACE_CRED,
                               "ValidateTargetName: %ws: TargetName syntax invalid.\n",
                               TargetName ));
#endif // LSA_SERVER_COMPILED
                    goto Cleanup;
                }

            }

        }

    }

    //
    // On success, copy the parameters back to the caller.
    //

    if ( WildcardTypePointer != NULL ) {
        *WildcardTypePointer = WildcardType;
    }

    if ( NonWildcardedTargetName != NULL ) {

        ULONG BufferSize = (wcslen(RealTargetName) + 1) * sizeof(WCHAR);

        NonWildcardedTargetName->Buffer = (LPWSTR) MIDL_user_allocate( BufferSize );

        if ( NonWildcardedTargetName->Buffer == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        RtlCopyMemory( NonWildcardedTargetName->Buffer, RealTargetName, BufferSize );
        NonWildcardedTargetName->MaximumLength = (USHORT)BufferSize;
        NonWildcardedTargetName->Length = (USHORT)(BufferSize - sizeof(WCHAR));
    }



    Status = STATUS_SUCCESS;

Cleanup:

    if ( AllocatedTargetName != NULL ) {
        MIDL_user_free( AllocatedTargetName );
    }

    if ( CanonicalUserName != NULL ) {
        MIDL_user_free( CanonicalUserName );
    }

    if ( TnAsCanonicalUserName != NULL ) {
        MIDL_user_free( TnAsCanonicalUserName );
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\credapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        Credapi.C
//
// Contents:    Credential API stubs for LPC
//
//
// History:
//
//------------------------------------------------------------------------

#include "secpch2.hxx"

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "spmlpcp.h"
}

#if defined(ALLOC_PRAGMA) && defined(SECURITY_KERNEL)
#pragma alloc_text(PAGE, SecpAcquireCredentialsHandle)
#pragma alloc_text(PAGE, SecpFreeCredentialsHandle)
#pragma alloc_text(PAGE, SecpAddCredentials )
#pragma alloc_text(PAGE, SecpQueryCredentialsAttributes)
#endif

//+-------------------------------------------------------------------------
//
//  Function:   SecpAcquireCredentialsHandle
//
//  Synopsis:   LPC client stub for AcquireCredentialsHandle
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
SecpAcquireCredentialsHandle(   
    PVOID_LPC           Context,
    PSECURITY_STRING    pssPrincipalName,
    PSECURITY_STRING    pssPackageName,
    ULONG               fCredentialUse,
    PLUID               pLogonID,
    PVOID               pvAuthData,
    SEC_GET_KEY_FN      pvGetKeyFn,
    PVOID               ulGetKeyArgument,
    PCRED_HANDLE_LPC    phCredentials,
    PTimeStamp          ptsExpiry, OPTIONAL
    PULONG              Flags)
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, AcquireCreds );
    ULONG           cbPrepackAvail = CBPREPACK;
    PUCHAR          Where;

    SEC_PAGED_CODE();

    DebugLog((DEB_TRACE,"Entered AcquireCredHandle\n"));

    scRet = IsOkayToExec( &pClient );
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    PREPARE_MESSAGE_EX(ApiBuffer, AcquireCreds, *Flags, Context );

    Where = ApiBuffer.ApiMessage.bData;

    if (pssPrincipalName)
    {
        DebugLog((DEB_TRACE_CALL,"    Principal = %wZ \n", pssPrincipalName));
        
        SecpSecurityStringToLpc( (&Args->ssPrincipal), pssPrincipalName );
        // Args->ssPrincipal     = *pssPrincipalName;

        if ((pssPrincipalName->Length > 0) &&
            (pssPrincipalName->Length <= cbPrepackAvail))
        {
            Args->ssPrincipal.Buffer =  (PWSTR_LPC) ((LONG_PTR) Where - (LONG_PTR) &ApiBuffer) ;

            RtlCopyMemory(
                    Where,
                    pssPrincipalName->Buffer,
                    pssPrincipalName->Length );

            Where += pssPrincipalName->Length;

            cbPrepackAvail -= pssPrincipalName->Length;
        }
        else
        {
            Args->ssPrincipal.Buffer        = 0;
            Args->ssPrincipal.MaximumLength = 0;
            Args->ssPrincipal.Length        = 0;
        }
    } 
    else
    {
        Args->ssPrincipal.Buffer        = 0;
        Args->ssPrincipal.MaximumLength = 0;
        Args->ssPrincipal.Length        = 0;
    }

    SecpSecurityStringToLpc( &Args->ssSecPackage, pssPackageName );

    if (pssPackageName->Length <= cbPrepackAvail)
    {
        Args->ssSecPackage.Buffer =  (PWSTR_LPC) ((LONG_PTR) Where - (LONG_PTR) &ApiBuffer );

        RtlCopyMemory(
                Where,
                pssPackageName->Buffer,
                pssPackageName->Length);

        Where += pssPackageName->Length;

        cbPrepackAvail -= pssPackageName->Length;
    }

    DebugLog((DEB_TRACE_CALL,"    PackageName = %wZ  \n", pssPackageName));

    Args->fCredentialUse   = fCredentialUse;
    if (pLogonID)
    {
        Args->LogonID      = *pLogonID;
        DebugLog((DEB_TRACE_CALL,"    LogonID = %x : %x\n", pLogonID->HighPart, pLogonID->LowPart));

    }
    else
    {
        Args->LogonID.HighPart = 0;
        Args->LogonID.LowPart  = 0;
    }

    if ( cbPrepackAvail != CBPREPACK )
    {
        //
        // We have consumed some of the bData space:  Adjust 
        // our length accordingly
        //

        ApiBuffer.pmMessage.u1.s1.TotalLength = (CSHORT) (Where - (PUCHAR) &ApiBuffer) ;

        ApiBuffer.pmMessage.u1.s1.DataLength = 
                ApiBuffer.pmMessage.u1.s1.TotalLength - sizeof( PORT_MESSAGE );
    }

    Args->pvAuthData = (PVOID_LPC) pvAuthData;
    Args->pvGetKeyFn = (PVOID_LPC) pvGetKeyFn;
    Args->ulGetKeyArgument = (PVOID_LPC) ulGetKeyArgument;

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    if ( NT_SUCCESS( scRet ) )
    {
        scRet = ApiBuffer.ApiMessage.scRet ;
    }

    DebugLog((DEB_TRACE,"AcquireCreds API Ret = %x\n", ApiBuffer.ApiMessage.scRet));

    *phCredentials = Args->hCredential;

    if (ARGUMENT_PRESENT(ptsExpiry))
    {
        *ptsExpiry = Args->tsExpiry;
    }

    DebugLog((DEB_TRACE_CALL,"    hCredentials = " POINTER_FORMAT " : " POINTER_FORMAT "\n", phCredentials->dwUpper, phCredentials->dwLower));

    FreeClient(pClient);

    *Flags = ApiBuffer.ApiMessage.Args.SpmArguments.fAPI ;

    return( scRet );
}


SECURITY_STATUS SEC_ENTRY
SecpAddCredentials(
    PVOID_LPC Context,
    PCRED_HANDLE_LPC phCredentials,
    PSECURITY_STRING pPrincipalName,
    PSECURITY_STRING pPackageName,
    ULONG fCredentialUse,
    PVOID pvAuthData,
    SEC_GET_KEY_FN pvGetKeyFn,
    PVOID pvGetKeyArg,
    PTimeStamp Expiry,
    PULONG Flags
    )
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, AddCredential );
    ULONG           cbPrepackAvail = CBPREPACK;
    PUCHAR          Where;

    SEC_PAGED_CODE();

    DebugLog((DEB_TRACE,"Entered AddCredential\n"));

    scRet = IsOkayToExec( &pClient );
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    PREPARE_MESSAGE_EX(ApiBuffer, AddCredential, *Flags, Context );

    Where = ApiBuffer.ApiMessage.bData;

    if (pPrincipalName)
    {
        DebugLog((DEB_TRACE_CALL,"    Principal = %wZ \n", pPrincipalName));

        SecpSecurityStringToLpc( &Args->ssPrincipal, pPrincipalName );

        if ((pPrincipalName->Length > 0) &&
            (pPrincipalName->Length <= cbPrepackAvail))
        {
            Args->ssPrincipal.Buffer = (PWSTR_LPC) (Where - (PUCHAR) &ApiBuffer );
            RtlCopyMemory(
                Where,
                pPrincipalName->Buffer,
                pPrincipalName->Length);

            Where += pPrincipalName->Length;

            cbPrepackAvail -= pPrincipalName->Length;
        }
        else
        {
            Args->ssPrincipal.Buffer        = 0;
            Args->ssPrincipal.MaximumLength = 0;
            Args->ssPrincipal.Length        = 0;
        }
    } 
    else
    {
        Args->ssPrincipal.Buffer        = 0;
        Args->ssPrincipal.MaximumLength = 0;
        Args->ssPrincipal.Length        = 0;
    }

    SecpSecurityStringToLpc( &Args->ssSecPackage, pPackageName );

    if (pPackageName->Length <= cbPrepackAvail)
    {
        Args->ssSecPackage.Buffer = (PWSTR_LPC) (Where - (PUCHAR) &ApiBuffer );

        RtlCopyMemory(
                Where,
                pPackageName->Buffer,
                pPackageName->Length);

        Where += pPackageName->Length;

        cbPrepackAvail -= pPackageName->Length;
    }

    DebugLog((DEB_TRACE_CALL,"    PackageName = %wZ  \n", pPackageName));

    Args->hCredentials = *phCredentials ;
    Args->fCredentialUse   = fCredentialUse;

    Args->pvAuthData = (PVOID_LPC) pvAuthData;
    Args->pvGetKeyFn = (PVOID_LPC) pvGetKeyFn;
    Args->ulGetKeyArgument = (PVOID_LPC) pvGetKeyArg ;

    if ( cbPrepackAvail != CBPREPACK )
    {
        //
        // We have consumed some of the bData space:  Adjust 
        // our length accordingly
        //

        ApiBuffer.pmMessage.u1.s1.TotalLength = (CSHORT) (Where - (PUCHAR) &ApiBuffer) ;

        ApiBuffer.pmMessage.u1.s1.DataLength = 
                ApiBuffer.pmMessage.u1.s1.TotalLength - sizeof( PORT_MESSAGE );
    }

    //
    // Call to the LSA
    //

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"AddCredentials API Ret = %x\n", ApiBuffer.ApiMessage.scRet));

    if (ARGUMENT_PRESENT(Expiry))
    {
        *Expiry = Args->tsExpiry;
    }

    FreeClient(pClient);

    *Flags = ApiBuffer.ApiMessage.Args.SpmArguments.fAPI ;

    return(ApiBuffer.ApiMessage.scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   SecpFreeCredentialsHandle
//
//  Synopsis:   LPC client stub for FreeCredentialsHandle
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
SecpFreeCredentialsHandle(
    ULONG            fFree,
    PCRED_HANDLE_LPC phCredential)
{
    SECURITY_STATUS scRet;
    PClient         pClient;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    DECLARE_ARGS( Args, ApiBuffer, FreeCredHandle );

    SEC_PAGED_CODE();

    DebugLog((DEB_TRACE,"Entered FreeCredentialHandle\n"));

    scRet = IsOkayToExec( &pClient );

    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    PREPARE_MESSAGE(ApiBuffer, FreeCredHandle);

    Args->hCredential = *phCredential;

    if (fFree & SECP_DELETE_NO_BLOCK)
    {
        ApiBuffer.ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_EXEC_NOW;
    }

    DebugLog(( DEB_TRACE, "  hCredentials  " POINTER_FORMAT " : " POINTER_FORMAT "\n",
                        phCredential->dwUpper, phCredential->dwLower ));

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    if (NT_SUCCESS(scRet))
    {
        scRet           = ApiBuffer.ApiMessage.scRet;
    }

    FreeClient(pClient);
    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   SecpQueryCredentialsAttributes
//
//  Synopsis:   Client LPC stub for SecpQueryCredentialsAttributes
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
SecpQueryCredentialsAttributes(
    PCRED_HANDLE_LPC phCredentials,
    ULONG ulAttribute,
    PVOID pBuffer,
    LONG Flags,
    PULONG Allocs,
    PVOID * Buffers
    )
{
    SECURITY_STATUS scRet;
    PClient         pClient;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    DECLARE_ARGS( Args, ApiBuffer, QueryCredAttributes );
    ULONG i ;

    SEC_PAGED_CODE();

    DebugLog((DEB_TRACE,"Entered QueryCredentialsAttributes\n"));

    scRet = IsOkayToExec( &pClient );

    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    PREPARE_MESSAGE_EX(ApiBuffer, QueryCredAttributes, Flags, NULL );

    Args->hCredentials = *phCredentials;
    Args->ulAttribute = ulAttribute;
    Args->pBuffer = (PVOID_LPC) pBuffer;

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
    }

    if ( NT_SUCCESS( scRet ) )
    {
        if ( ApiBuffer.ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_ALLOCS )
        {
            ASSERT( Args->Allocs <= MAX_BUFFERS_IN_CALL );

            *Allocs = Args->Allocs ;

            for ( i = 0 ; i < Args->Allocs ; i++ )
            {
                *Buffers++ = (PVOID) Args->Buffers[ i ];
            }
        }
        else
        {
            *Allocs = 0 ;
        }
    }

    FreeClient(pClient);

    return(scRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\ctxtapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        ctxtapi.cxx
//
// Contents:    Context API stubs for LPC
//
//
// History:     31 May 92   RichardW    Created
//
//------------------------------------------------------------------------

#include "secpch2.hxx"

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include <spmlpcp.h>
}

#if defined(ALLOC_PRAGMA) && defined(SECURITY_KERNEL)
#pragma alloc_text(PAGE, SecpInitializeSecurityContext)
#pragma alloc_text(PAGE, SecpAcceptSecurityContext)
#pragma alloc_text(PAGE, SecpDeleteSecurityContext)
#pragma alloc_text(PAGE, SecpApplyControlToken)
#pragma alloc_text(PAGE, SecpQueryContextAttributes)
#endif // ALLOC_PRAGMA


#if DBG
ULONG   cBigCalls = 0;  // Number of potential memory copy calls
ULONG   cPrePacks = 0;  // Number saved with PrePacks
#endif

static CONTEXT_HANDLE_LPC NullContext = {0,0};


//+---------------------------------------------------------------------------
//
//  Function:   SecpInitializeSecurityContext
//
//  Synopsis:   client LPC stub for init security context
//
//  Arguments:  [phCredentials]  -- Credential to use
//              [phContext]      -- Existing context (if any)
//              [pucsTarget]     --
//              [fContextReq]    --
//              [dwReserved1]    --
//              [cbInputToken]   --
//              [pbInputToken]   --
//              [dwReserved2]    --
//              [phNewContext]   --
//              [pcbOutputToken] --
//              [pbOutputToken]  --
//              [pfContextAttr]  --
//              [ptsExpiry]      --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-25-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
SecpInitializeSecurityContext(
    PVOID_LPC           ContextPointer,
    PCRED_HANDLE_LPC    phCredentials,
    PCONTEXT_HANDLE_LPC phContext,
    PSECURITY_STRING    pssTarget,
    ULONG               fContextReq,
    ULONG               dwReserved1,
    ULONG               TargetDataRep,
    PSecBufferDesc      pInput,
    ULONG               dwReserved2,
    PCONTEXT_HANDLE_LPC phNewContext,
    PSecBufferDesc      pOutput,
    ULONG *             pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBOOLEAN            MappedContext,
    PSecBuffer          ContextData,
    ULONG *             Flags )
{

    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE       ApiBuffer;
    PClient         pClient;
    PVOID           pBuffer = NULL;
    DECLARE_ARGS( Args, ApiBuffer, InitContext );
    PSEC_BUFFER_LPC pInputBuffers;
    PSEC_BUFFER_LPC pOutputBuffers = NULL;
    ULONG BuffersAvailable = NUM_SECBUFFERS ;
    ULONG BuffersConsumed = 0 ;

    SEC_PAGED_CODE();

    if (!phCredentials)
    {
        return(SEC_E_UNSUPPORTED_FUNCTION);
    }

    if (ARGUMENT_PRESENT(pInput) && (pInput->cBuffers > MAX_SECBUFFERS) ||
        ARGUMENT_PRESENT(pOutput) && (pOutput->cBuffers > MAX_SECBUFFERS))
    {
        DebugLog((DEB_ERROR, "Too many secbuffers passed in : %d or %d (max %d)\n",
                pInput->cBuffers,pOutput->cBuffers, MAX_SECBUFFERS ));

        return( SEC_E_INVALID_TOKEN );
    }


    //
    // pssTarget can not be NULL, since we dereference it
    //

    ASSERT(pssTarget);

    //
    //  Locate the client tracking record, or create one if it can't be found
    //


    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    //
    // Initialize the message
    //

    PREPARE_MESSAGE_EX(ApiBuffer, InitContext, *Flags, ContextPointer );

    DebugLog((DEB_TRACE, "InitializeContext\n"));

    // DebugLog((DEB_TRACE_CALL,"    Target = %wZ  \n", pssTarget));

    Args->hCredential   = *phCredentials;
    if (phContext)
    {
        Args->hContext  = *phContext;
    }
    else
    {
        Args->hContext = NullContext;
    }

    DebugLog((DEB_TRACE_CALL, "    Ctxt In = " POINTER_FORMAT " : " POINTER_FORMAT "\n",
                Args->hContext.dwUpper, Args->hContext.dwLower));

    SecpSecurityStringToLpc( &Args->ssTarget, pssTarget );

    Args->fContextReq   = fContextReq;
    Args->dwReserved1   = dwReserved1;
    Args->TargetDataRep = TargetDataRep;
    pInputBuffers = Args->sbData;

    if (ARGUMENT_PRESENT(pInput))
    {
        SecpSecBufferDescToLpc( &Args->sbdInput, pInput );

#ifndef BUILD_WOW64

        if ( pInput->cBuffers < BuffersAvailable )
        {

            Args->sbdInput.pBuffers = (PSecBuffer) ((LONG_PTR) pInputBuffers - (LONG_PTR) Args);


            RtlCopyMemory(  Args->sbData,
                            pInput->pBuffers,
                            sizeof(SecBuffer) * pInput->cBuffers);

            BuffersAvailable -= pInput->cBuffers ;
            BuffersConsumed += pInput->cBuffers ;

        }
#else
        if ( pInput->cBuffers < BuffersAvailable )
        {
            ULONG i ;
            PSEC_BUFFER_LPC Data ;
            PSecBuffer NarrowInput ;

            Data = (PSEC_BUFFER_LPC) ((LONG_PTR) pInputBuffers - (LONG_PTR) Args);

            Args->sbdInput.pBuffers = (PVOID_LPC) Data ;


            Data = (PSEC_BUFFER_LPC) pInputBuffers ;
            NarrowInput = pInput->pBuffers ;

            for ( i = 0 ; i < pInput->cBuffers ; i++ )
            {
                SecpSecBufferToLpc( Data, NarrowInput );
                Data++ ;
                NarrowInput++;
            }

            BuffersAvailable -= pInput->cBuffers ;
            BuffersConsumed += pInput->cBuffers ;

        }
#endif

    }
    else
    {
        RtlSecureZeroMemory(
            &Args->sbdInput,
            sizeof( SEC_BUFFER_DESC_LPC )
            );
    }


    Args->dwReserved2   = dwReserved2;

    if (ARGUMENT_PRESENT(pOutput))
    {
        SecpSecBufferDescToLpc( &Args->sbdOutput, pOutput );


#ifndef BUILD_WOW64
        if ( pOutput->cBuffers < BuffersAvailable )
        {
            pOutputBuffers = pInputBuffers + BuffersConsumed;

            Args->sbdOutput.pBuffers = (PSecBuffer) ((LONG_PTR) pOutputBuffers - (LONG_PTR) Args);
            RtlCopyMemory(  pOutputBuffers,
                            pOutput->pBuffers,
                            sizeof(SecBuffer) * pOutput->cBuffers);

            BuffersAvailable -= pOutput->cBuffers ;
            BuffersConsumed += pOutput->cBuffers ;
        }

        //
        // if the client asked the security layer to allocate
        // the memory, and we have a valid number of output
        // buffers available, reset them all to NULL so that
        // it's easier to keep track of them.
        //

        if ( ( fContextReq & ISC_REQ_ALLOCATE_MEMORY ) &&
             ( pOutputBuffers != NULL ) )
        {
            ULONG i;
            for (i = 0; i < pOutput->cBuffers ; i++ )
            {
                pOutputBuffers[i].pvBuffer = NULL;
            }
        }
#else
        if ( pOutput->cBuffers < BuffersAvailable )
        {
            PSEC_BUFFER_LPC Data ;
            ULONG i ;
            PSecBuffer NarrowOutput ;


            pOutputBuffers = pInputBuffers + BuffersConsumed;

            Data = (PSEC_BUFFER_LPC) ((LONG_PTR) pOutputBuffers - (LONG_PTR) Args );
            Args->sbdOutput.pBuffers = (PVOID_LPC) Data ;

            Data = (PSEC_BUFFER_LPC) (pOutputBuffers);
            NarrowOutput = pOutput->pBuffers ;


            for ( i = 0 ; i < pOutput->cBuffers ; i++ )
            {
                if ( (fContextReq & ISC_REQ_ALLOCATE_MEMORY ) != 0 )
                {
                    NarrowOutput->pvBuffer = NULL ;
                }

                SecpSecBufferToLpc( Data, NarrowOutput );

                Data++;
                NarrowOutput++;


            }

            BuffersAvailable -= pOutput->cBuffers ;
            BuffersConsumed += pOutput->cBuffers ;
        }
#endif

    }
    else
    {
        RtlSecureZeroMemory(
            &Args->sbdOutput,
            sizeof( SEC_BUFFER_DESC_LPC )
            );
    }


    Args->ContextData.pvBuffer = NULL;
    Args->ContextData.cbBuffer = 0;
    Args->ContextData.BufferType = 0;
    Args->MappedContext = FALSE;

    if ( BuffersConsumed > 0 )
    {
        //
        // We have consumed some of the bData space:  Adjust
        // our length accordingly
        //

        ApiBuffer.pmMessage.u1.s1.TotalLength =
            LPC_TOTAL_LENGTH( BuffersConsumed  * sizeof( SEC_BUFFER_LPC ) );

        ApiBuffer.pmMessage.u1.s1.DataLength =
            LPC_DATA_LENGTH( BuffersConsumed * sizeof( SEC_BUFFER_LPC ) );
    }

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    if (!NT_SUCCESS(scRet))
    {
        goto InitExitPoint;
    }

    DebugLog((DEB_TRACE, "    scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    //
    // If the API failed, then don't bother with the memory copies and that
    // that stuff.  In fact, if there was a memory problem, then we should
    // definitely get out now.
    //

    //
    // Either way we want to copy this - it will have updated size
    // information
    //

    if (ARGUMENT_PRESENT(pOutput))
    {
        if ( (ULONG_PTR) Args->sbdOutput.pBuffers < PORT_MAXIMUM_MESSAGE_LENGTH )
        {
#ifndef BUILD_WOW64
            RtlCopyMemory(  pOutput->pBuffers,
                            pOutputBuffers,
                            sizeof(SecBuffer) * Args->sbdOutput.cBuffers );
#else
            ULONG i ;
            PSEC_BUFFER_LPC Data ;
            PSecBuffer NarrowOutput ;

            Data = pOutputBuffers ;
            NarrowOutput = pOutput->pBuffers ;
            for (i = 0 ; i < Args->sbdOutput.cBuffers ; i++ )
            {
                SecpLpcBufferToSecBuffer( NarrowOutput, Data );
                NarrowOutput++ ;
                Data ++;
            }
#endif
        }

    }

    if (!NT_SUCCESS(ApiBuffer.ApiMessage.scRet))
    {
        if ( !( ( Args->hContext.dwUpper == 0 ) && ( Args->hContext.dwLower == 0 ) ) // not the first call
            && ( (ApiBuffer.ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_HANDLE_CHG) != 0 ) )
        {
            *phNewContext = Args->hNewContext;

            DebugLog((DEB_ERROR, "SecpInitializeSecurityContext replaced context handle %p:%p\n",
                phNewContext->dwUpper, phNewContext->dwLower));
        }

        DebugLog((DEB_ERROR, "SecpInitializeSecurityContext exiting %#x\n",
            ApiBuffer.ApiMessage.scRet));

        goto InitExitPoint;
    }

    //
    // If this was an Init call, handle the return values
    //

    *phNewContext   = Args->hNewContext;
    *pfContextAttr  = Args->fContextAttr;

    SecpLpcBufferToSecBuffer( ContextData, &Args->ContextData );

    *MappedContext  = Args->MappedContext;

    if (ARGUMENT_PRESENT(ptsExpiry))
    {
        *ptsExpiry = Args->tsExpiry;
    }

    DebugLog((DEB_TRACE_CALL,"    Ctxt Out = " POINTER_FORMAT ":" POINTER_FORMAT "\n",
              phNewContext->dwUpper, phNewContext->dwLower));

    //
    // Likewise, for the stream protocols, update the input
    // buffer types for EXTRA and MISSING:
    //

    if ( ARGUMENT_PRESENT( pInput ) )
    {
        if ( (ULONG_PTR) Args->sbdInput.pBuffers < PORT_MAXIMUM_MESSAGE_LENGTH )
        {
#ifndef BUILD_WOW64
            RtlCopyMemory( pInput->pBuffers,
                           pInputBuffers,
                           sizeof( SecBuffer ) * Args->sbdInput.cBuffers );
#else

            ULONG i ;
            PSEC_BUFFER_LPC Data ;
            PSecBuffer NarrowInput ;

            Data = pInputBuffers ;
            NarrowInput = pInput->pBuffers ;
            for (i = 0 ; i < Args->sbdInput.cBuffers ; i++ )
            {
                SecpLpcBufferToSecBuffer( NarrowInput, Data );
                NarrowInput++ ;
                Data ++;
            }
#endif
        }
    }


InitExitPoint:

    *Flags = ApiBuffer.ApiMessage.Args.SpmArguments.fAPI ;

    FreeClient(pClient);

    return( ApiBuffer.ApiMessage.scRet );
}

//+-------------------------------------------------------------------------
//
//  Function:   SecpAcceptSecurityContext()
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
SecpAcceptSecurityContext(
    PVOID_LPC           ContextPointer,
    PCRED_HANDLE_LPC    phCredentials,
    PCONTEXT_HANDLE_LPC phContext,
    PSecBufferDesc      pInput,
    ULONG               fContextReq,
    ULONG               TargetDataRep,
    PCONTEXT_HANDLE_LPC phNewContext,
    PSecBufferDesc      pOutput,
    ULONG *             pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBOOLEAN            MappedContext,
    PSecBuffer          ContextData,
    ULONG *             Flags,
    LPBYTE              lpIPAddress OPTIONAL
    )
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, AcceptContext );
    PSEC_BUFFER_LPC pInputBuffers;
    PSEC_BUFFER_LPC pOutputBuffers = NULL;
    ULONG   i;
    ULONG BuffersAvailable = NUM_SECBUFFERS ;
    ULONG BuffersConsumed = 0 ;

    SEC_PAGED_CODE();

    if (!phCredentials)
    {
        return(SEC_E_UNSUPPORTED_FUNCTION);
    }

    if (ARGUMENT_PRESENT(pInput) && (pInput->cBuffers > MAX_SECBUFFERS) ||
        ARGUMENT_PRESENT(pOutput) && (pOutput->cBuffers > MAX_SECBUFFERS))
    {
        DebugLog((DEB_ERROR,"Too many secbuffers passed in : %d or %d\n",
                pInput->cBuffers,pOutput->cBuffers));
        return(SEC_E_INVALID_TOKEN);
    }

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"AcceptSecurityContext\n"));

    PREPARE_MESSAGE_EX(ApiBuffer, AcceptContext, *Flags, ContextPointer );


    Args->hCredential   = *phCredentials;
    if (phContext)
    {
        Args->hContext  = *phContext;
    }
    else
    {
        Args->hContext = NullContext;
    }

    Args->fContextReq   = fContextReq;
    Args->TargetDataRep = TargetDataRep;

    DebugLog((DEB_TRACE_CALL,"    Ctxt In = " POINTER_FORMAT " : " POINTER_FORMAT "\n",
              Args->hContext.dwUpper, Args->hContext.dwLower));

    pInputBuffers = Args->sbData;

    if (ARGUMENT_PRESENT(pInput))
    {
        SecpSecBufferDescToLpc( &Args->sbdInput, pInput );

#ifndef BUILD_WOW64

        if ( pInput->cBuffers < BuffersAvailable )
        {

            Args->sbdInput.pBuffers = (PSecBuffer) ((LONG_PTR) pInputBuffers - (LONG_PTR) Args);

            RtlCopyMemory(  Args->sbData,
                            pInput->pBuffers,
                            sizeof(SecBuffer) * pInput->cBuffers);

            BuffersAvailable -= pInput->cBuffers ;
            BuffersConsumed += pInput->cBuffers ;

        }
#else
        if ( pInput->cBuffers < BuffersAvailable )
        {
            ULONG i ;
            PSEC_BUFFER_LPC Data ;
            PSecBuffer NarrowInput ;

            Data = (PSEC_BUFFER_LPC) ((LONG_PTR) pInputBuffers - (LONG_PTR) Args);

            Args->sbdInput.pBuffers = (PVOID_LPC) Data ;

            Data = (PSEC_BUFFER_LPC) pInputBuffers ;

            NarrowInput = pInput->pBuffers ;

            for ( i = 0 ; i < pInput->cBuffers ; i++ )
            {
                SecpSecBufferToLpc( Data, NarrowInput );
                Data++ ;
                NarrowInput++;
            }

            BuffersAvailable -= pInput->cBuffers ;
            BuffersConsumed += pInput->cBuffers ;
        }
#endif

    }
    else
    {
        RtlSecureZeroMemory(
            &Args->sbdInput,
            sizeof( SEC_BUFFER_DESC_LPC )
            );
    }

    if (ARGUMENT_PRESENT(pOutput))
    {
        SecpSecBufferDescToLpc( &Args->sbdOutput, pOutput );


#ifndef BUILD_WOW64
        if ( pOutput->cBuffers < BuffersAvailable )
        {
            pOutputBuffers = pInputBuffers + BuffersConsumed;

            Args->sbdOutput.pBuffers = (PSecBuffer) ((LONG_PTR) pOutputBuffers - (LONG_PTR) Args);
            RtlCopyMemory(  pOutputBuffers,
                            pOutput->pBuffers,
                            sizeof(SecBuffer) * pOutput->cBuffers);

            BuffersAvailable -= pOutput->cBuffers ;
            BuffersConsumed += pOutput->cBuffers ;
        }

        //
        // if the client asked the security layer to allocate
        // the memory, and we have a valid number of output
        // buffers available, reset them all to NULL so that
        // it's easier to keep track of them.
        //

        if ( ( fContextReq & ISC_REQ_ALLOCATE_MEMORY ) &&
             ( pOutputBuffers != NULL ) )
        {
            ULONG i;
            for (i = 0; i < pOutput->cBuffers ; i++ )
            {
                pOutputBuffers[i].pvBuffer = NULL;
            }
        }
#else
        if ( pOutput->cBuffers < BuffersAvailable )
        {
            PSEC_BUFFER_LPC Data ;
            ULONG i ;
            PSecBuffer NarrowOutput ;


            pOutputBuffers = pInputBuffers + BuffersConsumed ;

            Data = (PSEC_BUFFER_LPC) ((LONG_PTR) pOutputBuffers - (LONG_PTR) Args );
            Args->sbdOutput.pBuffers = (PVOID_LPC) Data ;

            Data = (PSEC_BUFFER_LPC) pOutputBuffers ;

            NarrowOutput = pOutput->pBuffers ;

            for ( i = 0 ; i < pOutput->cBuffers ; i++ )
            {
                if ( (fContextReq & ISC_REQ_ALLOCATE_MEMORY ) != 0 )
                {
                    NarrowOutput->pvBuffer = NULL ;
                }

                SecpSecBufferToLpc( Data, NarrowOutput );
                Data++;
                NarrowOutput++;
            }

            BuffersAvailable -= pOutput->cBuffers ;
            BuffersConsumed += pOutput->cBuffers ;
        }
#endif

    }
    else
    {
        RtlSecureZeroMemory(
            &Args->sbdOutput,
            sizeof( SEC_BUFFER_DESC_LPC )
            );
    }

    if ( BuffersConsumed > 0 )
    {
        //
        // We have consumed some of the bData space:  Adjust
        // our length accordingly
        //
        ApiBuffer.pmMessage.u1.s1.TotalLength =
            LPC_TOTAL_LENGTH( BuffersConsumed  * sizeof( SEC_BUFFER_LPC ) );

        ApiBuffer.pmMessage.u1.s1.DataLength =
            LPC_DATA_LENGTH( BuffersConsumed * sizeof( SEC_BUFFER_LPC ) );

    }

    Args->ContextData.pvBuffer = NULL;
    Args->ContextData.cbBuffer = 0;
    Args->ContextData.BufferType = 0;
    Args->MappedContext = FALSE;

    //
    // No need to zero out the buffer if lpIPAddress is NULL
    // as PREPARE_MESSAGE_EX already does this for us.
    //

    if (lpIPAddress != NULL)
    {
        RtlCopyMemory(Args->IpAddress, lpIPAddress, LSAP_ADDRESS_LENGTH);
    }

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE, "    scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (!NT_SUCCESS(scRet))
    {
        goto AcceptExitPoint;
    }

    //
    // Either way we want to copy this - it will have updated size
    // information
    //

    if (ARGUMENT_PRESENT(pOutput))
    {
        if ( (ULONG_PTR) Args->sbdOutput.pBuffers < PORT_MAXIMUM_MESSAGE_LENGTH )
        {
#ifndef BUILD_WOW64
            RtlCopyMemory(  pOutput->pBuffers,
                            pOutputBuffers,
                            sizeof(SecBuffer) * Args->sbdOutput.cBuffers );
#else
            ULONG i ;
            PSEC_BUFFER_LPC Data ;
            PSecBuffer NarrowOutput ;

            Data = pOutputBuffers ;
            NarrowOutput = pOutput->pBuffers ;
            for (i = 0 ; i < Args->sbdOutput.cBuffers ; i++ )
            {
                SecpLpcBufferToSecBuffer( NarrowOutput, Data );
                NarrowOutput++ ;
                Data ++;
            }
#endif
        }
    }

    *pfContextAttr = Args->fContextAttr;

    if (!NT_SUCCESS(ApiBuffer.ApiMessage.scRet))
    {
        if ( !( ( Args->hContext.dwUpper == 0 ) && ( Args->hContext.dwLower == 0 ) ) // not the first call
            && ( (ApiBuffer.ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_HANDLE_CHG) != 0 ) )
        {
            *phNewContext = Args->hNewContext;

            DebugLog((DEB_ERROR, "SecpAcceptSecurityContext replaced context handle %p:%p\n",
                phNewContext->dwUpper, phNewContext->dwLower));
        }
        DebugLog((DEB_ERROR, "SecpAcceptSecurityContext returning %#x\n",
           ApiBuffer.ApiMessage.scRet));
    }
    else
    {
        *phNewContext = Args->hNewContext;
    }

    if ((!NT_SUCCESS(ApiBuffer.ApiMessage.scRet)) &&
        ((Args->fContextAttr & ASC_RET_EXTENDED_ERROR) == 0 ) )
    {

        DebugLog((DEB_TRACE, "Accept FAILED, exiting now\n"));
        goto AcceptExitPoint;
    }

    SecpLpcBufferToSecBuffer( ContextData, &Args->ContextData );
    *MappedContext  = Args->MappedContext;
    if (ARGUMENT_PRESENT(ptsExpiry))
    {
        *ptsExpiry = Args->tsExpiry;
    }

    DebugLog((DEB_TRACE_CALL,"    Ctxt Out = " POINTER_FORMAT " : " POINTER_FORMAT "\n",
              phNewContext->dwUpper, phNewContext->dwLower));

    if ( (ULONG_PTR) Args->sbdInput.pBuffers < PORT_MAXIMUM_MESSAGE_LENGTH )
    {
        for ( i = 0 ; i < Args->sbdInput.cBuffers ; i++ )
        {
            if ( ((Args->sbData[i].BufferType == SECBUFFER_EXTRA ) ||
                 (Args->sbData[i].BufferType == SECBUFFER_MISSING ) )
#if DBG
                 && (pInput->pBuffers[i].BufferType == SECBUFFER_EMPTY )
#endif
                 )
            {
                SecpLpcBufferToSecBuffer( &pInput->pBuffers[i], &Args->sbData[i] );

                DebugLog(( DEB_TRACE_CALL, "    InputBuffer %d Changed from Empty to %d, @" POINTER_FORMAT " %d bytes\n",
                                i, pInput->pBuffers[i].BufferType,
                                pInput->pBuffers[i].pvBuffer,
                                pInput->pBuffers[i].cbBuffer ));
            }
        }
    }


AcceptExitPoint:

    FreeClient(pClient);

    *Flags = ApiBuffer.ApiMessage.Args.SpmArguments.fAPI ;

    return(ApiBuffer.ApiMessage.scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   SecpDeleteSecurityContext
//
//  Synopsis:   LPC client stub for DeleteSecurityContext
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
SecpDeleteSecurityContext(
    ULONG fDelete,
    PCONTEXT_HANDLE_LPC phContext)
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, DeleteContext );

    SEC_PAGED_CODE();



    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"DeleteSecurityContext\n"));

    PREPARE_MESSAGE(ApiBuffer, DeleteContext);


    Args->hContext    = *phContext;

    if (fDelete & SECP_DELETE_NO_BLOCK)
    {
        ApiBuffer.ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_EXEC_NOW;
    }

    DebugLog((DEB_TRACE_CALL,"    Context = " POINTER_FORMAT " : " POINTER_FORMAT "\n",
                    phContext->dwUpper, phContext->dwLower));

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"Delete.ApiMessage.scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (scRet == STATUS_SUCCESS)
    {
        scRet = ApiBuffer.ApiMessage.scRet;

    }

    FreeClient(pClient);
    return(scRet);

}


//+-------------------------------------------------------------------------
//
//  Function:   ApplyControlToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
SecpApplyControlToken(
    PCONTEXT_HANDLE_LPC phContext,
    PSecBufferDesc      pInput)
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, ApplyToken );
    ULONG i;

    SEC_PAGED_CODE();


    if (pInput->cBuffers > MAX_SECBUFFERS)
    {
        DebugLog((DEB_ERROR,"Too many secbuffers passed in : %d\n",
                pInput->cBuffers));
        return(SEC_E_INVALID_TOKEN);
    }

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"ApplyControlToken\n"));

    PREPARE_MESSAGE(ApiBuffer, ApplyToken);

    Args->hContext    = *phContext;

    if (ARGUMENT_PRESENT(pInput))
    {
        SecpSecBufferDescToLpc( &Args->sbdInput, pInput );

        for ( i = 0 ; i < pInput->cBuffers ; i++ )
        {
            SecpSecBufferToLpc( &Args->sbInputBuffer[ i ],
                                &pInput->pBuffers[ i ] );
        }

    }
    else
    {
        RtlSecureZeroMemory(
            &Args->sbdInput,
            sizeof( SEC_BUFFER_DESC_LPC )
            );
    }


    DebugLog((DEB_TRACE_CALL,"    Context = " POINTER_FORMAT " : " POINTER_FORMAT "\n",
              phContext->dwUpper, phContext->dwLower));

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"ApplyToken scRet = %x\n", ApiBuffer.ApiMessage.scRet));


    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
    }

    FreeClient(pClient);
    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpQueryContextAttributes
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [pBuffer]     --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    3-05-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SecpQueryContextAttributes(
    PVOID_LPC   ContextPointer,
    PCONTEXT_HANDLE_LPC phContext,
    ULONG       ulAttribute,
    PVOID       pBuffer,
    PULONG      Allocs,
    PVOID *     Buffers,
    PULONG      Flags
    )
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, QueryContextAttr );
    ULONG i;

    SEC_PAGED_CODE();

    *Allocs = 0;

    scRet = IsOkayToExec(&pClient);

    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"QueryContextAttributes\n"));

    PREPARE_MESSAGE_EX(ApiBuffer, QueryContextAttr, *Flags, ContextPointer);

    Args->hContext    = *phContext;
    Args->ulAttribute = ulAttribute ;
    Args->pBuffer     = (PVOID_LPC) pBuffer ;


    DebugLog((DEB_TRACE_CALL,"    Context = " POINTER_FORMAT ":" POINTER_FORMAT "\n",
              phContext->dwUpper, phContext->dwLower));

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"QueryContextAttributes scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if ( NT_SUCCESS( scRet ) )
    {
        scRet = ApiBuffer.ApiMessage.scRet ;
    }

    if ( NT_SUCCESS( scRet ) )
    {
        if ( ApiBuffer.ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_ALLOCS )
        {
            *Allocs = Args->Allocs ;

            for ( i = 0 ; i < Args->Allocs ; i++ )
            {
                *Buffers++ = (PVOID) Args->Buffers[ i ];
            }

        }
        else
        {
            *Allocs = 0 ;
        }
    }

    FreeClient(pClient);
    return(scRet);

}



//+---------------------------------------------------------------------------
//
//  Function:   SecpSetContextAttributes
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [pBuffer]     --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-20-00   CliffV   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SecpSetContextAttributes(
    PCONTEXT_HANDLE_LPC phContext,
    ULONG       ulAttribute,
    PVOID       pBuffer,
    ULONG cbBuffer
    )
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, SetContextAttr );
    ULONG i;

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);

    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"SetContextAttributes\n"));

    PREPARE_MESSAGE(ApiBuffer, SetContextAttr);

    Args->hContext    = *phContext;
    Args->ulAttribute = ulAttribute ;
    Args->pBuffer     = (PVOID_LPC) pBuffer ;
    Args->cbBuffer    = cbBuffer ;


    DebugLog((DEB_TRACE_CALL,"    Context = " POINTER_FORMAT ":" POINTER_FORMAT "\n",
              phContext->dwUpper, phContext->dwLower));

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"SetContextAttributes scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if ( NT_SUCCESS( scRet ) )
    {
        scRet = ApiBuffer.ApiMessage.scRet ;
    }

    FreeClient(pClient);
    return(scRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\austub.cxx ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    austub.c

Abstract:

    Local Security Authority AUTHENTICATION service client stubs.

Author:

    Jim Kelly (JimK) 20-Feb-1991

Environment:   Kernel or User Modes

Revision History:

--*/

#include "secpch2.hxx"

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include <spmlpcp.h>
#include <zwapi.h>
}

#ifdef KERNEL_MODE
//
// Unfortunately the security header files are just not at all constructed
// in a manner compatible with kernelmode. For some reason they are totally
// reliant on usermode header definitions. Just assume the text and const
// pragma's will work. If they don't work on an architecture, they can be
// fixed.
//
#pragma alloc_text(PAGE,LsaFreeReturnBuffer)
#pragma alloc_text(PAGE,LsaRegisterLogonProcess)
#pragma alloc_text(PAGE,LsaConnectUntrusted)
#pragma alloc_text(PAGE,LsaLookupAuthenticationPackage)
#pragma alloc_text(PAGE,LsaLogonUser)
#pragma alloc_text(PAGE,LsaCallAuthenticationPackage)
#pragma alloc_text(PAGE,LsaDeregisterLogonProcess)
#pragma const_seg("PAGECONST")

#define SecpLsaDispatchFn  NULL

#else

extern PLSA_DISPATCH_FN    SecpLsaDispatchFn ;

extern "C"
{
#include "secdll.h"
}

#endif


const WCHAR LsapEvent[] = L"\\SECURITY\\LSA_AUTHENTICATION_INITIALIZED";
const WCHAR LsapPort[] = L"\\LsaAuthenticationPort";


NTSTATUS
LsaFreeReturnBuffer (
    IN PVOID Buffer
    )


/*++

Routine Description:

    Some of the LSA authentication services allocate memory buffers to
    hold returned information.  This service is used to free those buffers
    when no longer needed.

Arguments:

    Buffer - Supplies a pointer to the return buffer to be freed.

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

    Others - returned by NtFreeVirtualMemory().

--*/

{

    NTSTATUS Status;
    ULONG_PTR Length;

    SEC_PAGED_CODE();

    Length = 0;
    Status = ZwFreeVirtualMemory(
                 NtCurrentProcess(),
                 &Buffer,
                 &Length,
                 MEM_RELEASE
                 );

    return Status;
}


NTSTATUS
LsaRegisterLogonProcess(
    IN PSTRING LogonProcessName,
    OUT PHANDLE LsaHandle,
    OUT PLSA_OPERATIONAL_MODE SecurityMode
    )

/*++

Routine Description:

    This service connects to the LSA server and verifies that the caller
    is a legitimate logon process. this is done by ensuring the caller has
    the SeTcbPrivilege privilege. It also opens the caller's process for
    PROCESS_DUP_HANDLE access in anticipation of future LSA authentication
    calls.

Arguments:

    LogonProcessName  - Provides a name string that identifies the logon
        process.  This should be a printable name suitable for display to
        administrators.  For example, "User32LogonProces" might be used
        for the windows logon process name.  No check is made to determine
        whether the name is already in use.  This name must NOT be longer
        than 127 bytes long.

    LsaHandle - Receives a handle which must be provided in future
        authenticaiton services.

    SecurityMode - The security mode the system is running under.  This
        value typically influences the logon user interface.  For example,
        a system running with password control will prompt for username
        and passwords before bringing up the UI shell.  One running without
        password control would typically automatically bring up the UI shell
        at system initialization.

Return Value:

    STATUS_SUCCESS - The call completed successfully.

    STATUS_PRIVILEGE_NOT_HELD  - Indicates the caller does not have the
        privilege necessary to act as a logon process.  The SeTcbPrivilege
        privilege is needed.


    STATUS_NAME_TOO_LONG - The logon process name provided is too long.

--*/

{
    NTSTATUS Status, IgnoreStatus;
    UNICODE_STRING PortName, EventName;
    LSAP_AU_REGISTER_CONNECT_INFO ConnectInfo;
    ULONG ConnectInfoLength;
    ALIGN_WOW64 SECURITY_QUALITY_OF_SERVICE DynamicQos;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE EventHandle;

    SEC_PAGED_CODE();

    //
    // Validate input parameters
    //

    if (LogonProcessName->Length > LSAP_MAX_LOGON_PROC_NAME_LENGTH) {
        return STATUS_NAME_TOO_LONG;
    }


    //
    // Wait for LSA to initialize...
    //


    RtlInitUnicodeString( &EventName, LsapEvent );
    InitializeObjectAttributes(
        &ObjectAttributes,
        &EventName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    Status = NtOpenEvent( &EventHandle, SYNCHRONIZE, &ObjectAttributes );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = NtWaitForSingleObject( EventHandle, TRUE, NULL);
    IgnoreStatus = NtClose( EventHandle );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }



    //
    // Set up the security quality of service parameters to use over the
    // port.  Use the most efficient (least overhead) - which is dynamic
    // rather than static tracking.
    //

    DynamicQos.Length = sizeof( DynamicQos );
    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = FALSE;




    //
    // Set up the connection information to contain the logon process
    // name.
    //

    ConnectInfoLength = sizeof(LSAP_AU_REGISTER_CONNECT_INFO);
    strncpy(
        ConnectInfo.LogonProcessName,
        LogonProcessName->Buffer,
        LogonProcessName->Length
        );
    ConnectInfo.LogonProcessNameLength = LogonProcessName->Length;
    ConnectInfo.LogonProcessName[ConnectInfo.LogonProcessNameLength] = '\0';


    //
    // Connect to the LSA server
    //

    RtlInitUnicodeString(&PortName,LsapPort);
    Status = ZwConnectPort(
                 LsaHandle,
                 &PortName,
                 &DynamicQos,
                 NULL,
                 NULL,
                 NULL,
                 &ConnectInfo,
                 &ConnectInfoLength
                 );
    if ( !NT_SUCCESS(Status) ) {
        //DbgPrint("LSA AU: Logon Process Register failed %lx\n",Status);
        return Status;
    }

    if ( !NT_SUCCESS(ConnectInfo.CompletionStatus) ) {
        //DbgPrint("LSA AU: Logon Process Register rejected %lx\n",ConnectInfo.CompletionStatus);
        ;
    }

    (*SecurityMode) = ConnectInfo.SecurityMode;

    return ConnectInfo.CompletionStatus;

}


NTSTATUS
LsaConnectUntrusted(
    OUT PHANDLE LsaHandle
    )

/*++

Routine Description:

    This service connects to the LSA server and sets up an untrusted
    connection.  It does not check anything about the caller.

Arguments:


    LsaHandle - Receives a handle which must be provided in future
        authenticaiton services.


Return Value:

    STATUS_SUCCESS - The call completed successfully.

--*/

{
    NTSTATUS Status, IgnoreStatus;
    UNICODE_STRING PortName, EventName;
    LSAP_AU_REGISTER_CONNECT_INFO ConnectInfo;
    ULONG ConnectInfoLength;
    ALIGN_WOW64 SECURITY_QUALITY_OF_SERVICE DynamicQos;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE EventHandle;
    HANDLE RealToken = NULL ;

    SEC_PAGED_CODE();


    //
    // Wait for LSA to initialize...
    //


    RtlInitUnicodeString( &EventName, LsapEvent );
    InitializeObjectAttributes(
        &ObjectAttributes,
        &EventName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    Status = NtOpenEvent( &EventHandle, SYNCHRONIZE, &ObjectAttributes );

    if (!NT_SUCCESS(Status))
    {
        HANDLE Null = NULL ;

        if ( Status != STATUS_BAD_IMPERSONATION_LEVEL &&
             Status != STATUS_ACCESS_DENIED )
        {
            goto Cleanup;
        }


        //
        // We appear to be running with an identify or anonymous level
        // token while trying to make this initial connection.  Try to
        // suspend the impersonation for the duration.
        //

        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_READ,
                    TRUE,
                    &RealToken );
        if ( !NT_SUCCESS( Status ) )
        {
            goto Cleanup;
        }

        //
        // We've got it, stop impersonating now, and try the connection.
        //

        Status = NtSetInformationThread(
                    NtCurrentThread(),
                    ThreadImpersonationToken,
                    &Null,
                    sizeof( HANDLE ) );

        if ( !NT_SUCCESS( Status ) )
        {
            NtClose( RealToken );
            RealToken = NULL;
            goto Cleanup;
        }

        Status = NtOpenEvent( &EventHandle, SYNCHRONIZE, &ObjectAttributes );

        if( !NT_SUCCESS( Status ) )
        {
            goto Cleanup;
        }
    }

    Status = NtWaitForSingleObject( EventHandle, TRUE, NULL);
    IgnoreStatus = NtClose( EventHandle );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }



    //
    // Set up the security quality of service parameters to use over the
    // port.  Use the most efficient (least overhead) - which is dynamic
    // rather than static tracking.
    //

    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = FALSE;




    //
    // Set up the connection information to contain the logon process
    // name.
    //

    ConnectInfoLength = sizeof(LSAP_AU_REGISTER_CONNECT_INFO);
    RtlZeroMemory(
        &ConnectInfo,
        ConnectInfoLength
        );


    //
    // Connect to the LSA server
    //

    RtlInitUnicodeString(&PortName,LsapPort);
    Status = ZwConnectPort(
                 LsaHandle,
                 &PortName,
                 &DynamicQos,
                 NULL,
                 NULL,
                 NULL,
                 &ConnectInfo,
                 &ConnectInfoLength
                 );
    if ( !NT_SUCCESS(Status) ) {
        //DbgPrint("LSA AU: Logon Process Register failed %lx\n",Status);
        goto Cleanup;
    }

    if ( !NT_SUCCESS(ConnectInfo.CompletionStatus) ) {
        //DbgPrint("LSA AU: Logon Process Register rejected %lx\n",ConnectInfo.CompletionStatus);
        ;
    }

    Status = ConnectInfo.CompletionStatus;

Cleanup:

    if ( RealToken )
    {
        NtSetInformationThread(
            NtCurrentThread(),
            ThreadImpersonationToken,
            &RealToken,
            sizeof( HANDLE ) );

        NtClose( RealToken );
    }

    return Status;

}


NTSTATUS
LsaLookupAuthenticationPackage (
    IN HANDLE LsaHandle,
    IN PSTRING PackageName,
    OUT PULONG AuthenticationPackage
    )

/*++

Arguments:

    LsaHandle - Supplies a handle obtained in a previous call to
        LsaRegisterLogonProcess.

    PackageName - Supplies a string which identifies the
        Authentication Package.  "MSV1.0" is the standard NT
        authentication package name.  The package name must not
        exceed 127 bytes in length.

    AuthenticationPackage - Receives an ID used to reference the
        authentication package in subsequent authentication services.

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_NO_SUCH_PACKAGE - The specified authentication package is
        unknown to the LSA.

    STATUS_NAME_TOO_LONG - The authentication package name provided is too
        long.



Routine Description:

    This service is used to obtain the ID of an authentication package.
    This ID may then be used in subsequent authentication services.


--*/

{

    NTSTATUS Status;
    ALIGN_WOW64 LSAP_AU_API_MESSAGE Message;
    PLSAP_LOOKUP_PACKAGE_ARGS Arguments;

    SEC_PAGED_CODE();

    //
    // Validate input parameters
    //

    if (PackageName->Length > LSAP_MAX_PACKAGE_NAME_LENGTH) {
        return STATUS_NAME_TOO_LONG;
    }



    Arguments = &Message.Arguments.LookupPackage;

    //
    // Set arguments
    //

    strncpy(Arguments->PackageName, PackageName->Buffer, PackageName->Length);
    Arguments->PackageNameLength = PackageName->Length;
    Arguments->PackageName[Arguments->PackageNameLength] = '\0';



    //
    // Call the Local Security Authority Server.
    //

    Message.ApiNumber = LsapAuLookupPackageApi;
    Message.PortMessage.u1.s1.DataLength = sizeof(*Arguments) + 8;
    Message.PortMessage.u1.s1.TotalLength = sizeof(Message);
    Message.PortMessage.u2.ZeroInit = 0L;

    if( SecpLsaDispatchFn == NULL )
    {
        Status = ZwRequestWaitReplyPort(
                LsaHandle,
                (PPORT_MESSAGE) &Message,
                (PPORT_MESSAGE) &Message
                );
    } else {
        Status = SecpLsaDispatchFn( (PSPM_LPC_MESSAGE)&Message );
    }

    //
    // Return the authentication package ID.
    // If the call failed for any reason, this will be garbage,
    // but who cares.
    //

    (*AuthenticationPackage) = Arguments->AuthenticationPackage;


    if ( NT_SUCCESS(Status) ) {
        Status = Message.ReturnedStatus;
        if ( !NT_SUCCESS(Status) ) {
            //DbgPrint("LSA AU: Package Lookup Failed %lx\n",Status);
            ;
        }
    } else {
#if DBG
        DbgPrint("LSA AU: Package Lookup NtRequestWaitReply Failed %lx\n",Status);
#else
        ;
#endif
    }

    return Status;
}


NTSTATUS
LsaLogonUser (
    IN HANDLE LsaHandle,
    IN PSTRING OriginName,
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG AuthenticationPackage,
    IN PVOID AuthenticationInformation,
    IN ULONG AuthenticationInformationLength,
    IN PTOKEN_GROUPS LocalGroups OPTIONAL,
    IN PTOKEN_SOURCE SourceContext,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID LogonId,
    OUT PHANDLE Token,
    OUT PQUOTA_LIMITS Quotas,
    OUT PNTSTATUS SubStatus
    )

/*++

Arguments:

    LsaHandle - Supplies a handle obtained in a previous call to
        LsaRegisterLogonProcess.

    OriginName - Supplies a string which identifies the origin of the
        logon attempt.  For example, "TTY1" specify terminal 1, or
        "LAN Manager - remote node JAZZ" might indicate a network
        logon attempt via LAN Manager from a remote node called
        "JAZZ".

    LogonType - Identifies the type of logon being attempted.  If the
        type is Interactive or Batch then a PrimaryToken will be
        generated to represent this new user.  If the type is Network
        then an impersonation token will be generated.

    AuthenticationPackage - Supplies the ID of the authentication
        package to use for the logon attempt.  The standard
        authentication package name for NT is called "MSV1.0".

    AuthenticationInformation - Supplies the authentication
        information specific to the authentication package.  It is
        expected to include identification and authentication
        information such as user name and password.

    AuthenticationInformationLength - Indicates the length of the
        authentication information buffer.

    LocalGroups - Optionally supplies a list of additional group
        identifiers to add to the authenticated user's token.  The
        WORLD group will always be included in the token.  A group
        identifying the logon type (INTERACTIVE, NETWORK, BATCH) will
        also automatically be included in the token.

    SourceContext - Supplies information identifying the source
        component (e.g., session manager) and context that may be
        useful to that component.  This information will be included
        in the token and may later be retrieved.

    ProfileBuffer - Receives a pointer to any returned profile and
        accounting information about the logged on user's account.
        This information is authentication package specific and
        provides such information as the logon shell, home directory
        and so forth.  For an authentication package value of
        "MSV1.0", a MSV1_0_PROFILE_DATA data structure is returned.

        This buffer is allocated by this service and must be freed
        using LsaFreeReturnBuffer() when no longer needed.

    ProfileBufferLength - Receives the length (in bytes) of the
        returned profile buffer.

    LogonId - Points to a buffer which receives a LUID that uniquely
        identifies this logon session.  This LUID was assigned by the
        domain controller which authenticated the logon information.

    Token - Receives a handle to the new token created for this
        authentication.

    Quotas - When a primary token is returned, this parameter will be
        filled in with process quota limits that are to be assigned
        to the newly logged on user's initial process.

    SubStatus - If the logon failed due to account restrictions, this
        out parameter will receive an indication as to why the logon
        failed.  This value will only be set to a meaningful value if
        the user has a legitimate account, but may not currently
        logon for some reason.  The substatus values for
        authentication package "MSV1.0" are:

            STATUS_INVALID_LOGON_HOURS

            STATUS_INVALID_WORKSTATION

            STATUS_PASSWORD_EXPIRED

            STATUS_ACCOUNT_DISABLED

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  Indicates the caller does not have
        enough quota to allocate the profile data being returned by
        the authentication package.

    STATUS_NO_LOGON_SERVERS - Indicates that no domain controllers
        are currently able to service the authentication request.

    STATUS_LOGON_FAILURE - Indicates the logon attempt failed.  No
        indication as to the reason for failure is given, but typical
        reasons include mispelled usernames, mispelled passwords.

    STATUS_ACCOUNT_RESTRICTION - Indicates the user account and
        password were legitimate, but that the user account has some
        restriction preventing successful logon at this time.

    STATUS_NO_SUCH_PACKAGE - The specified authentication package is
        unknown to the LSA.

    STATUS_BAD_VALIDATION_CLASS - The authentication information
        provided is not a validation class known to the specified
        authentication package.

Routine Description:

    This routine is used to authenticate a user logon attempt.  This is
    used only for user's initial logon, necessary to gain access to NT
    OS/2.  Subsequent (supplementary) authentication requests must be done
    using LsaCallAuthenticationPackage().  This service will cause a logon
    session to be created to represent the new logon.  It will also return
    a token representing the newly logged on user.

--*/

{
    NTSTATUS Status;
    ALIGN_WOW64 LSAP_AU_API_MESSAGE Message;
    PLSAP_LOGON_USER_ARGS Arguments;
    LPBYTE lpIPAddress = NULL;

    SEC_PAGED_CODE();


    Arguments = &Message.Arguments.LogonUser;

    //
    // Set arguments
    //

    Arguments->AuthenticationPackage      = AuthenticationPackage;
    Arguments->AuthenticationInformation  = (PVOID_AU) AuthenticationInformation;
    Arguments->AuthenticationInformationLength = AuthenticationInformationLength;

    SecpStringToLpc( &Arguments->OriginName, OriginName );

    Arguments->LogonType                  = LogonType;
    Arguments->SourceContext              = (*SourceContext);

    Arguments->LocalGroups                = (PVOID_AU) LocalGroups;
    if ( ARGUMENT_PRESENT(LocalGroups) ) {
        Arguments->LocalGroupsCount       = LocalGroups->GroupCount;
    } else {
        Arguments->LocalGroupsCount       = 0;
    }

#ifndef KERNEL_MODE

    lpIPAddress = (LPBYTE) SecGetIPAddress();

#endif

    if (lpIPAddress == NULL)
    {
        RtlZeroMemory(Arguments->IpAddress, LSAP_ADDRESS_LENGTH);
    }
    else
    {
        RtlCopyMemory(Arguments->IpAddress, lpIPAddress, LSAP_ADDRESS_LENGTH);
    }

    //
    // Call the Local Security Authority Server.
    //

    Message.ApiNumber = LsapAuLogonUserApi;
    Message.PortMessage.u1.s1.DataLength = sizeof(*Arguments) + 8;
    Message.PortMessage.u1.s1.TotalLength = sizeof(Message);
    Message.PortMessage.u2.ZeroInit = 0L;

    if( SecpLsaDispatchFn == NULL )
    {
        Status = ZwRequestWaitReplyPort(
                LsaHandle,
                (PPORT_MESSAGE) &Message,
                (PPORT_MESSAGE) &Message
                );
    } else {
        Status = SecpLsaDispatchFn( (PSPM_LPC_MESSAGE)&Message );
    }

    if (lpIPAddress != NULL)
    {
        RtlZeroMemory(lpIPAddress, LSAP_ADDRESS_LENGTH);
    }

    //
    // We may be returning bogus return values here, but it doesn't
    // matter.  They will just be ignored if an error occured.
    //

    (*SubStatus)           = Arguments->SubStatus;

    if ( NT_SUCCESS( Status ) )
    {
        Status = Message.ReturnedStatus ;

        // Don't not clear the ProfileBuffer even in case of error, cause
        // subauth packages need the ProfileBuffer.
        *ProfileBuffer = (PVOID) Arguments->ProfileBuffer ;
        *ProfileBufferLength = Arguments->ProfileBufferLength ;

        if ( NT_SUCCESS( Status ) )
        {
            *LogonId = Arguments->LogonId ;
            *Token = (HANDLE) Arguments->Token ;
            *Quotas = Arguments->Quotas ;
        } else {
            *Token = NULL;
        }

    } else {

        *ProfileBuffer = NULL ;
        *Token = NULL ;
    }

    return Status;


}


NTSTATUS
LsaCallAuthenticationPackage (
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer OPTIONAL,
    OUT PULONG ReturnBufferLength OPTIONAL,
    OUT PNTSTATUS ProtocolStatus OPTIONAL
    )

/*++

Arguments:

    LsaHandle - Supplies a handle obtained in a previous call to
        LsaRegisterLogonProcess.

    AuthenticationPackage - Supplies the ID of the authentication
        package to use for the logon attempt.  The standard
        authentication package name for NT is called "MSV1.0".

    ProtocolSubmitBuffer - Supplies a protocol message specific to
        the authentication package.

    SubmitBufferLength - Indicates the length of the submitted
        protocol message buffer.

    ProtocolReturnBuffer - Receives a pointer to a returned protocol
        message whose format and semantics are specific to the
        authentication package.

        This buffer is allocated by this service and must be freed
        using LsaFreeReturnBuffer() when no longer needed.

    ReturnBufferLength - Receives the length (in bytes) of the
        returned profile buffer.

    ProtocolStatus - Assuming the services completion is
        STATUS_SUCCESS, this parameter will receive completion status
        returned by the specified authentication package.  The list
        of status values that may be returned are authentication
        package specific.

Return Status:

    STATUS_SUCCESS - The call was made to the authentication package.
        The ProtocolStatus parameter must be checked to see what the
        completion status from the authentication package is.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the call could
        not be completed because the client does not have sufficient
        quota to allocate the return buffer.

    STATUS_NO_SUCH_PACKAGE - The specified authentication package is
        unknown to the LSA.

Routine Description:

    This routine is used when a logon process needs to communicate with an
    authentication package.  There are several reasons why a logon process
    may want to do this.  Some examples are:

     o  To implement multi-message authentication protocols (such as
        the LAN Manager Challenge-response protocol.

     o  To notify the authentication package of interesting state
        change information, such as LAN Manager notifying the MSV1.0
        package that a previously unreachable domain controller is
        now reachable.  In this example, the authentication package
        would re-logon any users logged on to that domain controller.


--*/

{

    NTSTATUS Status;
    ALIGN_WOW64 LSAP_AU_API_MESSAGE Message;
    PLSAP_CALL_PACKAGE_ARGS Arguments;


    SEC_PAGED_CODE();

    Arguments = &Message.Arguments.CallPackage;

    //
    // Set arguments
    //

    Arguments->AuthenticationPackage = AuthenticationPackage;
    Arguments->ProtocolSubmitBuffer  = (PVOID_AU) ProtocolSubmitBuffer;
    Arguments->SubmitBufferLength    = SubmitBufferLength;



    //
    // Call the Local Security Authority Server.
    //

    Message.ApiNumber = LsapAuCallPackageApi;
    Message.PortMessage.u1.s1.DataLength = sizeof(*Arguments) + 8;
    Message.PortMessage.u1.s1.TotalLength = sizeof(Message);
    Message.PortMessage.u2.ZeroInit = 0L;

    if( SecpLsaDispatchFn == NULL )
    {
        Status = ZwRequestWaitReplyPort(
                LsaHandle,
                (PPORT_MESSAGE) &Message,
                (PPORT_MESSAGE) &Message
                );
    } else {
        Status = SecpLsaDispatchFn( (PSPM_LPC_MESSAGE)&Message );
    }

    //
    // We may be returning bogus return values here, but it doesn't
    // matter.  They will just be ignored if an error occured.
    //

    if ( ProtocolReturnBuffer )
    {
        (*ProtocolReturnBuffer) = (PVOID) Arguments->ProtocolReturnBuffer;
    }

    if ( ReturnBufferLength )
    {
        (*ReturnBufferLength)   = Arguments->ReturnBufferLength;
    }

    if ( ProtocolStatus )
    {
        (*ProtocolStatus)       = Arguments->ProtocolStatus;
    }


    if ( NT_SUCCESS(Status) ) {
        Status = Message.ReturnedStatus;
#if DBG
        if ( !NT_SUCCESS(Status) ) {
            DbgPrint("LSA AU: Call Package Failed %lx\n",Status);
        }
    } else {
        DbgPrint("LSA AU: Call Package Failed %lx\n",Status);
#endif //DBG
    }



    return Status;

}


NTSTATUS
LsaDeregisterLogonProcess (
    IN HANDLE LsaHandle
    )

/*++

    This function deletes the caller's logon process context.


                        ---  WARNING  ---

        Logon Processes are part of the Trusted Computer Base, and,
        as such, are expected to be debugged to a high degree.  If
        a logon process deregisters, we will believe it.  This
        allows us to re-use the old Logon Process context value.
        If the Logon process accidently uses its context value
        after freeing it, strange things may happen.  LIkewise,
        if a client calls to release a context that has already
        been released, then LSA may grind to a halt.



Arguments:

    LsaHandle - Supplies a handle obtained in a previous call to
        LsaRegisterLogonProcess.


Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.


--*/

{

    NTSTATUS Status;
    ALIGN_WOW64 LSAP_AU_API_MESSAGE Message;

    SEC_PAGED_CODE();

    //
    // Call the Local Security Authority Server.
    //

    Message.ApiNumber = LsapAuDeregisterLogonProcessApi;
    Message.PortMessage.u1.s1.DataLength = 8;
    Message.PortMessage.u1.s1.TotalLength = sizeof(Message);
    Message.PortMessage.u2.ZeroInit = 0L;

    if( SecpLsaDispatchFn == NULL )
    {
        Status = ZwRequestWaitReplyPort(
                LsaHandle,
                (PPORT_MESSAGE) &Message,
                (PPORT_MESSAGE) &Message
                );
    } else {
        Status = SecpLsaDispatchFn( (PSPM_LPC_MESSAGE)&Message );
    }



    if ( NT_SUCCESS(Status) ) {
        Status = Message.ReturnedStatus;
        if ( NT_SUCCESS(Status) ) {

            NTSTATUS TempStatus;
            TempStatus = ZwClose(LsaHandle);
            ASSERT(NT_SUCCESS(TempStatus));
        }
#if DBG
        else {
            if ( Status != SEC_E_SECPKG_NOT_FOUND )
            {
                DbgPrint("LSA AU: DeRregisterLogonProcess Failed 0x%lx\n",Status);
            }
        }
    } else {
        DbgPrint("LSA AU: NtRequestWaitReply Failed 0x%lx\n",Status);
#endif
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\spmlpcp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        spmlpcp.h
//
// Contents:    private prototypes for security lpc functions
//
//
// History:     3-77-94     MikeSw      Created
//
//------------------------------------------------------------------------


#ifndef ALLOC_PRAGMA

#define SEC_PAGED_CODE()

#else

#define SEC_PAGED_CODE() PAGED_CODE()

#endif // ALLOC_PRAGMA

SECURITY_STATUS
CallSPM(PClient             pClient,
        PSPM_LPC_MESSAGE    pSendBuffer,
        PSPM_LPC_MESSAGE    pReceiveBuffer);

LSA_DISPATCH_FN SecpLsaCallback ;

NTSTATUS
LsaCallbackHandler(
    ULONG_PTR   Function,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    PSecBuffer Input,
    PSecBuffer Output
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\misc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       misc.cxx
//
//  Contents:   Miscellaneous functions for security clients
//
//  Classes:
//
//  Functions:
//
//  History:    3-4-94      MikeSw      Created
//
//----------------------------------------------------------------------------


#include "secpch2.hxx"
extern "C"
{
#include <windns.h>
#include <lmcons.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include "spmlpcp.h"
#include <align.h>
}

#if defined(ALLOC_PRAGMA) && defined(SECURITY_KERNEL)

//
// Procedure forwards needed by #pragmas below
//
extern "C"
{
VOID
CredpMarshalChar(
    IN OUT LPWSTR *Current,
    IN ULONG Byte
    );

ULONG
CredpMarshalSize(
    IN ULONG ByteCount
    );

VOID
CredpMarshalBytes(
    IN OUT LPWSTR *Current,
    IN LPBYTE Bytes,
    IN ULONG ByteCount
    );
}
#pragma alloc_text(PAGE, SecpGetUserInfo)
#pragma alloc_text(PAGE, SecpEnumeratePackages)
#pragma alloc_text(PAGE, SecpQueryPackageInfo)
#pragma alloc_text(PAGE, SecpGetUserName)
#pragma alloc_text(PAGE, SecpGetLogonSessionData)
#pragma alloc_text(PAGE, SecpEnumLogonSession)
#pragma alloc_text(PAGE, SecpLookupAccountSid)
#pragma alloc_text(PAGE, SecpLookupAccountName)
#pragma alloc_text(PAGE, SecpLookupWellKnownSid)
#pragma alloc_text(PAGE, CredMarshalTargetInfo)
#pragma alloc_text(PAGE, CredpMarshalChar)
#pragma alloc_text(PAGE, CredpMarshalSize)
#pragma alloc_text(PAGE, CredpMarshalBytes)
#endif

//
// Same as the SecPkgInfoW structure from SSPI, but with wide pointers:
//

typedef struct _SECPKG_INFO_LPC {
    unsigned long fCapabilities;        // Capability bitmask
    unsigned short wVersion;            // Version of driver
    unsigned short wRPCID;              // ID for RPC Runtime
    unsigned long cbMaxToken;           // Size of authentication token (max)
    PWSTR_LPC Name ;
    PWSTR_LPC Comment ;
} SECPKG_INFO_LPC, * PSECPKG_INFO_LPC ;

//
// Same as the SECURITY_LOGON_SESSION_DATA from secint.h, but with wide pointers
//
typedef struct _SECURITY_LOGON_SESSION_DATA_LPC {
    ULONG           Size ;
    LUID            LogonId ;
    SECURITY_STRING_LPC UserName ;
    SECURITY_STRING_LPC LogonDomain ;
    SECURITY_STRING_LPC AuthenticationPackage ;
    ULONG           LogonType ;
    ULONG           Session ;
    PVOID           Sid ;
    LARGE_INTEGER   LogonTime ;
} SECURITY_LOGON_SESSION_DATA_LPC, * PSECURITY_LOGON_SESSION_DATA_LPC ;

//+---------------------------------------------------------------------------
//
//  Function:   SecpGetUserInfo
//
//  Synopsis:   Get the SecurityUserData of the logon session passed in
//
//  Effects:    allocates memory to store SecurityUserData
//
//  Arguments:  (none)
//
//  Returns:    status
//
//  History:    8-03-93 MikeSw   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS NTAPI
SecpGetUserInfo(IN         PLUID                   pLogonId,
                IN         ULONG                   fFlags,
                IN OUT     PSecurityUserData *     ppUserInfo)
{
    NTSTATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    DECLARE_ARGS( Args, ApiBuffer, GetUserInfo );
    PClient         pClient;
    static LUID lFake = {0,0};

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"GetUserInfo\n"));

    PREPARE_MESSAGE(ApiBuffer, GetUserInfo);

    if (pLogonId)
    {
        Args->LogonId = *pLogonId;
    }
    else
    {
        Args->LogonId = lFake;
    }

    Args->fFlags = fFlags;
    Args->pUserInfo = NULL;


    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"GetUserInfo scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
        if (NT_SUCCESS(scRet))
        {
            *ppUserInfo = Args->pUserInfo;

#if BUILD_WOW64

            //
            // This works only because we're shortening the larger data.  Don't
            // try these conversions in the opposite direction.
            //

            PSECURITY_USER_DATA_WOW64 pUserInfo64 = (PSECURITY_USER_DATA_WOW64) *ppUserInfo;

            SecpLpcStringToSecurityString(&(*ppUserInfo)->UserName, &pUserInfo64->UserName);
            SecpLpcStringToSecurityString(&(*ppUserInfo)->LogonDomainName, &pUserInfo64->LogonDomainName);
            SecpLpcStringToSecurityString(&(*ppUserInfo)->LogonServer, &pUserInfo64->LogonServer);

            (*ppUserInfo)->pSid = (PSID) pUserInfo64->pSid;

#endif

        }
    }

    FreeClient(pClient);
    return(ApiBuffer.ApiMessage.scRet);
}



//+---------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackages
//
//  Synopsis:   Get the SecurityUserData of the logon session passed in
//
//  Effects:    allocates memory to store SecurityUserData
//
//  Arguments:  (none)
//
//  Returns:    status
//
//  History:    8-03-93 MikeSw   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS NTAPI
SecpEnumeratePackages(  IN         PULONG               pcPackages,
                        IN OUT     PSecPkgInfo *        ppPackageInfo)
{

    NTSTATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, EnumPackages );

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"EnumeratePackages\n"));

    PREPARE_MESSAGE(ApiBuffer, EnumPackages);

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"Enumerate scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if ( NT_SUCCESS( scRet ) )
    {
        scRet = ApiBuffer.ApiMessage.scRet ;
    }

    if (NT_SUCCESS(scRet))
    {

#ifdef BUILD_WOW64

        //
        // Need to in-place fixup the enumerated packages
        //
        // This works because we are shrinking the size of the data
        // do not try this if it is going to expand!
        //

        SECPKG_INFO_LPC LocalStore ;
        PSECPKG_INFO_LPC LpcForm ;
        PSecPkgInfoW FinalForm ;
        ULONG i ;

        LpcForm = (PSECPKG_INFO_LPC) Args->pPackages ;
        FinalForm = (PSecPkgInfoW) Args->pPackages ;


        for ( i = 0 ; i < Args->cPackages ; i++ )
        {
            LocalStore = *LpcForm ;

            LpcForm++ ;

            FinalForm->fCapabilities = LocalStore.fCapabilities ;
            FinalForm->wVersion = LocalStore.wVersion ;
            FinalForm->wRPCID = LocalStore.wRPCID ;
            FinalForm->cbMaxToken = LocalStore.cbMaxToken ;
            FinalForm->Name = (PWSTR) LocalStore.Name ;
            FinalForm->Comment = (PWSTR) LocalStore.Comment ;
        }


#endif
        *ppPackageInfo = Args->pPackages;
        *pcPackages = Args->cPackages;
    }

    FreeClient(pClient);
    return(ApiBuffer.ApiMessage.scRet);
}




//+-------------------------------------------------------------------------
//
//  Function:   SecpQueryPackageInfo
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
SecpQueryPackageInfo(   PSECURITY_STRING        pssPackageName,
                        PSecPkgInfo *           ppPackageInfo)
{
    NTSTATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, QueryPackage );
    ULONG cbPrepackAvail = CBPREPACK;
    PUCHAR Where;

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"QueryPackageInfo\n"));

    PREPARE_MESSAGE(ApiBuffer, QueryPackage);
    Where = ApiBuffer.ApiMessage.bData;

    SecpSecurityStringToLpc( &Args->ssPackageName, pssPackageName );
    if (pssPackageName->Length <= cbPrepackAvail)
    {
        Args->ssPackageName.Buffer =  (PWSTR_LPC) ((PUCHAR) Where - (PUCHAR) &ApiBuffer);
        RtlCopyMemory(
            Where,
            pssPackageName->Buffer,
            pssPackageName->Length);

        Where += pssPackageName->Length;
        cbPrepackAvail -= pssPackageName->Length;
    }

    if ( cbPrepackAvail != CBPREPACK )
    {
        //
        // We have consumed some of the bData space:  Adjust
        // our length accordingly
        //

        ApiBuffer.pmMessage.u1.s1.TotalLength = (CSHORT) ( Where - (PUCHAR) &ApiBuffer );

        ApiBuffer.pmMessage.u1.s1.DataLength =
                ApiBuffer.pmMessage.u1.s1.TotalLength - sizeof( PORT_MESSAGE );



    }

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"QueryPackageInfo scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;

        if (NT_SUCCESS(scRet))
        {
#ifdef BUILD_WOW64

        //
        // Need to in-place fixup the enumerated packages
        //
        // This works because we are shrinking the size of the data
        // do not try this if it is going to expand!
        //

            SECPKG_INFO_LPC LocalStore ;
            PSECPKG_INFO_LPC LpcForm ;
            PSecPkgInfoW FinalForm ;
            ULONG i ;

            LpcForm = (PSECPKG_INFO_LPC) Args->pPackageInfo ;
            FinalForm = (PSecPkgInfoW) Args->pPackageInfo ;

            LocalStore = *LpcForm ;


            FinalForm->fCapabilities = LocalStore.fCapabilities ;
            FinalForm->wVersion = LocalStore.wVersion ;
            FinalForm->wRPCID = LocalStore.wRPCID ;
            FinalForm->cbMaxToken = LocalStore.cbMaxToken ;
            FinalForm->Name = (PWSTR) LocalStore.Name ;
            FinalForm->Comment = (PWSTR) LocalStore.Comment ;


#endif


            *ppPackageInfo = Args->pPackageInfo;
        }
    }

    FreeClient(pClient);
    return(ApiBuffer.ApiMessage.scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpGetUserName
//
//  Synopsis:
//
//  Arguments:  [Options] --
//              [Name]    --
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
NTAPI
SecpGetUserName(
    ULONG Options,
    PUNICODE_STRING Name
    )
{
    NTSTATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, GetUserNameX );


    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"GetUserName\n"));

    PREPARE_MESSAGE(ApiBuffer, GetUserNameX );

    Args->Options = Options ;

    SecpSecurityStringToLpc( &Args->Name, Name );

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"GetUserName scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;

        if ( ApiBuffer.ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_WIN32_ERROR )
        {
#ifndef SECURITY_KERNEL
            SetLastError( scRet );
#endif
            scRet = STATUS_UNSUCCESSFUL ;
        }

        Name->Length = Args->Name.Length ;

        if (NT_SUCCESS(scRet))
        {
            if ( Args->Name.Buffer == (PWSTR_LPC)
                 ((LONG_PTR) ApiBuffer.ApiMessage.bData - (LONG_PTR) Args) )
            {
                //
                // Response was sent in the data area:
                //

                RtlCopyMemory(
                    Name->Buffer,
                    ApiBuffer.ApiMessage.bData,
                    Args->Name.Length
                    );
            }
        }
    }

    FreeClient(pClient);

    return scRet ;
}

//+---------------------------------------------------------------------------
//
//  Function:   SecpEnumLogonSession
//
//  Synopsis:
//
//  Arguments:  [LogonSessionCount] --
//              [LogonSessionList]  --
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
NTAPI
SecpEnumLogonSession(
    PULONG LogonSessionCount,
    PLUID * LogonSessionList
    )
{
    NTSTATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, EnumLogonSession );


    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"EnumLogonSession\n"));

    PREPARE_MESSAGE(ApiBuffer, EnumLogonSession );

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"EnumLogonSession scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;

        *LogonSessionCount = Args->LogonSessionCount ;
        *LogonSessionList = (PLUID) Args->LogonSessionList ;

    }

    FreeClient(pClient);

    return scRet ;
}


//+---------------------------------------------------------------------------
//
//  Function:   SecpGetLogonSessionData
//
//  Synopsis:
//
//  Arguments:  [LogonId]          --
//              [LogonSessionData] --
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
NTAPI
SecpGetLogonSessionData(
    IN PLUID LogonId,
    OUT PVOID * LogonSessionData
    )
{
    NTSTATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, GetLogonSessionData );


    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"GetLogonSessionData\n"));

    PREPARE_MESSAGE(ApiBuffer, GetLogonSessionData );

    Args->LogonId = *LogonId ;

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"GetLogonSessionData scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
#ifdef BUILD_WOW64
        SECURITY_LOGON_SESSION_DATA_LPC LocalStore ;
        PSECURITY_LOGON_SESSION_DATA_LPC LpcForm ;
        PSECURITY_LOGON_SESSION_DATA FinalForm ;

        LpcForm = (PSECURITY_LOGON_SESSION_DATA_LPC) Args->LogonSessionInfo ;
        LocalStore = *LpcForm ;

        FinalForm = (PSECURITY_LOGON_SESSION_DATA) Args->LogonSessionInfo ;

        FinalForm->Size = sizeof( SECURITY_LOGON_SESSION_DATA );
        FinalForm->LogonId = LocalStore.LogonId ;
        SecpLpcStringToSecurityString( &FinalForm->UserName, &LocalStore.UserName );
        SecpLpcStringToSecurityString( &FinalForm->LogonDomain, &LocalStore.LogonDomain );
        SecpLpcStringToSecurityString( &FinalForm->AuthenticationPackage, &LocalStore.AuthenticationPackage );
        FinalForm->LogonType = LocalStore.LogonType ;
        FinalForm->Session = LocalStore.Session ;
        FinalForm->Sid = (PSID) LocalStore.Sid ;
        FinalForm->LogonTime = LocalStore.LogonTime ;
#endif

        *LogonSessionData = (PVOID) Args->LogonSessionInfo ;

        scRet = ApiBuffer.ApiMessage.scRet;
    }

    FreeClient(pClient);

    return scRet ;
}


//+---------------------------------------------------------------------------
//
//  Function:   SecpLookupAccountName
//
//  Synopsis:
//
//  Arguments:  [Name]               --
//              [ReferencedDomain]   --
//              [RequiredDomainSize] --
//              [SidSize]            --
//              [Sid]                --
//              [NameUse]            --
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SecpLookupAccountName(
    IN PSECURITY_STRING Name,
    OUT PSECURITY_STRING ReferencedDomain,
    OUT PULONG RequiredDomainSize,
    IN OUT PULONG SidSize,
    OUT PSID Sid,
    OUT PSID_NAME_USE NameUse
    )
{
    NTSTATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, LookupAccountNameX );
    ULONG Size ;
    PSID LocalSid ;
    UNICODE_STRING String ;

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"LookupAccountName\n"));


    if ( Name->Length > CBPREPACK )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    PREPARE_MESSAGE(ApiBuffer, LookupAccountNameX );

    Args->Name.Length = Name->Length ;
    Args->Name.MaximumLength = Args->Name.Length ;
    Args->Name.Buffer = (PWSTR_LPC) (ULONG_PTR)PREPACK_START ;

    RtlCopyMemory(
        ApiBuffer.ApiMessage.bData,
        Name->Buffer,
        Name->Length );

    ApiBuffer.pmMessage.u1.s1.DataLength = LPC_DATA_LENGTH( Name->Length );
    ApiBuffer.pmMessage.u1.s1.TotalLength = LPC_TOTAL_LENGTH( Name->Length );

    scRet = CallSPM( pClient,
                     &ApiBuffer,
                     &ApiBuffer );

    if ( NT_SUCCESS( scRet ) )
    {
        //
        //  Call succeeded
        //

        scRet = ApiBuffer.ApiMessage.scRet ;

        if ( NT_SUCCESS( scRet ) )
        {
            *NameUse = Args->NameUse ;

            LocalSid = (PUCHAR) &ApiBuffer + (ULONG_PTR) Args->Sid  ;

            Size = RtlLengthSid( LocalSid );

            if ( Size < *SidSize )
            {
                RtlCopySid( *SidSize, Sid, LocalSid );
            }
            else
            {
                scRet = STATUS_BUFFER_TOO_SMALL;
            }

            *SidSize = Size ;
        }

        if ( NT_SUCCESS( scRet ))
        {
            if ( ReferencedDomain != NULL )
            {
                if ( Args->Domain.Length )
                {
                    if ( Args->Domain.Length <= ReferencedDomain->MaximumLength )
                    {
                        String.Buffer = (PWSTR) ((PUCHAR) &ApiBuffer + (ULONG_PTR) Args->Domain.Buffer) ;
                        String.Length = Args->Domain.Length ;
                        String.MaximumLength = Args->Domain.MaximumLength ;

                        RtlCopyUnicodeString(
                            ReferencedDomain,
                            &String );
                    }
                    else
                    {
                        scRet = STATUS_BUFFER_TOO_SMALL ;
                        *RequiredDomainSize = Args->Domain.Length ;
                        ReferencedDomain->Length = 0 ;
                    }
                }
                else
                {
                    ReferencedDomain->Length = 0 ;
                }
            }
        }
    }

    return scRet ;

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpLookupAccountSid
//
//  Synopsis:
//
//  Arguments:  [Sid]                --
//              [Name]               --
//              [RequiredNameSize]   --
//              [ReferencedDomain]   --
//              [RequiredDomainSize] --
//              [NameUse]            --
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SecpLookupAccountSid(
    IN PVOID_LPC ContextPointer,
    IN PSID Sid,
    OUT PSECURITY_STRING Name,
    OUT PULONG RequiredNameSize,
    OUT PSECURITY_STRING ReferencedDomain,
    OUT PULONG RequiredDomainSize,
    OUT PSID_NAME_USE NameUse
    )
{
    NTSTATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    DECLARE_ARGS( Args, ApiBuffer, LookupAccountSidX );
    PClient         pClient;
    UNICODE_STRING String ;
    ULONG Consumed ;

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"LookupAccountSid\n"));

    if ( RtlLengthSid( Sid ) > CBPREPACK )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    PREPARE_MESSAGE_EX(ApiBuffer,
        LookupAccountSidX, (ContextPointer ? SPMAPI_FLAG_KMAP_MEM : 0 ), ContextPointer );

    Args->Sid = (PVOID_LPC) (ULONG_PTR) PREPACK_START ;

    Consumed = RtlLengthSid( Sid );

    RtlCopyMemory(
        ApiBuffer.ApiMessage.bData,
        Sid,
        Consumed );

    ApiBuffer.pmMessage.u1.s1.DataLength = LPC_DATA_LENGTH( Consumed );
    ApiBuffer.pmMessage.u1.s1.TotalLength = LPC_TOTAL_LENGTH( Consumed );

    scRet = CallSPM( pClient,
                     &ApiBuffer,
                     &ApiBuffer );

    if ( NT_SUCCESS( scRet ) )
    {
        //
        //  Call succeeded
        //

        scRet = ApiBuffer.ApiMessage.scRet ;

        if ( NT_SUCCESS( scRet ) )
        {
            *NameUse = Args->NameUse ;

            if ( Name != NULL )
            {
                if ( Args->Name.Length )
                {
                    if ( Args->Name.Length <= Name->MaximumLength )
                    {
                        String.Length = Args->Name.Length ;
                        String.MaximumLength = Args->Name.MaximumLength ;

                        if ( SecLpcIsPointerInMessage(&ApiBuffer,Args->Name.Buffer ))
                        {
                            String.Buffer = (PWSTR) SecLpcFixupPointer(&ApiBuffer, Args->Name.Buffer );
                            RtlCopyUnicodeString(
                                Name,
                                &String );
                        }
                        else
                        {
                            String.Buffer = (PWSTR) Args->Name.Buffer ;
                            *Name = String ;

                        }
                    }
                    else
                    {
                        scRet = STATUS_BUFFER_TOO_SMALL ;
                        *RequiredNameSize = Args->Name.Length ;
                        Name->Length = 0 ;
                    }
                }
                else
                {
                    Name->Length = 0 ;
                }
            }
            else
            {
                *RequiredNameSize = Args->Name.Length ;
            }

            if ( ReferencedDomain != NULL )
            {
                if ( Args->Domain.Length )
                {
                    if ( Args->Domain.Length <= ReferencedDomain->MaximumLength )
                    {
                        String.Length = Args->Domain.Length ;
                        String.MaximumLength = Args->Domain.MaximumLength ;

                        if ( SecLpcIsPointerInMessage(&ApiBuffer, Args->Domain.Buffer ) )
                        {
                            String.Buffer = (PWSTR) SecLpcFixupPointer( &ApiBuffer, Args->Domain.Buffer );

                            RtlCopyUnicodeString(
                                ReferencedDomain,
                                &String );
                        }
                        else
                        {
                            String.Buffer = (PWSTR) Args->Domain.Buffer ;
                            *ReferencedDomain = String ;
                        }
                    }
                    else
                    {
                        scRet = STATUS_BUFFER_TOO_SMALL ;
                        *RequiredDomainSize = Args->Domain.Length ;
                        ReferencedDomain->Length = 0 ;
                    }
                }
                else
                {
                    ReferencedDomain->Length = 0 ;
                }
            }
            else
            {
                *RequiredDomainSize = Args->Domain.Length ;
            }
        }
    }

    return scRet ;
}


NTSTATUS
NTAPI
SecpLookupWellKnownSid(
    IN WELL_KNOWN_SID_TYPE SidType,
    OUT PSID Sid,
    IN ULONG SidBufferSize,
    IN OUT PULONG SidSize OPTIONAL
    )
{
    NTSTATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, LookupWellKnownSid );
    PSID LocalSid ;
    ULONG LocalSidSize ;

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"LookupWellKnownSid\n"));

    PREPARE_MESSAGE(ApiBuffer, LookupWellKnownSid );

    Args->SidType = SidType ;

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"LookupWellKnownSid scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if ( NT_SUCCESS( scRet ) )
    {
        scRet = ApiBuffer.ApiMessage.scRet ;
    }

    if (NT_SUCCESS(scRet))
    {

        if ( SecLpcIsPointerInMessage(&ApiBuffer, Args->Sid ) )
        {
            LocalSid = (PSID) SecLpcFixupPointer( &ApiBuffer, Args->Sid );
        }
        else
        {
            LocalSid = (PSID) Args->Sid ;
        }

        if ( !LocalSid )
        {
            scRet = STATUS_INVALID_PARAMETER ;
        }
        else
        {
            LocalSidSize = RtlLengthSid( LocalSid );

            if ( LocalSidSize <= SidBufferSize )
            {
                RtlCopyMemory( Sid, LocalSid, LocalSidSize );
            }
            else
            {
                scRet = STATUS_BUFFER_TOO_SMALL ;
            }

            if ( SidSize )
            {
                *SidSize = LocalSidSize ;
            }
        }

    }

    FreeClient(pClient);

    return scRet ;
}


VOID
CredpMarshalChar(
    IN OUT LPWSTR *Current,
    IN ULONG Byte
    )
/*++

Routine Description:

    This routine marshals 6 bits into a buffer.

Arguments:

    Current - On input, points to a pointer of the current location in the marshaled buffer.
        On output, is modified to point to the next available location in the marshaled buffer.

    Byte - Specifies the 6 bits to marshal

Return Values:

    None.

--*/
{
    UCHAR MappingTable[] = {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
        'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
        'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '#', '-'
    };

    SEC_PAGED_CODE();

    if ( Byte > 0x3F ) {
        *(*Current) = '=';
    } else {
        *(*Current) = MappingTable[Byte];
    }
    (*Current)++;
}

ULONG
CredpMarshalSize(
    IN ULONG ByteCount
    )
/*++

Routine Description:

    This routine returns the number of bytes that would be marshaled by
    CredpMarshalBytes when passed a buffer ByteCount bytes long.

Arguments:

    ByteCount - Specifies the number of bytes to marshal


Return Values:

    The number of bytes that would be marshaled.

--*/
{
    ULONG CharCount;
    ULONG ExtraBytes;

    //
    // If byte count is a multiple of 3, the char count is straight forward
    //
    CharCount = ByteCount / 3 * 4;

    ExtraBytes = ByteCount % 3;

    if ( ExtraBytes == 1 ) {
        CharCount += 2;
    } else if ( ExtraBytes == 2 ) {
        CharCount += 3;
    }

    return CharCount * sizeof(WCHAR);

}

VOID
CredpMarshalBytes(
    IN OUT LPWSTR *Current,
    IN LPBYTE Bytes,
    IN ULONG ByteCount
    )
/*++

Routine Description:

    This routine marshals bytes into a buffer.

Arguments:

    Current - On input, points to a pointer of the current location in the marshaled buffer.
        On output, is modified to point to the next available location in the marshaled buffer.

    Bytes - Specifies the buffer to marshal

    ByteCount - Specifies the number of bytes to marshal


Return Values:

    None.

--*/
{
    ULONG i;

    union {
        BYTE ByteValues[3];
        struct {
            ULONG Bits1 :6;
            ULONG Bits2 :6;
            ULONG Bits3 :6;
            ULONG Bits4 :6;
        } BitValues;
    } Bits;

    SEC_PAGED_CODE();

    //
    // Loop through marshaling 3 bytes at a time.
    //

    for ( i=0; i<ByteCount; i+=3 ) {
        ULONG BytesToCopy;

        //
        // Grab up to 3 bytes from the input buffer.
        //
        BytesToCopy = min( 3, ByteCount-i );

        if ( BytesToCopy != 3 ) {
            RtlZeroMemory( Bits.ByteValues, 3);
        }
        RtlCopyMemory( Bits.ByteValues, &Bytes[i], BytesToCopy );

        //
        // Marshal the first twelve bits
        //
        CredpMarshalChar( Current, Bits.BitValues.Bits1 );
        CredpMarshalChar( Current, Bits.BitValues.Bits2 );

        //
        // Optionally marshal the next bits.
        //

        if ( BytesToCopy > 1 ) {
            CredpMarshalChar( Current, Bits.BitValues.Bits3 );
            if ( BytesToCopy > 2 ) {
                CredpMarshalChar( Current, Bits.BitValues.Bits4 );
            }
        }

    }

}

#ifndef SECURITY_KERNEL // we don't need a kernel version yet
BOOL
CredpUnmarshalChar(
    IN OUT LPWSTR *Current,
    IN LPCWSTR End,
    OUT PULONG Value
    )
/*++

Routine Description:

    This routine unmarshals 6 bits from a buffer.

Arguments:

    Current - On input, points to a pointer of the current location in the marshaled buffer.
        On output, is modified to point to the next available location in the marshaled buffer.

    End - Points to the first character beyond the end of the marshaled buffer.

    Value - returns the unmarshaled 6 bits value.

Return Values:

    TRUE - if the bytes we're unmarshaled sucessfully

    FALSE - if the byte could not be unmarshaled from the buffer.

--*/
{
    WCHAR CurrentChar;

    SEC_PAGED_CODE();

    //
    // Ensure the character is available in the buffer
    //

    if ( *Current >= End ) {
        return FALSE;

    }

    //
    // Grab the character
    //

    CurrentChar = *(*Current);
    (*Current)++;

    //
    // Map it the 6 bit value
    //

    switch ( CurrentChar ) {
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z':
        *Value = CurrentChar - 'A';
        break;

    case 'a':
    case 'b':
    case 'c':
    case 'd':
    case 'e':
    case 'f':
    case 'g':
    case 'h':
    case 'i':
    case 'j':
    case 'k':
    case 'l':
    case 'm':
    case 'n':
    case 'o':
    case 'p':
    case 'q':
    case 'r':
    case 's':
    case 't':
    case 'u':
    case 'v':
    case 'w':
    case 'x':
    case 'y':
    case 'z':
        *Value = CurrentChar - 'a' + 26;
        break;

    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
        *Value = CurrentChar - '0' + 26 + 26;
        break;
    case '#':
        *Value = 26 + 26 + 10;
        break;
    case '-':
        *Value = 26 + 26 + 10 + 1;
        break;
    default:
        return FALSE;
    }

    return TRUE;
}

BOOL
CredpUnmarshalBytes(
    IN OUT LPWSTR *Current,
    IN LPCWSTR End,
    IN LPBYTE Bytes,
    IN ULONG ByteCount
    )
/*++

Routine Description:

    This routine unmarshals bytes bytes from a buffer.

Arguments:

    Current - On input, points to a pointer of the current location in the marshaled buffer.
        On output, is modified to point to the next available location in the marshaled buffer.

    End - Points to the first character beyond the end of the marshaled buffer.

    Bytes - Specifies the buffer to unmarsal into

    ByteCount - Specifies the number of bytes to unmarshal


Return Values:

    TRUE - if the bytes we're unmarshaled sucessfully

    FALSE - if the byte could not be unmarshaled from the buffer.

--*/
{
    ULONG i;
    ULONG Value;

    union {
        BYTE ByteValues[3];
        struct {
            ULONG Bits1 :6;
            ULONG Bits2 :6;
            ULONG Bits3 :6;
            ULONG Bits4 :6;
        } BitValues;
    } Bits;

    SEC_PAGED_CODE();

    //
    // Loop through unmarshaling 3 bytes at a time.
    //

    for ( i=0; i<ByteCount; i+=3 ) {
        ULONG BytesToCopy;

        //
        // Grab up to 3 bytes from the input buffer.
        //
        BytesToCopy = min( 3, ByteCount-i );

        if ( BytesToCopy != 3 ) {
            RtlZeroMemory( Bits.ByteValues, 3);
        }

        //
        // Unarshal the first twelve bits
        //
        if ( !CredpUnmarshalChar( Current, End, &Value ) ) {
            return FALSE;
        }
        Bits.BitValues.Bits1 = Value;

        if ( !CredpUnmarshalChar( Current, End, &Value ) ) {
            return FALSE;
        }
        Bits.BitValues.Bits2 = Value;


        //
        // Optionally marshal the next bits.
        //

        if ( BytesToCopy > 1 ) {
            if ( !CredpUnmarshalChar( Current, End, &Value ) ) {
                return FALSE;
            }
            Bits.BitValues.Bits3 = Value;
            if ( BytesToCopy > 2 ) {
                if ( !CredpUnmarshalChar( Current, End, &Value ) ) {
                    return FALSE;
                }
                Bits.BitValues.Bits4 = Value;
            }
        }

        //
        // Copy the unmarshaled bytes to the caller's buffer.
        //

        RtlCopyMemory( &Bytes[i], Bits.ByteValues, BytesToCopy );

    }

    return TRUE;
}
#endif // SECURITY_KERNEL // we don't need a kernel version yet


//
// Structure describing the marshaled target info
//

typedef struct _CRED_MARSHALED_TI {
    ULONG MagicConstant;
#define CRED_MARSHALED_TI_CONSTANT 0x91856535
    ULONG Flags;
    ULONG CredTypeCount;
    USHORT TargetNameSize;
    USHORT NetbiosServerNameSize;
    USHORT DnsServerNameSize;
    USHORT NetbiosDomainNameSize;
    USHORT DnsDomainNameSize;
    USHORT DnsTreeNameSize;
    USHORT PackageNameSize;
} CRED_MARSHALED_TI, *PCRED_MARSHALED_TI;



NTSTATUS
CredMarshalTargetInfo (
    IN PCREDENTIAL_TARGET_INFORMATIONW InTargetInfo,
    OUT PUSHORT *Buffer,
    OUT PULONG BufferSize
    )

/*++

Routine Description:

    Marshals a TargetInformation structure into an opaque blob suitable for passing to
    another process.

    The blob can be unmarshaled via CredUnmarshalTargetInfo.

Arguments:

    InTargetInfo - Input TargetInfo

    Buffer - Returns a marshaled form of TargetInfo.
        The returned buffer contains only unicode characters and is trailing zero terminated.
        For the kernel version of this routine,
            Buffer must be freed using ExFreePool (PagedPool).
        For the secur32.dll version of this routine,
            Buffer must be freed using LocalFree.

    BufferSize - Returns the size (in bytes) of the returned Buffer
        BufferSize does not include the trailing zero terminator.


Return Values:

    Status of the operation:

        STATUS_SUCCESS: Buffer was properly returned
        STATUS_INSUFFICIENT_RESOURCES: Buffer could not be allocated

--*/

{
    NTSTATUS Status;

    CRED_MARSHALED_TI OutTargetInfo;
    ULONG Size;

    LPWSTR AllocatedString = NULL;
    LPWSTR Current;

    SEC_PAGED_CODE();

    //
    // Fill in the structure to be marshaled
    //

    OutTargetInfo.MagicConstant = CRED_MARSHALED_TI_CONSTANT;
    OutTargetInfo.Flags = InTargetInfo->Flags;
    OutTargetInfo.CredTypeCount = InTargetInfo->CredTypeCount;

    OutTargetInfo.TargetNameSize = InTargetInfo->TargetName == NULL ? 0 : wcslen( InTargetInfo->TargetName ) * sizeof(WCHAR);
    OutTargetInfo.NetbiosServerNameSize = InTargetInfo->NetbiosServerName == NULL ? 0 : wcslen( InTargetInfo->NetbiosServerName ) * sizeof(WCHAR);
    OutTargetInfo.DnsServerNameSize = InTargetInfo->DnsServerName == NULL ? 0 : wcslen( InTargetInfo->DnsServerName ) * sizeof(WCHAR);
    OutTargetInfo.NetbiosDomainNameSize = InTargetInfo->NetbiosDomainName == NULL ? 0 : wcslen( InTargetInfo->NetbiosDomainName ) * sizeof(WCHAR);
    OutTargetInfo.DnsDomainNameSize = InTargetInfo->DnsDomainName == NULL ? 0 : wcslen( InTargetInfo->DnsDomainName ) * sizeof(WCHAR);
    OutTargetInfo.DnsTreeNameSize = InTargetInfo->DnsTreeName == NULL ? 0 : wcslen( InTargetInfo->DnsTreeName ) * sizeof(WCHAR);
    OutTargetInfo.PackageNameSize = InTargetInfo->PackageName == NULL ? 0 : wcslen( InTargetInfo->PackageName ) * sizeof(WCHAR);


    //
    // Allocate a buffer for the resultant target info blob
    //

    Size = CredpMarshalSize( sizeof(CRED_MARSHALED_TI) ) +
            CredpMarshalSize( InTargetInfo->CredTypeCount * sizeof(ULONG) )+
            OutTargetInfo.TargetNameSize +
            OutTargetInfo.NetbiosServerNameSize +
            OutTargetInfo.DnsServerNameSize +
            OutTargetInfo.NetbiosDomainNameSize +
            OutTargetInfo.DnsDomainNameSize +
            OutTargetInfo.DnsTreeNameSize +
            OutTargetInfo.PackageNameSize +
            CRED_MARSHALED_TI_SIZE_SIZE;

    ASSERT( CredpMarshalSize(sizeof(ULONG))  == CRED_MARSHALED_TI_SIZE_SIZE );

    AllocatedString = (LPWSTR)
#ifdef SECURITY_KERNEL
        ExAllocatePoolWithTag( PagedPool, Size + sizeof(WCHAR), 'ITeS' );
#else // SECURITY_KERNEL
        LocalAlloc( 0, Size + sizeof(WCHAR) );
#endif // SECURITY_KERNEL

    if ( AllocatedString == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Current = AllocatedString;


    //
    // Copy the fixed size data
    //

    CredpMarshalBytes( &Current, (LPBYTE)&OutTargetInfo, sizeof(OutTargetInfo) );


    //
    // Copy the ULONG data
    //

    CredpMarshalBytes( &Current, (LPBYTE)InTargetInfo->CredTypes, InTargetInfo->CredTypeCount * sizeof(ULONG) );


    //
    // Copy the data that is already unicode characters
    //

    if ( OutTargetInfo.TargetNameSize != 0 ) {
        RtlCopyMemory( Current, InTargetInfo->TargetName, OutTargetInfo.TargetNameSize );
        Current += OutTargetInfo.TargetNameSize / sizeof(WCHAR);
    }

    if ( OutTargetInfo.NetbiosServerNameSize != 0 ) {
        RtlCopyMemory( Current, InTargetInfo->NetbiosServerName, OutTargetInfo.NetbiosServerNameSize );
        Current += OutTargetInfo.NetbiosServerNameSize / sizeof(WCHAR);
    }

    if ( OutTargetInfo.DnsServerNameSize != 0 ) {
        RtlCopyMemory( Current, InTargetInfo->DnsServerName, OutTargetInfo.DnsServerNameSize );
        Current += OutTargetInfo.DnsServerNameSize / sizeof(WCHAR);
    }

    if ( OutTargetInfo.NetbiosDomainNameSize != 0 ) {
        RtlCopyMemory( Current, InTargetInfo->NetbiosDomainName, OutTargetInfo.NetbiosDomainNameSize );
        Current += OutTargetInfo.NetbiosDomainNameSize / sizeof(WCHAR);
    }

    if ( OutTargetInfo.DnsDomainNameSize != 0 ) {
        RtlCopyMemory( Current, InTargetInfo->DnsDomainName, OutTargetInfo.DnsDomainNameSize );
        Current += OutTargetInfo.DnsDomainNameSize / sizeof(WCHAR);
    }

    if ( OutTargetInfo.DnsTreeNameSize != 0 ) {
        RtlCopyMemory( Current, InTargetInfo->DnsTreeName, OutTargetInfo.DnsTreeNameSize );
        Current += OutTargetInfo.DnsTreeNameSize / sizeof(WCHAR);
    }

    if ( OutTargetInfo.PackageNameSize != 0 ) {
        RtlCopyMemory( Current, InTargetInfo->PackageName, OutTargetInfo.PackageNameSize );
        Current += OutTargetInfo.PackageNameSize / sizeof(WCHAR);
    }

    //
    // Put the size of the blob at the end of the blob
    //

    CredpMarshalBytes( &Current, (LPBYTE)&Size, sizeof(ULONG) );
    ASSERT( (ULONG)((Current - AllocatedString) * sizeof(WCHAR)) == Size );

    //
    // Add a trailing zero for convenience purposes only
    //

    *Current = '\0';
    Current++;



    //
    // Return to the caller
    //

    *BufferSize = Size;
    *Buffer = AllocatedString;

    return STATUS_SUCCESS;

}


#ifndef SECURITY_KERNEL // we don't need a kernel version yet
NTSTATUS
CredUnmarshalTargetInfo (
    IN PUSHORT Buffer,
    IN ULONG BufferSize,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *RetTargetInfo OPTIONAL,
    OUT PULONG RetActualSize OPTIONAL
    )

/*++

Routine Description:

    Converts a marshaled TargetInfo blob into a TargetInformation structure.
    This routine will work even though the blob is concatenated after
    any other arbitrary Unicode string.

    As such, this routine can be used to determine the actual length of the blob

Arguments:

    Buffer - Specifies a marshaled TargetInfo blob built by CredMarshalTargetInfo.
        Any arbitrary unicode string may be prepended to be built blob.

    BufferSize - Specifies the size (in bytes) of Buffer

    RetTargetInfo - Returns an allocated buffer containing the unmarshaled data.
        If not specified, Buffer is simply checked to ensure it is a valid opaque blob.
        For the kernel version of this routine,
            Buffer must be freed using ExFreePool (PagedPool).
        For the secur32.dll version of thie routine,
            Buffer must be freed using LocalFree.

    RetActualSize - Returns the size (in bytes) of the actual marshaled data.
        This size does not include any unicode character prepended to the marshaled data.


Return Values:

    Status of the operation:

        STATUS_SUCCESS: OutTargetInfo was properly returned
        STATUS_INSUFFICIENT_RESOURCES: OutTargetInfo could not be allocated
        STATUS_INVALID_PARAMETER: Buffer is not a valid opaque blob

--*/

{
    NTSTATUS Status;

    CRED_MARSHALED_TI TargetInfo;
    PCREDENTIAL_TARGET_INFORMATIONW OutTargetInfo = NULL;
    ULONG ActualSize = 0;

    PUCHAR InWhere;
    LPWSTR BufferEnd = (LPWSTR)(((LPBYTE)Buffer) + BufferSize);

    LPWSTR ActualBufferEnd;

    SEC_PAGED_CODE();


    //
    // Ensure the buffer contains atleast the size field
    //  .. is a multiple of the size of WCHAR
    //  .. isn't too large
    //

    if ( (BufferSize <= CRED_MARSHALED_TI_SIZE_SIZE) ||
         (BufferSize % sizeof(WCHAR)) != 0 ||
         BufferEnd < Buffer ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Grab the Actual size of the buffer
    //

    InWhere = ((LPBYTE)Buffer) + BufferSize - CRED_MARSHALED_TI_SIZE_SIZE;

    if ( ! CredpUnmarshalBytes( (LPWSTR *)&InWhere,
                                BufferEnd,
                                (LPBYTE)&ActualSize,
                                sizeof(ULONG) ) ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    ASSERT( InWhere == (LPBYTE)BufferEnd );

    //
    // Ensure the Actual buffer size is within bounds
    //

    if ( ActualSize > BufferSize ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;

    }

    //
    // Compute the actual blob part of the buffer
    //  .. Doesn't include the length field itself
    //

    InWhere = (((LPBYTE)BufferEnd) - ActualSize);
    ActualBufferEnd = BufferEnd - (CRED_MARSHALED_TI_SIZE_SIZE/sizeof(WCHAR));

    //
    // Grab the fixed size structure
    //

    if ( ! CredpUnmarshalBytes( (LPWSTR *)&InWhere,
                                ActualBufferEnd,
                                (LPBYTE)&TargetInfo,
                                sizeof(TargetInfo) ) ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Ensure the magic number is present
    //

    if ( TargetInfo.MagicConstant != CRED_MARSHALED_TI_CONSTANT ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // If the caller doesn't need the target info returned,
    //  just check the sizes
    //
#define CHECK_SIZE( _Size ) \
    if ( InWhere + (_Size) < InWhere || \
         InWhere + (_Size) > (LPBYTE)ActualBufferEnd || \
         ((_Size) % sizeof(WCHAR)) != 0 ) { \
        Status = STATUS_INVALID_PARAMETER; \
        goto Cleanup; \
    }

    if ( !ARGUMENT_PRESENT(RetTargetInfo) ) {
        ULONG CredTypeSize;


        //
        // Check the ULONG aligned data
        //

        CredTypeSize = CredpMarshalSize( TargetInfo.CredTypeCount * sizeof(ULONG) );
        CHECK_SIZE( CredTypeSize );
        InWhere += CredTypeSize;

        //
        // Check the USHORT aligned data
        //

        CHECK_SIZE( TargetInfo.TargetNameSize );
        InWhere += TargetInfo.TargetNameSize;

        CHECK_SIZE( TargetInfo.NetbiosServerNameSize );
        InWhere += TargetInfo.NetbiosServerNameSize;

        CHECK_SIZE( TargetInfo.DnsServerNameSize );
        InWhere += TargetInfo.DnsServerNameSize;

        CHECK_SIZE( TargetInfo.NetbiosDomainNameSize );
        InWhere += TargetInfo.NetbiosDomainNameSize;

        CHECK_SIZE( TargetInfo.DnsDomainNameSize );
        InWhere += TargetInfo.DnsDomainNameSize;

        CHECK_SIZE( TargetInfo.DnsTreeNameSize );
        InWhere += TargetInfo.DnsTreeNameSize;

        CHECK_SIZE( TargetInfo.PackageNameSize );
        InWhere += TargetInfo.PackageNameSize;

    //
    // If the caller does need the target info returned,
    //  allocate and copy the data.
    //

    } else {
        ULONG Size;
        ULONG MaximumSize;
        PUCHAR Where;


        //
        // Sanity check the size of the buffer to allocate
        //

        Size = sizeof(CREDENTIAL_TARGET_INFORMATIONW) +
                    TargetInfo.TargetNameSize + sizeof(WCHAR) +
                    TargetInfo.NetbiosServerNameSize + sizeof(WCHAR) +
                    TargetInfo.DnsServerNameSize + sizeof(WCHAR) +
                    TargetInfo.NetbiosDomainNameSize + sizeof(WCHAR) +
                    TargetInfo.DnsDomainNameSize + sizeof(WCHAR) +
                    TargetInfo.DnsTreeNameSize + sizeof(WCHAR) +
                    TargetInfo.PackageNameSize + sizeof(WCHAR) +
                    TargetInfo.CredTypeCount * sizeof(ULONG);

        MaximumSize = sizeof(CREDENTIAL_TARGET_INFORMATIONW) +
                    DNS_MAX_NAME_BUFFER_LENGTH * sizeof(WCHAR) + sizeof(WCHAR) +
                    CNLEN * sizeof(WCHAR) + sizeof(WCHAR) +
                    DNS_MAX_NAME_BUFFER_LENGTH * sizeof(WCHAR) + sizeof(WCHAR) +
                    CNLEN * sizeof(WCHAR) + sizeof(WCHAR) +
                    DNS_MAX_NAME_BUFFER_LENGTH * sizeof(WCHAR) + sizeof(WCHAR) +
                    DNS_MAX_NAME_BUFFER_LENGTH * sizeof(WCHAR) + sizeof(WCHAR) +
                    DNS_MAX_NAME_BUFFER_LENGTH * sizeof(WCHAR) + sizeof(WCHAR) +
                    50 * sizeof(ULONG);

        if ( Size > MaximumSize ) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Allocate a buffer for the resultant target info
        //
        OutTargetInfo = (PCREDENTIAL_TARGET_INFORMATIONW)
#ifdef SECURITY_KERNEL
            ExAllocatePoolWithTag( PagedPool, Size, 'ITeS' )
#else // SECURITY_KERNEL
            LocalAlloc( 0, Size );
#endif // SECURITY_KERNEL

        if ( OutTargetInfo == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Where = (PUCHAR)(OutTargetInfo + 1);


        //
        // Copy the fixed size data
        //

        OutTargetInfo->Flags = TargetInfo.Flags;


        //
        // Copy the ULONG aligned data
        //

        OutTargetInfo->CredTypeCount = TargetInfo.CredTypeCount;
        if ( TargetInfo.CredTypeCount != 0 ) {

            if ( ! CredpUnmarshalBytes( (LPWSTR *)&InWhere,
                                        ActualBufferEnd,
                                        Where,
                                        TargetInfo.CredTypeCount * sizeof(ULONG) ) ) {

                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            OutTargetInfo->CredTypes = (LPDWORD)Where;

            Where += TargetInfo.CredTypeCount * sizeof(ULONG);
        } else {
            OutTargetInfo->CredTypes = NULL;
        }


        //
        // Convert the USHORT aligned data
        //

        if ( TargetInfo.TargetNameSize != 0 ) {

            CHECK_SIZE( TargetInfo.TargetNameSize );

            OutTargetInfo->TargetName = (LPWSTR) Where;

            RtlCopyMemory( Where, InWhere, TargetInfo.TargetNameSize );
            Where += TargetInfo.TargetNameSize;
            InWhere += TargetInfo.TargetNameSize;

            *(LPWSTR)Where = '\0';
            Where += sizeof(WCHAR);
        } else {
            OutTargetInfo->TargetName = NULL;
        }

        if ( TargetInfo.NetbiosServerNameSize != 0 ) {

            CHECK_SIZE( TargetInfo.NetbiosServerNameSize );

            OutTargetInfo->NetbiosServerName = (LPWSTR) Where;

            RtlCopyMemory( Where, InWhere, TargetInfo.NetbiosServerNameSize );
            Where += TargetInfo.NetbiosServerNameSize;
            InWhere += TargetInfo.NetbiosServerNameSize;

            *(LPWSTR)Where = '\0';
            Where += sizeof(WCHAR);
        } else {
            OutTargetInfo->NetbiosServerName = NULL;
        }

        if ( TargetInfo.DnsServerNameSize != 0 ) {

            CHECK_SIZE( TargetInfo.DnsServerNameSize );

            OutTargetInfo->DnsServerName = (LPWSTR) Where;

            RtlCopyMemory( Where, InWhere, TargetInfo.DnsServerNameSize );
            Where += TargetInfo.DnsServerNameSize;
            InWhere += TargetInfo.DnsServerNameSize;

            *(LPWSTR)Where = '\0';
            Where += sizeof(WCHAR);
        } else {
            OutTargetInfo->DnsServerName = NULL;
        }

        if ( TargetInfo.NetbiosDomainNameSize != 0 ) {

            CHECK_SIZE( TargetInfo.NetbiosDomainNameSize );

            OutTargetInfo->NetbiosDomainName = (LPWSTR) Where;

            RtlCopyMemory( Where, InWhere, TargetInfo.NetbiosDomainNameSize );
            Where += TargetInfo.NetbiosDomainNameSize;
            InWhere += TargetInfo.NetbiosDomainNameSize;

            *(LPWSTR)Where = '\0';
            Where += sizeof(WCHAR);
        } else {
            OutTargetInfo->NetbiosDomainName = NULL;
        }

        if ( TargetInfo.DnsDomainNameSize != 0 ) {

            CHECK_SIZE( TargetInfo.DnsDomainNameSize );

            OutTargetInfo->DnsDomainName = (LPWSTR) Where;

            RtlCopyMemory( Where, InWhere, TargetInfo.DnsDomainNameSize );
            Where += TargetInfo.DnsDomainNameSize;
            InWhere += TargetInfo.DnsDomainNameSize;

            *(LPWSTR)Where = '\0';
            Where += sizeof(WCHAR);
        } else {
            OutTargetInfo->DnsDomainName = NULL;
        }

        if ( TargetInfo.DnsTreeNameSize != 0 ) {

            CHECK_SIZE( TargetInfo.DnsTreeNameSize );

            OutTargetInfo->DnsTreeName = (LPWSTR) Where;

            RtlCopyMemory( Where, InWhere, TargetInfo.DnsTreeNameSize );
            Where += TargetInfo.DnsTreeNameSize;
            InWhere += TargetInfo.DnsTreeNameSize;

            *(LPWSTR)Where = '\0';
            Where += sizeof(WCHAR);
        } else {
            OutTargetInfo->DnsTreeName = NULL;
        }

        if ( TargetInfo.PackageNameSize != 0 ) {

            CHECK_SIZE( TargetInfo.PackageNameSize );

            OutTargetInfo->PackageName = (LPWSTR) Where;

            RtlCopyMemory( Where, InWhere, TargetInfo.PackageNameSize );
            Where += TargetInfo.PackageNameSize;
            InWhere += TargetInfo.PackageNameSize;

            *(LPWSTR)Where = '\0';
            Where += sizeof(WCHAR);
        } else {
            OutTargetInfo->PackageName = NULL;
        }

    }

    //
    // Check that we're at the end of the actual buffer
    //

    if ( InWhere != (LPBYTE)ActualBufferEnd ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Return the buffer to the caller
    //
    if ( ARGUMENT_PRESENT(RetTargetInfo) ) {
        *RetTargetInfo = OutTargetInfo;
        OutTargetInfo = NULL;
    }

    if ( ARGUMENT_PRESENT( RetActualSize ) ) {
        *RetActualSize = ActualSize;
    }

    Status = STATUS_SUCCESS;
Cleanup:

    //
    // Be tidy
    //

    if ( OutTargetInfo != NULL ) {
#ifdef SECURITY_KERNEL
        ExFreePool( OutTargetInfo );
#else // SECURITY_KERNEL
        LocalFree( OutTargetInfo );
#endif // SECURITY_KERNEL
    }

    return Status;

}
#endif // SECURITY_KERNEL // we don't need a kernel version yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\spmlpc.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        spmlpc.cxx
//
// Contents:    lpc code for client->spmgr communication
//
//
// History:     3-4-94      MikeSw      Created
//
//------------------------------------------------------------------------

#include "secpch2.hxx"

extern "C"
{
#include <zwapi.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include <spmlpcp.h>

SECURITY_STATUS
LpcConnect( PWSTR       pszPortName,
            PVOID       pConnect,
            PULONG      pcbConnect,
            HANDLE *    phPort);
}

#if defined(ALLOC_PRAGMA) && defined(SECURITY_KERNEL)
#pragma alloc_text(PAGE, CreateConnection)
#pragma alloc_text(PAGE, CallSPM)
#pragma alloc_text(PAGE, LpcConnect)
#endif

PLSA_DISPATCH_FN    SecpLsaDispatchFn ;
LSA_DISPATCH_FN     SecpLsaCallback ;

#ifdef SECURITY_USERMODE

extern BOOL LsaPackageShutdown ;

NTSTATUS
NTAPI
SecpDllCallback(
    ULONG_PTR RequestType,
    ULONG_PTR Parameter,
    PSecBuffer InputBuffer,
    PSecBuffer OutputBuffer
    )
{
    DebugLog(( DEB_TRACE, "Internal Callback, request = %d\n", RequestType ));

    if ( RequestType == SPM_CALLBACK_SHUTDOWN )
    {
        LsaPackageShutdown = TRUE ;
    }

    return STATUS_NOT_IMPLEMENTED ;
}

NTSTATUS
SecpHandleCallback(
    PClient     pClient,
    PSPM_LPC_MESSAGE    pCallback
    )
{
    SPMCallbackAPI *    Args ;
    NTSTATUS Status  = STATUS_SUCCESS;
    SecBuffer Input ;
    SecBuffer Output ;

    while ( TRUE )
    {
        Args = LPC_MESSAGE_ARGSP( pCallback, Callback );

        SecpLpcBufferToSecBuffer( &Input, &Args->Input );
        SecpLpcBufferToSecBuffer( &Output, &Args->Output );

        switch ( Args->Type )
        {
            case SPM_CALLBACK_INTERNAL:
                Status = SecpDllCallback( (ULONG_PTR) Args->Argument1,
                                          (ULONG_PTR) Args->Argument2,
                                          &Input,
                                          &Output );
                break;

            case SPM_CALLBACK_GETKEY:
                Status = STATUS_NOT_IMPLEMENTED ;
                break;

            case SPM_CALLBACK_PACKAGE:

                Status = LsaCallbackHandler( (ULONG_PTR) Args->CallbackFunction,
                                             (ULONG_PTR) Args->Argument1,
                                             (ULONG_PTR) Args->Argument2,
                                             &Input,
                                             &Output );

                break;

            case SPM_CALLBACK_EXPORT:
                Status = STATUS_NOT_IMPLEMENTED ;
                break;
        }

        SecpSecBufferToLpc( &Args->Output, &Output );

        //
        // Now, post it back to the LSA, and wait for a reply to the
        // original request:
        //

        pCallback->ApiMessage.scRet = Status ;

        if ( pClient )
        {

            Status = ZwReplyWaitReplyPort(  pClient->hPort,
                                            (PPORT_MESSAGE) pCallback );

            if ( pCallback->pmMessage.u2.s2.Type == LPC_REPLY )
            {
                break;
            }
        }
        else
        {
            break;
        }
    }

    return Status ;
}


NTSTATUS
SecpLsaCallback(
    PSPM_LPC_MESSAGE    pCallback
    )
{
    return SecpHandleCallback( NULL, pCallback );
}
#endif


//+-------------------------------------------------------------------------
//
//  Function:   CallSPM
//
//  Synopsis:   Calls the SPM, handles LPC errors
//
//  Effects:
//
//  Arguments:  pConn           -- Connection to use
//              pSendBuffer     -- Send buffer to send up
//              pReceiveBuffer  -- Received data from SPM
//
//  Requires:
//
//  Returns:
//
//  Notes:      In the future, we can add retry and error handling,
//              but right now we just panic if something fails.
//
//--------------------------------------------------------------------------
SECURITY_STATUS
CallSPM(PClient         pClient,
        PSPM_LPC_MESSAGE      pSendBuffer,
        PSPM_LPC_MESSAGE      pReceiveBuffer)

{
    SECURITY_STATUS     scRet;
    int                 retry = 0;

    SEC_PAGED_CODE();

    if ( SecpLsaDispatchFn == NULL )
    {
        scRet = ZwRequestWaitReplyPort( pClient->hPort,
                                        (PPORT_MESSAGE) pSendBuffer,
                                        (PPORT_MESSAGE) pReceiveBuffer);

        if (!NT_SUCCESS(scRet))
        {
            // If the call failed, shout to everyone, kill the connection,
            // and stuff NO_SPM into the API return code

            DebugLog((DEB_ERROR,"Error %x in LPC to LSA\n", scRet));
            DebugLog((DEB_ERROR,"Breaking connection for process %x\n", pClient->ProcessId));
            scRet = SEC_E_INTERNAL_ERROR;
            pReceiveBuffer->ApiMessage.scRet = scRet;
            pReceiveBuffer->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
        }

#ifdef SECURITY_USERMODE
        if ( pReceiveBuffer->pmMessage.u2.s2.Type == LPC_REQUEST )
        {
            //
            // The LSA has issued a callback.  Punt up to the callback handler
            //

            scRet = SecpHandleCallback( pClient,
                                        pReceiveBuffer);
        }
#endif

    }
    else
    {
        if ( pSendBuffer != pReceiveBuffer )
        {
            RtlCopyMemory( pReceiveBuffer,
                           pSendBuffer,
                           sizeof( SPM_LPC_MESSAGE ) );
        }
        scRet = SecpLsaDispatchFn( pReceiveBuffer );
    }

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   CreateConnection()
//
//  Synopsis:   Creates a connection record to the SPM
//
//  Effects:    Creates an LPC port in the context of the calling FSP
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    phConnect   - handle to a connection
//
//              STATUS_INSUFFICIENT_RESOURCES   - out of connection records
//              SEC_E_NO_SPM                    - Cannot connect to SPM
//
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
CreateConnection(
    PSTR     LogonProcessName,
    ULONG    ClientMode,
    HANDLE * phConnect,
    ULONG *  PackageCount,
    ULONG *  OperationalMode
    )
{
    SECURITY_STATUS scRet;
    HANDLE          hPort;
    LSAP_AU_REGISTER_CONNECT_INFO_EX ConnectMessage;
    ULONG           cbConnect = sizeof(LSAP_AU_REGISTER_CONNECT_INFO);
    PLSAP_AU_REGISTER_CONNECT_RESP Resp;
    OBJECT_ATTRIBUTES           PortObjAttr;
    UNICODE_STRING              ucsPortName;
    SECURITY_QUALITY_OF_SERVICE sQOS;
    ULONG                       cbMaxMessage;

    SEC_PAGED_CODE();

    DebugLog((DEB_TRACE,"KSec:  CreateConnection\n" ));

    //
    // Zero this buffer to create an untrusted connection.
    //

    RtlZeroMemory(
        &ConnectMessage,
        sizeof(ConnectMessage)
        );

    if ( LogonProcessName )
    {
        ConnectMessage.LogonProcessNameLength = strlen( LogonProcessName );
        if ( ConnectMessage.LogonProcessNameLength >
                LSAP_MAX_LOGON_PROC_NAME_LENGTH )
        {
            ConnectMessage.LogonProcessNameLength = LSAP_MAX_LOGON_PROC_NAME_LENGTH ;
        }

        strncpy( ConnectMessage.LogonProcessName,
                 LogonProcessName,
                 ConnectMessage.LogonProcessNameLength );

        ConnectMessage.LogonProcessName[ConnectMessage.LogonProcessNameLength] = '\0';

        ConnectMessage.ClientMode = ClientMode;
        cbConnect = sizeof(LSAP_AU_REGISTER_CONNECT_INFO_EX);
    }

    RtlInitUnicodeString( &ucsPortName, SPM_PORTNAME );

    InitializeObjectAttributes(&PortObjAttr, &ucsPortName, 0, NULL, NULL);

    sQOS.Length = sizeof( sQOS );
    sQOS.ImpersonationLevel = SecurityImpersonation;
    sQOS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sQOS.EffectiveOnly = FALSE;

    scRet = ZwConnectPort(  phConnect,
                            &ucsPortName,
                            &sQOS,
                            NULL,
                            NULL,
                            &cbMaxMessage,
                            &ConnectMessage,
                            &cbConnect );

    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR,"KSec: LpcConnect to SPM Failed, %x \n",
                    scRet));

        scRet = SEC_E_INTERNAL_ERROR;
        goto Create_SafeExit;
    }

    Resp = (PLSAP_AU_REGISTER_CONNECT_RESP) &ConnectMessage ;

    if ( PackageCount )
    {
        *PackageCount = Resp->PackageCount;
    }

    if ( OperationalMode )
    {
        *OperationalMode = Resp->SecurityMode ;
    }

    DebugLog((DEB_TRACE,"KSec:  Connected process to SPMgr\n"));

    // Safe, clean exit point:

Create_SafeExit:

    // return the set status code

    return(scRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\efsp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       efsp.cxx
//
//  Contents:   Stub routines for EFS clients.  Kernel mode
//              and usermode stubs are all in this file.
//
//  Classes:
//
//  Functions:
//
//  History:    3-4-94      RobertRe      Created
//
//----------------------------------------------------------------------------


#include "secpch2.hxx"

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include <efsstruc.h>
#include <lpcefs.h>
#include "spmlpcp.h"
}

#if defined(ALLOC_PRAGMA) && defined(SECURITY_KERNEL)
#pragma alloc_text(PAGE, EfspGenerateKey)
#endif

extern "C"
NTSTATUS
SEC_ENTRY
EfspGenerateKey(
   PEFS_DATA_STREAM_HEADER * EfsStream,
   PEFS_DATA_STREAM_HEADER   DirectoryEfsStream,
   ULONG                     DirectoryEfsStreamLength,
   PEFS_KEY *                Fek,
   PVOID *                   BufferBase,
   PULONG                    BufferLength
   )
/*++

Routine Description:

    Private stub called by the EFS driver to do the work of the
    EfsGenerateKey server call.  The caller is in ksecdd.sys.

Arguments:

   EfsStream - Returns a pointer to an EFS_DATA_STREAM_HEADER.

   DirectoryEfsStream - The EFS stream from the containing directory.
        If present, may be used to calculate the EFS stream for the
        current file.

   DirectoryEfsStreamLength - The lenght in bytes of the passed
        EFS stream.

   Fek - Returns a pointer to a structure of type PEFS_KEY

   BufferBase -

   BufferLength -



Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, EfsGenerateKey );

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"EfsGenerateKey\n"));

    PREPARE_MESSAGE_EX(ApiBuffer, EfsGenerateKey, 0, 0 );

    Args->EfsStream = NULL;
    Args->Fek       = NULL;
    Args->BufferBase = NULL;
    Args->BufferLength = 0;
    Args->DirectoryEfsStream = DirectoryEfsStream;
    Args->DirectoryEfsStreamLength = DirectoryEfsStreamLength;

    scRet = (NTSTATUS)CallSPM(pClient,
                                &ApiBuffer,
                                &ApiBuffer);

    DebugLog((DEB_TRACE,"EfsGenerateKey scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;

        if (NT_SUCCESS( scRet )) {
            *Fek = (PEFS_KEY)(Args->Fek);
            *EfsStream = (PEFS_DATA_STREAM_HEADER)(Args->EfsStream);
            *BufferBase = Args->BufferBase;
            *BufferLength = Args->BufferLength;

        }
    }

    FreeClient(pClient);

    return scRet;
}


extern "C"
NTSTATUS
SEC_ENTRY
EfspGenerateDirEfs(
    PEFS_DATA_STREAM_HEADER   DirectoryEfsStream,
    ULONG                     DirectoryEfsStreamLength,
    PEFS_DATA_STREAM_HEADER * EfsStream,
    PVOID *                   BufferBase,
    PULONG                    BufferLength
    )
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, EfsGenerateDirEfs );

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"EfsGenerateKey\n"));

    PREPARE_MESSAGE_EX(ApiBuffer, EfsGenerateDirEfs, 0, 0 );

    Args->DirectoryEfsStream = DirectoryEfsStream;
    Args->DirectoryEfsStreamLength = DirectoryEfsStreamLength;
    Args->EfsStream = NULL;
    Args->BufferBase = NULL;
    Args->BufferLength = 0;

    scRet = (NTSTATUS)CallSPM(pClient,
                               &ApiBuffer,
                               &ApiBuffer);

    DebugLog((DEB_TRACE,"EfspGenerateDirEfs scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;

        if (NT_SUCCESS( scRet )) {

            *EfsStream = (PEFS_DATA_STREAM_HEADER)(Args->EfsStream);
            *BufferBase = Args->BufferBase;
            *BufferLength = Args->BufferLength;
        }
    }

    FreeClient(pClient);

    return scRet;
}

extern "C"
NTSTATUS
SEC_ENTRY
EfspDecryptFek(
    PEFS_KEY *                Fek,
    PEFS_DATA_STREAM_HEADER   EfsStream,
    ULONG                     EfsStreamLength,
    ULONG                     OpenType,
    PEFS_DATA_STREAM_HEADER * NewEfs,
    PVOID *                   BufferBase,
    PULONG                    BufferLength
    )
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, EfsDecryptFek );

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"EfsGenerateKey\n"));

    PREPARE_MESSAGE_EX(ApiBuffer, EfsDecryptFek, 0, 0);

    Args->Fek       = NULL;
    Args->BufferBase = NULL;
    Args->BufferLength = 0;
    Args->EfsStream = EfsStream;
    Args->OpenType = OpenType;
    Args->NewEfs = NULL;
    Args->EfsStreamLength = EfsStreamLength;

    scRet = (NTSTATUS)CallSPM(pClient,
                                &ApiBuffer,
                                &ApiBuffer);

    DebugLog((DEB_TRACE,"EfsGenerateKey scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;

        if (NT_SUCCESS( scRet )) {

            *Fek = (PEFS_KEY)(Args->Fek);
            *NewEfs = (PEFS_DATA_STREAM_HEADER)(Args->NewEfs);
            *BufferBase = Args->BufferBase;
            *BufferLength = Args->BufferLength;
        }
    }

    FreeClient(pClient);

    return scRet;
}



extern "C"
NTSTATUS
SEC_ENTRY
EfspGenerateSessionKey(
    PEFS_INIT_DATAEXG  InitData
    )
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, EfsGenerateSessionKey );

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"EfsGenerateSessionKey\n"));

    PREPARE_MESSAGE(ApiBuffer, EfsGenerateSessionKey);

    Args->InitDataExg = NULL;

    scRet = (NTSTATUS)CallSPM(pClient,
                                &ApiBuffer,
                                &ApiBuffer);

    DebugLog((DEB_TRACE,"EfsGenerateKey scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;

        if (NT_SUCCESS( scRet )) {

            RtlCopyMemory( InitData, &Args->InitDataExg, sizeof( EFS_INIT_DATAEXG ) );
            RtlSecureZeroMemory( &Args->InitDataExg, sizeof( EFS_INIT_DATAEXG ));
        }
    }

    FreeClient(pClient);

    return scRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\lsap.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    lsap.cxx

Abstract:

    Stub routines for Lsa lpc

Author:

    Mac McLain          (MacM)       Dec 7, 1997

Environment:

    User Mode

Revision History:

--*/

#include "secpch2.hxx"

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "spmlpcp.h"
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapPolicyChangeNotify
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
SECURITY_STATUS
SEC_ENTRY
LsapPolicyChangeNotify( IN ULONG Options,
                        IN BOOLEAN Register,
                        IN HANDLE EventHandle,
                        IN POLICY_NOTIFICATION_INFORMATION_CLASS NotifyInfoClass )
{

    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, LsaPolicyChangeNotify );

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"PolicyChangeNotify\n"));

    PREPARE_MESSAGE(ApiBuffer, LsaPolicyChangeNotify);


    Args->Options = Options;
    Args->Register = Register;
    Args->EventHandle = ( ULONG64 ) EventHandle;    // convert to 64 bit representation
                                                    // because server side expects it so
    Args->NotifyInfoClass = NotifyInfoClass;

    scRet = CallSPM( pClient,
                     &ApiBuffer,
                     &ApiBuffer );

    DebugLog((DEB_TRACE,"PolicyChangeNotify scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
    }

    FreeClient(pClient);

    return(scRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\dll\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.h
//
//  Contents:   Debug headers for the security dll
//
//  Classes:
//
//  Functions:
//
//  History:    4-26-93   RichardW   Created
//
//----------------------------------------------------------------------------

#ifdef DBG

#ifndef __DEBUG_H__
#define __DEBUG_H__


void    SetDebugInfo(void);

#define DEB_TRACE_OLDLSA    0x100
#define DEB_TRACE_PACKAGE   0x00000010
#define DEB_TRACE_GETUSER       0x00080000

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\dll\debug.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.c
//
//  Contents:   Debug support for the security client dll
//
//  Classes:
//
//  Functions:
//
//  History:    4-26-93   RichardW   Created
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop
extern "C"
{
#include <dsysdbg.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"

}

DEFINE_DEBUG2(Sec);

#if DBG     // NOTE:  This file does not get compiled in retail builds


void
KsecDebugOut(unsigned long  Mask,
            const char *    Format,
            ...)
{
    ULONG  Thread;
    ULONG  Process;
    va_list     ArgList;
    char        szOutString[256];

    if (SecInfoLevel & Mask)
    {
        Thread = GetCurrentThreadId();
        Process = GetCurrentProcessId();

        va_start(ArgList, Format);
        DbgPrint("%#x.%#x> KSec:  ", Process, Thread);
        if (_vsnprintf(szOutString, sizeof(szOutString),Format, ArgList) < 0)
        {
                //
                // Less than zero indicates that the string could not be
                // fitted into the buffer.  Output a special message indicating
                // that:
                //

                DbgPrint("Error printing message\n");

        }
        else
        {
            DbgPrint(szOutString);
        }
    }
}

#if 1

DEBUG_KEY   SecDebugKeys[]  = { {DEB_ERROR,         "Error"},
                                {DEB_WARN,          "Warn"},
                                {DEB_TRACE,         "Trace"},
                                {DEB_TRACE_LSA,     "Lsa"},
                                {DEB_TRACE_CALL,    "Call"},
                                {DEB_TRACE_GETUSER, "GetUser"},
                                {0, NULL}
                              };



VOID
SecInitializeDebug(VOID)
{
    // SecInitDebugEx(DSYSDBG_OPEN_ONLY, SecDebugKeys);
    SecInitDebugEx(0, SecDebugKeys);
}

VOID
SecUninitDebug( VOID )
{
    SecUnloadDebug();
}

#endif
#endif // NOTE:  This file does not get compiled in retail builds!
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\util.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       util.cxx
//
//  Contents:   Miscellaneous functions for security clients
//
//  Classes:
//
//  Functions:
//
//  History:    3-4-94      MikeSw      Created
//
//----------------------------------------------------------------------------

#include "secpch2.hxx"

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "spmlpcp.h"
}

#if defined(ALLOC_PRAGMA) && defined(SECURITY_KERNEL)
#pragma alloc_text(PAGE, SecpGetBinding)
#pragma alloc_text(PAGE, SecpFindPackage)
#endif


//+-------------------------------------------------------------------------
//
//  Function:   SecpGetBinding
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
SECURITY_STATUS SEC_ENTRY
SecpGetBinding( ULONG_PTR                   ulPackageId,
                PSEC_PACKAGE_BINDING_INFO   pBindingInfo)
{

    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, GetBinding );
    ULONG i ;

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }


    PREPARE_MESSAGE(ApiBuffer, GetBinding);

    DebugLog((DEB_TRACE,"GetBinding(%x)\n", ulPackageId));

    Args->ulPackageId = (LSA_SEC_HANDLE_LPC) ulPackageId;

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"GetBinding scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
        if (NT_SUCCESS(scRet))
        {
#ifdef BUILD_WOW64
            //
            // Copy "by hand," fixing up the pointers:
            //
            SecpLpcStringToSecurityString( &pBindingInfo->PackageName,
                                           &Args->BindingInfo.PackageName );

            SecpLpcStringToSecurityString( &pBindingInfo->Comment,
                                           &Args->BindingInfo.Comment );

            SecpLpcStringToSecurityString( &pBindingInfo->ModuleName,
                                           &Args->BindingInfo.ModuleName );

            pBindingInfo->PackageIndex = Args->BindingInfo.PackageIndex ;
            pBindingInfo->fCapabilities = Args->BindingInfo.fCapabilities ;
            pBindingInfo->Flags = Args->BindingInfo.Flags ;
            pBindingInfo->RpcId = Args->BindingInfo.RpcId ;
            pBindingInfo->Version = Args->BindingInfo.Version ;
            pBindingInfo->TokenSize = Args->BindingInfo.TokenSize ;
            pBindingInfo->ContextThunksCount = Args->BindingInfo.ContextThunksCount ;

            for ( i = 0 ; i < pBindingInfo->ContextThunksCount ; i++ )
            {
                pBindingInfo->ContextThunks[ i ] = Args->BindingInfo.ContextThunks[ i ] ;
            }
#else 
            *pBindingInfo = Args->BindingInfo;
#endif 
        }
    }

    FreeClient(pClient);
    return(scRet);

}

//+-------------------------------------------------------------------------
//
//  Function:   SecpFindPackage
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
SECURITY_STATUS SEC_ENTRY
SecpFindPackage(    PSECURITY_STRING        pssPackageName,
                    PULONG_PTR              pulPackageId)
{

    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, FindPackage );
    ULONG cbPrepackAvail = CBPREPACK;
    PUCHAR Where;

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"FindPackage\n"));

    PREPARE_MESSAGE(ApiBuffer, FindPackage);

    Where = ApiBuffer.ApiMessage.bData;

    SecpSecurityStringToLpc( &Args->ssPackageName, pssPackageName );

    if (pssPackageName->Length <= cbPrepackAvail)
    {
        Args->ssPackageName.Buffer =  (PWSTR_LPC) ((PUCHAR) Where - (PUCHAR) &ApiBuffer);

        RtlCopyMemory(Where,pssPackageName->Buffer,pssPackageName->Length);

        Where += pssPackageName->Length;

        cbPrepackAvail -= pssPackageName->Length;
    }

    if ( cbPrepackAvail != CBPREPACK )
    {
        //
        // We have consumed some of the bData space:  Adjust 
        // our length accordingly
        //

        ApiBuffer.pmMessage.u1.s1.TotalLength = (CSHORT) (Where - (PUCHAR) &ApiBuffer );

        ApiBuffer.pmMessage.u1.s1.DataLength = 
                ApiBuffer.pmMessage.u1.s1.TotalLength - sizeof( PORT_MESSAGE );


        
    }

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"FindPackage scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
        if (NT_SUCCESS(scRet))
        {
            *pulPackageId = (ULONG_PTR) Args->ulPackageId;
        }
    }

    FreeClient(pClient);
    return(scRet);
}

extern "C"
SECURITY_STATUS
SEC_ENTRY
SecpAddPackage(
    PUNICODE_STRING Package,
    PSECURITY_PACKAGE_OPTIONS Options)
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, AddPackage );
    ULONG cbPrepackAvail = CBPREPACK;
    PUCHAR Where;

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"AddPackage\n"));

    PREPARE_MESSAGE(ApiBuffer, AddPackage);

    Where = ApiBuffer.ApiMessage.bData;

    SecpSecurityStringToLpc( &Args->Package, Package );

    if ( Package->Length <= cbPrepackAvail )
    {
        Args->Package.Buffer = (PWSTR_LPC) ((PUCHAR) Where - (PUCHAR) &ApiBuffer);
        RtlCopyMemory(  Where,
                        Package->Buffer,
                        Package->Length );

        Where += Package->Length ;
        cbPrepackAvail -= Package->Length ;
    }

    Args->OptionsFlags = Options->Flags ;


    if ( cbPrepackAvail != CBPREPACK )
    {
        //
        // We have consumed some of the bData space:  Adjust 
        // our length accordingly
        //

        ApiBuffer.pmMessage.u1.s1.TotalLength = (CSHORT) (Where - (PUCHAR) &ApiBuffer) ;

        ApiBuffer.pmMessage.u1.s1.DataLength = 
                ApiBuffer.pmMessage.u1.s1.TotalLength - sizeof( PORT_MESSAGE );


        
    }

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"AddPackage scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
    }

    FreeClient(pClient);

    return(scRet);

}

extern "C"
SECURITY_STATUS
SEC_ENTRY
SecpDeletePackage(
    PUNICODE_STRING Package)
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, DeletePackage );
    ULONG cbPrepackAvail = CBPREPACK;
    PUCHAR Where;

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"DeletePackage\n"));

    PREPARE_MESSAGE(ApiBuffer, DeletePackage);

    Where = ApiBuffer.ApiMessage.bData;

    SecpSecurityStringToLpc( &Args->Package, Package );
    if ( Package->Length <= cbPrepackAvail )
    {
        Args->Package.Buffer = (PWSTR_LPC) ((PUCHAR) Where - (PUCHAR) &ApiBuffer);
        RtlCopyMemory(  Where,
                        Package->Buffer,
                        Package->Length );

        Where += Package->Length ;
        cbPrepackAvail -= Package->Length ;
    }

    if ( cbPrepackAvail != CBPREPACK )
    {
        //
        // We have consumed some of the bData space:  Adjust 
        // our length accordingly
        //

        ApiBuffer.pmMessage.u1.s1.TotalLength = (CSHORT) (Where - (PUCHAR) &ApiBuffer) ;

        ApiBuffer.pmMessage.u1.s1.DataLength = 
                ApiBuffer.pmMessage.u1.s1.TotalLength - sizeof( PORT_MESSAGE );


        
    }

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"DeletePackage scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
    }

    FreeClient(pClient);

    return(scRet);

}

extern "C"
SECURITY_STATUS
SEC_ENTRY
SecpSetSession(
    ULONG   Request,
    ULONG_PTR Argument,
    PULONG_PTR  Response,
    PVOID * ResponsePtr
    )
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, SetSession );

    SEC_PAGED_CODE();

#ifdef BUILD_WOW64

    return SEC_E_UNSUPPORTED_FUNCTION ;

#else 

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"SetSession\n"));

    PREPARE_MESSAGE(ApiBuffer, SetSession);

    Args->Request = Request ;
    Args->Argument = Argument ;
    Args->Response = 0 ;
    Args->ResponsePtr = 0 ;

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"SetSession scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
    }

    if ( NT_SUCCESS( scRet ) )
    {
        if ( Response )
        {
            *Response = Args->Response ;
        }

        if ( ResponsePtr )
        {
            *ResponsePtr = Args->ResponsePtr ;
        }
    }

    FreeClient(pClient);

    return scRet ;
#endif 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\dll\ipaddr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-
//
//  File:       ipaddr.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6-06-02   JSchwart   Created
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"

#include <winsock2.h>
#include <ws2tcpip.h>
#include <wsipx.h>
#include <ws2atm.h>
}


//
// Make sure the IP address buffer in the LPC message is large
// enough to hold the different address types we care about.
//

C_ASSERT(LSAP_ADDRESS_LENGTH >= sizeof(SOCKADDR_IN));
C_ASSERT(LSAP_ADDRESS_LENGTH >= sizeof(SOCKADDR_IN6));
C_ASSERT(LSAP_ADDRESS_LENGTH >= sizeof(SOCKADDR_IPX));
//C_ASSERT(LSAP_ADDRESS_LENGTH >= sizeof(SOCKADDR_ATM));


SECURITY_STATUS SEC_ENTRY
SecpSetIPAddress(
    PUCHAR  lpIpAddress,
    ULONG   cchIpAddress
    )
{
    LPBYTE lpAddress;

    if (DllState & DLLSTATE_NO_TLS)
    {
        //
        // No TLS slot -- can't store IP addresses
        //

        return SEC_E_INSUFFICIENT_MEMORY;
    }

    if (cchIpAddress > LSAP_ADDRESS_LENGTH)
    {
        ASSERT(FALSE && "LSAP_ADDRESS_LENGTH too small for passed-in IP address");
        return SEC_E_INSUFFICIENT_MEMORY;
    }

    //
    // Fetch the buffer from the TLS slot, if present.
    // Allocate a new one if not.
    //

    lpAddress = (LPBYTE) SecGetIPAddress();

    if (lpAddress == NULL)
    {
        //
        // First call on this thread
        //

        lpAddress = (LPBYTE) LocalAlloc(LMEM_ZEROINIT, LSAP_ADDRESS_LENGTH * sizeof(CHAR));

        if (lpAddress == NULL)
        {
            return SEC_E_INSUFFICIENT_MEMORY;
        }

        //
        // Populate the TLS slot
        //

        SecSetIPAddress(lpAddress);
    }

    RtlCopyMemory(lpAddress, lpIpAddress, cchIpAddress);

    return SEC_E_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\dll\lsastubs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       lsastubs.cxx
//
//  Contents:   Stubs to the pseudo-sspi dll that talks to the LSA
//
//  Classes:
//
//  Functions:
//
//  History:    8-20-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <credp.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
#include <stddef.h>
}

SECURITY_STATUS SEC_ENTRY
LsaAcquireCredentialsHandleW(
    SEC_WCHAR SEC_FAR *         pszPrincipal,       // Name of principal
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    );

SECURITY_STATUS SEC_ENTRY
LsaAcquireCredentialsHandleA(
    SEC_CHAR SEC_FAR *         pszPrincipal,       // Name of principal
    SEC_CHAR SEC_FAR *         pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    );

SECURITY_STATUS SEC_ENTRY
LsaAddCredentialsW(
    PCredHandle hCredentials,
    SEC_WCHAR SEC_FAR * pszPrincipal,   // Name of principal
    SEC_WCHAR SEC_FAR * pszPackage,     // Name of package
    unsigned long fCredentialUse,       // Flags indicating use
    void SEC_FAR * pAuthData,           // Package specific data
    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
    PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    );

SECURITY_STATUS SEC_ENTRY
LsaAddCredentialsA(
    PCredHandle hCredentials,
    SEC_CHAR SEC_FAR * pszPrincipal,   // Name of principal
    SEC_CHAR SEC_FAR * pszPackage,     // Name of package
    unsigned long fCredentialUse,       // Flags indicating use
    void SEC_FAR * pAuthData,           // Package specific data
    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
    PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    );

SECURITY_STATUS SEC_ENTRY
LsaFreeCredentialsHandle(
    PCredHandle                 phCredential        // Handle to free
    );


SECURITY_STATUS SEC_ENTRY
LsaInitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_WCHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );

SECURITY_STATUS SEC_ENTRY
LsaInitializeSecurityContextA(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_CHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );

SECURITY_STATUS SEC_ENTRY
LsaInitializeSecurityContextCommon(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_WCHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry,          // (out) Life span (OPT)
    BOOLEAN                     fUnicode            // (in) Unicode call?
    );


SECURITY_STATUS SEC_ENTRY
LsaAcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );


SECURITY_STATUS SEC_ENTRY
LsaDeleteSecurityContext(
    PCtxtHandle                 phContext           // Context to delete
    );



SECURITY_STATUS SEC_ENTRY
LsaApplyControlToken(
    PCtxtHandle                 phContext,          // Context to modify
    PSecBufferDesc              pInput              // Input token to apply
    );


SECURITY_STATUS SEC_ENTRY
LsaEnumerateSecurityPackagesW(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoW SEC_FAR *      ppPackageInfo       // Receives array of info
    );

SECURITY_STATUS SEC_ENTRY
LsaEnumerateSecurityPackagesA(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoA SEC_FAR *      ppPackageInfo       // Receives array of info
    );


SECURITY_STATUS SEC_ENTRY
LsaQuerySecurityPackageInfoW(
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfoW *              ppPackageInfo       // Receives package info
    );

SECURITY_STATUS SEC_ENTRY
LsaQuerySecurityPackageInfoA(
    SEC_CHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfoA *              ppPackageInfo       // Receives package info
    );


SECURITY_STATUS SEC_ENTRY
LsaFreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    );


SECURITY_STATUS SEC_ENTRY
LsaQueryCredentialsAttributesW(
    PCredHandle phCredential,
    ULONG ulAttribute,
    PVOID pBuffer
    );

SECURITY_STATUS SEC_ENTRY
LsaQueryCredentialsAttributesA(
    PCredHandle phCredential,
    ULONG ulAttribute,
    PVOID pBuffer
    );


SECURITY_STATUS SEC_ENTRY
LsaCompleteAuthToken(
    PCtxtHandle                 phContext,          // Context to complete
    PSecBufferDesc              pToken              // Token to complete
    );


SECURITY_STATUS SEC_ENTRY
LsaImpersonateSecurityContext(
    PCtxtHandle                 phContext           // Context to impersonate
    );


SECURITY_STATUS SEC_ENTRY
LsaRevertSecurityContext(
    PCtxtHandle                 phContext           // Context from which to re
    );


SECURITY_STATUS SEC_ENTRY
LsaQueryContextAttributesW(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    );

SECURITY_STATUS SEC_ENTRY
LsaQueryContextAttributesA(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    );

SECURITY_STATUS SEC_ENTRY
LsaSetContextAttributesW(
    PCtxtHandle                 phContext,          // Context to Set
    unsigned long               ulAttribute,        // Attribute to Set
    void SEC_FAR *              pBuffer,            // Buffer for attributes
    unsigned long               cbBuffer            // Size (in bytes) of pBuffer
    );

SECURITY_STATUS SEC_ENTRY
LsaSetContextAttributesA(
    PCtxtHandle                 phContext,          // Context to Set
    unsigned long               ulAttribute,        // Attribute to Set
    void SEC_FAR *              pBuffer,            // Buffer for attributes
    unsigned long               cbBuffer            // Size (in bytes) of pBuffer
    );


SECURITY_STATUS SEC_ENTRY
LsaMakeSignature(
    PCtxtHandle         phContext,
    DWORD               fQOP,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo
    );

SECURITY_STATUS SEC_ENTRY
LsaVerifySignature(
    PCtxtHandle     phContext,
    PSecBufferDesc  pMessage,
    ULONG           MessageSeqNo,
    DWORD *         pfQOP
    );


SECURITY_STATUS SEC_ENTRY
LsaSealMessage(
    PCtxtHandle         phContext,
    DWORD               fQOP,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo
    );


SECURITY_STATUS SEC_ENTRY
LsaUnsealMessage(
    PCtxtHandle         phContext,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo,
    DWORD *             pfQOP
    );


SECURITY_STATUS
SEC_ENTRY
LsaQuerySecurityContextToken(
    PCtxtHandle                 phContext,
    PHANDLE                     TokenHandle
    );


SECURITY_STATUS
SEC_ENTRY
LsaExportContext(
    IN PCtxtHandle ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer MarshalledContext,
    OUT PHANDLE TokenHandle
    );

SECURITY_STATUS
SEC_ENTRY
LsaImportContextW(
    IN LPWSTR PackageName,
    IN PSecBuffer MarshalledContext,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
    );

SECURITY_STATUS
SEC_ENTRY
LsaImportContextA(
    IN LPSTR PackageName,
    IN PSecBuffer MarshalledContext,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
    );

static LUID            lFake = {0, 0};
static SECURITY_STRING sFake = {0, 0, NULL};
static SecBufferDesc EmptyBuffer;
BOOL LsaPackageShutdown ;

SecurityFunctionTableW LsaFunctionTable = {
    SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_2,
    LsaEnumerateSecurityPackagesW,
    LsaQueryCredentialsAttributesW,
    LsaAcquireCredentialsHandleW,
    LsaFreeCredentialsHandle,
    NULL,
    LsaInitializeSecurityContextW,
    LsaAcceptSecurityContext,
    LsaCompleteAuthToken,
    LsaDeleteSecurityContext,
    LsaApplyControlToken,
    LsaQueryContextAttributesW,
    LsaImpersonateSecurityContext,
    LsaRevertSecurityContext,
    LsaMakeSignature,
    LsaVerifySignature,
    FreeContextBuffer,
    LsaQuerySecurityPackageInfoW,
    LsaSealMessage,
    LsaUnsealMessage,
    LsaExportContext,
    LsaImportContextW,
    LsaAddCredentialsW,
    NULL,
    LsaQuerySecurityContextToken,
    LsaSealMessage,
    LsaUnsealMessage,
    LsaSetContextAttributesW
    };

SecurityFunctionTableA LsaFunctionTableA = {
    SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_2,
    NULL,                                       // NOTE: NEVER CALLED
    LsaQueryCredentialsAttributesA,
    LsaAcquireCredentialsHandleA,
    LsaFreeCredentialsHandle,
    NULL,
    LsaInitializeSecurityContextA,
    LsaAcceptSecurityContext,
    LsaCompleteAuthToken,
    LsaDeleteSecurityContext,
    LsaApplyControlToken,
    LsaQueryContextAttributesA,
    LsaImpersonateSecurityContext,
    LsaRevertSecurityContext,
    LsaMakeSignature,
    LsaVerifySignature,
    FreeContextBuffer,
    NULL,                                       // NOTE: NEVER CALLED
    LsaSealMessage,
    LsaUnsealMessage,
    LsaExportContext,
    LsaImportContextA,
    LsaAddCredentialsA,
    NULL,
    LsaQuerySecurityContextToken,
    LsaSealMessage,
    LsaUnsealMessage,
    LsaSetContextAttributesA
    };


//+---------------------------------------------------------------------------
//
//  Function:   LsapConvertUnicodeString
//
//  Synopsis:   Converts a Unicode string to an ANSI string for the stubs
//
//  Arguments:  [String] --
//
//  History:    9-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PSTR
LsapConvertUnicodeString(
    PUNICODE_STRING String)
{
    ANSI_STRING s;
    NTSTATUS Status;

    s.MaximumLength = String->MaximumLength ;

    s.Buffer = (PSTR) SecClientAllocate( s.MaximumLength );

    if ( s.Buffer )
    {
        s.Length = 0;

        Status = RtlUnicodeStringToAnsiString( &s, String, FALSE );

        if ( NT_SUCCESS( Status ) )
        {
            return( s.Buffer );
        }

        SecClientFree( s.Buffer );

    }

    return( NULL );
}


//+-------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandle
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaAcquireCredentialsHandleW(
    SEC_WCHAR SEC_FAR *          pszPrincipal,       // Name of principal
    SEC_WCHAR SEC_FAR *          pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    SECURITY_STRING Principal;
    SECURITY_STRING PackageName;
    SECURITY_STATUS scRet = S_OK;
    ULONG Flags ;
    SEC_HANDLE_LPC LocalCredHandle ;
#ifdef BUILD_WOW64
    PSECWOW_HANDLE_MAP MappedCredHandle ;
#endif

    if (!pszPackageName)
    {
        scRet = (HRESULT_FROM_NT(STATUS_INVALID_PARAMETER));
        goto Cleanup;
    }

    RtlInitUnicodeString(&PackageName, pszPackageName);
    if (!pszPrincipal || !(*pszPrincipal))
    {
        Principal = sFake;
    } else
    {
        RtlInitUnicodeString(&Principal, pszPrincipal);
    }

    Flags = 0;

    scRet = SecpAcquireCredentialsHandle(
                NULL,
                &Principal,
                &PackageName,
                fCredentialUse,
                (pvLogonId ? (PLUID) pvLogonId : &lFake),
                pAuthData,
                pGetKeyFn,
                pvGetKeyArgument,
                &LocalCredHandle,
                ptsExpiry,
                &Flags );


    if NT_SUCCESS( scRet )
    {

#ifdef BUILD_WOW64
        if ( !SecpAddHandleMap(
                    &LocalCredHandle,
                    &MappedCredHandle ) )
        {
            SecpFreeCredentialsHandle( 0, &LocalCredHandle );
            scRet = SEC_E_INSUFFICIENT_MEMORY ;
        }
        else
        {
            phCredential->dwUpper = (ULONG) MappedCredHandle ;
        }
#else

        *phCredential = LocalCredHandle ;

#endif

    }

Cleanup:
    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));

}

//+---------------------------------------------------------------------------
//
//  Function:   LsaAcquireCredentialsHandleA
//
//  Synopsis:   ANSI stub for AcquireCredentialsHandle
//
//  Arguments:  [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pvLogonId]        --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [pvGetKeyArgument] --
//              [phCredential]     --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    9-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaAcquireCredentialsHandleA(
    SEC_CHAR SEC_FAR *          pszPrincipal,       // Name of principal
    SEC_CHAR SEC_FAR *          pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    SECURITY_STRING Principal;
    SECURITY_STRING PackageName;
    SECURITY_STATUS scRet = S_OK;
    ULONG Flags;
    SEC_HANDLE_LPC LocalCredHandle ;
#ifdef BUILD_WOW64
    PSECWOW_HANDLE_MAP MappedCredHandle ;
#endif

    if (!pszPackageName)
    {
        scRet = ( HRESULT_FROM_NT(STATUS_INVALID_PARAMETER) );
        goto Cleanup;
    }

    if (!RtlCreateUnicodeStringFromAsciiz( &PackageName, pszPackageName ))
    {
        scRet = ( SEC_E_INSUFFICIENT_MEMORY );
        goto Cleanup;
    }

    if (!pszPrincipal || !(*pszPrincipal))
    {
        Principal = sFake;
    }
    else
    {
        if (!RtlCreateUnicodeStringFromAsciiz(&Principal, pszPrincipal) )
        {
            RtlFreeUnicodeString( &PackageName );

            scRet = (SEC_E_INSUFFICIENT_MEMORY) ;

            goto Cleanup;
        }
    }

    Flags = SPMAPI_FLAG_ANSI_CALL ;

    scRet = SecpAcquireCredentialsHandle(
                NULL,
                &Principal,
                &PackageName,
                fCredentialUse,
                (pvLogonId ? (PLUID) pvLogonId : &lFake),
                pAuthData,
                pGetKeyFn,
                pvGetKeyArgument,
                &LocalCredHandle,
                ptsExpiry,
                &Flags );

    RtlFreeUnicodeString( &PackageName );

    if ( Principal.Buffer )
    {
        RtlFreeUnicodeString( &Principal );
    }

    if NT_SUCCESS( scRet )
    {

#ifdef BUILD_WOW64
        if ( !SecpAddHandleMap(
                    &LocalCredHandle,
                    &MappedCredHandle ) )
        {
            SecpFreeCredentialsHandle( 0, &LocalCredHandle );
            scRet = SEC_E_INSUFFICIENT_MEMORY ;
        }
        else
        {
            phCredential->dwUpper = (ULONG) MappedCredHandle ;
        }
#else

        *phCredential = LocalCredHandle ;

#endif

    }

Cleanup:
    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));

}


//+---------------------------------------------------------------------------
//
//  Function:   LsaAddCredentialsW
//
//  Synopsis:   Stub for acquire credentials handle
//
//  Arguments:  [phCredential]     --
//              [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [GetKey]           --
//              [pvGetKeyArgument] --
//              [ptsExpiry]        --
//
//  History:    9-11-99   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
LsaAddCredentialsW(
    PCredHandle hCredentials,
    SEC_WCHAR SEC_FAR * pszPrincipal,   // Name of principal
    SEC_WCHAR SEC_FAR * pszPackage,     // Name of package
    unsigned long fCredentialUse,       // Flags indicating use
    void SEC_FAR * pAuthData,           // Package specific data
    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
    PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    )
{
    SECURITY_STRING Principal;
    SECURITY_STRING PackageName;
    SECURITY_STATUS scRet = S_OK;
    SEC_HANDLE_LPC LocalHandle ;
    ULONG Flags ;

    if (!pszPackage)
    {
        scRet = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    RtlInitUnicodeString(&PackageName, pszPackage);
    if (!pszPrincipal || !(*pszPrincipal))
    {
        Principal = sFake;
    }
    else
    {
        RtlInitUnicodeString(&Principal, pszPrincipal);
    }

    Flags = 0;

#ifdef BUILD_WOW64

    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    if (!SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) hCredentials->dwUpper,
            &LocalHandle))
    {
        scRet = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

#else
    LocalHandle = *hCredentials ;
#endif


    scRet = SecpAddCredentials(
                NULL,
                &LocalHandle,
                &Principal,
                &PackageName,
                fCredentialUse,
                pAuthData,
                pGetKeyFn,
                pvGetKeyArgument,
                ptsExpiry,
                &Flags );

#ifdef BUILD_WOW64
    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) hCredentials->dwUpper );
#endif

Cleanup:
    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}



//+---------------------------------------------------------------------------
//
//  Function:   LsaAddCredentialsA
//
//  Synopsis:   Stub for acquire credentials handle
//
//  Arguments:  [phCredential]     --
//              [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [GetKey]           --
//              [pvGetKeyArgument] --
//              [ptsExpiry]        --
//
//  History:    9-11-99   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
LsaAddCredentialsA(
    PCredHandle hCredentials,
    SEC_CHAR SEC_FAR * pszPrincipal,   // Name of principal
    SEC_CHAR SEC_FAR * pszPackage,     // Name of package
    unsigned long fCredentialUse,       // Flags indicating use
    void SEC_FAR * pAuthData,           // Package specific data
    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
    PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    )
{
    SECURITY_STRING Principal;
    SECURITY_STRING PackageName;
    SECURITY_STATUS scRet = S_OK;
    SEC_HANDLE_LPC LocalHandle ;
    ULONG Flags;

    if (!pszPackage)
    {
        scRet = ( HRESULT_FROM_NT(STATUS_INVALID_PARAMETER) );
        goto Cleanup;
    }

    if (!RtlCreateUnicodeStringFromAsciiz( &PackageName, pszPackage ))
    {
        scRet = ( SEC_E_INSUFFICIENT_MEMORY );
        goto Cleanup;
    }

    if (!pszPrincipal || !(*pszPrincipal))
    {
        Principal = sFake;
    }
    else
    {
        if (!RtlCreateUnicodeStringFromAsciiz(&Principal, pszPrincipal) )
        {
            RtlFreeUnicodeString( &PackageName );

            scRet = (SEC_E_INSUFFICIENT_MEMORY) ;

            goto Cleanup;
        }
    }

    Flags = SPMAPI_FLAG_ANSI_CALL ;

#ifdef BUILD_WOW64

    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    if (!SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) hCredentials->dwUpper,
            &LocalHandle))
    {
        scRet = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

#else
    LocalHandle = *hCredentials ;
#endif

    scRet = SecpAddCredentials(
                NULL,
                &LocalHandle,
                &Principal,
                &PackageName,
                fCredentialUse,
                pAuthData,
                pGetKeyFn,
                pvGetKeyArgument,
                ptsExpiry,
                &Flags );

    RtlFreeUnicodeString( &PackageName );

    if ( Principal.Buffer )
    {
        RtlFreeUnicodeString( &Principal );
    }

#ifdef BUILD_WOW64
    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) hCredentials->dwUpper );
#endif

Cleanup:

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}



//+-------------------------------------------------------------------------
//
//  Function:   FreeCredentialsHandle
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaFreeCredentialsHandle(
    PCredHandle                 phCredential        // Handle to free
    )
{
    SECURITY_STATUS scRet;
    SEC_HANDLE_LPC LocalHandle ;


#ifdef BUILD_WOW64
    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    if (!SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) phCredential->dwUpper,
            &LocalHandle))
    {
        scRet = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

#else

    LocalHandle = *phCredential ;

#endif

    scRet = SecpFreeCredentialsHandle(0, &LocalHandle);

#ifdef BUILD_WOW64
    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phCredential->dwUpper );

    SecpDeleteHandleMap( (PSECWOW_HANDLE_MAP) phCredential->dwUpper );
#endif

#ifdef BUILD_WOW64

Cleanup:

#endif

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaQueryCredentialsAttributesW
//
//  Synopsis:   Stub to LSA for querycredentialsattributes
//
//  Effects:
//
//  Arguments:  [phCredential] --
//              [ulAttribute]  --
//              [pBuffer]      --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaQueryCredentialsAttributesW(
    PCredHandle phCredential,
    ULONG ulAttribute,
    PVOID pBuffer)
{
    SECURITY_STATUS scRet ;
    PSecPkgCredentials_Names CredNames;
    PVOID Buffers[ MAX_BUFFERS_IN_CALL ];
    ULONG Allocs ;
    SEC_HANDLE_LPC LocalHandle ;

    Allocs = 0 ;

#ifdef BUILD_WOW64
    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    if (!SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) phCredential->dwUpper,
            &LocalHandle))
    {
        scRet = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

#else
    LocalHandle = *phCredential ;
#endif

    scRet = SecpQueryCredentialsAttributes(
                    &LocalHandle,
                    ulAttribute,
                    pBuffer,
                    0,
                    &Allocs,
                    Buffers );

#ifdef BUILD_WOW64
    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phCredential->dwUpper );

Cleanup:

#endif

    if ( NT_SUCCESS( scRet ) )
    {
        ULONG i ;

        for ( i = 0 ; i < Allocs ; i++ )
        {
            SecpAddVM( Buffers[ i ] );
        }
    }
    else
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}

//+---------------------------------------------------------------------------
//
//  Function:   LsaQueryCredentialsAttributesA
//
//  Synopsis:   ANSI stub for QueryCredentialsAttributes
//
//  Arguments:  [phCredential] --
//              [ulAttribute]  --
//              [pBuffer]      --
//
//  History:    9-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaQueryCredentialsAttributesA(
    PCredHandle phCredential,
    ULONG ulAttribute,
    PVOID pBuffer)
{
    SECURITY_STATUS scRet ;
    PSecPkgCredentials_NamesW CredNamesW;
    PSTR Str;
    UNICODE_STRING Name;
    PVOID Buffers[ MAX_BUFFERS_IN_CALL ];
    ULONG Allocs ;
    ULONG i ;
    SEC_HANDLE_LPC LocalHandle ;

    Allocs = 0 ;

#ifdef BUILD_WOW64
    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    if (!SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) phCredential->dwUpper,
            &LocalHandle))
    {
        scRet = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

#else
    LocalHandle = *phCredential ;
#endif

    scRet = SecpQueryCredentialsAttributes(
                    &LocalHandle,
                    ulAttribute,
                    pBuffer,
                    SPMAPI_FLAG_ANSI_CALL,
                    &Allocs,
                    Buffers );
#ifdef BUILD_WOW64
    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phCredential->dwUpper );
#endif


    if ( NT_SUCCESS( scRet ) )
    {
        switch ( ulAttribute )
        {
            case SECPKG_CRED_ATTR_NAMES:

                CredNamesW = (PSecPkgCredentials_NamesW) pBuffer ;

                RtlInitUnicodeString( &Name, CredNamesW->sUserName );

                Str = LsapConvertUnicodeString( &Name );

                LsaFreeReturnBuffer( CredNamesW->sUserName );

                if ( Str )
                {
                    CredNamesW->sUserName = (PWSTR) Str ;
                }
                else
                {
                    CredNamesW->sUserName = NULL ;

                    scRet = SEC_E_INSUFFICIENT_MEMORY ;
                }

                break;

            default:

                for ( i = 0 ; i < Allocs ; i++ )
                {
                    SecpAddVM( Buffers[ i ] );
                }

                break;
        }
    }

#ifdef BUILD_WOW64

Cleanup:

#endif

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}


//+-------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaInitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_WCHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return LsaInitializeSecurityContextCommon(
                    phCredential,       // Cred to base context
                    phContext,          // Existing context (OPT)
                    pszTargetName,      // Name of target
                    fContextReq,        // Context Requirements
                    Reserved1,          // Reserved, MBZ
                    TargetDataRep,      // Data rep of target
                    pInput,             // Input Buffers
                    Reserved2,          // Reserved, MBZ
                    phNewContext,       // (out) New Context handle
                    pOutput,            // (inout) Output Buffers
                    pfContextAttr,      // (out) Context attrs
                    ptsExpiry,          // (out) Life span (OPT)
                    TRUE                // Unicode caller
                    );
}

//+---------------------------------------------------------------------------
//
//  Function:   LsaInitializeSecurityContextA
//
//  Synopsis:   ANSI stub for InitializeSecurityContext
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pszTargetName] --
//              [fContextReq]   --
//              [Reserved1]     --
//              [TargetDataRep] --
//              [pInput]        --
//              [Reserved2]     --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//
//  History:    9-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaInitializeSecurityContextA(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_CHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return LsaInitializeSecurityContextCommon(
                    phCredential,       // Cred to base context
                    phContext,          // Existing context (OPT)
                    (SEC_WCHAR SEC_FAR *)pszTargetName,
                    fContextReq,        // Context Requirements
                    Reserved1,          // Reserved, MBZ
                    TargetDataRep,      // Data rep of target
                    pInput,             // Input Buffers
                    Reserved2,          // Reserved, MBZ
                    phNewContext,       // (out) New Context handle
                    pOutput,            // (inout) Output Buffers
                    pfContextAttr,      // (out) Context attrs
                    ptsExpiry,          // (out) Life span (OPT)
                    FALSE               // NOT Unicode
                    );

}

SECURITY_STATUS SEC_ENTRY
LsaInitializeSecurityContextCommon(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_WCHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry,          // (out) Life span (OPT)
    BOOLEAN                     fUnicode            // (in) Unicode call?
    )
{
    SECURITY_STATUS scRet = S_OK;
    SECURITY_STRING Target;
    CredHandle hCredential;
    SecBuffer ContextData = {0,0,NULL};
    BOOLEAN MappedContext = FALSE;
    CtxtHandle NullContext = {0,0};
    ULONG i;
    ULONG Flags;
    SEC_HANDLE_LPC LocalCred = { 0 };
    SEC_HANDLE_LPC LocalContext = { 0 };
    SEC_HANDLE_LPC LocalNewContext;

#ifdef BUILD_WOW64
    PSECWOW_HANDLE_MAP HandleMap = NULL;
    BOOL DerefCred = FALSE ;
    BOOL DerefContext = FALSE ;
#endif

    SecInvalidateHandle(&LocalNewContext);

    //
    // They need to provide at least one of these two
    //

    if (!phCredential && !phContext)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

    //
    // Check for valid sizes, pointers, etc.:
    //

    if (!ARGUMENT_PRESENT(phContext))
    {
        phContext = &NullContext;
    }
    else
    {
#ifdef BUILD_WOW64

        if (!SecpReferenceHandleMap(
                (PSECWOW_HANDLE_MAP) phContext->dwUpper,
                &LocalContext ))
        {
            scRet = SEC_E_INVALID_HANDLE;
            goto Cleanup;
        }

        DerefContext = TRUE ;
#else
        LocalContext = *phContext ;
#endif
    }

    if (!ARGUMENT_PRESENT(pInput))
    {
        pInput = &EmptyBuffer;
    }

    if (!ARGUMENT_PRESENT(pOutput))
    {
        pOutput = &EmptyBuffer;
    }

    if (!ARGUMENT_PRESENT(phCredential))
    {
        //
        // Since the package is keyed off the upper part, we need to set
        // it.
        //

        hCredential.dwLower = phContext->dwLower;
        hCredential.dwUpper = 0;
        phCredential = &hCredential;

        LocalCred.dwLower = phContext->dwLower ;

    }
    else
    {
#ifdef BUILD_WOW64

        if (!SecpReferenceHandleMap(
                (PSECWOW_HANDLE_MAP) phCredential->dwUpper,
                &LocalCred))
        {
            scRet = SEC_E_INVALID_HANDLE;
            goto Cleanup;
        }

        DerefCred = TRUE ;
#else
        LocalCred = *phCredential ;
#endif
    }

    if( !fUnicode )
    {
        if ( !RtlCreateUnicodeStringFromAsciiz(
                    &Target,
                    (SEC_CHAR SEC_FAR *)pszTargetName
                    ))
        {
            scRet = SEC_E_INSUFFICIENT_MEMORY ;

            goto Cleanup;
        }

        Flags = SPMAPI_FLAG_ANSI_CALL ;
    }
    else
    {
        RtlInitUnicodeString( &Target, pszTargetName );
        Flags = 0;
    }

    if ( (fContextReq & ISC_REQ_ALLOCATE_MEMORY ) && pOutput )
    {
        for (i = 0; i < pOutput->cBuffers; i++)
        {
            if ( pOutput->pBuffers[i].BufferType == SECBUFFER_TOKEN )
            {
                pOutput->pBuffers[i].pvBuffer = NULL;
                pOutput->pBuffers[i].cbBuffer = 0;
            }
        }
    }

    *pfContextAttr = 0;

    scRet = SecpInitializeSecurityContext(
        NULL,
        &LocalCred,
        &LocalContext,
        &Target,
        fContextReq,
        Reserved1,
        TargetDataRep,
        pInput,
        Reserved2,
        &LocalNewContext,
        pOutput,
        pfContextAttr,
        ptsExpiry,
        &MappedContext,
        &ContextData,
        &Flags
        );

    if ( !fUnicode )
    {
        RtlFreeUnicodeString( &Target );
    }

#ifdef BUILD_WOW64

    if ( DerefCred )
    {
        SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phCredential->dwUpper );
    }

    if ( DerefContext )
    {
        if ( (Flags & SPMAPI_FLAG_HANDLE_CHG ) != 0 )
        {
            SecpDeleteHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
        }

        SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
    }

    if ( NT_SUCCESS( scRet ) )
    {
        if ( !(RtlEqualMemory( &LocalNewContext,
                               &LocalContext,
                               sizeof( SEC_HANDLE_LPC ) ) ) )
        {
            if ( SecpAddHandleMap( &LocalNewContext,
                                    &HandleMap ) )
            {
                phNewContext->dwLower = (LSA_SEC_HANDLE) LocalNewContext.dwLower ;
                phNewContext->dwUpper = (LSA_SEC_HANDLE) HandleMap ;
            }
            else
            {
                //
                // BUGBUG - not sure.  Need to clean out the
                // context data with a fake SECWOW_HANDLE_MAP
                //
                scRet = SEC_E_INSUFFICIENT_MEMORY ;
            }
        }
        else
        {
            *phNewContext = *phContext ;
            HandleMap = (PSECWOW_HANDLE_MAP) phContext->dwUpper ;
        }
    }
#else
    *phNewContext = LocalNewContext ;
#endif
    if (NT_SUCCESS(scRet) && MappedContext)
    {
        PDLL_SECURITY_PACKAGE   pspPackage ;
        PCtxtHandle     ContextHandle;
        SECURITY_STATUS SecondaryStatus;

        if ( (phContext != &NullContext) &&
             ((Flags & SPMAPI_FLAG_HANDLE_CHG) == 0) )
        {
            ContextHandle = phContext;
        }
        else
        {
            ContextHandle = phNewContext;
        }

#ifdef BUILD_WOW64
        ContextHandle->dwUpper = (LSA_SEC_HANDLE) HandleMap ;
        ContextHandle->dwLower = (LSA_SEC_HANDLE) LocalNewContext.dwLower ;
#else
        *ContextHandle = LocalNewContext ;
#endif
        pspPackage = SecLocatePackageById( ContextHandle->dwLower );
        if ((pspPackage != NULL)  && (pspPackage->pftUTable != NULL))
        {
            SecpAddVM( ContextData.pvBuffer );

            SecondaryStatus = pspPackage->pftUTable->InitUserModeContext(
                                ContextHandle->dwUpper,
                                &ContextData
                                );

            if (!NT_SUCCESS(SecondaryStatus))
            {
                scRet = SecondaryStatus;

                //
                // If the client didn't already have a handle to the context,
                // delete it now
                //

                if (phContext == &NullContext)
                {
                    (VOID) LsaDeleteSecurityContext( ContextHandle );
                    SecInvalidateHandle( ContextHandle );
                }
                //
                // Patch up handle so DeleteSecurityContext works right
                //
                else
                {
                    ContextHandle->dwLower = (ULONG_PTR) pspPackage;
                }

            }
        }
        else
        {
            if ( (phContext != &NullContext) // not the first call
                 && (Flags & SPMAPI_FLAG_HANDLE_CHG) != 0 )
            {
                DebugLog((DEB_ERROR, "LsaInitializeSecurityContextCommon failed to locate package %p : %p, deleting handle\n",
                    ContextHandle->dwUpper, ContextHandle->dwLower));

                (VOID) LsaDeleteSecurityContext( phNewContext );
                SecInvalidateHandle( phNewContext );
            }

            scRet = SEC_E_INVALID_HANDLE;
        }
    }

    if ( !NT_ERROR( scRet ) && (*pfContextAttr & ISC_RET_ALLOCATED_MEMORY ) && pOutput )
    {
        for (i = 0; i < pOutput->cBuffers; i++)
        {
            if ( pOutput->pBuffers[i].BufferType == SECBUFFER_TOKEN )
            {
                SecpAddVM( pOutput->pBuffers[i].pvBuffer );
            }
        }
    }
    else
    {
        if ( (fContextReq & ASC_REQ_ALLOCATE_MEMORY ) && pOutput )
        {
            for (i = 0; i < pOutput->cBuffers; i++)
            {
                if ( (pOutput->pBuffers[i].BufferType == SECBUFFER_TOKEN) && pOutput->pBuffers[i].pvBuffer )
                {
                    LsaFreeReturnBuffer( pOutput->pBuffers[i].pvBuffer );
                    pOutput->pBuffers[i].cbBuffer = 0;
                    pOutput->pBuffers[i].pvBuffer = NULL;
                }
            }
        }
    }

Cleanup:

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}

//+-------------------------------------------------------------------------
//
//  Function:   AcceptSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaAcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    SECURITY_STATUS scRet = S_OK;
    SecBufferDesc EmptyBuffer;
    CredHandle hCredential;
    SecBuffer ContextData = {0,0,NULL};
    BOOLEAN MappedContext = FALSE;
    CtxtHandle NullContext = {0,0};
    ULONG i;
    ULONG Flags;
    SEC_HANDLE_LPC LocalCred = { 0 };
    SEC_HANDLE_LPC LocalContext = { 0 };
    SEC_HANDLE_LPC LocalNewContext;
    LPBYTE lpAddress;

#ifdef BUILD_WOW64
    PSECWOW_HANDLE_MAP HandleMap = NULL;
    BOOL DerefCred = FALSE ;
    BOOL DerefContext = FALSE ;
#endif

    SecInvalidateHandle(&LocalNewContext);

    //
    // They need to provide at least one of these two
    //

    if (!ARGUMENT_PRESENT(phCredential) && !ARGUMENT_PRESENT(phContext))
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

    //
    // No user mode caller of sspi should be using this flag
    //

    if ( fContextReq & ASC_REQ_ALLOW_NULL_SESSION)
    {
        scRet = SEC_E_NOT_SUPPORTED;
        goto Cleanup;
    }

    if (!ARGUMENT_PRESENT(pInput))
    {
        pInput = &EmptyBuffer;
        RtlZeroMemory(pInput,sizeof(SecBufferDesc));
    }

    if (!ARGUMENT_PRESENT(pOutput))

    {
        pOutput = &EmptyBuffer;
        RtlZeroMemory(pOutput,sizeof(SecBufferDesc));
    }

    if (!ARGUMENT_PRESENT(phContext))
    {
        phContext = &NullContext;
    }
    else
    {
#ifdef BUILD_WOW64

        if (!SecpReferenceHandleMap(
                (PSECWOW_HANDLE_MAP) phContext->dwUpper,
                &LocalContext ))
        {
            scRet = SEC_E_INVALID_HANDLE;
            goto Cleanup;
        }

        DerefContext = TRUE ;
#else
        LocalContext = *phContext ;
#endif
    }

    if (!ARGUMENT_PRESENT(phCredential))
    {

        //
        // Since the package is keyed off the upper part, we need to set
        // it.
        //

        hCredential.dwLower = phContext->dwLower;
        hCredential.dwUpper = 0;
        phCredential = &hCredential;

        LocalCred.dwLower = LocalContext.dwLower ;
    }
    else
    {
#ifdef BUILD_WOW64

        if (!SecpReferenceHandleMap(
                (PSECWOW_HANDLE_MAP) phCredential->dwUpper,
                &LocalCred))
        {
            scRet = SEC_E_INVALID_HANDLE;
            goto Cleanup;
        }

        DerefCred = TRUE ;
#else
        LocalCred = *phCredential ;
#endif
    }

    if ( (fContextReq & ASC_REQ_ALLOCATE_MEMORY ) && pOutput )
    {
        for (i = 0; i < pOutput->cBuffers; i++)
        {
            if ( pOutput->pBuffers[i].BufferType == SECBUFFER_TOKEN )
            {
                pOutput->pBuffers[i].pvBuffer = NULL;
                pOutput->pBuffers[i].cbBuffer = 0;
            }
        }
    }

    Flags = 0;
    *pfContextAttr = 0;

    lpAddress = (LPBYTE) SecGetIPAddress();

    scRet = SecpAcceptSecurityContext(
                NULL,
                &LocalCred,
                &LocalContext,
                pInput,
                fContextReq,
                TargetDataRep,
                &LocalNewContext,
                pOutput,
                pfContextAttr,
                ptsExpiry,
                &MappedContext,
                &ContextData,
                &Flags,
                lpAddress);

    if (lpAddress != NULL)
    {
        RtlZeroMemory(lpAddress, LSAP_ADDRESS_LENGTH);
    }

#ifdef BUILD_WOW64

    if ( DerefCred )
    {
        SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phCredential->dwUpper );
    }


    if ( DerefContext )
    {
        if ( (Flags & SPMAPI_FLAG_HANDLE_CHG ) != 0 )
        {
            SecpDeleteHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
        }
        SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
    }

    if ( NT_SUCCESS( scRet ) )
    {
        if ( !(RtlEqualMemory( &LocalNewContext,
                               &LocalContext,
                               sizeof( SEC_HANDLE_LPC ) ) ) )
        {
            if ( SecpAddHandleMap( &LocalNewContext,
                                    &HandleMap ) )
            {
                phNewContext->dwLower = (LSA_SEC_HANDLE) LocalNewContext.dwLower ;
                phNewContext->dwUpper = (LSA_SEC_HANDLE) HandleMap ;
            }
            else
            {
                scRet = SEC_E_INSUFFICIENT_MEMORY ;
            }
        }
        else
        {
            *phNewContext = *phContext ;
            HandleMap = (PSECWOW_HANDLE_MAP) phContext->dwUpper ;
        }
    }
#else
    *phNewContext = LocalNewContext ;
#endif

    if (NT_SUCCESS(scRet) && MappedContext)
    {
        PDLL_SECURITY_PACKAGE pspPackage;
        PCtxtHandle     ContextHandle;
        SECURITY_STATUS SecondaryStatus;

        if ( (phContext != &NullContext) &&
             ((Flags & SPMAPI_FLAG_HANDLE_CHG) == 0) )
        {
            ContextHandle = phContext;
        }
        else
        {
            ContextHandle = phNewContext;
        }

#ifdef BUILD_WOW64
        ContextHandle->dwUpper = (LSA_SEC_HANDLE) HandleMap ;
        ContextHandle->dwLower = (LSA_SEC_HANDLE) LocalNewContext.dwLower ;
#else
        *ContextHandle = LocalNewContext ;
#endif

        pspPackage = SecLocatePackageById( ContextHandle->dwLower );

        if ((pspPackage != NULL)  && (pspPackage->pftUTable != NULL))
        {
            SecpAddVM( ContextData.pvBuffer );

            SecondaryStatus = pspPackage->pftUTable->InitUserModeContext(
                                ContextHandle->dwUpper,
                                &ContextData
                                );
            if (!NT_SUCCESS( SecondaryStatus ))
            {

                scRet = SecondaryStatus;

                //
                // If the client didn't already have a handle to the context,
                // delete it now
                //

                if (phContext == &NullContext)
                {
                    (VOID) LsaDeleteSecurityContext( ContextHandle );
                    SecInvalidateHandle( ContextHandle );
                }

                //
                // Patch up handle so DeleteSecurityContext works right
                //

                else
                {
                    ContextHandle->dwLower = (ULONG_PTR) pspPackage;
                }
            }
        }
        else
        {
            if ( (phContext != &NullContext) // not the first call
                 && (Flags & SPMAPI_FLAG_HANDLE_CHG) != 0 )
            {
                DebugLog((DEB_ERROR, "LsaAcceptSecurityContext failed to locate package %p : %p, deleting handle\n",
                    ContextHandle->dwUpper, ContextHandle->dwLower));

                (VOID) LsaDeleteSecurityContext( phNewContext );
                SecInvalidateHandle( phNewContext );
            }

            scRet = SEC_E_INVALID_HANDLE;
        }
    }

    if ( !NT_ERROR( scRet ) && (*pfContextAttr & ASC_RET_ALLOCATED_MEMORY ) && pOutput )
    {
        for (i = 0; i < pOutput->cBuffers; i++)
        {
            if ( pOutput->pBuffers[i].BufferType == SECBUFFER_TOKEN )
            {
                SecpAddVM( pOutput->pBuffers[i].pvBuffer );
            }
        }
    }
    else
    {
        if ( (fContextReq & ASC_REQ_ALLOCATE_MEMORY ) && pOutput )
        {
            for (i = 0; i < pOutput->cBuffers; i++)
            {
                if ( (pOutput->pBuffers[i].BufferType == SECBUFFER_TOKEN) && pOutput->pBuffers[i].pvBuffer )
                {
                    LsaFreeReturnBuffer( pOutput->pBuffers[i].pvBuffer );
                    pOutput->pBuffers[i].cbBuffer = 0;
                    pOutput->pBuffers[i].pvBuffer = NULL;
                }
            }
        }
    }

Cleanup:

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}

//+-------------------------------------------------------------------------
//
//  Function:   DeleteSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaDeleteSecurityContext(
    PCtxtHandle                 phContext           // Context to delete
    )
{
    SECURITY_STATUS     scRet = S_OK;
    SEC_HANDLE_LPC LocalHandle ;

    // For now, just delete the LSA context:

    if (!phContext)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        scRet = SEC_E_SECPKG_NOT_FOUND ;
        goto Cleanup ;
    }

    // If the package returned SEC_I_NO_LSA_CONTEXT, do not call
    // SecpDeleteSecurityContext and return Success. This happens when this
    // context is imported and therefore no LSA counterpart exists.

    if (DeleteUserModeContext(phContext) == SEC_I_NO_LSA_CONTEXT)
    {
        scRet = (S_OK);
        goto Cleanup;
    }

#ifdef BUILD_WOW64
    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    if (!SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) phContext->dwUpper,
            &LocalHandle))
    {
        scRet = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

#else
    LocalHandle = *phContext ;
#endif

    scRet = SecpDeleteSecurityContext(
                0,      // block while deleting
                &LocalHandle
                );

#ifdef BUILD_WOW64

    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );

    SecpDeleteHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );

#endif

Cleanup:

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}


//+-------------------------------------------------------------------------
//
//  Function:   ApplyControlToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaApplyControlToken(
    PCtxtHandle                 phContext,          // Context to modify
    PSecBufferDesc              pInput              // Input token to apply
    )
{
    SECURITY_STATUS     scRet = S_OK;
    SEC_HANDLE_LPC  LocalHandle ;

    if (!phContext)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

#ifdef BUILD_WOW64
    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    if (!SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) phContext->dwUpper,
            &LocalHandle))
    {
        scRet = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

#else

    LocalHandle = *phContext ;

#endif


    if (SUCCEEDED(scRet))
    {
        scRet = SecpApplyControlToken(  &LocalHandle,
                                        pInput);
    }

#ifdef BUILD_WOW64

    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );

#endif

Cleanup:

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}


//+-------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackage
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaEnumerateSecurityPackagesW(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoW SEC_FAR *      ppPackageInfo       // Receives array of info
    )
{
    SECURITY_STATUS scRet = S_OK;

    *ppPackageInfo = NULL;

    scRet = SecpEnumeratePackages(pcPackages, ppPackageInfo);

    if ( NT_SUCCESS( scRet ) )
    {
        SecpAddVM( *ppPackageInfo );
    }
    else if (*ppPackageInfo)
    {
        LsaFreeReturnBuffer(*ppPackageInfo);
        *ppPackageInfo = NULL;
    }

    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfo
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaQuerySecurityPackageInfoW(
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfo *               ppPackageInfo       // Receives package info
    )
{
    SECURITY_STATUS scRet = S_OK;
    SECURITY_STRING ssPackage;

    RtlInitUnicodeString(&ssPackage, pszPackageName);

    *ppPackageInfo = NULL;

    scRet = SecpQueryPackageInfo(&ssPackage, ppPackageInfo);

    if ( NT_SUCCESS( scRet ) )
    {
        SecpAddVM( *ppPackageInfo );
    }
    else if (*ppPackageInfo)
    {
        LsaFreeReturnBuffer(*ppPackageInfo);
        *ppPackageInfo = NULL;
    }

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}


//+-------------------------------------------------------------------------
//
//  Function:   FreeContextBuffer
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaFreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    )
{
    if ( SecpFreeVM( pvContextBuffer ) )
    {
        DebugLog(( DEB_TRACE, "Freeing VM %p\n", pvContextBuffer ));

        LsaFreeReturnBuffer( pvContextBuffer );
    }
    else
    {
        LocalFree( pvContextBuffer );
    }

    return( SEC_E_OK );
}


//+-------------------------------------------------------------------------
//
//  Function:   CompleteAuthToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaCompleteAuthToken(
    PCtxtHandle                 phContext,          // Context to complete
    PSecBufferDesc              pToken              // Token to complete
    )
{
    PDLL_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRet;

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (pPackage == NULL)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

    if ((pPackage->pftUTable != NULL) && (pPackage->pftUTable->CompleteAuthToken != NULL))
    {
        scRet = pPackage->pftUTable->CompleteAuthToken(
                                phContext->dwUpper,
                                pToken);
    }
    else
    {
        scRet = SEC_E_UNSUPPORTED_FUNCTION;
    }

Cleanup:

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}


//+-------------------------------------------------------------------------
//
//  Function:   ImpersonateSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaImpersonateSecurityContext(
    PCtxtHandle                 phContext           // Context to impersonate
    )
{
    PDLL_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRet;
    HANDLE          hToken;

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    if (pPackage->pftUTable == NULL)
    {
        return(SEC_E_UNSUPPORTED_FUNCTION);
    }

    scRet = pPackage->pftUTable->GetContextToken(phContext->dwUpper, &hToken);

    if (FAILED(scRet))
    {
        goto Cleanup;
    }

    DebugLog((DEB_TRACE, "Impersonating %ws[%p]\n",
                    pPackage->PackageName.Buffer, phContext->dwUpper));

    scRet = NtSetInformationThread( NtCurrentThread(),
                                    ThreadImpersonationToken,
                                    (PVOID) &hToken,
                                    sizeof(hToken) );

    if (FAILED(scRet))
    {
        DebugLog((DEB_ERROR, "Failed to impersonate handle %p, return %x\n",
                    hToken, scRet));
    }

Cleanup:

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));

        if ( scRet == STATUS_PRIVILEGE_NOT_HELD )
        {
            return SEC_E_NO_IMPERSONATION ;
            
        }
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}


//+-------------------------------------------------------------------------
//
//  Function:   RevertSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaRevertSecurityContext(
    PCtxtHandle                 phContext           // Context from which to re
    )
{
    PDLL_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRet;
    HANDLE          hToken = NULL;

#if DBG
    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        return(SEC_E_INVALID_HANDLE);
    }
#endif

    scRet = NtSetInformationThread( NtCurrentThread(),
                                    ThreadImpersonationToken,
                                    (PVOID) &hToken,
                                    sizeof(hToken) );

    if (FAILED(scRet))
    {
        DebugLog((DEB_ERROR, "Failed to revert handle %p, return %x\n",
                    hToken, scRet));
    }

    return(scRet);
}

//+-------------------------------------------------------------------------
//
//  Function:   QuerySecurityContextToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaQuerySecurityContextToken(
    PCtxtHandle                 phContext,
    PHANDLE                     TokenHandle
    )
{
    PDLL_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRet;
    HANDLE          hToken = NULL ;

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    if ((pPackage->pftUTable != NULL) && (pPackage->pftUTable->GetContextToken != NULL))
    {
        scRet = pPackage->pftUTable->GetContextToken( phContext->dwUpper,
                                                      &hToken);
    }
    else
    {
        scRet = SEC_E_UNSUPPORTED_FUNCTION;
    }

    if (NT_SUCCESS(scRet))
    {
        if (hToken != NULL)
        {
            //
            // Duplicate the token so the caller may hold onto it after
            // deleting the context
            //

            scRet = NtDuplicateObject(
                        NtCurrentProcess(),
                        hToken,
                        NtCurrentProcess(),
                        TokenHandle,
                        0,                  // desired access
                        0,                  // handle attributes
                        DUPLICATE_SAME_ACCESS
                        );
        }
        else
        {
            scRet = SEC_E_NO_IMPERSONATION;
        }
    }

Cleanup:

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}


//+---------------------------------------------------------------------------
//
//  Function:   QueryContextAttributesW
//
//  Synopsis:   Get context attributes
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [attributes]  --
//
//  History:    8-05-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaQueryContextAttributesW(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    PDLL_SECURITY_PACKAGE     pPackage;
    PDLL_LSA_PACKAGE_INFO   LsaInfo ;
    SECURITY_STATUS scRet = SEC_E_OK;
    PSecPkgContext_NegotiationInfoW pNegInfo ;
    ULONG                   i ;
    BOOL                    Thunked = FALSE ;
    ULONG Allocs ;
    PVOID Buffers[ MAX_BUFFERS_IN_CALL ];
    SEC_HANDLE_LPC LocalHandle ;
    ULONG Flags = 0;

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

    LsaInfo = pPackage->LsaInfo ;

    if ( LsaInfo->ContextThunkCount )
    {
        Allocs = 0 ;

        //
        // This package wants some of the context attr calls to be thunked to
        // the LSA.  help them out:
        //

        if ( LsaInfo->ContextThunks[ 0 ] == SECPKG_ATTR_THUNK_ALL )
        {

            Allocs = MAX_BUFFERS_IN_CALL ;
#ifdef BUILD_WOW64
            //
            // If this points to bogus data, we're ok.  The LSA will
            // reject it.
            //

            if (!SecpReferenceHandleMap(
                    (PSECWOW_HANDLE_MAP) phContext->dwUpper,
                    &LocalHandle))
            {
                scRet = SEC_E_INVALID_HANDLE;
                goto Cleanup;
            }
#else
            LocalHandle = *phContext ;
#endif

            scRet = SecpQueryContextAttributes(
                        NULL,
                        &LocalHandle,
                        ulAttribute,
                        pBuffer,
                        &Allocs,
                        Buffers,
                        &Flags );

#ifdef BUILD_WOW64
            SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
#endif
            Thunked = TRUE ;
        }
        else
        {
            for ( i = 0 ; i < LsaInfo->ContextThunkCount ; i++)
            {
                if ( LsaInfo->ContextThunks[ i ] == ulAttribute )
                {
                    Allocs = MAX_BUFFERS_IN_CALL ;
#ifdef BUILD_WOW64
                    //
                    // If this points to bogus data, we're ok.  The LSA will
                    // reject it.
                    //

                    if (!SecpReferenceHandleMap(
                            (PSECWOW_HANDLE_MAP) phContext->dwUpper,
                            &LocalHandle))
                    {
                        scRet = SEC_E_INVALID_HANDLE;
                        goto Cleanup;
                    }
#else
                    LocalHandle = *phContext ;
#endif
                    scRet = SecpQueryContextAttributes(
                                NULL,
                                &LocalHandle,
                                ulAttribute,
                                pBuffer,
                                &Allocs,
                                Buffers,
                                &Flags );

#ifdef BUILD_WOW64
                    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
#endif
                    Thunked = TRUE ;
                    break;
                }
            }
        }

        //
        // If the package allocated memory in our address space,
        // add it to the VM list so it can be freed correctly.
        //

        for ( i = 0 ; i < Allocs ; i++ )
        {
            SecpAddVM( Buffers[ i ] );
        }
    }

    if ( !Thunked )
    {
        if ((pPackage->pftUTable != NULL) &&
            (pPackage->pftUTable->QueryContextAttributes != NULL))
        {
            scRet = pPackage->pftUTable->QueryContextAttributes(
                        phContext->dwUpper,
                        ulAttribute,
                        pBuffer);
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }

        if ( ( scRet == SEC_E_INVALID_HANDLE ) ||
             ( scRet == STATUS_INVALID_HANDLE ) )
        {
            if ( ( ulAttribute == SECPKG_ATTR_PACKAGE_INFO ) ||
                 ( ulAttribute == SECPKG_ATTR_NEGOTIATION_INFO ) )
            {
                //
                // These attributes are really about the handle
                //

                pNegInfo = (PSecPkgContext_NegotiationInfoW) pBuffer ;

                if ( ulAttribute == SECPKG_ATTR_NEGOTIATION_INFO )
                {
                    pNegInfo->NegotiationState = SECPKG_NEGOTIATION_COMPLETE ;
                }

                scRet = SecCopyPackageInfoToUserW( pPackage, &pNegInfo->PackageInfo );
            }
        }
    }

Cleanup:

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaQueryContextAttributesA
//
//  Synopsis:   ANSI stub
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [attributes]  --
//
//  History:    3-05-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaQueryContextAttributesA(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    PDLL_SECURITY_PACKAGE   pPackage;
    PDLL_LSA_PACKAGE_INFO   LsaInfo ;
    SECURITY_STATUS         scRet = SEC_E_OK;
    PSTR                    AnsiString;
    UNICODE_STRING          String;
    SecPkgContext_NamesW *  Names;
    SecPkgContext_NativeNamesW * NativeNames;
    SecPkgContext_KeyInfoW *KeyInfo;
    PSecPkgContext_PackageInfoW PackageInfoW;
    PSecPkgContext_NegotiationInfoA pNegInfo ;
    PSecPkgContext_CredentialNameW CredName;
    ULONG                   PackageInfoSize;
    PSecPkgInfoA            PackageInfoA;
    PSTR                    PackageName = NULL;
    PSTR                    PackageComment = NULL;
    ULONG                   i ;
    BOOL                    Thunked = FALSE ;
    BOOL                    Converted = FALSE ;
    ULONG Allocs ;
    PVOID Buffers[ MAX_BUFFERS_IN_CALL ];
    SEC_HANDLE_LPC LocalHandle ;
    ULONG Flags = 0;

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

    LsaInfo = pPackage->LsaInfo ;

    if ( LsaInfo->ContextThunkCount )
    {
        Allocs = 0 ;

        //
        // This package wants some of the context attr calls to be thunked to
        // the LSA.  help them out:
        //

        if ( LsaInfo->ContextThunks[ 0 ] == SECPKG_ATTR_THUNK_ALL )
        {
            Allocs = MAX_BUFFERS_IN_CALL ;

#ifdef BUILD_WOW64
            //
            // If this points to bogus data, we're ok.  The LSA will
            // reject it.
            //

            if (!SecpReferenceHandleMap(
                    (PSECWOW_HANDLE_MAP) phContext->dwUpper,
                    &LocalHandle))
            {
                scRet = SEC_E_INVALID_HANDLE;
                goto Cleanup;
            }
#else
            LocalHandle = *phContext ;
#endif
            scRet = SecpQueryContextAttributes(
                        NULL,
                        &LocalHandle,
                        ulAttribute,
                        pBuffer,
                        &Allocs,
                        Buffers,
                        &Flags );

#ifdef BUILD_WOW64
            SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
#endif
            Thunked = TRUE ;
        }
        else
        {
            for ( i = 0 ; i < LsaInfo->ContextThunkCount ; i++)
            {
                if ( LsaInfo->ContextThunks[ i ] == ulAttribute )
                {
                    Allocs = MAX_BUFFERS_IN_CALL ;

#ifdef BUILD_WOW64
                    //
                    // If this points to bogus data, we're ok.  The LSA will
                    // reject it.
                    //

                    if (!SecpReferenceHandleMap(
                            (PSECWOW_HANDLE_MAP) phContext->dwUpper,
                            &LocalHandle))
                    {
                        scRet = SEC_E_INVALID_HANDLE;
                        goto Cleanup;
                    }

#else
                    LocalHandle = *phContext ;
#endif
                    scRet = SecpQueryContextAttributes(
                                NULL,
                                &LocalHandle,
                                ulAttribute,
                                pBuffer,
                                &Allocs,
                                Buffers,
                                &Flags );

#ifdef BUILD_WOW64
                    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
#endif
                    Thunked = TRUE ;
                    break;
                }
            }
        }

        //
        // If the package allocated memory in our address space,
        // add it to the VM list so it can be freed correctly.
        //

        for ( i = 0 ; i < Allocs ; i++ )
        {
            SecpAddVM( Buffers[ i ] );
        }
    }

    if ( !Thunked )
    {

        if ((pPackage->pftUTable != NULL) &&
            (pPackage->pftUTable->QueryContextAttributes != NULL))
        {
            scRet = pPackage->pftUTable->QueryContextAttributes(
                        phContext->dwUpper,
                        ulAttribute,
                        pBuffer);
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }

        if ( ( scRet == SEC_E_INVALID_HANDLE ) ||
             ( scRet == STATUS_INVALID_HANDLE ) )
        {
            if ( ( ulAttribute == SECPKG_ATTR_PACKAGE_INFO ) ||
                 ( ulAttribute == SECPKG_ATTR_NEGOTIATION_INFO ) )
            {
                //
                // These attributes are really about the handle
                //

                pNegInfo = (PSecPkgContext_NegotiationInfoA) pBuffer ;

                if ( ulAttribute == SECPKG_ATTR_NEGOTIATION_INFO )
                {
                    pNegInfo->NegotiationState = SECPKG_NEGOTIATION_COMPLETE ;
                }

                scRet = SecCopyPackageInfoToUserA( pPackage, &pNegInfo->PackageInfo );

                Converted = TRUE ;

            }
        }
    }
    if ( NT_SUCCESS( scRet ) &&
         ( Converted == FALSE ) )
    {
        //
        // Must convert individual context attributes to ANSI.
        //

        switch ( ulAttribute )
        {
            case SECPKG_ATTR_SIZES:
            case SECPKG_ATTR_LIFESPAN:
            case SECPKG_ATTR_DCE_INFO:
            case SECPKG_ATTR_STREAM_SIZES:
            case SECPKG_ATTR_PASSWORD_EXPIRY:
            case SECPKG_ATTR_SESSION_KEY:
            default:
                break;

            case SECPKG_ATTR_NAMES:
            case SECPKG_ATTR_AUTHORITY:
            case SECPKG_ATTR_PROTO_INFO:

                //
                // All these have the string pointer as their first member,
                // making this easy.
                //

                Names = (PSecPkgContext_NamesW) pBuffer ;

                RtlInitUnicodeString( &String, Names->sUserName );

                AnsiString = LsapConvertUnicodeString( &String );

                SecClientFree( Names->sUserName );

                Names->sUserName = (PWSTR) AnsiString ;

                if ( !AnsiString )
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY ;
                }

                break;


            case SECPKG_ATTR_KEY_INFO:

                KeyInfo = (PSecPkgContext_KeyInfoW) pBuffer ;

                RtlInitUnicodeString( &String, KeyInfo->sSignatureAlgorithmName );

                AnsiString = LsapConvertUnicodeString( &String );

                SecClientFree( KeyInfo->sSignatureAlgorithmName );

                KeyInfo->sSignatureAlgorithmName = (PWSTR) AnsiString ;

                if ( AnsiString )
                {
                    RtlInitUnicodeString( &String, KeyInfo->sEncryptAlgorithmName );

                    AnsiString = LsapConvertUnicodeString( &String );

                    SecClientFree( KeyInfo->sEncryptAlgorithmName );

                    KeyInfo->sEncryptAlgorithmName = (PWSTR) AnsiString ;

                    if ( !AnsiString )
                    {
                        SecClientFree( KeyInfo->sSignatureAlgorithmName );

                        scRet = SEC_E_INSUFFICIENT_MEMORY ;
                    }
                }
                else
                {
                    SecClientFree( KeyInfo->sEncryptAlgorithmName );

                    scRet = SEC_E_INSUFFICIENT_MEMORY ;
                }
                break;

            case SECPKG_ATTR_PACKAGE_INFO:
            case SECPKG_ATTR_NEGOTIATION_INFO:
                //
                // Convert the SecPkgInfoW to a SecPkgInfoA structure
                //
                PackageInfoW = (PSecPkgContext_PackageInfoW) pBuffer;
                RtlInitUnicodeString(
                    &String,
                    PackageInfoW->PackageInfo->Name
                    );
                PackageName = LsapConvertUnicodeString(
                                    &String
                                    );
                if (PackageName != NULL)
                {
                    RtlInitUnicodeString(
                        &String,
                        PackageInfoW->PackageInfo->Comment
                        );

                    PackageComment = LsapConvertUnicodeString(
                                        &String
                                        );

                    if (PackageComment != NULL)
                    {
                        PackageInfoSize = sizeof(SecPkgInfoA) +
                                            2 * sizeof(CHAR) +
                                            lstrlenA(PackageName) +     // null terminators
                                            lstrlenA(PackageComment);
                        PackageInfoA = (PSecPkgInfoA) SecClientAllocate(PackageInfoSize);
                        if (PackageInfoA != NULL)
                        {
                            *PackageInfoA = *(PSecPkgInfoA) PackageInfoW->PackageInfo;
                            AnsiString = (PSTR) (PackageInfoA + 1);
                            PackageInfoA->Name = AnsiString;
                            lstrcpyA(
                                AnsiString,
                                PackageName
                                );
                            AnsiString += lstrlenA(PackageName) + 1;
                            PackageInfoA->Comment = AnsiString;
                            lstrcpyA(
                                AnsiString,
                                PackageComment
                                );
                            SecClientFree(PackageInfoW->PackageInfo);
                            PackageInfoW->PackageInfo = (PSecPkgInfoW) PackageInfoA;

                        }
                        SecClientFree(PackageComment);
                    }
                    else
                    {
                        scRet = SEC_E_INSUFFICIENT_MEMORY;
                    }
                    SecClientFree(PackageName);
                }
                else
                {
                     scRet = SEC_E_INSUFFICIENT_MEMORY;
                }

                break;
            case SECPKG_ATTR_NATIVE_NAMES:

                //
                // All these have the string pointer as their first member,
                // making this easy.
                //

                NativeNames = (PSecPkgContext_NativeNamesW) pBuffer ;

                RtlInitUnicodeString( &String, NativeNames->sClientName );

                AnsiString = LsapConvertUnicodeString( &String );

                SecClientFree( NativeNames->sClientName );

                NativeNames->sClientName = (PWSTR) AnsiString ;

                if ( !AnsiString )
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY ;
                }

                RtlInitUnicodeString( &String, NativeNames->sServerName );

                AnsiString = LsapConvertUnicodeString( &String );

                SecClientFree( NativeNames->sServerName );

                NativeNames->sServerName = (PWSTR) AnsiString ;

                if ( !AnsiString )
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY ;
                }

                break;

        case SECPKG_ATTR_CREDENTIAL_NAME:

            CredName = (PSecPkgContext_CredentialNameW)pBuffer ;

            RtlInitUnicodeString( &String, CredName->sCredentialName );

            AnsiString = LsapConvertUnicodeString( &String );

            SecClientFree( CredName->sCredentialName );

            CredName->sCredentialName = (PWSTR) AnsiString ;

            if ( !AnsiString )
            {
                scRet = SEC_E_INSUFFICIENT_MEMORY ;
            }

            break;
        }
    }

Cleanup:

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}


//+---------------------------------------------------------------------------
//
//  Function:   SetContextAttributesW
//
//  Synopsis:   Set context attributes
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [attributes]  --
//
//  History:    4-20-00   CliffV   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaSetContextAttributesW(
    PCtxtHandle                 phContext,          // Context to Set
    unsigned long               ulAttribute,        // Attribute to Set
    void SEC_FAR *              pBuffer,            // Buffer for attributes
    unsigned long               cbBuffer            // Size (in bytes) of pBuffer
    )
{
    PDLL_SECURITY_PACKAGE pPackage;
    SECURITY_STATUS scRet = SEC_E_OK;
    ULONG i;
    SEC_HANDLE_LPC LocalHandle ;
    PSecPkgContext_CredentialNameW CredentialNameInfo = (PSecPkgContext_CredentialNameW)pBuffer;
    ULONG CredentialNameSize;

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }
    //
    // Must convert individual context attributes to ANSI.
    //
    switch ( ulAttribute ) {
    case SECPKG_ATTR_USE_VALIDATED:
        if ( cbBuffer < sizeof(DWORD) ) {
            scRet = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }

        break;
    case SECPKG_ATTR_CREDENTIAL_NAME:
        if ( cbBuffer < sizeof(SecPkgContext_CredentialNameW) ) {
            scRet = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }
        CredentialNameSize = (wcslen(CredentialNameInfo->sCredentialName) + 1) * sizeof(WCHAR);
        if ( (LPBYTE)(CredentialNameInfo->sCredentialName) < (LPBYTE)(CredentialNameInfo+1) ||
             CredentialNameSize > cbBuffer ||
             (LPBYTE)(CredentialNameInfo->sCredentialName) > (LPBYTE)(pBuffer) + cbBuffer - CredentialNameSize ) {

            scRet = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }

        break;
    }


#ifdef BUILD_WOW64
    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    if (!SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) phContext->dwUpper,
            &LocalHandle))
    {
        scRet = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

#else
    LocalHandle = *phContext ;
#endif

    scRet = SecpSetContextAttributes( &LocalHandle,
                                      ulAttribute,
                                      pBuffer,
                                      cbBuffer );

#ifdef BUILD_WOW64
    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
#endif

Cleanup:
    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}

//+---------------------------------------------------------------------------
//
//  Function:   LsaSetContextAttributesA
//
//  Synopsis:   ANSI stub
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [attributes]  --
//
//  History:    4-20-00   CliffV   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaSetContextAttributesA(
    PCtxtHandle                 phContext,          // Context to Set
    unsigned long               ulAttribute,        // Attribute to Set
    void SEC_FAR *              pBuffer,            // Buffer for attributes
    unsigned long               cbBuffer            // Size (in bytes) of pBuffer
    )
{
    PDLL_SECURITY_PACKAGE   pPackage;
    SECURITY_STATUS         scRet = SEC_E_OK;
    PSTR                    AnsiString;
    UNICODE_STRING          String;
    ULONG                   PackageInfoSize;
    PSecPkgInfoA            PackageInfoA;
    PSTR                    PackageName = NULL;
    PSTR                    PackageComment = NULL;
    ULONG                   i ;
    SEC_HANDLE_LPC LocalHandle ;
    PVOID AllocatedBuffer = NULL;

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

    //
    // Must convert individual context attributes to ANSI.
    //
    switch ( ulAttribute ) {
    case SECPKG_ATTR_USE_VALIDATED:
        if ( cbBuffer < sizeof(DWORD) ) {
            scRet = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }

        break;
    case SECPKG_ATTR_CREDENTIAL_NAME: {
        NTSTATUS Status;
        STRING AnsiString;
        UNICODE_STRING UnicodeString;
        ULONG CredentialNameSize;
        ULONG Size;
        PSecPkgContext_CredentialNameA ACredName;
        PSecPkgContext_CredentialNameW WCredName;

        //
        // Validate the caller's buffer
        //
        ACredName = (PSecPkgContext_CredentialNameA)pBuffer;

        if ( cbBuffer < sizeof(SecPkgContext_CredentialNameA) ) {
            scRet = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }
        CredentialNameSize = strlen(ACredName->sCredentialName) + 1;
        if ( (LPBYTE)(ACredName->sCredentialName) < (LPBYTE)(ACredName+1) ||
             CredentialNameSize > cbBuffer ||
             (LPBYTE)(ACredName->sCredentialName) > (LPBYTE)(pBuffer) + cbBuffer - CredentialNameSize ) {

            scRet = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }

        //
        // Allocate a buffer containing the UNICODE version of the structure
        //

        RtlInitString( &AnsiString, ACredName->sCredentialName );

        Size = RtlAnsiStringToUnicodeSize( &AnsiString );

        if ( Size + sizeof( SecPkgContext_CredentialNameW ) > 0xFFFE )
        {
            scRet = HRESULT_FROM_NT(STATUS_INVALID_PARAMETER);
            goto Cleanup;
        }

        UnicodeString.MaximumLength = (USHORT)Size;

        Size = sizeof(SecPkgContext_CredentialNameW) +
               UnicodeString.MaximumLength;

        AllocatedBuffer = LocalAlloc( 0, Size );

        if ( AllocatedBuffer == NULL ) {
            scRet = SEC_E_INSUFFICIENT_MEMORY ;
            goto Cleanup;
        }

        WCredName = (PSecPkgContext_CredentialNameW) AllocatedBuffer;
        pBuffer = WCredName;
        cbBuffer = Size;

        //
        // Fill in the UNICODE version of the structure
        //

        WCredName->CredentialType = ACredName->CredentialType;
        WCredName->sCredentialName = (LPWSTR)(WCredName+1);

        UnicodeString.Length = 0;
        UnicodeString.Buffer = WCredName->sCredentialName;

        Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );

        if ( !NT_SUCCESS(Status) ) {
            scRet = SEC_E_INSUFFICIENT_MEMORY ;
            goto Cleanup;
        }

        }
        break;
    }


    //
    // Call the LSA to set the information there.
    //


#ifdef BUILD_WOW64
    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    if (!SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) phContext->dwUpper,
            &LocalHandle))
    {
        scRet = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

#else
    LocalHandle = *phContext ;
#endif

    scRet = SecpSetContextAttributes( &LocalHandle,
                                       ulAttribute,
                                       pBuffer,
                                       cbBuffer );

#ifdef BUILD_WOW64
    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
#endif

Cleanup:
    if ( AllocatedBuffer != NULL ) {
        LocalFree( AllocatedBuffer );
    }

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}



//+-------------------------------------------------------------------------
//
//  Function:   MakeSignature
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]     -- context to use
//              [fQOP]          -- quality of protection to use
//              [pMessage]      -- message
//              [MessageSeqNo]  -- sequence number of message
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaMakeSignature(  PCtxtHandle         phContext,
                DWORD               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    PDLL_SECURITY_PACKAGE             pPackage;
    SECURITY_STATUS         scRet;


    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );
    if (!pPackage)
    {
        scRet = SEC_E_INVALID_HANDLE;
    }
    else
    {
        if ((pPackage->pftUTable != NULL) && (pPackage->pftUTable->MakeSignature != NULL))
        {
            scRet = pPackage->pftUTable->MakeSignature(
                                phContext->dwUpper,
                                fQOP,
                                pMessage,
                                MessageSeqNo );
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }
    }



    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}



//+-------------------------------------------------------------------------
//
//  Function:   VerifySignature
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]     -- Context performing the unseal
//              [pMessage]      -- Message to verify
//              [MessageSeqNo]  -- Sequence number of this message
//              [pfQOPUsed]     -- quality of protection used
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaVerifySignature(PCtxtHandle     phContext,
                PSecBufferDesc  pMessage,
                ULONG           MessageSeqNo,
                DWORD *         pfQOP)
{
    PDLL_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRet;


    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = SEC_E_INVALID_HANDLE;
    }
    else
    {
        if ((pPackage->pftUTable != NULL) && (pPackage->pftUTable->VerifySignature != NULL))
        {
            scRet = pPackage->pftUTable->VerifySignature(
                                    phContext->dwUpper,
                                    pMessage,
                                    MessageSeqNo,
                                    pfQOP );
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }
    }


    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));


}

//+---------------------------------------------------------------------------
//
//  Function:   SealMessage
//
//  Synopsis:   Seals a message
//
//  Effects:
//
//  Arguments:  [phContext]     -- context to use
//              [fQOP]          -- quality of protection to use
//              [pMessage]      -- message
//              [MessageSeqNo]  -- sequence number of message
//
//  History:    5-06-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaSealMessage(    PCtxtHandle         phContext,
                DWORD               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    PDLL_SECURITY_PACKAGE             pPackage;
    SECURITY_STATUS         scRet;

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = SEC_E_INVALID_HANDLE;
    }
    else
    {
        if ( ( pPackage->fState & DLL_SECPKG_NO_CRYPT ) != 0 )
        {
            return SecpFailedSealFunction(
                            phContext,
                            fQOP,
                            pMessage,
                            MessageSeqNo );
        }

        if ((pPackage->pftUTable != NULL) && (pPackage->pftUTable->SealMessage != NULL))
        {
            scRet = pPackage->pftUTable->SealMessage(
                                    phContext->dwUpper,
                                    fQOP,
                                    pMessage,
                                    MessageSeqNo );
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }
    }

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}

//+---------------------------------------------------------------------------
//
//  Function:   UnsealMessage
//
//  Synopsis:   Unseal a private message
//
//  Arguments:  [phContext]     -- Context performing the unseal
//              [pMessage]      -- Message to unseal
//              [MessageSeqNo]  -- Sequence number of this message
//              [pfQOPUsed]     -- quality of protection used
//
//  History:    5-06-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaUnsealMessage(  PCtxtHandle         phContext,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo,
                DWORD *             pfQOP)
{
    PDLL_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRet;

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = SEC_E_INVALID_HANDLE;
    }
    else
    {
        if ( ( pPackage->fState & DLL_SECPKG_NO_CRYPT ) != 0 )
        {
            return SecpFailedUnsealFunction(
                        phContext,
                        pMessage,
                        MessageSeqNo,
                        pfQOP );
        }
        if ((pPackage->pftUTable != NULL) && (pPackage->pftUTable->UnsealMessage != NULL))
        {
            scRet = pPackage->pftUTable->UnsealMessage(
                                phContext->dwUpper,
                                pMessage,
                                MessageSeqNo,
                                pfQOP );
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }
    }

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}


//+-------------------------------------------------------------------------
//
//  Function:   DeleteUsermodeContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
LsaDeleteUserModeContext(
    PCtxtHandle                 phContext           // Contxt to delete
    )
{
    PDLL_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRet = SEC_E_OK;

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        return(SEC_E_INVALID_HANDLE);
    }

    if ((pPackage->pftUTable != NULL) && (pPackage->pftUTable->DeleteUserModeContext != NULL))
    {
        scRet = pPackage->pftUTable->DeleteUserModeContext(
                    phContext->dwUpper);
    }

    return(scRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   LsaBootPackage
//
//  Synopsis:   Boots (instance-inits) a security package
//
//  Arguments:  [Package] --
//
//  History:    9-15-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SEC_ENTRY
LsaBootPackage(
    PDLL_SECURITY_PACKAGE Package)
{
    SECURITY_STATUS scRet ;
    PVOID ignored;

    SetCurrentPackage( Package );

    __try
    {
        scRet = Package->pftUTable->InstanceInit(
                                SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
                                & SecpFTable,
                                & ignored );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        scRet = GetExceptionCode();
    }

    SetCurrentPackage( NULL );

    return( NT_SUCCESS( scRet ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LsaUnloadPackage
//
//  Synopsis:   Called when a package is unloaded
//
//  Arguments:  (none)
//
//  History:    9-15-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SEC_ENTRY
LsaUnloadPackage(
    VOID )
{

}


//+-------------------------------------------------------------------------
//
//  Function:   SecInitUserModeContext
//
//  Synopsis:   Passes the context data to the user-mode portion of a package
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SecInitUserModeContext(
    IN PCtxtHandle ContextHandle,
    IN PSecBuffer ContextData
    )
{
    SECURITY_STATUS Status = SEC_E_OK;
    PDLL_SECURITY_PACKAGE pspPackage;

    pspPackage = SecLocatePackageById( ContextHandle->dwLower );


    if ( !pspPackage )
    {
        return SEC_E_INVALID_HANDLE ;
    }

    if ((pspPackage->pftUTable != NULL) && (pspPackage->pftUTable->InitUserModeContext != NULL))
    {
        SecpAddVM( ContextData->pvBuffer );

        Status = pspPackage->pftUTable->InitUserModeContext(
                    ContextHandle->dwUpper,
                        ContextData
                        );

    }
    else
    {
        Status = SEC_E_INVALID_HANDLE;
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   SecDeleteUserModeContext
//
//  Synopsis:   Frees up a context in the user-mode portion of a package.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SecDeleteUserModeContext(
    IN PCtxtHandle ContextHandle
    )
{
    return(LsaDeleteUserModeContext(ContextHandle));
}

//+---------------------------------------------------------------------------
//
//  Function:   LsaCallbackHandler
//
//  Synopsis:   handles LSA specific callbacks
//
//  Arguments:  [Function] --
//              [Arg1]     --
//              [Arg2]     --
//              [Input]    --
//              [Output]   --
//
//  History:    11-12-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
extern "C"
NTSTATUS
LsaCallbackHandler(
    ULONG_PTR   Function,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    PSecBuffer Input,
    PSecBuffer Output
    )
{
    PDLL_SECURITY_PACKAGE Package ;
    PDLL_LSA_CALLBACK   Callback ;
    PLIST_ENTRY Scan ;

    Package = (PDLL_SECURITY_PACKAGE) GetCurrentPackage();

    if ( !Package )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    Scan = Package->LsaInfo->Callbacks.Flink ;

    Callback = NULL ;

    while ( Scan != &Package->LsaInfo->Callbacks )
    {
        Callback = (PDLL_LSA_CALLBACK) Scan ;

        if ( Callback->CallbackId == Function )
        {
            break;
        }

        Callback = NULL ;

        Scan = Scan->Flink ;
    }

    if ( Callback )
    {
        return Callback->Callback( Arg1, Arg2, Input, Output );
    }

    return STATUS_ENTRYPOINT_NOT_FOUND ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaExportContext
//
//  Synopsis:   Exports
//
//  Arguments:
//
//  History:    18-08-97        MikeSw          Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaExportContext(
    IN PCtxtHandle ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer MarshalledContext,
    OUT PHANDLE TokenHandle
    )
{
    PDLL_SECURITY_PACKAGE  Package;
    SECURITY_STATUS scRet;

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    Package = SecLocatePackageById( ContextHandle->dwLower );

    if (!Package)
    {
        scRet = SEC_E_INVALID_HANDLE;
    }
    else
    {
        if ((Package->pftUTable != NULL) && (Package->pftUTable->ExportContext != NULL))
        {
            scRet = Package->pftUTable->ExportContext(
                                    ContextHandle->dwUpper,
                                    Flags,
                                    MarshalledContext,
                                    TokenHandle
                                    );
            if (NT_SUCCESS(scRet) && ((Flags & SECPKG_CONTEXT_EXPORT_DELETE_OLD) != 0))
            {
                LsaDeleteSecurityContext(ContextHandle);
            }
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }
    }

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaImportContextW
//
//  Synopsis:   Imports a context from another process
//
//  Arguments:
//
//  History:    18-08-97        MikeSw          Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaImportContextW(
    IN LPWSTR PackageName,
    IN PSecBuffer MarshalledContext,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
    )
{
    PDLL_SECURITY_PACKAGE  Package;
    SECURITY_STATUS scRet;

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    Package = SecLocatePackageW(PackageName );

    if (!Package)
    {
        scRet = SEC_E_SECPKG_NOT_FOUND;
    }
    else
    {
        if ((Package->pftUTable != NULL) && (Package->pftUTable->ImportContext != NULL))
        {
            scRet = Package->pftUTable->ImportContext(
                                    MarshalledContext,
                                    TokenHandle,
                                    &ContextHandle->dwUpper
                                    );
            if (NT_SUCCESS(scRet))
            {
                ContextHandle->dwLower = Package->PackageId;
            }
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }
    }

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }

    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}

//+---------------------------------------------------------------------------
//
//  Function:   LsaImportContextA
//
//  Synopsis:   Imports a context from another process
//
//  Arguments:
//
//  History:    18-08-97        MikeSw          Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaImportContextA(
    IN LPSTR PackageName,
    IN PSecBuffer MarshalledContext,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
    )
{
    PDLL_SECURITY_PACKAGE  Package;

    SECURITY_STATUS scRet;


    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    Package = SecLocatePackageA(PackageName );

    if (!Package)
    {
        scRet = SEC_E_SECPKG_NOT_FOUND;
    }
    else
    {
        if ((Package->pftUTable != NULL) && (Package->pftUTable->ImportContext != NULL))
        {
            scRet = Package->pftUTable->ImportContext(
                                    MarshalledContext,
                                    TokenHandle,
                                    &ContextHandle->dwUpper
                                    );
            if (NT_SUCCESS(scRet))
            {
                ContextHandle->dwLower = Package->PackageId;
            }
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }
    }

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}


NTSTATUS
LsaRegisterPolicyChangeNotification(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
    IN HANDLE  NotificationEventHandle
    )
/*++

Routine Description:

    This routine is the user mode stub routine for the LsaRegisterPolicyChangeNotification
    API.

Arguments:

    InformationClass -- Information class to remove the notification for

    EventHandle -- Event handle to register

Return Value:

    STATUS_SUCCESS on success, error otherwise.

--*/
{
    NTSTATUS Status;

    Status = IsOkayToExec( NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    Status = LsapPolicyChangeNotify( 0,
                                     TRUE,
                                     NotificationEventHandle,
                                     InformationClass );
    return( Status );
}


NTSTATUS
LsaUnregisterPolicyChangeNotification(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
    IN HANDLE  NotificationEventHandle
    )
/*++

Routine Description:

    This routine is the user mode stub routine for the LsaUnregisterPolicyChangeNotification
    API.

Arguments:

    InformationClass -- Information class to remove the notification for

    EventHandle -- Event handle to unregister

Return Value:

    STATUS_SUCCESS on success, error otherwise.

--*/
{
    NTSTATUS Status;

    Status = IsOkayToExec( NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }
    Status = LsapPolicyChangeNotify( 0,
                                     FALSE,
                                     NotificationEventHandle,
                                     InformationClass );
    return( Status );
}


SECURITY_STATUS
SEC_ENTRY
LsaEnumerateLogonSessions(
    OUT PULONG LogonSessionCount,
    OUT PLUID * LogonSessionList
    )
{
    NTSTATUS Status ;

    Status = IsOkayToExec( NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }
    return SecpEnumLogonSession(
                LogonSessionCount,
                LogonSessionList
                );
}


SECURITY_STATUS
SEC_ENTRY
LsaGetLogonSessionData(
    IN PLUID LogonId,
    OUT PSECURITY_LOGON_SESSION_DATA * ppLogonSessionData
    )
{
    PVOID Data ;
    NTSTATUS Status ;

    Status = IsOkayToExec( NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    if ( !LogonId )
    {
        return STATUS_INVALID_PARAMETER;
    }

    Status = SecpGetLogonSessionData(
                LogonId,
                (PVOID*) &Data );

    if ( NT_SUCCESS( Status ) )
    {
        *ppLogonSessionData = (PSECURITY_LOGON_SESSION_DATA) Data ;
    }

    return Status ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\dll\makefile.inc ===
#
# build a private secur32.lib that contains undocumented and
# private functions
#

$(O)\secur32p.def: secur32.src
    @echo Creating $@ from $**
    $(C_PREPROCESSOR_NAME) /DPRIVATE= $(C_PREPROCESSOR_FLAGS) $** > $@
    

$(O)\secur32p.lib: $(O)\secur32p.def $(LIBRARY_OBJS)
   -lib -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\secur32p.def
$(LIBRARY_OBJS)
<<NOKEEP

$(PROJECT_LIB_PATH)\secur32p.lib : $(O)\secur32p.lib
    $(PUBLISH_CMD) {$?=$@}
    

#
# Build public secur32.lib 
#

$(O)\secur32.def: secur32.src
    @echo Creating $@ from $**
    $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS) $** > $@


$(O)\secur32.lib : $(O)\secur32.def $(LIBRARY_OBJS)
   -lib -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\secur32.def
$(LIBRARY_OBJS)
<<NOKEEP

$(SDK_LIB_PATH)\secur32.lib : $(O)\secur32.lib
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\dll\extapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        extapi.cxx
//
// Contents:    user-mode stubs for security extension APIs
//
//
// History:     3-5-94      MikeSw      Created
//
//------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop
extern "C"
{
#include <secpri.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
}

//+-------------------------------------------------------------------------
//
//  Function:   GetSecurityUserInfo
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
GetSecurityUserInfo(    PLUID                   pLogonId,
                        ULONG                   fFlags,
                        PSecurityUserData *     ppUserInfo)
{
    return(SecpGetUserInfo(pLogonId,fFlags,ppUserInfo));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\dll\newstubs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       newstubs.cxx
//
//  Contents:   Stubs from ntlmssp
//
//  History:    9-06-96   RichardW   Stolen from ntlmssp
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
}
SecurityFunctionTableW SecTableW = {SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
                                    EnumerateSecurityPackagesW,
                                    QueryCredentialsAttributesW,
                                    AcquireCredentialsHandleW,
                                    FreeCredentialsHandle,
                                    NULL,
                                    InitializeSecurityContextW,
                                    AcceptSecurityContext,
                                    CompleteAuthToken,
                                    DeleteSecurityContext,
                                    ApplyControlToken,
                                    QueryContextAttributesW,
                                    ImpersonateSecurityContext,
                                    RevertSecurityContext,
                                    MakeSignature,
                                    VerifySignature,
                                    FreeContextBuffer,
                                    QuerySecurityPackageInfoW,
                                    EncryptMessage,
                                    DecryptMessage,
                                    ExportSecurityContext,
                                    ImportSecurityContextW,
                                    AddCredentialsW,
                                    NULL,
                                    QuerySecurityContextToken,
                                    EncryptMessage,
                                    DecryptMessage,
                                    SetContextAttributesW
                                   };


SecurityFunctionTableA   SecTableA = {SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
                                    EnumerateSecurityPackagesA,
                                    QueryCredentialsAttributesA,
                                    AcquireCredentialsHandleA,
                                    FreeCredentialsHandle,
                                    NULL,
                                    InitializeSecurityContextA,
                                    AcceptSecurityContext,
                                    CompleteAuthToken,
                                    DeleteSecurityContext,
                                    ApplyControlToken,
                                    QueryContextAttributesA,
                                    ImpersonateSecurityContext,
                                    RevertSecurityContext,
                                    MakeSignature,
                                    VerifySignature,
                                    FreeContextBuffer,
                                    QuerySecurityPackageInfoA,
                                    EncryptMessage,
                                    DecryptMessage,
                                    ExportSecurityContext,
                                    ImportSecurityContextA,
                                    AddCredentialsA,
                                    NULL,
                                    QuerySecurityContextToken,
                                    EncryptMessage,
                                    DecryptMessage,
                                    SetContextAttributesA
                                   };


SECURITY_STATUS
SEC_ENTRY
AcquireCredentialsHandleCommon(
    LPWSTR                      pszPrincipal,       // Name of principal
    LPWSTR                      pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry,          // (out) Lifetime (optional)
    BOOLEAN                     fUnicode            // (in) Unicode caller?
    );

SECURITY_STATUS
SEC_ENTRY
InitializeSecurityContextCommon(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPWSTR                      pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry,          // (out) Life span (OPT)
    BOOLEAN                     fUnicode            // (in) Unicode caller?
    );

//+---------------------------------------------------------------------------
//
//  Function:   SecpValidateHandle
//
//  Synopsis:   Validates a handle, determining effective handle and package
//
//  Arguments:  [pHandle]    -- Handle from user
//              [pEffective] -- Effective handle
//
//  History:    9-11-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDLL_SECURITY_PACKAGE
SecpValidateHandle(
    BOOL        Context,
    PSecHandle  pHandle,
    PSecHandle  pEffective)
{
    PDLL_SECURITY_PACKAGE   Package;

    __try
    {

        if ( (pHandle->dwLower == 0 ) ||
             (pHandle->dwLower == (INT_PTR)-1) )
        {
            Package = NULL ;
        }
        else if ( pHandle->dwLower == (ULONG_PTR) GetCurrentThread() )
        {
            Package = (PDLL_SECURITY_PACKAGE) TlsGetValue( SecTlsPackage );
        }
        else
        {
            Package = (PDLL_SECURITY_PACKAGE) pHandle->dwLower ;
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        Package = NULL ;
    }

    if ( Package )
    {


        if ( Package->fState & (DLL_SECPKG_SAVE_LOWER | DLL_SECPKG_CRED_LOWER) )
        {
            if ( Context )
            {
                if ( Package->fState & DLL_SECPKG_SAVE_LOWER )
                {
                    pEffective->dwLower = Package->OriginalLowerCtxt ;
                }
                else
                {
                    pEffective->dwLower = pHandle->dwLower ;
                }
            }
            else
            {
                if ( Package->fState & DLL_SECPKG_CRED_LOWER )
                {
                    pEffective->dwLower = Package->OriginalLowerCred ;
                }
                else
                {
                    pEffective->dwLower = pHandle->dwLower ;
                }
            }
        }
        else
        {
            pEffective->dwLower = pHandle->dwLower ;
        }

        pEffective->dwUpper = pHandle->dwUpper ;
    }

    return( Package );

}

//+---------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandleW
//
//  Synopsis:   Stub for AcquireCredentialsHandle
//
//  Arguments:  [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pvLogonId]        --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [pvGetKeyArgument] --
//              [phCredential]     --
//              [ptsExpiry]        --
//
//  History:    9-11-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
AcquireCredentialsHandleW(
    LPWSTR                      pszPrincipal,       // Name of principal
    LPWSTR                      pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    return AcquireCredentialsHandleCommon(
            pszPrincipal,       // Name of principal
            pszPackageName,     // Name of package
            fCredentialUse,     // Flags indicating use
            pvLogonId,          // Pointer to logon ID
            pAuthData,          // Package specific data
            pGetKeyFn,          // Pointer to GetKey() func
            pvGetKeyArgument,   // Value to pass to GetKey()
            phCredential,       // (out) Cred Handle
            ptsExpiry,          // (out) Lifetime (optional)
            TRUE                // Unicode caller
            );

}

//+---------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandleA
//
//  Synopsis:   Stub for acquire credentials handle
//
//  Arguments:  [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pvLogonId]        --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [pvGetKeyArgument] --
//              [phCredential]     --
//              [ptsExpiry]        --
//
//  History:    9-11-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
AcquireCredentialsHandleA(
    LPSTR                       pszPrincipal,       // Name of principal
    LPSTR                       pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    return AcquireCredentialsHandleCommon(
            (LPWSTR)pszPrincipal,       // Name of principal
            (LPWSTR)pszPackageName,     // Name of package
            fCredentialUse,     // Flags indicating use
            pvLogonId,          // Pointer to logon ID
            pAuthData,          // Package specific data
            pGetKeyFn,          // Pointer to GetKey() func
            pvGetKeyArgument,   // Value to pass to GetKey()
            phCredential,       // (out) Cred Handle
            ptsExpiry,          // (out) Lifetime (optional)
            FALSE               // NOT Unicode caller
            );
}

SECURITY_STATUS
SEC_ENTRY
AcquireCredentialsHandleCommon(
    LPWSTR                      pszPrincipal,       // Name of principal
    LPWSTR                      pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry,          // (out) Lifetime (optional)
    BOOLEAN                     fUnicode            // (in) Unicode caller?
    )
{
    SECURITY_STATUS scRet = SEC_E_OK;
    PDLL_SECURITY_PACKAGE pPackage;
    CredHandle  TempCreds;

    if (!pszPackageName)
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    TempCreds.dwLower = (UINT_PTR) -1;

    if( fUnicode )
    {
        pPackage = SecLocatePackageW( pszPackageName );

        if ( pPackage == NULL )
        {
            return( SEC_E_SECPKG_NOT_FOUND );
        }

        DebugLog(( DEB_TRACE, "AcquireCredentialHandleW( ..., %ws, %d, ...)\n",
                        pPackage->PackageName.Buffer, fCredentialUse ));

        SetCurrentPackage(  pPackage );

        scRet = pPackage->pftTableW->AcquireCredentialsHandleW(
                    pszPrincipal,
                    pszPackageName,
                    fCredentialUse,
                    pvLogonId,
                    pAuthData,
                    pGetKeyFn,
                    pvGetKeyArgument,
                    &TempCreds,
                    ptsExpiry);
    } else {

        pPackage = SecLocatePackageA( (LPSTR)pszPackageName );

        if ( pPackage == NULL )
        {
            return( SEC_E_SECPKG_NOT_FOUND );
        }

        DebugLog(( DEB_TRACE, "AcquireCredentialHandleA( ..., %s, %d, ...)\n",
                        (LPSTR)pPackage->PackageName.Buffer, fCredentialUse ));

        SetCurrentPackage(  pPackage );

        scRet = pPackage->pftTableA->AcquireCredentialsHandleA(
                    (LPSTR)pszPrincipal,
                    (LPSTR)pszPackageName,
                    fCredentialUse,
                    pvLogonId,
                    pAuthData,
                    pGetKeyFn,
                    pvGetKeyArgument,
                    &TempCreds,
                    ptsExpiry);
    }


    if ( scRet == SEC_E_OK )
    {
        if ( TempCreds.dwLower == (UINT_PTR) -1 )
        {
            //
            // Some packages are nice, and actually leave this
            // untouched.  Set the original lower appropriately.
            //

            TempCreds.dwLower = (ULONG_PTR) pPackage ;

        }
        //
        // If the dwLower has been changed, then we need to store it away in the
        // package record, for a level of indirection.
        //
Retry_CredLowerTest:

        if ( pPackage->fState & DLL_SECPKG_CRED_LOWER )
        {
            //
            // Package has already been detected with a mapped handle value,
            // so, make sure they're the same,
            //

            if ( pPackage->OriginalLowerCred != TempCreds.dwLower )
            {
                DebugLog(( DEB_ERROR, "Security Package %ws is manipulating dwLower value inappropriately\n\treturned %p when %p expected.",
                        pPackage->PackageName.Buffer, TempCreds.dwLower, pPackage->OriginalLowerCred ));
            }
        }
        else
        {
            //
            // Package has not been tagged yet.  Time to do the dance
            //

            WriteLockPackageList();

            //
            // Test again.  If another thread is (has) updated, we should treat that as
            // authoritative.
            //

            if ( pPackage->fState & DLL_SECPKG_CRED_LOWER )
            {
                //
                // Another thread has fixed this up.  Release the lock, and jump back up
                // to retry the operation.
                //

                WriteUnlockPackageList();

                goto Retry_CredLowerTest ;
            }

            //
            // Ok, we're the first.  Stick what the package wants as a dwLower into the
            // package record, and set the flag
            //

            pPackage->OriginalLowerCred = TempCreds.dwLower ;

            pPackage->fState |= DLL_SECPKG_CRED_LOWER ;

            WriteUnlockPackageList();

        }

        phCredential->dwLower = (ULONG_PTR) pPackage ;
        phCredential->dwUpper = TempCreds.dwUpper ;
    }

    DebugLog(( DEB_TRACE, "AcquireCredentialsHandleCommon returns %x, handle is %p : %p\n",
                    scRet, phCredential->dwUpper, phCredential->dwLower ));

    return( scRet );

}

//+---------------------------------------------------------------------------
//
//  Function:   AddCredentialsW
//
//  Synopsis:   Stub for acquire credentials handle
//
//  Arguments:  [phCredential]     --
//              [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [GetKey]           --
//              [pvGetKeyArgument] --
//              [ptsExpiry]        --
//
//  History:    9-11-99   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
AddCredentialsW(
    PCredHandle                 phCredentials,
    LPWSTR                      pszPrincipal,       // Name of principal
    LPWSTR                      pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    SECURITY_STATUS scRet = SEC_E_OK;
    PDLL_SECURITY_PACKAGE pPackage;

    if (!pszPackageName)
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    pPackage = SecLocatePackageW( pszPackageName );

    if ( pPackage == NULL )
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    if ( pPackage->pftTableW->AddCredentialsW == NULL )
    {
        return SEC_E_UNSUPPORTED_FUNCTION ;
    }

    DebugLog(( DEB_TRACE, "AddCredentialsW( ..., %ws, %d, ...)\n",
                    pPackage->PackageName.Buffer, fCredentialUse ));

    SetCurrentPackage(  pPackage );

    scRet = pPackage->pftTableW->AddCredentialsW(
                phCredentials,
                pszPrincipal,
                pszPackageName,
                fCredentialUse,
                pAuthData,
                pGetKeyFn,
                pvGetKeyArgument,
                ptsExpiry);

    DebugLog(( DEB_TRACE, "AddCredentialsA returns %x, handle is %p : %p\n",
                    scRet ));

    return( scRet );

}


//+---------------------------------------------------------------------------
//
//  Function:   AddCredentialsA
//
//  Synopsis:   Stub for acquire credentials handle
//
//  Arguments:  [phCredential]     --
//              [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [GetKey]           --
//              [pvGetKeyArgument] --
//              [ptsExpiry]        --
//
//  History:    9-11-99   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
AddCredentialsA(
    PCredHandle                 phCredentials,
    LPSTR                       pszPrincipal,       // Name of principal
    LPSTR                       pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    SECURITY_STATUS scRet = SEC_E_OK;
    PDLL_SECURITY_PACKAGE pPackage;

    if (!pszPackageName)
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    pPackage = SecLocatePackageA( pszPackageName );

    if ( pPackage == NULL )
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    if ( pPackage->pftTableA->AddCredentialsA == NULL )
    {
        return SEC_E_UNSUPPORTED_FUNCTION ;
    }

    DebugLog(( DEB_TRACE, "AddCredentialsA( ..., %ws, %d, ...)\n",
                    pPackage->PackageName.Buffer, fCredentialUse ));

    SetCurrentPackage(  pPackage );

    scRet = pPackage->pftTableA->AddCredentialsA(
                phCredentials,
                pszPrincipal,
                pszPackageName,
                fCredentialUse,
                pAuthData,
                pGetKeyFn,
                pvGetKeyArgument,
                ptsExpiry);

    DebugLog(( DEB_TRACE, "AddCredentialsA returns %x, handle is %p : %p\n",
                    scRet ));

    return( scRet );

}

//+---------------------------------------------------------------------------
//
//  Function:   FreeCredentialsHandle
//
//  Synopsis:   Stub for FreeCredentialsHandle
//
//  Arguments:  [phCredential] -- Credential to release
//
//  History:    9-11-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
FreeCredentialsHandle(
    PCredHandle                 phCredential        // Handle to free
    )
{
    CredHandle TempCredHandle;
    PDLL_SECURITY_PACKAGE Package;
    SECURITY_STATUS scRet ;

    Package = SecpValidateHandle( FALSE, phCredential, &TempCredHandle );

    if ( Package )
    {

        SetCurrentPackage( Package );

        scRet = Package->pftTable->FreeCredentialHandle( &TempCredHandle );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return( scRet );

}



//+---------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContextW
//
//  Synopsis:   InitializeSecurityContext stub
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pszTargetName] --
//              [fContextReq]   --
//              [Reserved1]     --
//              [Reserved]      --
//              [TargetDataRep] --
//              [pInput]        --
//              [Reserved2]     --
//              [Reserved]      --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
InitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPWSTR                      pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return InitializeSecurityContextCommon(
            phCredential,       // Cred to base context
            phContext,          // Existing context (OPT)
            pszTargetName,      // Name of target
            fContextReq,        // Context Requirements
            Reserved1,          // Reserved, MBZ
            TargetDataRep,      // Data rep of target
            pInput,             // Input Buffers
            Reserved2,          // Reserved, MBZ
            phNewContext,       // (out) New Context handle
            pOutput,            // (inout) Output Buffers
            pfContextAttr,      // (out) Context attrs
            ptsExpiry,          // (out) Life span (OPT)
            TRUE                // Unicode caller
            );
}

//+---------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContextA
//
//  Synopsis:   ANSI stub
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
InitializeSecurityContextA(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPSTR                       pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{

    return InitializeSecurityContextCommon(
            phCredential,       // Cred to base context
            phContext,          // Existing context (OPT)
            (LPWSTR)pszTargetName,      // Name of target
            fContextReq,        // Context Requirements
            Reserved1,          // Reserved, MBZ
            TargetDataRep,      // Data rep of target
            pInput,             // Input Buffers
            Reserved2,          // Reserved, MBZ
            phNewContext,       // (out) New Context handle
            pOutput,            // (inout) Output Buffers
            pfContextAttr,      // (out) Context attrs
            ptsExpiry,          // (out) Life span (OPT)
            FALSE               // NOT Unicode
            );

}

SECURITY_STATUS
SEC_ENTRY
InitializeSecurityContextCommon(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPWSTR                      pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry,          // (out) Life span (OPT)
    BOOLEAN                     fUnicode            // (in) Unicode caller?
    )
{
    SECURITY_STATUS scRet = SEC_E_OK;
    CredHandle TempCredHandle ;
    CtxtHandle TempCtxtHandle ;
    PDLL_SECURITY_PACKAGE Package ;
    PDLL_SECURITY_PACKAGE CredPackage ;
    PDLL_SECURITY_PACKAGE EndPackage ;
    PCredHandle EffectiveCreds;
    PCtxtHandle EffectiveCtxt;
    CtxtHandle ResultCtxt;
    ULONG_PTR ContextFix;

    //
    // They need to provide at least one of these two
    //

    if( fUnicode )
    {
        DebugLog(( DEB_TRACE, "InitializeSecurityContextW( %p, %p, %ws, ... )\n",
                                phCredential, phContext, (pszTargetName ? pszTargetName : L"<null>" ) ));
    } else {
        DebugLog(( DEB_TRACE, "InitializeSecurityContextA( %p, %p, %s, ... )\n",
                                phCredential, phContext, ((LPSTR)pszTargetName ? (LPSTR)pszTargetName : "<null>" ) ));
    }

    if (!phCredential && !phContext)
    {
        return( SEC_E_INVALID_HANDLE );
    }

    //
    // Need to determine which package to use.  Try the context handle first,
    // in case the context is actually present, and from a package other than
    // the credential (basically, the negotiator).
    //

    Package = NULL ;
    ResultCtxt.dwLower = (UINT_PTR) -1;
    if (phNewContext)
    {
        ResultCtxt.dwUpper = phNewContext->dwUpper;
    }

    if ( phContext )
    {
        //
        // Context is valid:
        //

        Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

        if ( !Package )
        {
            return( SEC_E_INVALID_HANDLE );
        }

        EffectiveCtxt = &TempCtxtHandle ;
    }
    else
    {
        EffectiveCtxt = NULL ;
    }

    //
    // Now do the creds:
    //

    if ( phCredential )
    {

        CredPackage = SecpValidateHandle( FALSE, phCredential, &TempCredHandle );

        if ( !CredPackage )
        {
            return( SEC_E_INVALID_HANDLE );
        }

        if ( !Package )
        {
            Package = CredPackage ;
        }

        EffectiveCreds = &TempCredHandle ;

    }
    else
    {
        EffectiveCreds = NULL ;
    }

    SetCurrentPackage( Package );

    if( fUnicode )
    {
        scRet = Package->pftTableW->InitializeSecurityContextW(
                        EffectiveCreds,
                        EffectiveCtxt,
                        pszTargetName,
                        fContextReq,
                        Reserved1,
                        TargetDataRep,
                        pInput,
                        Reserved2,
                        &ResultCtxt,
                        pOutput,
                        pfContextAttr,
                        ptsExpiry);
    } else {
        scRet = Package->pftTableA->InitializeSecurityContextA(
                        EffectiveCreds,
                        EffectiveCtxt,
                        (LPSTR)pszTargetName,
                        fContextReq,
                        Reserved1,
                        TargetDataRep,
                        pInput,
                        Reserved2,
                        &ResultCtxt,
                        pOutput,
                        pfContextAttr,
                        ptsExpiry);
    }

    if ( NT_SUCCESS( scRet ) )
    {
        if ( ResultCtxt.dwLower != (UINT_PTR) -1 )
        {
            if ( Package->TypeMask & SECPKG_TYPE_NEW )
            {
                EndPackage = SecLocatePackageById( ResultCtxt.dwLower );
            }
            else
            {
                EndPackage = SecLocatePackageByOriginalLower( TRUE, Package, ResultCtxt.dwLower );

            }

            if (EndPackage == NULL)
            {
                //
                // This should only happen in an out-of-memory case
                //

                if ( Package->OriginalLowerCtxt == 0 )
                {
                    EndPackage = Package;
                }
                else
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY;
                    goto Cleanup;
                }

            }
            //
            // If the dwLower has been changed, then we need to store it away in the
            // package record, for a level of indirection.
            //
Retry_CtxtLowerTest:

            if ( EndPackage->fState & DLL_SECPKG_SAVE_LOWER )
            {
                //
                // Package has already been detected with a mapped handle value,
                // so, make sure they're the same,
                //

                if ( EndPackage->OriginalLowerCtxt != ResultCtxt.dwLower )
                {
                    DebugLog(( DEB_ERROR, "Security Package %ws is manipulating dwLower value inappropriately\n\treturned %p when %p expected.\n",
                            EndPackage->PackageName.Buffer, ResultCtxt.dwLower, EndPackage->OriginalLowerCtxt ));
                }
            }
            else
            {
                //
                // Package has not been tagged yet.  Time to do the dance
                //

                WriteLockPackageList();

                //
                // Test again.  If another thread is (has) updated, we should treat that as
                // authoritative.
                //

                if ( EndPackage->fState & DLL_SECPKG_SAVE_LOWER )
                {
                    //
                    // Another thread has fixed this up.  Release the lock, and jump back up
                    // to retry the operation.
                    //

                    WriteUnlockPackageList();

                    goto Retry_CtxtLowerTest;
                }

                //
                // Ok, we're the first.  Stick what the package wants as a dwLower into the
                // package record, and set the flag
                //

                EndPackage->OriginalLowerCtxt = ResultCtxt.dwLower;

                EndPackage->fState |= DLL_SECPKG_SAVE_LOWER;

                WriteUnlockPackageList();

            }

            Package = EndPackage;

        }

        if ( phNewContext )
        {
            phNewContext->dwUpper = ResultCtxt.dwUpper;
            phNewContext->dwLower = (ULONG_PTR) Package;
        }
    }
    else if ( ( Package->TypeMask & SECPKG_TYPE_OLD ) != 0 )
    {
        if ( phNewContext )
        {
            *phNewContext = ResultCtxt;

            if ( ( ResultCtxt.dwLower == (UINT_PTR) -1 ) ||
                 ( ResultCtxt.dwLower == Package->OriginalLowerCtxt ) )
            {
                phNewContext->dwLower = (ULONG_PTR) Package;
            }
        }
    }

Cleanup:

    if ( !NT_SUCCESS(scRet)
         && phNewContext && Package && (Package->TypeMask & SECPKG_TYPE_NEW)
         && (ResultCtxt.dwLower != -1)
         && (Package->fState & DLL_SECPKG_SAVE_LOWER)
         && (ResultCtxt.dwLower != Package->OriginalLowerCtxt) ) // need to patch context handle
    {
        Package = SecLocatePackageById( ResultCtxt.dwLower );

        if (!Package) // already patched
        {
            *phNewContext = ResultCtxt;
        }
        else if ((Package->TypeMask & SECPKG_TYPE_NEW)
                 && (Package->fState & DLL_SECPKG_SAVE_LOWER))
        {
            phNewContext->dwUpper = ResultCtxt.dwUpper;
            phNewContext->dwLower = (ULONG_PTR) Package;
        }

        DebugLog((DEB_ERROR, "InitializeSecurityContextW patched context %p:%p, package %p\n",
            phNewContext->dwUpper, phNewContext->dwLower, Package));
    }

    DebugLog(( DEB_TRACE, "InitializeSecurityContextW returns status %x\n", scRet ));

    return( scRet );
}


//+---------------------------------------------------------------------------
//
//  Function:   AcceptSecurityContext
//
//  Synopsis:   AcceptSecurityContext stub
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pInput]        --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
AcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    SECURITY_STATUS scRet = SEC_E_OK;
    CredHandle TempCredHandle ;
    CtxtHandle TempCtxtHandle ;
    PDLL_SECURITY_PACKAGE Package ;
    PDLL_SECURITY_PACKAGE CredPackage ;
    PDLL_SECURITY_PACKAGE EndPackage ;
    PCredHandle EffectiveCreds;
    PCtxtHandle EffectiveCtxt;
    CtxtHandle ResultCtxt;
    ULONG_PTR ContextFix;

    //
    // They need to provide at least one of these two
    //

    if (!phCredential && !phContext)
    {
        return( SEC_E_INVALID_HANDLE );
    }

    //
    // Need to determine which package to use.  Try the context handle first,
    // in case the context is actually present, and from a package other than
    // the credential (basically, the negotiator).
    //

    Package = NULL ;
    ResultCtxt.dwLower = (UINT_PTR) -1 ;
    if (phNewContext)
    {
        ResultCtxt.dwUpper = phNewContext->dwUpper;
    }

    if ( phContext )
    {
        //
        // Context is valid:
        //

        Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

        if ( !Package )
        {
            return( SEC_E_INVALID_HANDLE );
        }

        EffectiveCtxt = &TempCtxtHandle ;
    }
    else
    {
        EffectiveCtxt = NULL ;
    }

    //
    // Now do the creds:
    //

    if ( phCredential )
    {

        CredPackage = SecpValidateHandle( FALSE, phCredential, &TempCredHandle );

        if ( !CredPackage )
        {
            return( SEC_E_INVALID_HANDLE );
        }

        if ( !Package )
        {
            Package = CredPackage ;
        }

        EffectiveCreds = &TempCredHandle ;

    }
    else
    {
        EffectiveCreds = NULL ;
    }

    DebugLog(( DEB_TRACE, "AcceptSecurityContext( [%ws] %x : %x, %x : %x, ...)\n",
            Package->PackageName.Buffer,
            EffectiveCreds ? EffectiveCreds->dwUpper : 0 ,
            EffectiveCreds ? EffectiveCreds->dwLower : 0 ,
            EffectiveCtxt ? EffectiveCtxt->dwUpper : 0 ,
            EffectiveCtxt ? EffectiveCtxt->dwLower : 0  ));

    SetCurrentPackage( Package );

    scRet = Package->pftTable->AcceptSecurityContext(
                EffectiveCreds,
                EffectiveCtxt,
                pInput,
                fContextReq,
                TargetDataRep,
                &ResultCtxt,
                pOutput,
                pfContextAttr,
                ptsExpiry);

    if (NT_SUCCESS(scRet))
    {
        if ( ResultCtxt.dwLower != (UINT_PTR) -1 )
        {
            if ( Package->TypeMask & SECPKG_TYPE_NEW )
            {
                EndPackage = SecLocatePackageById( ResultCtxt.dwLower );
            }
            else
            {
                EndPackage = SecLocatePackageByOriginalLower( TRUE, Package, ResultCtxt.dwLower );
            }

            if (EndPackage == NULL)
            {
                //
                // This should only happen in an out-of-memory case
                //

                if ( Package->OriginalLowerCtxt == 0 )
                {
                    EndPackage = Package;
                }
                else
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY;
                    goto Cleanup;
                }
            }

            //
            // If the dwLower has been changed, then we need to store it away in the
            // package record, for a level of indirection.
            //
Retry_CtxtLowerTest:

            if ( EndPackage->fState & DLL_SECPKG_SAVE_LOWER )
            {
                //
                // Package has already been detected with a mapped handle value,
                // so, make sure they're the same,
                //

                if ( EndPackage->OriginalLowerCtxt != ResultCtxt.dwLower )
                {
                    DebugLog(( DEB_ERROR, "Security Package %ws is manipulating dwLower value inappropriately\n\treturned %p when %p expected.\n",
                            EndPackage->PackageName.Buffer, ResultCtxt.dwLower, EndPackage->OriginalLowerCtxt ));
                }
            }
            else
            {
                //
                // Package has not been tagged yet.  Time to do the dance
                //

                WriteLockPackageList();

                //
                // Test again.  If another thread is (has) updated, we should treat that as
                // authoritative.
                //

                if ( EndPackage->fState & DLL_SECPKG_SAVE_LOWER )
                {
                    //
                    // Another thread has fixed this up.  Release the lock, and jump back up
                    // to retry the operation.
                    //

                    WriteUnlockPackageList();

                    goto Retry_CtxtLowerTest;
                }

                //
                // Ok, we're the first.  Stick what the package wants as a dwLower into the
                // package record, and set the flag
                //

                EndPackage->OriginalLowerCtxt = ResultCtxt.dwLower;

                EndPackage->fState |= DLL_SECPKG_SAVE_LOWER;

                WriteUnlockPackageList();

            }

            Package = EndPackage;
        }

        if ( phNewContext )
        {
            phNewContext->dwLower = (ULONG_PTR) Package;
            phNewContext->dwUpper = ResultCtxt.dwUpper;
        }
    }

Cleanup:

    if ( !NT_SUCCESS(scRet)
         && phNewContext && Package && (Package->TypeMask & SECPKG_TYPE_NEW)
         && (ResultCtxt.dwLower != -1)
         && (Package->fState & DLL_SECPKG_SAVE_LOWER)
         && (Package->OriginalLowerCtxt != ResultCtxt.dwLower) ) // need to patch context handle
    {
        Package = SecLocatePackageById(ResultCtxt.dwLower);

        if (!Package) // already patched
        {
            *phNewContext = ResultCtxt;
        }
        else if ((Package->TypeMask & SECPKG_TYPE_NEW)
                 && (Package->fState & DLL_SECPKG_SAVE_LOWER))
        {
            phNewContext->dwUpper = ResultCtxt.dwUpper;
            phNewContext->dwLower = (ULONG_PTR) Package;
        }

        DebugLog((DEB_ERROR, "AcceptSecurityContext patched context %p:%p, package %p\n",
            phNewContext->dwUpper, phNewContext->dwLower, Package));
    }

    if ( phNewContext )
    {
        DebugLog(( DEB_TRACE, "AcceptSecurityContext returns %x, handle %x : %x\n",
                scRet, phNewContext->dwUpper, phNewContext->dwLower ));
    }

    return( scRet );
}


//+---------------------------------------------------------------------------
//
//  Function:   DeleteSecurityContext
//
//  Synopsis:   DeleteSecurityContext stub
//
//  Arguments:  [delete] --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
DeleteSecurityContext(
    PCtxtHandle                 phContext           // Context to delete
    )
{
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;
    SECURITY_STATUS scRet ;

    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {

        SetCurrentPackage( Package );

        scRet = Package->pftTable->DeleteSecurityContext( &TempCtxtHandle );

        if ( Package->fState & DLL_SECPKG_SASL_PROFILE )
        {
            SaslDeleteSecurityContext( &TempCtxtHandle );
        }
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return( scRet );
}

//+-------------------------------------------------------------------------
//
//  Function:   ApplyControlToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
ApplyControlToken(
    PCtxtHandle                 phContext,          // Context to modify
    PSecBufferDesc              pInput              // Input token to apply
    )
{
    SECURITY_STATUS     scRet = SEC_E_OK;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package ;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        SetCurrentPackage( Package );

        scRet = Package->pftTable->ApplyControlToken(
                                            &TempCtxtHandle,
                                            pInput );
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);
}


//+---------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackagesW
//
//  Synopsis:   EnumerateSecurityPackages stub
//
//  Arguments:  [pcPackages] --
//              [info]       --
//
//  History:    9-11-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
EnumerateSecurityPackagesW(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoW SEC_FAR *      ppPackageInfo       // Receives array of info
    )
{
    PDLL_SECURITY_PACKAGE   Package;

    Package = SecLocatePackageById( 0 );

    if (!Package) 
    {
        DebugLog((DEB_ERROR, "EnumerateSecurityPackagesW encountered an internal error\n"));

        return SEC_E_INSUFFICIENT_MEMORY;
    }

    if (SecEnumeratePackagesW( pcPackages, ppPackageInfo ))
    {
        return( SEC_E_OK );
    }

    DebugLog((DEB_ERROR, "EnumerateSecurityPackagesW insufficient memory error\n"));
    
    return ( SEC_E_INSUFFICIENT_MEMORY);
}

//+---------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackagesA
//
//  Synopsis:   Ansi stub
//
//  Arguments:  [pcPackages] --
//              [info]       --
//
//  History:    9-11-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
EnumerateSecurityPackagesA(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoA SEC_FAR *      ppPackageInfo       // Receives array of info
    )
{
    PDLL_SECURITY_PACKAGE   Package;

    Package = SecLocatePackageById( 0 );

    if (!Package) 
    {
        DebugLog((DEB_ERROR, "EnumerateSecurityPackagesA encountered an internal error\n"));
    
        return SEC_E_INSUFFICIENT_MEMORY;
    }

    if (SecEnumeratePackagesA( pcPackages, ppPackageInfo ))
    {
        return( SEC_E_OK );
    }

    DebugLog((DEB_ERROR, "EnumerateSecurityPackagesA insufficient memory error\n"));

    return( SEC_E_INSUFFICIENT_MEMORY );
}

//+---------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfoW
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pszPackageName] --
//              [info]           --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
QuerySecurityPackageInfoW(
    LPWSTR                      pszPackageName,     // Name of package
    PSecPkgInfoW SEC_FAR *      pPackageInfo        // Receives package info
    )
{
    SECURITY_STATUS scRet;
    PDLL_SECURITY_PACKAGE Package;

    Package = SecLocatePackageW( pszPackageName );

    scRet = SecCopyPackageInfoToUserW( Package, pPackageInfo );

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfoA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pszPackageName] --
//              [info]           --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
QuerySecurityPackageInfoA(
    LPSTR                       pszPackageName,     // Name of package
    PSecPkgInfoA SEC_FAR *      pPackageInfo        // Receives package info
    )
{
    SECURITY_STATUS scRet;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecLocatePackageA( pszPackageName );

    return SecCopyPackageInfoToUserA( Package, pPackageInfo );
}



//+-------------------------------------------------------------------------
//
//  Function:   CompleteAuthToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
CompleteAuthToken(
    PCtxtHandle                 phContext,          // Context to complete
    PSecBufferDesc              pInput              // Token to complete
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        SetCurrentPackage( Package );

        scRet = Package->pftTable->CompleteAuthToken(
                                            &TempCtxtHandle,
                                            pInput );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}



//+-------------------------------------------------------------------------
//
//  Function:   ImpersonateSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
ImpersonateSecurityContext(
    PCtxtHandle                 phContext           // Context to impersonate
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        SetCurrentPackage( Package );

        scRet = Package->pftTable->ImpersonateSecurityContext(
                                            &TempCtxtHandle );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   QuerySecurityContextToken
//
//  Synopsis:   Stub for QuerySecurityContextToken
//
//  Arguments:  [phContext]   --
//              [TokenHandle] --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
QuerySecurityContextToken(
    PCtxtHandle                 phContext,
    VOID * *                    TokenHandle
    )
{

    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        if ( Package->pftTable->QuerySecurityContextToken )
        {
            SetCurrentPackage( NULL );

            scRet = Package->pftTable->QuerySecurityContextToken(
                                                        &TempCtxtHandle,
                                                        TokenHandle );

        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION ;
        }
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);
}



SECURITY_STATUS
SEC_ENTRY
RevertSecurityContext(
    PCtxtHandle                 phContext           // Context from which to re
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        SetCurrentPackage( Package );

        scRet = Package->pftTable->RevertSecurityContext(
                                            &TempCtxtHandle );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   QueryContextAttributesW
//
//  Synopsis:   QueryContextAttributesW stub
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [attributes]  --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
QueryContextAttributesW(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        SetCurrentPackage( Package );

        scRet = Package->pftTableW->QueryContextAttributesW(
                                            &TempCtxtHandle,
                                            ulAttribute,
                                            pBuffer );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   QueryContextAttributesA
//
//  Synopsis:   ANSI stub
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [attributes]  --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
QueryContextAttributesA(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        SetCurrentPackage( Package );

        scRet = Package->pftTableA->QueryContextAttributesA(
                                            &TempCtxtHandle,
                                            ulAttribute,
                                            pBuffer );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   SetContextAttributesW
//
//  Synopsis:   SetContextAttributesW stub
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [attributes]  --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SetContextAttributesW(
    PCtxtHandle                 phContext,          // Context to Set
    unsigned long               ulAttribute,        // Attribute to Set
    void SEC_FAR *              pBuffer,            // Buffer for attributes
    unsigned long               cbBuffer            // Size (in bytes) of pBuffer
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {

        if ( Package->pftTableW->dwVersion >= SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_2 &&
             Package->pftTableW->SetContextAttributesW != NULL ) {

            SetCurrentPackage( Package );

            scRet = Package->pftTableW->SetContextAttributesW(
                                            &TempCtxtHandle,
                                            ulAttribute,
                                            pBuffer,
                                            cbBuffer );
        } else {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   SetContextAttributesA
//
//  Synopsis:   ANSI stub
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [attributes]  --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SetContextAttributesA(
    PCtxtHandle                 phContext,          // Context to Set
    unsigned long               ulAttribute,        // Attribute to Set
    void SEC_FAR *              pBuffer,            // Buffer for attributes
    unsigned long               cbBuffer            // Size (in bytes) of pBuffer
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {

        if ( Package->pftTableA->dwVersion >= SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_2 &&
             Package->pftTableA->SetContextAttributesA != NULL ) {

            SetCurrentPackage( Package );

            scRet = Package->pftTableA->SetContextAttributesA(
                                            &TempCtxtHandle,
                                            ulAttribute,
                                            pBuffer,
                                            cbBuffer );
        } else {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}



//+-------------------------------------------------------------------------
//
//  Function:   QueryCredentialsAttributes
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
QueryCredentialsAttributesW(
    PCredHandle                 phCredentials,      // Credentials to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCredHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( FALSE, phCredentials, &TempCredHandle );

    if ( Package )
    {
        if ( Package->pftTableW->QueryCredentialsAttributesW )
        {

            SetCurrentPackage( Package );

            scRet = Package->pftTableW->QueryCredentialsAttributesW(
                                            &TempCredHandle,
                                            ulAttribute,
                                            pBuffer );

        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION ;
        }
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

SECURITY_STATUS
SEC_ENTRY
QueryCredentialsAttributesA(
    PCredHandle                 phCredentials,      // Credentials to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCredHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( FALSE, phCredentials, &TempCredHandle );

    if ( Package )
    {
        if ( Package->pftTableA->QueryCredentialsAttributesA )
        {

            SetCurrentPackage( Package );

            scRet = Package->pftTableA->QueryCredentialsAttributesA(
                                            &TempCredHandle,
                                            ulAttribute,
                                            pBuffer );

        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION ;
        }
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

//+-------------------------------------------------------------------------
//
//  Function:   MakeSignature
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]     -- context to use
//              [fQOP]          -- quality of protection to use
//              [pMessage]      -- message
//              [MessageSeqNo]  -- sequence number of message
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
MakeSignature(  PCtxtHandle         phContext,
                ULONG               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {

        SetCurrentPackage( Package );

        scRet = Package->pftTable->MakeSignature(
                                            &TempCtxtHandle,
                                            fQOP,
                                            pMessage,
                                            MessageSeqNo );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);


}



//+-------------------------------------------------------------------------
//
//  Function:   VerifySignature
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]     -- Context performing the unseal
//              [pMessage]      -- Message to verify
//              [MessageSeqNo]  -- Sequence number of this message
//              [pfQOPUsed]     -- quality of protection used
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
VerifySignature(PCtxtHandle     phContext,
                PSecBufferDesc  pMessage,
                ULONG           MessageSeqNo,
                ULONG *         pfQOP)
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {

        SetCurrentPackage( Package );

        scRet = Package->pftTable->VerifySignature(
                                            &TempCtxtHandle,
                                            pMessage,
                                            MessageSeqNo,
                                            pfQOP );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   SealMessage
//
//  Synopsis:   Seals a message
//
//  Effects:
//
//  Arguments:  [phContext]     -- context to use
//              [fQOP]          -- quality of protection to use
//              [pMessage]      -- message
//              [MessageSeqNo]  -- sequence number of message
//
//  History:    5-06-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


SECURITY_STATUS
SEC_ENTRY
EncryptMessage( PCtxtHandle         phContext,
                ULONG               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;
    SEAL_MESSAGE_FN SealMessageFn;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        SetCurrentPackage( Package );

        SealMessageFn = (SEAL_MESSAGE_FN) Package->pftTable->Reserved3 ;

        scRet = (SealMessageFn)(
                                 &TempCtxtHandle,
                                 fQOP,
                                 pMessage,
                                 MessageSeqNo );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);



}

//+---------------------------------------------------------------------------
//
//  Function:   UnsealMessage
//
//  Synopsis:   Unseal a private message
//
//  Arguments:  [phContext]     -- Context performing the unseal
//              [pMessage]      -- Message to unseal
//              [MessageSeqNo]  -- Sequence number of this message
//              [pfQOPUsed]     -- quality of protection used
//
//  History:    5-06-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
DecryptMessage( PCtxtHandle         phContext,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo,
                ULONG *             pfQOP)
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;
    UNSEAL_MESSAGE_FN UnsealMessageFunc;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        SetCurrentPackage( Package );

        UnsealMessageFunc = (UNSEAL_MESSAGE_FN) Package->pftTable->Reserved4 ;

        scRet = (UnsealMessageFunc)(
                                     &TempCtxtHandle,
                                     pMessage,
                                     MessageSeqNo,
                                     pfQOP );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   InitSecurityInterfaceA
//
//  Synopsis:   Retrieves the ANSI interface table
//
//  Arguments:  (none)
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PSecurityFunctionTableA
SEC_ENTRY
InitSecurityInterfaceA(
    VOID )
{
    DebugLog((DEB_TRACE, "Doing it the hard way:  @%x\n", &SecTableA));

    return( &SecTableA );
}

//+-------------------------------------------------------------------------
//
//  Function:   InitSecurityInterface
//
//  Synopsis:   returns function table of all the security function
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

PSecurityFunctionTableW
SEC_ENTRY
InitSecurityInterfaceW(void)
{
    DebugLog((DEB_TRACE, "Doing it the hard way:  @%x\n", &SecTableW));

    return( &SecTableW );
}


//+-------------------------------------------------------------------------
//
//  Function:   ExportSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
ExportSecurityContext(
    IN PCtxtHandle ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer MarshalledContext,
    OUT PHANDLE TokenHandle
    )
{
    PDLL_SECURITY_PACKAGE Package;
    CtxtHandle TempContextHandle;
    SECURITY_STATUS SecStatus = STATUS_SUCCESS;

    Package = SecpValidateHandle(
                TRUE,
                ContextHandle,
                &TempContextHandle
                );
    if (Package != NULL)
    {
        if (Package->pftTable->ExportSecurityContext != NULL)
        {
            SetCurrentPackage(Package);

            SecStatus = Package->pftTable->ExportSecurityContext(
                            &TempContextHandle,
                            Flags,
                            MarshalledContext,
                            TokenHandle
                            );

        }
        else
        {
            SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        }
    }
    else
    {
        SecStatus = SEC_E_INVALID_HANDLE;
    }
    return(SecStatus);
}


//+-------------------------------------------------------------------------
//
//  Function:   ImportSecurityContextW
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
ImportSecurityContextW(
    IN LPWSTR PackageName,
    IN PSecBuffer MarshalledContext,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
    )
{
    PDLL_SECURITY_PACKAGE Package;
    CtxtHandle TempContextHandle = {-1,-1};
    SECURITY_STATUS SecStatus = STATUS_SUCCESS;

    if (!PackageName)
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    Package = SecLocatePackageW( PackageName );

    if ( Package == NULL )
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    if (Package->pftTableW->ImportSecurityContextW != NULL)
    {
        SetCurrentPackage(Package);

        SecStatus = Package->pftTable->ImportSecurityContextW(
                        PackageName,
                        MarshalledContext,
                        TokenHandle,
                        &TempContextHandle
                        );

    }
    else
    {
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
    }

    if (NT_SUCCESS(SecStatus))
    {
        ContextHandle->dwUpper = TempContextHandle.dwUpper;
        ContextHandle->dwLower = (ULONG_PTR) Package;


    }
    return(SecStatus);
}


//+-------------------------------------------------------------------------
//
//  Function:   ImportSecurityContextA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
ImportSecurityContextA(
    IN LPSTR PackageName,
    IN PSecBuffer MarshalledContext,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
    )
{
    PDLL_SECURITY_PACKAGE Package;
    CtxtHandle TempContextHandle = {-1,-1};
    SECURITY_STATUS SecStatus = STATUS_SUCCESS;

    if (!PackageName)
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    Package = SecLocatePackageA( PackageName );

    if ( Package == NULL )
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    if (Package->pftTableA->ImportSecurityContextA != NULL)
    {
        SetCurrentPackage(Package);

        SecStatus = Package->pftTableA->ImportSecurityContextA(
                        PackageName,
                        MarshalledContext,
                        TokenHandle,
                        &TempContextHandle
                        );

    }
    else
    {
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
    }

    if (NT_SUCCESS(SecStatus))
    {
        ContextHandle->dwUpper = TempContextHandle.dwUpper;
        ContextHandle->dwLower = (ULONG_PTR) Package;
    }
    return(SecStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\dll\package.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        Package.c
//
// Contents:    Package management routines for the security DLL
//
//
// History:     12 Mar 92,  RichardW    Created
//              17 Aug 92,  RichardW    Rearranged, commented, etc.
//              08 Mar 94,  MikeSw      Moved to C++
//
//------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <crypt.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
}

#define NAME_NAME           TEXT("Name")
#define COMMENT_NAME        TEXT("Comment")
#define CAPABILITIES_NAME   TEXT("Capabilities")
#define RPCID_NAME          TEXT("RpcId")
#define TIME_NAME           TEXT("Time")
#define TYPE_NAME           TEXT("Type")
#define VERSION_NAME        TEXT("Version")
#define TOKENSIZE_NAME      TEXT("TokenSize")

NTSTATUS
NTAPI
LsaRegisterCallback(
    ULONG   CallbackId,
    PLSA_CALLBACK_FUNCTION Callback
    );

NTSTATUS
SEC_ENTRY
NegUserModeInitialize(
    IN ULONG,
    OUT PULONG,
    OUT PSECPKG_USER_FUNCTION_TABLE *,
    OUT PULONG );

ULONG           SecPackageListLockCount;
RTL_RESOURCE    SecPackageListLock[ SECPKG_LIST_LOCKS_MAX ];

PDLL_BINDING *  SecPackageDllList;
ULONG           SecPackageDllCount;
ULONG           SecPackageDllTotal;

LIST_ENTRY      SecPackageControlList;
LIST_ENTRY      SecSaslProfileList ;

BOOL            SecPackageLsaLoaded;
BOOL            SecPackageSspiLoaded;
ULONG           SecLsaPackageCount;
ULONG           SecSspiPackageCount;
ULONG           SecSaslProfileCount;

#define SSPI_PACKAGE_OFFSET         0x00010000
#define INITIAL_PACKAGE_DLL_SIZE    4


SECPKG_DLL_FUNCTIONS SecpFTable = {
    (PLSA_ALLOCATE_LSA_HEAP) SecClientAllocate,
    (PLSA_FREE_LSA_HEAP) SecClientFree,
    LsaRegisterCallback

};

static PWSTR SecpAllowedDlls[] = { L"SCHANNEL.DLL",
                                       L"MSNSSPC.DLL"
                                     };

DLL_BINDING SecpBuiltinBinding;

SECURITY_STATUS
SecpLoadLsaPackages(
    VOID
    );

SECURITY_STATUS
SecpLoadSspiPackages(
    VOID 
    );

SECURITY_STATUS
SecpLoadSaslProfiles(
    VOID
    );

BOOL
SecSnapDelayLoadDll(
    PDLL_SECURITY_PACKAGE Package
    );

BOOL
SecpSnapPackage(
    PDLL_SECURITY_PACKAGE Package);

BOOL
SecpLoadSspiDll(
    PDLL_BINDING Dll
    );

BOOL
SecpBindSspiDll(
    IN PDLL_BINDING Binding,
    OUT PSecurityFunctionTableA * pTableA,
    OUT PSecurityFunctionTableW * pTableW,
    OUT PBOOL FixedUp
    );

BOOL
SecpSnapDll(
    IN PDLL_BINDING Binding,
    OUT PLIST_ENTRY PackageList,
    OUT PULONG PackageCount
    );


//+---------------------------------------------------------------------------
//
//  Function:   SecpDuplicateString
//
//  Synopsis:   Duplicates a unicode string
//
//  Arguments:  [New]      --
//              [Original] --
//
//  History:    8-20-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecpDuplicateString(
    PUNICODE_STRING New,
    PUNICODE_STRING Original)
{
    New->Buffer = (PWSTR) LocalAlloc( LMEM_FIXED, Original->Length + sizeof(WCHAR) );

    if ( New->Buffer )
    {
        New->MaximumLength = Original->Length + sizeof( WCHAR );

        New->Length = Original->Length;

        CopyMemory( New->Buffer, Original->Buffer, Original->MaximumLength );

        return( TRUE );

    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   SecpAddDllPackage
//
//  Synopsis:   Adds a "user" mode package to the list, at the end
//
//  Arguments:  [pPackage] --
//
//  History:    8-02-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SecpAddDllPackage(
    PDLL_SECURITY_PACKAGE pPackage)
{
    PDLL_SECURITY_PACKAGE *   pList;

    //
    // Grab exclusive access to the list:
    //

    WriteLockPackageList();

    //
    // Add to the tail.  Hopefully, the one first referenced will be at the
    // front, and incidental packages will end up at the end.
    //


    InsertTailList( &SecPackageControlList,
                    &pPackage->List );

    pPackage->pBinding->RefCount++;

    WriteUnlockPackageList();

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpRemovePackage
//
//  Synopsis:   Removes a package from the list, returning the control
//              structure for deref and freeing.
//
//  Arguments:  [PackageId] --
//
//  History:    8-02-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDLL_SECURITY_PACKAGE
SecpRemovePackage(
    ULONG_PTR PackageId)
{
    PDLL_SECURITY_PACKAGE   Kill = NULL;
    PLIST_ENTRY Scan;

    WriteLockPackageList();

    Scan = SecPackageControlList.Flink;

    while ( Scan != &SecPackageControlList )
    {
        Kill = (PDLL_SECURITY_PACKAGE) Scan;

        if ( Kill->PackageId == PackageId )
        {
            break;
        }

        Scan = Scan->Flink ;

        Kill = NULL;
    }


    if ( Kill )
    {
        RemoveEntryList( &Kill->List );

    }

    WriteUnlockPackageList();

    return( Kill );

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpAddDll
//
//  Synopsis:   Add a DLL Binding to the list
//
//  Arguments:  [pBinding] -- binding to add
//
//  History:    8-02-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecpAddDll(
    PDLL_BINDING    pBinding)
{
    PDLL_BINDING *  pList;
    ULONG           DllId;

    DebugLog((DEB_TRACE, "Adding binding for %ws\n", pBinding->Filename.Buffer ));

    WriteLockPackageList();

    if ( SecPackageDllCount == SecPackageDllTotal )
    {
        pList = (PDLL_BINDING *) LocalAlloc( LMEM_FIXED, sizeof(PDLL_BINDING) *
                                (SecPackageDllTotal + INITIAL_PACKAGE_DLL_SIZE));
        if (!pList)
        {
            WriteUnlockPackageList();
            return( FALSE );
        }

        CopyMemory( pList,
                    SecPackageDllList,
                    sizeof( PDLL_BINDING ) * SecPackageDllTotal );

        SecPackageDllTotal += INITIAL_PACKAGE_DLL_SIZE;

        LocalFree( SecPackageDllList );

        SecPackageDllList = pList;
    }

    pBinding->DllIndex = SecPackageDllCount;
    SecPackageDllList[ SecPackageDllCount++ ] = pBinding;

    WriteUnlockPackageList();

    return( TRUE );

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpRemoveDll
//
//  Synopsis:   Remove a DLL binding from the list
//
//  Arguments:  [pBinding] --
//
//  History:    8-02-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SecpRemoveDll(
    PDLL_BINDING    pBinding)
{
    ULONG i;

    WriteLockPackageList();

    if (SecPackageDllList[SecPackageDllCount - 1] == pBinding )
    {
        SecPackageDllCount --;

        SecPackageDllList[ SecPackageDllCount ] = NULL;
    }
    else
    {

        for (i = 0; i < SecPackageDllCount ; i++ )
        {
            if (SecPackageDllList[ i ] == pBinding)
            {
                SecPackageDllList[ i ] = NULL;
                break;
            }
        }
    }

    WriteUnlockPackageList();

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpFindDll
//
//  Synopsis:   Returns the binding for a DLL
//
//  Arguments:  [DllName] -- Path to search for
//
//  History:    8-06-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDLL_BINDING
SecpFindDll(
    PUNICODE_STRING DllName)
{
    ULONG i;
    PDLL_BINDING Binding;

    ReadLockPackageList();

    for ( i = 0 ; i < SecPackageDllCount ; i++ )
    {
        if (RtlEqualUnicodeString(  DllName,
                                    &SecPackageDllList[i]->Filename,
                                    TRUE ) )
        {
            break;
        }
    }

    if ( i < SecPackageDllCount )
    {
        Binding = SecPackageDllList[ i ];
    }
    else
    {
        Binding = NULL ;
    }

    UnlockPackageList();

    return( Binding );

}



//+---------------------------------------------------------------------------
//
//  Function:   SecInitializePackageControl
//
//  Synopsis:   Initializes package control structures
//
//  Arguments:  (none)
//
//  History:    8-02-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecInitializePackageControl(
    HINSTANCE   Instance)
{
    NTSTATUS Status = STATUS_SUCCESS;
    NT_PRODUCT_TYPE ProductType;
    ULONG LockIndex;

    SecPackageListLockCount = 1;


    RtlGetNtProductType( &ProductType );

    if( ProductType == NtProductLanManNt ||
        ProductType == NtProductServer )
    {

        SYSTEM_INFO si;

        GetSystemInfo( &si );

        //
        // if not an even power of two, bump it up.
        //

        if( si.dwNumberOfProcessors & 1 )
        {
            si.dwNumberOfProcessors++;
        }
        
        //
        // insure it fits in the confines of the max allowed.
        //

        if( si.dwNumberOfProcessors > SECPKG_LIST_LOCKS_MAX )
        {
            si.dwNumberOfProcessors = SECPKG_LIST_LOCKS_MAX;
        }

        if( si.dwNumberOfProcessors )
        {
            SecPackageListLockCount = si.dwNumberOfProcessors;
        }

    }


    //
    // list count is 1, or a power of two, for index purposes.
    //

    ASSERT( (SecPackageListLockCount == 1) || ((SecPackageListLockCount % 2) == 0) );
    
    for( LockIndex=0 ; LockIndex < SecPackageListLockCount ; LockIndex++ )
    {

        __try {
            RtlInitializeResource (&SecPackageListLock[LockIndex]);
        } __except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
    }

    if( !NT_SUCCESS(Status) )
    {
        return FALSE;
    }

    WriteLockPackageList();

    InitializeListHead( &SecPackageControlList );

    //
    // SASL Init
    //

    InitializeListHead( &SecSaslProfileList );

    InitializeListHead( &SaslContextList );

    Status = RtlInitializeCriticalSection( &SaslLock );

    if (!NT_SUCCESS(Status))
    {
        WriteUnlockPackageList();

        for( LockIndex=0 ; LockIndex < SecPackageListLockCount ; LockIndex++ )
        {
            RtlDeleteResource (&SecPackageListLock[LockIndex]);
        }

        return( FALSE );
    }

    SecPackageLsaLoaded = FALSE ;

    SecPackageSspiLoaded = FALSE ;

    SecpBuiltinBinding.Type = SecPkgBuiltin ;
    SecpBuiltinBinding.RefCount = 1;
    SecpBuiltinBinding.hInstance = Instance;

    SecPackageDllList = (PDLL_BINDING *) LocalAlloc( LMEM_FIXED, sizeof(PDLL_BINDING) *
                            INITIAL_PACKAGE_DLL_SIZE );

    if (SecPackageDllList)
    {
        SecPackageDllCount = 0;
        SecPackageDllTotal = INITIAL_PACKAGE_DLL_SIZE;

        WriteUnlockPackageList();

        return( TRUE );

    }

    WriteUnlockPackageList();
    RtlDeleteCriticalSection( &SaslLock );

    for( LockIndex=0 ; LockIndex < SecPackageListLockCount ; LockIndex++ )
    {
        RtlDeleteResource (&SecPackageListLock[LockIndex]);
    }

    return( FALSE );
}


VOID
SecpDerefDll(
    PDLL_BINDING    Dll
    )
{
    Dll->RefCount-- ;

    if ( Dll->RefCount == 0 )
    {
        LocalFree( Dll->Filename.Buffer );

        FreeLibrary( Dll->hInstance );

#if DBG
        ZeroMemory( Dll, sizeof( DLL_BINDING ) );
#endif
        LocalFree( Dll );
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpFreePackage
//
//  Synopsis:   Frees the resources allocated for a security package
//
//  Arguments:  pPackage     -- pointer to security package
//              fUnload      -- if TRUE, unload the package as well
//
//  History:    05-June-1999 kumarp
//
VOID
SecpFreePackage(
    IN PDLL_SECURITY_PACKAGE pPackage,
    IN BOOL fUnload
    )
{
    if ( fUnload && pPackage->pfUnloadPackage )
    {
        pPackage->pfUnloadPackage();
    }

    LocalFree( pPackage->PackageName.Buffer );
    LocalFree( pPackage->Comment.Buffer );
    LocalFree( pPackage->PackageNameA );
    LocalFree( pPackage->CommentA );

    if ( pPackage->pBinding )
    {
        SecpDerefDll( pPackage->pBinding );
    }

#if DBG
    ZeroMemory( pPackage, sizeof( DLL_SECURITY_PACKAGE ) );
#endif

    LocalFree( pPackage );
}

//+---------------------------------------------------------------------------
//
//  Function:   SecpFreePackages
//
//  Synopsis:   Frees the resources allocated for security packages
//
//  Arguments:  pSecPackageList -- pointer to security package list
//              fUnload         -- if TRUE, unload each package as well
//
//  History:    05-June-1999 kumarp
//
VOID
SecpFreePackages(
    IN PLIST_ENTRY pSecPackageList,
    IN BOOL fUnload
    )
{
    PDLL_SECURITY_PACKAGE pPackage;

    while ( !IsListEmpty( pSecPackageList ) )
    {
        pPackage = (PDLL_SECURITY_PACKAGE) RemoveHeadList( pSecPackageList );

        SecpFreePackage( pPackage, fUnload );
    }
}

VOID
SecpDeletePackage(
    PDLL_SECURITY_PACKAGE   Package
    )
{
    SecpFreePackage( Package, TRUE );
}

VOID
SecUnloadPackages(
    BOOLEAN ProcessTerminate
    )
{
    ULONG LockIndex;

    if( !ProcessTerminate )
    {
        WriteLockPackageList();
    }

    SecpFreePackages( &SecPackageControlList, TRUE );

    if( !ProcessTerminate )
    {
        WriteUnlockPackageList();
    }

    LocalFree( SecPackageDllList );

    for( LockIndex=0 ; LockIndex < SecPackageListLockCount ; LockIndex++ )
    {
        RtlDeleteResource (&SecPackageListLock[LockIndex]);
    }

    RtlDeleteCriticalSection( &SaslLock );
}

//+---------------------------------------------------------------------------
//
//  Function:   SecpScanPackageList
//
//  Synopsis:   Scans the list
//
//  Arguments:  [PackageName] -- Name (optional)
//              [PackageId]   -- Id, or -1
//
//  History:    8-19-96   RichardW   Created
//
//  Notes:      Assumes the list is locked
//
//----------------------------------------------------------------------------
PDLL_SECURITY_PACKAGE
SecpScanPackageList(
    ULONG TypeMask,
    PUNICODE_STRING PackageName OPTIONAL,
    ULONG_PTR PackageId)
{
    PLIST_ENTRY Scan;
    PDLL_SECURITY_PACKAGE Package;

    Package = NULL ;

    Scan = SecPackageControlList.Flink;

    while ( Scan != &SecPackageControlList )
    {
        Package = (PDLL_SECURITY_PACKAGE) Scan;

        DebugLog(( DEB_TRACE_PACKAGE, "Compare package %ws\n", Package->PackageName.Buffer ));

        if ( PackageName )
        {
            if ( RtlEqualUnicodeString( &Package->PackageName, PackageName, TRUE ) )
            {
                if ( TypeMask == SECPKG_TYPE_ANY )
                {
                    break;
                }
                if ( (Package->TypeMask & TypeMask) == TypeMask )
                {
                    break;
                }
            }
        }
        else
        {
            if ( Package->PackageId == PackageId )
            {
                if ( TypeMask == SECPKG_TYPE_ANY )
                {
                    break;
                }
                if ( (Package->TypeMask & TypeMask) == TypeMask )
                {
                    break;
                }
            }
        }

        Scan = Scan->Flink ;

        Package = NULL ;
    }


    return( Package );
}

//+---------------------------------------------------------------------------
//
//  Function:   SecLocatePackageByOriginalId
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [OriginalId] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    10-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDLL_SECURITY_PACKAGE
SecLocatePackageByOriginalLower(
    BOOL Context,
    PDLL_SECURITY_PACKAGE OriginalPackage,
    ULONG_PTR   OriginalLower)
{
    PDLL_SECURITY_PACKAGE Package;
    BOOL Hit ;

    ReadLockPackageList();

    Package = OriginalPackage->pRoot ;

    while ( Package )
    {
        DebugLog(( DEB_TRACE_PACKAGE, "Compare package %ws (%p)\n",
                Package->PackageName.Buffer,
                Package->OriginalLowerCtxt ));

        if ( Context )
        {
            Hit = (Package->OriginalLowerCtxt == OriginalLower );
        }
        else
        {
            Hit = ( Package->OriginalLowerCred == OriginalLower );
        }

        if ( ( Hit ) &&
             (Package->pBinding->DllIndex == OriginalPackage->pBinding->DllIndex) )
        {
            if ( ( Package->TypeMask & SECPKG_TYPE_NEW ) == 0 )
            {
                break;
            }
        }

        Package = Package->pPeer ;
    }

    UnlockPackageList();

    return( Package );

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpLocatePackage
//
//  Synopsis:   Common package locating loop
//
//  Arguments:  [PackageName] -- Name (or NULL)
//              [PackageId]   -- Id (or -1)
//
//  History:    8-02-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDLL_SECURITY_PACKAGE
SecpLocatePackage(
    ULONG TypeMask,
    PUNICODE_STRING PackageName OPTIONAL,
    ULONG_PTR PackageId
    )
{
    PDLL_SECURITY_PACKAGE Package;
    SECURITY_STATUS Status;

    Package = NULL ;

    //
    // Search in several stages.  First, see if it is there.  This is the
    // most common case.
    //

    ReadLockPackageList();

    Package = SecpScanPackageList( TypeMask, PackageName, PackageId );

    //
    // Found it.  We're done.
    //

    if ( Package )
    {
        UnlockPackageList();

        goto Cleanup;
    }


    //
    // Well, no luck that time.  See if the guy passed in something bogus:
    //

    if ( SecPackageLsaLoaded && SecPackageSspiLoaded )
    {
        //
        // The full list is present, and the name was not found.  We're done.
        //

        UnlockPackageList();

        goto Cleanup;
    }

    //
    // Bummer, have to load the missing packages:
    //

    UnlockPackageList();

    WriteLockPackageList();

    //
    // SecpLoadLsaPackages failure is fatal
    //

    Status = SecpLoadLsaPackages();

    if (SUCCEEDED(Status)) 
    {
        Status = SecpLoadSspiPackages();
    }

    if (SUCCEEDED(Status)) 
    {
        Status = SecpLoadSaslProfiles();
    }

    WriteUnlockPackageList();

    //
    // Try the search again, otherwise return NULL
    //

    if (SUCCEEDED(Status)) 
    {    
        ReadLockPackageList();
    
        Package = SecpScanPackageList( TypeMask, PackageName, PackageId );
    
        UnlockPackageList();
    }

Cleanup:

    
    //
    // Succeed or fail, tell them what we've got:
    //

    return ( Package );

}

//+---------------------------------------------------------------------------
//
//  Function:   SecLocatePackageW
//
//  Synopsis:   Wide stub to locate a package
//
//  Arguments:  [Package] -- Package name, wide
//
//  History:    8-02-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDLL_SECURITY_PACKAGE
SecLocatePackageW(
    LPWSTR  pszPackage
    )
{
    UNICODE_STRING  PackageName;
    PDLL_SECURITY_PACKAGE   Package;
    BOOL Success;

    RtlInitUnicodeString( &PackageName, pszPackage );

    Package = SecpLocatePackage( SECPKG_TYPE_WIDE, &PackageName, (ULONG) -1 );

    if ( Package )
    {
        //
        // If everything is set, return it.  Otherwise, snap the package
        //

        if ( ( Package->fState & DLL_SECPKG_DELAY_LOAD ) == 0  )
        {
            return( Package );
        }

        WriteLockPackageList();

        if ( ( Package->fState & DLL_SECPKG_DELAY_LOAD ) == 0  )
        {
            //
            // Another thread beat us to it
            //

            WriteUnlockPackageList();

            return( Package );
        }

        Success = SecpSnapPackage( Package );

        WriteUnlockPackageList();

        if ( Success )
        {
            return( Package );
        }

    }

    return( NULL );
}


//+---------------------------------------------------------------------------
//
//  Function:   SecLocatePackageA
//
//  Synopsis:   ANSI Stub to locate a package
//
//  Arguments:  [Package] -- ASCIIZ Package name,
//
//  History:    8-02-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDLL_SECURITY_PACKAGE
SecLocatePackageA(
    LPSTR   Package
    )
{
    UNICODE_STRING PackageName;
    NTSTATUS Status;
    PDLL_SECURITY_PACKAGE SecurityPackage;
    BOOL Success ;

    if (RtlCreateUnicodeStringFromAsciiz(
                    &PackageName,
                    Package ))
    {
        SecurityPackage = SecpLocatePackage( SECPKG_TYPE_ANSI, &PackageName, (ULONG) -1 );

        RtlFreeUnicodeString( &PackageName );

    }
    else
    {
        SecurityPackage = NULL ;
    }

    if ( SecurityPackage )
    {
        if ( ( SecurityPackage->fState & DLL_SECPKG_DELAY_LOAD ) == 0 )
        {
            return( SecurityPackage );
        }

        WriteLockPackageList();

        if ( ( SecurityPackage->fState & DLL_SECPKG_DELAY_LOAD ) == 0  )
        {
            //
            // Another thread beat us to it
            //

            WriteUnlockPackageList();

            return( SecurityPackage );
        }

        Success = SecpSnapPackage( SecurityPackage );

        WriteUnlockPackageList();

        if ( Success )
        {
            return( SecurityPackage );
        }

        SecurityPackage = NULL ;

    }

    return( SecurityPackage );
}

//+---------------------------------------------------------------------------
//
//  Function:   SecLocatePackageById
//
//  Synopsis:   Locates a package by ID
//
//  Arguments:  [PackageId] --
//
//  History:    8-06-96   RichardW   Created
//
//  Notes:      Also loads and snaps a DLL, due to the nature of where
//              this is called from.
//
//----------------------------------------------------------------------------
PDLL_SECURITY_PACKAGE
SecLocatePackageById(
    ULONG_PTR  PackageId )
{
    PDLL_SECURITY_PACKAGE   Package;
    BOOL    Success;

    Package = SecpLocatePackage( SECPKG_TYPE_ANY, NULL, PackageId );

    if ( !Package )
    {
        return( NULL );
    }

    if ( ( Package->fState & DLL_SECPKG_DELAY_LOAD ) == 0  )
    {
        return( Package );
    }

    WriteLockPackageList();

    if ( ( Package->fState & DLL_SECPKG_DELAY_LOAD ) == 0  )
    {
        //
        // Another thread beat us to it
        //

        WriteUnlockPackageList();

        return( Package );
    }

    Success = SecpSnapPackage( Package );

    WriteUnlockPackageList();

    if ( Success )
    {
        return( Package );
    }

    return( NULL );
}

PSASL_PROFILE
SecpScanProfileList(
    PUNICODE_STRING ProfileName
    )
{
    PSASL_PROFILE Profile = NULL ;
    PLIST_ENTRY Scan ;

    ReadLockPackageList();

    Scan = SecSaslProfileList.Flink ;

    while ( Scan != &SecSaslProfileList )
    {
        Profile = CONTAINING_RECORD( Scan, SASL_PROFILE, List );

        if ( RtlEqualUnicodeString( ProfileName,
                                    &Profile->ProfileName,
                                    TRUE ) )
        {
            break;
        }

        Scan = Scan->Flink ;
        Profile = NULL ;
    }

    UnlockPackageList();

    return Profile ;

}


PSASL_PROFILE
SecLocateSaslProfileA(
    LPSTR ProfileName
    )
{
    UNICODE_STRING ProfileNameU;
    NTSTATUS Status;
    BOOL Success ;
    PSASL_PROFILE Profile ;

    if ( RtlCreateUnicodeStringFromAsciiz(
                    &ProfileNameU,
                    ProfileName ) )
    {

        Profile = SecpScanProfileList( &ProfileNameU );

        RtlFreeUnicodeString( &ProfileNameU );

    }
    else
    {
        Profile = NULL ;
    }

    return Profile ;
}

PSASL_PROFILE
SecLocateSaslProfileW(
    LPWSTR ProfileName
    )
{
    UNICODE_STRING ProfileNameU ;

    RtlInitUnicodeString(&ProfileNameU, ProfileName );

    return SecpScanProfileList( &ProfileNameU );
}


//+---------------------------------------------------------------------------
//
//  Function:   SecpSnapNewDll
//
//  Synopsis:   Snaps and loads the function table for a new package DLL
//
//  Arguments:  [Package] -- package control
//
//  History:    8-15-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecpSnapNewDll(
    PDLL_SECURITY_PACKAGE   Package)
{
    PDLL_BINDING    Binding;
    SpUserModeInitializeFn  Func;
    ULONG   PackageVersion;
    NTSTATUS Status;
    PVOID Ignored;

    DebugLog((DEB_TRACE, "Snapping new-style package %d, %ws\n",
                Package->PackageId, Package->pBinding->Filename.Buffer ));

    Binding = Package->pBinding;

    if ( Binding == &SecpBuiltinBinding )
    {
        Func = NegUserModeInitialize ;
    }
    else
    {
        Func = (SpUserModeInitializeFn) GetProcAddress(
                                            Binding->hInstance,
                                            SECPKG_USERMODEINIT_NAME );

    }


    if ( !Func )
    {
        FreeLibrary( Binding->hInstance );

        Binding->hInstance = NULL ;

        return( FALSE );
    }

    __try
    {
        Status = (Func)(SECPKG_INTERFACE_VERSION,
                        &PackageVersion,
                        &Binding->Table,
                        &Binding->PackageCount );

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }

    if ( !NT_SUCCESS( Status ) )
    {
        FreeLibrary( Binding->hInstance );

        Binding->hInstance = NULL ;

        return( FALSE );
    }

    //
    // Done, the binding table is now in the DLL record:
    //

    Package->pftUTable = &Binding->Table[ Package->PackageIndex ];
    Package->pftTableW = &LsaFunctionTable ;
    Package->pftTableA = &LsaFunctionTableA ;
    Package->pftTable = &LsaFunctionTable ;
    Package->pfLoadPackage = LsaBootPackage ;
    Package->pfUnloadPackage = LsaUnloadPackage ;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   SecpSnapPackage
//
//  Synopsis:   Loads and snaps entry points for new packages
//
//  Arguments:  [Package] --
//
//  History:    8-15-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecpSnapPackage(
    PDLL_SECURITY_PACKAGE Package
    )
{
    PDLL_BINDING    Binding ;

    DebugLog((DEB_TRACE, "Snapping DLL for package %#x, %ws\n",
                    Package->PackageId, Package->pBinding->Filename.Buffer ));

    if ( Package->TypeMask & SECPKG_TYPE_OLD )
    {
        //
        // Old package that has been delay loaded.
        //

        return SecSnapDelayLoadDll( Package );

    }

    Binding = Package->pBinding ;

    if ( Binding->hInstance )
    {
        //
        // In case we got partway through package init
        // the last time SecpSnapPackage was called.
        //

        if (!(Package->fState & DLL_SECPKG_DELAY_LOAD))
        {
            if ( Package->TypeMask & SECPKG_TYPE_NEW )
            {
                Package->pftUTable = &Binding->Table[ Package->PackageIndex ];
                Package->pftTableW = &LsaFunctionTable ;
                Package->pftTableA = &LsaFunctionTableA ;
                Package->pftTable = &LsaFunctionTable ;

                return TRUE ;
            }
            else
            {
                return FALSE ;
            }
        }
    }
    else
    {
        Binding->hInstance = LoadLibraryW( Binding->Filename.Buffer );
    }

    if ( Binding->hInstance )
    {
        Binding->Type = SecPkgNewAW ;

        if ( Package->TypeMask & SECPKG_TYPE_NEW )
        {
            if ( !SecpSnapNewDll( Package ) )
            {
                return FALSE ;
            }
        }
        else
        {
            Binding->hInstance = NULL ;
            return FALSE ;
        }

        if ( Package->pfLoadPackage )
        {
            if ( Package->pfLoadPackage( Package ) )
            {
                //
                // Package has been successfully loaded
                // and initialized.  Mark it as loaded.
                //

                Package->fState &= ~(DLL_SECPKG_DELAY_LOAD) ;

                return TRUE ;
            }
        }
    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   SecpLoadLsaPackages
//
//  Synopsis:   Gets the list of LSA mode packages
//
//  Arguments:  (none)
//
//
//  History:    8-05-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SecpLoadLsaPackages(
    VOID
    )
{
    DWORD   i;
    PDLL_SECURITY_PACKAGE   Package;
    PDLL_LSA_PACKAGE_INFO   LsaInfo;
    PDLL_BINDING    Binding;
    PDLL_BINDING    ExistingBinding;
    SECURITY_STATUS Status;
    SECURITY_STRING Dll;
    SECURITY_STRING Comment;
    SECURITY_STRING Local;
    SEC_PACKAGE_BINDING_INFO Info;
    ANSI_STRING AnsiString = { 0 };

    //
    // Make sure we have a connection to the LSA
    //

    Status = IsOkayToExec(NULL);
     
    if (Status != SEC_E_OK)
    {
        goto Cleanup;
    }

    //
    // At this point, we have a count of the LSA packages:
    //

    for ( i = 0 ; i < SecLsaPackageCount ; i++ )
    {
        ExistingBinding = NULL;

        Package = (PDLL_SECURITY_PACKAGE) LocalAlloc( LMEM_FIXED,
                                            sizeof( DLL_SECURITY_PACKAGE ) +
                                            sizeof( DLL_LSA_PACKAGE_INFO ) );

        Binding = (PDLL_BINDING) LocalAlloc( LMEM_FIXED, sizeof( DLL_BINDING ) );

        if ( (Binding) && (Package) )
        {

            //
            // Get the binding info from the LSA
            //

            LsaInfo = (PDLL_LSA_PACKAGE_INFO) (Package + 1);



            Status = SecpGetBinding(i,
                                    &Info );

            if ( NT_SUCCESS( Status ) )
            {
                //
                // Clean up
                //

                ZeroMemory( Package, sizeof( DLL_SECURITY_PACKAGE ) +
                                     sizeof( DLL_LSA_PACKAGE_INFO ) );

                //
                // Copy names around
                //

                DebugLog((DEB_TRACE_PACKAGE, "Got binding info for %d : %ws\n", i, Info.PackageName.Buffer ));

                //
                // initialize the easy parts:
                //

                SecpLpcStringToSecurityString( &Local, &Info.PackageName );

                if ( !SecpDuplicateString( &Package->PackageName, &Local ) )
                {
                    Status = SEC_E_INSUFFICIENT_MEMORY ;
                }
                else
                {
                    Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                                            &Package->PackageName,
                                                            TRUE );
                }

                if ( NT_SUCCESS( Status ) )
                {
                    Package->PackageNameA = AnsiString.Buffer ;
                    Package->AnsiNameSize = AnsiString.Length + 1 ;

                    SecpLpcStringToSecurityString( &Local, &Info.Comment );

                    if ( !SecpDuplicateString( &Package->Comment, &Local ) )
                    {
                        Status = SEC_E_INSUFFICIENT_MEMORY ;
                    }
                    else
                    {

                        Status = RtlUnicodeStringToAnsiString(  &AnsiString,
                                                                &Package->Comment,
                                                                TRUE );
                    }

                    if ( NT_SUCCESS( Status ) )
                    {
                        Package->CommentA = AnsiString.Buffer ;
                        Package->AnsiCommentSize = AnsiString.Length + 1;
                    }
                }


                if ( !NT_SUCCESS( Status ) )
                {
                    //
                    // Clean up and bail out:
                    //

                    if ( Package->CommentA )
                    {
                        RtlFreeHeap( RtlProcessHeap(), 0, Package->CommentA );
                    }

                    if ( Package->Comment.Buffer )
                    {
                        LocalFree( Package->Comment.Buffer );
                    }

                    if ( Package->PackageNameA )
                    {
                        RtlFreeHeap( RtlProcessHeap(), 0, Package->PackageNameA );
                    }

                    if ( Package->PackageName.Buffer )
                    {
                        LocalFree( Package->PackageName.Buffer );
                    }

                    LsaFreeReturnBuffer( Info.PackageName.Buffer );

                    LocalFree( Package );
                    LocalFree( Binding );

                    continue;
                }


                Package->TypeMask = SECPKG_TYPE_NEW |
                                SECPKG_TYPE_ANSI |
                                SECPKG_TYPE_WIDE ;

                Package->fState |= DLL_SECPKG_DELAY_LOAD ;
                if ( ( Info.Flags & PACKAGEINFO_SIGNED ) == 0 )
                {
                    Package->fState |= DLL_SECPKG_NO_CRYPT ;
                }
                Package->PackageIndex = Info.PackageIndex ;
                Package->fCapabilities = Info.fCapabilities ;
                Package->Version = (WORD) Info.Version ;
                Package->RpcId = (WORD) Info.RpcId ;
                Package->TokenSize = Info.TokenSize ;
                Package->LsaInfo = LsaInfo ;

                InitializeListHead( &LsaInfo->Callbacks );

                if ( Info.ContextThunksCount )
                {
                    LsaInfo->ContextThunkCount = Info.ContextThunksCount ;
                    LsaInfo->ContextThunks = (PULONG) LocalAlloc( LMEM_FIXED,
                                                LsaInfo->ContextThunkCount *
                                                    sizeof(DWORD) );
                    if ( LsaInfo->ContextThunks )
                    {
                        CopyMemory( LsaInfo->ContextThunks,
                                    Info.ContextThunks,
                                    Info.ContextThunksCount * sizeof(DWORD) );
                    }
                    else
                    {
                        LsaInfo->ContextThunkCount = 0 ;
                    }
                }

                if ( Info.Flags & PACKAGEINFO_BUILTIN )
                {
                    Binding = &SecpBuiltinBinding ;
                }
                else
                {
                    //
                    // If the package index is non-zero, then it is one of n
                    // packages contained in the DLL.  Snap it.
                    //
                    // Note:  This relies on the fact that the zero package
                    // would already have been found and loaded, and the
                    // fact that the LSA gave them to us in this order is relied
                    // upon.
                    //

                    if ( Package->PackageIndex != 0 )
                    {

                        SecpLpcStringToSecurityString( &Local, &Info.ModuleName );

                        ExistingBinding = SecpFindDll( &Local );

                        if ( ExistingBinding )
                        {
                            LocalFree( Binding );

                            Binding = ExistingBinding ;
                        }
                        else
                        {
                            ZeroMemory( Binding, sizeof( DLL_BINDING) );
                        }
                    }
                    else
                    {
                        ZeroMemory( Binding, sizeof( DLL_BINDING ) );
                    }

                    //
                    // If the file name isn't there already (new binding)
                    // copy it in as well.
                    //

                    if ( Binding->Filename.Buffer == NULL )
                    {
                        Binding->Type = SecPkgNewAW;

                        if ( Info.Flags & PACKAGEINFO_SIGNED )
                        {
                            Binding->Flags |= DLL_BINDING_SIG_CHECK ;
                        }

                        SecpLpcStringToSecurityString( &Local, &Info.ModuleName );

                        if (!SecpDuplicateString( &Binding->Filename, &Local ))
                        {
                            //
                            // Clean up and bail out:
                            //

                            if ( Package->CommentA )
                            {
                                RtlFreeHeap( RtlProcessHeap(), 0, Package->CommentA );
                            }

                            if ( Package->Comment.Buffer )
                            {
                                LocalFree( Package->Comment.Buffer );
                            }

                            if ( Package->PackageNameA )
                            {
                                RtlFreeHeap( RtlProcessHeap(), 0, Package->PackageNameA );
                            }

                            if ( Package->PackageName.Buffer )
                            {
                                LocalFree( Package->PackageName.Buffer );
                            }

                            LsaFreeReturnBuffer( Info.PackageName.Buffer );

                            LocalFree( Package );

                            if (ExistingBinding == NULL)
                            {
                                LocalFree( Binding );
                            }

                            continue;
                        }

                        //
                        // Add the DLL binding to the list (defer the load)
                        //

                        SecpAddDll( Binding );
                    }
                }

                //
                // Set package Ids and such
                //

                Package->PackageId = i;

                Package->pBinding = Binding;

                //
                // Add the package to the list (defer the load)
                //

                SecpAddDllPackage( Package );

                //
                // Clean up:
                //

                LsaFreeReturnBuffer( Info.PackageName.Buffer );


                //
                // Snap the builtin package(s) immediately
                //

                if ( Info.Flags & PACKAGEINFO_BUILTIN )
                {
                    SecpSnapNewDll( Package );
                    Package->fState &= ~(DLL_SECPKG_DELAY_LOAD) ;
                }
            }
            else
            {
                //
                // Call to LSA failed:
                //

                if ( Package )
                {
                    LocalFree( Package );
                }

                if ( Binding )
                {
                    LocalFree( Binding );
                }
            }

        }   //  if binding and package test
        else
        {
            if ( Package )
            {
                LocalFree( Package );
            }

            if ( Binding )
            {
                LocalFree( Binding );
            }

        }

    }   // for loop

    SecPackageLsaLoaded = TRUE;

    Status = SEC_E_OK;

Cleanup:
    
    return Status;

}


//+-------------------------------------------------------------------------
//
//  Function:   LocalWcsTok
//
//  Synopsis:   takes a pointer to a string, returns a pointer to the next
//              token in the string and sets StringStart to point to the
//              end of the string.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
LPWSTR
LocalWcsTok(
    LPWSTR String,
    LPWSTR Token,
    LPWSTR * NextStringStart
    )
{
    ULONG Index;
    ULONG Tokens;
    LPWSTR StartString;
    LPWSTR EndString;
    BOOLEAN Found;

    if (String == NULL)
    {
        *NextStringStart = NULL;
        return(NULL);
    }
    Tokens = wcslen(Token);

    //
    // Find the beginning of the string.
    //

    StartString = (LPTSTR) String;
    while (*StartString != L'\0')
    {
        Found = FALSE;
        for (Index = 0; Index < Tokens;  Index++)
        {
            if (*StartString == Token[Index])
            {
                StartString++;
                Found = TRUE;
                break;
            }
        }
        if (!Found)
        {
            break;
        }
    }

    //
    // There are no more tokens in this string.
    //

    if (*StartString == L'\0')
    {
        *NextStringStart = NULL;
        return(NULL);
    }

    EndString = StartString + 1;
    while (*EndString != L'\0')
    {
        for (Index = 0; Index < Tokens;  Index++)
        {
            if (*EndString == Token[Index])
            {
                *EndString = L'\0';
                *NextStringStart = EndString+1;
                return(StartString);
            }
        }
        EndString++;
    }
    *NextStringStart = NULL;
    return(StartString);

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpReadPackageList
//
//  Synopsis:   Reads the SSPI package list from the registry, and returns it
//              as separate strings, and a count
//
//  Arguments:  [pPackageCount] -- Number of SSPI DLLs
//              [pPackageArray] -- Names of DLLs
//
//  History:    8-19-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SecpReadPackageList(
    PULONG      pPackageCount,
    LPWSTR * *  pPackageArray,
    PVOID *     BasePointer,
    LPFILETIME  LastChange
    )
{
    HKEY RootKey = NULL;
    ULONG Error;
    ULONG Type;
    LPWSTR Packages = NULL;
    ULONG PackageSize = 0;
    LPWSTR PackageCopy = NULL;
    ULONG PackageCount = 0;
    LPWSTR PackageName;
    LPWSTR * PackageArray = NULL;
    ULONG Index;
    SECURITY_STATUS Status;
    LPWSTR TempString;

    //
    // Try to open the key.  If it isn't there, that's o.k.
    //

    *pPackageCount = 0;
    *pPackageArray = NULL;

    Error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\SecurityProviders"),
                0,
                KEY_READ,
                &RootKey );


    if (Error != 0)
    {
        return( SEC_E_OK );
    }

    if ( LastChange )
    {
        RegQueryInfoKey( RootKey,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         LastChange );
    }

    //
    // Try to read the value.  If the value is not there, that is
    // o.k.
    //

    Error = RegQueryValueEx(
                RootKey,
                L"SecurityProviders",
                NULL,
                &Type,
                (PUCHAR) Packages,
                &PackageSize
                );

    if ((Error == ERROR_FILE_NOT_FOUND) ||
        (Type != REG_SZ))
    {
        RegCloseKey(RootKey);

        return( SEC_E_OK );
    }
    else if (Error != 0)
    {
        RegCloseKey(RootKey);
        return(SEC_E_CANNOT_INSTALL);
    }

    if (PackageSize <= sizeof(UNICODE_NULL))
    {
        RegCloseKey(RootKey);

        return( SEC_E_OK );
    }

    Packages = (LPWSTR) LocalAlloc(0,2 * PackageSize);
    if (Packages == NULL)
    {
        RegCloseKey(RootKey);

        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    PackageCopy = (LPWSTR) ((PBYTE) Packages + PackageSize);

    Error = RegQueryValueEx(
                RootKey,
                L"SecurityProviders",
                NULL,
                &Type,
                (PUCHAR) Packages,
                &PackageSize
                );

    RegCloseKey(RootKey);

    if (Error != 0)
    {
        LocalFree(Packages);
        return(SEC_E_CANNOT_INSTALL);
    }

    RtlCopyMemory(
        PackageCopy,
        Packages,
        PackageSize
        );


    //
    // Pull the package names out of the string to count the number
    //

    PackageName = LocalWcsTok(PackageCopy,L" ,", &TempString);
    while (PackageName != NULL)
    {
        PackageCount++;
        PackageName = LocalWcsTok(TempString, L" ,", &TempString);
    }

    //
    // Now make an array of the package dll names.
    //


    PackageArray = (LPWSTR *) LocalAlloc(0,PackageCount * sizeof(LPWSTR));
    if (PackageArray == NULL)
    {
        LocalFree(Packages);
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    PackageName = LocalWcsTok(Packages,L" ,",&TempString);
    Index = 0;
    while (PackageName != NULL)
    {
        PackageArray[Index++] = PackageName;
        PackageName = LocalWcsTok(TempString, L" ,",&TempString);
    }

    *pPackageCount = PackageCount;
    *pPackageArray = PackageArray;
    *BasePointer = Packages ;

    return( SEC_E_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   SecpLoadSspiPackages
//
//  Synopsis:   Loads the set of SSPI packages
//
//  Arguments:  (none)
//
//  History:    8-20-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SecpLoadSspiPackages(
    VOID 
    )
{
    PVOID BasePointer ;
    PWSTR * DllNames;
    ULONG   DllCount;
    ULONG   i;
    ULONG   j;
    SECURITY_STATUS Status;
    PDLL_BINDING    Binding;
    WCHAR   DllPath[ MAX_PATH ];
    PWSTR   Path;
    DWORD   PathLen;
    UNICODE_STRING Maybe;
    UNICODE_STRING Allowed;

    Status = SecpReadPackageList(
        &DllCount,
        &DllNames,
        &BasePointer,
        NULL 
        );

    if (NT_ERROR( Status ))
    {
        DebugLog((DEB_ERROR, "SecpLoadSspiPackages SecpReadPackageList %#x\n", Status));

        return Status;
    }

    if ( DllCount == 0 )
    {
        return SEC_E_OK;
    }

    for ( i = 0 ; i < DllCount ; i++ )
    {
        PathLen = SearchPath(NULL,
            DllNames[i],
            NULL,
            MAX_PATH,
            DllPath,
            &Path 
            );
        if ( PathLen )
        {
            RtlInitUnicodeString( &Maybe, DllPath );

            if ( SecpFindDll( &Maybe ) )
            {
                continue;
            }

            Binding = (PDLL_BINDING) LocalAlloc( LMEM_FIXED, sizeof( DLL_BINDING ) );

            if ( Binding )
            {

                ZeroMemory( Binding, sizeof( DLL_BINDING ) );

                Binding->Type = SecPkgOld;

                Binding->Filename.Buffer = (PWSTR) LocalAlloc( LMEM_FIXED,
                                (PathLen + 1) * sizeof(WCHAR) );

                if ( Binding->Filename.Buffer )
                {
                    Binding->Filename.MaximumLength = (USHORT)((PathLen + 1) * sizeof(WCHAR));
                    Binding->Filename.Length = Binding->Filename.MaximumLength - 2;

                    CopyMemory( Binding->Filename.Buffer,
                                DllPath,
                                Binding->Filename.MaximumLength );

                } else {
                    LocalFree( Binding );
                    continue;
                }

                SecpAddDll( Binding );

                RtlInitUnicodeString( &Maybe, DllNames[i] );
                for ( j = 0 ; j < sizeof(SecpAllowedDlls) / sizeof(PWSTR) ; j++ )
                {
                    RtlInitUnicodeString( &Allowed, SecpAllowedDlls[j] );

                    if ( RtlEqualUnicodeString( &Maybe, &Allowed, TRUE ) == 1)
                    {
                        Binding->Flags |= DLL_BINDING_SIG_CHECK;
                        break;
                    }
                }

            }
        }
    }

    //
    // Enumerate through DLLs, snapping their packages:
    //

    for ( i = 0 ; i < SecPackageDllCount ; i++ )
    {
        Binding = SecPackageDllList[ i ];

        if ( Binding->Type == SecPkgOld )
        {
            SecpLoadSspiDll( Binding );
        }

    }

    SecPackageSspiLoaded = TRUE;

    LocalFree( BasePointer );
    LocalFree( DllNames );

    return SEC_E_OK;
}

BOOL
SecSnapDelayLoadDll(
    PDLL_SECURITY_PACKAGE Package
    )
{
    PSecurityFunctionTableA TableA ;
    PSecurityFunctionTableW TableW ;
    BOOL FixedUp ;

    if ( SecpBindSspiDll( Package->pBinding,
                          &TableA,
                          &TableW,
                          &FixedUp ) )
    {

        Package->pftTableW = TableW;
        Package->pftTable = TableW;
        Package->pftTableA = TableA ;

        //
        // ensure that we delay load the package only once
        //
        Package->fState    &= ~DLL_SECPKG_DELAY_LOAD;

        return TRUE ;
    }

    return FALSE ;
}

//+---------------------------------------------------------------------------
//
//  Function:   SecpRefDllFromCache
//
//  Synopsis:   Checks the registry to see if this DLL should be defer-loaded,
//              and returns true if so.  A DLL_SECURITY_PACKAGE structure is
//              created
//
//  Effects:
//
//  Arguments:  [Binding] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    10-24-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecpRefDllFromCache(
    PDLL_BINDING Binding
    )
{
    HKEY LsaKey ;
    HKEY PackageKey ;
    int err ;
    PWSTR FileName ;
    DWORD Type ;
    DWORD Size ;
    DWORD Temp ;
    PDLL_SECURITY_PACKAGE Package ;
    PDLL_SECURITY_PACKAGE Search ;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        TEXT("System\\CurrentControlSet\\Control\\Lsa\\SspiCache"),
                        0,
                        KEY_READ,
                        &LsaKey );

    if ( err )
    {
        return FALSE ;
    }

    FileName = &Binding->Filename.Buffer[ Binding->Filename.Length / 2 ];

    while ( (FileName != Binding->Filename.Buffer) &&
            (*FileName != TEXT('\\') ) )
    {
        FileName-- ;
    }

    FileName++ ;

    err = RegOpenKeyEx( LsaKey,
                        FileName,
                        0,
                        KEY_READ,
                        &PackageKey );


    if ( err )
    {
        RegCloseKey( LsaKey );

        return FALSE ;
    }

    Package = (PDLL_SECURITY_PACKAGE) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                          sizeof( DLL_SECURITY_PACKAGE ) );

    if ( !Package )
    {
        RegCloseKey( LsaKey );

        RegCloseKey( PackageKey );

        return FALSE ;
    }


    Size = 0 ;

    err = RegQueryValueEx( PackageKey,
                           NAME_NAME,
                           0,
                           &Type,
                           NULL,
                           &Size );

    if ( ( err ) || ( Type != REG_SZ ) )
    {
        DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        NAME_NAME ));
        goto BadCacheEntry ;
    }

    Package->PackageName.Buffer = (PWSTR) LocalAlloc( LMEM_FIXED, Size );

    if ( Package->PackageName.Buffer )
    {
        err = RegQueryValueEx( PackageKey,
                               NAME_NAME,
                               0,
                               &Type,
                               (PUCHAR) Package->PackageName.Buffer,
                               &Size );

        if ( err || ( Type != REG_SZ ) )
        {
            DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        NAME_NAME ));
            goto BadCacheEntry ;
        }

        Package->PackageName.MaximumLength = (WORD) Size ;
        Package->PackageName.Length = (WORD) Size - sizeof( WCHAR );

    }
    else
    {
        DebugLog(( DEB_ERROR, "Out of memory allocating %x\n", Size ));
        goto OutOfMemory ;
    }

    Size = 0 ;

    err = RegQueryValueEx( PackageKey,
                           COMMENT_NAME,
                           0,
                           &Type,
                           NULL,
                           &Size );

    if ( ( err ) || ( Type != REG_SZ ) )
    {
        DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        COMMENT_NAME ));
        goto BadCacheEntry ;
    }

    Package->Comment.Buffer = (PWSTR) LocalAlloc( LMEM_FIXED, Size );

    if ( Package->Comment.Buffer)
    {
        err = RegQueryValueEx( PackageKey,
                               COMMENT_NAME,
                               0,
                               &Type,
                               (PUCHAR) Package->Comment.Buffer,
                               &Size );

        if ( err || ( Type != REG_SZ ) )
        {
        DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        COMMENT_NAME ));
            goto BadCacheEntry ;
        }

        Package->Comment.MaximumLength = (WORD) Size ;
        Package->Comment.Length = (WORD) Size - sizeof( WCHAR );


    }
    else
    {
        DebugLog(( DEB_ERROR, "Out of memory allocating %x\n", Size ));
        goto OutOfMemory ;
    }

    //
    // Easy stuff now:
    //

    Size = sizeof( Temp );

    err = RegQueryValueEx( PackageKey,
                           CAPABILITIES_NAME,
                           0,
                           &Type,
                           (PUCHAR) &Temp,
                           &Size );

    if ( err || ( Type != REG_DWORD ) )
    {
        DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        CAPABILITIES_NAME ));
        goto BadCacheEntry ;
    }

    Package->fCapabilities = Temp ;

    err = RegQueryValueEx( PackageKey,
                           RPCID_NAME,
                           0,
                           &Type,
                           (PUCHAR) &Temp,
                           &Size );

    if ( err || ( Type != REG_DWORD ) )
    {
        DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        RPCID_NAME ));
        goto BadCacheEntry ;
    }

    Package->RpcId = (WORD) Temp ;

    err = RegQueryValueEx( PackageKey,
                           VERSION_NAME,
                           0,
                           &Type,
                           (PUCHAR) &Temp,
                           &Size );

    if ( err || ( Type != REG_DWORD ) )
    {
        DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        VERSION_NAME ));
        goto BadCacheEntry ;
    }

    Package->Version = (WORD) Temp ;

    err = RegQueryValueEx( PackageKey,
                           TYPE_NAME,
                           0,
                           &Type,
                           (PUCHAR) &Temp,
                           &Size );

    if ( err || ( Type != REG_DWORD ) )
    {
        DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        TYPE_NAME ));
        goto BadCacheEntry ;
    }

    Package->TypeMask = Temp ;

    err = RegQueryValueEx( PackageKey,
                           TOKENSIZE_NAME,
                           0,
                           &Type,
                           (PUCHAR) &Temp,
                           &Size );

    if ( err || ( Type != REG_DWORD ) )
    {

        DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        TOKENSIZE_NAME ));
        goto BadCacheEntry ;
    }

    Package->TokenSize = Temp ;

    //
    // Okay, we have read all the info back out of the registry cache.
    // we now will add the package to the list, and return done.
    //

    Package->pBinding = Binding ;
    Package->fState = DLL_SECPKG_DELAY_LOAD ;
    Binding->Flags |= DLL_BINDING_DELAY_LOAD ;
    Package->PackageId = (SecSspiPackageCount++) + SSPI_PACKAGE_OFFSET ;
    Package->PackageIndex = 0;
    Package->pRoot = Package ;
    Package->pPeer = NULL ;


    if ( Package->TypeMask & SECPKG_TYPE_ANSI )
    {
        Package->AnsiNameSize = RtlUnicodeStringToAnsiSize( &Package->PackageName ) + 1;

        Package->PackageNameA = (LPSTR) LocalAlloc( LMEM_FIXED,
                        Package->AnsiNameSize );
        if ( Package->PackageNameA )
        {
            ANSI_STRING String ;

            String.Length = 0 ;
            String.Buffer = Package->PackageNameA ;
            String.MaximumLength = (WORD) Package->AnsiNameSize ;

            RtlUnicodeStringToAnsiString(
                    &String,
                    &Package->PackageName,
                    FALSE );

        }

        Package->AnsiCommentSize = RtlUnicodeStringToAnsiSize( &Package->Comment ) + 1;

        Package->CommentA = (LPSTR) LocalAlloc( LMEM_FIXED,
                        Package->AnsiCommentSize );
        if ( Package->CommentA )
        {
            ANSI_STRING String ;

            String.Length = 0 ;
            String.Buffer = Package->CommentA ;
            String.MaximumLength = (WORD) Package->AnsiCommentSize ;

            RtlUnicodeStringToAnsiString(
                    &String,
                    &Package->Comment,
                    FALSE );

        }

        DebugLog((DEB_TRACE_PACKAGE, "Added ANSI entrypoints for %ws\n",
                        Package->PackageName.Buffer ));

    }

    WriteLockPackageList();

    Search = SecpScanPackageList( SECPKG_TYPE_ANY,
                                  &Package->PackageName,
                                  -1 );

    if ( !Search )
    {
        SecpAddDllPackage( Package );
    }
    else
    {
        DebugLog(( DEB_TRACE, "Duplicate package, %ws\n", Package->PackageName.Buffer ));
        SecpDeletePackage( Package );
    }

    WriteUnlockPackageList();

    RegCloseKey(LsaKey);
    RegCloseKey(PackageKey);
    return TRUE ;


BadCacheEntry:

    RegDeleteKey( LsaKey, FileName );


OutOfMemory:

    RegCloseKey( LsaKey );

    RegCloseKey( PackageKey );

    SecpDeletePackage( Package );

    return FALSE ;

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpLoadSspiDll
//
//  Synopsis:   Loads a DLL, and pulls all the packages out of it.
//
//  Effects:
//
//  Arguments:  [Binding] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-06-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecpLoadSspiDll(
    PDLL_BINDING Binding
    )
{
    LIST_ENTRY DllPackageList ;
    ULONG DllPackageCount ;
    PDLL_SECURITY_PACKAGE Package ;
    PDLL_SECURITY_PACKAGE Search ;
    PLIST_ENTRY Pop ;


    DebugLog(( DEB_TRACE, "Loading SSPI DLL %ws\n", Binding->Filename.Buffer ));

    //
    // This function is called on a lazy snap as well as the up-front
    // snap.  This flag is set if the DLL was marked as DELAY the first time
    // through.  Therefore, if it is not set, see if we're supposed to delay
    // load it.  If it is set, then we now really need it.
    //

    if ( (Binding->Flags & DLL_BINDING_DELAY_LOAD) == 0  )
    {
        if ( SecpRefDllFromCache( Binding ) )
        {
            DebugLog(( DEB_TRACE, "Deferring SSPI DLL %ws\n", Binding->Filename.Buffer ));
            return TRUE ;
        }
    }
    else
    {
        Binding->Flags &= ~(DLL_BINDING_DELAY_LOAD) ;
    }

    if ( SecpSnapDll( Binding, &DllPackageList, &DllPackageCount ) )
    {
        //
        // The DLL has been snapped, and the individual packages are
        // in the list, ready to be added.
        //

        while ( !IsListEmpty( &DllPackageList ) )
        {
            Pop = RemoveHeadList( &DllPackageList );

            Package = CONTAINING_RECORD( Pop, DLL_SECURITY_PACKAGE, List );

            WriteLockPackageList();

            Search = SecpScanPackageList( SECPKG_TYPE_ANY,
                                          &Package->PackageName,
                                          -1 );

            if ( !Search )
            {
                SecpAddDllPackage( Package );
            }
            else
            {
                DebugLog(( DEB_TRACE, "Duplicate package, %ws\n", Package->PackageName.Buffer ));
                SecpDeletePackage( Package );
            }

            WriteUnlockPackageList();
        }

        return TRUE ;

    }

    return FALSE ;

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpBindSspiDll
//
//  Synopsis:   Load the DLL, get out the dispatch tables.  Note if they were
//              fixed up due to a seal/unseal issue.
//
//  Arguments:  [Binding] --
//              [pTableA] --
//              [pTableW] --
//              [FixedUp] --
//
//  History:    12-22-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecpBindSspiDll(
    IN PDLL_BINDING Binding,
    OUT PSecurityFunctionTableA * pTableA,
    OUT PSecurityFunctionTableW * pTableW,
    OUT PBOOL FixedUp
    )
{
    HINSTANCE  hPackage;
    INIT_SECURITY_INTERFACE_W   InitW;
    INIT_SECURITY_INTERFACE_A   InitA;
    PSecurityFunctionTableA     TableA;
    PSecurityFunctionTableW     TableW;
    PSecurityFunctionTableA     FixupA = NULL ;
    PSecurityFunctionTableW     FixupW = NULL ;

    if ( RtlCheckSignatureInFile( Binding->Filename.Buffer ) )
    {
        Binding->Flags |= DLL_BINDING_SIG_CHECK ;
    }

    hPackage = LoadLibraryW( Binding->Filename.Buffer );
    if (!hPackage)
    {
        return( FALSE );
    }

    *FixedUp = FALSE ;

    Binding->hInstance = hPackage ;

    InitW = (INIT_SECURITY_INTERFACE_W)
            GetProcAddress(hPackage,"InitSecurityInterfaceW");

    InitA = (INIT_SECURITY_INTERFACE_A)
            GetProcAddress(hPackage,"InitSecurityInterfaceA");

    if ( ( InitW == NULL ) && ( InitA == NULL ) )
    {
        FreeLibrary( hPackage );

        return( FALSE );
    }

    if ( ( InitW == InitSecurityInterfaceW ) ||
         ( InitA == InitSecurityInterfaceA ) )
    {
        FreeLibrary( hPackage );

        return FALSE ;
    }

    if ( ( InitW ) && ( ! InitA ) )
    {
        Binding->Type = SecPkgOldW;
    }
    else
    {
        if ( ( InitW ) && ( InitA ) )
        {
            Binding->Type = SecPkgOldAW;
        }
        else
        {
            Binding->Type = SecPkgOldA;
        }
    }

    if ( InitA )
    {
        __try
        {
            TableA = InitA();
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            TableA = NULL ;
        }
    }
    else
    {
        TableA = NULL ;
    }

    if ( InitW )
    {
        __try
        {
            TableW = InitW();
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            TableW = NULL ;
        }
    }
    else
    {
        TableW = NULL ;
    }

    if ( ( ( InitW ) && ( TableW == NULL ) ) ||
         ( ( InitA ) && ( TableA == NULL ) ) )
    {
        FreeLibrary( hPackage );

        return( FALSE );
    }

    //
    // Security Fixups:
    //
    if ( TableW )
    {
        if ( (TableW->Reserved3) || (TableW->EncryptMessage) ||
             (TableW->Reserved4) || (TableW->DecryptMessage) )
        {
            if ( (Binding->Flags & DLL_BINDING_SIG_CHECK ) == 0 )
            {
                FixupW = (PSecurityFunctionTableW)
                                LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                            sizeof( SecurityFunctionTableW) );

                if ( FixupW )
                {
                    CopyMemory( FixupW, TableW, sizeof( SecurityFunctionTableW ) );

                    FixupW->Reserved3 = SecpFailedSealFunction ;
                    FixupW->EncryptMessage = SecpFailedSealFunction ;
                    FixupW->Reserved4 = SecpFailedUnsealFunction ;
                    FixupW->DecryptMessage = SecpFailedUnsealFunction ;

                    Binding->Flags |= DLL_BINDING_FREE_TABLE ;

                    TableW = FixupW ;

                    *FixedUp = TRUE ;
                }
                else
                {
                    FreeLibrary( hPackage );

                    return( FALSE );
                }
            }
        }
    }

    if ( TableA )
    {
        if ( (TableA->Reserved3) || (TableA->EncryptMessage) ||
             (TableA->Reserved4) || (TableA->DecryptMessage) )
        {
            if ( (Binding->Flags & DLL_BINDING_SIG_CHECK ) == 0 )
            {
                FixupA = (PSecurityFunctionTableA)
                                LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                            sizeof( SecurityFunctionTableA) );

                if ( FixupA )
                {
                    CopyMemory( FixupA, TableA, sizeof( SecurityFunctionTableA ) );

                    FixupA->Reserved3 = SecpFailedSealFunction ;
                    FixupA->EncryptMessage = SecpFailedSealFunction ;
                    FixupA->Reserved4 = SecpFailedUnsealFunction ;
                    FixupA->DecryptMessage = SecpFailedUnsealFunction ;

                    TableA = FixupA;

                    Binding->Flags |= DLL_BINDING_FREE_TABLE ;

                    *FixedUp = TRUE ;
                }
                else
                {
                    FreeLibrary( hPackage );

                    if ( FixupW )
                    {
                        LocalFree( FixupW );
                    }

                    return( FALSE );
                }
            }
        }
    }

    *pTableW = TableW ;
    *pTableA = TableA ;

    return TRUE ;

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpSnapDll
//
//  Synopsis:   Snap a DLL, reading the set of packages it contains
//
//  Arguments:  [Binding] --
//
//  History:    8-20-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecpSnapDll(
    IN PDLL_BINDING Binding,
    OUT PLIST_ENTRY PackageList,
    OUT PULONG PackageCount
    )
{

    PLIST_ENTRY Scan ;
    PDLL_SECURITY_PACKAGE Package = NULL;
    PDLL_SECURITY_PACKAGE RootPackage;
    PDLL_SECURITY_PACKAGE LastPackage;
    PSecurityFunctionTableA     TableA=NULL;
    PSecurityFunctionTableW     TableW=NULL;
    DWORD                       cPackages = 0 ;
    PSecPkgInfoA                PackageInfoA = NULL ;
    PSecPkgInfoW                PackageInfoW = NULL ;
    SECURITY_STATUS             scRet=SEC_E_OK;
    SECURITY_STRING             PackageName;
    SECURITY_STRING             String;
    DWORD                       i;
    BOOL                        FixedUp=FALSE;

    DebugLog((DEB_TRACE, "Snapping Packages from DLL %ws\n", Binding->Filename.Buffer ));

    InitializeListHead( PackageList );
    *PackageCount = 0 ;

    if ( ! SecpBindSspiDll( Binding, &TableA, &TableW, &FixedUp ) )
    {
        scRet = SEC_E_SECPKG_NOT_FOUND;
        goto Cleanup;
    }

    if ( TableW )
    {
        __try
        {
            scRet = TableW->EnumerateSecurityPackagesW( &cPackages,
                                                        &PackageInfoW );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            scRet = SEC_E_INVALID_HANDLE ;
        }

        RootPackage = NULL ;
        LastPackage = NULL ;
        if ( NT_SUCCESS( scRet ) )
        {
            for ( i = 0 ; i < cPackages ; i++ )
            {
                Package = (PDLL_SECURITY_PACKAGE) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                            sizeof( DLL_SECURITY_PACKAGE ) );

                if ( Package )
                {
                    Package->TypeMask = SECPKG_TYPE_OLD | SECPKG_TYPE_WIDE ;

                    Package->fCapabilities = PackageInfoW[i].fCapabilities ;
                    Package->pftTableW = TableW;
                    Package->pftTable = TableW;
                    Package->PackageId = (SecSspiPackageCount++) + SSPI_PACKAGE_OFFSET ;
                    Package->PackageIndex = i ;
                    if ( i == 0 )
                    {
                        RootPackage = Package ;
                    }
                    Package->pRoot = RootPackage ;
                    if ( LastPackage )
                    {
                        LastPackage->pPeer = Package ;
                    }
                    LastPackage = Package ;


                    RtlInitUnicodeString( &String, PackageInfoW[ i ].Name );

                    if (!SecpDuplicateString( &Package->PackageName, &String ))
                    {
                        LocalFree(Package);

                        scRet = SEC_E_INSUFFICIENT_MEMORY;
                        break;
                    }

                    Package->PackageNameA = NULL ;

                    RtlInitUnicodeString( &String, PackageInfoW[ i ].Comment );

                    if (!SecpDuplicateString( &Package->Comment, &String ))
                    {
                        LocalFree(Package->PackageName.Buffer);
                        LocalFree(Package);

                        scRet = SEC_E_INSUFFICIENT_MEMORY;
                        break;
                    }

                    Package->Version = PackageInfoW[ i ].wVersion ;
                    Package->RpcId = PackageInfoW[ i ].wRPCID ;
                    Package->TokenSize = PackageInfoW[ i ].cbMaxToken ;

                    Package->pBinding = Binding ;

                    if ( RootPackage )
                    {
                        Package->pBinding->RefCount++;
                    }

                    (*PackageCount)++ ;

                    DebugLog((DEB_TRACE_PACKAGE, "Snapped wide package %ws\n", Package->PackageName.Buffer ));

                    InsertTailList( PackageList, &Package->List );
                }
                else
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY;
                    break;
                }
            }
        }
        else
        {
            goto Cleanup;
        }
    }

    if ( TableA && NT_SUCCESS(scRet))
    {
        __try
        {
            scRet = TableA->EnumerateSecurityPackagesA( &cPackages,
                                                        &PackageInfoA );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            scRet = SEC_E_INVALID_HANDLE ;
        }

        if ( NT_SUCCESS( scRet ) )
        {
            RootPackage = NULL ;
            LastPackage = NULL ;

            for ( i = 0 ; i < cPackages ; i++ )
            {
                if ( RtlCreateUnicodeStringFromAsciiz( &PackageName,
                                                  PackageInfoA[i].Name ) )
                {
                    Scan = PackageList->Flink ;

                    while ( Scan != PackageList )
                    {
                        Package = CONTAINING_RECORD( Scan, DLL_SECURITY_PACKAGE, List );

                        if ( RtlCompareUnicodeString( &PackageName,
                                                      &Package->PackageName,
                                                      TRUE ) == 0 )
                        {
                            break;
                        }

                        Package = NULL ;

                        Scan = Scan->Flink ;

                    }

                    if ( Package )
                    {
                        Package->TypeMask |= SECPKG_TYPE_ANSI ;

                        Package->pftTableA = TableA;
                        RtlFreeUnicodeString( &PackageName );

                        Package->AnsiNameSize = strlen( PackageInfoA[i].Name ) + 1;

                        Package->PackageNameA = (LPSTR) LocalAlloc( LMEM_FIXED,
                                        Package->AnsiNameSize );
                        if ( Package->PackageNameA )
                        {
                            CopyMemory( Package->PackageNameA,
                                        PackageInfoA[i].Name,
                                        Package->AnsiNameSize );

                        }

                        Package->AnsiCommentSize = strlen( PackageInfoA[ i ].Comment ) + 1;

                        Package->CommentA = (LPSTR) LocalAlloc( LMEM_FIXED,
                                            Package->AnsiCommentSize );

                        if ( Package->CommentA )
                        {
                            CopyMemory( Package->CommentA,
                                        PackageInfoA[i].Comment,
                                        Package->AnsiCommentSize );
                        }

                        DebugLog((DEB_TRACE_PACKAGE, "Added ANSI entrypoints for %s\n",
                                        PackageInfoA[i].Name ));

                        continue;
                    }
                }

                Package = (PDLL_SECURITY_PACKAGE) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                            sizeof( DLL_SECURITY_PACKAGE ) );

                if ( Package )
                {
                    Package->TypeMask = SECPKG_TYPE_OLD | SECPKG_TYPE_ANSI ;
                    Package->fCapabilities = PackageInfoA[i].fCapabilities ;
                    Package->pftTableA = TableA;
                    Package->pftTable = (PSecurityFunctionTableW) TableA;
                    Package->PackageId = (SecSspiPackageCount++) + SSPI_PACKAGE_OFFSET ;
                    Package->PackageIndex = i ;

                    if ( i == 0 )
                    {
                        RootPackage = Package ;
                    }
                    Package->pRoot = RootPackage ;
                    if ( LastPackage )
                    {
                        LastPackage->pPeer = Package ;
                    }
                    LastPackage = Package ;

                    Package->PackageName = PackageName ;

                    Package->AnsiNameSize = strlen( PackageInfoA[i].Name ) + 1;

                    Package->PackageNameA = (LPSTR) LocalAlloc( LMEM_FIXED,
                                    Package->AnsiNameSize );
                    if ( Package->PackageNameA )
                    {
                        CopyMemory( Package->PackageNameA,
                                    PackageInfoA[i].Name,
                                    Package->AnsiNameSize );

                    }
                    else
                    {
                        LocalFree(Package);

                        scRet = SEC_E_INSUFFICIENT_MEMORY;
                        break;
                    }

                    Package->AnsiCommentSize = strlen( PackageInfoA[ i ].Comment ) + 1;

                    Package->CommentA = (LPSTR) LocalAlloc( LMEM_FIXED,
                                        Package->AnsiCommentSize );

                    if ( Package->CommentA )
                    {
                        CopyMemory( Package->CommentA,
                                    PackageInfoA[i].Comment,
                                    Package->AnsiCommentSize );
                    }
                    else
                    {
                        LocalFree(Package->PackageNameA);
                        LocalFree(Package);

                        scRet = SEC_E_INSUFFICIENT_MEMORY;
                        break;
                    }

                    Package->pBinding = Binding ;

                    (*PackageCount)++ ;

                    DebugLog((DEB_TRACE_PACKAGE, "Snapped ansi package %ws\n", Package->PackageName.Buffer ));

                    InsertTailList( PackageList, &Package->List );
                }
                else
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY;
                    break;
                }
            }
        }
    }

Cleanup:

    if ( !NT_SUCCESS(scRet) )
    {
        //
        // do cleanup on error
        //

        SecpFreePackages(PackageList, FALSE);

        if (FixedUp)
        {
            LocalFree( TableA );
            LocalFree( TableW );
        }
    }

    return NT_SUCCESS(scRet);
}


//+---------------------------------------------------------------------------
//
//  Function:   SecEnumeratePackagesA
//
//  Synopsis:   Worker for EnumerateSecurityPackages.
//
//  Arguments:  [PackageCount] --
//              [Packages]     --
//
//  History:    8-21-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecEnumeratePackagesA(
    PULONG          PackageCount,
    PSecPkgInfoA *  Packages)
{
    PLIST_ENTRY Scan;
    PDLL_SECURITY_PACKAGE   Package;
    ULONG                   Count;
    ULONG                   StringSize;
    PSecPkgInfoA    Info;
    LPSTR   String;

    Count = 0;

    StringSize = 0;

    *PackageCount = 0 ;

    *Packages = NULL ;

    ReadLockPackageList();

    Scan = SecPackageControlList.Flink;

    while ( Scan != &SecPackageControlList )
    {
        Package = (PDLL_SECURITY_PACKAGE) Scan;

        if ( Package->TypeMask & SECPKG_TYPE_ANSI )
        {
            Count++;

            StringSize += Package->AnsiNameSize +
                          Package->AnsiCommentSize ;

        }

        Scan = Scan->Flink ;

        Package = NULL ;
    }

    Info = (PSecPkgInfoA) LocalAlloc( LMEM_FIXED, Count * sizeof( SecPkgInfoA ) +
                                                    StringSize );

    if ( !Info )
    {
        UnlockPackageList();

        return( FALSE );
    }

    String = (LPSTR) &Info[ Count ];

    Count = 0;

    Scan = SecPackageControlList.Flink;

    while ( Scan != &SecPackageControlList )
    {
        Package = (PDLL_SECURITY_PACKAGE) Scan;

        if ( Package->TypeMask & SECPKG_TYPE_ANSI )
        {
            Info[ Count ].fCapabilities = Package->fCapabilities ;
            Info[ Count ].wVersion = Package->Version ;
            Info[ Count ].wRPCID = Package->RpcId ;
            Info[ Count ].cbMaxToken = Package->TokenSize ;
            Info[ Count ].Name = String ;

            CopyMemory( String,
                        Package->PackageNameA,
                        Package->AnsiNameSize);

            String += Package->AnsiNameSize;

            Info[ Count ].Comment = String ;

            CopyMemory( String,
                        Package->CommentA,
                        Package->AnsiCommentSize);

            String += Package->AnsiCommentSize ;

            Count++;


        }

        Scan = Scan->Flink ;

        Package = NULL ;
    }

    UnlockPackageList();

    *PackageCount = Count ;
    *Packages = Info ;

    return( TRUE );

}
//+---------------------------------------------------------------------------
//
//  Function:   SecEnumeratePackagesW
//
//  Synopsis:   Worker for EnumerateSecurityPackages
//
//  Arguments:  [PackageCount] --
//              [Packages]     --
//
//  History:    8-21-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecEnumeratePackagesW(
    PULONG  PackageCount,
    PSecPkgInfoW *  Packages)
{
    PLIST_ENTRY Scan;
    PDLL_SECURITY_PACKAGE   Package;
    ULONG                   Count;
    ULONG                   StringSize;
    PSecPkgInfoW    Info;
    PWSTR   String;

    Count = 0;

    StringSize = 0;

    *PackageCount = 0 ;

    *Packages = NULL ;

    ReadLockPackageList();

    Scan = SecPackageControlList.Flink;

    while ( Scan != &SecPackageControlList )
    {
        Package = (PDLL_SECURITY_PACKAGE) Scan;

        if ( Package->TypeMask & SECPKG_TYPE_WIDE )
        {
            Count++;

            StringSize += Package->PackageName.Length + sizeof(WCHAR) +
                          Package->Comment.Length + sizeof(WCHAR) ;

        }

        Scan = Scan->Flink ;

        Package = NULL ;
    }

    Info = (PSecPkgInfoW) LocalAlloc( LMEM_FIXED, Count * sizeof( SecPkgInfoW ) +
                                                    StringSize );

    if ( !Info )
    {
        UnlockPackageList();

        return( FALSE );
    }

    String = (PWSTR) &Info[ Count ];

    Count = 0;

    Scan = SecPackageControlList.Flink;

    while ( Scan != &SecPackageControlList )
    {
        Package = (PDLL_SECURITY_PACKAGE) Scan;

        if ( Package->TypeMask & SECPKG_TYPE_WIDE )
        {
            Info[ Count ].fCapabilities = Package->fCapabilities ;
            Info[ Count ].wVersion = Package->Version ;
            Info[ Count ].wRPCID = Package->RpcId ;
            Info[ Count ].cbMaxToken = Package->TokenSize ;
            Info[ Count ].Name = String ;

            CopyMemory( String,
                        Package->PackageName.Buffer,
                        Package->PackageName.Length );

            String += Package->PackageName.Length / sizeof(WCHAR);

            *String ++ = L'\0';

            Info[ Count ].Comment = String ;

            CopyMemory( String,
                        Package->Comment.Buffer,
                        Package->Comment.Length );

            String += Package->Comment.Length / sizeof(WCHAR) ;

            *String++ = L'\0';

            Count++;


        }

        Scan = Scan->Flink ;

        Package = NULL ;
    }

    UnlockPackageList();

    *PackageCount = Count ;
    *Packages = Info ;

    return( TRUE );

}

//+---------------------------------------------------------------------------
//
//  Function:   SecSetPackageFlag
//
//  Synopsis:   Sets a package flag
//
//  Arguments:  [Package] --
//              [Flag]    --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SecSetPackageFlag(
    PDLL_SECURITY_PACKAGE   Package,
    ULONG Flag)
{
    //
    // this optimization relies on the fact that SecClearPackageFlag is unused.
    //

    if( (Package->fState & Flag) == Flag )
    {
        return;
    }

    WriteLockPackageList();

    Package->fState |= Flag ;

    WriteUnlockPackageList();
}


//+---------------------------------------------------------------------------
//
//  Function:   SecClearPackageFlag
//
//  Synopsis:   Clears a package flag
//
//  Arguments:  [Package] --
//              [Flag]    --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SecClearPackageFlag(
    PDLL_SECURITY_PACKAGE Package,
    ULONG Flag)
{
    //
    // SetPackageFlag assumes this function remains un-used.  assert on that.
    //

    ASSERT( TRUE == FALSE );

    WriteLockPackageList();

    Package->fState &= ~(Flag);

    WriteUnlockPackageList();
}

//+---------------------------------------------------------------------------
//
//  Function:   SecpFailedSealFunction
//
//  Synopsis:   Stuck into the seal slot for packages that aren't allowed to
//              seal messages.
//
//  Arguments:  [phContext]    --
//              [fQOP]         --
//              [pMessage]     --
//              [MessageSeqNo] --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SecpFailedSealFunction(
    PCtxtHandle         phContext,
    ULONG               fQOP,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo)
{
    return( SEC_E_UNSUPPORTED_FUNCTION );

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpFailedUnsealFunction
//
//  Synopsis:   Stuck into the unseal slot for packages that aren't allowed
//              to unseal messages.
//
//  Arguments:  [phHandle]     --
//              [pMessage]     --
//              [MessageSeqNo] --
//              [pfQOP]        --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SecpFailedUnsealFunction(
    PCtxtHandle phHandle,
    PSecBufferDesc pMessage,
    ULONG MessageSeqNo,
    ULONG * pfQOP)
{
    return( SEC_E_UNSUPPORTED_FUNCTION );

}

//+---------------------------------------------------------------------------
//
//  Function:   LsaRegisterCallback
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [CallbackId] --
//              [Callback]   --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-25-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
NTAPI
LsaRegisterCallback(
    ULONG   CallbackId,
    PLSA_CALLBACK_FUNCTION Callback
    )
{
    PDLL_LSA_CALLBACK pCallback ;
    PDLL_SECURITY_PACKAGE Package ;

    Package = (PDLL_SECURITY_PACKAGE) GetCurrentPackage();

    if ( !Package )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    pCallback = (PDLL_LSA_CALLBACK) LocalAlloc( LMEM_FIXED,
                        sizeof( DLL_LSA_CALLBACK ) );

    if ( !pCallback )
    {
        return STATUS_NO_MEMORY ;
    }

    pCallback->CallbackId = CallbackId ;
    pCallback->Callback = Callback ;

    WriteLockPackageList();

    InsertTailList( &Package->LsaInfo->Callbacks, &pCallback->List );

    WriteUnlockPackageList();

    return STATUS_SUCCESS ;
}

extern "C"
NTSTATUS
WINAPI
SecCacheSspiPackages(
    VOID
    )
{
    PWSTR * DllNames;
    ULONG   DllCount;
    LARGE_INTEGER CacheTime ;
    LARGE_INTEGER ListTime ;
    LARGE_INTEGER DllTime ;
    LARGE_INTEGER CacheDllTime ;
    DWORD Type ;
    DWORD Size ;
    ULONG   i;
    ULONG   j;
    SECURITY_STATUS Status;
    PDLL_BINDING    Binding;
    WCHAR   DllPath[ MAX_PATH ];
    PWSTR   Path;
    DWORD   PathLen;
    UNICODE_STRING Maybe;
    UNICODE_STRING Allowed;
    PDLL_SECURITY_PACKAGE Package ;
    PLIST_ENTRY Scan ;
    LIST_ENTRY PackageList ;
    ULONG PackageCount ;
    HKEY LsaKey ;
    HKEY hKey ;
    int err ;
    DWORD Disp ;
    BOOL SnapDll ;
    HANDLE hDllFile ;
    DWORD Temp ;
    PVOID BasePointer ;


    err = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT( "System\\CurrentControlSet\\Control\\Lsa\\SspiCache" ),
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_READ | KEY_WRITE,
                NULL,
                &LsaKey,
                &Disp );

    if ( err )
    {
        return NtCurrentTeb()->LastStatusValue ;
    }

    if ( Disp == REG_OPENED_EXISTING_KEY )
    {
        Size = sizeof( CacheTime );

        err = RegQueryValueEx( LsaKey,
                         TIME_NAME,
                         0,
                         &Type,
                         (PUCHAR) &CacheTime,
                         &Size );

        if ( (err) || ( Type != REG_BINARY ) )
        {
            CacheTime.QuadPart = 0 ;
        }

    }
    else
    {
        CacheTime.QuadPart = 0 ;
    }


    Status = SecpReadPackageList(
                &DllCount,
                &DllNames,
                &BasePointer,
                (LPFILETIME) &ListTime );

    if ( NT_ERROR( Status ) )
    {
        RegCloseKey( LsaKey );

        return Status;
    }

    //
    // Caching trick:  If the cache time is greater than the
    // list time (meaning the cache was updated later than
    // the list of security packages), merely check the DLL
    // time stamps.  If the cache is out of date, or the file
    // info is out of date, snap and check the DLL.
    //

    for ( i = 0 ; i < DllCount ; i++ )
    {
        PathLen = SearchPath(NULL,
                        DllNames[i],
                        NULL,
                        MAX_PATH,
                        DllPath,
                        &Path );
        if ( PathLen )
        {
            Binding = (PDLL_BINDING) LocalAlloc( LMEM_FIXED, sizeof( DLL_BINDING ) );

            if ( Binding )
            {

                ZeroMemory( Binding, sizeof( DLL_BINDING ) );

                Binding->Type = SecPkgOld;
                Binding->RefCount = 1;

                Binding->Filename.Buffer = (PWSTR) LocalAlloc( LMEM_FIXED,
                                (PathLen + 1) * sizeof(WCHAR) );

                if ( Binding->Filename.Buffer )
                {
                    Binding->Filename.MaximumLength = (USHORT)((PathLen + 1) * sizeof(WCHAR));
                    Binding->Filename.Length = Binding->Filename.MaximumLength - 2;

                    CopyMemory( Binding->Filename.Buffer,
                                DllPath,
                                Binding->Filename.MaximumLength );

                }

                SnapDll = FALSE ;

                err = RegCreateKeyEx(
                            LsaKey,
                            DllNames[i],
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE | KEY_READ,
                            NULL,
                            &hKey,
                            &Disp );

                if ( err )
                {
                    //
                    // bust out.  Note:  if the path in the registry is not
                    // just a file name, this will fail.  Thus, any absolute
                    // security package path will not be cached.
                    //

                    SecpDerefDll( Binding );

                    continue;
                }


                if ( CacheTime.QuadPart > ListTime.QuadPart )
                {
                    //
                    // Check the time in the cache.
                    //

                    CacheDllTime.QuadPart = 0 ;

                    Size = sizeof( CacheDllTime );

                    err = RegQueryValueEx( hKey,
                                           TIME_NAME,
                                           NULL,
                                           &Type,
                                           (PUCHAR) &CacheDllTime,
                                           &Size );

                    //
                    // If this can't be found (key just created, e.g.)
                    // CacheDllTime will be 0, still less than the file time
                    // on the DLL itself.
                    //

                    hDllFile = CreateFile( Binding->Filename.Buffer,
                                           GENERIC_READ,
                                           FILE_SHARE_READ | FILE_SHARE_DELETE,
                                           NULL,
                                           OPEN_EXISTING,
                                           FILE_ATTRIBUTE_NORMAL,
                                           NULL );

                    if ( hDllFile == INVALID_HANDLE_VALUE )
                    {
                        SecpDerefDll( Binding );

                        continue;
                    }

                    GetFileTime( hDllFile, NULL, NULL, (LPFILETIME) &DllTime );

                    CloseHandle( hDllFile );

                    if ( CacheDllTime.QuadPart < DllTime.QuadPart )
                    {
                        SnapDll = TRUE ;
                    }

                }
                else
                {
                    SnapDll = TRUE ;
                }

                if ( SnapDll )
                {
                    if ( !SecpSnapDll( Binding, &PackageList, &PackageCount ) )
                    {
                        RegCloseKey( hKey );

                        RegDeleteKey( LsaKey,
                                      DllNames[i] );

                        continue;

                    }

                    //
                    // if there's only one package, we're set!
                    //

                    if ( PackageCount == 1 )
                    {
                        //
                        // Update the cache entry:
                        //

                        Scan = RemoveHeadList( &PackageList );

                        Package = CONTAINING_RECORD( Scan, DLL_SECURITY_PACKAGE, List );

                        RegSetValueEx(
                                hKey,
                                NAME_NAME,
                                0,
                                REG_SZ,
                                (PUCHAR) Package->PackageName.Buffer,
                                Package->PackageName.Length + 2 );

                        RegSetValueEx(
                                hKey,
                                COMMENT_NAME,
                                0,
                                REG_SZ,
                                (PUCHAR) Package->Comment.Buffer,
                                Package->Comment.Length + 2 );

                        RegSetValueEx(
                                hKey,
                                CAPABILITIES_NAME,
                                0,
                                REG_DWORD,
                                (PUCHAR) &Package->fCapabilities,
                                sizeof(DWORD) );

                        Temp = (DWORD) Package->RpcId ;

                        RegSetValueEx(
                                hKey,
                                RPCID_NAME,
                                0,
                                REG_DWORD,
                                (PUCHAR) &Temp,
                                sizeof( DWORD ) );

                        Temp = (DWORD) Package->Version ;

                        RegSetValueEx(
                                hKey,
                                VERSION_NAME,
                                0,
                                REG_DWORD,
                                (PUCHAR) &Temp,
                                sizeof( DWORD ) );


                        Temp = (DWORD) Package->TokenSize ;

                        RegSetValueEx(
                                hKey,
                                TOKENSIZE_NAME,
                                0,
                                REG_DWORD,
                                (PUCHAR) &Temp,
                                sizeof( DWORD ) );


                        hDllFile = CreateFile( Binding->Filename.Buffer,
                                                GENERIC_READ,
                                                FILE_SHARE_READ | FILE_SHARE_DELETE,
                                                NULL,
                                                OPEN_EXISTING,
                                                FILE_ATTRIBUTE_NORMAL,
                                                NULL );

                        if ( hDllFile == INVALID_HANDLE_VALUE )
                        {
                            SecpDerefDll( Binding );

                            continue;
                        }

                        GetFileTime( hDllFile, NULL, NULL, (LPFILETIME) &DllTime );

                        CloseHandle( hDllFile );

                        RegSetValueEx( hKey,
                                       TIME_NAME,
                                       0,
                                       REG_BINARY,
                                       (PUCHAR) &DllTime,
                                       sizeof( LARGE_INTEGER ) );

                        Temp = Package->TypeMask ;

                        RegSetValueEx( hKey,
                                       TYPE_NAME,
                                       0,
                                       REG_DWORD,
                                       (PUCHAR) &Temp,
                                       sizeof( DWORD ) );

                        SecpDeletePackage( Package );

                        RegCloseKey( hKey );

                        GetSystemTimeAsFileTime( (LPFILETIME) &CacheTime );

                        RegSetValueEx( LsaKey,
                                       TIME_NAME,
                                       0,
                                       REG_BINARY,
                                       (PUCHAR) &CacheTime,
                                       sizeof( CacheTime ) );
                    }

                    while ( !IsListEmpty( &PackageList ) )
                    {
                        Scan = RemoveHeadList( &PackageList );

                        Package = CONTAINING_RECORD( Scan, DLL_SECURITY_PACKAGE, List );

                        SecpDeletePackage( Package );
                    }


                }

                // SecpDerefDll( Binding );

            }
        }
    }

    RegCloseKey( LsaKey );

    LocalFree( BasePointer );
    LocalFree( DllNames );

    return STATUS_SUCCESS ;
}

SECURITY_STATUS
SecpLoadSaslProfiles(
    VOID
    )
{
    HKEY Key;
    int err;
    PWSTR EnumBuf;
    PWSTR ValueBuf;
    DWORD index;
    DWORD Type;
    DWORD Size;
    DWORD NameSize;
    PDLL_SECURITY_PACKAGE Package;
    SASL_PROFILE * Profile;
    UNICODE_STRING PackageName;

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\SecurityProviders\\SaslProfiles"),
                0,
                KEY_READ,
                &Key );

    if ( err == 0 )
    {

        EnumBuf = (PWSTR) RtlAllocateHeap( RtlProcessHeap(), 0, MAX_PATH * 2 * sizeof( WCHAR ));

        if ( EnumBuf )
        {
            ValueBuf = EnumBuf + MAX_PATH ;

            index = 0 ;

            do
            {
                NameSize = MAX_PATH ;
                Size = MAX_PATH * sizeof(WCHAR) ;

                err = RegEnumValue(
                            Key,
                            index,
                            EnumBuf,
                            &NameSize,
                            NULL,
                            &Type,
                            (PBYTE) ValueBuf,
                            &Size );

                if ( err == 0 )
                {
                    if ( Type == REG_SZ )
                    {
                        RtlInitUnicodeString( &PackageName, ValueBuf );

                        Package = SecpScanPackageList(
                                        SECPKG_TYPE_ANY,
                                        &PackageName,
                                        0 );

                        if ( Package )
                        {
                            //
                            // We found a package for the profile
                            // listed.  Create a SASL profile and
                            // link the two:
                            //

                            Size = (wcslen( EnumBuf ) + 1 ) * sizeof(WCHAR);

                            Profile = (PSASL_PROFILE) LocalAlloc( 0, sizeof( SASL_PROFILE ) + Size );

                            if ( Profile )
                            {
                                Profile->Package = Package ;
                                Profile->ProfileName.Buffer = (PWSTR) (Profile + 1);
                                Profile->ProfileName.MaximumLength = (USHORT) Size ;
                                Profile->ProfileName.Length = (USHORT) (Size - sizeof(WCHAR) );
                                RtlCopyMemory(
                                    Profile->ProfileName.Buffer,
                                    EnumBuf,
                                    Size );
                                InsertTailList( &SecSaslProfileList, &Profile->List );
                                Package->fState |= DLL_SECPKG_SASL_PROFILE ;

                                SecSaslProfileCount++ ;
                            }
                        }

                    }
                }

                index++ ;

            } while ( err == 0 );

            RtlFreeHeap( RtlProcessHeap(), 0, EnumBuf );

        }

        RegCloseKey( Key );
    }

    return SEC_E_OK;
}

SECURITY_STATUS
SecEnumerateSaslProfilesA(
    OUT LPSTR * ProfileList,
    OUT ULONG * ProfileCount
    )
{
    PLIST_ENTRY Scan ;
    PSASL_PROFILE Profile ;
    ULONG Size ;
    LPSTR Base ;
    LPSTR Current ;
    STRING String ;

    *ProfileCount = SecSaslProfileCount ;

    ReadLockPackageList();

    Scan = SecSaslProfileList.Flink ;
    Size = 0 ;

    while ( Scan != &SecSaslProfileList )
    {
        Profile = CONTAINING_RECORD( Scan, SASL_PROFILE, List );

        Size += (ULONG)RtlUnicodeStringToAnsiSize( &Profile->ProfileName ) + 1;

        Scan = Scan->Flink ;

    }

    Size ++ ;

    Base = (LPSTR) LocalAlloc( LMEM_FIXED, Size );

    if ( !Base )
    {
        UnlockPackageList();

        return SEC_E_INSUFFICIENT_MEMORY ;

    }

    Current = Base ;

    Scan = SecSaslProfileList.Flink ;

    while ( Scan != &SecSaslProfileList )
    {
        Profile = CONTAINING_RECORD( Scan, SASL_PROFILE, List );

        String.Buffer = Current ;
        String.MaximumLength = min((USHORT) Size, MAXSHORT) ;
        String.Length = 0 ;

        RtlUnicodeStringToAnsiString(
            &String,
            &Profile->ProfileName,
            FALSE );

        Scan = Scan->Flink ;

        Size -= String.Length + 1;

        Current += String.Length ;

        *Current++ = '\0';

    }

    *Current++ = '\0' ;

    UnlockPackageList();

    *ProfileList = Base ;

    return STATUS_SUCCESS ;

}


SECURITY_STATUS
SecEnumerateSaslProfilesW(
    OUT LPWSTR * ProfileList,
    OUT ULONG * ProfileCount
    )
{
    PLIST_ENTRY Scan ;
    PSASL_PROFILE Profile ;
    ULONG Size ;
    LPWSTR Base ;
    LPWSTR Current ;

    *ProfileCount = SecSaslProfileCount ;

    ReadLockPackageList();

    Scan = SecSaslProfileList.Flink ;
    Size = 0 ;

    while ( Scan != &SecSaslProfileList )
    {
        Profile = CONTAINING_RECORD( Scan, SASL_PROFILE, List );

        Size += Profile->ProfileName.Length + 2 ;

        Scan = Scan->Flink ;

    }

    Size += sizeof(WCHAR) ;

    Base = (LPWSTR) LocalAlloc( LMEM_FIXED, Size );

    if ( !Base )
    {
        UnlockPackageList();

        return SEC_E_INSUFFICIENT_MEMORY ;

    }

    Current = Base ;

    Scan = SecSaslProfileList.Flink ;

    while ( Scan != &SecSaslProfileList )
    {
        Profile = CONTAINING_RECORD( Scan, SASL_PROFILE, List );

        CopyMemory(
            Current,
            Profile->ProfileName.Buffer,
            Profile->ProfileName.Length );

        Scan = Scan->Flink ;

        Current += Profile->ProfileName.Length / sizeof(WCHAR) ;

        *Current++ = L'\0';

    }

    *Current++ = L'\0' ;

    UnlockPackageList();

    *ProfileList = Base ;

    return STATUS_SUCCESS ;
}

SECURITY_STATUS
SecCopyPackageInfoToUserW(
    PDLL_SECURITY_PACKAGE  Package,
    PSecPkgInfoW SEC_FAR * pPackageInfo
    )
{
    SECURITY_STATUS scRet ;
    PSecPkgInfoW pInfo ;
    ULONG Size ;
    PWSTR String ;

    if ( Package )
    {
        Size = sizeof( SecPkgInfoW ) +
                    Package->PackageName.Length + sizeof(WCHAR) +
                          Package->Comment.Length + sizeof(WCHAR) ;

        pInfo = (PSecPkgInfoW) SecClientAllocate( Size );

        if ( pInfo )
        {
            String = (PWSTR) (pInfo + 1) ;


            pInfo->fCapabilities = Package->fCapabilities ;
            pInfo->wVersion = Package->Version ;
            pInfo->wRPCID = Package->RpcId ;
            pInfo->cbMaxToken = Package->TokenSize ;
            pInfo->Name = String ;

            CopyMemory( String,
                        Package->PackageName.Buffer,
                        Package->PackageName.Length );

            String += Package->PackageName.Length / sizeof(WCHAR);

            *String ++ = L'\0';

            pInfo->Comment = String ;

            CopyMemory( String,
                        Package->Comment.Buffer,
                        Package->Comment.Length );

            String += Package->Comment.Length / sizeof(WCHAR) ;

            *String++ = L'\0';

            scRet = SEC_E_OK ;
        }
        else
        {
            scRet = SEC_E_INSUFFICIENT_MEMORY ;
        }

        *pPackageInfo = pInfo ;

    }
    else
    {
        scRet = SEC_E_SECPKG_NOT_FOUND ;
    }

    return(scRet);

}

SECURITY_STATUS
SecCopyPackageInfoToUserA(
    PDLL_SECURITY_PACKAGE Package,
    PSecPkgInfoA * pPackageInfo
    )
{
    SECURITY_STATUS scRet;
    PSecPkgInfoA pInfo ;
    ULONG Size ;
    PSTR String ;

    if ( Package )
    {
        Size = sizeof( SecPkgInfo ) +
                          Package->AnsiNameSize +
                          Package->AnsiCommentSize ;

        pInfo = (PSecPkgInfoA) SecClientAllocate( Size );

        if ( pInfo )
        {
            String = (PSTR) (pInfo + 1) ;


            pInfo->fCapabilities = Package->fCapabilities ;
            pInfo->wVersion = Package->Version ;
            pInfo->wRPCID = Package->RpcId ;
            pInfo->cbMaxToken = Package->TokenSize ;
            pInfo->Name = String ;

            CopyMemory( String,
                        Package->PackageNameA,
                        Package->AnsiNameSize);

            String += Package->AnsiNameSize;

            pInfo->Comment = String ;

            CopyMemory( String,
                        Package->CommentA,
                        Package->AnsiCommentSize);

            scRet = SEC_E_OK ;
        }
        else
        {
            scRet = SEC_E_INSUFFICIENT_MEMORY ;
        }

        *pPackageInfo = pInfo ;

    }
    else
    {
        scRet = SEC_E_SECPKG_NOT_FOUND ;
    }

    return(scRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\dll\sasl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       newstubs.cxx
//
//  Contents:   Stubs from SASL support
//
//  History:    9-06-96   RichardW   Stolen from ntlmssp
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <kerberos.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include <ntlsa.h>
#include "secdll.h"
}

CRITICAL_SECTION SaslLock ;
LIST_ENTRY SaslContextList = {0};
PNEGOTIATE_PACKAGE_PREFIXES SaslPrefixes = NULL;
PNEGOTIATE_PACKAGE_PREFIX SaslPrefixList = NULL;

typedef enum _SASL_STATE {
    SaslGss,                // Passthrough to packages
    SaslPause,              // Client-side: wait for cookie from server
                            // Server-side: wait for empty response from client
    SaslCookie,             // Server-side: issued cookie to client
    SaslComplete            // Done
} SASL_STATE ;

#define SASL_NO_SECURITY    0x01
#define SASL_INTEGRITY      0x02
#define SASL_PRIVACY        0x04

#define CLIENT_INTEGRITY    ( ISC_RET_REPLAY_DETECT | \
                              ISC_RET_SEQUENCE_DETECT | \
                              ISC_RET_INTEGRITY )

#define CLIENT_REQ_INTEGRITY (ISC_REQ_REPLAY_DETECT | \
                              ISC_REQ_SEQUENCE_DETECT | \
                              ISC_REQ_INTEGRITY )

#define SERVER_INTEGRITY    ( ASC_RET_REPLAY_DETECT | \
                              ASC_RET_SEQUENCE_DETECT | \
                              ASC_RET_INTEGRITY )

#define SERVER_REQ_INTEGRITY (ASC_REQ_REPLAY_DETECT | \
                              ASC_REQ_SEQUENCE_DETECT | \
                              ASC_REQ_INTEGRITY )


typedef struct _SASL_CONTEXT {

    LIST_ENTRY  List ;              // List control
    CtxtHandle  ContextHandle ;     // Context handle from real package
    TimeStamp   Expiry ;            // Context Expiration
    SASL_STATE  State ;             // Current SASL state
    SASL_AUTHZID_STATE  StateAuthZID;    // Rules to process AuthZID strings
    DWORD       ContextReq ;        // Context Request from caller
    DWORD       ContextAttr ;       // Context Attributes available
    DWORD       SendBufferSize ;    // Max Buffer Size
    DWORD       RecvBufferSize ;    // "
    PUCHAR      AuthzString ;       // Authorization string
    DWORD       AuthzStringLength ; // Length

} SASL_CONTEXT, * PSASL_CONTEXT ;

ULONG SaslGlobalSendSize = 0x0ffff ;  // Allow defaults to be set process wide
ULONG SaslGlobalRecvSize = 0x0ffff ;

// Application MUST retrieve the AuthzID string and verify that the specified user if any
// has sufficient priviledges before Request is processed
SASL_AUTHZID_STATE SaslGlobalAuthZID = Sasl_AuthZIDProcessed ;


PSecBuffer
SaslLocateBuffer(
    PSecBufferDesc  Desc,
    ULONG           Type
    )
{
    ULONG i ;

    for ( i = 0 ; i < Desc->cBuffers ; i++ )
    {
        if ( (Desc->pBuffers[i].BufferType & ~(SECBUFFER_ATTRMASK)) == Type )
        {
            return &Desc->pBuffers[i] ;
        }
    }

    return NULL ;
}


PSASL_CONTEXT
SaslCreateContext(
    PCtxtHandle ContextHandle
    )
{
    PSASL_CONTEXT Context ;

    Context = (PSASL_CONTEXT) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, sizeof( SASL_CONTEXT ) );

    if ( Context )
    {
        Context->ContextHandle = *ContextHandle ;
        Context->State = SaslGss ;
        Context->RecvBufferSize = SaslGlobalRecvSize ;
        Context->SendBufferSize = SaslGlobalSendSize ;
        Context->StateAuthZID =  SaslGlobalAuthZID;

        RtlEnterCriticalSection( &SaslLock );

        InsertHeadList( &SaslContextList, &Context->List );

        RtlLeaveCriticalSection( &SaslLock );
    }

    return Context ;
}

PSASL_CONTEXT
SaslFindContext(
    PCtxtHandle ContextHandle,
    BOOL Remove
    )
{
    PLIST_ENTRY Scan ;
    PSASL_CONTEXT Context = NULL ;

    RtlEnterCriticalSection( &SaslLock );

    Scan = SaslContextList.Flink ;

    while ( Scan != &SaslContextList )
    {
        Context = CONTAINING_RECORD( Scan, SASL_CONTEXT, List );

        if ( (Context->ContextHandle.dwUpper == ContextHandle->dwUpper) &&
             (Context->ContextHandle.dwLower == ContextHandle->dwLower ) )
        {
            break;
        }

        Context = NULL ;

        Scan = Scan->Flink ;
    }

    if ( Remove && ( Context != NULL ) )
    {
        RemoveEntryList( &Context->List );

        Context->List.Flink = NULL ;
        Context->List.Blink = NULL ;
    }

    RtlLeaveCriticalSection( &SaslLock );

    return Context ;
}

VOID
SaslDeleteContext(
    PSASL_CONTEXT Context
    )
{
    if ( Context->List.Flink )
    {
        RtlEnterCriticalSection( &SaslLock );

        RemoveEntryList( &Context->List );

        RtlLeaveCriticalSection( &SaslLock );
    }

    if ( Context->AuthzString )
    {
        LocalFree( Context->AuthzString );
    }

    LocalFree( Context );

}


// 
SECURITY_STATUS
SEC_ENTRY
SaslGetContextOption(
    PCtxtHandle ContextHandle,
    ULONG Option,
    PVOID Value,
    ULONG Size,
    PULONG Needed OPTIONAL
    )
{
    PSASL_CONTEXT Context ;
    PULONG Data ;
    ULONG DataSize ;
    SECURITY_STATUS Status = STATUS_SUCCESS ;

    Context = SaslFindContext( ContextHandle, FALSE );

    if ( Context == NULL )
    {
        return SEC_E_INVALID_HANDLE ;
    }

    switch ( Option )
    {
        case SASL_OPTION_SEND_SIZE:
            if ( Size < sizeof( ULONG ) )
            {
                Status = SEC_E_BUFFER_TOO_SMALL ;
            }
            else 
            {
                SecPkgContext_Sizes Sizes = {0};
                ULONG SSPSize = 0;
                ULONG MaxSizeAdjusted = 0;

                Status = QueryContextAttributesW(
                            ContextHandle,
                            SECPKG_ATTR_SIZES,
                            &Sizes );

                if ( !NT_SUCCESS( Status ) )
                {
                    return Status ;
                }

                // We know the padding requirements for the SSP - reduce the reported value
                // to include this space.  The application will then know the max size of the
                // data that can be sent.

                SSPSize = Sizes.cbBlockSize + Sizes.cbSecurityTrailer + Sizes.cbMaxSignature;

                if (SSPSize > Context->SendBufferSize)
                {
                    MaxSizeAdjusted = 0;
                }
                else
                {
                    MaxSizeAdjusted = Context->SendBufferSize - SSPSize;
                }

                Data = (PULONG) Value ;
                *Data = MaxSizeAdjusted ;
                Status = STATUS_SUCCESS;
            }
            DataSize = sizeof( ULONG ) ;
            break;

        case SASL_OPTION_RECV_SIZE:
            if ( Size < sizeof( ULONG ) )
            {
                Status =  SEC_E_BUFFER_TOO_SMALL ;
            }
            else 
            {
                Data = (PULONG) Value ;
                *Data = Context->RecvBufferSize ;
            }
            DataSize = sizeof( ULONG ) ;
            break;

        case SASL_OPTION_AUTHZ_PROCESSING:
            if ( Size < sizeof( ULONG ) )
            {
                Status =  SEC_E_BUFFER_TOO_SMALL ;
            }
            else 
            {
                Data = (PULONG) Value ;
                *Data = Context->StateAuthZID ;
            }
            DataSize = sizeof( ULONG ) ;
            break;

        case SASL_OPTION_AUTHZ_STRING:
            if (Context->StateAuthZID == Sasl_AuthZIDForbidden)
            {
                Status = SEC_E_UNSUPPORTED_FUNCTION;     // Do not provide any AuthZID information - not supported
                DataSize = 0;
                break;
            }

            if ( Size < Context->AuthzStringLength )
            {
                Status = SEC_E_BUFFER_TOO_SMALL ;

            }
            else 
            {
                RtlCopyMemory(
                    Value,
                    Context->AuthzString,
                    Context->AuthzStringLength );

            }
            DataSize = Context->AuthzStringLength ;
            break;

        default:
            DataSize = 0 ;
            Status = SEC_E_UNSUPPORTED_FUNCTION ;

    }

    if ( Needed )
    {
        *Needed = DataSize ;
    }

    return Status ;
}


//  
SECURITY_STATUS
SEC_ENTRY
SaslSetContextOption(
    PCtxtHandle ContextHandle,
    ULONG Option,
    PVOID Value,
    ULONG Size
    )
{
    PSASL_CONTEXT Context ;
    PULONG Data ;
    SECURITY_STATUS Status = STATUS_SUCCESS ;

    Context = SaslFindContext( ContextHandle, FALSE );

    switch ( Option )
    {
        case SASL_OPTION_SEND_SIZE:
            if ( Size < sizeof( ULONG ) )
            {
                Status = SEC_E_BUFFER_TOO_SMALL ;
            }
            else 
            {
                Data = (PULONG) Value ;
                if ( Context )
                {
                    Context->SendBufferSize = *Data ;
                }
                else
                {
                    SaslGlobalSendSize = *Data ;
                }
            }
            break;

        case SASL_OPTION_RECV_SIZE:
            if ( Size < sizeof( ULONG ) )
            {
                Status =  SEC_E_BUFFER_TOO_SMALL ;
            }
            else 
            {
                Data = (PULONG) Value ;
                if ( Context )
                {
                    Context->RecvBufferSize = *Data ;
                }
                else 
                {
                    SaslGlobalRecvSize = *Data ;
                }
            }
            break;

        case SASL_OPTION_AUTHZ_PROCESSING:
            if ( Size < sizeof( ULONG ) )
            {
                Status =  SEC_E_BUFFER_TOO_SMALL ;
            }
            else 
            {
                Data = (PULONG) Value ;
                if ( Context )
                {
                    Context->StateAuthZID = (SASL_AUTHZID_STATE)*Data ;
                }
                else 
                {
                    SaslGlobalAuthZID = (SASL_AUTHZID_STATE)*Data ;
                }
            }
            break;

        case SASL_OPTION_AUTHZ_STRING:
            if (Context == NULL)
            {
                Status =  SEC_E_INVALID_HANDLE ;    // must have a context - no global values for AuthZID
                break;
            }

            if (Context->StateAuthZID == Sasl_AuthZIDForbidden)
            {
                Status = SEC_E_UNSUPPORTED_FUNCTION;     // Do not allow AuthZID to be set - not supported
                break;
            }

            Context->AuthzString = (PUCHAR) LocalAlloc( LMEM_FIXED, Size );

            if ( Context->AuthzString )
            {
                Context->AuthzStringLength = Size ;
                RtlCopyMemory(
                        Context->AuthzString,
                        Value,
                        Size );

            }
            else 
            {
                Status = SEC_E_INSUFFICIENT_MEMORY ;

            }
            break;

        default:
            Status = SEC_E_UNSUPPORTED_FUNCTION ;

    }

    return Status ;
}



SECURITY_STATUS
SaslBuildCookie(
    PSecBufferDesc  Output,
    PSASL_CONTEXT   Context,
    UCHAR           SaslFlags
    )
{
    SECURITY_STATUS Status ;
    SecBuffer   WrapBuffer[ 3 ];
    SecBufferDesc   Wrap ;
    SecPkgContext_Sizes Sizes ;
    UCHAR lBuffer[ 128 ];
    PUCHAR Buffer ;
    ULONG TotalSize ;
    PUCHAR SaslMessage ;
    PUCHAR OutputMessage = NULL ;
    PSecBuffer OutputBuffer ;


    if ((Context->StateAuthZID == Sasl_AuthZIDForbidden) && (Context->AuthzStringLength))
    {
        return SEC_E_ALGORITHM_MISMATCH;      // we do not allow cookies to be processed
    }


    Status = QueryContextAttributesW(
                &Context->ContextHandle,
                SECPKG_ATTR_SIZES,
                &Sizes );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    //
    // The total size of the message is trailer + block size +
    // SASL component, which is spec'd to be 4 bytes + any authz string
    //

    TotalSize = Sizes.cbBlockSize + Sizes.cbSecurityTrailer + 
                    4 + Context->AuthzStringLength;

    if ( TotalSize < sizeof( lBuffer ) )
    {
        Buffer = lBuffer ;
    }
    else
    {
        Buffer = (PUCHAR) LocalAlloc( LMEM_FIXED, TotalSize );
    }

    if ( !Buffer )
    {
        return SEC_E_INSUFFICIENT_MEMORY ;
    }

    //
    // Construct the message:
    //

    Wrap.cBuffers = 3 ;
    Wrap.pBuffers = WrapBuffer ;
    Wrap.ulVersion = SECBUFFER_VERSION ;

    WrapBuffer[ 0 ].BufferType = SECBUFFER_TOKEN ;
    WrapBuffer[ 0 ].cbBuffer = Sizes.cbSecurityTrailer ;
    WrapBuffer[ 0 ].pvBuffer = Buffer ;

    WrapBuffer[ 1 ].BufferType = SECBUFFER_DATA ;
    WrapBuffer[ 1 ].cbBuffer = 4 + Context->AuthzStringLength ;
    WrapBuffer[ 1 ].pvBuffer = Buffer + Sizes.cbSecurityTrailer ;

    WrapBuffer[ 2 ].BufferType = SECBUFFER_PADDING ;
    WrapBuffer[ 2 ].cbBuffer = Sizes.cbBlockSize ;
    WrapBuffer[ 2 ].pvBuffer = Buffer + (Sizes.cbSecurityTrailer + 
                                         4 + Context->AuthzStringLength);

    //
    // Fill in our portion:
    //

    SaslMessage = (PUCHAR) WrapBuffer[ 1 ].pvBuffer ;


    //
    // Next three bytes are network byte order for the max
    // receive buffer supported by the server:
    //

    SaslMessage[ 0 ] = SaslFlags ;
    SaslMessage[ 1 ] = (UCHAR) ((Context->RecvBufferSize >> 16) & 0xFF) ;
    SaslMessage[ 2 ] = (UCHAR) ((Context->RecvBufferSize >> 8 ) & 0xFF) ;
    SaslMessage[ 3 ] = (UCHAR) ((Context->RecvBufferSize      ) & 0xFF) ;

    if ( Context->AuthzStringLength )
    {
        RtlCopyMemory( SaslMessage + 4,
                       Context->AuthzString,
                       Context->AuthzStringLength );
    }

    //
    // Wrap up the message:
    //

    Status = EncryptMessage(
                &Context->ContextHandle,
                KERB_WRAP_NO_ENCRYPT,
                &Wrap,
                0 );

    if ( NT_SUCCESS( Status ) )
    {
        //
        // Now copy the cookie back out to the caller:
        //

        OutputBuffer = SaslLocateBuffer(
                            Output,
                            SECBUFFER_TOKEN );

        if ( OutputBuffer )
        {
            if ( Context->ContextReq & ASC_REQ_ALLOCATE_MEMORY )
            {
                //
                // Allocate our own memory:
                //

                OutputMessage = (PUCHAR) SecpFTable.AllocateHeap( TotalSize );
                if ( OutputMessage )
                {
                    OutputBuffer->pvBuffer = OutputMessage ;
                }
                else
                {
                    Status = SEC_E_INSUFFICIENT_MEMORY ;
                }

            }
            else
            {
                OutputMessage = (PUCHAR) OutputBuffer->pvBuffer ;
                if ( OutputBuffer->cbBuffer < TotalSize )
                {
                    Status = SEC_E_INSUFFICIENT_MEMORY ;
                }
            }
        }
        else 
        {
            Status = SEC_E_INVALID_TOKEN ;
        }


        if ( NT_SUCCESS( Status ) )
        {
            RtlCopyMemory(
                OutputMessage,
                WrapBuffer[0].pvBuffer,
                WrapBuffer[0].cbBuffer );

            OutputMessage += WrapBuffer[0].cbBuffer ;

            RtlCopyMemory(
                OutputMessage,
                WrapBuffer[1].pvBuffer,
                WrapBuffer[1].cbBuffer );

            OutputMessage += WrapBuffer[1].cbBuffer ;

            RtlCopyMemory(
                OutputMessage,
                WrapBuffer[2].pvBuffer,
                WrapBuffer[2].cbBuffer );

            OutputBuffer->cbBuffer = WrapBuffer[ 0 ].cbBuffer +
                                     WrapBuffer[ 1 ].cbBuffer +
                                     WrapBuffer[ 2 ].cbBuffer ;

        }



    }

    if ( Buffer != lBuffer )
    {
        LocalFree( Buffer );
    }

    return Status ;


}

SECURITY_STATUS
SaslBuildServerCookie(
    PSecBufferDesc  Output,
    PSASL_CONTEXT Context
    )
{
    UCHAR SaslMessage ;

    SaslMessage = SASL_NO_SECURITY ;

    if ( Context->ContextAttr & SERVER_INTEGRITY )
    {
        SaslMessage |= SASL_INTEGRITY ;
    }

    if ( Context->ContextAttr & ASC_RET_CONFIDENTIALITY )
    {
        SaslMessage |= SASL_PRIVACY ;
    }

    return SaslBuildCookie( Output,
                            Context,
                            SaslMessage );

}

SECURITY_STATUS
SaslCrackCookie(
    PSecBufferDesc Input,
    PSASL_CONTEXT Context,
    PUCHAR SaslFlags
    )
{
    SECURITY_STATUS Status ;
    SecBufferDesc   Unwrap ;
    SecBuffer       UnwrapBuffer[ 2 ];
    PSecBuffer      InToken ;
    ULONG           QoP ;
    PUCHAR          SaslMessage ;

    InToken = SaslLocateBuffer(
                    Input,
                    SECBUFFER_TOKEN );

    if ( !InToken )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    Unwrap.cBuffers = 2 ;
    Unwrap.pBuffers = UnwrapBuffer ;
    Unwrap.ulVersion = SECBUFFER_VERSION ;

    UnwrapBuffer[ 0 ].BufferType = SECBUFFER_STREAM ;
    UnwrapBuffer[ 0 ].cbBuffer = InToken->cbBuffer ;
    UnwrapBuffer[ 0 ].pvBuffer = InToken->pvBuffer ;

    UnwrapBuffer[ 1 ].BufferType = SECBUFFER_DATA ;
    UnwrapBuffer[ 1 ].cbBuffer = 0 ;
    UnwrapBuffer[ 1 ].pvBuffer = NULL ;

    Status = DecryptMessage(
                &Context->ContextHandle,
                &Unwrap,
                0,
                &QoP );

    if ( !NT_SUCCESS( Status ) )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    SaslMessage = (PUCHAR) UnwrapBuffer[ 1 ].pvBuffer ;

    //
    // Ok, now that we have the server's capabilities,
    // match against what we wanted:
    //


    *SaslFlags = SaslMessage[ 0 ] ;

    Context->SendBufferSize = (SaslMessage[3]      ) +
                              (SaslMessage[2] << 8 ) +
                              (SaslMessage[1] << 16) ;

    if ( UnwrapBuffer[ 1 ].cbBuffer > 4 )
    {
        Context->AuthzStringLength = UnwrapBuffer[ 1 ].cbBuffer - 4 ;

        if ((Context->StateAuthZID == Sasl_AuthZIDForbidden) && (Context->AuthzStringLength))
        {
            Context->AuthzStringLength = 0;       // indicate no AuthZID string
            return SEC_E_ALGORITHM_MISMATCH;      // we do not allow cookies to be processed
        }

        Context->AuthzString = (PUCHAR) LocalAlloc( 
                                    LMEM_FIXED,
                                    Context->AuthzStringLength );

        if ( Context->AuthzString )
        {
            RtlCopyMemory(
                Context->AuthzString,
                SaslMessage + 4,
                Context->AuthzStringLength );
        }

    }

    return SEC_E_OK ;

}

SECURITY_STATUS
SaslCrackServerCookie(
    PSecBufferDesc  Input,
    PSecBufferDesc  Output,
    PSASL_CONTEXT   Context
    )
{
    UCHAR SaslFlags ;
    UCHAR ResponseSaslFlags ;
    SECURITY_STATUS Status ;
    ULONG           Attributes ;

    Status = SaslCrackCookie(
                    Input,
                    Context,
                    &SaslFlags );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    Attributes = 0 ;
    ResponseSaslFlags = 0 ;

    if ( SaslFlags & SASL_INTEGRITY )
    {
        //
        // Server can do integrity, can we, and did we want to
        // in the first place?
        //

        if ( ( Context->ContextAttr & CLIENT_INTEGRITY ) &&
             ( Context->ContextReq & CLIENT_REQ_INTEGRITY ) )
        {
            Attributes |= (Context->ContextAttr & CLIENT_INTEGRITY) ;
            ResponseSaslFlags |= SASL_INTEGRITY ;

        }

    }


    if ( SaslFlags & SASL_PRIVACY )
    {
        //
        // Server can do privacy, can we, and did we want to?
        //

        if ( ( Context->ContextAttr & ISC_RET_CONFIDENTIALITY ) &&
             ( Context->ContextReq & ISC_REQ_CONFIDENTIALITY ) )
        {
            Attributes |= ISC_RET_CONFIDENTIALITY ;
            ResponseSaslFlags |= SASL_PRIVACY ;

        }
    }

    if ( ResponseSaslFlags == 0 )
    {
        ResponseSaslFlags |= SASL_NO_SECURITY ;
    }

    //
    // Ok, now, mask out the original bits, and turn on only the ones
    // we have in common for the server:
    //

    Context->ContextAttr &= ~(CLIENT_INTEGRITY | ISC_RET_CONFIDENTIALITY);

    Context->ContextAttr |= Attributes ;
    //
    // Now, build the reply cookie to the server
    //

    return SaslBuildCookie(
                Output,
                Context,
                ResponseSaslFlags );

}

SECURITY_STATUS
SaslCrackClientCookie(
    PSecBufferDesc  Input,
    PSASL_CONTEXT   Context
    )
{
    SECURITY_STATUS Status ;
    UCHAR SaslFlags ;
    ULONG Attributes ;

    Status = SaslCrackCookie(
                    Input,
                    Context,
                    &SaslFlags );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    Attributes = 0 ;

    if ( SaslFlags & SASL_INTEGRITY )
    {
        //
        // Server can do integrity, can we, and did we want to
        // in the first place?
        //

        if ( ( Context->ContextAttr & SERVER_INTEGRITY ) &&
             ( Context->ContextReq & SERVER_REQ_INTEGRITY ) )
        {
            Attributes |= (Context->ContextAttr & SERVER_INTEGRITY) ;

        }

    }


    if ( SaslFlags & SASL_PRIVACY )
    {
        //
        // Server can do privacy, can we, and did we want to?
        //

        if ( ( Context->ContextAttr & ASC_RET_CONFIDENTIALITY ) &&
             ( Context->ContextReq & ASC_REQ_CONFIDENTIALITY ) )
        {
            Attributes |= ASC_RET_CONFIDENTIALITY ;

        }
    }

    //
    // Ok, now, mask out the original bits, and turn on only the ones
    // we have in common for the server:
    //

    Context->ContextAttr &= ~(SERVER_INTEGRITY | ISC_RET_CONFIDENTIALITY);

    Context->ContextAttr |= Attributes ;

    return SEC_E_OK ;
}


VOID
SaslDeleteSecurityContext(
    PCtxtHandle phContext
    )
{
    PSASL_CONTEXT Context ;

    Context = SaslFindContext( phContext, TRUE );

    if ( Context )
    {
        SaslDeleteContext( Context );
    }

}


SECURITY_STATUS
SEC_ENTRY
SaslEnumerateProfilesA(
    OUT LPSTR * ProfileList,
    OUT ULONG * ProfileCount
    )
{

    return SecEnumerateSaslProfilesA( ProfileList, ProfileCount );
}


SECURITY_STATUS
SEC_ENTRY
SaslEnumerateProfilesW(
    OUT LPWSTR * ProfileList,
    OUT ULONG * ProfileCount
    )
{
    return SecEnumerateSaslProfilesW( ProfileList, ProfileCount );

}


SECURITY_STATUS
SEC_ENTRY
SaslGetProfilePackageA(
    IN LPSTR ProfileName,
    OUT PSecPkgInfoA * PackageInfo
    )
{
    PSASL_PROFILE Profile ;

    Profile = SecLocateSaslProfileA( ProfileName );

    if ( Profile )
    {
        return SecCopyPackageInfoToUserA( Profile->Package, PackageInfo );
    }
    return SEC_E_SECPKG_NOT_FOUND ;

}


SECURITY_STATUS
SEC_ENTRY
SaslGetProfilePackageW(
    IN LPWSTR ProfileName,
    OUT PSecPkgInfoW * PackageInfo
    )
{
    PSASL_PROFILE Profile ;

    Profile = SecLocateSaslProfileW( ProfileName );

    if ( Profile )
    {
        return SecCopyPackageInfoToUserW( Profile->Package, PackageInfo );
    }

    return SEC_E_SECPKG_NOT_FOUND ;

}



//+---------------------------------------------------------------------------
//
//  Function:   SaslInitializeSecurityContextW
//
//  Synopsis:   SaslInitializeSecurityContext stub
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pszTargetName] --
//              [fContextReq]   --
//              [Reserved1]     --
//              [Reserved]      --
//              [TargetDataRep] --
//              [pInput]        --
//              [Reserved2]     --
//              [Reserved]      --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//
//  History:    12-2-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SaslInitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPWSTR                      pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    SECURITY_STATUS Status ;
    PSASL_CONTEXT Context = NULL ;
    TimeStamp   tsExpiry = {0};

    if ( ( phContext != NULL ) &&
         ( phContext->dwLower != 0 ) )
    {
        Context = SaslFindContext( phContext, FALSE );

        if ( !Context )
        {
            return SEC_E_INVALID_HANDLE ;
        }

        if ( Context->State == SaslPause )
        {
            //
            // If we're at the Pause state, that means we're waiting for a
            // GSS_wrap'd cookie from the server.
            //

            Status = SaslCrackServerCookie(
                        pInput,
                        pOutput,
                        Context );

            if ( NT_SUCCESS( Status ) )
            {
                *pfContextAttr = Context->ContextAttr ;

                if (ptsExpiry)     // Since this is marked as optional
                {
                    *ptsExpiry = Context->Expiry ;
                }

                return Status ;
            }
        }
    }

    Status = InitializeSecurityContextW(
                phCredential,
                phContext,
                pszTargetName,
                fContextReq |
                    ISC_REQ_CONFIDENTIALITY | ISC_REQ_INTEGRITY,
                Reserved1,
                TargetDataRep,
                pInput,
                Reserved2,
                phNewContext,
                pOutput,
                pfContextAttr,
                &tsExpiry );

    if ( NT_SUCCESS( Status ) )
    {
        if ( !Context )
        {
            Context = SaslCreateContext( phNewContext );

            if ( Context )
            {
                Context->ContextReq = fContextReq ;
            }
            else
            {
                Status = SEC_E_INSUFFICIENT_MEMORY ;

                DeleteSecurityContext( phNewContext );
            }

        }
        else
        {
            Context->ContextHandle = *phNewContext ;
        }

        if ( Status == SEC_E_OK )
        {
            Context->State = SaslPause ;

            Context->ContextAttr = *pfContextAttr ;

            Context->Expiry = tsExpiry ;

            if (ptsExpiry)
            {
                 *ptsExpiry  = tsExpiry;
            }
            
            Status = SEC_I_CONTINUE_NEEDED ;

        }
    }
    else
    {
        if ( Context )
        {
            SaslDeleteContext( Context );
        }
    }

    return Status ;
}


//+---------------------------------------------------------------------------
//
//  Function:   SaslInitializeSecurityContextA
//
//  Synopsis:   ANSI stub
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SaslInitializeSecurityContextA(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPSTR                       pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    SECURITY_STATUS Status ;
    PSASL_CONTEXT Context = NULL ;
    TimeStamp   tsExpiry = {0};

    if ( ( phContext != NULL ) &&
         ( phContext->dwLower != 0 ) )
    {
        Context = SaslFindContext( phContext, FALSE );

        if ( !Context )
        {
            return SEC_E_INVALID_HANDLE ;
        }

        if ( Context->State == SaslPause )
        {
            //
            // If we're at the Pause state, that means we're waiting for a
            // GSS_wrap'd cookie from the server.
            //

            Status = SaslCrackServerCookie(
                        pInput,
                        pOutput,
                        Context );

            if ( NT_SUCCESS( Status ) )
            {
                *pfContextAttr = Context->ContextAttr ;

                if (ptsExpiry)     // Since this is marked as optional
                {
                    *ptsExpiry = Context->Expiry ;
                }

                return Status ;
            }
        }
    }

    Status = InitializeSecurityContextA(
                phCredential,
                phContext,
                pszTargetName,
                fContextReq |
                    ISC_REQ_CONFIDENTIALITY | ISC_REQ_INTEGRITY,
                Reserved1,
                TargetDataRep,
                pInput,
                Reserved2,
                phNewContext,
                pOutput,
                pfContextAttr,
                &tsExpiry );

    if ( NT_SUCCESS( Status ) )
    {
        if ( !Context )
        {
            Context = SaslCreateContext( phNewContext );

            if ( Context )
            {
                Context->ContextReq = fContextReq ;
            }
            else
            {
                Status = SEC_E_INSUFFICIENT_MEMORY ;

                DeleteSecurityContext( phNewContext );
            }

        }
        else
        {
            Context->ContextHandle = *phNewContext ;
        }

        if ( Status == SEC_E_OK )
        {
            Context->State = SaslPause ;

            Context->ContextAttr = *pfContextAttr ;

            Context->Expiry = tsExpiry ;

            if (ptsExpiry)     // Since this is marked as optional
            {
                *ptsExpiry = tsExpiry ;
            }

            Status = SEC_I_CONTINUE_NEEDED ;

        }
    }
    else
    {
        if ( Context )
        {
            SaslDeleteContext( Context );
        }
    }

    return Status ;

}



//+---------------------------------------------------------------------------
//
//  Function:   SaslAcceptSecurityContext
//
//  Synopsis:   SaslAcceptSecurityContext stub
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pInput]        --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//
//  History:    12-2-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SaslAcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    SECURITY_STATUS Status ;
    PSASL_CONTEXT Context = NULL ;
    PSecBuffer Blob ;
    TimeStamp tsExpiry = {0};

    if ( ( phContext != NULL ) &&
         ( phContext->dwLower != 0 ) )
    {
        Context = SaslFindContext( phContext, FALSE );

        if ( !Context )
        {
            return SEC_E_INVALID_HANDLE ;
        }

        if ( Context->State == SaslPause )
        {
            //
            //  Generate the cookie for the client:
            //

            Status = SaslBuildServerCookie( pOutput, Context );

            if ( NT_SUCCESS( Status ) )
            {
                Context->State = SaslCookie ;

                return SEC_I_CONTINUE_NEEDED ;
            }

            return Status ;

        }

        if ( Context->State == SaslCookie )
        {
            //
            // This should be the response from the client:
            //

            Status = SaslCrackClientCookie(
                        pInput,
                        Context );

            *pfContextAttr = Context->ContextAttr ;
            if (ptsExpiry)
            {
                *ptsExpiry = Context->Expiry ;
            }

            return Status ;
        }
    }

    Status = AcceptSecurityContext(
                phCredential,
                phContext,
                pInput,
                fContextReq |
                    ASC_REQ_CONFIDENTIALITY |
                    ASC_REQ_INTEGRITY,
                TargetDataRep,
                phNewContext,
                pOutput,
                pfContextAttr,
                &tsExpiry );

    if ( NT_SUCCESS( Status ) )
    {
        if ( !Context )
        {
            Context = SaslCreateContext( phNewContext );

            if ( Context )
            {
                Context->ContextReq = fContextReq ;
            }
            else
            {
                DeleteSecurityContext( phNewContext );

                Status = SEC_E_INSUFFICIENT_MEMORY ;
            }

        }
        else
        {
            Context->ContextHandle = *phNewContext ;
        }

        if ( Status == SEC_E_OK )
        {
            Context->ContextAttr = *pfContextAttr ;
            Context->Expiry = tsExpiry ;

            if (ptsExpiry)     // Since this is marked as optional
            {
                *ptsExpiry = tsExpiry ;
            }

            Status = SEC_I_CONTINUE_NEEDED ;

            //
            // if there is no output token, then we launch into the make-the-
            // cookie path.  Otherwise, we need to pause for a round trip.
            //

            Blob = SaslLocateBuffer( pOutput, SECBUFFER_TOKEN );

            if ( Blob )
            {
                //
                // Already a token.  Switch to pause:
                //

                Context->State = SaslPause ;
            }
            else
            {
                Context->State = SaslCookie ;

                Status = SaslBuildServerCookie( pOutput, Context );

                if ( NT_SUCCESS( Status ) )
                {
                    Status = SEC_I_CONTINUE_NEEDED ;
                }
            }


        }
    }
    else
    {
        if ( Context )
        {
            SaslDeleteContext( Context );
        }
    }

    return Status ;

}

VOID
SaslDeletePackagePrefixes(
    VOID
    )
{
    return ;
}

SECURITY_STATUS
SaslLoadPackagePrefixes(
    VOID
    )
{
    SECURITY_STATUS Status ;
    SECURITY_STATUS SubStatus ;
    PDLL_SECURITY_PACKAGE Package ;
    PNEGOTIATE_PACKAGE_PREFIXES Prefixes = NULL ;
    PNEGOTIATE_PACKAGE_PREFIX PrefixList ;
    PNEGOTIATE_PACKAGE_PREFIXES DllCopy ;
    NEGOTIATE_PACKAGE_PREFIXES LocalPrefix ;
    HANDLE LsaHandle ;
    STRING LocalName = { 0 };
    LSA_OPERATIONAL_MODE Mode ;
    ULONG PrefixLen = 0 ;
    ULONG i ;

    RtlEnterCriticalSection( &SaslLock );

    if ( SaslPrefixes )
    {
        RtlLeaveCriticalSection( &SaslLock );

        return STATUS_SUCCESS ;
    }

    Package = SecLocatePackageW( NEGOSSP_NAME );

    if ( !Package )
    {
        RtlLeaveCriticalSection( &SaslLock );

        return SEC_E_SECPKG_NOT_FOUND ;
    }

    LocalPrefix.MessageType = NegEnumPackagePrefixes ;
    LocalPrefix.Offset = 0 ;
    LocalPrefix.PrefixCount = 0 ;

    Status = LsaConnectUntrusted(
                &LsaHandle );

    if ( NT_SUCCESS( Status ) )
    {
        Status = LsaCallAuthenticationPackage(
                        LsaHandle,
                        (ULONG) Package->PackageId,
                        &LocalPrefix,
                        sizeof( LocalPrefix ),
                        (PVOID *) &Prefixes,
                        &PrefixLen,
                        &SubStatus );

        LsaDeregisterLogonProcess( LsaHandle );
    }

    if ( !NT_SUCCESS( Status ) )
    {

        RtlLeaveCriticalSection( &SaslLock );

        return SEC_E_SECPKG_NOT_FOUND ;
    }

    DllCopy = (PNEGOTIATE_PACKAGE_PREFIXES) LocalAlloc( LMEM_FIXED, PrefixLen );

    if ( !DllCopy )
    {
        LsaFreeReturnBuffer( Prefixes );

        RtlLeaveCriticalSection( &SaslLock );

        return SEC_E_INSUFFICIENT_MEMORY ;
    }

    RtlCopyMemory(
        DllCopy,
        Prefixes,
        PrefixLen );

    LsaFreeReturnBuffer( Prefixes );

    //
    // Now, fix them up:
    //

    PrefixList = (PNEGOTIATE_PACKAGE_PREFIX) ((PUCHAR) DllCopy + DllCopy->Offset );

    for ( i = 0 ; i < DllCopy->PrefixCount ; i++ )
    {
        Package = SecLocatePackageById( PrefixList[ i ].PackageId );

        if ( !Package )
        {
            break;
        }

        Status = SecCopyPackageInfoToUserA( Package, (PSecPkgInfoA *) &PrefixList[ i ].PackageDataA );

        if ( NT_SUCCESS( Status ) )
        {
            Status = SecCopyPackageInfoToUserW( Package, (PSecPkgInfoW *) &PrefixList[ i ].PackageDataW );

        }

        if ( !NT_SUCCESS( Status ) )
        {
            Package = NULL ;
            break;
        }

    }


    //
    // Now, update the globals and we're done:
    //

    SaslPrefixList = PrefixList ;
    SaslPrefixes = DllCopy ;

    if ( Package == NULL )
    {
        //
        // Error path out of the loop.  Destroy and bail
        //

        SaslDeletePackagePrefixes();

    }

    RtlLeaveCriticalSection( &SaslLock );

    return STATUS_SUCCESS ;


}

int
Sasl_der_read_length(
     unsigned char **buf,
     int *bufsize
     )
{
   unsigned char sf;
   int ret;

   if (*bufsize < 1)
      return(-1);
   sf = *(*buf)++;
   (*bufsize)--;
   if (sf & 0x80) {
      if ((sf &= 0x7f) > ((*bufsize)-1))
         return(-1);
      if (sf > sizeof(int))
          return (-1);
      ret = 0;
      for (; sf; sf--) {
         ret = (ret<<8) + (*(*buf)++);
         (*bufsize)--;
      }
   } else {
      ret = sf;
   }

   return(ret);
}

SECURITY_STATUS
SaslIdentifyPackageHelper(
    PSecBufferDesc  pInput,
    PNEGOTIATE_PACKAGE_PREFIX * pPrefix
    )
{
    SECURITY_STATUS Status ;
    ULONG i ;
    PSecBuffer Token = NULL ;
    PUCHAR Buffer ;
    int Size ;
    int OidSize ;

    if ( !SaslPrefixes )
    {
        Status = SaslLoadPackagePrefixes();

        if ( !NT_SUCCESS( Status ) )
        {
            return Status ;
        }
    }

    for ( i = 0 ; i < pInput->cBuffers ; i++ )
    {
        if ( (pInput->pBuffers[ i ].BufferType & (~(SECBUFFER_ATTRMASK)) ) == SECBUFFER_TOKEN )
        {
            Token = &pInput->pBuffers[ i ];
            break;
        }
    }

    if ( !Token )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    //
    // Special case checks:

    Size = (int) Token->cbBuffer ;
    Buffer = (PUCHAR) Token->pvBuffer ;

    if ( Size == 0 )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    Size-- ;
    if ( (*Buffer != 0x60) &&
         (*Buffer != 0xA0) )
    {
        //
        // Not a valid SASL buffer
        //

        return SEC_E_INVALID_TOKEN ;
    }

    if ( *Buffer == 0xa0 )
    {
        *pPrefix = &SaslPrefixList[ 0 ];

        return STATUS_SUCCESS ;
    }

    Buffer++ ;

    OidSize = Sasl_der_read_length( &Buffer, &Size );

    if (OidSize < 0)
    {
        return SEC_E_INVALID_TOKEN ;
    }

    if ( *Buffer != 0x06 )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    OidSize = (int) Buffer[ 1 ] + 2;

    for ( i = 0 ; i < SaslPrefixes->PrefixCount ; i++ )
    {
        if ( (OidSize < (int)SaslPrefixList[ i ].PrefixLen ) ||
             (SaslPrefixList[ i ].PrefixLen == 0 ) )
        {
            continue;
        }

        if ( RtlEqualMemory( Buffer,
                             SaslPrefixList[ i ].Prefix,
                             SaslPrefixList[ i ].PrefixLen )  )
        {
            break;
        }
    }

    if ( i != SaslPrefixes->PrefixCount )
    {
        *pPrefix = &SaslPrefixList[ i ] ;
        Status = STATUS_SUCCESS ;
    }
    else
    {
        *pPrefix = NULL ;
        Status = SEC_E_INVALID_TOKEN ;
    }

    return Status ;

}


SECURITY_STATUS
SEC_ENTRY
SaslIdentifyPackageA(
    PSecBufferDesc  pInput,
    PSecPkgInfoA *   pPackage
    )
{
    SECURITY_STATUS Status ;
    PNEGOTIATE_PACKAGE_PREFIX Prefix = NULL ;

    Status = SaslIdentifyPackageHelper( pInput, &Prefix );

    if ( NT_SUCCESS( Status ) )
    {
        *pPackage = (PSecPkgInfoA) Prefix->PackageDataA ;
    }

    return Status ;
}


SECURITY_STATUS
SEC_ENTRY
SaslIdentifyPackageW(
    PSecBufferDesc  pInput,
    PSecPkgInfoW *   pPackage
    )
{
    SECURITY_STATUS Status ;
    PNEGOTIATE_PACKAGE_PREFIX Prefix = NULL ;

    Status = SaslIdentifyPackageHelper( pInput, &Prefix );

    if ( NT_SUCCESS( Status ) )
    {
        *pPackage = (PSecPkgInfoW) Prefix->PackageDataW ;
    }

    return Status ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\dll\negstubs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       negstubs.cxx
//
//  Contents:   Stubs to the negotiate package
//
//  Classes:
//
//  Functions:
//
//  History:    8-20-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
}

SpInstanceInitFn                NegInstanceInit;
SpInitUserModeContextFn         NegInitUserModeContext;
SpMakeSignatureFn               NegMakeSignature;
SpVerifySignatureFn             NegVerifySignature;
SpSealMessageFn                 NegSealMessage;
SpUnsealMessageFn               NegUnsealMessage;
SpGetContextTokenFn             NegGetContextToken;
SpQueryContextAttributesFn      NegQueryContextAttributes;
SpDeleteContextFn               NegDeleteUserModeContext;
SpCompleteAuthTokenFn           NegCompleteAuthToken;
SpFormatCredentialsFn           NegFormatCredentials;
SpMarshallSupplementalCredsFn   NegMarshallSupplementalCreds;
SpExportSecurityContextFn       NegExportSecurityContext;
SpImportSecurityContextFn       NegImportSecurityContext;

SECPKG_USER_FUNCTION_TABLE NegTable =
    {
     NegInstanceInit,
     NegInitUserModeContext,
     NegMakeSignature,
     NegVerifySignature,
     NegSealMessage,
     NegUnsealMessage,
     NegGetContextToken,
     NegQueryContextAttributes,
     NegCompleteAuthToken,
     NegDeleteUserModeContext,
     NegFormatCredentials,
     NegMarshallSupplementalCreds,
     NegExportSecurityContext,
     NegImportSecurityContext

    } ;

#define NegGenerateLsaHandle( PackageHandle, NewHandle ) \
            ((PSecHandle) NewHandle)->dwUpper = PackageHandle ; \
            ((PSecHandle) NewHandle)->dwLower = ((PDLL_SECURITY_PACKAGE) GetCurrentPackage())->OriginalLowerCtxt ;


NTSTATUS
SEC_ENTRY
NegUserModeInitialize(
    IN ULONG    LsaVersion,
    OUT PULONG  PackageVersion,
    OUT PSECPKG_USER_FUNCTION_TABLE * UserFunctionTable,
    OUT PULONG  pcTables)
{
    PSECPKG_USER_FUNCTION_TABLE Table ;

    if (LsaVersion < SECPKG_INTERFACE_VERSION)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    *PackageVersion = SECPKG_INTERFACE_VERSION ;

    *UserFunctionTable = &NegTable ;
    *pcTables = 1;

    return STATUS_SUCCESS ;

}


NTSTATUS NTAPI
NegInstanceInit(
    IN ULONG Version,
    IN PSECPKG_DLL_FUNCTIONS DllFunctionTable,
    OUT PVOID * UserFunctionTable
    )
{
    return STATUS_SUCCESS ;
}


NTSTATUS NTAPI
NegDeleteUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle
    )
{
    return STATUS_SUCCESS ;
}


NTSTATUS NTAPI
NegInitUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer PackedContext
    )
{
    return STATUS_SUCCESS ;
}


NTSTATUS NTAPI
NegExportSecurityContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer PackedContext,
    OUT PHANDLE TokenHandle
    )
{
    return SEC_E_INVALID_HANDLE ;
}

NTSTATUS
NTAPI
NegImportSecurityContext(
    IN PSecBuffer PackedContext,
    IN HANDLE Token,
    OUT PLSA_SEC_HANDLE ContextHandle
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION ;
}


NTSTATUS NTAPI
NegMakeSignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION ;
}


NTSTATUS NTAPI
NegVerifySignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION ;
}


NTSTATUS NTAPI
NegSealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION ;
}


NTSTATUS NTAPI
NegUnsealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION ;
}

NTSTATUS NTAPI
NegGetContextToken(
    IN LSA_SEC_HANDLE ContextHandle,
    OUT PHANDLE ImpersonationToken
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION ;
}


NTSTATUS NTAPI
NegQueryContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID Buffer
    )
{
    SEC_HANDLE_LPC hContext ;
    NTSTATUS Status ;
    ULONG Allocs = 0 ;
    PVOID Buffers[ 2 ] = { 0 };
    ULONG Flags = 0;
#ifdef BUILD_WOW64
    CtxtHandle Temp ;
#endif 

    switch ( ContextAttribute )
    {
        case SECPKG_ATTR_NEGOTIATION_INFO:
        {

#ifdef BUILD_WOW64

            //
            // Server side of this call copies over an entire new Buffer -- make sure
            // there's enough space for it.
            //

            SECPKGCONTEXT_NEGOTIATIONINFOWOW64  NegoInfo64;
            PSECPKG_INFO_WOW64                  pPackageInfo64;
            PSecPkgContext_NegotiationInfo      NegoInfo = (PSecPkgContext_NegotiationInfo) Buffer;

            Buffer = &NegoInfo64;

            NegGenerateLsaHandle( ContextHandle, &Temp );

            if (!SecpReferenceHandleMap( 
                    (PSECWOW_HANDLE_MAP) Temp.dwUpper, 
                    &hContext ))
            {
                return SEC_E_INVALID_HANDLE;
            }

#else
            NegGenerateLsaHandle( ContextHandle, &hContext );
#endif 
            Status = SecpQueryContextAttributes(
                        NULL,
                        &hContext,
                        SECPKG_ATTR_NEGOTIATION_INFO,
                        Buffer,
                        &Allocs,
                        Buffers,
                        &Flags );

#ifdef BUILD_WOW64

            pPackageInfo64 = (PSECPKG_INFO_WOW64) (ULONG) NegoInfo64.pPackageInfo64;

            NegoInfo->PackageInfo      = (PSecPkgInfoW) pPackageInfo64;
            NegoInfo->NegotiationState = NegoInfo64.NegotiationState;

            SecpLpcPkgInfoToSecPkgInfo(NegoInfo->PackageInfo, pPackageInfo64);
            Buffer = NegoInfo;

            SecpDerefHandleMap( 
                    (PSECWOW_HANDLE_MAP) Temp.dwUpper );
#endif 

            if ( NT_SUCCESS( Status ) )
            {
                ULONG i ;

                for ( i = 0 ; i < Allocs ; i++ )
                {
                    SecpAddVM( Buffers[ i ] );
                }

            }

            return Status ;
        }

        default:
            return SEC_E_UNSUPPORTED_FUNCTION ;

    }
    return SEC_E_UNSUPPORTED_FUNCTION ;
}


NTSTATUS NTAPI
NegCompleteAuthToken(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc InputBuffer
    )
{
    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
NegFormatCredentials(
    IN PSecBuffer Credentials,
    OUT PSecBuffer FormattedCredentials
    )
{
    return(STATUS_NOT_SUPPORTED);
}

NTSTATUS NTAPI
NegMarshallSupplementalCreds(
    IN ULONG CredentialSize,
    IN PUCHAR Credentials,
    OUT PULONG MarshalledCredSize,
    OUT PVOID * MarshalledCreds
    )
{
    return(STATUS_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\dll\stubs.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        stubs.cxx
//
// Contents:    user-mode stubs for security API
//
//
// History:     3/5/94      MikeSw      Created
//
//------------------------------------------------------------------------
#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
}


static LUID            lFake = {0, 0};
static SECURITY_STRING sFake = {0, 0, NULL};
static SecBufferDesc EmptyBuffer;

//+-------------------------------------------------------------------------
//
//  Function:   FreeContextBuffer
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
FreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    )
{
    if ( SecpFreeVM( pvContextBuffer ) )
    {
        DebugLog(( DEB_TRACE, "Freeing VM %x\n", pvContextBuffer ));

        LsaFreeReturnBuffer( pvContextBuffer );
    }
    else
    {
        LocalFree( pvContextBuffer );
    }

    return( SEC_E_OK );
}




SECURITY_STATUS
SEC_ENTRY
AddSecurityPackageW(
    LPWSTR          pszPackageName,
    PSECURITY_PACKAGE_OPTIONS pOptions
    )
{
    SECURITY_PACKAGE_OPTIONS    Options;
    UNICODE_STRING Package;

    if ( pOptions == NULL )
    {
        pOptions = &Options;
        Options.Size = sizeof( Options );
        Options.Flags = 0;

    }

    RtlInitUnicodeString( &Package, pszPackageName );

    return( SecpAddPackage( &Package, pOptions ) );

}


SECURITY_STATUS
SEC_ENTRY
AddSecurityPackageA(
    LPSTR          pszPackageName,
    PSECURITY_PACKAGE_OPTIONS pOptions
    )
{
    SECURITY_PACKAGE_OPTIONS    Options;
    UNICODE_STRING Package;
    SECURITY_STATUS scRet ;

    if ( pOptions == NULL )
    {
        pOptions = &Options;
        Options.Size = sizeof( Options );
        Options.Flags = 0;

    }

    if ( RtlCreateUnicodeStringFromAsciiz( &Package, pszPackageName ) )
    {
        scRet = SecpAddPackage( &Package, pOptions );

        RtlFreeUnicodeString( &Package );
    }
    else 
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY ;
    }

    return( scRet );

}

SECURITY_STATUS
SEC_ENTRY
DeleteSecurityPackageW(
    LPWSTR  pszPackageName
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}

SECURITY_STATUS
SEC_ENTRY
DeleteSecurityPackageA(
    LPSTR   pszPackageName
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\dll\secdll.h ===
//+-----------------------------------------------------------------------
//
// File:        SECDLL.H
//
// Contents:    Security DLL private defines
//
//
// History:     11 Mar 92   RichardW    Recreated
//
//------------------------------------------------------------------------

#ifndef __SECDLL_H__
#define __SECDLL_H__

#include <spseal.h> // prototypes for seal & unseal
#include <secur32p.h>

#include "debug.h"

#define SECPKG_TYPE_OLD     0x00000001  // Old, SSPI style
#define SECPKG_TYPE_NEW     0x00000002  // New, LSA style
#define SECPKG_TYPE_BUILTIN 0x00000004  // Internal psuedo
#define SECPKG_TYPE_ANY     0x00000008  // Any (for searching)

#define SECPKG_TYPE_ANSI    0x00000010  // Ansi (narrow)
#define SECPKG_TYPE_WIDE    0x00000020  // Unicode (wide)

typedef enum _SECPKG_TYPE {
    SecPkgOld,                  // Old, indeterminate (not yet loaded)
    SecPkgOldA,                 // Old style DLL only, ANSI entry points only
    SecPkgOldW,                 // Old style, Unicode entry points only
    SecPkgOldAW,                // Old style, both flavors
    SecPkgNew,                  // New, info from the LSA
    SecPkgNewAW,                // Ansi support
    SecPkgBuiltin,              // Builtin pseudo package
    SecPkgAny,                  // Any type (for searches)
    SecPkgAnsi,                 // Any ansi type (for searches)
    SecPkgWide                  // Any wide type (for searches)
} SECPKG_TYPE, *PSECPKG_TYPE ;

struct _DLL_BINDING;
struct _DLL_SECURITY_PACKAGE;

typedef void (SEC_ENTRY * EXIT_SECURITY_INTERFACE) (void);
typedef BOOL (SEC_ENTRY * LOAD_SECURITY_INTERFACE) (struct _DLL_SECURITY_PACKAGE * Package);

typedef struct _DLL_LSA_CALLBACK {
    LIST_ENTRY                  List ;
    ULONG                       CallbackId ;
    PLSA_CALLBACK_FUNCTION      Callback ;
} DLL_LSA_CALLBACK, * PDLL_LSA_CALLBACK ;

typedef struct _DLL_LSA_PACKAGE_INFO {
    ULONG                       ContextThunkCount ;
    PULONG                      ContextThunks ;
    LIST_ENTRY                  Callbacks ;
} DLL_LSA_PACKAGE_INFO, * PDLL_LSA_PACKAGE_INFO ;

typedef struct _DLL_SECURITY_PACKAGE {
    LIST_ENTRY                  List;               // List Control
    ULONG                       TypeMask ;
    ULONG_PTR                   PackageId;          // ID
    ULONG                       PackageIndex;       // Index for the package
    ULONG                       fState;             // State
    ULONG_PTR                   OriginalLowerCtxt;  // Original Lower context handle
    ULONG_PTR                   OriginalLowerCred;  // Original lower cred handle
    struct _DLL_BINDING *       pBinding;           // Link to DLL binding
    struct _DLL_SECURITY_PACKAGE * pRoot ;          // "First" Package of a DLL
    struct _DLL_SECURITY_PACKAGE * pPeer ;          // "Peer" package list
    ULONG                       fCapabilities;      // Package Info:
    WORD                        Version;            // Version
    WORD                        RpcId;              // RPC ID
    ULONG                       TokenSize;          // Initial Token Size
    SECURITY_STRING             PackageName;        // Name (U)
    SECURITY_STRING             Comment;            // Comment (U)

    LPSTR                       PackageNameA;       // Only if ANSI supported:
    DWORD                       AnsiNameSize;
    LPSTR                       CommentA;
    DWORD                       AnsiCommentSize;

    PSecurityFunctionTableA     pftTableA;          // Table for ansi-specific calls
    PSecurityFunctionTableW     pftTableW;          // Table for unicode-specific calls
    PSecurityFunctionTableW     pftTable;           // Table for non-specific calls
    PSECPKG_USER_FUNCTION_TABLE pftUTable;          // Table for user-mode stubs
    LOAD_SECURITY_INTERFACE     pfLoadPackage;      // Hook called at package init
    EXIT_SECURITY_INTERFACE     pfUnloadPackage;    // Hook called at package close

    PDLL_LSA_PACKAGE_INFO       LsaInfo ;           // Extra LSA info

} DLL_SECURITY_PACKAGE, * PDLL_SECURITY_PACKAGE ;

typedef struct _DLL_BINDING {
    SECPKG_TYPE     Type;               // Type of DLL loaded
    DWORD           Flags;              // Flags about the DLL
    HMODULE         hInstance;          // Instance Handle
    SECURITY_STRING Filename;           // Full path name
    DWORD           RefCount;           // Reference Count
    DWORD           PackageCount;       // Number of Packages in DLL
    ULONG           DllIndex;           // Index
    PSECPKG_USER_FUNCTION_TABLE Table;  // DLL-wide interface pointer
} DLL_BINDING, * PDLL_BINDING;

typedef struct _SASL_PROFILE {
    LIST_ENTRY              List ;
    PDLL_SECURITY_PACKAGE   Package ;
    SECURITY_STRING         ProfileName ;
} SASL_PROFILE, * PSASL_PROFILE ;

#define DLL_SECPKG_SAVE_LOWER   0x00000001      // Save the lower handle val
#define DLL_SECPKG_FREE_TABLE   0x00000002      // The tables are re-allocated
#define DLL_SECPKG_DELAY_LOAD   0x00000004      // The package is delay loaded
#define DLL_SECPKG_SASL_PROFILE 0x00000008      // The package has a SASL profile
#define DLL_SECPKG_CRED_LOWER   0x00000010      // Uses different values for context and cred
#define DLL_SECPKG_NO_CRYPT     0x00000020      // Fail crypto

#define DLL_BINDING_SIG_CHECK   0x00000001      // Signature has been checked
#define DLL_BINDING_DELAY_LOAD  0x00000002      // Delay load this DLL
#define DLL_BINDING_FREE_TABLE  0x00000004      // Free tables


#define DLLSTATE_DEFERRED   0x80000000
#define DLLSTATE_INITIALIZE 0x40000000
#define DLLSTATE_NO_TLS     0x20000000
#define DLLSTATE_CRITSEC    0x10000000
#define DLLSTATE_VMLIST     0x08000000
#define DLLSTATE_HANDLEMAP  0x04000000
#define DLLSTATE_PACKAGES   0x02000000



#if DBG

void SecInitializeDebug(void);
void SecUninitDebug(void);

#define DebugStmt(x)    x

#else

#define DebugStmt(x)

#endif



// Private prototypes

SECURITY_STATUS SEC_ENTRY
DeleteUserModeContext(
    PCtxtHandle                 phContext           // Contxt to delete
    );

SECURITY_STATUS       LoadParameters(void);

SECURITY_STATUS IsSPMgrReady(void);

SECURITY_STATUS
SspNtStatusToSecStatus(
    IN NTSTATUS NtStatus,
    IN SECURITY_STATUS DefaultStatus
    );

VOID * SEC_ENTRY
SecClientAllocate(ULONG cbMemory);

void SEC_ENTRY
SecClientFree(PVOID pvMemory);

BOOL
SecpAddVM(
    PVOID   pvAddr);

BOOL
SecpFreeVM(
    PVOID   pvAddr );

PDLL_SECURITY_PACKAGE
SecLocatePackageA(
    LPSTR   pszPackageName );

PDLL_SECURITY_PACKAGE
SecLocatePackageW(
    LPWSTR  pszPackageName );

PDLL_SECURITY_PACKAGE
SecLocatePackageById(
    ULONG_PTR Id );

PDLL_SECURITY_PACKAGE
SecLocatePackageByOriginalLower(
    BOOL Context,
    PDLL_SECURITY_PACKAGE OriginalPackage,
    ULONG_PTR    OriginalLower );

PSASL_PROFILE
SecLocateSaslProfileA(
    LPSTR ProfileName
    );

PSASL_PROFILE
SecLocateSaslProfileW(
    LPWSTR ProfileName
    );

SECURITY_STATUS
SecCopyPackageInfoToUserA(
    PDLL_SECURITY_PACKAGE Package,
    PSecPkgInfoA * pPackageInfo
    );

SECURITY_STATUS
SecCopyPackageInfoToUserW(
    PDLL_SECURITY_PACKAGE  Package,
    PSecPkgInfoW SEC_FAR * pPackageInfo
    );

SECURITY_STATUS
SecEnumerateSaslProfilesW(
    OUT LPWSTR * ProfileList,
    OUT ULONG * ProfileCount
    );

SECURITY_STATUS
SecEnumerateSaslProfilesA(
    OUT LPSTR * ProfileList,
    OUT ULONG * ProfileCount
    );

BOOL
SecInitializePackageControl(
    HINSTANCE);

VOID
SecUnloadPackages(
    BOOLEAN ProcessTerminate );

VOID
SecpFreePackages(
    IN PLIST_ENTRY pSecPackageList,
    IN BOOL fUnload
    );

VOID
SecpFreePackage(
    IN PDLL_SECURITY_PACKAGE pPackage,
    IN BOOL fUnload
    );

BOOL
SecEnumeratePackagesW(
    PULONG  PackageCount,
    PSecPkgInfoW *  Packages);

BOOL
SecEnumeratePackagesA(
    PULONG          PackageCount,
    PSecPkgInfoA *  Packages);

VOID
SecSetPackageFlag(
    PDLL_SECURITY_PACKAGE Package,
    ULONG   Flag);

VOID
SecClearPackageFlag(
    PDLL_SECURITY_PACKAGE Package,
    ULONG FLag);

BOOL
SEC_ENTRY
LsaBootPackage(
    PDLL_SECURITY_PACKAGE Package);

VOID
SEC_ENTRY
LsaUnloadPackage(
    VOID );

SECURITY_STATUS
SEC_ENTRY
SecpFailedSealFunction(
    PCtxtHandle         phContext,
    ULONG               fQOP,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo);

SECURITY_STATUS
SEC_ENTRY
SecpFailedUnsealFunction(
    PCtxtHandle phHandle,
    PSecBufferDesc pMessage,
    ULONG MessageSeqNo,
    ULONG * pfQOP);

VOID
SaslDeleteSecurityContext(
    PCtxtHandle phContext
    );

//
// Global variables
//

extern DWORD                DllState;
extern RTL_CRITICAL_SECTION csSecurity;
extern PClient              SecDllClient;
extern DWORD                SecTlsIP;
extern DWORD                SecTlsPackage;
extern ULONG                SecLsaPackageCount;
extern SecurityFunctionTableW   LsaFunctionTable;
extern SecurityFunctionTableA   LsaFunctionTableA;
extern SECPKG_DLL_FUNCTIONS SecpFTable;
extern LIST_ENTRY SaslContextList ;
extern CRITICAL_SECTION SaslLock ;


#define SECPKG_LIST_LOCKS_MAX   4
// insure power of 2.
C_ASSERT( (SECPKG_LIST_LOCKS_MAX % 2) == 0 );

extern ULONG SecPackageListLockCount;
extern RTL_RESOURCE SecPackageListLock[];

#define ReadLockPackageList()   \
    RtlAcquireResourceShared(&SecPackageListLock[NtCurrentTeb()->IdealProcessor & (SecPackageListLockCount-1)] ,TRUE)

#define UnlockPackageList()     \
    RtlReleaseResource(&SecPackageListLock[NtCurrentTeb()->IdealProcessor & (SecPackageListLockCount-1)])

#define WriteLockPackageList()  \
{                               \
    ULONG LockIndex;            \
                                \
    for( LockIndex = 0 ; LockIndex < SecPackageListLockCount ; LockIndex++ )    \
    {                                                                           \
        RtlAcquireResourceExclusive(&SecPackageListLock[ LockIndex ] ,TRUE);    \
    }                           \
}                               \

#define WriteUnlockPackageList()    \
{                                   \
    ULONG LockIndex;                \
                                    \
    for( LockIndex = 0 ; LockIndex < SecPackageListLockCount ; LockIndex++ )    \
    {                                                                           \
        RtlReleaseResource( &SecPackageListLock[ LockIndex ]);                  \
    }                                                                           \
}



#ifdef BUILD_WOW64

//
// Additional WOW64 defines
//


typedef struct _SECWOW_HANDLE_MAP {
    LIST_ENTRY  List ;
    SEC_HANDLE_LPC  Handle ;
    ULONG HandleCount ;
    ULONG RefCount ;
} SECWOW_HANDLE_MAP, * PSECWOW_HANDLE_MAP ;

BOOL
SecpInitHandleMap(
    VOID
    );

BOOL
SecpFreeHandleMap(
    VOID
    );

BOOL
SecpAddHandleMap(
    IN PSEC_HANDLE_LPC LsaHandle,
    OUT PSECWOW_HANDLE_MAP * LocalHandle
    );

VOID
SecpDeleteHandleMap(
    IN PSECWOW_HANDLE_MAP HandleMap
    );

VOID
SecpDerefHandleMap(
    IN PSECWOW_HANDLE_MAP HandleMap
    );

BOOL
SecpReferenceHandleMap(
    IN PSECWOW_HANDLE_MAP HandleMap,
    OUT PSEC_HANDLE_LPC LsaHandle
    );
#endif 

//
// Process wide synchronization
//
// NOTE:  UPDATE THE MACRO if the name of the critical section changes
//

#if DBG

void    GetProcessLock();
void    FreeProcessLock();

#else

#define GetProcessLock()    (void) RtlEnterCriticalSection(&csSecurity)
#define FreeProcessLock()   (void) RtlLeaveCriticalSection(&csSecurity)

#endif

#define SetCurrentPackage( p )  TlsSetValue( SecTlsPackage, p )
#define GetCurrentPackage( )    TlsGetValue( SecTlsPackage )


//
// Handle storing/fetching an IP address.  Caller's responsibility
// to make sure that (!(DllState & DLLSTATE_NO_TLS)) before setting.
//

#define SecGetIPAddress()   ((DllState & DLLSTATE_NO_TLS) ? NULL : TlsGetValue(SecTlsIP))
#define SecSetIPAddress(p)  TlsSetValue(SecTlsIP, p);

#endif // __SECDLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\dll\support.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        support.cxx
//
// Contents:    support routines for security dll
//
//
// History:     3-7-94      Created     MikeSw
//
//------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"

#include <overflow.h>
}

BOOL ProcAttach(HINSTANCE, LPVOID);
BOOL ProcDetach(HANDLE, LPVOID);

typedef struct _VMLIST {
    struct _VMLIST *    Next;
    PVOID               Vaddr;
} VMLIST, * PVMLIST ;



//
// Global Variables:
//

DWORD                DllState;
RTL_CRITICAL_SECTION csSecurity;
PClient              SecDllClient;
DWORD                SecTlsIP;
DWORD                SecTlsPackage ;

#define VMLIST_MAX_FREE_SIZE    16

RTL_CRITICAL_SECTION SecVMListLock;
PVMLIST              SecVMList;
PVMLIST              SecVMFreeList;
ULONG                SecVMFreeListSize;

#if DBG
ULONG                SecVMListSize ;

DWORD                   LockOwningThread;
#endif

//
// How we know that we are connected to the SPM:
// 1)   DllState & DLLSTATE_DEFERRED == 0.  This means we are ready to go,
//      and is a very fast check
//
// 2)   In the event that DllState still indicates that we aren't connected,
//      another thread may have initiated the connection already.  So, if we
//      see that we're still deferred, *then* we grab the process lock, and
//      check SecDllClient.
//



WCHAR       szLsaEvent[] = SPM_EVENTNAME;



BOOL WINAPI DllMain(
    HINSTANCE       hInstance,
    DWORD           dwReason,
    LPVOID          lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls ( hInstance );
            return ProcAttach(hInstance, lpReserved);

        case DLL_PROCESS_DETACH:
            return ProcDetach(hInstance, lpReserved);

        default:
            return(TRUE);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   FreeClient
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
FreeClient(PClient pClient)
{
    // nothing
}


///////////////////////////////////////////////////////////////////////////
//
// VMLIST routines
//
//  Because the LSA will allocate client memory in VM chunks, and SSPI DLLs
//  will allocate in Heap chunks, we have this lookaside to handle the list
//  of VM chunks that we check against.
//
///////////////////////////////////////////////////////////////////////////

NTSTATUS
SecpInitVMList(
    VOID
    )
{
    NTSTATUS Status;

    Status = RtlInitializeCriticalSection( &SecVMListLock );

    if ( NT_SUCCESS( Status ) )
    {
        SecVMList = NULL ;

        SecVMFreeList = NULL ;

        SecVMFreeListSize = 0;

#if DBG
        SecVMListSize = 0 ;
#endif

        return( STATUS_SUCCESS );

    }

    return( Status );
}


BOOL
SecpAddVM(
    PVOID   pvAddr)
{
    PVMLIST List;

    if(pvAddr == NULL)
    {
        return TRUE;
    }

    RtlEnterCriticalSection( &SecVMListLock );

    List = SecVMFreeList ;

    if ( List )
    {
        SecVMFreeList = List->Next ;

        SecVMFreeListSize --;

    }
    else
    {
        List = (PVMLIST) RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( VMLIST ) );
    }

    if ( List )
    {
        List->Vaddr = pvAddr ;

        List->Next = SecVMList ;

        SecVMList = List;

#if DBG
        SecVMListSize ++ ;
#endif

        RtlLeaveCriticalSection( &SecVMListLock );

        return( TRUE );
    }

    RtlLeaveCriticalSection( &SecVMListLock );

    return( FALSE );


}

BOOL
SecpFreeVM(
    PVOID   pvAddr )
{
    PVMLIST Search;
    PVMLIST Trail;

    Trail = NULL ;

    RtlEnterCriticalSection( &SecVMListLock );

    Search = SecVMList ;

    while ( Search )
    {
        if ( Search->Vaddr == pvAddr )
        {

#if DBG
            SecVMListSize -- ;
#endif

            if ( Trail )
            {
                Trail->Next = Search->Next ;
            }
            else
            {
                SecVMList = Search->Next ;
            }

            if ( SecVMFreeListSize < VMLIST_MAX_FREE_SIZE )
            {
                Search->Next = SecVMFreeList ;

                SecVMFreeList = Search ;

                SecVMFreeListSize ++ ;

            }
            else
            {
                RtlLeaveCriticalSection( &SecVMListLock );
                RtlFreeHeap( RtlProcessHeap(), 0, Search );
                return TRUE;
            }

            RtlLeaveCriticalSection( &SecVMListLock );

            return( TRUE );
        }

        Trail = Search;

        Search = Search->Next ;
    }

    RtlLeaveCriticalSection( &SecVMListLock );

    return( FALSE );
}

VOID
SecpUnloadVMList(
    VOID
    )
{
    PVMLIST Search;
    PVOID   Free;
    SIZE_T  BlockSize;

    RtlEnterCriticalSection( &SecVMListLock );

    Search = SecVMList ;

    while ( Search )
    {
        BlockSize = 0;

        NtFreeVirtualMemory( NtCurrentProcess(),
                             &Search->Vaddr,
                             &BlockSize,
                             MEM_RELEASE );

        Free = Search ;

        Search = Search->Next ;

        RtlFreeHeap( RtlProcessHeap(), 0, Free );
    }

    RtlLeaveCriticalSection( &SecVMListLock );

    RtlDeleteCriticalSection( &SecVMListLock );

}



//+-------------------------------------------------------------------------
//
//  Function:   SecClientAllocate
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID * SEC_ENTRY
SecClientAllocate(ULONG cbMemory)
{

    return( LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, cbMemory ) );
}



//+-------------------------------------------------------------------------
//
//  Function:   SecClientFree
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


void SEC_ENTRY
SecClientFree(PVOID pvMemory)
{
    FreeContextBuffer(pvMemory);
}







#if DBG
//+---------------------------------------------------------------------------
//
//  Function:   GetProcessLock
//
//  Synopsis:   Debug only wrapper for critical section
//
//  Arguments:  (none)
//
//  History:    9-10-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void
GetProcessLock(void)
{
    NTSTATUS    Status;

    Status = RtlEnterCriticalSection(&csSecurity);

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Could not get process-wide lock:  %x\n", Status));
    }

    LockOwningThread = GetCurrentThreadId();

}

//+---------------------------------------------------------------------------
//
//  Function:   FreeProcessLock
//
//  Synopsis:   Debug only wrapper for critical section
//
//  History:    9-10-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void
FreeProcessLock(void)
{
    NTSTATUS    Status;

    LockOwningThread = 0;

    Status = RtlLeaveCriticalSection(&csSecurity);

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Could not free process-wide lock: %x\n", Status));
    }
}

#endif // DBG

//+-------------------------------------------------------------------------
//
//  Function:   IsSPMgrReady()
//
//  Synopsis:   Internal function to determine the state of the link
//              to the SPM.  Called by all APIs before they attempt
//              to execute.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    TRUE or FALSE
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
IsSPMgrReady(
    VOID )
{
    OBJECT_ATTRIBUTES           EventObjAttr;
    NTSTATUS                    status;
    UNICODE_STRING              EventName;
    EVENT_BASIC_INFORMATION     EventStatus;
    HANDLE                      hEvent;

    RtlInitUnicodeString(&EventName, szLsaEvent);
    InitializeObjectAttributes(&EventObjAttr, &EventName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenEvent(&hEvent, EVENT_QUERY_STATE, &EventObjAttr);

    if (!NT_SUCCESS(status))
    {
        DebugLog((DEB_ERROR, "Could not open security event %ws, %x\n",
                    EventName.Buffer, status));

        return( status );
    }

    status = NtQueryEvent(  hEvent,
                            EventBasicInformation,
                            &EventStatus,
                            sizeof(EventStatus),
                            NULL);

    if (!NT_SUCCESS(status))
    {
        DebugLog((DEB_ERROR, "Failed NtQueryEvent on %ws, %x\n", EventName.Buffer, status));
        return( status );
    }

    (void) NtClose(hEvent);

    return( EventStatus.EventState == 0 ? STATUS_UNSUCCESSFUL : STATUS_SUCCESS );
}



//+-------------------------------------------------------------------------
//
//  Function:   InitState
//
//  Synopsis:   Performs the process bind to the SPM, allows SPM to open the
//              process, all sorts of things
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT
InitState(void)
{
    SECURITY_STATUS scRet;
    Client          TempClient;
    ULONG SecurityMode;

    GetProcessLock();

    //
    // If SecDllClient is non-null, then another thread has been here and
    // has initialized the connection.
    //

    if (SecDllClient)
    {
        FreeProcessLock();
        return(S_OK);
    }


    DebugLog(( DEB_TRACE, "Connecting to LSA\n" ));

    scRet = CreateConnection(NULL,      // no client name
                             0,         // no mode flags
                             &TempClient.hPort,
                             &SecLsaPackageCount,
                             &SecurityMode );

    if (scRet != STATUS_SUCCESS)
    {
        DebugLog((DEB_ERROR, "Error 0x%08x getting LSA state\n", scRet));

        FreeProcessLock();

        return(scRet);
    }

    SecDllClient = (PClient) LocalAlloc(0,sizeof(Client));
    if (!SecDllClient)
    {
        FreeProcessLock();
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    *SecDllClient = TempClient;

    if ( SecurityMode & LSA_MODE_SAME_PROCESS )
    {
        SecpSetSession( SETSESSION_GET_DISPATCH,
                        (ULONG_PTR) SecpLsaCallback,
                        (PULONG_PTR) &SecpLsaDispatchFn,
                        NULL );
    }

    DllState |= DLLSTATE_INITIALIZE;

    DebugLog((DEB_TRACE, "Security DLL initialized\n"));

    FreeProcessLock();

    return(S_OK);
}


//+-------------------------------------------------------------------------
//
//  Function:   IsOkayToExec
//
//  Synopsis:   Determines if it is okay to make a call to the SPM
//
//  Effects:    Binds if necessary to the SPM
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      uses IsSPMgrReady and InitState
//
// How we know that we are connected to the SPM:
// 1)   DllState & DLLSTATE_INITIALIZE != 0.  This means we are ready to go,
//      and is a very fast check
//
// 2)   In the event that DllState still indicates that we aren't connected,
//      another thread may have initiated the connection already.  So, if we
//      see that we're still deferred, *then* we grab the process lock, and
//      check SecDllClient.
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
IsOkayToExec(PClient * ppClient)
{
    SECURITY_STATUS scRet;
    HANDLE RealToken = NULL ;
    HANDLE Null = NULL ;


    //
    // Fast check.  If this bit has been reset, then we know everything is
    // ok.
    //

    if ((DllState & DLLSTATE_INITIALIZE) != 0)
    {

        if (ppClient)
        {
            *ppClient = SecDllClient;
        }
        return(S_OK);
    }

    //
    // Nope.  See if the (expletive deleted) thing is even running.
    //

    scRet = IsSPMgrReady();

    if ( !NT_SUCCESS( scRet ) )
    {
        if ( scRet != STATUS_BAD_IMPERSONATION_LEVEL &&
             scRet != STATUS_ACCESS_DENIED )
        {
            return scRet ;
        }

        //
        // We appear to be running with an identify or anonymous level
        // token while trying to make this initial connection.  Try to
        // suspend the impersonation for the duration.
        //

        scRet = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_READ,
                    TRUE,
                    &RealToken );
        if ( !NT_SUCCESS( scRet ) )
        {
            return scRet ;
        }

        //
        // We've got it, stop impersonating now, and try the connection.
        //

        scRet = NtSetInformationThread(
                    NtCurrentThread(),
                    ThreadImpersonationToken,
                    &Null,
                    sizeof( HANDLE ) );

        if ( !NT_SUCCESS( scRet ) )
        {
            NtClose( RealToken );
            return scRet ;
        }

    }

    //
    // It is running.  Initialize state, make the connection. InitState is
    // MT-Safe, and will make exactly one connection.
    //

    scRet = InitState();

    if ( RealToken )
    {
        NtSetInformationThread(
            NtCurrentThread(),
            ThreadImpersonationToken,
            &RealToken,
            sizeof( HANDLE ) );

        NtClose( RealToken );
    }

    if (FAILED(scRet))
    {
        return(scRet);
    }

    if (ppClient)
    {
        *ppClient = SecDllClient;
    }

    return(S_OK);
}


//+-------------------------------------------------------------------------
//
//  Function:   ProcAttach
//
//  Synopsis:   Handles when a process loads the DLL
//
//  Effects:    Bind process to SPM if it is running, or marks the
//              state as a deferred connection.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:  We receive DLL_PROCESS_DETACH even on DLL_PROCESS_ATTACH
//          failures, so we leave all the cleanup for ProcDetach
//
//--------------------------------------------------------------------------

BOOL
ProcAttach(
    HINSTANCE       hInstance,
    LPVOID          lpReserved
    )
{
    NTSTATUS    scRet;

#if DBG

    SecInitializeDebug();

#endif

    DllState |= DLLSTATE_DEFERRED;
    SecDllClient = NULL;

    //
    // We always need SecTlsPackage -- we can make do without SecTlsIP
    //

    SecTlsPackage = TlsAlloc();

    if (SecTlsPackage == 0xFFFFFFFF)
    {
        DebugLog((DEB_ERROR, "Could not get package TLS slot"));
        return FALSE;
    }

    SecTlsIP = TlsAlloc();

    if (SecTlsIP == 0xFFFFFFFF)
    {
        DllState |= DLLSTATE_NO_TLS;
    }

    scRet = RtlInitializeCriticalSection(&csSecurity);

    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR, "Could not initialize critsec, %x\n", scRet));
        return FALSE;
    }

    DllState |= DLLSTATE_CRITSEC;

    scRet = SecpInitVMList();

    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR, "Could not initialize VM list, %x\n", scRet));
        return FALSE;
    }

    DllState |= DLLSTATE_VMLIST;

#if BUILD_WOW64

    if ( !SecpInitHandleMap())
    {
        return FALSE ;
    }

    DllState |= DLLSTATE_HANDLEMAP;

#endif

    if ( SecInitializePackageControl( hInstance ))
    {
        DllState |= DLLSTATE_PACKAGES;
        return TRUE;
    }

    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Function:   ProcDetach
//
//  Synopsis:   Handles a process detach of the security DLL
//
//  Effects:    Unbinds the connection to the SPM.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL
ProcDetach(
    HANDLE          hInstance,
    LPVOID          lpReserved
    )
{
    ULONG i;
    BOOLEAN ProcessTerminate = (lpReserved != NULL);

    //
    // Don't grab locks in the process termination case
    // to avoid deadlocks with RTL_RESOURCEs.
    //

    if (SecTlsPackage != 0xFFFFFFFF)
    {
        TlsFree(SecTlsPackage);
    }

    if (!(DllState & DLLSTATE_NO_TLS))
    {
        TlsFree(SecTlsIP);
    }

    if (DllState & DLLSTATE_PACKAGES)
    {
        SecUnloadPackages(ProcessTerminate);
    }

#if BUILD_WOW64

    if (DllState & DLLSTATE_HANDLEMAP)
    {
        SecpFreeHandleMap();
    }

#endif

    //
    // Clean up remaining VM list entries
    //

    if (DllState & DLLSTATE_VMLIST)
    {
        SecpUnloadVMList();
    }

    if (DllState & DLLSTATE_CRITSEC)
    {
        RtlDeleteCriticalSection(&csSecurity);
    }

    if (SecDllClient)
    {
        NtClose(SecDllClient->hPort);
        LocalFree(SecDllClient);
    }

    DebugLog((DEB_TRACE, "Security DLL unbinding\n"));

#if DBG

    SecUninitDebug();

#endif

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:   SspNtStatusToSecStatus
//
//  Synopsis:   Convert an NtStatus code to the corresponding Security status
//              code. For particular errors that are required to be returned
//              as is (for setup code) don't map the errors.
//
//  Effects:
//
//
//  Arguments:  NtStatus - NT status to convert
//
//  Requires:
//
//  Returns:    Returns security status code.
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SspNtStatusToSecStatus(
    IN NTSTATUS NtStatus,
    IN SECURITY_STATUS DefaultStatus
    )
{
    SECURITY_STATUS SecStatus;

    //
    // Check for security status and let them through
    //

    if (HRESULT_FACILITY(NtStatus) == FACILITY_SECURITY )
    {
        return (NtStatus);
    }

    switch (NtStatus)
    {
    case STATUS_SUCCESS:
        SecStatus = SEC_E_OK;
        break;

    case STATUS_NO_MEMORY:
    case STATUS_INSUFFICIENT_RESOURCES:
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        break;

    case STATUS_NETLOGON_NOT_STARTED:
    case STATUS_DOMAIN_CONTROLLER_NOT_FOUND:
    case STATUS_NO_LOGON_SERVERS:
    case STATUS_NO_SUCH_DOMAIN:
    case STATUS_BAD_NETWORK_PATH:
    case STATUS_TRUST_FAILURE:
    case STATUS_TRUSTED_RELATIONSHIP_FAILURE:
    case STATUS_NETWORK_UNREACHABLE:

        SecStatus = SEC_E_NO_AUTHENTICATING_AUTHORITY;
        break;

    case STATUS_NO_SUCH_LOGON_SESSION:
        SecStatus = SEC_E_UNKNOWN_CREDENTIALS;
        break;

    case STATUS_INVALID_PARAMETER:
    case STATUS_PARTIAL_COPY:
        SecStatus = SEC_E_INVALID_TOKEN;
        break;

    case STATUS_PRIVILEGE_NOT_HELD:
        SecStatus = SEC_E_NOT_OWNER;
        break;

    case STATUS_INVALID_HANDLE:
        SecStatus = SEC_E_INVALID_HANDLE;
        break;

    case STATUS_BUFFER_TOO_SMALL:
        SecStatus = SEC_E_BUFFER_TOO_SMALL;
        break;

    case STATUS_NOT_SUPPORTED:
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        break;

    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_NO_TRUST_SAM_ACCOUNT:
        SecStatus = SEC_E_TARGET_UNKNOWN;
        break;

    // See bug 529185.
    case STATUS_DOMAIN_TRUST_INCONSISTENT:
    // See bug 75803 .
    case STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT:
    case STATUS_NOLOGON_SERVER_TRUST_ACCOUNT:
    case STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT:
    case STATUS_TRUSTED_DOMAIN_FAILURE:
    // See bug 527564
    case STATUS_AUTHENTICATION_FIREWALL_FAILED:
        SecStatus = NtStatus;
        break;

    case STATUS_LOGON_FAILURE:
    case STATUS_NO_SUCH_USER:
    case STATUS_ACCOUNT_DISABLED:
    case STATUS_ACCOUNT_RESTRICTION:
    case STATUS_ACCOUNT_LOCKED_OUT:
    case STATUS_WRONG_PASSWORD:
    case STATUS_ACCOUNT_EXPIRED:
    case STATUS_PASSWORD_EXPIRED:
    case STATUS_PASSWORD_MUST_CHANGE:
    case STATUS_LOGON_TYPE_NOT_GRANTED:
    case STATUS_USER2USER_REQUIRED:
        SecStatus = SEC_E_LOGON_DENIED;
        break;

    case STATUS_NAME_TOO_LONG:
    case STATUS_ILL_FORMED_PASSWORD:

        SecStatus = SEC_E_INVALID_TOKEN;
        break;

    case STATUS_TIME_DIFFERENCE_AT_DC:
        SecStatus = SEC_E_TIME_SKEW;
        break;

    case STATUS_SHUTDOWN_IN_PROGRESS:
        SecStatus = SEC_E_SHUTDOWN_IN_PROGRESS;
        break;

    case STATUS_DOWNGRADE_DETECTED:
        SecStatus = SEC_E_DOWNGRADE_DETECTED;
        break;

    case STATUS_INTERNAL_ERROR:
        SecStatus = SEC_E_INTERNAL_ERROR;
        ASSERT(FALSE);
        break;

    default:

        if ( DefaultStatus != 0 ) {
            SecStatus = DefaultStatus;
        } else {
            DebugLog((DEB_ERROR, "SECUR32: Unable to map error code 0x%x, returning SEC_E_INTERNAL_ERROR\n",NtStatus));
            SecStatus = SEC_E_INTERNAL_ERROR;
            ASSERT(FALSE);
        }
        break;
    }

    return(SecStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\dll\tcache.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       tcache.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-19-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define SECURITY_WIN32
#include <security.h>

UCHAR Buffer[ 1024 ];

NTSTATUS
SecCacheSspiPackages(
    VOID
    );

void _CRTAPI1 main (int argc, char *argv[])
{
    Buffer[0] = 0 ;

    SecCacheSspiPackages();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\dll\userstub.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        userstub.cxx
//
// Contents:    stubs for user-mode security APIs
//
//
// History:     3-7-94      MikeSw      Created
//
//------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop
extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
}


//+-------------------------------------------------------------------------
//
//  Function:   DeleteUsermodeContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
DeleteUserModeContext(
    PCtxtHandle                 phContext           // Contxt to delete
    )
{
    PDLL_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRet;

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        return(SEC_E_INVALID_HANDLE);
    }

    if (pPackage->pftUTable != NULL)
    {

        scRet = pPackage->pftUTable->DeleteUserModeContext(
                                phContext->dwUpper);

    }
    else
    {
        scRet = SEC_E_OK;
    }
    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   FormatCredentials
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
FormatCredentials(
    LPWSTR          pszPackageName,
    ULONG           cbCredentials,
    PUCHAR          pbCredentials,
    PULONG          pcbFormattedCreds,
    PUCHAR *        pbFormattedCreds)
{
    PDLL_SECURITY_PACKAGE pPackage;
    HRESULT scRet;
    SecBuffer InputCredentials;
    SecBuffer OutputCredentials;

    InputCredentials.pvBuffer = pbCredentials;
    InputCredentials.cbBuffer = cbCredentials;
    InputCredentials.BufferType = 0;



    if (FAILED(IsOkayToExec(NULL)))
    {
        return(SEC_E_INTERNAL_ERROR);
    }

    pPackage = SecLocatePackageW( pszPackageName );
    if (!pPackage)
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }



    scRet = pPackage->pftUTable->FormatCredentials(
                &InputCredentials,
                &OutputCredentials);

    if (NT_SUCCESS(scRet))
    {
        *pcbFormattedCreds = OutputCredentials.cbBuffer;
        *pbFormattedCreds = (PBYTE) OutputCredentials.pvBuffer;
    }


    return(scRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\dll\txlate.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       txlate.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6-17-97   RichardW   Created
//
//----------------------------------------------------------------------------


#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>

#include <windows.h>
#include <rpc.h>
#include <lm.h>
#include <ntdsapi.h>

#define SECURITY_WIN32
#include <security.h>

CHAR ReturnBuffer[ MAX_PATH ];
ULONG BufferSize ;

VOID
TranslateLoop(
    PSTR Name
    )
{
    EXTENDED_NAME_FORMAT DesiredFormat ;

    for ( DesiredFormat = NameFullyQualifiedDN ;
          DesiredFormat < NameServicePrincipal + 1 ;
          DesiredFormat ++ )
    {
        BufferSize = MAX_PATH ;

        if ( TranslateName( Name, NameUnknown, DesiredFormat,
                            ReturnBuffer, & BufferSize ) )
        {
            printf("%d:  %s\n", DesiredFormat, ReturnBuffer );
        }
        else
        {
            printf("%d: failed, %d\n", DesiredFormat, GetLastError() );
        }
    }
}

BOOL
ImpersonatePid(
    char * szPid
    )
{
    HANDLE hProcess ;
    HANDLE hToken ;
    DWORD pid ;
    SECURITY_IMPERSONATION_LEVEL Level ;
    PSTR PidString ;
    PSTR LevelString ;
    HANDLE DupToken ;

    PidString = szPid ;

    LevelString = strchr( szPid, '.' );

    if ( LevelString )
    {
        *LevelString++ = '\0';
        Level = atoi( LevelString );
    }
    else 
    {
        Level = SecurityImpersonation ;
    }
    pid = atoi( PidString );

    hProcess = OpenProcess( PROCESS_QUERY_INFORMATION,
                            FALSE,
                            pid );

    if ( hProcess )
    {
        if ( !OpenProcessToken( hProcess,
                                TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
                                &hToken ) )
        {
            printf("FAILED to open process token, %d\n", GetLastError() );
            return FALSE ;
        }

        if ( !DuplicateTokenEx( hToken,
                                TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
                                NULL,
                                Level,
                                TokenImpersonation,
                                &DupToken ) )
        {
            printf("FAILED to dup token, %d\n", GetLastError());
            return FALSE ;

        }

        if ( !ImpersonateLoggedOnUser( DupToken ) )
        {

            printf("FAILED to impersonate, %d\n", GetLastError() );
            return FALSE ;
        }

        return TRUE ;
    }
    else
    {
        printf("FAILED to open process %d, %d\n", pid, GetLastError() );
        return FALSE ;
    }

}

VOID
GetUserLoop(
    VOID
    )
{
    EXTENDED_NAME_FORMAT DesiredFormat ;

    for ( DesiredFormat = NameFullyQualifiedDN ;
          DesiredFormat < NameServicePrincipal + 1 ;
          DesiredFormat ++ )
    {
        BufferSize = MAX_PATH ;

        if ( GetUserNameEx( DesiredFormat,
                            ReturnBuffer, & BufferSize ) )
        {
            printf("%d:  %s\n", DesiredFormat, ReturnBuffer );
        }
        else
        {
            printf("%d: failed, %d\n", DesiredFormat, GetLastError() );
        }
    }

}

VOID
GetComputerLoop(
    VOID
    )
{
    EXTENDED_NAME_FORMAT DesiredFormat ;

    for ( DesiredFormat = NameFullyQualifiedDN ;
          DesiredFormat < NameServicePrincipal + 1 ;
          DesiredFormat ++ )
    {
        BufferSize = MAX_PATH ;

        if ( GetComputerObjectName( DesiredFormat,
                            ReturnBuffer, & BufferSize ) )
        {
            printf("%d:  %s\n", DesiredFormat, ReturnBuffer );
        }
        else
        {
            printf("%d: failed, %d\n", DesiredFormat, GetLastError() );
        }
    }

}

void __cdecl main (int argc, char *argv[])
{

    if ( argc > 1 )
    {
        if ( *argv[1] == '-' )
        {
            if ( *(argv[1]+1) == 'p')
            {
                if ( ImpersonatePid( argv[2] ) )
                {
                    GetUserLoop();
                }
            }
            else if ( *(argv[1]+1) == 'c')
            {
                GetComputerLoop();
            }
            else if ( *(argv[1]+1) == '$' )
            {

                //
                // Hopefully never hit.  This is to allow the sources file
                // to specify delay load for netapi32 and ntdsapi
                //
                PUCHAR ptr ;
                HANDLE h;

                NetUserModalsGet(NULL, 0, &ptr );
                DsBind(NULL, NULL, &h );
            }
        }
        else
        {
            TranslateLoop( argv[1] );
        }
    }
    else
    {
        GetUserLoop();
    }

    return ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\driver\connmgr.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        connmgr.c
//
// Contents:    Connection Manager code for KSecDD
//
//
// History:     3 Jun 92    RichardW    Created
//
//------------------------------------------------------------------------

#include "secpch2.hxx"
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include <zwapi.h>

#include "ksecdd.h"
#include "connmgr.h"

FAST_MUTEX  KsecConnectionMutex ;

BOOLEAN             fInitialized = 0;
PSTR                LogonProcessString = "KSecDD";
ULONG               KsecConnected = 0;

BOOLEAN
InitConnMgr(void);

SECURITY_STATUS
OpenSyncEvent(  HANDLE  *   phEvent);

} // extern "C"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, InitConnMgr)
#endif

//+-------------------------------------------------------------------------
//
//  Function:   InitConnMgr
//
//  Synopsis:   Initializes all this stuff
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
BOOLEAN
InitConnMgr(void)
{
    ExInitializeFastMutex( &KsecConnectionMutex );
    
    fInitialized = TRUE;

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Function:   OpenSyncEvent()
//
//  Synopsis:   Opens the sync event in the context of the calling FSP
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS
OpenSyncEvent(  HANDLE  *   phEvent)
{
    OBJECT_ATTRIBUTES   EventObjAttr;
    UNICODE_STRING EventName;

    PAGED_CODE();

    RtlInitUnicodeString(
        &EventName,
        SPM_EVENTNAME);

    InitializeObjectAttributes(
        &EventObjAttr, 
        &EventName,
        OBJ_CASE_INSENSITIVE, 
        NULL, 
        NULL);

    return(ZwOpenEvent(phEvent, EVENT_ALL_ACCESS, &EventObjAttr));
}


//+-------------------------------------------------------------------------
//
//  Function:   CreateClient
//
//  Synopsis:   Creates a client representing this caller.  Establishes
//              a connection with the SPM.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
CreateClient(
    BOOLEAN     ConnectAsKsec
    )
{
    NTSTATUS    scRet;
    KIRQL       OldIrql;
    HANDLE      hEvent;
    LSA_OPERATIONAL_MODE LsaMode;
    STRING      LogonProcessName;
    ULONG   PackageCount;
    HANDLE hIgnored ;

    if ( PsGetProcessId( PsGetCurrentProcess() ) !=
         PsGetThreadProcessId( PsGetCurrentThread() ) )
    {
        return STATUS_ACCESS_DENIED ;
    }

    if ( PsGetProcessSecurityPort( PsGetCurrentProcess() ) == ((PVOID) 1) )
    {
        return STATUS_PROCESS_IS_TERMINATING ;
    }

    scRet = OpenSyncEvent(&hEvent);

    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR,"KSec:  Failed to open event, %x\n", scRet));
        scRet = SEC_E_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // Okay, now wait to make sure the LSA has started:
    //

    scRet = NtWaitForSingleObject(hEvent, TRUE, NULL);

    (void) NtClose(hEvent);

    if (!NT_SUCCESS(scRet))
    {
        scRet = SEC_E_INTERNAL_ERROR;

        goto Cleanup;
    }

    scRet = CreateConnection( (ConnectAsKsec ? LogonProcessString : NULL),
                              LSAP_AU_KERNEL_CLIENT,
                              &hIgnored,
                              &PackageCount,
                              &LsaMode );

    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR,"KSec: Connection failed, postponing\n"));
        scRet = SEC_E_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // This is atomic, and the queries are always safe, anyway.
    //

    KsecConnected = 1;

    InitializePackages( PackageCount );

    return(STATUS_SUCCESS);

Cleanup:

    return(scRet);
}

//+-------------------------------------------------------------------------
//
//  Function:   LocateClient
//
//  Synopsis:   Locates a client record based on current process Id
//
//  Effects:    Grabs ConnectSpinLock for duration of search.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
LocateClient()
{
    PEPROCESS pCurrent;
    PVOID Port ;

    ExAcquireFastMutex( &KsecConnectionMutex );

    pCurrent = PsGetCurrentProcess();

    Port = PsGetProcessSecurityPort( pCurrent );

    ExReleaseFastMutex( &KsecConnectionMutex );

    if ( ( Port != NULL ) && 
         ( Port != (PVOID) 1 ) )
    {
        return STATUS_SUCCESS ;
    }
    else 
    {
        return STATUS_OBJECT_NAME_NOT_FOUND ;
    }
}

VOID
FreeClient(
    PClient ignored
    )
{
    return ;
    UNREFERENCED_PARAMETER( ignored );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\driver\context.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       context.cxx
//
//  Contents:   Context List functions
//
//  Classes:
//
//  Functions:
//
//  History:    4-29-98   RichardW   Created
//
//----------------------------------------------------------------------------

#include "secpch2.hxx"
#pragma hdrstop
extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "ksecdd.h"
#include "context.h"

VOID
KSecInsertListEntryPaged(
    PKSEC_CONTEXT_LIST List,
    PKSEC_LIST_ENTRY Entry
    );

NTSTATUS
KSecReferenceListEntryPaged(
    PKSEC_CONTEXT_LIST List,
    PKSEC_LIST_ENTRY Entry,
    ULONG Signature,
    BOOLEAN RemoveNoRef
    );

VOID
KSecDereferenceListEntryPaged(
    PKSEC_CONTEXT_LIST List,
    PKSEC_LIST_ENTRY Entry,
    BOOLEAN * Delete OPTIONAL
    );
}

#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#define ExAllocatePool(a,b) ExAllocatePoolWithTag( a, b, CONTEXT_TAG )
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag( a, b, CONTEXT_TAG )
#endif

#if DBG
#define KsecDebugValidateList( List, Entry )   KsecpValidateList( List, Entry )
#else
#define KsecDebugValidateList( List, Entry )
#endif


#pragma alloc_text(PAGEMSG, KSecCreateContextList)
#pragma alloc_text(PAGEMSG, KSecInsertListEntry)
#pragma alloc_text(PAGEMSG, KSecReferenceListEntry)
#pragma alloc_text(PAGEMSG, KSecDereferenceListEntry)

#pragma alloc_text(PAGE, KSecInsertListEntryPaged)
#pragma alloc_text(PAGE, KSecReferenceListEntryPaged)
#pragma alloc_text(PAGE, KSecDereferenceListEntryPaged)


//+---------------------------------------------------------------------------
//
//  Function:   KSecCreateContextList
//
//  Synopsis:   Creates a context list to be managed by the core ksec driver
//              on behalf of the packages.
//
//  Arguments:  [Type] -- indicates either paged or nonpaged
//
//  History:    7-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
SEC_ENTRY
KSecCreateContextList(
    KSEC_CONTEXT_TYPE Type
    )
{
    PKSEC_CONTEXT_LIST ContextList ;

    ContextList = (PKSEC_CONTEXT_LIST) ExAllocatePool( NonPagedPool, sizeof( KSEC_CONTEXT_LIST ) );

    if ( ContextList )
    {
        ContextList->Type = Type ;

        InitializeListHead( &ContextList->List );

        ContextList->Count = 0 ;

        if ( Type == KSecPaged )
        {
            ExInitializeResourceLite( &ContextList->Lock.Paged );
        }
        else
        {
            KeInitializeSpinLock( &ContextList->Lock.NonPaged );
        }

    }

    return ContextList ;
}
//+---------------------------------------------------------------------------
//
//  Function:   KsecpValidateList
//
//  Synopsis:   Debug function to validate a list
//
//  Arguments:  [List]  --
//              [Entry] --
//
//  History:    7-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#if DBG
VOID
KsecpValidateList(
    PKSEC_CONTEXT_LIST List,
    PKSEC_LIST_ENTRY Entry
    )
{
    ULONG Entries = 0;
    PLIST_ENTRY ListEntry;
    BOOLEAN FoundEntry ;

    if ( Entry )
    {
        FoundEntry = FALSE ;
        if ( List != (PKSEC_CONTEXT_LIST) Entry->OwningList )
        {
            DbgPrint( "KSEC: Supplied context and list do not match\n" );
            DbgBreakPoint();

        }
    }
    else
    {
        FoundEntry = TRUE ;
    }

    for (ListEntry = List->List.Flink ;
         ListEntry != &List->List ;
         ListEntry = ListEntry->Flink )
    {
        if ( ++Entries > List->Count ) {
            DbgPrint( "KSEC: Context List corrupt\n ");
            DbgBreakPoint();
            break;
        }
        if ( Entry == CONTAINING_RECORD( ListEntry, KSEC_LIST_ENTRY, List ) )
        {
            FoundEntry = TRUE ;
        }
    }

    if ( !FoundEntry )
    {
        DbgPrint( "KSEC: Context List did not contain expected entry %x\n", Entry );
        DbgBreakPoint();
    }

}

#endif

//+---------------------------------------------------------------------------
//
//  Function:   KSecInsertListEntryPaged
//
//  Synopsis:   paged (passive level) function for inserting into the context
//              list
//
//  Arguments:  [List]  -- List returned in KSecCreateContextList
//              [Entry] -- Entry to insert
//
//  History:    7-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
KSecInsertListEntryPaged(
    PKSEC_CONTEXT_LIST List,
    PKSEC_LIST_ENTRY Entry
    )
{
    PAGED_CODE();

    ASSERT( List->Type == KSecPaged );

    Entry->RefCount++ ;
    Entry->OwningList = List ;

    //
    // NTBUG 409213: use Enter and LeaveCriticalRegion around resource hold.
    // addresses case where caller hasn't disabled APCs (eg: serrdr).
    //

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite( &List->Lock.Paged, TRUE );


    KsecDebugValidateList( List, NULL );

    InsertHeadList( &List->List, &Entry->List );
    List->Count++ ;

    KsecDebugValidateList( List, Entry );

    ExReleaseResourceLite( &List->Lock.Paged );
    KeLeaveCriticalRegion();
}

//+---------------------------------------------------------------------------
//
//  Function:   KSecInsertListEntry
//
//  Synopsis:   non paged (DPC level) function for inserting into the list
//
//  Arguments:  [hList] -- List to insert into
//              [Entry] -- Entry to insert
//
//  History:    7-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SEC_ENTRY
KSecInsertListEntry(
    PVOID hList,
    PKSEC_LIST_ENTRY Entry
    )
{
    KIRQL OldIrql ;
    PKSEC_CONTEXT_LIST List = (PKSEC_CONTEXT_LIST) hList ;

    if ( List->Type == KSecPaged )
    {
        KSecInsertListEntryPaged( List, Entry );
        return ;
    }

    ASSERT( List->Type == KSecNonPaged );

    Entry->RefCount++ ;
    Entry->OwningList = List ;

    KeAcquireSpinLock( &List->Lock.NonPaged, &OldIrql );

    KsecDebugValidateList( List, NULL );

    InsertHeadList( &List->List, &Entry->List );
    List->Count++ ;

    KsecDebugValidateList( List, Entry );

    KeReleaseSpinLock( &List->Lock.NonPaged, OldIrql );

}


//+---------------------------------------------------------------------------
//
//  Function:   KSecReferenceListEntryPaged
//
//  Synopsis:   paged (passive level) function to reference a list entry
//
//  Arguments:  [List]        -- List that the context belongs to
//              [Entry]       -- Context entry to reference
//              [Signature]   -- Signature to check
//              [RemoveNoRef] -- If true, removes the entry from the list
//                               without referencing it.
//
//  History:    7-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
KSecReferenceListEntryPaged(
    PKSEC_CONTEXT_LIST List,
    PKSEC_LIST_ENTRY Entry,
    IN ULONG Signature,
    IN BOOLEAN RemoveNoRef
    )
{
    PAGED_CODE();

    ASSERT( List->Type == KSecPaged );

    if ( ((PUCHAR) Entry) < ((PUCHAR) MM_USER_PROBE_ADDRESS) )
    {
        return STATUS_INVALID_HANDLE ;
    }

    if ( Entry->Signature != Signature )
    {
#if DBG
        DbgPrint( "KSEC: Signature trashed (%x != expected %x)\n",
                        Entry->Signature, Signature );
#endif
        return STATUS_INVALID_HANDLE ;
    }

    KeEnterCriticalRegion();
    if( RemoveNoRef )
    {
        ExAcquireResourceExclusiveLite( &List->Lock.Paged, TRUE );
    } else {
        ExAcquireResourceSharedLite( &List->Lock.Paged, TRUE );
    }

    if ( Entry->Signature != Signature )
    {
        ExReleaseResourceLite( &List->Lock.Paged );
        KeLeaveCriticalRegion();
#if DBG
        DbgPrint( "KSEC: Signature trashed, probably multi-free race condition (%x != expected %x)\n",
                        Entry->Signature, Signature );
#endif
        return STATUS_INVALID_HANDLE ;
    }

    KsecDebugValidateList( List, Entry );

    if ( !RemoveNoRef )
    {
        InterlockedIncrement( &Entry->RefCount ) ;
    }
    else
    {
        RemoveEntryList( &Entry->List );

        List->Count-- ;

#if DBG
        if ( List->Count == 0 )
        {
            if ( !IsListEmpty( &List->List ) )
            {
                DbgPrint( "KSEC:  Context List corrupted\n" );
                DbgBreakPoint();
            }
        }
#endif

        Entry->List.Flink = Entry->List.Blink = NULL ;
        Entry->Signature &= 0x00FFFFFF ;
        Entry->Signature |= 0x78000000 ;        // Convert signature to a little 'x'

    }

    if ( RemoveNoRef )
    {
        KsecDebugValidateList( List, NULL );
    }
    else
    {
        KsecDebugValidateList( List, Entry );
    }

    ExReleaseResourceLite( &List->Lock.Paged );
    KeLeaveCriticalRegion();

    return STATUS_SUCCESS ;
}

//+---------------------------------------------------------------------------
//
//  Function:   KSecReferenceListEntry
//
//  Synopsis:   non paged (DPC level) function to dereference an entry
//
//  Arguments:  [Entry]       -- Entry to dereference
//              [Signature]   -- Signature to check for
//              [RemoveNoRef] -- Remove flag
//
//  History:    7-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
KSecReferenceListEntry(
    IN PKSEC_LIST_ENTRY Entry,
    IN ULONG Signature,
    IN BOOLEAN RemoveNoRef
    )
{
    KIRQL OldIrql ;


    PKSEC_CONTEXT_LIST List ;

    //
    // may still be in user mode (not mapped yet)
    //

    if ( (ULONG_PTR) Entry < (ULONG_PTR) (MM_USER_PROBE_ADDRESS) )
    {
        return STATUS_INVALID_HANDLE ;
    }

    List = (PKSEC_CONTEXT_LIST) Entry->OwningList ;

    if ( List->Type == KSecPaged )
    {
        return KSecReferenceListEntryPaged( List, Entry, Signature, RemoveNoRef );
    }

    ASSERT( List->Type == KSecNonPaged );

    if ( ((PUCHAR) Entry) < ((PUCHAR) MM_USER_PROBE_ADDRESS) )
    {
        return STATUS_INVALID_HANDLE ;
    }

    if ( Entry->Signature != Signature )
    {
#if DBG
        DbgPrint( "KSEC: Signature trashed (%x != expected %x)\n",
                        Entry->Signature, Signature );
#endif
        return STATUS_INVALID_HANDLE ;
    }

    KeAcquireSpinLock( &List->Lock.NonPaged, &OldIrql );

    KsecDebugValidateList( List, Entry );

    if ( !RemoveNoRef )
    {
        InterlockedIncrement( &Entry->RefCount ) ;
    }
    else
    {
        RemoveEntryList( &Entry->List );

        Entry->List.Flink = Entry->List.Blink = NULL ;
        Entry->Signature &= 0x00FFFFFF ;
        Entry->Signature |= 0x78000000 ;        // Convert signature to a big X
    }

    if ( RemoveNoRef )
    {
        KsecDebugValidateList( List, NULL );
    }
    else
    {
        KsecDebugValidateList( List, Entry );
    }

    KeReleaseSpinLock( &List->Lock.NonPaged, OldIrql );

    return STATUS_SUCCESS ;
}

//+---------------------------------------------------------------------------
//
//  Function:   KSecDereferenceListEntryPaged
//
//  Synopsis:   paged (passive level) function to dereference an entry
//
//  Arguments:  [List]   -- List for the entry
//              [Entry]  -- Entry
//              [Delete] -- Set to true if the entry should be deleted
//
//  History:    7-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
KSecDereferenceListEntryPaged(
    IN PKSEC_CONTEXT_LIST List,
    IN PKSEC_LIST_ENTRY Entry,
    OUT BOOLEAN * Delete OPTIONAL
    )
{
    BOOLEAN ShouldDelete = FALSE ;
    LONG RefCount;

    PAGED_CODE();

    ASSERT( List->Type == KSecPaged );

#if DBG
    KeEnterCriticalRegion();
    ExAcquireResourceSharedLite( &List->Lock.Paged, TRUE );

    if ( Entry->List.Flink )
    {
        KsecDebugValidateList( List, Entry );
    }
    else
    {
        KsecDebugValidateList( List, NULL );
    }
#endif

    RefCount = InterlockedDecrement( &Entry->RefCount );

    if ( RefCount == 0 )
    {
        ShouldDelete = TRUE ;
    }

#if DBG
    if ( Entry->List.Flink )
    {
        KsecDebugValidateList( List, Entry );
    }
    else
    {
        KsecDebugValidateList( List, NULL );
    }

    ExReleaseResourceLite( &List->Lock.Paged );
    KeLeaveCriticalRegion();

#endif

    if ( Delete )
    {
        *Delete = ShouldDelete ;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   KSecDereferenceListEntry
//
//  Synopsis:   non-paged (DPC level) function to dereference a list entry
//
//  Arguments:  [Entry]  -- Entry to dereference
//              [Delete] -- Returned flag if entry should be deleted
//
//  History:    7-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
KSecDereferenceListEntry(
    IN PKSEC_LIST_ENTRY Entry,
    OUT BOOLEAN * Delete OPTIONAL
    )
{
    KIRQL OldIrql ;
    BOOLEAN ShouldDelete = FALSE ;
    PKSEC_CONTEXT_LIST List;
    LONG RefCount;

    List = (PKSEC_CONTEXT_LIST) Entry->OwningList ;

    if ( List->Type == KSecPaged )
    {
        KSecDereferenceListEntryPaged( List, Entry, Delete );
        return ;
    }

    ASSERT( List->Type == KSecNonPaged );

#if DBG

    KeAcquireSpinLock( &List->Lock.NonPaged, &OldIrql );

    if ( Entry->List.Flink )
    {
        KsecDebugValidateList( List, Entry );
    }
    else
    {
        KsecDebugValidateList( List, NULL );
    }
#endif

    RefCount = InterlockedDecrement( &Entry->RefCount );

    if ( RefCount == 0 )
    {
        ShouldDelete = TRUE ;
    }

#if DBG
    if ( Entry->List.Flink )
    {
        KsecDebugValidateList( List, Entry );
    }
    else
    {
        KsecDebugValidateList( List, NULL );
    }

    KeReleaseSpinLock( &List->Lock.NonPaged, OldIrql );

#endif

    if ( Delete )
    {
        *Delete = ShouldDelete ;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\driver\connmgr.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        connmgr.h
//
// Contents:    Connection Manager code for KSecDD
//
//
// History:     3 Jun 92    RichardW    Created
//
//------------------------------------------------------------------------

#ifndef __CONNMGR_H__
#define __CONNMGR_H__

BOOLEAN         InitConnMgr(void);
NTSTATUS        CreateClient(BOOLEAN ConnectAsKsec);
NTSTATUS        LocateClient();

extern  ULONG   KsecConnected ;
extern  KSPIN_LOCK ConnectSpinLock ;

#endif // __CONNMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\dll\xlate.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       xlate.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-02-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"

#include <ntdsapi.h>
#include <lm.h>
#include <dsgetdc.h>
#include <dsgetdcp.h>

}
#if DBG
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif


typedef LONG (WINAPI * I_RPCMAPWIN32STATUS)(
    IN ULONG Win32Status
    );


NTSTATUS DsNameErrorMap[] = {   STATUS_SUCCESS,
                                STATUS_NO_SUCH_USER,
                                STATUS_NO_SUCH_USER,
                                STATUS_NONE_MAPPED,
                                STATUS_NONE_MAPPED,
                                STATUS_SOME_NOT_MAPPED,
                                STATUS_SOME_NOT_MAPPED
                            };

#define SecpMapDsNameError( x )    ((x < sizeof( DsNameErrorMap ) / sizeof( NTSTATUS ) ) ? \
                                     DsNameErrorMap[ x ] : STATUS_UNSUCCESSFUL )

#define SecpSetLastNTError( x ) SetLastError( RtlNtStatusToDosError( x ) )


/* The following function construct a SPN with the "@domainName"
   suffix.  The suffix serves as a hint for kerberos.  
*/

DWORD 
ConstructSPN( WCHAR * DomainControllerName,
              WCHAR * DnsDomainName, 
              WCHAR ** ppwszSpn )
{

    DWORD               dwErr, cChar, totalChar;
    LPCWSTR             pwszService, pwszInstance;
    WCHAR               *pwszTmpService = NULL;
    WCHAR               *pwszTmpInstance = NULL;
    WCHAR               *svcClass = L"LDAP";
    WCHAR               *pwszSpn = NULL;
    
    if (!DomainControllerName) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto bye;
    }
    
    if ( DnsDomainName )
    {
        // Caller gave all components needed to construct full 3-part SPN.
        pwszInstance = DomainControllerName;
        pwszService = DnsDomainName;
    }
    else 
    {
        // Construct SPN of form: LDAP/ntdsdc4.ntdev.microsoft.com
        pwszInstance = DomainControllerName;
        pwszService = DomainControllerName;
    }

    
    // Skip past leading "\\" if present.  This is not circumventing
    // a client who has passed NetBIOS names mistakenly but rather
    // helping the client which has passed args as returned by
    // DsGetDcName which prepends "\\" even when DS_RETURN_DNS_NAME
    // was requested.

    if (0 == wcsncmp(pwszInstance, L"\\\\", 2)) pwszInstance += 2;
    if (0 == wcsncmp(pwszService, L"\\\\", 2)) pwszService += 2;

    // Strip trailing '.' if it exists.  We do this as we know
    // the server side registers dot-less names only.  We can't whack
    // in place as the input args are const.

    cChar = wcslen(pwszInstance);
    if ( L'.' == pwszInstance[cChar - 1] )
    {
        pwszTmpInstance = (WCHAR *) LocalAlloc(LPTR, cChar * sizeof(WCHAR));
        if (!pwszTmpInstance) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto bye;
        }
        memcpy(pwszTmpInstance, pwszInstance, cChar * sizeof(WCHAR));
        pwszTmpInstance[cChar - 1] = L'\0';
        pwszInstance = (LPCWSTR) pwszTmpInstance;
    }

    cChar = wcslen(pwszService);
    if ( L'.' == pwszService[cChar - 1] )
    {
        pwszTmpService = (WCHAR *) LocalAlloc(LPTR, cChar * sizeof(WCHAR));
        if (!pwszTmpService) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto bye;
        }
        memcpy(pwszTmpService, pwszService, cChar * sizeof(WCHAR));
        pwszTmpService[cChar - 1] = L'\0';
        pwszService = (LPCWSTR) pwszTmpService;
    }


    cChar = 0;

    dwErr = DsMakeSpnW(svcClass, pwszService, pwszInstance, 0,
                       NULL, &cChar, NULL);

    if ( dwErr && (ERROR_BUFFER_OVERFLOW != dwErr) )
    {
        goto bye;
    }

    if (DnsDomainName) 
    {
        totalChar = cChar + wcslen(pwszService) + 1;
    }
    else
    {
        totalChar = cChar; 
    }

    if ( !(pwszSpn = (WCHAR *) LocalAlloc(LPTR, sizeof(WCHAR) * totalChar)) )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto bye;
    }

    dwErr = DsMakeSpnW(svcClass, pwszService, pwszInstance, 0,
                       NULL, &cChar, pwszSpn);
    if (dwErr) {
        goto bye;
    }

          
    if (DnsDomainName && (cChar < totalChar))
    {
        wcsncat(pwszSpn,L"@",totalChar-cChar);
        wcsncat(pwszSpn,pwszService, totalChar-cChar-1); 
    }


bye:

    if (pwszTmpInstance) {
        LocalFree(pwszTmpInstance);
    }

    if (pwszTmpService) {
        LocalFree(pwszTmpService);
    }

    if (dwErr) {
        if (pwszSpn)
        {
            LocalFree(pwszSpn);
        }
        *ppwszSpn = NULL;
    }
    else {
        *ppwszSpn = pwszSpn;
    }

    return(dwErr);

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpTranslateName
//
//  Synopsis:   Private helper to do the translation
//
//  Arguments:  [Domain]             --
//              [Name]               --
//              [Supplied]           --
//              [Desired]            --
//              [TranslatedName]     --
//              [TranslatedNameSize] --
//
//  History:    1-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
WINAPI
SecpTranslateName(
    PWSTR Domain,
    LPCWSTR Name,
    EXTENDED_NAME_FORMAT Supplied,
    EXTENDED_NAME_FORMAT Desired,
    PWSTR TranslatedName,
    PULONG TranslatedNameSize
    )
{
    DWORD NetStatus ;
    PDOMAIN_CONTROLLER_INFOW DcInfo = NULL ;
    HANDLE DcHandle ;
    ULONG RetryLimit ;
    PDS_NAME_RESULTW Results ;
    NTSTATUS Status = STATUS_CANT_ACCESS_DOMAIN_INFO ;
    ULONG LengthRequired ;
    BOOL bRet = FALSE ;
    BOOL UseNetStatus = TRUE ;
    BOOL fForcedLocal = FALSE ;
    PWSTR lpDcName, pwszSPN = NULL, pwszDomainDnsName;
    NT_PRODUCT_TYPE pt;
    PWSTR Scan, DomainName = NULL;

    I_RPCMAPWIN32STATUS pI_RpcMapWin32Status ;

    //
    // Note:  Status is initialized to can't access domain info because if there
    // is a series of network problems after finding a DC, we bail out of the loop
    // after some retries, and Status would be uninitialized.
    //

    pI_RpcMapWin32Status = (I_RPCMAPWIN32STATUS) GetProcAddress( GetModuleHandle(L"rpcrt4.dll"),
                                                                 "I_RpcMapWin32Status" );

    //
    // Note:  The following implementation uses DsGetDcName rather than
    // DsGetDcNameWithAccount as the latter is rather expensive. However,
    // it is possible that the DC retuned by the former doesn't have the
    // account due to replication latency.  In this case we should retry
    // to discover a DC that has the account by calling DsGetDcNameWithAccount.
    // We should be careful, though, to avoid unjustified use of this expensive
    // API. The current routine is called from 2 places. One is TraslateName
    // which is a public API which anyone can call and pass anything as the
    // account name.  We should avoid with account discoveries for this caller.
    // The other caller is GetComputerObject which passes the machine account
    // name that is guaranteed to be meaningful. For this caller, we should
    // retry DsGetDcNameWithAccount if the DC returned by DsGetDcName doesn't
    // have the machine account as indicated by the name crack failure below
    // (see SecpTranslateNameEx).
    //

    if (    !Domain
         && Supplied == NameSamCompatible  
         && (Scan = wcschr( Name, L'\\' )))
    {
        // when a sam compatible name is passed in, and the domain is not 
        // specified, we should get the domain from the supplied name, and
        // get a DC in that domain.  

        DomainName = (PWSTR) LocalAlloc( LMEM_ZEROINIT, (Scan-Name+1)*sizeof(WCHAR) );
        if ( DomainName )
        {
            wcsncpy( DomainName, Name, Scan-Name );
        }
            
    }

    NetStatus = DsGetDcName( NULL,
                             Domain ? Domain : ( DomainName ? DomainName : L"" ),
                             NULL,
                             NULL,
                             DS_DIRECTORY_SERVICE_REQUIRED |
                             DS_RETURN_DNS_NAME,
                             &DcInfo );


    //
    // Handle the case where this DC was just promoted and we're being called
    // before it's ready to advertise itself on the network as such.
    //

    if ((NetStatus == ERROR_NO_SUCH_DOMAIN)
         &&
        RtlGetNtProductType(&pt)
         &&
        (pt == NtProductLanManNt))
    {
        LSA_HANDLE LsaHandle = NULL;
        LSA_OBJECT_ATTRIBUTES LsaAttributes = {0};
        PPOLICY_DNS_DOMAIN_INFO pDnsInfo = NULL;

        Status = LsaOpenPolicy(
                     NULL,
                     &LsaAttributes,
                     POLICY_VIEW_LOCAL_INFORMATION,
                     &LsaHandle);

        if ( NT_SUCCESS( Status ))
        {
            Status = LsaQueryInformationPolicy(
                         LsaHandle,
                         PolicyDnsDomainInformation,
                         (PVOID *) &pDnsInfo);

            if ( NT_SUCCESS( Status ))
            {
                UNICODE_STRING DomainString;

                RtlInitUnicodeString(&DomainString, Domain);

                if (RtlEqualUnicodeString(&pDnsInfo->Name, &DomainString, TRUE)
                     ||
                    RtlEqualUnicodeString(&pDnsInfo->DnsDomainName, &DomainString, TRUE))
                {
                    //
                    // This machine is a non-advertising DC that
                    // can service the request.  Tweak things so
                    // we can try the bind below.
                    //

                    fForcedLocal = TRUE;
                    NetStatus    = NERR_Success;
                }

                LsaFreeMemory(pDnsInfo);
            }

            LsaClose( LsaHandle );
        }
    }

    if ( NetStatus != NERR_Success )
    {
        //
        // No DS DC available, therefore no name translation:
        //

        SecpSetLastNTError( STATUS_UNSUCCESSFUL );

        SetLastError( NetStatus );

#if DBG
        // FarzanaR special
        //
        //

        if ( NetStatus == ERROR_NO_SUCH_DOMAIN )
        {
            SYSTEMTIME Time ;

            GetLocalTime( &Time );

            DebugLog(( DEB_ERROR, "Failed to find any DC for domain %ws\n",
                       Domain ));

            DebugLog(( DEB_ERROR, "Time:  %02d:%02d:%02d, %d/%d\n",
                       Time.wHour, Time.wMinute, Time.wSecond,
                       Time.wMonth, Time.wDay ));


        }
#endif
               
        if ( DomainName )
        {
           LocalFree( DomainName );
           DomainName = NULL;
        }
        
        return FALSE ;
    }

    //
    // Okay, we have a DC that has a DS running on it.  Try to translate
    // the name:
    //

    if (fForcedLocal)
    {
        //
        // Don't retry with forced rediscovery if the bind fails since
        // we already know we won't find a DC even if we do that.
        //

        RetryLimit = 1;
        lpDcName   = L"Localhost";
        pwszDomainDnsName = NULL;
    }
    else
    {
        RetryLimit = 2;
        lpDcName   = DcInfo->DomainControllerName;
        pwszDomainDnsName = DcInfo->DomainName? DcInfo->DomainName : (Domain ? Domain : DomainName);
    }

    while ( RetryLimit-- )
    {
        DebugLog((DEB_TRACE_GETUSER, "Trying to bind to %ws\n", lpDcName));

        while ( *lpDcName == L'\\' )
        {
            lpDcName ++ ;
        }
        
        // pswzSPN is NULL on error, so don't care the return value.
        ConstructSPN(lpDcName,
                     pwszDomainDnsName,
                     &pwszSPN );


        NetStatus = DsBindWithSpnEx( lpDcName,  // DC name
                                     pwszDomainDnsName,    // domain name
                                     NULL,      // creds
                                     pwszSPN,   // SPN
                                     0,         // No delegation
                                     &DcHandle );

        if (pwszSPN) {
            LocalFree(pwszSPN);
            pwszSPN = NULL;
        }


        if ( NetStatus != 0 )
        {
           DebugLog((DEB_ERROR,
                     "DsBind returned 0x%lx, dc = %ws. %ws, line %d.\n",
                     NetStatus,
                     lpDcName,
                     THIS_FILE,
                     __LINE__));
        }

        //
        // We are done with the DC info, and makes the retry case easier:
        //

        if ( NetStatus != 0 )
        {
            //
            // Error mapping tricks.  Some win32 errors have
            // this format.
            //

            if ( NetStatus <= 0x80000000 )
            {
                Status = NtCurrentTeb()->LastStatusValue ;

                if ( pI_RpcMapWin32Status )
                {
                    Status = pI_RpcMapWin32Status( NetStatus );

                    if ( NT_SUCCESS( Status ) )
                    {
                        //
                        // Didn't map.  Treat as a win32 error
                        //       

                        UseNetStatus = TRUE ;

                        Status = STATUS_UNSUCCESSFUL ;
                    }
                }

            }
            else
            {
                UseNetStatus = TRUE ;

                Status = STATUS_UNSUCCESSFUL ;
            }


            DebugLog(( DEB_ERROR, "DsBind to %ws failed, %x (%d)\n",
                       lpDcName,
                       NetStatus,
                       UseNetStatus ));
        }

        if (!fForcedLocal)
        {
            NetApiBufferFree( DcInfo );
            DcInfo = NULL;
        }

RetryBind:

        if ( NetStatus != 0 )
        {
            if ( RetryLimit == 0 )
            {
                bRet = FALSE ;

                break;
            }

            NetStatus = DsGetDcName( NULL,
                                     Domain ? Domain : ( DomainName ? DomainName : L"" ),
                                     NULL,
                                     NULL,
                                     DS_DIRECTORY_SERVICE_REQUIRED |
                                         DS_RETURN_DNS_NAME |
                                         DS_FORCE_REDISCOVERY,
                                     &DcInfo );

            if ( NetStatus != 0 )
            {
                //
                // No DS DC available, therefore no name translation:
                //

                SecpSetLastNTError( STATUS_UNSUCCESSFUL );


        #if DBG
                // FarzanaR special
                //
                //

                if ( NetStatus == ERROR_NO_SUCH_DOMAIN )
                {
                    SYSTEMTIME Time ;

                    GetLocalTime( &Time );

                    DebugLog(( DEB_ERROR, "Failed to find any DC for domain %ws\n",
                               Domain ));

                    DebugLog(( DEB_ERROR, "Time:  %02d:%02d:%02d, %d/%d\n",
                               Time.wHour, Time.wMinute, Time.wSecond,
                               Time.wMonth, Time.wDay ));


                }
        #endif


                bRet = FALSE ;

                DebugLog((DEB_ERROR, "DsGetDcName returned 0x%lx, flags = 0x%lx. %ws, line %d\n", NetStatus, DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME | DS_FORCE_REDISCOVERY, THIS_FILE, __LINE__));
                break;
            }

            lpDcName = DcInfo->DomainControllerName;
            pwszDomainDnsName = DcInfo->DomainName? DcInfo->DomainName : (Domain ? Domain : DomainName);
            continue;
        }

        //
        // Got a connection.  Crack the name:
        //

        NetStatus = DsCrackNames(DcHandle,
                                 DS_NAME_NO_FLAGS,
                                 (DS_NAME_FORMAT) Supplied,
                                 (DS_NAME_FORMAT) Desired,
                                 1,
                                 &Name,
                                 &Results );

        //
        // Now, see what happened:
        //

        if ( NetStatus == 0 )
        {
            //
            // So far, so good.  See if the name got xlated:
            //

            if ( Results->cItems >= 1 )
            {
                if ( Results->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY )
                {
                    bRet = SecpTranslateName(
                                Results->rItems[0].pDomain,
                                Name,
                                Supplied,
                                Desired,
                                TranslatedName,
                                TranslatedNameSize );

                    UseNetStatus = TRUE ;

                    NetStatus = GetLastError();
                    Status    = NtCurrentTeb()->LastStatusValue ;

                    DebugLog((DEB_ERROR,
                              "SecpTranslateName (recursive) returned %d (0x%lx). %ws, line %d\n",
                              NetStatus,
                              Status,
                              THIS_FILE,
                              __LINE__));
                }
                else
                {

                    Status = SecpMapDsNameError( Results->rItems[0].status );

                    if ( NT_SUCCESS( Status ) )
                    {
                        //
                        // Mapped the name
                        //

                        LengthRequired = wcslen( Results->rItems[0].pName ) + 1;

                        if ( TranslatedName == NULL )
                        {
                            *TranslatedNameSize = LengthRequired ;
                            bRet = TRUE;
                        }
                        else
                        {
                            if ( LengthRequired <= *TranslatedNameSize )
                            {
                                RtlCopyMemory( TranslatedName,
                                               Results->rItems[0].pName,
                                               LengthRequired * sizeof( WCHAR ) );

                                bRet = TRUE ;
                            }
                            else
                            {
                                Status = STATUS_BUFFER_TOO_SMALL ;

                                UseNetStatus = FALSE ;

                                bRet = FALSE ;
                            }

                            *TranslatedNameSize = LengthRequired ;
                        }
                    }
                    else
                    {
                        SecpSetLastNTError( Status );

                        UseNetStatus = FALSE ;

                        bRet = FALSE ;

                        DebugLog((DEB_ERROR,
                                  "SecpMapDsNameError returned 0x%lx. %ws, line %d\n",
                                  Status,
                                  THIS_FILE,
                                  __LINE__));
                    }
                }
            }
            else
            {
                DebugLog((DEB_ERROR, "CrackName did not return useful stuff. %ws, line %d\n", THIS_FILE, __LINE__));
            }

            DsFreeNameResult( Results );

            //
            // We are done with the connection
            //

            (VOID) DsUnBind( &DcHandle );


            //
            // Get out of retry loop
            //

            break;
        }
        else
        {
            //
            // Could have disappeared.  Retry the call (maybe)
            //

            Status = NtCurrentTeb()->LastStatusValue ;

            if ( pI_RpcMapWin32Status )
            {
                Status = pI_RpcMapWin32Status( NetStatus );

                if ( NT_SUCCESS( Status ) )
                {
                    //
                    // Didn't map.  Treat as a win32 error
                    //

                    UseNetStatus = TRUE ;

                    Status = STATUS_UNSUCCESSFUL ;
                }

            }

            DebugLog((DEB_ERROR, "DsCrackNames returned 0x%lx, retry-ing. %ws, line %d\n", NetStatus, THIS_FILE, __LINE__));
            (VOID) DsUnBind( &DcHandle );

            goto RetryBind;
        }

    }

    if ( !bRet )
    {
        DebugLog((DEB_ERROR, "Return from SecpTranslateName 0x%lx. %ws, line %d\n", Status, THIS_FILE, __LINE__));

        if ( UseNetStatus ||
             NT_SUCCESS( Status )  )
        {
            SecpSetLastNTError( STATUS_UNSUCCESSFUL );
            SetLastError( NetStatus );
        }
        else
        {
            SecpSetLastNTError( Status );
        }
    }

   if ( DomainName )
   {
       LocalFree( DomainName );
       DomainName = NULL;
   }

    
    return (bRet != 0);
}


//+---------------------------------------------------------------------------
//
//  Function:   GetFullMachineName
//
//  Synopsis:   Private worker to get the domain\computer$ name
//
//  Arguments:  [Machine] --
//              [Domain]  --
//
//  History:    1-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
GetFullMachineName(
    PUNICODE_STRING Machine,
    PUNICODE_STRING Domain
    )
{
    WCHAR Buffer[ CNLEN + 2 ];
    NTSTATUS Status, IgnoreStatus ;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo;
    BOOL    PrimaryDomainPresent = FALSE;
    ULONG Size ;

    //
    // Set up the Security Quality Of Service
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes to open the Lsa policy object
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0L,
                               (HANDLE)NULL,
                               NULL);
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open the local LSA policy object
    //

    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &LsaHandle
                          );
    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    //
    // Get the primary domain info
    //
    Status = LsaQueryInformationPolicy(LsaHandle,
                                       PolicyDnsDomainInformation,
                                       (PVOID *)&DnsDomainInfo);
    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to query primary domain from Lsa, Status = 0x%lx\n", Status));

        IgnoreStatus = LsaClose(LsaHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        return( Status );
    }

    if ( DnsDomainInfo->Sid == NULL )
    {
        //
        // We're standalone.
        //

        LsaFreeMemory( DnsDomainInfo );

        LsaClose( LsaHandle );

        return STATUS_CANT_ACCESS_DOMAIN_INFO ;
    }

    //
    // Ok, we're part of a domain.  Use the flat name of the domain:
    //

    Domain->Buffer = (PWSTR) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                 DnsDomainInfo->Name.MaximumLength );

    if ( Domain->Buffer )
    {
        Domain->MaximumLength = DnsDomainInfo->Name.MaximumLength ;

        RtlCopyUnicodeString( Domain, &DnsDomainInfo->Name );
    }
    else
    {
        Status = STATUS_NO_MEMORY ;
    }

    LsaFreeMemory( DnsDomainInfo );

    LsaClose( LsaHandle );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    Size = sizeof( Buffer ) / sizeof( WCHAR ) ;

    if ( !GetComputerName( Buffer, &Size ) )
    {
        LocalFree( Domain->Buffer );

        return STATUS_NO_MEMORY ;
    }

    Buffer[ Size ] = TEXT( '$' );
    Buffer[ Size + 1 ] = TEXT('\0');

    if ( !RtlCreateUnicodeString( Machine, Buffer ) )
    {
        LocalFree( Domain->Buffer );

        return STATUS_NO_MEMORY ;
    }

    return STATUS_SUCCESS ;

}

BOOL
SEC_ENTRY
GetUserNameOldW(
    LPWSTR lpNameBuffer,
    LPDWORD nSize
    )
{
    NTSTATUS Status ;
    UNICODE_STRING String ;

    String.MaximumLength = (USHORT)(*nSize * sizeof(WCHAR));
    String.Buffer = lpNameBuffer ;

    Status = SecpGetUserName(
                    (ULONG) NameSamCompatible |
                        SPM_NAME_OPTION_NT4_ONLY,
                    &String );

    if ( NT_SUCCESS( Status ) )
    {
        *nSize = String.Length / sizeof(WCHAR) ;
        lpNameBuffer[ *nSize ] = L'\0';
    }
    else
    {
        if ( Status == STATUS_BUFFER_OVERFLOW )
        {
            *nSize = String.Length / sizeof(WCHAR) + 1;
        }

        SecpSetLastNTError( Status );
    }

    return NT_SUCCESS( Status );

}

//+---------------------------------------------------------------------------
//
//  Function:   GetUserNameExW
//
//  Synopsis:   Public:  Get Current Username in different formats
//
//  Arguments:  [NameFormat]   --
//              [lpNameBuffer] --
//              [nSize]        --
//
//  History:    1-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
SEC_ENTRY
GetUserNameExW (
    EXTENDED_NAME_FORMAT  NameFormat,
    LPWSTR lpNameBuffer,
    LPDWORD nSize
    )
{
    NTSTATUS Status ;
    UNICODE_STRING String ;

    String.MaximumLength = (USHORT)(*nSize * sizeof(WCHAR));
    String.Buffer = lpNameBuffer ;

    Status = SecpGetUserName(
                    NameFormat,
                    &String );

    if ( NT_SUCCESS( Status ) )
    {
        //
        // For reasons unclear, some APIs return the length needed as including
        // the trailing NULL for failure only.  Others return it for both
        // success and failure.  GetUserName() is one such API (unlike, say,
        // GetComputerName).  So, if the flag is set saying "this is old GetUserName
        // calling", adjust the return size appropriately.  Note:  do *not* try
        // to make one or the other APIs behave consistently.  Apps will cache
        // based on this length, and they break if the length isn't correct.
        //

        if ( (DWORD) NameFormat & SPM_NAME_OPTION_NT4_ONLY )
        {
            *nSize = String.Length / sizeof(WCHAR) + 1;

            //
            // Ensure we don't overflow the buffer
            //

            if (String.Length < String.MaximumLength)
            {
                lpNameBuffer[ *nSize - 1 ] = L'\0';
            }
            else
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                SecpSetLastNTError(Status);
            }
        }
        else
        {
            *nSize = String.Length / sizeof(WCHAR) ;

            //
            // Ensure we don't overflow the buffer
            //

            if (String.Length < String.MaximumLength)
            {
                lpNameBuffer[ *nSize ] = L'\0';
            }
            else
            {
                *nSize += 1;
                Status = STATUS_BUFFER_OVERFLOW;
                SecpSetLastNTError(Status);
            }
        }
    }
    else
    {
        if ( Status == STATUS_BUFFER_OVERFLOW )
        {
            *nSize = String.Length / sizeof(WCHAR) + 1;

            //
            // Another GetUserName oddity.  The API, while not spec'd as such,
            // must return ERROR_INSUFFICIENT_BUFFER, otherwise some code, like
            // MPR, breaks.  Translate the status appropriately.
            //
            if ( (DWORD) NameFormat & SPM_NAME_OPTION_NT4_ONLY )
            {
                Status = STATUS_BUFFER_TOO_SMALL ;
            }
        }

        if ( Status != STATUS_UNSUCCESSFUL )
        {
            SecpSetLastNTError( Status );
        }
    }

    return NT_SUCCESS( Status );
}



//+---------------------------------------------------------------------------
//
//  Function:   GetComputerObjectNameW
//
//  Synopsis:   Public:  Get computer name in different formats
//
//  Arguments:  [NameFormat]   --
//              [lpNameBuffer] --
//              [nSize]        --
//
//  History:    1-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
SEC_ENTRY
GetComputerObjectNameW (
    EXTENDED_NAME_FORMAT  NameFormat,
    LPWSTR lpNameBuffer,
    LPDWORD nSize
    )
{
    UNICODE_STRING UserName ;
    UNICODE_STRING DomainName ;
    NTSTATUS Status ;
    BOOL bRet ;
    WCHAR LocalName[ 64 ];
    PWSTR Local ;

    //
    // Get the user name from the LSA
    //

    if ( NameFormat == NameUnknown )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE ;
    }

    Status = GetFullMachineName( &UserName, &DomainName );

    if (!NT_SUCCESS(Status)) {
        SecpSetLastNTError( Status );
        return( FALSE );
    }

    if ( NameFormat != NameSamCompatible )
    {
        //
        // They want something that is not the default sam name.  Find
        // the DC for their domain, and do the lookup there:
        //
        if ( ((UserName.Length + DomainName.Length + 4) / sizeof(WCHAR) )
                    < 64 )
        {
            Local = LocalName ;

            RtlCopyMemory( Local,
                           DomainName.Buffer,
                           DomainName.Length );

            Local += DomainName.Length / sizeof(WCHAR) ;

            *Local++ = L'\\';

            RtlCopyMemory( Local,
                           UserName.Buffer,
                           UserName.Length + 2 );


        }

        bRet = SecpTranslateName( DomainName.Buffer,
                                  LocalName,
                                  NameSamCompatible,
                                  NameFormat,
                                  lpNameBuffer,
                                  nSize );

    }
    else
    {
        if ( ((UserName.Length + DomainName.Length + 4) / sizeof(WCHAR) )
                    <= *nSize )
        {
            RtlCopyMemory( lpNameBuffer,
                           DomainName.Buffer,
                           DomainName.Length );

            lpNameBuffer += DomainName.Length / sizeof(WCHAR) ;

            *lpNameBuffer++ = L'\\';

            RtlCopyMemory( lpNameBuffer,
                           UserName.Buffer,
                           UserName.Length + 2 );

            bRet = TRUE ;

        }
        else
        {

            SecpSetLastNTError( STATUS_BUFFER_TOO_SMALL );

            bRet = FALSE ;
        }

        *nSize = (UserName.Length + DomainName.Length + 4) / sizeof(WCHAR) ;
    }

    RtlFreeUnicodeString( &UserName );
    LocalFree( DomainName.Buffer );

    return ( bRet != 0 );

}

//+---------------------------------------------------------------------------
//
//  Function:   TranslateNameW
//
//  Synopsis:   Public:  Translate a name
//
//  Arguments:  [lpAccountName]     --
//              [AccountNameFormat] --
//              [DesiredNameFormat] --
//              [lpTranslatedName]  --
//              [nSize]             --
//
//  History:    1-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
SEC_ENTRY
TranslateNameW (
    LPCWSTR lpAccountName,
    EXTENDED_NAME_FORMAT AccountNameFormat,
    EXTENDED_NAME_FORMAT DesiredNameFormat,
    LPWSTR lpTranslatedName,
    LPDWORD nSize
    )
{
    if ( DesiredNameFormat == NameUnknown )
    {
        SetLastError( ERROR_INVALID_PARAMETER );

        return FALSE ;
    }

    return ( SecpTranslateName( NULL,
                                lpAccountName,
                                AccountNameFormat,
                                DesiredNameFormat,
                                lpTranslatedName,
                                nSize ) != 0 );
}


//+---------------------------------------------------------------------------
//
//  Function:   GetUserNameExA
//
//  Synopsis:   Public:  ANSI entrypoint
//
//  Arguments:  [NameFormat]   --
//              [lpNameBuffer] --
//              [nSize]        --
//
//  History:    1-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
SEC_ENTRY
GetUserNameExA (
    EXTENDED_NAME_FORMAT  NameFormat,
    LPSTR lpNameBuffer,
    LPDWORD nSize
    )
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    LPWSTR UnicodeBuffer;
    NTSTATUS st;
    //
    // Work buffer needs to be twice the size of the user's buffer
    //

    UnicodeBuffer = (PWSTR) RtlAllocateHeap(RtlProcessHeap(), 0, *nSize * sizeof(WCHAR));
    if (!UnicodeBuffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    //
    // Set up an ANSI_STRING that points to the user's buffer
    //

    AnsiString.MaximumLength = (USHORT) *nSize;
    AnsiString.Length = 0;
    AnsiString.Buffer = lpNameBuffer;


    //
    // Let the unicode version do the work:
    //

    if (!GetUserNameExW( NameFormat, UnicodeBuffer, nSize )) {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
        
        //
        // In the MBCS case, the count of characters isn't the same as the
        // count of bytes -- return a worst-case size.
        //

        *nSize *= sizeof(WCHAR);

        return(FALSE);
    }

    //
    // Now convert back to ANSI for the caller
    //

    RtlInitUnicodeString(&UnicodeString, UnicodeBuffer);
    st= RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);

    if(!NT_SUCCESS(st)) {
        //
        // RtlUnicodeStringToAnsiString may fail. Map the buffer overflow 
        // error to one that caller expect, and return the required size.
        //
        SecpSetLastNTError( (st==STATUS_BUFFER_OVERFLOW)?STATUS_BUFFER_TOO_SMALL:st );
        *nSize = AnsiString.Length + 1;
    }
    else {

        //
        // For reasons unclear, some APIs return the length needed as including
        // the trailing NULL for failure only.  Others return it for both
        // success and failure.  GetUserName() is one such API (unlike, say,
        // GetComputerName).  So, if the flag is set saying "this is old GetUserName
        // calling", adjust the return size appropriately.  Note:  do *not* try
        // to make one or the other APIs behave consistently.  Apps will cache
        // based on this length, and they break if the length isn't correct.
        //
    
        if ((DWORD) NameFormat & SPM_NAME_OPTION_NT4_ONLY )
        {
            *nSize = AnsiString.Length + 1;
        }
        else
        {
            *nSize = AnsiString.Length;
        }
    }

    RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
    return(NT_SUCCESS(st));


}

//+---------------------------------------------------------------------------
//
//  Function:   GetComputerObjectNameExA
//
//  Synopsis:   Public:  ANSI entrypoint
//
//  Arguments:  [NameFormat]   --
//              [lpNameBuffer] --
//              [nSize]        --
//
//  History:    1-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
SEC_ENTRY
GetComputerObjectNameA (
    EXTENDED_NAME_FORMAT  NameFormat,
    LPSTR lpNameBuffer,
    LPDWORD nSize
    )
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    LPWSTR UnicodeBuffer;
    NTSTATUS st;

    //
    // Work buffer needs to be twice the size of the user's buffer
    //

    UnicodeBuffer = (PWSTR) RtlAllocateHeap(RtlProcessHeap(), 0, *nSize * sizeof(WCHAR));
    if (!UnicodeBuffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    //
    // Set up an ANSI_STRING that points to the user's buffer
    //

    AnsiString.MaximumLength = (USHORT) *nSize;
    AnsiString.Length = 0;
    AnsiString.Buffer = lpNameBuffer;


    //
    // Let the unicode version do the work:
    //

    if (!GetComputerObjectNameW( NameFormat, UnicodeBuffer, nSize )) {
        // A DBCS unicode char may take 2 ansi chars. 
        // Prepare for the worst, require twice as much memory.
        *nSize *= sizeof(WCHAR); 
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
        return(FALSE);
    }

    //
    // Now convert back to ANSI for the caller
    //

    RtlInitUnicodeString(&UnicodeString, UnicodeBuffer);
    st=RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);
    if(!NT_SUCCESS(st))
    {   
        // the translation may fail due to the small buffer size,
        // return the required size on falure.
        SecpSetLastNTError( (st==STATUS_BUFFER_OVERFLOW)?STATUS_BUFFER_TOO_SMALL:st );
        *nSize = AnsiString.Length + 1;
        return(FALSE);
    }

    *nSize = AnsiString.Length + 1;
    RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
    return(TRUE);


}


//+---------------------------------------------------------------------------
//
//  Function:   TranslateNameA
//
//  Synopsis:   Public:  ANSI entrypoint
//
//  Arguments:  [lpAccountName]     --
//              [AccountNameFormat] --
//              [DesiredNameFormat] --
//              [lpTranslatedName]  --
//              [nSize]             --
//
//  History:    1-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
SEC_ENTRY
TranslateNameA (
    LPCSTR lpAccountName,
    EXTENDED_NAME_FORMAT AccountNameFormat,
    EXTENDED_NAME_FORMAT DesiredNameFormat,
    LPSTR lpTranslatedName,
    LPDWORD nSize
    )
{
    ANSI_STRING AnsiString ;
    UNICODE_STRING UnicodeString ;
    NTSTATUS Status ;
    UNICODE_STRING ReturnString ;
    PWSTR UnicodeBuffer ;
    BOOLEAN bRet;
    NTSTATUS st;

    RtlInitAnsiString( &AnsiString, lpAccountName );

    Status = RtlAnsiStringToUnicodeString( &UnicodeString,
                                           &AnsiString,
                                           TRUE);

    if ( !NT_SUCCESS(Status) )
    {
        SecpSetLastNTError(Status);

        return FALSE;
    }

    UnicodeBuffer = (PWSTR) RtlAllocateHeap( RtlProcessHeap(),
                                     0,
                                     *nSize * sizeof( WCHAR ) );

    if ( !UnicodeBuffer )
    {
        RtlFreeUnicodeString( &UnicodeString );

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );

        return FALSE ;
    }


    AnsiString.MaximumLength = (USHORT) *nSize ;
    AnsiString.Length = 0 ;
    AnsiString.Buffer = lpTranslatedName ;

    bRet = TranslateNameW( UnicodeString.Buffer,
                         AccountNameFormat,
                         DesiredNameFormat,
                         UnicodeBuffer,
                         nSize );

    RtlFreeUnicodeString( &UnicodeString );

    if ( bRet )
    {
        RtlInitUnicodeString( &UnicodeString,
                              UnicodeBuffer );
        st = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeString, FALSE );
        if (!NT_SUCCESS(st)) {
            // the translation may fail due to small buffer size
            SecpSetLastNTError( (st==STATUS_BUFFER_OVERFLOW)?STATUS_BUFFER_TOO_SMALL:st );
            bRet = FALSE;

        }

        *nSize = AnsiString.Length + 1;


    } else {
        // A DBCS unicode char may take 2 ansi chars. 
        // Prepare for the worst, require twice as much memory.
        *nSize *= sizeof(WCHAR);
    }

    RtlFreeHeap( RtlProcessHeap(), 0, UnicodeBuffer );

    return bRet ;

}

VOID
SecpFreeMemory(
    PVOID p
    )
{
    LocalFree( p );
}

BOOLEAN
WINAPI
SecpTranslateNameExWorker(
    PWSTR Domain,
    LPCWSTR Name,
    EXTENDED_NAME_FORMAT Supplied,
    EXTENDED_NAME_FORMAT *DesiredSelection,
    ULONG  DesiredCount,
    PWSTR **TranslatedNames,
    BOOL DoDiscoveryWithAccount,
    PBOOL NoSuchUser
    )
/*++

    DoDiscoveryWithAccount -- If TRUE, the (expensive) DC discovery with
        account will be attempted. Otherwise, the plain discovery w/o
        account will be attempted. The caller should specify FALSE on
        the first attempt to call this routine to minimize the performance
        hit. If this routine fails because the discovered DC doesn't have
        the specified account (as indicated by the NoSuchUser parameter),
        the caller should repeate the call passing TRUE for this parameter.

    NoSuchUser -- If this routine fails, this parameter will indicate
        whether the failure was due to the lack of the account on the
        discovered DC. This parameter is ignored if the routine succeeds.

--*/
{
    DWORD NetStatus ;
    PDOMAIN_CONTROLLER_INFOW DcInfo  = NULL;
    HANDLE DcHandle ;
    ULONG RetryLimit ;
    PDS_NAME_RESULTW Results ;
    NTSTATUS Status = STATUS_CANT_ACCESS_DOMAIN_INFO ;
    ULONG LengthRequired ;
    BOOL bRet = FALSE ;
    BOOL UseNetStatus = TRUE ;
    BOOL LocalNoSuchUser = FALSE ;
    PWSTR Scan = (PWSTR) Name ;
    PWSTR Dollar ;
    ULONG Bits = 0 ;
    ULONG i;
    PWSTR DomainName = NULL;
    PWSTR pwszSPN = NULL, pwszDomainDnsName;
          
    I_RPCMAPWIN32STATUS pI_RpcMapWin32Status ;

    //
    // Note:  Status is initialized to can't access domain info because if there
    // is a series of network problems after finding a DC, we bail out of the loop
    // after some retries, and Status would be uninitialized.
    //

    pI_RpcMapWin32Status = (I_RPCMAPWIN32STATUS) GetProcAddress( GetModuleHandle(L"rpcrt4.dll"),
                                                                 "I_RpcMapWin32Status" );

    //
    // This is the only kind this function handles with respect
    // to error codes from CrackNames
    //
    ASSERT( Supplied == NameSamCompatible );

    //
    //  Prepare the out parameter
    //
    ASSERT( TranslatedNames );
    (*TranslatedNames) = (PWSTR*) LocalAlloc( LMEM_ZEROINIT, DesiredCount*sizeof(WCHAR*) );
    if ( !(*TranslatedNames) )
    {

        SecpSetLastNTError( STATUS_NO_MEMORY );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }


    if (    !Domain
         && Supplied == NameSamCompatible  
         && (Scan = wcschr( Name, L'\\' )))
    {
        // when a sam compatible name is passed in, and the domain is not 
        // specified, we should get the domain from the supplied name, and
        // get a DC in that domain.  
        
        DomainName = (PWSTR) LocalAlloc( LMEM_ZEROINIT, (Scan-Name+1)*sizeof(WCHAR) );
        if ( DomainName )
        {
           wcsncpy( DomainName, Name, Scan-Name );
        }
    }

    //
    // Discover the DC as directed by the caller
    //

    if ( DoDiscoveryWithAccount ) {

        Scan = wcschr( Name, L'\\' );
        if ( Scan )
        {
            Scan++ ;
        }
        else
        {
            Scan = (PWSTR) Name ;
        }

        Bits = UF_NORMAL_ACCOUNT ;

        Dollar = wcschr( Scan, L'$' );

        if ( Dollar )
        {
            Bits |= UF_MACHINE_ACCOUNT_MASK ;
        }

        NetStatus = DsGetDcNameWithAccountW(
                                NULL,
                                Scan,
                                Bits,
                                Domain ? Domain : ( DomainName ? DomainName : L"" ),
                                NULL,
                                NULL,
                                DS_DIRECTORY_SERVICE_REQUIRED |
                                    DS_RETURN_DNS_NAME |
                                    DS_IS_FLAT_NAME,
                                &DcInfo );
    } else {

        NetStatus = DsGetDcNameW( NULL,
                                  Domain ? Domain : ( DomainName ? DomainName : L"" ),
                                  NULL,
                                  NULL,
                                  DS_DIRECTORY_SERVICE_REQUIRED |
                                    DS_RETURN_DNS_NAME |
                                    DS_IS_FLAT_NAME,
                                  &DcInfo );
    }

    if ( NetStatus != 0 )
    {
        //
        // No DS DC available, therefore no name translation:
        //

        SecpSetLastNTError( STATUS_UNSUCCESSFUL );

        SetLastError( NetStatus );

        bRet = FALSE;

        goto Exit;

    }

    DebugLog((DEB_TRACE_GETUSER, "Trying to bind to %ws\n", DcInfo->DomainControllerName));
    while ( *DcInfo->DomainControllerName == L'\\' )
    {
        DcInfo->DomainControllerName ++ ;
    }

    pwszDomainDnsName = DcInfo->DomainName? DcInfo->DomainName : (Domain ? Domain : DomainName);

    // pswzSPN is NULL on error, so we don't care the return value.
    ConstructSPN(DcInfo->DomainControllerName,
                 pwszDomainDnsName,
                 &pwszSPN );


    NetStatus = DsBindWithSpnEx( DcInfo->DomainControllerName,  // DC name
                                 pwszDomainDnsName,             // domain name
                                 NULL,                          // creds
                                 pwszSPN,                       // SPN
                                 0,                             // No delegation
                                 &DcHandle );
    
    if (pwszSPN) {
        LocalFree(pwszSPN);
        pwszSPN = NULL;
    }


    if ( NetStatus != 0 )
    {
        //
        // Error mapping tricks.  Some win32 errors have
        // this format.
        //

        if ( NetStatus <= 0x80000000 )
        {
            Status = NtCurrentTeb()->LastStatusValue ;

            if ( pI_RpcMapWin32Status )
            {
                Status = pI_RpcMapWin32Status( NetStatus );

                if ( NT_SUCCESS( Status ) )
                {
                    //
                    // Didn't map.  Treat as a win32 error
                    //

                    UseNetStatus = TRUE ;

                    Status = STATUS_UNSUCCESSFUL ;
                }
            }

        }
        else
        {
            UseNetStatus = TRUE ;

            Status = STATUS_UNSUCCESSFUL ;
        }


        DebugLog(( DEB_ERROR, "DsBind to %ws failed, %x (%d)\n",
                   DcInfo->DomainControllerName,
                   NetStatus,
                   UseNetStatus ));

        bRet = FALSE;

        goto Exit;

    }

    //
    // Got a connection.  Crack the names:
    //

    Status = STATUS_SUCCESS;
    for ( i = 0; (i < DesiredCount) && NT_SUCCESS(Status); i++ )
    {

        NetStatus = DsCrackNames(DcHandle,
                                  DS_NAME_NO_FLAGS,
                                  (DS_NAME_FORMAT) Supplied,
                                  (DS_NAME_FORMAT) DesiredSelection[i],
                                  1,
                                  &Name,
                                  &Results );

        //
        // Now, see what happened:
        //

        if ( NetStatus == 0 )
        {
            //
            // So far, so good.  See if the name got xlated:
            //
            if ( Results->cItems >= 1 )
            {

                if ( Results->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY )
                {
                    LocalFree( *TranslatedNames );
                    *TranslatedNames = 0;

                    bRet = SecpTranslateNameExWorker(
                                Results->rItems[0].pDomain,
                                Name,
                                Supplied,
                                DesiredSelection,
                                DesiredCount,
                                TranslatedNames,
                                FALSE,
                                &LocalNoSuchUser );

                    //
                    // Sleazy, but unfortunate, since last status gets
                    // overwritten by DsUnbind.
                    //

                    if ( !bRet )
                    {
                        UseNetStatus = FALSE ;

                        Status = NtCurrentTeb()->LastStatusValue ;
                        DebugLog((DEB_ERROR, "SecpTranslateNameEx returned 0x%lx. %ws, line %d\n", Status, THIS_FILE, __LINE__));
                    }


                }
                else
                {
                    Status = SecpMapDsNameError( Results->rItems[0].status );
    
                    if ( NT_SUCCESS( Status ) )
                    {
                        //
                        // Mapped the name
                        //
    
                        LengthRequired = wcslen( Results->rItems[0].pName ) + 1;
    
                        (*TranslatedNames)[i] = (PWSTR) LocalAlloc( LMEM_ZEROINIT, LengthRequired*sizeof(WCHAR) );
                        if ( (*TranslatedNames)[i] ) {
    
                            RtlCopyMemory( (*TranslatedNames)[i],
                                           Results->rItems[0].pName,
                                           LengthRequired * sizeof( WCHAR ) );
    
                        } else {
    
                            Status = STATUS_NO_MEMORY;
                        }
                    }
    
                    //
                    // If there is no such user on the DC,
                    //  tell the caller to retry to find a
                    //  DC that has the user account
                    //
                    else if ( Status == STATUS_NO_SUCH_USER )
                    {
                        LocalNoSuchUser = TRUE;
                    }
                }
            }
            else
            {
                DebugLog((DEB_ERROR, "CrackName did not return useful stuff. %ws, line %d\n", THIS_FILE, __LINE__));
                Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
            }

            DsFreeNameResult( Results );

        } else {

            Status = STATUS_UNSUCCESSFUL;
            UseNetStatus = TRUE;
        }

    }

    if ( NT_SUCCESS( Status ) )
    {
        bRet = TRUE;
    }

    //
    // We are done with the connection
    //

    (VOID) DsUnBind( &DcHandle );

Exit:

    if ( DomainName )
    {
        LocalFree( DomainName );
        DomainName = NULL;
    }


    if ( DcInfo )
    {
        NetApiBufferFree( DcInfo );
    }

    if ( !bRet )
    {
        //
        // Free out parameters
        //
        if( TranslatedNames && *TranslatedNames )
        {

            for ( i = 0; i < DesiredCount; i++ )
            {
                if ( (*TranslatedNames)[i] ) LocalFree( (*TranslatedNames)[i] );
            }
    
            LocalFree( (*TranslatedNames) );
            *TranslatedNames = NULL;
        }
    
        if ( UseNetStatus ||
             NT_SUCCESS( Status )  )
        {
            NtCurrentTeb()->LastStatusValue = STATUS_UNSUCCESSFUL;
            SetLastError( NetStatus );
        }
        else
        {
            NtCurrentTeb()->LastStatusValue = Status;
            SetLastError( RtlNtStatusToDosError(Status) );
        }

        //
        // Tell the caller whether we failed
        //  because the DC didn't have the account
        //
        *NoSuchUser = LocalNoSuchUser;
    }

    return (bRet != 0);

}

BOOLEAN
WINAPI
SecpTranslateNameEx(
    PWSTR Domain,
    LPCWSTR Name,
    EXTENDED_NAME_FORMAT Supplied,
    EXTENDED_NAME_FORMAT *DesiredSelection,
    ULONG  DesiredCount,
    PWSTR **TranslatedNames
    )
{
    BOOLEAN Result;
    BOOL NoSuchUser = FALSE;

    //
    // First try to discover a DC without specifying
    // the account as discoveries with account are
    // too expensive performance-wise. If it turns
    // out that the discovered DC doesn't have the
    // account, we will retry the discovery specifying
    // the account name next.
    //

    Result = SecpTranslateNameExWorker(
                         Domain,
                         Name,
                         Supplied,
                         DesiredSelection,
                         DesiredCount,
                         TranslatedNames,
                         FALSE,  // discovery w/o account
                         &NoSuchUser );

    if ( !Result && NoSuchUser ) {
        Result = SecpTranslateNameExWorker(
                         Domain,
                         Name,
                         Supplied,
                         DesiredSelection,
                         DesiredCount,
                         TranslatedNames,
                         TRUE,  // discovery w/ account
                         &NoSuchUser );
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\driver\efs.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        efs.cxx
//
// Contents:    kernel mode EFS API, called by efs.sys
//
//
// History:     3/5/94      RobertRe      Created
//
//------------------------------------------------------------------------
#include "secpch2.hxx"
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include <efsstruc.h>
#include <lpcefs.h>
#include "ksecdd.h"
#include "connmgr.h"

SECURITY_STATUS
MapContext( PCtxtHandle     pctxtHandle);
}



extern "C"
NTSTATUS
EfsGenerateKey(
    PEFS_KEY  * Fek,
    PEFS_DATA_STREAM_HEADER * EfsStream,
    PEFS_DATA_STREAM_HEADER DirectoryEfsStream,
    ULONG DirectoryEfsStreamLength,
    PVOID * BufferBase,
    PULONG BufferLength
    )

/*++

Routine Description:

    This routine generates an FEK and an EFS stream in
    response to a call from the driver.

Arguments:

    Fek -

    EfsStream -

    DirectoryEfsStream -

    DirectoryEfsStreamLength -

    BufferBase -

    BufferLength -


Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    NTSTATUS Status;

    Status = EfspGenerateKey(
               EfsStream,
               DirectoryEfsStream,
               DirectoryEfsStreamLength,
               Fek,
               BufferBase,
               BufferLength
               );

    return( Status );
}

extern "C"
NTSTATUS
GenerateDirEfs(
    PEFS_DATA_STREAM_HEADER DirectoryEfsStream,
    ULONG DirectoryEfsStreamLength,
    PEFS_DATA_STREAM_HEADER * NewEfs,
    PVOID * BufferBase,
    PULONG BufferLength
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    NTSTATUS Status;

    Status = EfspGenerateDirEfs(
                 DirectoryEfsStream,
                 DirectoryEfsStreamLength,
                 NewEfs,
                 BufferBase,
                 BufferLength);

    return( Status );
}




NTSTATUS
EfsDecryptFek(
    IN OUT PEFS_KEY * Fek,
    IN PEFS_DATA_STREAM_HEADER CurrentEfs,
    ULONG EfsStreamLength,
    IN ULONG OpenType,                      //Normal, Recovery or Backup
    OUT PEFS_DATA_STREAM_HEADER *NewEfs,     //In case the DDF, DRF are changed
    PVOID * BufferBase,
    PULONG BufferLength
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    NTSTATUS Status;

    //
    //  Do not touch anything in CurrentEfs. We are not in LSA process and CurrentEfs is in LSA.
    //

    Status = EfspDecryptFek(
                Fek,
                CurrentEfs,
                EfsStreamLength,
                OpenType,
                NewEfs,
                BufferBase,
                BufferLength
                );

    return( Status );
}


extern "C"
NTSTATUS
GenerateSessionKey(
    OUT PEFS_INIT_DATAEXG InitDataExg
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    NTSTATUS Status;

    Status = EfspGenerateSessionKey(
               InitDataExg
               );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\driver\extapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        extapi.cxx
//
// Contents:    user-mode stubs for security extension APIs
//
//
// History:     3-5-94      MikeSw      Created
//
//------------------------------------------------------------------------

#include "secpch2.hxx"
#pragma hdrstop
extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "ksecdd.h"
}





HRESULT SEC_ENTRY
GetSecurityUserInfo(    PLUID                   pLogonId,
                        ULONG                   fFlags,
                        PSecurityUserData *     ppUserInfo)
{
    return(SecpGetUserInfo(pLogonId,fFlags,ppUserInfo));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\driver\context.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       context.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-29-98   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __CONTEXT_H__
#define __CONTEXT_H__

#define CONTEXT_TAG 'LCeS'

typedef struct _KSEC_CONTEXT_LIST {
    KSEC_CONTEXT_TYPE Type ;                // Type (Paged or NonPaged)
    LIST_ENTRY List ;                       // List of context records
    ULONG Count ;                           // Count of context records
    union {
        ERESOURCE   Paged ;                 // Lock used when paged
        KSPIN_LOCK  NonPaged ;              // Lock used when non-paged
    } Lock ;
} KSEC_CONTEXT_LIST, * PKSEC_CONTEXT_LIST ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\driver\encmem.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    encmem.cxx

Abstract:

    This module contains the support code for memory encryption/decryption.

Author:

    Scott Field (SField) 09-October-2000

Revision History:

--*/

#include "secpch2.hxx"
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>

#include "ksecdd.h"

#include "randlib.h"
#include "aes.h"

}

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, KsecEncryptMemory )
#pragma alloc_text( PAGE, KsecEncryptMemoryInitialize )
#pragma alloc_text( PAGE, KsecEncryptMemoryShutdown )
#endif 

//
// note: g_DESXKey defaults to non-paged .bss/.data section.  by design!
//

DESXTable g_DESXKey;
MD5_CTX g_Md5Hash;

AESTable_128 g_AESKey;
MD5_CTX g_AESHash;

UCHAR RandomSalt[AES_BLOCKLEN];
BOOLEAN InitializedMemory;


VOID
GenerateKey(
    DESXTable *pKey,
    PUCHAR pSalt,
    DWORD cbSalt)
{
    MD5_CTX LocalMd5Hash;
    UCHAR LocalKeyMaterial[MD5DIGESTLEN * 2];

    LocalMd5Hash = g_Md5Hash;
    MD5Update(&LocalMd5Hash, (PUCHAR)"aaa", 3);
    MD5Update(&LocalMd5Hash, pSalt, cbSalt);
    MD5Final(&LocalMd5Hash);
    RtlCopyMemory(LocalKeyMaterial, LocalMd5Hash.digest, MD5DIGESTLEN);

    LocalMd5Hash = g_Md5Hash;
    MD5Update(&LocalMd5Hash, (PUCHAR)"bbb", 3);
    MD5Update(&LocalMd5Hash, pSalt, cbSalt);
    MD5Final(&LocalMd5Hash);
    RtlCopyMemory(LocalKeyMaterial + MD5DIGESTLEN, LocalMd5Hash.digest, MD5DIGESTLEN);

    desxkey( pKey, LocalKeyMaterial );

    RtlSecureZeroMemory(&LocalMd5Hash, sizeof(LocalMd5Hash));
    RtlSecureZeroMemory(LocalKeyMaterial, sizeof(LocalKeyMaterial));
}


VOID
GenerateAESKey(
    AESTable_128 *pKey,
    PUCHAR pSalt,
    DWORD cbSalt)
{
    MD5_CTX LocalMd5Hash;

    LocalMd5Hash = g_Md5Hash;
    MD5Update(&LocalMd5Hash, pSalt, cbSalt);
    MD5Final(&LocalMd5Hash);

    aeskey( (AESTable *)pKey, LocalMd5Hash.digest, AES_ROUNDS_128);

    RtlSecureZeroMemory(&LocalMd5Hash, sizeof(LocalMd5Hash));
}


NTSTATUS
NTAPI
KsecEncryptMemory(
    IN PVOID pMemory,
    IN ULONG cbMemory,
    IN int Operation,
    IN ULONG Option
    )
{
    PUCHAR pbIn;
    ULONG BlockCount;
    DESXTable LocalDESXKey;
    AESTable_128 LocalAESKey;
    UCHAR feedback[AES_BLOCKLEN];
    BOOL fUseAES = FALSE;

    PAGED_CODE();

    if( (cbMemory & (AES_BLOCKLEN-1)) == 0 )
    {
        fUseAES = TRUE;
    }
    else if( (cbMemory & (DESX_BLOCKLEN-1)) != 0 )
    {
        return STATUS_INVALID_PARAMETER;
    }

    if( !InitializedMemory )
    {
        NTSTATUS Status = KsecEncryptMemoryInitialize();

        if(!NT_SUCCESS(Status))
        {
            return Status;
        }
    }

    switch (Option)
    {
        case (0):
        {
            //
            // Mix the process creation time in with the key.
            // This will prevent memory from being decryptable across processes.
            //
            LONGLONG ProcessTime = PsGetProcessCreateTimeQuadPart( PsGetCurrentProcess() );

            if(fUseAES)
            {
                GenerateAESKey(&LocalAESKey,
                               (PUCHAR)&ProcessTime,
                               sizeof(ProcessTime));
            }
            else
            {
                GenerateKey(&LocalDESXKey,
                            (PUCHAR)&ProcessTime,
                            sizeof(ProcessTime));
            }
            break;
        }

        case (RTL_ENCRYPT_OPTION_CROSS_PROCESS):
        {
            if(fUseAES)
            {
                LocalAESKey = g_AESKey;
            }
            else
            {
                LocalDESXKey = g_DESXKey;
            }
            break;

        }
        case (RTL_ENCRYPT_OPTION_SAME_LOGON):
        {
            SECURITY_SUBJECT_CONTEXT SubjectContext;
            unsigned __int64 LogonId;
            NTSTATUS Status;

            SeCaptureSubjectContext( &SubjectContext );
            SeLockSubjectContext( &SubjectContext );

//
//      Return the effective token from a SecurityContext
//

#define EffectiveToken( SubjectSecurityContext ) (                           \
                (SubjectSecurityContext)->ClientToken ?                      \
                (SubjectSecurityContext)->ClientToken :                      \
                (SubjectSecurityContext)->PrimaryToken                       \
                )

            Status = SeQueryAuthenticationIdToken(
                                    EffectiveToken(&SubjectContext),
                                    (LUID*)&LogonId
                                    );

            SeUnlockSubjectContext( &SubjectContext );
            SeReleaseSubjectContext( &SubjectContext );

            if( !NT_SUCCESS(Status) )
            {
                return Status;
            }

            if(fUseAES)
            {
                GenerateAESKey(&LocalAESKey,
                               (PUCHAR)&LogonId,
                               sizeof(LogonId));
            }
            else
            {
                GenerateKey(&LocalDESXKey,
                            (PUCHAR)&LogonId,
                            sizeof(LogonId));
            }

            break;
        }

        default:
        {
            return STATUS_INVALID_PARAMETER;
        }
    }


    if(fUseAES)
    {
        memcpy(feedback, RandomSalt, AES_BLOCKLEN);
        BlockCount = cbMemory / AES_BLOCKLEN;
        pbIn = (PUCHAR)pMemory;
    
        while( BlockCount-- )
        {
            CBC(
                aes128,                     // aes128 is the cipher routine
                AES_BLOCKLEN,
                pbIn,                       // result buffer.
                pbIn,                       // input buffer.
                &LocalAESKey,
                Operation,
                feedback
                );
    
            pbIn += AES_BLOCKLEN;
        }
    
        RtlSecureZeroMemory(&LocalAESKey, sizeof(LocalAESKey));
    }
    else
    {
        memcpy(feedback, RandomSalt, DESX_BLOCKLEN);
        BlockCount = cbMemory / DESX_BLOCKLEN;
        pbIn = (PUCHAR)pMemory;
    
        while( BlockCount-- )
        {
            CBC(
                desx,                       // desx is the cipher routine
                DESX_BLOCKLEN,
                pbIn,                       // result buffer.
                pbIn,                       // input buffer.
                &LocalDESXKey,
                Operation,
                feedback
                );
    
            pbIn += DESX_BLOCKLEN;
        }
    
        RtlSecureZeroMemory(&LocalDESXKey, sizeof(LocalDESXKey));
    }

    return STATUS_SUCCESS;
}

NTSTATUS
NTAPI
KsecEncryptMemoryInitialize(
    VOID
    )
{
    UCHAR DESXKey[ DESX_KEYSIZE ];
    UCHAR AESKey[ AES_KEYSIZE_128 ];
    UCHAR Salt[AES_BLOCKLEN];

    PAGED_CODE();

    if(!NewGenRandom( NULL, NULL, DESXKey, sizeof(DESXKey) ))
    {
        return STATUS_UNSUCCESSFUL;
    }

    if(!NewGenRandom( NULL, NULL, AESKey, sizeof(AESKey) ))
    {
        return STATUS_UNSUCCESSFUL;
    }

    if(!NewGenRandom( NULL, NULL, Salt, sizeof(Salt) ))
    {
        return STATUS_UNSUCCESSFUL;
    }

    ExAcquireFastMutex( &KsecConnectionMutex );

    if( !InitializedMemory )
    {
        desxkey( &g_DESXKey, DESXKey );
        MD5Init(&g_Md5Hash);
        MD5Update(&g_Md5Hash, DESXKey, sizeof(DESXKey));

        aeskey( (AESTable *)&g_AESKey, AESKey, AES_ROUNDS_128 );
        MD5Init(&g_AESHash);
        MD5Update(&g_AESHash, AESKey, sizeof(AESKey));

        RtlCopyMemory( RandomSalt, Salt, sizeof(RandomSalt) );
        InitializedMemory = TRUE;
    }

    ExReleaseFastMutex( &KsecConnectionMutex );

    RtlSecureZeroMemory( DESXKey, sizeof(DESXKey) );
    RtlSecureZeroMemory( AESKey, sizeof(AESKey) );

    return STATUS_SUCCESS;
}

VOID
KsecEncryptMemoryShutdown(
    VOID
    )
{
    PAGED_CODE();

    RtlSecureZeroMemory( &g_DESXKey, sizeof(g_DESXKey) );
    RtlSecureZeroMemory( &g_Md5Hash, sizeof(g_Md5Hash) );
    RtlSecureZeroMemory( &g_AESKey,  sizeof(g_AESKey) );
    RtlSecureZeroMemory( &g_AESHash, sizeof(g_AESHash) );
    InitializedMemory = FALSE;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\driver\ksecdd.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        KSecDD.C
//
// Contents:    Base level stuff for the device driver
//
//
// History:     19 May 92,  RichardW    Blatently stolen from DarrylH
//
//------------------------------------------------------------------------
#include "secpch2.hxx"
#pragma hdrstop
#include <ntddksec.h>

extern "C"
{
#include <spmlpc.h>
#include <ntverp.h>

#include "ksecdd.h"

#include "connmgr.h"

#include "randlib.h"

//
// Define the local routines used by this driver module.
//


NTSTATUS
KsecDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KsecQueryFileInformation(
    OUT PVOID Buffer,
    IN OUT PULONG Length,
    IN FILE_INFORMATION_CLASS InformationClass
    );

NTSTATUS
KsecQueryVolumeInformation(
    OUT PVOID Buffer,
    IN OUT PULONG Length,
    IN FS_INFORMATION_CLASS InformationClass
    );

NTSTATUS
KsecDeviceControl(
    IN      PVOID   InputBuffer,
    IN      ULONG   InputLength,
        OUT PVOID   OutputBuffer,
    IN  OUT PULONG  OutputLength,
    IN      ULONG   IoControlCode
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath);

#ifdef KSEC_LEAK_TRACKING

VOID
KsecUnload(
    IN PDRIVER_OBJECT   DriverObject
    );

#endif  // KSEC_LEAK_TRACKING

} // extern "C"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, KsecQueryVolumeInformation)
#pragma alloc_text(PAGE, KsecDispatch)
#pragma alloc_text(PAGE, KsecQueryFileInformation)
#pragma alloc_text(PAGE, KsecDeviceControl)

#ifdef KSEC_LEAK_TRACKING
#pragma alloc_text(PAGE, KsecUnload)
#endif

#endif


BOOLEAN FoundLsa = FALSE ;
ULONG KsecUserProbeAddress ;
PEPROCESS KsecLsaProcess ;
HANDLE KsecLsaProcessHandle ;

#ifdef KSEC_LEAK_TRACKING
PDEVICE_OBJECT gDeviceObject = NULL;
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the synchronous NULL device driver.
    This routine creates the device object for the NullS device and performs
    all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    UNICODE_STRING nameString;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS Status;

    //
    // Create the device object.
    //

    RtlInitUnicodeString( &nameString,
                          DD_KSEC_DEVICE_NAME_U );

    Status = IoCreateDevice( DriverObject,
                             0L,
                             &nameString,
                             FILE_DEVICE_KSEC,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             &deviceObject );

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

#ifdef KSEC_LEAK_TRACKING

    DriverObject->DriverUnload = KsecUnload;
    //
    // Save device object away for unload
    //
    gDeviceObject = deviceObject;

#endif  // KSEC_LEAK_TRACKING
    //
    // Setting the following flag changes the timing of how many I/O's per
    // second can be accomplished by going through the NULL device driver
    // from being simply getting in and out of the driver, to getting in and
    // out with the overhead of building an MDL, probing and locking buffers,
    // unlocking the pages, and deallocating the MDL.  This flag should only
    // be set for performance testing.
    //

//  deviceObject->Flags |= DO_DIRECT_IO;

    //
    // Initialize the driver object with this device driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = KsecDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = KsecDispatch;
    DriverObject->MajorFunction[IRP_MJ_READ]   = KsecDispatch;
    DriverObject->MajorFunction[IRP_MJ_WRITE]  = KsecDispatch;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]  = KsecDispatch;
    DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION] = KsecDispatch;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = KsecDispatch ;



    if (!InitConnMgr())
    {
        DebugLog((DEB_ERROR,"Failed to initialize\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Create the resource protecting the list of packages
    //

    Status = ExInitializeFastMutex( &KsecPackageLock );

    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR,"Failed to initialize package lock: 0x%x\n",Status));
        return(Status);
    }

    Status = ExInitializeFastMutex( &KsecPageModeMutex );

    if ( !NT_SUCCESS( Status ))
    {
        return Status ;
    }

    KeInitializeEvent( 
        &KsecConnectEvent, 
        NotificationEvent, 
        FALSE );


#if ( _X86_ )
    KsecUserProbeAddress = *((PULONG) MmUserProbeAddress);
#endif

    InitializeRNG( NULL );

    DebugLog((DEB_TRACE,"Security device driver loaded\n"));
    return STATUS_SUCCESS;
}


NTSTATUS
KsecDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the synchronous NULL device
    driver.  It accepts an I/O Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.


--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
//    KIRQL oldIrql;
    PVOID buffer;
    ULONG length;
    ULONG ControlCode;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( DeviceObject );

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    //

    switch (irpSp->MajorFunction) {

        //
        // For both create/open and close operations, simply set the information
        // field of the I/O status block and complete the request.
        //

        case IRP_MJ_CREATE:
        case IRP_MJ_CLOSE:
            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = 0L;
            break;

        //
        // For read operations, set the information field of the I/O status
        // block, set an end-of-file status, and complete the request.
        //

        case IRP_MJ_READ:
            Irp->IoStatus.Status = STATUS_END_OF_FILE;
            Irp->IoStatus.Information = 0L;
            break;

        //
        // For write operations, set the information field of the I/O status
        // block to the number of bytes which were supposed to have been written
        // to the file and complete the request.
        //

        case IRP_MJ_WRITE:
            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = irpSp->Parameters.Write.Length;
            break;

        case IRP_MJ_DEVICE_CONTROL:

            ControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;

            if(((ControlCode & 0x00000003) == METHOD_OUT_DIRECT) && 
               (irpSp->Parameters.DeviceIoControl.OutputBufferLength != 0))
            {
                // The I/O method is METHOD_OUT_DIRECT, so obtain a pointer
                // to the output buffer, based on the same physical memory 
                // used by the user-mode application.
                buffer = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority);
                length = Irp->MdlAddress->ByteCount;

                if(buffer == NULL)
                {
                    Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                    Irp->IoStatus.Information = 0L;
                    break;
                }
            }
            else
            {
                // The I/O method is METHOD_BUFFERED.
                buffer = Irp->AssociatedIrp.SystemBuffer;
                length = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
            }

            Irp->IoStatus.Status = KsecDeviceControl(
                                        irpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                        irpSp->Parameters.DeviceIoControl.InputBufferLength,
                                        buffer,
                                        &length,
                                        ControlCode
                                        );

            Irp->IoStatus.Information = length;
            break;


        case IRP_MJ_QUERY_INFORMATION:
            buffer = Irp->AssociatedIrp.SystemBuffer;
            length = irpSp->Parameters.QueryFile.Length;
            Irp->IoStatus.Status = KsecQueryFileInformation( buffer,
                                                            &length,
                                                            irpSp->Parameters.QueryFile.FileInformationClass );
            Irp->IoStatus.Information = length;
            break;

        case IRP_MJ_QUERY_VOLUME_INFORMATION:
            buffer = Irp->AssociatedIrp.SystemBuffer;
            length = irpSp->Parameters.QueryVolume.Length;
            Irp->IoStatus.Status = KsecQueryVolumeInformation( buffer,
                                                              &length,
                                                              irpSp->Parameters.QueryVolume.FsInformationClass );
            Irp->IoStatus.Information = length;
            break;
    }

    //
    // Copy the final status into the return status, complete the request and
    // get out of here.
    //

    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, 0 );
    return status;
}

NTSTATUS
KsecQueryFileInformation(
    OUT PVOID Buffer,
    IN PULONG Length,
    IN FILE_INFORMATION_CLASS InformationClass
    )

/*++

Routine Description:

    This routine queries information about the opened file and returns the
    information in the specified buffer provided that the buffer is large
    enough and the specified type of information about the file is supported
    by this device driver.

    Information about files supported by this driver are:

        o   FileStandardInformation

Arguments:

    Buffer - Supplies a pointer to the buffer in which to return the
        information.

    Length - Supplies the length of the buffer on input and the length of
        the data actually written on output.

    InformationClass - Supplies the information class that is being queried.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    PFILE_STANDARD_INFORMATION standardBuffer;

    PAGED_CODE();
    //
    // Switch on the type of information that the caller would like to query
    // about the file.
    //

    switch (InformationClass) {

        case FileStandardInformation:

            //
            // Return the standard information about the file.
            //

            standardBuffer = (PFILE_STANDARD_INFORMATION) Buffer;
            *Length = (ULONG) sizeof( FILE_STANDARD_INFORMATION );
            standardBuffer->NumberOfLinks = 1;
            standardBuffer->DeletePending = FALSE;
            standardBuffer->AllocationSize.LowPart = 0;
            standardBuffer->AllocationSize.HighPart = 0;
            standardBuffer->Directory = FALSE;
            standardBuffer->EndOfFile.LowPart = 0;
            standardBuffer->EndOfFile.HighPart = 0;
            break;

        default:

            //
            // An invalid (or unsupported) information class has been queried
            // for the file.  Return the appropriate status.
            //

            return STATUS_INVALID_INFO_CLASS;

    }

    return STATUS_SUCCESS;
}

NTSTATUS
KsecQueryVolumeInformation(
    OUT PVOID Buffer,
    IN PULONG Length,
    IN FS_INFORMATION_CLASS InformationClass
    )

/*++

Routine Description:

    This routine queries information about the opened volume and returns the
    information in the specified buffer.

    Information about volumes supported by this driver are:

        o   FileFsDeviceInformation

Arguments:

    Buffer - Supplies a pointer to the buffer in which to return the
        information.

    Length - Supplies the length of the buffer on input and the length of
        the data actually written on output.

    InformationClass - Supplies the information class that is being queried.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    PFILE_FS_DEVICE_INFORMATION deviceBuffer;


    PAGED_CODE();
    //
    // Switch on the type of information that the caller would like to query
    // about the volume.
    //

    switch (InformationClass) {

        case FileFsDeviceInformation:

            //
            // Return the device information about the volume.
            //

            deviceBuffer = (PFILE_FS_DEVICE_INFORMATION) Buffer;
            *Length = sizeof( FILE_FS_DEVICE_INFORMATION );
            deviceBuffer->DeviceType = FILE_DEVICE_NULL;
            break;

        default:

            //
            // An invalid (or unsupported) information class has been queried
            // for the volume.  Return the appropriate status.
            //

            return STATUS_INVALID_INFO_CLASS;

    }

    return STATUS_SUCCESS;
}

NTSTATUS
KsecDeviceControl(
    IN      PVOID   InputBuffer,
    IN      ULONG   InputLength,
        OUT PVOID   OutputBuffer,
    IN  OUT PULONG  OutputLength,
    IN      ULONG   IoControlCode
    )
{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;

    PAGED_CODE();

    //
    // Switch on the type of information that the caller would like to query
    // about the volume.
    //

    switch (IoControlCode)
    {

        case IOCTL_KSEC_CONNECT_LSA:
        {

            if ( KsecLsaProcess == NULL )
            {
                (VOID) InitSecurityInterface();
                *OutputLength = 0;
                KsecLsaProcess = PsGetCurrentProcess() ;

                ObReferenceObject( KsecLsaProcess );

                Status = ObOpenObjectByPointer(
                            KsecLsaProcess,
                            OBJ_KERNEL_HANDLE,
                            NULL,
                            PROCESS_VM_OPERATION | PROCESS_QUERY_INFORMATION |
                                PROCESS_VM_READ | PROCESS_VM_WRITE,
                            NULL,
                            KernelMode,
                            &KsecLsaProcessHandle );

                if ( NT_SUCCESS( Status ) )
                {
                    Status = KsecInitLsaMemory();
                }

                return Status ;
            }

            break;
        }

        //
        // kernel mode encapsulated RNG.
        //

        case IOCTL_KSEC_RNG:
        {
            if( OutputBuffer == NULL || OutputLength == NULL )
                return STATUS_INVALID_PARAMETER;

            if( InputLength < *OutputLength ) {
                memset(
                        (unsigned char*)OutputBuffer + InputLength,
                        0,
                        *OutputLength - InputLength
                        );
            }

            if(NewGenRandom( NULL, NULL, (unsigned char *)OutputBuffer, *OutputLength ))
                return STATUS_SUCCESS;

            break;
        }

        case IOCTL_KSEC_RNG_REKEY:
        {
            RNG_CONTEXT RNGContext;

            if( OutputBuffer == NULL || OutputLength == NULL )
                return STATUS_INVALID_PARAMETER;

            if( InputLength < *OutputLength ) {
                memset(
                        (unsigned char*)OutputBuffer + InputLength,
                        0,
                        *OutputLength - InputLength
                        );
            }

            memset( &RNGContext, 0, sizeof(RNGContext) );

            RNGContext.cbSize = sizeof(RNGContext);
            RNGContext.Flags |= RNG_FLAG_REKEY_ONLY;

            if(NewGenRandomEx( &RNGContext, (unsigned char *)OutputBuffer, *OutputLength ))
                return STATUS_SUCCESS;

            break;
        }

        case IOCTL_KSEC_ENCRYPT_MEMORY:
        case IOCTL_KSEC_DECRYPT_MEMORY:
        case IOCTL_KSEC_ENCRYPT_MEMORY_CROSS_PROC:
        case IOCTL_KSEC_DECRYPT_MEMORY_CROSS_PROC:
        case IOCTL_KSEC_ENCRYPT_MEMORY_SAME_LOGON:
        case IOCTL_KSEC_DECRYPT_MEMORY_SAME_LOGON:
        {
            ULONG Option = 0;
            int Operation = ENCRYPT;

            if( OutputBuffer == NULL || OutputLength == NULL )
            {
                return STATUS_INVALID_PARAMETER;
            }

            if( InputLength < *OutputLength ) {
                memset(
                        (unsigned char*)OutputBuffer + InputLength,
                        0,
                        *OutputLength - InputLength
                        );
            }

            if( IoControlCode == IOCTL_KSEC_ENCRYPT_MEMORY_CROSS_PROC ||
                IoControlCode == IOCTL_KSEC_DECRYPT_MEMORY_CROSS_PROC )
            {
                Option = RTL_ENCRYPT_OPTION_CROSS_PROCESS;
            }

            if( IoControlCode == IOCTL_KSEC_ENCRYPT_MEMORY_SAME_LOGON ||
                IoControlCode == IOCTL_KSEC_DECRYPT_MEMORY_SAME_LOGON )
            {
                Option = RTL_ENCRYPT_OPTION_SAME_LOGON;
            }

            if( IoControlCode == IOCTL_KSEC_DECRYPT_MEMORY ||
                IoControlCode == IOCTL_KSEC_DECRYPT_MEMORY_CROSS_PROC ||
                IoControlCode == IOCTL_KSEC_DECRYPT_MEMORY_SAME_LOGON )
            {
                Operation = DECRYPT;
            }

            Status = KsecEncryptMemory(
                                OutputBuffer,
                                *OutputLength,
                                Operation,
                                Option
                                );
            if( NT_SUCCESS(Status) )
            {
                return Status;
            }

            break;
        }

        default:
        {
            //
            // An invalid (or unsupported) IoControlCode was specified.
            //

            DebugLog(( DEB_ERROR, "Invalid Ioctl supplied: %x\n", IoControlCode));

            break;
        }
    }

    if( OutputLength )
        *OutputLength = 0;

    return Status;
}

#if DBG
ULONG KsecInfoLevel;
//ULONG KsecInfoLevel = DEB_TRACE | DEB_ERROR |DEB_WARN | DEB_TRACE_CALL;

void
KsecDebugOut(unsigned long  Mask,
            const char *    Format,
            ...)
{
    PETHREAD    pThread;
    PEPROCESS   pProcess;
    va_list     ArgList;
    char        szOutString[256];

    if (KsecInfoLevel & Mask)
    {
        pThread = PsGetCurrentThread();
        pProcess = PsGetCurrentProcess();

        va_start(ArgList, Format);
        DbgPrint("%#x.%#x> KSec:  ", pProcess, pThread);
        if (_vsnprintf(szOutString, sizeof(szOutString),Format, ArgList) < 0)
        {
                //
                // Less than zero indicates that the string could not be
                // fitted into the buffer.  Output a special message indicating
                // that:
                //

                DbgPrint("Error printing message\n");

        }
        else
        {
            DbgPrint(szOutString);
        }
    }
}
#endif


#ifdef KSEC_LEAK_TRACKING

VOID
KsecUnload(
    IN PDRIVER_OBJECT   DriverObject
    )
/*++

Routine Description:

    Driver unload routine for ksecdd.sys

Arguments:

    DriverObject - This driver's driver objects

Return Value:

    None

--*/
{
    ShutdownRNG (NULL);
    KsecEncryptMemoryShutdown();
    UninitializePackages ();
    IoDeleteDevice (gDeviceObject);
    gDeviceObject = NULL;
    return;
}

#endif  // KSEC_LEAK_TRACKING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\driver\spmlpc.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        spmlpc.cxx
//
// Contents:    lpc code for client->spmgr communication
//
//
// History:     3-4-94      MikeSw      Created
//
//------------------------------------------------------------------------


#include "secpch2.hxx"

extern "C"
{
#include <zwapi.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include <spmlpcp.h>
#include "ksecdd.h"

}


#if defined(ALLOC_PRAGMA) && defined(SECURITY_KERNEL)
#pragma alloc_text(PAGE, CreateConnection)
#pragma alloc_text(PAGE, CallSPM)
#pragma alloc_text(PAGE, LpcConnect)
#endif

ULONG KSecLsaBp;

//+-------------------------------------------------------------------------
//
//  Function:   CallSPM
//
//  Synopsis:   Calls the SPM, handles LPC errors
//
//  Effects:
//
//  Arguments:  pConn           -- Connection to use
//              pSendBuffer     -- Send buffer to send up
//              pReceiveBuffer  -- Received data from SPM
//
//  Requires:
//
//  Returns:
//
//  Notes:      In the future, we can add retry and error handling,
//              but right now we just panic if something fails.
//
//--------------------------------------------------------------------------
SECURITY_STATUS
CallSPM(
        PClient         pClient,
        PSPM_LPC_MESSAGE      pSendBuffer,
        PSPM_LPC_MESSAGE      pReceiveBuffer)

{
    SECURITY_STATUS     scRet;
    int                 retry = 0;
    PEPROCESS           Process ;
    PPORT_MESSAGE       Send ;
    PPORT_MESSAGE       Receive ;
    PVOID               SecurityPort ;
    LONG                Flag ;

    SEC_PAGED_CODE();

    UNREFERENCED_PARAMETER( pClient );

    //
    // How this works:  The SecurityPort pointer is carried around
    // in the EPROCESS object, and is cleaned up when the process
    // terminates (there are no more threads).  The Process will have
    // a null value for this field in one of two cases.  First, the 
    // process hasn't connected to the LSA yet, this should be handled by
    // the call to IsOkayToExec() made by the stub first.  Second
    // is the case when the process has terminated, but kernel callers 
    // have kept a reference to it.  In that case, the ps stuff will 
    // reset the pointer to 1.
    //

    Process = PsGetCurrentProcess();

    SecurityPort = PsGetProcessSecurityPort( Process );

    if ( SecurityPort == (PVOID) 1 )
    {
        //
        // this process has terminated.  Do not attempt to re-establish the
        // connection.
        //

        return STATUS_PROCESS_IS_TERMINATING ;
    }

    if ( KSecLsaBp )
    {
        KSecLsaBp = 0 ;
        pSendBuffer->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET ;
        
    }

    Send = (PPORT_MESSAGE) pSendBuffer ;
    Receive = (PPORT_MESSAGE) pReceiveBuffer ;

    do
    {
        scRet = LpcRequestWaitReplyPort(
                    SecurityPort,
                    Send,
                    Receive );

        if (!NT_SUCCESS(scRet))
        {
            // If the call failed, shout to everyone, kill the connection,
            // and stuff NO_SPM into the API return code

            DebugLog((DEB_ERROR,"Error %x in LPC to LSA\n", scRet));
            DebugLog((DEB_ERROR,"Breaking connection for process %x\n", PsGetCurrentProcess()));

            scRet = SEC_E_INTERNAL_ERROR;

            pReceiveBuffer->ApiMessage.scRet = scRet;
            pReceiveBuffer->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;

            break;
        }
        if ( Receive->u2.s2.Type == LPC_REQUEST )
        {
            //
            // Note:  we may need to support callbacks to kernel mode in the 
            // future.  We will need to think very carefully about how to do
            // that, since it is essentially a quick trip into kernel mode.
            //

#if DBG
            DbgPrint( "KSEC: Callback not allowed\n" );
#endif 
            Send = Receive ;

            pReceiveBuffer->ApiMessage.scRet = SEC_E_NOT_SUPPORTED ;

        }
        else 
        {
            break;
        }
    } while ( TRUE  );

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   CreateConnection()
//
//  Synopsis:   Creates a connection record to the SPM
//
//  Effects:    Creates an LPC port in the context of the calling FSP
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    phConnect   - handle to a connection
//
//              STATUS_INSUFFICIENT_RESOURCES   - out of connection records
//              SEC_E_NO_SPM                    - Cannot connect to SPM
//
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
CreateConnection(
    PSTR     LogonProcessName,
    ULONG    ClientMode,
    HANDLE * phConnect,
    ULONG *  PackageCount,
    ULONG *  OperationalMode
    )
{
    SECURITY_STATUS scRet;
    NTSTATUS Status ;
    HANDLE          hPort;
    LSAP_AU_REGISTER_CONNECT_INFO_EX ConnectMessage;
    ULONG           cbConnect = sizeof(LSAP_AU_REGISTER_CONNECT_INFO);
    PLSAP_AU_REGISTER_CONNECT_RESP Resp;
    OBJECT_ATTRIBUTES           PortObjAttr;
    UNICODE_STRING              ucsPortName;
    SECURITY_QUALITY_OF_SERVICE sQOS;
    ULONG                       cbMaxMessage;
    PVOID Port, SecurityPort ;

    SEC_PAGED_CODE();

    DebugLog((DEB_TRACE,"KSec:  CreateConnection\n" ));

    //
    // Zero this buffer to create an untrusted connection.
    //

    RtlZeroMemory(
        &ConnectMessage,
        sizeof(ConnectMessage)
        );

    if ( LogonProcessName )
    {
        ConnectMessage.LogonProcessNameLength = strlen( LogonProcessName );
        if ( ConnectMessage.LogonProcessNameLength >
                LSAP_MAX_LOGON_PROC_NAME_LENGTH )
        {
            ConnectMessage.LogonProcessNameLength = LSAP_MAX_LOGON_PROC_NAME_LENGTH ;
        }

        strncpy( ConnectMessage.LogonProcessName,
                 LogonProcessName,
                 ConnectMessage.LogonProcessNameLength );

        ConnectMessage.ClientMode = ClientMode;
        cbConnect = sizeof(LSAP_AU_REGISTER_CONNECT_INFO_EX);
    }

    RtlInitUnicodeString( &ucsPortName, SPM_PORTNAME );

    //
    // TODO: LPC doesn't take this as an input parameter.
    //

    InitializeObjectAttributes(
        &PortObjAttr, 
        &ucsPortName, 
        OBJ_KERNEL_HANDLE, 
        NULL, 
        NULL);

    sQOS.ImpersonationLevel = SecurityImpersonation;
    sQOS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sQOS.EffectiveOnly = FALSE;

    scRet = ZwConnectPort(  phConnect,
                            &ucsPortName,
                            &sQOS,
                            NULL,
                            NULL,
                            &cbMaxMessage,
                            &ConnectMessage,
                            &cbConnect );

    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR,"KSec: LpcConnect to SPM Failed, %x \n",
                    scRet));

        scRet = SEC_E_INTERNAL_ERROR;
        goto Create_SafeExit;

    }

    Resp = (PLSAP_AU_REGISTER_CONNECT_RESP) &ConnectMessage ;

    if ( PackageCount )
    {
        *PackageCount = Resp->PackageCount;
    }

    if ( OperationalMode )
    {
        *OperationalMode = Resp->SecurityMode ;
    }

    DebugLog((DEB_TRACE,"KSec:  Connected process to SPMgr\n"));

    Status = ObReferenceObjectByHandle(
                *phConnect,
                PORT_ALL_ACCESS,
                NULL,
                KernelMode,
                &Port,
                NULL );


    //ZwClose( *phConnect );
    //
    // because LPC doesn't honor the OBJ_KERNEL_HANDLE flag, close it
    // with user disposition, to prevent a bad usermode application from
    // closing the handle in between the open above and the close.
    //

    ObCloseHandle( *phConnect, UserMode );

    *phConnect = NULL ;

    if ( !NT_SUCCESS( Status ) )
    {
        scRet = Status;
        goto Create_SafeExit;
    }


    //
    // We have a pointer to the port.  Set that as the process's security port,
    // and close the handle.  The ref keeps the port alive
    //

    ExAcquireFastMutex( &KsecConnectionMutex );

    SecurityPort = PsGetProcessSecurityPort( PsGetCurrentProcess() );

    if ( SecurityPort == NULL )
    {
        Status = PsSetProcessSecurityPort( PsGetCurrentProcess(), Port );
    }
    else if ( SecurityPort == (PVOID) 1 )
    {
        Status = STATUS_PROCESS_IS_TERMINATING;
    }
    else
    {
        Status = STATUS_OBJECT_NAME_COLLISION ;
    }

    ExReleaseFastMutex( &KsecConnectionMutex );

    if ( !NT_SUCCESS( Status ) )
    {
        //
        // Some other thread from this process already set the port.  Close this
        // reference
        //

        ObDereferenceObject( Port );

        if ( Status == STATUS_OBJECT_NAME_COLLISION )
        {
            Status = STATUS_OBJECT_NAME_EXISTS ;
        }

        scRet = Status;
    }


    // Safe, clean exit point:

Create_SafeExit:

    // return the set status code

    return( scRet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\driver\lsamem.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 2000
//
// File:        lsamem.cxx
//
// Contents:    Shared memory between ksec and lsa
//
//
// History:     7-19-00     Richardw    Created
//
//------------------------------------------------------------------------


#include "secpch2.hxx"

extern "C"
{
#include <zwapi.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include <spmlpcp.h>
#include "ksecdd.h"

}


//
// At this time, it is unlikely that we'd have more than one
// of these, but in the event that it becomes a high-demand
// list, having it in a structure should make it easier to 
// make per-processor.  
//

typedef struct _KSEC_LSA_MEMORY_CONTROL {
    LIST_ENTRY  List ;
    ULONG       Count ;
    ULONG       Present ;
    ULONG       HighWater ;
//    KEVENT      Block ;
    FAST_MUTEX  Lock ;
} KSEC_LSA_MEMORY_CONTROL, * PKSEC_LSA_MEMORY_CONTROL ;

#define KSEC_MAX_LSA_MEMORY_BLOCKS  1024

PKSEC_LSA_MEMORY_CONTROL LsaMemoryControl ;

NTSTATUS
KsecInitLsaMemory(
    VOID
    )
{
    NTSTATUS Status ;

    LsaMemoryControl = (PKSEC_LSA_MEMORY_CONTROL) ExAllocatePool( 
                            NonPagedPool, 
                            sizeof( KSEC_LSA_MEMORY_CONTROL ) );

    if ( !LsaMemoryControl )
    {
        return STATUS_NO_MEMORY ;
    }

    InitializeListHead( &LsaMemoryControl->List );
    Status = ExInitializeFastMutex( &LsaMemoryControl->Lock );

    if ( !NT_SUCCESS( Status ) )
    {
        ExFreePool( LsaMemoryControl );
        return Status ;
    }

    // KeInitializeEvent( &LsaMemoryControl->Block );
    LsaMemoryControl->Count = 0 ;
    LsaMemoryControl->HighWater = 0 ;
    LsaMemoryControl->Present = 0 ;

    return STATUS_SUCCESS ;


}


VOID
KsecpFreeLsaMemory(
    PKSEC_LSA_MEMORY LsaMemory,
    BOOLEAN Force
    )
{
    SIZE_T Size = 0 ;

    KeEnterCriticalRegion();
    ExAcquireFastMutex( &LsaMemoryControl->Lock );

    if ( LsaMemoryControl->Present * 2 > LsaMemoryControl->Count )
    {
        //
        // If the present count is half of the total count, dump 
        // this entry.
        //

        Force = TRUE ;
        
    }

    if ( !Force )
    {
        LsaMemoryControl->Present ++ ;
        InsertHeadList( &LsaMemoryControl->List, &LsaMemory->List );
    }
    else 
    {
        LsaMemoryControl->Count -- ;
    }

    ExReleaseFastMutex( &LsaMemoryControl->Lock );
    KeLeaveCriticalRegion();

    if ( Force )
    {
        ZwFreeVirtualMemory(
            KsecLsaProcessHandle,
            &LsaMemory->Region,
            &Size,
            MEM_RELEASE );

        ExFreePool( LsaMemory );
        
    }


}

PKSEC_LSA_MEMORY
KsecAllocLsaMemory(
    SIZE_T   Size
    )
{
    PKSEC_LSA_MEMORY LsaMemory = NULL ;
    PKSEC_LSA_MEMORY_HEADER Header ;
    PLIST_ENTRY Scan ;
    SIZE_T NewSize ;
    SIZE_T Reservation ;
    NTSTATUS Status ;
    KAPC_STATE ApcState ;

    if ( Size < 8192 )
    {
        Size = 8192 ;
    }

    if ( Size > 64 * 1024 )
    {
        return NULL ;
        
    }

    ASSERT( LsaMemoryControl );

    KeEnterCriticalRegion();
    ExAcquireFastMutex( &LsaMemoryControl->Lock );

    Scan = LsaMemoryControl->List.Flink ;

    while ( Scan != &LsaMemoryControl->List )
    {
        LsaMemory = CONTAINING_RECORD( Scan, KSEC_LSA_MEMORY, List );

        if ( LsaMemory->Commit >= Size )
        {
            RemoveEntryList( &LsaMemory->List );
            LsaMemoryControl->Present-- ;
            break;
        }

        LsaMemory = NULL ;

        Scan = Scan->Flink;

    }

    if ( LsaMemory == NULL )
    {
        if ( !IsListEmpty( &LsaMemoryControl->List ) )
        {
            Scan = RemoveHeadList( &LsaMemoryControl->List );
            LsaMemoryControl->Present-- ;
            LsaMemory = CONTAINING_RECORD( Scan, KSEC_LSA_MEMORY, List );
        }
    }


    if ( LsaMemory == NULL )
    {
        //
        // Still nothing there.  See if it is OK for us to allocate
        // another one.  

        if ( LsaMemoryControl->Count < KSEC_MAX_LSA_MEMORY_BLOCKS )
        {
            LsaMemory = (PKSEC_LSA_MEMORY) ExAllocatePool( PagedPool, 
                                    sizeof( KSEC_LSA_MEMORY ) );

            if ( LsaMemory )
            {
                LsaMemory->Commit = 0 ;
                LsaMemory->Size = 0 ;
                LsaMemory->Region = 0 ;

                LsaMemoryControl->Count ++ ;

                if ( LsaMemoryControl->Count > LsaMemoryControl->HighWater )
                {
                    LsaMemoryControl->HighWater = LsaMemoryControl->Count ;
                }
            }
        }
        else
        {
            //
            // In the future, we can use that block event in the
            // control structure to wait for to be returned to the
            // list.  However, the likelyhood of having all the 
            // requests outstanding is pretty slim.  We'll probably
            // get normal memory failures long before that.
            //

            NOTHING ;
        }


    }

    ExReleaseFastMutex( &LsaMemoryControl->Lock );
    KeLeaveCriticalRegion();

    if ( LsaMemory )
    {
        if ( LsaMemory->Commit < Size )
        {
            NewSize = Size ;

            if ( LsaMemory->Size < Size )
            {

                //
                // Need to make our reservation:
                //

                Reservation = 64 * 1024 ;  // 64K

                Status = ZwAllocateVirtualMemory(
                                KsecLsaProcessHandle,
                                &LsaMemory->Region,
                                0,
                                &Reservation,
                                MEM_RESERVE,
                                PAGE_NOACCESS );

                if ( NT_SUCCESS( Status ) )
                {
                    LsaMemory->Size = Reservation ;
                }

            }

            Status = ZwAllocateVirtualMemory(
                            KsecLsaProcessHandle,
                            &LsaMemory->Region,
                            0,
                            &NewSize,
                            MEM_COMMIT,
                            PAGE_READWRITE );

            if ( NT_SUCCESS( Status ) )
            {
                LsaMemory->Commit = NewSize ;
            }
            else
            {
                if ( LsaMemory->Region )
                {
                    KsecpFreeLsaMemory( LsaMemory, TRUE );
                }
                else
                {
                    ExFreePool( LsaMemory );
                }

                LsaMemory = NULL ;

            }
        }

        if ( LsaMemory )
        {
            //
            // Initialize the memory block for the LSA:
            //

            ASSERT( LsaMemory->Region != NULL );

            Header = (PKSEC_LSA_MEMORY_HEADER) LsaMemory->Region ;


            KeStackAttachProcess(
                (PRKPROCESS) KsecLsaProcess,
                &ApcState );

            __try {

                //
                // Initialize the structure in the LSA space.  This
                // protects the driver from bugs in the LSA process
                // stomping on the fields.  
                //

                Header->Commit = (ULONG) LsaMemory->Commit ;
                Header->Consumed = sizeof( KSEC_LSA_MEMORY_HEADER );
                Header->Preserve = (USHORT) Header->Consumed ;
                Header->Size = (ULONG) LsaMemory->Size ;
                Header->MapCount = 0 ;

                Status = STATUS_SUCCESS ;

            } 
            __except( EXCEPTION_EXECUTE_HANDLER )
            {
                //
                // An exception here indicates that the memory in user
                // mode is bad.  
                //

                Status = GetExceptionCode();

            }

            KeUnstackDetachProcess( &ApcState );

            if ( !NT_SUCCESS( Status ) )
            {
                KsecpFreeLsaMemory( LsaMemory, TRUE );

                LsaMemory = NULL ;
                
            }

            
        }

    }

    return LsaMemory ;

}


VOID
KsecFreeLsaMemory(
    PKSEC_LSA_MEMORY LsaMemory
    )
{
    if ( !LsaMemory )
    {
        DebugLog((DEB_TRACE, " KsecFreeLsaMemory called with NULL\n" ));
        return;
    }

    KsecpFreeLsaMemory( LsaMemory, FALSE );

}


NTSTATUS
KsecCopyPoolToLsa(
    PKSEC_LSA_MEMORY LsaMemory,
    SIZE_T LsaOffset,
    PVOID Pool,
    SIZE_T PoolSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS ;
    KAPC_STATE ApcState ;
    PKSEC_LSA_MEMORY_HEADER Header ;

    ASSERT( LsaOffset < LsaMemory->Commit );
    ASSERT( LsaOffset < LsaMemory->Size );
    ASSERT( PoolSize < LsaMemory->Commit );

    KeStackAttachProcess(
        (PRKPROCESS) KsecLsaProcess,
        &ApcState );

    __try {

        RtlCopyMemory(
            (PUCHAR) LsaMemory->Region + LsaOffset,
            Pool,
            PoolSize );

        Header = (PKSEC_LSA_MEMORY_HEADER) LsaMemory->Region ;
        if ( Header->MapCount < KSEC_LSA_MAX_MAPS )
        {
            Header->PoolMap[ Header->MapCount ].Offset = (USHORT) LsaOffset;
            Header->PoolMap[ Header->MapCount ].Size = (USHORT) PoolSize ;
            Header->PoolMap[ Header->MapCount ].Pool = Pool ;
            Header->MapCount++ ;
            
        }

    } 
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        // An exception here indicates that the memory in user
        // mode is bad.  
        //

        Status = GetExceptionCode();

    }

    KeUnstackDetachProcess( &ApcState );


    return Status ;

}

NTSTATUS
KsecCopyLsaToPool(
    PVOID Pool,
    PKSEC_LSA_MEMORY LsaMemory,
    PVOID LsaBuffer,
    SIZE_T Size
    )
{

    NTSTATUS Status = STATUS_SUCCESS ;
    KAPC_STATE ApcState ;
    ULONG LsaOffset ;
    PUCHAR Scratch ;

    LsaOffset = (ULONG) ((PUCHAR) LsaBuffer - (PUCHAR) LsaMemory->Region) ;

    ASSERT( LsaOffset < LsaMemory->Commit );
    ASSERT( LsaOffset < LsaMemory->Size );

    KeStackAttachProcess(
        (PRKPROCESS) KsecLsaProcess,
        &ApcState );

    __try {

        ASSERT( ((PKSEC_LSA_MEMORY_HEADER) LsaMemory->Region)->Size == LsaMemory->Size );

        //
        // Lsa can increase the committed LSA memory size
        //

        LsaMemory->Commit = ((PKSEC_LSA_MEMORY_HEADER) LsaMemory->Region)->Commit;

        ASSERT( Size < LsaMemory->Commit );

        RtlCopyMemory(
            Pool,
            LsaBuffer,
            Size );

    } 
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        // An exception here indicates that the memory in user
        // mode is bad.  
        //

        Status = GetExceptionCode();

    }

    KeUnstackDetachProcess( &ApcState );

    return Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\driver\ksecdd.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        KSECDD.H
//
// Contents:    Structures and defines for the security device driver
//
//
// History:     19 May 92,  RichardW    Created
//
//------------------------------------------------------------------------

#ifndef __KSECDD_H__
#define __KSECDD_H__

#if ( _X86_ )
#undef MM_USER_PROBE_ADDRESS

extern ULONG KsecUserProbeAddress ;

#define MM_USER_PROBE_ADDRESS KsecUserProbeAddress

#endif

#include <spseal.h>     // prototypes for seal & unseal
#include <lpcapi.h>

#include <des.h>
#include <modes.h>
#include <md5.h>

typedef struct _SEC_BUILTIN_KPACKAGE {
    PSECPKG_KERNEL_FUNCTION_TABLE   Table;
    PUNICODE_STRING Name;
    ULONG_PTR PackageId;
} SEC_BUILTIN_KPACKAGE, * PSEC_BUILTIN_KPACKAGE;

extern SEC_BUILTIN_KPACKAGE    KsecBuiltinPackages[];

extern PEPROCESS KsecLsaProcess ;
extern HANDLE KsecLsaProcessHandle ;

extern KEVENT KsecConnectEvent ;

// Prototypes:

NTSTATUS
LpcConnect( PWSTR           pszPortName,
            PVOID           pConnect,
            PULONG          cbConnect,
            HANDLE *        phPort);

NTSTATUS
LpcClose(   HANDLE      hPort);

NTSTATUS
CreateSyncEvent(
    VOID
    );

NTSTATUS
OpenSyncEvent(
    HANDLE *  phEvent
    );

SECURITY_STATUS SEC_ENTRY
DeleteUserModeContext(
    IN PCtxtHandle phContext,           // Contxt to delete
    OUT PCtxtHandle phLsaContext
    );

SECURITY_STATUS SEC_ENTRY
InitUserModeContext(
    IN PCtxtHandle                 phContext,      // Contxt to init
    IN PSecBuffer                  pContextBuffer,
    OUT PCtxtHandle                phNewContext
    );

SECURITY_STATUS SEC_ENTRY
MapKernelContextHandle(
    IN PCtxtHandle phContext,           // Contxt to map
    OUT PCtxtHandle phLsaContext
    );

SECURITY_STATUS
InitializePackages(
    ULONG PackageCount );

//
// Lsa memory handling routines:
//

//
// Structure defining a memory chunk available for ksec to use
// in handling a request from kernel mode
//
typedef struct _KSEC_LSA_MEMORY {
    LIST_ENTRY  List ;
    PVOID       Region ;            // Region in memory
    SIZE_T      Size ;              // Size of region (never exceeds 64K)
    SIZE_T      Commit ;
} KSEC_LSA_MEMORY, * PKSEC_LSA_MEMORY ;

#define KsecLsaMemoryToContext( p ) \
        ( ( (PKSEC_LSA_MEMORY) p)->Region)

#define KsecIsBlockInLsa( LsaMem, Block ) \
    ( ((LsaMem != NULL ) && (Block != NULL )) ? (((ULONG_PTR) (LsaMem->Region) ^ (ULONG_PTR) Block ) < (ULONG_PTR) LsaMem->Commit) : FALSE )
    

#define SECBUFFER_TYPE( x ) \
    ( (x) & (~ SECBUFFER_ATTRMASK ) )

NTSTATUS
KsecInitLsaMemory(
    VOID
    );

PKSEC_LSA_MEMORY
KsecAllocLsaMemory(
    SIZE_T   Size
    );

VOID
KsecFreeLsaMemory(
    PKSEC_LSA_MEMORY LsaMemory
    );

NTSTATUS
KsecCopyPoolToLsa(
    PKSEC_LSA_MEMORY LsaMemory,
    SIZE_T LsaOffset,
    PVOID Pool,
    SIZE_T PoolSize
    );

NTSTATUS
KsecCopyLsaToPool(
    PVOID Pool,
    PKSEC_LSA_MEMORY LsaMemory,
    PVOID LsaBuffer,
    SIZE_T Size
    );

SECURITY_STATUS
KsecQueryContextAttributes(
    IN PCtxtHandle  phContext,
    IN ULONG        Attribute,
    IN OUT PVOID    Buffer,
    IN PVOID        Extra,
    IN ULONG        ExtraLength
    );

#ifdef KSEC_LEAK_TRACKING

VOID
UninitializePackages(
    VOID );

#endif  // KSEC_LEAK_TRACKING

void SEC_ENTRY
SecFree(PVOID pvMemory);

//
//  Global Locks
//

extern FAST_MUTEX KsecPackageLock;
extern FAST_MUTEX KsecPageModeMutex ;
extern FAST_MUTEX KsecConnectionMutex ;

#define KSecLockPackageList()   (ExAcquireFastMutex( &KsecPackageLock ))
#define KSecUnlockPackageList() (ExReleaseFastMutex( &KsecPackageLock ))

//
// Macro to map package index to table
//

#define KsecPackageIndex(_x_) (_x_)

// Global Variables:
extern  KSPIN_LOCK  ConnectSpinLock;

ULONG
KsecInitializePackageList(
    VOID );

VOID * SEC_ENTRY
SecAllocate(ULONG cbMemory);

VOID
SecFree(
    IN PVOID Base
    );

#ifndef _NTIFS_
#ifdef POOL_TAGGING
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a, b, 'cesK')
#define ExAllocatePoolWithQuota(a,b)    ExAllocatePoolWithQuotaTag(a, b, 'cesK')
#endif
#endif 

#if DBG
#define DebugStmt(x) x
#else
#define DebugStmt(x)
#endif

SECURITY_STATUS SEC_ENTRY
DeleteSecurityContextDefer(
    PCtxtHandle     phContext);

SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandleDefer(
    PCredHandle     phCredential);

SECURITY_STATUS SEC_ENTRY
DeleteSecurityContextInternal(
    BOOLEAN     DeletePrivateContext,
    PCtxtHandle                 phContext          // Context to delete
    );

SECURITY_STATUS 
SEC_ENTRY
FreeCredentialsHandleInternal(
    PCredHandle                 phCredential        // Handle to free
    );

NTSTATUS
NTAPI
KsecEncryptMemoryInitialize(
    VOID
    );

VOID
KsecEncryptMemoryShutdown(
    VOID
    );

NTSTATUS
NTAPI
KsecEncryptMemory(
    IN PVOID pMemory,
    IN ULONG cbMemory,
    IN int Operation,
    IN ULONG Option
    );

#endif // __KSECDD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\driver\support.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        support.cxx
//
// Contents:    support routines for ksecdd.sys
//
//
// History:     3-7-94      Created     MikeSw
//
//------------------------------------------------------------------------

#include "secpch2.hxx"
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "ksecdd.h"
#include "connmgr.h"
}

//
// Global Variables:
//

//
// Use local RPC for all SPM communication
//

WCHAR       szLsaEvent[] = SPM_EVENTNAME;

SecurityFunctionTable   SecTable = {SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
                                    EnumerateSecurityPackages,
                                    NULL, // LogonUser,
                                    AcquireCredentialsHandle,
                                    FreeCredentialsHandle,
                                    NULL, // QueryCredentialAttributes,
                                    InitializeSecurityContext,
                                    AcceptSecurityContext,
                                    CompleteAuthToken,
                                    DeleteSecurityContext,
                                    ApplyControlToken,
                                    QueryContextAttributes,
                                    ImpersonateSecurityContext,
                                    RevertSecurityContext,
                                    MakeSignature,
                                    VerifySignature,
                                    FreeContextBuffer,
                                    NULL, // QuerySecurityPackageInfo
                                    SealMessage,
                                    UnsealMessage,
                                    ExportSecurityContext,
                                    ImportSecurityContextW,
                                    NULL,                       // reserved7
                                    NULL,                       // reserved8
                                    QuerySecurityContextToken,
                                    SealMessage,
                                    UnsealMessage
                                   };


//+-------------------------------------------------------------------------
//
//  Function:   SecAllocate
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID * SEC_ENTRY
SecAllocate(ULONG cbMemory)
{
    ULONG_PTR Size = cbMemory;
    NTSTATUS scRet;
    PVOID  Buffer = NULL;
    scRet = ZwAllocateVirtualMemory(
                NtCurrentProcess(),
                &Buffer,
                0L,
                &Size,
                MEM_COMMIT,
                PAGE_READWRITE
                );
    if (!NT_SUCCESS(scRet))
    {
        return(NULL);
    }
    return(Buffer);
}


//+-------------------------------------------------------------------------
//
//  Function:   SecFree
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

void SEC_ENTRY
SecFree(PVOID pvMemory)
{
    ULONG_PTR Length = 0;

    if ( (ULONG_PTR) pvMemory < MM_USER_PROBE_ADDRESS )
    {
        (VOID) ZwFreeVirtualMemory(
                     NtCurrentProcess(),
                     &pvMemory,
                     &Length,
                     MEM_RELEASE
                     );
    }
    else
    {
        ExFreePool( pvMemory );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   IsOkayToExec
//
//  Synopsis:   Determines if it is okay to make a call to the SPM
//
//  Effects:    Binds if necessary to the SPM
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS
IsOkayToExec( PClient * ppClient )
{
    SECURITY_STATUS scRet;

    UNREFERENCED_PARAMETER( ppClient );

    if (NT_SUCCESS(LocateClient()))
    {
        return(STATUS_SUCCESS);
    }

    scRet = CreateClient(TRUE);

    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   InitSecurityInterface
//
//  Synopsis:   returns function table of all the security function and,
//              more importantly, create a client session.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

PSecurityFunctionTable SEC_ENTRY
InitSecurityInterface(void)
{
    SECURITY_STATUS scRet;

    scRet = IsOkayToExec( NULL );

    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR, "Failed to init security interface: 0x%x\n", scRet));
        return(NULL);
    }

    SecpSetSession( SETSESSION_ADD_WORKQUEUE,
                    NULL,
                    NULL,
                    NULL );

    //
    // Do not free the client - this allows it to stay around while not
    // in use.
    //

    return(&SecTable);
}


//+-------------------------------------------------------------------------
//
//  Function:   MapSecurityError
//
//  Synopsis:   maps a HRESULT from the security interface to a NTSTATUS
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS SEC_ENTRY
MapSecurityError(SECURITY_STATUS Error)
{
    NTSTATUS Status;

    Status = RtlMapSecurityErrorToNtStatus( Error );

    // Apparently CreateFileW returns STATUS_INVALID_PARAMTER. Need to figure
    // out why that's happening.
    // If a previous ASSERT just fired (and was ignored) inside the LSA,
    // contact sfield & sethur to look at this issue.  A double assert
    // indicates RDR passed in a bad buffer, likely a buffer formatted by
    // the nego package, and passed directly into the NTLM package, or vice-versa
    //

    ASSERT(Status != STATUS_INVALID_PARAMETER);
    ASSERT(Status != STATUS_BUFFER_TOO_SMALL);

#ifdef DBG

    //
    // humm, not mapped? contact LZhu
    //

    if ((Error == Status) && !NT_SUCCESS(Status)) 
    {
        DebugLog((DEB_ERROR, "MapSecurityError unexpected status: %#x\n", Status));
    }

#endif

    return(Status);
}


//+---------------------------------------------------------------------------
//
//  Function:   SecLookupAccountSid
//
//  Synopsis:   Kernel interface for translating a SID to a name
//
//  Arguments:  [Sid]        -- 
//              [NameSize]   -- 
//              [NameBuffer] -- 
//              [OPTIONAL]   -- 
//              [OPTIONAL]   -- 
//              [NameUse]    -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

NTSTATUS
SEC_ENTRY
SecLookupAccountSid(
    IN PSID Sid,
    IN OUT PULONG NameSize,
    OUT PUNICODE_STRING NameBuffer,
    IN OUT OPTIONAL PULONG DomainSize,
    OUT OPTIONAL PUNICODE_STRING DomainBuffer,
    OUT PSID_NAME_USE NameUse
    )
{
    UNICODE_STRING NameString = { 0 };
    UNICODE_STRING DomainString = { 0 };
    PUNICODE_STRING Name ;
    PUNICODE_STRING Domain ;
    NTSTATUS Status ;
    PKSEC_LSA_MEMORY LsaMemory ;

    NameString = *NameBuffer ;
    Name = &NameString ;

    if ( DomainBuffer )
    {
        DomainString = *DomainBuffer ;
    }

    Domain = &DomainString ;

    LsaMemory = KsecAllocLsaMemory( 1024 );

    if ( !LsaMemory )
    {
        return STATUS_NO_MEMORY ;
    }

    Status = SecpLookupAccountSid(
                KsecLsaMemoryToContext( LsaMemory ),
                Sid,
                Name,
                NameSize,
                Domain,
                DomainSize,
                NameUse );

    if ( NT_SUCCESS( Status ) )
    {
        if ( Name->Buffer != NameBuffer->Buffer )
        {
            Status = KsecCopyLsaToPool(
                NameBuffer->Buffer,
                LsaMemory,
                Name->Buffer,
                Name->Length );
        }

        NameBuffer->Length = Name->Length ;

        if ( DomainBuffer )
        {
            if ( Domain->Buffer != DomainBuffer->Buffer )
            {
                Status = KsecCopyLsaToPool(
                    DomainBuffer->Buffer,
                    LsaMemory,
                    Domain->Buffer,
                    Domain->Length );
            }

            DomainBuffer->Length = Domain->Length ;
        }
    }

    KsecFreeLsaMemory( LsaMemory );

    return Status ;
}


//+---------------------------------------------------------------------------
//
//  Function:   SecLookupAccountName
//
//  Synopsis:   
//
//  Arguments:  [Name]     -- 
//              [SidSize]  -- 
//              [Sid]      -- 
//              [NameUse]  -- 
//              [OPTIONAL] -- 
//              [OPTIONAL] -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

NTSTATUS
SEC_ENTRY
SecLookupAccountName(
    IN PUNICODE_STRING Name,
    IN OUT PULONG SidSize,
    OUT PSID Sid,
    OUT PSID_NAME_USE NameUse,
    IN OUT OPTIONAL PULONG DomainSize,
    OUT OPTIONAL PUNICODE_STRING ReferencedDomain 
    )
{
    UNICODE_STRING DomainString = { 0 };
    PUNICODE_STRING Domain ;
    NTSTATUS Status ;

    if ( ReferencedDomain )
    {
        if ( ReferencedDomain->MaximumLength > 0 )
        {
            Domain = ReferencedDomain ;
        }
        else
        {
            Domain = &DomainString ;
        }
    }
    else
    {
        Domain = &DomainString;
    }

    Status = SecpLookupAccountName(
                Name,
                Domain,
                DomainSize,
                SidSize,
                Sid,
                NameUse );

    return Status ;
}

    
NTSTATUS
NTAPI
SecLookupWellKnownSid(
    IN WELL_KNOWN_SID_TYPE SidType,
    OUT PSID Sid,
    IN ULONG SidBufferSize,
    IN OUT OPTIONAL PULONG SidSize
    )
{
    PSID LocalSid = NULL ;
    ULONG LocalSidSize ;
    NTSTATUS Status ;

    switch ( SidType )
    {
        case WinNullSid:
            LocalSid = SeExports->SeNullSid ;
            break;
        
        case WinWorldSid:
            LocalSid = SeExports->SeWorldSid ;
            break;

        case WinLocalSid:
            LocalSid = SeExports->SeLocalSid ;
            break;

        case WinCreatorOwnerSid:
            LocalSid = SeExports->SeCreatorOwnerSid ;
            break;

        case WinCreatorGroupSid:
            LocalSid = SeExports->SeCreatorGroupSid ;
            break;

        case WinNtAuthoritySid:
            LocalSid = SeExports->SeNtAuthoritySid ;
            break;

        case WinDialupSid:
            LocalSid = SeExports->SeDialupSid ;
            break;

        case WinNetworkSid:
            LocalSid = SeExports->SeNetworkSid ;
            break;

        case WinBatchSid:
            LocalSid = SeExports->SeBatchSid ;
            break;

        case WinInteractiveSid:
            LocalSid = SeExports->SeInteractiveSid ;
            break;

        case WinAnonymousSid:
            LocalSid = SeExports->SeAnonymousLogonSid ;
            break;

        case WinAuthenticatedUserSid:
            LocalSid = SeExports->SeAuthenticatedUsersSid ;
            break;

        case WinRestrictedCodeSid:
            LocalSid = SeExports->SeRestrictedSid ;
            break;

        case WinLocalSystemSid:
            LocalSid = SeExports->SeLocalSystemSid ;
            break;

        case WinLocalServiceSid:
            LocalSid = SeExports->SeLocalServiceSid ;
            break;

        case WinNetworkServiceSid:
            LocalSid = SeExports->SeNetworkServiceSid ;
            break;

        case WinBuiltinAdministratorsSid:
            LocalSid = SeExports->SeAliasAdminsSid ;
            break;

        case WinBuiltinUsersSid:
            LocalSid = SeExports->SeAliasUsersSid ;
            break;

        case WinBuiltinGuestsSid:
            LocalSid = SeExports->SeAliasGuestsSid ;
            break;

        case WinBuiltinPowerUsersSid:
            LocalSid = SeExports->SeAliasPowerUsersSid ;
            break;

        case WinBuiltinAccountOperatorsSid:
            LocalSid = SeExports->SeAliasAccountOpsSid ;
            break;

        case WinBuiltinSystemOperatorsSid:
            LocalSid = SeExports->SeAliasSystemOpsSid ;
            break;

        case WinBuiltinPrintOperatorsSid:
            LocalSid = SeExports->SeAliasPrintOpsSid ;
            break;

        case WinBuiltinBackupOperatorsSid:
            LocalSid = SeExports->SeAliasBackupOpsSid ;
            break;

        default:
            LocalSid = NULL ;
            break;
    }

    if ( LocalSid )
    {
        LocalSidSize = RtlLengthSid( LocalSid );

        if ( LocalSidSize <= SidBufferSize )
        {
            RtlCopyMemory( Sid, LocalSid, LocalSidSize );

            Status = STATUS_SUCCESS ;
        }
        else 
        {
            Status = STATUS_BUFFER_TOO_SMALL ;
        }

        if ( SidSize )
        {
            *SidSize = LocalSidSize ;
        }
    }
    else 
    {
        Status = SecpLookupWellKnownSid( SidType, Sid, SidBufferSize, SidSize );
    }

    return Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\driver\spn.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1999
//
// File:        spn.cxx
//
// Contents:    SPN Construction for kernel mode
//
// History:     2/10/99      RichardW    Created
//
//------------------------------------------------------------------------
#include "secpch2.hxx"
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "ksecdd.h"
#include "connmgr.h"

}

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SecMakeSPN )
#endif 

NTSTATUS
NTAPI
SecMakeSPNEx(
    IN PUNICODE_STRING ServiceClass,
    IN PUNICODE_STRING ServiceName,
    IN PUNICODE_STRING InstanceName OPTIONAL,
    IN USHORT InstancePort OPTIONAL,
    IN PUNICODE_STRING Referrer OPTIONAL,
    IN PUNICODE_STRING TargetInfo OPTIONAL,
    IN OUT PUNICODE_STRING Spn,
    OUT PULONG TotalSize OPTIONAL,
    IN BOOLEAN Allocate
    )
{
    SIZE_T TotalLength ;
    UNICODE_STRING Instance = { 0 };
    WCHAR InstanceBuffer[ 10 ];
    NTSTATUS Status ;
    UNICODE_STRING SPN = { 0 };
    PWSTR Where ;

    TotalLength = ServiceClass->Length +
                  ServiceName->Length +
                  2 * sizeof( WCHAR );

    if ( InstancePort )
    {
        Instance.Buffer = InstanceBuffer ;
        Instance.Length = 0 ;
        Instance.MaximumLength = sizeof( InstanceBuffer );

        Status = RtlIntegerToUnicodeString(
                        (ULONG) InstancePort,
                        10,
                        &Instance );

        if ( !NT_SUCCESS( Status ) )
        {
            return Status ;
        }

        TotalLength += Instance.Length + 2 * sizeof(WCHAR) ;
    }

    if ( InstanceName )
    {
        TotalLength += InstanceName->Length + 2 * sizeof( WCHAR );
    }

    if ( TargetInfo )
    {
        TotalLength += TargetInfo->Length + sizeof( WCHAR );
        
    }

    if ( TotalLength > 65535 )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    if ( TotalSize )
    {
        *TotalSize = (ULONG) TotalLength ;
    }

    if ( Allocate )
    {
        SPN.Buffer = (PWSTR) ExAllocatePool( PagedPool, TotalLength );

        if ( SPN.Buffer )
        {
            SPN.MaximumLength = (USHORT) TotalLength;
        }
        else
        {
            return STATUS_NO_MEMORY ;
        }
    }
    else 
    {
        if ( (Spn == NULL) ||
             ( Spn->MaximumLength < (USHORT) TotalLength ) )
        {
            return STATUS_BUFFER_OVERFLOW ;
        }

        SPN = *Spn ;
    }

    //
    // Now construct the SPN
    //

    Where = SPN.Buffer ;

    RtlCopyMemory(
        Where,
        ServiceClass->Buffer,
        ServiceClass->Length );

    Where += ServiceClass->Length / sizeof( WCHAR );

    *Where++ = L'/';

    if ( InstanceName )
    {
        RtlCopyMemory(
            Where,
            InstanceName->Buffer,
            InstanceName->Length );

        Where += InstanceName->Length / sizeof( WCHAR );

        if ( InstancePort )
        {
            *Where++ = L':';

            RtlCopyMemory(
                Where,
                Instance.Buffer,
                Instance.Length );

            Where += Instance.Length / sizeof( WCHAR );
        }

        *Where++ = L'/';
    }

    //
    // Now the service name:
    //

    RtlCopyMemory(
        Where,
        ServiceName->Buffer,
        ServiceName->Length );

    Where += ServiceName->Length / sizeof( WCHAR );

    if ( TargetInfo )
    {
        RtlCopyMemory(
            Where,
            TargetInfo->Buffer,
            TargetInfo->Length );

        Where += TargetInfo->Length / sizeof( WCHAR );
        
    }

    SPN.Length = (USHORT) ((Where - SPN.Buffer) * sizeof( WCHAR ));

    *Where++ = L'\0';

    *Spn = SPN ;

    return STATUS_SUCCESS ;

}

NTSTATUS
NTAPI
SecMakeSPN(
    IN PUNICODE_STRING ServiceClass,
    IN PUNICODE_STRING ServiceName,
    IN PUNICODE_STRING InstanceName OPTIONAL,
    IN USHORT InstancePort OPTIONAL,
    IN PUNICODE_STRING Referrer OPTIONAL,
    IN OUT PUNICODE_STRING Spn,
    OUT PULONG TotalSize OPTIONAL,
    IN BOOLEAN Allocate
    )
{

    return SecMakeSPNEx(
                ServiceClass,
                ServiceName,
                InstanceName,
                InstancePort,
                Referrer,
                NULL,
                Spn,
                TotalSize,
                Allocate );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\driver\negapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        krnlapi.cxx
//
// Contents:    Kernel-mode APIs to the NTLM package
//
//
// History:     07-Sep-1996   Created         ChandanS
//
//------------------------------------------------------------------------
#include "secpch2.hxx"
#pragma hdrstop
//
// Make these extern "C" to allow them to be pageable.
//

extern "C"
{
#include "spmlpc.h"
#include "ksecdd.h"
KspInitPackageFn       NegInitKernelPackage;
KspDeleteContextFn     NegDeleteKernelContext;
KspInitContextFn       NegInitKernelContext;
KspMapHandleFn         NegMapKernelHandle;
KspMakeSignatureFn     NegMakeSignature;
KspVerifySignatureFn   NegVerifySignature;
KspSealMessageFn       NegSealMessage;
KspUnsealMessageFn     NegUnsealMessage;
KspGetTokenFn          NegGetContextToken;
KspQueryAttributesFn   NegQueryContextAttributes;
KspCompleteTokenFn     NegCompleteToken;
KspSetPagingModeFn     NegSetPagingMode;
SpExportSecurityContextFn   NegExportContext;
SpImportSecurityContextFn   NegImportContext;
}

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NegInitKernelPackage)
#pragma alloc_text(PAGE, NegDeleteKernelContext)
#pragma alloc_text(PAGE, NegInitKernelContext)
#pragma alloc_text(PAGE, NegMapKernelHandle)
#pragma alloc_text(PAGEMSG, NegMakeSignature)
#pragma alloc_text(PAGEMSG, NegVerifySignature)
#pragma alloc_text(PAGEMSG, NegSealMessage)
#pragma alloc_text(PAGEMSG, NegUnsealMessage)
#pragma alloc_text(PAGEMSG, NegGetContextToken)
#pragma alloc_text(PAGEMSG, NegQueryContextAttributes)
#pragma alloc_text(PAGE, NegCompleteToken)
#pragma alloc_text(PAGE, NegExportContext)
#pragma alloc_text(PAGE, NegImportContext)
#endif

SECPKG_KERNEL_FUNCTION_TABLE NegFunctionTable = {
    NegInitKernelPackage,
    NegDeleteKernelContext,
    NegInitKernelContext,
    NegMapKernelHandle,
    NegMakeSignature,
    NegVerifySignature,
    NegSealMessage,
    NegUnsealMessage,
    NegGetContextToken,
    NegQueryContextAttributes,
    NegCompleteToken,
    NULL,
    NULL,
    NegSetPagingMode
};



//+-------------------------------------------------------------------------
//
//  Function:   NegInitKernelPackage
//
//  Synopsis:   Initialize an instance of the NtLm package in
//              a client's (kernel) address space
//
//  Arguments:  None
//
//  Returns:    STATUS_SUCCESS or
//              returns from ExInitializeResource
//
//  Notes:      we do what was done in SpInstanceInit()
//              from security\msv_sspi\userapi.cxx
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NegInitKernelPackage(
    IN PSECPKG_KERNEL_FUNCTIONS KernelFunctions
    )
{
    return(STATUS_SUCCESS);
}



//+-------------------------------------------------------------------------
//
//  Function:   NegDeleteKernelContext
//
//  Synopsis:   Deletes a kernel mode context by unlinking it and then
//              dereferencing it.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Kernel context handle of the context to delete
//              LsaContextHandle    - The Lsa mode handle
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, STATUS_INVALID_HANDLE if the
//              context can't be located
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NegDeleteKernelContext(
    IN ULONG_PTR KernelContextHandle,
    OUT PULONG_PTR LsaContextHandle
    )
{
    *LsaContextHandle = KernelContextHandle;
    return(STATUS_SUCCESS);
}



//+-------------------------------------------------------------------------
//
//  Function:   NegInitKernelContext
//
//  Synopsis:   Creates a kernel-mode context from a packed LSA mode context
//
//  Arguments:  LsaContextHandle - Lsa mode context handle for the context
//              PackedContext - A marshalled buffer containing the LSA
//                  mode context.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
NegInitKernelContext(
    IN ULONG_PTR LsaContextHandle,
    IN PSecBuffer PackedContext,
    OUT PULONG_PTR NewContextHandle
    )
{
    *NewContextHandle = LsaContextHandle;
    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   NegMapKernelHandle
//
//  Synopsis:   Maps a kernel handle into an LSA handle
//
//  Arguments:  KernelContextHandle - Kernel context handle of the context to map
//              LsaContextHandle - Receives LSA context handle of the context
//                      to map
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
NegMapKernelHandle(
    IN ULONG_PTR KernelContextHandle,
    OUT PULONG_PTR LsaContextHandle
    )
{
    *LsaContextHandle = KernelContextHandle;
    return (STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   NegMakeSignature
//
//  Synopsis:   Signs a message buffer by calculatinga checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleSignMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NegMakeSignature(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Function:   NegVerifySignature
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleVerifyMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------



NTSTATUS NTAPI
NegVerifySignature(
    IN ULONG_PTR KernelContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


//+-------------------------------------------------------------------------
//
//  Function:   NegSealMessage
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleSealMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
NegSealMessage(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Function:   NegUnsealMessage
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleUnsealMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NegUnsealMessage(
    IN ULONG_PTR KernelContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}



//+-------------------------------------------------------------------------
//
//  Function:   NegGetContextToken
//
//  Synopsis:   returns a pointer to the token for a server-side context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NegGetContextToken(
    IN ULONG_PTR KernelContextHandle,
    OUT PHANDLE ImpersonationToken,
    OUT OPTIONAL PACCESS_TOKEN *RawToken
    )
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}



//+-------------------------------------------------------------------------
//
//  Function:   NegQueryContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//              This API allows a customer of the security
//              services to determine certain attributes of
//              the context.  These are: sizes, names, and lifespan.
//
//  Effects:
//
//  Arguments:
//
//    ContextHandle - Handle to the context to query.
//
//    Attribute - Attribute to query.
//
//        #define SECPKG_ATTR_SIZES    0
//        #define SECPKG_ATTR_NAMES    1
//        #define SECPKG_ATTR_LIFESPAN 2
//
//    Buffer - Buffer to copy the data into.  The buffer must
//             be large enough to fit the queried attribute.
//
//
//  Requires:
//
//  Returns:
//
//        STATUS_SUCCESS - Call completed successfully
//
//        STATUS_INVALID_HANDLE -- Credential/Context Handle is invalid
//        STATUS_UNSUPPORTED_FUNCTION -- Function code is not supported
//
//  Notes:
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NegQueryContextAttributes(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG Attribute,
    IN OUT PVOID Buffer
    )
{
    CtxtHandle TempHandle;
    NTSTATUS Status ;
    SecPkgContext_NegotiationInfoW NegInfo ;
    PSecPkgInfoW PackageInfo = NULL ;
    PVOID BufferSave = Buffer ;
    ULONG ExtraSize = 0 ;


    TempHandle.dwLower = KsecBuiltinPackages[0].PackageId;
    TempHandle.dwUpper = KernelContextHandle;


    if ( Attribute == SECPKG_ATTR_NEGOTIATION_INFO )
    {
        PackageInfo = (PSecPkgInfoW) ExAllocatePool( PagedPool, sizeof( SecPkgInfoW ) );

        if ( !PackageInfo )
        {
            return STATUS_NO_MEMORY ;
        }

        ExtraSize = sizeof( SecPkgInfoW );

        Buffer = &NegInfo ;
        NegInfo.PackageInfo = PackageInfo ;
    }

    Status = KsecQueryContextAttributes(
                &TempHandle,
                Attribute,
                Buffer,
                PackageInfo,
                ExtraSize );

    if ( NT_SUCCESS( Status ) )
    {
        if ( Attribute == SECPKG_ATTR_NEGOTIATION_INFO )
        {
            RtlCopyMemory( BufferSave, Buffer, sizeof( NegInfo ) );
        }
    }
    else
    {
        if ( Attribute == SECPKG_ATTR_NEGOTIATION_INFO )
        {
            ExFreePool( PackageInfo );
        }
    }

    return Status ;

}



//+-------------------------------------------------------------------------
//
//  Function:   NegCompleteToken
//
//  Synopsis:   Completes a context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NegCompleteToken(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc InputBuffer
    )
{
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
NTAPI
NegSetPagingMode(
    IN BOOLEAN Pagable
    )
{
    return STATUS_SUCCESS ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\driver\stubs.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        stubs.cxx
//
// Contents:    user-mode stubs for security API
//
//
// History:     3/5/94      MikeSw      Created
//
//------------------------------------------------------------------------
#include "secpch2.hxx"
#pragma hdrstop

extern "C"
{
#include <align.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include "ksecdd.h"
#include "connmgr.h"

SECURITY_STATUS SEC_ENTRY
DeleteSecurityContextInternal(
    BOOLEAN     DeletePrivateContext,
    PCtxtHandle phContext
    );

SECURITY_STATUS
KsecCaptureBufferDesc(
    PKSEC_LSA_MEMORY *LsaMemoryBlock,
    PBOOLEAN        Mapped,
    PUNICODE_STRING Target,
    PSecBufferDesc  InputBuffers,
    PSecBufferDesc  LocalBuffers,
    PUNICODE_STRING NewTarget
    );

SECURITY_STATUS
KsecUncaptureBufferDesc(
    PKSEC_LSA_MEMORY LsaMemory,
    BOOLEAN AllocMem,
    PSecBufferDesc CapturedBuffers,
    PSecBufferDesc SuppliedBuffers,
    PSecBuffer ContextData OPTIONAL
    );
}

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AcquireCredentialsHandle)
#pragma alloc_text(PAGE, AddCredentials)
#pragma alloc_text(PAGE, FreeCredentialsHandle)
#pragma alloc_text(PAGE, QueryCredentialsAttributes)
#pragma alloc_text(PAGE, InitializeSecurityContext)
#pragma alloc_text(PAGE, AcceptSecurityContext)
#pragma alloc_text(PAGE, DeleteSecurityContextInternal)
#pragma alloc_text(PAGE, DeleteSecurityContext)
#pragma alloc_text(PAGE, ApplyControlToken)
#pragma alloc_text(PAGE, EnumerateSecurityPackages)
#pragma alloc_text(PAGE, QuerySecurityPackageInfo)
#pragma alloc_text(PAGE, FreeContextBuffer)
#pragma alloc_text(PAGE, LsaGetLogonSessionData)
#pragma alloc_text(PAGE, LsaEnumerateLogonSessions)
#pragma alloc_text(PAGE, KsecCaptureBufferDesc)
#pragma alloc_text(PAGE, KsecUncaptureBufferDesc)
#endif

static LUID            lFake = {0, 0};
static SECURITY_STRING sFake = {0, 0, NULL};

//+-------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandle
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandle(
    PSECURITY_STRING            pssPrincipal,       // Name of principal
    PSECURITY_STRING            pssPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pvAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    SECURITY_STATUS scRet;
    SECURITY_STRING Principal;
    TimeStamp   OptionalTimeStamp;
    ULONG Flags ;
    PKSEC_LSA_MEMORY LsaMemory = NULL;
    ULONG AuthSize ;
    PVOID AuthData = NULL ;
    PVOID AuthDataParameter ;
    NTSTATUS Status ;

    PAGED_CODE();

    if (!pssPackageName)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    if (!pssPrincipal)
    {
        Principal = sFake;
    }

    Flags = 0;

    AuthDataParameter = pvAuthData ;

    if ( (ULONG_PTR) pvAuthData > MM_USER_PROBE_ADDRESS )
    {
        //
        // Got some data.  Let's copy it into a kmap buffer.
        // First, have the package serialize it:
        //

        Status = KSecSerializeWinntAuthData(
                    pvAuthData,
                    &AuthSize,
                    &AuthData );

        if ( NT_SUCCESS( Status ) )
        {
            LsaMemory = KsecAllocLsaMemory( AuthSize );

            if ( LsaMemory )
            {
                Status = KsecCopyPoolToLsa(
                                LsaMemory,
                                sizeof( KSEC_LSA_MEMORY_HEADER ),
                                AuthData,
                                AuthSize );

                if ( NT_SUCCESS( Status ) )
                {
                    AuthDataParameter = (PUCHAR) LsaMemory->Region + sizeof( KSEC_LSA_MEMORY_HEADER );
                    Flags |= SPMAPI_FLAG_KMAP_MEM ;
                }
            }
        }
    }

    scRet = SecpAcquireCredentialsHandle(
                (LsaMemory ? KsecLsaMemoryToContext( LsaMemory ) : NULL),
                (pssPrincipal ? pssPrincipal : &Principal),
                pssPackageName,
                fCredentialUse,
                (pvLogonId ? (PLUID) pvLogonId : &lFake),
                AuthDataParameter,
                pGetKeyFn,
                pvGetKeyArgument,
                phCredential,
                (ptsExpiry ? ptsExpiry : &OptionalTimeStamp),
                &Flags );

    if ( ( AuthData != NULL ) &&
         ( AuthData != pvAuthData ) )
    {
        ExFreePool( AuthData );
    }

    if ( LsaMemory )
    {
        KsecFreeLsaMemory( LsaMemory );
    }

    return(scRet);
}


//+---------------------------------------------------------------------------
//
//  Function:   AddCredentialsW
//
//  Synopsis:
//
//  Arguments:  [phCredential]     --
//              [pssPrincipal]     --
//              [pssPackageName]   --
//              [fCredentialUse]   --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [GetKey]           --
//              [pvGetKeyArgument] --
//              [GetKey]           --
//              [out]              --
//              [optional]         --
//              [optional]         --
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
AddCredentialsW(
    PCredHandle                 phCredential,
    PSECURITY_STRING            pssPrincipal,       // Name of principal
    PSECURITY_STRING            pssPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    SECURITY_STATUS scRet;
    SECURITY_STRING Principal;
    TimeStamp   OptionalTimeStamp;
    ULONG Flags ;

    PAGED_CODE();

    if (!pssPackageName)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    if (!pssPrincipal)
    {
        Principal = sFake;
    }

    Flags = 0;

    scRet = SecpAddCredentials(
                NULL,
                phCredential,
                (pssPrincipal ? pssPrincipal : &Principal),
                pssPackageName,
                fCredentialUse,
                pAuthData,
                pGetKeyFn,
                pvGetKeyArgument,
                (ptsExpiry ? ptsExpiry : &OptionalTimeStamp),
                &Flags );

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   FreeCredentialsHandleInternal
//
//  Synopsis:   Guts of freeing a handle
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
FreeCredentialsHandleInternal(
    PCredHandle                 phCredential        // Handle to free
    )
{
    NTSTATUS Status ;

    PAGED_CODE();

    Status = SecpFreeCredentialsHandle(SECP_DELETE_NO_BLOCK, phCredential);

    return Status ;
}


//+-------------------------------------------------------------------------
//
//  Function:   FreeCredentialsHandle
//
//  Synopsis:   Public interface.  If the process is terminating, the
//              handle will be stuck on a defered workitem list.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
FreeCredentialsHandle(
    PCredHandle     phCredential
    )
{
    NTSTATUS Status ;

    PAGED_CODE();

    Status = FreeCredentialsHandleInternal( phCredential );

    return Status ;
}


//+-------------------------------------------------------------------------
//
//  Function:   QueryCredentialsAttributes
//
//  Synopsis:   queries attributes for a credentials handle
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
QueryCredentialsAttributes(
    PCredHandle phCredential,
    ULONG ulAttribute,
    PVOID pBuffer
    )
{
    PAGED_CODE();

    return SEC_E_UNSUPPORTED_FUNCTION;

    UNREFERENCED_PARAMETER(phCredential);
    UNREFERENCED_PARAMETER(ulAttribute);
    UNREFERENCED_PARAMETER(pBuffer);

    #if 0

    //
    // we need to allocate LSA memory from ksecdd in order to receive output
    // from LSA, punt to Logonhorn
    //

    SECURITY_STATUS Status ;
    ULONG Allocs ;
    PVOID Buffers[ 8 ];

    Allocs = 0;

    Status = SecpQueryCredentialsAttributes(
                            phCredential,
                            ulAttribute,
                            pBuffer,
                            0,
                            &Allocs,
                            Buffers );

    return( Status );

    #endif
}


//+---------------------------------------------------------------------------
//
//  Function:   KsecCaptureBufferDesc
//
//  Synopsis:   Captures information about pool paramters into an LSA memory
//              block
//
//  Arguments:  [LsaMemoryBlock] --
//              [Mapped]         --
//              [Target]         --
//              [InputBuffers]   --
//              [LocalBuffers]   --
//              [NewTarget]      --
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
KsecCaptureBufferDesc(
    OUT PKSEC_LSA_MEMORY *LsaMemoryBlock,
    OUT PBOOLEAN        Mapped,
    IN OPTIONAL PUNICODE_STRING Target,
    IN OPTIONAL PSecBufferDesc  InputBuffers,
    IN OPTIONAL PSecBufferDesc  LocalBuffers,
    IN OPTIONAL PUNICODE_STRING NewTarget
    )
{
    ULONG i ;
    SIZE_T TotalSize ;
    SIZE_T CopyCount ;
    PKSEC_LSA_MEMORY LsaMemory ;
    SIZE_T Offset ;
    KSEC_LSA_MEMORY_HEADER Header ;
    NTSTATUS Status = STATUS_SUCCESS ;

    PAGED_CODE();

    *Mapped = FALSE ;

    TotalSize = 0 ;

    if ( InputBuffers )
    {
        if ( InputBuffers->cBuffers > LocalBuffers->cBuffers )
        {
            return STATUS_INVALID_PARAMETER ;
        }

        for ( i = 0 ; i < InputBuffers->cBuffers ; i++ )
        {
            if ( ((ULONG_PTR) InputBuffers->pBuffers[ i ].pvBuffer > MM_USER_PROBE_ADDRESS ) &&
                ( InputBuffers->pBuffers[ i ].cbBuffer > 0 ))
            {
                //
                // Caller has supplied a buffer out of pool.  Add this to our
                // total required size
                //

                TotalSize += ROUND_UP_COUNT( InputBuffers->pBuffers[ i ].cbBuffer, ALIGN_LPVOID );
            }
        }
    }

    if ( Target )
    {
        if ( (ULONG_PTR) Target->Buffer > MM_USER_PROBE_ADDRESS )
        {
            TotalSize += ROUND_UP_COUNT( (Target->Length + sizeof( WCHAR )), ALIGN_LPVOID );
        }
    }

    if ( TotalSize )
    {
        //
        // Cool - we've got a chunk of data in pool, and we need to copy
        // it up to the LSA.
        //

        if ( InputBuffers )
        {
            TotalSize += sizeof( SecBuffer ) * InputBuffers->cBuffers ;
        }

        TotalSize += sizeof( KSEC_LSA_MEMORY_HEADER );

        LsaMemory = KsecAllocLsaMemory( TotalSize );

        if ( !LsaMemory )
        {
            return STATUS_NO_MEMORY ;
        }

        //
        // Assemble the buffer
        //

        Offset = 0 ;

        Offset += sizeof( KSEC_LSA_MEMORY_HEADER );

        if ( InputBuffers )
        {
            Offset += sizeof( SecBuffer ) * InputBuffers->cBuffers ;

            for ( i = 0 ; i < InputBuffers->cBuffers ; i++ )
            {
                LocalBuffers->pBuffers[ i ] = InputBuffers->pBuffers[ i ];

                if ( ( (ULONG_PTR) InputBuffers->pBuffers[ i ].pvBuffer > MM_USER_PROBE_ADDRESS ) &&
                    ( InputBuffers->pBuffers[ i ].cbBuffer > 0 ) )
                {

                    LocalBuffers->pBuffers[ i ].BufferType |= SECBUFFER_KERNEL_MAP ;
                    LocalBuffers->pBuffers[ i ].pvBuffer = (PUCHAR) LsaMemory->Region + Offset ;

                    Status = KsecCopyPoolToLsa(
                                    LsaMemory,
                                    Offset,
                                    InputBuffers->pBuffers[ i ].pvBuffer,
                                    InputBuffers->pBuffers[ i ].cbBuffer );

                    Offset += ROUND_UP_COUNT( InputBuffers->pBuffers[ i ].cbBuffer, ALIGN_LPVOID );

                    if ( !NT_SUCCESS( Status ) )
                    {
                        break;
                    }
                }
            }

            LocalBuffers->cBuffers = InputBuffers->cBuffers ;
        }

        if ( NT_SUCCESS( Status ) )
        {
            if ( Target )
            {
                if ( (ULONG_PTR) Target->Buffer > MM_USER_PROBE_ADDRESS )
                {
                    Status = KsecCopyPoolToLsa(
                                LsaMemory,
                                Offset,
                                Target->Buffer,
                                Target->Length );

                    if ( NT_SUCCESS( Status ) )
                    {
                        NewTarget->Buffer = (PWSTR) ((PUCHAR) LsaMemory->Region + Offset);
                        NewTarget->Length = Target->Length ;
                        NewTarget->MaximumLength = NewTarget->Length + sizeof( WCHAR ) ;
                    }

                    Offset += ROUND_UP_COUNT( (Target->Length + sizeof( WCHAR )), ALIGN_LPVOID );
                }
            }
        }

        if ( !NT_SUCCESS( Status ) )
        {
            KsecFreeLsaMemory( LsaMemory );
            return Status ;
        }

        *Mapped = TRUE ;
        *LsaMemoryBlock = LsaMemory ;
    }

    return Status ;
}


//+---------------------------------------------------------------------------
//
//  Function:   KsecUncaptureBufferDesc
//
//  Synopsis:   Copies information back out of the LSA block into various pool
//              descriptors
//
//  Arguments:  [LsaMemory]       --
//              [AllocMem]        --
//              [CapturedBuffers] --
//              [SuppliedBuffers] --
//              [OPTIONAL]        --
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
KsecUncaptureBufferDesc(
    PKSEC_LSA_MEMORY LsaMemory,
    BOOLEAN AllocMem,
    PSecBufferDesc CapturedBuffers,
    PSecBufferDesc SuppliedBuffers,
    PSecBuffer ContextData OPTIONAL
    )
{

    ULONG i ;
    PVOID p ;
    NTSTATUS Status = STATUS_SUCCESS ;

    for ( i = 0 ; i < CapturedBuffers->cBuffers ; i++ )
    {
        if ( ( CapturedBuffers->pBuffers[ i ].pvBuffer == SuppliedBuffers->pBuffers[ i ].pvBuffer ) ||
             ( !KsecIsBlockInLsa( LsaMemory, CapturedBuffers->pBuffers[ i ].pvBuffer ) ) )
        {
            //
            // Same buffer?  Not in the LSA block?  Skip it - this was done by the LSA
            //
            SuppliedBuffers->pBuffers[ i ] = CapturedBuffers->pBuffers[ i ];

            continue;
        }

        if ( ( CapturedBuffers->pBuffers[ i ].BufferType & ~SECBUFFER_ATTRMASK ) == SECBUFFER_TOKEN )
        {
            if ( AllocMem )
            {
                p = ExAllocatePool(
                        PagedPool,
                        CapturedBuffers->pBuffers[ i ].cbBuffer );

                if ( p )
                {
                    SuppliedBuffers->pBuffers[ i ].pvBuffer = p ;
                    SuppliedBuffers->pBuffers[ i ].cbBuffer =
                            CapturedBuffers->pBuffers[ i ].cbBuffer ;
                }
                else
                {
                    Status = STATUS_NO_MEMORY ;
                    break;
                }
            }
            else
            {
                if ( SuppliedBuffers->pBuffers[ i ].cbBuffer <
                        CapturedBuffers->pBuffers[ i ].cbBuffer )
                {
                    DebugLog(( DEB_ERROR, "Error:  supplied buffer smaller than capture\n" ));
                    Status = STATUS_BUFFER_TOO_SMALL ;
                    break;
                }
            }

            //
            // Safe to copy now
            //

            Status = KsecCopyLsaToPool(
                        SuppliedBuffers->pBuffers[ i ].pvBuffer,
                        LsaMemory,
                        CapturedBuffers->pBuffers[ i ].pvBuffer,
                        CapturedBuffers->pBuffers[ i ].cbBuffer );

            SuppliedBuffers->pBuffers[ i ].cbBuffer = CapturedBuffers->pBuffers[ i ].cbBuffer ;
            SuppliedBuffers->pBuffers[ i ].BufferType = CapturedBuffers->pBuffers[ i ].BufferType ;
        }
    }

    if ( NT_SUCCESS( Status ) )
    {
        if ( ContextData )
        {
            if ( KsecIsBlockInLsa( LsaMemory, ContextData->pvBuffer ) )
            {
                p = ExAllocatePool(
                        PagedPool,
                        ContextData->cbBuffer );

                if ( p )
                {
                    Status = KsecCopyLsaToPool(
                                p,
                                LsaMemory,
                                ContextData->pvBuffer,
                                ContextData->cbBuffer );
                }
                else
                {
                    Status = STATUS_NO_MEMORY ;
                }

                if ( NT_SUCCESS( Status ))
                {
                    ContextData->pvBuffer = p ;
                }
            }
        }
    }

    if ( !NT_SUCCESS( Status ) )
    {
        //
        // Failure path cleanup
        //

        if ( AllocMem )
        {
            for ( i = 0 ; i < CapturedBuffers->cBuffers ; i++ )
            {
                if ( ( SuppliedBuffers->pBuffers[ i ].BufferType & ~SECBUFFER_ATTRMASK ) == SECBUFFER_TOKEN )
                {
                    if ( SuppliedBuffers->pBuffers[ i ].pvBuffer )
                    {
                        ExFreePool( SuppliedBuffers->pBuffers[ i ].pvBuffer );
                        SuppliedBuffers->pBuffers[ i ].pvBuffer = NULL ;
                    }
                }
            }
        }
    }

    return Status ;
}


//+-------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
InitializeSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSECURITY_STRING            pssTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    SECURITY_STATUS scRet;
    NTSTATUS Status ;
    BOOLEAN MappedContext = FALSE;
    SecBuffer ContextData = {0,0,NULL};
    CtxtHandle TempInputContext = {0,0};
    CtxtHandle TempOutputContext = {0, 0};
    CtxtHandle ContextHandle = {0,0};
    CredHandle CredentialHandle = {0,0};
    ULONG Flags;

    SecBuffer LocalBuffers[ MAX_BUFFERS_IN_CALL ];
    SecBufferDesc LocalDesc ;
    SecBuffer LocalOutBuffers[ MAX_BUFFERS_IN_CALL ];
    SecBufferDesc LocalOutDesc ;
    BOOLEAN Mapped = FALSE;
    PSecBufferDesc InputBuffers ;
    SECURITY_STRING LocalTarget ;
    PKSEC_LSA_MEMORY LsaMemory = NULL ;

    PAGED_CODE();

    // Check for valid sizes, pointers, etc.:

    //
    // Onw of the two of these is required
    //

    if (!ARGUMENT_PRESENT(phContext) && !ARGUMENT_PRESENT(phCredential))
    {
        scRet = SEC_E_INVALID_HANDLE ;
        goto Cleanup ;
    }

    if (ARGUMENT_PRESENT(phCredential))
    {
        CredentialHandle = *phCredential;
    }

    TempOutputContext = *phNewContext ;

    if (ARGUMENT_PRESENT(phContext))
    {

        //
        // Map the handle from kernel mode into LSA mode
        //

        TempInputContext = *phContext;

        scRet = MapKernelContextHandle(
                    phContext,
                    &ContextHandle
                    );

        if (!NT_SUCCESS(scRet))
        {
            return(scRet);
        }

        if (!ARGUMENT_PRESENT(phCredential))
        {
            CredentialHandle.dwLower = ContextHandle.dwLower;
        }
    }

    if (!pssTargetName)
    {
        pssTargetName = &sFake;
    }

    LocalTarget = *pssTargetName ;

    LocalDesc.pBuffers = LocalBuffers ;
    LocalDesc.cBuffers = MAX_BUFFERS_IN_CALL;
    LocalDesc.ulVersion = SECBUFFER_VERSION ;

    ASSERT( pOutput->cBuffers <= MAX_BUFFERS_IN_CALL );

    LocalOutDesc.pBuffers = LocalOutBuffers ;
    LocalOutDesc.cBuffers = pOutput->cBuffers ;
    LocalOutDesc.ulVersion = SECBUFFER_VERSION ;

    RtlCopyMemory(
        LocalOutBuffers,
        pOutput->pBuffers,
        pOutput->cBuffers * sizeof( SecBuffer ) );

    InputBuffers = pInput ;

    scRet = KsecCaptureBufferDesc(
                &LsaMemory,
                &Mapped,
                pssTargetName,
                pInput,
                &LocalDesc,
                &LocalTarget );

    if ( !NT_SUCCESS( scRet ) )
    {
        return scRet ;
    }

    if ( Mapped && ( pInput != NULL ) )
    {
        InputBuffers = &LocalDesc ;
    }

    if ( !LsaMemory )
    {
        //
        // Allocate one, so that the LSA can return any data to us
        // in the region
        //

        LsaMemory = KsecAllocLsaMemory( 3 * 1024 );

        if ( !LsaMemory )
        {
            return STATUS_NO_MEMORY;
        }
    }

    Flags = 0;

    if ( Mapped || LsaMemory )
    {
        Flags |= SPMAPI_FLAG_KMAP_MEM ;
    }

    scRet = SecpInitializeSecurityContext(
                    KsecLsaMemoryToContext(LsaMemory),
                    &CredentialHandle,
                    &ContextHandle,
                    &LocalTarget,
                    fContextReq,
                    Reserved1,
                    TargetDataRep,
                    InputBuffers,
                    Reserved2,
                    phNewContext,
                    &LocalOutDesc,
                    pfContextAttr,
                    ptsExpiry,
                    &MappedContext,
                    &ContextData,
                    &Flags );

    if ( NT_SUCCESS( scRet ) )
    {
        Status = KsecUncaptureBufferDesc(
                    LsaMemory,
                    ((*pfContextAttr & ISC_RET_ALLOCATED_MEMORY) != 0),
                    &LocalOutDesc,
                    pOutput,
                    ( MappedContext ? &ContextData : NULL ) );

        if ( !NT_SUCCESS( Status ) )
        {
            scRet = Status ;
        }
    }

    if (NT_SUCCESS(scRet))
    {

#if 0 // DBG
        if ( phNewContext->dwLower < 3 )
        {
            ULONG i ;
            NTSTATUS CheckStatus ;

            for ( i = 0 ; i < pOutput->cBuffers ; i++ )
            {
                if ( (pOutput->pBuffers[i].BufferType & ~SECBUFFER_ATTRMASK ) == SECBUFFER_TOKEN)
                {
                    CheckStatus = KSecValidateBuffer(
                                        (PUCHAR) pOutput->pBuffers[i].pvBuffer,
                                        pOutput->pBuffers[i].cbBuffer );

                    if ( !NT_SUCCESS( CheckStatus ) )
                    {
                        DbgBreakPoint();
                    }
                }
            }
        }
#endif
        if ( MappedContext )
        {
            SECURITY_STATUS SecStatus;

            if ( ( phNewContext->dwUpper != 0 ) &&
                 ( phNewContext->dwLower != 0 ) )
            {
                SecStatus = InitUserModeContext(
                                    phNewContext,
                                    &ContextData,
                                    phNewContext
                                    );
            }
            else
            {
                SecStatus = SEC_E_INSUFFICIENT_MEMORY ;
            }

            if (!NT_SUCCESS(SecStatus))
            {

                //
                // If this was a first call, reset the output context
                //

                if (!ARGUMENT_PRESENT(phContext))
                {
                    DeleteSecurityContext(phNewContext);

                    *phNewContext = TempOutputContext ;

                }

                scRet = SecStatus;
            }
        }
        else
        {
            //
            // Make sure to map the output handle also
            //

            if (ARGUMENT_PRESENT(phContext) && (phNewContext->dwUpper == ContextHandle.dwUpper) )
            {
                *phNewContext = TempInputContext;
            }
        }
    }

    if ( LsaMemory )
    {
        KsecFreeLsaMemory( LsaMemory );
    }

Cleanup:

#if DBG
    if ( scRet == SEC_E_INVALID_HANDLE )
    {
        DebugLog(( DEB_WARN, "Invalid handle passed to InitializeSecurityContext\n" ));
    }
#endif
    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   AcceptSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
AcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    SECURITY_STATUS scRet;
    NTSTATUS Status ;
    BOOLEAN MappedContext = FALSE;;
    SecBuffer ContextData = {0,0,NULL};
    CtxtHandle TempInputContext = {0,0};
    CtxtHandle TempOutputContext = {0,0};
    CtxtHandle ContextHandle = {0,0};
    CredHandle CredentialHandle = {0,0};
    ULONG Flags;
    ULONG i ;
    SecBuffer LocalBuffers[ MAX_BUFFERS_IN_CALL ];
    SecBufferDesc LocalDesc ;
    SecBuffer LocalOutBuffers[ MAX_BUFFERS_IN_CALL ];
    SecBufferDesc LocalOutDesc ;
    BOOLEAN Mapped = FALSE;
    PSecBufferDesc InputBuffers ;
    PKSEC_LSA_MEMORY LsaMemory = NULL ;
    PBYTE lpIPAddress = NULL ;

    PAGED_CODE();

    //
    // Onw of the two of these is required
    //

    if (!ARGUMENT_PRESENT(phContext) && !ARGUMENT_PRESENT(phCredential))
    {
        scRet = SEC_E_INVALID_HANDLE ;
        goto Cleanup ;
    }

    if (ARGUMENT_PRESENT(phCredential))
    {
        CredentialHandle = *phCredential;
    }

    TempOutputContext = *phNewContext ;

    if (ARGUMENT_PRESENT(phContext))
    {
        //
        // Map the handle from kernel mode into LSA mode
        //

        TempInputContext = *phContext;

        scRet = MapKernelContextHandle(
                    phContext,
                    &ContextHandle
                    );

        if (!NT_SUCCESS(scRet))
        {
            return(scRet);
        }

        if (!ARGUMENT_PRESENT(phCredential))
        {
            CredentialHandle.dwLower = ContextHandle.dwLower;
        }
    }

    LocalDesc.pBuffers = LocalBuffers ;
    LocalDesc.cBuffers = MAX_BUFFERS_IN_CALL ;
    LocalDesc.ulVersion = SECBUFFER_VERSION ;

    LocalOutDesc.pBuffers = LocalOutBuffers ;
    LocalOutDesc.cBuffers = pOutput->cBuffers ;
    LocalOutDesc.ulVersion = SECBUFFER_VERSION ;

    RtlCopyMemory(
        LocalOutBuffers,
        pOutput->pBuffers,
        pOutput->cBuffers * sizeof( SecBuffer ) );

#if DBG
    if ( (fContextReq & ASC_REQ_ALLOCATE_MEMORY) == 0 )
    {
        for (i = 0 ; i < pOutput->cBuffers ; i++ )
        {
            if ( SECBUFFER_TYPE( pOutput->pBuffers[ i ].BufferType ) == SECBUFFER_TOKEN )
            {
                ASSERT( pOutput->pBuffers[ i ].cbBuffer > 0 );
            }
        }
    }
#endif

    //
    // Check for supplied IP address
    //

    if (pInput != NULL && pInput->cBuffers != 0 &&
        pInput->pBuffers[pInput->cBuffers - 1].BufferType == SECBUFFER_IPADDRESS)
    {
        lpIPAddress = (PBYTE) pInput->pBuffers[pInput->cBuffers - 1].pvBuffer;

        pInput->cBuffers--;
    }

    InputBuffers = pInput ;

    scRet = KsecCaptureBufferDesc(
                &LsaMemory,
                &Mapped,
                NULL,
                pInput,
                &LocalDesc,
                NULL );

    if ( !NT_SUCCESS( scRet ) )
    {
        if (lpIPAddress != NULL)
        {
            pInput->cBuffers++;
        }

        return scRet ;
    }

    if ( Mapped && ( pInput != NULL ) )
    {
        InputBuffers = &LocalDesc ;
    }

    if ( !LsaMemory )
    {
        //
        // Allocate one, so that the LSA can return any data to us
        // in the region
        //

        LsaMemory = KsecAllocLsaMemory( 3 * 1024 );

        if ( !LsaMemory )
        {
            if (lpIPAddress != NULL)
            {
                pInput->cBuffers++;
            }

            return STATUS_NO_MEMORY;
        }
    }

    Flags = 0;

    if ( Mapped )
    {
        Flags |= SPMAPI_FLAG_KMAP_MEM ;
    }

    scRet = SecpAcceptSecurityContext(
                KsecLsaMemoryToContext(LsaMemory),
                &CredentialHandle,
                &ContextHandle,
                InputBuffers,
                fContextReq,
                TargetDataRep,
                phNewContext,
                &LocalOutDesc,
                pfContextAttr,
                ptsExpiry,
                &MappedContext,
                &ContextData,
                &Flags,
                lpIPAddress );

    if (lpIPAddress != NULL)
    {
        pInput->cBuffers++;
    }

    if ( NT_SUCCESS( scRet ) )
    {
        Status = KsecUncaptureBufferDesc(
                    LsaMemory,
                    ((*pfContextAttr & ISC_RET_ALLOCATED_MEMORY) != 0),
                    &LocalOutDesc,
                    pOutput,
                    ( MappedContext ? &ContextData : NULL ) );

        if ( !NT_SUCCESS( Status ) )
        {
            scRet = Status ;
        }
    }

    if (NT_SUCCESS(scRet))
    {
        if (MappedContext)
        {
            SECURITY_STATUS SecStatus;

            //
            // Successful return means that the context is complete.  Map the
            // context into the user space:
            //

            if ( ( phNewContext->dwUpper != 0 ) &&
                 ( phNewContext->dwLower != 0 ) )
            {
                SecStatus = InitUserModeContext(
                                    phNewContext,
                                    &ContextData,
                                    phNewContext
                                    );
            }
            else
            {
                SecStatus = SEC_E_INSUFFICIENT_MEMORY ;
            }

            if (!NT_SUCCESS(SecStatus))
            {
                //
                // If this was a first call, restore the context
                //
                if (!ARGUMENT_PRESENT(phContext))
                {
                    DeleteSecurityContext(phNewContext);

                    *phNewContext = TempOutputContext ;
                }

                scRet = SecStatus;
            }
        }
        else
        {
            //
            // Make sure to map the output handle also
            //

            if (ARGUMENT_PRESENT(phContext) && (phNewContext->dwUpper == ContextHandle.dwUpper))
            {
                *phNewContext = TempInputContext;
            }
        }
    }

    if ( LsaMemory )
    {
        KsecFreeLsaMemory( LsaMemory );
    }

Cleanup:

#if DBG
    if ( scRet == SEC_E_INVALID_HANDLE )
    {
        DebugLog(( DEB_WARN, "Invalid handle passed to AcceptSecurityContext\n" ));
    }
#endif

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   DeleteSecurityContextInternal
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
DeleteSecurityContextInternal(
    BOOLEAN     DeletePrivateContext,
    PCtxtHandle                 phContext          // Context to delete
    )
{
    SECURITY_STATUS     scRet;
    CtxtHandle LsaContext = { 0 };

    PAGED_CODE();

    if ( DeletePrivateContext )
    {
        scRet = DeleteUserModeContext(
                    phContext,
                    &LsaContext
                    );
    }
    else
    {
        scRet = SEC_E_UNSUPPORTED_FUNCTION ;
    }

    //
    // Don't expect all packages to implement the functions to be called in
    // the caller's process.
    //

    if (!NT_SUCCESS(scRet))
    {
        LsaContext = *phContext;
    }

    //
    // Furthermore, if the package returned SEC_I_NO_LSA_CONTEXT, do not call
    // SecpDeleteSecurityContext and return Success. This happens when this
    // context is imported and therefore no LSA counterpart exists.
    //

    if (scRet == SEC_I_NO_LSA_CONTEXT)
    {
        return STATUS_SUCCESS;
    }

    //
    // Now delete the LSA context. This must be done second so we don't
    // reuse the LSA context before the kernel context is deleted. If
    // the lsa context value is zero, then there is no lsa context so
    // don't bother deleting it.
    //

    if (NT_SUCCESS(scRet) && (LsaContext.dwUpper != 0))
    {
        scRet = SecpDeleteSecurityContext(
                    SECP_DELETE_NO_BLOCK,
                    &LsaContext );

    }

#if DBG
    if ( scRet == SEC_E_INVALID_HANDLE )
    {
        DebugLog(( DEB_WARN, "Invalid handle passed to DeleteSecurityContext\n" ));
    }
#endif

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   DeleteSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
DeleteSecurityContext(
    PCtxtHandle phContext
    )
{
    NTSTATUS Status ;

    Status = DeleteSecurityContextInternal(
                    TRUE,
                    phContext
                    );

    return Status ;
}


//+-------------------------------------------------------------------------
//
//  Function:   ApplyControlToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
ApplyControlToken(
    PCtxtHandle                 phContext,          // Context to modify
    PSecBufferDesc              pInput              // Input token to apply
    )
{
    SECURITY_STATUS     scRet;

    PAGED_CODE();

    if (!phContext)
    {
        return(SEC_E_INVALID_HANDLE);
    }

    scRet = SecpApplyControlToken(  phContext,
                                    pInput);

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackage
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackages(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfo SEC_FAR *       ppPackageInfo       // Receives array of info
    )
{
    PAGED_CODE();

    return(SecpEnumeratePackages(pcPackages,ppPackageInfo));
}


//+-------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfo
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfo(
    PSECURITY_STRING PackageName,     // Name of package
    PSecPkgInfo * ppPackageInfo       // Receives package info
    )
{
    PAGED_CODE();

    return(SecpQueryPackageInfo(PackageName,ppPackageInfo));
}


//+-------------------------------------------------------------------------
//
//  Function:   FreeContextBuffer
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
FreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    )
{
    PAGED_CODE();

    SecFree( pvContextBuffer );

    return STATUS_SUCCESS;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaEnumerateLogonSessions
//
//  Synopsis:
//
//  Arguments:  [LogonSessionCount] --
//              [LogonSessionList]  --
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaEnumerateLogonSessions(
    OUT PULONG LogonSessionCount,
    OUT PLUID * LogonSessionList
    )
{
    PAGED_CODE();

    return SecpEnumLogonSession(
                LogonSessionCount,
                LogonSessionList
                );
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaGetLogonSessionData
//
//  Synopsis:
//
//  Arguments:  [LogonId]            --
//              [ppLogonSessionData] --
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaGetLogonSessionData(
    IN PLUID LogonId,
    OUT PSECURITY_LOGON_SESSION_DATA * ppLogonSessionData
    )
{
    PVOID Data ;
    NTSTATUS Status ;

    PAGED_CODE();

    Status = SecpGetLogonSessionData(
                LogonId,
                &Data );

    if ( NT_SUCCESS( Status ) )
    {
        *ppLogonSessionData = (PSECURITY_LOGON_SESSION_DATA) Data ;
    }

    return Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\h\lpcefs.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        lpcefs.h
//
// Contents:    prototypes for EFS client lpc functions
//
//
// History:     3-7-94      RobertRe      Created
//
//------------------------------------------------------------------------

#ifndef __LPCEFS_H__
#define __LPCEFS_H__

#include <efsstruc.h>

//
// Efs routines (efsp.cxx)
//

//
// Kernel mode API
//


SECURITY_STATUS
SEC_ENTRY
EfspGenerateKey(
   PEFS_DATA_STREAM_HEADER * EfsStream,
   PEFS_DATA_STREAM_HEADER   DirectoryEfsStream,
   ULONG                     DirectoryEfsStreamLength,
   PEFS_KEY *                Fek,
   PVOID *                   BufferBase,
   PULONG                    BufferLength
   );

NTSTATUS
SEC_ENTRY
EfspGenerateDirEfs(
    PEFS_DATA_STREAM_HEADER   DirectoryEfsStream,
    ULONG                     DirectoryEfsStreamLength,
    PEFS_DATA_STREAM_HEADER * EfsStream,
    PVOID *                   BufferBase,
    PULONG                    BufferLength
    );

NTSTATUS
SEC_ENTRY
EfspDecryptFek(
    PEFS_KEY *                Fek,
    PEFS_DATA_STREAM_HEADER   EfsStream,
    ULONG                     EfsStreamLength,
    ULONG                     OpenType,
    PEFS_DATA_STREAM_HEADER * NewEfs,
    PVOID *                   BufferBase,
    PULONG                    BufferLength
    );

NTSTATUS
SEC_ENTRY
EfspGenerateSessionKey(
    PEFS_INIT_DATAEXG InitDataExg
    );


#endif  // __LPCEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\h\lpcapi.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        lpcapi.h
//
// Contents:    prototypes for SPMgr client lpc functions
//
//
// History:     3-7-94      MikeSw      Created
//
//------------------------------------------------------------------------

#ifndef __LPCAPI_H__
#define __LPCAPI_H__


typedef struct _Client {
    LIST_ENTRY          Next;
    PVOID               ProcessId;
    HANDLE              hPort;
    ULONG               fClient;
    LONG                cRefs;
} Client, *PClient;





//
// Credentials APIs (credapi.cxx)
//



SECURITY_STATUS SEC_ENTRY
SecpAcquireCredentialsHandle(
    PVOID_LPC           Context,
    PSECURITY_STRING    pssPrincipalName,
    PSECURITY_STRING    pssPackageName,
    ULONG               fCredentialUse,
    PLUID               pLogonID,
    PVOID               pvAuthData,
    SEC_GET_KEY_FN      pvGetKeyFn,
    PVOID               ulGetKeyArgument,
    PCRED_HANDLE_LPC         phCredentials,
    PTimeStamp          ptsExpiry,
    PULONG              Flags);


SECURITY_STATUS SEC_ENTRY
SecpAddCredentials(
    PVOID_LPC        Context,
    PCRED_HANDLE_LPC phCredentials,
    PSECURITY_STRING pPrincipalName,
    PSECURITY_STRING pPackageName,
    ULONG fCredentialUse,
    PVOID pvAuthData,
    SEC_GET_KEY_FN pvGetKeyFn,
    PVOID pvGetKeyArg,
    PTimeStamp Expiry,
    PULONG Flags
    );


SECURITY_STATUS SEC_ENTRY
SecpFreeCredentialsHandle(
    ULONG           fFree,
    PCRED_HANDLE_LPC     phCredential);

SECURITY_STATUS SEC_ENTRY
SecpQueryCredentialsAttributes(
    PCRED_HANDLE_LPC phCredential,
    ULONG            ulAttribute,
    PVOID            pBuffer,
    LONG             Flags,
    PULONG           Allocs,
    PVOID *          Buffers );

//
// Context APIs (ctxtapi.cxx)
//



SECURITY_STATUS SEC_ENTRY
SecpInitializeSecurityContext(
    PVOID_LPC           ContextPointer,
    PCRED_HANDLE_LPC    phCredentials,
    PCONTEXT_HANDLE_LPC phContext,
    PSECURITY_STRING    pucsTarget,
    ULONG               fContextReq,
    ULONG               dwReserved1,
    ULONG               TargetDataRep,
    PSecBufferDesc      pInput,
    ULONG               dwReserved2,
    PCONTEXT_HANDLE_LPC phNewContext,
    PSecBufferDesc      pOutput,
    ULONG *             pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBOOLEAN            MappedContext,
    PSecBuffer          ContextData,
    ULONG *             Flags );

SECURITY_STATUS SEC_ENTRY
SecpAcceptSecurityContext(
    PVOID_LPC           ContextPointer,
    PCRED_HANDLE_LPC    phCredentials,
    PCONTEXT_HANDLE_LPC phContext,
    PSecBufferDesc      pInput,
    ULONG               fContextReq,
    ULONG               TargetDataRep,
    PCONTEXT_HANDLE_LPC phNewContext,
    PSecBufferDesc      pOutput,
    ULONG *             pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBOOLEAN            MappedContext,
    PSecBuffer          ContextData,
    ULONG *             Flags,
    LPBYTE              lpIPAddress
    );

SECURITY_STATUS SEC_ENTRY
SecpDeleteSecurityContext(
    ULONG           fDelete,
    PCONTEXT_HANDLE_LPC     phContext);

#define SECP_DELETE_NO_BLOCK    0x00000001

SECURITY_STATUS SEC_ENTRY
SecpApplyControlToken(
    PCONTEXT_HANDLE_LPC phContext,
    PSecBufferDesc      pInput);

//
// Misc. APIs (misc.cxx)
//

SECURITY_STATUS SEC_ENTRY
SecpGetUserInfo(IN         PLUID                   pLogonId,
                IN         ULONG                   fFlags,
                IN OUT     PSecurityUserData *     ppUserInfo);

SECURITY_STATUS SEC_ENTRY
SecpEnumeratePackages(  IN         PULONG               pcPackages,
                        IN OUT     PSecPkgInfo *        ppPackageInfo);

SECURITY_STATUS SEC_ENTRY
SecpQueryPackageInfo(   PSECURITY_STRING        pssPackageName,
                        PSecPkgInfo *           ppPackageInfo);

SECURITY_STATUS SEC_ENTRY
SecpPackageControl(     PSECURITY_STRING        pssPackageName,
                        unsigned long           dwFunctionCode,
                        PSecBuffer              pInput,
                        PSecBuffer              pOuput);

//
// Utility routines (util.cxx)
//

SECURITY_STATUS SEC_ENTRY
SecpGetBinding( ULONG_PTR               ulPackageId,
                PSEC_PACKAGE_BINDING_INFO BindingInfo );

SECURITY_STATUS SEC_ENTRY
SecpFindPackage(    PSECURITY_STRING        pssPackageName,
                    PULONG_PTR              pulPackagdId);


#ifndef SECURITY_KERNEL

SECURITY_STATUS
SEC_ENTRY
SecpAddPackage(
    PUNICODE_STRING Package,
    PSECURITY_PACKAGE_OPTIONS Options);

SECURITY_STATUS
SEC_ENTRY
SecpDeletePackage(
    PUNICODE_STRING Package);

#endif

SECURITY_STATUS
SEC_ENTRY
SecpSetSession(
    ULONG   Request,
    ULONG_PTR Argument,
    PULONG_PTR Response,
    PVOID * ResponsePtr
    );

SECURITY_STATUS
SEC_ENTRY
SecpQueryContextAttributes(
    PVOID_LPC ContextPointer,
    PCONTEXT_HANDLE_LPC phContext,
    ULONG   ulAttribute,
    PVOID   pBuffer,
    PULONG  Allocs,
    PVOID * Buffers,
    PULONG  Flags
    );

SECURITY_STATUS
SEC_ENTRY
SecpSetContextAttributes(
    PCONTEXT_HANDLE_LPC phContext,
    ULONG       ulAttribute,
    PVOID       pBuffer,
    ULONG cbBuffer
    );


NTSTATUS
NTAPI
SecpGetUserName(
    ULONG Options,
    PUNICODE_STRING Name
    );


NTSTATUS
NTAPI
SecpGetLogonSessionData(
    IN PLUID LogonId,
    OUT PVOID * LogonSessionData
    );


NTSTATUS
NTAPI
SecpEnumLogonSession(
    PULONG LogonSessionCount,
    PLUID * LogonSessionList
    );

SECURITY_STATUS
SEC_ENTRY
LsapPolicyChangeNotify( IN ULONG Options,
                        IN BOOLEAN Register,
                        IN HANDLE EventHandle,
                        IN POLICY_NOTIFICATION_INFORMATION_CLASS NotifyInfoClass
                        );

SECURITY_STATUS
SecpLookupAccountSid(
    PVOID_LPC ContextPointer,
    IN PSID Sid,
    OUT PSECURITY_STRING Name,
    OUT PULONG RequiredNameSize,
    OUT PSECURITY_STRING ReferencedDomain,
    OUT PULONG RequiredDomainSize,
    OUT PSID_NAME_USE NameUse
    );

SECURITY_STATUS
SecpLookupAccountName(
    IN PSECURITY_STRING Name,
    OUT PSECURITY_STRING ReferencedDomain,
    OUT PULONG RequiredDomainSize,
    IN OUT PULONG SidSize,
    OUT PSID Sid,
    OUT PSID_NAME_USE NameUse
    );

NTSTATUS
NTAPI
SecpLookupWellKnownSid(
    IN WELL_KNOWN_SID_TYPE SidType,
    OUT PSID Sid,
    IN ULONG SidBufferSize,
    IN OUT PULONG SidSize OPTIONAL
    );

//
// LPC support routins
//
NTSTATUS
CreateConnection(
    PSTR     LogonProcessName OPTIONAL,
    ULONG    ClientMode OPTIONAL,
    HANDLE * phConnect,
    ULONG *  PackageCount,
    ULONG *  OperationalMode
    );

LSA_DISPATCH_FN SecpLsaCallback ;

//
// Linkee can replace this value and the library will call it instead
//

extern PLSA_DISPATCH_FN     SecpLsaDispatchFn;

//
// functions that must be provided by the linkee
//

SECURITY_STATUS
IsOkayToExec(PClient * pClient);

VOID
FreeClient(PClient pClient);



#define DEB_TRACE_LSA   0x00000008
#define DEB_TRACE_CALL  0x00000010

#if DBG

#ifdef SEC_KMODE

extern ULONG SecInfoLevel;

#define DEB_ERROR   0x00000001
#define DEB_WARN    0x00000002
#define DEB_TRACE   0x00000004

void KsecDebugOut(ULONG, const char *, ...);

#define DebugLog(x) KsecDebugOut x

#else

#include <dsysdbg.h>

DECLARE_DEBUG2(Sec);                 // Defines the SecInfoLevel

#define DebugLog(x)     SecDebugPrint x

#endif // usermode

#else // DBG

#define DebugLog(x)

#endif // DBG

#endif // __LPCAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\wow6432\debug.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.c
//
//  Contents:   Debug support for the security client dll
//
//  Classes:
//
//  Functions:
//
//  History:    4-26-93   RichardW   Created
//
//----------------------------------------------------------------------------

#include "..\dll\debug.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\driver\userstub.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        userstub.cxx
//
// Contents:    stubs for user-mode security APIs
//
//
// History:     3-7-94      MikeSw      Created
//
//------------------------------------------------------------------------

#include "secpch2.hxx"
#pragma hdrstop
extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "ksecdd.h"
#include "connmgr.h"
#include <ntlmsp.h>
#include <kerberos.h>
#include <negossp.h>
#include <wdigest.h>


//
// Local Prototypes that can be paged:
//

SECURITY_STATUS
KsecLocatePackage(
    IN PUNICODE_STRING PackageName,
    OUT PSECPKG_KERNEL_FUNCTION_TABLE * Package,
    OUT PULONG_PTR PackageId
    );

}

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, InitializePackages)

#ifdef KSEC_LEAK_TRACKING
#pragma alloc_text(PAGE, UninitializePackages)
#endif

#pragma alloc_text(PAGEMSG, CompleteAuthToken)
#pragma alloc_text(PAGEMSG, ImpersonateSecurityContext)
#pragma alloc_text(PAGEMSG, RevertSecurityContext)
#pragma alloc_text(PAGEMSG, QueryContextAttributes)
#pragma alloc_text(PAGEMSG, QuerySecurityContextToken)
#pragma alloc_text(PAGEMSG, MakeSignature)
#pragma alloc_text(PAGEMSG, VerifySignature)
#pragma alloc_text(PAGEMSG, SealMessage)
#pragma alloc_text(PAGEMSG, UnsealMessage)
#pragma alloc_text(PAGE, DeleteUserModeContext)
#pragma alloc_text(PAGE, InitUserModeContext)
#pragma alloc_text(PAGE, ExportSecurityContext)
#pragma alloc_text(PAGE, ImportSecurityContextW)
#pragma alloc_text(PAGE, KsecLocatePackage)
#pragma alloc_text(PAGE, KSecSerializeWinntAuthData)
#endif

extern SECPKG_KERNEL_FUNCTION_TABLE KerberosFunctionTable;
extern SECPKG_KERNEL_FUNCTION_TABLE NtLmFunctionTable;
extern SECPKG_KERNEL_FUNCTION_TABLE NegFunctionTable;
extern SECPKG_KERNEL_FUNCTION_TABLE WDigestFunctionTable;

FAST_MUTEX  KsecPackageLock ;
LONG KsecConnectionIndicator ;
KEVENT KsecConnectEvent ;
ULONG KsecQuerySizes[] = {
    sizeof( SecPkgContext_Sizes ),
    sizeof( SecPkgContext_Names ),
    sizeof( SecPkgContext_Lifespan ),
    sizeof( SecPkgContext_DceInfo ),
    sizeof( SecPkgContext_StreamSizes ),
    sizeof( SecPkgContext_KeyInfo ),
    sizeof( SecPkgContext_Authority ),
    sizeof( SecPkgContext_ProtoInfo ),
    sizeof( SecPkgContext_PasswordExpiry ),
    sizeof( SecPkgContext_SessionKey ),
    sizeof( SecPkgContext_PackageInfo ),
    sizeof( SecPkgContext_UserFlags ),
    sizeof( SecPkgContext_NegotiationInfo ),
    sizeof( SecPkgContext_NativeNames ),
    sizeof( ULONG ),
    sizeof( PVOID )
};

#define KSecContextAttrSize( attr ) \
        ( attr < sizeof( KsecQuerySizes ) / sizeof( ULONG) ? KsecQuerySizes[ attr ] : sizeof( ULONG ) ) 

#define KSEC_CLEAR_CONTEXT_ATTR( attr, buffer ) \
    RtlZeroMemory( buffer,                      \
    KSecContextAttrSize( attr ) )
//
// This counter controls the paging mode.  >0 indicates that messagemode
// APIs should be paged in.  0 indicates normal operation.  <0 is error
//

LONG KsecPageModeCounter = 0 ;
FAST_MUTEX KsecPageModeMutex ;
HANDLE KsecPagableSection ;

PSECPKG_KERNEL_FUNCTION_TABLE * Packages;

ULONG cKernelPackages;

PSEC_BUILTIN_KPACKAGE   KsecDeferredPackages;

ULONG   KsecDeferredPackageCount;
BOOLEAN PackagesInitialized = FALSE;

UNICODE_STRING  KerberosName = {0, 0, MICROSOFT_KERBEROS_NAME_W };
UNICODE_STRING  NtlmName = {0, 0, NTLMSP_NAME };
UNICODE_STRING  NegotiateName = {0,0, NEGOSSP_NAME };
UNICODE_STRING  WDigestName = {0,0, WDIGEST_SP_NAME_W };

UCHAR NtlmTag[] = "NTLMSSP" ;

SEC_BUILTIN_KPACKAGE    KsecBuiltinPackages[] = {
    { &NegFunctionTable, &NegotiateName },
    { &KerberosFunctionTable, &KerberosName },
    { &NtLmFunctionTable, &NtlmName },
    { &WDigestFunctionTable, &WDigestName }
    } ;

SECPKG_KERNEL_FUNCTIONS KspKernelFunctions = {
        SecAllocate,
        SecFree,
        KSecCreateContextList,
        KSecInsertListEntry,
        KSecReferenceListEntry,
        KSecDereferenceListEntry,
        KSecSerializeWinntAuthData
        };

#define MAYBE_PAGED_CODE() \
    if ( KsecPageModeCounter == 0 ) \
    {                               \
        PAGED_CODE()                \
    }

#define FailIfNoPackages()          \
    if ( Packages == NULL )         \
    {                               \
        return STATUS_UNSUCCESSFUL ;\
    }


//+-------------------------------------------------------------------------
//
//  Function:   InitializePackages
//
//  Synopsis:   Initialize all kernel-mode security packages
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
InitializePackages(
    ULONG   LsaPackageCount )
{
    ULONG Index;
    SECURITY_STATUS scRet = SEC_E_OK;
    ULONG_PTR PackageId;

    PAGED_CODE();

    if ( PackagesInitialized )
    {
        return STATUS_SUCCESS ;
    }

    KSecLockPackageList();

    //
    // Someone might have initialized it by now, so check again.
    //

    if ( PackagesInitialized )
    {
        KSecUnlockPackageList();

        return(STATUS_SUCCESS);
    }

    //
    // Nope, no one doing this yet.  Try to set the flag that we're going
    // to do it.
    //

    if ( KsecConnectionIndicator == 0 )
    {
        KsecConnectionIndicator = 1 ;
    }
    else
    {
        //
        // other thread is already initializing.  Release the lock
        // and wait quietly:
        //

        KSecUnlockPackageList();

        KeWaitForSingleObject( 
            &KsecConnectEvent,
            UserRequest,
            KernelMode,
            FALSE,
            NULL );


        if ( PackagesInitialized )
        {
            return STATUS_SUCCESS ;

        }

        return STATUS_UNSUCCESSFUL ;
    }

    KSecUnlockPackageList();

    Packages = (PSECPKG_KERNEL_FUNCTION_TABLE *) ExAllocatePool( NonPagedPool,
                    sizeof( PSECPKG_KERNEL_FUNCTION_TABLE ) * LsaPackageCount );

    if ( Packages == NULL )
    {
        return( SEC_E_INSUFFICIENT_MEMORY );
    }

    RtlZeroMemory( Packages,
                   sizeof( PSECPKG_KERNEL_FUNCTION_TABLE ) * LsaPackageCount );

    //
    // Loop through and determine the package id for all builtin packages
    //

    for ( Index = 0 ;
          Index < sizeof( KsecBuiltinPackages ) / sizeof( SEC_BUILTIN_KPACKAGE ) ;
          Index ++ )
    {
        RtlInitUnicodeString( KsecBuiltinPackages[ Index ].Name,
                              KsecBuiltinPackages[ Index ].Name->Buffer );

        scRet = SecpFindPackage( KsecBuiltinPackages[ Index ].Name,
                                 &PackageId );

        if ( NT_SUCCESS( scRet ) &&
             ( Packages[ PackageId ] == NULL ) )
        {
            DebugLog(( DEB_TRACE, "Assigning package %ws index %d\n",
                            KsecBuiltinPackages[Index].Name->Buffer,
                            PackageId ));

            Packages[ PackageId ] = KsecBuiltinPackages[ Index ].Table ;
            KsecBuiltinPackages[ Index ].PackageId = PackageId ;
        }
        else
        {
            DebugLog(( DEB_ERROR, "Could not find builtin package %ws\n",
                            KsecBuiltinPackages[Index].Name->Buffer ));

        }
    }

    if ( KsecDeferredPackageCount )
    {
        for ( Index = 0 ; Index < KsecDeferredPackageCount ; Index++ )
        {
            scRet = SecpFindPackage( KsecDeferredPackages[ Index ].Name,
                                     &PackageId );

            if ( NT_SUCCESS( scRet ) &&
                 ( Packages[ PackageId ] == NULL ) )
            {
                DebugLog(( DEB_TRACE, "Assigning package %ws index %d\n",
                                KsecDeferredPackages[Index].Name->Buffer,
                                PackageId ));

                Packages[ PackageId ] = KsecDeferredPackages[ Index ].Table ;
                KsecDeferredPackages[ Index ].PackageId = PackageId ;
            }
            else
            {
                DebugLog(( DEB_ERROR, "Could not find deferred package %ws\n",
                                KsecDeferredPackages[Index].Name->Buffer ));

            }
        }
    }
    //
    // Now, initialize them:
    //

    for ( Index = 0 ; Index < LsaPackageCount ; Index++ )
    {
        if ( Packages[ Index ] )
        {
            Packages[ Index ]->Initialize( &KspKernelFunctions );

            //
            // If at least one was set up, go with it.
            //

            PackagesInitialized = TRUE;
        }
    }

    cKernelPackages = LsaPackageCount ;

    KsecConnectionIndicator = 0 ;
    KeSetEvent( 
        &KsecConnectEvent, 
        1, 
        FALSE );

    return(scRet);
}


#ifdef KSEC_LEAK_TRACKING

//+---------------------------------------------------------------------------
//
//  Function:   UninitializePackages
//
//  Synopsis:   Frees allocated resources used for packages
//
//  Arguments:  --
//
//  History:    09-03-2000   NeillC   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

VOID
UninitializePackages(
    VOID
    )
{
    PSECPKG_KERNEL_FUNCTION_TABLE * TempPackages;

    KSecLockPackageList();
    TempPackages = Packages;
    Packages = NULL;
    KSecUnlockPackageList();

    if (TempPackages != NULL) {
        ExFreePool (TempPackages);
    }
}

#endif  // KSEC_LEAK_TRACKING


//+---------------------------------------------------------------------------
//
//  Function:   KsecRegisterSecurityProvider
//
//  Synopsis:   Registers a new security provider with the driver
//
//  Arguments:  [Name]  --
//              [Table] --
//
//  History:    9-16-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
KSecRegisterSecurityProvider(
    PUNICODE_STRING Name,
    PSECPKG_KERNEL_FUNCTION_TABLE Table)
{
    SEC_BUILTIN_KPACKAGE *  DeferredList ;
    NTSTATUS Status;
    ULONG_PTR PackageId;

    KSecLockPackageList();

    if ( Packages == NULL )
    {
        //
        // A driver connected before we were ready.  Put this on the deferred
        // list.
        //

        DeferredList = (PSEC_BUILTIN_KPACKAGE) ExAllocatePool(
                                                PagedPool,
                                                sizeof( SEC_BUILTIN_KPACKAGE ) *
                                                (KsecDeferredPackageCount + 1) );

        if ( DeferredList )
        {
            if ( KsecDeferredPackages )
            {
                RtlCopyMemory( DeferredList,
                               KsecDeferredPackages,
                               sizeof( SEC_BUILTIN_KPACKAGE ) *
                                        KsecDeferredPackageCount );

                ExFreePool( KsecDeferredPackages );
            }

            DeferredList[ KsecDeferredPackageCount ].Name = Name;
            DeferredList[ KsecDeferredPackageCount ].Table = Table ;

            KsecDeferredPackageCount ++ ;
            KsecDeferredPackages = DeferredList ;

            Status = SEC_E_OK ;
        }
        else
        {
            Status = SEC_E_INSUFFICIENT_MEMORY ;
        }
    }
    else
    {
        //
        // Okay, we're up and running.  Find a connection to the
        // LSA.  Hopefully, we've already got a connection, but if
        // not, we'll create a short lived one dynamically.
        //

        Status = LocateClient();

        if ( NT_ERROR( Status ) )
        {
            Status = CreateClient( FALSE );

            if (NT_ERROR( Status ) )
            {
                KSecUnlockPackageList();

                return( Status );
            }
        }

        if ( Name->Length + 2 > CBPREPACK )
        {
            KSecUnlockPackageList();

            return( SEC_E_INSUFFICIENT_MEMORY );
        }

        Status = SecpFindPackage(   Name,
                                    &PackageId );

        if ( NT_SUCCESS( Status ) )
        {
            if ( PackageId >= cKernelPackages )
            {
                KSecUnlockPackageList();

                return( SEC_E_SECPKG_NOT_FOUND );
            }

            if ( Packages[ PackageId ] == NULL )
            {
                Packages[ PackageId ] = Table ;

                Table->Initialize( &KspKernelFunctions );
            }
            else
            {
                Status = SEC_E_SECPKG_NOT_FOUND ;
            }
        }
    }

    KSecUnlockPackageList();

    return( Status );
}


//+-------------------------------------------------------------------------
//
//  Function:   KsecLocatePackage
//
//  Synopsis:   Locates a package from its name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
KsecLocatePackage(
    IN PUNICODE_STRING PackageName,
    OUT PSECPKG_KERNEL_FUNCTION_TABLE * Package,
    OUT PULONG_PTR PackageId
    )
{
    ULONG Index;

    PAGED_CODE();

    *Package = NULL ;

    for ( Index = 0 ;
          Index < sizeof( KsecBuiltinPackages ) / sizeof( SEC_BUILTIN_KPACKAGE ) ;
          Index ++ )
    {
        if (RtlEqualUnicodeString(
                PackageName,
                KsecBuiltinPackages[Index].Name,
                TRUE))
        {
            *Package = KsecBuiltinPackages[ Index ].Table ;
            *PackageId = KsecBuiltinPackages[ Index ].PackageId ;
            return(STATUS_SUCCESS);
        }
    }
    for (Index = 0; Index < KsecDeferredPackageCount ; Index++ )
    {
        if (RtlEqualUnicodeString(
                PackageName,
                KsecDeferredPackages[Index].Name,
                TRUE))
        {
            *Package = KsecDeferredPackages[Index].Table;
            *PackageId = KsecDeferredPackages[ Index ].PackageId ;
            return(STATUS_SUCCESS);
        }
    }
    return(SEC_E_SECPKG_NOT_FOUND);
}


extern "C"
SECURITY_STATUS
SEC_ENTRY
SecSetPagingMode(
    BOOLEAN Pageable
    )
{
    ULONG PackageIndex ;
    NTSTATUS Status = STATUS_SUCCESS ;

    PAGED_CODE();

    FailIfNoPackages();

    ExAcquireFastMutex( &KsecPageModeMutex );

    if ( !Pageable )
    {
        //
        // If we have already done the work, just bump the counter and return
        //
        if ( KsecPageModeCounter++ )
        {
            ExReleaseFastMutex( &KsecPageModeMutex );

            return STATUS_SUCCESS ;
        }
    }
    else
    {
        //
        // If the counter is greater than one, don't worry about setting
        // or resetting everything
        //

        if ( --KsecPageModeCounter )
        {
            ExReleaseFastMutex( &KsecPageModeMutex );

            return STATUS_SUCCESS ;
        }
    }

    //
    // At this point, we must actually do the work:
    //

    if ( Pageable )
    {
        for ( PackageIndex = 0 ; PackageIndex < cKernelPackages ; PackageIndex++ )
        {
            if ( Packages[ PackageIndex ] &&
                 Packages[ PackageIndex ]->SetPackagePagingMode )
            {
                Status = Packages[ PackageIndex ]->SetPackagePagingMode( TRUE );

                if ( !NT_SUCCESS( Status ) )
                {
                    break;
                }
            }
        }

        if ( NT_SUCCESS( Status ) )
        {
            MmUnlockPagableImageSection( KsecPagableSection );

            KsecPagableSection = NULL ;
        }

    }
    else
    {
        KsecPagableSection = MmLockPagableCodeSection( CompleteAuthToken  );

        if ( KsecPagableSection )
        {
            for ( PackageIndex = 0 ; PackageIndex < cKernelPackages ; PackageIndex++ )
            {
                if ( Packages[ PackageIndex ] &&
                     Packages[ PackageIndex ]->SetPackagePagingMode )
                {
                    Status = Packages[ PackageIndex ]->SetPackagePagingMode( FALSE );

                    if ( !NT_SUCCESS( Status ) )
                    {
                        break;
                    }
                }
            }
        }
    }

    ExReleaseFastMutex( &KsecPageModeMutex );

    return Status ;
}


//+-------------------------------------------------------------------------
//
//  Function:   CompleteAuthToken
//
//  Synopsis:   Kernel dispatch stub for CompleteAuthToken - just turns
//              around and calls the package
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
CompleteAuthToken(
    PCtxtHandle                 phContext,          // Context to complete
    PSecBufferDesc              pToken              // Token to complete
    )
{
    SECURITY_STATUS scRet;

    PAGED_CODE();

    FailIfNoPackages();

    if (phContext->dwLower < cKernelPackages)
    {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->CompleteToken(
                    phContext->dwUpper,
                    pToken);
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   ImpersonateSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
ImpersonateSecurityContext(
    PCtxtHandle                 phContext           // Context to impersonate
    )
{
    SECURITY_STATUS scRet;
    PACCESS_TOKEN AccessToken = NULL;

    PAGED_CODE();

    FailIfNoPackages();

    if (phContext->dwLower < cKernelPackages)
    {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->GetToken(
                    phContext->dwUpper,
                    NULL,
                    &AccessToken
                    );
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    if (NT_SUCCESS(scRet))
    {
        ASSERT(AccessToken != NULL);
        scRet = PsImpersonateClient(
                    PsGetCurrentThread(),
                    AccessToken,
                    FALSE,              // don't copy on open
                    FALSE,              // not effective only
                    SeTokenImpersonationLevel(AccessToken)
                    );
    }

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   RevertSecurityContext
//
//  Synopsis:   Revert the thread to the process identity
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
RevertSecurityContext(
    PCtxtHandle                 phContext           // Context from which to re
    )
{
    SECURITY_IMPERSONATION_LEVEL Unused = SecurityImpersonation;

    PAGED_CODE();

    PsImpersonateClient(
        PsGetCurrentThread(),
        NULL,
        FALSE,
        FALSE,
        Unused
        );

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   QuerySecurityContextToken
//
//  Synopsis:   Returns a copy ofthe context's token
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
QuerySecurityContextToken(
    PCtxtHandle                 phContext,
    PHANDLE                     TokenHandle
    )
{
    SECURITY_STATUS scRet;
    HANDLE      hToken = NULL ;

    PAGED_CODE();

    FailIfNoPackages();

    if (phContext->dwLower < cKernelPackages)
    {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->GetToken(
                    phContext->dwUpper,
                    &hToken,
                    NULL
                    );
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }
    if (NT_SUCCESS(scRet))
    {
        //
        // Duplicate the token so the caller may hold onto it after
        // deleting the context
        //

        scRet = NtDuplicateObject(
                    NtCurrentProcess(),
                    hToken,
                    NtCurrentProcess(),
                    TokenHandle,
                    0,                  // desired access
                    0,                  // handle attributes
                    DUPLICATE_SAME_ACCESS
                    );
    }

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   QueryContextAttributes
//
//  Synopsis:   Queries attributes of a context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
QueryContextAttributes(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    SECURITY_STATUS scRet;

    PAGED_CODE();

    FailIfNoPackages();

    KSEC_CLEAR_CONTEXT_ATTR( ulAttribute, pBuffer );

    if (phContext->dwLower < cKernelPackages)
    {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->QueryAttributes(
                    phContext->dwUpper,
                    ulAttribute,
                    pBuffer);
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   MakeSignature
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]     -- context to use
//              [fQOP]          -- quality of protection to use
//              [pMessage]      -- message
//              [MessageSeqNo]  -- sequence number of message
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
MakeSignature(  PCtxtHandle         phContext,
                ULONG               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    SECURITY_STATUS scRet;

    MAYBE_PAGED_CODE();

    FailIfNoPackages();

    if (phContext->dwLower < cKernelPackages)
    {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->Sign(
                    phContext->dwUpper,
                    fQOP,
                    pMessage,
                    MessageSeqNo);
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   VerifySignature
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]     -- Context performing the unseal
//              [pMessage]      -- Message to verify
//              [MessageSeqNo]  -- Sequence number of this message
//              [pfQOPUsed]     -- quality of protection used
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
VerifySignature(PCtxtHandle     phContext,
                PSecBufferDesc  pMessage,
                ULONG           MessageSeqNo,
                ULONG *         pfQOP)
{
    SECURITY_STATUS scRet;

    MAYBE_PAGED_CODE();

    FailIfNoPackages();

    if (phContext->dwLower < cKernelPackages)
    {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->Verify(
                    phContext->dwUpper,
                    pMessage,
                    MessageSeqNo,
                    pfQOP);
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    return(scRet);

}


//+---------------------------------------------------------------------------
//
//  Function:   SealMessage
//
//  Synopsis:   Seals a message
//
//  Effects:
//
//  Arguments:  [phContext]     -- context to use
//              [fQOP]          -- quality of protection to use
//              [pMessage]      -- message
//              [MessageSeqNo]  -- sequence number of message
//
//  History:    5-06-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
SealMessage(    PCtxtHandle         phContext,
                ULONG               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    SECURITY_STATUS scRet;

    MAYBE_PAGED_CODE();

    FailIfNoPackages();

    if (phContext->dwLower < cKernelPackages)
    {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->Seal(
                    phContext->dwUpper,
                    fQOP,
                    pMessage,
                    MessageSeqNo);
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    return(scRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   UnsealMessage
//
//  Synopsis:   Unseal a private message
//
//  Arguments:  [phContext]     -- Context performing the unseal
//              [pMessage]      -- Message to unseal
//              [MessageSeqNo]  -- Sequence number of this message
//              [pfQOPUsed]     -- quality of protection used
//
//  History:    5-06-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
UnsealMessage(  PCtxtHandle         phContext,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo,
                ULONG *             pfQOP)
{
    SECURITY_STATUS scRet;

    MAYBE_PAGED_CODE();

    FailIfNoPackages();

    if (phContext->dwLower < cKernelPackages)   {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->Unseal(
                    phContext->dwUpper,
                    pMessage,
                    MessageSeqNo,
                    pfQOP);
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   DeleteUserModeContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
DeleteUserModeContext(
    IN PCtxtHandle phContext,           // Contxt to delete
    OUT PCtxtHandle phLsaContext
    )
{
    SECURITY_STATUS scRet;

    PAGED_CODE();

    FailIfNoPackages();

    if (phContext == NULL)
    {
        return(SEC_E_INVALID_HANDLE);
    }

    if (phContext->dwLower < cKernelPackages)   {

        if (Packages[KsecPackageIndex(phContext->dwLower)]->DeleteContext == NULL)
        {
            return(SEC_E_UNSUPPORTED_FUNCTION);
        }

        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->DeleteContext(
                    phContext->dwUpper,
                    &phLsaContext->dwUpper);

        if( scRet == STATUS_INVALID_HANDLE )
        {
            //
            // NTBUG 402192
            // incomplete kernel mode contexts will cause a leak in the LSA
            // process.
            // Tell the LSA to delete the LSA mode handle.
            //

            DebugLog(( DEB_WARN, "Possibly invalid handle passed to DeleteUserModeContext (incomplete? %lx)\n", phContext->dwUpper ));
            scRet = STATUS_SUCCESS;
        }

        if (NT_SUCCESS(scRet))
        {
            phLsaContext->dwLower = phContext->dwLower;
        }
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    return(scRet);
}


//--------------------------------------------------------------------------
//
//  Function:   MapKernelContextHandle
//
//  Synopsis:   Maps a context handle from kernel mode to lsa mode
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
MapKernelContextHandle(
    IN PCtxtHandle phContext,           // Contxt to map
    OUT PCtxtHandle phLsaContext
    )
{
    SECURITY_STATUS scRet = STATUS_SUCCESS;

    PAGED_CODE();

    FailIfNoPackages();

    //
    // If both elements are NULL, this is a null handle.
    //

    if ((phContext->dwLower == 0) && (phContext->dwUpper == 0))
    {
        *phLsaContext = *phContext;
    }
    else
    {
        if ( ( phContext->dwLower < cKernelPackages ) &&
             ( (PUCHAR) phContext->dwUpper < (PUCHAR) (MM_USER_PROBE_ADDRESS) ))
        {
            *phLsaContext = *phContext ;
            return STATUS_SUCCESS;
        }

        if (phContext->dwLower < cKernelPackages)   {
            scRet = Packages[KsecPackageIndex(phContext->dwLower)]->MapHandle(
                        phContext->dwUpper,
                        &phLsaContext->dwUpper);
            if (NT_SUCCESS(scRet))
            {
                phLsaContext->dwLower = phContext->dwLower;
            }
        }
        else
        {
            scRet = SEC_E_INVALID_HANDLE;
        }
    }

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   InitUserModeContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
InitUserModeContext(
    IN PCtxtHandle                 phContext,      // Contxt to init
    IN PSecBuffer                  pContextBuffer,
    OUT PCtxtHandle                phNewContext
    )
{
    SECURITY_STATUS scRet;

    PAGED_CODE();

    FailIfNoPackages();

    if (phContext->dwLower < cKernelPackages)   {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->InitContext(
                    phContext->dwUpper,
                    pContextBuffer,
                    &phNewContext->dwUpper
                    );
        if (NT_SUCCESS(scRet))
        {
            phNewContext->dwLower = phContext->dwLower;
        }
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   ExportSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
ExportSecurityContext(
    IN PCtxtHandle ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer MarshalledContext,
    OUT PHANDLE TokenHandle
    )
{
    SECURITY_STATUS scRet;

    PAGED_CODE();

    FailIfNoPackages();

    if (ContextHandle->dwLower < cKernelPackages)
    {
        scRet = Packages[KsecPackageIndex(ContextHandle->dwLower)]->ExportContext(
                    ContextHandle->dwUpper,
                    Flags,
                    MarshalledContext,
                    TokenHandle
                    );
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   ImportSecurityContextW
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
ImportSecurityContextW(
    IN PUNICODE_STRING PackageName,
    IN PSecBuffer MarshalledContext,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
    )
{
    PSECPKG_KERNEL_FUNCTION_TABLE Package;
    ULONG_PTR TempContextHandle = -1;
    ULONG_PTR PackageId = -1;
    SECURITY_STATUS SecStatus = STATUS_SUCCESS;

    PAGED_CODE();

    FailIfNoPackages();

    SecStatus = KsecLocatePackage( PackageName,&Package, &PackageId );

    if ( NT_SUCCESS( SecStatus )  )
    {
        if (Package->ImportContext != NULL)
        {
            SecStatus = Package->ImportContext(
                            MarshalledContext,
                            TokenHandle,
                            &TempContextHandle
                            );
        }
        else
        {
            SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        }

        if (NT_SUCCESS(SecStatus))
        {
            ContextHandle->dwUpper = TempContextHandle;
            ContextHandle->dwLower = PackageId;
        }
    }
    else
    {
        SecStatus =  SEC_E_SECPKG_NOT_FOUND;
    }

    return(SecStatus);
}

extern "C"
SECURITY_STATUS
SEC_ENTRY
KSecValidateBuffer(
    PUCHAR Buffer,
    ULONG Length
    )
{
    UCHAR Test ;
    ULONG ClaimedLength ;
    ULONG ByteCount ;
    ULONG i ;

    if ( Length == 0 )
    {
        return STATUS_SUCCESS ;
    }

    if ( Length >= sizeof( NtlmTag )  )
    {
        if ( RtlEqualMemory( Buffer, NtlmTag, sizeof( NtlmTag ) ) )
        {
            return STATUS_SUCCESS ;
        }
    }

    //
    // This does a poor man's validation of the BER encoded SNEGO buffer
    //

    //
    // First, make sure the first byte is a BER value for Context Specific
    //

    Test = Buffer[0] & 0xC0 ;

    if ( (Test != 0x80 ) &&
         (Test != 0x40 ) )
    {
//        DbgPrint( "KSEC:  Buffer does not lead off with 'Context' or 'Application' specific\n");
        goto Bad_Buffer ;
    }

    //
    // Now, check the claimed size in the header with the size we were passed:
    //

    Buffer++ ;
    ClaimedLength = 0 ;

    if (*Buffer & 0x80)
    {
        ByteCount = *Buffer++ & 0x7f;

        for (i = 0; i < ByteCount ; i++ )
        {
            ClaimedLength <<= 8;
            ClaimedLength += *Buffer++;
        }
    }
    else
    {
        ByteCount = 0;
        ClaimedLength = *Buffer++;
    }

    if ( (ClaimedLength + 2 + ByteCount) != Length )
    {
//        DbgPrint( "KSEC: Packet claimed length %x, actual length is %x\n",
//                    ClaimedLength + 2 + ByteCount, Length );

        goto Bad_Buffer ;
    }

    return STATUS_SUCCESS ;

Bad_Buffer:

    return STATUS_DATA_ERROR ;
}

NTSTATUS
KSecSerializeWinntAuthData(
    IN PVOID pvAuthData,
    OUT PULONG SerializedSize,
    OUT PVOID * SerializedData
    )
{
    PSEC_WINNT_AUTH_IDENTITY Auth ;
    PSEC_WINNT_AUTH_IDENTITY_EX AuthEx ;
    PSEC_WINNT_AUTH_IDENTITY_EX Serialized ;
    SEC_WINNT_AUTH_IDENTITY_EX Local ;
    ULONG Size = 0 ;
    PUCHAR Where ;
    NTSTATUS Status = STATUS_SUCCESS ;

    //
    // We're in kernel mode, so we're trusting our callers not to
    // pass us bogus data.  
    //

    Auth = (PSEC_WINNT_AUTH_IDENTITY) pvAuthData ;
    AuthEx = (PSEC_WINNT_AUTH_IDENTITY_EX) pvAuthData ;

    if ( AuthEx->Version == SEC_WINNT_AUTH_IDENTITY_VERSION )
    {
        //
        // This is a EX structure.  
        //

        if ( AuthEx->Flags & SEC_WINNT_AUTH_IDENTITY_MARSHALLED )
        {
            //
            // Easy case:  This is already serialized by the caller.
            //

            Size = sizeof( SEC_WINNT_AUTH_IDENTITY_EX ) ;

            if ( AuthEx->DomainLength )
            {
                Size += (AuthEx->DomainLength + 1) * sizeof(WCHAR) ;
                
            }
            if ( AuthEx->PackageListLength )
            {
                Size += (AuthEx->PackageListLength + 1) * sizeof( WCHAR );
                
            }

            if ( AuthEx->UserLength )
            {
                Size += (AuthEx->UserLength + 1) * sizeof( WCHAR );
                
            }

            if ( AuthEx->PasswordLength )
            {
                Size += (AuthEx->PasswordLength + 1) * sizeof( WCHAR );
                
            }

            *SerializedSize = Size ;
            *SerializedData = AuthEx ;

            return STATUS_SUCCESS ;
            
        }

        Auth = NULL ;

    }
    else
    {

        if ( Auth->Flags & SEC_WINNT_AUTH_IDENTITY_MARSHALLED )
        {
            //
            // Easy case:  This is already serialized by the caller.
            //

            Size = sizeof( SEC_WINNT_AUTH_IDENTITY ) ;

            if ( Auth->DomainLength )
            {
                Size += (Auth->DomainLength + 1) * sizeof( WCHAR ) ;
                
            }

            if ( Auth->PasswordLength )
            {
                Size += (Auth->PasswordLength + 1) * sizeof( WCHAR );
                
            }

            if ( Auth->UserLength )
            {
                Size += (Auth->UserLength + 1) * sizeof( WCHAR );
                
            }

            *SerializedSize = Size ;
            *SerializedData = Auth ;

            return STATUS_SUCCESS ;
        }

        AuthEx = NULL ;
    }

    if ( Auth )
    {
        Local.Flags = Auth->Flags ;
        Local.Domain = Auth->Domain ;
        Local.DomainLength = Auth->DomainLength ;
        Local.Password = Auth->Password ;
        Local.PasswordLength = Auth->PasswordLength ;
        Local.User = Auth->User ;
        Local.UserLength = Auth->UserLength ;

        Local.Version = SEC_WINNT_AUTH_IDENTITY_VERSION ;
        Local.Length = sizeof( SEC_WINNT_AUTH_IDENTITY_EX );
        Local.PackageList = NULL ;
        Local.PackageListLength = 0 ;

        AuthEx = &Local ;
    }

    if ( AuthEx )
    {
        Size = sizeof( SEC_WINNT_AUTH_IDENTITY_EX ) +
            ( AuthEx->DomainLength + AuthEx->PackageListLength +
            AuthEx->PasswordLength + AuthEx->UserLength + 4 ) * sizeof( WCHAR );

        Serialized = (PSEC_WINNT_AUTH_IDENTITY_EX) ExAllocatePool( PagedPool, Size );

        if ( Serialized )
        {
            Serialized->Flags = AuthEx->Flags | SEC_WINNT_AUTH_IDENTITY_MARSHALLED ;
            Serialized->Version = SEC_WINNT_AUTH_IDENTITY_VERSION ;
            Serialized->Length = sizeof( SEC_WINNT_AUTH_IDENTITY_EX );
            
            Where = (PUCHAR) ( Serialized + 1);

            if ( AuthEx->User )
            {
                Serialized->User = (PWSTR) (Where - (PUCHAR) Serialized );
                RtlCopyMemory(
                    Where,
                    AuthEx->User,
                    AuthEx->UserLength * sizeof( WCHAR ) );

                Serialized->UserLength = AuthEx->UserLength ;

                Where += AuthEx->UserLength * sizeof( WCHAR );

                *Where++ = '\0';    // unicode null terminator
                *Where++ = '\0';
            }
            else
            {
                Serialized->User = NULL ;
                Serialized->UserLength = 0 ;
            }

            if ( AuthEx->Domain )
            {
                Serialized->Domain = (PWSTR) (Where - (PUCHAR) Serialized );

                RtlCopyMemory(
                    Where,
                    AuthEx->Domain,
                    AuthEx->DomainLength * sizeof( WCHAR ) );

                Serialized->DomainLength = AuthEx->DomainLength ;

                Where += AuthEx->DomainLength * sizeof( WCHAR );

                *Where++ = '\0';    // unicode null terminator
                *Where++ = '\0';
            }
            else
            {
                Serialized->Domain = NULL ;
                Serialized->DomainLength = 0 ;
            }

            if ( AuthEx->Password )
            {
                Serialized->Password = (PWSTR) (Where - (PUCHAR) Serialized );
                RtlCopyMemory(
                    Where,
                    AuthEx->Password,
                    AuthEx->PasswordLength * sizeof( WCHAR ) );

                Serialized->PasswordLength = AuthEx->PasswordLength ;

                Where += AuthEx->PasswordLength * sizeof( WCHAR );

                *Where++ = '\0';    // unicode null terminator
                *Where++ = '\0';
            }
            else
            {
                Serialized->Password = NULL ;
                Serialized->PasswordLength = 0 ;
            }

            if ( AuthEx->PackageList )
            {
                Serialized->PackageList = (PWSTR) (Where - (PUCHAR) Serialized );
                RtlCopyMemory(
                    Where,
                    AuthEx->PackageList,
                    AuthEx->PackageListLength * sizeof( WCHAR ) );

                Serialized->PackageListLength = AuthEx->PackageListLength ;

                Where += AuthEx->PackageListLength * sizeof( WCHAR );

                *Where++ = '\0';    // unicode null terminator
                *Where++ = '\0';
            }
            else
            {
                Serialized->PackageList = NULL ;
                Serialized->PackageListLength = 0 ;
            }
        }
        else
        {
            Status = STATUS_NO_MEMORY ;
        }

        *SerializedSize = Size ;
        *SerializedData = Serialized;
    }

    return Status ;
}


//+---------------------------------------------------------------------------
//
//  Function:   KsecQueryContextAttributes
//
//  Synopsis:   Thunk to get from kernel to LSA mode
//
//  Arguments:  [phContext]   -- 
//              [Attribute]   -- 
//              [Buffer]      -- 
//              [Extra]       -- 
//              [ExtraLength] -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

SECURITY_STATUS
KsecQueryContextAttributes(
    IN PCtxtHandle  phContext,
    IN ULONG        Attribute,
    IN OUT PVOID    Buffer,
    IN PVOID        Extra,
    IN ULONG        ExtraLength
    )
{
    ULONG Allocs = MAX_BUFFERS_IN_CALL;
    PVOID Buffers[ MAX_BUFFERS_IN_CALL ];
    ULONG Flags ;
    PKSEC_LSA_MEMORY LsaMemory;
    NTSTATUS Status ;
    ULONG AttrSize ;
    ULONG Size ;

    AttrSize = KSecContextAttrSize( Attribute );
    Size = AttrSize + ExtraLength ;

    LsaMemory = KsecAllocLsaMemory( Size );

    if ( !LsaMemory )
    {
        return STATUS_NO_MEMORY ;
    }

    Status = KsecCopyPoolToLsa(
                LsaMemory,
                sizeof( KSEC_LSA_MEMORY_HEADER ),
                Buffer,
                AttrSize );

    if ( NT_SUCCESS( Status ) && ExtraLength )
    {
        Status = KsecCopyPoolToLsa(
                    LsaMemory,
                    sizeof( KSEC_LSA_MEMORY_HEADER ) + AttrSize,
                    Extra,
                    ExtraLength );
    }

    if ( !NT_SUCCESS( Status ) )
    {
        KsecFreeLsaMemory( LsaMemory );
        return Status ;
    }

    Flags = SPMAPI_FLAG_KMAP_MEM ;

    Status = SecpQueryContextAttributes(
                KsecLsaMemoryToContext(LsaMemory),
                phContext,
                Attribute,
                Buffer,
                &Allocs,
                Buffers,
                &Flags );

    if ( NT_SUCCESS( Status ) )
    {
        Status = KsecCopyLsaToPool(
                    Buffer,
                    LsaMemory,
                    (PUCHAR) LsaMemory->Region + sizeof( KSEC_LSA_MEMORY_HEADER ),
                    AttrSize );

        if ( NT_SUCCESS( Status ) && ExtraLength )
        {
            Status = KsecCopyLsaToPool(
                        Extra,
                        LsaMemory,
                        (PUCHAR) LsaMemory->Region + (sizeof( KSEC_LSA_MEMORY_HEADER) + AttrSize),
                        ExtraLength );
        }
    }

    KsecFreeLsaMemory( LsaMemory );

    return Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\wow6432\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.h
//
//  Contents:   Debug headers for the security dll
//
//  Classes:
//
//  Functions:
//
//  History:    4-26-93   RichardW   Created
//
//----------------------------------------------------------------------------

#include "..\dll\debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\wow6432\extapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        extapi.cxx
//
// Contents:    user-mode stubs for security extension APIs
//
//
// History:     3-5-94      MikeSw      Created
//
//------------------------------------------------------------------------

#include "..\dll\extapi.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\stubdll\stubdll.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       stubdll.c
//
//  Contents:   Stub calls to secur32.DLL
//
//  Classes:
//
//  Functions:
//
//  History:    10-05-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include <windows.h>

int
WINAPI
LibMain(
    HINSTANCE   hDll,
    DWORD       dwReason,
    PVOID       Context)
{
    DisableThreadLibraryCalls( hDll );
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\wow6432\sasl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       newstubs.cxx
//
//  Contents:   Stubs from ntlmssp
//
//  History:    9-06-96   RichardW   Stolen from ntlmssp
//
//----------------------------------------------------------------------------

#include "..\dll\sasl.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\wow6432\handle.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       handle.cxx
//
//  Contents:   Manages the handle map to the thunking layer.
//
//  Classes:
//
//  Functions:
//
//  History:    1-10-00   RichardW   Created
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
}

LIST_ENTRY HandleMapList ;
RTL_CRITICAL_SECTION HandleMapLock ;

BOOL
SecpInitHandleMap(
    VOID
    )
{
    NTSTATUS Status ;

    InitializeListHead( &HandleMapList );

    Status = RtlInitializeCriticalSection( &HandleMapLock );

    return NT_SUCCESS( Status );
}

BOOL
SecpFreeHandleMap(
    VOID
    )
{
    PLIST_ENTRY Scan ;

    RtlEnterCriticalSection( &HandleMapLock );

    while ( ! IsListEmpty( &HandleMapList ) )
    {
        Scan = RemoveHeadList( &HandleMapList );

        LocalFree( Scan );
    }

    RtlLeaveCriticalSection( &HandleMapLock );

    RtlDeleteCriticalSection( &HandleMapLock );

    return TRUE ;
}


BOOL
SecpAddHandleMap(
    IN PSEC_HANDLE_LPC LsaHandle,
    OUT PSECWOW_HANDLE_MAP * LocalHandle
    )
{
    PLIST_ENTRY Scan ;
    PSECWOW_HANDLE_MAP HandleMap = NULL ;


    //
    // The most labor intensive function.  First, scan through the list, 
    // checking if we already have an entry for this:
    //

    RtlEnterCriticalSection( &HandleMapLock );

    Scan = HandleMapList.Flink ;

    while ( Scan != &HandleMapList )
    {
        HandleMap = CONTAINING_RECORD( Scan, SECWOW_HANDLE_MAP, List );

        if ( RtlEqualMemory( &HandleMap->Handle,
                             LsaHandle,
                             sizeof( SEC_HANDLE_LPC ) ) )
        {
            break;
        }

        Scan = Scan->Flink ;

        HandleMap = NULL ;
    }

    if ( HandleMap )
    {
        HandleMap->RefCount++ ;
        HandleMap->HandleCount++ ;

    }

    RtlLeaveCriticalSection( &HandleMapLock );

    if ( !HandleMap )
    {
        HandleMap = (PSECWOW_HANDLE_MAP) LocalAlloc( LMEM_FIXED, 
                                                     sizeof( SECWOW_HANDLE_MAP ) );

        if ( HandleMap )
        {
            HandleMap->RefCount = 1;
            HandleMap->HandleCount = 1;
            HandleMap->Handle = *LsaHandle;

            RtlEnterCriticalSection( &HandleMapLock );

            InsertHeadList( &HandleMapList, &HandleMap->List );

            RtlLeaveCriticalSection( &HandleMapLock );

            DebugLog(( DEB_TRACE, "New handle map at %p, for " POINTER_FORMAT ":" POINTER_FORMAT "\n",
                       HandleMap, LsaHandle->dwUpper, LsaHandle->dwLower ));

        }
    }

    *LocalHandle = HandleMap ;

    return (HandleMap != NULL);
}

VOID
SecpDeleteHandleMap(
    IN PSECWOW_HANDLE_MAP HandleMap
    )
{
    RtlEnterCriticalSection( &HandleMapLock );

    HandleMap->HandleCount-- ;

    SecpDerefHandleMap( HandleMap );

    RtlLeaveCriticalSection( &HandleMapLock );
}

VOID
SecpDerefHandleMap(
    IN PSECWOW_HANDLE_MAP HandleMap
    )
{
    BOOL FreeIt = FALSE;

    RtlEnterCriticalSection( &HandleMapLock );

    HandleMap->RefCount-- ;

    if ( HandleMap->RefCount == 0 )
    {
        RemoveEntryList( &HandleMap->List );

        FreeIt = TRUE ;
    }

    RtlLeaveCriticalSection( &HandleMapLock );

    if ( FreeIt )
    {
        DebugLog(( DEB_TRACE, "Freeing handle map at %p, for " POINTER_FORMAT ":" POINTER_FORMAT "\n",
                   HandleMap, HandleMap->Handle.dwUpper, HandleMap->Handle.dwLower ));

        LocalFree( HandleMap );
    }
}

BOOL
SecpReferenceHandleMap(
    IN  PSECWOW_HANDLE_MAP HandleMap,
    OUT PSEC_HANDLE_LPC LsaHandle
    )
{
    BOOL        fRet = FALSE;
    PLIST_ENTRY Scan;

    //
    // Scan through the list to make sure this is a valid handle
    //

    RtlEnterCriticalSection( &HandleMapLock );

    for (Scan = HandleMapList.Flink; Scan != &HandleMapList; Scan = Scan->Flink)
    {
        if ((PSECWOW_HANDLE_MAP) Scan == HandleMap)
        {
            fRet = TRUE;
            break;
        }
    }

    if (fRet)
    {
        HandleMap->RefCount++ ;

        *LsaHandle = HandleMap->Handle ;
    }

    RtlLeaveCriticalSection( &HandleMapLock );

    if (fRet)
    {
        DebugLog(( DEB_TRACE, "Referencing handle map at %p for " POINTER_FORMAT ":" POINTER_FORMAT "\n",
                       HandleMap, HandleMap->Handle.dwUpper, HandleMap->Handle.dwLower ));
    }
    else
    {
        DebugLog(( DEB_TRACE, "Not referencing invalid handle map at %p\n", HandleMap));
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\wow6432\secdll.h ===
//+-----------------------------------------------------------------------
//
// File:        SECDLL.H
//
// Contents:    Security DLL private defines
//
//
// History:     11 Mar 92   RichardW    Recreated
//
//------------------------------------------------------------------------

#include "..\dll\secdll.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\wow6432\package.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        Package.c
//
// Contents:    Package management routines for the security DLL
//
//
// History:     12 Mar 92,  RichardW    Created
//              17 Aug 92,  RichardW    Rearranged, commented, etc.
//              08 Mar 94,  MikeSw      Moved to C++
//
//------------------------------------------------------------------------

#include "..\dll\package.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\wow6432\newstubs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       newstubs.cxx
//
//  Contents:   Stubs from ntlmssp
//
//  History:    9-06-96   RichardW   Stolen from ntlmssp
//
//----------------------------------------------------------------------------

#include "..\dll\newstubs.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\wow6432\negstubs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       negstubs.cxx
//
//  Contents:   Stubs to the negotiate package
//
//  Classes:
//
//  Functions:
//
//  History:    8-20-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "..\dll\negstubs.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\wow6432\lsastubs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       lsastubs.cxx
//
//  Contents:   Stubs to the pseudo-sspi dll that talks to the LSA
//
//  Classes:
//
//  Functions:
//
//  History:    8-20-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "..\dll\lsastubs.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\wow6432\stubs.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        stubs.cxx
//
// Contents:    user-mode stubs for security API
//
//
// History:     3/5/94      MikeSw      Created
//
//------------------------------------------------------------------------

#include "..\dll\stubs.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\wow6432\stubsa.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       stubsa.cxx
//
//  Contents:   ANSI stubs for security functions
//
//  History:    8-05-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "..\dll\stubsa.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\wow6432\userstub.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        userstub.cxx
//
// Contents:    stubs for user-mode security APIs
//
//
// History:     3-7-94      MikeSw      Created
//
//------------------------------------------------------------------------

#include "..\dll\userstub.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\wow6432\support.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        support.cxx
//
// Contents:    support routines for security dll
//
//
// History:     3-7-94      Created     MikeSw
//
//------------------------------------------------------------------------

#include "..\dll\support.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\au.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    au.h

Abstract:

    LSA Authentication - Exported Function Definitions, Datatypes and Defines

    This module contains the LSA Authentication Routines that may be called
    by parts of the LSA outside the Authentication sub-component.

Author:

    Scott Birrell       (ScottBi)       March 24, 1992

Environment:

Revision History:

--*/

NTSTATUS
LsapAuOpenSam( BOOLEAN DuringStartup );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\security\wow6432\xlate.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       xlate.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-02-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "..\dll\xlate.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\adt.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adt.h

Abstract:

    Local Security Authority - Audit Log Management - Public Defines,
    data and function prototypes.

    Functions, data and defines in this module are exported to the
    whole of the Lsa subsystem from the Auditing Sub-component.

Author:

    Scott Birrell       (ScottBi)      November 20, 1991

Environment:

Revision History:

--*/

#ifndef _ADT_H
#define _ADT_H


//
// Audit Log Information.  This must be kept in sync with the information
// in the Lsa Database.
//

extern POLICY_AUDIT_LOG_INFO LsapAdtLogInformation;

extern LSARM_POLICY_AUDIT_EVENTS_INFO LsapAdtEventsInformation;

POLICY_AUDIT_EVENT_TYPE
LsapAdtEventTypeFromCategoryId(
    IN ULONG CategoryId
    );

BOOLEAN
LsapAdtAuditingEnabledByCategory(
    IN POLICY_AUDIT_EVENT_TYPE Category,
    IN UINT AuditEventType
    );

NTSTATUS
LsapAdtAuditingEnabledBySid(
    IN POLICY_AUDIT_EVENT_TYPE Category,
    IN PSID UserSid,
    IN UINT AuditEventType,
    OUT PBOOLEAN bAudit
    );

NTSTATUS
LsapAdtAuditingEnabledByLogonId(
    IN POLICY_AUDIT_EVENT_TYPE Category,
    IN PLUID LogonId,
    IN UINT AuditEventType,
    OUT PBOOLEAN bAudit
    );

NTSTATUS
LsapAdtAuditingEnabledByPolicy(
    IN POLICY_AUDIT_EVENT_TYPE Category,
    IN PTOKEN_AUDIT_POLICY pPolicy,
    IN UINT AuditEventType,
    OUT PBOOLEAN bAudit
    );

BOOLEAN
LsapAdtAuditingEnabledHint(
    IN POLICY_AUDIT_EVENT_TYPE AuditCategory,
    IN UINT AuditEventType
    );

NTSTATUS
LsapAdtWriteLogWrkr(
    IN PLSA_COMMAND_MESSAGE CommandMessage,
    OUT PLSA_REPLY_MESSAGE ReplyMessage
    );

NTSTATUS
LsapAdtInitialize(
    );

NTSTATUS
LsapAdtInitializeDefaultAuditing(
    IN ULONG Options,
    OUT PLSARM_POLICY_AUDIT_EVENTS_INFO AuditEventsInformation
    );

VOID
LsapAdtAuditPackageLoad(
    PUNICODE_STRING PackageFileName
    );

VOID
LsapAdtGenerateLsaAuditSystemAccessChange(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PSID ClientSid,
    IN LUID CallerAuthenticationId,
    IN PSID TargetSid,
    IN PCWSTR szSystemAccess
    );

NTSTATUS
LsapAdtGenerateLsaAuditEvent(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG AuditEventCategory,
    IN ULONG AuditEventId,
    IN PPRIVILEGE_SET Privileges,
    IN ULONG SidCount,
    IN PSID *Sids OPTIONAL,
    IN ULONG UnicodeStringCount,
    IN PUNICODE_STRING UnicodeStrings OPTIONAL,
    IN PLSARM_POLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo OPTIONAL
    );

NTSTATUS
LsapAdtTrustedDomainAdd(
    IN USHORT          EventType,
    IN PUNICODE_STRING pName,
    IN PSID            pSid,
    IN ULONG           Type,
    IN ULONG           Direction,
    IN ULONG           Attributes
    );

NTSTATUS
LsapAdtTrustedDomainRem(
    IN USHORT          EventType,
    IN PUNICODE_STRING pName,
    IN PSID            pSid,
    IN PSID            pClientSid,
    IN PLUID           pClientAuthId
    );

NTSTATUS
LsapAdtTrustedDomainMod(
    IN USHORT          EventType,
    IN PSID            pDomainSid,

    IN PUNICODE_STRING pOldName,
    IN ULONG           OldType,
    IN ULONG           OldDirection,
    IN ULONG           OldAttributes,

    IN PUNICODE_STRING pNewName,
    IN ULONG           NewType,
    IN ULONG           NewDirection,
    IN ULONG           NewAttributes
    );


NTSTATUS
LsapAdtGenerateLsaAuditEventWithClientSid(
    IN ULONG AuditEventCategory,
    IN ULONG AuditEventId,
    IN PSID ClientSid,
    IN LUID ClientAuthenticationId,
    IN PPRIVILEGE_SET Privileges,
    IN ULONG SidCount,
    IN PSID *Sids OPTIONAL,
    IN ULONG UnicodeStringCount,
    IN PUNICODE_STRING UnicodeStrings OPTIONAL,
    IN PLSARM_POLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo OPTIONAL
    );

typedef enum _OBJECT_OPERATION_TYPE {
    ObjectOperationNone=0,
    ObjectOperationQuery,
    ObjectOperationDummyLast
} OBJECT_OPERATION_TYPE;

NTSTATUS
LsapAdtGenerateObjectOperationAuditEvent(
    IN LSAPR_HANDLE ObjectHandle,
    IN USHORT AuditEventType,
    IN OBJECT_OPERATION_TYPE OperationType
    );

NTSTATUS
LsapAdtGenerateDomainPolicyChangeAuditEvent(
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    IN USHORT AuditEventType,
    IN LSAP_DB_ATTRIBUTE* OldAttributes,
    IN LSAP_DB_ATTRIBUTE* NewAttributes,
    IN ULONG AttributeCount
    );

NTSTATUS
LsapAdtTrustedForestNamespaceCollision(
    IN LSA_FOREST_TRUST_COLLISION_RECORD_TYPE CollisionTargetType,
    IN PUNICODE_STRING pCollisionTargetName,
    IN PUNICODE_STRING pForestRootDomainName,
    IN PUNICODE_STRING pTopLevelName,
    IN PUNICODE_STRING pDnsName,
    IN PUNICODE_STRING pNetbiosName,
    IN PSID            pSid,
    IN ULONG           NewFlags
    );

NTSTATUS
LsapAdtTrustedForestInfoEntryAdd(
    IN PUNICODE_STRING pForestRootDomainName,
    IN PSID            pForestRootDomainSid,
    IN PLUID           pOperationId,
    IN LSA_FOREST_TRUST_RECORD_TYPE EntryType,
    IN ULONG           Flags,
    IN PUNICODE_STRING TopLevelName,
    IN PUNICODE_STRING DnsName,
    IN PUNICODE_STRING NetbiosName,
    IN PSID            pSid
    );

NTSTATUS
LsapAdtTrustedForestInfoEntryRem(
    IN PUNICODE_STRING pForestRootDomainName,
    IN PSID            pForestRootDomainSid,
    IN PLUID           pOperationId,
    IN LSA_FOREST_TRUST_RECORD_TYPE EntryType,
    IN ULONG           Flags,
    IN PUNICODE_STRING TopLevelName,
    IN PUNICODE_STRING DnsName,
    IN PUNICODE_STRING NetbiosName,
    IN PSID            pSid
    );

NTSTATUS
LsapAdtTrustedForestInfoEntryMod(
    IN PUNICODE_STRING pForestRootDomainName,
    IN PSID            pForestRootDomainSid,
    IN PLUID           pOperationId,
    IN LSA_FOREST_TRUST_RECORD_TYPE EntryType,
                                    
    IN ULONG           OldFlags,
    IN PUNICODE_STRING pOldTopLevelName,
    IN PUNICODE_STRING pOldDnsName,
    IN PUNICODE_STRING pOldNetbiosName,
    IN PSID            pOldSid,
                       
    IN ULONG           NewFlags,
    IN PUNICODE_STRING pNewTopLevelName,
    IN PUNICODE_STRING pNewDnsName,
    IN PUNICODE_STRING pNewNetbiosName,
    IN PSID            pNewSid
    );

//
// Macro to determine the size of a PRIVILEGE_SET
//

#define LsapPrivilegeSetSize( PrivilegeSet )                                   \
        ( ( PrivilegeSet ) == NULL ? 0 :                                       \
        ((( PrivilegeSet )->PrivilegeCount > 0)                                \
         ?                                                                     \
         ((ULONG)sizeof(PRIVILEGE_SET) +                                       \
           (                                                                   \
             (( PrivilegeSet )->PrivilegeCount  -  ANYSIZE_ARRAY) *            \
             (ULONG)sizeof(LUID_AND_ATTRIBUTES)                                \
           )                                                                   \
         )                                                                     \
         : ((ULONG)sizeof(PRIVILEGE_SET) - (ULONG)sizeof(LUID_AND_ATTRIBUTES)) \
        ))

ULONG
LsapStringListSize(
    IN  PLSA_ADT_STRING_LIST pStringList
    );

ULONG
LsapSidListSize(
    IN  PLSA_ADT_SID_LIST pSidList
    );

#endif // _ADT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\adtp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtp.h

Abstract:

    Local Security Authority - Audit Log Management - Private Defines,
    data and function prototypes.

    Functions, data and defines in this module are internal to the
    Auditing Subcomponent of the LSA Subsystem.

Author:

    Scott Birrell       (ScottBi)      November 20, 1991

Environment:

Revision History:

--*/

#ifndef _LSAP_ADTP_
#define _LSAP_ADTP_


#include "ausrvp.h"
#include "cfiles\adtdebug.h"

//
// Names of the registry keys where security event log information
// is rooted and the object names are listed under an event source
// module.
//

#define LSAP_ADT_AUDIT_MODULES_KEY_NAME L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\EventLog\\Security"
#define LSAP_ADT_OBJECT_NAMES_KEY_NAME  L"ObjectNames"                                                        

#define MAX_OBJECT_TYPES 32


//
// Macros for setting fields in an SE_AUDIT_PARAMETERS array.
//
// These must be kept in sync with similar macros in se\sepaudit.c.
//


#define LsapSetParmTypeSid( AuditParameters, Index, Sid )                      \
    {                                                                          \
        if( Sid ) {                                                            \
                                                                               \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeSid;         \
        (AuditParameters).Parameters[(Index)].Length = RtlLengthSid( (Sid) );  \
        (AuditParameters).Parameters[(Index)].Address = (Sid);                 \
                                                                               \
        } else {                                                               \
                                                                               \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeNone;        \
        (AuditParameters).Parameters[(Index)].Length = 0;                      \
        (AuditParameters).Parameters[(Index)].Address = NULL;                  \
                                                                               \
        }                                                                      \
    }


#define LsapSetParmTypeAccessMask( AuditParameters, Index, AccessMask, ObjectTypeIndex ) \
    {                                                                                    \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeAccessMask;            \
        (AuditParameters).Parameters[(Index)].Length = sizeof( ACCESS_MASK );            \
        (AuditParameters).Parameters[(Index)].Data[0] = (AccessMask);                    \
        (AuditParameters).Parameters[(Index)].Data[1] = (ObjectTypeIndex);               \
    }



#define LsapSetParmTypeString( AuditParameters, Index, String )                \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeString;      \
        (AuditParameters).Parameters[(Index)].Length =                         \
                sizeof(UNICODE_STRING)+(String)->Length;                       \
        (AuditParameters).Parameters[(Index)].Address = (String);              \
    }


#define LsapSetParmTypeUlong( AuditParameters, Index, Ulong )                  \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeUlong;       \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( (Ulong) );     \
        (AuditParameters).Parameters[(Index)].Data[0] = (ULONG)(Ulong);        \
    }


#define LsapSetParmTypeHexUlong( AuditParameters, Index, Ulong )               \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeHexUlong;    \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( (Ulong) );     \
        (AuditParameters).Parameters[(Index)].Data[0] = (ULONG)(Ulong);        \
    }


#define LsapSetParmTypeHexInt64( AuditParameters, Index, Qword )               \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeHexInt64;    \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( (Qword) );     \
        *(PULONGLONG)((AuditParameters).Parameters[(Index)].Data) = (Qword);   \
    }


#define LsapSetParmTypeTime( AuditParameters, Index, Time )                                  \
    {                                                                                        \
        (AuditParameters).Parameters[(Index)].Type    = SeAdtParmTypeTime;                   \
        (AuditParameters).Parameters[(Index)].Length  = sizeof( LARGE_INTEGER );             \
        *(PLARGE_INTEGER)((AuditParameters).Parameters[(Index)].Data) = (Time);              \
    }


#define LsapSetParmTypeDateTime( AuditParameters, Index, Time )                              \
    {                                                                                        \
        (AuditParameters).Parameters[(Index)].Type    = SeAdtParmTypeDateTime;               \
        (AuditParameters).Parameters[(Index)].Length  = sizeof( LARGE_INTEGER );             \
        *(PLARGE_INTEGER)((AuditParameters).Parameters[(Index)].Data) = (Time);              \
    }


#define LsapSetParmTypeDuration( AuditParameters, Index, Duration )                          \
    {                                                                                        \
        (AuditParameters).Parameters[(Index)].Type    = SeAdtParmTypeDuration;               \
        (AuditParameters).Parameters[(Index)].Length  = sizeof( LARGE_INTEGER );             \
        *(PLARGE_INTEGER)((AuditParameters).Parameters[(Index)].Data) = (Duration);          \
    }


#define LsapSetParmTypeGuid( AuditParameters, Index, pGuid )                   \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type    = SeAdtParmTypeGuid;     \
        (AuditParameters).Parameters[(Index)].Length  = sizeof( GUID );        \
        (AuditParameters).Parameters[(Index)].Address = (pGuid);               \
    }


#define LsapSetParmTypeNoLogon( AuditParameters, Index )                       \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeNoLogonId;   \
    }


#define LsapSetParmTypeLogonId( AuditParameters, Index, LogonId )              \
    {                                                                          \
        PLUID TmpLuid;                                                         \
                                                                               \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeLogonId;     \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( (LogonId) );   \
        TmpLuid = (PLUID)(&(AuditParameters).Parameters[(Index)].Data[0]);     \
        *TmpLuid = (LogonId);                                                  \
    }


#define LsapSetParmTypePrivileges( AuditParameters, Index, Privileges )                      \
    {                                                                                        \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypePrivs;                     \
        (AuditParameters).Parameters[(Index)].Length = LsapPrivilegeSetSize( (Privileges) ); \
        (AuditParameters).Parameters[(Index)].Address = (Privileges);                        \
    }


#define LsapSetParmTypeStringList( AuditParameters, Index, StringList )                      \
    {                                                                                        \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeStringList;                \
        (AuditParameters).Parameters[(Index)].Length = LsapStringListSize( (StringList) );   \
        (AuditParameters).Parameters[(Index)].Address = (StringList);                        \
    }


#define LsapSetParmTypeSidList( AuditParameters, Index, SidList )                            \
    {                                                                                        \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeSidList;                   \
        (AuditParameters).Parameters[(Index)].Length = LsapSidListSize( (SidList) );         \
        (AuditParameters).Parameters[(Index)].Address = (SidList);                           \
    }


#define LsapSetParmTypeUac( AuditParameters, Index, OldUac, NewUac )                         \
    {                                                                                        \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeUserAccountControl;        \
        (AuditParameters).Parameters[(Index)].Length = 2 * sizeof(ULONG);                    \
        (AuditParameters).Parameters[(Index)].Data[0] = (ULONG_PTR) (OldUac);                \
        (AuditParameters).Parameters[(Index)].Data[1] = (ULONG_PTR) (NewUac);                \
    }


#define LsapSetParmTypeNoUac( AuditParameters, Index )                                       \
    {                                                                                        \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeNoUac;                     \
    }


#define LsapSetParmTypePtr( AuditParameters, Index, Ptr )                                    \
    {                                                                                        \
        (AuditParameters).Parameters[(Index)].Type    = SeAdtParmTypePtr;                    \
        (AuditParameters).Parameters[(Index)].Length  = sizeof(ULONG_PTR);                   \
        (AuditParameters).Parameters[(Index)].Data[0] = (ULONG_PTR) (Ptr);                   \
    }


#define LsapSetParmTypeMessage( AuditParameters, Index, MessageId )                          \
    {                                                                                        \
        (AuditParameters).Parameters[(Index)].Type    = SeAdtParmTypeMessage;                \
        (AuditParameters).Parameters[(Index)].Length  = sizeof(ULONG);                       \
        (AuditParameters).Parameters[(Index)].Data[0] = (ULONG_PTR) (MessageId);             \
    }

#define LsapSetParmTypeSockAddr( AuditParameters, Index, pSockAddr )       \
    {                                                                      \
        USHORT sa_family = ((SOCKADDR*) pSockAddr)->sa_family;             \
                                                                           \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeSockAddr;\
        if ( sa_family == AF_INET6 )                                       \
        {                                                                  \
            (AuditParameters).Parameters[(Index)].Length = sizeof(SOCKADDR_IN6);\
        }                                                                  \
        else if ( sa_family == AF_INET )                                   \
        {                                                                  \
            (AuditParameters).Parameters[(Index)].Length = sizeof(SOCKADDR_IN);\
        }                                                                  \
        else                                                               \
        {                                                                  \
            (AuditParameters).Parameters[(Index)].Length = sizeof(SOCKADDR);\
            if ( sa_family != 0 )                                          \
            {                                                              \
               AdtAssert(FALSE, ("LsapSetParmTypeSockAddr: invalid sa_family: %d",sa_family));                                                                    \
            }                                                              \
        }                                                                  \
        (AuditParameters).Parameters[(Index)].Address = (pSockAddr);       \
    }



#define IsInRange(item,min_val,max_val) \
            (((item) >= min_val) && ((item) <= max_val))

//       
// see msaudite.mc for def. of valid category-id
//
#define IsValidCategoryId(c) \
            (IsInRange((c), SE_ADT_MIN_CATEGORY_ID, SE_ADT_MAX_CATEGORY_ID))

//
// see msaudite.mc for def. of valid audit-id
//

#define IsValidAuditId(a) \
            (IsInRange((a), SE_ADT_MIN_AUDIT_ID, SE_ADT_MAX_AUDIT_ID))

//
// check for reasonable value of parameter count. we must have atleast
// 2 parameters in the audit-params array. Thus the min limit is 3.
// The max limit is determined by the value in ntlsa.h
//

#define IsValidParameterCount(p) \
            (IsInRange((p), 2, SE_MAX_AUDIT_PARAMETERS))


//
// macro used by LsapAdtDemarshallAuditInfo and LsapAuditFailed
// to decide when not to assert in DBG build
//

#define LsapAdtNeedToAssert( Status ) \
           (( Status != STATUS_LOG_FILE_FULL          ) && \
            ( Status != STATUS_DISK_FULL              ) && \
            ( Status != STATUS_INSUFFICIENT_RESOURCES ) && \
            ( Status != STATUS_NO_MEMORY              ) && \
            ( Status != STATUS_COMMITMENT_LIMIT       ))


#define SEP_MAX_PRIVILEGE_COUNT (SE_MAX_WELL_KNOWN_PRIVILEGE-SE_MIN_WELL_KNOWN_PRIVILEGE+32)

#define IsValidPrivilegeCount( count ) ((count == 0) || \
                                        ((count > 0) && \
                                         (count <= SEP_MAX_PRIVILEGE_COUNT)))



///////////////////////////////////////////////////////////////////////////
//                                                                       //
// Private data for Audit Log Management                                 //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

#define LSAP_ADT_LOG_FULL_SHUTDOWN_TIMEOUT    (ULONG) 0x0000012cL

extern RTL_CRITICAL_SECTION LsapAdtLogFullLock;

//
// Structure describing a queued audit record
//

typedef struct _LSAP_ADT_QUEUED_RECORD {

    LIST_ENTRY             Link;
    SE_ADT_PARAMETER_ARRAY Buffer;

} LSAP_ADT_QUEUED_RECORD, *PLSAP_ADT_QUEUED_RECORD;

//
// Audit Log Queue Header.  The queue is maintained in chronological
// (FIFO) order.  New records are appended to the back of the queue.
//

typedef struct _LSAP_ADT_LOG_QUEUE_HEAD {

    PLSAP_ADT_QUEUED_RECORD FirstQueuedRecord;
    PLSAP_ADT_QUEUED_RECORD LastQueuedRecord;

} LSAP_ADT_LOG_QUEUE_HEAD, *PLSAP_ADT_LOG_QUEUE_HEAD;

//
// String that will be passed in for SubsystemName for audits generated
// by LSA (eg, logon, logoff, restart, etc).
//

extern UNICODE_STRING LsapSubsystemName;

//
// String that will be passed in for SubsystemName for some audits generated
// by LSA for LSA objects (PolicyObject, SecretObject, TrustedDomainObject, UserAccountObject).
//

extern UNICODE_STRING LsapLsaName;

//
// max number of replacement string params that we support in 
// eventlog audit record. 
//
#define SE_MAX_AUDIT_PARAM_STRINGS 48

//
// Maximum number of strings used to represent an ObjectTypeList.
//

#define LSAP_ADT_OBJECT_TYPE_STRINGS 1

///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//      The following structures and data are used by LSA to contain          /
//      drive letter-device name mapping information.  LSA obtains this       /
//      information once during initialization and saves it for use           /
//      by auditing code.                                                     /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//      The DRIVE_MAPPING structure contains the drive letter (without        /
//      the colon) and a unicode string containing the name of the            /
//      corresponding device.  The buffer in the unicode string is            /
//      allocated from the LSA heap and is never freed.                       /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////


typedef struct _DRIVE_MAPPING {
    WCHAR DriveLetter;
    UNICODE_STRING DeviceName;
} DRIVE_MAPPING, PDRIVE_MAPPING;


////////////////////////////////////////////////////////////////////////////////
//                                                                             /
//      We assume a maximum of 26 drive letters.  Though no auditing           /
//      will occur due to references to files on floppy (drives A and          /
//      B), perform their name lookup anyway.  This will then just             /
//      work if somehow we start auditing files on floppies.                   /
//                                                                             /
////////////////////////////////////////////////////////////////////////////////

#define MAX_DRIVE_MAPPING  26

extern DRIVE_MAPPING DriveMappingArray[];

//
// This is a structure that contains all auditing information specific to a 
// monitored user.  Currently this information is read from the registry.
//

typedef struct _PER_USER_AUDITING_ELEMENT {
    struct _PER_USER_AUDITING_ELEMENT * Next;
    PSID pSid;
    ULONGLONG RawPolicy;
    TOKEN_AUDIT_POLICY TokenAuditPolicy;
    TOKEN_AUDIT_POLICY_ELEMENT PolicyArray[POLICY_AUDIT_EVENT_TYPE_COUNT - 1];
} PER_USER_AUDITING_ELEMENT, *PPER_USER_AUDITING_ELEMENT;

//
// This structure allows for the per user auditing settings for a user 
// to be queried by the logon ID.
// 

typedef struct _PER_USER_AUDITING_LUID_QUERY_ELEMENT {
    struct _PER_USER_AUDITING_LUID_QUERY_ELEMENT * Next;
    LUID Luid;
    TOKEN_AUDIT_POLICY Policy;
    TOKEN_AUDIT_POLICY_ELEMENT PolicyArray[POLICY_AUDIT_EVENT_TYPE_COUNT - ANYSIZE_ARRAY];
} PER_USER_AUDITING_LUID_QUERY_ELEMENT, *PPER_USER_AUDITING_LUID_QUERY_ELEMENT;

#define PER_USER_AUDITING_POLICY_TABLE_SIZE 11
#define PER_USER_AUDITING_LUID_TABLE_SIZE   16
#define PER_USER_AUDITING_MAX_POLICY_SIZE (sizeof(TOKEN_AUDIT_POLICY) + (sizeof(TOKEN_AUDIT_POLICY_ELEMENT) * (POLICY_AUDIT_EVENT_TYPE_COUNT - ANYSIZE_ARRAY)))

extern LONG LsapAdtPerUserAuditUserCount;
extern LONG LsapAdtPerUserAuditLogonCount;
extern LONG LsapAdtPerUserAuditHint[POLICY_AUDIT_EVENT_TYPE_COUNT];
extern LONG LsapAdtPerUserPolicyCategoryCount[POLICY_AUDIT_EVENT_TYPE_COUNT];
extern HKEY LsapAdtPerUserKey;
extern HANDLE LsapAdtPerUserKeyEvent;
extern HANDLE LsapAdtPerUserKeyTimer;
extern RTL_RESOURCE LsapAdtPerUserPolicyTableResource;
extern RTL_RESOURCE LsapAdtPerUserLuidTableResource;
extern PPER_USER_AUDITING_ELEMENT LsapAdtPerUserAuditingTable[PER_USER_AUDITING_POLICY_TABLE_SIZE];

//
// macros to get the table locks for the per user settings.
//

#define LsapAdtAcquirePerUserPolicyTableReadLock()  RtlAcquireResourceShared(&LsapAdtPerUserPolicyTableResource, TRUE)
#define LsapAdtAcquirePerUserPolicyTableWriteLock() RtlAcquireResourceExclusive(&LsapAdtPerUserPolicyTableResource, TRUE);
#define LsapAdtReleasePerUserPolicyTableLock()      RtlReleaseResource(&LsapAdtPerUserPolicyTableResource)

#define LsapAdtAcquirePerUserLuidTableReadLock()  RtlAcquireResourceShared(&LsapAdtPerUserLuidTableResource, TRUE)
#define LsapAdtAcquirePerUserLuidTableWriteLock() RtlAcquireResourceExclusive(&LsapAdtPerUserLuidTableResource, TRUE);
#define LsapAdtReleasePerUserLuidTableLock()      RtlReleaseResource(&LsapAdtPerUserLuidTableResource)

//
// Special privilege values which are not normally audited,
// but generate audits when assigned to a user.  See
// LsapAdtAuditSpecialPrivileges.
//

extern LUID ChangeNotifyPrivilege;
extern LUID AuditPrivilege;
extern LUID CreateTokenPrivilege;
extern LUID AssignPrimaryTokenPrivilege;
extern LUID BackupPrivilege;
extern LUID RestorePrivilege;
extern LUID DebugPrivilege;

//
// Global variable to indicate whether or not we're
// supposed to crash when an audit fails.
//

extern BOOLEAN LsapCrashOnAuditFail;
extern BOOLEAN LsapAllowAdminLogonsOnly;




////////////////////////////////////////////////////////////////////////////////
//                                                                             /
//                                                                             /
////////////////////////////////////////////////////////////////////////////////


NTSTATUS
LsapAdtWriteLog(
    IN OPTIONAL PSE_ADT_PARAMETER_ARRAY AuditRecord
    );

NTSTATUS
LsapAdtDemarshallAuditInfo(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters
    );

VOID
LsapAdtNormalizeAuditInfo(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters
    );

NTSTATUS
LsapAdtOpenLog(
    OUT PHANDLE AuditLogHandle
    );

VOID
LsapAdtAuditLogon(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING Source,
    IN PUNICODE_STRING PackageName,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PSID UserSid,
    IN LUID AuthenticationId,
    IN PUNICODE_STRING WorkstationName,
    IN NTSTATUS LogonStatus,
    IN NTSTATUS SubStatus,
    IN LPGUID LogonGuid,                        OPTIONAL
    IN PLUID  CallerLogonId,                    OPTIONAL
    IN PHANDLE CallerProcessID,                 OPTIONAL
    IN PLSA_ADT_STRING_LIST TransittedServices, OPTIONAL
    IN SOCKADDR* pSockAddr                      OPTIONAL
    );

VOID
LsapAuditLogonHelper(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN PSID UserSid,                            OPTIONAL
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId,
    IN LPGUID LogonGuid,                        OPTIONAL
    IN PLUID  CallerLogonId,                    OPTIONAL
    IN PHANDLE CallerProcessID,                 OPTIONAL
    IN PLSA_ADT_STRING_LIST TransittedServices  OPTIONAL
    );

VOID
LsapAdtSystemRestart(
    PLSARM_POLICY_AUDIT_EVENTS_INFO AuditEventsInfo
    );

VOID
LsapAdtAuditLogonProcessRegistration(
    IN PLSAP_AU_REGISTER_CONNECT_INFO_EX ConnectInfo
    );


NTSTATUS
LsapAdtInitializeLogQueue(
    VOID
    );

NTSTATUS
LsapAdtQueueRecord(
    IN PSE_ADT_PARAMETER_ARRAY AuditRecord
    );

#define LsapAdtAcquireLogFullLock()  RtlEnterCriticalSection(&LsapAdtLogFullLock)
#define LsapAdtReleaseLogFullLock()  RtlLeaveCriticalSection(&LsapAdtLogFullLock)


NTSTATUS
LsapAdtObjsInitialize(
    );



NTSTATUS
LsapAdtBuildDashString(
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildUlongString(
    IN ULONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildHexUlongString(
    IN ULONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildHexInt64String(
    IN PULONGLONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildPtrString(
    IN  PVOID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildLuidString(
    IN PLUID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );


NTSTATUS
LsapAdtBuildSidString(
    IN PSID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildObjectTypeStrings(
    IN PUNICODE_STRING SourceModule,
    IN PUNICODE_STRING ObjectTypeName,
    IN PSE_ADT_OBJECT_TYPE ObjectTypeList,
    IN ULONG ObjectTypeCount,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone,
    OUT PUNICODE_STRING NewObjectTypeName
    );

NTSTATUS
LsapAdtBuildAccessesString(
    IN PUNICODE_STRING SourceModule,
    IN PUNICODE_STRING ObjectTypeName,
    IN ACCESS_MASK Accesses,
    IN BOOLEAN Indent,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildFilePathString(
    IN PUNICODE_STRING Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildLogonIdStrings(
    IN PLUID LogonId,
    OUT PUNICODE_STRING ResultantString1,
    OUT PBOOLEAN FreeWhenDone1,
    OUT PUNICODE_STRING ResultantString2,
    OUT PBOOLEAN FreeWhenDone2,
    OUT PUNICODE_STRING ResultantString3,
    OUT PBOOLEAN FreeWhenDone3
    );

NTSTATUS
LsapBuildPrivilegeAuditString(
    IN PPRIVILEGE_SET PrivilegeSet,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildTimeString(
    IN PLARGE_INTEGER Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildDateString(
    IN PLARGE_INTEGER Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildDateTimeString(
    IN PLARGE_INTEGER Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildDurationString(
    IN  PLARGE_INTEGER Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildGuidString(
    IN  LPGUID pGuid,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildStringListString(
    IN  PLSA_ADT_STRING_LIST pList,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildSidListString(
    IN  PLSA_ADT_SID_LIST pList,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildUserAccountControlString(
    IN  ULONG UserAccountControlOld,
    IN  ULONG UserAccountControlNew,
    OUT PUNICODE_STRING ResultantString1,
    OUT PBOOLEAN FreeWhenDone1,
    OUT PUNICODE_STRING ResultantString2,
    OUT PBOOLEAN FreeWhenDone2,
    OUT PUNICODE_STRING ResultantString3,
    OUT PBOOLEAN FreeWhenDone3
    );

NTSTATUS
LsapAdtBuildMessageString(
    IN  ULONG MessageId,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildSockAddrString(
    IN  PSOCKADDR       pSockAddr, 
    OUT PUNICODE_STRING ResultantString1,
    OUT PBOOLEAN        FreeWhenDone1,
    OUT PUNICODE_STRING ResultantString2,
    OUT PBOOLEAN        FreeWhenDone2
    );

NTSTATUS
LsapAdtMarshallAuditRecord(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters,
    OUT PSE_ADT_PARAMETER_ARRAY *MarshalledAuditParameters
    );

NTSTATUS
LsapAdtInitializePerUserAuditing(
    VOID
    );

NTSTATUS
LsapAdtInitializeDriveLetters(
    VOID
    );

BOOLEAN
LsapAdtLookupDriveLetter(
    IN PUNICODE_STRING FileName,
    OUT PUSHORT DeviceNameLength,
    OUT PWCHAR DriveLetter
    );

VOID
LsapAdtSubstituteDriveLetter(
    IN PUNICODE_STRING FileName
    );

VOID
LsapAdtUserRightAssigned(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PSID UserSid,
    IN LUID CallerAuthenticationId,
    IN PSID ClientSid,
    IN PPRIVILEGE_SET Privileges
    );

VOID
LsapAdtTrustedDomain(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PSID ClientSid,
    IN LUID CallerAuthenticationId,
    IN PSID TargetSid,
    IN PUNICODE_STRING DomainName
    );

VOID
LsapAdtAuditLogoff(
    PLSAP_LOGON_SESSION Session
    );

VOID
LsapAdtPolicyChange(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PSID ClientSid,
    IN LUID CallerAuthenticationId,
    IN PLSARM_POLICY_AUDIT_EVENTS_INFO LsapAdtEventsInformation
    );

VOID
LsapAdtAuditSpecialPrivileges(
    PPRIVILEGE_SET Privileges,
    LUID LogonId,
    PSID UserSid
    );

VOID
LsapAuditFailed(
    IN NTSTATUS AuditStatus
    );

NTSTATUS
LsapAdtInitParametersArray(
    IN SE_ADT_PARAMETER_ARRAY* AuditParameters,
    IN ULONG AuditCategoryId,
    IN ULONG AuditId,
    IN USHORT AuditEventType,
    IN USHORT ParameterCount,
    ...);

NTSTATUS
LsapAdtInitGenericAudits( 
    VOID 
    );

NTSTATUS
LsapAdtInitializeExtensibleAuditing(
    );

NTSTATUS
LsapAdtConstructTablePerUserAuditing(
    VOID
    );

VOID
LsapAdtFreeTablePerUserAuditing(
    VOID
    );

NTSTATUS 
LsapAdtOpenPerUserAuditingKey(
    VOID
    );

ULONG
LsapAdtHashPerUserAuditing(
    IN PSID pSid
    );

NTSTATUS
LsapAdtConstructPolicyPerUserAuditing(
    IN ULONGLONG RawPolicy,
    OUT PTOKEN_AUDIT_POLICY pTokenPolicy,
    IN OUT PULONG TokenPolicyLength
    );

NTSTATUS
LsapAdtQueryPerUserAuditing(
    IN PSID pInputSid,
    OUT PTOKEN_AUDIT_POLICY pPolicy,
    IN OUT PULONG pLength,
    OUT PBOOLEAN bFound
    );

NTSTATUS
LsapAdtFilterAdminPerUserAuditing(
    IN HANDLE hToken,
    IN OUT PTOKEN_AUDIT_POLICY pPolicy
    );

NTSTATUS
LsapAdtStorePolicyByLuidPerUserAuditing(
    IN PLUID pLogonId,
    IN PTOKEN_AUDIT_POLICY pPolicy
    );

NTSTATUS
LsapAdtQueryPolicyByLuidPerUserAuditing(
    IN PLUID pLogonId,
    OUT PTOKEN_AUDIT_POLICY pPolicy,
    IN OUT PULONG pLength,
    OUT PBOOLEAN bFound
    );

NTSTATUS
LsapAdtRemoveLuidQueryPerUserAuditing(
    IN PLUID pLogonId
    );

DWORD
LsapAdtKeyNotifyFirePerUserAuditing(
    IN LPVOID Ignore
    );

DWORD
LsapAdtKeyNotifyStubPerUserAuditing(
    IN LPVOID Ignore
    );

NTSTATUS
LsapAdtLogonPerUserAuditing(
    IN PSID pSid,
    IN PLUID pLogonId,
    IN HANDLE hToken
    );

VOID
LsapAdtLogonCountersPerUserAuditing(
    IN PTOKEN_AUDIT_POLICY pPolicy
    );

NTSTATUS 
LsapAdtLogoffPerUserAuditing(
    IN PLUID pLogonId
    );

VOID
LsapAdtLogoffCountersPerUserAuditing(
    IN PTOKEN_AUDIT_POLICY pPolicy
    );

VOID
LsapAdtAuditPerUserTableCreation(
    BOOLEAN bSuccess
    );

VOID
LsapAdtLogAuditFailureEvent(
    NTSTATUS AuditStatus
    );

NTSTATUS
LsapFlushSecurityLog();

#endif // _LSAP_ADTP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\ausrvp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ausrvp.h

Abstract:

    This module contains AUTHENTICATION related data structures and
    API definitions that are private to the Local Security Authority
    (LSA) server.


Author:

    Jim Kelly (JimK) 21-February-1991

Revision History:

--*/

#ifndef _AUSRVP_
#define _AUSRVP_



//#define LSAP_AU_TRACK_CONTEXT
//#define LSAP_AU_TRACK_THREADS
//#define LSAP_AU_TRACK_LOGONS

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <stdlib.h>
#include "lsasrvp.h"
#include <aup.h>
#include <samrpc.h>
#include <ntdsapi.h>
#include "spmgr.h"
#include <secur32p.h>
#include <credp.hxx>


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// AU specific constants                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The filter/augmentor routines use the following bits in a mask
// to track properties of IDs during logon.  These bits have the following
// meaning:
//
// LSAP_AU_SID_PROP_ALLOCATED - Indicates the SID was allocated within
//     the filter routine.  If an error occurs, this allows allocated
//     IDs to be deallocated.  Otherwise, the caller must deallocate
//     them.
//
// LSAP_AU_SID_COPY - Indicates the SID must be copied before returning.
//     This typically indicates that the pointed-to SID is a global
//     variable for use throughout LSA or that the SID is being referenced
//     from another structure (such as an existing TokenInformation structure).
//

#define LSAP_AU_SID_PROP_ALLOCATED      (0x00000001L)
#define LSAP_AU_SID_PROP_COPY           (0x00000002L)


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Macro definitions                                                   //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
// Macros to gain exclusive access to protected global authentication
// data structures
//

#define LsapAuLock()    (RtlEnterCriticalSection(&LsapAuLock))
#define LsapAuUnlock()  (RtlLeaveCriticalSection(&LsapAuLock))



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Type definitions                                                    //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// This data structure is used to house logon process information.
//

typedef struct _LSAP_LOGON_PROCESS {

    //
    //     Links - Used to link contexts together.  This must be the
    //        first field of the context block.
    //

    LIST_ENTRY Links;


    //
    //     ReferenceCount - Used to prevent this context from being
    //       deleted prematurely.
    //

    ULONG References;


    //
    //     ClientProcess - A handle to the client process.  This handle is
    //        used to perform virtual memory operations within the client
    //        process (allocate, deallocate, read, write).
    //

    HANDLE ClientProcess;


    //
    //    CommPort - A handle to the LPC communication port created to
    //       communicate with this client.  this port must be closed
    //       when the client deregisters.
    //

    HANDLE CommPort;

    //
    //    TrustedClient - If TRUE, the caller has TCB privilege and may
    //      call any API. If FALSE, the caller may only call
    //      LookupAuthenticatePackage and CallPackage, which is converted
    //      to LsaApCallPackageUntrusted.
    //

    BOOLEAN TrustedClient;

    //
    // Name of the logon process.
    //

    WCHAR LogonProcessName[1];

} LSAP_LOGON_PROCESS, *PLSAP_LOGON_PROCESS;




//
// This structure should be treated as opaque by non-LSA code.
// It is used to maintain client information related to individual
// requests.  A public data structure (LSA_CLIENT_REQUEST) is
// typecast to this type by LSA code.
//

typedef struct _LSAP_CLIENT_REQUEST {

    //
    //   Request - Points to the request message received from the
    //       client.
    //

    PLSAP_AU_API_MESSAGE Request;


} LSAP_CLIENT_REQUEST, *PLSAP_CLIENT_REQUEST;





//
// The dispatch table of services which are provided by
// authentication packages.
//
typedef struct _LSAP_PACKAGE_TABLE {
    PLSA_AP_INITIALIZE_PACKAGE LsapApInitializePackage;
    PLSA_AP_LOGON_USER LsapApLogonUser;
    PLSA_AP_CALL_PACKAGE LsapApCallPackage;
    PLSA_AP_LOGON_TERMINATED LsapApLogonTerminated;
    PLSA_AP_CALL_PACKAGE_UNTRUSTED LsapApCallPackageUntrusted;
    PLSA_AP_LOGON_USER_EX LsapApLogonUserEx;
} LSAP_PACKAGE_TABLE, *PLSA_PACKAGE_TABLE;


//
// Used to house information about each loaded authentication package
//

typedef struct _LSAP_PACKAGE_CONTEXT {
    PSTRING Name;
    LSAP_PACKAGE_TABLE PackageApi;
} LSAP_PACKAGE_CONTEXT, *PLSAP_PACKAGE_CONTEXT;


//
// Rather than keep authentication package contexts in a linked list,
// they are pointed to via an array of pointers.  This is practical
// because there will never be more than a handful of authentication
// packages in any particular system, and because authentication packages
// are never unloaded.
//

typedef struct _LSAP_PACKAGE_ARRAY {
    PLSAP_PACKAGE_CONTEXT Package[ANYSIZE_ARRAY];
} LSAP_PACKAGE_ARRAY, *PLSAP_PACKAGE_ARRAY;




//
// Logon Session & Credential management data structures.
//
// Credentials are kept in a structure that looks like:
//
//                    +------+     +------+
// LsapLogonSessions->| Logon|---->| Logon|------> o o o
//                    | Id   |     | Id   |
//                    |   *  |     |   *  |
//                    +---|--+     +---|--+
//                        |
//                        |   +-----+       +-----+
//                        +-->| Auth|------>| Auth|
//                            | Cred|       | Cred|
//                            |- - -|       |- - -|
//                            | Cred|       |  .  |
//                            | List|       |  .  |
//                            |  *  |       |  .  |
//                            +--|--+       +-----+
//                               |
//                               +------> +------------+
//                                        | NextCred   | -----> o o o
//                                        |- - - - - - |
//                                        | Primary Key|--->(PrimaryKeyvalue)
//                                        |- - - - - - |
//                                        | Credential |
//                                        | Value      |--->(CredentialValue)
//                                        +------------+
//
//
//

typedef struct _LSAP_CREDENTIALS {

    struct _LSAP_CREDENTIALS *NextCredentials;
    STRING PrimaryKey;
    STRING Credentials;

} LSAP_CREDENTIALS, *PLSAP_CREDENTIALS;



typedef struct _LSAP_PACKAGE_CREDENTIALS {

    struct _LSAP_PACKAGE_CREDENTIALS *NextPackage;

    //
    // Package that created (and owns) these credentials
    //

    ULONG PackageId;

    //
    // List of credentials associated with this package
    //

    PLSAP_CREDENTIALS Credentials;

} LSAP_PACKAGE_CREDENTIALS, *PLSAP_PACKAGE_CREDENTIALS;


#define LSAP_MAX_DS_NAMES   (DS_DNS_DOMAIN_NAME + 1)

typedef struct _LSAP_DS_NAME_MAP {
    LARGE_INTEGER   ExpirationTime ;
    LONG            RefCount ;
    UNICODE_STRING  Name ;
} LSAP_DS_NAME_MAP, * PLSAP_DS_NAME_MAP ;

typedef struct _LSAP_LOGON_SESSION {

    //
    // List maintained for enumeration
    //

    LIST_ENTRY List ;

    //
    // Each record represents just one logon session
    //

    LUID LogonId;


    //
    // For audit purposes, we keep an account name, authenticating
    // authority name, and User SID for each logon session.
    //

    UNICODE_STRING AccountName;
    UNICODE_STRING AuthorityName;
    UNICODE_STRING ProfilePath;
    PSID UserSid;
    SECURITY_LOGON_TYPE LogonType;

    //
    // Session ID
    //

    ULONG Session ;

    //
    // Logon Time
    //

    LARGE_INTEGER LogonTime ;

    //
    // purported logon server.
    //

    UNICODE_STRING LogonServer;

    //
    // The authentication packages that have credentials associated
    // with this logon session each have their own record in the following
    // linked list.
    //
    // Access serialized by AuCredLock
    //

    PLSAP_PACKAGE_CREDENTIALS Packages;

    //
    // License Server Handle.
    //
    // Null if the license server need not be notified upon logoff.
    //

    HANDLE LicenseHandle;

    //
    // Handle to the token associated with this session.
    //
    // Read-only field once added to the logon session.
    //

    HANDLE TokenHandle;

    //
    // Creating Package
    //
    // Read-only field once added to the logon session.
    //

    ULONG_PTR CreatingPackage;

    //
    // Create trace info:
    //
    // Read-only field once added to the logon session.
    //

    ULONG PackageSpecificAttr ;

    //
    // Credential Sets for this logon session.
    //

    CREDENTIAL_SETS CredentialSets;

    //
    // Access serialized by LogonSessionListLock
    //

    PLSAP_DS_NAME_MAP DsNames[ LSAP_MAX_DS_NAMES ];

    //
    // Logon GUID
    // 
    // This is used by Kerberos package for auditing.
    // (please see function header for LsaIGetLogonGuid for more info)
    //
    // Read-only field once added to the logon session.
    //

    GUID LogonGuid;

    //
    // User name and domain used when going off the machine if the
    // LogonType equals NewCredentials, not populated otherwise.
    // This information is duplicated from the logon packages so that
    // auditing can retrieve it in a package independent way.
    //

    UNICODE_STRING NewAccountName;
    UNICODE_STRING NewAuthorityName;
}
LSAP_LOGON_SESSION, *PLSAP_LOGON_SESSION;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Internal API definitions                                            //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

NTSTATUS
LsapAuApiDispatchLogonUser(         // LsaLogonUser() dispatch routine
    IN OUT PLSAP_CLIENT_REQUEST ClientRequest
    );

NTSTATUS
LsapAuApiDispatchCallPackage(       // LsaCallAuthenticationPackage() dispatch routine
    IN OUT PLSAP_CLIENT_REQUEST ClientRequest
    );

//
// Client process virtual memory routines
//

NTSTATUS
LsapAllocateClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG LengthRequired,
    OUT PVOID *ClientBaseAddress
    );

NTSTATUS
LsapFreeClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ClientBaseAddress OPTIONAL
    );

NTSTATUS
LsapCopyToClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID ClientBaseAddress,
    IN PVOID BufferToCopy
    );

NTSTATUS
LsapCopyFromClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID BufferToCopy,
    IN PVOID ClientBaseAddress
    );

//
// Logon session routines
//

BOOLEAN
LsapLogonSessionInitialize();

NTSTATUS
LsapCreateLogonSession(
    IN PLUID LogonId
    );

NTSTATUS
LsapDeleteLogonSession (
    IN PLUID LogonId
    );

PLSAP_LOGON_SESSION
LsapLocateLogonSession(
    PLUID LogonId
    );

VOID
LsapReleaseLogonSession(
    PLSAP_LOGON_SESSION LogonSession
    );

NTSTATUS
LsapSetLogonSessionAccountInfo(
    IN PLUID LogonId,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthorityName,
    IN OPTIONAL PUNICODE_STRING ProfilePath,
    IN PSID * UserSid,
    IN SECURITY_LOGON_TYPE LogonType,
    IN OPTIONAL PSECPKG_PRIMARY_CRED PrimaryCredentials
    );

NTSTATUS
LsapGetLogonSessionAccountInfo(
    IN PLUID LogonId,
    OUT PUNICODE_STRING AccountName,
    OUT PUNICODE_STRING AuthorityName
    );

VOID
LsapDerefDsNameMap(
    PLSAP_DS_NAME_MAP Map
    );

NTSTATUS
LsapGetNameForLogonSession(
    PLSAP_LOGON_SESSION LogonSession,
    ULONG NameType,
    PLSAP_DS_NAME_MAP * Map,
    BOOL  LocalOnly
    );

NTSTATUS
LsapSetSessionToken(
    IN HANDLE InputTokenHandle,
    IN PLUID LogonId
    );

NTSTATUS
LsapOpenTokenByLogonId(
    IN PLUID LogonId,
    OUT HANDLE *RetTokenHandle
    );

PLSAP_DS_NAME_MAP
LsapGetNameForLocalSystem(
    VOID
    );


//
// Credentials routines
//


NTSTATUS
LsapAddCredential(
    IN PLUID LogonId,
    IN ULONG AuthenticationPackage,
    IN PSTRING PrimaryKeyValue,
    IN PSTRING Credentials
    );


NTSTATUS
LsapGetCredentials(
    IN PLUID LogonId,
    IN ULONG AuthenticationPackage,
    IN OUT PULONG QueryContext,
    IN BOOLEAN RetrieveAllCredentials,
    IN PSTRING PrimaryKeyValue,
    OUT PULONG PrimaryKeyLength,
    IN PSTRING Credentials
    );

NTSTATUS
LsapDeleteCredential(
    IN PLUID LogonId,
    IN ULONG AuthenticationPackage,
    IN PSTRING PrimaryKeyValue
    );

PLSAP_PACKAGE_CREDENTIALS
LsapGetPackageCredentials(
    IN PLSAP_LOGON_SESSION LogonSession,
    IN ULONG PackageId,
    IN BOOLEAN CreateIfNecessary
    );

VOID
LsapFreePackageCredentialList(
    IN PLSAP_PACKAGE_CREDENTIALS PackageCredentialList
    );

VOID
LsapFreeCredentialList(
    IN PLSAP_CREDENTIALS CredentialList
    );

NTSTATUS
LsapReturnCredential(
    IN PLSAP_CREDENTIALS SourceCredentials,
    IN PSTRING TargetCredentials,
    IN BOOLEAN ReturnPrimaryKey,
    IN PSTRING PrimaryKeyValue OPTIONAL,
    OUT PULONG PrimaryKeyLength OPTIONAL
    );

//
// Logon process related services
//

NTSTATUS
LsapValidLogonProcess(
    IN PVOID ConnectionRequest,
    IN ULONG RequestLength,
    IN PCLIENT_ID ClientId,
    OUT PLUID LogonId,
    OUT PULONG Flags
    );

//
// Authentication package routines
//

VOID
LsapAuLogonTerminatedPackages(
    IN PLUID LogonId
    );

NTSTATUS
LsaCallLicenseServer(
    IN PWCHAR LogonProcessName,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING DomainName OPTIONAL,
    IN BOOLEAN IsAdmin,
    OUT HANDLE *LicenseHandle
    );

VOID
LsaFreeLicenseHandle(
    IN HANDLE LicenseHandle
    );

//
//  Miscellaneous other routines
// (LsapAuInit() is the link to the rest of LSA and resides in lsap.h)
//

BOOLEAN
LsapWellKnownValueInit(
    VOID
    );

BOOLEAN
LsapEnableCreateTokenPrivilege(
    VOID
    );

NTSTATUS
LsapCreateNullToken(
    IN PLUID LogonId,
    IN PTOKEN_SOURCE TokenSource,
    IN PLSA_TOKEN_INFORMATION_NULL TokenInformationNull,
    OUT PHANDLE Token
    );

NTSTATUS
LsapCreateV2Token(
    IN PLUID LogonId,
    IN PTOKEN_SOURCE TokenSource,
    IN PLSA_TOKEN_INFORMATION_V2 TokenInformationV2,
    IN TOKEN_TYPE TokenType,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    OUT PHANDLE Token
    );


NTSTATUS
LsapCaptureClientTokenGroups(
    IN PLSAP_CLIENT_REQUEST ClientRequest,
    IN ULONG GroupCount,
    IN PTOKEN_GROUPS ClientTokenGroups,
    IN PTOKEN_GROUPS *CapturedTokenGroups
    );

NTSTATUS
LsapBuildDefaultTokenGroups(
    PLSAP_LOGON_USER_ARGS Arguments
    );

VOID
LsapFreeTokenGroups(
    IN PTOKEN_GROUPS TokenGroups
    );

VOID
LsapFreeTokenPrivileges(
    IN PTOKEN_PRIVILEGES TokenPrivileges OPTIONAL
    );

VOID
LsapFreeTokenInformationNull(
    IN PLSA_TOKEN_INFORMATION_NULL TokenInformationNull
    );

VOID
LsapFreeTokenInformationV1(
    IN PLSA_TOKEN_INFORMATION_V1 TokenInformationV1
    );

VOID
LsapFreeTokenInformationV2(
    IN PLSA_TOKEN_INFORMATION_V2 TokenInformationV2
    );

NTSTATUS
LsapAuUserLogonPolicyFilter(
    IN SECURITY_LOGON_TYPE          LogonType,
    IN PLSA_TOKEN_INFORMATION_TYPE  TokenInformationType,
    IN PVOID                       *TokenInformation,
    IN PTOKEN_GROUPS                LocalGroups,
    OUT PQUOTA_LIMITS               QuotaLimits,
    OUT PPRIVILEGE_SET             *PrivilegesAssigned,
    IN BOOL                         RecoveryMode
    );


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Global variables of the LSA server                                  //
//                                                                     //
/////////////////////////////////////////////////////////////////////////



//
// Well known LUIDs
//

extern LUID LsapSystemLogonId;
extern LUID LsapAnonymousLogonId;

//
//  Well known privilege values
//

extern LUID LsapTcbPrivilege;

//
// Strings needed for auditing.
//

extern UNICODE_STRING LsapLsaAuName;
extern UNICODE_STRING LsapRegisterLogonServiceName;

//
//  The following information pertains to the use of the local SAM
//  for authentication.
//


// Length of typical Sids of members of the Account or Built-In Domains

extern ULONG LsapAccountDomainMemberSidLength,
             LsapBuiltinDomainMemberSidLength;

// Sub-Authority Counts for members of the Account or Built-In Domains

extern UCHAR LsapAccountDomainSubCount,
             LsapBuiltinDomainSubCount;

// Typical Sids for members of Account or Built-in Domains

extern PSID  LsapAccountDomainMemberSid,
             LsapBuiltinDomainMemberSid;

#endif // _AUSRVP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\bndcache.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        bndcache.h
//
// Contents:    Prototypes and types for binding handle  cache
//
//
// History:     13-August-1996  Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __BNDCACHE_H__
#define __BNDCACHE_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines TKTCACHE_ALLOCATE
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef BNDCACHE_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

typedef struct _LSAP_LIST {
    LIST_ENTRY List;
    RTL_CRITICAL_SECTION Lock;
} LSAP_LIST, *PLSAP_LIST;

EXTERN BOOLEAN LsapBindingCacheInitialized;
EXTERN LSAP_LIST LsapBindingCache;
#define LsapLockList(_List_) RtlEnterCriticalSection(&(_List_)->Lock)
#define LsapUnlockList(_List_) RtlLeaveCriticalSection(&(_List_)->Lock)

typedef struct _LSAP_LIST_ENTRY {
    LIST_ENTRY Next;
    ULONG ReferenceCount;
} LSAP_LIST_ENTRY, *PLSAP_LIST_ENTRY;


typedef struct _LSAP_BINDING_CACHE_ENTRY {
    LSAP_LIST_ENTRY ListEntry;
    TimeStamp LastUsed;
    UNICODE_STRING RealmName;
    LPWSTR ServerName;
    LPWSTR ServerPrincipalName;
    PVOID ClientContext;
    LSA_HANDLE PolicyHandle;
} LSAP_BINDING_CACHE_ENTRY, *PLSAP_BINDING_CACHE_ENTRY;


VOID
LsapDereferenceBindingCacheEntry(
    IN PLSAP_BINDING_CACHE_ENTRY BindingCacheEntry
    );

VOID
LsapReferenceBindingCacheEntry(
    IN PLSAP_BINDING_CACHE_ENTRY BindingCacheEntry,
    IN BOOLEAN RemoveFromList
    );

NTSTATUS
LsapInitBindingCache(
    VOID
    );

PLSAP_BINDING_CACHE_ENTRY
LsapLocateBindingCacheEntry(
    IN PUNICODE_STRING RealmName,
    IN BOOLEAN RemoveFromCache
    );

VOID
LsapFreeBindingCacheEntry(
    IN PLSAP_BINDING_CACHE_ENTRY BindingCacheEntry
    );

NTSTATUS
LsapCacheBinding(
    IN PUNICODE_STRING RealmName,
    IN PLSA_HANDLE Handle,
    IN OUT LPWSTR * ServerName,
    IN OUT LPWSTR * ServerPrincipalName,
    IN OUT PVOID * ClientContext,
    OUT PLSAP_BINDING_CACHE_ENTRY * NewCacheEntry
    );

//
// Functions for manipulating lsap lists
//


NTSTATUS
LsapInitializeList(
    IN PLSAP_LIST List
    );

VOID
LsapFreeList(
    IN PLSAP_LIST List
    );

VOID
LsapInsertListEntry(
    IN PLSAP_LIST_ENTRY ListEntry,
    IN PLSAP_LIST List
    );

VOID
LsapReferenceListEntry(
    IN PLSAP_LIST List,
    IN PLSAP_LIST_ENTRY ListEntry,
    IN BOOLEAN RemoveFromList
    );

BOOLEAN
LsapDereferenceListEntry(
    IN PLSAP_LIST_ENTRY ListEntry,
    IN PLSAP_LIST List
    );

VOID
LsapInitializeListEntry(
    IN OUT PLSAP_LIST_ENTRY ListEntry
    );

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __TKTCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\crserver.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    crserver.c

Abstract:

    Local Security Authority - Server Cipher Routines

    These routines interface the LSA server side with the Cipher
    Routines.  They perform RPC-style memory allocation.

Author:

    Scott Birrell       (ScottBi)       December 13, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>


NTSTATUS
LsapCrServerGetSessionKey(
    IN LSAPR_HANDLE ObjectHandle,
    OUT PLSAP_CR_CIPHER_KEY *SessionKey
    )

/*++

Routine Description:

    This function obtains the Session Key, allocates an Cipher Key
    structure and returns the key.

Arguments:

    ObjectHandle - Handle from an LsaOpen<ObjectType> call.

    SessionKey - Receives a pointer to a structure containing the
       Session Key in which the memory has been allocated via
       MIDL_user_allocate().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            (e.g memory) to complete the call.
--*/


{
    NTSTATUS Status;
    PLSAP_CR_CIPHER_KEY OutputSessionKey = NULL;
    ULONG OutputSessionKeyBufferLength;

    //
    // Allocate memory for the Session Key buffer and LSAP_CR_CIPHER_KEY
    // structure.
    //

    OutputSessionKeyBufferLength = sizeof (USER_SESSION_KEY);

    OutputSessionKey = MIDL_user_allocate(
                           OutputSessionKeyBufferLength +
                           sizeof (LSAP_CR_CIPHER_KEY)
                           );

    if (OutputSessionKey == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ServerGetSessionKeyError;
    }

    //
    // Fill in the Cipher key structure, making the buffer point to
    // just beyond the header.
    //

    OutputSessionKey->Length = OutputSessionKeyBufferLength;
    OutputSessionKey->MaximumLength = OutputSessionKeyBufferLength;
    OutputSessionKey->Buffer = (PUCHAR) (OutputSessionKey + 1);

    Status = RtlGetUserSessionKeyServer(
                 ObjectHandle,
                 (PUSER_SESSION_KEY) OutputSessionKey->Buffer
                 );

    if (!NT_SUCCESS(Status)) {

        //
        // It is better to clear here.
        //

        MIDL_user_free(OutputSessionKey);
        OutputSessionKey = NULL;
        goto ServerGetSessionKeyError;
    }


ServerGetSessionKeyFinish:

    *SessionKey = OutputSessionKey;
    return(Status);

ServerGetSessionKeyError:

    goto ServerGetSessionKeyFinish;
}


NTSTATUS
LsapCrServerGetSessionKeySafe(
    IN LSAPR_HANDLE ObjectHandle,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    OUT PLSAP_CR_CIPHER_KEY *SessionKey
    )

/*++

Routine Description:

    This function obtains the Session Key, allocates an Cipher Key
    structure and returns the key.

    Same a LsapCrServerGetSessionKey except the ObjectHandle is verified

        the LsapCrServerGetSessionKey version of this routine shouldn't exist.
        That routine calls down into the kernel.  Such a call can call back up to the
        LSA and lock locks.  Since LsapCrServerGetSessionKey doesn't validate the
        handle, the caller must have done that.  All such callers lock LSA locks.
        That's bound to be a deadlock.


Arguments:

    ObjectHandle - Handle from an LsaOpen<ObjectType> call.

    ObjectTypeId - Type of ObjectHandle.

    SessionKey - Receives a pointer to a structure containing the
       Session Key in which the memory has been allocated via
       MIDL_user_allocate().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            (e.g memory) to complete the call.
--*/


{
    NTSTATUS Status;


    //
    // Verify that the handle is valid.
    //

    Status =  LsapDbVerifyHandle( ObjectHandle, 0, ObjectTypeId, TRUE );

    if (NT_SUCCESS(Status)) {

        //
        // Get the session key.
        //

        Status = LsapCrServerGetSessionKey( ObjectHandle,
                                            SessionKey );

        //
        // Dereference the handle
        //

        (VOID) LsapDbDereferenceHandle( ObjectHandle, TRUE );

    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\bndcache.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        bndcache.cxx
//
// Contents:    Binding cache for Kerberos Package
//
//
// History:     13-August-1996  Created         MikeSw
//
//------------------------------------------------------------------------
#include <lsapch.hxx>

#define BNDCACHE_ALLOCATE
#include <bndcache.h>

//
// REVIEW: (markpu: 02/02/19)
//
//  - consider using a more efficient data store than a linked list
//  - convert the lock to a r/w resource
//  - get away from using the boneheaded Reference/Dereference scheme
//    for removing items from the list
//

//+-------------------------------------------------------------------------
//
//  Function:   LsapInitializeList
//
//  Synopsis:   Initializes a lsap list by initializing the lock
//              and the list entry.
//
//  Effects:
//
//  Arguments:  List - List to initialize
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success or errors from
//              RtlInitializeResources
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
LsapInitializeList(
    IN PLSAP_LIST List
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    InitializeListHead(&List->List);

    Status = RtlInitializeCriticalSection(
                &List->Lock
                );

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapFreeList
//
//  Synopsis:   Frees a lsap list by deleting the associated
//              critical section.
//
//  Effects:    List - the list to free.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    none
//
//  Notes:      The list must be empty before freeing it.
//
//
//--------------------------------------------------------------------------



VOID
LsapFreeList(
    IN PLSAP_LIST List
    )
{
    //
    // Make sure the list is empty first
    //

    DsysAssert(List->List.Flink == List->List.Blink);
    RtlDeleteCriticalSection(&List->Lock);

}


//+-------------------------------------------------------------------------
//
//  Function:   LsapInitializeListEntry
//
//  Synopsis:   Initializes a newly created list entry for later
//              insertion onto the list.
//
//  Effects:    The reference count is set to one and the links are set
//              to NULL.
//
//  Arguments:  ListEntry - the list entry to initialize
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
LsapInitializeListEntry(
    IN OUT PLSAP_LIST_ENTRY ListEntry
    )
{
    ListEntry->ReferenceCount = 1;
    ListEntry->Next.Flink = ListEntry->Next.Blink = NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapInsertListEntry
//
//  Synopsis:   Inserts an entry into a lsap list
//
//  Effects:    increments the reference count on the entry - if the
//              list entry was formly referenced it remains referenced.
//
//  Arguments:  ListEntry - the entry to insert
//              List - the list in which to insert the ListEntry
//
//  Requires:
//
//  Returns:    nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
LsapInsertListEntry(
    IN PLSAP_LIST_ENTRY ListEntry,
    IN PLSAP_LIST List
    )
{
    ListEntry->ReferenceCount++;

    RtlEnterCriticalSection(&List->Lock);


    InsertHeadList(
        &List->List,
        &ListEntry->Next
        );


    RtlLeaveCriticalSection(&List->Lock);

}


//+-------------------------------------------------------------------------
//
//  Function:   LsapReferenceListEntry
//
//  Synopsis:   References a list entry. If the flag RemoveFromList
//              has been specified, the entry is unlinked from the
//              list.
//
//  Effects:    bumps the reference count on the entry (unless it is
//              being removed from the list)
//
//  Arguments:
//
//  Requires:   The list must be locked when calling this routine
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
LsapReferenceListEntry(
    IN PLSAP_LIST List,
    IN PLSAP_LIST_ENTRY ListEntry,
    IN BOOLEAN RemoveFromList
    )
{

    //
    // If it has already been removed from the list
    // don't do it again.
    //

    if (RemoveFromList && ((ListEntry->Next.Flink != NULL) &&
                           (ListEntry->Next.Blink != NULL)))
    {
        RemoveEntryList(&ListEntry->Next);
        ListEntry->Next.Flink = NULL;
        ListEntry->Next.Blink = NULL;
    }
    else
    {
        ListEntry->ReferenceCount++;
    }

}


//+-------------------------------------------------------------------------
//
//  Function:   LsapDereferenceListEntry
//
//  Synopsis:   Dereferences a list entry and returns a flag indicating
//              whether the entry should be freed.
//
//  Effects:    decrements reference count on list entry
//
//  Arguments:  ListEntry - the list entry to dereference
//              List - the list containing the list entry
//
//  Requires:
//
//  Returns:    TRUE - the list entry should be freed
//              FALSE - the list entry is still referenced
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOLEAN
LsapDereferenceListEntry(
    IN PLSAP_LIST_ENTRY ListEntry,
    IN PLSAP_LIST List
    )
{
    BOOLEAN DeleteEntry = FALSE;

    RtlEnterCriticalSection(&List->Lock);

    ListEntry->ReferenceCount -= 1;
    if (ListEntry->ReferenceCount == 0)
    {
        DeleteEntry = TRUE;
    }

    RtlLeaveCriticalSection(&List->Lock);
    return(DeleteEntry);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapInitBindingCache
//
//  Synopsis:   Initializes the binding cache
//
//  Effects:    allocates a resources
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes
//              on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
LsapInitBindingCache(
    VOID
    )
{
    NTSTATUS Status;

    Status = LsapInitializeList( &LsapBindingCache );

    if (NT_SUCCESS(Status))
    {
        LsapBindingCacheInitialized = TRUE;
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapDereferenceBindingCacheEntry
//
//  Synopsis:   Dereferences a binding cache entry
//
//  Effects:    Dereferences the binding cache entry to make it go away
//              when it is no longer being used.
//
//  Arguments:  decrements reference count and delets cache entry if it goes
//              to zero
//
//  Requires:   BindingCacheEntry - The binding cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
LsapDereferenceBindingCacheEntry(
    IN PLSAP_BINDING_CACHE_ENTRY BindingCacheEntry
    )
{
    if (LsapDereferenceListEntry(
            &BindingCacheEntry->ListEntry,
            &LsapBindingCache
            ) )
    {
        LsapFreeBindingCacheEntry(BindingCacheEntry);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapReferenceBindingCacheEntry
//
//  Synopsis:   References a binding cache entry
//
//  Effects:    Increments the reference count on the binding cache entry
//
//  Arguments:  BindingCacheEntry - binding cache entry  to reference
//
//  Requires:   The binding cache must be locked
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
LsapReferenceBindingCacheEntry(
    IN PLSAP_BINDING_CACHE_ENTRY BindingCacheEntry,
    IN BOOLEAN RemoveFromList
    )
{
    LsapLockList(&LsapBindingCache);

    LsapReferenceListEntry(
        &LsapBindingCache,
        &BindingCacheEntry->ListEntry,
        RemoveFromList
        );

    LsapUnlockList(&LsapBindingCache);
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapLocateBindingCacheEntry
//
//  Synopsis:   References a binding cache entry by name
//
//  Effects:    Increments the reference count on the binding cache entry
//
//  Arguments:  RealmName - Contains the name of the realm for which to
//                      obtain a binding handle.
//              RemoveFromList - Remove cache entry from cache when found.
//
//  Requires:
//
//  Returns:    The referenced cache entry or NULL if it was not found.
//
//  Notes:      If an invalid entry is found it may be dereferenced
//
//
//--------------------------------------------------------------------------

PLSAP_BINDING_CACHE_ENTRY
LsapLocateBindingCacheEntry(
    IN PUNICODE_STRING RealmName,
    IN BOOLEAN RemoveFromList
    )
{
    PLIST_ENTRY ListEntry;
    PLSAP_BINDING_CACHE_ENTRY CacheEntry = NULL;
    BOOLEAN Found = FALSE;

    //
    // REVIEW: the lock should be converted to a r/w resource
    //         this lock can be acquired for read whenever RemoveFromList is FALSE
    //         (with corresponding changes made to LsapReferenceBindingCacheEntry)
    //

    LsapLockList(&LsapBindingCache);

    //
    // Go through the binding cache looking for the correct entry
    //

    for (ListEntry = LsapBindingCache.List.Flink ;
         ListEntry !=  &LsapBindingCache.List ;
         ListEntry = ListEntry->Flink )
    {
        CacheEntry = CONTAINING_RECORD(ListEntry, LSAP_BINDING_CACHE_ENTRY, ListEntry.Next);
        if (RtlEqualUnicodeString(
                &CacheEntry->RealmName,
                RealmName,
                TRUE
                ))
        {
            LsapReferenceBindingCacheEntry(
                CacheEntry,
                RemoveFromList
                );

            Found = TRUE;

            NtQuerySystemTime(
                &CacheEntry->LastUsed
                );

            break;
        }
    }
    if (!Found)
    {
        CacheEntry = NULL;
    }

    LsapUnlockList(&LsapBindingCache);
    return(CacheEntry);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapFreeBindingCacheEntry
//
//  Synopsis:   Frees memory associated with a binding cache entry
//
//  Effects:
//
//  Arguments:  BindingCacheEntry - The cache entry to free. It must be
//                      unlinked.
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
LsapFreeBindingCacheEntry(
    IN PLSAP_BINDING_CACHE_ENTRY BindingCacheEntry
    )
{
    if ( !BindingCacheEntry )
    {
        return;
    }
    LsapFreeString(&BindingCacheEntry->RealmName);
    if (BindingCacheEntry->PolicyHandle != NULL)
    {
        LsaClose(BindingCacheEntry->PolicyHandle);
    }
    if (BindingCacheEntry->ServerName != NULL) {
        //
        // Note -- because I_NetLogonAuthData is not supported for NT4 and
        // below, ServerName won't always be allocated from NetLogon's MM.
        // So, the ServerName allocation is normalized to LocalAlloc/LocalFree
        //
        LocalFree(BindingCacheEntry->ServerName);
    }
    if (BindingCacheEntry->ServerPrincipalName != NULL) {
        I_NetLogonFree(BindingCacheEntry->ServerPrincipalName);
    }
    if (BindingCacheEntry->ClientContext != NULL) {
        I_NetLogonFree(BindingCacheEntry->ClientContext);
    }

    LsapFreeLsaHeap(BindingCacheEntry);
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapInsertBinding
//
//  Synopsis:   Inserts a binding into the binding cache
//
//  Effects:    bumps reference count on binding
//
//  Arguments:  CacheEntry - Cache entry to insert
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS always
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
LsapInsertBinding(
    IN PLSAP_BINDING_CACHE_ENTRY CacheEntry
    )
{
    LsapInsertListEntry(
        &CacheEntry->ListEntry,
        &LsapBindingCache
        );

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapCacheBinding
//
//  Synopsis:   Caches a binding in the binding cache
//
//  Effects:    creates a cache entry.
//
//  Arguments:  RealmName - The realm name of the LSA the binding is to.
//              Handle - LSA policy handle to the target machine.
//              ServerName,ServerPrincipalName, ClientContext - authenticated
//                      rpc parameters needed to be cached for the duration
//                      of the binding.
//              CacheEntry - Receives the new binding cache entry,
//                      referenced.
//
//  Requires:
//
//  Returns:
//
//  Notes:      Locks the binding cache for write access while adding
//              the cache entry.
//
//
//--------------------------------------------------------------------------


NTSTATUS
LsapCacheBinding(
    IN PUNICODE_STRING RealmName,
    IN PLSA_HANDLE Handle,
    IN OUT LPWSTR * ServerName,
    IN OUT LPWSTR * ServerPrincipalName,
    IN OUT PVOID * ClientContext,
    OUT PLSAP_BINDING_CACHE_ENTRY * NewCacheEntry
    )
{
    PLSAP_BINDING_CACHE_ENTRY CacheEntry = NULL;
    PLSAP_BINDING_CACHE_ENTRY OldCacheEntry = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    *NewCacheEntry = NULL;

    CacheEntry = (PLSAP_BINDING_CACHE_ENTRY)
        LsapAllocateLsaHeap(sizeof(LSAP_BINDING_CACHE_ENTRY));
    if (CacheEntry == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory(
        CacheEntry,
        sizeof(LSAP_BINDING_CACHE_ENTRY)
        );

    LsapInitializeListEntry(
        &CacheEntry->ListEntry
        );

    NtQuerySystemTime(
        &CacheEntry->LastUsed
        );

    Status = LsapDuplicateString(
                &CacheEntry->RealmName,
                RealmName
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    CacheEntry->PolicyHandle = *Handle;
    *Handle = NULL;
    CacheEntry->ServerName = *ServerName;
    *ServerName = NULL;
    CacheEntry->ServerPrincipalName = *ServerPrincipalName;
    *ServerPrincipalName = NULL;
    CacheEntry->ClientContext = *ClientContext;
    *ClientContext = NULL;

    //
    // Before we insert this binding we want to remove any
    // previous instances of bindings to the same realm.
    //

    OldCacheEntry = LsapLocateBindingCacheEntry(
                        RealmName,
                        TRUE    // remove from cache
                        );

    if (OldCacheEntry != NULL)
    {
        LsapDereferenceBindingCacheEntry( OldCacheEntry );
    }

    //
    // Insert the cache entry into the cache
    //

    Status = LsapInsertBinding(
                CacheEntry
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *NewCacheEntry = CacheEntry;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if ( CacheEntry )
        {
            LsapFreeBindingCacheEntry(CacheEntry);
        }
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\credapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        credapi.c
//
// Contents:    Credential related APIs to the SPMgr
//              - LsaEstablishCreds
//              - LsaLogonUser
//              - LsaAcquireCredHandle
//              - LsaFreeCredHandle
//
//
// History:     20 May 92   RichardW    Commented existing code
//
//------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C"
{
#include "adtp.h"
#include "msaudite.h"   // LsaAuditLogon
}

//+-------------------------------------------------------------------------
//
//  Function:   WLsaAcquireCredHandle
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
WLsaAcquireCredHandle(  PSECURITY_STRING    pPrincipal,
                        PSECURITY_STRING    pSecPackage,
                        DWORD               fCredentialUse,
                        PLUID               pLogonID,
                        PVOID               pvAuthData,
                        PVOID               pvGetKeyFn,
                        PVOID               pvGetKeyArgument,
                        PCredHandle         phCredential,
                        PTimeStamp          ptsExpiry)
{
    PLSAP_SECURITY_PACKAGE     pspPackage;
    NTSTATUS           scRet;
    LUID            CallerLogonID;
    PSession        pSession = GetCurrentSession();
    SECPKG_CLIENT_INFO ClientInfo;
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();

    //
    // Check if the caller is restricted
    //
    scRet = LsapGetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR,"Failed to get client info: 0x%x\n",scRet));
        return(scRet);
    }

    //
    // If the caller is restricted, fail the call for now. This should change
    // if packages are able to support restrictions. In that case, the call
    // should check the package capabilities for handling restrictions and
    // if it supports restrictions, allow the call to continue.
    //

    if (ClientInfo.Restricted)
    {
        DebugLog((DEB_WARN, "Trying to acquire credentials with a restrictred token\n"));
        scRet = SEC_E_NO_CREDENTIALS;
        return (scRet);
    }

    //
    //  Todds - 08/02
    //
    //  We used to disallow tokens with identification level or lower to
    // AcquireCredentialsHandle, thus prevent it from elevating to impersonation
    // level - but this check has been moved to the packages to allow some
    // s4uproxy scenarios to work w/o TCB.
    //


#if DBG
    if (pPrincipal->Length)
    {
        DebugLog((DEB_TRACE_WAPI, "[%x] AcquireCredentialHandle(%ws, %ws)\n",
            pSession->dwProcessID, pPrincipal->Buffer, pSecPackage->Buffer));
    }
    else
    {
        DebugLog((DEB_TRACE_WAPI, "[%x] AcquireCredHandle(%x:%x, %ws)\n",
            pSession->dwProcessID, pLogonID->HighPart, pLogonID->LowPart,
            pSecPackage->Buffer));
    }
#endif // DBG

    phCredential->dwUpper = 0;
    phCredential->dwLower = 0xFFFFFFFF;
    ptsExpiry->LowPart = 0;
    ptsExpiry->HighPart = 0;

    pspPackage = SpmpLookupPackageAndRequest(pSecPackage,
                                            SP_ORDINAL_ACQUIRECREDHANDLE);
    if (!pspPackage)
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }

    SetCurrentPackageId(pspPackage->dwPackageID);

    CallerLogonID = *pLogonID;

    StartCallToPackage( pspPackage );

    __try
    {
        scRet = pspPackage->FunctionTable.AcquireCredentialsHandle(pPrincipal,
                                                            fCredentialUse,
                                                            &CallerLogonID,
                                                            pvAuthData,
                                                            pvGetKeyFn,
                                                            pvGetKeyArgument,
                                                            &phCredential->dwUpper,
                                                            ptsExpiry);
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pspPackage->dwPackageID);
    }

    EndCallToPackage( pspPackage );

    if (FAILED(scRet))
    {
        DebugLog((DEB_WARN, "Failed to acquire cred handle for %ws with %ws\n",
                            pPrincipal->Buffer, pSecPackage->Buffer));
        return(scRet);
    }

    phCredential->dwLower = pspPackage->dwPackageID;

    if(!AddCredHandle(pSession, phCredential, 0))
    {
        DebugLog(( DEB_ERROR, "Failed adding credential handle %p:%p to session %p\n",
                    phCredential->dwUpper, phCredential->dwLower,
                    pSession ));

        pspPackage = SpmpLookupPackageAndRequest(pSecPackage,
                                                SP_ORDINAL_FREECREDHANDLE);

        if( pspPackage )
        {
            ULONG OldCallCount = CallInfo->CallInfo.CallCount;

            CallInfo->CallInfo.CallCount = 1 ;


            //
            // remove the handle from the underlying package.
            //

            StartCallToPackage( pspPackage );

            __try
            {
                pspPackage->FunctionTable.FreeCredentialsHandle(
                                                        phCredential->dwUpper
                                                        );
            }
            __except (SP_EXCEPTION)
            {
                NOTHING;
            }

            EndCallToPackage( pspPackage );

            CallInfo->CallInfo.CallCount = OldCallCount;

        }

        phCredential->dwLower = 0;
        phCredential->dwUpper = 0;

        return SEC_E_INSUFFICIENT_MEMORY;
    }

    LsapLogCallInfo( CallInfo, pSession, *phCredential );

    return(scRet);
}


NTSTATUS
WLsaAddCredentials(
    PCredHandle     phCredential,
    PSECURITY_STRING    pPrincipal,
    PSECURITY_STRING    pSecPackage,
    DWORD               fCredentialUse,
    PVOID               pvAuthData,
    PVOID               pvGetKeyFn,
    PVOID               pvGetKeyArgument,
    PTimeStamp          ptsExpiry)
{
    PLSAP_SECURITY_PACKAGE     pspPackage;
    NTSTATUS           scRet;
    LUID            CallerLogonID;
    PSession        pSession = GetCurrentSession();
    SECPKG_CLIENT_INFO ClientInfo;
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();
    PVOID CredKey ;

    //
    // Check if the caller is restricted
    //
    scRet = LsapGetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR,"Failed to get client info: 0x%x\n",scRet));
        return(scRet);
    }

    //
    // If the caller is restricted, fail the call for now. This should change
    // if packages are able to support restrictions. In that case, the call
    // should check the package capabilities for handling restrictions and
    // if it supports restrictions, allow the call to continue.
    //

    if (ClientInfo.Restricted)
    {
        DebugLog((DEB_WARN,"Trying to acquire credentials with a restrictred token\n"));
        scRet = SEC_E_NO_CREDENTIALS;
        return(scRet);
    }

#if DBG
    if (pPrincipal->Length)
    {
        DebugLog((DEB_TRACE_WAPI, "[%x] AddCredentials(%ws, %ws)\n",
            pSession->dwProcessID, pPrincipal->Buffer, pSecPackage->Buffer));
    }
    else
    {
        DebugLog((DEB_TRACE_WAPI, "[%x] AddCredentials(%ws)\n",
            pSession->dwProcessID,
            pSecPackage->Buffer));
    }
#endif // DBG

    ptsExpiry->LowPart = 0;
    ptsExpiry->HighPart = 0;

    LsapLogCallInfo( CallInfo, pSession, *phCredential );

    scRet = ValidateCredHandle(
                    pSession,
                    phCredential,
                    &CredKey );

    if ( NT_SUCCESS( scRet ) )
    {
        pspPackage = SpmpValidRequest( phCredential->dwLower,
                                       SP_ORDINAL_ADDCREDENTIALS );
    }
    else
    {
        DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

        return( SEC_E_INVALID_HANDLE );
    }

    if (!pspPackage)
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }

    SetCurrentPackageId(pspPackage->dwPackageID);

    StartCallToPackage( pspPackage );

    __try
    {
        scRet = pspPackage->FunctionTable.AddCredentials(
                                            phCredential->dwUpper,
                                            pPrincipal,
                                            pSecPackage,
                                            fCredentialUse,
                                            pvAuthData,
                                            pvGetKeyFn,
                                            pvGetKeyArgument,
                                            ptsExpiry);
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pspPackage->dwPackageID);
    }

    EndCallToPackage( pspPackage );

    if (FAILED(scRet))
    {
        DebugLog((DEB_WARN, "Failed to add credentials for %ws with %ws\n",
                            pPrincipal->Buffer, pSecPackage->Buffer));
        return(scRet);
    }

    LsapLogCallInfo( CallInfo, pSession, *phCredential );

    return(scRet);
}





//+-------------------------------------------------------------------------
//
//  Function:   WLsaFreeCredHandle
//
//  Synopsis:   Worker function to free a cred handle,
//
//  Effects:    calls into a package to free the handle
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
WLsaFreeCredHandle( PCredHandle     phCreds)
{
    NTSTATUS       scRet;
    PSession    pSession = GetCurrentSession();
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();
    PLSAP_SECURITY_PACKAGE pPackage;


    IsOkayToExec(0);

    DebugLog((DEB_TRACE_WAPI, "[%x] WLsaFreeCredHandle(%p : %p)\n",
                pSession->dwProcessID, phCreds->dwUpper, phCreds->dwLower));

    scRet = ValidateAndDerefCredHandle( pSession, phCreds );

    if ( !NT_SUCCESS( scRet ) )
    {
        if ( ( CallInfo->Flags & CALL_FLAG_NO_HANDLE_CHK ) == 0 )
        {
            DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );
        }
    }

    LsapLogCallInfo( CallInfo, pSession, *phCreds );

    if (SUCCEEDED(scRet))
    {
        phCreds->dwUpper = phCreds->dwLower = 0xFFFFFFFF;
    }

    return(scRet);

}


//+-------------------------------------------------------------------------
//
//  Function:   WLsaQueryCredAttributes
//
//  Synopsis:   SPMgr worker to query credential attributes
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
WLsaQueryCredAttributes(
    PCredHandle phCredentials,
    ULONG ulAttribute,
    PVOID pBuffer
    )
{
    NTSTATUS       scRet;
    PSession    pSession = GetCurrentSession();
    PLSA_CALL_INFO CallInfo = LsapGetCurrentCall();
    PLSAP_SECURITY_PACKAGE pPackage;
    PVOID       CredKey = NULL ;


    DebugLog((DEB_TRACE_WAPI, "[%x] WLsaQueryCredAttributes(%p : %p)\n",
                pSession->dwProcessID, phCredentials->dwUpper, phCredentials->dwLower));

    LsapLogCallInfo( CallInfo, pSession, *phCredentials );

    scRet = ValidateCredHandle(
                    pSession,
                    phCredentials,
                    &CredKey );

    if ( !NT_SUCCESS( scRet ) )
    {
        DsysAssert( (pSession->fSession & SESFLAG_KERNEL) == 0 );

        return( scRet );
    }


    pPackage = SpmpValidRequest(phCredentials->dwLower,
                                SP_ORDINAL_QUERYCREDATTR );

    if (pPackage)
    {

        SetCurrentPackageId(phCredentials->dwLower);

        StartCallToPackage( pPackage );

        __try
        {
            scRet = pPackage->FunctionTable.QueryCredentialsAttributes(
                        phCredentials->dwUpper,
                        ulAttribute,
                        pBuffer
                        );

        }
        __except (SP_EXCEPTION)
        {
            scRet = GetExceptionCode();
            scRet = SPException(scRet, phCredentials->dwLower);
        }

        EndCallToPackage( pPackage );
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    DerefCredHandle( pSession, NULL, CredKey );

    return(scRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\db.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    db.h

Abstract:

    LSA Database Exported Function Definitions, Datatypes and Defines

    This module contains the LSA Database Routines that may be called
    by parts of the LSA outside the Database sub-component.

Author:

    Scott Birrell       (ScottBi)       August 26, 1991

Environment:

Revision History:

--*/

#ifndef _LSA_DB_
#define _LSA_DB_

//
// Maximum Number of attributes in the various object types
//

#define LSAP_DB_ATTRS_POLICY             ((ULONG) 0x00000010L)
#define LSAP_DB_ATTRS_ACCOUNT            ((ULONG) 0x00000010L)
#define LSAP_DB_ATTRS_DOMAIN             ((ULONG) 0x00000013L)
#define LSAP_DB_ATTRS_SECRET             ((ULONG) 0x00000010L)

//
// Constants for matching options on Sid/Name lookup operations
//

#define LSAP_DB_MATCH_ON_SID             ((ULONG) 0x00000001L)
#define LSAP_DB_MATCH_ON_NAME            ((ULONG) 0x00000002L)

//
// Options for LsapDbLookupSidsInLocalDomains()
//

#define LSAP_DB_SEARCH_BUILT_IN_DOMAIN   ((ULONG) 0x00000001L)
#define LSAP_DB_SEARCH_ACCOUNT_DOMAIN    ((ULONG) 0x00000002L)

//
// Options for LsapDbMergeDisjointReferencedDomains
//

#define LSAP_DB_USE_FIRST_MERGAND_GRAPH  ((ULONG) 0x00000001L)
#define LSAP_DB_USE_SECOND_MERGAND_GRAPH ((ULONG) 0x00000002L)

//
// Option for updating Policy Database
//

#define LSAP_DB_UPDATE_POLICY_DATABASE   ((ULONG) 0x00000001L)

//
// Maximum number of attributes corresponding to a Policy Object
// Information Class
//

#define LSAP_DB_ATTRS_INFO_CLASS_POLICY  ((ULONG) 0x00000007L)

//
// Maximum number of attributes corresponding to a Trusted Domain Object
// Information Class
//

#define LSAP_DB_ATTRS_INFO_CLASS_DOMAIN  ((ULONG) 0x00000010L)

//
// Global variables
//

extern BOOLEAN LsapDbRequiresSidInfo[];
extern BOOLEAN LsapDbRequiresNameInfo[];
extern LSAPR_HANDLE LsapDbHandle;
extern BOOLEAN LsapSetupWasRun;
extern BOOLEAN LsapDatabaseSetupPerformed;
extern NT_PRODUCT_TYPE LsapProductType;
extern WORD LsapProductSuiteMask;
extern BOOLEAN LsapDsIsRunning;
extern BOOLEAN LsapDsWReplEnabled;


//
// Table of accesses required to query Policy Information.  This table
// is indexed by Policy Information Class
//

extern ACCESS_MASK LsapDbRequiredAccessQueryPolicy[];
extern ACCESS_MASK LsapDbRequiredAccessQueryDomainPolicy[];

//
// Table of accesses required to set Policy Information.  This table
// is indexed by Policy Information Class
//

extern ACCESS_MASK LsapDbRequiredAccessSetPolicy[];
extern ACCESS_MASK LsapDbRequiredAccessSetDomainPolicy[];

//
// Table of accesses required to query TrustedDomain Information.  This table
// is indexed by TrustedDomain Information Class
//

extern ACCESS_MASK LsapDbRequiredAccessQueryTrustedDomain[];

//
// Table of accesses required to set TrustedDomain Information.  This table
// is indexed by TrustedDomain Information Class
//

extern ACCESS_MASK LsapDbRequiredAccessSetTrustedDomain[];

//
// Maximum Handle Reference Count
//

#define LSAP_DB_MAXIMUM_REFERENCE_COUNT  ((ULONG) 0x00001000L)

//
// Maximum handles per user logon id
//   This was determined by taking the "interesting" access bits and generating possible
//   permutations and using that.  The interesting bits were determined to be:
//      POLICY_VIEW_LOCAL_INFORMATION
//      POLICY_VIEW_AUDIT_INFORMATION
//      POLICY_TRUST_ADMIN
//      POLICY_CREATE_ACCOUNT
//      POLICY_CREATE_SECRET
//      POLICY_LOOKUP_NAMES
//   The possible combinations add up to 720 entries
#define LSAP_DB_MAXIMUM_HANDLES_PER_USER    0x000002D0

//
// Default Computer Name used for Policy Account Domain Info
//

#define LSAP_DB_DEFAULT_COMPUTER_NAME    (L"MACHINENAME")

//
// Options for the LsaDbReferenceObject and LsaDbDereferenceObject
//

#define LSAP_DB_LOCK                                  ((ULONG) 0x00000001L)
#define LSAP_DB_NO_LOCK                               ((ULONG) 0x00000002L)
#define LSAP_DB_OPENED_BY_ANONYMOUS                   ((ULONG) 0x00000004L)
#define LSAP_DB_START_TRANSACTION                     ((ULONG) 0x00000008L)
#define LSAP_DB_FINISH_TRANSACTION                    ((ULONG) 0x00000010L)
#define LSAP_DB_VALIDATE_HANDLE                       ((ULONG) 0x00000020L)
#define LSAP_DB_TRUSTED                               ((ULONG) 0x00000040L)
#define LSAP_DB_STANDALONE_REFERENCE                  ((ULONG) 0x00000080L)
#define LSAP_DB_DEREFERENCE_CONTR                     ((ULONG) 0x00000100L)
#define LSAP_DB_LOG_QUEUE_LOCK                        ((ULONG) 0x00001000L)
#define LSAP_DB_OMIT_REPLICATOR_NOTIFICATION          ((ULONG) 0x00004000L)
#define LSAP_DB_USE_LPC_IMPERSONATE                   ((ULONG) 0x00008000L)
#define LSAP_DB_ADMIT_DELETED_OBJECT_HANDLES          ((ULONG) 0x00010000L)
#define LSAP_DB_DS_NO_PARENT_OBJECT                   ((ULONG) 0x00080000L)
#define LSAP_DB_OBJECT_SCOPE_DS                       ((ULONG) 0x00100000L)
#define LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET           ((ULONG) 0x00400000L)
#define LSAP_DB_READ_ONLY_TRANSACTION                 ((ULONG) 0x01000000L)
#define LSAP_DB_DS_OP_TRANSACTION                     ((ULONG) 0x02000000L)
#define LSAP_DB_NO_DS_OP_TRANSACTION                  ((ULONG) 0x04000000L)
#define LSAP_DB_HANDLE_UPGRADE                        ((ULONG) 0x10000000L)
#define LSAP_DB_HANDLE_CREATED_SECRET                 ((ULONG) 0x20000000L)
#define LSAP_DB_SCE_POLICY_HANDLE                     ((ULONG) 0x40000000L)

#define LSAP_DB_STATE_MASK                                           \
    (LSAP_DB_LOCK | LSAP_DB_NO_LOCK | \
     LSAP_DB_START_TRANSACTION | LSAP_DB_FINISH_TRANSACTION |        \
     LSAP_DB_LOG_QUEUE_LOCK | \
     LSAP_DB_READ_ONLY_TRANSACTION | LSAP_DB_DS_OP_TRANSACTION | \
     LSAP_DB_NO_DS_OP_TRANSACTION)


//
// Configuration Registry Root Key for Lsa Database.  All Physical Object
// and Attribute Names are relative to this Key.
//

#define LSAP_DB_ROOT_REG_KEY_NAME L"\\Registry\\Machine\\Security"

//
// LSA Database Object Defines
//

#define LSAP_DB_OBJECT_OPEN                FILE_OPEN
#define LSAP_DB_OBJECT_OPEN_IF             FILE_OPEN_IF
#define LSAP_DB_OBJECT_CREATE              FILE_CREATE
#define LSAP_DB_KEY_VALUE_MAX_LENGTH       (0x00000040L)
#define LSAP_DB_LOGICAL_NAME_MAX_LENGTH    (0x00000100L)
#define LSAP_DB_CREATE_OBJECT_IN_DS        (0x00000200L)

#define LSAP_DB_CREATE_VALID_EXTENDED_FLAGS     0x00000600

//
// LSA Database Object SubKey Defines
//

#define LSAP_DB_SUBKEY_OPEN                FILE_OPEN
#define LSAP_DB_SUBKEY_OPEN_IF             FILE_OPEN_IF
#define LSAP_DB_SUBKEY_CREATE              FILE_CREATE


//
// Growth Delta for Referenced Domain Lists
//

#define LSAP_DB_REF_DOMAIN_DELTA     ((ULONG)  0x00000020L )

//
// Object options values for the object handles
//
#define LSAP_DB_OBJECT_SECRET_INTERNAL      0x00000001  // M$
#define LSAP_DB_OBJECT_SECRET_LOCAL         0x00000002  // L$


//
// The following data type is used in name and SID lookup services to
// describe the domains referenced in the lookup operation.
//
// WARNING! This is an internal version of LSA_REFERENCED_DOMAIN_LIST
// in ntlsa.h.  It has an additional field, MaxEntries.
//

typedef struct _LSAP_DB_REFERENCED_DOMAIN_LIST {

    ULONG Entries;
    PLSA_TRUST_INFORMATION Domains;
    ULONG MaxEntries;

} LSAP_DB_REFERENCED_DOMAIN_LIST, *PLSAP_DB_REFERENCED_DOMAIN_LIST;

// where members have the following usage:
//
//     Entries - Is a count of the number of domains described in the
//         Domains array.
//
//     Domains - Is a pointer to an array of Entries LSA_TRUST_INFORMATION data
//         structures.
//
//     MaxEntries - Is the maximum number of entries that can be stored
//         in the current array


/////////////////////////////////////////////////////////////////////////////
//
// LSA Database Object Types
//
/////////////////////////////////////////////////////////////////////////////

//
// Lsa Database Object Type
//

typedef enum _LSAP_DB_OBJECT_TYPE_ID {

    NullObject = 0,
    PolicyObject,
    TrustedDomainObject,
    AccountObject,
    SecretObject,
    AllObject,
    NewTrustedDomainObject,
    DummyLastObject

} LSAP_DB_OBJECT_TYPE_ID, *PLSAP_DB_OBJECT_TYPE_ID;

//
// LSA Database Object Handle structure (Internal definition of LSAPR_HANDLE)
//
// Note that the Handle structure is public to clients of the Lsa Database
// exported functions, e.g server API workers) so that they can get at things
// like GrantedAccess.
//
// Access to all fields serialized by LsapDbHandleTableEx.TableLock
//

typedef struct _LSAP_DB_HANDLE {

    struct _LSAP_DB_HANDLE *Next;
    struct _LSAP_DB_HANDLE *Previous;
    LIST_ENTRY UserHandleList;
    BOOLEAN Allocated;
    BOOLEAN SceHandle;          // Sce Open Policy handle (opened with LsaOpenPolicySce)
    BOOLEAN SceHandleChild;     // Child handle of an Sce Open Policy Handle
    ULONG ReferenceCount;
    UNICODE_STRING LogicalNameU;
    UNICODE_STRING PhysicalNameU;
    PSID Sid;
    HANDLE KeyHandle;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId;
    struct _LSAP_DB_HANDLE *ContainerHandle;
    ACCESS_MASK DesiredAccess;
    ACCESS_MASK GrantedAccess;
    ACCESS_MASK RequestedAccess;
    BOOLEAN GenerateOnClose;
    BOOLEAN Trusted;
    BOOLEAN DeletedObject;
    BOOLEAN NetworkClient;
    ULONG Options;
    // New for the Ds
    UNICODE_STRING PhysicalNameDs;
    BOOLEAN fWriteDs;
    ULONG ObjectOptions;
    PVOID   UserEntry;
#if DBG == 1
    LARGE_INTEGER HandleCreateTime;
    LARGE_INTEGER HandleLastAccessTime;
#endif

} *LSAP_DB_HANDLE, **PLSAP_DB_HANDLE;

//
// LSA Database Object Sid Enumeration Buffer
//

typedef struct _LSAP_DB_SID_ENUMERATION_BUFFER {

    ULONG EntriesRead;
    PSID *Sids;

} LSAP_DB_SID_ENUMERATION_BUFFER, *PLSAP_DB_SID_ENUMERATION_BUFFER;

//
// LSA Database Object Name Enumeration Buffer
//

typedef struct _LSAP_DB_NAME_ENUMERATION_BUFFER {

    ULONG EntriesRead;
    PUNICODE_STRING Names;

} LSAP_DB_NAME_ENUMERATION_BUFFER, *PLSAP_DB_NAME_ENUMERATION_BUFFER;

#define LSAP_DB_OBJECT_TYPE_COUNT 0x00000005L

//
// Default System Access assigned to Account objects
//

#define LSAP_DB_ACCOUNT_DEFAULT_SYS_ACCESS      ((ULONG) 0L);

//
// LSA Database Account Object Information
//

typedef struct _LSAP_DB_ACCOUNT_INFORMATION {

    QUOTA_LIMITS QuotaLimits;
    PRIVILEGE_SET Privileges;

} LSAP_DB_ACCOUNT_INFORMATION, *PLSAP_DB_ACCOUNT_INFORMATION;

//
// LSA Database Change Account Privilege Mode
//

typedef enum _LSAP_DB_CHANGE_PRIVILEGE_MODE {

    AddPrivileges = 1,
    RemovePrivileges,
    SetPrivileges

} LSAP_DB_CHANGE_PRIVILEGE_MODE;

//
// Self-Relative Unicode String Structure.
//
//
// UNICODE_STRING_SR is used to store self-relative unicode strings in
// the database.  Prior to Sundown, the UNICODE_STRING structure was used,
// overloading the "Buffer" field with a byte offset.
//

typedef struct _UNICODE_STRING_SR {
    USHORT Length;
    USHORT MaximumLength;
    ULONG Offset;

} UNICODE_STRING_SR, *PUNICODE_STRING_SR;

//
// LSA Database Object SubKey names in Unicode Form
//

typedef enum _LSAP_DB_NAMES {

    SecDesc = 0,
    Privilgs,
    Sid,
    Name,
    AdminMod,
    OperMode,
    QuotaLim,
    DefQuota,
    PrDomain,
    Policy,
    Accounts,
    Domains,
    Secrets,
    CurrVal,
    OldVal,
    CupdTime,
    OupdTime,
    PolAdtLg,
    PolAdtEv,
    PolAcDmN,
    PolAcDmS,
    PolDnDDN,
    PolDnTrN,
    PolDnDmG,
    PolEfDat,
    PolPrDmN,
    PolPrDmS,
    PolPdAcN,
    PolRepSc,
    PolRepAc,
    PolRevision,
    PolMod,
    PolState,
    ActSysAc,
    TrDmName,
    TrDmTrPN,   // Netbios name of trust partner
    TrDmSid,
    TrDmAcN,
    TrDmCtN,
    TrDmPxOf,
    TrDmCtEn,
    TrDmTrTy,   // Type of trust
    TrDmTrDi,   // Trust direction
    TrDmTrLA,   // Trust attributes
    TrDmTrPr,   // Trust partner
    TrDmTrRt,   // Trust root partner
    TrDmSAI,    // Auth inbound
    TrDmSAO,    // Auth outbound
    TrDmForT,   // Forest trust info
    TrDmCrSid,  // The SID of the creator
    KerOpts,    // Kerberos authentication options (e.g. POLICY_KERBEROS_VALIDATE_CLIENT)
    KerMinT,    // Kerberos: Maximum lifespan of a service (TGS) ticket
    KerMaxT,    // Kerberos: Maximum lifespan of a ticket-granting (TGT) ticket
    KerMaxR,    // Kerberos: Maximum length of time a TGT can be renewed
    KerProxy,   // Kerberos: Maximum allowed clock skew between client and KDC
    KerLogoff,  // Kerberos: unused
    BhvrVers,   // Behavior-Version
    AuditLog,
    AuditLogMaxSize,
    AuditRecordRetentionPeriod,     // Entries beyond this point don't correspond to real policy
                                    // entries, but are pseudo entries only
    PseudoSystemCritical,
    PolSecretEncryptionKey,
    XRefDnsRoot,      // DNS name of cross-ref object
    XRefNetbiosName,  // NETBIOS name of cross-ref object
    DummyLastName

} LSAP_DB_NAMES;

typedef struct _LSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO {

    ULONG SystemAccess;
    QUOTA_LIMITS QuotaLimits;
    PPRIVILEGE_SET PrivilegeSet;

} LSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO, *PLSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern UNICODE_STRING LsapDbNames[DummyLastName];
extern UNICODE_STRING LsapDbObjectTypeNames[DummyLastObject];

//
// LSA Database Object Type-specific attribute names and values.  If
// supplied on a call to LsapDbCreateObject, they will be stored with
// the object.
//

typedef enum _LSAP_DB_ATTRIB_TYPE {

    LsapDbAttribUnknown = 0,
    LsapDbAttribUnicode,
    LsapDbAttribMultiUnicode,
    LsapDbAttribSid,
    LsapDbAttribGuid,
    LsapDbAttribULong,
    LsapDbAttribUShortAsULong,
    LsapDbAttribSecDesc,
    LsapDbAttribDsName,
    LsapDbAttribPByte,
    LsapDbAttribTime,
    LsapDbAttribDsNameAsUnicode,
    LsapDbAttribDsNameAsSid,
    LsapDbAttribIntervalAsULong

} LSAP_DB_ATTRIB_TYPE, *PLSAP_DB_ATTRIB_TYPE;


typedef struct _LSAP_DB_ATTRIBUTE {

    PUNICODE_STRING AttributeName;
    PVOID AttributeValue;
    ULONG AttributeValueLength;
    BOOLEAN MemoryAllocated;
    BOOLEAN CanDefaultToZero;
    BOOLEAN PseudoAttribute;
    ULONG DsAttId;
    LSAP_DB_ATTRIB_TYPE AttribType;
    LSAP_DB_NAMES DbNameIndex;

} LSAP_DB_ATTRIBUTE, *PLSAP_DB_ATTRIBUTE;

typedef enum _LSAP_DB_DS_LOCATION {

    LsapDsLocUnknown = 0,
    LsapDsLocRegistry,
    LsapDsLocDs,
    LsapDsLocDsLocalPolObj,
    LsapDsLocDsDomainPolObj,
    LsapDsLocLocalAndReg

} LSAP_DB_DS_LOCATION, *PLSAP_DB_DS_LOCATION;

typedef struct _LSAP_DB_DS_INFO {

    ULONG AttributeId;
    LSAP_DB_ATTRIB_TYPE AttributeType;
    LSAP_DB_DS_LOCATION AttributeLocation;

} LSAP_DB_DS_INFO, *PLSAP_DB_DS_INFO;

//
// LSA Database Object General Information.
//

typedef struct _LSAP_DB_OBJECT_INFORMATION {

    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId;
    LSAP_DB_OBJECT_TYPE_ID ContainerTypeId;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PLSAP_DB_ATTRIBUTE TypeSpecificAttributes;
    PSID Sid;
    BOOLEAN ObjectAttributeNameOnly;
    ULONG DesiredObjectAccess;

} LSAP_DB_OBJECT_INFORMATION, *PLSAP_DB_OBJECT_INFORMATION;

//
// New for the Ds integration
//
extern PLSAP_DB_DS_INFO LsapDbDsAttInfo;

//
// Installed, absolute minimum and absolute maximum Quota Limits.
//

extern QUOTA_LIMITS LsapDbInstalledQuotaLimits;
extern QUOTA_LIMITS LsapDbAbsMinQuotaLimits;
extern QUOTA_LIMITS LsapDbAbsMaxQuotaLimits;

//
// Required Ds data types
//
//
// This is the state of the machine with respect to the Ds.  It will control
// some of the basic functionality of the Lsa APIs by determing who can write
// what where, etc...
//
typedef enum _LSADS_INIT_STATE {

    LsapDsUnknown = 0,
    LsapDsNoDs,
    LsapDsDs,
    LsapDsDsMaintenance,
    LsapDsDsSetup

} LSADS_INIT_STATE, *PLSADS_INIT_STATE;


//
// LSA Database Exported Function Prototypes
//
// NOTE: These are callable only from the LSA
//

BOOLEAN
LsapDbIsServerInitialized(
    );

NTSTATUS
LsapDbOpenPolicy(
    IN PLSAPR_SERVER_NAME SystemName OPTIONAL,
    IN OPTIONAL PLSAPR_OBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Options,
    OUT PLSAPR_HANDLE PolicyHandle,
    IN BOOLEAN TrustedClient
    );

NTSTATUS
LsapDbOpenTrustedDomain(
    IN LSAPR_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE TrustedDomainHandle,
    IN ULONG Options
    );

NTSTATUS
LsapDbOpenTrustedDomainByName(
    IN LSAPR_HANDLE PolicyHandle OPTIONAL,
    IN PUNICODE_STRING TrustedDomainName,
    OUT PLSAPR_HANDLE TrustedDomainHandle,
    IN ULONG AccessMask,
    IN ULONG Options,
    IN BOOLEAN Trusted
    );

NTSTATUS
LsapDbOpenObject(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG Options,
    OUT PLSAPR_HANDLE LsaHandle
    );

NTSTATUS
LsapDbCreateObject(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateDisposition,
    IN ULONG Options,
    IN OPTIONAL PLSAP_DB_ATTRIBUTE TypeSpecificAttributes,
    IN OUT ULONG *TypeSpecificAttributeCount,
    IN ULONG TypeSpecificAttributeAllocated,
    OUT PLSAPR_HANDLE LsaHandle
    );

NTSTATUS
LsapCloseHandle(
    IN OUT LSAPR_HANDLE *ObjectHandle,
    IN NTSTATUS PreliminaryStatus
    );

NTSTATUS
LsapDbCloseObject(
    IN PLSAPR_HANDLE ObjectHandle,
    IN ULONG Options,
    IN NTSTATUS PreliminaryStatus
    );

NTSTATUS
LsapDbDeleteObject(
    IN LSAPR_HANDLE ObjectHandle
    );

NTSTATUS
LsapDbReferenceObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN ACCESS_MASK DesiredAccess,
    IN LSAP_DB_OBJECT_TYPE_ID HandleTypeId,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN ULONG Options
    );

NTSTATUS
LsapDbDereferenceObject(
    IN OUT PLSAPR_HANDLE ObjectHandle,
    IN LSAP_DB_OBJECT_TYPE_ID HandleTypeId,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN ULONG Options,
    IN SECURITY_DB_DELTA_TYPE SecurityDbDeltaType,
    IN NTSTATUS PreliminaryStatus
    );

NTSTATUS
LsapDbReadAttributeObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN PUNICODE_STRING AttributeNameU,
    IN OPTIONAL PVOID AttributeValue,
    IN OUT PULONG AttributeValueLength
    );

NTSTATUS
LsapDbReadAttributeObjectEx(
    IN LSAPR_HANDLE ObjectHandle,
    IN LSAP_DB_NAMES AttributeIndex,
    IN OPTIONAL PVOID AttributeValue,
    IN OUT PULONG AttributeValueLength,
    IN BOOLEAN CanDefaultToZero
    );

NTSTATUS
LsapDbWriteAttributeObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN PUNICODE_STRING AttributeNameU,
    IN PVOID AttributeValue,
    IN ULONG AttributeValueLength
    );

NTSTATUS
LsapDbWriteAttributesObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    );

NTSTATUS
LsapDbReadAttributesObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG Options,
    IN OUT PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    );

NTSTATUS
LsapDbDeleteAttributeObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN PUNICODE_STRING AttributeNameU,
    IN BOOLEAN DeleteSecurely
    );

NTSTATUS
LsapDbDeleteAttributesObject(
    IN LSAPR_HANDLE ObjectHandle,
    IN PLSAP_DB_ATTRIBUTE Attributes,
    IN ULONG AttributeCount
    );

NTSTATUS
LsapDbOpenTransaction(
    IN ULONG Options
    );

NTSTATUS
LsapDbApplyTransaction(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG Options,
    IN SECURITY_DB_DELTA_TYPE SecurityDbDeltaType
    );

NTSTATUS
LsapDbAbortTransaction(
    IN ULONG Options
    );

NTSTATUS
LsapDbSidToLogicalNameObject(
    IN PSID Sid,
    OUT PUNICODE_STRING LogicalNameU
    );

NTSTATUS
LsapDbChangePrivilegesAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN LSAP_DB_CHANGE_PRIVILEGE_MODE ChangeMode,
    IN BOOLEAN AllPrivileges,
    IN OPTIONAL PPRIVILEGE_SET Privileges,
    IN BOOL LockSce
    );

NTSTATUS
LsapDbEnumerateSids(
    IN LSAPR_HANDLE ContainerHandle,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAP_DB_SID_ENUMERATION_BUFFER DbEnumerationBuffer,
    IN ULONG PreferedMaximumLength
    );

NTSTATUS
LsapDbFindNextSid(
    IN LSAPR_HANDLE ContainerHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    OUT PLSAPR_SID *NextSid
    );

NTSTATUS
LsapDbEnumeratePrivileges(
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAPR_PRIVILEGE_ENUM_BUFFER EnumerationBuffer,
    IN ULONG PreferedMaximumLength
    );

NTSTATUS
LsapDbEnumerateNames(
    IN LSAPR_HANDLE ContainerHandle,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAP_DB_NAME_ENUMERATION_BUFFER DbEnumerationBuffer,
    IN ULONG PreferedMaximumLength
    );

NTSTATUS
LsapDbFindNextName(
    IN LSAPR_HANDLE ContainerHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    OUT PLSAPR_UNICODE_STRING Name
    );

VOID
LsapDbFreeEnumerationBuffer(
    IN PLSAP_DB_NAME_ENUMERATION_BUFFER DbEnumerationBuffer
    );

NTSTATUS
LsapDbInitializeServer(
    IN ULONG Pass
    );

//
// These routines may someday migrate to Rtl runtime library.  Their
// names have Lsap Prefixes only temporarily, so that they can be located
// easily.
//

// Options for LsapRtlAddPrivileges

#define  RTL_COMBINE_PRIVILEGE_ATTRIBUTES   ((ULONG) 0x00000001L)
#define  RTL_SUPERSEDE_PRIVILEGE_ATTRIBUTES ((ULONG) 0x00000002L)

NTSTATUS
LsapRtlAddPrivileges(
    IN OUT PPRIVILEGE_SET * RunningPrivileges,
    IN OUT PULONG           MaxRunningPrivileges,
    IN PPRIVILEGE_SET       PrivilegesToAdd,
    IN ULONG                Options,
    OUT OPTIONAL BOOLEAN *  Changed
    );

NTSTATUS
LsapRtlRemovePrivileges(
    IN OUT PPRIVILEGE_SET ExistingPrivileges,
    IN PPRIVILEGE_SET PrivilegesToRemove
    );

PLUID_AND_ATTRIBUTES
LsapRtlGetPrivilege(
    IN PLUID_AND_ATTRIBUTES Privilege,
    IN PPRIVILEGE_SET Privileges
    );

BOOLEAN
LsapRtlPrefixSid(
    IN PSID PrefixSid,
    IN PSID Sid
    );

ULONG
LsapDbGetSizeTextSid(
    IN PSID Sid
    );

NTSTATUS
LsapDbSidToTextSid(
    IN PSID Sid,
    OUT PSZ TextSid
    );

NTSTATUS
LsapDbSidToUnicodeSid(
    IN PSID Sid,
    OUT PUNICODE_STRING SidU,
    IN BOOLEAN AllocateDestinationString
    );

NTSTATUS
LsapDbInitializeWellKnownValues();

#if defined(REMOTE_BOOT)
VOID
LsapDbInitializeRemoteBootState();
#endif // defined(REMOTE_BOOT)

NTSTATUS
LsapDbVerifyInformationObject(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation
    );

/*++

BOOLEAN
LsapDbIsValidTypeObject(
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId
    )

Routine Description:

    This macro function determines if a given Object Type Id is valid.

Arguments:

    ObjectTypeId - Object Type Id.

Return Values:

    BOOLEAN - TRUE if object type id is valid, else FALSE.

--*/

#define LsapDbIsValidTypeObject(ObjectTypeId)                            \
            (((ObjectTypeId) > NullObject) &&                            \
             ((ObjectTypeId) < DummyLastObject))


NTSTATUS
LsapDbVerifyInfoQueryPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PACCESS_MASK RequiredAccess
    );

NTSTATUS
LsapDbVerifyInfoSetPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation,
    OUT PACCESS_MASK RequiredAccess
    );

BOOLEAN
LsapDbValidInfoPolicy(
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN OPTIONAL PLSAPR_POLICY_INFORMATION PolicyInformation
    );

NTSTATUS
LsapDbVerifyInfoQueryTrustedDomain(
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN BOOLEAN Trusted,
    OUT PACCESS_MASK RequiredAccess
    );

NTSTATUS
LsapDbVerifyInfoSetTrustedDomain(
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation,
    IN BOOLEAN Trusted,
    OUT PACCESS_MASK RequiredAccess
    );

BOOLEAN
LsapDbValidInfoTrustedDomain(
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN OPTIONAL PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation
    );

NTSTATUS
LsapDbMakeUnicodeAttribute(
    IN OPTIONAL PUNICODE_STRING UnicodeValue,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    );

VOID
LsapDbCopyUnicodeAttributeNoAlloc(
    OUT PUNICODE_STRING OutputString,
    IN PLSAP_DB_ATTRIBUTE Attribute,
    IN BOOLEAN SelfRelative
    );

NTSTATUS
LsapDbCopyUnicodeAttribute(
    OUT PUNICODE_STRING OutputString,
    IN PLSAP_DB_ATTRIBUTE Attribute,
    IN BOOLEAN SelfRelative
    );

NTSTATUS
LsapDbMakeSidAttribute(
    IN PSID Sid,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    );

NTSTATUS
LsapDbMakeGuidAttribute(
    IN GUID *Guid,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    );

NTSTATUS
LsapDbMakeUnicodeAttributeDs(
    IN OPTIONAL PUNICODE_STRING UnicodeValue,
    IN LSAP_DB_NAMES Name,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    );

NTSTATUS
LsapDbMakeSidAttributeDs(
    IN PSID Sid,
    IN IN LSAP_DB_NAMES Name,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    );

NTSTATUS
LsapDbMakeGuidAttributeDs(
    IN GUID *Guid,
    IN LSAP_DB_NAMES Name,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    );

NTSTATUS
LsapDbMakePByteAttributeDs(
    IN OPTIONAL PBYTE Buffer,
    IN ULONG BufferLength,
    IN LSAP_DB_ATTRIB_TYPE AttribType,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    );

NTSTATUS
LsapDbReadAttribute(
    IN LSAPR_HANDLE ObjectHandle,
    IN OUT PLSAP_DB_ATTRIBUTE Attribute
    );

NTSTATUS
LsapDbFreeAttributes(
    IN ULONG Count,
    IN PLSAP_DB_ATTRIBUTE Attributes
    );

/*++

VOID
LsapDbInitializeAttribute(
    IN PLSAP_DB_ATTRIBUTE AttributeP,
    IN PUNICODE_STRING AttributeNameP,
    IN OPTIONAL PVOID AttributeValueP,
    IN ULONG AttributeValueLengthP,
    IN BOOLEAN MemoryAllocatedP
    )

Routine Description:

    This macro function initialize an Lsa Database Object Attribute
    structure.  No validation is done.

Arguments:

    AttributeP - Pointer to Lsa Database Attribute structure to be
        initialized.

    AttributeNameP - Pointer to Unicode String containing the attribute's
        name.

    AttributeValueP - Pointer to the attribute's value.  NULL may be
        specified.

    AttributeValueLengthP - Length of the attribute's value in bytes.

    MemoryAllocatedP - TRUE if memory is allocated by MIDL_user_allocate
        within the LSA Server code (not by RPC server stubs), else FALSE.

Return Values:

    None.

--*/

#define LsapDbInitializeAttribute(                                         \
            AttributeP,                                                    \
            AttributeNameP,                                                \
            AttributeValueP,                                               \
            AttributeValueLengthP,                                         \
            MemoryAllocatedP                                               \
            )                                                              \
                                                                           \
{                                                                          \
    (AttributeP)->AttributeName = AttributeNameP;                          \
    (AttributeP)->AttributeValue = AttributeValueP;                        \
    (AttributeP)->AttributeValueLength = AttributeValueLengthP;            \
    (AttributeP)->MemoryAllocated = MemoryAllocatedP;                      \
    (AttributeP)->DsAttId =   0;                                           \
    (AttributeP)->AttribType = LsapDbAttribUnknown;                        \
    (AttributeP)->CanDefaultToZero = FALSE;                                \
    (AttributeP)->PseudoAttribute = FALSE;                                 \
}

/*++

VOID
LsapDbInitializeAttributeDs(
    IN PLSAP_DB_ATTRIBUTE AttributeP,
    IN LSAP_DB_NAMES Name,
    IN OPTIONAL PVOID AttributeValueP,
    IN ULONG AttributeValueLengthP,
    IN BOOLEAN MemoryAllocatedP
    )

Routine Description:

    This macro function initialize an Lsa Database Object Attribute
    structure.  No validation is done.

Arguments:

    AttributeP - Pointer to Lsa Database Attribute structure to be
        initialized.

    Name - Name index to create

    AttributeValueP - Pointer to the attribute's value.  NULL may be
        specified.

    AttributeValueLengthP - Length of the attribute's value in bytes.

    MemoryAllocatedP - TRUE if memory is allocated by MIDL_user_allocate
        within the LSA Server code (not by RPC server stubs), else FALSE.

Return Values:

    None.

--*/
#define LsapDbInitializeAttributeDs(                                       \
            AttributeP,                                                    \
            Name,                                                          \
            AttributeValueP,                                               \
            AttributeValueLengthP,                                         \
            MemoryAllocatedP                                               \
            )                                                              \
                                                                           \
{                                                                          \
    LsapDbInitializeAttribute( (AttributeP), &LsapDbNames[Name],           \
                                AttributeValueP, AttributeValueLengthP,    \
                                MemoryAllocatedP );                        \
    (AttributeP)->DsAttId =   LsapDbDsAttInfo[Name].AttributeId;           \
    (AttributeP)->AttribType = LsapDbDsAttInfo[Name].AttributeType;        \
    (AttributeP)->CanDefaultToZero = FALSE;                                \
    (AttributeP)->DbNameIndex = Name;                                      \
}

#define LsapDbAttributeCanNotExist(                                        \
            AttributeP                                                     \
            )                                                              \
{                                                                          \
    (AttributeP)->CanDefaultToZero = TRUE;                                 \
}


NTSTATUS
LsapInitializeNotifiyList(
    VOID
    );

NTSTATUS
LsapCrServerGetSessionKeySafe(
    IN LSAPR_HANDLE ObjectHandle,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    OUT PLSAP_CR_CIPHER_KEY *SessionKey
    );

NTSTATUS
LsapDbVerifyHandle(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG Options,
    IN LSAP_DB_OBJECT_TYPE_ID ExpectedObjectTypeId,
    IN BOOLEAN ReferenceHandle
    );

BOOLEAN
LsapDbDereferenceHandle(
    IN LSAPR_HANDLE ObjectHandle,
    IN BOOLEAN CalledInSuccessPath
    );

NTSTATUS
LsapDbQueryAllInformationAccounts(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG IdCount,
    IN PSID_AND_ATTRIBUTES Ids,
    OUT PLSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO AccountInfo
    );

NTSTATUS
LsapCreateTrustedDomain2(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE TrustedDomainHandle
    );

NTSTATUS
LsapDsInitializeDsStateInfo(
    IN  LSADS_INIT_STATE    DsInitState
    );

NTSTATUS
LsapDsUnitializeDsStateInfo(
    );

/*++

BOOLEAN
LsapValidateLsaUnicodeString(
    IN PLSAPR_UNICODE_STRING UnicodeString
    );

Returns TRUE if the LSAPR_UNICODE_STRING is valid.  FALSE otherwise
--*/

#define LsapValidateLsaUnicodeString( _us_ ) \
(( (_us_) == NULL  || \
    ( \
        (_us_)->MaximumLength >= ( _us_ )->Length && \
        (_us_)->Length % 2 == 0  && \
        (_us_)->MaximumLength % 2 == 0 && \
        ((_us_)->Length == 0  || (_us_)->Buffer != NULL ) \
    ) \
) ? TRUE : FALSE )

/*++

BOOLEAN
LsapValidateLsaCipherValue(
    IN PLSAPR_UNICODE_STRING UnicodeString
    );

Returns TRUE if the LSAPR_CR_CIPHER_KEY is valid.  FALSE otherwise
--*/

#define LsapValidateLsaCipherValue( _us_ ) \
    ( \
        (_us_)->MaximumLength >= ( _us_ )->Length && \
        ((_us_)->Length == 0  || (_us_)->Buffer != NULL ) \
    ) \
? TRUE : FALSE


NTSTATUS
LsapDbIsRpcClientNetworkClient(
    IN OUT PBOOLEAN IsNetworkClient
    );

BOOLEAN
LsapSidPresentInGroups(
    IN PTOKEN_GROUPS TokenGroups,
    IN SID * Sid
    );

NTSTATUS
LsapDomainRenameHandlerForLogonSessions(
    IN PUNICODE_STRING OldNetbiosName,
    IN PUNICODE_STRING OldDnsName,
    IN PUNICODE_STRING NewNetbiosName,
    IN PUNICODE_STRING NewDnsName
    );

NTSTATUS
LsapRetrieveDnsDomainNameFromHive(
    IN HKEY Hkey,
    IN OUT DWORD * Length,
    OUT WCHAR * Buffer
    );

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _LSA_DB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\base\lsa\server\credmgr.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    credmgr.cxx

Abstract:

    Credential Manager Interfaces

Author:

    Cliff Van Dyke      (CliffV)

Environment:

Revision History:

--*/

#include <lsapch.hxx>

extern "C" {
#include <wincrypt.h>
#include <windns.h>
#include <align.h>
#include <rc4.h>
#include <des.h>
#include <modes.h>
#include <cryptdll.h>
#include <names.h>
#include <smbgtpt.h>
#include <shfolder.h>
#include <netlibnt.h>
#include <stddef.h>
#include <userenv.h>
#include <userenvp.h>
#include <sclogon.h>
#include <sclogon2.h>
}

//
// Include routines common with netapi32.dll
//

#include <credp.h>
#include <..\netclient\credapi.c>

extern "C"
{
BOOLEAN
LsapIsRunningOnPersonal(
    VOID
    );
}

//
// Local structures
//

//
// Structure describing a canonical credential
//
// This is the structure of a single credential as stored in memory in the LSA process.
//

typedef struct _CANONICAL_CREDENTIAL {

    //
    // The Credential itself
    //

    CREDENTIALW Cred;

    //
    // The size in bytes of the clear text credential blob
    //

    ULONG ClearCredentialBlobSize;

    //
    // Link to next entry in the list of credentials in the credential set.
    //  Access serialized by UserCredentialSets->CritSect
    //

    LIST_ENTRY Next;

    //
    // UNICODE_STRING form of Cred.TargetName
    //

    UNICODE_STRING TargetName;

    //
    // UNICODE_STRING form of Cred.TargetAlias
    //

    UNICODE_STRING TargetAlias;

    //
    // UNICODE_STRING form of Cred.UserName
    //

    UNICODE_STRING UserName;

    //
    // Describe the wildcard nature of this credential
    //
    WILDCARD_TYPE WildcardType;

    //
    // TargetName with the wildcard characters removed.
    //
    // The exact value is a function on WildcardType:
    //  WcDfsShareName: this is the 'server name' portion of the string
    //  WcServerWildcard: this is the 'server name' portion of the string preceeded by a .
    //  WcDomainWildcard: this is the 'domain name' portion of the string
    //  All Others: This is a copy of TargetName
    //
    // ??? I don't think we use it for WcDfsShare name any more.

    UNICODE_STRING NonWildcardedTargetName;

    //
    // Size (in bytes) of this structure and all of the pointed to strings.
    //

    ULONG AllocatedSize;

    //
    // True if credential is to be returned to the caller.
    //  Access serialized by UserCredentialSets->CritSect
    //

    BOOLEAN ReturnMe;

    //
    // True if the CredBlob should be ignored and the logon password should be used.
    //

    BOOLEAN UseLogonPassword;


} CANONICAL_CREDENTIAL, *PCANONICAL_CREDENTIAL;


//
// Structure describing when a credential should be prompted for.
//
//  In general, this structure exists on a per-session basis for each credential that needs prompt
//  data to be stored.
//  In the future, this structure might contain other per-session/per-credential data.
//
typedef struct _PROMPT_DATA {

    //
    // Link to next entry in the list of PROMPT_DATA for this session.
    //  Access serialized by UserCredentialSets->CritSect
    //

    LIST_ENTRY Next;

    //
    // Target Name of the credential this prompt data is for.
    //

    UNICODE_STRING TargetName;

    //
    // Type of the credential this prompt data is for.
    //

    DWORD Type;

    //
    // Persistence of the credential this prompt data is for.
    //

    DWORD Persist;

    //
    // Boolean indicating if this credential was been written yet in this session.
    //

    BOOLEAN Written;

} PROMPT_DATA, *PPROMPT_DATA;

//
// Structure describing the ability to undo a credential write
//
// UserCredentialSets->CritSect must remain locked for the life of this structure.
//

typedef struct _CRED_WRITE_UNDO {


    //
    // A pointer to the old credential
    //
    // NULL if there was no old credential.
    // OldCredential should be freed using LsapFreeLsaHeap.
    //
    PCANONICAL_CREDENTIAL OldCredential;

    //
    // A pointer to the new credential
    //
    // NewCredential is properly linked and should only be freed if it is delinked.
    //
    PCANONICAL_CREDENTIAL NewCredential;


    //
    // A pointer to the old prompt data for the credential
    //
    // NULL if there is no old prompt data.
    //  OldPromptData should be freed using LsapFreeLsaHeap
    PPROMPT_DATA OldPromptData;

    //
    // A pointer to the new prompt data for the credential
    //
    // NULL if there is no new prompt data.
    // NewPromptData is properly linked into the prompt data list and should only be freed
    //    (using LsapFreeLsaHeap) if it is delinked.
    //
    PPROMPT_DATA NewPromptData;

} CRED_WRITE_UNDO, *PCRED_WRITE_UNDO;

//
// Structure describing a canonical target info
//

typedef struct _CANONICAL_TARGET_INFO {

    UNICODE_STRING TargetName;
    UNICODE_STRING NetbiosServerName;
    UNICODE_STRING DnsServerName;
    UNICODE_STRING NetbiosDomainName;
    UNICODE_STRING DnsDomainName;
    UNICODE_STRING DnsTreeName;
    UNICODE_STRING PackageName;
    DWORD Flags;
    DWORD CredTypeCount;
    LPDWORD CredTypes;


//
// Define how a credential matches a target info.
//
// This list is ordered from most specific to least specific
//
#define CRED_DFS_SHARE_NAME         0
#define CRED_DNS_SERVER_NAME        1
#define CRED_NETBIOS_SERVER_NAME    2
#define CRED_TARGET_NAME            3
#define CRED_WILDCARD_SERVER_NAME   4
#define CRED_DNS_DOMAIN_NAME        5
#define CRED_NETBIOS_DOMAIN_NAME    6
#define CRED_UNIVERSAL_SESSION_NAME 7
#define CRED_UNIVERSAL_NAME         8
#define CRED_MAX_ALIASES            9


    //
    // Link into SessionCredSets->TargetInfoHashTable
    //

    LIST_ENTRY HashNext;

    //
    // Link into SessionCredSets->TargetInfoLruList
    //

    LIST_ENTRY LruNext;

} CANONICAL_TARGET_INFO, *PCANONICAL_TARGET_INFO;


//
// Structure describing an encryptable credential set
//
// This is the structure of a credential set as it appears on disk.
// It appears as a MARSHALED_CREDENTIAL_SET structure followed by a series of
// MARSHALED_CREDENTIAL structures.
//

typedef struct _MARSHALED_CREDENTIAL_SET {

    // Version of this structure
    ULONG Version;
#define MARSHALED_CREDENTIAL_SET_VERSION 1

    // Size in bytes of the entire credential set.
    ULONG Size;

} MARSHALED_CREDENTIAL_SET, *PMARSHALED_CREDENTIAL_SET;

typedef struct _MARSHALED_CREDENTIAL {

    //
    // Size in bytes of the entire credential (including variable length fields)
    //
    ULONG EntrySize;

    //
    // Fields from the CREDENTIALW structure
    //
    DWORD Flags;
    DWORD Type;
    FILETIME LastWritten;
    DWORD CredentialBlobSize;
    DWORD Persist;
    DWORD AttributeCount;
    DWORD Expansion1;       // This field is reserved for expansion
    DWORD Expansion2;       // This field is reserved for expansion

} MARSHALED_CREDENTIAL, *PMARSHALED_CREDENTIAL;



//
// Macro to pick a credential set for a particular peristance.
//

#define CREDENTIAL_FILE_NAME L"Credentials";
#define CRED_PERSIST_MIN CRED_PERSIST_SESSION
#define CRED_PERSIST_MAX CRED_PERSIST_ENTERPRISE

#define PersistToCredentialSet( _CredentialSets, _Persist ) \
    (((_Persist) == CRED_PERSIST_SESSION) ? \
        (_CredentialSets)->SessionCredSets->SessionCredSet : \
        (((_Persist) == CRED_PERSIST_LOCAL_MACHINE) ? \
            (_CredentialSets)->UserCredentialSets->LocalMachineCredSet : \
            (_CredentialSets)->UserCredentialSets->EnterpriseCredSet ) )

//
// Macro returns TRUE if the CredentialBlob is to be persisted
//
// Don't persist PINS passwords.  We entrust the PIN to the CSP.
//
#define PersistCredBlob( _Credential ) \
    ( (_Credential)->Type != CRED_TYPE_DOMAIN_CERTIFICATE )

//
// Macro returns TRUE if the credential is to be prompted for
//
// If there is no prompt data,
//      we've never prompted for this credential since logon.
// If there is prompt data,
//      we can rely on the boolean
//

#define ShouldPromptNow( _PromptData ) \
    ((_PromptData) == NULL || !(_PromptData)->Written )



//
// Globals
//
// List of USER_CREDENTIAL_SETS for each logged on user.

RTL_CRITICAL_SECTION CredentialSetListLock;
LIST_ENTRY CredentialSetList;

//
// Configurable values
//
#define CRED_TARGET_INFO_MAX_COUNT 1000;
ULONG CredTargetInfoMaxCount;
ULONG CredDisableDomainCreds;
ULONG CredIsPersonal;

//
// Define the default order for returning credentials from CredReadDomainCredentials
//

ULONG CredTypeDefaultOrder[] =
{
    CRED_TYPE_DOMAIN_CERTIFICATE,
    CRED_TYPE_DOMAIN_PASSWORD,
    CRED_TYPE_DOMAIN_VISIBLE_PASSWORD
};

//
// Memory containing key for LSA protected memory.
//

PVOID CredLockedMemory = NULL;
ULONG CredLockedMemorySize = 0;

//
// DES-X keystate
//

DESXTable *g_pDESXKey = NULL;
unsigned __int64 g_Feedback;

//
// RC4 keystate
//

PBYTE g_pRandomKey = NULL;
ULONG g_cbRandomKey = 0;

//
// Forwards
//

NTSTATUS
CredpWriteCredential(
    IN PCREDENTIAL_SETS CredentialSets,
    IN OUT PCANONICAL_CREDENTIAL *NewCredential,
    IN BOOLEAN FromPersistedFile,
    IN BOOLEAN WritePinToCsp,
    IN BOOLEAN PromptedFor,
    IN DWORD Flags,
    OUT PCRED_WRITE_UNDO *CredUndo OPTIONAL
    );


extern DWORD
DPAPINotifyPasswordChange(
    IN PUNICODE_STRING NetbiosDomainName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword
    );


VOID
LsaINotifyPasswordChanged(
    IN PUNICODE_STRING NetbiosDomainName OPTIONAL,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DnsDomainName OPTIONAL,
    IN PUNICODE_STRING Upn OPTIONAL,
    IN PUNICODE_STRING OldPassword OPTIONAL,
    IN PUNICODE_STRING NewPassword,
    IN BOOLEAN Impersonating
    )

/*++

Routine Description:

    This routine is a callback from the MSV authentication package following a password
    change.  This routine will update any password caches maintained in the LSA.


Arguments:

    NetbiosDomainName - Netbios domain name of the user whose password was changed
                        OPTIONAL if we're caching MIT realm credentials

    UserName - User name of the user whose password was changed

    DnsDomainName - If known, Dns Domain Name of the user whose password was changed

    Upn - If known, the Upn of the user whose password was changed

    OldPassword - If known, the previous password for the user.

    NewPassword - The new password for the user.

    Impersonating - If TRUE, this routine is called while impersonating the user changing
        the password.  That user isn't necessarily UserName.

Return Values:

    None

--*/
{

    //
    // Notify the credential manager of the change.
    //

    if ( Impersonating ) {
        CredpNotifyPasswordChange( NetbiosDomainName,
                                   UserName,
                                   DnsDomainName,
                                   Upn,
                                   NewPassword );
    }

    //
    // Notify DPAPI of the change.
    //

    if (ARGUMENT_PRESENT(NetbiosDomainName))  {

        DPAPINotifyPasswordChange( NetbiosDomainName,
                                   UserName,
                                   OldPassword,
                                   NewPassword);
    }
}


VOID
LsaEncryptMemory(
    PBYTE       pData,
    ULONG       cbData,
    int         Operation
    )
/*++

Routine Description:

    This routine encrypts the specified buffer in place with a key that exists until
    the next reboot.

    The purpose of the routine is to protect sensitive data that will be swapped
    to the page file.

Arguments:

    pData - Pointer to the data to encrypt

    cbData - Length (in bytes) of the data to encrypt

    Operation - ENCRYPT or DECRYPT

Return Values:

    None

--*/
{

    if( pData == NULL || cbData == 0 ) {
        return;
    }

    DsysAssert( ((DESX_BLOCKLEN % 8) == 0) );

    if( (cbData & (DESX_BLOCKLEN-1)) == 0 )
    {
        unsigned __int64 feedback;
        ULONG BlockCount;

        BlockCount = cbData / DESX_BLOCKLEN;
        feedback = g_Feedback;

        while( BlockCount-- )
        {
            CBC(
                desx,                       // desx is the cipher routine
                DESX_BLOCKLEN,
                pData,                      // result buffer.
                pData,                      // input buffer.
                g_pDESXKey,
                Operation,
                (unsigned char*)&feedback
                );

            pData += DESX_BLOCKLEN;
        }


    } else {
        RC4_KEYSTRUCT rc4key;

        rc4_key( &rc4key, g_cbRandomKey, g_pRandomKey );
        rc4( &rc4key, cbData, pData );

        RtlSecureZeroMemory( &rc4key, sizeof(rc4key) );
    }

    return;
}



VOID
LsaProtectMemory(
    VOID        *pData,
    ULONG       cbData
    )
/*++

Routine Description:

    This routine encrypts the specified buffer in place with a key that exists until
    the next reboot.

    The purpose of the routine is to protect sensitive data that will be swapped
    to the page file.

Arguments:

    pData - Pointer to the data to encrypt

    cbData - Length (in bytes) of the data to encrypt

Return Values:

    None

--*/
{
    LsaEncryptMemory( (PBYTE)pData, cbData, ENCRYPT );
}


VOID
LsaUnprotectMemory(
    VOID        *pData,
    ULONG       cbData
    )
/*++

Routine Description:

    This routine decrypts the specified buffer in place with a key that exists until
    the next reboot.

    The purpose of the routine is to un protect sensitive data that was encrypted via
    LsaProtectMemory.

Arguments:

    pData - Pointer to the data to decrypt

    cbData - Length (in bytes) of the data to decrypt

Return Values:

    None

--*/
{
    LsaEncryptMemory( (PBYTE)pData, cbData, DECRYPT );
}

extern "C"
VOID
LsaCleanupProtectedMemory(
    VOID
    )
/*++

Routine Description:

    This routine cleans up the LsaProtectMemory subsystem

Arguments:

    None

Return Values:

    None

--*/
{
    if( CredLockedMemory ) {
        ZeroMemory( CredLockedMemory, CredLockedMemorySize );
        VirtualFree( CredLockedMemory, 0, MEM_RELEASE );
        CredLockedMemory = NULL;
    }
}

extern "C"
NTSTATUS
LsaInitializeProtectedMemory(
    VOID
    )
/*++

Routine Description:

    This routine initializes the LsaProtectMemory subsystem

Arguments:

    None

Return Values:

    Status of the operation

--*/
{
    NTSTATUS Status;
    //
    // Lock enough memory to contain the maximum size key the algorithm supports.
    //

    g_cbRandomKey = 256;

    CredLockedMemorySize = sizeof(DESXTable) + g_cbRandomKey;

    CredLockedMemory = VirtualAlloc(
                                    NULL,
                                    CredLockedMemorySize,
                                    MEM_COMMIT,
                                    PAGE_READWRITE );

    if ( CredLockedMemory == NULL ) {
        return I_RpcMapWin32Status( GetLastError() );
    }

    //
    // lock memory.
    //

    if (!VirtualLock( CredLockedMemory, CredLockedMemorySize )) {
        Status = I_RpcMapWin32Status( GetLastError() );
        goto Cleanup;
    }

    //
    // setup DESX key.
    //

    g_pDESXKey = (DESXTable*)CredLockedMemory;
    g_pRandomKey = (PBYTE)( (PBYTE)g_pDESXKey + sizeof(DESXTable) );

    if ( !RtlGenRandom( g_pRandomKey, DESX_KEYSIZE )) {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    if ( !RtlGenRandom( (PUCHAR)&g_Feedback, sizeof(g_Feedback) )) {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    desxkey( g_pDESXKey, g_pRandomKey );

    //
    // generate random key in page locked memory.
    //

    if ( !RtlGenRandom( g_pRandomKey, g_cbRandomKey )) {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;

Cleanup:

    if(!NT_SUCCESS(Status))
    {
        LsaCleanupProtectedMemory();
    }

    return Status;
}



NTSTATUS
CredpInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the credential manager.  It is called once during LSA
    initialization.

Arguments:

    None.

Return Values:

    Status of the operation.

--*/
{
    NTSTATUS Status;
    DWORD WinStatus;
    ULONG i;
    HKEY LsaKey;



    //
    // Initialize LSA memory protection subsystem
    //  (This initialization could have happened earlier, but the cred manager
    //  is its first client.)
    //
    Status = LsaInitializeProtectedMemory();

    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    //
    // Initialize credential set globals.
    //
    Status = RtlInitializeCriticalSection( &CredentialSetListLock );

    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    InitializeListHead( &CredentialSetList );

    //
    // Domain creds are always disabled on personal
    //

    if ( LsapIsRunningOnPersonal() ) {

        CredIsPersonal = TRUE;

    }

    //
    // Initialize default values of configurable values.
    //
    CredTargetInfoMaxCount = CRED_TARGET_INFO_MAX_COUNT;
    CredDisableDomainCreds = FALSE;


    //
    // Grab registry settings.
    //


    WinStatus = RegOpenKeyExA(
                            HKEY_LOCAL_MACHINE,
                            "System\\CurrentControlSet\\Control\\Lsa",
                            0,
                            KEY_READ,
                            &LsaKey );

    if ( WinStatus == NO_ERROR ) {
        ULONG Value;
        ULONG Type;
        ULONG Size = sizeof(DWORD);

        //
        // Get the cache size
        //
        WinStatus = RegQueryValueExA(
                            LsaKey,
                            "TargetInfoCacheSize",
                            0,
                            &Type,
                            (PUCHAR) &Value,
                            &Size );

        if ( WinStatus == NO_ERROR ) {
            //
            // Don't allow ridiculously small values.
            //

            if ( Value == 0 ) {
                Value = 1;
            }
            CredTargetInfoMaxCount = Value;
        }

        //
        // Get whether domain creds are disabled
        //

        Size = sizeof(DWORD);

        WinStatus = RegQueryValueExA(
                            LsaKey,
                            "DisableDomainCreds",
                            0,
                            &Type,
                            (PUCHAR) &Value,
                            &Size );

        if ( WinStatus == NO_ERROR ) {
            CredDisableDomainCreds = Value;
        }

        RegCloseKey( LsaKey );
    }


    // ???: Don't check this in
    // SPMInfoLevel |= DEB_TRACE_CRED;

    return STATUS_SUCCESS;
}

DWORD
CredpHashIndexTargetInfo(
    IN LPWSTR TargetName
    )

/*++

Routine Description:

    This routine computes the hash index for a particular server.

Arguments:

    TargetName - Name of the server to compute the index for

Return Values:

    Hash index

--*/

{
    NTSTATUS Status;
    OEM_STRING UpcasedString;
    UNICODE_STRING NetbiosServerNameString;
    CHAR StringBuffer[CNLEN+1];
    ULONG i;
    DWORD Value = 0;

    WCHAR NetbiosServerNameBuffer[CNLEN+1];
    DWORD Size;

    //
    // Convert the name to a netbios name.
    //  (It might already be one.)
    //
    //  We want to make sure the queried name falls into the same hash bucket.
    //  So, no matter what form the input name is in, make the hash real generic.
    //

    Size = CNLEN+1;
    if ( DnsHostnameToComputerNameW( TargetName,
                                     NetbiosServerNameBuffer,
                                     &Size ) ) {

        TargetName = NetbiosServerNameBuffer;
    }

    //
    // Convert the server name to a canonical form
    //

    Status = RtlInitUnicodeStringEx( &NetbiosServerNameString, TargetName );
    if ( !NT_SUCCESS(Status) ) {
        return 0;
    }

    UpcasedString.Buffer = StringBuffer;
    UpcasedString.MaximumLength = sizeof(StringBuffer);

    Status = RtlUpcaseUnicodeStringToOemString(
                        &UpcasedString,
                        &NetbiosServerNameString,
                        FALSE );

    if ( !NT_SUCCESS(Status) ) {
        return 0;
    }

    for ( i=0; i<UpcasedString.Length; i++ ) {
        Value += UpcasedString.Buffer[i];
    }

    return (Value & (CRED_TARGET_INFO_HASH_TABLE_SIZE-1));

}


BOOLEAN
CredpCacheTargetInfo(
    IN PCREDENTIAL_SETS CredentialSets,
    IN PCANONICAL_TARGET_INFO TargetInfo
    )

/*++

Routine Description:

    This routine inserts the specified TargetInfo into the target info cache.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSets - A pointer to the referenced credential sets.

    TargetInfo - Specifies the target info to insert.
        If this routine returns TRUE, the caller may no longer reference or free
        the passed in TargetInfo.

Return Values:

    TRUE: TargetInfo was inserted.
    FALSE: TargetInfo was not inserted.

--*/

{
    DWORD Index;
    PLIST_ENTRY ListEntry;
    PCANONICAL_TARGET_INFO ExistingTargetInfo;

    //
    // Require a target name name
    //

    if ( TargetInfo->TargetName.Length == 0 ) {
        return FALSE;
    }

    //
    // Compute the hash index
    //
    Index = CredpHashIndexTargetInfo( TargetInfo->TargetName.Buffer );

    //
    // Loop through the existing entries deleting any conflicting entry
    //

    for ( ListEntry = CredentialSets->SessionCredSets->TargetInfoHashTable[Index].Flink ;
          ListEntry != &CredentialSets->SessionCredSets->TargetInfoHashTable[Index];
          ListEntry = ListEntry->Flink) {

        ExistingTargetInfo = CONTAINING_RECORD( ListEntry, CANONICAL_TARGET_INFO, HashNext );


        //
        // If the target names don't match,
        //   neither do the entries.
        //
        if ( !RtlEqualUnicodeString( &TargetInfo->TargetName,
                                     &ExistingTargetInfo->TargetName,
                                     TRUE ) ) {
            continue;
        }


        //
        // Remove the existing entry
        //

        RemoveEntryList( &ExistingTargetInfo->HashNext );
        RemoveEntryList( &ExistingTargetInfo->LruNext );
        LsapFreeLsaHeap( ExistingTargetInfo );
        CredentialSets->SessionCredSets->TargetInfoCount --;
        break;

    }

    //
    // Link the new entry into the list
    //

    InsertHeadList( &CredentialSets->SessionCredSets->TargetInfoHashTable[Index], &TargetInfo->HashNext );
    InsertHeadList( &CredentialSets->SessionCredSets->TargetInfoLruList, &TargetInfo->LruNext );
    CredentialSets->SessionCredSets->TargetInfoCount ++;

    //
    // If we now have too many cache entries,
    //  ditch the oldest.
    //

    while ( CredentialSets->SessionCredSets->TargetInfoCount > CredTargetInfoMaxCount ) {

        ListEntry = RemoveTailList( &CredentialSets->SessionCredSets->TargetInfoLruList );

        ExistingTargetInfo = CONTAINING_RECORD( ListEntry, CANONICAL_TARGET_INFO, LruNext );

        RemoveEntryList( &ExistingTargetInfo->HashNext );
        LsapFreeLsaHeap( ExistingTargetInfo );
        CredentialSets->SessionCredSets->TargetInfoCount --;
    }

    return TRUE;
}


PCANONICAL_TARGET_INFO
CredpFindTargetInfo(
    IN PCREDENTIAL_SETS CredentialSets,
    IN LPWSTR TargetName
    )

/*++

Routine Description:

    This routine finds a cached TargetInfo for the named server.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSets - A pointer to the referenced credential sets.

    TargetName - Specifies the server name to find the TargetInfo for

Return Values:

    Returns the requested TargetInfo.
    The returned structure can only be referenced while UserCredentialSets->CritSect remains locked.

    NULL - No such target info exists

--*/

{
    NTSTATUS Status;
    DWORD Index;
    PLIST_ENTRY ListEntry;
    PCANONICAL_TARGET_INFO ExistingTargetInfo = NULL;
    UNICODE_STRING TargetNameString;


    //
    // Compute the hash index
    //

    Status = RtlInitUnicodeStringEx( &TargetNameString, TargetName );
    if ( !NT_SUCCESS(Status)) {
        return NULL;
    }
    Index = CredpHashIndexTargetInfo( TargetName );

    //
    // Loop through the entries finding this one.
    //

    for ( ListEntry = CredentialSets->SessionCredSets->TargetInfoHashTable[Index].Flink ;
          ListEntry != &CredentialSets->SessionCredSets->TargetInfoHashTable[Index];
          ListEntry = ListEntry->Flink) {

        ExistingTargetInfo = CONTAINING_RECORD( ListEntry, CANONICAL_TARGET_INFO, HashNext );

        if ( RtlEqualUnicodeString( &TargetNameString,
                                    &ExistingTargetInfo->TargetName,
                                    TRUE ) ) {

            break;
        }

        ExistingTargetInfo = NULL;
    }

    return ExistingTargetInfo;

}

PCREDENTIAL_SET
CredpAllocateCredSet(
    VOID
    )

/*++

Routine Description:

    Allocates and initializes a CREDENTIAL set

Arguments:

    None

Return Values:

    Returns the allocated credential set.
    The caller must dereference this credential set using CredpDereferenceCredSet.

    Return NULL if the memory cannot be allocated.

--*/

{
    PCREDENTIAL_SET TempCredentialSet;

    //
    // Allocate the credential set.
    //

    TempCredentialSet = (PCREDENTIAL_SET) LsapAllocateLsaHeap( sizeof(CREDENTIAL_SET) );

    if ( TempCredentialSet == NULL ) {
        return NULL;
    }

    //
    // Fill it in
    //

    TempCredentialSet->ReferenceCount = 1;
    InitializeListHead( &TempCredentialSet->Credentials );

    TempCredentialSet->Dirty = FALSE;
    TempCredentialSet->BeingWritten = FALSE;
    TempCredentialSet->WriteCount = 0;

    return TempCredentialSet;

}

NTSTATUS
CredpCreateCredSets(
    IN PSID UserSid,
    IN PUNICODE_STRING NetbiosDomainName,
    OUT PCREDENTIAL_SETS CredentialSets
    )

/*++

Routine Description:

    Create the credential sets for a user with the specified SID.

    If a credential set already exists for the specified user, the existing cred set is used.

Arguments:

    UserSid - User sid of the user to create a credential set for.

    NetbiosDomainName - Specifies the netbios domain name of the user to create the
        credential set for.

    CredentialSets - Returns a pointer the various credential sets.
        The caller must dereference this credential set using CredpDereferenceCredSets.

Return Values:

    The following status codes may be returned:

--*/

{
    NTSTATUS Status;
    PLIST_ENTRY ListEntry;
    ULONG i;

    WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD ComputerNameSize = MAX_COMPUTERNAME_LENGTH + 1;
    UNICODE_STRING ComputerNameString;

    //
    // Initialization
    //
    RtlEnterCriticalSection( &CredentialSetListLock );
    RtlZeroMemory( CredentialSets, sizeof(*CredentialSets) );

    //
    // Allocate a session specific credential structure
    //

    CredentialSets->SessionCredSets = (PSESSION_CREDENTIAL_SETS) LsapAllocateLsaHeap( sizeof(SESSION_CREDENTIAL_SETS) );

    if ( CredentialSets->SessionCredSets == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize it
    //

    CredentialSets->SessionCredSets->ReferenceCount = 1;
    for ( i=0; i<CRED_TARGET_INFO_HASH_TABLE_SIZE; i++ ) {
        InitializeListHead( &CredentialSets->SessionCredSets->TargetInfoHashTable[i] );
    }
    CredentialSets->SessionCredSets->TargetInfoCount = 0;
    InitializeListHead( &CredentialSets->SessionCredSets->TargetInfoLruList );
    InitializeListHead( &CredentialSets->SessionCredSets->PromptData );
    CredentialSets->SessionCredSets->ProfileLoaded = FALSE;

    //
    // Allocate a session credential set
    //

    CredentialSets->SessionCredSets->SessionCredSet = CredpAllocateCredSet();

    if ( CredentialSets->SessionCredSets->SessionCredSet == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Loop through the list of loaded user credential sets trying to find this one
    //

    for ( ListEntry = CredentialSetList.Flink ;
          ListEntry != &CredentialSetList;
          ListEntry = ListEntry->Flink) {

        CredentialSets->UserCredentialSets = CONTAINING_RECORD( ListEntry, USER_CREDENTIAL_SETS, Next );

        if ( RtlEqualSid( UserSid,
                          CredentialSets->UserCredentialSets->UserSid ) ) {
            CredentialSets->UserCredentialSets->ReferenceCount ++;
            break;
        }

        CredentialSets->UserCredentialSets = NULL;
    }

    //
    // If we didn't find one,
    //  allocate a new one.
    //

    if ( CredentialSets->UserCredentialSets == NULL ) {
        ULONG UserSidSize;
        LPBYTE Where;
        PUSER_CREDENTIAL_SETS TempUserCredentialSets;


        //
        // Allocate a user credential set
        //

        UserSidSize = RtlLengthSid( UserSid );

        TempUserCredentialSets = (PUSER_CREDENTIAL_SETS) LsapAllocateLsaHeap(
                    sizeof(USER_CREDENTIAL_SETS) + UserSidSize );

        if ( TempUserCredentialSets == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        //
        // Initialize constant fields
        //

        TempUserCredentialSets->ReferenceCount = 1;
        InitializeListHead( &TempUserCredentialSets->Next );
        TempUserCredentialSets->EnterpriseCredSet = NULL;
        TempUserCredentialSets->LocalMachineCredSet = NULL;

        Where = (LPBYTE)(TempUserCredentialSets+1);
        TempUserCredentialSets->UserSid = Where;
        RtlCopyMemory( Where, UserSid, UserSidSize );

        //
        // Initialize the crit sect
        //

        Status = RtlInitializeCriticalSection( &TempUserCredentialSets->CritSect );

        if ( !NT_SUCCESS(Status) ) {
            LsapFreeLsaHeap( TempUserCredentialSets );
            goto Cleanup;
        }

        //
        // We've initialized to the point that common cleanup can work.
        //

        CredentialSets->UserCredentialSets = TempUserCredentialSets;

        //
        // Allocate the credential sets that hang off this structure
        //

        TempUserCredentialSets->EnterpriseCredSet = CredpAllocateCredSet();

        if ( TempUserCredentialSets->EnterpriseCredSet == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        TempUserCredentialSets->LocalMachineCredSet = CredpAllocateCredSet();

        if ( TempUserCredentialSets->LocalMachineCredSet == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        //
        // Insert the credential set into the global list.
        //
        // Being in the global list doesn't constitute a reference.
        //

        InsertHeadList( &CredentialSetList, &TempUserCredentialSets->Next );
    }

    //
    // Determine if the user is logging onto a local account
    //

    if ( !GetComputerName( ComputerName, &ComputerNameSize ) ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlInitUnicodeString( &ComputerNameString, ComputerName );

    if ( RtlEqualUnicodeString( NetbiosDomainName,
                                &ComputerNameString,
                                TRUE ) ) {

        CredentialSets->Flags |= CREDSETS_FLAGS_LOCAL_ACCOUNT;
    }


    Status = STATUS_SUCCESS;


Cleanup:
    if ( !NT_SUCCESS(Status) ) {
        CredpDereferenceCredSets( CredentialSets );
    }
    RtlLeaveCriticalSection( &CredentialSetListLock );

    return Status;

}


NTSTATUS
CredpReferenceCredSets(
    IN PLUID LogonId,
    OUT PCREDENTIAL_SETS CredentialSets
    )

/*++

Routine Description:

    This routine references a credential sets for the specified LogonId.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    CredentialSet - Returns a pointer to the referenced credential set.
        The caller must dereference this credential set using CredpDereferenceCredSets.

Return Values:

    The following status codes may be returned:

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;

    PLSAP_LOGON_SESSION LogonSession = NULL;

    //
    // Get the credential set from the logon session.
    //

    LogonSession = LsapLocateLogonSession( LogonId );

    if ( LogonSession == NULL ) {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    if ( LogonSession->CredentialSets.UserCredentialSets == NULL ) {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Grab a copy of the cred set pointers and reference them
    //

    RtlEnterCriticalSection( &CredentialSetListLock );
    *CredentialSets = LogonSession->CredentialSets;
    CredentialSets->UserCredentialSets->ReferenceCount ++;
    CredentialSets->SessionCredSets->ReferenceCount ++;
    RtlLeaveCriticalSection( &CredentialSetListLock );

    Status = STATUS_SUCCESS;


Cleanup:
    if ( LogonSession != NULL ) {
        LsapReleaseLogonSession( LogonSession );
    }

    return Status;

}

VOID
CredpDereferenceCredSet(
    IN PCREDENTIAL_SET CredentialSet
    )

/*++

Routine Description:

    This routine dereferences a credential set.

Arguments:

    CredentialSet - A pointer to the referenced credential set.

Return Values:

    None

--*/

{

    //
    // Dereference the credential set.
    //
    RtlEnterCriticalSection( &CredentialSetListLock );
    CredentialSet->ReferenceCount --;

    if ( CredentialSet->ReferenceCount == 0 ) {

        //
        // Uninitialize it
        //

        while ( !IsListEmpty( &CredentialSet->Credentials) ) {
            PLIST_ENTRY ListEntry;
            PCANONICAL_CREDENTIAL TempCredential;

            ListEntry = RemoveHeadList( &CredentialSet->Credentials );

            TempCredential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

            LsapFreeLsaHeap( TempCredential );
        }

        //
        // Free the entry.
        //

        LsapFreeLsaHeap( CredentialSet );

    }

    RtlLeaveCriticalSection( &CredentialSetListLock );

    return;
}

VOID
CredpDereferenceUserCredSets(
    IN PUSER_CREDENTIAL_SETS UserCredentialSets
    )

/*++

Routine Description:

    This routine dereferences a user credential set.

Arguments:

    UserCredentialSets - A pointer to the referenced user credential set.

Return Values:

    None

--*/

{

    //
    // Dereference the credential set.
    //
    RtlEnterCriticalSection( &CredentialSetListLock );
    UserCredentialSets->ReferenceCount --;

    if ( UserCredentialSets->ReferenceCount == 0 ) {

        //
        // Remove the entry from the global list.
        //

        RemoveEntryList( &UserCredentialSets->Next );


        //
        // Uninitialize it
        //

        if ( UserCredentialSets->EnterpriseCredSet != NULL ) {
            CredpDereferenceCredSet( UserCredentialSets->EnterpriseCredSet );
        }
        if ( UserCredentialSets->LocalMachineCredSet != NULL ) {
            CredpDereferenceCredSet( UserCredentialSets->LocalMachineCredSet );
        }

        (VOID) RtlDeleteCriticalSection( &UserCredentialSets->CritSect );


        //
        // Free the entry.
        //

        LsapFreeLsaHeap( UserCredentialSets );

    }

    RtlLeaveCriticalSection( &CredentialSetListLock );

    return;
}

VOID
CredpDereferenceSessionCredSets(
    IN PSESSION_CREDENTIAL_SETS SessionCredentialSets
    )

/*++

Routine Description:

    This routine dereferences a session credential set.

Arguments:

    SessionCredentialSets - A pointer to the referenced session credential set.

Return Values:

    None

--*/

{
    PLIST_ENTRY ListEntry;

    //
    // Dereference the credential set.
    //
    RtlEnterCriticalSection( &CredentialSetListLock );
    SessionCredentialSets->ReferenceCount --;

    if ( SessionCredentialSets->ReferenceCount == 0 ) {

        //
        // Uninitialize it
        //

        if ( SessionCredentialSets->SessionCredSet != NULL ) {
            CredpDereferenceCredSet( SessionCredentialSets->SessionCredSet );
        }

        //
        // Free Target Info Cache
        //

        while ( SessionCredentialSets->TargetInfoCount > 0 ) {
            PCANONICAL_TARGET_INFO ExistingTargetInfo;

            ListEntry = RemoveTailList( &SessionCredentialSets->TargetInfoLruList );

            ExistingTargetInfo = CONTAINING_RECORD( ListEntry, CANONICAL_TARGET_INFO, LruNext );

            RemoveEntryList( &ExistingTargetInfo->HashNext );
            LsapFreeLsaHeap( ExistingTargetInfo );
            SessionCredentialSets->TargetInfoCount --;
        }

        //
        // Free the prompt data
        //

        while ( !IsListEmpty( &SessionCredentialSets->PromptData ) ) {
            PPROMPT_DATA PromptData;

            ListEntry = RemoveHeadList( &SessionCredentialSets->PromptData );

            PromptData = CONTAINING_RECORD( ListEntry, PROMPT_DATA, Next );
            LsapFreeLsaHeap( PromptData );
        }


        //
        // Free the entry.
        //

        LsapFreeLsaHeap( SessionCredentialSets );

    }

    RtlLeaveCriticalSection( &CredentialSetListLock );

    return;
}

VOID
CredpDereferenceCredSets(
    IN PCREDENTIAL_SETS CredentialSets
    )

/*++

Routine Description:

    This routine dereferences a set of credential sets.

Arguments:

    CredentialSets - A pointer to the referenced credential sets.

Return Values:

    None

--*/

{
    //
    // Dereference the User wide credential sets
    //

    if ( CredentialSets->UserCredentialSets != NULL ) {
        CredpDereferenceUserCredSets( CredentialSets->UserCredentialSets );
        CredentialSets->UserCredentialSets = NULL;
    }

    //
    // Dereference the session specific credential sets
    //

    if ( CredentialSets->SessionCredSets != NULL ) {
        CredpDereferenceSessionCredSets( CredentialSets->SessionCredSets );
        CredentialSets->SessionCredSets = NULL;
    }

}

BOOLEAN
CredpValidateBuffer(
    IN LPBYTE Buffer OPTIONAL,
    IN ULONG BufferSize,
    IN ULONG MaximumSize,
    IN BOOLEAN NullOk,
    IN ULONG Alignment
    )

/*++

Routine Description:

    This routine validates a passed in Buffer

Arguments:

    Buffer - Buffer to validate

    BufferSize - Size of the buffer in bytes

    MaximumSize - Maximum size of the buffer (in bytes).

    NullOk - if TRUE, a NULL Buffer is OK.

    Alignment - Specifies the alignment requirements of the buffer size.

Return Values:

    TRUE - Buffer is valid.

    FALSE - Buffer is not valid.

--*/

{
    if ( Buffer == NULL ) {
        if ( BufferSize != 0 ) {
            return FALSE;
        }
        if ( !NullOk ) {
            return FALSE;
        }

        return TRUE;
    }

    if ( BufferSize == 0 ) {
        return FALSE;
    }

    if ( BufferSize > MaximumSize ) {
        return FALSE;
    }

    if ( BufferSize != ROUND_UP_COUNT(BufferSize, Alignment) ) {
        return FALSE;
    }

    return TRUE;
}



BOOLEAN
CredpCompareCredToTargetInfo(
    IN PCANONICAL_TARGET_INFO TargetInfo,
    IN PCANONICAL_CREDENTIAL Credential,
    OUT PULONG AliasIndex
    )

/*++

Routine Description:

    This routine determines if the specified credential matches the
    specified target info.

Arguments:

    TargetInfo - A description of the various aliases for a target.

    Credential - Pointer to the credential to match.

    AliasIndex - On success, this parameter returns an index
        indicating which target alias matched the credential.

Return Values:

    TRUE if the credential matches the target info.

--*/

{
    ULONG Index;
    BOOLEAN DnsCompareFailed = FALSE;

    //
    // If the credential isn't a domain credential,
    //  it doesn't match;
    //

    if ( !CredpIsDomainCredential(Credential->Cred.Type) ) {
        return FALSE;
    }

    //
    // Make sure that UserNameTarget credentials only match
    //  UserNameTarget requests (and vice versa)
    //

    if ( Credential->WildcardType == WcUserName ) {
        if ( (TargetInfo->Flags & CRED_TI_USERNAME_TARGET) == 0 ) {
            return FALSE;
        }
    } else {
        if ( (TargetInfo->Flags & CRED_TI_USERNAME_TARGET) != 0 ) {
            return FALSE;
        }
    }

    //
    // If the target info specifies a list of valid cred types,
    //  only return a credential that matches the list.
    //

    if ( TargetInfo->CredTypeCount ) {
        ULONG i;

        for ( i=0; i<TargetInfo->CredTypeCount; i++ ) {

            if ( TargetInfo->CredTypes[i] == Credential->Cred.Type ) {
                break;
            }

        }

        //
        // If the cred doesn't match any of the valid cred types,
        //  ignore it.
        //
        if ( i == TargetInfo->CredTypeCount ) {
            return FALSE;
        }
    }


    //
    // Handle credentials that specify DFS share names
    //

    switch (Credential->WildcardType ) {
    case WcDfsShareName:

        //
        // Determine if the target info is for the named dfs share
        //

        if ( TargetInfo->TargetName.Length != 0 &&
             RtlEqualUnicodeString( &TargetInfo->TargetName,
                                    &Credential->TargetName,
                                    TRUE ) ) {

            *AliasIndex = CRED_DFS_SHARE_NAME;
            return TRUE;

        }

        break;

    //
    // Handle credentials that are for a specific server
    //
    case WcServerName:

        //
        // Compare the DNS server name
        //

        if ( TargetInfo->DnsServerName.Length != 0 ) {

            //
            // Do an exact comparison.
            //
            if ( RtlEqualUnicodeString( &TargetInfo->DnsServerName,
                                        &Credential->TargetName,
                                        TRUE ) ) {

                *AliasIndex = CRED_DNS_SERVER_NAME;
                return TRUE;
            }

            DnsCompareFailed = TRUE;

            //
            // If a netbios alias is specified,
            //  and we don't know the format of the target info name,
            //  compare it.
            //

            if ( Credential->TargetAlias.Length != 0 &&
                 (TargetInfo->Flags & CRED_TI_SERVER_FORMAT_UNKNOWN) != 0 ) {

                if ( RtlEqualUnicodeString( &TargetInfo->DnsServerName,
                                            &Credential->TargetAlias,
                                            TRUE ) ) {

                    *AliasIndex = CRED_NETBIOS_SERVER_NAME;
                    return TRUE;
                }
            }
        }

        //
        // Compare the netbios server name
        //

        if ( TargetInfo->NetbiosServerName.Length != 0 ) {

            //
            // If no alias is specified,
            //  the TargetName might be the netbios name.
            //

            if ( Credential->TargetAlias.Length == 0 ) {

                if ( RtlEqualUnicodeString( &TargetInfo->NetbiosServerName,
                                            &Credential->TargetName,
                                            TRUE ) ) {

                    *AliasIndex = CRED_NETBIOS_SERVER_NAME;
                    return TRUE;
                }

            //
            // If an alias is specified,
            //  it is always the netbios name.
            //
            // (Don't compare the alias if the more specific comparision failed.)
            //

            } else if ( !DnsCompareFailed ) {

                if ( RtlEqualUnicodeString( &TargetInfo->NetbiosServerName,
                                            &Credential->TargetAlias,
                                            TRUE ) ) {

                    *AliasIndex = CRED_NETBIOS_SERVER_NAME;
                    return TRUE;
                }
            }

        }

        //
        // Compare the target name if it is different than the Netbios or DNS name already compared
        //

        if ( TargetInfo->TargetName.Length != 0 &&
             !RtlEqualUnicodeString( &TargetInfo->TargetName,
                                     &TargetInfo->DnsServerName,
                                     TRUE ) &&
             !RtlEqualUnicodeString( &TargetInfo->TargetName,
                                     &TargetInfo->NetbiosServerName,
                                     TRUE ) ) {

            //
            // The TargetName might be the netbios name or DNS name
            //

            if ( RtlEqualUnicodeString( &TargetInfo->TargetName,
                                        &Credential->TargetName,
                                        TRUE ) ) {

                *AliasIndex = CRED_TARGET_NAME;
                return TRUE;
            }

            if ( RtlEqualUnicodeString( &TargetInfo->TargetName,
                                        &Credential->TargetAlias,
                                        TRUE ) ) {

                *AliasIndex = CRED_TARGET_NAME;
                return TRUE;
            }

        }

        break;

    //
    // Handle the server wildcard case
    //
    // If the TargetName is of the form *.xxx.yyy,
    //  compare equal if the DnsServerName ends in .xxx.yyy.
    //
    // The comparision includes the . to ensure *.xxx.yyy doesn't match
    //  fredxxx.yyy
    //

    case WcServerWildcard:

        //
        // Compare the DNS server name
        //

        if ( TargetInfo->DnsServerName.Length != 0 ) {

            UNICODE_STRING LocalTargetName = Credential->NonWildcardedTargetName;
            UNICODE_STRING LocalServerName = TargetInfo->DnsServerName;

            //
            // Build a server name without the leading characters
            //

            if ( LocalTargetName.Length < LocalServerName.Length ) {
                DWORD TrimAmount = LocalServerName.Length - LocalTargetName.Length;

                LocalServerName.Length = LocalTargetName.Length;
                LocalServerName.MaximumLength = LocalTargetName.Length;
                LocalServerName.Buffer += TrimAmount/sizeof(WCHAR);

                //
                // Compare the names
                //

                if ( RtlEqualUnicodeString( &LocalServerName,
                                            &LocalTargetName,
                                            TRUE ) ) {

                    *AliasIndex = CRED_WILDCARD_SERVER_NAME;
                    return TRUE;
                }
            }
        }

        //
        // Compare the Target name field on the target info
        //  The Target name field represents what the user typed.
        //  The DnsServerName represents what was returned from the server itself.
        //  The server may have several DNS records.  By using what the user typed,
        //  we are assured of matching that name also.
        //

        if ( TargetInfo->TargetName.Length != 0 ) {

            UNICODE_STRING LocalTargetName = Credential->NonWildcardedTargetName;
            UNICODE_STRING LocalServerName = TargetInfo->TargetName;

            //
            // Build a server name without the leading characters
            //

            if ( LocalTargetName.Length < LocalServerName.Length ) {
                DWORD TrimAmount = LocalServerName.Length - LocalTargetName.Length;

                LocalServerName.Length = LocalTargetName.Length;
                LocalServerName.MaximumLength = LocalTargetName.Length;
                LocalServerName.Buffer += TrimAmount/sizeof(WCHAR);

                //
                // Compare the names
                //

                if ( RtlEqualUnicodeString( &LocalServerName,
                                            &LocalTargetName,
                                            TRUE ) ) {

                    *AliasIndex = CRED_WILDCARD_SERVER_NAME;
                    return TRUE;
                }
            }
        }

        break;

    //
    // Handle the domain wildcard case.
    //
    // If the target names is of the form <Domain>\*,
    //  compare equal if Netbios or Dns domain name is <Domain>
    //

    case WcDomainWildcard: {
        UNICODE_STRING LocalTargetName;
        UNICODE_STRING LocalTargetAlias;

        //
        // Build a target name without the \*
        //

        LocalTargetName = Credential->NonWildcardedTargetName;

        LocalTargetAlias = Credential->TargetAlias;
        if ( LocalTargetAlias.Length > 2 * sizeof(WCHAR) &&
             LocalTargetAlias.Buffer[(LocalTargetAlias.Length/sizeof(WCHAR))-1] == L'*' &&
             LocalTargetAlias.Buffer[(LocalTargetAlias.Length/sizeof(WCHAR))-2] == L'\\' ) {

            LocalTargetAlias.Length -= 2 * sizeof(WCHAR);
        }


        //
        // Compare the DNS domain name
        //

        if ( TargetInfo->DnsDomainName.Length != 0 ) {


            if ( RtlEqualUnicodeString( &TargetInfo->DnsDomainName,
                                        &LocalTargetName,
                                        TRUE ) ) {

                *AliasIndex = CRED_DNS_DOMAIN_NAME;
                return TRUE;

            }

            DnsCompareFailed = TRUE;

            //
            // If a netbios alias is specified,
            //  and we don't know the format of the target info name,
            //  compare it.
            //

            if ( LocalTargetAlias.Length != 0 &&
                 (TargetInfo->Flags & CRED_TI_DOMAIN_FORMAT_UNKNOWN) != 0 ) {

                if ( RtlEqualUnicodeString( &TargetInfo->DnsDomainName,
                                            &LocalTargetAlias,
                                            TRUE ) ) {

                    *AliasIndex = CRED_NETBIOS_DOMAIN_NAME;
                    return TRUE;
                }
            }

        }

        //
        // Compare the netbios domain name
        //

        if ( TargetInfo->NetbiosDomainName.Length != 0 ) {

            //
            // If no alias is specified,
            //  the TargetName might be the netbios name.
            //

            if ( LocalTargetAlias.Length == 0 ) {

                if ( RtlEqualUnicodeString( &TargetInfo->NetbiosDomainName,
                                            &LocalTargetName,
                                            TRUE ) ) {

                    *AliasIndex = CRED_NETBIOS_DOMAIN_NAME;
                    return TRUE;
                }

            //
            // If an alias is specified,
            //  it is always the netbios name.
            //
            // (Don't compare the alias if the more specific comparision failed.)
            //

            } else if ( !DnsCompareFailed ) {

                if ( RtlEqualUnicodeString( &TargetInfo->NetbiosDomainName,
                                            &LocalTargetAlias,
                                            TRUE ) ) {

                    *AliasIndex = CRED_NETBIOS_DOMAIN_NAME;
                    return TRUE;
                }
            }
        }

        break;
    }

    //
    // Handle the * wildcard case.
    //

    case WcUniversalWildcard:

        *AliasIndex = CRED_UNIVERSAL_NAME;
        return TRUE;

    //
    // Handle the * wildcard case.
    //

    case WcUniversalSessionWildcard:

        *AliasIndex = CRED_UNIVERSAL_SESSION_NAME;
        return TRUE;

    //
    // Handles creds that have a user name as the target name
    //

    case WcUserName:

        //
        // Determine if the target info is for this username
        //

        if ( TargetInfo->TargetName.Length != 0 &&
             RtlEqualUnicodeString( &TargetInfo->TargetName,
                                    &Credential->TargetName,
                                    TRUE ) ) {

            *AliasIndex = CRED_TARGET_NAME;
            return TRUE;

        }

        break;

    //
    // Catch coding errors
    //
    default:
        ASSERT( FALSE );
        break;
    }


    return FALSE;
}


NTSTATUS
CredpLogonCredsMatchTargetInfo(
    IN PLUID LogonId,
    IN PCANONICAL_TARGET_INFO TargetInfo
    )

/*++

Routine Description:

    This routine determines if the specified credential matches the
    specified target info.

Arguments:

    LogonId - LogonId of the session to check

    TargetInfo - A description of the various aliases for a target.

Return Values:

    STATUS_SUCCESS - Logon creds match target info
    STATUS_NO_MATCH - Logon creds don't match target info
    Otherwise, fatal error

--*/

{
    NTSTATUS Status;
    PLSAP_LOGON_SESSION LogonSession = NULL;
    ULONG AliasIndex;
    CANONICAL_CREDENTIAL CanonicalCredential;
    LPWSTR DottedDnsDomainName = NULL;
    PLSAP_DS_NAME_MAP DnsDomainMap = NULL;

    //
    // If the target machine is a member of a workgroup,
    //  never use the *Session cred.

    if ( TargetInfo->Flags & CRED_TI_WORKGROUP_MEMBER ) {
        DebugLog((DEB_TRACE_CRED,
                 "*Session: %wZ: not used on workgroup member.\n",
                 &TargetInfo->TargetName ));
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Get the credential set from the logon session.
    //

    LogonSession = LsapLocateLogonSession( LogonId );

    if ( LogonSession == NULL ) {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Get the DnsDomainName for the logon session.  Do not go
    // off-machine if it's not in the cache.
    //

    Status = LsapGetNameForLogonSession(
                        LogonSession,
                        NameDnsDomain,
                        &DnsDomainMap,
                        TRUE );

    if ( !NT_SUCCESS(Status) ) {
        DnsDomainMap = NULL;
    } else {
        if ( DnsDomainMap->Name.Length == 0 ) {
            LsapDerefDsNameMap( DnsDomainMap );
            DnsDomainMap = NULL;
        }
    }


    //
    // Check if a *.<DnsDomainName> credential matches the target info
    //

    if ( DnsDomainMap != NULL ) {

        //
        // Clear the cred
        //

        RtlZeroMemory( &CanonicalCredential, sizeof(CanonicalCredential) );
        CanonicalCredential.Cred.Type = CRED_TYPE_DOMAIN_PASSWORD;
        CanonicalCredential.WildcardType = WcServerWildcard;

        //
        // Allocate space on the stack
        //

        SafeAllocaAllocate( DottedDnsDomainName,
                            DnsDomainMap->Name.Length + (3*sizeof(WCHAR)) );

        if ( DottedDnsDomainName == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        //
        // Build *.<DnsDomainName>
        //

        RtlCopyMemory( DottedDnsDomainName,
                       L"*.",
                       2*sizeof(WCHAR) );

        RtlCopyMemory( DottedDnsDomainName+2,
                       DnsDomainMap->Name.Buffer,
                       DnsDomainMap->Name.Length );

        DottedDnsDomainName[(DnsDomainMap->Name.Length/sizeof(WCHAR))+2] = L'\0';

        //
        // Fill in the Canonical cred
        //

        RtlInitUnicodeString( &CanonicalCredential.TargetName, DottedDnsDomainName );

        CanonicalCredential.NonWildcardedTargetName.Buffer =
            CanonicalCredential.TargetName.Buffer + 1;
        CanonicalCredential.NonWildcardedTargetName.Length =
            CanonicalCredential.TargetName.Length - sizeof(WCHAR);
        CanonicalCredential.NonWildcardedTargetName.MaximumLength =
            CanonicalCredential.TargetName.MaximumLength - sizeof(WCHAR);


        //
        // See if the cred matches the target info
        //

        if ( CredpCompareCredToTargetInfo(
                    TargetInfo,
                    &CanonicalCredential,
                    &AliasIndex ) ) {

            DebugLog((DEB_TRACE_CRED,
                     "*Session: %wZ: %ws: not used on wildcard server match.\n",
                     &TargetInfo->TargetName,
                     DottedDnsDomainName ));

            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

    }

    //
    // Check if a <DomainName>\* credential matches the target info
    //

    if ( LogonSession->AuthorityName.Length != 0 ) {

        //
        // Clear the cred
        //

        RtlZeroMemory( &CanonicalCredential, sizeof(CanonicalCredential) );
        CanonicalCredential.Cred.Type = CRED_TYPE_DOMAIN_PASSWORD;
        CanonicalCredential.WildcardType = WcDomainWildcard;

        //
        // If there is a DNS domain name too,
        //  build a cred with an alias
        //

        if ( DnsDomainMap != NULL ) {

            //
            // The primary target name is the DNS domain name
            //

            CanonicalCredential.NonWildcardedTargetName = DnsDomainMap->Name;

            //
            // The alias is the netbios domain name
            //

            CanonicalCredential.TargetAlias = LogonSession->AuthorityName;


        //
        // If there is no DNS domain name,
        //  just use the netbios domain name.
        //

        } else {
            CanonicalCredential.NonWildcardedTargetName = LogonSession->AuthorityName;

        }


        //
        // See if the cred matches the target info
        //

        if ( CredpCompareCredToTargetInfo(
                    TargetInfo,
                    &CanonicalCredential,
                    &AliasIndex ) ) {

            DebugLog((DEB_TRACE_CRED,
                     "*Session: %wZ: %wZ: not used on wildcard domain match.\n",
                     &TargetInfo->TargetName,
                     &CanonicalCredential.NonWildcardedTargetName ));

            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

    }


    Status = STATUS_NO_MATCH;


Cleanup:
    if ( DnsDomainMap != NULL ) {
        LsapDerefDsNameMap( DnsDomainMap );
    }

    if ( LogonSession != NULL ) {
        LsapReleaseLogonSession( LogonSession );
    }

    if ( DottedDnsDomainName != NULL ) {
        SafeAllocaFree( DottedDnsDomainName );
    }

    return Status;
}


NTSTATUS
CredpValidateCredential(
    IN ULONG CredFlags,
    IN PCANONICAL_TARGET_INFO TargetInfo OPTIONAL,
    IN PENCRYPTED_CREDENTIALW EncryptedInputCredential,
    OUT PCANONICAL_CREDENTIAL *ValidatedCredential
    )

/*++

Routine Description:

    This routine validates a passed in credential structure.  It returns
    a canonicalized version of the credential.

Arguments:

    CredFlags - Flags changing the behavior of the routine:
        CREDP_FLAGS_IN_PROCESS - Caller is in-process.  Limit to Session Creds.
            But allow to write OWF password and to create cert/password mapping.

        CREDP_FLAGS_CLEAR_PASSWORD - CredentialBlob data is passed in in the clear.
        CREDP_FLAGS_USER_ENCRYPTED_PASSWORD - CredentialBlob data is passed in protected via CredpEncodeCredential.
            If neither set, CredentialBlob data is passed in protected via LsapProtectMemory.

    TargetInfo - Validated Target information that further describes the
        target of the credential.

    EncryptedInputCredential - Specifies the credential to validate.

    ValidatedCredential - Returns a pointer to the canonicalized credential.
        The caller should free this structure by calling LsapFreeLsaHeap.

Return Values:

    The following status codes may be returned:

        STATUS_INVALID_PARMETER - The input credential is not valid.

--*/

{
    NTSTATUS Status;
    DWORD WinStatus;
    PCREDENTIALW InputCredential;
    PCANONICAL_CREDENTIAL ReturnCredential = NULL;
    ULONG TempSize;

    ULONG TargetNameSize;
    ULONG TempTargetNameSize;
    UNICODE_STRING NonWildcardedTargetName;
    ULONG CommentSize;

    ULONG TargetAliasSize;
    LPWSTR TargetAlias;
    LPWSTR AllocatedTargetAlias = NULL;

    ULONG UserNameSize;
    LPWSTR UserName;
    LPWSTR AllocatedUserName = NULL;

    ULONG CredBlobSizeToAlloc;

    ULONG VariableAttributeSize;
    ULONG AllocatedSize;
    WILDCARD_TYPE WildcardType;
    TARGET_NAME_TYPE TargetNameType;

    LPBYTE Where;
    LPBYTE OldWhere;

    ULONG i;

    //
    // Initialization
    //

    RtlInitUnicodeString( &NonWildcardedTargetName, NULL );

    //
    // Validate the pointer itself.
    //

    if ( EncryptedInputCredential == NULL ) {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_TRACE_CRED, "ValidateCredential: credential NULL\n" ));
        goto Cleanup;
    }
    InputCredential = &EncryptedInputCredential->Cred;

    //
    // Validate flags
    //  (Flags may indicate presence of other fields.)
    //

    if ( (InputCredential->Flags & ~CRED_FLAGS_VALID_FLAGS) != 0 ) {
        DebugLog((DEB_TRACE_CRED, "ValidateCredential: %ws: Invalid flags: 0x%lx\n", InputCredential->TargetName, InputCredential->Flags ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    InputCredential->Flags &= ~CRED_FLAGS_PROMPT_NOW;   // Ignore "prompt now" bit on input


    //
    // Only session creds are allow for in process callers
    //

    if ( CredFlags & CREDP_FLAGS_IN_PROCESS ) {

        //
        // An in process caller only passes in the LogonId.
        //  However, non-session credentials are encrypted via DPAPI.
        //  DPAPI requires that we impersonate the caller.
        //

        if ( InputCredential->Persist != CRED_PERSIST_SESSION ) {
            DebugLog((DEB_TRACE_CRED, "ValidateCredential: %ws: In process caller can only specify session creds: 0x%ld\n", InputCredential->TargetName, InputCredential->Persist ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

    //
    // The in-process flags for the cert/password handshake are cleared for an out of process caller
    //

    } else {
        InputCredential->Flags &= ~(CRED_FLAGS_PASSWORD_FOR_CERT|CRED_FLAGS_OWF_CRED_BLOB);
    }


    //
    // Ensure flags are consistent with type.
    //
    if ( InputCredential->Flags & CRED_FLAGS_USERNAME_TARGET ) {

        if ( !CredpIsDomainCredential(InputCredential->Type ) ) {
            DebugLog((DEB_TRACE_CRED, "ValidateCredential: %ws: UsernameTarget flag for non domain credentrial: 0x%ld\n", InputCredential->TargetName, InputCredential->Type ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        TargetNameType = IsUsernameTarget;
    } else {
        TargetNameType = IsNotUsernameTarget;
    }

    //
    // Validate the Target Name
    //

    Status = CredpValidateTargetName( InputCredential->TargetName,
                                      InputCredential->Type,
                                      TargetNameType,
                                      &InputCredential->UserName,
                                      &InputCredential->Persist,
                                      &TargetNameSize,
                                      &WildcardType,
                                      &NonWildcardedTargetName );

    if ( !NT_SUCCESS(Status ) ) {
        goto Cleanup;
    }


    //
    // Validate the contained strings.
    //

    if ( !CredpValidateString( InputCredential->Comment, CRED_MAX_STRING_LENGTH, TRUE, &CommentSize ) ||
         !CredpValidateString( InputCredential->TargetAlias, CRED_MAX_STRING_LENGTH, TRUE, &TargetAliasSize ) ||
         !CredpValidateString( InputCredential->UserName, CRED_MAX_USERNAME_LENGTH, TRUE, &UserNameSize ) ) {

        DebugLog(( DEB_TRACE_CRED,
                   "ValidateCredential: %ws: Invalid Comment or TargetAlias or UserName\n",
                   InputCredential->TargetName ));

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    TargetAlias = InputCredential->TargetAlias;
    UserName = InputCredential->UserName;

    //
    // Validate the credential blob.
    //  The passed in blob size must be the clear text size or the encrypted text size.
    //

    CredBlobSizeToAlloc = AllocatedCredBlobSize( EncryptedInputCredential->ClearCredentialBlobSize );

    if ( CredFlags & CREDP_FLAGS_CLEAR_PASSWORD ) {
        if ( InputCredential->CredentialBlobSize != EncryptedInputCredential->ClearCredentialBlobSize ) {
            DebugLog((DEB_TRACE_CRED, "ValidateCredential: %ws: Bad clear cred blob size %ld %ld\n",
                                      InputCredential->TargetName,
                                      InputCredential->CredentialBlobSize,
                                      EncryptedInputCredential->ClearCredentialBlobSize ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    } else {
        if ( InputCredential->CredentialBlobSize != CredBlobSizeToAlloc ) {
            DebugLog((DEB_TRACE_CRED, "ValidateCredential: %ws: Bad encrypted cred blob size %ld %ld\n",
                                      InputCredential->TargetName,
                                      InputCredential->CredentialBlobSize,
                                      CredBlobSizeToAlloc ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }


    if ( !CredpValidateBuffer( InputCredential->CredentialBlob,
                               EncryptedInputCredential->ClearCredentialBlobSize,
                               CRED_MAX_CREDENTIAL_BLOB_SIZE,
                               TRUE,
                               InputCredential->Type == CRED_TYPE_GENERIC ?
                                    ALIGN_BYTE :
                                    ALIGN_WCHAR ) ) {

        DebugLog((DEB_TRACE_CRED, "ValidateCredential: %ws: Invalid credential blob\n", InputCredential->TargetName ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the attribute list.
    //  Ensure RPC passed us sane information.
    //

    if ( InputCredential->AttributeCount != 0 &&
         InputCredential->Attributes == NULL ) {
        DebugLog((DEB_TRACE_CRED, "ValidateCredential: %ws: Invalid attribute buffer\n", InputCredential->TargetName ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Ensure there aren't too many attributes
    //

    if ( InputCredential->AttributeCount > CRED_MAX_ATTRIBUTES ) {
        DebugLog((DEB_TRACE_CRED, "ValidateCredential: %ws: Too many attributes %ld\n", InputCredential->TargetName, InputCredential->AttributeCount ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate each attribute.
    //

    VariableAttributeSize = 0;
    for ( i=0; i<InputCredential->AttributeCount; i++ ) {
        if ( !CredpValidateString( InputCredential->Attributes[i].Keyword,
                                  CRED_MAX_STRING_LENGTH,
                                  FALSE,
                                  &TempSize ) ) {
            DebugLog((DEB_TRACE_CRED, "ValidateCredential: %ws: Invalid attribute keyword buffer: %ld\n", InputCredential->TargetName, i ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        VariableAttributeSize += TempSize;

        if ( !CredpValidateBuffer( InputCredential->Attributes[i].Value,
                                   InputCredential->Attributes[i].ValueSize,
                                   CRED_MAX_VALUE_SIZE,
                                   TRUE,
                                   ALIGN_BYTE ) ) {
            DebugLog(( DEB_TRACE_CRED,
                       "ValidateCredential: %ws: %ws: Invalid attribute value buffer: %ld\n",
                       InputCredential->TargetName,
                       InputCredential->Attributes[i].Keyword,
                       i ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        VariableAttributeSize += InputCredential->Attributes[i].ValueSize;
    }

    //
    // Validate the credential type
    //
    // Handle generic credentials
    //

    if ( InputCredential->Type == CRED_TYPE_GENERIC ) {
        /* Drop through */


    //
    // Handle domain credentials
    //
    } else if ( CredpIsDomainCredential(InputCredential->Type) ) {


        //
        // If the password should come from the cert,
        //  so should the username
        //

        if ( InputCredential->Flags & CRED_FLAGS_PASSWORD_FOR_CERT ) {

            if ( UserNameSize != 0 ) {
                Status = STATUS_INVALID_ACCOUNT_NAME;
                goto Cleanup;
            }

        //
        //
        // Domain credentials have a specific Username format
        //

        } else {
            Status = CredpValidateUserName( UserName, InputCredential->Type, &AllocatedUserName );

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }

            // Recompute since CredpValidateUserName canonicalized the name
            UserName = AllocatedUserName;
            UserNameSize = (wcslen( AllocatedUserName ) + 1) * sizeof(WCHAR);
        }



        //
        // Handle where the target alias is specified,
        //

        if ( TargetAlias != NULL ) {

            LPWSTR RealTargetAlias; // TargetAlias sans wildcard chars
            ULONG RealTargetAliasLength;

            RealTargetAlias = TargetAlias;
            RealTargetAliasLength = (TargetAliasSize-sizeof(WCHAR))/sizeof(WCHAR);

            //
            // Process alias as a function of Wildcard Type
            //

            switch ( WildcardType ) {
            case WcServerName:
                /* Nothing to do here */
                break;
            case WcDfsShareName:
            case WcServerWildcard:
            case WcUniversalWildcard:
            case WcUniversalSessionWildcard:
            case WcUserName:
                //
                // Server credentials of the form *.xxx.yyy aren't allowed with TargetAliases
                // Otherwise a wildcarded DNS name would have a non-wildcarded netbios name.

                Status = STATUS_INVALID_PARAMETER;
                DebugLog(( DEB_TRACE_CRED,
                           "ValidateCredential: %ws: TargetAlias not allowed for server wildcard credential.\n",
                           InputCredential->TargetName ));
                goto Cleanup;

            case WcDomainWildcard:
                //
                // If the TargetName is a domain wildcard, so must the TargetAlias
                //

                if ( RealTargetAliasLength > 2 &&
                     RealTargetAlias[RealTargetAliasLength-1] == L'*' &&
                     RealTargetAlias[RealTargetAliasLength-2] == L'\\' ) {

                    //
                    // Allocate a buffer for the target alias so we don't have to modify the
                    //  callers buffer.
                    //

                    SafeAllocaAllocate( AllocatedTargetAlias, TargetAliasSize );

                    if ( AllocatedTargetAlias == NULL ) {
                        Status = STATUS_NO_MEMORY;
                        goto Cleanup;
                    }

                    RtlCopyMemory( AllocatedTargetAlias, RealTargetAlias, TargetAliasSize );
                    RealTargetAlias = AllocatedTargetAlias;
                    RealTargetAliasLength -= 2;
                    RealTargetAlias[RealTargetAliasLength] = '\0';
                } else {

                    Status = STATUS_INVALID_PARAMETER;
                    DebugLog(( DEB_TRACE_CRED,
                               "ValidateCredential: %ws: %ws: TargetAlias must be wildcard if TargetName is.\n",
                               InputCredential->TargetName,
                               TargetAlias ));
                    goto Cleanup;
                }



                break;
            }

            //
            //  The target alias must be a netbios name.
            //
            if ( !NetpIsDomainNameValid( RealTargetAlias ) ) {
                DebugLog(( DEB_TRACE_CRED,
                           "ValidateCredential: %ws: TargetAlias '%ws' must be a netbios name.\n",
                           InputCredential->TargetName,
                           TargetAlias ));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            //
            // The target name must be a DNS name
            //
            if ( !CredpValidateDnsString( NonWildcardedTargetName.Buffer,
                                          FALSE,
                                          DnsNameDomain,
                                          &TempTargetNameSize ) ) {
                Status = STATUS_INVALID_PARAMETER;
                DebugLog(( DEB_TRACE_CRED,
                           "ValidateCredential: %ws: TargetName for domain or server must be a DNS name if target alias specified.\n",
                           InputCredential->TargetName ));
                goto Cleanup;
            }


        }

    } else {
        DebugLog(( DEB_TRACE_CRED,
                   "ValidateCredential: %ws: Type %ld not valid\n",
                   InputCredential->TargetName,
                   InputCredential->Type ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the persistence.
    //

    switch ( InputCredential->Persist ) {
    case CRED_PERSIST_SESSION:
    case CRED_PERSIST_LOCAL_MACHINE:
    case CRED_PERSIST_ENTERPRISE:
        break;
    default:
        DebugLog(( DEB_TRACE_CRED,
                   "ValidateCredential: %ws: Invalid persistance: %ld.\n",
                   InputCredential->TargetName,
                   InputCredential->Persist ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Allocate a buffer for the canonicalized credential.
    //

    AllocatedSize = (ULONG)(ROUND_UP_COUNT( sizeof(CANONICAL_CREDENTIAL), ALIGN_WORST) +
                    TargetNameSize +
                    (NonWildcardedTargetName.Buffer == NULL ?
                        0 :
                        NonWildcardedTargetName.MaximumLength ) +
                    CommentSize +
                    ROUND_UP_COUNT( CredBlobSizeToAlloc, ALIGN_WORST) +
                    InputCredential->AttributeCount * sizeof(CREDENTIAL_ATTRIBUTE) +
                    VariableAttributeSize +
                    TargetAliasSize +
                    UserNameSize);

    ReturnCredential = (PCANONICAL_CREDENTIAL) LsapAllocateLsaHeap( AllocatedSize );


    if ( ReturnCredential == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    OldWhere = (PUCHAR)(ReturnCredential+1);
    Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, ALIGN_WORST );
    RtlZeroMemory( OldWhere, Where-OldWhere );

    ReturnCredential->AllocatedSize = AllocatedSize;
    ReturnCredential->WildcardType = WildcardType;

    //
    // Copy the fixed size data
    //

    ReturnCredential->Cred.Flags = InputCredential->Flags;
    ReturnCredential->Cred.Type = InputCredential->Type;
    ReturnCredential->Cred.Persist = InputCredential->Persist;
    ReturnCredential->Cred.LastWritten = InputCredential->LastWritten;

    RtlZeroMemory( &ReturnCredential->Next, sizeof(ReturnCredential->Next) );

    //
    // Copy the 8-byte aligned data.
    //  (We don't know the format of the credential blob, but our in-process callers
    //  may have alignment requirements.)
    //

    if ( EncryptedInputCredential->ClearCredentialBlobSize != 0 ) {

        //
        // Put the credential blob in the buffer.
        //
        ReturnCredential->Cred.CredentialBlob = Where;
        ReturnCredential->Cred.CredentialBlobSize = InputCredential->CredentialBlobSize;
        ReturnCredential->ClearCredentialBlobSize = EncryptedInputCredential->ClearCredentialBlobSize;
        RtlCopyMemory( Where, InputCredential->CredentialBlob, InputCredential->CredentialBlobSize );
        Where += InputCredential->CredentialBlobSize;


        //
        // Align the running pointer again
        //
        OldWhere = Where;
        // Always leave an extra trailing byte for encrypting the buffer in place
        Where += CredBlobSizeToAlloc - InputCredential->CredentialBlobSize;
        Where = (PUCHAR) ROUND_UP_POINTER( Where, ALIGN_WORST );
        RtlZeroMemory( OldWhere, Where-OldWhere );

        //
        // If the blob isn't encrypted correctly for the cache,
        //  convert it.
        //

        if ( (CredFlags & (CREDP_FLAGS_CLEAR_PASSWORD|CREDP_FLAGS_USER_ENCRYPTED_PASSWORD)) != 0 ) {

            //
            // Only decode data if it is there
            //

            if ( ReturnCredential->Cred.CredentialBlobSize != 0 ) {
                ULONG PaddingSize;


                //
                // If the password was encrypted by the user,
                //  convert it to the clear.
                //
                if ( CredFlags & CREDP_FLAGS_USER_ENCRYPTED_PASSWORD ) {

                    // Ensure we can cast between the types
                    ASSERT( offsetof( _ENCRYPTED_CREDENTIALW, Cred) == offsetof( _CANONICAL_CREDENTIAL, Cred));
                    ASSERT( offsetof( _ENCRYPTED_CREDENTIALW, ClearCredentialBlobSize) == offsetof( _CANONICAL_CREDENTIAL, ClearCredentialBlobSize));

                    if ( !CredpDecodeCredential( (PENCRYPTED_CREDENTIALW)ReturnCredential ) ) {
                        DebugLog(( DEB_TRACE_CRED,
                                   "ValidateCredential: %ws: Cannot decode cred blob\n",
                                   InputCredential->TargetName ));
                        Status = STATUS_INVALID_PARAMETER;
                        goto Cleanup;
                    }

                }

                //
                // Obfuscate the sensitive data
                //  A large enough space was already pushed above.
                //

                ReturnCredential->Cred.CredentialBlobSize = CredBlobSizeToAlloc;

                // Clear the padding at the end to ensure we can compare encrypted blobs
                PaddingSize = CredBlobSizeToAlloc -
                              ReturnCredential->ClearCredentialBlobSize;

                if ( PaddingSize != 0 ) {
                    RtlZeroMemory( &ReturnCredential->Cred.CredentialBlob[ReturnCredential->ClearCredentialBlobSize],
                                   PaddingSize );
                }

                LsaProtectMemory( ReturnCredential->Cred.CredentialBlob,
                                  ReturnCredential->Cred.CredentialBlobSize );
            }
        }

    }


    //
    // Copy the ALIGN_WORST aligned data
    //

    ReturnCredential->Cred.AttributeCount = InputCredential->AttributeCount;
    if ( InputCredential->AttributeCount != 0 ) {
        ReturnCredential->Cred.Attributes = (PCREDENTIAL_ATTRIBUTEW) Where;
        Where += ReturnCredential->Cred.AttributeCount * sizeof(CREDENTIAL_ATTRIBUTE);
    } else {
        ReturnCredential->Cred.Attributes = NULL;
    }


    //
    // Copy the 2 byte aligned data
    //

    ReturnCredential->Cred.TargetName = (LPWSTR) Where;
    RtlCopyMemory( Where, InputCredential->TargetName, TargetNameSize );
    Where += TargetNameSize;
    ReturnCredential->TargetName.Buffer = ReturnCredential->Cred.TargetName;
    ReturnCredential->TargetName.MaximumLength = (USHORT)TargetNameSize;
    ReturnCredential->TargetName.Length = ReturnCredential->TargetName.MaximumLength - sizeof(WCHAR);

    if ( NonWildcardedTargetName.Buffer != NULL ) {
        ReturnCredential->NonWildcardedTargetName.Buffer = (LPWSTR)Where;

        RtlCopyMemory( Where, NonWildcardedTargetName.Buffer, NonWildcardedTargetName.MaximumLength );
        Where += NonWildcardedTargetName.MaximumLength;

        ReturnCredential->NonWildcardedTargetName.MaximumLength = NonWildcardedTargetName.MaximumLength;
        ReturnCredential->NonWildcardedTargetName.Length = NonWildcardedTargetName.Length;
    } else {
        ReturnCredential->NonWildcardedTargetName = ReturnCredential->TargetName;
    }

    if ( CommentSize != 0 ) {
        ReturnCredential->Cred.Comment = (LPWSTR) Where;
        RtlCopyMemory( Where, InputCredential->Comment, CommentSize );
        Where += CommentSize;
    } else {
        ReturnCredential->Cred.Comment = NULL;
    }

    if ( TargetAliasSize != 0 ) {
        ReturnCredential->Cred.TargetAlias = (LPWSTR) Where;
        RtlCopyMemory( Where, TargetAlias, TargetAliasSize );
        Where += TargetAliasSize;

        ReturnCredential->TargetAlias.Buffer = ReturnCredential->Cred.TargetAlias;
        ReturnCredential->TargetAlias.MaximumLength = (USHORT)TargetAliasSize;
        ReturnCredential->TargetAlias.Length = ReturnCredential->TargetAlias.MaximumLength - sizeof(WCHAR);
    } else {
        ReturnCredential->Cred.TargetAlias = NULL;
        RtlInitUnicodeString( &ReturnCredential->TargetAlias, NULL );
    }

    if ( UserNameSize != 0 ) {
        ReturnCredential->Cred.UserName = (LPWSTR) Where;
        RtlCopyMemory( Where, UserName, UserNameSize );
        Where += UserNameSize;
        ReturnCredential->UserName.Buffer = ReturnCredential->Cred.UserName;
        ReturnCredential->UserName.MaximumLength = (USHORT)UserNameSize;
        ReturnCredential->UserName.Length = ReturnCredential->UserName.MaximumLength - sizeof(WCHAR);
    } else {
        ReturnCredential->Cred.UserName = NULL;
        RtlInitUnicodeString( &ReturnCredential->UserName, NULL );
    }

    for ( i=0; i<InputCredential->AttributeCount; i++ ) {
        TempSize = (wcslen( InputCredential->Attributes[i].Keyword ) + 1) * sizeof(WCHAR);
        ReturnCredential->Cred.Attributes[i].Keyword = (LPWSTR) Where;
        RtlCopyMemory( Where, InputCredential->Attributes[i].Keyword, TempSize );
        Where += TempSize;

        ReturnCredential->Cred.Attributes[i].Flags = InputCredential->Attributes[i].Flags;
    }


    //
    // Copy the 1 byte aligned data
    //

    for ( i=0; i<InputCredential->AttributeCount; i++ ) {

        if ( InputCredential->Attributes[i].ValueSize != 0 ) {
            ReturnCredential->Cred.Attributes[i].ValueSize =
                InputCredential->Attributes[i].ValueSize;
            ReturnCredential->Cred.Attributes[i].Value = Where;
            RtlCopyMemory( Where,
                           InputCredential->Attributes[i].Value,
                           InputCredential->Attributes[i].ValueSize );
            Where += InputCredential->Attributes[i].ValueSize;
        } else {
            ReturnCredential->Cred.Attributes[i].ValueSize = 0;
            ReturnCredential->Cred.Attributes[i].Value = NULL;
        }

        ReturnCredential->Cred.Attributes[i].Flags = InputCredential->Attributes[i].Flags;
    }


    //
    // If we have target information,
    //  use it to do an extra validation.
    //

    if ( TargetInfo != NULL ) {
        ULONG AliasIndex;

        if (!CredpCompareCredToTargetInfo( TargetInfo, ReturnCredential, &AliasIndex ) ) {
            Status = STATUS_INVALID_PARAMETER;
            DebugLog(( DEB_TRACE_CRED,
                       "ValidateCredential: %ws: TargetInfo doesn't match credential.\n",
                       InputCredential->TargetName ));
            goto Cleanup;
        }
    }



    //
    // Return the credential to the caller.
    //
    *ValidatedCredential = ReturnCredential;
    ReturnCredential = NULL;
    Status = STATUS_SUCCESS;

Cleanup:
    if ( ReturnCredential != NULL ) {
        LsapFreeLsaHeap( ReturnCredential );
    }
    if ( NonWildcardedTargetName.Buffer != NULL ) {
        LsapFreeLsaHeap( NonWildcardedTargetName.Buffer );
    }
    if ( AllocatedTargetAlias != NULL ) {
        SafeAllocaFree( AllocatedTargetAlias );
    }
    if ( AllocatedUserName != NULL ) {
        MIDL_user_free( AllocatedUserName );
    }

    return Status;

}

BOOLEAN
CredpValidateNames(
    IN OUT PCREDENTIAL_TARGET_INFORMATION InputTargetInfo,
    IN BOOLEAN DoServer,
    OUT PULONG NetbiosNameSize,
    OUT PULONG DnsNameSize
    )

/*++

Routine Description:

    This routine validates the server names (or domain names) in a target info structure.
    It handles the CRED_TI_*_FORMAT_UNKNOWN bit.  If specified, the routine ensures only the
    "dns" field of the name is specified.  Also, the specified name is syntax checked.
    If the specified name only matches one of the name formats, the "FORMAT_UNKNOWN" bit is
    turned off and the appropriate name is set in InputTargetInfo

Arguments:

    InputTargetInfo - Specifies the target info to validate.
        On return, the Flags and name fields my be updated to reflect the true name formats.

    DoServer - If TRUE the server names are validated.
        If FALSE, the domain names are validated.

    NetbiosNameSize - Returns the size in bytes of the netbios name

    DnsNameSize - Returns the size in bytes of the DNS name

Return Values:

    FALSE - if the names are invalid.

--*/
{
    DWORD FlagBit;
    LPWSTR *NetbiosNamePtr;
    LPWSTR *DnsNamePtr;
    DNS_NAME_FORMAT DnsNameFormat;

    //
    // Set up some locals identifying whether we're doing the server or domain.
    //

    if ( DoServer ) {
        FlagBit = CRED_TI_SERVER_FORMAT_UNKNOWN;
        NetbiosNamePtr = &InputTargetInfo->NetbiosServerName;
        DnsNamePtr = &InputTargetInfo->DnsServerName;
        DnsNameFormat = DnsNameHostnameFull;
    } else {
        FlagBit = CRED_TI_DOMAIN_FORMAT_UNKNOWN;
        NetbiosNamePtr = &InputTargetInfo->NetbiosDomainName;
        DnsNamePtr = &InputTargetInfo->DnsDomainName;
        DnsNameFormat = DnsNameDomain;
    }


    //
    // If the format unknown bit is set,
    //  try to determine the formation.
    //

    if ( InputTargetInfo->Flags & FlagBit ) {

        BOOLEAN IsNetbios;
        BOOLEAN IsDns;
        ULONG LocalNetbiosNameSize;
        ULONG LocalDnsNameSize;

        //
        // Caller must pass the unknown name as the DNS name
        //

        if ( *NetbiosNamePtr != NULL) {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpValidateNames: Netbios name must be null.\n" ));
            return FALSE;
        }

        //
        // Determine the syntax of the passed in name.
        //

        IsNetbios = CredpValidateString( *DnsNamePtr, CNLEN, FALSE, &LocalNetbiosNameSize );
        IsDns = CredpValidateDnsString( *DnsNamePtr, FALSE, DnsNameFormat, &LocalDnsNameSize );

        //
        // If the name simply isn't valid,
        //  we're done.
        //

        if ( !IsNetbios && !IsDns ) {

            DebugLog(( DEB_TRACE_CRED,
                       "CredpValidateNames: Invalid DNS Buffer: %ws (may not be fatal).\n",
                       *DnsNamePtr ));
            return FALSE;

        //
        // If the name is only a valid DNS name
        //  use it as such
        //

        } else if ( !IsNetbios && IsDns ) {

            // Turn off the bit since the name is not ambiguous.
            InputTargetInfo->Flags &= ~FlagBit;

            *NetbiosNameSize = 0;
            *DnsNameSize = LocalDnsNameSize;

        //
        // If the name is only a valid netbios name
        //  use it as such
        //

        } else if ( IsNetbios && !IsDns ) {

            // Turn off the bit since the name is not ambiguous.
            InputTargetInfo->Flags &= ~FlagBit;

            *NetbiosNameSize = LocalNetbiosNameSize;
            *NetbiosNamePtr = *DnsNamePtr;

            *DnsNamePtr = NULL;
            *DnsNameSize = 0;


        //
        // If the name is valid for both formats,
        //  leave it ambiguous
        //

        } else {

            *NetbiosNameSize = 0;
            *DnsNameSize = LocalDnsNameSize;
        }






    } else {
        if ( !CredpValidateString( *NetbiosNamePtr, CNLEN, TRUE, NetbiosNameSize ) ||
             !CredpValidateDnsString( *DnsNamePtr, TRUE, DnsNameFormat, DnsNameSize ) ) {

            DebugLog(( DEB_TRACE_CRED,
                       "CredpValidateNames: Invalid Buffer.\n" ));
            return FALSE;
        }
    }

    return TRUE;
}

NTSTATUS
CredpValidateTargetInfo(
    IN PCREDENTIAL_TARGET_INFORMATION InputTargetInfo,
    OUT PCANONICAL_TARGET_INFO *ValidatedTargetInfo
    )

/*++

Routine Description:

    This routine validates a passed in target info structure.  It returns
    a canonicalized version of the target info.

    All DNS names have the trailing . stripped.

Arguments:

    InputTargetInfo - Specifies the target info to validate.

    ValidatedTargetInfo - Returns a pointer to the canonicalized target info.
        The caller should free this structure by calling LsapFreeLsaHeap.

Return Values:

    The following status codes may be returned:

        STATUS_INVALID_PARMETER - The input target info is not valid.

--*/

{
    NTSTATUS Status;
    PCANONICAL_TARGET_INFO ReturnTargetInfo = NULL;
    ULONG TempSize;

    // Local copy of InputTargetInfo that this routine can modify.
    CREDENTIAL_TARGET_INFORMATION LocalTargetInfo;

    ULONG TargetNameSize;

    ULONG NetbiosServerNameSize;
    WCHAR NetbiosServerName[CNLEN+1];

    ULONG DnsServerNameSize;
    ULONG NetbiosDomainNameSize;
    ULONG DnsDomainNameSize;
    ULONG DnsTreeNameSize;
    ULONG PackageNameSize;
    ULONG CredTypeSize;
    ULONG AllocatedSize;

    BOOLEAN FictitiousServerName = FALSE;


    LPBYTE Where;
    LPBYTE OldWhere;

    ULONG i;

    //
    // Validate the pointer itself.
    //

    if ( InputTargetInfo == NULL ) {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog(( DEB_TRACE_CRED,
                   "ValidateTargetInfo: TargetInfo NULL.\n" ));
        goto Cleanup;
    }

    //
    // Validate Flags
    //

    LocalTargetInfo = *InputTargetInfo;
    if ( (LocalTargetInfo.Flags & ~CRED_TI_VALID_FLAGS) != 0 ) {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog(( DEB_TRACE_CRED,
                   "ValidateTargetInfo: Invalid flags 0x%lx.\n",
                   LocalTargetInfo.Flags ));
        goto Cleanup;

    }

    //
    // All share level machines are workgroup members
    //

    if ( LocalTargetInfo.Flags & CRED_TI_ONLY_PASSWORD_REQUIRED ) {
        LocalTargetInfo.Flags |= CRED_TI_WORKGROUP_MEMBER;
    }


    //
    // Validate the contained strings.
    //

    if ( !CredpValidateString( LocalTargetInfo.TargetName, CRED_MAX_DOMAIN_TARGET_NAME_LENGTH, TRUE, &TargetNameSize ) ||
         !CredpValidateDnsString( LocalTargetInfo.DnsTreeName, TRUE, DnsNameDomain, &DnsTreeNameSize ) ||
         !CredpValidateString( LocalTargetInfo.PackageName, CRED_MAX_STRING_LENGTH, TRUE, &PackageNameSize ) ) {

        Status = STATUS_INVALID_PARAMETER;
        DebugLog(( DEB_TRACE_CRED,
                   "ValidateTargetInfo: Invalid Buffer.\n" ));
        goto Cleanup;
    }

    //
    // Supply a server name if none is present.
    //
    // pre-NTLM-V2 servers don't supply a server name in the negotiate response.  NTLM supplies
    // the TargetName from the SPN.  In that case, the TargetName makes a better server name than
    // none at all.
    //

    if ( (LocalTargetInfo.NetbiosServerName == NULL || *(LocalTargetInfo.NetbiosServerName) == L'\0') &&
         (LocalTargetInfo.DnsServerName == NULL || *(LocalTargetInfo.DnsServerName) == L'\0') &&
         TargetNameSize != 0 ) {

        LocalTargetInfo.DnsServerName = LocalTargetInfo.TargetName;
        LocalTargetInfo.Flags |= CRED_TI_SERVER_FORMAT_UNKNOWN;
        FictitiousServerName = TRUE;

    }

    //
    // Validate the server and domain names.
    //

    if ( !CredpValidateNames( &LocalTargetInfo, TRUE, &NetbiosServerNameSize, &DnsServerNameSize ) ) {

        //
        // Don't bail out if we made up the server name
        //

        if ( FictitiousServerName ) {
            LocalTargetInfo.DnsServerName = NULL;
            LocalTargetInfo.Flags &= ~CRED_TI_SERVER_FORMAT_UNKNOWN;
            FictitiousServerName = FALSE;
            NetbiosServerNameSize = 0;
            DnsServerNameSize = 0;

        } else {
            Status = STATUS_INVALID_PARAMETER;
            DebugLog(( DEB_TRACE_CRED,
                       "ValidateTargetInfo: Invalid server buffer.\n" ));
            goto Cleanup;
        }
    }
    if ( !CredpValidateNames( &LocalTargetInfo, FALSE, &NetbiosDomainNameSize, &DnsDomainNameSize ) ) {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog(( DEB_TRACE_CRED,
                   "ValidateTargetInfo: Invalid domain buffer.\n" ));
        goto Cleanup;
    }

    //
    // Validate the attribute list.
    //  Ensure RPC passed us sane information.
    //

    if ( LocalTargetInfo.CredTypeCount != 0 &&
         LocalTargetInfo.CredTypes == NULL ) {
        DebugLog((DEB_TRACE_CRED, "ValidateTargetInfo: Invalid cred type buffer.\n" ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the cred types
    //

    for ( i=0; i<LocalTargetInfo.CredTypeCount; i ++ ) {
        switch ( LocalTargetInfo.CredTypes[i] ) {
        case CRED_TYPE_GENERIC:
        case CRED_TYPE_DOMAIN_PASSWORD:
        case CRED_TYPE_DOMAIN_CERTIFICATE:
        case CRED_TYPE_DOMAIN_VISIBLE_PASSWORD:
            break;
        default:
            DebugLog((DEB_TRACE_CRED, "ValidateTargetInfo: Invalid cred type %ld %ld.\n", i, LocalTargetInfo.CredTypes[i] ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }
    CredTypeSize = LocalTargetInfo.CredTypeCount * sizeof(DWORD);

    //
    // Supply a netbios server name if none is present and DNS server name is known.
    //

    if ( NetbiosServerNameSize == 0 &&
         DnsServerNameSize != 0 &&
         (LocalTargetInfo.Flags & CRED_TI_SERVER_FORMAT_UNKNOWN) == 0 ) {

        DWORD Size = CNLEN+1;

        if ( !DnsHostnameToComputerNameW( LocalTargetInfo.DnsServerName,
                                          NetbiosServerName,
                                          &Size ) ) {
            DebugLog(( DEB_TRACE_CRED,
                       "ValidateTargetInfo: Cannot DnsHostNameToComputerName: %ld.\n",
                       GetLastError() ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        LocalTargetInfo.NetbiosServerName = NetbiosServerName;
        NetbiosServerNameSize = (Size + 1) * sizeof(WCHAR);
    }


    //
    // Supply a target name if none is present.
    //
    // NTLM authentication to Unix servers return target info.  However, the callers of SSPI
    // don't supply an SPN.  NTLM builds the TargetName from the SPN.
    //

    if ( TargetNameSize == 0 ) {

        //
        // If there's a DNS server name,
        //  use it.
        //

        if ( DnsServerNameSize != 0 ) {
            LocalTargetInfo.TargetName = LocalTargetInfo.DnsServerName;
            TargetNameSize = DnsServerNameSize;

        //
        // If there's a netbios server name,
        //  use it.

        } else if ( NetbiosServerNameSize != 0 ) {
            LocalTargetInfo.TargetName = LocalTargetInfo.NetbiosServerName;
            TargetNameSize = NetbiosServerNameSize;

        //
        // If there's a DNS Domain name,
        //  use it.
        //

        } else if ( DnsDomainNameSize != 0 ) {
            LocalTargetInfo.TargetName = LocalTargetInfo.DnsDomainName;
            TargetNameSize = DnsDomainNameSize;

        //
        // If there's a netbios Domain name,
        //  use it.

        } else if ( NetbiosDomainNameSize != 0 ) {
            LocalTargetInfo.TargetName = LocalTargetInfo.NetbiosDomainName;
            TargetNameSize = NetbiosDomainNameSize;

        //
        // If there's a DNS tree name,
        //  use it.
        //

        } else if ( DnsTreeNameSize != 0 ) {
            LocalTargetInfo.TargetName = LocalTargetInfo.DnsTreeName;
            TargetNameSize = DnsTreeNameSize;
        }

    }

    //
    // Canonicalize the target info.
    //
    // There are several cases where authentication packages are sent invalid target info.
    // This section clears up those cases.
    //

    if ( NetbiosServerNameSize != 0 ) {
        UNICODE_STRING NetbiosServerNameString;

        NetbiosServerNameString.Buffer = LocalTargetInfo.NetbiosServerName;
        NetbiosServerNameString.MaximumLength = (USHORT) NetbiosServerNameSize;
        NetbiosServerNameString.Length = NetbiosServerNameString.MaximumLength - sizeof(WCHAR);

        //
        // Machines that are a member of a workgroup indicate that their NetbiosDomainName
        //  equals their NetbiosServerName.
        //  Instead, indicate workgroup membership by the lack of a NetbiosDomainName.
        //

        if ( NetbiosDomainNameSize != 0 ) {
            UNICODE_STRING NetbiosDomainNameString;

            NetbiosDomainNameString.Buffer = LocalTargetInfo.NetbiosDomainName;
            NetbiosDomainNameString.MaximumLength = (USHORT) NetbiosDomainNameSize;
            NetbiosDomainNameString.Length = NetbiosDomainNameString.MaximumLength - sizeof(WCHAR);

            if ( RtlEqualUnicodeString( &NetbiosServerNameString,
                                        &NetbiosDomainNameString,
                                        TRUE ) ) {
                NetbiosDomainNameSize = 0;
                LocalTargetInfo.Flags |= CRED_TI_WORKGROUP_MEMBER;
            }
        }

        //
        // Machines that are a member of an NT 4 domain indicate that their DnsDomainName
        //  equals their NetbiosServerName.
        //  Instead, zap the DnsDomainName.
        //

        if ( DnsDomainNameSize != 0 ) {
            UNICODE_STRING DnsDomainNameString;

            DnsDomainNameString.Buffer = LocalTargetInfo.DnsDomainName;
            DnsDomainNameString.MaximumLength = (USHORT) DnsDomainNameSize;
            DnsDomainNameString.Length = DnsDomainNameString.MaximumLength - sizeof(WCHAR);

            if ( RtlEqualUnicodeString( &NetbiosServerNameString,
                                        &DnsDomainNameString,
                                        TRUE ) ) {
                DnsDomainNameSize = 0;
            }
        }

        //
        // Some machines in a workgroup also return the DnsDomainName set to the DnsServerName.
        //  Instead, zap the DnsDomainName.

        if ( DnsDomainNameSize != 0 && DnsServerNameSize != 0 ) {
            UNICODE_STRING DnsServerNameString;
            UNICODE_STRING DnsDomainNameString;

            DnsServerNameString.Buffer = LocalTargetInfo.DnsServerName;
            DnsServerNameString.MaximumLength = (USHORT) DnsServerNameSize;
            DnsServerNameString.Length = DnsServerNameString.MaximumLength - sizeof(WCHAR);


            DnsDomainNameString.Buffer = LocalTargetInfo.DnsDomainName;
            DnsDomainNameString.MaximumLength = (USHORT) DnsDomainNameSize;
            DnsDomainNameString.Length = DnsDomainNameString.MaximumLength - sizeof(WCHAR);

            if ( RtlEqualUnicodeString( &DnsServerNameString,
                                        &DnsDomainNameString,
                                        TRUE ) ) {
                DnsDomainNameSize = 0;
            }
        }


    }


    //
    // Allocate a buffer for the canonicalized TargetInfo.
    //

    AllocatedSize = sizeof(CANONICAL_TARGET_INFO) +
                    TargetNameSize +
                    NetbiosServerNameSize +
                    DnsServerNameSize +
                    NetbiosDomainNameSize +
                    DnsDomainNameSize +
                    DnsTreeNameSize +
                    PackageNameSize +
                    CredTypeSize;

    ReturnTargetInfo = (PCANONICAL_TARGET_INFO) LsapAllocateLsaHeap( AllocatedSize );


    if ( ReturnTargetInfo == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Where = (PUCHAR)(ReturnTargetInfo+1);

    //
    // Copy fixed size data
    //

    ReturnTargetInfo->Flags = LocalTargetInfo.Flags;

    //
    // Copy the DWORD aligned data
    //

    ReturnTargetInfo->CredTypeCount = LocalTargetInfo.CredTypeCount;
    if ( ReturnTargetInfo->CredTypeCount != 0 ) {

        ReturnTargetInfo->CredTypes = (LPDWORD)Where;
        RtlCopyMemory( Where, LocalTargetInfo.CredTypes, CredTypeSize );
        Where += CredTypeSize;

    } else {
        ReturnTargetInfo->CredTypes = NULL;
    }


    //
    // Copy the 2 byte aligned data
    //

    if ( TargetNameSize != 0 ) {
        ReturnTargetInfo->TargetName.Buffer = (LPWSTR) Where;
        ReturnTargetInfo->TargetName.MaximumLength = (USHORT) TargetNameSize;
        ReturnTargetInfo->TargetName.Length = (USHORT)(ReturnTargetInfo->TargetName.MaximumLength - sizeof(WCHAR));

        RtlCopyMemory( Where, LocalTargetInfo.TargetName, TargetNameSize );
        Where += TargetNameSize;
    } else {
        RtlInitUnicodeString( &ReturnTargetInfo->TargetName, NULL );
    }

    if ( NetbiosServerNameSize != 0 ) {
        ReturnTargetInfo->NetbiosServerName.Buffer = (LPWSTR) Where;
        ReturnTargetInfo->NetbiosServerName.MaximumLength = (USHORT) NetbiosServerNameSize;
        ReturnTargetInfo->NetbiosServerName.Length = (USHORT)(ReturnTargetInfo->NetbiosServerName.MaximumLength - sizeof(WCHAR));

        RtlCopyMemory( Where, LocalTargetInfo.NetbiosServerName, NetbiosServerNameSize );
        Where += NetbiosServerNameSize;
    } else {
        RtlInitUnicodeString( &ReturnTargetInfo->NetbiosServerName, NULL );
    }

    if ( DnsServerNameSize != 0 ) {
        ReturnTargetInfo->DnsServerName.Buffer = (LPWSTR) Where;
        ReturnTargetInfo->DnsServerName.MaximumLength = (USHORT) DnsServerNameSize;
        ReturnTargetInfo->DnsServerName.Length = (USHORT)(ReturnTargetInfo->DnsServerName.MaximumLength - sizeof(WCHAR));

        RtlCopyMemory( Where, LocalTargetInfo.DnsServerName, DnsServerNameSize );
        Where += DnsServerNameSize;
    } else {
        RtlInitUnicodeString( &ReturnTargetInfo->DnsServerName, NULL );
    }

    if ( NetbiosDomainNameSize != 0 ) {
        ReturnTargetInfo->NetbiosDomainName.Buffer = (LPWSTR) Where;
        ReturnTargetInfo->NetbiosDomainName.MaximumLength = (USHORT)(NetbiosDomainNameSize);
        ReturnTargetInfo->NetbiosDomainName.Length = (USHORT)(ReturnTargetInfo->NetbiosDomainName.MaximumLength - sizeof(WCHAR));

        RtlCopyMemory( Where, LocalTargetInfo.NetbiosDomainName, NetbiosDomainNameSize );
        Where += NetbiosDomainNameSize;
    } else {
        RtlInitUnicodeString( &ReturnTargetInfo->NetbiosDomainName, NULL );
    }

    if ( DnsDomainNameSize != 0 ) {
        ReturnTargetInfo->DnsDomainName.Buffer = (LPWSTR) Where;
        ReturnTargetInfo->DnsDomainName.MaximumLength = (USHORT)(DnsDomainNameSize);
        ReturnTargetInfo->DnsDomainName.Length = (USHORT)(ReturnTargetInfo->DnsDomainName.MaximumLength - sizeof(WCHAR));

        RtlCopyMemory( Where, LocalTargetInfo.DnsDomainName, DnsDomainNameSize );
        Where += DnsDomainNameSize;
    } else {
        RtlInitUnicodeString( &ReturnTargetInfo->DnsDomainName, NULL );
    }

    if ( DnsTreeNameSize != 0 ) {
        ReturnTargetInfo->DnsTreeName.Buffer = (LPWSTR) Where;
        ReturnTargetInfo->DnsTreeName.MaximumLength = (USHORT)(DnsTreeNameSize);
        ReturnTargetInfo->DnsTreeName.Length = (USHORT)(ReturnTargetInfo->DnsTreeName.MaximumLength - sizeof(WCHAR));

        RtlCopyMemory( Where, LocalTargetInfo.DnsTreeName, DnsTreeNameSize );
        Where += DnsTreeNameSize;
    } else {
        RtlInitUnicodeString( &ReturnTargetInfo->DnsTreeName, NULL );
    }

    if ( PackageNameSize != 0 ) {
        ReturnTargetInfo->PackageName.Buffer = (LPWSTR) Where;
        ReturnTargetInfo->PackageName.MaximumLength = (USHORT)(PackageNameSize);
        ReturnTargetInfo->PackageName.Length = (USHORT)(ReturnTargetInfo->PackageName.MaximumLength - sizeof(WCHAR));

        RtlCopyMemory( Where, LocalTargetInfo.PackageName, PackageNameSize );
        Where += PackageNameSize;
    } else {
        RtlInitUnicodeString( &ReturnTargetInfo->PackageName, NULL );
    }




    //
    // Return the TargetInfo to the caller.
    //
    *ValidatedTargetInfo = ReturnTargetInfo;
    ReturnTargetInfo = NULL;
    Status = STATUS_SUCCESS;

Cleanup:
    if ( ReturnTargetInfo != NULL ) {
        LsapFreeLsaHeap( ReturnTargetInfo );

    }

    return Status;

}


PPROMPT_DATA
CredpFindPromptData(
    IN PCREDENTIAL_SETS CredentialSets,
    IN PUNICODE_STRING TargetName,
    IN ULONG Type,
    IN ULONG Persist
    )

/*++

Routine Description:

    This routine finds a the prompt data for a credential in a credential set.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSet - Credential set list to find the credential in.

    TargetName - Name of the credential whose prompt data is to be found.

    Type - Type of the credential whose prompt data is to be found.

    Persist - Peristence of the credential whose prompt data is to be found.

Return Values:

    Returns a pointer to the prompt data.  This pointer my be used as long as
    UserCredentialSets->CritSect remains locked.

    NULL: There is no such credential or there is no prompt data for the credential.

--*/
{
    PPROMPT_DATA PromptData;
    PLIST_ENTRY ListEntry;

    //
    // Loop through the list of prompt data trying to find this one.
    //

    for ( ListEntry = CredentialSets->SessionCredSets->PromptData.Flink ;
          ListEntry != &CredentialSets->SessionCredSets->PromptData;
          ListEntry = ListEntry->Flink) {

        PromptData = CONTAINING_RECORD( ListEntry, PROMPT_DATA, Next );

        if ( Type == PromptData->Type &&
             Persist == PromptData->Persist &&
             RtlEqualUnicodeString( TargetName,
                                    &PromptData->TargetName,
                                    TRUE ) ) {
            return PromptData;
        }

    }

    return NULL;
}


PPROMPT_DATA
CredpAllocatePromptData(
    IN PCANONICAL_CREDENTIAL Credential
    )

/*++

Routine Description:

    This routine allocates a prompt data structure that corresponds to the passed in
    credential.

Arguments:

    Credential - Specifies the credential to allocate the prompt data structure for.

Return Values:

    Returns a pointer to the prompt data.
    The buffer should be freed via LsapFreeLsaHeap.

    NULL: Memory could not be allocated.

--*/
{
    PPROMPT_DATA PromptData;
    LPBYTE Where;

    //
    // Allocate the PromptData structure.
    //

    PromptData = (PPROMPT_DATA) LsapAllocateLsaHeap(
                        sizeof(PROMPT_DATA) +
                        Credential->TargetName.Length );

    if ( PromptData == NULL ) {
        return NULL;
    }

    Where = (LPBYTE)(PromptData+1);

    //
    // Fill it in
    //

    PromptData->Type = Credential->Cred.Type;
    PromptData->Persist = Credential->Cred.Persist;
    PromptData->Written = FALSE;

    PromptData->TargetName.Buffer = (LPWSTR)Where;
    PromptData->TargetName.Length = Credential->TargetName.Length;
    PromptData->TargetName.MaximumLength = Credential->TargetName.Length;

    RtlCopyMemory( Where,
                   Credential->TargetName.Buffer,
                   PromptData->TargetName.Length );

    return PromptData;
}


PENCRYPTED_CREDENTIALW
CredpCloneCredential(
    IN PCREDENTIAL_SETS CredentialSets,
    IN ULONG CredFlags,
    IN PCANONICAL_CREDENTIAL InputCredential
    )

/*++

Routine Description:

    This routine creates a credential suitable for returning out of the
    credential manager.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSets - A pointer to the referenced credential sets the cloned credential is in.

    CredFlags - Flags changing the behavior of the routine:
        CREDP_FLAGS_IN_PROCESS - Caller is in-process.  Password data may be returned
        CREDP_FLAGS_USE_MIDL_HEAP - If specified, use MIDL_user_allocate to allocate memory.

    InputCredential - Specifies the credential to clone

Return Values:

    Credential to return.
    The returned credential may container pointers.  All pointer are to addresses within
    the returned allocated block.

    The caller should free this memory using LsapFreeLsaHeap.
    If CREDP_FLAGS_USE_MIDL_HEAP was specified, use MIDL_user_free.


    NULL: Memory could not be allocated


--*/

{
    PCREDENTIAL Credential;
    PENCRYPTED_CREDENTIALW EncryptedCredential;
    DWORD_PTR Offset;
    ULONG i;

    //
    // Allocate memory for the returned credential
    //

    if ( CredFlags & CREDP_FLAGS_USE_MIDL_HEAP ) {
        Credential = (PCREDENTIALW) MIDL_user_allocate( InputCredential->AllocatedSize );
    } else {
        Credential = (PCREDENTIALW) LsapAllocateLsaHeap( InputCredential->AllocatedSize );
    }

    if ( Credential == NULL ) {
        return NULL;
    }

    EncryptedCredential = (PENCRYPTED_CREDENTIALW) Credential;

    //
    // Copy the credential
    //  Note that the "fixed size" part of the structure copied below is copying a
    //  CANONICAL_CREDENTIAL to a ENCRYPTED_CREDENTIALW.  We rely on the following
    //  asserted conditions.
    //
    ASSERT( sizeof(ENCRYPTED_CREDENTIALW) <= sizeof(CANONICAL_CREDENTIAL) );
    ASSERT( offsetof( _ENCRYPTED_CREDENTIALW, Cred) == 0 );
    ASSERT( offsetof( _CANONICAL_CREDENTIAL, Cred) == 0 );

    RtlCopyMemory( Credential, InputCredential, InputCredential->AllocatedSize );

    //
    // Grab the clear text size of the blob
    //

    EncryptedCredential->ClearCredentialBlobSize = InputCredential->ClearCredentialBlobSize;
    ASSERT( InputCredential->ClearCredentialBlobSize <= InputCredential->Cred.CredentialBlobSize );


    //
    // Relocate any pointers
    //
#define RELOCATE_ONE( _x, _type ) if ( _x != NULL ) { _x = (_type) ((LPBYTE)(_x) + Offset); }

    Offset = ((LPBYTE)Credential) - ((LPBYTE)InputCredential);

    RELOCATE_ONE( Credential->TargetName, LPWSTR );
    RELOCATE_ONE( Credential->Comment, LPWSTR );

    RELOCATE_ONE( Credential->CredentialBlob, LPBYTE );

    RELOCATE_ONE( Credential->Attributes, PCREDENTIAL_ATTRIBUTEW );
    for ( i=0; i<Credential->AttributeCount; i++ ) {
        RELOCATE_ONE( Credential->Attributes[i].Keyword, LPWSTR );
        RELOCATE_ONE( Credential->Attributes[i].Value, LPBYTE );
    }

    RELOCATE_ONE( Credential->TargetAlias, LPWSTR );
    RELOCATE_ONE( Credential->UserName, LPWSTR );
#undef RELOCATE_ONE

    //
    // If we're leaving the process,
    //  handle the private data.
    //

    if ( (CredFlags & CREDP_FLAGS_IN_PROCESS) == 0 ) {

        //
        // Domain passwords or cert pins never leave the process
        //
        // "Visible Password" is for user mode implementation auth package implementations.
        // So allow "Visible Password" credentials out of process.
        //

        if ( Credential->Type != CRED_TYPE_GENERIC &&
             Credential->Type != CRED_TYPE_DOMAIN_VISIBLE_PASSWORD ) {

            if ( Credential->CredentialBlob != NULL &&
                 Credential->CredentialBlobSize != 0 ) {

                RtlZeroMemory( Credential->CredentialBlob, Credential->CredentialBlobSize );
                Credential->CredentialBlob = NULL;
                Credential->CredentialBlobSize = 0;
                EncryptedCredential->ClearCredentialBlobSize = 0;

            }

        //
        // Other credentials should be protected for transit on the wire.
        //
        } else {

            //
            // Only encode data if it is there
            //

            if ( Credential->CredentialBlobSize != 0 ) {

                //
                // First unprotect the memory
                //

                LsaUnprotectMemory( Credential->CredentialBlob,
                                    Credential->CredentialBlobSize );


                //
                // Encrypt for transit on the wire (always LPC)
                //

                if ( !CredpEncodeCredential( EncryptedCredential )) {

                    // Clear the possibly clear password
                    RtlZeroMemory( Credential->CredentialBlob, Credential->CredentialBlobSize );

                    if ( CredFlags & CREDP_FLAGS_USE_MIDL_HEAP ) {
                        MIDL_user_free( Credential );
                    } else {
                        LsapFreeLsaHeap( Credential );
                    }
                    return NULL;
                }

            }

        }

    }

    //
    // Return the PromptNow bit if the credential hasn't been refreshed recently.
    //

    Credential->Flags &= ~CRED_FLAGS_PROMPT_NOW;

    if ( !PersistCredBlob( Credential ) ) {
        PPROMPT_DATA PromptData;

        //
        // Get the prompt data for this credential
        //

        PromptData = CredpFindPromptData( CredentialSets,
                                          &InputCredential->TargetName,
                                          Credential->Type,
                                          Credential->Persist );

        //
        // If we've never prompted for this credential since logon,
        //  Prompt now
        //

        if ( ShouldPromptNow( PromptData )) {
            Credential->Flags |= CRED_FLAGS_PROMPT_NOW;
        }
    }


    return EncryptedCredential;

}


BOOLEAN
CredpMarshalCredentials(
    IN PCREDENTIAL_SET CredentialSet,
    OUT LPDWORD BufferSize,
    OUT LPBYTE *Buffer
    )

/*++

Routine Description:

    This routine grabs all of the credentials from a Credential Set and
    marshals them into a single buffer.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSet - Credential set containing the credentials to marshal

    BufferSize - Returns the size of the marshaled credentials
        Returns zero if there are no credentials.

    Buffer - Returns a buffer containing the marshaled credentials
        The buffer must be freed using LsapFreeLsaHeap.

Return Values:

    TRUE - Buffer was sucessfully marshaled

    FALSE - Buffer could not be allocated

--*/

{
    PLIST_ENTRY ListEntry;
    PCANONICAL_CREDENTIAL Credential;
    ULONG ReturnBufferSize;
    PMARSHALED_CREDENTIAL_SET ReturnBuffer;
    ULONG i;
    LPBYTE Where;
    LPBYTE OldWhere;

    LPBYTE LocalCredBlob = NULL;
    ULONG LocalCredBlobSize = 0;


    //
    // Loop through the list of credentials computing the size of the return buffer
    //

    ReturnBufferSize = 0;
    for ( ListEntry = CredentialSet->Credentials.Flink ;
          ListEntry != &CredentialSet->Credentials;
          ListEntry = ListEntry->Flink) {

        Credential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

        ReturnBufferSize += sizeof(MARSHALED_CREDENTIAL);

        ReturnBufferSize = ROUND_UP_COUNT( ReturnBufferSize, ALIGN_WCHAR );
        ReturnBufferSize += sizeof(ULONG) + Credential->TargetName.MaximumLength;

        ReturnBufferSize = ROUND_UP_COUNT( ReturnBufferSize, ALIGN_WCHAR );
        ReturnBufferSize += sizeof(ULONG) + (Credential->Cred.Comment == NULL ? 0 : ((wcslen( Credential->Cred.Comment ) + 1) * sizeof(WCHAR)));

        ReturnBufferSize = ROUND_UP_COUNT( ReturnBufferSize, ALIGN_WCHAR );
        ReturnBufferSize += sizeof(ULONG) + Credential->TargetAlias.MaximumLength;

        ReturnBufferSize = ROUND_UP_COUNT( ReturnBufferSize, ALIGN_WCHAR );
        ReturnBufferSize += sizeof(ULONG) + Credential->UserName.MaximumLength;

        if ( PersistCredBlob( &Credential->Cred ) ) {
            ReturnBufferSize += sizeof(ULONG) + Credential->ClearCredentialBlobSize;
            LocalCredBlobSize = max( LocalCredBlobSize, Credential->Cred.CredentialBlobSize );
        } else {
            ReturnBufferSize += sizeof(ULONG);
        }


        for ( i=0; i<Credential->Cred.AttributeCount; i++ ) {

            ReturnBufferSize += sizeof(ULONG);

            ReturnBufferSize = ROUND_UP_COUNT( ReturnBufferSize, ALIGN_WCHAR );
            ReturnBufferSize += sizeof(ULONG) + (Credential->Cred.Attributes[i].Keyword == NULL ? 0 : (wcslen( Credential->Cred.Attributes[i].Keyword ) + 1 ) * sizeof(WCHAR) );

            ReturnBufferSize += sizeof(ULONG) + Credential->Cred.Attributes[i].ValueSize;

        }

        ReturnBufferSize = ROUND_UP_COUNT( ReturnBufferSize, ALIGN_WORST );

    }


    //
    // If there is nothing to marshal,
    //  we're done.
    //

    if ( ReturnBufferSize == 0 ) {
        *Buffer = NULL;
        *BufferSize = 0;
        return TRUE;
    }
    //
    // Allocate a buffer to return to the caller.
    //

    ReturnBufferSize += ROUND_UP_COUNT( sizeof(MARSHALED_CREDENTIAL_SET), ALIGN_WORST );
    ReturnBuffer = (PMARSHALED_CREDENTIAL_SET) LsapAllocateLsaHeap( ReturnBufferSize );

    if ( ReturnBuffer == NULL) {
        return FALSE;
    }

    //
    // Allocate a buffer to decrypt the credential blob into
    //

    SafeAllocaAllocate( LocalCredBlob, LocalCredBlobSize );
    if ( LocalCredBlob == NULL ) {
        LsapFreeLsaHeap( ReturnBuffer );
        return FALSE;
    }

    //
    // Create the buffer header.
    //

    ReturnBuffer->Version = MARSHALED_CREDENTIAL_SET_VERSION;
    ReturnBuffer->Size = ReturnBufferSize;

    OldWhere = (PUCHAR)(ReturnBuffer+1);
    Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, ALIGN_WORST );
    RtlZeroMemory( OldWhere, Where-OldWhere );

    //
    // Copy the individual credentials
    //

    for ( ListEntry = CredentialSet->Credentials.Flink ;
          ListEntry != &CredentialSet->Credentials;
          ListEntry = ListEntry->Flink) {

        PMARSHALED_CREDENTIAL CredEntry;
        ULONG CommentSize;

        Credential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

        CredEntry = (PMARSHALED_CREDENTIAL)Where;

        //
        // Copy the fixed size fields into the buffer.
        //

        CredEntry->Flags = Credential->Cred.Flags;
        CredEntry->Type = Credential->Cred.Type;
        CredEntry->LastWritten = Credential->Cred.LastWritten;
        CredEntry->Persist = Credential->Cred.Persist;
        CredEntry->AttributeCount = Credential->Cred.AttributeCount;
        CredEntry->Expansion1 = 0;
        CredEntry->Expansion2 = 0;

        Where = (LPBYTE)(CredEntry+1);

        //
        // Copy the strings
        //

#define CredpMarshalBytes( _Ptr, _Size, _Align ) \
        OldWhere = Where; \
        Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, _Align ); \
        RtlZeroMemory( OldWhere, Where-OldWhere ); \
        SmbPutUlong( Where, (_Size) ); \
        Where += sizeof(ULONG); \
        if ( _Size != 0 ) { \
            RtlCopyMemory( Where, (_Ptr), (_Size) ); \
            Where += (_Size); \
        }

        CredpMarshalBytes( Credential->TargetName.Buffer, Credential->TargetName.MaximumLength, ALIGN_WCHAR );

        CommentSize = Credential->Cred.Comment == NULL ? 0 : (wcslen( Credential->Cred.Comment ) + 1 ) * sizeof(WCHAR);
        CredpMarshalBytes( Credential->Cred.Comment, CommentSize, ALIGN_WCHAR );

        CredpMarshalBytes( Credential->TargetAlias.Buffer, Credential->TargetAlias.MaximumLength, ALIGN_WCHAR );

        CredpMarshalBytes( Credential->UserName.Buffer, Credential->UserName.MaximumLength, ALIGN_WCHAR );


        //
        // Marshal the (decrypted) credential itself
        //

        if ( PersistCredBlob( &Credential->Cred ) ) {

            //
            // Grab a local copy of the cred blob to decrypt into
            //

            if ( Credential->Cred.CredentialBlobSize != 0 ) {
                RtlCopyMemory( LocalCredBlob,
                               Credential->Cred.CredentialBlob,
                               Credential->Cred.CredentialBlobSize );

                LsaUnprotectMemory( LocalCredBlob,
                                    Credential->Cred.CredentialBlobSize );
            }

            CredpMarshalBytes( LocalCredBlob, Credential->ClearCredentialBlobSize, ALIGN_BYTE );

        } else {
            CredpMarshalBytes( NULL, 0, ALIGN_BYTE );
        }

        //
        // Marshal the attributes
        //

        for ( i=0; i<CredEntry->AttributeCount; i++ ) {
            ULONG KeywordSize;
            SmbPutUlong( Where, Credential->Cred.Attributes[i].Flags );
            Where += sizeof(ULONG);

            KeywordSize = Credential->Cred.Attributes[i].Keyword == NULL ? 0 : (wcslen( Credential->Cred.Attributes[i].Keyword ) + 1) * sizeof(WCHAR);
            CredpMarshalBytes( Credential->Cred.Attributes[i].Keyword, KeywordSize, ALIGN_WCHAR );

            CredpMarshalBytes( Credential->Cred.Attributes[i].Value,
                                Credential->Cred.Attributes[i].ValueSize,
                                ALIGN_BYTE );

        }

        //
        // Zero any padding bytes
        //
        OldWhere = Where;
        Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, ALIGN_WORST );
        RtlZeroMemory( OldWhere, Where-OldWhere );


        //
        // Remember the size of this credential.
        //

        CredEntry->EntrySize = (ULONG)(Where - ((LPBYTE)CredEntry));

    }

    //
    // Sanity check
    //

    if ( ReturnBufferSize != (ULONG)(Where - ((LPBYTE)ReturnBuffer))) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpMarshalCredentials: Marshaled %ld bytes into a buffer %ld long.\n",
                   Where - ((LPBYTE)ReturnBuffer),
                   ReturnBufferSize ));
    }

    //
    // Return the buffer to the caller
    //

    *Buffer = (LPBYTE) ReturnBuffer;
    *BufferSize = ReturnBufferSize;

    //
    // Free the temp buffer
    //

    if ( LocalCredBlob != NULL ) {
        RtlSecureZeroMemory( LocalCredBlob, LocalCredBlobSize );
        SafeAllocaFree( LocalCredBlob );
    }

    return TRUE;

}


DWORD
CreateNestedDirectories(
    IN      LPWSTR szFullPath,
    IN      LPWSTR szCreationStartPoint // must point in null-terminated range of szFullPath
    )
/*++

    Create all subdirectories if they do not exists starting at
    szCreationStartPoint.

    szCreationStartPoint must point to a character within the null terminated
    buffer specified by the szFullPath parameter.

    Note that szCreationStartPoint should not point at the first character
    of a drive root, eg:

    d:\foo\bar\bilge\water
    \\server\share\foo\bar
    \\?\d:\big\path\bilge\water

    Instead, szCreationStartPoint should point beyond these components, eg:

    bar\bilge\water
    foo\bar
    big\path\bilge\water

    This function does not implement logic for adjusting to compensate for these
    inputs because the environment it was design to be used in causes the input
    szCreationStartPoint to point well into the szFullPath input buffer.


    This function stolen from crypto api.

--*/
{
    DWORD i;
    DWORD cchRemaining;
    DWORD LastError = ERROR_SUCCESS;

    BOOL fSuccess = FALSE;


    if( szCreationStartPoint < szFullPath ||
        szCreationStartPoint  > (lstrlenW(szFullPath) + szFullPath)
        )
        return ERROR_INVALID_PARAMETER;

    cchRemaining = lstrlenW( szCreationStartPoint );

    //
    // scan from left to right in the szCreationStartPoint string
    // looking for directory delimiter.
    //

    for ( i = 0 ; i < cchRemaining ; i++ ) {
        WCHAR charReplaced = szCreationStartPoint[ i ];

        if( charReplaced == L'\\' || charReplaced == L'/' ) {

            szCreationStartPoint[ i ] = L'\0';

            fSuccess = CreateDirectoryW( szFullPath, NULL );

            szCreationStartPoint[ i ] = charReplaced;

            if( !fSuccess ) {
                LastError = GetLastError();
                if( LastError != ERROR_ALREADY_EXISTS ) {

                    //
                    // continue onwards, trying to create specified subdirectories.
                    // this is done to address the obscure scenario where
                    // the Bypass Traverse Checking Privilege allows the caller
                    // to create directories below an existing path where one
                    // component denies the user access.
                    // we just keep trying and the last CreateDirectory()
                    // result is returned to the caller.
                    //

                    continue;
                }
            }

            LastError = ERROR_SUCCESS;
        }
    }

    //
    // check if the last directory creation actually succeeded.
    // if it did, we need to adjust the file attributes on that directory
    // and its parent.
    //

    if( fSuccess ) {

        SetFileAttributesW( szFullPath, FILE_ATTRIBUTE_SYSTEM );

        //
        // now, scan from right to left looking for the prior directory
        // de-limiter.
        //

        if( cchRemaining < 2 )
            return LastError;

        for ( i = (cchRemaining-2) ; i > 0 ; i-- ) {
            WCHAR charReplaced = szCreationStartPoint[ i ];

            if( charReplaced == L'\\' || charReplaced == L'/' ) {

                szCreationStartPoint[ i ] = L'\0';
                SetFileAttributesW( szFullPath, FILE_ATTRIBUTE_SYSTEM );
                szCreationStartPoint[ i ] = charReplaced;

                break;
            }

        }
    }

    return LastError;
}

DWORD
GetUserStorageArea(
    IN BOOL fLocalAppData,
    IN PSID UserSid,
    OUT LPWSTR *UserStorageArea
    )

/*++

Routine Description:

    Get the path to user's roaming profile.  The subdirectories are created as needed.

    Caller must be impersonating the user.

Arguments:

    csidl - Specifies which system directory to use as a root.

    UserSid - Sid of the user


    UserStorageArea - Returns the path of the user storage area
        The buffer must be freed using LsapFreeLsaHeap

Return Values:

    NO_ERROR: Path returned properly
    ERROR_CANTOPEN: Path could not be found

--*/
{
    DWORD WinStatus;
    NTSTATUS Status;

    WCHAR szUserStorageRoot[MAX_PATH+1];
    DWORD cbUserStorageRoot;

    const WCHAR szProductString[] = L"\\Microsoft\\Credentials\\";
    DWORD cbProductString = sizeof(szProductString) - sizeof(WCHAR);

    HANDLE hFile = INVALID_HANDLE_VALUE;
    PBYTE Where;
    UNICODE_STRING UserSidString;

    HANDLE hToken;

    //
    // Initialization
    //
    *UserStorageArea = NULL;
    RtlInitUnicodeString( &UserSidString, NULL );

    //
    // Get the path of the "Application Data" folder
    //

    if( !OpenThreadToken( GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hToken )) {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    WinStatus = GetUserAppDataPath(hToken, fLocalAppData, szUserStorageRoot);

    CloseHandle( hToken );

    if( WinStatus != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    cbUserStorageRoot = wcslen( szUserStorageRoot ) * sizeof(WCHAR);

    //
    // An empty string is not legal as the root component of the per-user
    // storage area.
    //

    if( cbUserStorageRoot == 0 ) {
        WinStatus = ERROR_CANTOPEN;
        goto Cleanup;
    }

    //
    // Ensure returned string does not have trailing \
    //

    if( szUserStorageRoot[ (cbUserStorageRoot / sizeof(WCHAR)) - 1 ] == L'\\' ) {

        szUserStorageRoot[ (cbUserStorageRoot / sizeof(WCHAR)) - 1 ] = L'\0';
        cbUserStorageRoot -= sizeof(WCHAR);
    }

    //
    // Convert the SID to a text string
    //

    Status = RtlConvertSidToUnicodeString( &UserSidString, UserSid, TRUE );

    if ( !NT_SUCCESS(Status) ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    //
    // Allocate memory for the return string
    //

    *UserStorageArea = (LPWSTR)LsapAllocateLsaHeap(
                                    cbUserStorageRoot +
                                    cbProductString +
                                    UserSidString.Length +
                                    (2 * sizeof(WCHAR)) // trailing slash and NULL
                                    );

    if( *UserStorageArea == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    //
    // Build the name as of the path.
    //

    Where = (PBYTE)*UserStorageArea;

    RtlCopyMemory(Where, szUserStorageRoot, cbUserStorageRoot);
    Where += cbUserStorageRoot;

    RtlCopyMemory(Where, szProductString, cbProductString);
    Where += cbProductString;

    RtlCopyMemory(Where, UserSidString.Buffer, UserSidString.Length);
    Where += UserSidString.Length; // note: does not include terminal NULL


    if( *((LPWSTR)Where - 1) != L'\\' ) {
        *(LPWSTR)Where = L'\\';
        Where += sizeof(WCHAR);
    }

    *(LPWSTR)Where = L'\0';


    //
    // Ensure the directory exists
    //

    WinStatus = CreateNestedDirectories(
                            *UserStorageArea,
                            (LPWSTR)((LPBYTE)*UserStorageArea + cbUserStorageRoot + sizeof(WCHAR)) );


Cleanup:

    RtlFreeUnicodeString( &UserSidString );

    if( WinStatus != ERROR_SUCCESS && *UserStorageArea ) {
        LsapFreeLsaHeap( *UserStorageArea );
        *UserStorageArea = NULL;
    }

    return WinStatus;
}

DWORD
OpenFileInStorageArea(
    IN      DWORD   dwDesiredAccess,
    IN      LPCWSTR szUserStorageArea,
    IN      LPCWSTR szFileName,
    IN OUT  HANDLE  *phFile
    )
// Routine stolen from crypto API
{
    LPWSTR szFilePath = NULL;
    DWORD cbUserStorageArea;
    DWORD cbFileName;
    DWORD dwShareMode = 0;
    DWORD dwCreationDistribution = OPEN_EXISTING;
    DWORD LastError = ERROR_SUCCESS;

    *phFile = INVALID_HANDLE_VALUE;

    if( dwDesiredAccess & GENERIC_READ ) {
        dwShareMode |= FILE_SHARE_READ;
        dwCreationDistribution = OPEN_EXISTING;
    }

    if( dwDesiredAccess & GENERIC_WRITE ) {
        dwShareMode = 0;
        dwCreationDistribution = CREATE_ALWAYS;
    }

    cbUserStorageArea = wcslen( szUserStorageArea ) * sizeof(WCHAR);
    cbFileName = wcslen( szFileName ) * sizeof(WCHAR);

    SafeAllocaAllocate( szFilePath, cbUserStorageArea + cbFileName + sizeof(WCHAR) );

    if( szFilePath == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    CopyMemory(szFilePath, szUserStorageArea, cbUserStorageArea);
    CopyMemory((LPBYTE)szFilePath+cbUserStorageArea, szFileName, cbFileName + sizeof(WCHAR));

    if( LastError == ERROR_SUCCESS ) {

        //
        // TODO:
        // apply security descriptor to file.
        //

        *phFile = CreateFileW(
                    szFilePath,
                    dwDesiredAccess,
                    dwShareMode,
                    NULL,
                    dwCreationDistribution,
                    FILE_ATTRIBUTE_HIDDEN |
                    FILE_ATTRIBUTE_SYSTEM |
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );

        if( *phFile == INVALID_HANDLE_VALUE ) {
            LastError = GetLastError();
        }


    }

    if(szFilePath)
        SafeAllocaFree(szFilePath);

    return LastError;
}

DWORD
DeleteFileInStorageArea(
    IN      LPCWSTR szUserStorageArea,
    IN      LPCWSTR szFileName
    )
// Routine stolen from crypto API
{
    LPWSTR szFilePath = NULL;
    DWORD cbUserStorageArea;
    DWORD cbFileName;
    DWORD LastError = ERROR_SUCCESS;

    cbUserStorageArea = wcslen( szUserStorageArea ) * sizeof(WCHAR);
    cbFileName = wcslen( szFileName ) * sizeof(WCHAR);

    SafeAllocaAllocate( szFilePath, cbUserStorageArea + cbFileName + sizeof(WCHAR) );

    if( szFilePath == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    CopyMemory(szFilePath, szUserStorageArea, cbUserStorageArea);
    CopyMemory((LPBYTE)szFilePath+cbUserStorageArea, szFileName, cbFileName + sizeof(WCHAR));

    if ( !DeleteFileW( szFilePath ) ) {
            LastError = GetLastError();
    }

    if(szFilePath)
        SafeAllocaFree(szFilePath);

    return LastError;
}

BOOL
CredpGetUnicodeString(
    IN LPBYTE BufferEnd,
    IN OUT LPBYTE *Where,
    OUT LPWSTR *String
    )

/*++

Routine Description:

    Determine if a UNICODE string in a message buffer is valid.

    UNICODE strings always appear at a 2-byte boundary in the message.

Arguments:

    BufferEnd - A pointer to the first byte beyond the end of the buffer.

    Where - Indirectly points to the current location in the buffer.  The
        string at the current location is validated (i.e., checked to ensure
        its length is within the bounds of the message buffer and not too
        long).  If the string is valid, this current location is updated
        to point to the byte following the zero byte in the message buffer.

    String - Returns a pointer to the validated string.
        Pointer is to the buffer *Where points to.
        Returns NULL for empty strings.


Return Value:

    TRUE - the string is valid.

    FALSE - the string is invalid.

--*/

{
    DWORD Size;
    LPWSTR ZeroPtr;

    //
    // Align the unicode string on a WCHAR boundary.
    //

    *Where = (LPBYTE) ROUND_UP_POINTER( *Where, ALIGN_WCHAR );

    if ( (*Where) + sizeof(ULONG) > BufferEnd ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpGetUnicodeString: String size after buffer end: %lx %lx.\n",
                   *Where,
                   BufferEnd ));
        return FALSE;
    }

    //
    // Get the string size (in bytes)
    //

    Size = SmbGetUlong( *Where );
    *Where += sizeof(ULONG);

    if ( Size == 0 ) {
        *String = NULL;
        return TRUE;
    }


    if ( *Where >= BufferEnd ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpGetUnicodeString: String after buffer end: %lx %lx.\n",
                   *Where,
                   BufferEnd ));
        return FALSE;
    }

    //
    // Ensure the size is aligned
    //

    if ( Size != ROUND_UP_COUNT( Size, ALIGN_WCHAR) ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpGetUnicodeString: Size not aligned: %lx.\n",
                   Size ));
        return FALSE;
    }


    //
    // Limit the string to the number of bytes remaining in the message buffer.
    //

    if ( Size > (ULONG)(BufferEnd - (*Where)) ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpGetUnicodeString: String too big: %lx %lx %lx.\n",
                   *Where,
                   BufferEnd,
                   Size ));
        return FALSE;
    }

    //
    // Ensure the trailing zero exists
    //

    if ( ((LPWSTR)(*Where))[(Size/sizeof(WCHAR))-1] != L'\0' ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpGetUnicodeString: No trailing zero: %lx.\n",
                   Size ));
        return FALSE;
    }

    //
    // Ensure there aren't extra zero bytes.
    //

    ZeroPtr = wcschr( (LPWSTR)(*Where), L'\0' );

    if ( ZeroPtr < &((LPWSTR)(*Where))[(Size/sizeof(WCHAR))-1] ) {
        DebugLog(( DEB_TRACE_CRED,
                   "Trailing zero in middle of string: %lx.\n",
                   Size ));
        return FALSE;
    }

    //
    // Position 'Where' past the end of the string.
    //

    *String = (LPWSTR)(*Where);
    *Where += Size;

    return TRUE;

}

BOOL
CredpGetBytes(
    IN LPBYTE BufferEnd,
    IN OUT LPBYTE *Where,
    OUT LPDWORD BufferSize,
    OUT LPBYTE *Buffer
    )

/*++

Routine Description:

    Unmarshal an array of bytes from a message buffer.

Arguments:

    BufferEnd - A pointer to the first byte beyond the end of the buffer.

    Where - Indirectly points to the current location in the buffer.  The
        string at the current location is validated (i.e., checked to ensure
        its length is within the bounds of the message buffer and not too
        long).  If the string is valid, this current location is updated
        to point to the byte following the data bytes in the message buffer.

    BufferSize - Returns the size (in bytes) of the data.

    Buffer - Returns a pointer to the validated data.
        Pointer is to the buffer *Where points to.
        Returns NULL for zero length data.


Return Value:

    TRUE - the string is valid.

    FALSE - the string is invalid.

--*/

{
    DWORD Size;

    //
    // Get the string size (in bytes)
    //

    Size = SmbGetUlong( *Where );
    *Where += sizeof(ULONG);

    if ( Size == 0 ) {
        *Buffer = NULL;
        *BufferSize = 0;
        return TRUE;
    }


    if ( *Where >= BufferEnd ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpGetBytes: String after buffer end: %lx %lx.\n",
                   *Where,
                   BufferEnd ));
        return FALSE;
    }

    //
    // Limit the string to the number of bytes remaining in the message buffer.
    //

    if ( Size > (ULONG)(BufferEnd - (*Where)) ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpGetBytes: String too big: %lx %lx %lx.\n",
                   *Where,
                   BufferEnd,
                   Size ));
        return FALSE;
    }

    //
    // Position 'Where' past the end of the string.
    //

    *Buffer = *Where;
    *BufferSize = Size;
    *Where += Size;

    return TRUE;

}

VOID
CredpMarkDirty(
    IN PCREDENTIAL_SETS CredentialSets,
    IN ULONG Persist,
    IN PCANONICAL_CREDENTIAL Credential OPTIONAL
    )

/*++

Routine Description:

    The routine marks a credential set dirty and updates the last written
    time on a credential.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSets - Credential set to mark.

    Persist - Persistence of the credential set to mark

    Credential - Specifies the modified credential.
        If NULL, no specific credential was modified.

Return Values:

    None.

--*/

{

    //
    // Mark the credential set dirty.
    //

    PersistToCredentialSet( CredentialSets, Persist )->Dirty = TRUE;

    //
    // Mark the credential as modified
    //

    if ( Credential != NULL ) {
        LsapQuerySystemTime( &Credential->Cred.LastWritten );
    }

}

DWORD
CredpLogonGetUserNames(
    IN PLUID LogonId,
    OUT PULONG UserNameCount,
    OUT PUNICODE_STRING *UserNames
    )
/*++

Routine Description:

    This routine returns the UserNames for the specified LogonId.  It returns
    all of the forms valid to appear on a credential.

    That is, <NetbiosDomain>\<SamAccountName>, <DnsDomain>\<SamAccountName>, and UPN.

Arguments:

    LogonId - LogonId of the session to check

    UserNameCount - On success, returns a count of the names in UserNames

    UserNames - On success, returns an array of pointers to the various UserNames.
        Buffer must be freed using LsapFreeLsaHeap.

Return Values:

    NO_ERROR - User names were returned
    Otherwise, fatal error

--*/

{
    DWORD WinStatus;

    NTSTATUS Status;
    PLSAP_LOGON_SESSION LogonSession = NULL;

    PLSAP_DS_NAME_MAP SamMap = NULL;
    PLSAP_DS_NAME_MAP DnsDomainMap = NULL;
    UNICODE_STRING DnsDomainName;
    PLSAP_DS_NAME_MAP UpnMap = NULL;
    UNICODE_STRING Upn;
    UNICODE_STRING SamAccountName;

    ULONG Index;
    ULONG Count;
    ULONG Size;
    PUNICODE_STRING Names;
    LPWSTR Current;

    //
    // Initialization
    //

    *UserNameCount = 0;
    *UserNames = NULL;
    RtlInitUnicodeString( &SamAccountName, NULL );

    //
    // Get the credential set from the logon session.
    //

    LogonSession = LsapLocateLogonSession( LogonId );

    if ( LogonSession == NULL ) {
        WinStatus = ERROR_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Get the netbios form of the username for the logon session.
    //  Do not go off-machine if it's not in the cache.
    //

    Status = LsapGetNameForLogonSession(
                        LogonSession,
                        NameSamCompatible,
                        &SamMap,
                        TRUE );

    if ( !NT_SUCCESS(Status) ) {
        WinStatus = RtlNtStatusToDosError( Status );
        goto Cleanup;
    }


    //
    // Get the DnsDomainName for the logon session.
    //  Do not go off-machine if it's not in the cache.
    //

    Status = LsapGetNameForLogonSession(
                        LogonSession,
                        NameDnsDomain,
                        &DnsDomainMap,
                        TRUE );

    if ( !NT_SUCCESS(Status) ) {
        RtlInitUnicodeString( &DnsDomainName, NULL );
    } else {
        DnsDomainName = DnsDomainMap->Name;
    }

    //
    // Get the UPN for the logon session.
    //  Do not go off-machine if it's not in the cache.
    //

    Status = LsapGetNameForLogonSession(
                        LogonSession,
                        NameUserPrincipal,
                        &UpnMap,
                        TRUE );

    if ( !NT_SUCCESS(Status) ) {
        RtlInitUnicodeString( &Upn, NULL );
    } else {
        Upn = UpnMap->Name;
    }

    //
    // Determine the size of the buffer to contain the names
    //

    Count = 1;
    Size = SamMap->Name.Length;

    if ( DnsDomainName.Length != 0 ) {

        //
        // Find the <SamAccountName> part of the Sam name
        //
        // SAM name is always NULL-terminated
        //

        SamAccountName.Buffer = wcschr( SamMap->Name.Buffer, L'\\' );

        if ( SamAccountName.Buffer != NULL ) {
            SamAccountName.Buffer++;
            SamAccountName.Length = SamMap->Name.Length - ((SamAccountName.Buffer-SamMap->Name.Buffer)*sizeof(WCHAR));
            SamAccountName.MaximumLength = SamAccountName.Length;
        } else {
            SamAccountName = SamMap->Name;
        }

        //
        // Add the length of <DnsDomainName>\<SamAccountName>
        //
        Count ++;
        Size += DnsDomainName.Length +
                sizeof(WCHAR) +
                SamAccountName.Length;

    }

    if ( Upn.Length != 0 ) {
        Count ++;
        Size += Upn.Length;
    }

    //
    // Allocate the buffer
    //

    Names = (PUNICODE_STRING)LsapAllocateLsaHeap( Count * sizeof(UNICODE_STRING) + Size );

    if ( Names == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Current = (LPWSTR)(&Names[Count]);

    //
    // Copy the <NetbiosDomain>\<SamAccountName> name into the buffer
    //

    Index = 0;
    Names[Index].Buffer = Current;
    Names[Index].Length = SamMap->Name.Length;
    Names[Index].MaximumLength = Names[Index].Length;
    RtlCopyMemory( Current, SamMap->Name.Buffer, SamMap->Name.Length );
    Current += Names[Index].Length/sizeof(WCHAR);

    //
    // Copy the <DnsDomain>\<SamAccountName> name into the buffer
    //

    if ( DnsDomainName.Length != 0) {
        Index++;

        Names[Index].Buffer = Current;
        Names[Index].Length = DnsDomainName.Length + sizeof(WCHAR) + SamAccountName.Length;
        Names[Index].MaximumLength = Names[Index].Length;

        RtlCopyMemory( Current, DnsDomainName.Buffer, DnsDomainName.Length );
        Current += DnsDomainName.Length/sizeof(WCHAR);

        *Current = L'\\';
        Current++;

        RtlCopyMemory( Current, SamAccountName.Buffer, SamAccountName.Length );
        Current += SamAccountName.Length/sizeof(WCHAR);
    }

    //
    // Copy the UPN into the buffer
    //

    if ( Upn.Length != 0) {
        Index++;

        Names[Index].Buffer = Current;
        Names[Index].Length = Upn.Length;
        Names[Index].MaximumLength = Names[Index].Length;

        RtlCopyMemory( Current, Upn.Buffer, Upn.Length );
        Current += Upn.Length/sizeof(WCHAR);
    }

    //
    // Return the names to the caller
    //
    *UserNameCount = Count;
    *UserNames = Names;
    WinStatus = NO_ERROR;

Cleanup:
    if ( DnsDomainMap != NULL ) {
        LsapDerefDsNameMap( DnsDomainMap );
    }

    if ( UpnMap != NULL ) {
        LsapDerefDsNameMap( UpnMap );
    }

    if ( SamMap != NULL ) {
        LsapDerefDsNameMap( SamMap );
    }

    if ( LogonSession != NULL ) {
        LsapReleaseLogonSession( LogonSession );
    }

    return WinStatus;
}

DWORD
CredpReadCredSet(
    IN PLUID LogonId,
    IN PCREDENTIAL_SETS CredentialSets,
    IN ULONG Persist
    )

/*++

Routine Description:

    The routine reads a credential set from disk

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    LogonId - LogonId of the session to read the credentials for

    CredentialSets - Credential sets to read into

    Persist - Persistence of the credential set to read

Return Values:

    NO_ERROR - Credential set read successfully

--*/

{
    DWORD WinStatus;

    NTSTATUS Status;

    ULONG UserNameCount = 0;
    PUNICODE_STRING UserNames = NULL;

    PCREDENTIAL_SET CredentialSet;
    PMARSHALED_CREDENTIAL_SET CredSetBuffer = NULL;
    ULONG CredSetBufferSize = 0;
    LPBYTE CredSetBufferEnd;
    PMARSHALED_CREDENTIAL CredEntry;
    LIST_ENTRY CredentialList;
    PCANONICAL_CREDENTIAL TempCredential;

    LPWSTR FilePath = NULL;
    LPWSTR FileName = CREDENTIAL_FILE_NAME;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    PCREDENTIAL_ATTRIBUTEW Attributes = NULL;
    BOOLEAN CritSectLocked = TRUE;

    ULONG i;
    ULONG BytesRead;

    PVOID EncryptedBlob = NULL;
    ULONG EncryptedBlobSize;

    LPBYTE LocalCredBlob = NULL;
    ULONG LocalCredBlobSize = 0;


    PLIST_ENTRY ListEntry;

    LPBYTE Where;

    //
    // Initialization
    //

    InitializeListHead( &CredentialList );


    //
    // Ignore non-persistent credential sets
    //

    if ( Persist == CRED_PERSIST_SESSION ) {
        return NO_ERROR;
    }

    CredentialSet = PersistToCredentialSet( CredentialSets, Persist );

    //
    // Get all the user names for the currently logged on user
    //

    Status = CredpLogonGetUserNames(
                LogonId,
                &UserNameCount,
                &UserNames );


    //
    // Drop the lock while we're doing the read.  DPAPI accesses network resources
    //  while encrypting.  We don't want to hold up cred set access just because the
    //  network is slow.
    //

    RtlLeaveCriticalSection( &CredentialSets->UserCredentialSets->CritSect );
    CritSectLocked = FALSE;

    //
    // Get the name of the path to read the cred set from
    //

    WinStatus = GetUserStorageArea(
            (Persist == CRED_PERSIST_ENTERPRISE ? FALSE : TRUE),  // TRUE == local app data
            CredentialSets->UserCredentialSets->UserSid,
            &FilePath );

    if ( WinStatus != NO_ERROR ) {
        if ( WinStatus == ERROR_CANTOPEN ) {
            WinStatus = NO_ERROR;
        } else {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: Cannot determine path to profile: %ld.\n",
                       WinStatus ));
        }
        goto Cleanup;
    }

    //
    // Open the file
    //

    WinStatus = OpenFileInStorageArea(
                    GENERIC_READ,
                    FilePath,
                    FileName,
                    &FileHandle );

    if ( WinStatus != NO_ERROR ) {
        if ( WinStatus == ERROR_FILE_NOT_FOUND ||
             WinStatus == ERROR_PATH_NOT_FOUND ) {
            WinStatus = NO_ERROR;
        } else {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: Cannot open file %ls\\%ls: %ld.\n",
                       FilePath,
                       FileName,
                       WinStatus ));
        }
        goto Cleanup;
    }


    //
    // Get the size of the file.
    //

    EncryptedBlobSize = GetFileSize( FileHandle, NULL );

    if ( EncryptedBlobSize == 0xFFFFFFFF ) {

        WinStatus = GetLastError();
        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Cannot GetFileSize %ls\\%ls: %ld.\n",
                   FilePath,
                   FileName,
                   WinStatus ));
        WinStatus = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    if ( EncryptedBlobSize < 1 ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Size too small %ls\\%ls: %ld.\n",
                   FilePath,
                   FileName,
                   EncryptedBlobSize ));
        WinStatus = ERROR_INVALID_DATA;
        goto Cleanup;
    }


    //
    // Allocate a buffer to read the file into.
    //

    SafeAllocaAllocate( EncryptedBlob, EncryptedBlobSize );

    if ( EncryptedBlob == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Read the file into the buffer.
    //

    if ( !ReadFile( FileHandle,
                    EncryptedBlob,
                    EncryptedBlobSize,
                    &BytesRead,
                    NULL ) ) {  // Not Overlapped

        WinStatus = GetLastError();
        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Cannot ReadFile %ls\\%ls: %ld.\n",
                   FilePath,
                   FileName,
                   WinStatus ));

        WinStatus = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    if ( BytesRead != EncryptedBlobSize ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Cannot read entire file %ls\\%ls: %ld %ld.\n",
                   FilePath,
                   FileName,
                   BytesRead,
                   EncryptedBlobSize ));

        WinStatus = ERROR_INVALID_DATA;
        goto Cleanup;
    }



    //
    // Decrypt the data
    //

    if ( !LsaICryptUnprotectData(
                              EncryptedBlob,
                              EncryptedBlobSize,
                              NULL,    // No additional entropy
                              0,
                              NULL,    // Must be NULL
                              NULL,    // Must be NULL
                              CRYPTPROTECT_SYSTEM |              // Cannot be decrypted by usermode app
                                CRYPTPROTECT_VERIFY_PROTECTION | // Tell us if the encryption algorithm needs to change
                                CRYPTPROTECT_UI_FORBIDDEN,       // No UI allowed
                              NULL,    // No description of the data
                              (PVOID *)&CredSetBuffer,
                              &CredSetBufferSize ) ) {

        WinStatus = GetLastError();

        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Cannot CryptUnprotectData: 0x%lx.\n",
                   WinStatus ));

        WinStatus = ERROR_INVALID_DATA;
        goto Cleanup;

    }


    //
    // If the encryption algorithm changed,
    //  encrypt the data with the new algorithm
    //

    WinStatus = GetLastError();
    if ( WinStatus == CRYPT_I_NEW_PROTECTION_REQUIRED ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Need to change encryption algorithm: 0x%lx.\n",
                   WinStatus ));

        // The easiest way to do that is to simply mark the cred set as dirty.
        CredpMarkDirty( CredentialSets, Persist, NULL );
    }



    //
    // Validate the returned data.
    //

    if ( CredSetBufferSize < sizeof(MARSHALED_CREDENTIAL_SET) ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Size too small %ls\\%ls: %ld.\n",
                   FilePath,
                   FileName,
                   CredSetBufferSize ));
        WinStatus = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    if ( CredSetBuffer->Version != MARSHALED_CREDENTIAL_SET_VERSION ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Version wrong %ls\\%ls: %ld %ld.\n",
                   FilePath,
                   FileName,
                   CredSetBuffer->Version,
                   MARSHALED_CREDENTIAL_SET_VERSION ));
        WinStatus = ERROR_INVALID_DATA;
        goto Cleanup;
    }

    if ( CredSetBuffer->Size != CredSetBufferSize ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CredpReadCredSet: Size wrong %ls\\%ls: %ld %ld.\n",
                   FilePath,
                   FileName,
                   CredSetBuffer->Size,
                   CredSetBufferSize ));
        WinStatus = ERROR_INVALID_DATA;
        goto Cleanup;
    }



    //
    // Loop through each log entry.
    //

    CredSetBufferEnd = ((LPBYTE)CredSetBuffer) + CredSetBufferSize;
    CredEntry = (PMARSHALED_CREDENTIAL)ROUND_UP_POINTER( (CredSetBuffer + 1), ALIGN_WORST );

    while ( (LPBYTE)(CredEntry+1) <= CredSetBufferEnd ) {
        LPBYTE CredEntryEnd;
        ENCRYPTED_CREDENTIALW LocalCredential;

        CredEntryEnd = ((LPBYTE)CredEntry) + CredEntry->EntrySize;

        //
        // Cleanup from a previous iteration.
        //

        if ( Attributes != NULL ) {
            LsapFreeLsaHeap( Attributes );
            Attributes = NULL;
        }

        //
        // Ensure this entry is entirely within the allocated buffer.
        //

        if  ( CredEntryEnd > CredSetBufferEnd || CredEntryEnd <= (LPBYTE)CredEntry ) {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: Entry too big %ls\\%ls: %ld %ld.\n",
                       FilePath,
                       FileName,
                       ((LPBYTE)CredEntry)-((LPBYTE)CredSetBuffer),
                       CredEntry->EntrySize ));
            WinStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        //
        // Validate the entry
        //

        if ( !COUNT_IS_ALIGNED(CredEntry->EntrySize, ALIGN_WORST) ) {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: EntrySize not aligned %ls\\%ls: %ld.\n",
                       FilePath,
                       FileName,
                       CredEntry->EntrySize ));
            WinStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }


        //
        // Grab the Position past the fixed size data for the entry.
        //

        Where = (LPBYTE) (CredEntry+1);
        if ( Where >= CredEntryEnd ) {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: Data after record missing %ls\\%ls: %lx %lx.\n",
                       FilePath,
                       FileName,
                       Where,
                       CredEntryEnd ));
            WinStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        //
        // Copy the fixed size fields into the buffer.
        //


        RtlZeroMemory( &LocalCredential, sizeof(LocalCredential) );
        LocalCredential.Cred.Flags = CredEntry->Flags;
        LocalCredential.Cred.Type = CredEntry->Type;
        LocalCredential.Cred.LastWritten = CredEntry->LastWritten;
        LocalCredential.Cred.Persist = Persist;
        LocalCredential.Cred.AttributeCount = CredEntry->AttributeCount;

        //
        // Copy the strings
        //

        if ( !CredpGetUnicodeString( CredEntryEnd, &Where, &LocalCredential.Cred.TargetName ) ) {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: TargetName string broken %ls\\%ls: %lx %lx.\n",
                       FilePath,
                       FileName,
                       Where,
                       CredEntryEnd ));
            WinStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        if ( !CredpGetUnicodeString( CredEntryEnd, &Where, &LocalCredential.Cred.Comment ) ) {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: Comment string broken %ls\\%ls: %lx %lx.\n",
                       FilePath,
                       FileName,
                       Where,
                       CredEntryEnd ));
            WinStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        if ( !CredpGetUnicodeString( CredEntryEnd, &Where, &LocalCredential.Cred.TargetAlias ) ) {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: TargetAlias string broken %ls\\%ls: %lx %lx.\n",
                       FilePath,
                       FileName,
                       Where,
                       CredEntryEnd ));
            WinStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        if ( !CredpGetUnicodeString( CredEntryEnd, &Where, &LocalCredential.Cred.UserName ) ) {
            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: UserName string broken %ls\\%ls: %lx %lx.\n",
                       FilePath,
                       FileName,
                       Where,
                       CredEntryEnd ));
            WinStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }


        //
        // Unmarshal the clear credential itself
        //

        if ( !CredpGetBytes( CredEntryEnd,
                             &Where,
                             &LocalCredential.Cred.CredentialBlobSize,
                             &LocalCredential.Cred.CredentialBlob ) ) {

            DebugLog(( DEB_TRACE_CRED,
                       "CredpReadCredSet: Credential broken %ls\\%ls: %lx %lx.\n",
                       FilePath,
                       FileName,
                       Where,
                       CredEntryEnd ));

            WinStatus = ERROR_INVALID_DATA;
            goto Cleanup;

        }

        // Clear cred have both buffers the same size.
        LocalCredential.ClearCredentialBlobSize = LocalCredential.Cred.CredentialBlobSize;


        //
        // Marshal the attributes
        //

        if ( CredEntry->AttributeCount != 0) {
            //
            // Allocate an array to point to the aliases.
            //

            Attributes = (PCREDENTIAL_ATTRIBUTEW) LsapAllocateLsaHeap(
                    CredEntry->AttributeCount * sizeof(CREDENTIAL_ATTRIBUTEW) );

            if ( Attributes == NULL ) {
                WinStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            LocalCredential.Cred.Attributes = Attributes;

            //
            // Loop unmarshaling the aliases.
            //

            for ( i=0; i<CredEntry->AttributeCount; i++ ) {

                //
                // Get the flags
                //
                LocalCredential.Cred.Attributes[i].Flags = SmbGetUlong( Where );
                Where += sizeof(ULONG);

                //
                // Get the keyword
                //
                if ( !CredpGetUnicodeString( CredEntryEnd, &Where, &LocalCredential.Cred.Attributes[i].Keyword ) ) {
                    DebugLog(( DEB_TRACE_CRED,
                               "CredpReadCredSet: Keyword %ld broken %ls\\%ls: %lx %lx.\n",
                               i,
                               FilePath,
                               FileName,
                               Where,
                               CredEntryEnd ));
                    WinStatus = ERROR_INVALID_DATA;
                    goto Cleanup;
                }

                //
                // Get the value
                //

                if ( !CredpGetBytes( CredEntryEnd,
                                     &Where,
                                     &LocalCredential.Cred.Attributes[i].ValueSize,
                                     &LocalCredential.Cred.Attributes[i].Value ) ) {

                    DebugLog(( DEB_TRACE_CRED,
                               "CredpReadCredSet: Value %ld broken %ls\\%ls: %lx %lx.\n",
                               i,
                               FilePath,
                               FileName,
                               Where,
                               CredEntryEnd ));
                    WinStatus = ERROR_INVALID_DATA;
                    goto Cleanup;

                }

            }
        }

        //
        // Canonicalize the credential.
        //

        Status = CredpValidateCredential(
                        CREDP_FLAGS_CLEAR_PASSWORD,
                        NULL,   // No target info
                        &LocalCredential,
                        &TempCredential );

        if ( !NT_SUCCESS(Status) ) {
            if ( Status == ERROR_INVALID_PARAMETER ) {
                // This isn't fatal. Just ignore this one credential
            } else {
                WinStatus = RtlNtStatusToDosError( Status );
                goto Cleanup;
            }

        //
        // Put it on a local list until we finish reading the entire log file
        //

        } else {
            InsertTailList( &CredentialList, &TempCredential->Next );
        }


        //
        // Move to the next entry.
        //

        CredEntry = (PMARSHALED_CREDENTIAL)(((LPBYTE)CredEntry) + CredEntry->EntrySize);
    }


    WinStatus = NO_ERROR;


    //
    // Be tidy.
    //
Cleanup:

    if ( !CritSectLocked ) {
        RtlEnterCriticalSection( &CredentialSets->UserCredentialSets->CritSect );
    }

    //
    // Free the temp buffer
    //

    if ( LocalCredBlob != NULL ) {
        RtlSecureZeroMemory( LocalCredBlob, LocalCredBlobSize );
        SafeAllocaFree( LocalCredBlob );
    }

    //
    // If the file cannot be read,
    //  that's not really an error.
    //

    if ( WinStatus == ERROR_INVALID_DATA ) {
        // Leave it lying around to allow debugging.
        WinStatus = NO_ERROR;
    }

    //
    // If we're successful so far,
    //  add the temporary credential list to the in-memory credential set.
    //

    if ( WinStatus == NO_ERROR ) {


        //
        // Loop through the credentials adding them to the in-memory credential set.
        //

        while ( !IsListEmpty( &CredentialList ) ) {

            ListEntry = RemoveHeadList( &CredentialList );

            TempCredential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

            //
            // If this is a domain password cred,
            //  and the username on the cred matches the logon username,
            //  mark the cred to indicate that the logon password is to be used.
            //
            // Basically, there is no way to ensure that the CredBlob on the credential is
            //  up to date.  So, use the password on the logon session.
            //

            if ( TempCredential->Cred.Type == CRED_TYPE_DOMAIN_PASSWORD ) {
                ULONG Index;

                for ( Index = 0; Index<UserNameCount; Index++ ) {

                    if ( RtlEqualUnicodeString( &UserNames[Index],
                                                &TempCredential->UserName,
                                                TRUE ) ) {
                        TempCredential->UseLogonPassword = TRUE;
                        break;
                    }
                }


            }

            //
            // Write it to the credential set
            //

            Status = CredpWriteCredential( CredentialSets,
                                           &TempCredential,
                                           TRUE,    // Creds are from persisted file
                                           FALSE,   // Don't update pin in CSP
                                           FALSE,   // Creds have not been prompted for
                                           0,       // No flags
                                           NULL );

            if ( !NT_SUCCESS( Status )) {
                LsapFreeLsaHeap( TempCredential );

                //
                // Remember the status.  But continue on.
                //
                WinStatus = RtlNtStatusToDosError( Status );
            }

        }
    }

    //
    // Cleanup temporary credential list
    //
    while ( !IsListEmpty( &CredentialList ) ) {

        ListEntry = RemoveHeadList( &CredentialList );

        TempCredential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

        LsapFreeLsaHeap( TempCredential );

    }


    //
    // Clear the buffer with clear text passwords in it
    //

    if ( CredSetBuffer != NULL ) {
        RtlZeroMemory( CredSetBuffer, CredSetBufferSize );
        LocalFree( CredSetBuffer );
    }

    if ( EncryptedBlob != NULL ) {
        SafeAllocaFree( EncryptedBlob );
    }

    if ( FilePath != NULL ) {
        LsapFreeLsaHeap( FilePath );
    }
    if ( FileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( FileHandle );
    }

    if ( Attributes != NULL ) {
        LsapFreeLsaHeap( Attributes );
        Attributes = NULL;
    }

    if ( UserNames != NULL ) {
        LsapFreeLsaHeap( UserNames );
    }

    return WinStatus;

}

VOID
CredpLockCredSets(
    IN PCREDENTIAL_SETS CredentialSets
    )

/*++

Routine Description:

    This routine locks a set of credential sets.

Arguments:

    CredentialSets - Credential set to lock

Return Values:

    None.

--*/

{
    DWORD WinStatus;

    //
    // Lock the credential set.
    //
    // There's one crit sect the proctects all of the cred sets for the user.
    // We could introduce one crit sect per credential set, but the user-wide crit
    // sect would always be locked along with one of the session crit sects.
    // So, the session crit sect would be wasted.
    //

    RtlEnterCriticalSection( &CredentialSets->UserCredentialSets->CritSect );


}

VOID
CredpUnlockAndFlushCredSets(
    IN PCREDENTIAL_SETS CredentialSets
    )

/*++

Routine Description:

    This routine unlocks a set of credential sets and flushes it to disk if dirty.

Arguments:

    CredentialSets - Credential set to lock

Return Values:

    None.

--*/

{
    PCREDENTIAL_SET CredentialSet;
    PCANONICAL_CREDENTIAL Credential;
    PLIST_ENTRY ListEntry;
    ULONG Persist;

    //
    // Loop through the list of credential sets persisting each
    //

    for ( Persist=CRED_PERSIST_MIN; Persist <= CRED_PERSIST_MAX; Persist++ ) {

        //
        // Ignore non-persistent credential sets
        //

        if ( Persist == CRED_PERSIST_SESSION ) {
            continue;
        }

        CredentialSet = PersistToCredentialSet( CredentialSets, Persist );



        //
        // If the credential set is dirty,
        //  flush it.
        //

        if ( CredentialSet->Dirty ) {

            //
            // Indicate that the credential set is no longer dirty.
            //  But increment that count of times that it has been dirty.
            //

            CredentialSet->Dirty = FALSE;
            CredentialSet->WriteCount ++;

            //
            // If no other thread is already writing it,
            //  we'll take on that responsibility.
            //
            //  Otherwise, let that thread write it again.
            //

            if ( !CredentialSet->BeingWritten ) {

                ULONG WriteCount;

                //
                // Tell other threads that we're writing
                //

                CredentialSet->BeingWritten = TRUE;

                //
                // Loop writing the credentials
                //

                do {
                    LPBYTE CredSetBuffer;
                    ULONG CredSetBufferSize;
                    LPWSTR FilePath;
                    LPWSTR FileName = CREDENTIAL_FILE_NAME;
                    DWORD WinStatus;

                    //
                    // Remember which snapshot we're writing.
                    //
                    WriteCount = CredentialSet->WriteCount;
                    FilePath = NULL;

                    //
                    // Grab a marshaled copy of the credential set
                    //

                    if ( !CredpMarshalCredentials( CredentialSet,
                                                   &CredSetBufferSize,
                                                   &CredSetBuffer ) ) {
                        //
                        // If we can't, mark them dirty for the next caller to flush
                        //
                        CredentialSet->Dirty = TRUE;
                        continue;
                    }

                    //
                    // Drop the lock while we're doing the write.  DPAPI accesses network resources
                    //  while encrypting.  We don't want to hold up cred set access just because the
                    //  network is slow.
                    //

                    RtlLeaveCriticalSection( &CredentialSets->UserCredentialSets->CritSect );

                    //
                    // Get the name of the path to write the cred set to
                    //

                    WinStatus = GetUserStorageArea(
                            (Persist == CRED_PERSIST_ENTERPRISE ? FALSE : TRUE),
                            CredentialSets->UserCredentialSets->UserSid,
                            &FilePath );

                    if ( WinStatus != NO_ERROR ) {
                        DebugLog(( DEB_TRACE_CRED,
                                   "CredpUnlockAndFlushCredSets: Cannot determine path to profile: %ld.\n",
                                   WinStatus ));

                    } else {

                        //
                        // If the buffer is zero length,
                        //  just delete the file
                        //

                        if ( CredSetBufferSize == 0 ) {

                            WinStatus = DeleteFileInStorageArea( FilePath, FileName );

                            if ( WinStatus != NO_ERROR ) {
                                if ( WinStatus == ERROR_FILE_NOT_FOUND ||
                                     WinStatus == ERROR_PATH_NOT_FOUND ) {
                                    WinStatus = NO_ERROR;
                                } else {
                                    DebugLog(( DEB_TRACE_CRED,
                                               "CredpUnlockAndFlushCredSets: Cannot delete %ls\\%ls: %ld.\n",
                                               FilePath,
                                               FileName,
                                               WinStatus ));
                                }
                            }


                        //
                        // Otherwise, write data to the file.
                        //
                        } else {
                            PVOID EncryptedBlob;
                            ULONG EncryptedBlobSize;
                            UNICODE_STRING DescriptionString;

                            //
                            // Encrypt the data
                            //

                            RtlInitUnicodeString( &DescriptionString,
                                                  Persist == CRED_PERSIST_ENTERPRISE ?
                                                        L"Enterprise Credential Set" :
                                                        L"Local Credential Set" );

                            if ( !LsaICryptProtectData(
                                                    CredSetBuffer,
                                                    CredSetBufferSize,
                                                    &DescriptionString,
                                                    NULL,    // No additional entropy
                                                    0,
                                                    NULL,    // Must be NULL
                                                    NULL,    // Must be NULL
                                                    CRYPTPROTECT_SYSTEM |         // Cannot be decrypted by usermode app
                                                      CRYPTPROTECT_UI_FORBIDDEN,  // No UI allowed
                                                    &EncryptedBlob,
                                                    &EncryptedBlobSize ) ) {

                                WinStatus = GetLastError();

                                DebugLog(( DEB_TRACE_CRED,
                                           "CredpUnlockAndFlushCredSets: Cannot CryptProtectData: 0x%lx.\n",
                                           WinStatus ));


                            } else {

                                HANDLE FileHandle;


                                //
                                // Open the file
                                //

                                WinStatus = OpenFileInStorageArea(
                                                GENERIC_WRITE,
                                                FilePath,
                                                FileName,
                                                &FileHandle );

                                if ( WinStatus == NO_ERROR ) {
                                    ULONG BytesWritten;

                                    //
                                    // Write the file
                                    //

                                    if ( !WriteFile( FileHandle,
                                                     EncryptedBlob,
                                                     EncryptedBlobSize,
                                                     &BytesWritten,
                                                     NULL ) ) {  // Not Overlapped

                                        WinStatus = GetLastError();
                                        DebugLog(( DEB_TRACE_CRED,
                                                   "CredpUnlockAndFlushCredSets: Cannot write %ls\\%ls: %ld.\n",
                                                   FilePath,
                                                   FileName,
                                                   WinStatus ));
                                    } else {
                                        if ( BytesWritten !=  EncryptedBlobSize ) {
                                            DebugLog(( DEB_TRACE_CRED,
                                                       "CredpUnlockAndFlushCredSets: Cannot write all of %ls\\%ls: %ld %ld.\n",
                                                       FilePath,
                                                       FileName,
                                                       EncryptedBlobSize,
                                                       BytesWritten ));

                                            WinStatus = ERROR_INSUFFICIENT_BUFFER;
                                        }
                                    }

                                    CloseHandle( FileHandle );

                                }

                                LocalFree( EncryptedBlob );

                            }
                        }

                    }


                    //
                    // If we failed to write for any reason,
                    //  ensure the next caller does the flush.
                    //

                    if ( WinStatus != NO_ERROR ) {
                        CredentialSet->Dirty = TRUE;
                    }


                    //
                    // Clear the buffer with clear text passwords in it
                    //

                    if ( CredSetBufferSize != 0 ) {
                        RtlZeroMemory( CredSetBuffer, CredSetBufferSize );
                        LsapFreeLsaHeap( CredSetBuffer );
                    }

                    //
                    // Free any other resources
                    //

                    if ( FilePath != NULL ) {
                        LsapFreeLsaHeap( FilePath );
                    }

                    //
                    // Grab the lock again to see if we need to write again
                    //

                    RtlEnterCriticalSection( &CredentialSets->UserCredentialSets->CritSect );

                } while ( CredentialSet->WriteCount != WriteCount );

                //
                // Tell other threads that we're no longer writing
                //

                CredentialSet->BeingWritten = FALSE;

            }

        }
    }

    //
    // Unlock the credential set.
    //

    RtlLeaveCriticalSection( &CredentialSets->UserCredentialSets->CritSect );
}


PCANONICAL_CREDENTIAL
CredpFindCredential(
    IN PCREDENTIAL_SETS CredentialSets,
    IN PUNICODE_STRING TargetName,
    IN ULONG Type
    )

/*++

Routine Description:

    This routine finds a named credential in a credential set.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSet - Credential set list to find the credential in.

    TargetName - Name of the credential to find.

    Type - Type of the credential to find.

Return Values:

    Returns a pointer to the named credential.  This pointer my be used as long as
    UserCredentialSets->CritSect remains locked.

    NULL: There is no such credential.

--*/
{
    PCREDENTIAL_SET CredentialSet;
    PCANONICAL_CREDENTIAL Credential;
    PLIST_ENTRY ListEntry;
    ULONG Persist;

    //
    // Ignore queries for unsupported cred types
    //

    if ( CredDisableDomainCreds &&
         CredpIsDomainCredential( Type ) ) {

        return NULL;

    }

    //
    // Loop through the list of credentials trying to find this one.
    //

    for ( Persist=CRED_PERSIST_MIN; Persist <= CRED_PERSIST_MAX; Persist++ ) {

        //
        // If the profile has not yet been loaded by this session,
        //  ignore any credentials loaded by another session.
        //

        if ( Persist != CRED_PERSIST_SESSION &&
             !CredentialSets->SessionCredSets->ProfileLoaded ) {
            continue;
        }

        CredentialSet = PersistToCredentialSet( CredentialSets, Persist );

        for ( ListEntry = CredentialSet->Credentials.Flink ;
              ListEntry != &CredentialSet->Credentials;
              ListEntry = ListEntry->Flink) {

            Credential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

            if ( Type == Credential->Cred.Type &&
                 RtlEqualUnicodeString( TargetName,
                                        &Credential->TargetName,
                                        TRUE ) ) {
                return Credential;
            }

        }
    }

    return NULL;
}

NTSTATUS
CredpWritePinToCsp(
    IN PCREDENTIAL_SETS CredentialSets,
    IN PCANONICAL_CREDENTIAL Credential
    )
/*++

Routine Description:

    This routine write a PIN to the CSP.  CSPs implement the rules for the lifetime of
    the PIN.  Cred manager therefore doesn't hold onto the PIN, but rather gives it to
    the CSP to manage.

    The caller must be impersonating the logged on user owning the cred set.

Arguments:

    CredentialSets - Credential set the credential is in.

    Credential - Specifies the credential whose PIN is to be written.

Return Values:

    The following status codes may be returned:

        STATUS_SUCCESS - The PIN was stored successfully.
            Or the credential isn't a cert credential.

        STATUS_INVALID_PARAMETER

        STATUS_INVALID_PARAMETER - Certain fields may not be changed in an
            existing credential.  If such a field does not match the value
            specified in the existing credential, this error is returned.

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.
            Returned only if CRED_PRESERVE_CREDENTIAL_BLOB was specified.

--*/

{
    NTSTATUS Status;
    DWORD WinStatus;

    CRED_MARSHAL_TYPE CredType;
    PCERT_CREDENTIAL_INFO CredInfo;

    CRYPT_HASH_BLOB HashBlob;

    HCERTSTORE CertStoreHandle = NULL;
    PCCERT_CONTEXT CertContext = NULL;

    ULONG ProviderInfoSize;
    PCRYPT_KEY_PROV_INFO ProviderInfo = NULL;

    ULONG_PTR RedirectedProviderHandle = NULL;

    UNICODE_STRING UnicodePin;
    ANSI_STRING AnsiPin;
    BOOLEAN ClearPin = FALSE;

    CERT_KEY_CONTEXT CertKeyContext;

    //
    // Initialization
    //

    RtlInitAnsiString( &AnsiPin, NULL );

    //
    // Ignore credentials that aren't certificate credentials
    //

    if ( Credential->Cred.Type != CRED_TYPE_DOMAIN_CERTIFICATE ) {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Ignore pins of zero length.
    //
    // Either the caller is writing the cred and doesn't know the PIN yet.
    // Or this cert has no PIN.
    //

    if ( Credential->Cred.CredentialBlobSize == 0 ) {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // If the profile hasn't been loaded,
    //  fail now.
    //
    // The "My" store open will fail below and it'd be better to give a good error code.
    //

    ClearPin = TRUE;
    if ( !CredentialSets->SessionCredSets->ProfileLoaded ) {

        Status = SCARD_E_NO_SUCH_CERTIFICATE;

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWritePinToCsp: %ws: Cannot write PIN to cert since profile isn't loaded: 0x%lx.\n",
                   Credential->Cred.UserName,
                   Status ));

        goto Cleanup;

    }

    //
    // Convert the UserName of the credential to a hash of the cert
    //
    if (!CredUnmarshalCredentialW(
            Credential->Cred.UserName,
            &CredType,
            (PVOID *)&CredInfo ) ) {

        WinStatus = GetLastError();

        if ( WinStatus == ERROR_INVALID_PARAMETER ) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            Status = NetpApiStatusToNtStatus(WinStatus);
        }

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWritePinToCsp: %ws: Cannot unmarshal user name of cert cred: 0x%lx.\n",
                   Credential->Cred.UserName,
                   Status ));

        goto Cleanup;
    }

    if ( CredType != CertCredential ) {

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWritePinToCsp: %ws: cred isn't cert cred: %ld.\n",
                   Credential->Cred.UserName,
                   CredType ));

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Open a cert store
    //

    CertStoreHandle = CertOpenStore(
                        CERT_STORE_PROV_SYSTEM_W,
                        0,
                        0,
                        CERT_SYSTEM_STORE_CURRENT_USER,
                        L"MY");

    if ( CertStoreHandle == NULL ) {

        WinStatus = GetLastError();

        if ( HRESULT_FACILITY(WinStatus) == FACILITY_SCARD ) {
            Status = WinStatus;
        } else {
            Status = NetpApiStatusToNtStatus(WinStatus);
        }

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWritePinToCsp: %ws: cannot open cert store: %ld 0x%lx.\n",
                   Credential->Cred.UserName,
                   WinStatus,
                   WinStatus ));

        goto Cleanup;

    }

    //
    // Find the cert in the store which meets this hash
    //

    HashBlob.cbData = sizeof(CredInfo->rgbHashOfCert);
    HashBlob.pbData = CredInfo->rgbHashOfCert;

    CertContext = CertFindCertificateInStore(
                                        CertStoreHandle,
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        0,
                                        CERT_FIND_HASH,
                                        &HashBlob,
                                        NULL );

    if ( CertContext == NULL ) {

        WinStatus = GetLastError();

        if ( HRESULT_FACILITY(WinStatus) == FACILITY_SCARD ) {
            Status = WinStatus;
        } else if ( WinStatus == CRYPT_E_NOT_FOUND ) {
            Status = SCARD_E_NO_SUCH_CERTIFICATE;
        } else {
            Status = NetpApiStatusToNtStatus(WinStatus);
        }

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWritePinToCsp: %ws: cannot find cert: %ld 0x%lx.\n",
                   Credential->Cred.UserName,
                   WinStatus,
                   WinStatus ));

        goto Cleanup;
    }

    //
    // Get a handle to the private key
    //

    Status = __ScHelper_CryptAcquireCertificatePrivateKey(
                                        CertContext,
                                        &RedirectedProviderHandle,
                                        &WinStatus  );

    if ( !NT_SUCCESS( Status )) {

        if ( WinStatus == NTE_BAD_KEYSET ) {
            // Some CSPs (Schlumberger Cryptoflex) return the wrong status
            Status = SCARD_W_REMOVED_CARD;

        } else if ( HRESULT_FACILITY(WinStatus) == FACILITY_SECURITY ||
                    HRESULT_FACILITY(WinStatus) == FACILITY_SCARD ) {
            Status = WinStatus;

        } else if ( WinStatus == 0 ) {
            // do nothing, since Status already contains an error
        } else {
            Status = NetpApiStatusToNtStatus(WinStatus);
        }

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWritePinToCsp: %ws: cannot CryptAcquireCertificatePrivateKey: %ld 0x%lx.\n",
                   Credential->Cred.UserName,
                   WinStatus,
                   WinStatus ));

        goto Cleanup;

    }



    //
    // Convert the pin to ANSI
    //

    LsaUnprotectMemory( Credential->Cred.CredentialBlob,
                        Credential->Cred.CredentialBlobSize );

    UnicodePin.Buffer = (LPWSTR) Credential->Cred.CredentialBlob;
    UnicodePin.Length = (USHORT) Credential->ClearCredentialBlobSize;
    UnicodePin.MaximumLength = (USHORT) Credential->ClearCredentialBlobSize;

    Status = RtlUnicodeStringToAnsiString( &AnsiPin,
                                           &UnicodePin,
                                           TRUE );

    LsaProtectMemory( Credential->Cred.CredentialBlob,
                      Credential->Cred.CredentialBlobSize );

    if ( !NT_SUCCESS( Status )) {

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWritePinToCsp: %ws: Cannot convert PIN '%wZ' to ANSI: 0x%lx.\n",
                   Credential->Cred.UserName,
                   &UnicodePin,
                   Status ));

        goto Cleanup;
    }

    //
    // Set the pin in the provider
    //

    Status = __ScHelper_CryptSetProvParam(  RedirectedProviderHandle,
                                            AnsiPin.Buffer,
                                            &WinStatus  );

    if ( !NT_SUCCESS( Status )) {

        //
        // Some certs don't require a PIN
        //

        if ( WinStatus == NTE_BAD_TYPE ) {

            //
            // If the caller didn't pass us a PIN,
            //  we're fine.
            //

            if ( AnsiPin.Length == 0 ) {
                WinStatus = NO_ERROR;

            //
            // If the caller did pass us a PIN,
            //  tell him.
            //
            } else {

                WinStatus = ERROR_INVALID_PASSWORD;
            }
        }

        if ( HRESULT_FACILITY(WinStatus) == FACILITY_SCARD ) {
            Status = WinStatus;

        } else if ( WinStatus == ERROR_ACCOUNT_DISABLED ) {
            // Some CSPs (Schlumberger Cryptoflex) return the wrong status
            Status = SCARD_W_CHV_BLOCKED;

        } else if ( WinStatus == 0 ) {
            // do nothing, since Status already contains an error
        } else {
            Status = NetpApiStatusToNtStatus(WinStatus);
        }

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWritePinToCsp: %ws: cannot CryptSetProvParam: %ld 0x%lx.\n",
                   Credential->Cred.UserName,
                   WinStatus,
                   WinStatus ));

        goto Cleanup;
    }


    Status = STATUS_SUCCESS;

    //
    // Free any locally used resources
    //
Cleanup:
    //
    // The whole reason we wrote the PIN to the CSP was so that cred man wouldn't store it.
    //  So clear it.
    //
    if ( ClearPin ) {
        if ( Credential->Cred.CredentialBlob != NULL &&
             Credential->Cred.CredentialBlobSize != 0 ) {
            RtlZeroMemory( Credential->Cred.CredentialBlob,
                           Credential->Cred.CredentialBlobSize );

        }

        Credential->Cred.CredentialBlob = NULL;
        Credential->Cred.CredentialBlobSize = 0;
        Credential->ClearCredentialBlobSize = 0;
        // Cred it already marked dirty
    }

    if ( AnsiPin.Buffer != NULL ) {
        RtlSecureZeroMemory( AnsiPin.Buffer, AnsiPin.Length );
        RtlFreeAnsiString( &AnsiPin );
    }

    if ( RedirectedProviderHandle != NULL ) {
        __ScHelper_CryptReleaseContext( RedirectedProviderHandle );
    }

    if (NULL != ProviderInfo) {
        LsapFreeLsaHeap( ProviderInfo );
    }

    if ( CertContext != NULL ) {
        CertFreeCertificateContext( CertContext );
    }

    if ( CertStoreHandle != NULL ) {
        CertCloseStore( CertStoreHandle, 0 );
    }

    return Status;

}


VOID
CredpUndo(
    IN PCREDENTIAL_SETS CredentialSets,
    IN PCRED_WRITE_UNDO CredUndo
    )

/*++

Routine Description:

    This routine undoes a previous CredpWriteCredential.

    Some callers of CredpWriteCredential need to perform other operations after the
    call to CredpWriteCredential.  Those operations may fail requiring that the
    CredpWriteCredential be backed out.  This routine backs out the call.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSets - Credential set to write the credential in.

    CredUndo - Specifies the operation to undo

Return Values:

    None - This operation cannot fail

--*/

{

    //
    // Remove the new credential from the cred set.
    //

    ASSERT( CredUndo->NewCredential != NULL );
    RemoveEntryList( &CredUndo->NewCredential->Next );
    // LsapFreeLsaHeap( CredUndo->NewCredential );  The caller is still responsible for this

    //
    // Remove the new prompt data from the cred set.
    //

    if ( CredUndo->NewPromptData != NULL ) {
        RemoveEntryList( &CredUndo->NewPromptData->Next );
        LsapFreeLsaHeap( CredUndo->NewPromptData );
    }

    //
    // Put the old credential back in the cred set.
    //

    if ( CredUndo->OldCredential != NULL ) {
        InsertHeadList(
            &PersistToCredentialSet( CredentialSets, CredUndo->OldCredential->Cred.Persist )->Credentials,
            &CredUndo->OldCredential->Next );
        CredUndo->OldCredential = NULL;
    }

    //
    // Put the old prompt data back in the cred set.
    //

    if ( CredUndo->OldPromptData != NULL ) {
        InsertHeadList(
            &CredentialSets->SessionCredSets->PromptData,
            &CredUndo->OldPromptData->Next );
        CredUndo->OldPromptData = NULL;
    }

}

VOID
CredpUndoFree(
    IN PCRED_WRITE_UNDO CredUndo
    )

/*++

Routine Description:

    This routine frees the undo structure returned from CredpWriteCredential.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredUndo - Specifies the operation to undo

Return Values:

    None - This operation cannot fail

--*/

{

    //
    // Free the old credential
    //

    if ( CredUndo->OldCredential != NULL ) {
        LsapFreeLsaHeap( CredUndo->OldCredential );
    }

    //
    // Free the old prompt data
    //

    if ( CredUndo->OldPromptData != NULL ) {
        LsapFreeLsaHeap( CredUndo->OldPromptData );
    }

    //
    // Free the undo structure itself
    //

    LsapFreeLsaHeap( CredUndo );

}


NTSTATUS
CredpWriteCredential(
    IN PCREDENTIAL_SETS CredentialSets,
    IN OUT PCANONICAL_CREDENTIAL *NewCredential,
    IN BOOLEAN FromPersistedFile,
    IN BOOLEAN WritePinToCsp,
    IN BOOLEAN PromptedFor,
    IN DWORD Flags,
    OUT PCRED_WRITE_UNDO *RetCredUndo OPTIONAL
    )

/*++

Routine Description:

    The routine writes a credential to a credential set.  If the credential
    replaces an existing credential, the existing credential is delinked and
    returned to the caller.

    On entry, UserCredentialSets->CritSect must be locked.  (This design ensures
    Credential is valid upon return from the routine.)

Arguments:

    CredentialSets - Credential set to write the credential in.

    NewCredential - Specifies the credential to be written.
        If CRED_PRESERVE_CREDENTIAL_BLOB is specified, the Credential returned in this
        parameter will contain the preserved credential blob. The original credential will be
        deleted.

        If CRED_PRESERVE_CREDENTIAL_BLOB is not specified, this field will not be modified.

    FromPersistedFile - True if the credential is from a persisted file.
        Less validation is done on the credential.

    WritePinToCsp - True if the password is explicitly being set.
        If true, the PIN of certificate credentials is to be written to the CSP.
        Callers that are simply updating the in-memory credential will set this false.

    PromptedFor - Specifies whether Credential has already been prompted for

    Flags - Specifies flags to control the operation of the API.
        The following flags are defined:

        CRED_PRESERVE_CREDENTIAL_BLOB: The credential blob should be preserved from the
            already existing credential with the same credential name and credential type.

    RetCredUndo - If Specified, returns a pointer to the data needed to undo this operation.
        CredUndo should be freed by calling CredpUndoFree().  Prior to that CredpUndo() may
        be called to undo the CredpWriteCredential.
        UserCredentialSets->CritSect must be remain locked until after CredpUndo() is called.

Return Values:

    The following status codes may be returned:

        STATUS_INVALID_PARAMETER - Certain fields may not be changed in an
            existing credential.  If such a field does not match the value
            specified in the existing credential, this error is returned.

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.
            Returned only if CRED_PRESERVE_CREDENTIAL_BLOB was specified.

--*/

{
    NTSTATUS Status;
    PCANONICAL_CREDENTIAL Credential = *NewCredential;
    PCANONICAL_CREDENTIAL TempCredential;
    PPROMPT_DATA TempPromptData;
    PPROMPT_DATA PromptData = NULL;
    PCRED_WRITE_UNDO CredUndo = NULL;

    //
    // Initialization
    //

    if ( RetCredUndo != NULL ) {
        *RetCredUndo = NULL;
    }

    //
    // Allocate an undo structure
    //

    CredUndo = (PCRED_WRITE_UNDO)LsapAllocateLsaHeap( sizeof(*CredUndo) );

    if ( CredUndo == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }



    //
    // If the profile hasn't been loaded yet,
    //  don't allow writing to persistent credential sets.
    //

    if ( Credential->Cred.Persist != CRED_PERSIST_SESSION &&
         !FromPersistedFile &&
         !CredentialSets->SessionCredSets->ProfileLoaded ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWriteCredential: Cannot write persistent cred set until profile loaded: %ld.\n",
                   Credential->Cred.Persist ));

        goto Cleanup;

    }

    //
    // If domain creds have been disabled,
    //  don't allow them to be written.
    //

    if ( CredDisableDomainCreds &&
         !FromPersistedFile &&
         CredpIsDomainCredential( Credential->Cred.Type ) ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWriteCredential: Cannot write domain cred when feature is disabled: %ld.\n",
                   Credential->Cred.Type ));

        goto Cleanup;

    }

    //
    // If this is a personal system,
    //  and this is a domain credential other than the *Session cred,
    //  don't allow them to be written.
    //

    if ( CredIsPersonal &&
         CredpIsDomainCredential( Credential->Cred.Type ) &&
         Credential->Cred.Type != CRED_TYPE_DOMAIN_VISIBLE_PASSWORD &&
         Credential->WildcardType != WcUniversalSessionWildcard ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWriteCredential: Cannot write domain cred on personal: %ld.\n",
                   Credential->Cred.Type ));

        goto Cleanup;
    }

    //
    // Don't allow * credential if the user is logged onto a domain account.
    //  In that case, the system uses the logon session credential for several purposes
    //  and the * credential masks that.
    //

    if ( Credential->WildcardType == WcUniversalWildcard &&
         (CredentialSets->Flags & CREDSETS_FLAGS_LOCAL_ACCOUNT) == 0 ) {

        Status = STATUS_INVALID_PARAMETER;

        DebugLog(( DEB_TRACE_CRED,
                   "CredpWriteCredential: Cannot write '*' cred when logged onto domain account.\n" ));

        goto Cleanup;
    }

    //
    // Allocate PromptData if user is writing an always prompt credential
    //  Assume that the user only writes such a credential because he was prompted for a password.
    //

    if ( !FromPersistedFile &&
         !PersistCredBlob( &Credential->Cred ) ) {

        PromptData = CredpAllocatePromptData( Credential );

        if ( PromptData == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

    }

    //
    // Find any existing credential by the same name.
    //

    TempCredential = CredpFindCredential(
                            CredentialSets,
                            &Credential->TargetName,
                            Credential->Cred.Type );


    //
    // Find any prompt data for the existing credential
    //
    // There are cases where there is prompt data and no credential.  That'd be the case
    //  if a machine (or enterprise) credential is deleted from another session.
    //

    TempPromptData = CredpFindPromptData(
                        CredentialSets,
                        &Credential->TargetName,
                        Credential->Cred.Type,
                        TempCredential == NULL ?
                            Credential->Cred.Persist :
                            TempCredential->Cred.Persist );



    //
    // Preserve the credential blob from this credential by the same name.
    //

    if ( Flags & CRED_PRESERVE_CREDENTIAL_BLOB ) {

        ENCRYPTED_CREDENTIALW LocalCredential;
        PCANONICAL_CREDENTIAL CompleteCredential;

        //
        // Don't allow the caller to specify a credential blob if he asked us to preserve the existing one

        if ( Credential->Cred.CredentialBlobSize != 0 ) {

            DebugLog(( DEB_TRACE_CRED,
                       "CredpWriteCredential: %ws: Trying to preserve credential blob AND specify a new one.\n",
                       Credential->Cred.TargetName ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // If we need to preserve the blob,
        //  fail if there is no blob to preserve.
        //

        if ( TempCredential == NULL ) {

            DebugLog(( DEB_TRACE_CRED,
                       "CredpWriteCredential: %ws: Cannot write credential with preserved blob.\n",
                       Credential->Cred.TargetName ));
            Status = STATUS_NOT_FOUND;
            goto Cleanup;
        }

        //
        // Since we're preserving the existing credential blob,
        //  we know better than the caller whether the blob has been prompted for.
        //
        // If the existing credential has a persisted credential blob,
        //  then it has been prompted for.
        //
        // Otherwise, check whether we've already cached the credential in memory.
        //
        // (Use the PromptData for that to prevent leakage from another logon session.)
        //

        if ( PersistCredBlob( &TempCredential->Cred ) ) {
            PromptedFor = TRUE;
        } else {
            PromptedFor = !ShouldPromptNow( TempPromptData );
        }

        //
        // If the new credential isn't an always prompt credential, and
        //  there isn't a existing password on the credential,
        //  then the caller should have prompted for the credential and not asked us to preserve the old one.
        //

        if ( PromptData == NULL && !PromptedFor ) {

            DebugLog(( DEB_TRACE_CRED,
                       "CredpWriteCredential: %ws: Trying to preserve credential blob AND it hasn't been prompted for.\n",
                       Credential->Cred.TargetName ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }


        //
        // Build a new credential with the preserved credential blob in it.
        //

        LocalCredential.Cred = Credential->Cred;
        LocalCredential.Cred.CredentialBlob = TempCredential->Cred.CredentialBlob;
        LocalCredential.Cred.CredentialBlobSize = TempCredential->Cred.CredentialBlobSize;
        LocalCredential.ClearCredentialBlobSize = TempCredential->ClearCredentialBlobSize;

        //
        // Get a marshaled copy of the new credential
        //

        Status = CredpValidateCredential(
                            0,      // No flags (Password is encrypted via LsaProtectMemory)
                            NULL,   // Don't need to use TargetInfo again
                            &LocalCredential,
                            &CompleteCredential );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // Preserve the flag indicating to use the logon password
        //

        CompleteCredential->UseLogonPassword = TempCredential->UseLogonPassword;

        //
        // Use this new credential for the rest of the operation
        //

        LsapFreeLsaHeap( Credential );
        Credential = CompleteCredential;
        *NewCredential = Credential;

    }

    //
    // If this is a cert credential,
    //  write the pin into the CSP.
    //

    if ( WritePinToCsp ) {
        Status = CredpWritePinToCsp( CredentialSets, Credential );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

    }



    //
    // Delink the existing credential.
    //

    if ( TempCredential != NULL ) {

        RemoveEntryList( &TempCredential->Next );
        CredpMarkDirty( CredentialSets, TempCredential->Cred.Persist, NULL );

        CredUndo->OldCredential = TempCredential;
    }



    //
    // Delink existing prompt data
    //
    if ( TempPromptData != NULL ) {

        RemoveEntryList( &TempPromptData->Next );

        CredUndo->OldPromptData = TempPromptData;
    }

    //
    // Mark the credential as modified.
    //  Don't change the LastWritten date on restored credentials
    //

    CredpMarkDirty( CredentialSets,
                    Credential->Cred.Persist,
                    FromPersistedFile ? NULL : Credential );

    //
    // Link the prompt data
    //

    if ( PromptData != NULL ) {
        InsertHeadList( &CredentialSets->SessionCredSets->PromptData,
                        &PromptData->Next );

        CredUndo->NewPromptData = PromptData;

        PromptData->Written = PromptedFor;
        PromptData = NULL;
    }


    //
    // Link the new credential into the cred set.
    //

    if ( FromPersistedFile ) {
        // Preserve the order of the credentials in the file.
        InsertTailList(
            &PersistToCredentialSet( CredentialSets, Credential->Cred.Persist )->Credentials,
            &Credential->Next );
    } else {
        // Put new credentials early in the list where they can be found quickly
        InsertHeadList(
            &PersistToCredentialSet( CredentialSets, Credential->Cred.Persist )->Credentials,
            &Credential->Next );
    }

    CredUndo->NewCredential = Credential;

    //
    // Return the undo data to the caller
    //

    if ( RetCredUndo != NULL ) {
        *RetCredUndo = CredUndo;
        CredUndo = NULL;
    }

    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( PromptData != NULL ) {
        LsapFreeLsaHeap( PromptData );
    }

    if ( CredUndo != NULL ) {
        CredpUndoFree( CredUndo );
    }

    return Status;

}

NTSTATUS
CredpWriteMorphedCredential(
    IN PCREDENTIAL_SETS CredentialSets,
    IN ULONG CredFlags,
    IN BOOLEAN PromptedFor,
    IN PCANONICAL_TARGET_INFO TargetInfo OPTIONAL,
    IN PENCRYPTED_CREDENTIALW MorphedCredential,
    OUT PCANONICAL_CREDENTIAL *WrittenCredential
    )

/*++

Routine Description:

    This routine write a morphed credential to the credential set.

    Any credential by the same target name and type is delinked and deallocated.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSets - A pointer to the referenced credential set.

    CredFlags - Flags changing the behavior of the routine:
        CREDP_FLAGS_IN_PROCESS - Caller is in-process.  Limit to Session Creds.
            But allow to write OWF password and to create cert/password mapping.

        CREDP_FLAGS_CLEAR_PASSWORD - CredentialBlob data is passed in in the clear.
        CREDP_FLAGS_USER_ENCRYPTED_PASSWORD - CredentialBlob data is passed in protected via CredpEncodeCredential.
            If neither set, CredentialBlob data is passed in protected via LsapProtectMemory.

    PromptedFor - Specifies whether the MorphedCredential should be considered
        as having been prompted for.

    TargetInfo - A description of the various aliases for a target.

    MorphedCredential - Pointer to a credential to add to the credential set.

    WrittenCredential - On success, returns a pointer to the written credential.

Return Values:

    Sundry credential write status codes.

--*/

{
    NTSTATUS Status;
    PCANONICAL_CREDENTIAL ValidatedCredential;

    //
    // Get a marshaled copy of the new credential
    //

    Status = CredpValidateCredential(
                        CredFlags,
                        TargetInfo,
                        MorphedCredential,
                        &ValidatedCredential );

    if ( NT_SUCCESS(Status) ) {

        //
        // Write it to the credential set
        //

        Status = CredpWriteCredential( CredentialSets,
                                       &ValidatedCredential,
                                       FALSE,   // Creds are not from persisted file
                                       FALSE,   // Don't update pin in CSP
                                       PromptedFor, // Caller knows if cred has been prompted for
                                       0,       // No flags
                                       NULL );

        if ( NT_SUCCESS( Status )) {

            *WrittenCredential = ValidatedCredential;
        } else {
            LsapFreeLsaHeap( ValidatedCredential );
        }
    }

    return Status;
}

VOID
CredpUpdatePassword2(
    IN PCREDENTIAL_SETS CredentialSets,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password,
    IN DWORD CredType,
    IN DWORD CredFlag
    )

/*++

Routine Description:

    This routine updates the password in all credentials for UserName.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSets - A pointer to the referenced credential set.

    UserName - The UserName of the user.
        Same format as in credential.

    Password - New password for the user.
        This password should be passed in hidden via LsapProtectMemory.
        Length - Clear text length of the password
        MaximumLength - Encrypted length of the password

    CredType - Specifies the credential type to change the password on.
        This should be one of CRED_TYPE_DOMAIN_*
        
    CredFag - Specifies if the credential is a one way function password vs clear text.  
              The only flag of interest is CRED_FLAGS_OWF_CRED_BLOB

Return Values:

    None

--*/

{
    NTSTATUS Status;
    ULONG Persist;
    PCANONICAL_CREDENTIAL TempCredential;
    PCANONICAL_CREDENTIAL WrittenCredential;
    PLIST_ENTRY ListEntry;
    ENCRYPTED_CREDENTIALW LocalCredential;

    //
    // Ignore writes for unsupported cred types
    //

    if ( CredDisableDomainCreds &&
         CredpIsDomainCredential( CredType ) ) {

        return;

    }


    //
    // We do not update password in all other credentials if the new password
    // is OWF.  
    if(CredFlag & CRED_FLAGS_OWF_CRED_BLOB) {

        return;
    }

    //
    // Loop through the credentials finding those that match.
    //

    for ( Persist=CRED_PERSIST_MIN; Persist <= CRED_PERSIST_MAX; Persist++ ) {
        PCREDENTIAL_SET CredentialSet;

        //
        // If the profile has not yet been loaded by this session,
        //  ignore any credentials loaded by another session.
        //

        if ( Persist != CRED_PERSIST_SESSION &&
             !CredentialSets->SessionCredSets->ProfileLoaded ) {
            continue;
        }

        CredentialSet = PersistToCredentialSet( CredentialSets, Persist );

        for ( ListEntry = CredentialSet->Credentials.Flink ;
              ListEntry != &CredentialSet->Credentials;
              ) {


            // Grab a pointer to the next entry since this one may be delinked
            TempCredential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );
            ListEntry = ListEntry->Flink;


            //
            // Only do credentials of the type requested
            //
            if ( TempCredential->Cred.Type != CredType ) {
                continue;
            }


            //
            // Only do credentials with identical user names.
            //

            if ( TempCredential->UserName.Length == 0 ||
                 !RtlEqualUnicodeString( UserName,
                                         &TempCredential->UserName,
                                         TRUE ) ) {

                continue;
            }


            //
            // Only do credentials if the password doesn't match already
            //

            if ( Password->MaximumLength == TempCredential->Cred.CredentialBlobSize &&
                 Password->Length == TempCredential->ClearCredentialBlobSize &&
                 (Password->MaximumLength == 0 ||
                  RtlEqualMemory( Password->Buffer,
                                  TempCredential->Cred.CredentialBlob,
                                  Password->MaximumLength ) ) ) {

                continue;
            }

            //
            // Finally, update the credential to match the new one.
            //

            LocalCredential.Cred = TempCredential->Cred;
            LocalCredential.Cred.CredentialBlob = (LPBYTE)Password->Buffer;
            LocalCredential.Cred.CredentialBlobSize = Password->MaximumLength;
            LocalCredential.ClearCredentialBlobSize = Password->Length;

            //
            // Get a marshaled copy of the new credential
            //

            Status = CredpWriteMorphedCredential(
                                CredentialSets,
                                0,          // No Flags (Password is encrypted via LsaProtectMemory)
                                TRUE,       // Cred has been prompted for
                                NULL,       // No Target info since cred not for this target
                                &LocalCredential,
                                &WrittenCredential );


            //
            // Simply note success
            //
            if ( NT_SUCCESS(Status) ) {
                DebugLog((  DEB_TRACE_CRED,
                           "CredpUpdatePassword: %ws: Updated password for '%ws'.\n",
                           WrittenCredential->TargetName.Buffer,
                           UserName->Buffer ));
            }

        }

    }



}

VOID
CredpUpdatePassword(
    IN PCREDENTIAL_SETS CredentialSets,
    IN PCANONICAL_CREDENTIAL NewCredential
    )

/*++

Routine Description:

    This routine updates the password in all credentials to match that of the new credential.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    CredentialSets - A pointer to the referenced credential set.

    NewCredential - Pointer to a credential that was just added to the
        credential set.

Return Values:

    None

--*/

{
    NTSTATUS Status;
    UNICODE_STRING Password;


    //
    // If the credential isn't a domain credential,
    //  we're done.
    //

    if ( !CredpIsDomainCredential( NewCredential->Cred.Type ) ||
         NewCredential->UserName.Length == 0 ) {
        return;
    }

    //
    // Update the password on all matching credentials.
    //

    Password.Buffer = (LPWSTR)NewCredential->Cred.CredentialBlob;
    Password.Length = (USHORT)NewCredential->ClearCredentialBlobSize;
    Password.MaximumLength = (USHORT)NewCredential->Cred.CredentialBlobSize;

    CredpUpdatePassword2( CredentialSets,
                          &NewCredential->UserName,
                          &Password,
                          NewCredential->Cred.Type,
                          NewCredential->Cred.Flags );

}

VOID
CredpNotifyPasswordChange(
    IN PUNICODE_STRING NetbiosDomainName OPTIONAL,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DnsDomainName OPTIONAL,
    IN PUNICODE_STRING Upn OPTIONAL,
    IN PUNICODE_STRING NewPassword
    )

/*++

Routine Description:

    This routine updates the password of a particular user in the credential manager.

    This routine is called while impersonating the user changing the password.  That
    user isn't necessarily UserName.

Arguments:

    NetbiosDomainName - Netbios domain name of the user whose password was changed

    UserName - User name of the user whose password was changed

    DnsDomainName - If known, Dns Domain Name of the user whose password was changed

    Upn - If known, the Upn of the user whose password was changed

    NewPassword - The new password for the user.

Return Values:

    None

--*/
{
    HANDLE ClientToken;
    LUID LogonId;
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = { NULL };
    BOOLEAN CritSectLocked = FALSE;
    UNICODE_STRING LocalUserName;
    UNICODE_STRING EncryptedNewPassword;

    //
    // Got to have at least Netbios DomainName OR DNSDomainName
    //
    if (!ARGUMENT_PRESENT(NetbiosDomainName) &&
        !ARGUMENT_PRESENT(DnsDomainName)) {

        return;
    }

    //
    // Initialization
    //

    LocalUserName.Buffer = NULL;
    EncryptedNewPassword.Buffer = NULL;

    //
    // The password needs to be protected when we put it on the credential
    //

    EncryptedNewPassword.MaximumLength = AllocatedCredBlobSize( NewPassword->Length );
    EncryptedNewPassword.Length = NewPassword->Length;

    SafeAllocaAllocate( EncryptedNewPassword.Buffer, EncryptedNewPassword.MaximumLength );

    if ( EncryptedNewPassword.Buffer == NULL ) {
        goto Cleanup;
    }

    RtlZeroMemory( EncryptedNewPassword.Buffer, EncryptedNewPassword.MaximumLength );

    RtlCopyMemory( EncryptedNewPassword.Buffer,
                   NewPassword->Buffer,
                   NewPassword->Length );

    LsaProtectMemory( EncryptedNewPassword.Buffer, EncryptedNewPassword.MaximumLength );


    //
    // Get the logon id from the token
    //

    Status = NtOpenThreadToken( NtCurrentThread(),
                                TOKEN_QUERY,
                                TRUE,
                                &ClientToken );

    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    } else {
        TOKEN_STATISTICS TokenStats;
        ULONG ReturnedSize;

        //
        // Get the LogonId
        //

        Status = NtQueryInformationToken( ClientToken,
                                          TokenStatistics,
                                          &TokenStats,
                                          sizeof( TokenStats ),
                                          &ReturnedSize );

        if ( NT_SUCCESS( Status ) ) {

            //
            // Save the logon id
            //

            LogonId = TokenStats.AuthenticationId;
        }

        NtClose( ClientToken );

    }


    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( &LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;


    //
    // Update the password for all <NetbiosDomainName>\<UserName> credentials
    //

    if ( NetbiosDomainName != NULL ) {


        LocalUserName.Length = NetbiosDomainName->Length +
            sizeof(WCHAR) +
            UserName->Length;
        LocalUserName.MaximumLength = LocalUserName.Length;
        SafeAllocaAllocate( LocalUserName.Buffer, LocalUserName.MaximumLength );

        if ( LocalUserName.Buffer == NULL ) {
            goto Cleanup;
        }

        RtlCopyMemory( LocalUserName.Buffer, NetbiosDomainName->Buffer, NetbiosDomainName->Length );
        LocalUserName.Buffer[NetbiosDomainName->Length/sizeof(WCHAR)] = '\\';
        RtlCopyMemory( &LocalUserName.Buffer[(NetbiosDomainName->Length/sizeof(WCHAR)) + 1],
                       UserName->Buffer,
                       UserName->Length );


        CredpUpdatePassword2( &CredentialSets,
                              &LocalUserName,
                              &EncryptedNewPassword,
                              CRED_TYPE_DOMAIN_PASSWORD,
                              0 );      //CRED_FLAGS_OWF_CRED_BLOB should not be set

    }


    //
    // Update the password for all <DnsDomainName>\<UserName> credentials
    //

    if ( DnsDomainName != NULL ) {

        if ( LocalUserName.Buffer != NULL ) {
            SafeAllocaFree( LocalUserName.Buffer );
        }

        LocalUserName.Length = DnsDomainName->Length +
                               sizeof(WCHAR) +
                               UserName->Length;
        LocalUserName.MaximumLength = LocalUserName.Length;
        SafeAllocaAllocate( LocalUserName.Buffer, LocalUserName.MaximumLength );

        if ( LocalUserName.Buffer == NULL ) {
            goto Cleanup;
        }

        RtlCopyMemory( LocalUserName.Buffer, DnsDomainName->Buffer, DnsDomainName->Length );
        LocalUserName.Buffer[DnsDomainName->Length/sizeof(WCHAR)] = '\\';
        RtlCopyMemory( &LocalUserName.Buffer[(DnsDomainName->Length/sizeof(WCHAR)) + 1],
                       UserName->Buffer,
                       UserName->Length );


        CredpUpdatePassword2( &CredentialSets,
                              &LocalUserName,
                              &EncryptedNewPassword,
                              CRED_TYPE_DOMAIN_PASSWORD,
                              0 );    //CRED_FLAGS_OWF_CRED_BLOB should not be set
    }


    //
    // Update the password for all <Upn> credentials
    //

    if ( Upn != NULL ) {

        CredpUpdatePassword2( &CredentialSets,
                              Upn,
                              &EncryptedNewPassword,
                              CRED_TYPE_DOMAIN_PASSWORD,
                              0 );    //CRED_FLAGS_OWF_CRED_BLOB should not be set
    }


    //
    // Cleanup
    //
Cleanup:
    if ( LocalUserName.Buffer != NULL ) {
        SafeAllocaFree( LocalUserName.Buffer );
    }
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }
    CredpDereferenceCredSets( &CredentialSets );

    if ( EncryptedNewPassword.Buffer != NULL ) {
        RtlSecureZeroMemory( EncryptedNewPassword.Buffer, EncryptedNewPassword.MaximumLength );
        SafeAllocaFree( EncryptedNewPassword.Buffer );
    }

}


NTSTATUS
CredpFindBestCredentials(
    IN PLUID LogonId,
    IN ULONG CredFlags,
    IN PCREDENTIAL_SETS CredentialSets,
    IN PCANONICAL_TARGET_INFO TargetInfo,
    OUT PCANONICAL_CREDENTIAL *BestCredentials,
    OUT PULONG BestCredentialCount
    )

/*++

Routine Description:

    This routine finds the best credentials given a description of the target.

    On entry, UserCredentialSets->CritSect must be locked.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    CredFlags - Flags changing the behavior of the routine:
        CREDP_FLAGS_IN_PROCESS - Caller is in-process.  Don't find creds that match logon password

    CredentialSets - A pointer to the referenced credential set.

    TargetInfo - A description of the various aliases for a target.

    BestCredentials - Returns the best credential for each credential type.

    BestCredentialCount - Returns the number of elements returned in BestCredentials.

Return Values:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    PCANONICAL_CREDENTIAL Credential;
    PLIST_ENTRY ListEntry;

    ULONG TypeIndex;
    ULONG AliasIndex;

    ULONG Persist;


    //
    // This routine finds the best credentials for each credtype that match the TargetInfo.
    // This array contains the pointers to the found credentials.
    //

    PCANONICAL_CREDENTIAL SavedCredentials[CRED_TYPE_MAXIMUM];
    ULONG AliasIndices[CRED_TYPE_MAXIMUM];

    ULONG CredTypeCount;
    LPDWORD CredTypes;

    //
    // Clear our list of remembered credentials
    //

    RtlZeroMemory( SavedCredentials, sizeof(SavedCredentials) );
    for ( TypeIndex=0; TypeIndex<CRED_TYPE_MAXIMUM; TypeIndex++ ) {
        AliasIndices[TypeIndex] = CRED_MAX_ALIASES;
    }

    //
    // Loop through the list of credentials finding all that match the TargetInfo
    //
    for ( Persist=CRED_PERSIST_MIN; Persist <= CRED_PERSIST_MAX; Persist++ ) {

        PCREDENTIAL_SET CredentialSet;

        //
        // If the profile has not yet been loaded by this session,
        //  ignore any credentials loaded by another session.
        //

        if ( Persist != CRED_PERSIST_SESSION &&
             !CredentialSets->SessionCredSets->ProfileLoaded ) {
            continue;
        }

        CredentialSet = PersistToCredentialSet( CredentialSets, Persist );

        for ( ListEntry = CredentialSet->Credentials.Flink ;
              ListEntry != &CredentialSet->Credentials;
              ListEntry = ListEntry->Flink) {

            Credential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

            //
            // Ignore unsupported cred types
            //

            if ( CredDisableDomainCreds &&
                 CredpIsDomainCredential( Credential->Cred.Type ) ) {

                continue;
            }

            //
            // If the credential matches,
            //  save it.
            //

            if ( CredpCompareCredToTargetInfo( TargetInfo,
                                               Credential,
                                               &AliasIndex ) ) {

                //
                // Compute indices into the array of saved credentials.
                //
                // Rely on the following:
                //   CompareCred* validated that the cred is a domain cred
                //   CompareCred* only returns TRUE for well known CredType values.

                TypeIndex = Credential->Cred.Type;


                //
                // If we've already found a credential in this category,
                //  keep the "better" one.
                //

                if ( SavedCredentials[TypeIndex] != NULL ) {

                    DebugLog(( DEB_TRACE_CRED,
                               "CredpFindBestCredentials: %ws: %ws: Two credentials match same target info criterias.\n",
                               SavedCredentials[TypeIndex]->TargetName.Buffer,
                               Credential->TargetName.Buffer ));

                    //
                    // If the existing credential is more specific than this one,
                    //  Keep the existing.
                    //

                    if ( AliasIndices[TypeIndex] < AliasIndex ) {

                        DebugLog(( DEB_TRACE_CRED,
                                   "CredpFindBestCredentials: %ws: Use this one (AI1).\n",
                                   SavedCredentials[TypeIndex]->TargetName.Buffer ));
                        /* nothing to do here */

                    //
                    // If this credential is more specific than the saved one,
                    //  save this one.
                    //

                    } else if ( AliasIndices[TypeIndex] > AliasIndex ) {
                        SavedCredentials[TypeIndex] = Credential;
                        AliasIndices[TypeIndex] = AliasIndex;

                        DebugLog(( DEB_TRACE_CRED,
                                   "CredpFindBestCredentials: %ws: Use this one (AI2).\n",
                                   SavedCredentials[TypeIndex]->TargetName.Buffer ));

                    //
                    // If the existing credential has a more specific wildcard,
                    //  keep the existing.
                    //

                    } else if ( AliasIndex == CRED_WILDCARD_SERVER_NAME &&
                                SavedCredentials[TypeIndex]->TargetName.Length >
                                Credential->TargetName.Length ) {


                        DebugLog(( DEB_TRACE_CRED,
                                   "CredpFindBestCredentials: %ws: Use this one (WC1).\n",
                                   SavedCredentials[TypeIndex]->TargetName.Buffer ));
                        /* nothing to do here */

                    //
                    // If the existing credential has a less specific wildcard,
                    //  save this one.
                    //

                    } else if ( AliasIndex == CRED_WILDCARD_SERVER_NAME &&
                                SavedCredentials[TypeIndex]->TargetName.Length <
                                Credential->TargetName.Length ) {

                        SavedCredentials[TypeIndex] = Credential;
                        AliasIndices[TypeIndex] = AliasIndex;

                        DebugLog(( DEB_TRACE_CRED,
                                   "CredpFindBestCredentials: %ws: Use this one (WC2).\n",
                                   SavedCredentials[TypeIndex]->TargetName.Buffer ));

                    //
                    // If one credential has a target alias and the other doesn't,
                    //  keep the one without an alias,
                    //  this is the case when the target info passes in a netbios name
                    //  and there is both a netbios credential and a DNS credential.
                    //  Prefer the netbios credential.
                    //

                    } else if ( SavedCredentials[TypeIndex]->TargetAlias.Length == 0 ) {

                        DebugLog(( DEB_TRACE_CRED,
                                   "CredpFindBestCredentials: %ws: Use this one (AL).\n",
                                   SavedCredentials[TypeIndex]->TargetName.Buffer ));
                        /* nothing to do here */

                    //
                    // If one credential is session specific,
                    //  keep it (allowing the user to override persistent credentials).
                    //

                    } else if ( SavedCredentials[TypeIndex]->Cred.Persist == CRED_PERSIST_SESSION ) {

                        DebugLog(( DEB_TRACE_CRED,
                                   "CredpFindBestCredentials: %ws: Use this one (PE).\n",
                                   SavedCredentials[TypeIndex]->TargetName.Buffer ));
                        /* nothing to do here */

                    //
                    // Otherwise, just save this one
                    //

                    } else {
                        SavedCredentials[TypeIndex] = Credential;
                        AliasIndices[TypeIndex] = AliasIndex;

                        DebugLog(( DEB_TRACE_CRED,
                                   "CredpFindBestCredentials: %ws: Use this one (default).\n",
                                   Credential->TargetName.Buffer ));
                    }

                //
                // Otherwise, just save this one
                //

                } else {
                    SavedCredentials[TypeIndex] = Credential;
                    AliasIndices[TypeIndex] = AliasIndex;
                }

            }
        }

    }

    //
    // Don't return a *Session credential if our logon creds should work
    //
    // The *Session cred is a hack to force us to always use RAS dial creds on all
    //  connections to the dialed up network.  However, we don't know what network a
    //  server is on.  We still want to be able to use logon creds on the LAN.  Our
    //  best bet is to use logon creds if the server is in the same domain as our logon
    //  creds.
    //
    // If we found a domain cred,
    //  and that cred is the *Session cred,
    //  and the logon creds should work,
    //  ignore the *Session cred.
    //

    if ( (SavedCredentials[CRED_TYPE_DOMAIN_PASSWORD] != NULL  &&
          AliasIndices[CRED_TYPE_DOMAIN_PASSWORD] == CRED_UNIVERSAL_SESSION_NAME) ||
         (SavedCredentials[CRED_TYPE_DOMAIN_CERTIFICATE] != NULL  &&
              AliasIndices[CRED_TYPE_DOMAIN_CERTIFICATE] == CRED_UNIVERSAL_SESSION_NAME) ) {

        Status = CredpLogonCredsMatchTargetInfo( LogonId, TargetInfo );

        if ( NT_SUCCESS( Status )) {
            if ( AliasIndices[CRED_TYPE_DOMAIN_PASSWORD] == CRED_UNIVERSAL_SESSION_NAME ) {
                SavedCredentials[CRED_TYPE_DOMAIN_PASSWORD] = NULL;
            }
            if ( AliasIndices[CRED_TYPE_DOMAIN_CERTIFICATE] == CRED_UNIVERSAL_SESSION_NAME ) {
                SavedCredentials[CRED_TYPE_DOMAIN_CERTIFICATE] = NULL;
            }

        } else if ( Status != STATUS_NO_MATCH ) {
            return Status;
        }

    }

    //
    // Don't return password credentials to an in-process caller if the cred is so marked
    //

    if ( (CredFlags & CREDP_FLAGS_IN_PROCESS) != 0 &&
         SavedCredentials[CRED_TYPE_DOMAIN_PASSWORD] != NULL &&
         SavedCredentials[CRED_TYPE_DOMAIN_PASSWORD]->UseLogonPassword ) {

        SavedCredentials[CRED_TYPE_DOMAIN_PASSWORD] = NULL;

    }


    //
    // Decide the order to return the credentials in
    //

    if ( TargetInfo->CredTypeCount != 0 ) {

        // Use the order specified by the auth package
        CredTypeCount = TargetInfo->CredTypeCount;
        CredTypes = TargetInfo->CredTypes;

    } else {

        // Use the default order
        CredTypeCount = sizeof(CredTypeDefaultOrder)/sizeof(CredTypeDefaultOrder[0]);
        CredTypes = CredTypeDefaultOrder;

    }


    //
    // Return the credentials to the caller.
    //  Only return the ones requested by the caller
    //

    *BestCredentialCount = 0;

    for ( TypeIndex=0; TypeIndex<CredTypeCount; TypeIndex++ ) {

        ASSERT( CredTypes[TypeIndex] < CRED_TYPE_MAXIMUM );
        if ( CredTypes[TypeIndex] < CRED_TYPE_MAXIMUM ) {

            //
            // If we have a saved credential,
            //  return it.
            //

            if ( SavedCredentials[CredTypes[TypeIndex]] != NULL ) {
                BestCredentials[*BestCredentialCount] = SavedCredentials[CredTypes[TypeIndex]];
                *BestCredentialCount += 1;
            }
        }

    }

    Status = STATUS_SUCCESS;

    return Status;
}


extern "C"
NTSTATUS
CrediWrite(
    IN PLUID LogonId,
    IN ULONG CredFlags,
    IN PENCRYPTED_CREDENTIALW Credential,
    IN ULONG Flags
    )

/*++

Routine Description:

    The CredWrite API creates a new credential or modifies an existing
    credential in the user's credential set.  The new credential is
    associated with the logon session of the current token.  The token
    must not have the user's SID disabled.

    The CredWrite API creates a credential if none already exists by the
    specified TargetName.  If the specified TargetName already exists, the
    specified credential replaces the existing one.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    CredFlags - Flags changing the behavior of the routine:
        CREDP_FLAGS_IN_PROCESS - Caller is in-process.  Limit to Session Creds.
            But allow to write OWF password and to create cert/password mapping.

        CREDP_FLAGS_CLEAR_PASSWORD - CredentialBlob data is passed in in the clear.
        CREDP_FLAGS_USER_ENCRYPTED_PASSWORD - CredentialBlob data is passed in protected via CredpEncodeCredential.
            If neither set, CredentialBlob data is passed in protected via LsapProtectMemory.

        Note: The CredFlags parameter is internal to the LSA process.
            The Flags parameter is external to the process.

    Credential - Specifies the credential to be written.

    Flags - Specifies flags to control the operation of the API.
        The following flags are defined:

        CRED_PRESERVE_CREDENTIAL_BLOB: The credential blob should be preserved from the
            already existing credential with the same credential name and credential type.


Return Values:

    The following status codes may be returned:

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

        STATUS_INVALID_PARAMETER - Certain fields may not be changed in an
            existing credential.  If such a field does not match the value
            specified in the existing credential, this error is returned.

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.
            Returned only if CRED_PRESERVE_CREDENTIAL_BLOB was specified.

--*/

{
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = { NULL };
    PCRED_WRITE_UNDO CredUndo = NULL;
    PCANONICAL_CREDENTIAL PassedCredential = NULL;
    BOOLEAN CritSectLocked = FALSE;
    BOOLEAN CreatePasswordCredToo = FALSE;
    PCANONICAL_CREDENTIAL PasswordCredential;


    //
    // Validate the flags
    //

#define CREDP_WRITE_VALID_FLAGS CRED_PRESERVE_CREDENTIAL_BLOB

    if ( (Flags & ~CREDP_WRITE_VALID_FLAGS) != 0 ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Cleanup;
    }

    //
    // Validate the passed in credential
    //

    Status = CredpValidateCredential( CredFlags,
                                      NULL,     // No TargetInfo
                                      Credential,
                                      &PassedCredential );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;

    //
    // If the caller is writing a certificate *Session credential,
    //  create a corresponding password *Session credential.
    //
    // A certificate credential can only be used to some servers.  NTLM will
    //  use a password credential for all other servers.  By creating the password
    //  *Session credential, NTLM has a flagged credential telling it to get the
    //  user's password via a handshake with kerberos.

    if ( PassedCredential->Cred.Type == CRED_TYPE_DOMAIN_CERTIFICATE &&
         PassedCredential->WildcardType == WcUniversalSessionWildcard ) {


        //
        // Only create a password credential if it doesn't already exist.
        //

        PasswordCredential = CredpFindCredential(
                                &CredentialSets,
                                &PassedCredential->TargetName,
                                CRED_TYPE_DOMAIN_PASSWORD );

        if ( PasswordCredential == NULL ) {
            CreatePasswordCredToo = TRUE;
            PassedCredential->Cred.Flags |= CRED_FLAGS_PASSWORD_FOR_CERT;
        }
    }


    //
    // Write the credential to the credential set.
    //

    Status = CredpWriteCredential( &CredentialSets,
                                   &PassedCredential,
                                   FALSE,   // Creds are not from persisted file
                                   TRUE,    // Update pin in CSP
                                   TRUE,    // Cred has been prompted for
                                   Flags,
                                   &CredUndo );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }


    //
    // If we decided above to create a corresponding password cred,
    //  do so now.
    //

    if ( CreatePasswordCredToo ) {

        ENCRYPTED_CREDENTIALW NewPasswordCredential;

        //
        // Build the password credential
        //  Mark it the NTLM needs to determine the password for the corresponding cert
        //

        RtlZeroMemory( &NewPasswordCredential, sizeof(NewPasswordCredential) );
        NewPasswordCredential.Cred.Type = CRED_TYPE_DOMAIN_PASSWORD;
        NewPasswordCredential.Cred.TargetName = PassedCredential->TargetName.Buffer;
        NewPasswordCredential.Cred.Persist = CRED_PERSIST_SESSION;
        NewPasswordCredential.Cred.Flags = CRED_FLAGS_PASSWORD_FOR_CERT;

        //
        // Get a marshaled copy of the new credential
        //

        Status = CredpWriteMorphedCredential(
                            &CredentialSets,
                            CREDP_FLAGS_IN_PROCESS, // Allow CRED_FLAGS_PASSWORD_FOR_CERT
                            TRUE,       // Cred has been prompted for
                            NULL,       // No Target info since cred not for this target
                            &NewPasswordCredential,
                            &PasswordCredential );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }


    }

    //
    // Update the password for this user on all credentials.
    //

    CredpUpdatePassword( &CredentialSets,
                         PassedCredential );


    PassedCredential = NULL;
    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {

        //
        // On failure, undo any CredpWriteCredential
        //
        if ( !NT_SUCCESS(Status) && CredUndo != NULL ) {

            CredpUndo( &CredentialSets, CredUndo );
        }

        CredpUnlockAndFlushCredSets( &CredentialSets );
    }
    if ( PassedCredential != NULL ) {
        LsapFreeLsaHeap( PassedCredential );
    }

    if ( CredUndo != NULL ) {
        CredpUndoFree( CredUndo );
    }

    CredpDereferenceCredSets( &CredentialSets );

    return Status;

}

extern "C"
NTSTATUS
CrediRead (
    IN PLUID LogonId,
    IN ULONG CredFlags,
    IN LPWSTR TargetName,
    IN ULONG Type,
    IN ULONG Flags,
    OUT PENCRYPTED_CREDENTIALW *Credential
    )

/*++

Routine Description:

    The CredRead API reads a credential from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    CredFlags - Flags changing the behavior of the routine:
        CREDP_FLAGS_IN_PROCESS - Caller is in-process.  Password data may be returned
        CREDP_FLAGS_USE_MIDL_HEAP - If specified, use MIDL_user_allocate to allocate memory.

        Note: The CredFlags parameter is internal to the LSA process.
            The Flags parameter is external to the process.

    TargetName - Specifies the name of the credential to read.

    Type - Specifies the Type of the credential to find.
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

    Credential - Returns a pointer to the credential.  The returned buffer
        must be freed by calling LsapFreeLsaHeap.
        If CREDP_FLAGS_USE_MIDL_HEAP was specified, use MIDL_user_free.

Return Values:

    STATUS_NOT_FOUND - There is no credential with the specified TargetName.

    STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
        there is no credential set associated with this logon session.
        Network logon sessions do not have an associated credential set.

--*/
{
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = { NULL };
    PCANONICAL_CREDENTIAL TempCredential;
    UNICODE_STRING TargetNameString;
    DWORD TargetNameSize;
    BOOLEAN CritSectLocked = FALSE;

    //
    // Validate the flags
    //

    if ( Flags != 0 ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //

    Status = CredpValidateTargetName( TargetName,
                                      Type,
                                      MightBeUsernameTarget,
                                      NULL,         // Don't know user name
                                      NULL,         // Don't know persist
                                      &TargetNameSize,
                                      NULL,         // Don't care about name type
                                      NULL );       // Don't care about non-wilcarded form of name

    if ( !NT_SUCCESS(Status ) ) {
        goto Cleanup;
    }

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }


    //
    // Find the credential
    //

    TargetNameString.Buffer = TargetName;
    TargetNameString.MaximumLength = (USHORT) TargetNameSize;
    TargetNameString.Length = TargetNameString.MaximumLength - sizeof(WCHAR);

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;

    TempCredential = CredpFindCredential(
                            &CredentialSets,
                            &TargetNameString,
                            Type );

    if ( TempCredential == NULL ) {
        Status = STATUS_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Grab a copy of the credential to return to the caller.
    //

    *Credential = CredpCloneCredential( &CredentialSets, CredFlags, TempCredential );

    if ( *Credential == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }
    CredpDereferenceCredSets( &CredentialSets );

    return Status;

}

extern "C"
VOID
CrediFreeCredentials (
    IN ULONG Count,
    IN PENCRYPTED_CREDENTIALW *Credentials OPTIONAL
    )

/*++

Routine Description:

    This routine frees the buffers allocated by CrediEnumerate or
    CrediReadDomainCredentials.

Arguments:

    Count - Specifies the number of credentials in Credentials.

    Credentials - A pointer to an array of pointers to credentials.

Return Values:

    None.

--*/
{
    ULONG i;

    if ( Credentials != NULL ) {
        for ( i=0; i<Count; i++ ) {
            if ( Credentials[i] != NULL ) {
                MIDL_user_free( Credentials[i] );
            }
        }
        MIDL_user_free( Credentials );
    }
}


extern "C"
NTSTATUS
CrediEnumerate (
    IN PLUID LogonId,
    IN ULONG CredFlags,
    IN LPWSTR Filter,
    IN ULONG Flags,
    OUT PULONG Count,
    OUT PENCRYPTED_CREDENTIALW **Credentials
    )

/*++

Routine Description:

    The CredEnumerate API enumerates the credentials from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    CredFlags - Flags changing the behavior of the routine:
        CREDP_FLAGS_IN_PROCESS - Caller is in-process.  Password data may be returned

        Note: The CredFlags parameter is internal to the LSA process.
            The Flags parameter is external to the process.

    Filter - Specifies a filter for the returned credentials.  Only credentials
        with a TargetName matching the filter will be returned.  The filter specifies
        a name prefix followed by an asterisk.  For instance, the filter "FRED*" will
        return all credentials with a TargetName beginning with the string "FRED".

        If NULL is specified, all credentials will be returned.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

    Count - Returns a count of the number of credentials returned in Credentials.

    Credentials - Returns a pointer to an array of pointers to credentials.
        The returned buffer must be freed by calling CrediFreeCredentials

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        STATUS_NOT_FOUND - There is no credentials matching the specified Filter.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/
{
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = { NULL };
    ULONG Persist;
    PCANONICAL_CREDENTIAL TempCredential;
    PENCRYPTED_CREDENTIALW *TempCredentials = NULL;
    DWORD FilterSize;
    ULONG CredentialCount = 0;
    ULONG CredentialIndex;
    PLIST_ENTRY ListEntry;
    BOOLEAN CritSectLocked = FALSE;

    UNICODE_STRING PassedFilter;
    BOOLEAN Wildcarded = FALSE;

    //
    // Validate the flags
    //

    if ( Flags != 0 ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //

    if ( !CredpValidateString( Filter,
                               max(CRED_MAX_GENERIC_TARGET_NAME_LENGTH, CRED_MAX_DOMAIN_TARGET_NAME_LENGTH),
                               TRUE,   // NULL is OK
                               &FilterSize ) ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CrediEnumerate: Invalid Filter buffer.\n" ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }


    //
    // Canonicalize the filter
    //

    if ( FilterSize != 0 ) {
        PassedFilter.Buffer = Filter;
        PassedFilter.Length = (USHORT)(FilterSize - sizeof(WCHAR));
        PassedFilter.MaximumLength = (USHORT)FilterSize;

        if ( Filter[(PassedFilter.Length-sizeof(WCHAR))/sizeof(WCHAR)] == '*' ) {
            PassedFilter.Length -= sizeof(WCHAR);
            PassedFilter.MaximumLength -= sizeof(WCHAR);
            Wildcarded = TRUE;
        }
    } else {
        RtlInitUnicodeString( &PassedFilter, NULL );
    }



    //
    // Count the number of credentials the match the filter
    //

    CredentialCount = 0;
    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;

    //
    // Walk each credential set
    //

    for ( Persist=CRED_PERSIST_MIN; Persist <= CRED_PERSIST_MAX; Persist++ ) {

        PCREDENTIAL_SET CredentialSet;

        //
        // If the profile has not yet been loaded by this session,
        //  ignore any credentials loaded by another session.
        //

        if ( Persist != CRED_PERSIST_SESSION &&
             !CredentialSets.SessionCredSets->ProfileLoaded ) {
            continue;
        }

        CredentialSet = PersistToCredentialSet( &CredentialSets, Persist );

        for ( ListEntry = CredentialSet->Credentials.Flink ;
              ListEntry != &CredentialSet->Credentials;
              ListEntry = ListEntry->Flink) {

            UNICODE_STRING TempTargetName;


            TempCredential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

            //
            // Ignore unsupported cred types
            //

            if ( CredDisableDomainCreds &&
                 CredpIsDomainCredential( TempCredential->Cred.Type ) ) {

                continue;
            }


            //
            // If wildcarding,
            //  compare the filter to the prefix of the target name.
            //

            TempTargetName = TempCredential->TargetName;
            if ( Wildcarded && TempTargetName.Length > PassedFilter.Length ) {

                TempTargetName.Length = PassedFilter.Length;
                TempTargetName.MaximumLength = PassedFilter.MaximumLength;
            }

            if ( FilterSize == 0 ||
                 RtlEqualUnicodeString( &PassedFilter,
                                        &TempTargetName,
                                        TRUE ) ) {
                CredentialCount++;
                TempCredential->ReturnMe = TRUE;
            } else {
                TempCredential->ReturnMe = FALSE;
            }

        }
    }

    if ( CredentialCount == 0 ) {
        Status = STATUS_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Allocate a buffer to return the credentials in
    //

    TempCredentials = (PENCRYPTED_CREDENTIALW *) MIDL_user_allocate( CredentialCount * sizeof(PENCRYPTED_CREDENTIALW) );

    if ( TempCredentials == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory( TempCredentials, CredentialCount * sizeof(PENCRYPTED_CREDENTIALW) );


    //
    // Grab a copy of each of the credentials to return to the caller.
    //

    CredentialIndex = 0;
    for ( Persist=CRED_PERSIST_MIN; Persist <= CRED_PERSIST_MAX; Persist++ ) {

        PCREDENTIAL_SET CredentialSet;

        //
        // If the profile has not yet been loaded by this session,
        //  ignore any credentials loaded by another session.
        //

        if ( Persist != CRED_PERSIST_SESSION &&
             !CredentialSets.SessionCredSets->ProfileLoaded ) {
            continue;
        }

        CredentialSet = PersistToCredentialSet( &CredentialSets, Persist );

        for ( ListEntry = CredentialSet->Credentials.Flink ;
              ListEntry != &CredentialSet->Credentials;
              ListEntry = ListEntry->Flink) {

            TempCredential = CONTAINING_RECORD( ListEntry, CANONICAL_CREDENTIAL, Next );

            //
            // Ignore unsupported cred types
            //

            if ( CredDisableDomainCreds &&
                 CredpIsDomainCredential( TempCredential->Cred.Type ) ) {

                continue;
            }

            if ( TempCredential->ReturnMe ) {
                TempCredentials[CredentialIndex] =
                    CredpCloneCredential( &CredentialSets,
                                          CredFlags | CREDP_FLAGS_USE_MIDL_HEAP,
                                          TempCredential );

                if ( TempCredentials[CredentialIndex] == NULL ) {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

                CredentialIndex ++;
            }

        }

    }

    *Count = CredentialCount;
    *Credentials = TempCredentials;
    TempCredentials = NULL;
    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {
        CredpUnlockAndFlushCredSets( &CredentialSets );
    }
    if ( TempCredentials != NULL ) {
        CrediFreeCredentials( CredentialCount, TempCredentials );
    }

    CredpDereferenceCredSets( &CredentialSets );

    return Status;

}

extern "C"
NTSTATUS
CrediWriteDomainCredentials (
    IN PLUID LogonId,
    IN ULONG CredFlags,
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN PENCRYPTED_CREDENTIALW Credential,
    IN ULONG Flags
    )

/*++

Routine Description:

    The CredWriteDomainCredentials API writes a new domain
    credential to the user's credential set.  The new credential is
    associated with the logon session of the current token.  The token
    must not have the user's SID disabled.

    CredWriteDomainCredentials differs from CredWrite in that it handles
    the idiosyncrasies of domain (CRED_TYPE_DOMAIN_*)
    credentials.  Domain credentials contain more than one target field.

    At least one of the naming parameters must be specified: NetbiosServerName,
    DnsServerName, NetbiosDomainName, DnsDomainName or DnsTreeName.

Arguments:

    LogonId - LogonId of the session to associate the credential with.

    CredFlags - Flags changing the behavior of the routine:
        CREDP_FLAGS_USER_ENCRYPTED_PASSWORD - CredentialBlob data is passed in protected via CredpEncodeCredential.
            If neither set, CredentialBlob data is passed in protected via LsapProtectMemory.

        Note: The CredFlags parameter is internal to the LSA process.
            The Flags parameter is external to the process.

    TargetInfo - Specifies the target information identifying the target server.

    Credential - Specifies the credential to be written.

    Flags - Specifies flags to control the operation of the API.
        The following flags are defined:

        CRED_PRESERVE_CREDENTIAL_BLOB: The credential blob should be preserved from the
            already existing credential with the same credential name and credential type.

Return Values:

    The following status codes may be returned:

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

        STATUS_INVALID_PARAMETER - Certain fields may not be changed in an
            existing credential.  If such a field does not match the value
            specified in the existing credential, this error is returned.

        STATUS_INVALID_PARAMETER - None of the naming parameters were specified
            or the credential specified did not have the Type field set to
            CRED_TYPE_DOMAIN_PASSWORD, CRED_TYPE_DOMAIN_CERTIFICATE or CRED_TYPE_DOMAIN_VISIBLE_PASSWORD.

--*/

{
    NTSTATUS Status;
    CREDENTIAL_SETS CredentialSets = {NULL};
    PCRED_WRITE_UNDO CredUndo = NULL;

    PCANONICAL_CREDENTIAL PassedCredential = NULL;
    PCANONICAL_TARGET_INFO CanonicalTargetInfo = NULL;
    ULONG AliasIndex;
    BOOLEAN CritSectLocked = FALSE;

    ULONG CredentialCount = 0;
    PCANONICAL_CREDENTIAL BestCredentials[CRED_TYPE_MAXIMUM];
    ULONG CredentialIndex;

    //
    // Validate the flags
    //
#define CREDP_WRITE_DOM_VALID_FLAGS CRED_PRESERVE_CREDENTIAL_BLOB

    if ( (Flags & ~CREDP_WRITE_DOM_VALID_FLAGS) != 0 ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Cleanup;
    }

    //
    // Validate the TargetInfo
    //

    Status = CredpValidateTargetInfo( TargetInfo,
                                      &CanonicalTargetInfo );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Validate the passed in credential
    //

    Status = CredpValidateCredential( CredFlags,
                                      CanonicalTargetInfo,
                                      Credential,
                                      &PassedCredential );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    if ( !CredpIsDomainCredential(PassedCredential->Cred.Type) ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CrediWriteDomainCredential: Only allow for domain credentials.\n" ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Get the credential set.
    //

    Status = CredpReferenceCredSets( LogonId, &CredentialSets );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    CredpLockCredSets( &CredentialSets );
    CritSectLocked = TRUE;


    //
    // Write the credential to the credential set.
    //

    Status = CredpWriteCredential( &CredentialSets,
                                   &PassedCredential,
                                   FALSE,   // Creds are not from persisted file
                                   TRUE,    // Update pin in CSP
                                   TRUE,    // Cred has been prompted for
                                   Flags,
                                   &CredUndo );


    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Ensure the written credential is the best credential for this target info
    //

    Status = CredpFindBestCredentials( LogonId,
                                       CredFlags,
                                       &CredentialSets,
                                       CanonicalTargetInfo,
                                       BestCredentials,
                                       &CredentialCount );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    for ( CredentialIndex = 0; CredentialIndex<CredentialCount; CredentialIndex++ ) {

        if ( PassedCredential == BestCredentials[CredentialIndex] ) {
            break;
        }

    }

    if ( CredentialIndex >= CredentialCount ) {
        DebugLog(( DEB_TRACE_CRED,
                   "CrediWriteDomainCredential: Credential isn't best credential for target info.\n" ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Update the password for this user on all credentials.
    //

    CredpUpdatePassword( &CredentialSets,
                         PassedCredential );


    PassedCredential = NULL;
    Status = STATUS_SUCCESS;

    //
    // Cleanup
    //
Cleanup:
    if ( CritSectLocked ) {

        //
        // On failure, undo any CredpWriteCredential
        //
        if ( !NT_SUCCESS(Status) && CredUndo != NULL ) {

            CredpUndo( &CredentialSets, CredUndo );
        }

        CredpUnlockAndFlushCredSets( &CredentialSets );
    }
    if ( PassedCredential != NULL ) {
        LsapFreeLsaHeap( PassedCredential );
    }

    if ( CredUndo != NULL ) {
        CredpUndoFree( CredUndo );
    }

    if ( CanonicalTargetInfo != NULL ) {
        LsapFreeLsaHeap( CanonicalTargetInfo );
    }

    CredpDereferenceCredSets( &CredentialSets );

    return Status;
}


extern "C"
NTSTATUS
CrediReadDomainCredentials (
    IN PLUID LogonId,
    IN ULONG CredFlags,
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN ULONG Flags,
    OUT PULONG Count,
    OUT PENCRYPTED_CREDENTIALW **Credentials
    )

/*++

Routine Description:

    The CredReadDomainCredentials API reads the domain credentials from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

    CredReadDomainCredentials differs from CredRead in that it handles the
    idi